{"meta":{"title":"royhuang's blog","subtitle":"hello world","description":"tech & life","author":"Wanghui Huang","url":"http://example.com","root":"/"},"pages":[{"title":"[404]","date":"2021-11-24T11:41:16.226Z","updated":"2021-11-24T11:41:16.226Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"Hi there ğŸ‘‹","date":"2021-11-24T11:42:21.093Z","updated":"2021-11-24T11:42:21.093Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"I am Wanghui Huang (royHuang). ğŸ”­ I am studying for a masterâ€™s degree in Chongqing University and will graduate in July, 2022. Whatâ€™s more, I will officially join Tencent next year. ğŸ“« If you want know me more : www.hwh.zone, this is my personal blog. ğŸ’¬ Ask me about deep learning(object tracking) , C++, Java and my projects on &#x68;&#x77;&#x68;&#x31;&#x39;&#x39;&#x36;&#48;&#49;&#64;&#113;&#113;&#46;&#x63;&#x6f;&#x6d;. âš¡ Fun fact: this is a less funny boy."},{"title":"tags","date":"2021-11-25T05:45:14.000Z","updated":"2021-11-25T05:47:43.270Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-11-25T05:45:57.000Z","updated":"2021-11-25T05:47:33.936Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"XXX","slug":"å·¥ä½œä¸€_ç®—æ³•ç¬”è®°","date":"2021-11-25T03:34:30.479Z","updated":"2021-11-25T03:49:00.735Z","comments":true,"path":"2021/11/25/å·¥ä½œä¸€_ç®—æ³•ç¬”è®°/","link":"","permalink":"http://example.com/2021/11/25/%E5%B7%A5%E4%BD%9C%E4%B8%80_%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","excerpt":"","text":"å‰è¨€æ‰¾å·¥ä½œè®°å½•çš„åˆ·é¢˜ç¬”è®°ã€‚ TO DO è¡¥å……SQLç®—æ³•é¢˜ è™¾çš®ä¸“åœº1. æ ˆå®ç°é˜Ÿåˆ— https://leetcode-cn.com/problems/implement-queue-using-stacks/ æ€è·¯ è®¾ç½®ä¸¤ä¸ªæ ˆS1ã€S2 ï¼ŒS1å§‹ç»ˆç”¨æ¥å½“åšé˜Ÿåˆ—å­˜å…ƒç´ ï¼ŒS2ç”¨ä½œä¸­è½¬æ ˆã€‚å½“éœ€è¦æ“ä½œï¼ˆå–ï¼Œåˆ é™¤ï¼‰S1ä¸­é˜Ÿå¤´å…ƒç´ ï¼Œå°±pop S1ä¸­å…ƒç´ åˆ°S2ä¸­ï¼Œæ“ä½œå®Œæˆåå†pop S2ä¸­å…ƒç´ å›æ¥S1ã€‚ ä»£ç  ä»£ç æ˜“é”™ç‚¹1ã€2è§ä¸‹ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.*;class MyQueue &#123; /** Initialize your data structure here. */ Stack&lt;Integer&gt; stack1 ; Stack&lt;Integer&gt; stack2 ; public MyQueue() &#123; stack1 = new Stack&lt;Integer&gt;(); stack2 = new Stack&lt;Integer&gt;(); &#125; /** Push element x to the back of queue. */ public void push(int x) &#123; stack1.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; if(stack2.isEmpty()) &#123; // ã€æ˜“é”™ç‚¹1ã€‘åœ¨è¿™é‡Œä½¿ç”¨ for(int i=0 ; i&lt;stack1.size();i++ ) åˆ¤æ–­ï¼Œ // ä½†æ˜¯stack1.size()æ˜¯å˜é‡ï¼Œéšç€å¾ªç¯ä¼šä¸æ–­å‡å°‘ã€‚ while(!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; &#125; int res = stack2.pop(); /* // ã€æ˜“é”™ç‚¹2ã€‘ä¸ç”¨å‚»å‚»å†å€’å›å»ï¼Œæ­¤æ—¶stack2ï¼Œä»æ ˆé¡¶åˆ°æ ˆå°¾å°±æ˜¯é˜Ÿåˆ—çš„é¡ºåº // stack2ä¸ºç©ºå†å€’å›å»å°±è¡Œ while(!stack2.isEmpty()) &#123; stack1.push(stack2.pop()); &#125; */ return res; &#125; /** Get the front element. */ public int peek() &#123; if(stack2.isEmpty()) &#123; while(!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; &#125; int res = stack2.peek(); /* // ã€æ˜“é”™ç‚¹2ã€‘ä¸ç”¨å‚»å‚»å†å€’å›å»ï¼Œæ­¤æ—¶stack2ï¼Œä»æ ˆé¡¶åˆ°æ ˆå°¾å°±æ˜¯é˜Ÿåˆ—çš„é¡ºåº while(!stack2.isEmpty()) &#123; stack1.push(stack2.pop()); &#125; */ return res; &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; return (stack1.isEmpty() &amp;&amp; stack2.isEmpty()) ? true : false; &#125;&#125; ä»£ç ï¼ˆè¿›é˜¶ï¼šç”¨è‡ªå·±å®ç°çš„æ ˆï¼‰ æ³¨æ„ï¼šæ³›å‹æ•°ç»„ä¸èƒ½ç›´æ¥åˆå§‹åŒ–ï¼Œè€Œä¸”å…ˆå®šä¹‰ä¸€ä¸ªObjectæ•°ç»„å†å¼ºåˆ¶è½¬æ¢ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class StackDemo&lt;E&gt; &#123; /** åº•å±‚ä½¿ç”¨ä¸€ä¸ªæ³›å‹æ•°ç»„åšå­˜å‚¨ */ private E[] items; private int top; private int capacity; public StackDemo() &#123; //ä¼šè°ƒç”¨ä¸‹é¢ä¸€ä¸ªæ„é€ æ–¹æ³•,åˆå§‹åŒ–ä¸€ä¸ªé•¿åº¦ä¸º10çš„æ•°ç»„ this(10); &#125; public StackDemo(int i)&#123; this.capacity=i; // ã€æ˜“é”™3ã€‘æ³›å‹æ•°ç»„ä¸èƒ½ç›´æ¥åˆå§‹åŒ–ï¼Œè€Œä¸”å…ˆå®šä¹‰ä¸€ä¸ªObjectæ•°ç»„å†å¼ºåˆ¶è½¬æ¢ã€‚ this.items=(E[])new Object [this.capacity]; this.top=0; &#125; /** * å…¥æ ˆæ“ä½œ */ public void push(E e) throws Exception&#123; if(top!=capacity)&#123; items[top++]=e; //åˆ¤æ–­æ•°æ®æ˜¯ä¸æ˜¯å·²ç»æ»¡äº†,çœ‹éœ€ä¸éœ€è¦æ‰©å®¹ resize(); &#125;else&#123; throw new Exception(); &#125; &#125; /** * å‡ºæ ˆæ“ä½œ */ public E pop() throws Exception&#123; if(top==0)&#123; throw new Exception(); &#125;else&#123; E ret=items[--top]; items[top]=null; return ret; &#125; &#125; /** * resizeæ“ä½œ,æŠŠæ•°ç»„æ‰©å¤§ä¸¤å€ */ public void resize()&#123; // å¦‚æœtopå’Œcapacityç›¸ç­‰çš„è¯,è¯´æ˜æ»¡äº† if(top==capacity)&#123; // æŠŠèŒƒå›´æ‰©å¤§2å€ this.capacity = this.capacity*2; // newä¸€ä¸ªæ–°æ•°ç»„ E[] newItems = (E[])new Object [this.capacity]; // è½¬ç§»è€æ•°æ® System.arraycopy(items,0,newItems,0,items.length); // æŠŠæ–°çš„æ•°ç»„å½“æˆåº•å±‚çš„å­˜å‚¨ this.items = newItems; &#125; &#125; public static void main(String[] args) &#123; StackDemo&lt;String&gt; stack = new StackDemo&lt;&gt;(2); try &#123; stack.push(&quot;first&quot;); stack.push(&quot;second&quot;); stack.push(&quot;third&quot;); stack.push(&quot;four&quot;); String pop = stack.pop(); System.out.println(pop); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2. LRUCachehashmap + åŒå‘çš„linklistï¼Œç•¥ã€‚ 3. ç›¸äº¤é“¾è¡¨æ³¨æ„ä¸‹é¢ä¸¤ç‚¹ï¼š è®¡ç®—å·®å€¼è¦ç”¨ç»å¯¹å€¼ åˆ¤æ–­ç›¸ç­‰ï¼Œæ¯”è¾ƒçš„æ˜¯èŠ‚ç‚¹ï¼Œæ‰€ä»¥è¿”å›ç¬¬ä¸€ä¸ªç›¸ç­‰çš„èŠ‚ç‚¹å°±å¯ä»¥äº† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode pA = headA ; ListNode pB = headB ; // è®¡ç®—Aã€Bé“¾è¡¨é•¿åº¦ä¹‹å·® int lenA = 0; int lenB = 0 ; int d = 0; while(pA != null) &#123; pA = pA.next; lenA++; &#125; while(pB != null) &#123; pB = pB.next; lenB++; &#125; // A1ï¼šç»å¯¹å€¼ d = Math.abs(lenA-lenB); // æ›´é•¿çš„å…ˆèµ°dæ­¥ if(lenA&lt;lenB) &#123; while(d--&gt;0) &#123; headB = headB.next; &#125; &#125; if(lenA&gt;lenB) &#123; while(d--&gt;0) &#123; headA = headA.next; &#125; &#125; // å¼€å§‹ä¸€èµ·èµ°å¼€å§‹åˆ¤æ–­ while(headA != null) &#123; // A2 : è¿”å›ç¬¬ä¸€ä¸ªç›¸ç­‰çš„èŠ‚ç‚¹ if(headA == headB) return headA; headA = headA.next; headB = headB.next; &#125; return null; &#125;&#125; 4. æœ‰åºé“¾è¡¨åˆå¹¶æ²¡å•¥å¥½è¯´çš„ï¼Œè®°ä½å°±è¡Œã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; // 1. åˆ›å»ºè™šæ‹ŸèŠ‚ç‚¹head,tail ï¼Œp1,p2åˆå§‹æŒ‡é’ˆåˆ†åˆ«æŒ‡å‘l1ã€l2 // 2. æ¯”è¾ƒp1ã€p2æŒ‡é’ˆæ‰€æŒ‡çš„å€¼å¤§å°,æ›´å°çš„ç”¨tailæŒ‡å‘ // 3. æ›´æ–°p1æˆ–p2æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ // 4. æœ€åä¸²èµ·æ¥å‰©ä¸‹æœªæ¯”è¾ƒçš„èŠ‚ç‚¹ ListNode head = new ListNode() ; ListNode tail = head; ListNode p1 = l1 , p2 = l2; while(p1 != null &amp;&amp; p2 != null) &#123; if(p1.val &lt; p2.val) &#123; tail.next = p1; tail = p1; p1 = p1.next; &#125; else // è¿™é‡Œä¸èƒ½ç”¨ifåˆ¤æ–­ï¼Œå› ä¸ºä¸Šä¸€ä¸ªifä¼šæƒ³ä¿®æ”¹è¿™ä¸ªifçš„åˆ¤æ–­æ¡ä»¶ &#123; tail.next = p2; tail = p2; p2 = p2.next; &#125; &#125; if(p1 == null) &#123; while(p2 != null) &#123; tail.next = p2; tail = p2; p2 = p2.next ; &#125; &#125; if(p2 == null) &#123; while(p1 != null) &#123; tail.next = p1; tail = p1; p1 = p1.next ; &#125; &#125; return head.next; &#125;&#125; 5. åè½¬é“¾è¡¨æ³¨æ„ä¸‹é¢ï¼Œå¯¹è±¡å¼•ç”¨ä¸æ˜¯å¯¹è±¡å¤åˆ¶ï¼ˆcloneï¼‰ï¼ï¼ 123456789101112131415161718192021222324252627class Solution &#123; public ListNode reverseList(ListNode head) &#123; // 1. è®°å½•ä¸¤ä¸ªæŒ‡é’ˆp,q ï¼Œ åˆå§‹åˆ†åˆ«æŒ‡å‘é“¾è¡¨ç¬¬ä¸€ä¸ªï¼Œç¬¬äºŒä¸ªèŠ‚ç‚¹ // 2. p-&gt;q è½¬æ¢ä¸º p&lt;-q // 3. æ›´æ–°pï¼ŒqåŒæ—¶å¾€åç§»åŠ¨ï¼Œç›´è‡³qä¸ºnull // 4. æœ€åå¤„ç†ä¸‹head-&gt;next = null if(head == null) return head; ListNode p = head , q = head.next; ListNode tmp = null ; while(q != null) &#123; // ã€æ˜“é”™ã€‘ç”¨tmpè®°å½•qçš„ä½ç½®ï¼Œåœ¨q.next = pï¼Œæ‰§è¡Œåå°è¯•å†å»è·å–åŸå…ˆq.next // æ­¤æ—¶tmp, q éƒ½æ˜¯æŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡ï¼Œqæ“ä½œå¯¹è±¡æ”¹å˜nextæŒ‡å‘åï¼Œtmpå¯¹åº”å¯¹è±¡nextä¹Ÿè¢«æ”¹å˜äº† // çœŸè¦ç”¨tmpè®°å½•ä¹‹å‰çŠ¶æ€çš„qï¼Œåº”è¯¥æ˜¯ä½¿ç”¨ã€é‡å†™cloneæ–¹æ³•ã€‘ tmp = q.next; q.next = p; p = q; q = tmp; &#125; head.next = null; return p; &#125;&#125; 6. ä¸¤æ•°ä¹‹å’Œæ³¨æ„ä¸¤ç‚¹ï¼š hashmapçš„ containsKeyæ–¹æ³• è¿”å›çš„æ˜¯æ•°ç»„ä¸‹æ ‡ 12345678910111213141516171819202122232425import java.util.*;class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; // hashmapå°†æ•°ç»„æ¯ä¸ªå€¼ä½œä¸ºkeyå­˜å…¥ HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for (int i = 0 ; i &lt; nums.length ; i++) &#123; map.put(nums[i],i); &#125; int[] res = new int[2]; for (int i = 0 ; i &lt; nums.length ; i++) &#123; if(map.containsKey(target-nums[i]) &amp;&amp; map.get(target-nums[i]) != i ) &#123; res[0] = i; res[1] = map.get(target-nums[i]); return res; &#125; &#125; return res; &#125;&#125; 7. kä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨è¿˜æ˜¯è¾¹ç•Œæ²¡æœ‰å¤„ç†å¥½ï¼Œç›´æ¥çœ‹åŸæ¥çš„è§£æ³•å§ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// æ€è·¯// éå†é“¾è¡¨æ‰¾åˆ°æ¯æ¬¡åè½¬çš„first,end è¿›è¡Œç¿»è½¬// *ç‰¹åˆ«çš„ï¼šç¬¬ä¸€æ¬¡ç¿»è½¬endæ˜¯è¿”å›çš„å¤´ç»“ç‚¹public ListNode reverseKGroup (ListNode head, int k) &#123; ListNode pre = null; ListNode f = head; ListNode e = head; int count = 1; // è®°å½•ç¿»è½¬åé“¾è¡¨ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ ListNode firstNode = e; while (e!=null) &#123; // æ‰¾åˆ°ç¿»è½¬æ®µçš„å°¾èŠ‚ç‚¹e if(count % k == 0 ) &#123; // ç¬¬ä¸€æ¬¡ç¿»è½¬ if(count == k) firstNode = e; // ç¿»è½¬ reverse(pre,f,e); // *æ›´æ–°:æ³¨æ„æ­¤æ—¶æ®µå°¾éƒ¨æ˜¯f // *å°¾éƒ¨eç§»åŠ¨äº†ï¼Œè¦count+1 pre = f; f = e = f.next; &#125; else e = e.next; // æ— è®ºå“ªç§æƒ…å†µéƒ½è¦count++ï¼Œæ‰€ä»¥ç§»åˆ°è¿™å„¿ count++; &#125; return firstNode; &#125; // æŒ‡å®šé“¾è¡¨æ®µç¿»è½¬ // å…ˆå°†[first-end] èŠ‚ç‚¹åè½¬ï¼Œå†ä¿®æ”¹åè½¬åçš„é¦–å°¾èŠ‚ç‚¹æŒ‡å‘ public ListNode reverse(ListNode pre,ListNode first,ListNode end) &#123; ListNode p = null; ListNode q = first; ListNode q_next = null; // ä¸´æ—¶èŠ‚ç‚¹å­˜å‚¨q.next while (p !=end ) // ä¿®æ”¹ï¼šåˆ°è¾¾æœ«å°¾ç»ˆæ­¢æ¡ä»¶ &#123; q_next = q.next; q.next = p; p = q; q = q_next; &#125; // ä¿®æ”¹ï¼šå¤„ç†åè½¬åçš„é¦–å°¾èŠ‚ç‚¹æŒ‡å‘ first.next = q; // ã€è¾¹ç•Œæƒ…å†µã€‘ï¼šä»å¤´èŠ‚ç‚¹å¼€å§‹åè½¬ if(pre!=null) pre.next=end; // *è¿”å›ç¿»è½¬åé“¾è¡¨é¦–èŠ‚ç‚¹end return end; &#125; 8. äºŒå‰æ ‘æœ€è¿‘å…¬å…±ç¥–å…ˆ å‚è€ƒï¼šhttps://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/ è¿™ä¸ªå…³é”®æ˜¯æ˜ç™½ï¼š ååºé€’å½’æŸ¥æ‰¾èŠ‚ç‚¹pï¼Œq ï¼Œå¶å­èŠ‚ç‚¹ï¼Œè¿™éƒ¨åˆ†å­æ ‘å°±è¿”å›èŠ‚ç‚¹ï¼ˆp,q,nullï¼‰ ç”±äºæ˜¯ååºé€’å½’ï¼Œæ¯æ¬¡éƒ½æ¯”è¾ƒå½“å‰rootå·¦å³å­æ ‘çš„è¿”å›å€¼ å·¦å³å­æ ‘éƒ½æœ‰è¿”å›å€¼ï¼Œè¯´æ˜rootå°±æ˜¯å½“å‰æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œè¿”å› å¦‚æœåªæœ‰å·¦æˆ–å³å­æ ‘ï¼ˆå‡è®¾å·¦ï¼‰æœ‰è¿”å›å€¼ï¼ˆä¸ä¸ºnullï¼‰ï¼Œè¿”å›å·¦å­æ ‘è¿”å›çš„èŠ‚ç‚¹å½“åšæœ€å°å…¬å…±èŠ‚ç‚¹ï¼Œç»§ç»­å¾€ä¸Šé€’å½’æ¯”è¾ƒå·¦å³å­æ ‘ï¼Œçœ‹æ˜¯å¦æ›´æ–°è¿™ä¸ªæœ€å°å…¬å…±èŠ‚ç‚¹ï¼ˆä¸€ç›´æ²¡æœ‰æ›´æ–°ï¼Œè¯´æ˜å°±æ˜¯pæ˜¯qçš„ç¥–å…ˆè¿™ç§æƒ…å†µï¼‰ 1234567891011121314151617181920212223242526272829class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; // å¶å­èŠ‚ç‚¹è¿”å› ï¼Œ å½“å‰å·¦ã€å³å­æ ‘æ‰¾åˆ°äº†pæˆ–qä¹Ÿè¿”å› if(root == null || root == p || root == q ) return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); // å¦‚æœå½“å‰å·¦å³å­æ ‘éƒ½è¿”å›äº†èŠ‚ç‚¹ï¼ˆæ‰¾åˆ°äº† p,q ä¸”å¼‚ä¾§ï¼‰ï¼Œè¿”å›root // å› ä¸ºæ˜¯ä»åº•å±‚å¾€ä¸Šï¼Œæ‰€ä»¥æ­¤æ—¶rootä¸€å®šæ˜¯æœ€è¿‘çš„ç¥–å…ˆ if(left != null &amp;&amp; right != null) return root; // å·¦å­æ ‘ä¸ä¸ºnullï¼Œä½†å³å­æ ‘ä¸ºnullï¼ŒæŠŠå·¦å­æ ‘è¿”å›çš„èŠ‚ç‚¹å½“æˆä»¥rootä¸ºæ ¹çš„å­æ ‘ç»“æœå¾€ä¸Šè¿”å› // è¿™æ ·ä¿è¯äº†ï¼šï¼ˆ1ï¼‰æ‰¾åˆ°äº†pï¼Œqå­æ ‘çš„ç»“æœï¼ˆèŠ‚ç‚¹ï¼‰å¯ä»¥ä¸€ç›´å¾€ä¸Šè¿”å› ï¼ˆ2ï¼‰ä¹Ÿä¿è¯äº†pæ˜¯qçš„ç¥–å…ˆèŠ‚ç‚¹ï¼Œ // ä½†æ˜¯éå†åˆ°på°±å¾€ä¸Šè¿”å›pï¼Œä¸ç”¨å»å†æ‰¾åˆ°q if(left != null &amp;&amp; right == null) return left; // åŒä¸Š if(right != null &amp;&amp; left == null) return right; // å·¦å³å­æ ‘éƒ½ä¸ºnullï¼Œä¸”rootä¸ä¸ºpï¼Œq return null; &#125;&#125; 9. åˆ é™¤é“¾è¡¨é‡å¤å…ƒç´ æ³¨æ„ä¸ä¿ç•™ç¬¬ä¸€ä¸ªé‡å¤å…ƒç´ ï¼Œè€Œæ˜¯å…¨éƒ¨åˆ é™¤ã€‚ 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; // 1. è®¾ç½®èŠ‚ç‚¹pï¼Œqåˆå§‹éƒ½æŒ‡å‘head // 2. qå¾€åéå†æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸é‡å¤çš„èŠ‚ç‚¹ // 3. è®¾ç½®p-&gt;qï¼Œp=q , é‡å¤2ï¼Œç›´è‡³qä¸ºnull // è¿™çš„qä¸è¦æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ¯”è¾ƒå¥½ ListNode pre = null , p = head ,q = head ; while(q != null) &#123; if(q.next == null) return head; if(p.val == q.next.val) &#123; // æ‰¾åˆ°ä¸é‡å¤çš„å…ƒç´  while(q.next != null &amp;&amp; p.val == q.next.val) q = q.next; if(pre == null) // è€ƒè™‘pre==nullçš„æƒ…å†µ head = q.next; else pre.next = q.next; &#125; else &#123; pre = p; // åˆ é™¤é‡å¤å…ƒç´ çš„æ—¶å€™æ˜¯ä¸ç”¨æ›´æ–°pre &#125; p = q = q.next; &#125; return head; &#125;&#125; 10. æœ€å¤§æ•°å…³é”®åœ¨äºæ€ä¹ˆæ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œjavaä¸­è‡ªå¸¦çš„ compareToå¯ä»¥æ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²aï¼Œbï¼š å…ˆæ¯”è¾ƒå­—ç¬¦ä¸²çš„é¦–å­—ç¬¦ä¸²çš„ASCIIç ï¼Œå¦‚æœç›¸åŒå†æ¯”è¾ƒä¸‹ä¸€ä¸ª é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æ¯”è¾ƒa+b ä¸ b+aæ¥ç¡®å®šè°åº”è¯¥åœ¨å‰é¢ã€‚å…¶å®ƒåº”è¯¥æ³¨æ„çš„åœ°æ–¹ï¼š StringBuilder å¸¸ç”¨çš„ append ã€charAtã€toStringæ–¹æ³•è¦è®°ä½ Arrays.sort é«˜çº§å‡½æ•°ç”¨æ³•æ€ä¹ˆå†™è¦è®°ä½ Arrays.sort(æ•°ç»„,(å‚æ•°..) -&gt; &#123; return æ¯”è¾ƒçš„é€»è¾‘ &#125;) 123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;class Solution &#123; public String largestNumber(int[] nums) &#123; String[] stringNums = new String[nums.length]; for(int i = 0 ; i &lt; nums.length; i++) &#123; stringNums[i] = String.valueOf(nums[i]); &#125; // è¦å¯¹JAVAçš„lambdaç†Ÿæ‚‰ Arrays.sort ( // æ•°ç»„,(å‚æ•°..) -&gt; &#123; return æ¯”è¾ƒçš„é€»è¾‘ &#125; // è¿”å›å€¼&gt;0 ï¼Œåˆ™bå’Œaäº’æ¢ stringNums,(a,b) -&gt; &#123; return (b+a).compareTo(a+b); &#125; ); StringBuilder sb = new StringBuilder(); for(int i = 0 ; i &lt; nums.length; i++) &#123; sb.append(stringNums[i]); &#125; // toString() å¯ä»¥å°†sbè½¬æ¢ä¸ºStringå­—ç¬¦ä¸² if(sb.charAt(0) == &#x27;0&#x27;) return new String(&quot;0&quot;); // æˆ–è€…ç›´æ¥è¿”å›:&quot;0&quot; else return sb.toString(); &#125;&#125; 11. äºŒåˆ†æŸ¥æ‰¾æ³¨æ„ï¼šè¾¹ç•Œæ¡ä»¶æ˜¯ &lt;= ä¸æ˜¯&lt; ã€‚ 1234567891011121314151617181920212223class Solution &#123; public int search(int[] nums, int target) &#123; int len = nums.length; int s = 0, e = len-1; while(s &lt;= e ) // è¿™é‡Œæ˜¯&lt;= , ä¸æ˜¯&lt; &#123; int mid = (s+e)/2; if(target == nums[mid]) return mid; else if(target &gt; nums[mid]) &#123; s = mid+1; &#125; else &#123; e = mid-1; &#125; &#125; return -1; &#125;&#125; 12. æœ€é•¿ä¸é‡å¤å­ä¸²ç»´æŒä¸€ä¸ªæ»‘åŠ¨çª—å£ï¼Œrigthæ— è®ºå¦‚ä½•éƒ½++ ï¼› left å½“æ»‘åŠ¨çª—å£åŠ å…¥äº†é‡å¤çš„å­—ç¬¦ä¸²å°±æ›´æ–°ä¸ºleft=é‡å¤çš„å­—ç¬¦ä¸²ä¸‹æ ‡+1ã€‚ æ³¨æ„ä»¥ä¸‹ä¸¤ç‚¹ï¼š æ­¤é¢˜è¿˜å¯ä»¥ç”¨HashMap&lt;å­—ç¬¦ï¼Œå­—ç¬¦ä¸‹æ ‡&gt;è®°å½•çª—å£çš„æ‰€æœ‰å€¼ï¼Œæ¯æ¬¡éƒ½åŠ å…¥ä¸€ä¸ªå­—ç¬¦ä¸²éƒ½åˆ¤æ–­æ˜¯å¦åœ¨hashmapä¸­ã€‚ map.get&lt;æ–°åŠ å…¥å­—ç¬¦çš„ä¸‹æ ‡&gt; left ï¼Œè¯´æ˜çª—å£å†…æœ‰é‡å¤ï¼Œæ›´æ–°left = map.get&lt;æ–°åŠ å…¥å­—ç¬¦çš„ä¸‹æ ‡&gt; ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution&#123; public int lengthOfLongestSubstring(String s) &#123; // 1. è®¾ç½®æŒ‡é’ˆleft, rigth åˆ†åˆ«åœ¨æŒ‡å‘æ»‘åŠ¨çª—å£çš„å·¦å³, maxLen è®°å½•çª—å£æœ€å¤§å€¼ï¼Œlenè®°å½•é•¿åº¦ // 2. æ¯æ¬¡rigthå‘å³ç§»åŠ¨ï¼Œåˆ¤æ–­å½“å‰rightæŒ‡å‘çš„å­—ç¬¦æ˜¯å¦å‡ºç°åœ¨çª—å£å†… // 1ï¼‰ å¦‚æœä¸å‡ºç°ï¼Œåˆ™len+1ï¼ŒåŒæ—¶åˆ¤æ–­æ˜¯å¦æ›´æ–°maxLen // 2ï¼‰ å¦‚æœå‡ºç°ï¼Œåˆ™leftæ›´æ–°ä¸ºçª—å£å†…å‡ºç°é‡å¤å­—ç¬¦ä¸²çš„ä¸‹ä¸€ä¸ªä½ç½® // 3. é‡å¤2ï¼Œç›´è‡³rigth&gt;=å­—ç¬¦ä¸²æœ€å¤§é•¿åº¦ int left = 0 , right = 0; int len = 1 , maxLen = 1; if(s.length()==0) return 0 ; while(right &lt; s.length()-1) &#123; int idx = isExist(s,s.charAt(right+1),left,right); right++; if(idx == -1) // ä¸å­˜åœ¨ &#123; len++; maxLen = len&gt;maxLen? len:maxLen; &#125; else &#123; left = idx+1; len = right-left+1; &#125; &#125; return maxLen; &#125; public int isExist(String s ,char c, int left , int right) &#123; for(int i = left ; i &lt;= right ; i++) &#123; if(s.charAt(i) == c ) return i; &#125; return -1; &#125;&#125; ä¼˜åŒ–åçš„æ–¹æ³•ï¼š 1234567891011121314151617class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s.length()==0) return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int max = 0; int left = 0; for(int i = 0; i &lt; s.length(); i ++)&#123; if(map.containsKey(s.charAt(i)))&#123; left = Math.max(left,map.get(s.charAt(i)) + 1); &#125; map.put(s.charAt(i),i); max = Math.max(max,i-left+1); &#125; return max; &#125;&#125; 13. ä¸¤æ•°ç›¸åŠ IIæ³¨æ„ï¼š æƒ³æŠŠé“¾è¡¨åè½¬ + é•¿åº¦ä¸€è‡´ï¼Œåšæ³•æœ‰ç‚¹å¤æ‚æ˜“é”™ï¼Œæ¯”è¾ƒå¥½çš„åšæ³•è¿˜æ˜¯ï¼šæ ˆå‹å…¥ + æ–°å»ºèŠ‚ç‚¹æ„å»ºæ–°é“¾è¡¨ï¼› ç”¨å°¾æ’æ³•ï¼Œä¿è¯è¾“å‡ºçš„ç»“æœæ˜¯é€†åºçš„ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; // 1. é‡‡ç”¨ä¸¤ä¸ªæ ˆå‹å…¥ä¸¤ä¸ªé“¾è¡¨ // 2. é€ä¸ªå¼¹å‡ºè®¡ç®—å€¼ï¼Œåˆ›å»ºæ–°èŠ‚ç‚¹ Stack&lt;ListNode&gt; s1 = new Stack&lt;ListNode&gt;(); Stack&lt;ListNode&gt; s2 = new Stack&lt;ListNode&gt;(); while(l1 != null) &#123; s1.push(l1); l1=l1.next; &#125; while(l2 != null) &#123; s2.push(l2); l2=l2.next; &#125; ListNode head = null; int r = 0; while(s1.size() != 0 &amp;&amp; s2.size() != 0) &#123; int val1 = s1.pop().val; int val2 = s2.pop().val; int sum = val1 + val2 + r; ListNode newNode = new ListNode(sum%10); newNode.next = head; head = newNode; r = sum / 10; &#125; while(s1.size() != 0) &#123; int sum = s1.pop().val + r ; ListNode newNode = new ListNode(sum%10); newNode.next = head; head = newNode; r = sum / 10; &#125; while(s2.size() != 0) &#123; int sum = s2.pop().val + r ; ListNode newNode = new ListNode(sum%10); newNode.next = head; head = newNode; r = sum / 10; &#125; if(r != 0) &#123; ListNode newNode = new ListNode(r); newNode.next = head; head = newNode; &#125; return head; &#125;&#125; 14. ä¸‰æ•°ä¹‹å’Œ15. nextæ ‘ï¼ˆç©ºé—´O(1)ï¼‰æ³¨æ„ï¼Œè¦æ±‚å¸¸æ•°çš„ç©ºé—´å¤æ‚åº¦ï¼Œä¸‹é¢è¿™ç§æ˜¯ç©ºé—´å¤æ‚åº¦O(n)ã€‚ ä¸€æ—¦åœ¨æŸå±‚çš„èŠ‚ç‚¹ä¹‹é—´å»ºç«‹äº† \\text{next}next æŒ‡é’ˆï¼Œé‚£è¿™å±‚èŠ‚ç‚¹å®é™…ä¸Šå½¢æˆäº†ä¸€ä¸ªé“¾è¡¨ã€‚å› æ­¤ï¼Œå¦‚æœå…ˆå»å»ºç«‹æŸä¸€å±‚çš„ \\text{next}next æŒ‡é’ˆï¼Œå†å»éå†è¿™ä¸€å±‚ï¼Œå°±æ— éœ€å†ä½¿ç”¨é˜Ÿåˆ—äº†ã€‚ é˜Ÿåˆ—åˆå§‹åŒ–æ˜¯ç”¨ new LinkedList(); æ ¸å¿ƒï¼š éƒ½æ˜¯éå†å½“å‰å±‚ï¼ˆå‡ºé˜Ÿ/ éå†nextæŒ‡é’ˆï¼‰ï¼Œæ¥å¤„ç†ä¸‹ä¸€å±‚ ï¼ˆå…¥é˜Ÿ / è®¾ç½®nextæŒ‡é’ˆï¼‰ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public Node connect(Node root) &#123; if(root == null) return null; Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); queue.offer(root); root.next = null; while(queue.size() != 0) // ä¼˜åŒ–ï¼šcurè¡¨ç¤ºå½“å‰å±‚æŒ‡é’ˆï¼ˆåˆå§‹ç¬¬ä¸€ä¸ªï¼‰ï¼Œè¿™é‡Œåªè¦curä¸ä¸ºnull &#123; int len = queue.size(); // Node preNode = null; Node preNode = new Node(0); // ä¼˜åŒ–ï¼šè¿™é‡Œä¸ºæ¯ä¸€å±‚é“¾è¡¨è®¾ç½®ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹æ¯”è¾ƒå¥½ï¼ï¼ while(len-- &gt; 0) // æ¯æ¬¡åªåŠ å…¥ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹ï¼Œä¼˜åŒ–ï¼šæ ¹æ®curæ˜¯å¦ä¸ºnullæ¥åˆ¤æ–­æ˜¯å¦éå†å®Œæˆ &#123; Node tmpNode = queue.poll(); /* // åŸå§‹æ€è·¯ï¼Œæ˜¯åœ¨å½“å‰å±‚å¤„ç†å½“å‰å±‚æ‰€æœ‰èŠ‚ç‚¹çš„æŒ‡å‘ï¼Œä½†è¿™æ ·ä¸å¤ªå¥½ // è¿˜æ˜¯åœ¨å½“å‰å±‚å¤„ç†ä¸‹ä¸€å±‚æ‰€æœ‰èŠ‚ç‚¹çš„æŒ‡å‘æ¯”è¾ƒå¥½ if(preNode != null) &#123; preNode.next = tmpNode; &#125; preNode = tmpNode; */ if(tmpNode.left != null) &#123; queue.offer(tmpNode.left); // ä½¿ç”¨é“¾è¡¨è¿™ä¸€æ­¥å¯ä»¥çœç•¥ // åœ¨å½“å‰å±‚å¤„ç†ä¸‹ä¸€å±‚æ‰€æœ‰èŠ‚ç‚¹ preNode.next = tmpNode.left; preNode = tmpNode.left; &#125; if(tmpNode.right != null) &#123; queue.offer(tmpNode.right); // ä½¿ç”¨é“¾è¡¨è¿™ä¸€æ­¥å¯ä»¥çœç•¥ // åœ¨å½“å‰å±‚å¤„ç†ä¸‹ä¸€å±‚æ‰€æœ‰èŠ‚ç‚¹ preNode.next = tmpNode.right; preNode = tmpNode.right; &#125; &#125; preNode.next = null; &#125; return root; &#125;&#125; ä¼˜åŒ–åO(1) çº§åˆ«çš„ 1234567891011121314151617181920212223242526272829303132333435public Node connect(Node root) &#123; if (root == null) return root; //curæˆ‘ä»¬å¯ä»¥æŠŠå®ƒçœ‹åšæ˜¯æ¯ä¸€å±‚çš„é“¾è¡¨ Node cur = root; while (cur != null) &#123; //éå†å½“å‰å±‚çš„æ—¶å€™ï¼Œä¸ºäº†æ–¹ä¾¿æ“ä½œåœ¨ä¸‹ä¸€ //å±‚å‰é¢æ·»åŠ ä¸€ä¸ªå“‘ç»“ç‚¹ï¼ˆæ³¨æ„è¿™é‡Œæ˜¯è®¿é—® //å½“å‰å±‚çš„èŠ‚ç‚¹ï¼Œç„¶åæŠŠä¸‹ä¸€å±‚çš„èŠ‚ç‚¹ä¸²èµ·æ¥ï¼‰ Node dummy = new Node(0); //preè¡¨ç¤ºè®¿ä¸‹ä¸€å±‚èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ Node pre = dummy; //ç„¶åå¼€å§‹éå†å½“å‰å±‚çš„é“¾è¡¨ while (cur != null) &#123; if (cur.left != null) &#123; //å¦‚æœå½“å‰èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ä¸ä¸ºç©ºï¼Œå°±è®©preèŠ‚ç‚¹ //çš„nextæŒ‡å‘ä»–ï¼Œä¹Ÿå°±æ˜¯æŠŠå®ƒä¸²èµ·æ¥ pre.next = cur.left; //ç„¶åå†æ›´æ–°pre pre = pre.next; &#125; //åŒç†å‚ç…§å·¦å­æ ‘ if (cur.right != null) &#123; pre.next = cur.right; pre = pre.next; &#125; //ç»§ç»­è®¿é—®è¿™ä¸€è¡Œçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ cur = cur.next; &#125; //æŠŠä¸‹ä¸€å±‚ä¸²è”æˆä¸€ä¸ªé“¾è¡¨ä¹‹åï¼Œè®©ä»–èµ‹å€¼ç»™curï¼Œ //åç»­ç»§ç»­å¾ªç¯ï¼Œç›´åˆ°curä¸ºç©ºä¸ºæ­¢ cur = dummy.next; &#125; return root;&#125; 16. è·³è·ƒæ¸¸æˆ2æ³¨æ„ä¸¤ç‚¹ï¼š å¯¹äºæ•°ç»„ [3,1] ï¼Œåˆ¤æ–­å¯è·³è·ƒçš„èŒƒå›´å¤§äºæ•°ç»„å³è¾¹ç•Œæ—¶ï¼Œæ­¤æ—¶ç›´æ¥é€€å‡º åœ¨å¯è·³è·ƒçš„èŒƒå›´å»ºè®®ç”¨æ•°ç»„çœŸå®ä¸‹æ ‡sè¡¨ç¤ºï¼Œæ¯ä¸ªè·³è·ƒçš„èŒƒå›´è·ç¦» = s+nums[s] 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int jump(int[] nums) &#123; // å¯¹äºæ•°ç»„ S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 // 3 2 3 3 // ä»S0èµ·è·³ï¼Œå¯ä»¥è·³ S1 S2 S3 ï¼Œå°è¯•ä» S1 S2 S3 åˆ†åˆ«è·³ // å‘ç°S3å¯ä»¥è·³åˆ°æœ€è¿œï¼ˆ3+3ï¼‰ï¼Œæ‰€ä»¥ä¸‹ä¸€è·³é€‰S3 // é‚£ä¹ˆæœ‰æ²¡æœ‰é€‰S1 æˆ–è€… S2 èƒ½æ›´å¿«è·³åˆ°ç»ˆç‚¹å‘¢ï¼Ÿ // ä¸å¯èƒ½ï¼Œå› ä¸ºS3æ˜¯èƒ½è·³åˆ°æœ€è¿œçš„ï¼Œå®ƒä¸‹ä¸€æ¬¡è·³çš„èŒƒå›´ï¼ˆå¯èƒ½çš„è·¯å¾„ï¼‰ä¹Ÿå°±å¿…ç„¶æ¯”S1 æˆ– S2 å¤šï¼ˆä¸”åŒ…å«ï¼‰ int i = 0; int step = 0; while(i &lt; nums.length-1) &#123; int maxPos = -1; int maxDistance = 0; int e = i+nums[i]; if(e&gt;=nums.length-1) // æ³¨æ„å¯è·³è·ƒçš„èŒƒå›´å¦‚æœå¤§äºå½“å‰æ•°ç»„å³è¾¹ç•Œï¼Œåˆ™é€€å‡º &#123; step++; break; &#125; for(int s = i+1 ; s &lt;= e ; s++) // å¯ä»¥è·³çš„æ•°ç»„ä½ç½®ä¸‹æ ‡ &#123; int curDistance = s + nums[s]; if(curDistance &gt; maxDistance) &#123; maxPos = s; maxDistance = curDistance; &#125; &#125; i = maxPos; // æ‰¾åˆ°èƒ½è·³æœ€è¿œè·ç¦»ä½ç½®ä¸‹æ ‡ step++; &#125; return step; &#125;&#125; 17. äºŒå‰æ ‘æ‰€æœ‰è·¯å¾„é¦–å…ˆæ˜ç¡®ä»¥ä¸‹å‡ ç‚¹ï¼š æ ¹èŠ‚ç‚¹åˆ°æŒ‡å®šå¶èŠ‚ç‚¹çš„è·¯å¾„æ˜¯å”¯ä¸€çš„ é€’å½’éå†ï¼Œå¯ä»¥è®¾ç½®ä¸€ä¸ªå˜é‡ï¼ˆå°±æ”¾åˆ°å‚æ•°é‡Œï¼‰ï¼Œè®°å½•èµ°åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„æ˜¯ä»€ä¹ˆ ä½¿ç”¨ååºéå†ï¼Œå¦‚æœåˆ°äº†å¶å­èŠ‚ç‚¹ï¼ˆå·¦å³èŠ‚ç‚¹éƒ½ä¸ºnullï¼‰ï¼Œå°±æŠŠè·¯å¾„è¾“å‡º 12345678910111213141516171819202122class Solution &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); // ä¸èƒ½å®šä¹‰åˆ°é€’å½’å‡½æ•°é‡Œé¢ public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; findPaths(root, String.valueOf(root.val)); return res; &#125; public void findPaths(TreeNode root , String curPath) &#123; if(root == null) return; if(root.left != null) // è®°å½•åˆ°å·¦èŠ‚ç‚¹çš„è·¯å¾„ï¼Œé˜²æ­¢ä¸ºå·¦èŠ‚ç‚¹ä¸ºç©ºåˆ¤æ–­ findPaths(root.left, curPath + &quot;-&gt;&quot; + root.left.val ); if(root.right != null) // åŒä¸Š findPaths(root.right, curPath + &quot;-&gt;&quot; + root.right.val ); if( root.left == null &amp;&amp; root.right == null) // åˆ¤æ–­æ˜¯å¦éå†åˆ°å¶å­èŠ‚ç‚¹ï¼ˆæ‰§è¡Œåˆ°è¿™ä¹Ÿå¯èƒ½æ˜¯å·¦å³å­æ ‘éå†å®Œï¼‰ res.add(curPath); &#125;&#125; åä¸ºä¸“åœº æœºè¯•çš„ä¸¤é“ç®—æ³•é¢˜ ç¬¬ä¸€é¢˜ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.Arrays;import java.util.Scanner;class Solution_KS &#123; Solution_KS() &#123; &#125; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String[] locs = in.nextLine().split(&quot; &quot;); int len = locs.length; int[] locArray = new int[len]; for(int i = 0; i &lt; len; ++i) &#123; locArray[i] = Integer.parseInt(locs[i]); &#125; String[] fixs = in.nextLine().split(&quot; &quot;); int len1 = fixs.length; int[] fixArray = new int[len1]; int res; for(res = 0; res &lt; len1; ++res) &#123; fixArray[res] = Integer.parseInt(fixs[res]); &#125; res = findR(locArray, fixArray); System.out.println(res); &#125; public static int findR(int[] workstations, int[] sterilizers) &#123; Arrays.sort(workstations); Arrays.sort(sterilizers); int worksNums = workstations.length; int sterNums = sterilizers.length; int[][] distance = new int[sterNums][worksNums]; int lastSter; for(int i = 0; i &lt; sterNums; ++i) &#123; for(lastSter = 0; lastSter &lt; worksNums; ++lastSter) &#123; distance[i][lastSter] = Math.abs(sterilizers[i] - workstations[lastSter]); &#125; &#125; int[] minRs = new int[worksNums]; Arrays.fill(minRs, -1); lastSter = 0; int res_max; int i; for(res_max = 0; res_max &lt; worksNums; ++res_max) &#123; minRs[res_max] = distance[lastSter][res_max]; for(i = lastSter + 1; i &lt; sterNums &amp;&amp; distance[i][res_max] &lt; minRs[res_max]; lastSter = i++) &#123; minRs[res_max] = distance[i][res_max]; &#125; &#125; res_max = -1; for(i = 0; i &lt; minRs.length; ++i) &#123; if (minRs[i] &gt; res_max) &#123; res_max = minRs[i]; &#125; &#125; return res_max; &#125;&#125; ç¬¬äºŒé¢˜ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int m = in.nextInt(); in.nextLine(); List&lt;Integer&gt; v = new ArrayList&lt;&gt;(); List&lt;Integer&gt; f = new ArrayList&lt;&gt;(2*m); Collections.fill(f,0); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(int i=0;i&lt;2*m;i++)&#123; v.add(in.nextInt()); f.add(0); &#125; Collections.sort(v); int r = 2*m-1; int l = r-1; while(l&gt;=0) &#123; if(f.get(r) !=0) &#123; r--; l = r-1; continue; &#125; while(l&gt;=0&amp;&amp;(f.get(l) != 0||(v.get(r)+v.get(l))%n!=0)) &#123; l--; &#125; if(l&gt;=0&amp;&amp;l!=r&amp;&amp;(v.get(r)+v.get(l))%n==0) &#123; ans.add(v.get(r)); ans.add(v.get(l)); f.set(r,1); f.set(l,1); r--; l = r-1; &#125; &#125; if(ans.size()!=2*m) &#123; System.out.println(0);; &#125; else &#123; for(int i=0;i&lt;2*m;i++) &#123; System.out.print(ans.get(i));; if(i!=2*m-1) System.out.print(&quot; &quot;); &#125; System.out.println();; &#125; &#125;&#125; runableã€callableå„è‡ªçš„åŒºåˆ« Runnableæ˜¯æ‰§è¡Œå·¥ä½œçš„ç‹¬ç«‹ä»»åŠ¡ï¼Œä½†æ˜¯å®ƒä¸è¿”å›ä»»ä½•å€¼ã€‚å¦‚æœä½ å¸Œæœ›ä»»åŠ¡åœ¨å®Œæˆçš„èƒ½è¿”å›ä¸€ä¸ªå€¼ï¼Œé‚£ä¹ˆå¯ä»¥å®ç°Callableæ¥å£è€Œä¸æ˜¯Runnableæ¥å£ã€‚åœ¨Java SE5ä¸­å¼•å…¥çš„Callableæ˜¯ä¸€ç§å…·æœ‰ç±»å‹å‚æ•°çš„æ³›å‹ï¼Œå®ƒçš„å‚æ•°ç±»å‹è¡¨ç¤ºçš„æ˜¯ä»æ–¹æ³•call()(ä¸æ˜¯run())ä¸­è¿”å›çš„å€¼ã€‚ 12345678910111213141516171819202122232425262728293031323334353637 1 package ThreadOne; 2 3 import java.awt.Panel; 4 import java.util.concurrent.Callable; 5 import java.util.concurrent.Future; 6 import java.util.concurrent.FutureTask; 7 8 public class ThreadCallable extends Panel &#123; 9 10 public static void main(String[] args) &#123;11 12 MyThread2 myThread2 = new MyThread2();13 14 FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(myThread2);15 new Thread(futureTask, &quot;çº¿ç¨‹åï¼šæœ‰è¿”å›å€¼çš„çº¿ç¨‹2&quot;).start();16 17 try &#123;18 System.out.println(&quot;å­çº¿ç¨‹çš„è¿”å›å€¼ï¼š&quot; + futureTask.get());19 &#125; catch (Exception e) &#123;20 e.printStackTrace();21 &#125;22 &#125;23 &#125;24 25 class MyThread2 implements Callable&lt;Integer&gt; &#123;26 27 public Integer call() throws Exception &#123;28 System.out.println(&quot;å½“å‰çº¿ç¨‹åâ€”â€”&quot; + Thread.currentThread().getName());29 int i = 0;30 for (; i &lt; 5; i++) &#123;31 System.out.println(&quot;å¾ªç¯å˜é‡içš„å€¼ï¼š&quot; + i);32 &#125;33 34 return i;35 &#125;36 37 &#125; å†…å­˜æº¢å‡ºã€å†…å­˜æ³„æ¼ã€æ€ä¹ˆåˆ†æ å†…å­˜æ³„æ¼ï¼šä¸å†ä¼šè¢«ä½¿ç”¨çš„å¯¹è±¡çš„å†…å­˜ä¸èƒ½è¢«å›æ”¶ï¼Œå°±æ˜¯å†…å­˜æ³„éœ²ã€‚ å†…å­˜æº¢å‡ºï¼šjava.lang.OutOfMemoryErrorã€‚å†…å­˜æº¢å‡ºé€šä¿—ç†è§£å°±æ˜¯å†…å­˜ä¸å¤Ÿï¼Œæ˜¯æŒ‡è¿è¡Œç¨‹åºæ—¶è¦æ±‚çš„å†…å­˜ï¼Œè¶…å‡ºäº†ç³»ç»Ÿæ‰€èƒ½åˆ†é…çš„èŒƒå›´ï¼Œä»è€Œå¯¼è‡´å‘ç”Ÿå†…å­˜æº¢å‡ºã€‚ ä¸€ã€ç®—æ³•1.1 åŸºæœ¬ç®—æ³•æœ€åŸºæœ¬è¦è®°å¿†ã€çƒ‚ç†Ÿäºå¿ƒçš„ç®—æ³•ã€‚ æ•°ç»„æ’åº å‚è€ƒï¼šåå¤§ç»å…¸æ’åºç®—æ³•æœ€å¼ºæ€»ç»“ï¼ˆå«JAVAä»£ç å®ç°ï¼‰ ä¸‹é¢æè¿°ä¸­ï¼Œè®°ï¼šå·²æ’åºéƒ¨åˆ†ä¸ºSï¼Œæœªæ’åºéƒ¨åˆ†ä¸ºRï¼Œä¸”ç›¸é‚»ã€‚ å†’æ³¡æ’åº æ ¸å¿ƒæ€æƒ³ å†…å¾ªç¯ï¼šæ¯æ¬¡åœ¨Rä¸­ä»å¤´ æ‰«æï¼ˆå·²æ’åºSæ”¾æœ€åï¼‰ï¼Œç›¸é‚»å…ƒç´ æ¯”è¾ƒï¼Œè¾ƒå¤§å¾€åäº¤æ¢ï¼›å¤–å¾ªç¯ï¼šnä¸ªæ•°éœ€n-1è½®ä¾æ¬¡é€‰å‡º$R_i$ ä¸­æœ€å¤§ã€‚ æ¯æ¬¡ä»å¤´ï¼Œæœªæ’ç›¸é‚»æ¯”è¾ƒï¼Œæœ€å¤§æœ€åã€‚ï¼ˆå¦‚æœé€†åºï¼Œæœ€å°æœ€åï¼‰ ä»£ç å®ç° 123456789101112131415161718public int[] bubble_sort(int[] arr) &#123; for(int i=0; i&lt;arr.length-1;i++) // å¤–è½®=n-1 // * j=0,æ¯æ¬¡éƒ½æ˜¯ä»å¤´å¼€å§‹æ¯”è¾ƒ for (int j=0; j&lt; arr.length-i-1; j++ ) // å†…è½®=ä½™ä¸‹ä¹±åºæ•°-1 &#123; if (arr[j]&gt;arr[j+1]) swap(arr,j,j+1); &#125; return arr; &#125; public void swap(int[] arr,int idx_i,int idx_j) &#123; int tmp = arr[idx_i]; arr[idx_i] = arr[idx_j]; arr[idx_j] = tmp; &#125; é€‰æ‹©æ’åº æ ¸å¿ƒæ€æƒ³ å†…å¾ªç¯ï¼šæ¯æ¬¡åœ¨Rä¸­ä»å¤´ æ‰«æï¼ˆå·²æ’åºSæ”¾æœ€å‰ï¼‰ï¼Œè®°å½•æœ€å¤§å…ƒç´ äº¤æ¢ï¼›å¤–å¾ªç¯ï¼šnä¸ªæ•°éœ€n-1è½®ä¾æ¬¡é€‰å‡º$R_i$ ä¸­æœ€å¤§ã€‚ æœªæ’å¼€å§‹ï¼Œä¸€è½®å¾ªç¯ï¼Œæ¯”è¾ƒæœ€å¤§ï¼ˆå°ï¼‰ï¼Œæ”¾åœ¨å·²æ’æœ€åã€‚ ä»£ç å®ç° 1234567891011121314151617public int[] select_sort(int[] arr) &#123; for(int i=0; i&lt;arr.length-1;i++) // å¤–è½®=n-1 &#123; int min = i; // å’Œå†’æ³¡æ’åºä¸åŒï¼Œè™½ç„¶å†…è½®å¾ªç¯æ•°åŒæ ·=ä½™ä¸‹æœªæ’æ•°-1 // * ä½†æ˜¯å¾ªç¯æ¡ä»¶æ˜¯ j&lt;arr.length-1 ï¼Œå› ä¸ºã€å·²æ’åºæ•°ã€‘æ”¾æœ€å‰ï¼Œè€Œéæœ€å for(int j=i; j&lt;arr.length-1; j++) // å†…è½®=ä½™ä¸‹æœªæ’æ•°-1 &#123; // å¯»æ‰¾ä¸€è½®å¾ªç¯æœ€å°æ•° if(arr[j+1]&lt;arr[min]) min = j+1; &#125; swap(arr,i,min); &#125; return arr; &#125; æ’å…¥æ’åº æ ¸å¿ƒæ€æƒ³ å†…å¾ªç¯ï¼šé€‰å–R[0]ï¼Œæ¯æ¬¡åœ¨å·²æ’Sä¸­ä»å°¾æ‰«æï¼ˆå·²æ’åºSæ”¾æœ€å‰ï¼‰ï¼Œå¦‚æœè¯¥å…ƒç´ ï¼ˆå·²æ’åºï¼‰&gt;R[0]ï¼Œç§»åŠ¨ä¸‹ä¸€ä½ï¼Œå¦åˆ™æ’å…¥R[0]åœ¨å…¶åï¼› å…³äºç©ºä½ï¼šå¦‚æœR[0]å¤§äºå·²æ’S æœ€åä¸€ä¸ªæ•°ï¼Œåˆ™ç›´æ¥æ’å…¥S æœ€åï¼ˆç”±äºS,Rå®é™…ä¸å˜ç›¸é‚»ï¼ŒR[0]ä½ç½®ä¸å˜ï¼‰å’Œæ™®é€šæ’å…¥æƒ…å†µä¸€è‡´ï¼›å¦‚æœR[0]å°äºå·²æ’S æœ€å‰ä¸€ä¸ªæ•°ï¼Œåˆ™æ’å…¥æœ€å‰ã€‚å®é™…ä¸­ï¼Œé€šè¿‡è®°å½•pre_indexï¼Œå¯ç»Ÿä¸€æ’å…¥æ“ä½œã€‚ å¤–å¾ªç¯ï¼šnä¸ªæ•°éœ€n-1è½®ä¾æ¬¡é€‰å‡º$R_i$ ä¸­æœ€å¤§ã€‚ ä»£ç å®ç°1 12345678910111213141516171819202122232425public int[] insert_sort(int[] arr) &#123; for(int i=0; i&lt;arr.length-1;i++) // å¤–è½®=n-1 &#123; int insert_num = arr[i+1]; // ç¬¬1ä¸ªæ•°é»˜è®¤å·²æ’åº // * å†…å¾ªç¯ä»åéå†å·²æ’Sï¼Œæ¯”è¾ƒâ†’ç§»åŠ¨å…ƒç´ /æ’å…¥ç©ºä½ // ** ä»å‰éå†ä¸æ–¹ä¾¿ç§»åŠ¨å…ƒç´ ï¼Œå·§å¦™åˆ©ç”¨R[0]å…¶å®åœ¨Så for(int j=i; j&gt;=0; j--) // å†…è½®= å·²æ’åºçš„æ•° &#123; if(insert_num&lt;arr[j]) &#123; arr[j+1]=arr[j]; // å¤§å¾€åç§»åŠ¨ if(j==0) // è¾¹ç•Œæ¡ä»¶ï¼šæ‰«æå®Œæ¯•æ’å…¥æœ€å‰ &#123; arr[0]=insert_num; break; &#125; &#125; else &#123; arr[j+1]=insert_num; break; &#125; &#125; &#125; return arr; &#125; ä»£ç å®ç°2ï¼ˆä¼˜åŒ–ï¼‰ ä¼˜åŒ–åœ¨å†…å¾ªç¯åç»Ÿä¸€æ’å…¥ï¼Œå‡å°‘ä¸¤æ¬¡æ’å…¥æ“ä½œä¸ºä¸€æ¬¡ã€‚ 123456789101112131415161718192021222324public int[] insert_sort1(int[] arr) &#123; for(int i=0; i&lt;arr.length-1;i++) // å¤–è½®=n-1 &#123; int insert_num = arr[i+1]; // ç¬¬1ä¸ªæ•°é»˜è®¤å·²æ’åº // * å†…å¾ªç¯ä»åéå†å·²æ’Sï¼Œæ¯”è¾ƒâ†’ç§»åŠ¨å…ƒç´ /æ’å…¥ç©ºä½ // ** ä»å‰éå†ä¸æ–¹ä¾¿ç§»åŠ¨å…ƒç´ ï¼Œå·§å¦™åˆ©ç”¨R[0]å…¶å®åœ¨Så // *** åˆå§‹ä¸º-1,å¤„ç†æ°å¥½æ’å…¥æ•°æœ€å°æ’å…¥æœ€å‰çš„æƒ…å†µ int pre_idx=-1; for(int j=i; j&gt;=0; j--) // å†…è½®= å·²æ’åºçš„æ•° &#123; if(insert_num&lt;arr[j]) &#123; arr[j+1]=arr[j]; // å¤§å¾€åç§»åŠ¨ &#125; else // å°æ’å…¥å…¶å &#123; pre_idx = j; break; &#125; &#125; arr[pre_idx+1]= insert_num; &#125; return arr; &#125; å½’å¹¶æ’åº æ ¸å¿ƒæ€æƒ³ æŠŠé•¿åº¦ä¸ºnçš„è¾“å…¥åºåˆ—åˆ†æˆä¸¤ä¸ªé•¿åº¦ä¸ºn/2çš„å­åºåˆ—ï¼› å¯¹è¿™ä¸¤ä¸ªå­åºåˆ—åˆ†åˆ«é‡‡ç”¨å½’å¹¶æ’åºï¼› å°†ä¸¤ä¸ªæ’åºå¥½çš„å­åºåˆ—åˆå¹¶æˆä¸€ä¸ªæœ€ç»ˆçš„æ’åºåºåˆ—ã€‚ ä»£ç å®ç° 1234567891011121314151617181920212223242526272829303132333435363738public static void mergeSort(int[] arr, int low, int high) &#123; int mid = (low + high) / 2; if (low &lt; high) &#123; // å·¦è¾¹ mergeSort(arr, low, mid); // å³è¾¹ mergeSort(arr, mid + 1, high); // å·¦å³å½’å¹¶ merge(arr, low, mid, high); &#125; &#125;public static void merge(int[] arr, int low, int mid, int high) &#123; int[] temp = new int[high - low + 1]; int i = low; // å·¦æŒ‡é’ˆ int j = mid + 1; // å³æŒ‡é’ˆ int k = 0; // æŠŠè¾ƒå°çš„æ•°å…ˆç§»åˆ°æ–°æ•°ç»„ä¸­ while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (arr[i] &lt; arr[j]) temp[k++] = arr[i++]; else temp[k++] = arr[j++]; &#125; // æŠŠå·¦è¾¹å‰©ä½™çš„æ•°ç§»å…¥æ•°ç»„ while (i &lt;= mid) temp[k++] = arr[i++]; // æŠŠå³è¾¹è¾¹å‰©ä½™çš„æ•°ç§»å…¥æ•°ç»„ while (j &lt;= high) temp[k++] = arr[j++]; // æŠŠæ–°æ•°ç»„ä¸­çš„æ•°è¦†ç›–numsæ•°ç»„ for (int k2 = 0; k2 &lt; temp.length; k2++) arr[k2 + low] = temp[k2]; &#125; å¿«é€Ÿæ’åº æ ¸å¿ƒæ€æƒ³ å¿«é€Ÿæ’åºä½¿ç”¨åˆ†æ²»æ³•æ¥æŠŠä¸€ä¸ªä¸²ï¼ˆlistï¼‰åˆ†ä¸ºä¸¤ä¸ªå­ä¸²ï¼ˆsub-listsï¼‰ï¼š è®¾å®šä¸€ä¸ªåŸºå‡†pivot=arr[right], åˆ†å‰²æ ‡è®°partition=left partition è¡¨ç¤ºæœ€ç»ˆåŸºå‡†æ’å…¥çš„ä½ç½®ï¼Œåˆå§‹==leftè¡¨ç¤ºé»˜è®¤æ‰€æœ‰å…ƒç´ &gt;pivot éå†æ•°ç»„ï¼Œå¦‚æœæ•°ç»„å…ƒç´ arr[i]&lt;pivot,äº¤æ¢arr[partition]å’Œarr[i] ï¼Œ ä¸”partition+1ï¼Œå°†arr[i]äº¤æ¢åˆ°partitionå·¦è¾¹ã€‚ä¿è¯åŸºå‡†å·¦ä¾§å…ƒç´ &lt;åŸºå‡† é€’å½’é‡å¤ä¸Šè¿°æ“ä½œ ä»£ç å®ç° 123456789101112131415161718192021222324252627public int[] quick_sort(int[] arr,int left,int right) &#123; if(right&lt;=left)&#123;return null;&#125; // é€‰æ‹©åŸºå‡†ï¼šæ•°ç»„æœ€å³æ•°å­— // *å¦‚æœé€‰æ‹©æœ€å·¦ï¼Œæ€è€ƒäº¤æ¢è¿‡ç¨‹ // *partition å·¦ä¾§å§‹ç»ˆæ˜¯æ¯”pivotå°çš„æ•° int pivot = arr[right]; int partition = left; // éå†åˆ†åŒºå…ƒç´  // å°äºåŸºå‡†çš„æ”¾åŸºå‡†å·¦è¾¹ï¼Œå¤§äºçš„æ”¾åŸºå‡†å³è¾¹ // * ç»ˆæ­¢æ¡ä»¶ï¼ši &lt; right è€Œé right-1ï¼ for(int i=left; i&lt; right;i++) &#123; if(arr[i]&lt;pivot) // å®é™…åªäº¤æ¢å°äºåˆ°å·¦è¾¹å³å¯ &#123; swap(arr,i,partition); partition++; &#125; &#125; // åŸºå‡†æ’å…¥ä½ç½®partitionä½ç½® swap(arr,partition,right); //é€’å½’çš„æ’åº quick_sort(arr,left,partition-1); quick_sort(arr,partition+1,right); return arr; &#125; å †æ’åº ä¹‹å‰ç¬”è®°ï¼š6.æ’åº æ ¸å¿ƒæ€æƒ³ ç©ºé—´å¤æ‚åº¦ï¼šO(1) , æ—¶é—´å¤æ‚åº¦ï¼šO(n*logn)ã€‚å…¶ä¸­å»ºå †ï¼šO(n) ï¼Œæ’åºï¼šO(n*logn)ï¼Œæ—¶ç©ºå¤æ‚åº¦ç”±è®¡ç®—æ¯”è¾ƒæ¬¡æ•°å¾—åˆ°ï¼Œå…·ä½“ç†è§£ å †æ’åºä¸­å»ºå †è¿‡ç¨‹æ—¶é—´å¤æ‚åº¦O(n)æ€ä¹ˆæ¥çš„ï¼Ÿ - wuxinliuleiçš„å›ç­” - çŸ¥ä¹ å…·ä½“å¯¹åº”ä»£ç å®ç°ï¼š å°†ä¸€ç»´æ•°ç»„$arr$è§†ä½œä¸ºå®Œå…¨äºŒå‰æ ‘å¤„ç†ï¼ˆè§ä¸Šï¼‰ æ„å»ºåˆå§‹æœ€å¤§å †ã€‚éå†æ•°ç»„ï¼Œä»å€’æ•°ç¬¬ä¸€ä¸ªéå¶å­èŠ‚ç‚¹$i=len/2$,è¿›è¡Œæ„å»ºæœ€å¤§å † å¦‚æœå·¦å­©å­ï¼ˆ$i2+1$ï¼‰,å³å­©å­ï¼ˆ$i2+2$ï¼‰å¤§äºå½“å‰èŠ‚ç‚¹å€¼ï¼Œåˆ™äº¤æ¢ å¦‚æœå‘ç”Ÿäº¤æ¢å¯èƒ½ä¼šç ´åæœ€å¤§å †æ€§è´¨ï¼Œç»§ç»­å¾€ä¸‹è°ƒæ•´ é‡å¤1~3ï¼Œç›´è‡³æ‰€æœ‰èŠ‚ç‚¹çš„å­æ ‘éƒ½è°ƒæ•´å®Œæ¯• å †æ’åºã€‚ éå†æ•°ç»„ï¼Œæ¯æ¬¡äº¤æ¢å †é¡¶$i=0$ ï¼ˆæœ€å¤§å€¼ï¼‰å’Œå †å°¾å…ƒç´ $i=len-1$ ç”±äºäº¤æ¢å…ƒç´ å€¼ä¼šå¯èƒ½æ”¹å˜æœ€å¤§å †æ€§è´¨ï¼Œä»å †é¡¶å¾€ä¸‹è°ƒæ•´ï¼ˆæ•°ç»„é•¿åº¦-1ï¼‰ é‡å¤5~6ç›´è‡³å †æ’åºå®Œæˆ ä»£ç å®ç° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public int[] heapSort(int[] arr) &#123; int len = arr.length; // 1.æ„å»ºåˆå§‹å † // ä»æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹æ„å»ºåˆå§‹å † for(int i= len/2; i&gt;=0; i--) // å¯¹æ¯ä¸€ä¸ªèŠ‚ç‚¹è§†ä½œæ ¹èŠ‚ç‚¹ï¼Œè°ƒæ•´å­æ ‘ç¬¦åˆæœ€å¤§å † MaxHeapfily(arr,i,len); // 2.æ’åº // æ¯æ¬¡äº¤æ¢å †é¡¶å’Œå †å°¾å…ƒç´  // *æ³¨æ„æ•°ç»„é•¿åº¦ä¼šå˜åŒ–ï¼Œæ‰€ä»¥ç»ˆæ­¢æ¡ä»¶æ˜¯i&lt;arr.length-1ï¼Œè€Œä¸æ˜¯len-1 for(int i=0; i&lt;arr.length-1 ; i++) &#123; swap(arr,0,len-1); // äº¤æ¢ç ´åæœ€å¤§å †æ€§è´¨ // ä»äº¤æ¢çš„å…ƒç´ i=0ï¼Œå¼€å§‹å¾€ä¸‹è°ƒæ•´ // *æ³¨æ„æ•°ç»„é•¿åº¦-1,è€Œä¸”ä¼šé€’å½’è°ƒç”¨ï¼Œæ‰€ä»¥ä¸è¦åœ¨å‡½æ•°å‚æ•°è°ƒç”¨len-- len = len-1; MaxHeapfily(arr,0,len); &#125; return arr; &#125; // è®¾ç½®å‚æ•°è¦æœ‰æ•°ç»„é•¿åº¦ï¼Œå› ä¸ºæ’åºæ—¶äº¤æ¢å †é¡¶å’Œå †å°¾å…ƒç´ ï¼Œç›¸å½“åˆ é™¤å †é¡¶å…ƒç´  // å¯¹åº”æ•°ç»„é•¿åº¦-1 public void MaxHeapfily(int[] arr, int root , int len) &#123; // å·¦å³å­©å­ int left = root*2+1; int right = root*2+2; if(left&gt;=len) return; int largest = root; // é€‰æ‹©æœ€å¤§è€… // *ä¿è¯å·¦å³å­©å­å­˜åœ¨ largest = arr[left]&gt;arr[largest]? left : largest; largest = right&lt;len &amp;&amp; arr[right]&gt;arr[largest]? right : largest; // å¦‚æœå‘ç”Ÿäº¤æ¢è¦å¾€ä¸‹è°ƒæ•´ if(largest!=root) &#123; swap(arr,largest,root); MaxHeapfily(arr,largest,len); &#125; &#125; public void swap(int[] arr, int i,int j) &#123; int temp ; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; æ•°ç»„æŸ¥æ‰¾ äºŒåˆ†æŸ¥æ‰¾ äºŒåˆ†æŸ¥æ‰¾è¿˜æ˜¯è¾ƒä¸ºç®€å•çš„ï¼Œæ˜“é”™çš„éƒ¨åˆ†çœ‹ä»£ç æ³¨é‡Šå°±è¡Œã€‚ 12345678910111213141516171819202122232425// binary search public int binarySearch(int[] arr, int value) &#123; int left = 0,right = arr.length-1; int mid ; while (left&lt;=right) //*&lt;= è€Œä¸æ˜¯&lt; &#123; mid = (left+right)/2; if(value == arr[mid]) &#123; return mid; // å¦‚æœæ•°ç»„å­˜åœ¨å¾…æŸ¥æ‰¾å…ƒç´ ï¼ŒæŒ‰ç…§é€»è¾‘ä¸€å®šä¼šæ˜¯mid &#125; else if(value &lt; arr[mid]) &#123; right = mid-1; &#125; else // value &gt; arr[mid] &#123; left = mid+1; &#125; &#125; return -1; &#125; æ ‘éå†é¦–å…ˆï¼Œæˆ‘ä»¬å®šä¹‰åŸºæœ¬æ ‘ç»“æ„ï¼š 1234567public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; ç»™å®šæµ‹è¯•æ ‘ç»“æ„å¦‚ä¸‹ï¼š å›å¿†æ ‘ä¸‰ç§éå†æ–¹å¼ï¼š å‰åºéå†ï¼ˆæ ¹â†’å·¦â†’å³ï¼‰ï¼šæŒ‰ç…§æ ¹èŠ‚ç‚¹â†’å·¦å­©å­â†’å³å­©å­ä¾æ¬¡è®¿é—®ï¼Œæ¯è®¿é—®å°±ç«‹å³æ‰“å°å‡ºå€¼ ã€‚(1)ä¸€ç›´å¾€æ ¹èŠ‚ç‚¹å·¦å­©å­è®¿é—®ï¼Œæ¯è®¿é—®å°±ç«‹å³è¾“å‡ºå€¼ï¼ˆå«æ ¹èŠ‚ç‚¹ï¼‰ ï¼Œç›´è‡³èŠ‚ç‚¹æ²¡æœ‰å·¦å­©å­ï¼ˆå­æ ‘ï¼‰ï¼›ï¼ˆ2ï¼‰å¦‚æœè¯¥èŠ‚ç‚¹æœ‰å³å­©å­ï¼Œå³å­©å­ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œé‡å¤(1) ; ï¼ˆ3ï¼‰å¦‚æœæ²¡æœ‰ï¼Œè®¿é—®è¯¥èŠ‚ç‚¹çš„æ ¹èŠ‚ç‚¹å³å­©å­ï¼Œä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œé‡å¤ä»¥ä¸Šï¼Œç›´è‡³å…¨éƒ¨è®¿é—®å¹¶è¾“å‡ºã€‚ æµ‹è¯•å€¼ï¼š6 2 0 1 4 5 8 9 ä¸­åºéå†ï¼ˆå·¦â†’æ ¹â†’å³ï¼‰ï¼š(1)ä¸€ç›´å¾€æ ¹èŠ‚ç‚¹å·¦å­©å­è®¿é—®ï¼Œå¦‚æœè‡³èŠ‚ç‚¹æ²¡æœ‰å·¦å­©å­/å­æ ‘ï¼ˆæˆ–å·²è®¿é—®ï¼‰ï¼Œåˆ™è¾“å‡ºè¯¥èŠ‚ç‚¹å€¼ï¼›(2)å¦‚æœè¯¥èŠ‚ç‚¹æœ‰å³å­©å­ï¼Œå³å­©å­ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œé‡å¤(1) ; ï¼ˆ3ï¼‰å¦‚æœæ²¡æœ‰ï¼Œè®¿é—®å…¶æ ¹èŠ‚ç‚¹çš„å³å­©å­ï¼Œä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œé‡å¤ä»¥ä¸Šï¼Œç›´è‡³å…¨éƒ¨è®¿é—®å¹¶è¾“å‡ºã€‚ æµ‹è¯•å€¼ï¼š0 1 2 4 5 6 8 9 ååºéå†ï¼ˆå·¦â†’å³â†’æ ¹ï¼‰ï¼šç±»æ¯”å‰ä¸­åºéå†ï¼Œä¸è¿‡è®¿é—®è¾“å‡ºæ¡ä»¶å˜ä¸ºï¼šèŠ‚ç‚¹å·¦å³å­æ ‘éƒ½æ²¡æœ‰ï¼ˆæˆ–å·²è®¿é—®ï¼‰ï¼Œåˆ™è¾“å‡ºè¯¥èŠ‚ç‚¹å€¼ï¼›è®¿é—®ä¼˜å…ˆé¡ºåºï¼Œ**éƒ½æ˜¯å…ˆæ²¿æ ¹èŠ‚ç‚¹å·¦å­©å­è®¿é—®ï¼Œå†å³å­©å­æˆ–è€…ä¸Šä¸€èŠ‚ç‚¹å³å­©å­ç»§ç»­..**ã€‚ æµ‹è¯•å€¼ï¼š1 0 5 4 2 9 8 6 å…±åŒç‚¹ï¼šå‰/ä¸­/ååºéå†ï¼Œè¾“å‡ºèŠ‚ç‚¹æ¡ä»¶ä¸ä¸€æ ·ï¼Œä½†é€’å½’éå†é¡ºåºä¸€æ ·ï¼š ï¼ˆ1ï¼‰å¯¹äºç»™å®šæ ¹èŠ‚ç‚¹rootï¼Œä¸€ç›´æ²¿ç€å·¦å­©å­èµ°ç›´åˆ°ä¸ºç©ºï¼ˆ2ï¼‰ä¸ºç©ºéœ€è¦è®¿é—®å…¶å³å­©å­ï¼Œä½œä¸ºæ–°çš„æ ¹èŠ‚ç‚¹é‡å¤ä»¥ä¸Šæ­¥éª¤ã€‚ ä»å›¾éå†åˆ°â†’æ ‘éå†ï¼šçœ‹å®Œè¿™ç¯‡ï¼Œä½ ä¼šç†è§£å›¾å’Œæ ‘çš„éå† å›¾æœ‰ä¸¤ç§éå†æ–¹å¼ï¼Œæ·±åº¦ä¼˜å…ˆéå†ï¼ˆDFSï¼‰å’Œå¹¿åº¦ä¼˜å…ˆéå†ï¼ˆBFSï¼‰ï¼Œä¸‹é¢ç”¨æ¥éå†æ ‘ç»“æ„ã€‚ æ·±åº¦ä¼˜å…ˆéå†ï¼ˆDFSï¼‰ æ›´ç»†è‡´è®²è§£DFSå’ŒBFSï¼Œå¯ä»¥çœ‹ï¼šå›¾æ–‡è¯¦è§£ä¸¤ç§ç®—æ³•ï¼šDFSå’ŒBFS è§ä¸Šè®²è§£é“¾æ¥ï¼šé¦–å…ˆçŸ¥é“ï¼ŒDFSéå†è¿‡ç¨‹==æ ‘å‰åºéå†ï¼ˆæ ¹â†’å·¦â†’å³ï¼‰ã€‚é€’å½’ä»£ç å¦‚ä¸‹ï¼š 12345678public void DFS(TreeNode root)&#123; if (root == null) return; System.out.print(root.val+&quot; &quot;); inOrderTraverse1(root.left); inOrderTraverse1(root.right);&#125; ä¸ºä»€ä¹ˆè¦ç”¨ï¼ˆæ ˆï¼Œstackï¼‰éé€’å½’æ¨¡æ‹Ÿè¿›è¡Œå®ç°DFS/ å‰åºéå†ï¼Ÿ æ ˆæ˜¯æ¨¡æ‹Ÿé€’å½’ä¸äºŒé€‰æ‹©ï¼Œå› ä¸ºé€’å½’å…¶å®å‡½æ•°è°ƒç”¨æ ˆçš„é—®é¢˜ï¼Œå› æ­¤éœ€è¦æ ˆ è¿™ç§æ•°æ®ç»“æ„æ”¯æŒã€‚ æ ˆç”¨æ ˆæ—¶æ¨¡æ‹Ÿé€’å½’æ“ä½œï¼Œæ ¸å¿ƒæ“ä½œè¦ç‚¹ï¼Ÿ push æ—¶æœºï¼šä¸€ç»è®¿é—®å³pushï¼ŒåŒé€’å½’ pop æ—¶æœºï¼šèŠ‚ç‚¹å·¦å³å­æ ‘éƒ½è¢«è®¿é—®ï¼ŒåŒé€’å½’å‡½æ•°è¢«è®¿é—®å®Œæ¯•ã€‚åœ¨å‰/ä¸­åºéé€’å½’éå†æ—¶ï¼Œå·¦å³å­©å­è¢«è®¿é—®å³å¯ï¼š 1234é€’å½’æ—¶ï¼Œè¦ç­‰èŠ‚ç‚¹å³å­©å­popå‡ºï¼Œå³å³å­æ ‘è¢«è®¿é—®å®Œæ¯•ï¼ˆæ³¨ï¼Œéƒ½è®¿é—®å³å­©å­äº†ï¼Œå·¦å­æ ‘è‚¯å®šè¢«è®¿é—®å®Œæ¯•ï¼‰å†popå‡ºèŠ‚ç‚¹ï¼ˆæ­¤æ—¶èŠ‚ç‚¹å·¦å³å­æ ‘éƒ½å·²è¢«è®¿é—®ï¼‰ï¼Œä¹Ÿå°±æ˜¯popä¸¤æ¬¡ï¼› ä½†å¯¹äºã€å‰åº/ä¸­åºã€‘éé€’å½’æ—¶å¯ä»¥æå‰popï¼Œå³åœ¨èŠ‚ç‚¹å³å­©å­è¢«è®¿é—®å³popï¼Œã€ä¸å½±å“éå†è¾“å‡ºå€¼ã€‘ï¼šå› ä¸ºå¾ªç¯é€»è¾‘åŒæ—¶popå¤šæ¬¡æ¯”è¾ƒå¤æ‚ï¼Œé€’å½’çš„ç¬¬äºŒæ¬¡popå‡ºèŠ‚ç‚¹ä¹Ÿæ²¡æœ‰å®è´¨æ€§å½±å“ã€‚ [*]ç„¶è€Œã€ååºã€‘éé€’å½’ï¼Œå¿…é¡»è¦ï¼šåˆ¤æ–­èŠ‚ç‚¹å·¦å³å­æ ‘éƒ½è®¿é—®å®Œï¼Œæ‰å¯ä»¥popå¹¶è¾“å‡ºå…¶å€¼ã€‚å¦‚æœåªæ˜¯å¦‚å‰/ä¸­åºéé€’å½’ï¼šå·¦å­æ ‘è®¿é—®å®Œï¼Œè®¿é—®å³å­©å­å°±popè¾“å‡ºå…¶å€¼ï¼Œä¸ç¬¦åˆå®é™…é€’å½’ååºè°ƒç”¨ã€‚æ‰€ä»¥éœ€è¦è®¾ç½®åˆ¤æ–­å³å­æ ‘æ˜¯å¦è®¿é—®å®Œæ¯•ï¼Œå†popå’Œè¾“å‡ºã€‚ è¾“å‡ºæ—¶æœºï¼šæ ¹æ®å‰/ä¸­/ååºï¼Œæ‰€éœ€ä¸åŒæ¡ä»¶è¿›è¡Œè¾“å‡ºã€‚ä¾‹å¦‚ï¼Œå‰åº/DFSï¼šä¸€è®¿é—®åˆ™ç«‹å³è¾“å‡ºï¼›ä¸­åºï¼šè®¿é—®å³å­©å­æ—¶å³è¾“å‡ºã€‚ 12345678910111213141516171819202122232425262728public void DFS(TreeNode root) &#123; LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); TreeNode pNode = root; // *æ ˆç©ºä¾æ—§å¯èƒ½æ²¡éå†å®Œï¼ˆå¦‚ï¼Œè®¿é—®å³å­©å­ä½†æ²¡å‹å…¥ï¼‰ while (pNode != null || !stack.isEmpty()) &#123; // *è¿™ä¸ªæ¡ä»¶æ˜“å¿˜ï¼šè¾“å‡ºç©ºèŠ‚ç‚¹æ•°å€¼ if (pNode != null) // *è¿™é‡Œä¸ç”¨whileæ›´ç®€æ´ &#123; // å‰åºéå†ï¼šè®¿é—®åç«‹å³è¾“å‡º System.out.print(pNode.val+&quot; &quot;); // å‹å…¥æ ˆæ˜¯ä¸ºäº†èµ°åˆ°ç©ºèŠ‚ç‚¹ï¼Œå¯ä»¥é€€å›åˆ°æ ¹èŠ‚ç‚¹ // è¿›è€Œå¯ä»¥è®¿é—®åŒçº§å³å­©å­ï¼ˆæ¨¡æ‹Ÿé€’å½’ï¼‰ stack.push(pNode); // æ²¿ç€ä¸‹ä¸€ä¸ªå·¦å­©å­èµ° pNode = pNode.left; &#125; else //pNode == null &amp;&amp; !stack.isEmpty() &#123; // ä¸€ä¸ªèŠ‚ç‚¹ã€å·¦å³å­©å­éƒ½è¢«è®¿é—®ã€‘å³pop // è™½ç„¶ä¸æ˜¯å­æ ‘ï¼Œä½†è¿™é‡Œç¬¦åˆé€’å½’è°ƒç”¨é€»è¾‘ TreeNode node = stack.pop(); // å³å­©å­ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼ˆnodeå³å­æ ‘ï¼‰ï¼Œé‡å¤ä»¥ä¸Š pNode = node.right; &#125; &#125; &#125; å’Œå¹¿åº¦ä¼˜å…ˆéå†ï¼ˆBFSï¼‰ å¹¿åº¦ä¼˜å…ˆéå†è¾ƒä¸ºç®€å•ï¼Œä½¿ç”¨é˜Ÿåˆ—ï¼š é˜Ÿåˆ—é¦–å…ˆåŠ å…¥æ ¹èŠ‚ç‚¹ï¼Œä¹‹åå¯¹äºé¦–èŠ‚ç‚¹ å‡ºé˜Ÿå¹¶è¾“å‡ºå…¶å…ƒç´ ï¼ŒåŒæ—¶åˆ¤æ–­å…¶æ˜¯å¦å³å·¦å³å­©å­ï¼Œæœ‰åˆ™åŠ å…¥ ç›´è‡³é˜Ÿåˆ—ä¸ºç©º 1234567891011121314151617181920212223// BFS,é˜Ÿåˆ—public void levelTraverse(TreeNode root)&#123; if (root == null) &#123; return; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); // é˜Ÿå°¾åŠ å…¥ï¼Œä¸‹åŒ while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); // å‡ºåˆ— System.out.print(node.val+&quot; &quot;); if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125;&#125; å‰åºéå† å‰åºéå†ï¼Œéé€’å½’ä»£ç åŒDFSï¼Œä¸å†èµ˜è¿°ã€‚ä»¥ä¸‹æ˜¯é€’å½’ä»£ç ï¼š 123456789public void preOrderTraverse1(TreeNode root) &#123; if (root != null) &#123; System.out.print(root.val+&quot; &quot;); preOrderTraverse1(root.left); preOrderTraverse1(root.right); &#125; &#125; ä¸­åºéå† ä¸­åºéé€’å½’ä»£ç ï¼Œæœ‰äº†å‰åºéé€’å½’å®ç°å°±ç®€å•å¾ˆå¤šäº†ã€‚ åŒå‰ï¼Œé€’å½’éå†é¡ºåºéƒ½æ˜¯ä¸€æ ·çš„ï¼Œä½†æ˜¯ è®¿é—®æ¡ä»¶ä¸ä¸€æ · å¯¹äºä¸­åºéå†ï¼š å·¦å­©å­ä¸ºç©ºï¼Œè®¿é—®æ ¹èŠ‚ç‚¹å³å­©å­æ—¶ã€‚æ‰€ä»¥ï¼Œä»£ç åªéœ€ä¿®æ”¹ä¸€å¤„ï¼š 12345678910111213141516171819202122232425262728293031323334public void inOrderTraverse(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode pNode = root; // *æ ˆç©ºä¾æ—§å¯èƒ½æ²¡éå†å®Œï¼ˆå¦‚ï¼Œè®¿é—®å³å­©å­ä½†æ²¡å‹å…¥ï¼‰ while (pNode != null || !stack.isEmpty()) &#123; // *è¿™ä¸ªæ¡ä»¶æ˜“å¿˜ï¼šè¾“å‡ºç©ºèŠ‚ç‚¹æ•°å€¼ if (pNode != null) // *è¿™é‡Œä¸ç”¨whileæ›´ç®€æ´ &#123; // ã€å‰åºéå†è¾“å‡ºã€‘ // System.out.print(node.val+&quot; &quot;); // å‹å…¥æ ˆæ˜¯ä¸ºäº†èµ°åˆ°ç©ºèŠ‚ç‚¹ï¼Œå¯ä»¥é€€å›åˆ°æ ¹èŠ‚ç‚¹ // è¿›è€Œå¯ä»¥è®¿é—®åŒçº§å³å­©å­ï¼ˆæ¨¡æ‹Ÿé€’å½’ï¼‰ stack.push(pNode); // æ²¿ç€ä¸‹ä¸€ä¸ªå·¦å­©å­èµ° pNode = pNode.left; &#125; else //å¦‚æœ pNode == null ä¸”æ ˆä¸åŒ &#123; // ä¸€ä¸ªèŠ‚ç‚¹ã€å·¦å³å­©å­éƒ½è¢«è®¿é—®ã€‘å³pop // è™½ç„¶ä¸æ˜¯å­æ ‘ï¼Œä½†è¿™é‡Œç¬¦åˆé€’å½’è°ƒç”¨é€»è¾‘ TreeNode node = stack.pop(); //ã€ä¸­åºéå†è¾“å‡ºã€‘ System.out.print(node.val+&quot; &quot;); // å³å­©å­ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼ˆnodeå³å­æ ‘ï¼‰ï¼Œé‡å¤ä»¥ä¸Š pNode = node.right; &#125; &#125;&#125; ååºéå† éé€’å½’ååºéå†è¿™ä¸ªåˆ†ææ¯”è¾ƒæ¸…æ™°ï¼šäºŒå‰æ ‘éå†(å…ˆåºã€ä¸­åºã€ååº) å¦‚å‰æ‰€è¿°ï¼š [*] ç„¶è€Œã€ååºã€‘éé€’å½’ï¼Œå¿…é¡»è¦ï¼šåˆ¤æ–­èŠ‚ç‚¹å·¦å³å­æ ‘éƒ½è®¿é—®å®Œï¼Œæ‰å¯ä»¥popå¹¶è¾“å‡ºå…¶å€¼ã€‚å¦‚æœåªæ˜¯å¦‚å‰/ä¸­åºéé€’å½’ï¼šå·¦å­æ ‘è®¿é—®å®Œï¼Œè®¿é—®å³å­©å­å°±pop&amp;è¾“å‡ºå…¶å€¼ï¼Œä¸ç¬¦åˆå®é™…é€’å½’ååºè°ƒç”¨ã€‚æ‰€ä»¥éœ€è¦è®¾ç½®åˆ¤æ–­å³å­æ ‘æ˜¯å¦è®¿é—®å®Œæ¯•ï¼Œå†popå’Œè¾“å‡ºã€‚ ä»£ç å“ªä¸€å—éœ€è¦ä¿®æ”¹å‘¢ï¼Ÿ whileå†…éƒ¨å‰é¢ä»£ç ï¼šä¸€ç›´æ²¿èŠ‚ç‚¹å·¦å­©å­å¾€ä¸‹èµ°å¹¶PUSHå…¥æ ˆï¼Œç›´è‡³==null ã€‚ç¬¦åˆå®é™…é€’å½’é€»è¾‘ï¼Œä¸ç”¨ä¿®æ”¹ã€‚æ‰€ä»¥ï¼Œå®é™…æ˜¯å¦‚ä½•å¯¹åç»­â€œå¾€å³èµ°â€åçš„é€»è¾‘ä¿®æ”¹ï¼Œå¢åŠ å¯¹å³å­æ ‘æ˜¯å¦è®¿é—®å®Œæ¯•ï¼Œè¿›è€Œæ˜¯å¦å‡ºæ ˆpopã€‚ å¦‚ä½•åˆ¤æ–­å³å­æ ‘æ˜¯å¦è®¿é—®å®Œæ¯•å‘¢ï¼Ÿ å¦‚æœç›´æ¥æ€è€ƒå³å­æ ‘æ˜¯å¦è¢«è®¿é—®ï¼Œéš¾ä»¥å¾—å‡ºå¥½çš„æ–¹æ³•ã€‚å¯ä»¥å…ˆè€ƒè™‘ä¸€ç§ç‰¹æ®Šæƒ…å†µï¼šå¦‚æœå¾€å³èµ°æ—¶ï¼Œå³å­©å­ä¸ºç©º å³å­©å­==nullï¼Œåˆ™pop å¯¹äºåˆ¤æ–­å³å­æ ‘!=nullï¼Œä½†å·²è®¿é—®ä¹Ÿéœ€popçš„æƒ…å†µã€‚å› ä¸ºæˆ‘ä»¬è®¾ç½®lastVisitæ¥æ ‡è®°ä¸Šä¸€ä¸ªè¢«popçš„èŠ‚ç‚¹ï¼Œå¦‚æœlastVisitæŒ‡å‘çš„èŠ‚ç‚¹çš„å³å­©å­ï¼Œåˆ™è¯´æ˜èŠ‚ç‚¹å³å­æ ‘éƒ½å·²è¢«è®¿é—®å®Œæ¯•å¯ä»¥è¢«popï¼ˆå’Œè¾“å‡ºï¼‰ã€‚ æˆ–è€… lastVisit==èŠ‚ç‚¹.rightï¼Œåˆ™pop ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031// éé€’å½’ååºéå†public void postorderTraversal(TreeNode root)&#123; LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); TreeNode node = root; TreeNode lastVisit = root; // åˆå§‹åŒ–ä¸ºnullï¼Ÿ while (node != null || !stack.isEmpty()) &#123; if (node != null) &#123; stack.push(node); node = node.left; &#125; node = stack.peek(); //å¦‚æœå…¶å³å­æ ‘ä¹Ÿä¸ºç©ºï¼Œæˆ–è€…å³å­æ ‘å·²ç»è®¿é—® //åˆ™å¯ä»¥ç›´æ¥è¾“å‡ºå½“å‰èŠ‚ç‚¹çš„å€¼ if (node.right == null || node.right == lastVisit) &#123; System.out.print(node.val + &quot; &quot;); stack.pop(); lastVisit = node; node = null; &#125; else &#123; //å¦åˆ™ï¼Œç»§ç»­éå†å³å­©å­ä¸ºæ–°æ ¹èŠ‚ç‚¹ï¼Œå¾€å·¦èµ° node = node.right; &#125; &#125;&#125; åŠ¨æ€è§„åˆ’ å‚è€ƒæ•™ç¨‹ï¼šå‘Šåˆ«åŠ¨æ€è§„åˆ’ï¼Œè¿åˆ· 40 é“é¢˜ï¼Œæˆ‘æ€»ç»“äº†è¿™äº›å¥—è·¯ï¼Œçœ‹ä¸æ‡‚ä½ æ‰“æˆ‘ åŠ¨æ€è§„åˆ’è§£ææ ¸å¿ƒå››ä¸ªæ¡ä»¶ï¼Œä»¥æ–æ³¢é‚£å¥‘æ•°åˆ—ä¸ºä¾‹ï¼š çŠ¶æ€å®šä¹‰ï¼š è®¾ $dp$ ä¸ºä¸€ç»´æ•°ç»„ï¼Œå…¶ä¸­ d$p[i]$ çš„å€¼ä»£è¡¨ æ–æ³¢é‚£å¥‘æ•°åˆ—ç¬¬ $i$ ä¸ªæ•°å­— ã€‚ è½¬ç§»æ–¹ç¨‹ï¼š $dp[i + 1] = dp[i] + dp[i - 1]$ ï¼Œå³å¯¹åº”æ•°åˆ—å®šä¹‰$ f(n + 1) = f(n) + f(n - 1)$ ï¼› åˆå§‹çŠ¶æ€ï¼š $dp[0] = 1,dp[1]=1$ ï¼Œå³åˆå§‹åŒ–å‰ä¸¤ä¸ªæ•°å­—ï¼› è¿”å›å€¼ï¼š $dp[n]$ï¼Œå³æ–æ³¢é‚£å¥‘æ•°åˆ—çš„ç¬¬ $n$ ä¸ªæ•°å­—ã€‚ ä»¥ä¸‹æ¡ˆä¾‹åˆ†æã€‚ é’è›™è·³å°é˜¶ï¼ˆ1ç»´dpï¼‰ é—®é¢˜æè¿° ä¸€åªé’è›™ä¸€æ¬¡å¯ä»¥è·³ä¸Š1çº§å°é˜¶ï¼Œä¹Ÿå¯ä»¥è·³ä¸Š2çº§ã€‚æ±‚è¯¥é’è›™è·³ä¸Šä¸€ä¸ªnçº§çš„å°é˜¶æ€»å…±æœ‰å¤šå°‘ç§è·³æ³•ã€‚ è§£æ³•åˆ†æ å‚è€ƒé¢è¯•é¢˜10- II. é’è›™è·³å°é˜¶é—®é¢˜ï¼ˆåŠ¨æ€è§„åˆ’ï¼Œæ¸…æ™°å›¾è§£ï¼‰ åŒä¸Šåˆ†ææˆ‘ä»¬å¯ä»¥å¾—å‡ºä»£ç ï¼š 123456789101112131415161718192021public int numWays(int n)&#123; if (n &lt;= 1) return 1; // çŠ¶æ€å®šä¹‰ï¼šdp[i]è¡¨ç¤ºè·³åˆ°ç¬¬iä¸ªå°é˜¶çš„æ–¹å¼ int[] dp = new int[n + 1]; // åˆå§‹çŠ¶æ€ dp[1] = 1; dp[2] = 2; // è½¬ç§»æ–¹ç¨‹ï¼šè·³åˆ°ç¬¬nä¸ªå°é˜¶çš„æ–¹å¼d[n] // -ä»ç¬¬n-1â†’è·³åˆ°nï¼Œè·³åˆ°ç¬¬n-1ä¸ªå°é˜¶æœ‰d[n-1]æ–¹å¼ï¼Œç¬¬n-1â†’è·³åˆ°næœ‰ // 1ç§æ–¹å¼ï¼ˆè·³1é˜¶ï¼‰ï¼Œæ•…æœ‰d[n-1]*1 // -ä»ç¬¬n-2â†’è·³åˆ°nï¼Œè·³åˆ°ç¬¬n-2ä¸ªå°é˜¶æœ‰d[n-2]æ–¹å¼ï¼Œç¬¬n-1â†’è·³åˆ°næœ‰ // 1ç§æ–¹å¼ï¼ˆè·³2é˜¶ï¼‰ï¼Œæ•…æœ‰d[n-2]*1 // ä¸€å…±æ˜¯ï¼šd[n-1]+d[n-2] for (int i = 3; i &lt;= n; i++) dp[i] = dp[i - 1] + dp[i - 2]; // è¿”å›å€¼ return dp[n]; &#125; ä¸åŒè·¯å¾„Iï¼ˆäºŒç»´dpï¼‰ é¢˜ç›®æè¿° ä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª m x n ç½‘æ ¼çš„å·¦ä¸Šè§’ï¼Œæœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚æœºå™¨äººè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’ï¼Œä¸€å…±æœ‰å¤šå°‘ç§è·¯å¾„ï¼Ÿ è§£æ³•åˆ†æ æŒ‰ç…§ä¹‹å‰åŠ¨æ€è§„åˆ’å››æ­¥èµ°ï¼š çŠ¶æ€å®šä¹‰ï¼š $d[i][j]$ è¡¨ç¤ºç§»åŠ¨åæ ‡ä¸º$(i,j)$ çš„è·¯å¾„æ–¹å¼ è½¬ç§»æ–¹ç¨‹ï¼š $$(i,j)$$åªèƒ½ç”±å·¦è¾¹ $(i-1,j)$â†’å³åˆ°$(i,j)$ æˆ–è€…$(i,j-1)$â†’ä¸‹åˆ° $(i,j)$ï¼Œæ‰€ä»¥ç±»ä¼¼é’è›™è·³å°é˜¶ï¼š $d[i][j]$ = $d[i-1][j]$ + $d[i][j-1]$ PS: è¿™æ ·æ€è€ƒä¸ä¹Ÿä¼šæœ‰é‡å¤è·¯å¾„äº§ç”Ÿ è¿”å›çŠ¶æ€ï¼š $d[n-1][m-1]$ åˆå§‹å€¼ï¼š å¯¹äºçŠ¶æ€æ–¹ç¨‹ $d[i][j]$ = $d[i-1][j]$ + $d[i][j-1]$ ï¼Œå¿…é¡»æ˜¯$i&gt;0,j&gt;0$ æ‰æˆç«‹ï¼Œæ‰€ä»¥åˆå§‹çŠ¶æ€åº”è¯¥æ˜¯$d[0][j]=1$ , $d[i][0]=1$ ã€‚è¡¨ç¤ºå¦‚æœåæ ‡$(i,j)$æ˜¯åœ¨ç¬¬ä¸€åˆ—æˆ–è€…ç¬¬ä¸€è¡Œï¼Œåªèƒ½ä¸€ç›´å‘ä¸‹èµ° æˆ– å‘å³èµ°è¿™ä¸€ç§æ–¹å¼ ä»£ç å®ç° 123456789101112131415161718192021222324252627282930public int uniquePaths (int m, int n) &#123; // åŠ¨æ€è§„åˆ’ // 1.çŠ¶æ€å®šä¹‰ï¼šdp[i][j]è¡¨ç¤ºèµ°åˆ°å½“å‰ä½ç½®(i,j)ä¸åŒè·¯å¾„æ•° // 2.è½¬ç§»æ–¹ç¨‹ï¼šä½ç½®(i,j)å¯ä»¥ç”± // 1ï¼‰(i-1,j)å‘å³èµ°(i,j) // 2ï¼‰(i,j-1)å‘ä¸‹èµ°(i,j) // æ‰€ä»¥èµ°åˆ°(i,j)çš„æ€»è·¯å¾„æ•°dp[i,j]=dp[i-1,j]+dp[i,j-1] // 3.åˆå§‹å®šä¹‰ï¼šåˆå§‹åŒ–dp[0,j] å’Œ dp[i,0] // 4.è¿”å›å€¼ï¼šè¿”å›dp[m-1][n-1] if(m==1 || n==1) return 1; // çŠ¶æ€å®šä¹‰ int[][] dp = new int[m][n]; // åˆå§‹å®šä¹‰ for(int i=0 ; i&lt;m ; i++) dp[i][0]=1; for(int j=0 ; j&lt;n ; j++) dp[0][j]=1; // è½¬ç§»æ–¹ç¨‹ for(int i=1 ; i&lt;m ; i++) for(int j=1 ; j&lt;n ; j++) dp[i][j]=dp[i-1][j]+dp[i][j-1]; // è¿”å› return dp[m-1][n-1]; &#125; ä¸åŒè·¯å¾„IIï¼ˆäºŒç»´dpï¼‰ é¢˜ç›®æè¿° ç»™å®šä¸€ä¸ª n * m çš„çŸ©é˜µ aï¼Œä»å·¦ä¸Šè§’å¼€å§‹æ¯æ¬¡åªèƒ½å‘å³æˆ–è€…å‘ä¸‹èµ°ï¼Œæœ€ååˆ°è¾¾å³ä¸‹è§’çš„ä½ç½®ï¼Œè·¯å¾„ä¸Šæ‰€æœ‰æ•°å­—ç´¯åŠ å°±æ˜¯è·¯å¾„å’Œï¼Œè¾“å‡ºæ‰€æœ‰è·¯å¾„ä¸­æœ€å°è·¯å¾„å’Œã€‚ è§£æ³•åˆ†æ æŒ‰ç…§ä¹‹å‰åŠ¨æ€è§„åˆ’å››æ­¥èµ°ï¼š çŠ¶æ€å®šä¹‰ï¼š $d[i][j]$ è¡¨ç¤ºç§»åŠ¨åæ ‡ä¸º$(i,j)$ çš„è·¯å¾„ä¹‹å’Œæœ€å°æ–¹å¼çš„å€¼ è½¬ç§»æ–¹ç¨‹ï¼š $$(i,j)$$åªèƒ½ç”±å·¦è¾¹ $(i-1,j)$â†’å³åˆ°$(i,j)$ æˆ–è€…$(i,j-1)$â†’ä¸‹åˆ° ï¼Œ$(i,j)$ ï¼Œæ¯”è¾ƒ $d[i-1][j]$ å’Œ $d[i][j-1]$ å¤§å°å–è¾ƒå°å€¼åŠ ä¸Š $places[i][j]$ ä¾¿æ˜¯æœ€å°è·¯å¾„ä¹‹å’Œï¼š$$d[i][j] = d[i-1][j]&lt;d[i][j-1]?d[i-1][j]+places[i][j]ï¼šd[i][j-1]+places[i][j]â€‹$$ è¿”å›çŠ¶æ€ï¼š $d[n-1][m-1]$ åˆå§‹å€¼ï¼š å¯¹äºçŠ¶æ€æ–¹ç¨‹ $d[i][j]$ = $d[i-1][j]$ + $d[i][j-1]$ ï¼Œå¿…é¡»æ˜¯$i&gt;0,j&gt;0$ æ‰æˆç«‹ï¼Œæ‰€ä»¥åˆå§‹çŠ¶æ€åº”è¯¥æ˜¯ï¼š$d[0][j]=\\sum_j places[0][j]$ (å‘ä¸‹èµ°è·¯å¾„ä¹‹å’Œï¼Œç”±äºåªèƒ½å‘å³å’Œå‘ä¸‹ï¼Œæ‰€ä»¥ç¬¬ä¸€åˆ—ä¸Šçš„ä½ç½®åªèƒ½ä¸€ç›´å¾€ä¸‹èµ°) ï¼›åŒç†ï¼Œç¬¬ä¸€è¡Œä¸Šä½ç½®ï¼Œ$d[i][0]=\\sum_i places[i][0]$ ã€‚ ä»£ç å®ç° 1234567891011121314151617181920public int minPathSum (int[][] matrix) &#123; int n = matrix.length; // è¡Œï¼Œä¸€ç»´çŸ©é˜µä¸ªæ•° int m = matrix[0].length; // åˆ—ï¼Œä¸€ç»´æ•°ç»„é•¿åº¦ // çŠ¶æ€å®šä¹‰ int[][] dp = new int[n][m]; // åˆå§‹å€¼ dp[0][0] = matrix[0][0]; for(int i=1; i&lt;n; i++) dp[i][0] = dp[i-1][0] + matrix[i][0]; for(int j=1; j&lt;m; j++) dp[0][j] = dp[0][j-1] + matrix[0][j]; // é€’æ¨&amp;è½¬ç§»æ–¹ç¨‹ for(int i=1; i&lt;n; i++) for(int j=1; j&lt;m; j++) dp[i][j] = dp[i-1][j]&lt;dp[i][j-1]? dp[i-1][j]+matrix[i][j]: dp[i][j-1]+matrix[i][j]; return dp[n-1][m-1]; &#125; ç¼–è¾‘å­—ç¬¦ï¼ˆäºŒç»´dpï¼‰ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ çŠ¶æ€å®šä¹‰æ¯”è¾ƒéš¾æƒ³åˆ°ï¼Œè¿˜éœ€å¤šåšé¢˜ã€‚è½¬ç§»æ–¹ç¨‹ä¹Ÿå¾ˆéš¾å†™ï¼Œç›´æ¥çœ‹ leetcodeé¢˜è§£-ç¼–è¾‘è·ç¦» å§ã€‚ åŠ¨æ€è§„åˆ’å››æ­¥èµ°ï¼š çŠ¶æ€å®šä¹‰ï¼š $d[i][j]$ è¡¨ç¤ºä»é•¿åº¦ä¸º$i$ çš„word1è½¬ä¸ºä¸ºé•¿åº¦ä¸º$j$çš„word2æ‰€éœ€æœ€å°‘æ“ä½œæ•° è½¬ç§»æ–¹ç¨‹ï¼š è¿”å›çŠ¶æ€ï¼š $d[n][m]$ åˆå§‹å€¼ï¼š åŒå‰ï¼Œä¿è¯$iï¼Œj&gt;0$ æˆç«‹ï¼Œæ‰€ä»¥åˆå§‹çŠ¶æ€åº”è¯¥æ˜¯ï¼š$d[0][j]=\\sum_{j=0} j+1$ ï¼Œ $d[i][0]=\\sum_{i=0} i+1$ ä»£ç å®ç° 123456789101112131415161718192021222324252627282930313233343536 class Solution &#123; public int minDistance(String word1, String word2) &#123; int n = word1.length(); int m = word2.length(); // æœ‰ä¸€ä¸ªå­—ç¬¦ä¸²ä¸ºç©ºä¸² if (n * m == 0) &#123; return n + m; &#125; // DP æ•°ç»„ int[][] D = new int[n + 1][m + 1]; // è¾¹ç•ŒçŠ¶æ€åˆå§‹åŒ– for (int i = 0; i &lt; n + 1; i++) &#123; D[i][0] = i; &#125; for (int j = 0; j &lt; m + 1; j++) &#123; D[0][j] = j; &#125; // è®¡ç®—æ‰€æœ‰ DP å€¼ for (int i = 1; i &lt; n + 1; i++) &#123; for (int j = 1; j &lt; m + 1; j++) &#123; int left = D[i - 1][j] + 1; int down = D[i][j - 1] + 1; int left_down = D[i - 1][j - 1]; if (word1.charAt(i - 1) != word2.charAt(j - 1)) &#123; left_down += 1; &#125; D[i][j] = Math.min(left, Math.min(down, left_down)); &#125; &#125; return D[n][m]; &#125;&#125; é“¾è¡¨æ“ä½œ åŸºæœ¬é“¾è¡¨å®ç°ï¼Œå«åˆ é™¤ã€æ’å…¥ç­‰åŸºæœ¬æ“ä½œã€‚ å®šä¹‰ListNode ä½¿ç”¨é€šå¸¸OJ (e.g. ç‰›å®¢ç½‘) ï¼Œçš„èŠ‚ç‚¹å®šä¹‰ï¼š 12345678910public class ListNode&#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; å®šä¹‰LinkList ä¸ºäº†å¼•å…¥å¤´ç»“ç‚¹head ï¼Œå’Œä¸€äº›åŸºæœ¬ï¼ˆå•ï¼‰é“¾è¡¨æ“ä½œã€‚ å¦‚æœä¸å¼•å…¥å¤´ç»“ç‚¹headï¼Œè¿˜è¦ç‰¹åˆ«åˆ¤æ–­è¦ åˆ é™¤/æ’å…¥/â€¦çš„èŠ‚ç‚¹æ˜¯å¦å¤´ç»“ç‚¹ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class LinkList&#123; ListNode head; int len; // ã€åˆå§‹åŒ–ã€‘ LinkList() &#123; // ** head å¿…é¡»åˆå§‹åŒ–ï¼ï¼ head = new ListNode(0); len = 0; &#125; // ã€åˆ é™¤ã€‘ä¸€ä¸ªèŠ‚ç‚¹:å…³é”®åœ¨äºæ‰¾åˆ°è¢«åˆ é™¤èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ public void del(ListNode delNode) &#123; ListNode pre = head; // æ‰¾åˆ°è¢«åˆ é™¤èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ while (pre.next!=delNode) pre = pre.next; // å¼€å§‹åˆ é™¤èŠ‚ç‚¹ // headâ†’..â†’preâ†’delnodeâ†’.. pre.next = delNode.next; delNode.next=null; // *æ›´æ–°é•¿åº¦ len--; &#125; // ã€æ’å…¥ã€‘ä¸€ä¸ªèŠ‚ç‚¹ public void insert(ListNode preNode,ListNode newNode) &#123; // *å°½é‡å…ˆä¸ç ´ååŸå…ˆé“¾æ¥ï¼Œå…ˆæ›´æ–°æ–°èŠ‚ç‚¹newNodeçš„æŒ‡å‘ // å†æ›´æ–°åŸå…ˆèŠ‚ç‚¹preNodeçš„æŒ‡å‘ newNode.next = preNode.next; preNode.next = newNode; //*é•¿åº¦æ›´æ–° len++; &#125; // ã€æ‰“å°ã€‘é“¾è¡¨ public void print () &#123; ListNode tmp = head; while (tmp.next!=null) &#123; System.out.print(tmp.next.val+&quot;â†’&quot;); tmp = tmp.next; &#125; &#125;&#125; åŸºæœ¬ï¼šç¿»è½¬é“¾è¡¨ æä¾›çš„é“¾è¡¨å¤´ç»“ç‚¹æŒ‡å‘ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè€Œéä¼ªèŠ‚ç‚¹ã€‚ 12345678910111213141516171819202122public ListNode ReverseList(ListNode head) &#123; if(head==null) return head; // *p,q,q_next,åˆ†åˆ«è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå½“å‰èŠ‚ç‚¹ï¼Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹ // *ä¸ºäº†æ“ä½œç»Ÿä¸€ï¼Œpæœ€å¼€å§‹æŒ‡å‘nullï¼ï¼ ListNode p = null; ListNode q = head,q_next=null; while(q!=null) &#123; // *ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ›´æ–°æ”¾åœ¨å¾ªç¯å¼€å§‹ï¼Œè€Œéæœ«å°¾ // é¿å…q.next==nullæ—¶ï¼Œq.next.nextèµ‹å€¼ç»™q.nextå‡ºé”™ q_next = q.next; // æ”¹å˜qæŒ‡å‘ q.next=p; // *æ›´æ–°å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå½“å‰æ›´æ–°p,qèŠ‚ç‚¹åªèƒ½åœ¨å¾ªç¯æœ«å°¾ // å› ä¸ºåé¢ä»£ç q.next=pï¼Œè¦æ“ä½œpï¼Œqï¼Œåœ¨æ­¤ä¹‹å‰ä¸èƒ½æ›´æ–°pï¼Œq p=q; q=q_next; &#125; return p; &#125; åŸºæœ¬ï¼šæ˜¯å¦æœ‰ç¯ ç»ˆæ­¢æ¡ä»¶è®°ä¸‹ã€‚ 1234567891011121314151617181920212223public boolean hasCycle(ListNode head) &#123; // æ€è·¯1ï¼šå¿«æ…¢æŒ‡é’ˆï¼ˆtrickï¼‰ï¼Œæœ€ä¼˜è§£ï¼ŒO(1)å¤æ‚åº¦ // æ€è·¯2ï¼šhashmapå­˜ä¸‹æ‰€æœ‰èŠ‚ç‚¹ï¼Œç„¶åéå†èŠ‚ç‚¹å°±å»åˆ¤æ–­æ˜¯å¦åœ¨hashmapä¸­ // *è¦å…ˆåˆ¤æ–­head==nullçš„æƒ…å†µ if(head==null) return false; ListNode step1 = head; ListNode step2 = head; while(step2!= null &amp;&amp; step2.next != null) &#123; // å¥½åƒä¸ä¼šå‡ºç°step1==nullçš„æƒ…å†µï¼Ÿ // å› ä¸ºã€å¦‚æœæœ‰ç¯ã€‘ä¼šåœ¨å¿«æŒ‡é’ˆèµ°åˆ°ç»ˆç‚¹å‰å°±ç›¸é‡ step1 = step1.next; // å¾ªç¯ç»ˆæ­¢æ¡ä»¶ä»è¿™é‡Œå¾—åˆ° step2 = step2.next.next; // *ä¸èƒ½åœ¨å‰é¢åˆ¤æ–­ï¼Œå› ä¸ºåˆå§‹step1==step2 if(step1==step2) return true; &#125; return false; &#125; åŸºæœ¬ï¼šåˆå¹¶é“¾è¡¨ é«˜é¢‘å‡ºç°ã€‚ 1234567891011121314151617181920212223242526272829public ListNode mergeList(ListNode head1,ListNode head2) &#123; ListNode head = new ListNode(0); // *ä¿ç•™headï¼Œä½¿ç”¨å·¥ä½œæŒ‡é’ˆh ListNode h = head; while(head1 != null &amp;&amp; head2 != null) &#123; if(head1.val&lt;head2.val) &#123; h.next = head1; head1 = head1.next; &#125; else &#123; h.next = head2; head2 = head2.next; &#125; // *æŒ‡å‘åˆå¹¶é“¾è¡¨æœ«å°¾ h = h.next; &#125; // å‰©ä¸‹æœªæ’åºå®Œæˆçš„ if(head1 != null) h.next = head1; else h.next = head2; return head.next; &#125; åŸºç¡€ï¼šåˆ é™¤é‡å¤æ•° ä¸çŸ¥é“ä¸ºå•¥ï¼Œæˆ‘åˆ é™¤é‡å¤ä»£ç è®°å¾—å¥½ç‰¢é ã€‚ã€‚ 123456789101112131415161718192021222324252627public ListNode deleteDuplicates (ListNode head) &#123; if(head == null || head.next == null) return head; // æ€è·¯(ä¿è¯ä¸‹é¢é“¾è¡¨è‡³å°‘æœ‰2ä¸ªèŠ‚ç‚¹) // 1.è®¾ç½®åˆå§‹å·¥ä½œæŒ‡é’ˆpre=head,p=head.next // preæŒ‡å‘çš„å¾…åˆ é™¤é‡å¤æ•°åœ¨é“¾è¡¨æ’åºæœ€å‰çš„æ•°å­— // 2.å¦‚æœpre.val = p.val,åˆ™åˆ é™¤pæŒ‡å‘çš„èŠ‚ç‚¹,på¾€åç§»åŠ¨ // 3.å¦‚æœä¸ç­‰ï¼Œè¯´æ˜preæŒ‡å‘çš„æ•°å­—ä¸å­˜åœ¨é‡å¤æ•°ï¼Œ // preå’Œpéƒ½å¾€åç§»åŠ¨ï¼Œç›´è‡³pä¸ºnullé€€å‡ºå¾ªç¯ ListNode pre = head, p = head.next; while(p!=null) &#123; if(pre.val == p.val) &#123; pre.next = p.next; p = p.next; &#125; else &#123; pre = pre.next; p = p.next; &#125; &#125; return head; &#125; 1.2 æ•°ç»„ã€çœ‹ã€‘NC61: ä¸¤æ•°ä¹‹å’Œ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ æš´åŠ›è§£æ³•ï¼Œæ¯”è¾ƒè€—æ—¶ï¼šå¯¹æ•°ç»„æ¯ä¸ªå…ƒç´ ï¼ˆå¾ªç¯1ï¼‰ï¼Œå»éå†å‰©ä½™çš„å…ƒç´ æ‰¾åˆ°è¡¥è¶³æ•°å¹¶è¿”å›ä¸‹æ ‡ï¼ˆå¾ªç¯2ï¼‰ã€‚ ï¼ˆå¾ªç¯2ï¼‰å¯è½¬æ¢ä¸º â€œåœ¨æ•°ç»„ä¸­æ‰¾åˆ° æŒ‡å®šæ•° çš„ä¸‹æ ‡â€ ï¼Œå¯ä»¥è€ƒè™‘å¯¹æ•°ç»„å»ºç«‹ä»¥ï¼šå…ƒç´ ä¸ºkeyï¼Œä¸‹æ ‡ä¸ºvalue çš„HashMap ã€‚å¯¹äºå·²çŸ¥çš„keyï¼ˆæŒ‡å®šæ•°ï¼‰ï¼ŒHashMap å¯åœ¨O(1) æ—¶é—´æ‰¾åˆ°ï¼Œè€Œéæ¯æ¬¡éå†å…¶ä½™æ•°ç»„å‰©ä¸‹æ•°O(n)ã€‚ ä»£ç å®ç° 1234567891011121314151617181920public int[] twoSum (int[] numbers, int target) &#123; // write code here HashMap&lt;Integer , Integer&gt; dic = new HashMap(); // ä¸€æ¬¡éå†å»ºç«‹hashmap for(int i=0; i&lt; numbers.length; i++) dic.put(numbers[i],i); // éå†æ¯ä¸ªå…ƒç´ æ‰¾åˆ°è¡¥è¶³æ•° int[] res = new int[2]; for(int i=0; i&lt; numbers.length-1; i++) &#123; Object complemetNumIdx = dic.get(target-numbers[i]); if (complemetNumIdx!=null &amp;&amp; (Integer) complemetNumIdx != i) &#123; // *iä¸€å®š&lt;complemetNumIdxï¼Œä¸ç”¨åˆ¤æ–­å¤§å° return new int[]&#123;i+1,(Integer) complemetNumIdx+1&#125;; &#125; &#125; return null ; &#125; NC22: åˆå¹¶æ•°ç»„ ã€å¥—è·¯ã€‘ã€å½’å¹¶ã€‘ï¼šä¸¤ä¸ªæœ‰åºå­æ•°ç»„å½’å¹¶æ’åº é¢˜ç›®æè¿° è§£æ³•æ€è·¯ å¥—è·¯ï¼šè®¾ç½®ä¸‰ä¸ªæŒ‡é’ˆiï¼Œjï¼Œk åˆ†åˆ«æŒ‡å‘ï¼šæ•°ç»„Aæœ«å°¾å…ƒç´ ã€æ•°ç»„Bæœ«å°¾å…ƒç´ ï¼Œæ•°ç»„Aç´¢å¼•$m+n-1$ å¤„ã€‚æ¯æ¬¡æŒ‡é’ˆi ä¸j è¿›è¡Œå¯¹æ¯”ï¼Œå–è¾ƒå¤§è€…å…ƒç´ æ”¾ç½®æŒ‡é’ˆk å¤„ï¼Œä¸”å¯¹åº”æŒ‡é’ˆï¼ˆiæˆ–jï¼‰ ä¸kå¾€å‰ç§»åŠ¨ã€‚ç›´è‡³i æˆ–j &lt;0ï¼ˆnullï¼‰ï¼Œå¤„ç†è¾¹ç•Œæƒ…å†µï¼š æ•°ç»„Aæœªéå†å®Œï¼ˆi&gt;0ï¼‰ï¼šç”±äºæ˜¯å¯¹Aæ“ä½œï¼Œå·²ç»æœ‰åºäº†ï¼Œç»“æŸ æ•°ç»„Bæœªéå†å®Œï¼ˆj&gt;0ï¼‰ï¼šè¯´æ˜Bå‰©ä½™å…ƒç´ éƒ½å°äºAä¸­å…ƒç´ ï¼ŒAæ‰€æœ‰å…ƒç´ éƒ½å·²ç§»åŠ¨è‡³åï¼ŒæŒ‡é’ˆj ç»§ç»­å¾€å‰ç§»åŠ¨ï¼Œå°†Bå‰©ä½™å…ƒç´ ç›´æ¥æ’å…¥Aä¸­å³å¯ã€‚ ä»£ç å®ç° *ä¸€ä¸ªè ¢è ¢é”™è¯¯ï¼šæ•°ç»„Bå…¨éƒ¨ç”¨æ•°ç»„Aã€‚ 123456789101112131415public void merge(int A[], int m, int B[], int n) &#123; // å®šä¹‰ä¸‰ä¸ªæŒ‡é’ˆ int qa= m-1,qb=n-1,qc=m+n-1; // å¾ªç¯éå†ï¼šä»å°¾éƒ¨å¼€å§‹ for (int i=qc; i&gt;=0 ; i--) &#123; if(qb&lt;0) // æ•°ç»„Béå†ç»“æŸ return; if(qa&lt;0) // æ•°ç»„Aéå†ç»“æŸï¼Œä½†Bæœªç»“æŸ A[qc--] = B[qb--]; else A[qc--] = A[qa]&gt;B[qb]? A[qa--]:B[qb--]; &#125; &#125; NC38: èºæ—‹çŸ©é˜µ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ å¯¹äºè¿™ç§å¤šå±‚é€’å½’å¾ªç¯é—®é¢˜ï¼Œé€šè¿‡ä»ç‰¹ä¾‹æ€è€ƒï¼Œæ¯”å¦‚ï¼šå¦‚ä½•éå†æœ€å¤–å±‚çŸ©é˜µå…ƒç´ è¾“å‡ºï¼Ÿ å‡ºå‘ä½ç½®ï¼šâ†’å‘å³å‡ºå‘ï¼Œè¶…å‡ºå³ä¾§è¾¹ç•Œåˆ™åœä¸‹ï¼›â†“æ¥ç€å¾€ä¸‹ï¼Œè¶…å‡ºä¸‹ä¾§è¾¹ç•Œåˆ™åœä¸‹ï¼›â†å¾€å·¦ç»§ç»­ï¼Œè¶…å‡ºå·¦ä¾§è¾¹ç•Œåˆ™åœä¸‹ï¼›â†‘å‘ä¸Šç»§ç»­ï¼Œå³å°†åˆ°è¾¾åˆå§‹ä½ç½®åˆ™åœä¸‹ã€‚ è¿™æ ·æœ€å¤–å±‚éå†ä¾¿æ˜äº†äº†ï¼Œå¯¹äºå†…å±‚çŸ©é˜µç»§ç»­å¾ªç¯è¾“å‡ºæœ‰ä»€ä¹ˆä¸ä¸€æ ·å—ï¼Ÿ å‡ºå‘ä½ç½®å˜åŒ–ï¼ˆå·¦ä¸Šï¼‰ï¼šä¸‹ä¸€å±‚çŸ©é˜µå¾ªç¯ï¼Œå‡ºå‘ä½ç½®æ¨ªçºµåæ ‡å‡+1 è¾¹ç•Œä½ç½®å˜åŒ–ï¼ˆå³ä¸‹ï¼‰ï¼šè¾¹ç•Œä½ç½®-1ï¼ˆçŸ©é˜µæœ€å³ä¾§ç´¢å¼•ï¼Œæœ€ä¸‹ä¾§ç´¢å¼•ä½ç½®ï¼‰ è¿™æ ·æˆ‘ä»¬åªè¦ï¼šå¤–ä¾§å¥—å…¥ä¸€ä¸ªå¾ªç¯ï¼Œå°†å‡ºå‘ä½ç½®å’Œè¾¹ç•Œä½ç½®ä½œä¸ºå˜é‡ ï¼Œä¾¿å¯ä»¥éå†æ•´ä¸ªèºæ—‹çŸ©é˜µã€‚å¾ªç¯ç»“æŸæ¡ä»¶ï¼šå·²è¿”å›çš„å…ƒç´ ä¸ªæ•°==çŸ©é˜µå…ƒç´ ä¸ªæ•°ã€‚ ä»£ç å®ç° ä»£ç ä¸€ç›´åœ¨ç‰›å®¢ç½‘é€šè¿‡ä¸äº†ï¼Œä½†æœ¬åœ°æ²¡é—®é¢˜ï¼Ÿ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//NC38 public ArrayList&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; ArrayList&lt;Integer&gt; arr = new ArrayList(); int m = matrix.length; // çŸ©é˜µè¡Œæ•° int n = matrix[0].length; // çŸ©é˜µåˆ—æ•° if(n == 0) // * æ³¨æ„è¾¹ç•Œæ¡ä»¶ return arr; // èºæ—‹é€’å½’æ€è€ƒå¤ªå¤æ‚ï¼Œå…ˆæ€è€ƒå¦‚ä½•éå†ä¸€åœˆ int i,j; // çŸ©é˜µéå†ç´¢å¼• int left = 0 , top=0 , // çŸ©é˜µå·¦ä¸Š right = m-1, bottom = n-1; // çŸ©é˜µå³ä¸‹ // *åˆ¤æ–­æ¡ä»¶ä¸èƒ½æ˜¯&lt;=, ä¼šå¯¼è‡´å†æ¬¡è¿›å…¥å¾ªç¯ while (arr.size() &lt; m*n) // é€’å½’èºæ—‹çŸ©é˜µ &#123; // åˆå§‹çŸ©é˜µéå†ä½ç½® i = left; j = top; while (j&lt;=bottom) // å‘å³ &#123; arr.add(matrix[i][j++]); &#125; j--; i++; // *çŸ©é˜µå³è¾¹ä»ç¬¬äºŒä¸ªå…ƒç´ å¼€å§‹ while (i&lt;=right) // å‘ä¸‹ &#123; arr.add(matrix[i++][j]); &#125; i--; j--; // *ä»çŸ©é˜µä¸‹è¾¹ä»å·¦â†’å³ç¬¬äºŒä¸ªå…ƒç´ å¼€å§‹ while (j&gt;=left) // å‘å·¦ &#123; arr.add(matrix[i][j--]); &#125; j++; i--; // *ä»çŸ©é˜µå·¦è¾¹ä»ä¸‹â†’ä¸Šç¬¬äºŒä¸ªå…ƒç´ å¼€å§‹ while (i &gt; top) // å‘ä¸Š &#123; arr.add(matrix[i--][j]); &#125; // å¼€å§‹ä¸‹ä¸€å†…å±‚çŸ©é˜µéå† left++ ; top++; // æ›´æ–°å†…çŸ©é˜µå·¦ä¸Šä½ç½® right-- ; bottom--; // æ›´æ–°å†…çŸ©é˜µå³ä¸‹ä½ç½® &#125; return arr; &#125; NC12: é‡å»ºäºŒå‰æ ‘ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ æ ‘éå†çš„æ¨¡æ¿ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314public void Traverse(TreeNode root)&#123; // 1.é€’å½’ç»ˆæ­¢æ¡ä»¶ if (root == null) return; // 2.ç¡®å®šæ–°çš„é€’å½’å‚æ•° // do something // 3.é€’å½’æ“ä½œ Traverse(root.left); Traverse(root.right); &#125; å¦‚ä½•å°†æ¨¡æ¿ä»£ç ä¿®æ”¹ä¸ºæˆ‘ä»¬éœ€è¦çš„é‡å»ºäºŒå‰æ ‘çš„ä»£ç ï¼Ÿ 1234public TreeNode reConstructBinaryTree(int [] pre,int [] in)&#123; // code is here &#125; é¦–å…ˆæˆ‘ä»¬å°†é—®é¢˜è½¬æ¢ä¸ºé€’å½’æ€è·¯ï¼š æ ¹æ®å‰åºåºåˆ—ç¬¬ä¸€ä¸ªç»“ç‚¹ç¡®å®šæ ¹ç»“ç‚¹ æ ¹æ®æ ¹ç»“ç‚¹åœ¨ä¸­åºåºåˆ—ä¸­çš„ä½ç½®åˆ†å‰²å‡ºå·¦å³ä¸¤ä¸ªå­åºåˆ— å¯¹å·¦å­æ ‘å’Œå³å­æ ‘åˆ†åˆ«é€’å½’ä½¿ç”¨åŒæ ·çš„æ–¹æ³•ç»§ç»­åˆ†è§£ æ ¹æ®æ¨¡æ¿ä»£ç ï¼Œæˆ‘ä»¬ï¼š ç¡®å®šé€’å½’ç»ˆæ­¢æ¡ä»¶ åŸæ¥ç¡®å®šé€’å½’ç»ˆæ­¢æ˜¯ï¼Œå½“å‰èŠ‚ç‚¹ä¸ºnullï¼š 123// 1.é€’å½’ç»ˆæ­¢æ¡ä»¶ if (root == null) return; ä¸­åºç»™å®šå‚æ•°ä¸ºå‰åºã€ä¸­åºæ•°ç»„preå’Œin , å¯ä»¥é€šè¿‡åˆ¤æ–­æ•°ç»„é•¿åº¦==0åˆ¤æ–­ï¼š 12if(pre.length==0) return null; ç¡®å®šæ–°çš„é€’å½’å‚æ•°preã€in å¯¹äºæ ‘éå†æ¨¡æ¿ï¼Œæ–°çš„é€’å½’å‚æ•°åªéœ€root.left /root.right å¯ç›´æ¥è·å–ã€‚ ä½†å¯¹äºé‡å»ºäºŒå‰æ ‘ï¼Œéœ€è¦æ ¹æ®å‰åºã€ä¸­åºåºåˆ—ç¡®å®šå·¦å³å­æ ‘ï¼Œè¿›è€Œå¾—åˆ°æ–°çš„é€’å½’å‚æ•°pre/ inã€‚ è¿™ä¸€éƒ¨åˆ†ä¸»è¦çŸ¥é“å¦‚ä½•æ ¹æ®å‰åºã€ä¸­åºåºåˆ—ç¡®å®šä¸€æ ¹æ ‘ï¼Œéš¾åº¦ä¸é«˜ã€‚ æ ¹æ®å‰åºpreç¡®å®šæ ‘æ ¹pre[0] æ‰¾åˆ°pre[0] åœ¨ä¸­åºin çš„ä½ç½®root_idx è¿›è€Œç¡®å®šå·¦å³å­æ ‘çš„ä¸­åºã€å‰åºåºåˆ— 123456789// ç¡®å®šæ ¹èŠ‚ç‚¹åœ¨ä¸­åºä¸­ä½ç½®ï¼Œè¿›è€Œåˆ’åˆ†å·¦å³å­æ ‘int rootIdx = findRootIdx(in,pre[0]); // å·¦å­æ ‘çš„ï¼šå‰åºåºåˆ—ï¼Œä¸­åºåºåˆ—(copyOfRange å‡½æ•°ï¼Œå·¦é—­å³å¼€)int[] l_pre = Arrays.copyOfRange(pre, 1, rootIdx + 1);int[] l_in = Arrays.copyOfRange(in, 0, rootIdx);//å³å­æ ‘çš„ï¼šå‰åºåºåˆ—ï¼Œä¸­åºåºåˆ—int[] r_pre = Arrays.copyOfRange(pre, rootIdx+1, pre.length);int[] r_in = Arrays.copyOfRange(in, rootIdx+1, in.length); é€’å½’æ“ä½œ è¿™ä¸€éƒ¨åˆ†ç•¥å¾®éš¾ä»¥ç†è§£: å½“å‰èŠ‚ç‚¹å·¦å­æ ‘éå†å®Œæˆæ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›è¿”å›å®ƒçš„æ ¹èŠ‚ç‚¹ä½œä¸ºå½“å‰èŠ‚ç‚¹çš„å·¦å­©å­ å½“å‰èŠ‚ç‚¹å³å­æ ‘éå†å®Œæˆæ—¶ï¼Œè¿”å›å®ƒçš„æ ¹èŠ‚ç‚¹ä½œä¸ºå½“å‰èŠ‚ç‚¹çš„å³å­©å­ æ— è®ºå·¦å­æ ‘è¿˜æ˜¯å³å­æ ‘ï¼šâ€œéå†å®Œæˆæ—¶â€ ,å‡æŒ‡çš„æ˜¯ä»£ç å°†è¦æ‰§è¡Œå®Œæˆåˆ°å‡½æ•°æœ«å°¾&#125; ã€‚ å³åœ¨ååºä½ç½®ï¼Œè¿”å›å½“å‰èŠ‚ç‚¹ï¼š 12345678910111213// å‰åºæ‰¾åˆ°æ ¹èŠ‚ç‚¹ TreeNode root = new TreeNode(pre[0]);// è¯´æ˜å½“å‰èŠ‚ç‚¹çš„å·¦å­æ ‘å·²ç»è®¿é—®å®Œæ¯•ï¼ˆå³å°†è®¿é—®å³å­æ ‘ï¼‰// è¿”å›çš„æ˜¯å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹ï¼ˆå³å½“å‰èŠ‚ç‚¹çš„å·¦å­©å­ï¼‰// *æ‰€ä»¥å‡½æ•°æœ€åè¿˜è¦ return root; root.left = reConstructBinaryTree(l_pre,l_in);// å³å­æ ‘å®Œæˆæ—¶ root.right = reConstructBinaryTree(r_pre,r_in); // [ååº]*å¿…é¡»è¦è¿”å›å½“å‰èŠ‚ç‚¹(ç”¨æ¥æ„å»ºå·¦å³å­æ ‘) return root; ä»£ç å®ç° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.Arrays;public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; // [é€’å½’ç»ˆæ­¢] æ ¹æ®preå’Œinåˆ¤æ–­ // å‰åºï¼ˆæˆ–ä¸­åºï¼‰é•¿åº¦ä¸º0ï¼Œè¯´æ˜å½“å‰èŠ‚ç‚¹ä¸ºç©ºèŠ‚ç‚¹ if(pre.length==0) return null; // ç¡®å®šæ ¹èŠ‚ç‚¹åœ¨ä¸­åºä¸­ä½ç½®ï¼Œè¿›è€Œåˆ’åˆ†å·¦å³å­æ ‘ int rootIdx = findRootIdx(in,pre[0]); // å·¦å­æ ‘çš„ï¼šå‰åºåºåˆ—ï¼Œä¸­åºåºåˆ—(copyOfRange å‡½æ•°ï¼Œå·¦é—­å³å¼€) int[] l_pre = Arrays.copyOfRange(pre, 1, rootIdx + 1); int[] l_in = Arrays.copyOfRange(in, 0, rootIdx); //å³å­æ ‘çš„ï¼šå‰åºåºåˆ—ï¼Œä¸­åºåºåˆ— int[] r_pre = Arrays.copyOfRange(pre, rootIdx+1, pre.length); int[] r_in = Arrays.copyOfRange(in, rootIdx+1, in.length); // é€’å½’è®¡ç®—k // å‰åºæ‰¾åˆ°æ ¹èŠ‚ç‚¹ TreeNode root = new TreeNode(pre[0]); // è¯´æ˜å½“å‰èŠ‚ç‚¹çš„å·¦å­æ ‘å·²ç»è®¿é—®å®Œæ¯•ï¼ˆå³å°†è®¿é—®å³å­æ ‘ï¼‰ // è¿”å›çš„æ˜¯å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹ï¼ˆå³å½“å‰èŠ‚ç‚¹çš„å·¦å­©å­ï¼‰ // *æ‰€ä»¥å‡½æ•°æœ€åè¿˜è¦ return root; root.left = reConstructBinaryTree(l_pre,l_in); root.right = reConstructBinaryTree(r_pre,r_in); // *å¿…é¡»è¦è¿”å›å½“å‰èŠ‚ç‚¹(ç”¨æ¥æ„å»ºå·¦å³å­æ ‘) return root; &#125; public int findRootIdx(int[] array,int val) &#123; int val_idx = -1; for(int i=0 ; i &lt; array.length; i++) &#123; if (val == array[i]) &#123; val_idx = i; return val_idx; &#125; &#125; return val_idx; &#125; &#125; NC65: æ–æ³¢é‚£å¥‘ é¢˜ç›®æè¿° é¢˜è§£æ€è·¯ æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼ŒåŒæ ·æ˜¯é€’å½’è§£å†³ï¼Œå…³é”®åœ¨äºå¦‚ä½•æ‹†è§£ä¸ºé€’å½’å­é—®é¢˜ï¼Ÿ æ¬²æ±‚F(n) , æ‹†è§£ä¸ºæ±‚F(n-1) å’ŒF(n-2)ä¹‹å’Œ å¯¹äºF(n-1) æ‹†è§£ä¸ºæ±‚F(n-2) å’ŒF(n-3)ä¹‹å’Œ ï¼›F(n-2) æ‹†è§£ä¸ºæ±‚F(n-3) å’ŒF(n-4)ä¹‹å’Œ é‡å¤ä»¥ä¸Šï¼Œç›´è‡³æ‹†è§£ä¸ºå·²çŸ¥çš„F(0)=1 å’ŒF(1)=1ä¹‹å’Œ æ‰€ä»¥ä»£ç å®¹æ˜“å¾—å‡ºï¼š 1234567891011public class Solution&#123; public int Fibonacci(int n) &#123; // ç¬¬0é¡¹æ˜¯0ï¼Œç¬¬1é¡¹æ˜¯ç¬¬ä¸€ä¸ª1,æ¯ä¸€é¡¹ç­‰äºå‰ä¸¤é¡¹ä¹‹å’Œ if(n==0) return 0; if(n==1) return 1; return Fibonacci(n-1)+Fibonacci(n-2); &#125;&#125; ä½†æ˜¯è¿™ç§æ–¹å¼è¿›è¡Œçš„é€’å½’æœ‰å¤ªå¤šé‡å¤è®¡ç®—ï¼Œå¦‚ä¸‹å›¾ï¼š f(2) è¢«é‡å¤è®¡ç®—3æ¬¡ ï¼› f(3) è¢«é‡å¤è®¡ç®—2æ¬¡ ä¸ºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘ç”¨ä¸€ä¸ªæ•°ç»„ï¼ˆæˆ–å­—å…¸ï¼‰æ¥ä¿å­˜å·²è®¡ç®—çš„å€¼ï¼Œä»è€Œå‡å°‘é‡å¤è®¡ç®—ã€‚ ä»£ç å®ç° 12345678910111213141516171819202122232425import java.util.Arrays;public class Solution &#123; int[] res ; public int Fibonacci(int n) &#123; res = new int[n+1]; // *é•¿åº¦==n+1ï¼Œå¦åˆ™res[n]è¶…å‡ºç´¢å¼• Arrays.fill(res,-1); return F(n); &#125; public int F(int n) &#123; if(n==0 || n==1) return n; if(res[n] != -1) return res[n]; return res[n] = F(n-1)+F(n-2); &#125;&#125; NC48: åŠ¨æ•°ç»„æ‰¾å€¼ é¢˜ç›®æè¿° é¢˜ç›®æ€è·¯ leetcodeå®˜æ–¹è§£æ å·²ç»å¾ˆæ¸…æ™°äº†ï¼Œä»…è¡¥å……ä¸€ç‚¹è‡ªå·±æƒ³æ³•ã€‚ æ­¤é¢˜éš¾ç‚¹åœ¨äºï¼šå¦‚ä½•ç”¨äºŒåˆ†æŸ¥æ‰¾æ³•å®ŒæˆæŸ¥æ‰¾ï¼Ÿ é¦–å…ˆï¼Œæ•°ç»„æœ‰åºä»…æ˜¯å¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾çš„å……åˆ†æ¡ä»¶è€Œå¹¶ä¸æ˜¯å¿…è¦æ¡ä»¶ï¼Œå…³é”®åœ¨äºèƒ½å¦ç¡®å®šå¾…æŸ¥æ‰¾çš„æ•°ï¼ˆtargetï¼‰åœ¨ç•Œæ¡©ï¼ˆå¦‚ï¼Œmidï¼‰çš„å“ªä¸€è¾¹ï¼Ÿ å¯¹äºè½¬åŠ¨çš„æ•°ç»„ï¼Œä¾æ—§ä»¥midä¸ºç•Œæ¡©ï¼Œæ ¹æ®è½¬åŠ¨ç‰¹ç‚¹åœ¨midå·¦å³æ•°ç»„å­åºåˆ—å¿…æœ‰ä¸€è¾¹æ˜¯æœ‰åºçš„ã€‚æˆ‘ä»¬å¯ä»¥æ ¹æ®æœ‰åºé‚£è¾¹ç¡®å®štargetæ˜¯å¦åœ¨å…¶ä¸­ï¼Œå¦åˆ™åœ¨å¦å¤–ä¸€è¾¹ï¼š ç¡®å®šå“ªä¸€è¾¹æœ‰åºï¼šå¯¹äºå·¦è¾¹ï¼Œç”±äºè½¬åŠ¨å¯¼è‡´å·¦è¾¹ç•Œå¯èƒ½å­˜åœ¨éæœ‰åºæ•°å­—ï¼Œå¦‚mid&gt;å·¦è¾¹ç•Œåˆ™å·¦è¾¹ä¸€å®šæœ‰åº ï¼›åŒç†ï¼Œmid&lt;å³è¾¹ç•Œåˆ™å³è¾¹æœ‰åºã€‚ æŸ¥æ‰¾targetæ˜¯å¦åœ¨æœ‰åºéƒ¨åˆ†èŒƒå›´å†…ï¼Œå¦‚æœ åœ¨æœ‰åºéƒ¨åˆ†å†…ï¼Œé‡å¤1,2ï¼ˆä½†æ˜¯åˆ¤æ–­æ¡ä»¶å°±æœ‰ç‚¹å¤šä½™äº†ï¼‰ å¦‚æœä¸åœ¨ï¼Œé‡å¤1,2åœ¨æ— åºéƒ¨åˆ†æœç´¢ï¼ˆæ— åºéƒ¨åˆ†ä¾æ—§ç¬¦åˆè½¬åŠ¨ç‰¹ç‚¹ï¼‰ ä»£ç å®ç° 12345678910111213141516171819202122232425262728293031323334353637public int search (int[] A, int target) &#123; if(A==null || A.length==0) return -1; int left=0, right=A.length-1; int mid=-1; while(left&lt;=right) &#123; // *ä½†æ˜¯å¯èƒ½å­˜åœ¨æ­¤æ—¶åˆ’åˆ†çš„æ•°ç»„é•¿åº¦=1ï¼Œleft=right=mid // ä¸”left/rightæ­¤æ—¶ä¸ºæ•°ç»„å·¦/å³è¾¹ç•Œï¼Œä¸‹é¢mid-1/mid+1ä¼šè¶…ç´¢å¼• // å¦‚ [1] æŸ¥æ‰¾0ï¼ˆä¸å­˜åœ¨ï¼‰ï¼Œæ‰€ä»¥å…ˆæ’é™¤è¯¥æƒ…å†µ if(right-left==0 &amp;&amp; A[left]!=target) return -1; mid = (left+right)/2; if(A[mid]==target) return mid; if(A[left]&lt;A[mid]) // å·¦è¾¹æ­¤æ—¶æœ‰åºï¼ˆå³è¾¹ä¹Ÿå¯èƒ½ï¼‰ &#123; // åˆ¤æ–­targetæ˜¯å¦åœ¨å·¦è¾¹æœ‰åºéƒ¨åˆ† if(A[left]&lt;=target &amp;&amp; target&lt;=A[mid-1]) right=mid-1; else // å¦åˆ™åœ¨å³è¾¹æœ‰åºéƒ¨åˆ† left=mid+1; &#125; else // å¦‚æœå·¦è¾¹ä¸æœ‰åºåˆ™å³è¾¹ä¸€å®šæœ‰åº &#123; // åˆ¤æ–­targetæ˜¯å¦åœ¨å³è¾¹æœ‰åºéƒ¨åˆ† if(A[mid+1]&lt;=target &amp;&amp; target&lt;=A[right]) left=mid+1; else // å¦åˆ™åœ¨å·¦è¾¹æ— åºéƒ¨åˆ† right=mid-1; &#125; &#125; return -1; &#125; NC54: 3sum é¢˜ç›®æè¿° è§£æ³•æ€è·¯ å»ºè®®ç›´æ¥çœ‹LeetCodeè§£ç­”æ›´æ¸…æ™° : å¦‚ä½•ä¸€æ­¥æ­¥ä»ä¸‰é‡å¾ªç¯ä¼˜åŒ– é¢˜ç›®ä¸­è¦æ±‚æ‰¾åˆ°æ‰€æœ‰ã€Œä¸é‡å¤ã€ä¸”å’Œä¸º 00 çš„ä¸‰å…ƒç»„ï¼Œè¿™ä¸ªã€Œä¸é‡å¤ã€çš„è¦æ±‚ä½¿å¾—æˆ‘ä»¬æ— æ³•ç®€å•åœ°ä½¿ç”¨ä¸‰é‡å¾ªç¯æšä¸¾æ‰€æœ‰çš„ä¸‰å…ƒç»„ã€‚è¿™æ˜¯å› ä¸ºåœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œæ•°ç»„ä¸­çš„å…ƒç´ å…¨éƒ¨ä¸º 00ï¼Œå³ï¼š 1[0, 0, 0, 0, 0, ..., 0, 0, 0] ä»»æ„ä¸€ä¸ªä¸‰å…ƒç»„çš„å’Œéƒ½ä¸º 0ã€‚å¦‚æœæˆ‘ä»¬ç›´æ¥ä½¿ç”¨ä¸‰é‡å¾ªç¯æšä¸¾ä¸‰å…ƒç»„ï¼Œä¼šå¾—åˆ° $O(N^3) $ä¸ªæ»¡è¶³é¢˜ç›®è¦æ±‚çš„ä¸‰å…ƒç»„ï¼ˆå…¶ä¸­ $N$ æ˜¯æ•°ç»„çš„é•¿åº¦ï¼‰æ—¶é—´å¤æ‚åº¦è‡³å°‘ä¸º $O(N^3)$ã€‚åœ¨è¿™ä¹‹åï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä½¿ç”¨å“ˆå¸Œè¡¨è¿›è¡Œå»é‡æ“ä½œï¼Œå¾—åˆ°ä¸åŒ…å«é‡å¤ä¸‰å…ƒç»„çš„æœ€ç»ˆç­”æ¡ˆï¼Œåˆæ¶ˆè€—äº†å¤§é‡çš„ç©ºé—´ã€‚è¿™ä¸ªåšæ³•çš„æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦éƒ½å¾ˆé«˜ï¼Œå› æ­¤æˆ‘ä»¬è¦æ¢ä¸€ç§æ€è·¯æ¥è€ƒè™‘è¿™ä¸ªé—®é¢˜ã€‚ ã€Œä¸é‡å¤ã€çš„æœ¬è´¨æ˜¯ä»€ä¹ˆï¼Ÿæˆ‘ä»¬ä¿æŒä¸‰é‡å¾ªç¯çš„å¤§æ¡†æ¶ä¸å˜ï¼Œåªéœ€è¦ä¿è¯ï¼š ç¬¬äºŒé‡å¾ªç¯æšä¸¾åˆ°çš„å…ƒç´ ä¸å°äºå½“å‰ç¬¬ä¸€é‡å¾ªç¯æšä¸¾åˆ°çš„å…ƒç´ ï¼› ç¬¬ä¸‰é‡å¾ªç¯æšä¸¾åˆ°çš„å…ƒç´ ä¸å°äºå½“å‰ç¬¬äºŒé‡å¾ªç¯æšä¸¾åˆ°çš„å…ƒç´ ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬æšä¸¾çš„ä¸‰å…ƒç»„ $(a, b, c)$æ»¡è¶³ $a \\leq b \\leq c$ï¼Œä¿è¯äº†åªæœ‰$ (a, b, c)$ è¿™ä¸ªé¡ºåºä¼šè¢«æšä¸¾åˆ°ï¼Œè€Œ $(b, a, c)$ã€$(c,b,a)$ ç­‰ç­‰è¿™äº›ä¸ä¼šï¼Œè¿™æ ·å°±å‡å°‘äº†é‡å¤ã€‚è¦å®ç°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥å°† æ•°ç»„ä¸­çš„å…ƒç´ ä»å°åˆ°å¤§è¿›è¡Œæ’åº ï¼Œéšåä½¿ç”¨æ™®é€šçš„ä¸‰é‡å¾ªç¯å°±å¯ä»¥æ»¡è¶³ä¸Šé¢çš„è¦æ±‚ã€‚ åŒæ—¶ï¼Œå¯¹äºæ¯ä¸€é‡å¾ªç¯è€Œè¨€ï¼Œç›¸é‚»ä¸¤æ¬¡æšä¸¾çš„å…ƒç´ ä¸èƒ½ç›¸åŒï¼Œå¦åˆ™ä¹Ÿä¼šé€ æˆé‡å¤ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œå¦‚æœæ’å®Œåºçš„æ•°ç»„ä¸º: 1[0, 1, 2, 2, 2, 3] æˆ‘ä»¬ä½¿ç”¨ä¸‰é‡å¾ªç¯æšä¸¾åˆ°çš„ç¬¬ä¸€ä¸ªä¸‰å…ƒç»„ä¸º $(0, 1, 2)$ï¼Œå¦‚æœç¬¬ä¸‰é‡å¾ªç¯ç»§ç»­æšä¸¾ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆä»ç„¶æ˜¯ä¸‰å…ƒç»„ $(0, 1, 2)$ï¼Œäº§ç”Ÿäº†é‡å¤ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦å°†ç¬¬ä¸‰é‡å¾ªç¯ã€Œè·³åˆ°ã€ä¸‹ä¸€ä¸ªä¸ç›¸åŒçš„å…ƒç´ ï¼Œå³æ•°ç»„ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´  $3$ï¼Œæšä¸¾ä¸‰å…ƒç»„$ (0, 1, 3)$ã€‚ ä¸‹é¢ç»™å‡ºäº†æ”¹è¿›çš„æ–¹æ³•çš„ä¼ªä»£ç å®ç°ï¼š 12345678910nums.sort()for first = 0 .. n-1 // åªæœ‰å’Œä¸Šä¸€æ¬¡æšä¸¾çš„å…ƒç´ ä¸ç›¸åŒï¼Œæˆ‘ä»¬æ‰ä¼šè¿›è¡Œæšä¸¾ if first == 0 or nums[first] != nums[first-1] then for second = first+1 .. n-1 if second == first+1 or nums[second] != nums[second-1] then for third = second+1 .. n-1 if third == second+1 or nums[third] != nums[third-1] then // åˆ¤æ–­æ˜¯å¦æœ‰ a+b+c==0 check(first, second, third) è¿™ç§æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä»ç„¶ä¸º $O(N^3)$ï¼Œæ¯•ç«Ÿæˆ‘ä»¬è¿˜æ˜¯æ²¡æœ‰è·³å‡ºä¸‰é‡å¾ªç¯çš„å¤§æ¡†æ¶ã€‚ç„¶è€Œå®ƒæ˜¯å¾ˆå®¹æ˜“ç»§ç»­ä¼˜åŒ–çš„ï¼Œå¯ä»¥å‘ç°ï¼Œå¦‚æœæˆ‘ä»¬å›ºå®šäº†å‰ä¸¤é‡å¾ªç¯æšä¸¾åˆ°çš„å…ƒç´  $a$ å’Œ $b$ï¼Œé‚£ä¹ˆåªæœ‰å”¯ä¸€çš„ $c$ æ»¡è¶³ $a+b+c=0$ã€‚å½“ç¬¬äºŒé‡å¾ªç¯å¾€åæšä¸¾ä¸€ä¸ªå…ƒç´ $ bâ€™$æ—¶ï¼Œç”±äº $bâ€™ &gt;b$ï¼Œé‚£ä¹ˆæ»¡è¶³ $a+bâ€™+câ€™=0$ çš„ $câ€™$ä¸€å®šæœ‰ $câ€™ &lt; c$ å³ $câ€™$åœ¨æ•°ç»„ä¸­ä¸€å®šå‡ºç°åœ¨ $c$ çš„å·¦ä¾§ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥ä»å°åˆ°å¤§æšä¸¾ $b$ï¼ŒåŒæ—¶ä»å¤§åˆ°å°æšä¸¾ $c$ï¼Œå³ç¬¬äºŒé‡å¾ªç¯å’Œç¬¬ä¸‰é‡å¾ªç¯å®é™…ä¸Šæ˜¯å¹¶åˆ—çš„å…³ç³»ã€‚ æœ‰äº†è¿™æ ·çš„å‘ç°ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä¿æŒç¬¬äºŒé‡å¾ªç¯ä¸å˜ï¼Œè€Œå°†ç¬¬ä¸‰é‡å¾ªç¯å˜æˆä¸€ä¸ªä»æ•°ç»„æœ€å³ç«¯å¼€å§‹å‘å·¦ç§»åŠ¨çš„æŒ‡é’ˆï¼Œä»è€Œå¾—åˆ°ä¸‹é¢çš„ä¼ªä»£ç ï¼š 123456789101112nums.sort()for first = 0 .. n-1 if first == 0 or nums[first] != nums[first-1] then // ç¬¬ä¸‰é‡å¾ªç¯å¯¹åº”çš„æŒ‡é’ˆ third = n-1 for second = first+1 .. n-1 if second == first+1 or nums[second] != nums[second-1] then // å‘å·¦ç§»åŠ¨æŒ‡é’ˆï¼Œç›´åˆ° a+b+c ä¸å¤§äº 0 while nums[first]+nums[second]+nums[third] &gt; 0 third = third-1 // åˆ¤æ–­æ˜¯å¦æœ‰ a+b+c==0 check(first, second, third) è¿™ä¸ªæ–¹æ³•å°±æ˜¯æˆ‘ä»¬å¸¸è¯´çš„ã€ŒåŒæŒ‡é’ˆã€ï¼Œå½“æˆ‘ä»¬éœ€è¦æšä¸¾æ•°ç»„ä¸­çš„ä¸¤ä¸ªå…ƒç´ æ—¶ï¼Œå¦‚æœæˆ‘ä»¬å‘ç°éšç€ç¬¬ä¸€ä¸ªå…ƒç´ çš„é€’å¢ï¼Œç¬¬äºŒä¸ªå…ƒç´ æ˜¯é€’å‡çš„ï¼Œé‚£ä¹ˆå°±å¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆçš„æ–¹æ³•ï¼Œå°†æšä¸¾çš„æ—¶é—´å¤æ‚åº¦ä» $O(N^2)$ å‡å°‘è‡³ $O(N)$ã€‚ä¸ºä»€ä¹ˆæ˜¯ $O(N)$ å‘¢ï¼Ÿè¿™æ˜¯å› ä¸ºåœ¨æšä¸¾çš„è¿‡ç¨‹æ¯ä¸€æ­¥ä¸­ï¼Œã€Œå·¦æŒ‡é’ˆã€ä¼šå‘å³ç§»åŠ¨ä¸€ä¸ªä½ç½®ï¼ˆä¹Ÿå°±æ˜¯é¢˜ç›®ä¸­çš„ $b$ï¼‰ï¼Œè€Œã€Œå³æŒ‡é’ˆã€ä¼šå‘å·¦ç§»åŠ¨è‹¥å¹²ä¸ªä½ç½®ï¼Œè¿™ä¸ªä¸æ•°ç»„çš„å…ƒç´ æœ‰å…³ï¼Œä½†æˆ‘ä»¬çŸ¥é“å®ƒä¸€å…±ä¼šç§»åŠ¨çš„ä½ç½®æ•°ä¸º $O(N)$ï¼Œå‡æ‘Šä¸‹æ¥ï¼Œæ¯æ¬¡ä¹Ÿå‘å·¦ç§»åŠ¨ä¸€ä¸ªä½ç½®ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º$O(N)$ã€‚ æ³¨æ„åˆ°æˆ‘ä»¬çš„ä¼ªä»£ç ä¸­è¿˜æœ‰ç¬¬ä¸€é‡å¾ªç¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(N)$ï¼Œå› æ­¤æšä¸¾çš„æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(N^2)$ã€‚ç”±äºæ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(N \\log N)$ï¼Œåœ¨æ¸è¿›æ„ä¹‰ä¸‹å°äºå‰è€…ï¼Œå› æ­¤ç®—æ³•çš„æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(N^2)$ã€‚ ä¸Šè¿°çš„ä¼ªä»£ç ä¸­è¿˜æœ‰ä¸€äº›ç»†èŠ‚éœ€è¦è¡¥å……ï¼Œä¾‹å¦‚æˆ‘ä»¬éœ€è¦ä¿æŒå·¦æŒ‡é’ˆä¸€ç›´åœ¨å³æŒ‡é’ˆçš„å·¦ä¾§ï¼ˆå³æ»¡è¶³$ b \\leq c$ï¼‰ï¼Œå…·ä½“å¯ä»¥å‚è€ƒä¸‹é¢çš„ä»£ç ï¼Œå‡ç»™å‡ºäº†è¯¦ç»†çš„æ³¨é‡Šã€‚ ä»£ç å®ç° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(int[] num) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); int len = num.length; // æ’åºæ–¹ä¾¿å¾ªç¯ä¸é‡å¤ // å¤šé‡å¾ªç¯æœ‰åºæ•°ç»„ç»„åˆä¸é‡å¤ï¼šä¸‹ä¸€è½®å¾ªç¯&gt;=ä¸Šä¸€è½®å…ƒç´  Arrays.sort(num); // ä¸€é‡å¾ªç¯ï¼šé€‰æ‹©ä¸€ä¸ªæ•°ä¸ºç›®æ ‡æ•°ï¼ˆä¸èƒ½é‡å¤ï¼‰ for(int a=0; a&lt;len ; a++) &#123; // *é‡å¤åˆ™è·³è¿‡ // å¦‚æœæ˜¯åˆ¤æ–­num[a]==num[a+1]? ä¼šå‡ºç°caseï¼šnums=[0,0,0] // è¾“å‡ºä¸º[] è€Œéé¢„æœŸçš„è¾“å‡º[0,0,0] // ä¿è¯å¤šä¸ªç›¸é‚»é‡å¤æ•°ï¼Œç¬¬ä¸€ä¸ªå¯ä»¥ä½¿ç”¨ if(a&gt;0 &amp;&amp; num[a]==num[a-1]) continue; // äºŒé‡å¾ªç¯ï¼šåŒæŒ‡é’ˆæ³• // å…ƒç´ ä¸é‡å¤:äºŒé‡å¾ªç¯å…ƒç´ &gt;=ä¸€é‡å¾ªç¯ int c = len-1; // å³æŒ‡é’ˆ for(int b=a+1; b&lt;c ; b++) &#123; // *é‡å¤åˆ™è·³è¿‡ // è¿™é‡Œb&gt;a+1,å¦åˆ™åŒæ ·caseï¼šnums=[0,0,0] // è¾“å‡ºä¸º[] if(b&gt;a+1 &amp;&amp; num[b]==num[b-1]) continue; // å³æŒ‡é’ˆå·¦ç§»åŠ¨ï¼Œç›´è‡³a+b+c&lt;=0 // *ä¿è¯cåœ¨bçš„å³ä¾§ï¼Œå¦åˆ™ä¼šä½¿ç”¨é‡å¤å…ƒç´  while(b&lt;c &amp;&amp; num[a]+num[b]+num[c]&gt;0) &#123; c--; &#125; // æ£€æŸ¥æ­¤æ—¶a+b+c=0ï¼Ÿ // **æ³¨æ„æ­¤æ—¶bä¸èƒ½ç­‰äºcï¼Œå¦åˆ™ä¼šä½¿ç”¨é‡å¤å…ƒç´ ï¼ if(b!=c &amp;&amp; num[a]+num[b]+num[c]==0) &#123; ArrayList&lt;Integer&gt; triple = new ArrayList(); triple.add(num[a]); triple.add(num[b]); triple.add(num[c]); res.add(triple); &#125; &#125; &#125; return res; &#125; NC73:ä¸€åŠæ•°å­— é¢˜ç›®æè¿° è§£æ³•æ€è·¯ é¢˜ç›®æŒºç®€å•çš„ å“ˆå¸Œæ³•ï¼š 12345678910111213141516171819public int MoreThanHalfNum_Solution(int [] array) &#123; // é‡‡ç”¨haspmapä¸€æ¬¡è®°å½• HashMap dic = new HashMap(); int len = array.length; // ä¸€æ¬¡éå†è®°å½• for(int i=0; i&lt; len; i++) &#123; Object obj_cur_count = dic.get(array[i]); int count = 1; if(obj_cur_count!=null) count = Integer.parseInt(obj_cur_count.toString())+1; dic.put(array[i], count); // *æ˜¯i&gt;= ä¸æ˜¯ i&gt; if(i&gt;=len/2 &amp;&amp; count&gt;len/2) return array[i]; &#125; return 0; &#125; å€™é€‰æ³• åŠ å…¥æ•°ç»„ä¸­å­˜åœ¨ä¼—æ•°ï¼Œé‚£ä¹ˆä¼—æ•°ä¸€å®šå¤§äºæ•°ç»„çš„é•¿åº¦çš„ä¸€åŠã€‚ åˆå§‹åŒ–ï¼šä¼—æ•°=num[0] , ç¥¨æ•°=0ï¼Œ ä»i=1éå†æ•°ç»„ï¼Œå¦‚æœå½“å‰æ•°å­—â‰ ä¼—æ•°ï¼Œç¥¨æ•°-1 ã€‚å¦‚æœç¥¨æ•°&lt;=0ï¼Œåˆ™ä¼—æ•°=num[i++] ã€‚æœ€å·®çš„æƒ…å†µæ˜¯æ¶ˆå»ä¸€ä¸ªä¼—æ•°å’Œä¸€ä¸ªéä¼—æ•°ï¼› å¦‚æœå½“å‰æ•°å­—=ä¼—æ•°ï¼Œç¥¨æ•°+1 å¾ªç¯ç»“æŸï¼Œè¿”å›æœ€ç»ˆä¼—æ•° ä»£ç å®ç° å€™é€‰æ³•å®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425public int MoreThanHalfNum_Solution(int [] array) &#123; // åˆå§‹åŒ–ä¼—æ•°å’Œç¥¨æ•° int modal = array[0], vote = 0; for(int i=1; i&lt;array.length;i++) &#123; // åˆ¤æ–­ä¼—æ•°æ˜¯å¦å’Œå½“å‰æ•°å­—ç›¸ç­‰ // ç›¸ç­‰åˆ™vote+1ï¼Œä¸ç›¸ç­‰åˆ™vote-1 vote = modal==array[i]?vote+1:vote-1; // ç¥¨æ•°&lt;=0 &amp;&amp; iä¸æŒ‡å‘æ•°ç»„æœ«å°¾ï¼Œæ›´æ–°ä¼—æ•° // ç¥¨æ•°&lt;=0 ä¸”å½“å‰iæŒ‡å‘æ•°ç»„æœ«å°¾ï¼Œæ­¤æ—¶å¿…ä¸å­˜åœ¨ä¼—æ•° if(vote&lt;=0 &amp;&amp; ++i&lt;array.length) modal=array[i]; &#125; // éªŒè¯ä¼—æ•° int count=0; for(int i=0; i&lt;array.length; i++) &#123; if(modal==array[i]) count++; if(count&gt;array.length/2) return modal; &#125; return 0; &#125; NC36: æ•°ç»„ä¸­ä½æ•° é¢˜ç›®æè¿° è§£æ³•æ€è·¯ leetcode é¢˜è§£ï¼šè¯¦ç»†é€šä¿—çš„æ€è·¯åˆ†æï¼Œå¤šè§£æ³• æœ¬é¢˜æ˜“è”æƒ³åˆ°å½’å¹¶æ’åºä¸­ åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„ï¼Œå†å–ä¸­ä½æ•°ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œåªéœ€è®°å½•æŒ‡é’ˆä½ç§»ï¼Œä¸ç”¨è¿›è¡Œå®é™…å…ƒç´ æ›´æ–°ï¼šç©ºé—´å¤æ‚åº¦å¯ä»¥ä¼˜åŒ–æˆO(1)ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦ä¾æ—§æ˜¯O(n+m) : æ³¨æ„å’ŒNC22ä¸åŒï¼ˆæ•°ç»„Aæœ‰å¤šä½™ç©ºé—´å¯ä»¥å­˜ä¸‹Bï¼‰ï¼Œè¿™é‡Œçš„æŒ‡é’ˆä»å¤´å¼€å§‹è€Œéå°¾éƒ¨ã€‚ ä»å¤´éƒ¨è€ƒè™‘æ›´ç®€å•ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940public int findMedianinTwoSortedAray (int[] arrA, int[] arrB) &#123; // å°†ä¸¤ä¸ªæœ‰åºæ•°ç»„åˆå¹¶æˆä¸€ä¸ªæœ‰åºæ•°ç»„ï¼šä¸‰æŒ‡é’ˆæ³• int m = arrA.length , n = arrB.length; // å®šä¹‰ä¸‰ä¸ªæŒ‡é’ˆ // è¿™é‡Œqcç”¨æ¥è®°å½•æŒ‡é’ˆæ€»çš„ç§»åŠ¨æ¬¡æ•° // æŒ‡é’ˆæ¯ç§»åŠ¨ä¸€æ¬¡ä»£è¡¨ä¸€ä¸ªæ•°è¢«ç¡®å®š(è¢«æ’åºå¥½) int qa= 0 ,qb=0, qc=0; // éœ€è¢«ç¡®å®šçš„æ•°ï¼Œä¸­ä½æ•°kåŠä¹‹å‰çš„æ‰€æœ‰çš„æ•° int k = (m+n)%2==0? (m+n)/2 : (m+n)/2+1; // å…ˆæ¯”è¾ƒå®Œä¸€ä¸ªæ•°ç»„ while(qa&lt;m &amp;&amp; qb&lt;n) &#123; if(arrA[qa]&lt;=arrB[qb]) &#123; qa++; qc++; // æ¯æ¬¡ç§»åŠ¨æŒ‡é’ˆæ—¶åˆ¤æ–­æ˜¯å¦ç¡®å®šï¼ˆæ’åºï¼‰æ•°ç»„ä¸­[0,ä¸­ä½æ•°k] // æ‰€æœ‰æ•°å­— if(qc==k) return arrA[qa-1]; &#125; else &#123; qb++; qc++; if(qc==k) return arrB[qb-1]; &#125; &#125; // æ¯”è¾ƒå‰©ä½™çš„æ•° while(qa&lt;m) // Aæœªæ¯”è¾ƒå®Œæ¯• &#123; qa++; qc++; if(qc==k) return arrA[qa-1]; &#125; while(qb&lt;m) &#123; qb++;qc++; if(qc==k) return arrB[qb-1]; &#125; return 0; &#125; ä½†æ˜¯å¦‚ä½•ä¼˜åŒ–æ—¶é—´åˆ°O(log(m+n)å‘¢ï¼Ÿ è¯¥é—®é¢˜å¯è½¬æ¢ä¸ºï¼šæ±‚ç¬¬kå°æ•°å­—ã€‚ åˆå§‹kå€¼ï¼Œå³ä¸­ä½æ•°åœ¨åˆå¹¶çš„åºåˆ—ä¸­ä¸‹æ ‡ä¸º k = (m+n)%2==0? (m+n)/2 : (m+n)/2+1; æ¯”è¾ƒA[k/2-1] å’Œ B[k/2-1]ï¼Œå…¶ä¸­è¾ƒå°è€…ï¼šæœ€å¤šåªæœ‰A[0..k/2-2] + B[0..k/2-2] == k-2 ä¸ªå…ƒç´ æ¯”å®ƒå°ï¼Œä¸å¯èƒ½æ˜¯ä¸­ä½æ•°kï¼Œå¯ä»¥å°†ï¼ˆ[0..k/2-1]ï¼‰æ•°å­—å…¨éƒ¨æ’é™¤ã€‚ æ›´æ–°æ•°ç»„å·¦è¾¹ç•Œleft=k/2ï¼Œä¿®æ”¹k=k-(k/2) ï¼ˆ:warning: ä¸ç­‰ä»·äºk=k/2!ï¼‰ ç„¶åè€ƒè™‘ä¸‰ç§è¾¹ç•Œæ¡ä»¶ï¼ˆfu*kï¼Œæ€ä¹ˆè¿™ä¹ˆéš¾æƒ³ï¼Ÿï¼‰ï¼š ä»£ç å®ç° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public int findMedianinTwoSortedAray (int[] arrA, int[] arrB) &#123; int m = arrA.length, n = arrB.length; // è½¬æ¢ä¸ºæ±‚ç¬¬kå°çš„æ•° int k = (m + n) % 2 == 0 ? (m + n) / 2 : (m + n) / 2 + 1; // æ•°ç»„å·¦è¾¹ç•Œå˜åŒ– int leftA = 0, leftB = 0; // ä¸­ä½æ•°æŒ‡é’ˆæ¯”è¾ƒä½ç½® int mediaA = 0, mediaB = 0; while (true) &#123; /* 1.æ¯”è¾ƒA[k/2-1]å’Œ B[k/2-1] 2.å¦‚æœï¼Œk/2-1ä¼šå¯¼è‡´è¶Šç•Œï¼Œæ”¹ä¸ºå¯¹åº”æ•°ç»„çš„æœ«å°¾len-1 3.å¦åˆ™ï¼Œæ›´å°çš„æ’é™¤å‰é¢[0..k/2-1]ä¸ªæ•° æˆ– [0..len-1]ä¹‹é—´æ•°å­— 4.æ›´æ–°k=k-k/2 æˆ–è€… k=k-len 5.æ›´æ–°å·¦è¾¹ç•Œleft,å¦‚æœleft&gt;æ•°ç»„è¾¹ç•Œï¼Œè¿”å›å¦å¤–ä¸€ä¸ªæ•°ç»„ç¬¬kä¸ªå…ƒç´  6.ç›´è‡³k=1ï¼Œè¿”å›å·¦è¾¹ç•Œè¾ƒå°çš„æ•°ä¾¿æ˜¯ç¬¬kå°çš„æ•° */ // æ•°ç»„ä¸ºç©ºè¯´æ˜è¯¥æ•°ç»„å…ƒç´ å…¨éƒ¨è¢«æ’é™¤ï¼Œç›´æ¥è¿”å›å¦å¤–æ•°ç»„ç¬¬kå°å³å¯ if(leftA &gt; m-1) return arrB[leftB+k-1]; if(leftB &gt; n-1) return arrA[leftA+k-1]; // k==1æ—¶æ¯”è¾ƒå‰©ä½™å¾…æ¯”è¾ƒæ•°ç»„å·¦è¾¹ç•Œç¬¬ä¸€ä¸ªæ•°å­— if (k == 1) return arrA[leftA] &lt; arrB[leftB] ? arrA[leftA] : arrB[leftB] ; // *æ›´æ–°ä¸­ä½æ•°æŒ‡é’ˆæ¯”è¾ƒä½ç½®(æ³¨æ„æŒ‡é’ˆ+left) mediaA = leftA + k / 2 - 1; mediaB = leftB + k / 2 - 1; // å¤„ç†è¶Šç•Œæƒ…å†µ if (mediaA &gt; m - 1) // æ•°ç»„Aè¶Šç•Œ mediaA = m - 1; if (mediaB &gt; n - 1) // æ•°ç»„Bè¶Šç•Œ mediaB = n - 1; // æ¯”è¾ƒ if (arrA[mediaA] &lt; arrB[mediaB]) //æ’é™¤[leftA..mediaA] &#123; // *å…ˆæ›´æ–°kï¼ k = k - (mediaA - leftA + 1); // æ›´æ–°k=k-æ’é™¤çš„æ•°å­— leftA = mediaA + 1; // æ•°ç»„Aå·¦è¾¹ç•Œå˜åŒ– &#125; else //æ’é™¤[leftB..mediaB] &#123; k = k - (mediaB - leftB + 1); // æ›´æ–°k=k-æ’é™¤çš„æ•°å­— leftB = mediaB + 1; &#125; &#125; &#125; NC30: æœ€å°æ­£æ•° é¢˜ç›®æè¿° åŠ ä¸Šæ¡ä»¶ï¼šåŠ ä¸Šè¿™ä¸ªç¼ºå¤±çš„æœ€å°æ•´æ•°åï¼ˆä¸åŒ…æ‹¬0ï¼‰ï¼Œå®ƒæ˜¯ä¸€ä¸ªè¿ç»­æ•°ç»„ã€‚ è§£æ³•æ€è·¯ å¦‚æœä¸è€ƒè™‘æ—¶é—´&amp;ç©ºé—´å¤æ‚åº¦ï¼Œåˆ©ç”¨åŒå±‚å¾ªç¯ï¼š ä¸€æ¬¡éå†è®°å½•æ•°ç»„æœ€å°å…ƒç´ minï¼Œå’Œæœ€å¤§å…ƒç´ max ï¼šå¦‚æœmin&gt;1 ï¼Œè¿”å›min-1 ã€å¤–å±‚å¾ªç¯ã€‘å¯¹äºæ¯ä¸ªæ•´æ•°å…ƒç´  $j\\in[min,max]$ ï¼Œã€å†…å±‚å¾ªç¯ã€‘éå†æ•´ä¸ªæ•°ç»„Nums åˆ¤æ–­æ˜¯å¦å­˜åœ¨ï¼šä¸å­˜åœ¨åˆ™è¿”å›j ï¼› éƒ½å­˜åœ¨åˆ™è¿”å›max+1 æ˜¾ç„¶å¯¹äºã€å†…å±‚å¾ªç¯ã€‘ï¼Œå¯ä»¥åˆ©ç”¨å“ˆå¸Œè¡¨ï¼šå¿«é€Ÿåˆ¤æ–­æ•°ç»„å…ƒç´ æ˜¯å¦å­˜åœ¨ ï¼Œçš„ç‰¹æ€§æ¥æŸ¥æ‰¾ã€‚ç‰ºç‰²ç©ºé—´æ¢æ—¶é—´ï¼š éå†æ•°ç»„ï¼Œå°†æ•°ç»„å…ƒç´ Nums[i], ä½œä¸ºå“ˆå¸Œdicåœ°å€å€¼(key) , å¯åœ¨O(1)æ—¶é—´åˆ¤æ–­æ•°ç»„å…ƒç´ æ˜¯å¦å­˜åœ¨ åŒæ—¶ä¸Šè¿°éå†å¯ä»¥è®°å½•æ•°ç»„æœ€å°å…ƒç´ minï¼Œå’Œæœ€å¤§å…ƒç´ maxï¼šå¦‚æœmin&gt;1 ï¼Œè¿”å›min-1 ä¾æ¬¡éå†æ•´æ•° $j\\in[min,max]$ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨dic.get(j)ï¼Œä¸å­˜åœ¨åˆ™è¿”å›j ï¼› éƒ½å­˜åœ¨åˆ™è¿”å›max+1 æ—¶é—´å¤æ‚åº¦é™ä¸ºO(n) , ä½†æ˜¯ç©ºé—´å¤æ‚åº¦ä¹Ÿæ˜¯ O(n) ï¼Œå› ä¸ºå¼•å…¥é¢å¤–çš„å“ˆå¸Œç©ºé—´ã€‚ä¸ºæ­¤æˆ‘ä»¬ä½¿ç”¨â€œ åŸåœ°å“ˆå¸Œ â€ , å€ŸåŠ©å·²çŸ¥çš„æ•°ç»„Numsæ„é€ å“ˆå¸Œè¡¨ï¼Œä¼˜åŒ–ç©ºé—´ã€‚ é¦–å…ˆåˆ†ææœ€å°æ­£æ•°èŒƒå›´ï¼šå¯¹äºä¸€ä¸ªé•¿åº¦ä¸ºNçš„æ•´æ•°æ•°ç»„Numsï¼Œå¦‚æœå‡ºç°å…ƒç´ Nums[i]&lt;1 æˆ–è€… Nums[i]&gt;N çš„æ•°ï¼Œé‚£ä¹ˆç¼ºå°‘çš„æ•´æ•°$j\\in[1,N]$ ; å¦‚æœéƒ½å‡ºç°ï¼Œåˆ™$j=N+1$ã€‚æ‰€ä»¥$j\\in[1,N+1]$ ã€‚å› ä¸ºæ•°ç»„ä¸€å…±åªæœ‰Nä¸ªæ•°ï¼Œå¦‚æœå‡ºç°ä¸åˆæ³•çš„æ•°ï¼Œåˆ™å‡ºç°çš„1åˆ°Nä¹‹é—´çš„æ•°çš„ä¸ªæ•°ä¸€å®šå°äºNï¼Œæ•…ä¸€å®šæœ‰æ²¡æœ‰å‡ºç°çš„æ•°ã€‚ å› æ­¤æˆ‘ä»¬å¯ä»¥æ¢ç§æ–¹å¼ï¼Œç”¨æ¥åœ¨éå†æ­£æ•°$j\\in[1,N]$ å¿«é€Ÿåˆ¤æ–­æ˜¯$j$å¦å­˜åœ¨ï¼šéå†æ•°ç»„ï¼Œå¦‚æœå­˜åœ¨å…ƒç´ $Nums[i]\\in[1,N]$ , åˆ™æ ‡è®°$Nums[Nums[i]-1]$ å–è´Ÿæ•°ã€‚ ä»£ç å®ç° ä»£ç ä¸æ˜¯è‡ªå·±å†™çš„ï¼Œå› ä¸ºè§‰å¾—æ²¡å¤šå¤§æ„æ€è¿™é¢˜ï¼Œå¤§å¤šæ˜¯æ•°å­¦é—®é¢˜ã€‚æ˜ç™½æ€ä¹ˆåˆ†æè¿‡æ¥å°±è¡Œã€‚ 1234567891011121314151617181920212223public int firstMissingPositive(int[] nums)&#123; int n = nums.length; for (int i = 0; i &lt; n; ++i) &#123; if (nums[i] &lt;= 0) nums[i] = n + 1; &#125; for (int i = 0; i &lt; n; ++i) &#123; int num = Math.abs(nums[i]); if (num &lt;= n) &#123; nums[num - 1] = -Math.abs(nums[num - 1]); &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; if (nums[i] &gt; 0) return i + 1; &#125; return n + 1; &#125; ã€çœ‹ã€‘NC119:æœ€å°kä¸ªæ•° é¢˜ç›®æè¿° è§£æ³•æ€è·¯ æŠŠ å †æ’åº èƒŒä¸‹å°±æ²¡é—®é¢˜äº†ï¼Œå¯å‚è€ƒå‰é¢å †æ’åºä»£ç ç†è§£ã€‚ æ—¶é—´å¤æ‚åº¦ï¼šO(nlongk) ä»£ç å®ç° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] arr, int k) &#123; // å¥—è·¯é¢˜ï¼šå¯¹äºæ‰¾ç¬¬kä¸ªå°/æ‰“æ•°ï¼Œä¸€èˆ¬æ˜¯å †æ’åºæœ€ä¼˜ int len = arr.length; ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); // kéœ€å°äºæ•°ç»„é•¿åº¦ if(k&gt;len|| k&lt;=0) return array ; // 1.æ„å»ºåˆå§‹å † for(int i= len/2; i&gt;=0; i--) // å¯¹æ¯ä¸€ä¸ªèŠ‚ç‚¹è§†ä½œæ ¹èŠ‚ç‚¹ï¼Œè°ƒæ•´å­æ ‘ç¬¦åˆæœ€å°å † MinHeapfily(arr,i,len); // 2.æ’åº for(int i=0; i&lt;k ; i++) &#123; array.add(arr[0]); swap(arr,0,len-1); len--; MinHeapfily(arr,0,len); &#125; return array; &#125; // è®¾ç½®å‚æ•°è¦æœ‰æ•°ç»„é•¿åº¦ï¼Œå› ä¸ºæ’åºæ—¶äº¤æ¢å †é¡¶å’Œå †å°¾å…ƒç´ ï¼Œç›¸å½“åˆ é™¤å †é¡¶å…ƒç´  // å¯¹åº”æ•°ç»„é•¿åº¦-1 public void MinHeapfily(int[] arr, int root , int len) &#123; // å·¦å³å­©å­ int left = root*2+1; int right = root*2+2; if(left&gt;=len) return; int min = root; min = arr[left]&lt; arr[min]? left : min; min = right&lt;len &amp;&amp; arr[right]&lt; arr[min]? right : min; // å¦‚æœå‘ç”Ÿäº¤æ¢è¦å¾€ä¸‹è°ƒæ•´ if(min!=root) &#123; swap(arr,min,root); MinHeapfily(arr,min,len); &#125; &#125; public void swap(int[] arr, int i,int j) &#123; int temp ; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; NC88: ç¬¬Kå¤§ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ æ€è·¯ä¸»è¦å‚è€ƒå¿«æ’ï¼Œæœ€ååˆ¤æ–­æ—¶ç»“åˆäºŒåˆ†ï¼šæ ¹æ®Kå¤§å°å†³å®šå»å“ªä¸ªå­åºåˆ—æœå¯»Kthã€‚ ä»£ç ç»†èŠ‚å‚è€ƒä¸‹*ã€‚ ä»£ç å®ç° æ³¨æ„é¢˜ç›®æ˜¯å¯»æ‰¾ç¬¬Kå¤§ï¼Œç¬¬Kå¤§å¯¹åº”çš„å…ƒç´ åœ¨ æ’åºåçš„æ•°ç»„ä¸‹æ ‡ æ˜¯ arr[n-k] ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public int findKth(int[] arr, int n, int K) &#123; // å¿«æ’ç»“åˆäºŒåˆ†: // å¦‚æœä¸€è½®k==partitionï¼Œreturn arr[k] // å¦‚æœk&gt;partition, åˆ™åœ¨å³ä¾§æœç´¢ // å¦‚æœk&lt;partition, åˆ™åœ¨å·¦ä¾§æœç´¢ int Kth = quickSort(arr,0,n-1,n-K); return Kth; &#125; // å¿«æ’æ€æƒ³ // 1.è®¾å®šä¸€ä¸ªåŸºå‡†pivot=arr[right],åˆ†å‰²æ ‡è®°partition=left // partition è¡¨ç¤ºæœ€ç»ˆåŸºå‡†æ’å…¥çš„ä½ç½®ï¼Œåˆå§‹==leftè¡¨ç¤ºé»˜è®¤æ‰€æœ‰å…ƒç´ &gt;pivot // 2.éå†æ•°ç»„ï¼Œå¦‚æœæ•°ç»„å…ƒç´ arr[i]&lt;pivot,äº¤æ¢arr[partition]å’Œarr[i] // ä¸”partition+1ï¼Œå°†arr[i]äº¤æ¢åˆ°partitionå·¦è¾¹ã€‚ä¿è¯åŸºå‡†å·¦ä¾§å…ƒç´ &lt;åŸºå‡† // 3.é€’å½’é‡å¤ä¸Šè¿°æ“ä½œ public int quickSort(int[] arr,int left, int right,int K) &#123; // *è¿™é‡Œå®é™…ä¸ä¼šæ‰§è¡Œï¼Œå› ä¸ºé¢˜ç›®ä¿è¯Kthä¸€å®šå­˜åœ¨ // æ‰€æœ‰returnçš„ä¸€å®šæ˜¯é€’å½’è¿”å›åçš„å…ƒç´  if(left&gt;right) return 0; int pivot = arr[right]; int partition = left; // ä¿è¯partitionå·¦ä¾§æ•°å­—éƒ½å°äºåŸºå‡† // *ä»i=leftï¼Œè€Œä¸æ˜¯i=0 for(int i=left; i&lt;right; i++) &#123; if(arr[i]&lt;pivot) &#123; swap(arr, i, partition); partition++; &#125; &#125; // åŸºå‡†æ’å…¥ swap(arr,partition,right); // æ’åº+äºŒåˆ† // é€’å½’è¿”å›æœç´¢é€’å½’å­æ ‘çš„ç»“æœ if(K==partition) return arr[partition]; else if(K&lt;partition) return quickSort(arr,left,partition-1,K); else return quickSort(arr,partition+1,right,K); &#125; // æ•°ç»„äº¤æ¢å…ƒç´  public void swap(int[] arr, int i,int j) &#123; int temp ; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; NC105: äºŒåˆ†æŸ¥æ‰¾ç¬¬ä¸€ä¸ª é¢˜ç›®æè¿° è§£é¢˜æ€è·¯ å°±æ˜¯äºŒåˆ†æŸ¥æ‰¾å¥—è·¯ï¼Œä½†æ˜¯æŸ¥æ‰¾åˆ°targetæ—¶è¦ä¿è¯ç¬¬ä¸€æ¬¡å‡ºç°ï¼Œå³å·¦ä¾§æ²¡æœ‰é‡å¤çš„å…ƒç´ ã€‚ ä»£ç å®ç° 123456789101112131415161718192021222324252627public int search (int[] arr, int target) &#123; int left = 0,right = arr.length-1; int mid ; while (left&lt;=right) //*&lt;= è€Œä¸æ˜¯&lt; &#123; mid = (left+right)/2; if(target == arr[mid]) &#123; // *å¯èƒ½å·¦ä¾§è¿˜å­˜åœ¨ç›¸åŒtargetï¼Œä¿è¯ç¬¬ä¸€æ¬¡å‡ºç° while(mid&gt;0 &amp;&amp; arr[mid-1]==target) mid--; return mid; // å¦‚æœæ•°ç»„å­˜åœ¨å¾…æŸ¥æ‰¾å…ƒç´ ï¼ŒæŒ‰ç…§é€»è¾‘ä¸€å®šä¼šæ˜¯mid &#125; else if(target &lt; arr[mid]) &#123; right = mid-1; &#125; else // value &gt; arr[mid] &#123; left = mid+1; &#125; &#125; return -1; &#125; NC91: æœ€é•¿é€’å¢å­åºåˆ— é¢˜ç›®æè¿° è§£æ³•æ€è·¯ ä»æš´åŠ›è§£æ³•â†’åŠ¨æ€è§„åˆ’â†’å†ä¼˜åŒ–ã€‚ ã€ä¸€ã€æš´åŠ›éå†ã€‘ ä»å¤´éå†æ‰€æœ‰çš„é€’å¢åºåˆ—ï¼š å¯¹äºæ¯ä¸ªå…ƒç´ arr[i],q=i,ArrayList.add(arr[i]) å¾€åéå†ï¼Œå¦‚æœarr[j]&gt;arr[i],åˆ™q=jï¼ŒArrayList.add(arr[j]) å¦‚æœarr[j]&lt;arr[i] ä¸” j!=arr.length-1,æ›¿æ¢é€’å¢åºåˆ—ä¸ºarr[j],q=[j] å¾ªç¯1,2ï¼Œå¹¶è®°å½•æ¯ä¸ªArrayListçš„æœ€å¤§é•¿åº¦ï¼Œç›´è‡³å…¨éƒ¨éå†å®Œ éå†æ‰€æœ‰ArrayListï¼Œæ‰¾åˆ°é•¿åº¦æœ€é•¿&amp;å­—å…¸æœ€å°çš„ArrayListè¿”å› æ—¶é—´å¤æ‚åº¦ä¸ºO(n^2)ï¼Œç©ºé—´å¤æ‚åº¦ä¹Ÿä¸ºO(n^2)ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public int[] LIS (int[] arr) &#123; int q=-1; int maxLen=-1; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrays = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for(int i=0; i&lt;arr.length-1;i++) &#123; q=i; // å½“å‰é€’å¢åºåˆ—æœ«å°¾ ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); array.add(arr[q]); for(int j=i+1; j&lt;arr.length;j++) &#123; if(arr[j]&gt;arr[q]) &#123; q=j;array.add(arr[q]); &#125; if(j!=arr.length-1&amp;&amp;arr[j]&lt;arr[q]) // æ›¿æ¢æœ«å°¾å…ƒç´  &#123; array.remove(array.size()-1); array.add(arr[j]); q=j; &#125; &#125; // è®°å½•æœ€å¤§é•¿åº¦ int len = array.size(); if(len &gt; maxLen) maxLen = len; // è®°å½•ä»¥iä¸ºé¦–çš„é€’å¢å­åºåˆ— arrays.add(array); &#125; // æ‰¾åˆ°ç¬¦åˆè¦æ±‚çš„æœ€é•¿é€’å¢å­åºåˆ— int LIS_idx=0; int minSum ; for(int i=0; i&lt;arrays.size();i++) &#123; minSum = Sum(arrays.get(0)); if(arrays.get(i).size()==maxLen) // ç¬¦åˆæœ€å¤§é•¿åº¦ &#123; if(Sum(arrays.get(i))&lt;minSum) &#123; minSum=Sum(arrays.get(i)); LIS_idx=i; &#125; &#125; &#125; // è¿”å›æ»¡è¶³è¦æ±‚çš„æœ€é•¿é€’å¢åºåˆ— return arrays.get(LIS_idx).stream().mapToInt(k-&gt;k).toArray(); &#125; ã€äºŒã€åŠ¨æ€è§„åˆ’ã€‘ å‚è€ƒè§£æï¼šleetcode-300ï¼Œæ±‚æœ€é•¿å­åºåˆ—é•¿åº¦ ï¼Œä½†æœ¬é¢˜è¿˜éœ€è¦è¿”å›é€’å¢å­åºåˆ—ã€‚ å¯¹çŠ¶æ€æ–¹ç¨‹ä¸ç†è§£ï¼Œå¯ä»¥çœ‹çœ‹ è§£æçš„slidesï¼Œå¦‚ä½•ä¿è¯ $ dp[i]$ æ˜¯æœ€å¤§é€’å¢åºåˆ—é•¿åº¦ã€‚ æ¬²æ±‚å­åºåˆ— $nums[0,1..,i]$ ä¸­ $ dp[i]$ ï¼Œä¸”å·²çŸ¥é“$j&lt;i,nums[0,1..,j]$ å„ä¸ªå­åºåˆ—çš„$ dp[j]$ éå†æ¯ä¸ªå­åºåˆ—ï¼Œ$nums[j]$ æ˜¯å­åºåˆ—çš„æœ«å°¾å…ƒç´  å¦‚æœ$nums[i]&gt;nums[j]$ï¼Œåˆ™å¯æ„æˆæ–°çš„é€’å¢å­åºåˆ—ï¼Œ $nums[0,1..,j,i]$ï¼Œæ­¤æ—¶æœ€å¤§å­åºåˆ—é•¿åº¦+1 ï¼š$dp[i]=dp[j]+1$ ã€‚ä½†è¦ä¿è¯$dp[i]$æœ€å¤§ï¼ˆæ¯ä¸ªå­åºåˆ—$dp[j]$å€¼ä¸åŒï¼Œæ›´æ–°$dp[i]$ æœªå¿…æœ‰å…ˆå‰å¤§ ï¼‰ï¼š$dp[i]=max(dp[i],dp[j]+1]$ å¦‚æœ$nums[i]&lt;nums[j]$ , è·³è¿‡ä¸ç”¨æ›´æ–°$dp[i]$ å¯¹äºæœ¬é¢˜è¿˜åº”è¯¥è®¾ç½®äºŒç»´æ•°ç»„ï¼Œä¿å­˜æ‰€æœ‰é€’å¢å­åºåˆ—ï¼Œæ‰€ä»¥ï¼šæ—¶é—´å¤æ‚åº¦ä¸ºO(n^2)ï¼Œç©ºé—´å¤æ‚åº¦ä¹Ÿä¸ºO(n^2)ã€‚ 12345678910111213141516171819202122public int LIS(int[] nums) &#123; if(nums.length == 0) return 0; // 1.çŠ¶æ€å®šä¹‰ int[] dp = new int[nums.length]; int res = 0; // 2.åˆå§‹çŠ¶æ€ Arrays.fill(dp, 1); for(int i = 0; i &lt; nums.length; i++) &#123; for(int j = 0; j &lt; i; j++) &#123; // 3.åŠ¨æ€æ–¹ç¨‹ if(nums[j] &lt; nums[i]) dp[i] = Math.max(dp[i], dp[j] + 1); &#125; res = Math.max(res, dp[i]); &#125; // è¿”å›å€¼ return res;&#125; ã€ä¸‰ã€å†ä¼˜åŒ–ã€‘ ç®—äº†ã€‚ ä»£ç å®ç° 1 NC32: æ±‚å¹³æ–¹æ ¹ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ ä¸€ã€äºŒåˆ†æ³•ï¼Œä½†æ˜¯ä¸çŸ¥é“ä¸ºä»€ä¹ˆä¼šè¶…æ—¶ï¼Ÿ å†™å‡ºäºŒåˆ†æ³•æ¨¡æ¿ï¼Œä¿®æ”¹äº›è¾¹ç•Œæ¡ä»¶ï¼š æ‰¾åˆ°æ‰€éœ€å¹³æ–¹æ ¹ï¼šå¦‚æœä¸€ä¸ªæ•°$mid$ æ˜¯$x$ å¹³æ–¹æ ¹ï¼Œé‚£ä¸€å®šæ»¡è¶³$mid^2&lt;x&lt;(mid+1)^2$ ä¿®æ”¹å·¦å³è¾¹ç•Œï¼Œæ³¨æ„æ›´æ–°å·¦å³è¾¹ç•Œæ—¶å¯èƒ½ä¼šå¯¼è‡´: ${right}^2&lt;x$ æˆ–è€… ${left}^2&gt;x$ ï¼Œ éœ€è¦è¿›è¡Œé¢å¤–åˆ¤æ–­ :bookmark_tabs: æ³¨æ„æ˜ç™½1. ä»€ä¹ˆæƒ…å†µå¯ä»¥ç¡®å®šå½“å‰midæ˜¯å¹³æ–¹æ ¹ã€‚ ä»£ç å®ç° 123456789101112131415161718192021222324252627282930313233343536373839404142public int sqrt (int x) &#123; // *x/2å¯ä»¥èŠ‚çœæ—¶é—´ return binarySearchX(x,1,x/2); &#125;public int binarySearchX(int x, int left,int right) &#123; if(x&lt;2) return x; int mid ; while (left&lt;=right) &#123; mid = (right+left)/2; /* // [è¶…æ—¶ï¼ï¼]è¿™ä¸ªåˆ¤æ–­æ¡ä»¶ä¼šå¯¼è‡´è¶…æ—¶ if(right-left&lt;=1) // æ­¤æ—¶ä¸€å®šæ˜¯ left*left&lt;x&lt;right*right return left; */ if(x/mid==mid) // ç­‰ä»·äºmid*mid&lt;x&lt;(mid+1)*(mid+1) &#123; return mid; &#125; // *é˜²æ­¢mid*midè¶…å‡ºintæœ€å¤§è¡¨ç¤º if(x/mid &lt; mid) &#123; right = mid-1; // *å¯èƒ½ä¼šå‡ºç°rightæ›´æ–°åright*right&lt;x // è¯´æ˜(mid-1)*(mid-1) &lt; x &lt; mid*mid if(right &lt; x/right) return mid-1; &#125; if(x/mid &gt; mid) &#123; left = mid+1; // *å¯èƒ½ä¼šå‡ºç°left*left&gt;x if(left &gt; x/left) return mid; &#125; &#125; return -1; &#125; NC37: åˆå¹¶åŒºé—´ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ éš¾ç‚¹åœ¨äºï¼š æ’åºå®Œæˆåï¼Œå¯ä»¥åˆ†æå‡ºæ‰€æœ‰å¯èƒ½åˆå¹¶æƒ…å†µ èƒ½æƒ³åˆ°åˆå¹¶åŒºé—´æ—¶ä¸å€ŸåŠ©é¢å¤–ç©ºé—´ï¼Œåªè¿›è¡Œåˆ é™¤ã€æ›¿æ¢å…ƒç´ ï¼Œæ”¹å˜æŒ‡é’ˆæŒ‡å‘ æ€è·¯å¦‚ä¸‹ï¼š 12345671.å†’æ³¡æ’åºï¼šæŒ‰åŒºé—´å·¦å…ƒç´ 2.éå†åŒºé—´åˆ¤æ–­ï¼šæ˜¯å¦åˆå¹¶åŒºé—´ å‰åºåˆ—i=[a,b], åºåˆ—i+1=[c,d]ï¼Œå…¶ä¸­c&gt;=a, i). å¦‚æœc&gt;b,åˆ™ä¸åˆå¹¶ ii). å¦‚æœc&lt;b,åˆ™å¯ä»¥åˆå¹¶åºåˆ—[a,b]+[c,d]=[a,d] iii).å¦‚æœd&lt;b,åˆ™å¯ä»¥åˆå¹¶åºåˆ—[a,b]+[c,d]=[a,b]3.éå†è¿”å›ç»“æœ ä»£ç å®ç° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public ArrayList&lt;Interval&gt; merge(ArrayList&lt;Interval&gt; intervals) &#123; if(intervals.size()&lt;=1) return intervals; // 1.å†’æ³¡æ’åº int len = intervals.size(); for(int i=0; i&lt;len-1;i++) // å¤–è½®=n-1 for (int j=0; j&lt; len-i-1; j++ ) // å†…è½®=ä½™ä¸‹ä¹±åºæ•°-1 &#123; if (intervals.get(j).start&gt;intervals.get(j+1).start) &#123; swapInterval(intervals,j,j+1); &#125; &#125; // 2.åˆå¹¶åŒºé—´ // *åªä¿ç•™ç¬¦åˆè¦æ±‚çš„åŒºé—´ï¼Œä¸å€ŸåŠ©é¢å¤–çš„ç©ºé—´ int q=0; while (q&lt;intervals.size()-1) &#123; Interval i1 = intervals.get(q); Interval i2 = intervals.get(q+1); if(i2.start&lt;=i1.end) &#123; if(i2.end&lt;=i1.end) // æƒ…å†µii,[a,b]+[c,d]=[a,b]ï¼Œåˆ é™¤[c,d] intervals.remove(q+1); else // æƒ…å†µi,[a,b]+[c,d]=[a,d],æ›¿æ¢[c,d]==[a,d]ï¼Œåˆ é™¤[a,b] &#123; // æ›¿æ¢ intervals.get(q+1).start= i1.start; // åˆ é™¤ intervals.remove(q); &#125; &#125; else // æƒ…å†µi,ä¸åˆå¹¶ q++; &#125; // 3.è¿”å› return intervals; &#125; public void swapInterval(ArrayList&lt;Interval&gt; intervals,int i1,int i2) &#123; // *äº¤æ¢ç±»ç±»å‹æŒ‡å‘ä¸è¡Œï¼Ÿäº¤æ¢å®ƒä»¬çš„æ•°å€¼ int s1 = intervals.get(i1).start; int e1 = intervals.get(i1).end; intervals.get(i1).start = intervals.get(i2).start; intervals.get(i1).end = intervals.get(i2).end; intervals.get(i2).start = s1; intervals.get(i2).end = e1; &#125; NC41: æ— é‡å¤å­ä¸² é¢˜ç›®æè¿° è§£æ³•æ€è·¯ ä»£ç å®ç° 1 1.3 å­—ç¬¦ä¸²NC1: å¤§æ•°ç›¸åŠ  é¢˜ç›®æè¿° è§£æ³•æ€è·¯ ä¸¤ä¸ªä¸ç­‰é•¿åº¦å­—ç¬¦ä¸²ï¼Œå…ˆè¡¥0åŒ–ä¸ºé•¿åº¦ç›¸åŒã€å­—ç¬¦æ•°ç»„ã€‘ e.g. : s=â€™123â€™ , t = â€˜4â€™ ==&gt; s=â€™123â€™ , t = â€˜004â€™ :notebook: ç›´æ¥ä½ä½ç›¸åŠ  ä»ä½ä½ç›¸åŠ ï¼Œè®¡ç®— 12345// å¾ªç¯ç›¸åŠ  int a = cs[len]-&#x27;0&#x27; + ct[len]-&#x27;0&#x27; + carry;res.append(a%10); // (æ˜“é”™)*a%10 æ˜¯ä½ä½ï¼›a/10 æ˜¯é«˜ä½// æ›´æ–°è¿›ä½carry = a/10; è¿”å›ç»“æœ è¦æœ€ååˆ¤æ–­æ˜¯å¦æœ‰è¿›ä½ ã€åæ€ï¼šä¸ºä»€ä¹ˆdebugè¿™ä¹ˆä¹…ï¼Ÿã€‘ å¯¹Stringç±»å‹è½¬æ¢ä¸ç†Ÿæ‚‰ï¼šchar[] , int [] , Stringç­‰ç­‰äº’è½¬ï¼Ÿåˆå¦‚ï¼Œcharå’Œintä¹‹é—´å¦‚ä½•äº’è½¬ï¼Ÿ 123// *charè½¬æ¢ä¸ºintè‡ªåŠ¨è½¬æ¢Ã— ,ä½†è½¬æ¢çš„æ˜¯ASCIIç ï¼char c = &#x27;5&#x27;int a = &#x27;5&#x27; - &#x27;0&#x27;; // å‡å»&#x27;0&#x27;çš„ASCIIç ï¼Œåˆšå¥½æ˜¯intç±»å‹5 å¯¹StringBuffer ä¸ç†Ÿæ‚‰ï¼šåœ¨æœ¬é¢˜è¿˜éœ€è¦ä¸€ä¸ªç»“æœå­—ç¬¦ä¸²æ•°ç»„resæ¥ä¿å­˜æœ€åç»“æœï¼Œresä¼šä¸æ–­è¢«æ›´æ–°ã€‚å¦‚æœä½¿ç”¨char[] ä¼šå¾ˆéº»çƒ¦ï¼ˆæœ€åè½¬æ¢è¿˜æ˜¯å‡ºé”™ä¹±ç äº†ï¼‰ï¼Œåœ¨javaåº”è¯¥ä¼˜å…ˆè€ƒè™‘StringBufferï¼ ä»£ç å®ç° 1234567891011121314151617181920212223242526272829303132333435363738394041public String solve (String s, String t) &#123; int i = s.length(), j = t.length(); int m = Math.max(i,j); // 1.å…ˆåŒ–ä¸ºæ ‡å‡†å­—ç¬¦ä¸² char[] cs = new char[m]; char[] ct = new char[m]; // *é‡åˆ°å…ˆå‡å»å€¼å†è®¡ç®—çš„ï¼Œæœ€å¥½ç”¨--mï¼Œè€Œém-- while(--m&gt;=0) &#123; cs[m] = --i&gt;=0? s.charAt(i):&#x27;0&#x27;; ct[m] = --j&gt;=0? t.charAt(j):&#x27;0&#x27;; &#125; // 2.ä½ä½ç›¸åŠ  int len = cs.length; /* 1.ä¸çŸ¥é“ä¸ºä»€ä¹ˆç”¨char[] æ•°ç»„ä¿å­˜ç»“æœï¼Œæœ€åè½¬æ¢stringä¹±ç ï¼Ÿ char[] res = new char[len+1]; 2.ä¸‹é¢StringBufferç›´æ¥insertä¼šå‡ºé”™ï¼Ÿæ”¹ç”¨appendã€‚ res.insert(len+1,String.valueOf(a%10)); */ StringBuffer res = new StringBuffer(); int carry = 0; while(--len&gt;=0) &#123; // *charè½¬æ¢ä¸ºintè‡ªåŠ¨è½¬æ¢Ã— ,ä½†è½¬æ¢çš„æ˜¯ASCIIç ï¼ // å¾—è¦å‡å»-â€˜0â€™ int a = cs[len]-&#x27;0&#x27; + ct[len]-&#x27;0&#x27; + carry; // (æ˜“é”™)*a%10 æ˜¯ä½ä½ï¼›a/10 æ˜¯é«˜ä½ res.append(a%10); // æ›´æ–°è¿›ä½ carry = a/10; &#125; // 3.è¿”å›æœ€åç»“æœ if(carry != 0) // æœ€åä¾ç„¶æœ‰è¿›ä½ res.append(carry); return res.reverse().toString(); &#125; NC127: æœ€é•¿å…¬å…±å­ä¸² é¢˜ç›®æè¿° è§£æ³•æ€è·¯ ä»£ç å®ç° 1234567891011121314151617181920public int longestCommonSubsequence(String text1, String text2) &#123; int m = text1.length(), n = text2.length(); //dp[i][j] è¡¨ç¤º text1[0,i] å’Œ text1[0,j]æœ€é•¿ int[][] dp = new int[m + 1][n + 1]; // è¾¹ç•Œï¼Œiæˆ–j=0ï¼Œå­—ç¬¦ä¸²ä¸ºç©ºï¼Œdp[0][j]=dp[i][0]=0 for (int i = 1; i &lt;= m; i++) &#123; char c1 = text1.charAt(i - 1); for (int j = 1; j &lt;= n; j++) &#123; char c2 = text2.charAt(j - 1); // åŠ¨æ€æ–¹ç¨‹ if (c1 == c2) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[m][n];&#125; NC41: æœ€é•¿ä¸é‡å¤ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ é‡‡ç”¨ç»å…¸æ»‘åŠ¨çª—å£æ¥è§£å†³ï¼Œæ»‘åŠ¨çª—å£é‡Œçš„æ•°å­—éƒ½æ˜¯ä¸é‡å¤çš„ï¼š æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N æ˜¯å­—ç¬¦ä¸²çš„é•¿åº¦ã€‚ è®¾ç½®åˆå§‹æŒ‡é’ˆleft=0,right=0 æŒ‡å‘æ•°ç»„ç¬¬1ä¸ªæ•°å­—ï¼›curLen=1,maxLen=1 åˆ†åˆ«è®°å½•å½“å‰æ»‘åŠ¨çª—å£çš„é•¿åº¦ï¼Œå’Œå½“å‰æœ€å¤§çš„ä¸é‡å¤å­ä¸²é•¿åº¦ï¼› è®¾ç½®å¾ªç¯ï¼Œright å‘å³ç§»åŠ¨+1ï¼Œæ­¤æ—¶æŒ‡å‘arr[rigth] ,è®¾ç½®å¾ªç¯éå†æ»‘åŠ¨çª—å£[left,right-1] ï¼Œæ˜¯å¦å‘ç”Ÿé‡å¤ï¼› :warning: å¾ªç¯éå†ï¼Œå·²ç»ç”¨HashMapè¿›è¡Œäº†ä¼˜åŒ–ã€‚ å¦‚æœä¸å‘ç”Ÿé‡å¤ï¼Œåˆ™æ­¤æ—¶çª—å£é•¿åº¦curLen+1 ï¼Œå¹¶æ›´æ–°æœ€å¤§çª—å£é•¿åº¦maxLen = Math.max(curLen,maxLen); ç”¨HashMapä¸èƒ½åœ¨æ­¤æ—¶æ›´æ–°æœ€å¤§çª—å£é•¿åº¦ï¼Œè€Œåº”è¯¥åœ¨æœ€åã€‚è¯¦è§ä»£ç æ³¨é‡Š å¦‚æœå‘ç”Ÿé‡å¤ï¼Œæ­¤æ—¶å·¦æŒ‡é’ˆæŒ‡å‘é‡å¤æ•°ä¹‹åï¼Œæ›´æ–°çª—å£é•¿åº¦curLen = right-left+1; ç›´è‡³rightæŒ‡é’ˆåˆ°è¾¾æ•°ç»„æœ«å°¾ï¼Œè¿”å›æœ€å¤§çª—å£é•¿åº¦ã€‚ ã€æ€ç»´éš¾ç‚¹ã€‘ é™·å…¥ä½¿ç”¨åŠ¨æ€è§„åˆ’ï¼Œè€Œä¸çŸ¥é“å¦‚ä½•ä¸‹æ‰‹ï¼› åˆ¤æ–­å‘ç”Ÿé‡å¤ï¼Œå¯¹HashMapä¸ç†Ÿæ‚‰ï¼Œæœ€åè¿˜æ˜¯ç”¨äº†å¾ªç¯ HashMapä¸å…è®¸é”®å€¼é‡å¤ï¼Œå¦‚æœå‘ç”Ÿé‡å¤ä¼šç”¨åé¢çš„å€¼è¦†ç›– å¯ä»¥åˆ©ç”¨è¿™ä¸ªç‰¹æ€§æ¯æ¬¡right å‘å³ç§»åŠ¨éƒ½ç”¨HashMapè®°å½•é”®å€¼å¯¹&lt;arr[right],right&gt; ï¼Œä¿è¯é‡å¤çš„keyï¼Œæ•°ç»„åºåˆ—å·ä¸€å®šæ˜¯åé¢çš„ ç„¶ååœ¨åˆ¤æ–­æ˜¯å¦å‘ç”Ÿé‡å¤æ—¶ï¼Œåˆ¤æ–­æ˜¯å¦åœ¨HashMapä¸­ï¼Œä½†æ˜¯å¯èƒ½å‡ºç°å‘ç”Ÿé‡å¤ï¼Œä½†ä¸åœ¨å½“å‰æ»‘åŠ¨çª—å£ä¸­ï¼Œæ‰€ä»¥è¿˜è¦åˆ¤æ–­ä¸‹é‡å¤å…ƒç´ çš„valueæ˜¯å¦&gt;left ä»£ç å®ç° 1234567891011121314151617181920212223242526272829public int maxLength (int[] arr) &#123; int left=0,right=0; int maxLen=1,curLen=1; // *æ³¨æ„åˆå§‹æ¡ä»¶curLen HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); while(++right&lt;arr.length) // å³æŒ‡é’ˆæ¯æ¬¡å¾ªç¯å‘å³ç§»åŠ¨ &#123; map.put(arr[right-1],right-1); // åˆ¤æ–­å½“å‰å³æŒ‡é’ˆæ˜¯å¦å’Œå‰é¢åºåˆ—å‘ç”Ÿé‡å¤ // æ ¹æ®æ˜¯å¦é‡å¤åšå‡ºåˆ¤æ–­ if(! map.containsKey(arr[right])) &#123; curLen++; &#125; else // å‘ç”Ÿé‡å¤ &#123; // æ”¹å˜leftæŒ‡é’ˆæŒ‡å‘åˆ°é‡å¤æ•°å­—ä¹‹å // ä½†è¦ä¿è¯ä¸€å®šæ˜¯åœ¨å½“å‰æ»‘åŠ¨çª—å£å†…[left,right-1] left = Math.max(left, map.get(arr[right])+1); curLen = right-left+1; &#125; // *æ˜“é”™ï¼Œæ­¤æ—¶æœ€å¤§å€¼æ›´æ–°ä¸€å®šè¦åœ¨æœ€ååˆ¤æ–­ // è€Œä¸æ˜¯æ”¾åœ¨ifè¯­å¥å†… // å› ä¸ºç”¨HashMapåˆ¤æ–­ä¼šå¯¼è‡´ï¼Œå‡ºç°é‡å¤ä½† // å®é™…å¹¶ä¸åœ¨æ»‘åŠ¨çª—å£å†…ï¼Œä¸ä¼šæ‰§è¡Œä¸‹é¢è¯­å¥ maxLen = Math.max(curLen,maxLen); &#125; return maxLen; &#125; NC52: æ‹¬å·åºåˆ— é¢˜ç›®æè¿° è§£æ³•æ€è·¯ æ€è·¯å¾ˆæ¸…æ™°ï¼š è®¾ç½®ä¸€ä¸ªæ ˆï¼Œéå†å­—ç¬¦ä¸²s ï¼› å¦‚æœå½“å‰æ ˆä¸ä¸ºç©ºï¼Œä¸”æ ˆé¡¶å…ƒç´ å’Œs.charAt(i) æ‹¬å·åŒ¹é…åˆ™å°†æ ˆé¡¶å…ƒç´ å‡ºæ ˆï¼› å¦åˆ™å°†s.charAt(i)å‹å…¥æ ˆï¼› å½“å¾ªç¯ç»“æŸåï¼Œå¦‚æœæ‹¬å·éƒ½åŒ¹é…ï¼Œæ­¤æ—¶æ ˆåº”è¯¥ä¸ºç©ºï¼Œè¿”å›true ï¼›å¦åˆ™è¿”å›false ï¼› ä»£ç å®ç° 12345678910111213141516171819202122232425262728public boolean isValid (String s) &#123; // Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); // å¦‚æœåŒ¹é…å°±å‡ºæ ˆï¼Œå¦åˆ™å…¥æ ˆ for(int i=0 ; i&lt;s.length();i++) &#123; if(!stack.isEmpty() &amp;&amp; isMatch(stack.peek(),s.charAt(i))) // æ­¤æ—¶åŒ¹é…åˆ™å‡ºæ ˆ stack.pop(); else stack.push(s.charAt(i)); &#125; // å¦‚æœéƒ½åŒ¹é…æœ€åçš„æ ˆåº”è¯¥æ˜¯ç©ºçš„ if(stack.isEmpty()) return true; else return false; &#125; public boolean isMatch(char c1,char c2) &#123; if(c1==&#x27;(&#x27; &amp;&amp; c2==&#x27;)&#x27;) return true; if(c1==&#x27;[&#x27; &amp;&amp; c2==&#x27;]&#x27;) return true; if(c1==&#x27;&#123;&#x27; &amp;&amp; c2==&#x27;&#125;&#x27;) return true; return false; &#125; NC103: åè½¬å­—ç¬¦ä¸² é¢˜ç›®æè¿° è§£æ³•æ€è·¯ æ€è·¯ï¼š é¦–å°¾è®¾ç½®åŒæŒ‡é’ˆï¼Œäº¤æ¢é¦–å°¾å…ƒç´ å³å¯ ã€ç¼–ç éš¾ç‚¹ã€‘ Stringç±»å‹ä¸èƒ½ä¿®æ”¹ï¼Œåº”è¯¥è½¬æ¢ä¸ºchar[] åœ¨åŸåœ°äº¤æ¢ String å’Œ char[] äº’è½¬ä¸ç†Ÿæ‚‰ ä»£ç å®ç° 1234567891011121314public String solve (String str) &#123; // æ€è·¯ï¼šåŒæŒ‡é’ˆ+äº¤æ¢ // *stringç±»å‹ä¸èƒ½ä¿®æ”¹ï¼Œæ‰€ä»¥å…ˆè½¬æ¢ä¸ºèƒ½ä¿®æ”¹çš„charæ•°ç»„ char[] cstr = str.toCharArray(); // å¾ªç¯éå† for(int i=0,j=cstr.length-1; i&lt;j; i++,j--) &#123; char tmp = cstr[i]; cstr[i] = cstr[j]; cstr[j] = tmp; &#125; return new String(cstr); &#125; NC41: å­—ç¬¦ä¸²æ’åˆ—ç»„åˆ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ ä»£ç å®ç° NC17: æœ€é•¿å›æ–‡å­ä¸² é¢˜ç›®æè¿° è§£æ³•æ€è·¯ ä»£ç å®ç° 1 NC49: æœ€é•¿æ‹¬å·å­ä¸² é¢˜ç›®æè¿° è§£æ³•æ€è·¯ ä»£ç å®ç° NC41: æœ€é•¿ä¸é‡å¤ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ ä»£ç å®ç° NC41: æœ€é•¿ä¸é‡å¤ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ ä»£ç å®ç° NC41: æœ€é•¿ä¸é‡å¤ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ ä»£ç å®ç° å­—ç¬¦ä¸²ç¬¬ä¸€ä¸ªä¸é‡å¤çš„æ•°å­—å…ˆä¸€ä¸ªint[26]ç»Ÿè®¡26ä¸ªå­—æ¯å‡ºç°æ¬¡æ•°ï¼Œç„¶åè¿”å›æ¬¡æ•°ä¸º1çš„ã€‚ 12345678910111213public int firstUniqChar(String s) &#123; int[] arr = new int[26]; int n = s.length(); for (int i = 0; i &lt; n; i++) &#123; arr[s.charAt(i)-&#x27;a&#x27;]++ ; &#125; for (int i = 0; i &lt; n; i++) &#123; if (arr[s.charAt(i)-&#x27;a&#x27;] == 1) &#123; return i; &#125; &#125; return -1; &#125; åè¿›åˆ¶è½¬äºŒè¿›åˆ¶123456789101112131415161718192021class Solution &#123; public String printBin(double num) &#123; StringBuilder builder = new StringBuilder(&quot;0.&quot;); for (int i = 0; i &lt; 33; i++) &#123; num *= 2; if (num &gt;= 1) &#123; // å–æ•´æ•°éƒ¨åˆ† builder.append(&quot;1&quot;); // å–å®Œåå‡1å–å°æ•°éƒ¨åˆ† num -= 1; &#125; else &#123; builder.append(0); &#125; if (num == 0) &#123; return builder.toString(); &#125; &#125; return &quot;ERROR&quot;; &#125;&#125; å¾®ä¿¡æŠ¢çº¢åŒ…ç®—æ³•1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void main(String[] args) &#123; double sum = 0; ArrayList&lt;Double&gt; res = WXRedPackageAlgorithm(10,3); for(double money:res) &#123; sum += money; System.out.print(money +&quot; &quot;); &#125; System.out.println(); System.out.println(sum); &#125;private static ArrayList&lt;Double&gt;WXRedPackageAlgorithm(double restMoney,int restNum)&#123; ArrayList&lt;Double&gt; res = new ArrayList&lt;&gt;(restNum); Random random=new Random(); while(restNum&gt;1) &#123; //æœ€å¤§çš„çº¢åŒ…ä¸ºï¼šä¸¤å€çš„å¹³å‡çº¢åŒ…å¤§å° double max=(restMoney/restNum) * 2; //äº§ç”Ÿ[0,1)ä¹‹é—´çš„éšæœºæ•° double r=random.nextDouble(); //æŠ¢åˆ°çš„çº¢åŒ…åŒºé—´[0,max) double money = r * max; if(money&lt;0.01) money = 0.01; else money= Math.floor(money*100)/100; res.add(money); restNum--; restMoney -= money; &#125; //æœ€åä¸€ä¸ªçº¢åŒ…ä¸ºå‰©ä½™ä½™é¢ res.add(Math.floor(restMoney*100)/100 ); return res;&#125; 1.4 é“¾è¡¨å’Œæ ˆNC78: åè½¬é“¾è¡¨ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ å‡è®¾å­˜åœ¨é“¾è¡¨ 1â†’2â†’3â†’âˆ…ï¼Œæˆ‘ä»¬æƒ³è¦æŠŠå®ƒæ”¹æˆâˆ…â†1â†2â†3ã€‚ æ ¸å¿ƒéš¾ç‚¹ï¼š è®¾ç½®ä¸‰ä¸ªæŒ‡é’ˆåˆå§‹åŒ–é—®é¢˜ï¼Œp,q,q_next,è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå½“å‰èŠ‚ç‚¹ï¼Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹; ä¸ºäº†æ“ä½œç»Ÿä¸€ï¼Œå‰ä¸€ä¸ªèŠ‚ç‚¹åº”è¯¥æŒ‡å‘null æ›´æ–°èŠ‚ç‚¹é—®é¢˜ï¼Œæ”¾åœ¨å¾ªç¯å¼€å¤´è¿˜æ˜¯æœ«å°¾ ä»£ç å®ç°è§ä¸‹ã€‚ ä»£ç å®ç° 12345678910111213141516171819202122public ListNode ReverseList(ListNode head) &#123; if(head==null) return head; // *p,q,q_next,åˆ†åˆ«è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå½“å‰èŠ‚ç‚¹ï¼Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹ // *ä¸ºäº†æ“ä½œç»Ÿä¸€ï¼Œpæœ€å¼€å§‹æŒ‡å‘nullï¼ï¼ ListNode p = null; ListNode q = head,q_next=head; while(q!=null) &#123; // *ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ›´æ–°æ”¾åœ¨å¾ªç¯å¼€å§‹ï¼Œè€Œéæœ«å°¾ // é¿å…q.next==nullæ—¶ï¼Œq.next.nextèµ‹å€¼ç»™q.nextå‡ºé”™ q_next = q.next; // æ”¹å˜qæŒ‡å‘ q.next=p; // *æ›´æ–°å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå½“å‰æ›´æ–°p,qèŠ‚ç‚¹åªèƒ½åœ¨å¾ªç¯æœ«å°¾ // å› ä¸ºåé¢ä»£ç q.next=pï¼Œè¦æ“ä½œpï¼Œqï¼Œåœ¨æ­¤ä¹‹å‰ä¸èƒ½æ›´æ–°pï¼Œq p=q; q=q_next; &#125; return p; &#125; NC93: LRU é¢˜ç›®æè¿° è§£æ³•æ€è·¯ é¦–å…ˆæ¢è®¨ä½¿ç”¨ä½•ç§æ•°æ®ç»“æ„ï¼š å“ˆå¸Œè¡¨ï¼šé€šè¿‡keyå®šä½è¦æ“ä½œçš„èŠ‚ç‚¹ï¼ŒO(1)å¤æ‚åº¦ åŒå‘é“¾è¡¨ï¼šå®ç°èŠ‚ç‚¹æ’å…¥ã€åˆ é™¤ã€è·å–å€¼ç­‰æ“ä½œï¼ŒO(1)å¤æ‚åº¦ æ‰€ä»¥æœ€ç»ˆçš„æ•°æ®ç»“æ„å½¢å¼å¦‚ä¸‹ï¼š 1HashMap&lt;int key,DLinkedNode&gt; map ; DLinkedNode æ˜¯åŒé“¾è¡¨èŠ‚ç‚¹ï¼š 1234567891011class DLinkedNode&#123; // é”®å€¼å¯¹ int key,value ; // å‰åæŒ‡é’ˆ DLinkedNode pre,next; public DLinkedNode() &#123; pre = next = null; &#125; public DLinkedNode(int k, int v) &#123; key = k; value = v;&#125;&#125; å…·ä½“å®ç°åŒé“¾è¡¨DLinkedListçš„trickï¼š ç»Ÿä¸€æ“ä½œï¼š åŒå‘é“¾è¡¨ä½¿ç”¨ä¼ªå¤´éƒ¨å’Œä¼ªå°¾éƒ¨æ¥ç»Ÿä¸€æ’å…¥/åˆ é™¤æ“ä½œ é“¾è¡¨å®ç°ï¼Œåº”è¯¥åŒ…å«åŸºæœ¬åˆ é™¤ã€æ’å…¥æ“ä½œï¼ˆå…·ä½“ä»£ç ç•¥ï¼‰ã€‚ 123456789101112131415161718class DLinkedList&#123; // ä¼ªå¤´éƒ¨ï¼Œå°¾éƒ¨ DLinkedNode head; DLinkedNode tail; // *åˆå§‹åŒ–,âˆ…â‡Œheadâ‡Œtailâ‡Œâˆ… public DLinkedList() &#123; //*è¿™é‡Œheadå’Œtailæ˜¯å­˜åœ¨çš„ï¼Œè¦å®ä¾‹åŒ–ï¼Œè€ŒéæŒ‡é’ˆ &#125; /*å®šä¹‰ä¸€äº›é“¾è¡¨åŸºæœ¬æ“ä½œ*/ // åŒé“¾è¡¨ï¼šæ’å…¥ public void insert(DLinkedNode preNode,DLinkedNode insertNode)&#123;&#125; // åŒé“¾è¡¨ï¼šåˆ é™¤ public void del(DLinkedNode delNode)&#123;&#125; ä¸ºæ»¡è¶³é¢˜ç›®æ¡ä»¶ï¼š æ»¡è¶³æ¡ä»¶1ï¼š ä½¿ç”¨HashMap ä¿å­˜é“¾è¡¨&lt;key,å¯¹åº”èŠ‚ç‚¹&gt;ï¼Œç”¨äºå¿«é€Ÿå®šä½ï¼›åŒå‘é“¾è¡¨ç”¨äºæ»¡è¶³æ“ä½œ,O(1)å¤æ‚åº¦ æ»¡è¶³æ¡ä»¶2ï¼šé“¾è¡¨è¶Šé è¿‘å¤´éƒ¨åˆ™è¡¨ç¤ºè¶Šé¢‘ç¹ä½¿ç”¨ï¼Œæ¯æ¬¡setæ“ä½œï¼Œå°†èŠ‚ç‚¹æ’å…¥åˆ°å¤´éƒ¨ï¼›getæ“ä½œï¼Œå°†èŠ‚ç‚¹ç§»åŠ¨åˆ°å¤´éƒ¨ æ»¡è¶³æ¡ä»¶3ï¼š æ¯æ¬¡setæ“ä½œï¼Œæ£€æŸ¥å½“å‰å®¹é‡è¶…è¿‡ç¼“å­˜å¤§å°ï¼Œåˆ é™¤å°¾èŠ‚ç‚¹ å°è£…æ•°æ®ç»“æ„ HashMap&lt;int key,DLinkedNode&gt; ï¼Œå’Œå¯¹åº”æ–¹æ³• setã€get æ¥å®ç°æ»¡è¶³ä¸Šè¿°æ¡ä»¶çš„åŸºæœ¬LRUç¼“å­˜ç»“æ„ã€‚ ä»£ç å®ç° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145import java.util.*;public class LRU_Solution&#123; /** * lru design * @param operators intæ•´å‹äºŒç»´æ•°ç»„ the ops * @param k intæ•´å‹ the k * @return intæ•´å‹ä¸€ç»´æ•°ç»„ */ public int[] LRU (int[][] operators, int k) &#123; ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(); Cache cache = new Cache(k); // è¿›è¡Œæ“ä½œ // eg:[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3 for(int i=0; i&lt;operators.length;i++) &#123; int opt = operators[i][0]; int key = operators[i][1] ,value; if(opt==1) &#123; value = operators[i][2]; cache.set(key,value); &#125; else arr.add(cache.get(key)); &#125; // è¿”å›æœ€åç»“æœ int[] res = new int[arr.size()]; for(int i=0; i&lt;arr.size();i++) res[i]=arr.get(i); return res; &#125;&#125;class Cache&#123; int capacity,len; // hashmap ä¿å­˜æ‰€æœ‰èŠ‚ç‚¹ï¼Œå¿«é€Ÿç´¢å¼• HashMap&lt;Integer,DLinkedNode&gt; map ; // é“¾è¡¨ DLinkedList dll; public Cache(int capacity) &#123; this.capacity = capacity; this.len = 0; map = new HashMap&lt;Integer,DLinkedNode&gt;(); dll = new DLinkedList(); &#125; public void set(int key,int value) &#123; // æ–°å»ºèŠ‚ç‚¹ DLinkedNode node = new DLinkedNode(key,value); if(len&gt;=capacity) &#123; // é•¿åº¦è¶…è¿‡å®¹é‡ï¼Œç§»é™¤æœ€ä¸å¸¸ä½¿ç”¨çš„è®°å½•ï¼ˆå°¾éƒ¨ï¼‰ // *hashmapæ“ä½œï¼šmapç§»é™¤å¯¹åº”key // *ç§»é™¤çš„æ˜¯è¢«åˆ é™¤çš„å°¾èŠ‚ç‚¹çš„keyï¼ï¼ map.remove(dll.tail.pre.key); // åŒé“¾è¡¨æ“ä½œ:ç§»é™¤ dll.del(dll.tail.pre); // *é•¿åº¦-1 len--; &#125; // é“¾è¡¨å¤´éƒ¨æ’å…¥æ–°èŠ‚ç‚¹å˜ä¸ºæœ€å¸¸ç”¨ dll.insert(dll.head, node); // *HashMapä¹Ÿè¦æ›´æ–° map.put(key,node); // cachaé•¿åº¦+1 len++; &#125; public int get(int key) &#123; DLinkedNode node = map.get(key); if(node==null) return -1; else &#123; // åˆ é™¤èŠ‚ç‚¹ dll.del(node); // ç§»åŠ¨åˆ°å¤´éƒ¨å˜ä¸ºæœ€å¸¸ç”¨ dll.insert(dll.head,node); // è¿”å›å€¼ return node.value; &#125; &#125;&#125;class DLinkedList&#123; // ä¼ªå¤´éƒ¨ï¼Œå°¾éƒ¨ DLinkedNode head,tail; // *åˆå§‹åŒ–,âˆ…â‡Œheadâ‡Œtailâ‡Œâˆ… public DLinkedList() &#123; //*è¿™é‡Œheadå’Œtailæ˜¯å­˜åœ¨çš„ï¼Œè¦å®ä¾‹åŒ–ï¼Œè€ŒéæŒ‡é’ˆ head = new DLinkedNode(); tail = new DLinkedNode(); head.next = tail; tail.pre = head; &#125; /*å®šä¹‰ä¸€äº›é“¾è¡¨åŸºæœ¬æ“ä½œ*/ // åŒé“¾è¡¨ï¼šæ’å…¥ public void insert(DLinkedNode preNode,DLinkedNode insertNode) &#123; insertNode.next = preNode.next; preNode.next.pre = insertNode; insertNode.pre = preNode; preNode.next = insertNode; &#125; // åŒé“¾è¡¨ï¼šåˆ é™¤ public void del(DLinkedNode delNode) &#123; delNode.next.pre=delNode.pre; delNode.pre.next = delNode.next; delNode.pre = delNode.next =null; &#125;&#125;class DLinkedNode&#123; // é”®å€¼å¯¹ int key,value ; // å‰åæŒ‡é’ˆ DLinkedNode pre,next;; public DLinkedNode() &#123; pre = next = null; &#125; public DLinkedNode(int k, int v) &#123; key = k; value = v; &#125;&#125; NC4: æ˜¯å¦æœ‰ç¯ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ ç•¥ï¼Œçœ‹ä»£ç  ä»£ç å®ç° 1234567891011121314151617181920212223public boolean hasCycle(ListNode head) &#123; // æ€è·¯1ï¼šå¿«æ…¢æŒ‡é’ˆï¼ˆtrickï¼‰ï¼Œæœ€ä¼˜è§£ï¼ŒO(1)å¤æ‚åº¦ // æ€è·¯2ï¼šhashmapå­˜ä¸‹æ‰€æœ‰èŠ‚ç‚¹ï¼Œç„¶åéå†èŠ‚ç‚¹å°±å»åˆ¤æ–­æ˜¯å¦åœ¨hashmapä¸­ // *è¦å…ˆåˆ¤æ–­head==nullçš„æƒ…å†µ if(head==null) return false; ListNode step1 = head; ListNode step2 = head; while(step2!= null &amp;&amp; step2.next != null) &#123; // å¥½åƒä¸ä¼šå‡ºç°step1==nullçš„æƒ…å†µï¼Ÿ // å› ä¸ºã€å¦‚æœæœ‰ç¯ã€‘ä¼šåœ¨å¿«æŒ‡é’ˆèµ°åˆ°ç»ˆç‚¹å‰å°±ç›¸é‡ step1 = step1.next; // å¾ªç¯ç»ˆæ­¢æ¡ä»¶ä»è¿™é‡Œå¾—åˆ° step2 = step2.next.next; // *ä¸èƒ½åœ¨å‰é¢åˆ¤æ–­ï¼Œå› ä¸ºåˆå§‹step1==step2 if(step1==step2) return true; &#125; return false; &#125; NC33:åˆå¹¶é“¾è¡¨ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ æ•´ä½“æ€è·¯å¦‚ä¸‹ï¼š å®šä¹‰ä¸€ä¸ªè¾…åŠ©å¤´ç»“ç‚¹head ï¼Œä»‹ç»åˆ¤æ–­ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„éº»çƒ¦ï¼›åŒæ—¶å®šä¹‰åˆå¹¶åé“¾è¡¨å·¥ä½œæŒ‡é’ˆtail ï¼Œç”¨äºåœ¨åˆå¹¶é“¾è¡¨åæ–¹ä¾¿æ’å…¥èŠ‚ç‚¹ :warning: å®šä¹‰è¾…åŠ©å¤´èŠ‚ç‚¹æ˜¯è¦å£°æ˜ç©ºé—´è¿›è¡Œåˆå§‹åŒ–çš„ï¼Œå’ŒæŒ‡é’ˆä¸åŒï¼æŒ‡é’ˆä¿å­˜çš„éƒ½æ˜¯èŠ‚ç‚¹çš„åœ°å€ï¼ :notebook_with_decorative_cover: ã€ä¸ç”¨çº ç»“ã€‘ä¹Ÿå¯ä»¥ä¸å®šä¹‰è¾…åŠ©å¤´èŠ‚ç‚¹ï¼Œä½†æ˜¯è¦å…ˆå¾—åˆ°ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ å®šä¹‰æŒ‡é’ˆh1ï¼Œh2 ï¼Œåˆ†åˆ«æŒ‡å‘é“¾è¡¨L1,L2 ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼šæ¯”è¾ƒæŒ‡é’ˆh1ï¼Œh2 æŒ‡å‘çš„å€¼å¤§å°ï¼Œå°†tail æŒ‡å‘æ›´å°çš„èŠ‚ç‚¹ï¼ŒåŒæ—¶æ›´æ–°tail å’Œç›¸åº”å·¥ä½œæŒ‡é’ˆh1ï¼Œh2 123456789101112if(h1.val &lt; h2.val)&#123; // æ›´æ–°headæŒ‡å‘æ–­å¼€çš„èŠ‚ç‚¹h1 tail.next = h1; // æ›´æ–°tailæŒ‡å‘åˆå¹¶é“¾è¡¨æœ€åæ’å…¥çš„èŠ‚ç‚¹ tail = h1; // æ›´æ–°å·¥ä½œæŒ‡é’ˆh1ä¸ºh1.next h1 = h1.next; // ä¸ç”¨æ›´æ–°*ä¹‹å‰h1æŒ‡å‘nullï¼Œå› ä¸ºæ­¤æ—¶æ˜¯tailï¼Œåé¢ä¼šæŒ‡å‘&#125;else // åŒä¸Š ç›´è‡³h1æˆ–h2 æŒ‡å‘nullï¼Œå³å…¶ä¸­ä¸€ä¸ªé“¾è¡¨è¢«éå†å®Œæˆï¼Œå°†tail ç›´æ¥æŒ‡å‘å‰©ä½™æœªéå†å®Œæˆçš„é“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå³æ­¤æ—¶ä¸ä¸ºnullå·¥ä½œæŒ‡é’ˆh1æˆ–h2 :warning: å’Œåˆå¹¶æ•°ç»„ä¸åŒï¼šæ­¤æ—¶ ä¸ç”¨å¾ªç¯æ’å…¥å‰©ä½™çš„èŠ‚ç‚¹ï¼ æŒ‡å‘ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å³å¯ï¼ æœ€åè¿”å›è¾…åŠ©å¤´èŠ‚ç‚¹çš„head.next ä»£ç å®ç° ä¸ç”¨åœ¨å¼€å¤´åˆ¤æ–­L1ï¼ŒL2 æ˜¯å¦ä¸ºnullï¼Œåé¢çš„é€»è¾‘ä¼šå¤„ç†ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344public ListNode mergeTwoLists (ListNode l1, ListNode l2) &#123; // æ€è·¯ // å®šä¹‰å·¥ä½œèŠ‚ç‚¹h1,h2 ListNode h1 = l1, h2 = l2; // å®šä¹‰ä¸€ä¸ªè¾…åŠ©å¤´èŠ‚ç‚¹ï¼Œå‡å°‘å¤„ç†ç¬¬ä¸€ä¸ªèŠ‚ç‚¹éº»çƒ¦ // è¾…åŠ©å¤´èŠ‚ç‚¹è‚¯å®šæ˜¯è¦ã€åˆå§‹åŒ–ã€‘ ListNode head = new ListNode(0); // *å®šä¹‰ä¸€ä¸ªå°¾æŒ‡é’ˆï¼ˆä¸ºäº†ä¿ç•™headè¿”å›ï¼‰ // *è¿™ä¸ªå°¾æŒ‡é’ˆåªå¯¹æŒ‡å‘çš„èŠ‚ç‚¹æ“ä½œ ListNode tail = head; while(h1!=null &amp;&amp; h2!=null) &#123; // åˆ¤æ–­å¤§å° if(h1.val &lt; h2.val) &#123; // æ›´æ–°headæŒ‡å‘æ–­å¼€çš„èŠ‚ç‚¹h1 tail.next = h1; // æ›´æ–°tailæŒ‡å‘åˆå¹¶é“¾è¡¨æœ€åæ’å…¥çš„èŠ‚ç‚¹ tail = h1; // æ›´æ–°å·¥ä½œæŒ‡é’ˆh1ä¸ºh1.next h1 = h1.next; // ä¸ç”¨æ›´æ–°*ä¹‹å‰h1æŒ‡å‘null &#125; else &#123; // æ›´æ–°headæŒ‡å‘æ–­å¼€çš„èŠ‚ç‚¹h2 tail.next = h2; // æ›´æ–°tailæŒ‡å‘åˆå¹¶é“¾è¡¨æœ€åæ’å…¥çš„èŠ‚ç‚¹ tail = h2; // æ›´æ–°å·¥ä½œæŒ‡é’ˆh2 h2 = h2.next; &#125; &#125; // tailç›´æ¥æŒ‡å‘å‰©ä¸‹é“¾è¡¨ // *ä¸ç”¨å¾ªç¯ä¸€ä¸ªä¸ªæ’å…¥åˆ°tailåé¢ï¼ if(h1 != null) tail.next = h1; if(h2 != null) tail.next = h2; return head.next; &#125; NC76: æ ˆå®ç°é˜Ÿåˆ— é¢˜ç›®æè¿° æ€è·¯è§£æ é¦–å…ˆåˆ†æé˜Ÿåˆ—å’Œæ ˆçš„ä¸¤ä¸ªæ“ä½œçš„ä¸åŒï¼š push pop é˜Ÿåˆ— å°¾éƒ¨æ’å…¥ å¤´éƒ¨å¼¹å‡º æ ˆ å°¾éƒ¨æ’å…¥ å°¾éƒ¨å¼¹å‡º æ˜¾ç„¶å¯¹äºé˜Ÿåˆ—çš„push æ“ä½œå¯ä»¥ç›´æ¥ç”¨æ ˆpush æ“ä½œæ¥å®ç° ï¼› é‚£é˜Ÿåˆ—çš„popæ“ä½œå¦‚ä½•ç”¨æ ˆæ¥å®ç°å‘¢ï¼Ÿ å‡å®šå®ç°é˜Ÿåˆ—push ç”¨*stack1æ¥*push å®ç°ï¼Œå°¾éƒ¨æ’å…¥ é‚£ä¹ˆéœ€è¦ç”¨æ ˆpop å®ç°é˜Ÿåˆ— pop ï¼Œå¿…é¡»è¦å…ˆå°†å·²æœ‰â€é˜Ÿåˆ—â€œstack1ä¸­æ•°æ®é€†ç½®ï¼šå³å°†stack1ä¸­æ‰€æœ‰æ•°æ®éƒ½popï¼Œåœ¨pushåˆ°stack2ä¸­ stack2 å†ä½¿ç”¨æ ˆpop å‡ºçš„å°±æ˜¯â€é˜Ÿåˆ—â€œstack1 ä¸­çš„å¤´éƒ¨ï¼Œå³æ¨¡æ‹Ÿäº†é˜Ÿåˆ—çš„pop å¯¹äºåç»­çš„é˜Ÿåˆ—pop ï¼Œ éƒ½å¯ä»¥ç›´æ¥pop å‡ºstack2ä¸­çš„å…ƒç´ ï¼›å¦‚æœstack2ä¸ºç©ºï¼Œå°±å°†stack1 ä¸­å…ƒç´ é€†ç½®åˆ°stack2ä¸­ï¼Œå†pop æ€»ç»“æ ¸å¿ƒæ“ä½œï¼š é˜Ÿåˆ—pushï¼Œç›´æ¥ç”¨æ ˆpushå®ç°ï¼Œéƒ½æ˜¯â€œå°¾éƒ¨æ’å…¥â€ é˜Ÿåˆ—popï¼Œå¯ä»¥å…ˆå°†é˜Ÿåˆ—ä¸­æ•°æ®é€†ç½®ï¼ˆä¸¤ä¸ªæ ˆäº¤æ¢æ•°æ®ï¼‰ï¼Œå†ç”¨æ ˆpopâ€œå¤´éƒ¨â€å¼¹å‡º ä»£ç å®ç° 12345678910111213141516171819202122public class Solution&#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if(stack2.empty()) &#123; // å°†stack1å…¨éƒ¨è½¬ç§»åˆ°stack2ä¸­ while(!stack1.empty()) stack2.push(stack1.pop()); &#125; // ç„¶åå†popå‡ºæ¥ return stack2.pop(); &#125;&#125; NC50: é“¾è¡¨kç¿»è½¬ é¢˜ç›®æè¿° è§£ææ€è·¯ ã€å¥—ç¿»è½¬æ¨¡æ¿ã€‘å…ˆæ€è€ƒå¦‚ä½•ç¿»è½¬æŒ‡å®šé¦–å°¾çš„é“¾è¡¨ï¼š ä¿®æ”¹1ï¼šè€ƒè™‘ç¿»è½¬å¾ªç¯è¾¹ç•Œæ¡ä»¶ ä¿®æ”¹2ï¼šé¦–å°¾èŠ‚ç‚¹æŒ‡å‘ éå†é“¾è¡¨ï¼Œè®¾ç½®æŒ‡é’ˆpre,f,e åˆ†åˆ«æŒ‡å‘è¦åè½¬é“¾è¡¨æ®µ çš„ï¼šé¦–èŠ‚ç‚¹å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œé¦–èŠ‚ç‚¹ï¼Œå°¾èŠ‚ç‚¹ 12// åˆå§‹æ®µé¦–å°¾èŠ‚ç‚¹éƒ½æŒ‡å‘é¦–èŠ‚ç‚¹ListNode pre = null, f = head, f = head; å°¾æŒ‡é’ˆeç§»åŠ¨å¹¶è®¡æ•°ï¼Œå¦‚æœæ»¡è¶³count % k == 0 è¯´æ˜æ‰¾åˆ°å°¾èŠ‚ç‚¹ï¼Œåˆ™åè½¬æŒ‡å®šé¦–å°¾çš„é“¾è¡¨ï¼Œç„¶åæ›´æ–°æŒ‡é’ˆ 12pre = f; // æŒ‡å‘ä¸‹ä¸€ä¸ªåè½¬æ®µçš„é¦–èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ f = e = f.next; // é¦–å°¾åˆå§‹æŒ‡å‘é¦–èŠ‚ç‚¹ ç›´åˆ°ç§»åŠ¨eï¼Œå¯»æ‰¾ä¸‹ä¸€ä¸ªæ®µçš„å°¾èŠ‚ç‚¹å‘ç°ä¸å­˜åœ¨ï¼Œe==nullé€€å‡ºå¾ªç¯ :warning: åœ¨kåè½¬çš„é“¾è¡¨ï¼Œç¬¬ä¸€ç»„çš„ç¿»è½¬çš„é“¾è¡¨å°¾èŠ‚ç‚¹eï¼Œæ˜¯æ•´ä¸ªç¿»è½¬é“¾è¡¨çš„é¦–èŠ‚ç‚¹ï¼ ä»£ç å®ç° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// æ€è·¯// éå†é“¾è¡¨æ‰¾åˆ°æ¯æ¬¡åè½¬çš„first,end è¿›è¡Œç¿»è½¬// *ç‰¹åˆ«çš„ï¼šç¬¬ä¸€æ¬¡ç¿»è½¬endæ˜¯è¿”å›çš„å¤´ç»“ç‚¹public ListNode reverseKGroup (ListNode head, int k) &#123; ListNode pre = null; ListNode f = head; ListNode e = head; int count = 1; // è®°å½•ç¿»è½¬åé“¾è¡¨ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ ListNode firstNode = e; while (e!=null) &#123; // æ‰¾åˆ°ç¿»è½¬æ®µçš„å°¾èŠ‚ç‚¹e if(count % k == 0 ) &#123; // ç¬¬ä¸€æ¬¡ç¿»è½¬ if(count == k) firstNode = e; // ç¿»è½¬ reverse(pre,f,e); // *æ›´æ–°:æ³¨æ„æ­¤æ—¶æ®µå°¾éƒ¨æ˜¯f // *å°¾éƒ¨eç§»åŠ¨äº†ï¼Œè¦count+1 pre = f; f = e = f.next; &#125; else e = e.next; // æ— è®ºå“ªç§æƒ…å†µéƒ½è¦count++ï¼Œæ‰€ä»¥ç§»åˆ°è¿™å„¿ count++; &#125; return firstNode; &#125; // æŒ‡å®šé“¾è¡¨æ®µç¿»è½¬ // å…ˆå°†[first-end] èŠ‚ç‚¹åè½¬ï¼Œå†ä¿®æ”¹åè½¬åçš„é¦–å°¾èŠ‚ç‚¹æŒ‡å‘ public ListNode reverse(ListNode pre,ListNode first,ListNode end) &#123; ListNode p = null; ListNode q = first; ListNode q_next = null; // ä¸´æ—¶èŠ‚ç‚¹å­˜å‚¨q.next while (p !=end ) // ä¿®æ”¹ï¼šåˆ°è¾¾æœ«å°¾ç»ˆæ­¢æ¡ä»¶ &#123; q_next = q.next; q.next = p; p = q; q = q_next; &#125; // ä¿®æ”¹ï¼šå¤„ç†åè½¬åçš„é¦–å°¾èŠ‚ç‚¹æŒ‡å‘ first.next = q; // ã€è¾¹ç•Œæƒ…å†µã€‘ï¼šä»å¤´èŠ‚ç‚¹å¼€å§‹åè½¬ if(pre!=null) pre.next=end; // *è¿”å›ç¿»è½¬åé“¾è¡¨é¦–èŠ‚ç‚¹end return end; &#125; NC3: ç¯å…¥å£èŠ‚ç‚¹ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ æ•°å­¦é¢˜ï¼Œé¢˜è§£è§ä¸‹ï¼š ä»£ç å®ç° å¥—ä¸ŠNC4ï¼šæ˜¯å¦æœ‰ç¯çš„æ¨¡æ¿ï¼Œè¡¥ä¸Šåç»­æ“ä½œåˆ¤æ–­å³å¯ã€‚ 1234567891011121314151617181920212223242526272829303132public ListNode detectCycle(ListNode head) &#123; // *è¦å…ˆåˆ¤æ–­head==nullçš„æƒ…å†µ if(head==null) return null; ListNode step1 = head; ListNode step2 = head; while(step2!= null &amp;&amp; step2.next != null) &#123; // å¥½åƒä¸ä¼šå‡ºç°step1==nullçš„æƒ…å†µï¼Ÿ // å› ä¸ºã€å¦‚æœæœ‰ç¯ã€‘ä¼šåœ¨å¿«æŒ‡é’ˆèµ°åˆ°ç»ˆç‚¹å‰å°±ç›¸é‡ step1 = step1.next; // å¾ªç¯ç»ˆæ­¢æ¡ä»¶ä»è¿™é‡Œå¾—åˆ° step2 = step2.next.next; // *åœ¨åé¢åˆ¤æ–­æ˜¯å¦ç›¸é‡ if(step1==step2) &#123; // ç›¸é‡,æ…¢æŒ‡é’ˆå›åˆ°èµ·ç‚¹ï¼Œå¿«æŒ‡é’ˆä¾æ—§åœ¨ç›¸é‡ç‚¹ step1 = head; // å¿«æŒ‡é’ˆä»ç›¸é‡ç‚¹ï¼Œå’Œæ…¢æŒ‡é’ˆä»èµ·å§‹ç‚¹ï¼Œã€ä¸€æ­¥ä¸€æ­¥èµ°ã€‘å†ç›¸é‡ // *ç›¸é‡çš„åœ°æ–¹å°±æ˜¯ç¯å…¥å£ while(step1!=step2) &#123; step1 = step1.next; step2 = step2.next; &#125; return step1; &#125; &#125; return null; &#125; NC53: åˆ å€’kä¸ªèŠ‚ç‚¹ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ ç®€å•ï¼Œç•¥ã€‚å…³é”®åœ¨äºæŒæ¡ä¸¤ä¸ªã€åŸºç¡€æ¨¡æ¿ã€‘ï¼š å•é“¾è¡¨åˆ é™¤èŠ‚ç‚¹ åˆ é™¤å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹æ¨¡æ¿ ä»£ç å®ç° 1234567891011121314151617181920212223242526272829303132333435363738public ListNode removeNthFromEnd (ListNode head, int n) &#123; // è¾¹ç•Œæ¡ä»¶åˆ¤æ–­ // 1.è®¾ç½®p,qæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘é¦–èŠ‚ç‚¹ï¼ŒpreæŒ‡å‘på‰ä¸€ä¸ªèŠ‚ç‚¹ // 2.qå…ˆèµ°kæ­¥ï¼Œç„¶åp,qä¸€èµ·èµ°ï¼Œç›´è‡³qæŒ‡å‘null // 3.åˆ é™¤p // 3.è¿”å›head ListNode p = head, q = head; ListNode p_pre = null; int step = n; while(q!=null) &#123; if(step&gt;0) &#123; q = q.next; step--; &#125; else &#123; p_pre = p; p = p.next; q = q.next; &#125; &#125; // åˆ é™¤p // *å½“è¦åˆ é™¤çš„èŠ‚ç‚¹æ°ä¸ºå¤´ç»“ç‚¹ if(p==head) head = head.next; else p_pre.next = p.next; return head; &#125; NC66: å…¬å…±èŠ‚ç‚¹ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ ã€æ–¹æ³•ä¸€ã€‘é¦–å…ˆå®¹æ˜“æƒ³åˆ°æš´åŠ›éå†ï¼š ä½¿ç”¨åŒå¾ªç¯ï¼Œå¯¹é“¾è¡¨1æ¯ä¸ªèŠ‚ç‚¹åœ¨é“¾è¡¨2è¿›è¡Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨ç›¸åŒèŠ‚ç‚¹ ä¸Šè¿°æ—¶é—´å¤æ‚åº¦ä¸ºO(N^2) , , ç©ºé—´å¤æ‚åº¦O(1)ã€‚ ã€æ–¹æ³•äºŒã€‘å¯¹äºåˆ¤æ–­é“¾è¡¨2æ˜¯å¦å­˜åœ¨æŸä¸ªèŠ‚ç‚¹ï¼Œå¯ä»¥ç”¨hashmap å­˜å‚¨æ‰€æœ‰é“¾è¡¨2çš„èŠ‚ç‚¹ï¼Œè¿™æ ·åˆ¤æ–­æ—¶é—´å¤æ‚åº¦é™ä¸ºO(1) å…ˆhashmapå­˜å‚¨æ‰€æœ‰é“¾è¡¨2èŠ‚ç‚¹ï¼Œéå†é“¾è¡¨1æ¯ä¸ªèŠ‚ç‚¹ï¼Œæ˜¯å¦åœ¨é“¾è¡¨2å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨åˆ™è¿”å›å…¬å…±èŠ‚ç‚¹ æ—¶é—´å¤æ‚åº¦ä¸ºO(N) , ç©ºé—´å¤æ‚åº¦O(N)ã€‚å¦‚ä½•ç»§ç»­ä¼˜åŒ–ç©ºé—´å¤æ‚åº¦ï¼Ÿ ã€æ–¹æ³•ä¸‰ã€‘è§‚å¯Ÿå…¬å…±é“¾è¡¨ç‰¹ç‚¹ï¼šå°¾éƒ¨ç›¸åŒï¼Œä½†å‰ç¼€ä¸åŒä¸”é•¿åº¦ä¹Ÿä¸åŒã€‚ å¦‚æœçŸ¥é“å‰ç¼€é•¿åº¦å’Œç›¸å·®çš„é•¿åº¦kï¼Œ é‚£ä¹ˆå¯ï¼šè®©æ›´é•¿çš„é“¾è¡¨å·¥ä½œæŒ‡é’ˆpå…ˆèµ°kæ­¥ï¼Œç„¶åå’Œæ›´çŸ­çš„é“¾è¡¨å·¥ä½œæŒ‡é’ˆqä¸€èµ·èµ°ï¼Œåˆ¤æ–­å½“å‰æŒ‡å‘çš„èŠ‚ç‚¹ç›¸åŒå°±å¯ä»¥è¿”å›å…¬å…±èŠ‚ç‚¹ã€‚ é‚£ä¹ˆå¦‚ä½•çŸ¥é“ç›¸å·®çš„é•¿åº¦k ï¼Ÿæˆ–è€…è¯´å¦‚ä½•è®©p,qè·ç¦»å…¬å…±èŠ‚ç‚¹é•¿åº¦ä¸€è‡´ï¼Ÿ åŒæŒ‡é’ˆæ³•ã€‚ é“¾è¡¨æŒ‡é’ˆåˆå§‹p=head1,q=head2 éƒ½åŒæ—¶å¾€åèµ°ï¼Œå½“æ›´çŸ­çš„æŒ‡é’ˆï¼ˆå‡è®¾ä¸ºpï¼‰æŒ‡å‘null æ—¶ï¼Œæ›´é•¿é“¾è¡¨å·¥ä½œæŒ‡é’ˆqå‰©ä½™k æ­¥æœªèµ°ï¼› æ›´æ–°p æŒ‡å‘é•¿é“¾è¡¨å¤´head2 ï¼Œpå’Œqç»§ç»­å¾€ä¸‹èµ°ï¼› å½“qæŒ‡å‘nullæ—¶ï¼Œpè·ç¦»head2ä¹Ÿèµ°äº†kæ­¥ ï¼ŒqæŒ‡å‘head1ï¼›è¿™æ ·ä¸¤ä¸ªé“¾è¡¨çš„å·¥ä½œæŒ‡é’ˆè·ç¦»å…¬å…±èŠ‚ç‚¹çš„è·ç¦»å˜ä¿æŒä¸€è‡´äº† p,qåŒæ—¶å¾€ä¸‹èµ°ï¼Œåˆ¤æ–­é‡åˆ°çš„ç¬¬ä¸€ä¸ªç›¸åŒèŠ‚ç‚¹ä¾¿æ˜¯å…¬å…±èŠ‚ç‚¹äº† ä»£ç å®ç° å®ç°ã€æ–¹æ³•ä¸‰ã€‘ã€‚ 123456789101112public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2)&#123; if (pHead1 == null || pHead2 == null) return null; ListNode p1 = pHead1; ListNode p2 = pHead2; while (p1 != p2) &#123; p1 = p1 == null ? pHead2 : p1.next; p2 = p2 == null ? pHead1 : p2.next; &#125; return p1;&#125; NC40: é“¾è¡¨å¤§æ•°ç›¸åŠ  é¢˜ç›®æè¿° è§£æ³•æ€è·¯ æ€è·¯ç±»ä¼¼NC1 å¤§æ•°ç›¸åŠ ï¼Œä½†æ˜¯ä¸è¿›è¡Œè¡¥0æ ‡å‡†åŒ–ï¼š å…ˆåè½¬é“¾è¡¨ï¼Œä»é“¾è¡¨å¤´éƒ¨ï¼ˆä½ä½å¼€å§‹ç›¸åŠ ï¼‰ï¼Œåˆ©ç”¨åŠ æ³•å…¬å¼ï¼š 12// è®¡ç®—è¡¨è¾¾å¼int res = a+b+carry; ä½†æ˜¯ç”±äºä¸è¿›è¡Œæ ‡å‡†åŒ–ï¼Œé•¿åº¦ä¸ä¸€è‡´ï¼Œåœ¨åˆ¤æ–­æŒ‡é’ˆç§»åŠ¨æ—¶è¦åˆ¤æ–­æ˜¯å¦åˆ°æœ«å°¾ 12p1 = p1==null? null : p1.next;p2 = p2==null? null : p2.next; åŒæ ·çš„ï¼Œè·å–è®¡ç®—è¡¨è¾¾å¼$a,b$ å€¼ï¼Œä¹Ÿè¦è¿›è¡Œåˆ¤æ–­æŒ‡é’ˆä½ç½®ï¼š 12a = p1==null? 0 : p1.val;b = p2==null? 0 : p2.val; æ¯æ¬¡è®¡ç®—ç»“æœæ’å…¥å¤´ç»“ç‚¹åé¢ ï¼Œè¿”å›æœ€åçš„ç»“æœé“¾è¡¨å¤´ç»“ç‚¹ ã€éš¾ç‚¹åˆ†æã€‘ è®°å¥½åè½¬é“¾è¡¨ æ¨¡æ¿ è®°å¥½åŸºæœ¬é“¾è¡¨æ“ä½œ ,å¦‚ï¼Œæ’å…¥ ä»£ç å®ç° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public ListNode addInList (ListNode head1, ListNode head2) &#123; // 1.ä»ä½ä½å¼€å§‹ç›¸åŠ ï¼Œå…ˆé«˜ä½è¡¥0è½¬æ¢ä¸ºæ ‡å‡†åŒ–ã€char[]æ•°ç»„ã€‘ // 2.ä½†ç”±äºé•¿åº¦ä¸çŸ¥ï¼Œæ‰€ä»¥ç”¨ã€ArrayListã€‘,å¹¶ä¸”ä¸æ ‡å‡†åŒ–ï¼ˆé•¿åº¦ä¸ä¸€è‡´ï¼‰ // 3.ä½†æ˜¯ä¼šå¼•å…¥é¢å¤–çš„ç©ºé—´O(n)ï¼Œä¸å¦‚ç›´æ¥åè½¬é“¾è¡¨ï¼Œä»ä½ä½å¼€å§‹ç›¸åŠ  head1 = reverse(head1); head2 = reverse(head2); // å·¥ä½œæŒ‡é’ˆ ListNode p1 = head1, p2 = head2; // ç»“æœé“¾è¡¨ LinkList resList = new LinkList(); int a,b,carry=0; while(p1!=null || p2 != null) &#123; a = p1==null? 0 : p1.val; b = p2==null? 0 : p2.val; // è®¡ç®—è¡¨è¾¾å¼ int res = a+b+carry; // æ’å…¥æ–°èŠ‚ç‚¹åˆ°å¤´ç»“ç‚¹ resList.insert2head(new ListNode(res%10)); // æ›´æ–°è¿›ä½ carry = res/10; // å·¥ä½œæŒ‡é’ˆåç§» p1 = p1==null? null : p1.next; p2 = p2==null? null : p2.next; &#125; // å¦‚æœæœ€åè¿˜æœ‰è¿›ä½ if(carry != 0) resList.insert2head(new ListNode(carry)); return resList.head.next; &#125; // åè½¬ã€æŒ‡å®šã€‘é“¾è¡¨,é“¾è¡¨æ²¡æœ‰å¤´ç»“ç‚¹ public ListNode reverse(ListNode head) &#123; if(head == null) return null; ListNode pre = null; ListNode p = head , q=null; while(p!=null) &#123; q = p.next; p.next = pre; pre = p; p = q; &#125; return pre; &#125; &#125;class LinkList&#123; ListNode head; public LinkList() &#123; head = new ListNode(0); &#125; // æ’å…¥åˆ°ã€å½“å‰ã€‘å¤´éƒ¨ public void insert2head(ListNode newNode) &#123; ListNode tmp = head.next; head.next = newNode; newNode.next = tmp; &#125;&#125; NC51:åˆå¹¶kä¸ªæ’åºé“¾è¡¨ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ å…³é”®åœ¨äºå¥—æ¨¡æ¿ï¼š ã€æ¨¡æ¿ã€‘åˆå¹¶ä¸¤ä¸ªæ’åºé“¾è¡¨ æ˜“é”™ç‚¹ï¼š åˆå¹¶å¤´ç»“ç‚¹ä¸è®°å¾—ï¼Œä½¿ç”¨å·¥ä½œæŒ‡é’ˆå§‹ç»ˆæŒ‡å‘åˆå¹¶é“¾è¡¨æœ«å°¾ï¼ˆé”®ä»£ç ï¼‰ ä»£ç å®ç° 1234567891011121314151617181920212223242526272829303132333435363738394041public ListNode mergeKLists(ArrayList&lt;ListNode&gt; lists) &#123; if(lists.size()==0) return null; ListNode res = lists.get(0); for(int i=1 ; i&lt;lists.size(); i++) res = mergeList(res,lists.get(i)); return res; &#125; public ListNode mergeList(ListNode head1,ListNode head2) &#123; ListNode head = new ListNode(0); // *ä¿ç•™headï¼Œä½¿ç”¨å·¥ä½œæŒ‡é’ˆh ListNode h = head; while(head1 != null &amp;&amp; head2 != null) &#123; if(head1.val&lt;head2.val) &#123; h.next = head1; head1 = head1.next; &#125; else &#123; h.next = head2; head2 = head2.next; &#125; // *æŒ‡å‘åˆå¹¶é“¾è¡¨æœ«å°¾ h = h.next; &#125; // å‰©ä¸‹æœªæ’åºå®Œæˆçš„ if(head1 != null) h.next = head1; else h.next = head2; return head.next; &#125; NC70:é“¾è¡¨æ’åº é¢˜ç›®æè¿° è§£æ³•æ€è·¯ æ¨¡æ¿ï¼šå†’æ³¡æ’åº :warning: å†’æ³¡ä¼šè¶…æ—¶ï¼Œä½†æ˜¯å †æ’åºä¸ä¼šï¼ˆåé¢æ›´æ–°ä»£ç ï¼‰ 12345678910111213141516171819202122232425public ListNode sortInList (ListNode head) &#123; if(head==null) return null; ListNode p , q ; ListNode sort_first = null; for(p=head; p.next!=null; p = p.next ) // n-1è½® &#123; for(q=head; q.next!=sort_first; q = q.next)// n-å·²æ’åº-1è½® &#123; if(q.val&gt;q.next.val) swap(q,q.next); &#125; // å·²æ’åºçš„å€¼æ”¾åœ¨é“¾è¡¨ä¹‹åï¼Œè®°å½•å·²æ’åºçš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ sort_first = q; &#125; return head; &#125; public void swap(ListNode node1, ListNode node2) &#123; int tmp = node1.val; node1.val = node2.val; node2.val = tmp; &#125; æ¨¡æ¿ï¼šå½’å¹¶æ’åº æœ€ä½³é€‰æ‹©ï¼šä¿è¯äº†æœ€å¥½å’Œæœ€åæ—¶é—´å¤æ‚åº¦éƒ½æ˜¯nlognï¼Œè€Œä¸”å®ƒåœ¨æ•°ç»„æ’åºä¸­å¹¿å—è¯Ÿç—…çš„ã€åˆå¹¶é“¾è¡¨æ—¶ã€‘**ç©ºé—´å¤æ‚åº¦åœ¨é“¾è¡¨æ’åºä¸­ä¹Ÿä»O(n)é™åˆ°äº†O(1)**ã€‚ ã€å¿«æ…¢æŒ‡é’ˆã€‘æ‰¾åˆ°é“¾è¡¨ä¸­ç‚¹ï¼Œç„¶åæ‹†åˆ†æˆä¸¤ä¸ªå­é“¾è¡¨ :warning: å¿«æ…¢æŒ‡é’ˆæ³¨æ„åˆ¤æ–­æ¡ä»¶ï¼ï¼ ã€æ¨¡æ¿ï¼Œåˆå¹¶æœ‰åºé“¾è¡¨ã€‘å¦‚æœä¸¤ä¸ªé“¾è¡¨ï¼šé•¿åº¦==1ã€nullã€æœ‰åºï¼Œåˆ™åˆå¹¶ä¸¤ä¸ªé“¾è¡¨ ã€æ¨¡æ¿ï¼Œå½’å¹¶ã€‘å½’å¹¶æ’åºé€’å½’ ä»£ç å®ç° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public ListNode sortInList (ListNode head) &#123; // *è€ƒè™‘ä¼šå‡ºç°å…¶ä¸­ä¸€ä¸ªå­é“¾è¡¨ä¸ºç©ºçš„æƒ…å†µ // ä¸ºç©ºæˆ–è€…é•¿åº¦=1ï¼Œéƒ½å¯ä»¥è¿”å›è¿›è¡Œåˆå¹¶ if(head==null || head.next==null) return head; // æ‹†åˆ†æˆä¸¤ä¸ªå­é“¾è¡¨ ListNode h1 = head; ListNode mid = getMid(head); ListNode h2 = mid.next; mid.next = null; // é€’å½’æ’åº // *å­é“¾è¡¨æ’åºåï¼Œå…¶åŸå…ˆå¤´ç»“ç‚¹ä¸ä¸€å®šå†æ˜¯åˆå¹¶åå¤´ç»“ç‚¹ // *æ•…è¦æ›´æ–° h1 = sortInList(h1); h2 = sortInList(h2); // ä¸¤ä¸ªå­é“¾è¡¨éƒ½æ»¡è¶³å·²æ’åºï¼Œæˆ–è€…é•¿åº¦==1,null,åˆ™å¼€å§‹åˆå¹¶ return mergeList(h1,h2); &#125; // å¿«æ…¢æŒ‡é’ˆè·å–ä¸­ç‚¹ public ListNode getMid (ListNode head) &#123; ListNode slow = head, fast = head; // *å¦‚æœåˆ¤æ–­æ¡ä»¶æ˜¯fast!=null æˆ–è€… fast.next !=null // *ç­‰ä»·äºè®¡ç®—å¾—åˆ°çš„ä¸­ç‚¹å‘ä¸Šå–æ•´ï¼Œå½“é“¾è¡¨é•¿åº¦=2æ—¶ï¼Œ1â†’2â†’null // *mid=2ï¼Œç”±æ­¤åˆ‡å‰²çš„å­é“¾è¡¨æ˜¯ï¼š1â†’2â†’null &amp; null ï¼Œä¸ç¬¦åˆè¦æ±‚ while(fast.next != null &amp;&amp; fast.next.next !=null) &#123; slow = slow.next; fast = fast.next.next; &#125; return slow; &#125; // åˆå¹¶ä¸¤ä¸ªé“¾è¡¨ public ListNode mergeList(ListNode head1,ListNode head2) &#123; ListNode head = new ListNode(0); // *ä¿ç•™headï¼Œä½¿ç”¨å·¥ä½œæŒ‡é’ˆh ListNode h = head; while(head1 != null &amp;&amp; head2 != null) &#123; if(head1.val&lt;head2.val) &#123; h.next = head1; head1 = head1.next; &#125; else &#123; h.next = head2; head2 = head2.next; &#125; // *æŒ‡å‘åˆå¹¶é“¾è¡¨æœ«å°¾ h = h.next; &#125; // å‰©ä¸‹æœªæ’åºå®Œæˆçš„ if(head1 != null) h.next = head1; else h.next = head2; return head.next; &#125; NC96:æ˜¯å¦å›æ–‡ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ æ€è·¯ä¸€ï¼š 1.æ ˆ/æˆ–è€…æ•°ç»„ï¼Œä¿å­˜èŠ‚ç‚¹ï¼Œé€†å‘æ¯”è¾ƒ æ—¶ç©ºå¤æ‚åº¦éƒ½æ˜¯O(N) æ€è·¯äºŒï¼šâˆšï¼ˆé‡‡ç”¨ï¼‰ 1. å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°é“¾è¡¨ä¸­ç‚¹ï¼Œç¿»è½¬åé¢ã€ä¸€åŠã€‘èŠ‚ç‚¹ï¼Œæ¯”è¾ƒ 2. æ—¶é—´å¤æ‚åº¦O(N),ç©ºé—´å¤æ‚åº¦O(1) ã€éš¾ç‚¹ï¼šå¿«æ…¢æŒ‡é’ˆã€‘ 1while(fast.next != null &amp;&amp; fast.next.next != null) ä¸Šé¢è¿™ç§åˆ¤æ–­æ¡ä»¶ï¼š å¿«æ…¢æŒ‡é’ˆè¿”å›çš„æ˜¯å·¦ä¸­ä½æ•°ï¼šä¸çŸ¥é“å¥‡/å¶æ•°ä¸ªèŠ‚ç‚¹è¿”å›å…·ä½“å“ªä¸ªä½ç½® å¦‚æœæ˜¯å¶æ•°ï¼Œæ‰¾åˆ°æ˜¯å·¦ä¸­ä½æ•°ï¼Œå¦‚ï¼š1â†’2â†’3â†’4â†’âˆ…ï¼ˆèŠ‚ç‚¹2ï¼‰ å¦‚æœæ˜¯å¥‡æ•°ï¼Œå°±æ˜¯ä¸­é—´èŠ‚ç‚¹ï¼Œå¦‚ï¼š1â†’2â†’3â†’âˆ…ï¼ˆèŠ‚ç‚¹2ï¼‰ è¾¹ç•Œæ¡ä»¶ï¼š è¦ä¿è¯headä¸ä¸ºnull 12if(head==null) return null; ä»£ç å®ç° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public boolean isPail (ListNode head) &#123; if(head==null) return false; if(head.next==null) // ä¸€ä¸ªæ•°å°±æ˜¯å›æ–‡ return true; // ï¼ˆå€¾å‘å·¦çš„ï¼‰å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°ä¸­é—´èŠ‚ç‚¹ // å¦‚æœæ˜¯å¶æ•°ï¼Œæ‰¾åˆ°æ˜¯å·¦ä¸­ä½æ•°ï¼Œå¦‚ï¼š1â†’2â†’3â†’4â†’âˆ…ï¼ˆèŠ‚ç‚¹2ï¼‰ // å¦‚æœæ˜¯å¥‡æ•°ï¼Œå°±æ˜¯ä¸­é—´èŠ‚ç‚¹ï¼Œå¦‚ï¼š1â†’2â†’3â†’âˆ…ï¼ˆèŠ‚ç‚¹2ï¼‰ ListNode mid = getMid(head); // ç¿»è½¬èŠ‚ç‚¹ ListNode head2 = reverse(mid.next); // æ¯”è¾ƒæ˜¯å¦æ˜¯å›æ–‡ while(head2!=null) &#123; if(head.val != head2.val) return false; head2 = head2.next; head = head.next; &#125; return true; &#125; public ListNode getMid(ListNode head) &#123; // å‰é¢é€»è¾‘ä¿è¯headä¸ä¸ºnull ListNode fast = head; ListNode slow = head; while(fast.next != null &amp;&amp; fast.next.next != null) &#123; fast = fast.next.next; slow = slow.next; &#125; return slow; &#125; public ListNode reverse(ListNode head) &#123; if(head.next==null) // å‰é¢é€»è¾‘ä¿è¯headä¸ä¼šä¸ºnull return head; // é“¾è¡¨ç¿»è½¬æ¨¡æ¿ ListNode pre = null; ListNode p = head, q = null; while(p!=null) &#123; q = p.next; p.next = pre; pre = p; p = q; &#125; return pre; &#125; NC21:åŒºé—´ç¿»è½¬ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ å¯¹äºæŒ‡å®šé“¾è¡¨ï¼Œå¦‚ï¼š1â†’2â†’3â†’4â†’5â†’âˆ…ï¼Œ è®¾ç½®å·¥ä½œæŒ‡é’ˆç§»åŠ¨è®°å½•ï¼Œç¿»è½¬åŒºé—´é¦–èŠ‚ç‚¹r1 ï¼Œå’Œå°¾èŠ‚ç‚¹r2 æ ¹æ®ç¿»è½¬é“¾è¡¨æ¨¡æ¿ï¼Œreverse(r1,r2) æ˜“å°†æŒ‡å®šåŒºé—´ç¿»è½¬ä¸ºï¼Œâˆ…â†2â†3â†4ï¼Œ ç°åœ¨è¦ä¿®æ”¹ã€æ¨¡æ¿ï¼šç¿»è½¬é“¾è¡¨ã€‘é¦–å°¾èŠ‚ç‚¹æŒ‡å‘ï¼š å°¾èŠ‚ç‚¹r1 ï¼ˆ2ï¼‰æŒ‡å‘ï¼ˆ5ï¼‰ï¼šç”±äºreverse(r1,r2)æ¨¡æ¿å¯ä»¥è·å¾—ç¿»è½¬é“¾è¡¨å°¾èŠ‚ç‚¹åº”è¯¥è¿æ¥çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹qï¼ˆ5ï¼‰ï¼Œæ‰€ä»¥å¯ä»¥åœ¨reverseå‡½æ•°ä¸­ç›´æ¥ä¿®æ”¹å°¾èŠ‚ç‚¹æŒ‡å‘ 1r1.next = q; é¦–èŠ‚ç‚¹r2ï¼ˆ4ï¼‰ã€è¢«ã€‘ï¼ˆ1ï¼‰æŒ‡å‘ï¼šç”±äºèŠ‚ç‚¹ï¼ˆ1ï¼‰åœ¨ç¿»è½¬ä¸­æ²¡æ³•è·å–ï¼Œæ‰€ä»¥è¿˜è¦åœ¨1. ä¸­è®°å½•r1 å‰ä¸€ä¸ªèŠ‚ç‚¹ pre ã€‚ å› æ­¤reverse(pre,r1,r2)å¢åŠ ä¸€ä¸ªå‚æ•°pre è¿›è¡Œä¼ é€’ 12if(pre != null) // ä»å¤´èŠ‚ç‚¹å¼€å§‹ç¿»è½¬ï¼Œå‰é¢æ— èŠ‚ç‚¹æŒ‡å‘ pre.next = tail; // é¦–èŠ‚ç‚¹ã€è¢«ã€‘æŒ‡å‘ è¿”å›ï¼šå¦‚æœæ˜¯ä»å¤´ç»“ç‚¹å¼€å§‹ç¿»è½¬ï¼Œè¿”å›ç¿»è½¬åŒºé—´å°¾èŠ‚ç‚¹ï¼›å¦åˆ™è¿”å›å¤´ç»“ç‚¹ã€‚ ã€éš¾ç‚¹åˆ†æã€‘ æŒ‡å®šåŒºé—´ç¿»è½¬ä¸ç†Ÿæ‚‰ï¼šä¿®æ”¹é¦–å°¾èŠ‚ç‚¹çš„æ“ä½œåº”è¯¥ åœ¨reverseå‡½æ•°é‡Œï¼Œè€Œä¸æ˜¯åœ¨å¤–é¢è®¾ç½®ä¸€å †èŠ‚ç‚¹è®°å½•è¾¹ç•Œï¼Œæœ€åç¿»è½¬åå†æ¥å‡½æ•°å¤–ä¿®æ”¹ã€‚å®šä¹‰å˜é‡å¤šï¼Œä¸”æ˜“é”™ å¥—è·¯ä¸ç†Ÿæ‚‰ ï¼šæŒ‡å®šåŒºé—´ç¿»è½¬çš„ï¼Œé€šé€šï¼ˆ1ï¼‰å…ˆè·å– ç¿»è½¬è¾¹ç•Œé¦–å°¾èŠ‚ç‚¹ ï¼ˆ2ï¼‰å†å¥—ç¿»è½¬æ¨¡æ¿ç¿»è½¬ï¼ˆ3ï¼‰åœ¨ç¿»è½¬å‡½æ•°å‡½æ•°é‡Œé¢ï¼Œä¿®æ”¹ç¿»è½¬åé¦–å°¾èŠ‚ç‚¹æŒ‡å‘ï¼ˆ4ï¼‰è€ƒè™‘è¾¹ç•Œæƒ…å†µï¼šä»é“¾è¡¨å¤´éƒ¨å¼€å§‹ç¿»è½¬ ä»£ç å®ç° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public ListNode reverseBetween (ListNode head, int m, int n) &#123; int count = 1; // æ‰¾åˆ°è¦åè½¬çš„åŒºé—´é¦–å°¾èŠ‚ç‚¹r1,r2 // å’Œé¦–èŠ‚ç‚¹å‰ä¸€ä¸ªèŠ‚ç‚¹r1_pre ListNode p = head, pre = null; ListNode r1=p, r1_pre=pre; ListNode r2; while(count&lt;=n) &#123; if(count == m) &#123; r1_pre = pre; r1 = p; &#125; pre = p; p = p.next; count++; &#125; r2 = pre; // åè½¬æŒ‡å®šåŒºé—´é“¾è¡¨ // *ä¼ å‚r1_preæ–¹ä¾¿åœ¨åè½¬æ—¶ã€å‡½æ•°å†…éƒ¨ã€‘ä¿®æ”¹é“¾è¡¨é¦–å°¾æŒ‡å‘ ListNode reverse_head = reverse(r1_pre,r1,r2); if(r1_pre == null) // æ­¤æ—¶ä»å¤´éƒ¨å°±å¼€å§‹åè½¬ return reverse_head; else return head; &#125; // *ç¿»è½¬æŒ‡å®šåŒºé—´é“¾è¡¨ï¼Œé™¤äº†é¦–å°¾æœ€å¥½ä¼ å‚é¦–èŠ‚ç‚¹å‰ä¸€ä¸ªèŠ‚ç‚¹ public ListNode reverse(ListNode pre_head ,ListNode head,ListNode tail) &#123; // é“¾è¡¨ç¿»è½¬æ¨¡æ¿ ListNode pre = null; ListNode p = head, q = null; while(pre!=tail) &#123; q = p.next; p.next = pre; pre = p; p = q; &#125; // *å¤„ç†é¦–å°¾èŠ‚ç‚¹ head.next = q; // å°¾èŠ‚ç‚¹æŒ‡å‘ if(pre_head != null) pre_head.next = tail; // é¦–èŠ‚ç‚¹ã€è¢«ã€‘æŒ‡å‘ return tail; &#125; NC24:åˆ é™¤é‡å¤å…ƒç´  é¢˜ç›®æè¿° è§£æ³•æ€è·¯ æœ¬é¢˜åœ¨ã€ï¼ˆæ¨¡æ¿ï¼‰åŸºç¡€ï¼šåˆ é™¤é‡å¤å…ƒç´ ã€‘ä¸Šè¿›ä¸€æ­¥è¦æ±‚ï¼Œç¬¬ä¸€æ¬¡å‡ºç°çš„é‡å¤æ•°ä¹Ÿè¦åˆ é™¤ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨æ¨¡æ¿ä¸Šè¿›è¡Œä¿®æ”¹ï¼š 1234567891011121314151617181920public ListNode deleteDuplicates (ListNode head) &#123; if(head == null || head.next == null) return head; ListNode pre = head, p = head.next; while(p!=null) &#123; if(pre.val == p.val) &#123; pre.next = p.next; p = p.next; &#125; else &#123; pre = p; p = p.next; &#125; &#125; return head; &#125; è®¾ç½®ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘preå‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå’Œä¸€ä¸ªæ ‡è®°æ˜¯å¦åˆ é™¤å½“å‰pre 123ListNode pre = head, p = head.next; ListNode tmp = null; // è®°å½•preå‰çš„èŠ‚ç‚¹boolean isDel = false; ã€å¢åŠ ã€‘æ¯æ¬¡preå³å°†ç§»åŠ¨æ—¶ï¼ˆpre.val != p.valï¼‰,å³ä¸å­˜åœ¨å’Œpreç›¸åŒçš„æ•°äº†ï¼Œåˆ¤æ–­å½“å‰preæ˜¯å¦è¦åˆ é™¤ã€‚ å¦‚æœå­˜åœ¨è¿‡å’Œpreç›¸åŒçš„æ•°é‚£ä¹ˆå°±è¦åˆ é™¤å®ƒï¼ˆisDel==trueï¼‰ã€‚ :warning: åªæœ‰preæ²¡æœ‰è¢«åˆ é™¤æ—¶ï¼Œæ‰èƒ½æ›´æ–°tmpæŒ‡å‘pre ï¼›å¦‚æœè¢«åˆ é™¤ï¼Œä¸ä¿®æ”¹æŒ‡å‘ï¼ˆæ­¤æ—¶ä¼šå°† tmp.next = pï¼Œæ­¤æ—¶tmpæŒ‡å‘p ï¼Œè€Œåé¢åˆæ›´æ–°äº†preæŒ‡å‘p ï¼Œé‚£ä¹ˆtmpå°±æ˜¯preå‰ä¸€ä¸ªèŠ‚ç‚¹ï¼‰ 123456789101112131415161718else // pre.val != p.val &#123; if(isDel) // preç§»åŠ¨åˆ°ä¸‹ä¸€ä½æ—¶åˆ¤æ–­æ˜¯å¦åˆ é™¤pre &#123; if(pre==head) // *åˆ é™¤å¤´ç»“ç‚¹ head = head.next; else tmp.next = p; &#125; else // *preæ²¡åˆ ï¼Œtmpæ‰æ›´æ–° &#123; tmp = pre; &#125; isDel = false; pre = p; p = p.next; &#125; ã€å¢åŠ ã€‘åœ¨pre.val == p.val æ—¶æˆ‘ä»¬ä¹Ÿè¦å¢åŠ åˆ¤æ–­ä¸€ç§è¾¹ç•Œæƒ…å†µï¼šé“¾è¡¨æ‰€æœ‰æ•°å€¼éƒ½ç›¸åŒï¼Œåˆ é™¤åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œå¦‚æ­¤æ—¶é“¾è¡¨1â†’âˆ… ã€‚ä½†æ­¤æ—¶p æŒ‡å‘âˆ… ï¼Œä¸ä¼šè¿›å…¥ä¸‹ä¸€æ¬¡å¾ªç¯å»åˆ¤æ–­åˆ é™¤1 ï¼Œå› æ­¤è¦è¿›è¡Œè¾¹ç•Œåˆ¤æ–­ã€‚ 1234567891011121314if(pre.val == p.val) &#123; pre.next = p.next; // åˆ é™¤p p = p.next; // å­˜åœ¨å’Œpreç›¸åŒçš„å…ƒç´ ï¼Œç­‰åˆ é™¤å®Œé‡å¤çš„ï¼Œpreä¹Ÿè¦åˆ  isDel = true; if(p==null) // *è¾¹ç•Œï¼špå·²æŒ‡å‘nullï¼Œä½†preè¦åˆ é™¤ &#123; if(tmp!=null) // *è¾¹ç•Œï¼šé“¾è¡¨å…¨ç›¸åŒï¼Œåˆ é™¤æœ€åä¸€ä¸ªæ•° tmp.next = p; else return null; &#125; &#125; ä»£ç å®ç° 123456789101112131415161718192021222324252627282930313233343536373839404142434445public ListNode deleteDuplicates (ListNode head) &#123; if(head == null || head.next == null) return head; ListNode pre = head, p = head.next; ListNode tmp = null; // è®°å½•preå‰çš„èŠ‚ç‚¹ boolean isDel = false; while(p!=null) &#123; if(pre.val == p.val) &#123; pre.next = p.next; // åˆ é™¤p p = p.next; // å­˜åœ¨å’Œpreç›¸åŒçš„å…ƒç´ ï¼Œç­‰åˆ é™¤å®Œé‡å¤çš„ï¼Œpreä¹Ÿè¦åˆ  isDel = true; if(p==null) // *è¾¹ç•Œï¼špå·²æŒ‡å‘nullï¼Œä½†preè¦åˆ é™¤ &#123; if(tmp!=null) // *è¾¹ç•Œï¼šé“¾è¡¨å…¨ç›¸åŒï¼Œåˆ é™¤æœ€åä¸€ä¸ªæ•° tmp.next = p; else return null; &#125; &#125; else // pre.val == p.val &#123; if(isDel) // preç§»åŠ¨åˆ°ä¸‹ä¸€ä½æ—¶åˆ¤æ–­æ˜¯å¦åˆ é™¤pre &#123; if(pre==head) // åˆ é™¤å¤´ç»“ç‚¹ head = head.next; else tmp.next = p; &#125; else // *preæ²¡åˆ ï¼Œtmpæ‰æ›´æ–° &#123; tmp = pre; &#125; isDel = false; pre = p; p = p.next; &#125; &#125; return head; &#125; NC133:å¥‡å¶é‡æ’ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ æ€è·¯ä¸€ï¼ˆè¶…æ—¶ï¼‰ è®¾ç½®æŒ‡é’ˆåˆå§‹Pre=head,q=head.next.next ä½¿ç”¨ä¸´æ—¶èŠ‚ç‚¹tmpè®°å½•ä¸‹ä¸€ä¸ªå¾…æ“ä½œçš„èŠ‚ç‚¹tmp=q.next.next, ç„¶åï¼š åˆ é™¤èŠ‚ç‚¹q æ’å…¥åˆ°Preåé¢ æ›´æ–°pre=qï¼Œq=tmp ç›´è‡³tmp==null æ€è·¯äºŒï¼ˆé€šè¿‡ï¼‰ å°†å¥‡æ•°ã€å¶æ•°èŠ‚ç‚¹åˆ†åˆ«é“¾æ¥èµ·æ¥ï¼Œç„¶åå°†å¶æ•°èŠ‚ç‚¹ä¸²è”åœ¨å…¶åï¼Œå…·ä½“ï¼š è®¾ç½®ä¸¤ä¸ªä¼ªèŠ‚ç‚¹evenHead ã€oddHead ï¼Œå’Œä¸¤ä¸ªå·¥ä½œæŒ‡é’ˆï¼ševen = evenHead, odd = evenHead; ï¼Œä»¥åŠä¸€ä¸ªå·¥ä½œæŒ‡é’ˆp=head å°†odd.next æŒ‡å‘pï¼ˆå¥‡æ•°èŠ‚ç‚¹ï¼‰ï¼Œ even.next æŒ‡å‘p.nextï¼ˆå¶æ•°èŠ‚ç‚¹ï¼‰ï¼Œå¹¶æ›´æ–° odd = p, even = p.next; å¦‚æœä¸‹ä¸€ä¸ªå¥‡æ•°èŠ‚ç‚¹å­˜åœ¨ï¼Œå³p.next != null || p.next.next != null , é‚£ä¹ˆæ›´æ–° p = p.next.next ï¼Œé‡å¤2ã€3ï¼Œå¦åˆ™é€€å‡ºå¾ªç¯ æœ€åå°†å¶æ•°é“¾è¡¨æ”¾åœ¨å¥‡æ•°é“¾è¡¨ä¹‹åå³å¯ ã€éš¾ç‚¹åˆ†æã€‘ æƒ³ä¸åˆ°åˆ†åˆ«ä¸²è”ä¸€ä¸ªå¥‡å¶é“¾è¡¨ï¼Œå†è¿æ¥ è®¾ç½®ä¼ªèŠ‚ç‚¹æœ‰åˆ©äºç»Ÿä¸€æ’å…¥æ“ä½œï¼Œä¹Ÿå¯ä»¥ä¿è¯é“¾è¡¨è‡³å°‘æœ‰ä¸¤ä¸ªèŠ‚ç‚¹ 12if(head==null || head.next==null || head.next.next==null) return head; ç„¶åè®©ç¬¬ä¸€ã€äºŒä¸ªèŠ‚ç‚¹åˆ†åˆ«ä¸ºå¥‡æ•°ã€å¶æ•°é“¾è¡¨çš„å¤´ç»“ç‚¹ã€‚ ä»£ç å®ç° 1234567891011121314151617181920212223242526272829public ListNode oddEvenList (ListNode head) &#123; if(head == null) return null; ListNode evenHead = new ListNode(0); ListNode oddHead = new ListNode(0); ListNode even = evenHead, odd = evenHead; ListNode p = head; while(true) &#123; odd = odd.next = p; even = even.next = p.next; if(p.next == null || p.next.next == null) break; else p = p.next.next; &#125; // å°†å¶æ•°é“¾è¡¨é“¾æ¥åœ¨å¥‡é“¾è¡¨ä¹‹å // *evenæ­¤æ—¶æŒ‡å‘å¯èƒ½ä¸ºnull if(even != null) even.next = null; odd.next = evenHead.next; return head; &#125; 1.5 åŠ¨æ€è§„åˆ’NC7: ä¹°è‚¡ç¥¨ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ å› ä¸ºæ˜¯ä¹°è‚¡ç¥¨ï¼Œæ‰€ä»¥ä¹°è‚¡ç¥¨ä¸€å®šè¦åœ¨å–è‚¡ç¥¨ä¹‹å‰ ï¼ŒåŒ…å«æ—¶é—´åºåˆ—ï¼Œå¦‚æœä¸€æ¬¡éå†æ‰¾åˆ°æœ€å¤§æœ€å°æ±‚å·®æ˜¯è¡Œä¸é€šçš„ï¼š 123456789int min=0, max=0;for(int i=0; i&lt;prices.length; i++)&#123; if(prices[i]&lt;prices[min]) min = i; else if(prices[i]&gt;prices[max]) max = i; &#125;return prices[max]-prices[min]; ä¾‹å¦‚å¯¹äºcaseï¼šnum[2,4,1] , è¾“å‡ºçš„min=1ï¼Œmax=4ï¼Œè€Œå®é™…ä¹°å…¥çš„åˆ©æ¶¦æ˜¯-3ã€‚ ä¸ºæ­¤æˆ‘ä»¬å¯ä»¥é‡‡ç”¨åŠ¨æ€è§„åˆ’çš„æ€æƒ³ï¼Œéå†æ•°ç»„pricesï¼Œå¯»æ‰¾å‰[0,i]ä¸­æœ€å¤§åˆ©æ¶¦ï¼š è®°å½•å‰[0,i-1] ä¸­è‚¡ç¥¨æœ€ä½å€¼ä¿¡æ¯minValueï¼Œå’Œæœ€å¤§åˆ©æ¶¦maxProfit ç¬¬[i]ä¸ªå…ƒç´ å‡å»å‰[0,i-1] ä¸­minValueï¼Œå¦‚æœ&gt;maxProfit, æ›´æ–°maxProfitã€‚ä»è€Œè·å–å‰[0,i]ä¸­æœ€å¤§åˆ©æ¶¦ ä»£ç å®ç° 1234567891011121314public int maxProfit (int[] prices) &#123; // å¯»æ‰¾æ•°ç»„ä¸­æœ€å¤§ã€æœ€å°æ•°å­— int minValue=prices[0], maxProfit=0,currentProfit=0; for(int i=1; i&lt;prices.length; i++) &#123; // æ›´æ–°æœ€å¤§åˆ©æ¶¦ currentProfit = prices[i]-minValue; maxProfit = currentProfit &gt; maxProfit? currentProfit:maxProfit; // æ›´æ–°æ•°ç»„å‰[0,i-1]ä¸­æœ€å°å€¼ minValue = prices[i]&lt;minValue?prices[i]:minValue; &#125; return maxProfit; &#125; NC59ï¼šä¸åŒè·¯å¾„ é¢˜ç›®æè¿° è§£æ³•åˆ†æ å‚è€ƒåŠ¨æ€è§„åˆ’ä¾‹é¢˜ï¼šä¸åŒè·¯å¾„IIï¼ˆäºŒç»´dpï¼‰ NC19: æœ€å¤§ç´¯ç§¯å’Œ é¢˜ç›®æè¿° è§£æ³•æ€è·¯ å¾ˆæ˜æ˜¾æ˜¯åˆ°åŠ¨æ€è§„åˆ’é¢˜ç›®ï¼ŒæŒ‰ç…§åŠ¨æ€è§„åˆ’æ–¹å¼è¿›è¡Œè§£é¢˜å¯ä»¥å¤§å¹…åº¦é™ä½æ€ç»´è´Ÿæ‹… ï¼š å‚è€ƒè§£æï¼šä»æš´åŠ›ç ´è§£åˆ°åŠ¨æ€è§„åˆ’ , è®²è§£å¾—å¾ˆæ¸…æ™°ã€‚ çŠ¶æ€å®šä¹‰ï¼šdp[i]è¡¨ç¤ºä»¥nums[i] ç»“å°¾çš„æ‰€æœ‰å­æ•°ç»„ï¼ˆä¸æ˜¯æ‰€æœ‰å¯èƒ½å­æ•°ç»„ï¼‰æ±‚å’Œæœ€å¤§å€¼ã€‚ ä¾‹å¦‚dp[3] è¡¨ç¤º$sum(0,3)ã€sum(1,3)ã€sum(2,3)ã€sum(3,3)$ ä¸­æœ€å¤§å€¼ã€‚æ‰€æœ‰dp[i] åŒ…å«æ‰€æœ‰å¯èƒ½çš„å­æ•°ç»„ï¼Œå®ƒä»¬çš„æœ€å¤§å€¼ç´¯å’Œæœ€å¤§å€¼ã€‚ è½¬ç§»æ–¹ç¨‹ï¼š è½¬ç§»æ–¹ç¨‹è§ä¸‹ ä»¥dp[3]ä¸ºä¾‹ï¼Œæ‰¾å¯»$sum(0,3)ã€sum(1,3)ã€sum(2,3)ã€sum(3,3)$ä¸­æœ€å¤§å€¼ ï¼Œç”±äºéƒ½åŒ…å«äº†$nums[3]$, **ç­‰ä»·äºæ‰¾å¯»$0,sum(0,2)ã€sum(1,2)ã€sum(2,2)$ä¸­æœ€å¤§å€¼å†+$nums[3]$**ã€‚è€Œ$0,sum(0,2)ã€sum(1,2)ã€sum(2,2)$ æœ€å¤§å€¼ == dp[2] ã€‚ ä½†ç‰¹åˆ«çš„ï¼Œå•ä¸ªå…ƒç´ ä¹Ÿå¯ä»¥ä½œä¸ºä¸€ä¸ªå­æ•°ç»„ï¼Œå½“dp[2]&lt;0 , dp[3]==nums[3] æ›´å¤§ã€‚ åˆå§‹çŠ¶æ€ï¼š $j-1&gt;0$, å¾ªç¯ä»1å¼€å§‹ï¼Œé‚£ä¹ˆdp[0]=nums[0]éœ€å·²çŸ¥ è¿”å›å€¼ï¼šè¿”å›æ•°ç»„dpä¸­æœ€å¤§å€¼ ä¼˜åŒ–ç©ºé—´ä¸ºO(1) ? ç”±äºç»™å®šæ•°ç»„nums åœ¨ä¸‹æ¬¡å¾ªç¯i+1æ—¶ï¼Œå‰iä¸ªå…ƒç´ éƒ½ä¸ä¼šä½¿ç”¨ï¼Œå¯ä»¥ä½œä¸ºä½¿ç”¨ç©ºé—´ã€‚ ä»£ç å®ç° 123456789101112131415161718192021public int maxsumofSubarray (int[] arr) &#123; // åˆå§‹çŠ¶æ€ // ä½¿ç”¨arrç©ºé—´ä½œä¸ºdpç©ºé—´ï¼Œåˆå§‹åŒ–ä¸ç”¨è¿›è¡Œ // çŠ¶æ€æ–¹ç¨‹ for(int i=1; i&lt;arr.length; i++) &#123; if(arr[i-1]&gt;0) arr[i]=arr[i-1]+arr[i]; &#125; // æ‰¾å¯»åˆ°æœ€å¤§å€¼ int max = arr[0]; for(int i=1; i&lt;arr.length; i++) &#123; if(arr[i]&gt;max) max = arr[i]; &#125; return max; &#125; 1.6 æ ‘äºŒã€æ•°æ®åº“2.1 å…¥é—¨å¼€èƒƒèœ ç»å…¸é¢è¯•é¢˜å‹ æœ€æ™šå…¥èŒå‘˜å·¥ é¢˜ç›® ä»£ç  12345/* ä½¿ç”¨limitå…³é”®å­— ä»ç¬¬0æ¡è®°å½• å‘åè¯»å–1ä¸ªï¼Œ */select * from employees order by hire_date desc LIMIT 1 offset 0; å…¥èŒå€’æ•°ç¬¬ä¸‰ é¢˜ç›® ä»£ç  123select * from employees order by hire_date desc LIMIT 1 offset 2; æŸ¥çœ‹éƒ¨é—¨è–ªæ°´ é¢˜ç›® è¯·ä½ æŸ¥æ‰¾å„ä¸ªéƒ¨é—¨é¢†å¯¼è–ªæ°´è¯¦æƒ…ä»¥åŠå…¶å¯¹åº”éƒ¨é—¨ç¼–å·dept_noï¼Œè¾“å‡ºç»“æœä»¥salaries.emp_noå‡åºæ’åºï¼Œå¹¶ä¸”è¯·æ³¨æ„è¾“å‡ºç»“æœé‡Œé¢dept_noåˆ—æ˜¯æœ€åä¸€åˆ—ã€‚ å…¨éƒ¨å‘˜å·¥çš„è–ªæ°´è¡¨salaries: å„ä¸ªéƒ¨é—¨çš„é¢†å¯¼è¡¨dept_manager: ä»£ç  çº¯whereè¿æ¥ä¸¤å¼ è¡¨è¿›è¡ŒæŸ¥è¯¢ï¼š 123456/*çº¯whereè¿æ¥ä¸¤å¼ è¡¨*/select s.* , d.dept_nofrom dept_manager d, salaries swhere d.emp_no = s.emp_no and d.to_date = &#x27;9999-01-01&#x27;order by s.emp_no ASC; /*é»˜è®¤å‡åºASC*/ ä½¿ç”¨å†…è¿æ¥è¿›è¡ŒæŸ¥è¯¢ï¼š å†…å¤–è¿æ¥å¾ˆæ¸…æ™°çš„ä¸€ç¯‡æ–‡ç«  12345select s.* , d.dept_nofrom dept_manager as d inner join salaries as son d.emp_no = s.emp_no where d.to_date = &#x27;9999-01-01&#x27; /*ä¿è¯æ²¡ç¦»èŒ*/order by s.emp_no ASC; æŸ¥çœ‹å‘˜å·¥ä¿¡æ¯ é¢˜ç›® è¯·ä½ æŸ¥æ‰¾æ‰€æœ‰å·²ç»åˆ†é…éƒ¨é—¨çš„å‘˜å·¥çš„last_nameå’Œfirst_nameä»¥åŠdept_noï¼š åˆ†åˆ«å†™å‡ºæŸ¥è¯¢è¯­å¥æŸ¥è¯¢ï¼šã€æ˜¾ç¤º/ä¸æ˜¾ç¤ºã€‘æœªåˆ†é…çš„éƒ¨é—¨çš„å‘˜å·¥ï¼› è·å–æ‰€æœ‰émanagerçš„å‘˜å·¥çš„emp_no å‘˜å·¥è¡¨ï¼Œemployeesï¼š éƒ¨é—¨è¡¨ï¼Œdept_empï¼š ä»£ç  ä¸åŒ…æ‹¬æœªåˆ†é…å‘˜å·¥ï¼šä½¿ç”¨å†…è¿æ¥å»äºŒè€…äº¤é›†å³å¯ã€‚ 123select e.last_name , e.first_name, d.dept_nofrom dept_emp as d inner join employees as eon e.emp_no = d.emp_no; åŒ…æ‹¬æœªåˆ†é…çš„å‘˜å·¥ï¼Œä½¿ç”¨å¤–è¿æ¥å³å¯ã€‚ä½¿ç”¨å·¦è¿æ¥ï¼Œä»¥å‘˜å·¥è¡¨ä¸ºä¸»è¡¨ã€‚ 123select e.last_name , e.first_name, d.dept_nofrom employees as e left join dept_emp as d on e.emp_no = d.emp_no; è·å–æ‰€æœ‰émanagerçš„å‘˜å·¥çš„emp_no ã€‚ ä¸€ã€ä½¿ç”¨NOT IN å­å¥ 123select emp_nofrom employeeswhere emp_no not in (select emp_no from dept_manager); äºŒã€LEFT JOINå·¦è¿æ¥+IS NULL 1234SELECT e.emp_noFROM employees AS e LEFT JOIN dept_manager AS dON e.emp_no=d.emp_noWHERE dept_no IS NULL; â€‹ ç»Ÿè®¡è–ªæ°´æ¶¨å¹… é¢˜ç›® è¯·ä½ æŸ¥æ‰¾è–ªæ°´è®°å½•è¶…è¿‡15æ¬¡çš„å‘˜å·¥å·emp_noä»¥åŠå…¶å¯¹åº”çš„è®°å½•æ¬¡æ•°tã€‚ è–ªæ°´è¡¨ï¼Œsalariesï¼š é¢˜ç›®éšå«ï¼š ä¸€æ¡è®°å½•å°±ç®—ä¸€æ¬¡æ¶¨å¹…(ä¸¥æ ¼æ„ä¹‰ä¸Šï¼Œä»ç¬¬äºŒæ¡è®°å½•ç®—èµ·æ‰ç®—ä¸€æ¬¡æ¶¨å¹…) ä»»ä½•ä¸€æ¡è®°å½•éƒ½ç®—ä¸€æ¬¡æ¶¨å¹…(ä¸¥æ ¼æ„ä¹‰ä¸Šï¼Œå¿…é¡»æ¯”ä¸Šä¸€æ¡è®°å½•çš„å·¥èµ„é«˜æ‰ç®—ä¸€æ¬¡æ¶¨å¹…) ä»£ç  MySQL GROUP BY è¯­å¥ GROUP BY è¯­å¥æ ¹æ® ä¸€ä¸ªæˆ–å¤šä¸ªåˆ— å¯¹ç»“æœé›†è¿›è¡Œåˆ†ç»„ã€‚åœ¨åˆ†ç»„çš„åˆ—ä¸Šæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ COUNT, SUM, AVG,ç­‰å‡½æ•°ã€‚ ç»Ÿè®¡ç»“æœè¦è¿›è¡Œåˆ¤æ–­ï¼Œå¿…é¡»ä½¿ç”¨having è€Œä¸æ˜¯ where 1234select emp_no , count(emp_no) tfrom salaries group by emp_nohaving t&gt;15; /*å¿…é¡»ç”¨having*/ è–ªæ°´æ˜¾ç¤ºå»é‡ é¢˜ç›® ä½ æ‰¾å‡ºæ‰€æœ‰å‘˜å·¥å…·ä½“çš„è–ªæ°´salaryæƒ…å†µï¼Œå¯¹äºç›¸åŒçš„è–ªæ°´åªæ˜¾ç¤ºä¸€æ¬¡,å¹¶æŒ‰ç…§é€†åºæ˜¾ç¤ºã€‚ è–ªæ°´è¡¨ï¼Œsalariesï¼š ä»£ç  ä¸€ã€å¯ä»¥ç”¨distinctå‡½æ•° 1234select distinct(salary)from salarieswhere to_date=&#x27;9999-01-01&#x27;order by salary desc; äºŒã€ä½¿ç”¨group by ï¼ˆæ¨èï¼Œæ€§èƒ½æ›´é«˜ï¼‰ 12345select salaryfrom salaries where to_date=&#x27;9999-01-01&#x27;group by salary /*åˆ†ç»„ä¸€å®šè¦åœ¨whereè¯­å¥åé¢ï¼*/order by salary desc; /*æ’åºæœ€åé¢*/ 2.2 ç»å…¸é¢˜ç›®é¢˜ç›®æè¿° å­¦ç”Ÿè¡¨ï¼šStudent(SId,Sname,Sage,Ssex) è¯¾ç¨‹è¡¨ï¼šCourse(CId,Cname,TId) æ•™å¸ˆè¡¨ï¼šTeacher(TId,Tname) æˆç»©è¡¨ï¼šSC(SId,CId,score) ç»å…¸50é¢˜https://zhuanlan.zhihu.com/p/32137597 1. æŸ¥è¯¢â€ 01 â€œè¯¾ç¨‹æ¯”â€ 02 â€œè¯¾ç¨‹æˆç»©é«˜çš„å­¦ç”Ÿçš„ä¿¡æ¯åŠè¯¾ç¨‹åˆ†æ•° å…ˆåˆ†åˆ«å¾—åˆ°åªæœ‰01è¯¾ç¨‹å’Œ02è¯¾ç¨‹ä¸¤å¼ æˆç»©å­è¡¨ï¼šsc1 (SID,score1) , sc2 (SID,score2) é€šè¿‡**è‡ªç„¶è¿æ¥**ï¼Œæ„å»ºä¸€å¼ 01,02è¯¾ç¨‹æˆç»©åœ¨åŒä¸€è¡Œçš„è¡¨ï¼Œsc12(SID,score1,score2) ï¼Œå¹¶ sc1.score&gt;sc2.score å› ä¸ºæœ‰å­¦ç”Ÿä¸æ˜¯01ï¼Œ02éƒ½é€‰ï¼Œå¯¼è‡´å‡ºç°score1æˆ– score2 ä¸ºnullçš„æƒ…å†µï¼Ÿ è‡ªç„¶è¿æ¥ï¼Œ0ï¼Œåªæœ‰è¯¥SIDéƒ½æœ‰åˆ†æ•°æ‰ä¼šä¿ç•™ å†…è¿æ¥å’Œäº¤å‰è¿æ¥ï¼Œæ‰ä¼šä¿ç•™æ‰€æœ‰ç»“æœï¼ˆç¬›å¡å°”ç§¯ï¼‰ å¤–è¿æ¥æ‰ä¼šå¯¼è‡´ï¼ŒæŸä¸ªåˆ†æ•°scoreå‡ºç°nullï¼Œæ²¡åŒ¹é…åˆ°SIDä½†è¿˜æ˜¯ä¿ç•™ å†è”åˆStudentè¡¨ï¼Œæ ¹æ®SIDæ‰¾åˆ°å¯¹åº”å­¦ç”Ÿä¿¡æ¯ï¼ˆåªè¦SIDï¼Œä¸è¦nameç­‰å¯ä»¥çœç•¥è¿™æ­¥ï¼Œä¸‹é¢å°±çœç•¥äº†è¿™æ­¥ï¼‰ 1234Select * from (select SId ,score from sc where sc.CId=&#x27;01&#x27;)as sc1 , (select SId ,score from sc where sc.CId=&#x27;02&#x27;) as sc2where sc1.SId=sc2.SIdand sc1.score&gt;sc2.score 1.1 æŸ¥è¯¢åŒæ—¶é€‰äº†â€ 01 â€œè¯¾ç¨‹å’Œâ€ 02 â€œè¯¾ç¨‹çš„å­¦ç”ŸSIDè‡ªç„¶è¿æ¥ã€‚ 123select *from (select SId ,score from sc where sc.CId=&#x27;01&#x27;)as t1 , (select SId ,score from sc where sc.CId=&#x27;02&#x27;) as t2where t1.SId=t2.SId 1.2 æŸ¥è¯¢é€‰äº†â€ 01 â€œè¯¾ç¨‹ä½†å¯èƒ½ä¸å­˜åœ¨â€ 02 â€œè¯¾ç¨‹çš„æƒ…å†µ(ä¸å­˜åœ¨æ—¶æ˜¾ç¤ºä¸º null )1 1.3 æŸ¥è¯¢é€‰äº†â€ 01 â€œè¯¾ç¨‹ä½†æ²¡é€‰â€ 02 â€œè¯¾ç¨‹çš„æƒ…å†µ1234select *from scwhere sc.SId not in (select SId from sc where sc.CId=&#x27;01&#x27;)and sc.CId=&#x27;02&#x27; 2. æŸ¥è¯¢å¹³å‡æˆç»©å¤§äºç­‰äº 60 åˆ†çš„åŒå­¦çš„å­¦ç”Ÿç¼–å·å’Œå­¦ç”Ÿå§“åå’Œå¹³å‡æˆç»© å…ˆå¾—åˆ°ä¸€å¼ å¹³å‡æˆç»©è¡¨(SID,AvgScore) å†æ ¹æ®å¹³å‡æˆç»©è¡¨SIDï¼Œæ‰¾åˆ°Student è¡¨ä¸­ä¿¡æ¯ï¼Œè¿™é‡Œè”åˆä¸¤å¼ è¡¨å¯ä»¥é‡‡ç”¨å·¦å¤–è¿æ¥ 123456789Select s.SID,s.Sname, From Student as s left join ï¼ˆ Select SC.SID , AVG(SC.score) as avgscore From SC Group by(SC.SID ) Having AVG(sc.score) &gt;= 60 # é›†åˆå‡½æ•°æ—¶ä¸èƒ½ä½¿ç”¨where ï¼‰as avgTable ON s.SID = avgTable.SID # å¤–è¿æ¥ç”¨ON, ä¸æ˜¯Whereè¿æ¥","categories":[],"tags":[]},{"title":"","slug":"test","date":"2021-11-24T09:34:48.534Z","updated":"2021-11-24T09:34:48.534Z","comments":true,"path":"2021/11/24/test/","link":"","permalink":"http://example.com/2021/11/24/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"test_my_site","slug":"test-my-site","date":"2021-11-24T09:03:08.000Z","updated":"2021-11-24T09:03:08.457Z","comments":true,"path":"2021/11/24/test-my-site/","link":"","permalink":"http://example.com/2021/11/24/test-my-site/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-11-24T09:00:02.998Z","updated":"2021-11-24T09:56:38.951Z","comments":true,"path":"2021/11/24/hello-world/","link":"","permalink":"http://example.com/2021/11/24/hello-world/","excerpt":"","text":"toc: ture Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}