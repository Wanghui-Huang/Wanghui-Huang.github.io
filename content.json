{"meta":{"title":"royhuang's blog","subtitle":"hello world","description":"tech & life","author":"Wanghui Huang","url":"http://example.com","root":"/"},"pages":[{"title":"[404]","date":"2021-11-24T11:41:16.226Z","updated":"2021-11-24T11:41:16.226Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"Hi there 👋","date":"2021-11-24T11:42:21.093Z","updated":"2021-11-24T11:42:21.093Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"I am Wanghui Huang (royHuang). 🔭 I am studying for a master’s degree in Chongqing University and will graduate in July, 2022. What’s more, I will officially join Tencent next year. 📫 If you want know me more : www.hwh.zone, this is my personal blog. 💬 Ask me about deep learning(object tracking) , C++, Java and my projects on &#x68;&#x77;&#x68;&#x31;&#x39;&#x39;&#x36;&#48;&#49;&#64;&#113;&#113;&#46;&#x63;&#x6f;&#x6d;. ⚡ Fun fact: this is a less funny boy."},{"title":"tags","date":"2021-11-25T05:45:14.000Z","updated":"2021-11-25T05:47:43.270Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-11-25T05:45:57.000Z","updated":"2021-11-25T05:47:33.936Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"XXX","slug":"工作一_算法笔记","date":"2021-11-25T03:34:30.479Z","updated":"2021-11-25T03:49:00.735Z","comments":true,"path":"2021/11/25/工作一_算法笔记/","link":"","permalink":"http://example.com/2021/11/25/%E5%B7%A5%E4%BD%9C%E4%B8%80_%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","excerpt":"","text":"前言找工作记录的刷题笔记。 TO DO 补充SQL算法题 虾皮专场1. 栈实现队列 https://leetcode-cn.com/problems/implement-queue-using-stacks/ 思路 设置两个栈S1、S2 ，S1始终用来当做队列存元素，S2用作中转栈。当需要操作（取，删除）S1中队头元素，就pop S1中元素到S2中，操作完成后再pop S2中元素回来S1。 代码 代码易错点1、2见下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.*;class MyQueue &#123; /** Initialize your data structure here. */ Stack&lt;Integer&gt; stack1 ; Stack&lt;Integer&gt; stack2 ; public MyQueue() &#123; stack1 = new Stack&lt;Integer&gt;(); stack2 = new Stack&lt;Integer&gt;(); &#125; /** Push element x to the back of queue. */ public void push(int x) &#123; stack1.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; if(stack2.isEmpty()) &#123; // 【易错点1】在这里使用 for(int i=0 ; i&lt;stack1.size();i++ ) 判断， // 但是stack1.size()是变量，随着循环会不断减少。 while(!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; &#125; int res = stack2.pop(); /* // 【易错点2】不用傻傻再倒回去，此时stack2，从栈顶到栈尾就是队列的顺序 // stack2为空再倒回去就行 while(!stack2.isEmpty()) &#123; stack1.push(stack2.pop()); &#125; */ return res; &#125; /** Get the front element. */ public int peek() &#123; if(stack2.isEmpty()) &#123; while(!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; &#125; int res = stack2.peek(); /* // 【易错点2】不用傻傻再倒回去，此时stack2，从栈顶到栈尾就是队列的顺序 while(!stack2.isEmpty()) &#123; stack1.push(stack2.pop()); &#125; */ return res; &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; return (stack1.isEmpty() &amp;&amp; stack2.isEmpty()) ? true : false; &#125;&#125; 代码（进阶：用自己实现的栈） 注意：泛型数组不能直接初始化，而且先定义一个Object数组再强制转换。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class StackDemo&lt;E&gt; &#123; /** 底层使用一个泛型数组做存储 */ private E[] items; private int top; private int capacity; public StackDemo() &#123; //会调用下面一个构造方法,初始化一个长度为10的数组 this(10); &#125; public StackDemo(int i)&#123; this.capacity=i; // 【易错3】泛型数组不能直接初始化，而且先定义一个Object数组再强制转换。 this.items=(E[])new Object [this.capacity]; this.top=0; &#125; /** * 入栈操作 */ public void push(E e) throws Exception&#123; if(top!=capacity)&#123; items[top++]=e; //判断数据是不是已经满了,看需不需要扩容 resize(); &#125;else&#123; throw new Exception(); &#125; &#125; /** * 出栈操作 */ public E pop() throws Exception&#123; if(top==0)&#123; throw new Exception(); &#125;else&#123; E ret=items[--top]; items[top]=null; return ret; &#125; &#125; /** * resize操作,把数组扩大两倍 */ public void resize()&#123; // 如果top和capacity相等的话,说明满了 if(top==capacity)&#123; // 把范围扩大2倍 this.capacity = this.capacity*2; // new一个新数组 E[] newItems = (E[])new Object [this.capacity]; // 转移老数据 System.arraycopy(items,0,newItems,0,items.length); // 把新的数组当成底层的存储 this.items = newItems; &#125; &#125; public static void main(String[] args) &#123; StackDemo&lt;String&gt; stack = new StackDemo&lt;&gt;(2); try &#123; stack.push(&quot;first&quot;); stack.push(&quot;second&quot;); stack.push(&quot;third&quot;); stack.push(&quot;four&quot;); String pop = stack.pop(); System.out.println(pop); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2. LRUCachehashmap + 双向的linklist，略。 3. 相交链表注意下面两点： 计算差值要用绝对值 判断相等，比较的是节点，所以返回第一个相等的节点就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode pA = headA ; ListNode pB = headB ; // 计算A、B链表长度之差 int lenA = 0; int lenB = 0 ; int d = 0; while(pA != null) &#123; pA = pA.next; lenA++; &#125; while(pB != null) &#123; pB = pB.next; lenB++; &#125; // A1：绝对值 d = Math.abs(lenA-lenB); // 更长的先走d步 if(lenA&lt;lenB) &#123; while(d--&gt;0) &#123; headB = headB.next; &#125; &#125; if(lenA&gt;lenB) &#123; while(d--&gt;0) &#123; headA = headA.next; &#125; &#125; // 开始一起走开始判断 while(headA != null) &#123; // A2 : 返回第一个相等的节点 if(headA == headB) return headA; headA = headA.next; headB = headB.next; &#125; return null; &#125;&#125; 4. 有序链表合并没啥好说的，记住就行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; // 1. 创建虚拟节点head,tail ，p1,p2初始指针分别指向l1、l2 // 2. 比较p1、p2指针所指的值大小,更小的用tail指向 // 3. 更新p1或p2指向下一个节点 // 4. 最后串起来剩下未比较的节点 ListNode head = new ListNode() ; ListNode tail = head; ListNode p1 = l1 , p2 = l2; while(p1 != null &amp;&amp; p2 != null) &#123; if(p1.val &lt; p2.val) &#123; tail.next = p1; tail = p1; p1 = p1.next; &#125; else // 这里不能用if判断，因为上一个if会想修改这个if的判断条件 &#123; tail.next = p2; tail = p2; p2 = p2.next; &#125; &#125; if(p1 == null) &#123; while(p2 != null) &#123; tail.next = p2; tail = p2; p2 = p2.next ; &#125; &#125; if(p2 == null) &#123; while(p1 != null) &#123; tail.next = p1; tail = p1; p1 = p1.next ; &#125; &#125; return head.next; &#125;&#125; 5. 反转链表注意下面，对象引用不是对象复制（clone）！！ 123456789101112131415161718192021222324252627class Solution &#123; public ListNode reverseList(ListNode head) &#123; // 1. 记录两个指针p,q ， 初始分别指向链表第一个，第二个节点 // 2. p-&gt;q 转换为 p&lt;-q // 3. 更新p，q同时往后移动，直至q为null // 4. 最后处理下head-&gt;next = null if(head == null) return head; ListNode p = head , q = head.next; ListNode tmp = null ; while(q != null) &#123; // 【易错】用tmp记录q的位置，在q.next = p，执行后尝试再去获取原先q.next // 此时tmp, q 都是指向同一个对象，q操作对象改变next指向后，tmp对应对象next也被改变了 // 真要用tmp记录之前状态的q，应该是使用【重写clone方法】 tmp = q.next; q.next = p; p = q; q = tmp; &#125; head.next = null; return p; &#125;&#125; 6. 两数之和注意两点： hashmap的 containsKey方法 返回的是数组下标 12345678910111213141516171819202122232425import java.util.*;class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; // hashmap将数组每个值作为key存入 HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for (int i = 0 ; i &lt; nums.length ; i++) &#123; map.put(nums[i],i); &#125; int[] res = new int[2]; for (int i = 0 ; i &lt; nums.length ; i++) &#123; if(map.containsKey(target-nums[i]) &amp;&amp; map.get(target-nums[i]) != i ) &#123; res[0] = i; res[1] = map.get(target-nums[i]); return res; &#125; &#125; return res; &#125;&#125; 7. k个一组翻转链表还是边界没有处理好，直接看原来的解法吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 思路// 遍历链表找到每次反转的first,end 进行翻转// *特别的：第一次翻转end是返回的头结点public ListNode reverseKGroup (ListNode head, int k) &#123; ListNode pre = null; ListNode f = head; ListNode e = head; int count = 1; // 记录翻转后链表第一个节点 ListNode firstNode = e; while (e!=null) &#123; // 找到翻转段的尾节点e if(count % k == 0 ) &#123; // 第一次翻转 if(count == k) firstNode = e; // 翻转 reverse(pre,f,e); // *更新:注意此时段尾部是f // *尾部e移动了，要count+1 pre = f; f = e = f.next; &#125; else e = e.next; // 无论哪种情况都要count++，所以移到这儿 count++; &#125; return firstNode; &#125; // 指定链表段翻转 // 先将[first-end] 节点反转，再修改反转后的首尾节点指向 public ListNode reverse(ListNode pre,ListNode first,ListNode end) &#123; ListNode p = null; ListNode q = first; ListNode q_next = null; // 临时节点存储q.next while (p !=end ) // 修改：到达末尾终止条件 &#123; q_next = q.next; q.next = p; p = q; q = q_next; &#125; // 修改：处理反转后的首尾节点指向 first.next = q; // 【边界情况】：从头节点开始反转 if(pre!=null) pre.next=end; // *返回翻转后链表首节点end return end; &#125; 8. 二叉树最近公共祖先 参考：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/ 这个关键是明白： 后序递归查找节点p，q ，叶子节点，这部分子树就返回节点（p,q,null） 由于是后序递归，每次都比较当前root左右子树的返回值 左右子树都有返回值，说明root就是当前最近公共祖先，返回 如果只有左或右子树（假设左）有返回值（不为null），返回左子树返回的节点当做最小公共节点，继续往上递归比较左右子树，看是否更新这个最小公共节点（一直没有更新，说明就是p是q的祖先这种情况） 1234567891011121314151617181920212223242526272829class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; // 叶子节点返回 ， 当前左、右子树找到了p或q也返回 if(root == null || root == p || root == q ) return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); // 如果当前左右子树都返回了节点（找到了 p,q 且异侧），返回root // 因为是从底层往上，所以此时root一定是最近的祖先 if(left != null &amp;&amp; right != null) return root; // 左子树不为null，但右子树为null，把左子树返回的节点当成以root为根的子树结果往上返回 // 这样保证了：（1）找到了p，q子树的结果（节点）可以一直往上返回 （2）也保证了p是q的祖先节点， // 但是遍历到p就往上返回p，不用去再找到q if(left != null &amp;&amp; right == null) return left; // 同上 if(right != null &amp;&amp; left == null) return right; // 左右子树都为null，且root不为p，q return null; &#125;&#125; 9. 删除链表重复元素注意不保留第一个重复元素，而是全部删除。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; // 1. 设置节点p，q初始都指向head // 2. q往后遍历找到第一个不重复的节点 // 3. 设置p-&gt;q，p=q , 重复2，直至q为null // 这的q不要指向下一个节点比较好 ListNode pre = null , p = head ,q = head ; while(q != null) &#123; if(q.next == null) return head; if(p.val == q.next.val) &#123; // 找到不重复的元素 while(q.next != null &amp;&amp; p.val == q.next.val) q = q.next; if(pre == null) // 考虑pre==null的情况 head = q.next; else pre.next = q.next; &#125; else &#123; pre = p; // 删除重复元素的时候是不用更新pre &#125; p = q = q.next; &#125; return head; &#125;&#125; 10. 最大数关键在于怎么比较两个字符串，java中自带的 compareTo可以比较两个字符串a，b： 先比较字符串的首字符串的ASCII码，如果相同再比较下一个 那么我们可以比较a+b 与 b+a来确定谁应该在前面。其它应该注意的地方： StringBuilder 常用的 append 、charAt、toString方法要记住 Arrays.sort 高级函数用法怎么写要记住 Arrays.sort(数组,(参数..) -&gt; &#123; return 比较的逻辑 &#125;) 123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;class Solution &#123; public String largestNumber(int[] nums) &#123; String[] stringNums = new String[nums.length]; for(int i = 0 ; i &lt; nums.length; i++) &#123; stringNums[i] = String.valueOf(nums[i]); &#125; // 要对JAVA的lambda熟悉 Arrays.sort ( // 数组,(参数..) -&gt; &#123; return 比较的逻辑 &#125; // 返回值&gt;0 ，则b和a互换 stringNums,(a,b) -&gt; &#123; return (b+a).compareTo(a+b); &#125; ); StringBuilder sb = new StringBuilder(); for(int i = 0 ; i &lt; nums.length; i++) &#123; sb.append(stringNums[i]); &#125; // toString() 可以将sb转换为String字符串 if(sb.charAt(0) == &#x27;0&#x27;) return new String(&quot;0&quot;); // 或者直接返回:&quot;0&quot; else return sb.toString(); &#125;&#125; 11. 二分查找注意：边界条件是 &lt;= 不是&lt; 。 1234567891011121314151617181920212223class Solution &#123; public int search(int[] nums, int target) &#123; int len = nums.length; int s = 0, e = len-1; while(s &lt;= e ) // 这里是&lt;= , 不是&lt; &#123; int mid = (s+e)/2; if(target == nums[mid]) return mid; else if(target &gt; nums[mid]) &#123; s = mid+1; &#125; else &#123; e = mid-1; &#125; &#125; return -1; &#125;&#125; 12. 最长不重复子串维持一个滑动窗口，rigth无论如何都++ ； left 当滑动窗口加入了重复的字符串就更新为left=重复的字符串下标+1。 注意以下两点： 此题还可以用HashMap&lt;字符，字符下标&gt;记录窗口的所有值，每次都加入一个字符串都判断是否在hashmap中。 map.get&lt;新加入字符的下标&gt; left ，说明窗口内有重复，更新left = map.get&lt;新加入字符的下标&gt; 。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution&#123; public int lengthOfLongestSubstring(String s) &#123; // 1. 设置指针left, rigth 分别在指向滑动窗口的左右, maxLen 记录窗口最大值，len记录长度 // 2. 每次rigth向右移动，判断当前right指向的字符是否出现在窗口内 // 1） 如果不出现，则len+1，同时判断是否更新maxLen // 2） 如果出现，则left更新为窗口内出现重复字符串的下一个位置 // 3. 重复2，直至rigth&gt;=字符串最大长度 int left = 0 , right = 0; int len = 1 , maxLen = 1; if(s.length()==0) return 0 ; while(right &lt; s.length()-1) &#123; int idx = isExist(s,s.charAt(right+1),left,right); right++; if(idx == -1) // 不存在 &#123; len++; maxLen = len&gt;maxLen? len:maxLen; &#125; else &#123; left = idx+1; len = right-left+1; &#125; &#125; return maxLen; &#125; public int isExist(String s ,char c, int left , int right) &#123; for(int i = left ; i &lt;= right ; i++) &#123; if(s.charAt(i) == c ) return i; &#125; return -1; &#125;&#125; 优化后的方法： 1234567891011121314151617class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s.length()==0) return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int max = 0; int left = 0; for(int i = 0; i &lt; s.length(); i ++)&#123; if(map.containsKey(s.charAt(i)))&#123; left = Math.max(left,map.get(s.charAt(i)) + 1); &#125; map.put(s.charAt(i),i); max = Math.max(max,i-left+1); &#125; return max; &#125;&#125; 13. 两数相加II注意： 想把链表反转 + 长度一致，做法有点复杂易错，比较好的做法还是：栈压入 + 新建节点构建新链表； 用尾插法，保证输出的结果是逆序的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; // 1. 采用两个栈压入两个链表 // 2. 逐个弹出计算值，创建新节点 Stack&lt;ListNode&gt; s1 = new Stack&lt;ListNode&gt;(); Stack&lt;ListNode&gt; s2 = new Stack&lt;ListNode&gt;(); while(l1 != null) &#123; s1.push(l1); l1=l1.next; &#125; while(l2 != null) &#123; s2.push(l2); l2=l2.next; &#125; ListNode head = null; int r = 0; while(s1.size() != 0 &amp;&amp; s2.size() != 0) &#123; int val1 = s1.pop().val; int val2 = s2.pop().val; int sum = val1 + val2 + r; ListNode newNode = new ListNode(sum%10); newNode.next = head; head = newNode; r = sum / 10; &#125; while(s1.size() != 0) &#123; int sum = s1.pop().val + r ; ListNode newNode = new ListNode(sum%10); newNode.next = head; head = newNode; r = sum / 10; &#125; while(s2.size() != 0) &#123; int sum = s2.pop().val + r ; ListNode newNode = new ListNode(sum%10); newNode.next = head; head = newNode; r = sum / 10; &#125; if(r != 0) &#123; ListNode newNode = new ListNode(r); newNode.next = head; head = newNode; &#125; return head; &#125;&#125; 14. 三数之和15. next树（空间O(1)）注意，要求常数的空间复杂度，下面这种是空间复杂度O(n)。 一旦在某层的节点之间建立了 \\text{next}next 指针，那这层节点实际上形成了一个链表。因此，如果先去建立某一层的 \\text{next}next 指针，再去遍历这一层，就无需再使用队列了。 队列初始化是用 new LinkedList(); 核心： 都是遍历当前层（出队/ 遍历next指针），来处理下一层 （入队 / 设置next指针）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public Node connect(Node root) &#123; if(root == null) return null; Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); queue.offer(root); root.next = null; while(queue.size() != 0) // 优化：cur表示当前层指针（初始第一个），这里只要cur不为null &#123; int len = queue.size(); // Node preNode = null; Node preNode = new Node(0); // 优化：这里为每一层链表设置个虚拟头节点比较好！！ while(len-- &gt; 0) // 每次只加入下一层的节点，优化：根据cur是否为null来判断是否遍历完成 &#123; Node tmpNode = queue.poll(); /* // 原始思路，是在当前层处理当前层所有节点的指向，但这样不太好 // 还是在当前层处理下一层所有节点的指向比较好 if(preNode != null) &#123; preNode.next = tmpNode; &#125; preNode = tmpNode; */ if(tmpNode.left != null) &#123; queue.offer(tmpNode.left); // 使用链表这一步可以省略 // 在当前层处理下一层所有节点 preNode.next = tmpNode.left; preNode = tmpNode.left; &#125; if(tmpNode.right != null) &#123; queue.offer(tmpNode.right); // 使用链表这一步可以省略 // 在当前层处理下一层所有节点 preNode.next = tmpNode.right; preNode = tmpNode.right; &#125; &#125; preNode.next = null; &#125; return root; &#125;&#125; 优化后O(1) 级别的 1234567891011121314151617181920212223242526272829303132333435public Node connect(Node root) &#123; if (root == null) return root; //cur我们可以把它看做是每一层的链表 Node cur = root; while (cur != null) &#123; //遍历当前层的时候，为了方便操作在下一 //层前面添加一个哑结点（注意这里是访问 //当前层的节点，然后把下一层的节点串起来） Node dummy = new Node(0); //pre表示访下一层节点的前一个节点 Node pre = dummy; //然后开始遍历当前层的链表 while (cur != null) &#123; if (cur.left != null) &#123; //如果当前节点的左子节点不为空，就让pre节点 //的next指向他，也就是把它串起来 pre.next = cur.left; //然后再更新pre pre = pre.next; &#125; //同理参照左子树 if (cur.right != null) &#123; pre.next = cur.right; pre = pre.next; &#125; //继续访问这一行的下一个节点 cur = cur.next; &#125; //把下一层串联成一个链表之后，让他赋值给cur， //后续继续循环，直到cur为空为止 cur = dummy.next; &#125; return root;&#125; 16. 跳跃游戏2注意两点： 对于数组 [3,1] ，判断可跳跃的范围大于数组右边界时，此时直接退出 在可跳跃的范围建议用数组真实下标s表示，每个跳跃的范围距离 = s+nums[s] 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int jump(int[] nums) &#123; // 对于数组 S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 // 3 2 3 3 // 从S0起跳，可以跳 S1 S2 S3 ，尝试从 S1 S2 S3 分别跳 // 发现S3可以跳到最远（3+3），所以下一跳选S3 // 那么有没有选S1 或者 S2 能更快跳到终点呢？ // 不可能，因为S3是能跳到最远的，它下一次跳的范围（可能的路径）也就必然比S1 或 S2 多（且包含） int i = 0; int step = 0; while(i &lt; nums.length-1) &#123; int maxPos = -1; int maxDistance = 0; int e = i+nums[i]; if(e&gt;=nums.length-1) // 注意可跳跃的范围如果大于当前数组右边界，则退出 &#123; step++; break; &#125; for(int s = i+1 ; s &lt;= e ; s++) // 可以跳的数组位置下标 &#123; int curDistance = s + nums[s]; if(curDistance &gt; maxDistance) &#123; maxPos = s; maxDistance = curDistance; &#125; &#125; i = maxPos; // 找到能跳最远距离位置下标 step++; &#125; return step; &#125;&#125; 17. 二叉树所有路径首先明确以下几点： 根节点到指定叶节点的路径是唯一的 递归遍历，可以设置一个变量（就放到参数里），记录走到当前节点的路径是什么 使用后序遍历，如果到了叶子节点（左右节点都为null），就把路径输出 12345678910111213141516171819202122class Solution &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); // 不能定义到递归函数里面 public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; findPaths(root, String.valueOf(root.val)); return res; &#125; public void findPaths(TreeNode root , String curPath) &#123; if(root == null) return; if(root.left != null) // 记录到左节点的路径，防止为左节点为空判断 findPaths(root.left, curPath + &quot;-&gt;&quot; + root.left.val ); if(root.right != null) // 同上 findPaths(root.right, curPath + &quot;-&gt;&quot; + root.right.val ); if( root.left == null &amp;&amp; root.right == null) // 判断是否遍历到叶子节点（执行到这也可能是左右子树遍历完） res.add(curPath); &#125;&#125; 华为专场 机试的两道算法题 第一题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.Arrays;import java.util.Scanner;class Solution_KS &#123; Solution_KS() &#123; &#125; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String[] locs = in.nextLine().split(&quot; &quot;); int len = locs.length; int[] locArray = new int[len]; for(int i = 0; i &lt; len; ++i) &#123; locArray[i] = Integer.parseInt(locs[i]); &#125; String[] fixs = in.nextLine().split(&quot; &quot;); int len1 = fixs.length; int[] fixArray = new int[len1]; int res; for(res = 0; res &lt; len1; ++res) &#123; fixArray[res] = Integer.parseInt(fixs[res]); &#125; res = findR(locArray, fixArray); System.out.println(res); &#125; public static int findR(int[] workstations, int[] sterilizers) &#123; Arrays.sort(workstations); Arrays.sort(sterilizers); int worksNums = workstations.length; int sterNums = sterilizers.length; int[][] distance = new int[sterNums][worksNums]; int lastSter; for(int i = 0; i &lt; sterNums; ++i) &#123; for(lastSter = 0; lastSter &lt; worksNums; ++lastSter) &#123; distance[i][lastSter] = Math.abs(sterilizers[i] - workstations[lastSter]); &#125; &#125; int[] minRs = new int[worksNums]; Arrays.fill(minRs, -1); lastSter = 0; int res_max; int i; for(res_max = 0; res_max &lt; worksNums; ++res_max) &#123; minRs[res_max] = distance[lastSter][res_max]; for(i = lastSter + 1; i &lt; sterNums &amp;&amp; distance[i][res_max] &lt; minRs[res_max]; lastSter = i++) &#123; minRs[res_max] = distance[i][res_max]; &#125; &#125; res_max = -1; for(i = 0; i &lt; minRs.length; ++i) &#123; if (minRs[i] &gt; res_max) &#123; res_max = minRs[i]; &#125; &#125; return res_max; &#125;&#125; 第二题： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int m = in.nextInt(); in.nextLine(); List&lt;Integer&gt; v = new ArrayList&lt;&gt;(); List&lt;Integer&gt; f = new ArrayList&lt;&gt;(2*m); Collections.fill(f,0); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(int i=0;i&lt;2*m;i++)&#123; v.add(in.nextInt()); f.add(0); &#125; Collections.sort(v); int r = 2*m-1; int l = r-1; while(l&gt;=0) &#123; if(f.get(r) !=0) &#123; r--; l = r-1; continue; &#125; while(l&gt;=0&amp;&amp;(f.get(l) != 0||(v.get(r)+v.get(l))%n!=0)) &#123; l--; &#125; if(l&gt;=0&amp;&amp;l!=r&amp;&amp;(v.get(r)+v.get(l))%n==0) &#123; ans.add(v.get(r)); ans.add(v.get(l)); f.set(r,1); f.set(l,1); r--; l = r-1; &#125; &#125; if(ans.size()!=2*m) &#123; System.out.println(0);; &#125; else &#123; for(int i=0;i&lt;2*m;i++) &#123; System.out.print(ans.get(i));; if(i!=2*m-1) System.out.print(&quot; &quot;); &#125; System.out.println();; &#125; &#125;&#125; runable、callable各自的区别 Runnable是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成的能返回一个值，那么可以实现Callable接口而不是Runnable接口。在Java SE5中引入的Callable是一种具有类型参数的泛型，它的参数类型表示的是从方法call()(不是run())中返回的值。 12345678910111213141516171819202122232425262728293031323334353637 1 package ThreadOne; 2 3 import java.awt.Panel; 4 import java.util.concurrent.Callable; 5 import java.util.concurrent.Future; 6 import java.util.concurrent.FutureTask; 7 8 public class ThreadCallable extends Panel &#123; 9 10 public static void main(String[] args) &#123;11 12 MyThread2 myThread2 = new MyThread2();13 14 FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(myThread2);15 new Thread(futureTask, &quot;线程名：有返回值的线程2&quot;).start();16 17 try &#123;18 System.out.println(&quot;子线程的返回值：&quot; + futureTask.get());19 &#125; catch (Exception e) &#123;20 e.printStackTrace();21 &#125;22 &#125;23 &#125;24 25 class MyThread2 implements Callable&lt;Integer&gt; &#123;26 27 public Integer call() throws Exception &#123;28 System.out.println(&quot;当前线程名——&quot; + Thread.currentThread().getName());29 int i = 0;30 for (; i &lt; 5; i++) &#123;31 System.out.println(&quot;循环变量i的值：&quot; + i);32 &#125;33 34 return i;35 &#125;36 37 &#125; 内存溢出、内存泄漏、怎么分析 内存泄漏：不再会被使用的对象的内存不能被回收，就是内存泄露。 内存溢出：java.lang.OutOfMemoryError。内存溢出通俗理解就是内存不够，是指运行程序时要求的内存，超出了系统所能分配的范围，从而导致发生内存溢出。 一、算法1.1 基本算法最基本要记忆、烂熟于心的算法。 数组排序 参考：十大经典排序算法最强总结（含JAVA代码实现） 下面描述中，记：已排序部分为S，未排序部分为R，且相邻。 冒泡排序 核心思想 内循环：每次在R中从头 扫描（已排序S放最后），相邻元素比较，较大往后交换；外循环：n个数需n-1轮依次选出$R_i$ 中最大。 每次从头，未排相邻比较，最大最后。（如果逆序，最小最后） 代码实现 123456789101112131415161718public int[] bubble_sort(int[] arr) &#123; for(int i=0; i&lt;arr.length-1;i++) // 外轮=n-1 // * j=0,每次都是从头开始比较 for (int j=0; j&lt; arr.length-i-1; j++ ) // 内轮=余下乱序数-1 &#123; if (arr[j]&gt;arr[j+1]) swap(arr,j,j+1); &#125; return arr; &#125; public void swap(int[] arr,int idx_i,int idx_j) &#123; int tmp = arr[idx_i]; arr[idx_i] = arr[idx_j]; arr[idx_j] = tmp; &#125; 选择排序 核心思想 内循环：每次在R中从头 扫描（已排序S放最前），记录最大元素交换；外循环：n个数需n-1轮依次选出$R_i$ 中最大。 未排开始，一轮循环，比较最大（小），放在已排最后。 代码实现 1234567891011121314151617public int[] select_sort(int[] arr) &#123; for(int i=0; i&lt;arr.length-1;i++) // 外轮=n-1 &#123; int min = i; // 和冒泡排序不同，虽然内轮循环数同样=余下未排数-1 // * 但是循环条件是 j&lt;arr.length-1 ，因为【已排序数】放最前，而非最后 for(int j=i; j&lt;arr.length-1; j++) // 内轮=余下未排数-1 &#123; // 寻找一轮循环最小数 if(arr[j+1]&lt;arr[min]) min = j+1; &#125; swap(arr,i,min); &#125; return arr; &#125; 插入排序 核心思想 内循环：选取R[0]，每次在已排S中从尾扫描（已排序S放最前），如果该元素（已排序）&gt;R[0]，移动下一位，否则插入R[0]在其后； 关于空位：如果R[0]大于已排S 最后一个数，则直接插入S 最后（由于S,R实际不变相邻，R[0]位置不变）和普通插入情况一致；如果R[0]小于已排S 最前一个数，则插入最前。实际中，通过记录pre_index，可统一插入操作。 外循环：n个数需n-1轮依次选出$R_i$ 中最大。 代码实现1 12345678910111213141516171819202122232425public int[] insert_sort(int[] arr) &#123; for(int i=0; i&lt;arr.length-1;i++) // 外轮=n-1 &#123; int insert_num = arr[i+1]; // 第1个数默认已排序 // * 内循环从后遍历已排S，比较→移动元素/插入空位 // ** 从前遍历不方便移动元素，巧妙利用R[0]其实在S后 for(int j=i; j&gt;=0; j--) // 内轮= 已排序的数 &#123; if(insert_num&lt;arr[j]) &#123; arr[j+1]=arr[j]; // 大往后移动 if(j==0) // 边界条件：扫描完毕插入最前 &#123; arr[0]=insert_num; break; &#125; &#125; else &#123; arr[j+1]=insert_num; break; &#125; &#125; &#125; return arr; &#125; 代码实现2（优化） 优化在内循环后统一插入，减少两次插入操作为一次。 123456789101112131415161718192021222324public int[] insert_sort1(int[] arr) &#123; for(int i=0; i&lt;arr.length-1;i++) // 外轮=n-1 &#123; int insert_num = arr[i+1]; // 第1个数默认已排序 // * 内循环从后遍历已排S，比较→移动元素/插入空位 // ** 从前遍历不方便移动元素，巧妙利用R[0]其实在S后 // *** 初始为-1,处理恰好插入数最小插入最前的情况 int pre_idx=-1; for(int j=i; j&gt;=0; j--) // 内轮= 已排序的数 &#123; if(insert_num&lt;arr[j]) &#123; arr[j+1]=arr[j]; // 大往后移动 &#125; else // 小插入其后 &#123; pre_idx = j; break; &#125; &#125; arr[pre_idx+1]= insert_num; &#125; return arr; &#125; 归并排序 核心思想 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 代码实现 1234567891011121314151617181920212223242526272829303132333435363738public static void mergeSort(int[] arr, int low, int high) &#123; int mid = (low + high) / 2; if (low &lt; high) &#123; // 左边 mergeSort(arr, low, mid); // 右边 mergeSort(arr, mid + 1, high); // 左右归并 merge(arr, low, mid, high); &#125; &#125;public static void merge(int[] arr, int low, int mid, int high) &#123; int[] temp = new int[high - low + 1]; int i = low; // 左指针 int j = mid + 1; // 右指针 int k = 0; // 把较小的数先移到新数组中 while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (arr[i] &lt; arr[j]) temp[k++] = arr[i++]; else temp[k++] = arr[j++]; &#125; // 把左边剩余的数移入数组 while (i &lt;= mid) temp[k++] = arr[i++]; // 把右边边剩余的数移入数组 while (j &lt;= high) temp[k++] = arr[j++]; // 把新数组中的数覆盖nums数组 for (int k2 = 0; k2 &lt; temp.length; k2++) arr[k2 + low] = temp[k2]; &#125; 快速排序 核心思想 快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）： 设定一个基准pivot=arr[right], 分割标记partition=left partition 表示最终基准插入的位置，初始==left表示默认所有元素&gt;pivot 遍历数组，如果数组元素arr[i]&lt;pivot,交换arr[partition]和arr[i] ， 且partition+1，将arr[i]交换到partition左边。保证基准左侧元素&lt;基准 递归重复上述操作 代码实现 123456789101112131415161718192021222324252627public int[] quick_sort(int[] arr,int left,int right) &#123; if(right&lt;=left)&#123;return null;&#125; // 选择基准：数组最右数字 // *如果选择最左，思考交换过程 // *partition 左侧始终是比pivot小的数 int pivot = arr[right]; int partition = left; // 遍历分区元素 // 小于基准的放基准左边，大于的放基准右边 // * 终止条件：i &lt; right 而非 right-1！ for(int i=left; i&lt; right;i++) &#123; if(arr[i]&lt;pivot) // 实际只交换小于到左边即可 &#123; swap(arr,i,partition); partition++; &#125; &#125; // 基准插入位置partition位置 swap(arr,partition,right); //递归的排序 quick_sort(arr,left,partition-1); quick_sort(arr,partition+1,right); return arr; &#125; 堆排序 之前笔记：6.排序 核心思想 空间复杂度：O(1) , 时间复杂度：O(n*logn)。其中建堆：O(n) ，排序：O(n*logn)，时空复杂度由计算比较次数得到，具体理解 堆排序中建堆过程时间复杂度O(n)怎么来的？ - wuxinliulei的回答 - 知乎 具体对应代码实现： 将一维数组$arr$视作为完全二叉树处理（见上） 构建初始最大堆。遍历数组，从倒数第一个非叶子节点$i=len/2$,进行构建最大堆 如果左孩子（$i2+1$）,右孩子（$i2+2$）大于当前节点值，则交换 如果发生交换可能会破坏最大堆性质，继续往下调整 重复1~3，直至所有节点的子树都调整完毕 堆排序。 遍历数组，每次交换堆顶$i=0$ （最大值）和堆尾元素$i=len-1$ 由于交换元素值会可能改变最大堆性质，从堆顶往下调整（数组长度-1） 重复5~6直至堆排序完成 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public int[] heapSort(int[] arr) &#123; int len = arr.length; // 1.构建初始堆 // 从最后一个非叶子节点构建初始堆 for(int i= len/2; i&gt;=0; i--) // 对每一个节点视作根节点，调整子树符合最大堆 MaxHeapfily(arr,i,len); // 2.排序 // 每次交换堆顶和堆尾元素 // *注意数组长度会变化，所以终止条件是i&lt;arr.length-1，而不是len-1 for(int i=0; i&lt;arr.length-1 ; i++) &#123; swap(arr,0,len-1); // 交换破坏最大堆性质 // 从交换的元素i=0，开始往下调整 // *注意数组长度-1,而且会递归调用，所以不要在函数参数调用len-- len = len-1; MaxHeapfily(arr,0,len); &#125; return arr; &#125; // 设置参数要有数组长度，因为排序时交换堆顶和堆尾元素，相当删除堆顶元素 // 对应数组长度-1 public void MaxHeapfily(int[] arr, int root , int len) &#123; // 左右孩子 int left = root*2+1; int right = root*2+2; if(left&gt;=len) return; int largest = root; // 选择最大者 // *保证左右孩子存在 largest = arr[left]&gt;arr[largest]? left : largest; largest = right&lt;len &amp;&amp; arr[right]&gt;arr[largest]? right : largest; // 如果发生交换要往下调整 if(largest!=root) &#123; swap(arr,largest,root); MaxHeapfily(arr,largest,len); &#125; &#125; public void swap(int[] arr, int i,int j) &#123; int temp ; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; 数组查找 二分查找 二分查找还是较为简单的，易错的部分看代码注释就行。 12345678910111213141516171819202122232425// binary search public int binarySearch(int[] arr, int value) &#123; int left = 0,right = arr.length-1; int mid ; while (left&lt;=right) //*&lt;= 而不是&lt; &#123; mid = (left+right)/2; if(value == arr[mid]) &#123; return mid; // 如果数组存在待查找元素，按照逻辑一定会是mid &#125; else if(value &lt; arr[mid]) &#123; right = mid-1; &#125; else // value &gt; arr[mid] &#123; left = mid+1; &#125; &#125; return -1; &#125; 树遍历首先，我们定义基本树结构： 1234567public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 给定测试树结构如下： 回忆树三种遍历方式： 前序遍历（根→左→右）：按照根节点→左孩子→右孩子依次访问，每访问就立即打印出值 。(1)一直往根节点左孩子访问，每访问就立即输出值（含根节点） ，直至节点没有左孩子（子树）；（2）如果该节点有右孩子，右孩子作为根节点，重复(1) ; （3）如果没有，访问该节点的根节点右孩子，作为根节点，重复以上，直至全部访问并输出。 测试值：6 2 0 1 4 5 8 9 中序遍历（左→根→右）：(1)一直往根节点左孩子访问，如果至节点没有左孩子/子树（或已访问），则输出该节点值；(2)如果该节点有右孩子，右孩子作为根节点，重复(1) ; （3）如果没有，访问其根节点的右孩子，作为根节点，重复以上，直至全部访问并输出。 测试值：0 1 2 4 5 6 8 9 后序遍历（左→右→根）：类比前中序遍历，不过访问输出条件变为：节点左右子树都没有（或已访问），则输出该节点值；访问优先顺序，**都是先沿根节点左孩子访问，再右孩子或者上一节点右孩子继续..**。 测试值：1 0 5 4 2 9 8 6 共同点：前/中/后序遍历，输出节点条件不一样，但递归遍历顺序一样： （1）对于给定根节点root，一直沿着左孩子走直到为空（2）为空需要访问其右孩子，作为新的根节点重复以上步骤。 从图遍历到→树遍历：看完这篇，你会理解图和树的遍历 图有两种遍历方式，深度优先遍历（DFS）和广度优先遍历（BFS），下面用来遍历树结构。 深度优先遍历（DFS） 更细致讲解DFS和BFS，可以看：图文详解两种算法：DFS和BFS 见上讲解链接：首先知道，DFS遍历过程==树前序遍历（根→左→右）。递归代码如下： 12345678public void DFS(TreeNode root)&#123; if (root == null) return; System.out.print(root.val+&quot; &quot;); inOrderTraverse1(root.left); inOrderTraverse1(root.right);&#125; 为什么要用（栈，stack）非递归模拟进行实现DFS/ 前序遍历？ 栈是模拟递归不二选择，因为递归其实函数调用栈的问题，因此需要栈 这种数据结构支持。 栈用栈时模拟递归操作，核心操作要点？ push 时机：一经访问即push，同递归 pop 时机：节点左右子树都被访问，同递归函数被访问完毕。在前/中序非递归遍历时，左右孩子被访问即可： 1234递归时，要等节点右孩子pop出，即右子树被访问完毕（注，都访问右孩子了，左子树肯定被访问完毕）再pop出节点（此时节点左右子树都已被访问），也就是pop两次； 但对于【前序/中序】非递归时可以提前pop，即在节点右孩子被访问即pop，【不影响遍历输出值】：因为循环逻辑同时pop多次比较复杂，递归的第二次pop出节点也没有实质性影响。 [*]然而【后序】非递归，必须要：判断节点左右子树都访问完，才可以pop并输出其值。如果只是如前/中序非递归：左子树访问完，访问右孩子就pop输出其值，不符合实际递归后序调用。所以需要设置判断右子树是否访问完毕，再pop和输出。 输出时机：根据前/中/后序，所需不同条件进行输出。例如，前序/DFS：一访问则立即输出；中序：访问右孩子时即输出。 12345678910111213141516171819202122232425262728public void DFS(TreeNode root) &#123; LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); TreeNode pNode = root; // *栈空依旧可能没遍历完（如，访问右孩子但没压入） while (pNode != null || !stack.isEmpty()) &#123; // *这个条件易忘：输出空节点数值 if (pNode != null) // *这里不用while更简洁 &#123; // 前序遍历：访问后立即输出 System.out.print(pNode.val+&quot; &quot;); // 压入栈是为了走到空节点，可以退回到根节点 // 进而可以访问同级右孩子（模拟递归） stack.push(pNode); // 沿着下一个左孩子走 pNode = pNode.left; &#125; else //pNode == null &amp;&amp; !stack.isEmpty() &#123; // 一个节点【左右孩子都被访问】即pop // 虽然不是子树，但这里符合递归调用逻辑 TreeNode node = stack.pop(); // 右孩子作为根节点（node右子树），重复以上 pNode = node.right; &#125; &#125; &#125; 和广度优先遍历（BFS） 广度优先遍历较为简单，使用队列： 队列首先加入根节点，之后对于首节点 出队并输出其元素，同时判断其是否右左右孩子，有则加入 直至队列为空 1234567891011121314151617181920212223// BFS,队列public void levelTraverse(TreeNode root)&#123; if (root == null) &#123; return; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); // 队尾加入，下同 while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); // 出列 System.out.print(node.val+&quot; &quot;); if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125;&#125; 前序遍历 前序遍历，非递归代码同DFS，不再赘述。以下是递归代码： 123456789public void preOrderTraverse1(TreeNode root) &#123; if (root != null) &#123; System.out.print(root.val+&quot; &quot;); preOrderTraverse1(root.left); preOrderTraverse1(root.right); &#125; &#125; 中序遍历 中序非递归代码，有了前序非递归实现就简单很多了。 同前，递归遍历顺序都是一样的，但是 访问条件不一样 对于中序遍历： 左孩子为空，访问根节点右孩子时。所以，代码只需修改一处： 12345678910111213141516171819202122232425262728293031323334public void inOrderTraverse(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode pNode = root; // *栈空依旧可能没遍历完（如，访问右孩子但没压入） while (pNode != null || !stack.isEmpty()) &#123; // *这个条件易忘：输出空节点数值 if (pNode != null) // *这里不用while更简洁 &#123; // 【前序遍历输出】 // System.out.print(node.val+&quot; &quot;); // 压入栈是为了走到空节点，可以退回到根节点 // 进而可以访问同级右孩子（模拟递归） stack.push(pNode); // 沿着下一个左孩子走 pNode = pNode.left; &#125; else //如果 pNode == null 且栈不同 &#123; // 一个节点【左右孩子都被访问】即pop // 虽然不是子树，但这里符合递归调用逻辑 TreeNode node = stack.pop(); //【中序遍历输出】 System.out.print(node.val+&quot; &quot;); // 右孩子作为根节点（node右子树），重复以上 pNode = node.right; &#125; &#125;&#125; 后序遍历 非递归后序遍历这个分析比较清晰：二叉树遍历(先序、中序、后序) 如前所述： [*] 然而【后序】非递归，必须要：判断节点左右子树都访问完，才可以pop并输出其值。如果只是如前/中序非递归：左子树访问完，访问右孩子就pop&amp;输出其值，不符合实际递归后序调用。所以需要设置判断右子树是否访问完毕，再pop和输出。 代码哪一块需要修改呢？ while内部前面代码：一直沿节点左孩子往下走并PUSH入栈，直至==null 。符合实际递归逻辑，不用修改。所以，实际是如何对后续“往右走”后的逻辑修改，增加对右子树是否访问完毕，进而是否出栈pop。 如何判断右子树是否访问完毕呢？ 如果直接思考右子树是否被访问，难以得出好的方法。可以先考虑一种特殊情况：如果往右走时，右孩子为空 右孩子==null，则pop 对于判断右子树!=null，但已访问也需pop的情况。因为我们设置lastVisit来标记上一个被pop的节点，如果lastVisit指向的节点的右孩子，则说明节点右子树都已被访问完毕可以被pop（和输出）。 或者 lastVisit==节点.right，则pop 代码如下： 12345678910111213141516171819202122232425262728293031// 非递归后序遍历public void postorderTraversal(TreeNode root)&#123; LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); TreeNode node = root; TreeNode lastVisit = root; // 初始化为null？ while (node != null || !stack.isEmpty()) &#123; if (node != null) &#123; stack.push(node); node = node.left; &#125; node = stack.peek(); //如果其右子树也为空，或者右子树已经访问 //则可以直接输出当前节点的值 if (node.right == null || node.right == lastVisit) &#123; System.out.print(node.val + &quot; &quot;); stack.pop(); lastVisit = node; node = null; &#125; else &#123; //否则，继续遍历右孩子为新根节点，往左走 node = node.right; &#125; &#125;&#125; 动态规划 参考教程：告别动态规划，连刷 40 道题，我总结了这些套路，看不懂你打我 动态规划解析核心四个条件，以斐波那契数列为例： 状态定义： 设 $dp$ 为一维数组，其中 d$p[i]$ 的值代表 斐波那契数列第 $i$ 个数字 。 转移方程： $dp[i + 1] = dp[i] + dp[i - 1]$ ，即对应数列定义$ f(n + 1) = f(n) + f(n - 1)$ ； 初始状态： $dp[0] = 1,dp[1]=1$ ，即初始化前两个数字； 返回值： $dp[n]$，即斐波那契数列的第 $n$ 个数字。 以下案例分析。 青蛙跳台阶（1维dp） 问题描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解法分析 参考面试题10- II. 青蛙跳台阶问题（动态规划，清晰图解） 同上分析我们可以得出代码： 123456789101112131415161718192021public int numWays(int n)&#123; if (n &lt;= 1) return 1; // 状态定义：dp[i]表示跳到第i个台阶的方式 int[] dp = new int[n + 1]; // 初始状态 dp[1] = 1; dp[2] = 2; // 转移方程：跳到第n个台阶的方式d[n] // -从第n-1→跳到n，跳到第n-1个台阶有d[n-1]方式，第n-1→跳到n有 // 1种方式（跳1阶），故有d[n-1]*1 // -从第n-2→跳到n，跳到第n-2个台阶有d[n-2]方式，第n-1→跳到n有 // 1种方式（跳2阶），故有d[n-2]*1 // 一共是：d[n-1]+d[n-2] for (int i = 3; i &lt;= n; i++) dp[i] = dp[i - 1] + dp[i - 2]; // 返回值 return dp[n]; &#125; 不同路径I（二维dp） 题目描述 一个机器人位于一个 m x n 网格的左上角，机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，一共有多少种路径？ 解法分析 按照之前动态规划四步走： 状态定义： $d[i][j]$ 表示移动坐标为$(i,j)$ 的路径方式 转移方程： $$(i,j)$$只能由左边 $(i-1,j)$→右到$(i,j)$ 或者$(i,j-1)$→下到 $(i,j)$，所以类似青蛙跳台阶： $d[i][j]$ = $d[i-1][j]$ + $d[i][j-1]$ PS: 这样思考不也会有重复路径产生 返回状态： $d[n-1][m-1]$ 初始值： 对于状态方程 $d[i][j]$ = $d[i-1][j]$ + $d[i][j-1]$ ，必须是$i&gt;0,j&gt;0$ 才成立，所以初始状态应该是$d[0][j]=1$ , $d[i][0]=1$ 。表示如果坐标$(i,j)$是在第一列或者第一行，只能一直向下走 或 向右走这一种方式 代码实现 123456789101112131415161718192021222324252627282930public int uniquePaths (int m, int n) &#123; // 动态规划 // 1.状态定义：dp[i][j]表示走到当前位置(i,j)不同路径数 // 2.转移方程：位置(i,j)可以由 // 1）(i-1,j)向右走(i,j) // 2）(i,j-1)向下走(i,j) // 所以走到(i,j)的总路径数dp[i,j]=dp[i-1,j]+dp[i,j-1] // 3.初始定义：初始化dp[0,j] 和 dp[i,0] // 4.返回值：返回dp[m-1][n-1] if(m==1 || n==1) return 1; // 状态定义 int[][] dp = new int[m][n]; // 初始定义 for(int i=0 ; i&lt;m ; i++) dp[i][0]=1; for(int j=0 ; j&lt;n ; j++) dp[0][j]=1; // 转移方程 for(int i=1 ; i&lt;m ; i++) for(int j=1 ; j&lt;n ; j++) dp[i][j]=dp[i-1][j]+dp[i][j-1]; // 返回 return dp[m-1][n-1]; &#125; 不同路径II（二维dp） 题目描述 给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有数字累加就是路径和，输出所有路径中最小路径和。 解法分析 按照之前动态规划四步走： 状态定义： $d[i][j]$ 表示移动坐标为$(i,j)$ 的路径之和最小方式的值 转移方程： $$(i,j)$$只能由左边 $(i-1,j)$→右到$(i,j)$ 或者$(i,j-1)$→下到 ，$(i,j)$ ，比较 $d[i-1][j]$ 和 $d[i][j-1]$ 大小取较小值加上 $places[i][j]$ 便是最小路径之和：$$d[i][j] = d[i-1][j]&lt;d[i][j-1]?d[i-1][j]+places[i][j]：d[i][j-1]+places[i][j]​$$ 返回状态： $d[n-1][m-1]$ 初始值： 对于状态方程 $d[i][j]$ = $d[i-1][j]$ + $d[i][j-1]$ ，必须是$i&gt;0,j&gt;0$ 才成立，所以初始状态应该是：$d[0][j]=\\sum_j places[0][j]$ (向下走路径之和，由于只能向右和向下，所以第一列上的位置只能一直往下走) ；同理，第一行上位置，$d[i][0]=\\sum_i places[i][0]$ 。 代码实现 1234567891011121314151617181920public int minPathSum (int[][] matrix) &#123; int n = matrix.length; // 行，一维矩阵个数 int m = matrix[0].length; // 列，一维数组长度 // 状态定义 int[][] dp = new int[n][m]; // 初始值 dp[0][0] = matrix[0][0]; for(int i=1; i&lt;n; i++) dp[i][0] = dp[i-1][0] + matrix[i][0]; for(int j=1; j&lt;m; j++) dp[0][j] = dp[0][j-1] + matrix[0][j]; // 递推&amp;转移方程 for(int i=1; i&lt;n; i++) for(int j=1; j&lt;m; j++) dp[i][j] = dp[i-1][j]&lt;dp[i][j-1]? dp[i-1][j]+matrix[i][j]: dp[i][j-1]+matrix[i][j]; return dp[n-1][m-1]; &#125; 编辑字符（二维dp） 题目描述 解法思路 状态定义比较难想到，还需多做题。转移方程也很难写，直接看 leetcode题解-编辑距离 吧。 动态规划四步走： 状态定义： $d[i][j]$ 表示从长度为$i$ 的word1转为为长度为$j$的word2所需最少操作数 转移方程： 返回状态： $d[n][m]$ 初始值： 同前，保证$i，j&gt;0$ 成立，所以初始状态应该是：$d[0][j]=\\sum_{j=0} j+1$ ， $d[i][0]=\\sum_{i=0} i+1$ 代码实现 123456789101112131415161718192021222324252627282930313233343536 class Solution &#123; public int minDistance(String word1, String word2) &#123; int n = word1.length(); int m = word2.length(); // 有一个字符串为空串 if (n * m == 0) &#123; return n + m; &#125; // DP 数组 int[][] D = new int[n + 1][m + 1]; // 边界状态初始化 for (int i = 0; i &lt; n + 1; i++) &#123; D[i][0] = i; &#125; for (int j = 0; j &lt; m + 1; j++) &#123; D[0][j] = j; &#125; // 计算所有 DP 值 for (int i = 1; i &lt; n + 1; i++) &#123; for (int j = 1; j &lt; m + 1; j++) &#123; int left = D[i - 1][j] + 1; int down = D[i][j - 1] + 1; int left_down = D[i - 1][j - 1]; if (word1.charAt(i - 1) != word2.charAt(j - 1)) &#123; left_down += 1; &#125; D[i][j] = Math.min(left, Math.min(down, left_down)); &#125; &#125; return D[n][m]; &#125;&#125; 链表操作 基本链表实现，含删除、插入等基本操作。 定义ListNode 使用通常OJ (e.g. 牛客网) ，的节点定义： 12345678910public class ListNode&#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 定义LinkList 为了引入头结点head ，和一些基本（单）链表操作。 如果不引入头结点head，还要特别判断要 删除/插入/…的节点是否头结点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class LinkList&#123; ListNode head; int len; // 【初始化】 LinkList() &#123; // ** head 必须初始化！！ head = new ListNode(0); len = 0; &#125; // 【删除】一个节点:关键在于找到被删除节点的前一个节点 public void del(ListNode delNode) &#123; ListNode pre = head; // 找到被删除节点的前一个节点 while (pre.next!=delNode) pre = pre.next; // 开始删除节点 // head→..→pre→delnode→.. pre.next = delNode.next; delNode.next=null; // *更新长度 len--; &#125; // 【插入】一个节点 public void insert(ListNode preNode,ListNode newNode) &#123; // *尽量先不破坏原先链接，先更新新节点newNode的指向 // 再更新原先节点preNode的指向 newNode.next = preNode.next; preNode.next = newNode; //*长度更新 len++; &#125; // 【打印】链表 public void print () &#123; ListNode tmp = head; while (tmp.next!=null) &#123; System.out.print(tmp.next.val+&quot;→&quot;); tmp = tmp.next; &#125; &#125;&#125; 基本：翻转链表 提供的链表头结点指向第一个节点，而非伪节点。 12345678910111213141516171819202122public ListNode ReverseList(ListNode head) &#123; if(head==null) return head; // *p,q,q_next,分别记录前一个节点，当前节点，下一个节点 // *为了操作统一，p最开始指向null！！ ListNode p = null; ListNode q = head,q_next=null; while(q!=null) &#123; // *下一个节点更新放在循环开始，而非末尾 // 避免q.next==null时，q.next.next赋值给q.next出错 q_next = q.next; // 改变q指向 q.next=p; // *更新前一个节点，当前更新p,q节点只能在循环末尾 // 因为后面代码q.next=p，要操作p，q，在此之前不能更新p，q p=q; q=q_next; &#125; return p; &#125; 基本：是否有环 终止条件记下。 1234567891011121314151617181920212223public boolean hasCycle(ListNode head) &#123; // 思路1：快慢指针（trick），最优解，O(1)复杂度 // 思路2：hashmap存下所有节点，然后遍历节点就去判断是否在hashmap中 // *要先判断head==null的情况 if(head==null) return false; ListNode step1 = head; ListNode step2 = head; while(step2!= null &amp;&amp; step2.next != null) &#123; // 好像不会出现step1==null的情况？ // 因为【如果有环】会在快指针走到终点前就相遇 step1 = step1.next; // 循环终止条件从这里得到 step2 = step2.next.next; // *不能在前面判断，因为初始step1==step2 if(step1==step2) return true; &#125; return false; &#125; 基本：合并链表 高频出现。 1234567891011121314151617181920212223242526272829public ListNode mergeList(ListNode head1,ListNode head2) &#123; ListNode head = new ListNode(0); // *保留head，使用工作指针h ListNode h = head; while(head1 != null &amp;&amp; head2 != null) &#123; if(head1.val&lt;head2.val) &#123; h.next = head1; head1 = head1.next; &#125; else &#123; h.next = head2; head2 = head2.next; &#125; // *指向合并链表末尾 h = h.next; &#125; // 剩下未排序完成的 if(head1 != null) h.next = head1; else h.next = head2; return head.next; &#125; 基础：删除重复数 不知道为啥，我删除重复代码记得好牢靠。。 123456789101112131415161718192021222324252627public ListNode deleteDuplicates (ListNode head) &#123; if(head == null || head.next == null) return head; // 思路(保证下面链表至少有2个节点) // 1.设置初始工作指针pre=head,p=head.next // pre指向的待删除重复数在链表排序最前的数字 // 2.如果pre.val = p.val,则删除p指向的节点,p往后移动 // 3.如果不等，说明pre指向的数字不存在重复数， // pre和p都往后移动，直至p为null退出循环 ListNode pre = head, p = head.next; while(p!=null) &#123; if(pre.val == p.val) &#123; pre.next = p.next; p = p.next; &#125; else &#123; pre = pre.next; p = p.next; &#125; &#125; return head; &#125; 1.2 数组【看】NC61: 两数之和 题目描述 解法思路 暴力解法，比较耗时：对数组每个元素（循环1），去遍历剩余的元素找到补足数并返回下标（循环2）。 （循环2）可转换为 “在数组中找到 指定数 的下标” ，可以考虑对数组建立以：元素为key，下标为value 的HashMap 。对于已知的key（指定数），HashMap 可在O(1) 时间找到，而非每次遍历其余数组剩下数O(n)。 代码实现 1234567891011121314151617181920public int[] twoSum (int[] numbers, int target) &#123; // write code here HashMap&lt;Integer , Integer&gt; dic = new HashMap(); // 一次遍历建立hashmap for(int i=0; i&lt; numbers.length; i++) dic.put(numbers[i],i); // 遍历每个元素找到补足数 int[] res = new int[2]; for(int i=0; i&lt; numbers.length-1; i++) &#123; Object complemetNumIdx = dic.get(target-numbers[i]); if (complemetNumIdx!=null &amp;&amp; (Integer) complemetNumIdx != i) &#123; // *i一定&lt;complemetNumIdx，不用判断大小 return new int[]&#123;i+1,(Integer) complemetNumIdx+1&#125;; &#125; &#125; return null ; &#125; NC22: 合并数组 【套路】【归并】：两个有序子数组归并排序 题目描述 解法思路 套路：设置三个指针i，j，k 分别指向：数组A末尾元素、数组B末尾元素，数组A索引$m+n-1$ 处。每次指针i 与j 进行对比，取较大者元素放置指针k 处，且对应指针（i或j） 与k往前移动。直至i 或j &lt;0（null），处理边界情况： 数组A未遍历完（i&gt;0）：由于是对A操作，已经有序了，结束 数组B未遍历完（j&gt;0）：说明B剩余元素都小于A中元素，A所有元素都已移动至后，指针j 继续往前移动，将B剩余元素直接插入A中即可。 代码实现 *一个蠢蠢错误：数组B全部用数组A。 123456789101112131415public void merge(int A[], int m, int B[], int n) &#123; // 定义三个指针 int qa= m-1,qb=n-1,qc=m+n-1; // 循环遍历：从尾部开始 for (int i=qc; i&gt;=0 ; i--) &#123; if(qb&lt;0) // 数组B遍历结束 return; if(qa&lt;0) // 数组A遍历结束，但B未结束 A[qc--] = B[qb--]; else A[qc--] = A[qa]&gt;B[qb]? A[qa--]:B[qb--]; &#125; &#125; NC38: 螺旋矩阵 题目描述 解法思路 对于这种多层递归循环问题，通过从特例思考，比如：如何遍历最外层矩阵元素输出？ 出发位置：→向右出发，超出右侧边界则停下；↓接着往下，超出下侧边界则停下；←往左继续，超出左侧边界则停下；↑向上继续，即将到达初始位置则停下。 这样最外层遍历便明了了，对于内层矩阵继续循环输出有什么不一样吗？ 出发位置变化（左上）：下一层矩阵循环，出发位置横纵坐标均+1 边界位置变化（右下）：边界位置-1（矩阵最右侧索引，最下侧索引位置） 这样我们只要：外侧套入一个循环，将出发位置和边界位置作为变量 ，便可以遍历整个螺旋矩阵。循环结束条件：已返回的元素个数==矩阵元素个数。 代码实现 代码一直在牛客网通过不了，但本地没问题？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//NC38 public ArrayList&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; ArrayList&lt;Integer&gt; arr = new ArrayList(); int m = matrix.length; // 矩阵行数 int n = matrix[0].length; // 矩阵列数 if(n == 0) // * 注意边界条件 return arr; // 螺旋递归思考太复杂，先思考如何遍历一圈 int i,j; // 矩阵遍历索引 int left = 0 , top=0 , // 矩阵左上 right = m-1, bottom = n-1; // 矩阵右下 // *判断条件不能是&lt;=, 会导致再次进入循环 while (arr.size() &lt; m*n) // 递归螺旋矩阵 &#123; // 初始矩阵遍历位置 i = left; j = top; while (j&lt;=bottom) // 向右 &#123; arr.add(matrix[i][j++]); &#125; j--; i++; // *矩阵右边从第二个元素开始 while (i&lt;=right) // 向下 &#123; arr.add(matrix[i++][j]); &#125; i--; j--; // *从矩阵下边从左→右第二个元素开始 while (j&gt;=left) // 向左 &#123; arr.add(matrix[i][j--]); &#125; j++; i--; // *从矩阵左边从下→上第二个元素开始 while (i &gt; top) // 向上 &#123; arr.add(matrix[i--][j]); &#125; // 开始下一内层矩阵遍历 left++ ; top++; // 更新内矩阵左上位置 right-- ; bottom--; // 更新内矩阵右下位置 &#125; return arr; &#125; NC12: 重建二叉树 题目描述 解法思路 树遍历的模板代码如下： 1234567891011121314public void Traverse(TreeNode root)&#123; // 1.递归终止条件 if (root == null) return; // 2.确定新的递归参数 // do something // 3.递归操作 Traverse(root.left); Traverse(root.right); &#125; 如何将模板代码修改为我们需要的重建二叉树的代码？ 1234public TreeNode reConstructBinaryTree(int [] pre,int [] in)&#123; // code is here &#125; 首先我们将问题转换为递归思路： 根据前序序列第一个结点确定根结点 根据根结点在中序序列中的位置分割出左右两个子序列 对左子树和右子树分别递归使用同样的方法继续分解 根据模板代码，我们： 确定递归终止条件 原来确定递归终止是，当前节点为null： 123// 1.递归终止条件 if (root == null) return; 中序给定参数为前序、中序数组pre和in , 可以通过判断数组长度==0判断： 12if(pre.length==0) return null; 确定新的递归参数pre、in 对于树遍历模板，新的递归参数只需root.left /root.right 可直接获取。 但对于重建二叉树，需要根据前序、中序序列确定左右子树，进而得到新的递归参数pre/ in。 这一部分主要知道如何根据前序、中序序列确定一根树，难度不高。 根据前序pre确定树根pre[0] 找到pre[0] 在中序in 的位置root_idx 进而确定左右子树的中序、前序序列 123456789// 确定根节点在中序中位置，进而划分左右子树int rootIdx = findRootIdx(in,pre[0]); // 左子树的：前序序列，中序序列(copyOfRange 函数，左闭右开)int[] l_pre = Arrays.copyOfRange(pre, 1, rootIdx + 1);int[] l_in = Arrays.copyOfRange(in, 0, rootIdx);//右子树的：前序序列，中序序列int[] r_pre = Arrays.copyOfRange(pre, rootIdx+1, pre.length);int[] r_in = Arrays.copyOfRange(in, rootIdx+1, in.length); 递归操作 这一部分略微难以理解: 当前节点左子树遍历完成时，我们希望返回它的根节点作为当前节点的左孩子 当前节点右子树遍历完成时，返回它的根节点作为当前节点的右孩子 无论左子树还是右子树：“遍历完成时” ,均指的是代码将要执行完成到函数末尾&#125; 。 即在后序位置，返回当前节点： 12345678910111213// 前序找到根节点 TreeNode root = new TreeNode(pre[0]);// 说明当前节点的左子树已经访问完毕（即将访问右子树）// 返回的是左子树的根节点（即当前节点的左孩子）// *所以函数最后还要 return root; root.left = reConstructBinaryTree(l_pre,l_in);// 右子树完成时 root.right = reConstructBinaryTree(r_pre,r_in); // [后序]*必须要返回当前节点(用来构建左右子树) return root; 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.Arrays;public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; // [递归终止] 根据pre和in判断 // 前序（或中序）长度为0，说明当前节点为空节点 if(pre.length==0) return null; // 确定根节点在中序中位置，进而划分左右子树 int rootIdx = findRootIdx(in,pre[0]); // 左子树的：前序序列，中序序列(copyOfRange 函数，左闭右开) int[] l_pre = Arrays.copyOfRange(pre, 1, rootIdx + 1); int[] l_in = Arrays.copyOfRange(in, 0, rootIdx); //右子树的：前序序列，中序序列 int[] r_pre = Arrays.copyOfRange(pre, rootIdx+1, pre.length); int[] r_in = Arrays.copyOfRange(in, rootIdx+1, in.length); // 递归计算k // 前序找到根节点 TreeNode root = new TreeNode(pre[0]); // 说明当前节点的左子树已经访问完毕（即将访问右子树） // 返回的是左子树的根节点（即当前节点的左孩子） // *所以函数最后还要 return root; root.left = reConstructBinaryTree(l_pre,l_in); root.right = reConstructBinaryTree(r_pre,r_in); // *必须要返回当前节点(用来构建左右子树) return root; &#125; public int findRootIdx(int[] array,int val) &#123; int val_idx = -1; for(int i=0 ; i &lt; array.length; i++) &#123; if (val == array[i]) &#123; val_idx = i; return val_idx; &#125; &#125; return val_idx; &#125; &#125; NC65: 斐波那契 题目描述 题解思路 斐波那契数列，同样是递归解决，关键在于如何拆解为递归子问题？ 欲求F(n) , 拆解为求F(n-1) 和F(n-2)之和 对于F(n-1) 拆解为求F(n-2) 和F(n-3)之和 ；F(n-2) 拆解为求F(n-3) 和F(n-4)之和 重复以上，直至拆解为已知的F(0)=1 和F(1)=1之和 所以代码容易得出： 1234567891011public class Solution&#123; public int Fibonacci(int n) &#123; // 第0项是0，第1项是第一个1,每一项等于前两项之和 if(n==0) return 0; if(n==1) return 1; return Fibonacci(n-1)+Fibonacci(n-2); &#125;&#125; 但是这种方式进行的递归有太多重复计算，如下图： f(2) 被重复计算3次 ； f(3) 被重复计算2次 为此，我们可以考虑用一个数组（或字典）来保存已计算的值，从而减少重复计算。 代码实现 12345678910111213141516171819202122232425import java.util.Arrays;public class Solution &#123; int[] res ; public int Fibonacci(int n) &#123; res = new int[n+1]; // *长度==n+1，否则res[n]超出索引 Arrays.fill(res,-1); return F(n); &#125; public int F(int n) &#123; if(n==0 || n==1) return n; if(res[n] != -1) return res[n]; return res[n] = F(n-1)+F(n-2); &#125;&#125; NC48: 动数组找值 题目描述 题目思路 leetcode官方解析 已经很清晰了，仅补充一点自己想法。 此题难点在于：如何用二分查找法完成查找？ 首先，数组有序仅是可以使用二分查找的充分条件而并不是必要条件，关键在于能否确定待查找的数（target）在界桩（如，mid）的哪一边？ 对于转动的数组，依旧以mid为界桩，根据转动特点在mid左右数组子序列必有一边是有序的。我们可以根据有序那边确定target是否在其中，否则在另外一边： 确定哪一边有序：对于左边，由于转动导致左边界可能存在非有序数字，如mid&gt;左边界则左边一定有序 ；同理，mid&lt;右边界则右边有序。 查找target是否在有序部分范围内，如果 在有序部分内，重复1,2（但是判断条件就有点多余了） 如果不在，重复1,2在无序部分搜索（无序部分依旧符合转动特点） 代码实现 12345678910111213141516171819202122232425262728293031323334353637public int search (int[] A, int target) &#123; if(A==null || A.length==0) return -1; int left=0, right=A.length-1; int mid=-1; while(left&lt;=right) &#123; // *但是可能存在此时划分的数组长度=1，left=right=mid // 且left/right此时为数组左/右边界，下面mid-1/mid+1会超索引 // 如 [1] 查找0（不存在），所以先排除该情况 if(right-left==0 &amp;&amp; A[left]!=target) return -1; mid = (left+right)/2; if(A[mid]==target) return mid; if(A[left]&lt;A[mid]) // 左边此时有序（右边也可能） &#123; // 判断target是否在左边有序部分 if(A[left]&lt;=target &amp;&amp; target&lt;=A[mid-1]) right=mid-1; else // 否则在右边有序部分 left=mid+1; &#125; else // 如果左边不有序则右边一定有序 &#123; // 判断target是否在右边有序部分 if(A[mid+1]&lt;=target &amp;&amp; target&lt;=A[right]) left=mid+1; else // 否则在左边无序部分 right=mid-1; &#125; &#125; return -1; &#125; NC54: 3sum 题目描述 解法思路 建议直接看LeetCode解答更清晰 : 如何一步步从三重循环优化 题目中要求找到所有「不重复」且和为 00 的三元组，这个「不重复」的要求使得我们无法简单地使用三重循环枚举所有的三元组。这是因为在最坏的情况下，数组中的元素全部为 00，即： 1[0, 0, 0, 0, 0, ..., 0, 0, 0] 任意一个三元组的和都为 0。如果我们直接使用三重循环枚举三元组，会得到 $O(N^3) $个满足题目要求的三元组（其中 $N$ 是数组的长度）时间复杂度至少为 $O(N^3)$。在这之后，我们还需要使用哈希表进行去重操作，得到不包含重复三元组的最终答案，又消耗了大量的空间。这个做法的时间复杂度和空间复杂度都很高，因此我们要换一种思路来考虑这个问题。 「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证： 第二重循环枚举到的元素不小于当前第一重循环枚举到的元素； 第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。 也就是说，我们枚举的三元组 $(a, b, c)$满足 $a \\leq b \\leq c$，保证了只有$ (a, b, c)$ 这个顺序会被枚举到，而 $(b, a, c)$、$(c,b,a)$ 等等这些不会，这样就减少了重复。要实现这一点，我们可以将 数组中的元素从小到大进行排序 ，随后使用普通的三重循环就可以满足上面的要求。 同时，对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复。举个例子，如果排完序的数组为: 1[0, 1, 2, 2, 2, 3] 我们使用三重循环枚举到的第一个三元组为 $(0, 1, 2)$，如果第三重循环继续枚举下一个元素，那么仍然是三元组 $(0, 1, 2)$，产生了重复。因此我们需要将第三重循环「跳到」下一个不相同的元素，即数组中的最后一个元素 $3$，枚举三元组$ (0, 1, 3)$。 下面给出了改进的方法的伪代码实现： 12345678910nums.sort()for first = 0 .. n-1 // 只有和上一次枚举的元素不相同，我们才会进行枚举 if first == 0 or nums[first] != nums[first-1] then for second = first+1 .. n-1 if second == first+1 or nums[second] != nums[second-1] then for third = second+1 .. n-1 if third == second+1 or nums[third] != nums[third-1] then // 判断是否有 a+b+c==0 check(first, second, third) 这种方法的时间复杂度仍然为 $O(N^3)$，毕竟我们还是没有跳出三重循环的大框架。然而它是很容易继续优化的，可以发现，如果我们固定了前两重循环枚举到的元素 $a$ 和 $b$，那么只有唯一的 $c$ 满足 $a+b+c=0$。当第二重循环往后枚举一个元素$ b’$时，由于 $b’ &gt;b$，那么满足 $a+b’+c’=0$ 的 $c’$一定有 $c’ &lt; c$ 即 $c’$在数组中一定出现在 $c$ 的左侧。也就是说，我们可以从小到大枚举 $b$，同时从大到小枚举 $c$，即第二重循环和第三重循环实际上是并列的关系。 有了这样的发现，我们就可以保持第二重循环不变，而将第三重循环变成一个从数组最右端开始向左移动的指针，从而得到下面的伪代码： 123456789101112nums.sort()for first = 0 .. n-1 if first == 0 or nums[first] != nums[first-1] then // 第三重循环对应的指针 third = n-1 for second = first+1 .. n-1 if second == first+1 or nums[second] != nums[second-1] then // 向左移动指针，直到 a+b+c 不大于 0 while nums[first]+nums[second]+nums[third] &gt; 0 third = third-1 // 判断是否有 a+b+c==0 check(first, second, third) 这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 $O(N^2)$ 减少至 $O(N)$。为什么是 $O(N)$ 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 $b$），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 $O(N)$，均摊下来，每次也向左移动一个位置，因此时间复杂度为$O(N)$。 注意到我们的伪代码中还有第一重循环，时间复杂度为 $O(N)$，因此枚举的总时间复杂度为 $O(N^2)$。由于排序的时间复杂度为 $O(N \\log N)$，在渐进意义下小于前者，因此算法的总时间复杂度为 $O(N^2)$。 上述的伪代码中还有一些细节需要补充，例如我们需要保持左指针一直在右指针的左侧（即满足$ b \\leq c$），具体可以参考下面的代码，均给出了详细的注释。 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(int[] num) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); int len = num.length; // 排序方便循环不重复 // 多重循环有序数组组合不重复：下一轮循环&gt;=上一轮元素 Arrays.sort(num); // 一重循环：选择一个数为目标数（不能重复） for(int a=0; a&lt;len ; a++) &#123; // *重复则跳过 // 如果是判断num[a]==num[a+1]? 会出现case：nums=[0,0,0] // 输出为[] 而非预期的输出[0,0,0] // 保证多个相邻重复数，第一个可以使用 if(a&gt;0 &amp;&amp; num[a]==num[a-1]) continue; // 二重循环：双指针法 // 元素不重复:二重循环元素&gt;=一重循环 int c = len-1; // 右指针 for(int b=a+1; b&lt;c ; b++) &#123; // *重复则跳过 // 这里b&gt;a+1,否则同样case：nums=[0,0,0] // 输出为[] if(b&gt;a+1 &amp;&amp; num[b]==num[b-1]) continue; // 右指针左移动，直至a+b+c&lt;=0 // *保证c在b的右侧，否则会使用重复元素 while(b&lt;c &amp;&amp; num[a]+num[b]+num[c]&gt;0) &#123; c--; &#125; // 检查此时a+b+c=0？ // **注意此时b不能等于c，否则会使用重复元素！ if(b!=c &amp;&amp; num[a]+num[b]+num[c]==0) &#123; ArrayList&lt;Integer&gt; triple = new ArrayList(); triple.add(num[a]); triple.add(num[b]); triple.add(num[c]); res.add(triple); &#125; &#125; &#125; return res; &#125; NC73:一半数字 题目描述 解法思路 题目挺简单的 哈希法： 12345678910111213141516171819public int MoreThanHalfNum_Solution(int [] array) &#123; // 采用haspmap一次记录 HashMap dic = new HashMap(); int len = array.length; // 一次遍历记录 for(int i=0; i&lt; len; i++) &#123; Object obj_cur_count = dic.get(array[i]); int count = 1; if(obj_cur_count!=null) count = Integer.parseInt(obj_cur_count.toString())+1; dic.put(array[i], count); // *是i&gt;= 不是 i&gt; if(i&gt;=len/2 &amp;&amp; count&gt;len/2) return array[i]; &#125; return 0; &#125; 候选法 加入数组中存在众数，那么众数一定大于数组的长度的一半。 初始化：众数=num[0] , 票数=0， 从i=1遍历数组，如果当前数字≠众数，票数-1 。如果票数&lt;=0，则众数=num[i++] 。最差的情况是消去一个众数和一个非众数； 如果当前数字=众数，票数+1 循环结束，返回最终众数 代码实现 候选法实现代码如下： 12345678910111213141516171819202122232425public int MoreThanHalfNum_Solution(int [] array) &#123; // 初始化众数和票数 int modal = array[0], vote = 0; for(int i=1; i&lt;array.length;i++) &#123; // 判断众数是否和当前数字相等 // 相等则vote+1，不相等则vote-1 vote = modal==array[i]?vote+1:vote-1; // 票数&lt;=0 &amp;&amp; i不指向数组末尾，更新众数 // 票数&lt;=0 且当前i指向数组末尾，此时必不存在众数 if(vote&lt;=0 &amp;&amp; ++i&lt;array.length) modal=array[i]; &#125; // 验证众数 int count=0; for(int i=0; i&lt;array.length; i++) &#123; if(modal==array[i]) count++; if(count&gt;array.length/2) return modal; &#125; return 0; &#125; NC36: 数组中位数 题目描述 解法思路 leetcode 题解：详细通俗的思路分析，多解法 本题易联想到归并排序中 合并两个有序数组，再取中位数。在这个过程中，只需记录指针位移，不用进行实际元素更新：空间复杂度可以优化成O(1)，但是时间复杂度依旧是O(n+m) : 注意和NC22不同（数组A有多余空间可以存下B），这里的指针从头开始而非尾部。 从头部考虑更简单。 12345678910111213141516171819202122232425262728293031323334353637383940public int findMedianinTwoSortedAray (int[] arrA, int[] arrB) &#123; // 将两个有序数组合并成一个有序数组：三指针法 int m = arrA.length , n = arrB.length; // 定义三个指针 // 这里qc用来记录指针总的移动次数 // 指针每移动一次代表一个数被确定(被排序好) int qa= 0 ,qb=0, qc=0; // 需被确定的数，中位数k及之前的所有的数 int k = (m+n)%2==0? (m+n)/2 : (m+n)/2+1; // 先比较完一个数组 while(qa&lt;m &amp;&amp; qb&lt;n) &#123; if(arrA[qa]&lt;=arrB[qb]) &#123; qa++; qc++; // 每次移动指针时判断是否确定（排序）数组中[0,中位数k] // 所有数字 if(qc==k) return arrA[qa-1]; &#125; else &#123; qb++; qc++; if(qc==k) return arrB[qb-1]; &#125; &#125; // 比较剩余的数 while(qa&lt;m) // A未比较完毕 &#123; qa++; qc++; if(qc==k) return arrA[qa-1]; &#125; while(qb&lt;m) &#123; qb++;qc++; if(qc==k) return arrB[qb-1]; &#125; return 0; &#125; 但是如何优化时间到O(log(m+n)呢？ 该问题可转换为：求第k小数字。 初始k值，即中位数在合并的序列中下标为 k = (m+n)%2==0? (m+n)/2 : (m+n)/2+1; 比较A[k/2-1] 和 B[k/2-1]，其中较小者：最多只有A[0..k/2-2] + B[0..k/2-2] == k-2 个元素比它小，不可能是中位数k，可以将（[0..k/2-1]）数字全部排除。 更新数组左边界left=k/2，修改k=k-(k/2) （:warning: 不等价于k=k/2!） 然后考虑三种边界条件（fu*k，怎么这么难想？）： 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public int findMedianinTwoSortedAray (int[] arrA, int[] arrB) &#123; int m = arrA.length, n = arrB.length; // 转换为求第k小的数 int k = (m + n) % 2 == 0 ? (m + n) / 2 : (m + n) / 2 + 1; // 数组左边界变化 int leftA = 0, leftB = 0; // 中位数指针比较位置 int mediaA = 0, mediaB = 0; while (true) &#123; /* 1.比较A[k/2-1]和 B[k/2-1] 2.如果，k/2-1会导致越界，改为对应数组的末尾len-1 3.否则，更小的排除前面[0..k/2-1]个数 或 [0..len-1]之间数字 4.更新k=k-k/2 或者 k=k-len 5.更新左边界left,如果left&gt;数组边界，返回另外一个数组第k个元素 6.直至k=1，返回左边界较小的数便是第k小的数 */ // 数组为空说明该数组元素全部被排除，直接返回另外数组第k小即可 if(leftA &gt; m-1) return arrB[leftB+k-1]; if(leftB &gt; n-1) return arrA[leftA+k-1]; // k==1时比较剩余待比较数组左边界第一个数字 if (k == 1) return arrA[leftA] &lt; arrB[leftB] ? arrA[leftA] : arrB[leftB] ; // *更新中位数指针比较位置(注意指针+left) mediaA = leftA + k / 2 - 1; mediaB = leftB + k / 2 - 1; // 处理越界情况 if (mediaA &gt; m - 1) // 数组A越界 mediaA = m - 1; if (mediaB &gt; n - 1) // 数组B越界 mediaB = n - 1; // 比较 if (arrA[mediaA] &lt; arrB[mediaB]) //排除[leftA..mediaA] &#123; // *先更新k！ k = k - (mediaA - leftA + 1); // 更新k=k-排除的数字 leftA = mediaA + 1; // 数组A左边界变化 &#125; else //排除[leftB..mediaB] &#123; k = k - (mediaB - leftB + 1); // 更新k=k-排除的数字 leftB = mediaB + 1; &#125; &#125; &#125; NC30: 最小正数 题目描述 加上条件：加上这个缺失的最小整数后（不包括0），它是一个连续数组。 解法思路 如果不考虑时间&amp;空间复杂度，利用双层循环： 一次遍历记录数组最小元素min，和最大元素max ：如果min&gt;1 ，返回min-1 【外层循环】对于每个整数元素 $j\\in[min,max]$ ，【内层循环】遍历整个数组Nums 判断是否存在：不存在则返回j ； 都存在则返回max+1 显然对于【内层循环】，可以利用哈希表：快速判断数组元素是否存在 ，的特性来查找。牺牲空间换时间： 遍历数组，将数组元素Nums[i], 作为哈希dic地址值(key) , 可在O(1)时间判断数组元素是否存在 同时上述遍历可以记录数组最小元素min，和最大元素max：如果min&gt;1 ，返回min-1 依次遍历整数 $j\\in[min,max]$，判断是否存在dic.get(j)，不存在则返回j ； 都存在则返回max+1 时间复杂度降为O(n) , 但是空间复杂度也是 O(n) ，因为引入额外的哈希空间。为此我们使用“ 原地哈希 ” , 借助已知的数组Nums构造哈希表，优化空间。 首先分析最小正数范围：对于一个长度为N的整数数组Nums，如果出现元素Nums[i]&lt;1 或者 Nums[i]&gt;N 的数，那么缺少的整数$j\\in[1,N]$ ; 如果都出现，则$j=N+1$。所以$j\\in[1,N+1]$ 。因为数组一共只有N个数，如果出现不合法的数，则出现的1到N之间的数的个数一定小于N，故一定有没有出现的数。 因此我们可以换种方式，用来在遍历正数$j\\in[1,N]$ 快速判断是$j$否存在：遍历数组，如果存在元素$Nums[i]\\in[1,N]$ , 则标记$Nums[Nums[i]-1]$ 取负数。 代码实现 代码不是自己写的，因为觉得没多大意思这题，大多是数学问题。明白怎么分析过来就行。 1234567891011121314151617181920212223public int firstMissingPositive(int[] nums)&#123; int n = nums.length; for (int i = 0; i &lt; n; ++i) &#123; if (nums[i] &lt;= 0) nums[i] = n + 1; &#125; for (int i = 0; i &lt; n; ++i) &#123; int num = Math.abs(nums[i]); if (num &lt;= n) &#123; nums[num - 1] = -Math.abs(nums[num - 1]); &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; if (nums[i] &gt; 0) return i + 1; &#125; return n + 1; &#125; 【看】NC119:最小k个数 题目描述 解法思路 把 堆排序 背下就没问题了，可参考前面堆排序代码理解。 时间复杂度：O(nlongk) 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] arr, int k) &#123; // 套路题：对于找第k个小/打数，一般是堆排序最优 int len = arr.length; ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); // k需小于数组长度 if(k&gt;len|| k&lt;=0) return array ; // 1.构建初始堆 for(int i= len/2; i&gt;=0; i--) // 对每一个节点视作根节点，调整子树符合最小堆 MinHeapfily(arr,i,len); // 2.排序 for(int i=0; i&lt;k ; i++) &#123; array.add(arr[0]); swap(arr,0,len-1); len--; MinHeapfily(arr,0,len); &#125; return array; &#125; // 设置参数要有数组长度，因为排序时交换堆顶和堆尾元素，相当删除堆顶元素 // 对应数组长度-1 public void MinHeapfily(int[] arr, int root , int len) &#123; // 左右孩子 int left = root*2+1; int right = root*2+2; if(left&gt;=len) return; int min = root; min = arr[left]&lt; arr[min]? left : min; min = right&lt;len &amp;&amp; arr[right]&lt; arr[min]? right : min; // 如果发生交换要往下调整 if(min!=root) &#123; swap(arr,min,root); MinHeapfily(arr,min,len); &#125; &#125; public void swap(int[] arr, int i,int j) &#123; int temp ; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; NC88: 第K大 题目描述 解法思路 思路主要参考快排，最后判断时结合二分：根据K大小决定去哪个子序列搜寻Kth。 代码细节参考下*。 代码实现 注意题目是寻找第K大，第K大对应的元素在 排序后的数组下标 是 arr[n-k] 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public int findKth(int[] arr, int n, int K) &#123; // 快排结合二分: // 如果一轮k==partition，return arr[k] // 如果k&gt;partition, 则在右侧搜索 // 如果k&lt;partition, 则在左侧搜索 int Kth = quickSort(arr,0,n-1,n-K); return Kth; &#125; // 快排思想 // 1.设定一个基准pivot=arr[right],分割标记partition=left // partition 表示最终基准插入的位置，初始==left表示默认所有元素&gt;pivot // 2.遍历数组，如果数组元素arr[i]&lt;pivot,交换arr[partition]和arr[i] // 且partition+1，将arr[i]交换到partition左边。保证基准左侧元素&lt;基准 // 3.递归重复上述操作 public int quickSort(int[] arr,int left, int right,int K) &#123; // *这里实际不会执行，因为题目保证Kth一定存在 // 所有return的一定是递归返回后的元素 if(left&gt;right) return 0; int pivot = arr[right]; int partition = left; // 保证partition左侧数字都小于基准 // *从i=left，而不是i=0 for(int i=left; i&lt;right; i++) &#123; if(arr[i]&lt;pivot) &#123; swap(arr, i, partition); partition++; &#125; &#125; // 基准插入 swap(arr,partition,right); // 排序+二分 // 递归返回搜索递归子树的结果 if(K==partition) return arr[partition]; else if(K&lt;partition) return quickSort(arr,left,partition-1,K); else return quickSort(arr,partition+1,right,K); &#125; // 数组交换元素 public void swap(int[] arr, int i,int j) &#123; int temp ; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; NC105: 二分查找第一个 题目描述 解题思路 就是二分查找套路，但是查找到target时要保证第一次出现，即左侧没有重复的元素。 代码实现 123456789101112131415161718192021222324252627public int search (int[] arr, int target) &#123; int left = 0,right = arr.length-1; int mid ; while (left&lt;=right) //*&lt;= 而不是&lt; &#123; mid = (left+right)/2; if(target == arr[mid]) &#123; // *可能左侧还存在相同target，保证第一次出现 while(mid&gt;0 &amp;&amp; arr[mid-1]==target) mid--; return mid; // 如果数组存在待查找元素，按照逻辑一定会是mid &#125; else if(target &lt; arr[mid]) &#123; right = mid-1; &#125; else // value &gt; arr[mid] &#123; left = mid+1; &#125; &#125; return -1; &#125; NC91: 最长递增子序列 题目描述 解法思路 从暴力解法→动态规划→再优化。 【一、暴力遍历】 从头遍历所有的递增序列： 对于每个元素arr[i],q=i,ArrayList.add(arr[i]) 往后遍历，如果arr[j]&gt;arr[i],则q=j，ArrayList.add(arr[j]) 如果arr[j]&lt;arr[i] 且 j!=arr.length-1,替换递增序列为arr[j],q=[j] 循环1,2，并记录每个ArrayList的最大长度，直至全部遍历完 遍历所有ArrayList，找到长度最长&amp;字典最小的ArrayList返回 时间复杂度为O(n^2)，空间复杂度也为O(n^2)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public int[] LIS (int[] arr) &#123; int q=-1; int maxLen=-1; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrays = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for(int i=0; i&lt;arr.length-1;i++) &#123; q=i; // 当前递增序列末尾 ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); array.add(arr[q]); for(int j=i+1; j&lt;arr.length;j++) &#123; if(arr[j]&gt;arr[q]) &#123; q=j;array.add(arr[q]); &#125; if(j!=arr.length-1&amp;&amp;arr[j]&lt;arr[q]) // 替换末尾元素 &#123; array.remove(array.size()-1); array.add(arr[j]); q=j; &#125; &#125; // 记录最大长度 int len = array.size(); if(len &gt; maxLen) maxLen = len; // 记录以i为首的递增子序列 arrays.add(array); &#125; // 找到符合要求的最长递增子序列 int LIS_idx=0; int minSum ; for(int i=0; i&lt;arrays.size();i++) &#123; minSum = Sum(arrays.get(0)); if(arrays.get(i).size()==maxLen) // 符合最大长度 &#123; if(Sum(arrays.get(i))&lt;minSum) &#123; minSum=Sum(arrays.get(i)); LIS_idx=i; &#125; &#125; &#125; // 返回满足要求的最长递增序列 return arrays.get(LIS_idx).stream().mapToInt(k-&gt;k).toArray(); &#125; 【二、动态规划】 参考解析：leetcode-300，求最长子序列长度 ，但本题还需要返回递增子序列。 对状态方程不理解，可以看看 解析的slides，如何保证 $ dp[i]$ 是最大递增序列长度。 欲求子序列 $nums[0,1..,i]$ 中 $ dp[i]$ ，且已知道$j&lt;i,nums[0,1..,j]$ 各个子序列的$ dp[j]$ 遍历每个子序列，$nums[j]$ 是子序列的末尾元素 如果$nums[i]&gt;nums[j]$，则可构成新的递增子序列， $nums[0,1..,j,i]$，此时最大子序列长度+1 ：$dp[i]=dp[j]+1$ 。但要保证$dp[i]$最大（每个子序列$dp[j]$值不同，更新$dp[i]$ 未必有先前大 ）：$dp[i]=max(dp[i],dp[j]+1]$ 如果$nums[i]&lt;nums[j]$ , 跳过不用更新$dp[i]$ 对于本题还应该设置二维数组，保存所有递增子序列，所以：时间复杂度为O(n^2)，空间复杂度也为O(n^2)。 12345678910111213141516171819202122public int LIS(int[] nums) &#123; if(nums.length == 0) return 0; // 1.状态定义 int[] dp = new int[nums.length]; int res = 0; // 2.初始状态 Arrays.fill(dp, 1); for(int i = 0; i &lt; nums.length; i++) &#123; for(int j = 0; j &lt; i; j++) &#123; // 3.动态方程 if(nums[j] &lt; nums[i]) dp[i] = Math.max(dp[i], dp[j] + 1); &#125; res = Math.max(res, dp[i]); &#125; // 返回值 return res;&#125; 【三、再优化】 算了。 代码实现 1 NC32: 求平方根 题目描述 解法思路 一、二分法，但是不知道为什么会超时？ 写出二分法模板，修改些边界条件： 找到所需平方根：如果一个数$mid$ 是$x$ 平方根，那一定满足$mid^2&lt;x&lt;(mid+1)^2$ 修改左右边界，注意更新左右边界时可能会导致: ${right}^2&lt;x$ 或者 ${left}^2&gt;x$ ， 需要进行额外判断 :bookmark_tabs: 注意明白1. 什么情况可以确定当前mid是平方根。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142public int sqrt (int x) &#123; // *x/2可以节省时间 return binarySearchX(x,1,x/2); &#125;public int binarySearchX(int x, int left,int right) &#123; if(x&lt;2) return x; int mid ; while (left&lt;=right) &#123; mid = (right+left)/2; /* // [超时！！]这个判断条件会导致超时 if(right-left&lt;=1) // 此时一定是 left*left&lt;x&lt;right*right return left; */ if(x/mid==mid) // 等价于mid*mid&lt;x&lt;(mid+1)*(mid+1) &#123; return mid; &#125; // *防止mid*mid超出int最大表示 if(x/mid &lt; mid) &#123; right = mid-1; // *可能会出现right更新后right*right&lt;x // 说明(mid-1)*(mid-1) &lt; x &lt; mid*mid if(right &lt; x/right) return mid-1; &#125; if(x/mid &gt; mid) &#123; left = mid+1; // *可能会出现left*left&gt;x if(left &gt; x/left) return mid; &#125; &#125; return -1; &#125; NC37: 合并区间 题目描述 解法思路 难点在于： 排序完成后，可以分析出所有可能合并情况 能想到合并区间时不借助额外空间，只进行删除、替换元素，改变指针指向 思路如下： 12345671.冒泡排序：按区间左元素2.遍历区间判断：是否合并区间 前序列i=[a,b], 序列i+1=[c,d]，其中c&gt;=a, i). 如果c&gt;b,则不合并 ii). 如果c&lt;b,则可以合并序列[a,b]+[c,d]=[a,d] iii).如果d&lt;b,则可以合并序列[a,b]+[c,d]=[a,b]3.遍历返回结果 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public ArrayList&lt;Interval&gt; merge(ArrayList&lt;Interval&gt; intervals) &#123; if(intervals.size()&lt;=1) return intervals; // 1.冒泡排序 int len = intervals.size(); for(int i=0; i&lt;len-1;i++) // 外轮=n-1 for (int j=0; j&lt; len-i-1; j++ ) // 内轮=余下乱序数-1 &#123; if (intervals.get(j).start&gt;intervals.get(j+1).start) &#123; swapInterval(intervals,j,j+1); &#125; &#125; // 2.合并区间 // *只保留符合要求的区间，不借助额外的空间 int q=0; while (q&lt;intervals.size()-1) &#123; Interval i1 = intervals.get(q); Interval i2 = intervals.get(q+1); if(i2.start&lt;=i1.end) &#123; if(i2.end&lt;=i1.end) // 情况ii,[a,b]+[c,d]=[a,b]，删除[c,d] intervals.remove(q+1); else // 情况i,[a,b]+[c,d]=[a,d],替换[c,d]==[a,d]，删除[a,b] &#123; // 替换 intervals.get(q+1).start= i1.start; // 删除 intervals.remove(q); &#125; &#125; else // 情况i,不合并 q++; &#125; // 3.返回 return intervals; &#125; public void swapInterval(ArrayList&lt;Interval&gt; intervals,int i1,int i2) &#123; // *交换类类型指向不行？交换它们的数值 int s1 = intervals.get(i1).start; int e1 = intervals.get(i1).end; intervals.get(i1).start = intervals.get(i2).start; intervals.get(i1).end = intervals.get(i2).end; intervals.get(i2).start = s1; intervals.get(i2).end = e1; &#125; NC41: 无重复子串 题目描述 解法思路 代码实现 1 1.3 字符串NC1: 大数相加 题目描述 解法思路 两个不等长度字符串，先补0化为长度相同【字符数组】 e.g. : s=’123’ , t = ‘4’ ==&gt; s=’123’ , t = ‘004’ :notebook: 直接低位相加 从低位相加，计算 12345// 循环相加 int a = cs[len]-&#x27;0&#x27; + ct[len]-&#x27;0&#x27; + carry;res.append(a%10); // (易错)*a%10 是低位；a/10 是高位// 更新进位carry = a/10; 返回结果 要最后判断是否有进位 【反思：为什么debug这么久？】 对String类型转换不熟悉：char[] , int [] , String等等互转？又如，char和int之间如何互转？ 123// *char转换为int自动转换× ,但转换的是ASCII码！char c = &#x27;5&#x27;int a = &#x27;5&#x27; - &#x27;0&#x27;; // 减去&#x27;0&#x27;的ASCII码，刚好是int类型5 对StringBuffer 不熟悉：在本题还需要一个结果字符串数组res来保存最后结果，res会不断被更新。如果使用char[] 会很麻烦（最后转换还是出错乱码了），在java应该优先考虑StringBuffer！ 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041public String solve (String s, String t) &#123; int i = s.length(), j = t.length(); int m = Math.max(i,j); // 1.先化为标准字符串 char[] cs = new char[m]; char[] ct = new char[m]; // *遇到先减去值再计算的，最好用--m，而非m-- while(--m&gt;=0) &#123; cs[m] = --i&gt;=0? s.charAt(i):&#x27;0&#x27;; ct[m] = --j&gt;=0? t.charAt(j):&#x27;0&#x27;; &#125; // 2.低位相加 int len = cs.length; /* 1.不知道为什么用char[] 数组保存结果，最后转换string乱码？ char[] res = new char[len+1]; 2.下面StringBuffer直接insert会出错？改用append。 res.insert(len+1,String.valueOf(a%10)); */ StringBuffer res = new StringBuffer(); int carry = 0; while(--len&gt;=0) &#123; // *char转换为int自动转换× ,但转换的是ASCII码！ // 得要减去-‘0’ int a = cs[len]-&#x27;0&#x27; + ct[len]-&#x27;0&#x27; + carry; // (易错)*a%10 是低位；a/10 是高位 res.append(a%10); // 更新进位 carry = a/10; &#125; // 3.返回最后结果 if(carry != 0) // 最后依然有进位 res.append(carry); return res.reverse().toString(); &#125; NC127: 最长公共子串 题目描述 解法思路 代码实现 1234567891011121314151617181920public int longestCommonSubsequence(String text1, String text2) &#123; int m = text1.length(), n = text2.length(); //dp[i][j] 表示 text1[0,i] 和 text1[0,j]最长 int[][] dp = new int[m + 1][n + 1]; // 边界，i或j=0，字符串为空，dp[0][j]=dp[i][0]=0 for (int i = 1; i &lt;= m; i++) &#123; char c1 = text1.charAt(i - 1); for (int j = 1; j &lt;= n; j++) &#123; char c2 = text2.charAt(j - 1); // 动态方程 if (c1 == c2) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[m][n];&#125; NC41: 最长不重复 题目描述 解法思路 采用经典滑动窗口来解决，滑动窗口里的数字都是不重复的： 时间复杂度：O(N)，其中 N 是字符串的长度。 设置初始指针left=0,right=0 指向数组第1个数字；curLen=1,maxLen=1 分别记录当前滑动窗口的长度，和当前最大的不重复子串长度； 设置循环，right 向右移动+1，此时指向arr[rigth] ,设置循环遍历滑动窗口[left,right-1] ，是否发生重复； :warning: 循环遍历，已经用HashMap进行了优化。 如果不发生重复，则此时窗口长度curLen+1 ，并更新最大窗口长度maxLen = Math.max(curLen,maxLen); 用HashMap不能在此时更新最大窗口长度，而应该在最后。详见代码注释 如果发生重复，此时左指针指向重复数之后，更新窗口长度curLen = right-left+1; 直至right指针到达数组末尾，返回最大窗口长度。 【思维难点】 陷入使用动态规划，而不知道如何下手； 判断发生重复，对HashMap不熟悉，最后还是用了循环 HashMap不允许键值重复，如果发生重复会用后面的值覆盖 可以利用这个特性每次right 向右移动都用HashMap记录键值对&lt;arr[right],right&gt; ，保证重复的key，数组序列号一定是后面的 然后在判断是否发生重复时，判断是否在HashMap中，但是可能出现发生重复，但不在当前滑动窗口中，所以还要判断下重复元素的value是否&gt;left 代码实现 1234567891011121314151617181920212223242526272829public int maxLength (int[] arr) &#123; int left=0,right=0; int maxLen=1,curLen=1; // *注意初始条件curLen HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); while(++right&lt;arr.length) // 右指针每次循环向右移动 &#123; map.put(arr[right-1],right-1); // 判断当前右指针是否和前面序列发生重复 // 根据是否重复做出判断 if(! map.containsKey(arr[right])) &#123; curLen++; &#125; else // 发生重复 &#123; // 改变left指针指向到重复数字之后 // 但要保证一定是在当前滑动窗口内[left,right-1] left = Math.max(left, map.get(arr[right])+1); curLen = right-left+1; &#125; // *易错，此时最大值更新一定要在最后判断 // 而不是放在if语句内 // 因为用HashMap判断会导致，出现重复但 // 实际并不在滑动窗口内，不会执行下面语句 maxLen = Math.max(curLen,maxLen); &#125; return maxLen; &#125; NC52: 括号序列 题目描述 解法思路 思路很清晰： 设置一个栈，遍历字符串s ； 如果当前栈不为空，且栈顶元素和s.charAt(i) 括号匹配则将栈顶元素出栈； 否则将s.charAt(i)压入栈； 当循环结束后，如果括号都匹配，此时栈应该为空，返回true ；否则返回false ； 代码实现 12345678910111213141516171819202122232425262728public boolean isValid (String s) &#123; // Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); // 如果匹配就出栈，否则入栈 for(int i=0 ; i&lt;s.length();i++) &#123; if(!stack.isEmpty() &amp;&amp; isMatch(stack.peek(),s.charAt(i))) // 此时匹配则出栈 stack.pop(); else stack.push(s.charAt(i)); &#125; // 如果都匹配最后的栈应该是空的 if(stack.isEmpty()) return true; else return false; &#125; public boolean isMatch(char c1,char c2) &#123; if(c1==&#x27;(&#x27; &amp;&amp; c2==&#x27;)&#x27;) return true; if(c1==&#x27;[&#x27; &amp;&amp; c2==&#x27;]&#x27;) return true; if(c1==&#x27;&#123;&#x27; &amp;&amp; c2==&#x27;&#125;&#x27;) return true; return false; &#125; NC103: 反转字符串 题目描述 解法思路 思路： 首尾设置双指针，交换首尾元素即可 【编码难点】 String类型不能修改，应该转换为char[] 在原地交换 String 和 char[] 互转不熟悉 代码实现 1234567891011121314public String solve (String str) &#123; // 思路：双指针+交换 // *string类型不能修改，所以先转换为能修改的char数组 char[] cstr = str.toCharArray(); // 循环遍历 for(int i=0,j=cstr.length-1; i&lt;j; i++,j--) &#123; char tmp = cstr[i]; cstr[i] = cstr[j]; cstr[j] = tmp; &#125; return new String(cstr); &#125; NC41: 字符串排列组合 题目描述 解法思路 代码实现 NC17: 最长回文子串 题目描述 解法思路 代码实现 1 NC49: 最长括号子串 题目描述 解法思路 代码实现 NC41: 最长不重复 题目描述 解法思路 代码实现 NC41: 最长不重复 题目描述 解法思路 代码实现 NC41: 最长不重复 题目描述 解法思路 代码实现 字符串第一个不重复的数字先一个int[26]统计26个字母出现次数，然后返回次数为1的。 12345678910111213public int firstUniqChar(String s) &#123; int[] arr = new int[26]; int n = s.length(); for (int i = 0; i &lt; n; i++) &#123; arr[s.charAt(i)-&#x27;a&#x27;]++ ; &#125; for (int i = 0; i &lt; n; i++) &#123; if (arr[s.charAt(i)-&#x27;a&#x27;] == 1) &#123; return i; &#125; &#125; return -1; &#125; 十进制转二进制123456789101112131415161718192021class Solution &#123; public String printBin(double num) &#123; StringBuilder builder = new StringBuilder(&quot;0.&quot;); for (int i = 0; i &lt; 33; i++) &#123; num *= 2; if (num &gt;= 1) &#123; // 取整数部分 builder.append(&quot;1&quot;); // 取完后减1取小数部分 num -= 1; &#125; else &#123; builder.append(0); &#125; if (num == 0) &#123; return builder.toString(); &#125; &#125; return &quot;ERROR&quot;; &#125;&#125; 微信抢红包算法1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void main(String[] args) &#123; double sum = 0; ArrayList&lt;Double&gt; res = WXRedPackageAlgorithm(10,3); for(double money:res) &#123; sum += money; System.out.print(money +&quot; &quot;); &#125; System.out.println(); System.out.println(sum); &#125;private static ArrayList&lt;Double&gt;WXRedPackageAlgorithm(double restMoney,int restNum)&#123; ArrayList&lt;Double&gt; res = new ArrayList&lt;&gt;(restNum); Random random=new Random(); while(restNum&gt;1) &#123; //最大的红包为：两倍的平均红包大小 double max=(restMoney/restNum) * 2; //产生[0,1)之间的随机数 double r=random.nextDouble(); //抢到的红包区间[0,max) double money = r * max; if(money&lt;0.01) money = 0.01; else money= Math.floor(money*100)/100; res.add(money); restNum--; restMoney -= money; &#125; //最后一个红包为剩余余额 res.add(Math.floor(restMoney*100)/100 ); return res;&#125; 1.4 链表和栈NC78: 反转链表 题目描述 解法思路 假设存在链表 1→2→3→∅，我们想要把它改成∅←1←2←3。 核心难点： 设置三个指针初始化问题，p,q,q_next,记录前一个节点，当前节点，下一个节点; 为了操作统一，前一个节点应该指向null 更新节点问题，放在循环开头还是末尾 代码实现见下。 代码实现 12345678910111213141516171819202122public ListNode ReverseList(ListNode head) &#123; if(head==null) return head; // *p,q,q_next,分别记录前一个节点，当前节点，下一个节点 // *为了操作统一，p最开始指向null！！ ListNode p = null; ListNode q = head,q_next=head; while(q!=null) &#123; // *下一个节点更新放在循环开始，而非末尾 // 避免q.next==null时，q.next.next赋值给q.next出错 q_next = q.next; // 改变q指向 q.next=p; // *更新前一个节点，当前更新p,q节点只能在循环末尾 // 因为后面代码q.next=p，要操作p，q，在此之前不能更新p，q p=q; q=q_next; &#125; return p; &#125; NC93: LRU 题目描述 解法思路 首先探讨使用何种数据结构： 哈希表：通过key定位要操作的节点，O(1)复杂度 双向链表：实现节点插入、删除、获取值等操作，O(1)复杂度 所以最终的数据结构形式如下： 1HashMap&lt;int key,DLinkedNode&gt; map ; DLinkedNode 是双链表节点： 1234567891011class DLinkedNode&#123; // 键值对 int key,value ; // 前后指针 DLinkedNode pre,next; public DLinkedNode() &#123; pre = next = null; &#125; public DLinkedNode(int k, int v) &#123; key = k; value = v;&#125;&#125; 具体实现双链表DLinkedList的trick： 统一操作： 双向链表使用伪头部和伪尾部来统一插入/删除操作 链表实现，应该包含基本删除、插入操作（具体代码略）。 123456789101112131415161718class DLinkedList&#123; // 伪头部，尾部 DLinkedNode head; DLinkedNode tail; // *初始化,∅⇌head⇌tail⇌∅ public DLinkedList() &#123; //*这里head和tail是存在的，要实例化，而非指针 &#125; /*定义一些链表基本操作*/ // 双链表：插入 public void insert(DLinkedNode preNode,DLinkedNode insertNode)&#123;&#125; // 双链表：删除 public void del(DLinkedNode delNode)&#123;&#125; 为满足题目条件： 满足条件1： 使用HashMap 保存链表&lt;key,对应节点&gt;，用于快速定位；双向链表用于满足操作,O(1)复杂度 满足条件2：链表越靠近头部则表示越频繁使用，每次set操作，将节点插入到头部；get操作，将节点移动到头部 满足条件3： 每次set操作，检查当前容量超过缓存大小，删除尾节点 封装数据结构 HashMap&lt;int key,DLinkedNode&gt; ，和对应方法 set、get 来实现满足上述条件的基本LRU缓存结构。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145import java.util.*;public class LRU_Solution&#123; /** * lru design * @param operators int整型二维数组 the ops * @param k int整型 the k * @return int整型一维数组 */ public int[] LRU (int[][] operators, int k) &#123; ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(); Cache cache = new Cache(k); // 进行操作 // eg:[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3 for(int i=0; i&lt;operators.length;i++) &#123; int opt = operators[i][0]; int key = operators[i][1] ,value; if(opt==1) &#123; value = operators[i][2]; cache.set(key,value); &#125; else arr.add(cache.get(key)); &#125; // 返回最后结果 int[] res = new int[arr.size()]; for(int i=0; i&lt;arr.size();i++) res[i]=arr.get(i); return res; &#125;&#125;class Cache&#123; int capacity,len; // hashmap 保存所有节点，快速索引 HashMap&lt;Integer,DLinkedNode&gt; map ; // 链表 DLinkedList dll; public Cache(int capacity) &#123; this.capacity = capacity; this.len = 0; map = new HashMap&lt;Integer,DLinkedNode&gt;(); dll = new DLinkedList(); &#125; public void set(int key,int value) &#123; // 新建节点 DLinkedNode node = new DLinkedNode(key,value); if(len&gt;=capacity) &#123; // 长度超过容量，移除最不常使用的记录（尾部） // *hashmap操作：map移除对应key // *移除的是被删除的尾节点的key！！ map.remove(dll.tail.pre.key); // 双链表操作:移除 dll.del(dll.tail.pre); // *长度-1 len--; &#125; // 链表头部插入新节点变为最常用 dll.insert(dll.head, node); // *HashMap也要更新 map.put(key,node); // cacha长度+1 len++; &#125; public int get(int key) &#123; DLinkedNode node = map.get(key); if(node==null) return -1; else &#123; // 删除节点 dll.del(node); // 移动到头部变为最常用 dll.insert(dll.head,node); // 返回值 return node.value; &#125; &#125;&#125;class DLinkedList&#123; // 伪头部，尾部 DLinkedNode head,tail; // *初始化,∅⇌head⇌tail⇌∅ public DLinkedList() &#123; //*这里head和tail是存在的，要实例化，而非指针 head = new DLinkedNode(); tail = new DLinkedNode(); head.next = tail; tail.pre = head; &#125; /*定义一些链表基本操作*/ // 双链表：插入 public void insert(DLinkedNode preNode,DLinkedNode insertNode) &#123; insertNode.next = preNode.next; preNode.next.pre = insertNode; insertNode.pre = preNode; preNode.next = insertNode; &#125; // 双链表：删除 public void del(DLinkedNode delNode) &#123; delNode.next.pre=delNode.pre; delNode.pre.next = delNode.next; delNode.pre = delNode.next =null; &#125;&#125;class DLinkedNode&#123; // 键值对 int key,value ; // 前后指针 DLinkedNode pre,next;; public DLinkedNode() &#123; pre = next = null; &#125; public DLinkedNode(int k, int v) &#123; key = k; value = v; &#125;&#125; NC4: 是否有环 题目描述 解法思路 略，看代码 代码实现 1234567891011121314151617181920212223public boolean hasCycle(ListNode head) &#123; // 思路1：快慢指针（trick），最优解，O(1)复杂度 // 思路2：hashmap存下所有节点，然后遍历节点就去判断是否在hashmap中 // *要先判断head==null的情况 if(head==null) return false; ListNode step1 = head; ListNode step2 = head; while(step2!= null &amp;&amp; step2.next != null) &#123; // 好像不会出现step1==null的情况？ // 因为【如果有环】会在快指针走到终点前就相遇 step1 = step1.next; // 循环终止条件从这里得到 step2 = step2.next.next; // *不能在前面判断，因为初始step1==step2 if(step1==step2) return true; &#125; return false; &#125; NC33:合并链表 题目描述 解法思路 整体思路如下： 定义一个辅助头结点head ，介绍判断第一个节点的麻烦；同时定义合并后链表工作指针tail ，用于在合并链表后方便插入节点 :warning: 定义辅助头节点是要声明空间进行初始化的，和指针不同！指针保存的都是节点的地址！ :notebook_with_decorative_cover: 【不用纠结】也可以不定义辅助头节点，但是要先得到第一个节点。 定义指针h1，h2 ，分别指向链表L1,L2 第一个节点：比较指针h1，h2 指向的值大小，将tail 指向更小的节点，同时更新tail 和相应工作指针h1，h2 123456789101112if(h1.val &lt; h2.val)&#123; // 更新head指向断开的节点h1 tail.next = h1; // 更新tail指向合并链表最后插入的节点 tail = h1; // 更新工作指针h1为h1.next h1 = h1.next; // 不用更新*之前h1指向null，因为此时是tail，后面会指向&#125;else // 同上 直至h1或h2 指向null，即其中一个链表被遍历完成，将tail 直接指向剩余未遍历完成的链表的第一个节点，即此时不为null工作指针h1或h2 :warning: 和合并数组不同：此时 不用循环插入剩余的节点！ 指向第一个节点即可！ 最后返回辅助头节点的head.next 代码实现 不用在开头判断L1，L2 是否为null，后面的逻辑会处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public ListNode mergeTwoLists (ListNode l1, ListNode l2) &#123; // 思路 // 定义工作节点h1,h2 ListNode h1 = l1, h2 = l2; // 定义一个辅助头节点，减少处理第一个节点麻烦 // 辅助头节点肯定是要【初始化】 ListNode head = new ListNode(0); // *定义一个尾指针（为了保留head返回） // *这个尾指针只对指向的节点操作 ListNode tail = head; while(h1!=null &amp;&amp; h2!=null) &#123; // 判断大小 if(h1.val &lt; h2.val) &#123; // 更新head指向断开的节点h1 tail.next = h1; // 更新tail指向合并链表最后插入的节点 tail = h1; // 更新工作指针h1为h1.next h1 = h1.next; // 不用更新*之前h1指向null &#125; else &#123; // 更新head指向断开的节点h2 tail.next = h2; // 更新tail指向合并链表最后插入的节点 tail = h2; // 更新工作指针h2 h2 = h2.next; &#125; &#125; // tail直接指向剩下链表 // *不用循环一个个插入到tail后面！ if(h1 != null) tail.next = h1; if(h2 != null) tail.next = h2; return head.next; &#125; NC76: 栈实现队列 题目描述 思路解析 首先分析队列和栈的两个操作的不同： push pop 队列 尾部插入 头部弹出 栈 尾部插入 尾部弹出 显然对于队列的push 操作可以直接用栈push 操作来实现 ； 那队列的pop操作如何用栈来实现呢？ 假定实现队列push 用*stack1来*push 实现，尾部插入 那么需要用栈pop 实现队列 pop ，必须要先将已有”队列“stack1中数据逆置：即将stack1中所有数据都pop，在push到stack2中 stack2 再使用栈pop 出的就是”队列“stack1 中的头部，即模拟了队列的pop 对于后续的队列pop ， 都可以直接pop 出stack2中的元素；如果stack2为空，就将stack1 中元素逆置到stack2中，再pop 总结核心操作： 队列push，直接用栈push实现，都是“尾部插入” 队列pop，可以先将队列中数据逆置（两个栈交换数据），再用栈pop“头部”弹出 代码实现 12345678910111213141516171819202122public class Solution&#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if(stack2.empty()) &#123; // 将stack1全部转移到stack2中 while(!stack1.empty()) stack2.push(stack1.pop()); &#125; // 然后再pop出来 return stack2.pop(); &#125;&#125; NC50: 链表k翻转 题目描述 解析思路 【套翻转模板】先思考如何翻转指定首尾的链表： 修改1：考虑翻转循环边界条件 修改2：首尾节点指向 遍历链表，设置指针pre,f,e 分别指向要反转链表段 的：首节点前一个节点，首节点，尾节点 12// 初始段首尾节点都指向首节点ListNode pre = null, f = head, f = head; 尾指针e移动并计数，如果满足count % k == 0 说明找到尾节点，则反转指定首尾的链表，然后更新指针 12pre = f; // 指向下一个反转段的首节点的前一个节点 f = e = f.next; // 首尾初始指向首节点 直到移动e，寻找下一个段的尾节点发现不存在，e==null退出循环 :warning: 在k反转的链表，第一组的翻转的链表尾节点e，是整个翻转链表的首节点！ 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 思路// 遍历链表找到每次反转的first,end 进行翻转// *特别的：第一次翻转end是返回的头结点public ListNode reverseKGroup (ListNode head, int k) &#123; ListNode pre = null; ListNode f = head; ListNode e = head; int count = 1; // 记录翻转后链表第一个节点 ListNode firstNode = e; while (e!=null) &#123; // 找到翻转段的尾节点e if(count % k == 0 ) &#123; // 第一次翻转 if(count == k) firstNode = e; // 翻转 reverse(pre,f,e); // *更新:注意此时段尾部是f // *尾部e移动了，要count+1 pre = f; f = e = f.next; &#125; else e = e.next; // 无论哪种情况都要count++，所以移到这儿 count++; &#125; return firstNode; &#125; // 指定链表段翻转 // 先将[first-end] 节点反转，再修改反转后的首尾节点指向 public ListNode reverse(ListNode pre,ListNode first,ListNode end) &#123; ListNode p = null; ListNode q = first; ListNode q_next = null; // 临时节点存储q.next while (p !=end ) // 修改：到达末尾终止条件 &#123; q_next = q.next; q.next = p; p = q; q = q_next; &#125; // 修改：处理反转后的首尾节点指向 first.next = q; // 【边界情况】：从头节点开始反转 if(pre!=null) pre.next=end; // *返回翻转后链表首节点end return end; &#125; NC3: 环入口节点 题目描述 解法思路 数学题，题解见下： 代码实现 套上NC4：是否有环的模板，补上后续操作判断即可。 1234567891011121314151617181920212223242526272829303132public ListNode detectCycle(ListNode head) &#123; // *要先判断head==null的情况 if(head==null) return null; ListNode step1 = head; ListNode step2 = head; while(step2!= null &amp;&amp; step2.next != null) &#123; // 好像不会出现step1==null的情况？ // 因为【如果有环】会在快指针走到终点前就相遇 step1 = step1.next; // 循环终止条件从这里得到 step2 = step2.next.next; // *在后面判断是否相遇 if(step1==step2) &#123; // 相遇,慢指针回到起点，快指针依旧在相遇点 step1 = head; // 快指针从相遇点，和慢指针从起始点，【一步一步走】再相遇 // *相遇的地方就是环入口 while(step1!=step2) &#123; step1 = step1.next; step2 = step2.next; &#125; return step1; &#125; &#125; return null; &#125; NC53: 删倒k个节点 题目描述 解法思路 简单，略。关键在于掌握两个【基础模板】： 单链表删除节点 删除倒数第n个节点模板 代码实现 1234567891011121314151617181920212223242526272829303132333435363738public ListNode removeNthFromEnd (ListNode head, int n) &#123; // 边界条件判断 // 1.设置p,q指针分别指向首节点，pre指向p前一个节点 // 2.q先走k步，然后p,q一起走，直至q指向null // 3.删除p // 3.返回head ListNode p = head, q = head; ListNode p_pre = null; int step = n; while(q!=null) &#123; if(step&gt;0) &#123; q = q.next; step--; &#125; else &#123; p_pre = p; p = p.next; q = q.next; &#125; &#125; // 删除p // *当要删除的节点恰为头结点 if(p==head) head = head.next; else p_pre.next = p.next; return head; &#125; NC66: 公共节点 题目描述 解法思路 【方法一】首先容易想到暴力遍历： 使用双循环，对链表1每个节点在链表2进行判断是否存在相同节点 上述时间复杂度为O(N^2) , , 空间复杂度O(1)。 【方法二】对于判断链表2是否存在某个节点，可以用hashmap 存储所有链表2的节点，这样判断时间复杂度降为O(1) 先hashmap存储所有链表2节点，遍历链表1每个节点，是否在链表2存在，如果存在则返回公共节点 时间复杂度为O(N) , 空间复杂度O(N)。如何继续优化空间复杂度？ 【方法三】观察公共链表特点：尾部相同，但前缀不同且长度也不同。 如果知道前缀长度和相差的长度k， 那么可：让更长的链表工作指针p先走k步，然后和更短的链表工作指针q一起走，判断当前指向的节点相同就可以返回公共节点。 那么如何知道相差的长度k ？或者说如何让p,q距离公共节点长度一致？ 双指针法。 链表指针初始p=head1,q=head2 都同时往后走，当更短的指针（假设为p）指向null 时，更长链表工作指针q剩余k 步未走； 更新p 指向长链表头head2 ，p和q继续往下走； 当q指向null时，p距离head2也走了k步 ，q指向head1；这样两个链表的工作指针距离公共节点的距离变保持一致了 p,q同时往下走，判断遇到的第一个相同节点便是公共节点了 代码实现 实现【方法三】。 123456789101112public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2)&#123; if (pHead1 == null || pHead2 == null) return null; ListNode p1 = pHead1; ListNode p2 = pHead2; while (p1 != p2) &#123; p1 = p1 == null ? pHead2 : p1.next; p2 = p2 == null ? pHead1 : p2.next; &#125; return p1;&#125; NC40: 链表大数相加 题目描述 解法思路 思路类似NC1 大数相加，但是不进行补0标准化： 先反转链表，从链表头部（低位开始相加），利用加法公式： 12// 计算表达式int res = a+b+carry; 但是由于不进行标准化，长度不一致，在判断指针移动时要判断是否到末尾 12p1 = p1==null? null : p1.next;p2 = p2==null? null : p2.next; 同样的，获取计算表达式$a,b$ 值，也要进行判断指针位置： 12a = p1==null? 0 : p1.val;b = p2==null? 0 : p2.val; 每次计算结果插入头结点后面 ，返回最后的结果链表头结点 【难点分析】 记好反转链表 模板 记好基本链表操作 ,如，插入 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public ListNode addInList (ListNode head1, ListNode head2) &#123; // 1.从低位开始相加，先高位补0转换为标准化【char[]数组】 // 2.但由于长度不知，所以用【ArrayList】,并且不标准化（长度不一致） // 3.但是会引入额外的空间O(n)，不如直接反转链表，从低位开始相加 head1 = reverse(head1); head2 = reverse(head2); // 工作指针 ListNode p1 = head1, p2 = head2; // 结果链表 LinkList resList = new LinkList(); int a,b,carry=0; while(p1!=null || p2 != null) &#123; a = p1==null? 0 : p1.val; b = p2==null? 0 : p2.val; // 计算表达式 int res = a+b+carry; // 插入新节点到头结点 resList.insert2head(new ListNode(res%10)); // 更新进位 carry = res/10; // 工作指针后移 p1 = p1==null? null : p1.next; p2 = p2==null? null : p2.next; &#125; // 如果最后还有进位 if(carry != 0) resList.insert2head(new ListNode(carry)); return resList.head.next; &#125; // 反转【指定】链表,链表没有头结点 public ListNode reverse(ListNode head) &#123; if(head == null) return null; ListNode pre = null; ListNode p = head , q=null; while(p!=null) &#123; q = p.next; p.next = pre; pre = p; p = q; &#125; return pre; &#125; &#125;class LinkList&#123; ListNode head; public LinkList() &#123; head = new ListNode(0); &#125; // 插入到【当前】头部 public void insert2head(ListNode newNode) &#123; ListNode tmp = head.next; head.next = newNode; newNode.next = tmp; &#125;&#125; NC51:合并k个排序链表 题目描述 解法思路 关键在于套模板： 【模板】合并两个排序链表 易错点： 合并头结点不记得，使用工作指针始终指向合并链表末尾（键代码） 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041public ListNode mergeKLists(ArrayList&lt;ListNode&gt; lists) &#123; if(lists.size()==0) return null; ListNode res = lists.get(0); for(int i=1 ; i&lt;lists.size(); i++) res = mergeList(res,lists.get(i)); return res; &#125; public ListNode mergeList(ListNode head1,ListNode head2) &#123; ListNode head = new ListNode(0); // *保留head，使用工作指针h ListNode h = head; while(head1 != null &amp;&amp; head2 != null) &#123; if(head1.val&lt;head2.val) &#123; h.next = head1; head1 = head1.next; &#125; else &#123; h.next = head2; head2 = head2.next; &#125; // *指向合并链表末尾 h = h.next; &#125; // 剩下未排序完成的 if(head1 != null) h.next = head1; else h.next = head2; return head.next; &#125; NC70:链表排序 题目描述 解法思路 模板：冒泡排序 :warning: 冒泡会超时，但是堆排序不会（后面更新代码） 12345678910111213141516171819202122232425public ListNode sortInList (ListNode head) &#123; if(head==null) return null; ListNode p , q ; ListNode sort_first = null; for(p=head; p.next!=null; p = p.next ) // n-1轮 &#123; for(q=head; q.next!=sort_first; q = q.next)// n-已排序-1轮 &#123; if(q.val&gt;q.next.val) swap(q,q.next); &#125; // 已排序的值放在链表之后，记录已排序的第一个节点 sort_first = q; &#125; return head; &#125; public void swap(ListNode node1, ListNode node2) &#123; int tmp = node1.val; node1.val = node2.val; node2.val = tmp; &#125; 模板：归并排序 最佳选择：保证了最好和最坏时间复杂度都是nlogn，而且它在数组排序中广受诟病的【合并链表时】**空间复杂度在链表排序中也从O(n)降到了O(1)**。 【快慢指针】找到链表中点，然后拆分成两个子链表 :warning: 快慢指针注意判断条件！！ 【模板，合并有序链表】如果两个链表：长度==1、null、有序，则合并两个链表 【模板，归并】归并排序递归 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public ListNode sortInList (ListNode head) &#123; // *考虑会出现其中一个子链表为空的情况 // 为空或者长度=1，都可以返回进行合并 if(head==null || head.next==null) return head; // 拆分成两个子链表 ListNode h1 = head; ListNode mid = getMid(head); ListNode h2 = mid.next; mid.next = null; // 递归排序 // *子链表排序后，其原先头结点不一定再是合并后头结点 // *故要更新 h1 = sortInList(h1); h2 = sortInList(h2); // 两个子链表都满足已排序，或者长度==1,null,则开始合并 return mergeList(h1,h2); &#125; // 快慢指针获取中点 public ListNode getMid (ListNode head) &#123; ListNode slow = head, fast = head; // *如果判断条件是fast!=null 或者 fast.next !=null // *等价于计算得到的中点向上取整，当链表长度=2时，1→2→null // *mid=2，由此切割的子链表是：1→2→null &amp; null ，不符合要求 while(fast.next != null &amp;&amp; fast.next.next !=null) &#123; slow = slow.next; fast = fast.next.next; &#125; return slow; &#125; // 合并两个链表 public ListNode mergeList(ListNode head1,ListNode head2) &#123; ListNode head = new ListNode(0); // *保留head，使用工作指针h ListNode h = head; while(head1 != null &amp;&amp; head2 != null) &#123; if(head1.val&lt;head2.val) &#123; h.next = head1; head1 = head1.next; &#125; else &#123; h.next = head2; head2 = head2.next; &#125; // *指向合并链表末尾 h = h.next; &#125; // 剩下未排序完成的 if(head1 != null) h.next = head1; else h.next = head2; return head.next; &#125; NC96:是否回文 题目描述 解法思路 思路一： 1.栈/或者数组，保存节点，逆向比较 时空复杂度都是O(N) 思路二：√（采用） 1. 快慢指针找到链表中点，翻转后面【一半】节点，比较 2. 时间复杂度O(N),空间复杂度O(1) 【难点：快慢指针】 1while(fast.next != null &amp;&amp; fast.next.next != null) 上面这种判断条件： 快慢指针返回的是左中位数：不知道奇/偶数个节点返回具体哪个位置 如果是偶数，找到是左中位数，如：1→2→3→4→∅（节点2） 如果是奇数，就是中间节点，如：1→2→3→∅（节点2） 边界条件： 要保证head不为null 12if(head==null) return null; 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public boolean isPail (ListNode head) &#123; if(head==null) return false; if(head.next==null) // 一个数就是回文 return true; // （倾向左的）快慢指针找到中间节点 // 如果是偶数，找到是左中位数，如：1→2→3→4→∅（节点2） // 如果是奇数，就是中间节点，如：1→2→3→∅（节点2） ListNode mid = getMid(head); // 翻转节点 ListNode head2 = reverse(mid.next); // 比较是否是回文 while(head2!=null) &#123; if(head.val != head2.val) return false; head2 = head2.next; head = head.next; &#125; return true; &#125; public ListNode getMid(ListNode head) &#123; // 前面逻辑保证head不为null ListNode fast = head; ListNode slow = head; while(fast.next != null &amp;&amp; fast.next.next != null) &#123; fast = fast.next.next; slow = slow.next; &#125; return slow; &#125; public ListNode reverse(ListNode head) &#123; if(head.next==null) // 前面逻辑保证head不会为null return head; // 链表翻转模板 ListNode pre = null; ListNode p = head, q = null; while(p!=null) &#123; q = p.next; p.next = pre; pre = p; p = q; &#125; return pre; &#125; NC21:区间翻转 题目描述 解法思路 对于指定链表，如：1→2→3→4→5→∅， 设置工作指针移动记录，翻转区间首节点r1 ，和尾节点r2 根据翻转链表模板，reverse(r1,r2) 易将指定区间翻转为，∅←2←3←4， 现在要修改【模板：翻转链表】首尾节点指向： 尾节点r1 （2）指向（5）：由于reverse(r1,r2)模板可以获得翻转链表尾节点应该连接的下一个节点q（5），所以可以在reverse函数中直接修改尾节点指向 1r1.next = q; 首节点r2（4）【被】（1）指向：由于节点（1）在翻转中没法获取，所以还要在1. 中记录r1 前一个节点 pre 。 因此reverse(pre,r1,r2)增加一个参数pre 进行传递 12if(pre != null) // 从头节点开始翻转，前面无节点指向 pre.next = tail; // 首节点【被】指向 返回：如果是从头结点开始翻转，返回翻转区间尾节点；否则返回头结点。 【难点分析】 指定区间翻转不熟悉：修改首尾节点的操作应该 在reverse函数里，而不是在外面设置一堆节点记录边界，最后翻转后再来函数外修改。定义变量多，且易错 套路不熟悉 ：指定区间翻转的，通通（1）先获取 翻转边界首尾节点 （2）再套翻转模板翻转（3）在翻转函数函数里面，修改翻转后首尾节点指向（4）考虑边界情况：从链表头部开始翻转 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public ListNode reverseBetween (ListNode head, int m, int n) &#123; int count = 1; // 找到要反转的区间首尾节点r1,r2 // 和首节点前一个节点r1_pre ListNode p = head, pre = null; ListNode r1=p, r1_pre=pre; ListNode r2; while(count&lt;=n) &#123; if(count == m) &#123; r1_pre = pre; r1 = p; &#125; pre = p; p = p.next; count++; &#125; r2 = pre; // 反转指定区间链表 // *传参r1_pre方便在反转时【函数内部】修改链表首尾指向 ListNode reverse_head = reverse(r1_pre,r1,r2); if(r1_pre == null) // 此时从头部就开始反转 return reverse_head; else return head; &#125; // *翻转指定区间链表，除了首尾最好传参首节点前一个节点 public ListNode reverse(ListNode pre_head ,ListNode head,ListNode tail) &#123; // 链表翻转模板 ListNode pre = null; ListNode p = head, q = null; while(pre!=tail) &#123; q = p.next; p.next = pre; pre = p; p = q; &#125; // *处理首尾节点 head.next = q; // 尾节点指向 if(pre_head != null) pre_head.next = tail; // 首节点【被】指向 return tail; &#125; NC24:删除重复元素 题目描述 解法思路 本题在【（模板）基础：删除重复元素】上进一步要求，第一次出现的重复数也要删除。因此我们可以在模板上进行修改： 1234567891011121314151617181920public ListNode deleteDuplicates (ListNode head) &#123; if(head == null || head.next == null) return head; ListNode pre = head, p = head.next; while(p!=null) &#123; if(pre.val == p.val) &#123; pre.next = p.next; p = p.next; &#125; else &#123; pre = p; p = p.next; &#125; &#125; return head; &#125; 设置一个指针指向pre前一个节点，和一个标记是否删除当前pre 123ListNode pre = head, p = head.next; ListNode tmp = null; // 记录pre前的节点boolean isDel = false; 【增加】每次pre即将移动时（pre.val != p.val）,即不存在和pre相同的数了，判断当前pre是否要删除。 如果存在过和pre相同的数那么就要删除它（isDel==true）。 :warning: 只有pre没有被删除时，才能更新tmp指向pre ；如果被删除，不修改指向（此时会将 tmp.next = p，此时tmp指向p ，而后面又更新了pre指向p ，那么tmp就是pre前一个节点） 123456789101112131415161718else // pre.val != p.val &#123; if(isDel) // pre移动到下一位时判断是否删除pre &#123; if(pre==head) // *删除头结点 head = head.next; else tmp.next = p; &#125; else // *pre没删，tmp才更新 &#123; tmp = pre; &#125; isDel = false; pre = p; p = p.next; &#125; 【增加】在pre.val == p.val 时我们也要增加判断一种边界情况：链表所有数值都相同，删除到最后一个节点时，如此时链表1→∅ 。但此时p 指向∅ ，不会进入下一次循环去判断删除1 ，因此要进行边界判断。 1234567891011121314if(pre.val == p.val) &#123; pre.next = p.next; // 删除p p = p.next; // 存在和pre相同的元素，等删除完重复的，pre也要删 isDel = true; if(p==null) // *边界：p已指向null，但pre要删除 &#123; if(tmp!=null) // *边界：链表全相同，删除最后一个数 tmp.next = p; else return null; &#125; &#125; 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445public ListNode deleteDuplicates (ListNode head) &#123; if(head == null || head.next == null) return head; ListNode pre = head, p = head.next; ListNode tmp = null; // 记录pre前的节点 boolean isDel = false; while(p!=null) &#123; if(pre.val == p.val) &#123; pre.next = p.next; // 删除p p = p.next; // 存在和pre相同的元素，等删除完重复的，pre也要删 isDel = true; if(p==null) // *边界：p已指向null，但pre要删除 &#123; if(tmp!=null) // *边界：链表全相同，删除最后一个数 tmp.next = p; else return null; &#125; &#125; else // pre.val == p.val &#123; if(isDel) // pre移动到下一位时判断是否删除pre &#123; if(pre==head) // 删除头结点 head = head.next; else tmp.next = p; &#125; else // *pre没删，tmp才更新 &#123; tmp = pre; &#125; isDel = false; pre = p; p = p.next; &#125; &#125; return head; &#125; NC133:奇偶重排 题目描述 解法思路 思路一（超时） 设置指针初始Pre=head,q=head.next.next 使用临时节点tmp记录下一个待操作的节点tmp=q.next.next, 然后： 删除节点q 插入到Pre后面 更新pre=q，q=tmp 直至tmp==null 思路二（通过） 将奇数、偶数节点分别链接起来，然后将偶数节点串联在其后，具体： 设置两个伪节点evenHead 、oddHead ，和两个工作指针：even = evenHead, odd = evenHead; ，以及一个工作指针p=head 将odd.next 指向p（奇数节点）， even.next 指向p.next（偶数节点），并更新 odd = p, even = p.next; 如果下一个奇数节点存在，即p.next != null || p.next.next != null , 那么更新 p = p.next.next ，重复2、3，否则退出循环 最后将偶数链表放在奇数链表之后即可 【难点分析】 想不到分别串联一个奇偶链表，再连接 设置伪节点有利于统一插入操作，也可以保证链表至少有两个节点 12if(head==null || head.next==null || head.next.next==null) return head; 然后让第一、二个节点分别为奇数、偶数链表的头结点。 代码实现 1234567891011121314151617181920212223242526272829public ListNode oddEvenList (ListNode head) &#123; if(head == null) return null; ListNode evenHead = new ListNode(0); ListNode oddHead = new ListNode(0); ListNode even = evenHead, odd = evenHead; ListNode p = head; while(true) &#123; odd = odd.next = p; even = even.next = p.next; if(p.next == null || p.next.next == null) break; else p = p.next.next; &#125; // 将偶数链表链接在奇链表之后 // *even此时指向可能为null if(even != null) even.next = null; odd.next = evenHead.next; return head; &#125; 1.5 动态规划NC7: 买股票 题目描述 解法思路 因为是买股票，所以买股票一定要在卖股票之前 ，包含时间序列，如果一次遍历找到最大最小求差是行不通的： 123456789int min=0, max=0;for(int i=0; i&lt;prices.length; i++)&#123; if(prices[i]&lt;prices[min]) min = i; else if(prices[i]&gt;prices[max]) max = i; &#125;return prices[max]-prices[min]; 例如对于case：num[2,4,1] , 输出的min=1，max=4，而实际买入的利润是-3。 为此我们可以采用动态规划的思想，遍历数组prices，寻找前[0,i]中最大利润： 记录前[0,i-1] 中股票最低值信息minValue，和最大利润maxProfit 第[i]个元素减去前[0,i-1] 中minValue，如果&gt;maxProfit, 更新maxProfit。从而获取前[0,i]中最大利润 代码实现 1234567891011121314public int maxProfit (int[] prices) &#123; // 寻找数组中最大、最小数字 int minValue=prices[0], maxProfit=0,currentProfit=0; for(int i=1; i&lt;prices.length; i++) &#123; // 更新最大利润 currentProfit = prices[i]-minValue; maxProfit = currentProfit &gt; maxProfit? currentProfit:maxProfit; // 更新数组前[0,i-1]中最小值 minValue = prices[i]&lt;minValue?prices[i]:minValue; &#125; return maxProfit; &#125; NC59：不同路径 题目描述 解法分析 参考动态规划例题：不同路径II（二维dp） NC19: 最大累积和 题目描述 解法思路 很明显是到动态规划题目，按照动态规划方式进行解题可以大幅度降低思维负担 ： 参考解析：从暴力破解到动态规划 , 讲解得很清晰。 状态定义：dp[i]表示以nums[i] 结尾的所有子数组（不是所有可能子数组）求和最大值。 例如dp[3] 表示$sum(0,3)、sum(1,3)、sum(2,3)、sum(3,3)$ 中最大值。所有dp[i] 包含所有可能的子数组，它们的最大值累和最大值。 转移方程： 转移方程见下 以dp[3]为例，找寻$sum(0,3)、sum(1,3)、sum(2,3)、sum(3,3)$中最大值 ，由于都包含了$nums[3]$, **等价于找寻$0,sum(0,2)、sum(1,2)、sum(2,2)$中最大值再+$nums[3]$**。而$0,sum(0,2)、sum(1,2)、sum(2,2)$ 最大值 == dp[2] 。 但特别的，单个元素也可以作为一个子数组，当dp[2]&lt;0 , dp[3]==nums[3] 更大。 初始状态： $j-1&gt;0$, 循环从1开始，那么dp[0]=nums[0]需已知 返回值：返回数组dp中最大值 优化空间为O(1) ? 由于给定数组nums 在下次循环i+1时，前i个元素都不会使用，可以作为使用空间。 代码实现 123456789101112131415161718192021public int maxsumofSubarray (int[] arr) &#123; // 初始状态 // 使用arr空间作为dp空间，初始化不用进行 // 状态方程 for(int i=1; i&lt;arr.length; i++) &#123; if(arr[i-1]&gt;0) arr[i]=arr[i-1]+arr[i]; &#125; // 找寻到最大值 int max = arr[0]; for(int i=1; i&lt;arr.length; i++) &#123; if(arr[i]&gt;max) max = arr[i]; &#125; return max; &#125; 1.6 树二、数据库2.1 入门开胃菜 经典面试题型 最晚入职员工 题目 代码 12345/* 使用limit关键字 从第0条记录 向后读取1个， */select * from employees order by hire_date desc LIMIT 1 offset 0; 入职倒数第三 题目 代码 123select * from employees order by hire_date desc LIMIT 1 offset 2; 查看部门薪水 题目 请你查找各个部门领导薪水详情以及其对应部门编号dept_no，输出结果以salaries.emp_no升序排序，并且请注意输出结果里面dept_no列是最后一列。 全部员工的薪水表salaries: 各个部门的领导表dept_manager: 代码 纯where连接两张表进行查询： 123456/*纯where连接两张表*/select s.* , d.dept_nofrom dept_manager d, salaries swhere d.emp_no = s.emp_no and d.to_date = &#x27;9999-01-01&#x27;order by s.emp_no ASC; /*默认升序ASC*/ 使用内连接进行查询： 内外连接很清晰的一篇文章 12345select s.* , d.dept_nofrom dept_manager as d inner join salaries as son d.emp_no = s.emp_no where d.to_date = &#x27;9999-01-01&#x27; /*保证没离职*/order by s.emp_no ASC; 查看员工信息 题目 请你查找所有已经分配部门的员工的last_name和first_name以及dept_no： 分别写出查询语句查询：【显示/不显示】未分配的部门的员工； 获取所有非manager的员工的emp_no 员工表，employees： 部门表，dept_emp： 代码 不包括未分配员工：使用内连接去二者交集即可。 123select e.last_name , e.first_name, d.dept_nofrom dept_emp as d inner join employees as eon e.emp_no = d.emp_no; 包括未分配的员工，使用外连接即可。使用左连接，以员工表为主表。 123select e.last_name , e.first_name, d.dept_nofrom employees as e left join dept_emp as d on e.emp_no = d.emp_no; 获取所有非manager的员工的emp_no 。 一、使用NOT IN 子句 123select emp_nofrom employeeswhere emp_no not in (select emp_no from dept_manager); 二、LEFT JOIN左连接+IS NULL 1234SELECT e.emp_noFROM employees AS e LEFT JOIN dept_manager AS dON e.emp_no=d.emp_noWHERE dept_no IS NULL; ​ 统计薪水涨幅 题目 请你查找薪水记录超过15次的员工号emp_no以及其对应的记录次数t。 薪水表，salaries： 题目隐含： 一条记录就算一次涨幅(严格意义上，从第二条记录算起才算一次涨幅) 任何一条记录都算一次涨幅(严格意义上，必须比上一条记录的工资高才算一次涨幅) 代码 MySQL GROUP BY 语句 GROUP BY 语句根据 一个或多个列 对结果集进行分组。在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。 统计结果要进行判断，必须使用having 而不是 where 1234select emp_no , count(emp_no) tfrom salaries group by emp_nohaving t&gt;15; /*必须用having*/ 薪水显示去重 题目 你找出所有员工具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示。 薪水表，salaries： 代码 一、可以用distinct函数 1234select distinct(salary)from salarieswhere to_date=&#x27;9999-01-01&#x27;order by salary desc; 二、使用group by （推荐，性能更高） 12345select salaryfrom salaries where to_date=&#x27;9999-01-01&#x27;group by salary /*分组一定要在where语句后面！*/order by salary desc; /*排序最后面*/ 2.2 经典题目题目描述 学生表：Student(SId,Sname,Sage,Ssex) 课程表：Course(CId,Cname,TId) 教师表：Teacher(TId,Tname) 成绩表：SC(SId,CId,score) 经典50题https://zhuanlan.zhihu.com/p/32137597 1. 查询” 01 “课程比” 02 “课程成绩高的学生的信息及课程分数 先分别得到只有01课程和02课程两张成绩子表：sc1 (SID,score1) , sc2 (SID,score2) 通过**自然连接**，构建一张01,02课程成绩在同一行的表，sc12(SID,score1,score2) ，并 sc1.score&gt;sc2.score 因为有学生不是01，02都选，导致出现score1或 score2 为null的情况？ 自然连接，0，只有该SID都有分数才会保留 内连接和交叉连接，才会保留所有结果（笛卡尔积） 外连接才会导致，某个分数score出现null，没匹配到SID但还是保留 再联合Student表，根据SID找到对应学生信息（只要SID，不要name等可以省略这步，下面就省略了这步） 1234Select * from (select SId ,score from sc where sc.CId=&#x27;01&#x27;)as sc1 , (select SId ,score from sc where sc.CId=&#x27;02&#x27;) as sc2where sc1.SId=sc2.SIdand sc1.score&gt;sc2.score 1.1 查询同时选了” 01 “课程和” 02 “课程的学生SID自然连接。 123select *from (select SId ,score from sc where sc.CId=&#x27;01&#x27;)as t1 , (select SId ,score from sc where sc.CId=&#x27;02&#x27;) as t2where t1.SId=t2.SId 1.2 查询选了” 01 “课程但可能不存在” 02 “课程的情况(不存在时显示为 null )1 1.3 查询选了” 01 “课程但没选” 02 “课程的情况1234select *from scwhere sc.SId not in (select SId from sc where sc.CId=&#x27;01&#x27;)and sc.CId=&#x27;02&#x27; 2. 查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩 先得到一张平均成绩表(SID,AvgScore) 再根据平均成绩表SID，找到Student 表中信息，这里联合两张表可以采用左外连接 123456789Select s.SID,s.Sname, From Student as s left join （ Select SC.SID , AVG(SC.score) as avgscore From SC Group by(SC.SID ) Having AVG(sc.score) &gt;= 60 # 集合函数时不能使用where ）as avgTable ON s.SID = avgTable.SID # 外连接用ON, 不是Where连接","categories":[],"tags":[]},{"title":"","slug":"test","date":"2021-11-24T09:34:48.534Z","updated":"2021-11-24T09:34:48.534Z","comments":true,"path":"2021/11/24/test/","link":"","permalink":"http://example.com/2021/11/24/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"test_my_site","slug":"test-my-site","date":"2021-11-24T09:03:08.000Z","updated":"2021-11-24T09:03:08.457Z","comments":true,"path":"2021/11/24/test-my-site/","link":"","permalink":"http://example.com/2021/11/24/test-my-site/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-11-24T09:00:02.998Z","updated":"2021-11-24T09:56:38.951Z","comments":true,"path":"2021/11/24/hello-world/","link":"","permalink":"http://example.com/2021/11/24/hello-world/","excerpt":"","text":"toc: ture Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}