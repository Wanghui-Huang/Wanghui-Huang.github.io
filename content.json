{"meta":{"title":"royhuang's blog","subtitle":"hello world","description":"tech & life","author":"Wanghui Huang","url":"https://hwh.zone","root":"/"},"pages":[{"title":"[404]","date":"2021-11-24T11:41:16.226Z","updated":"2021-11-24T11:41:16.226Z","comments":true,"path":"404.html","permalink":"https://hwh.zone/404.html","excerpt":"","text":""},{"title":"Hi there 👋","date":"2022-02-09T11:19:26.980Z","updated":"2022-02-09T11:19:26.980Z","comments":true,"path":"about/index.html","permalink":"https://hwh.zone/about/index.html","excerpt":"","text":"I am Wanghui Huang (royHuang) 🔭 I am studying for a master’s degree in Chongqing University and will graduate in July, 2022. What’s more, I will officially join Tencent at sometime. 📫 If you want know me more : https://hwh.zone, this is my personal blog. 💬 Ask me about deep learning(object tracking) , C++, Java and my projects on hwh199601@qq.com. ⚡ Fun fact: this is a less funny man. 💑 A little secret，royHuang ，my name is from my cherished girlfriend. ↓ Can't wait to talk to me ↓"},{"title":"Python 基础笔记","date":"2022-01-02T11:54:25.534Z","updated":"2021-12-03T03:41:02.895Z","comments":true,"path":"NO_post/Python基础学习.html","permalink":"https://hwh.zone/NO_post/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.html","excerpt":"","text":"第一章：函数基础 1.1 字符串 1.1.1 编码 字符串和比特 常见字符串和比特表示方法见下： 123456# 字符串表示的两种方法print(&#x27;i am string&#x27;); # i am stringprint(r&#x27;i am string&#x27;); # i am string# byte表示：前面加bprint(b&#x27;i am byte&#x27;); # b&#x27;i am byte&#x27; 注意到最后byte 字符串输出结果有些奇怪，不像字符串直接输出双引号的内容。 我们还可以将字符串 str 编码成 bytes： 方法 描述 encode(‘ascii’) 可将纯英文编码成 bytes，如果含中文编码会出错 encode(‘utf-8’) 可将含中文字符串编码成 bytes 123456# 字符串编码成bytestrTobyte = &#x27;hwh&#x27;.encode(&#x27;ascii&#x27;);print(strTobyte); # 输出：b&#x27;hwh&#x27;strTobyte = &#x27;黄旺辉&#x27;.encode(&#x27;utf-8&#x27;);print(strTobyte); # 输出：b&#x27;\\xe9\\xbb\\x84\\xe6\\x97\\xba\\xe8\\xbe\\x89&#x27; 当然我们也可以用*decode()*函数进行解码： 方法 描述 decode(‘uft-8’) 将bytes 变为 str 12a = b&#x27;\\xe9\\xbb\\x84\\xe6\\x97\\xba\\xe8\\xbe\\x89&#x27;.decode(&#x27;utf-8&#x27;);print(a); # 输出：黄旺辉 1.1.2 格式字符串 格式化字符串有两种方式：一种类C语言使用%占位符；一种利用 format 方法实现。 %占位符方式 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 还可指定长度、精度等： 指定长度：%2d —&gt; 表示整数占位2空格，不足补空格； %02d —&gt;同样表示正式占位2空格，但不足补0 指定精度：%.1f —&gt; 表示小数保留1为小数 以上为占位符方式，以下为举例： 12&gt;&gt;&gt; &#x27;%s 今年 %d 岁啦！&#x27;%(&#x27;黄旺辉&#x27;,23)&#x27;黄旺辉 今年 23 岁啦！&#x27; format() 格式化 在字符串方式format() 内部使用的占位符依次为：{0}、{1} … 12&gt;&gt;&gt; &#x27;&#123;0&#125; 今年 &#123;1&#125; 岁啦！&#x27;.format(&#x27;黄旺辉&#x27;,23)&#x27;黄旺辉 今年 23 岁啦！&#x27; 1.2 list &amp; tuple 1.2.1 列表：list list 类似我们此前接触的 C/C++/C# 数组，但是可以每个元素类型可以不同，比如： 1&gt;&gt;&gt; L = [&#x27;Apple&#x27;, 123, True]; 特别的当，当元素类型也为数组时就可以看做一个多维数组了： 1&gt;&gt;&gt; L = [[&#x27;C#&#x27;,C&#x27;,&#x27;C++&#x27;],[&#x27;JAVA&#x27;,&#x27;JAVASCRIPT&#x27;],[&#x27;PYTHON&#x27;,&#x27;PHP&#x27;]]; 此时获取 JAVASCRIPT ： 12&gt;&gt;&gt; L[1][-1]&#x27;JAVASCRIPT&#x27; 更多增删查改操作见下。 索引 索引从0开始，python 不但可以使用 自然数从正序 开始索引，还可以使用 负数从倒序 开始索引。 1234567891011&gt;&gt;&gt; classmates = [&#x27;hwh&#x27;,&#x27;lt&#x27;,&#x27;dxj&#x27;,&#x27;fs&#x27;]# 正序索引从0开始（正序第一个）&gt;&gt;&gt; classmates[0]&#x27;hwh&#x27;# 倒序索引从-1开始(倒序第一个)&gt;&gt;&gt; classmates[-1]&#x27;fs&#x27;&gt;&gt;&gt; classmates[-2]&#x27;dxj&#x27; ⚠️ 索引越界抛出IndexErro 错误！ 插入 给list 插入数据有两种方法： 方法 描述 append(data) 在list 表末尾 插入数据 insert(index,data) 在指定 位置 index 插入数据 1234567891011&gt;&gt;&gt; classmates = [&#x27;hwh&#x27;,&#x27;lt&#x27;,&#x27;dxj&#x27;,&#x27;fs&#x27;]# append()方法classmates.append(&#x27;lhy&#x27;)classmates[&#x27;hwh&#x27;, &#x27;lt&#x27;, &#x27;dxj&#x27;, &#x27;fs&#x27;, &#x27;lhy&#x27;]# insert()方法classmates.insert(0,&#x27;ljx&#x27;)classmates[&#x27;ljx&#x27;, &#x27;hwh&#x27;, &#x27;lt&#x27;, &#x27;dxj&#x27;, &#x27;fs&#x27;, &#x27;lhy&#x27;] 修改 要将元素A替换成别的元素B，直接赋值即可。 123&gt;&gt;&gt; classmates[-1] = &#x27;赖浩源&#x27;&gt;&gt;&gt; classmates[&#x27;ljx&#x27;, &#x27;hwh&#x27;, &#x27;lt&#x27;, &#x27;dxj&#x27;, &#x27;fs&#x27;, &#x27;赖浩源&#x27;] 删除 方法 描述 pop(index) 删除指定位置 index 元素，不带参数则删除末尾元素 ，返回值为被删除的元素 123456&gt;&gt;&gt; classmates.pop();&#x27;赖浩源&#x27;&gt;&gt;&gt; classmates.pop(0);&#x27;ljx&#x27;&gt;&gt;&gt; classmates[&#x27;hwh&#x27;, &#x27;lt&#x27;, &#x27;dxj&#x27;, &#x27;fs&#x27;] 1.2.2 不可变列表：tuple tuple 和 list 和相似，但是它里面元素不可以改变，可看做是一个常数列表 。它简单定义如下： 1234&gt;&gt;&gt; t = (); # 空列表&gt;&gt;&gt; t = (&#x27;Apple&#x27;, 123, True);&gt;&gt;&gt; t[-1];True 但是注意当只有一个元素时不能写做： 1&gt;&gt;&gt; t = (1); 这会和 python 数学公式中小括号产生歧义，此时定义的不是 tuple ，而是计算结果1这个数。为此我们需要加一个逗号消除歧义： 1&gt;&gt;&gt; t = (1,); 1.3 循环 1.3.1 for 循环 在其它语言循环遍历集合有两种方式： for、while 循环：根据元素下标遍历集合 foreach 循环：直接获取集合每个元素 python 只有：for、while 两种，但是python 中 for 循环其实更类似于其它语言foreach循环。 C++语言尝试遍历列表：L = ['hwh','lt','dxj','fs'] 。 遍历 0~length(L)-1 的下标索引来打印出数组 12for(int i = 0; i &lt; length(L); i++) print(L[i]); 利用 foreach 循环，获取列表每个元素打印数组 12foreach(int x in L) print(x); python 中遍历：L = ['hwh','lt','dxj','fs']。 根据 python for 循环基本类似 foreach 循环获取集合元素特性遍历 12for x in L: print(x); 巧妙达到用下标索引打印数组 在 python 中提供 rang(start,end) 函数，可生成 start~end-1 连续整数列表。从而根据下标索引打印数组： 12for i in range(0,len(L)): print(L[i]); 更多有关 range 函数 函数 描述 range(start,end) 生成指定从 start~end-1 连续整数列表 range(end) 生成指定从 0~end-1 连续整数列表 注意 range 生成的整数不包含最后一个指定参数整数。 尝试生成列表：[0,1,2,3] 。 12&gt;&gt;&gt; l = range(4);&gt;&gt;&gt; l = range(0,4); 1.3.2 while 循环 while 循环和以前接触相同同，不再赘述。 1.4 dict &amp; set 1.4.1 dict dict 即字典，在别的语言中又称为 map ，都是采用键值对(key-value)形式 ，查找速度极快。且有以下特点： dict 一个 key 只能对应一个 value ，重复对一个key 赋值会把前面值替换 简单增、删、查、改方式举例。 123456789101112131415161718192021&gt;&gt;&gt; dic = &#123;&#125;;# 增：给不存在键值赋值，即可增加一堆键值对&gt;&gt;&gt; dic[&#x27;shazi&#x27;] = &#x27;lt&#x27;;&gt;&gt;&gt; dic&#123;&#x27;shazi&#x27;: &#x27;lt&#x27;&#125;# 查：直接根据键值查找&gt;&gt;&gt; dic[&#x27;shazi&#x27;];&#x27;lt&#x27;# 改：给存在的键值赋新值，即可改&gt;&gt;&gt; dic[&#x27;shazi&#x27;] = &#x27;fs&#x27;;&gt;&gt;&gt; dic&#123;&#x27;shazi&#x27;: &#x27;fs&#x27;&#125;# 删：pop(key)方法即可删除&gt;&gt;&gt; dic.pop(&#x27;shazi&#x27;);&#x27;fs&#x27;&gt;&gt;&gt; dic&#123;&#125; 还可利用 *get(key,returnValue)*验证指定键值是否存在： 123# 判断键值是否存在：不存在指定返回-1（如果不指定返回None，但是在交互环境什么都不显示）&gt;&gt;&gt; dic.get(&#x27;shazi&#x27;,-1);-1 1.4.2 set set 和 dict 类似，是一组 key 集合 ，但不存储 value ，且： set 中 key 值不能重复 set 和 dict 都不是有序的 创建一个set ，需要 list 作为输入集合： 123&gt;&gt;&gt; s = set([1,2,3]);&gt;&gt;&gt; s&#123;1, 2, 3&#125; 简单 set 增、删、改、查如下。 1234567891011121314# 增：add方法，参数是字符串类型，带双引号&gt;&gt;&gt; s.add(&#x27;a&#x27;);&gt;&gt;&gt; s&#123;1, 2, 3, &#x27;a&#x27;&#125;# 删：remove方法，参数是字符串类型，带双引号&gt;&gt;&gt; s.remove(&#x27;a&#x27;)&gt;&gt;&gt; s&#123;1, 2, 3&#125;# 查：必须要先转换为list类型&gt;&gt;&gt; l = list(s);&gt;&gt;&gt; l[0];1 set 可以看做数学意义上无序、重复元素集合。因此还可以做交集、并集等操作。 123456&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2&#123;2, 3&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 4&#125; 1.5 函数 1.5.1 基本定义 下面展示了在 python 如何定义一个函数（注意冒号），且带默认参数。 123456# python 没有三目运算符def max(x,y = 5): if x &gt; y : return x; else: return y; 在上面除了必选参数、默认参数还有： 可变参数：定义为可变的参数的形参，接收的实参可以是多个（组成 tuple ） 关键字参数：定义为关键字的参数的形参，接收的实参可以是多个（组成 dict ） 命名关键字参数：通过分隔符 * 可限制关键字参数的名字 以上在下节1.5.2 会详细讲述，我们再来看一下 python 其它特性。 可变和不可变对象 什么是可变/不可变对象？ 简单来说：就是可变对象A充当函数实参 时，函数内部对形参 A进行修改，会同步改变A。 这是因为可变对象传递的是一个地址（引用传递），而不可变对象传递的是一份拷贝（值传递）！ 常见可变对象/不可变对象： 不可变对象：Number ,String , Tuple，bool 可变对象：List , Set , Dictionary 匿名函数 python 中匿名函数直接用 lambda 表达式表达，其语法格式为： lambda 参数列表 : 执行语句 执行语句只有一条，不用写 return ，返回值就是表达式结果。 筛选出所有奇数。 12&gt;&gt;&gt; L = list(filter(lambda n:n%2==1, range(1, 10)))[1, 3, 5, 7, 9] 1.5.2 返回值 return 返回多个值 在 python 函数中可以返回多个值，但实际它返回的是一个元组 tuple： 123def test(): return 1,2,3;print(test()); # (1, 2, 3) 这个时候利用解构赋值，可以接收函数返回值： 1x,y,z = test(); # x=1 y=2 z=3 返回函数 &amp; 闭包 参照：JavaScript 笔记 &amp; 阮一峰的闭包博客 。 🙂 什么是闭包？ 简单来说，就是一个函数，内部定义了一个函数并返回。 🙂 为什么要有闭包？ 读取函数内部变量 让变量值始终保存在内存中 下面开始详细介绍闭包两个作用。 读取函数变量值。 我们知道，根据作用域规则函数内部的变量、参数是无法被外部获取 的。 12345def test(a): b = 1;a; # 错误：无法读取b; # 错误：无法读取 但是，如果我在内部再定义一个子函数，返回变量、参数，最后再返回该子函数： 12345678def test(a): b = 1; def f(): return a,b; return f;f = test(0);a,b = f();print(a,b); # 输出：0 1 这样闭包便起到函数内、外部沟通的桥梁。 让变量始终保存在内存中。 1234567891011def test3(): x = 0; def f3(): nonlocal x; x += 1; return x ; # 直接 return x+=1 出错？ return f3;f3 = test3();print(f3()); # 输出：1print(f3()); # 输出：2print(f3()); # 输出：3 在内部子函数 f3() 对x进行修改，会屏蔽掉外部函数对 x 定义，这样内部函数 f3() 使用 x 会显示未定义。所以必须使用 nonlocal 关键字，让编译器知道这是前面已定义的 x。 为什么每次调用 f3() 输出的值都不一样？ 这是因为函数内部定义了子函数形成了闭包，函数的变量x都会保存在内存中，并没有消亡。 不要引用循环变量！ 子函数（返回函数）不要引用循环变量！这是因为返回函数不会立即执行，直到调用它才会执行。 123456789def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count() count() 函数尝试返回 i = 1,2,3 对应的不同函数。当我们尝试去执行它们： 123456&gt;&gt;&gt; f1()9&gt;&gt;&gt; f2()9&gt;&gt;&gt; f3()9 发现函数执行结果都是 9，这是因为返回的函数f1、f2、f3没有立即执行。而当执行它们是 i 都已经是9了。 1.5.3 函数参数 可变参数 试想如果一个函数接收参数不确定，比如计算用户输入的若干数字之和。当然我们可以用 列表接收多个参数： 1234567def sum(nums): sum = 0; for x in nums: sum += x; return sum;sum([1,2,3,4,5]); // 15 采用可变参数形式，来接收多个参数。 1234567def sum(nums): sum = 0; for x in nums: sum += x; return sum;sum(1,2,3,4,5); // 15 可见相比用列表接收参数，在调用时不用传递一个列表而是一个个传递参数即可，简洁明了。 如果定义了可变参数，又想传递一个列表呢？在调用时加上* 即可 。 12L = [1,2,3,4,5];print(sum(*L)); // 15 关键字参数 关键字参数类同可变参数，但它不同于可变参数接收多个参数组成 tuple 而是组成一个 dict 。 12345def person(name,age,**other): print(other);# 输出：&#123;&#x27;university&#x27;: &#x27;chongqingU&#x27;, &#x27;city&#x27;: &#x27;fuzhou&#x27;&#125;person(&#x27;hwh&#x27;, 20, university=&#x27;chongqingU&#x27;, city=&#x27;fuzhou&#x27;); 同样的它也解决 传递若干参数不用传递一个dict ，而是传递一个个 key:value 值就可以了 。 同前，如果已经定义了关键字参数，又想传递一个dict ，加上 ** 即可： 12dic = &#123;&#x27;university&#x27;: &#x27;chongqingU&#x27;, &#x27;city&#x27;: &#x27;fuzhou&#x27;&#125;;person(&#x27;hwh&#x27;, 20, **dic); ⚠️ other 获取的是 dic 一份拷贝，对 other 修改不会影响 dic 。 命名关键字参数 在上述关键字参数中，会将传递进来的若干 key:value 参数组成 dict 。但是，有时候我们希望传递的 key 为指定名字，且个数被限定 。 这个时，可以使用命名关键字，不同于关键字参数 **other ，命令关键字使用一个特殊分隔符 *： 1234def person(name,age,*,Uni,City): print(name,age,Uni,City);person(&#x27;hwh&#x27;,23,Uni = &#x27;chongQingU&#x27;,City = &#x27;fuzhou&#x27;); # hwh 23 chongQingU fuzhou 在以下情况，没有传递正确命名关键字参数会出错： 传递参数不带 key，只传 value 值 ，出错： 1person(&#x27;hwh&#x27;,23,&#x27;chongQingU&#x27;,&#x27;fuzhou&#x27;); # 出错 或者不是 key 值并不是限定的名字，出错： 1person(&#x27;hwh&#x27;,23,u=&#x27;chongQingU&#x27;,c=&#x27;fuzhou&#x27;); # 出错 或传递了多余参数，出错： 1person(&#x27;hwh&#x27;,23,Uni = &#x27;chongQingU&#x27;,City = &#x27;fuzhou&#x27;,height = 173); # 出错 关键字组合 必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是顺序： 必选参数 、 默认参数 、可变参数、命名关键字参数、关键字参数！ 1.6 基本类型转换 第二章：高级特性 2.1 切片 试想下有一数组和字符串，如何获取它们各自前三个元素？ 12L = [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;];S = &#x27;python.py&#x27;; 我们可以联想到 ：C# 中 substring() 进行 字符串 截取；JavaScript 中 slice() 方法，进行 数组、字符串 截取。 在 python 中提供了类似 JavaScript 中 slice() 方法 ，进行更加优雅的 列表（数组）、元组、字符串 截取。 12345678910111213# 1.截取数组# 第一个索引是0，还可以省略，L[:3]&gt;&gt;&gt; L[0:3] [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]# 2.截取字符串&gt;&gt;&gt; S[:3]&#x27;pyt&#x27;# 3.截取元组&gt;&gt;&gt; t = (1,2,3,4,5);&gt;&gt;&gt; t[:3](1, 2, 3) 第二个索引值一定要比第二个索引大！特别注意负数情况 第一个索引是0，可以省略；最后一个索引是列表长度，也可以省略 所以，下面获取的是整个列表。 12&gt;&gt;&gt; L[:]&gt;&gt;&gt; [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;] 2.1.1 切片更多技巧 索引使用负数 注意，第二个索引一定要比第一个索引大，换言之只能从数组头到尾方向切片！ 123&gt;&gt;&gt; L = [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;];&gt;&gt;&gt; L[-6:-2];[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;] 指定间隔取数 L[s:e:j] : 截取数组指定 [s:e] 范围， 然后每隔 j 个数取出数，返回一个新数组。 取出数组下标为奇数元素。 123&gt;&gt;&gt; L = [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;];&gt;&gt;&gt; L[1::2][&#x27;B&#x27;, &#x27;D&#x27;] 2.2 列表生成式 什么是列表生成式？简而言之，就是快速创建列表的表达式，类似 lambada 表达式生成函数。 生成式格式：[变量运算表达式 变量来源表达式 限制变量表达式 ] 最简单的利用 range(s,e) 来生成一个列表： 12&gt;&gt;&gt; list(range(1, 11))[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 利用列表生成式可写作： 12&gt;&gt;&gt; [x for x in range(1,11)][1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 变形1：在 1 - 11 中删选出为偶数的数字，且开平方作为为列表元素。 我们需要改变元素运算表达式开方，和增加限制变量表达式判断是否为偶数。 12&gt;&gt;&gt; [x*x for x in range(1,11) if x%2 == 0]; # 注意，判断条件是 == 号[4, 16, 36, 64, 100] 变形2：将字典 &#123;1:'one',2:'two',3:'three'&#125; 变为列表 ['1=one','3=three'] 。 利用 for 循环迭代字典获取 key、value，在元素运算表达式中拼接即可。 12&gt;&gt;&gt; [str(k)+&#x27;=&#x27;+v for k,v in &#123;1:&#x27;one&#x27;,2:&#x27;two&#x27;,3:&#x27;three&#x27;&#125;.items() if k!=2 ];[&#x27;1=one&#x27;, &#x27;3=three&#x27;] 前面都是 if 判断条件都限制遍历的集合，下例可以限制生成的值。 遍历['hwh','lt','fs'] ,如果是 'hwh'就对应生成列表对应元素数字1，否则生成0。 12&gt;&gt;&gt; [1 if name==&#x27;hwh&#x27; else 0 for name in [&#x27;hwh&#x27;,&#x27;lt&#x27;,&#x27;fs&#x27;] ][1 0 0] 2.3 生成器 在前面我们利用 列表生成式 可以快速生成列表。但是： 如果生成列表很大，如百万个元素，但后面很多元素当前不会用到，浪费空间存储又必须要保存怎么办呢？ 这个时候就可以利用生成器，只保存列表元素的推算算法，需要用到时可以不断推算出来。 创建一个 generator 和 列表生成式很像，只不过把 [] 变为了 () : 123&gt;&gt;&gt; g = (x * x for x in range(6))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 直接打印 g 是不会显示生成的列表，因为保存的是推算算法，我们可以利用 next() 函数 或者 直接 for 循环迭代： 1234567891011121314&gt;&gt;&gt; g = (x for x in range(6))&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)2# 注意：因为已经前面已经next获取到2了，下面是从3开始打印&gt;&gt;&gt; for x in g:... print(x);... 345 2.3.1 yield 返回：进一步理解生成器 观测下面有多个 yield 返回值函数： 1234567&gt;&gt;&gt; def g():... yield 1;... yiled 2;... yield 3;&gt;&gt;&gt; o = g();&gt;&gt;&gt; o&lt;generator object g at 0x000001B9C07059A8&gt; 可以看到，函数返回 的是一个 generator 对象，类似的可以通过 *next()*函数 或者 for 迭代 获取多个返回值。 12345678&gt;&gt;&gt; next(o)1&gt;&gt;&gt; next(o)2&gt;&gt;&gt; next(o)3&gt;&gt;&gt; next(o)Traceback (most recent call last): 在这里，我们基本就可以明白，生成器 (表达式) 本质是生成了一个有多个 yield 返回值的 generator 对象。 我们还可以将 斐波拉契数列 利用生成器依次打印出来。 常规定义的 fib() 函数如下： 1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print b # 打印生成的数字 a, b = b, a + b n = n + 1 return &#x27;done&#x27; 我们只需要将本该打印数字 print b ，变为返回 yeild b 即可。 1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b # 打印生成的数字 a, b = b, a + b n = n + 1 return &#x27;done&#x27; 然后利用函数返回 generator 对象打印出来： 123456789f = fib(5);next(f);1next(f);1next(f);2next(f);3 注意：generator 对象拿不到 return 语句的返回值。 2.4 for 迭代 什么是迭代？ 在其它语言也有类似的迭代器概念，换言之就是如何一种方式遍历各种类型数据结构集合。 python 中 for 循环是一种比其它语言 for 更高度抽象的概念，可直接作用于 for 循环迭代的数据类型有： 集合类型：如 list、tuple、dict、set、str等 generator 类型：包括 生成器 、带 yield 的 generator 函数 2.4.1 集合类型迭代 迭代 list &amp; tuple 12345&gt;&gt;&gt; for x in [1,2,3]:... print(x) &gt;&gt;&gt; for x in (1,2,3):... print(x) 试着分析下面列表迭代，元素类型为元组。 123456&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:... print(x, y)...1 12 43 9 这里同时引用了2个变量：因为列表的元素也是集合类型（元组），可以类似解析构值，将元组值赋值给 x、y。然后每一次循环都赋值一次，遍历所有元组打印。 ⚠️ 注意下面 key-value 字典不可以直接解析构值，要先利用 items() 方法变为元组，详情见下。 迭代 dict 12345678910111213# 迭代字典keyfor k in &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;: print(k); # 输出：a c b# 迭代字典value# 利用values()方法，将字典类型返回为values组成列表for k in &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;.values(): print(k); # 输出：1 2 3# 同时迭代字典 key，value# 利用items()方法for k,v in &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;.items(): print(k,v); # 输出：a 1 b 2 c 3 迭代字符串 12&gt;&gt;&gt; for c in &#x27;ABC&#x27;:... print(c) # 输出：A B C 2.4.2 生成器类型迭代 生成器类型迭代直接 for… in 循环打印即可，可参见 2.3 生成器 一节。 2.4.3 关于迭代更多 判断迭代对象 判断迭代对象利用 instance() 方法判断： 1234567&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance(&#x27;abc&#x27;, Iterable) # str是否可迭代True&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代True&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代False 把列表像字典一样迭代 Python 内置的enumerate(list)函数可以把一个 list 变成 索引-元素对 。 123456&gt;&gt;&gt; for i, value in enumerate([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]):... print(i, value) ...0 A1 B2 C 第三章：函数式编程 3.1 高阶函数 所谓高阶函数即指：函数也是变量，从而可作为另一个函数（高阶函数）参数。 在 JavaScript 中已经详细讲解了 map/reduce 、filter、sorted 等高阶函数 ，但是调用方法、返回值不同： 调用方法：JavaScript 中是数组对象方法， [1,2,3].map(func) ; python 中需要传递两个参数 map(func,[1,2,3]) 。 返回值：JavaScript 中直接返回一个列表；python 中返回一个是一个iterator 惰性序列 ，可以用 next() 逐个打印 、 for 循环 迭代打印 、 list() 方法直接转为列表 。 以下为简单示例。 3.1.1 高级函数示例 映射： map map 高级函数可以原列表元素x根据传递的函数 func 依依映射成新值 func(x)。 123456&gt;&gt;&gt; def f(x):... return x * x...&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81 r 是一个iterator 惰性序列 而非列表，需要 list() 转换为列表，当然也可用 next() 、for 循环迭代打印 事实上，第二个参数并不止可以是列表，还可以是其它可迭代对象集合，比如 str。 利用 map 将字符串 ’123456‘ 转换成数字列表集合 [1, 2, 3, 4, 5, 6] 。 1234567&gt;&gt;&gt; def char2num(s):... digits = &#123;&#x27;0&#x27;:0, &#x27;1&#x27;:1, &#x27;2&#x27;:2, &#x27;3&#x27;:3, &#x27;4&#x27;:4, &#x27;5&#x27;:5, &#x27;6&#x27;:6, &#x27;7&#x27;:7, &#x27;8&#x27;:8, &#x27;9&#x27;:9&#125;&gt;&gt;&gt; return digits[s]&gt;&gt;&gt; r = map(char2num,&#x27;123456&#x27;)&gt;&gt;&gt; list(r);[1, 2, 3, 4, 5, 6] 因为 str 也是可迭代对象，在map 函数迭代中中会依次把 str 每个字符当做一次迭代元素。 char2num 函数如果返回的是 return s ，那么最后结果是返回：['1', '2', '3', '4', '5', '6'] 。 由于实际上 char2num 函数是映射返回数字字符对应数字，所以最后结果是：[1, 2, 3, 4, 5, 6] 。 逐减：reduce 把序列[1, 3, 5, 7, 9]变换成整数13579。 123456&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def fn(x, y):... return x * 10 + y...&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])13579 结合上述两例，便可以将 字符串 转换为对应 数字。 12345678910&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def fn(x, y):... return x * 10 + y...&gt;&gt;&gt; def char2num(s):... digits = &#123;&#x27;0&#x27;:0, &#x27;1&#x27;:1, &#x27;2&#x27;:2, &#x27;3&#x27;:3, &#x27;4&#x27;:4, &#x27;5&#x27;:5, &#x27;6&#x27;:6, &#x27;7&#x27;:7, &#x27;8&#x27;:8, &#x27;9&#x27;:9&#125;... return digits[s]...&gt;&gt;&gt; reduce(fn, map(char2num, &#x27;13579&#x27;)) # map 返回的是一个可迭代对象13579 过滤：filter filter 把传入的函数作用于每个元素，返回值是ture 过滤，false 保留。 删除字符串中所有数字。 12345&gt;&gt;&gt; def isnum(x):... return 1 - (ord(x) &gt;= 48 and ord(x) &lt;= 57);&gt;&gt;&gt; r = filter(isnum, &#x27;A1B2C3&#x27;);&gt;&gt;&gt; list(r);[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;] ⚠️ python bool 运算常见操作误解！ python 中 &amp; | 是位运算，非位运算只能用 and 、or 替换 python 中取反 !b 非法，应该用 1-b 来达到取反效果 排序：sorted sorted(collection,key,reverse) 函数有三个参数： collection ： 可迭代集合数据类型都可 key：函数变量，指定集合元素进行映射，比如都取绝对值等，但只会改变排序结果不会改变集合元素 reverse ：指定是否反转 返回值：是一个列表（不同前高阶函数返回的是一个 genrator 对象）。 给指定字符列表 ['bob', 'about', 'Zoo', 'Credit'] 排序。 python会自动按首字母 ASCII 值给字符串数组排序，不用特定指定规则。 12&gt;&gt;&gt; sorted([&#x27;bob&#x27;, &#x27;about&#x27;, &#x27;Zoo&#x27;, &#x27;Credit&#x27;]);[&#x27;Credit&#x27;, &#x27;Zoo&#x27;, &#x27;about&#x27;, &#x27;bob&#x27;] 接上：将字符串全部变为小写，同时按降序排序。 12&gt;&gt;&gt; sorted([&#x27;bob&#x27;, &#x27;about&#x27;, &#x27;Zoo&#x27;, &#x27;Credit&#x27;],key=str.lower,reverse=True);[&#x27;Zoo&#x27;, &#x27;Credit&#x27;, &#x27;bob&#x27;, &#x27;about&#x27;] 3.2 装饰器 明月装饰了我的窗，我装饰了谁的梦？ 什么是装饰器？ 在不修改函数的前提下，在代码运行期间动态给函数增加功能，称之为装饰器（Decorator）。 比如，现在我们有一个函数 now ，希望每次调用它时都能打印调用信息，但又不改动函数： 12def now(): print(&#x27;2019-9-7&#x27;) 这个时候我们定义一个装饰器函数 log： 12345def log(func): def wrapper(*args, **kw): print(&quot;调用&quot; + func.__name__) return func(*args, **kw) # func是now的形参，但now没有参数啊，这里可以传任意参数？ return wrapper 装饰器本身是一个函数，内部也返回了一个函数 … … … 3.3 偏函数 偏函数是一个语法糖，可用来固定函数某个参数（设置默认值）。其调用方式： functools.partial(func,parameter=value): func，是要固定的函数；parameter=value 是要固定函数参数及值。 固定 int 函数第二个参数值为 2 ，返回函数 int2 使得可默认进行 二进制 --&gt; 十进制 转换。 1234&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2(&#x27;1000000&#x27;)64 3.3.1 关于偏函数参数 实际上偏函数参数是：functools.partial(func,*args,**kw)。 也就是说，下面二者是等价的： 1int2(&#x27;10010&#x27;) 12kw = &#123; &#x27;base&#x27;: 2 &#125;int(&#x27;10010&#x27;, **kw) 没太明白。 当传入： 1max2 = functools.partial(max, 10) 实际上会把10作为*args的一部分自动加到左边，也就是下面二者是等价的： 1max2(5, 6, 7) 12args = (10, 5, 6, 7)max(*args) 第四章：面向对象编程 4.1 python 面对对象快速入门 定义一个类，要求每次创建实例时类属性 count 自动加1，同时可打印成绩 123456789101112131415class Student: count = 0 def __init__(self, name, score): Student.count += 1 self.name = name self.score = score def print_score(self): print(&#x27;%s: %s&#x27; % (self.name, self.score)) if __name__ == &#x27;__main__&#x27;: stu = Student(&#x27;hwh&#x27;, 99) print(stu.count) # 输出：1 self ：在类中定义的函数必须要带有self ，它指向类创建的实例对象。 _init_ : _init_ 是一个特殊的函数用于创建实例时进行初始化。 类属性 count &amp; 实例属性 name、score：count是类属性它为所有创建的类实例共享 ；name、score 是实例属性，在创建实例的时候会根据传入的参数初始化。 4.2 面对对象进阶 4.2.1 访问限制 在前面我们定义实例属性，直接用 self.属性名 直接就可以绑定一个实例属性，在外部可以 读取、修改。 但是如果我们不希望进行修改呢？ 在属性名前加上 __ 可变为 私有变量，即 self.__属性名 即可，这样外部不能访问、不能修改 。 123456789101112131415161718class Student(object): def __init__(self, name, score): self.name = name self.__score = score def get_score(self): return self.__score def set_gender(self, score): if type(score) != str: print(&quot;error!&quot;) return -1 self.__score = score if __name__ == &#x27;__main__&#x27;: stu = Student(&#x27;hwh&#x27;, 99) # print(stu.__score) # 出错，不能访问 type 方法可以获取类型属性进行判断，类似的还有 instance 方法。instance 不但可以判断所有type 可判断的类型，还可以方便的判断 类型、实例 之间关系。 如果需要外部需要访问，可定义 get、set 方法。 注意！这不是修改私有变量 在前我们尝试打印出私有变量 __score 出错，但是我们尝试修改似乎成功了？ 12stu.__score = 88print(stu.__score) # 输出：88 其实不然，这和Student 类内部的 __score 不是同一个变量，我们尝试利用 get_score 打印出内部私有变量 __score : 1print(stu.get_gender()) # 输出：99 第五章：IO编程 5.1 增 open(filePath,type) 不仅可用于读写文件，还可在没有文件时创建一个新文件。 mkdir(filePath) 可创建一个目录。 12345# 创建目录 os.makedirs(&#x27;myDir&#x27;)# 创建文件with open(r&#x27;myDir\\myTxt&#x27;, &#x27;w&#x27;) as f: f.write(&#x27;hello world! \\n i \\n am \\n a \\n coder&#x27;) with open as ... 是 python 提供的文件读写操作简单写法，它等价于： 123456try: f = open(r&#x27;myDir\\myTxt&#x27;, &#x27;w&#x27;) f.write(&#x27;hello world! \\n i \\n am \\n a \\n coder&#x27;)finally: if f: f.close() windows 目录路径使用反斜杠\\，为了防止和文本其它字母转义，建议前面用 r 或者 双反斜杆 \\\\ 5.1.1 打开文件模式 模式 r r+ w w+ a a+ 读 + + + + 写 + + + + + 创建 + + + + 覆盖 + + 指针在开始 + + + + 指针在结尾 + + 5.2 删 1234# 删除目录 os.rmdir(&#x27;myDir&#x27;)# 删除文件os.remove(&#x27;test.py&#x27;) 5.3 查：读文件等 5.3.1 文件读 方法 描述 read(filePath) 一次读取所有内容 readline(filePath) 每次读取一行 readlines(filePath) 一次读取所有行，返回列表，每一个元素是一行内容 简单测试读取文本。 123with open(r&#x27;myDir\\myTxt&#x27;, &#x27;r&#x27;) as f: for line in f.readlines(): print(line.strip()) # 去除\\n，要不然会多打印换行 打印前两行。 123with open(r&#x27;myDir\\myTxt&#x27;, &#x27;r&#x27;) as f: for i in range(0,2): print(f.readline().strip()) # 去除\\n，要不然会多打印换行 二进制文件 &amp; 其它编码 如果读取的文件是二进制文件，比如图片、视频 等要用 rb 模式打开文件： 读取二进制文件。 123&gt;&gt;&gt; f = open(&#x27;/Users/michael/test.jpg&#x27;, &#x27;rb&#x27;)&gt;&gt;&gt; f.read()b&#x27;\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...&#x27; # 十六进制表示的字节 如果读取是非UTF-8编码文件，要指定按什么编码格式读取： 读取二进制且编码为gbk 文件。 123&gt;&gt;&gt; f = open(&#x27;/Users/michael/gbk.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;gbk&#x27;)&gt;&gt;&gt; f.read()&#x27;测试&#x27; 5.3.2 查看其它信息 123456# 获取当前文件操作路径os.getcwd()# 获取目录列表（重要）# 该方法获取的不包括文件路径，仅文件名os.listdir(&quot;./&quot;) 5.4 改：写文件等 5.4.1 写文件 写文件也是调用 open() 方法，传入标识符 'w'、’wb‘ 写文本或者二进制文件。 也是采用类似读文件 python 提供的一种简易写法，也可同读文件传入 encoding 参数转换编码。 12with open(&#x27;/Users/michael/test.txt&#x27;, &#x27;w&#x27;) as f: f.write(&#x27;Hello, world!&#x27;) 5.4.2 文件重命名等 12# 对文件重命名&gt;&gt;&gt; os.rename(&#x27;test.txt&#x27;, &#x27;test.py&#x27;) 5.5 序列化与反序列化 序列化：即指可以将把指定类型对象从 内存 —&gt; 磁盘 ； 反序列化：则可将保存在磁盘的对象从 磁盘 —&gt; 内存 。 5.5.1 pickle python 提供了 pickle 模块来进行任意对象的序列化和反序列化，但它序列化只能用于 python。 常用序列化、反序列化方法如下： 方法 描述 pickle.dump(obj, fp, [,protocol]) 将任意对象序列化 pickle.load(fp) 将保存在磁盘的bytes对象反序列化 pickle.dumps(obj, [,protocol]) 将obj 对象序列化为 string 形式，而不是存入文件中。 pickle.loads(string) 从string 中读出序列化前的 obj对象 以下做一个简单实例将 dict 字典类型序列化与反序列化进行io读写。 1234567891011# 序列化：保存在磁盘中d = &#123;&#x27;name&#x27;: &#x27;hwh&#x27;, &#x27;age&#x27;: &#x27;23&#x27;&#125;# 注意：创建一个写二进制文件file对象with open(&#x27;test.txt&#x27;, &#x27;wb&#x27;) as f: pickle.dump(d,f)# 反序列化：从磁盘中读取# 注意：创建一个读二进制文件file对象with open(&#x27;test.txt&#x27;, &#x27;rb&#x27;) as f: dic = pickle.load(f)print(dic) # 输出：&#123;&#x27;name&#x27;: &#x27;hwh&#x27;, &#x27;age&#x27;: &#x27;23&#x27;&#125; 但是 pickle 模块序列化只用于 python ，如何在不同编程语言传递对象？ 我们需要一种标准格式，比如 XML 、JSON ，json 是一种更好的选择。 5.5.2 JSON 因为要在不同语言中传递对象，首先要有一种把python对象 —&gt; 通用语(json) ，它们直接对应关系： JSON 类型 Python类型 {} dict [] list “string” str 1234.56 int 或 float true/false True/False null None 类似 pickle 模块，json 模块提供了序列化，反序列化方法： 方法 描述 json.dump(obj, fp…) 将任意对象序列化 json.load(fp) 将保存在磁盘的bytes对象反序列化 json.dumps(obj) 将obj 对象序列化为 string 形式，而不是存入文件中。 json.loads(string) 从string 中读出序列化前的 obj对象 改写上面 pickle 模块读写。 1234567891011# 序列化：保存在磁盘中d = &#123;&#x27;name&#x27;: &#x27;hwh&#x27;, &#x27;age&#x27;: &#x27;23&#x27;&#125;# 注意：和pickle模块不同这里是 w，不是二进制with open(&#x27;test.json&#x27;, &#x27;w&#x27;) as f: json.dump(d,f)# 反序列化：从磁盘中读取# 注意：这里是rwith open(&#x27;test.json&#x27;, &#x27;r&#x27;) as f: dic = json.load(f)print(dic) # 输出：&#123;&#x27;name&#x27;: &#x27;hwh&#x27;, &#x27;age&#x27;: &#x27;23&#x27;&#125; 不进行io读写，dumps() 序列化为 string，然后 loads() 反序列化读取。 12345678# 序列化d = &#123;&#x27;name&#x27;: &#x27;hwh&#x27;, &#x27;age&#x27;: &#x27;23&#x27;&#125;str = json.dumps(d)# 反序列化# 注意：这里是rdic = json.loads(str)print(dic) # 输出：&#123;&#x27;name&#x27;: &#x27;hwh&#x27;, &#x27;age&#x27;: &#x27;23&#x27;&#125; 自定义序列化规则 在 json 中用 &#123;&#125; 表示对象，对应 python 中 dict 。不过我们一般用 class 表示对象，但是 class 类对象不能直接序列化，需要自己定义序列化规则。 1234567891011121314class Student(object): def __init__(self, name, age, score): self.name = name self.age = age self.score = scoredef student2dict(std): return &#123;&#x27;name&#x27;:std.name, &#x27;age&#x27;:std.age, &#x27;score&#x27;:std.score&#125;s = Student(&#x27;hwh&#x27;, 20, 99)# 输出：&#123;&quot;name&quot;: &quot;hwh&quot;, &quot;age&quot;: 20, &quot;score&quot;: 99&#125;print(json.dumps(s, default=student2dict)) 因为通常class的实例都有一个__dict__属性，它就是一个dict，用来存储实例变量。 所以还可用 lambda 表达式直接简写： 1print(json.dumps(s, default=lambda obj: obj.__dict__))"},{"title":"前端基础（二）CSS基础笔记","date":"2022-01-02T11:54:25.535Z","updated":"2021-12-03T03:41:02.906Z","comments":true,"path":"NO_post/前端基础（二）CSS笔记.html","permalink":"https://hwh.zone/NO_post/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89CSS%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"第一部分：基本样式属性 文本样式 字体：font-family 指定设置元素的字体： 1234p&#123; font-family: &quot;Times New Roman&quot;, Times, serif;&#125; 逗号分隔表示为备选字体，当不浏览器不支持 “Times New Roman” 后会依次选择 Times、serif 字体。 如果字体不止为一个单词，要用 “ ” 包围，比如 “Times New Roman” 大小：font-size font-size 属性用于设置字体的大小，常用设置字体方式有三种： 关键字：small &lt; medium &lt; large &lt; xlarge 数值：像素值 px 、相对尺寸单位 em，特别的：1em = 16px 123456p &#123; font-size: small;// font-size: 16px;// font-size: 1em;&#125; 斜体：font-style font-style 通常用于指定斜体文本，常用属性值用关键字设置： 关键字：normal(正常文本)， italic（斜体） ，oblique(倾斜) 和 italic 效果类似 1234p&#123; font-style: italic;&#125; 粗细：font-weight font-weight 控制文本的粗细，可以设置关键字或者数值来指定： 关键字：normal (默认)，bold，bolder，和 lighter 数值：100（细）—&gt; 900（粗) ，特别的：normal == 400，700 == bold 大写：font-variant font-variant 属性可将字体转换 —&gt; 小型大写字母 ,可设属性有： 关键字：normal、small-caps（小型大写）、inherit ： 123456789101112&lt;html&gt;&lt;head&gt; &lt;style&gt; p.normal &#123; font-variant: normal;&#125; p.small &#123; font-variant: small-caps;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;normal&quot;&gt;设置为normal&lt;/p&gt; &lt;p class=&quot;small&quot;&gt;设置为small-caps&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 执行效果：可以看到原小写 small-caps 被转换为大写 SMALL-CAPS，但是字体较小 颜色：color color 可用于设置文本颜色，通常可用以下三种方法设置： 颜色关键字，如：red、blue、green 十六进制值，如：#0000FF(蓝色) RGB，如：rgb(255,0,0)(红色) 对齐：text-align 、vertical-align text-align 用于水平对齐，可设置属性为：left、center、rigth 。 vertical-align 用于垂直对齐，可设属性为： 文字在 表格单元 居中、上、下：top、middle、bottom ，不可用数值 字体能达到 不改变、下标、上标 ：baseline、sub、super ，可用数值 使得文字在表格居中、上、下。 123456789101112131415161718&lt;html&gt;&lt;head&gt; &lt;style&gt; td.top &#123; vertical-align: top;&#125; td.middle &#123; vertical-align: middle;&#125; td.bottom &#123; vertical-align: bottom;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;0&quot; style=&quot;height: 150px;&quot;&gt; &lt;tr&gt; &lt;td class=&quot;top&quot;&gt;Top&lt;/td&gt; &lt;td class=&quot;middle&quot;&gt;Middle&lt;/td&gt; &lt;td class=&quot;bottom&quot;&gt;Bottom&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; ⚠️ 但是特别的，如果 文字要在div区域到垂直居中效果 ，必须： 外部div标签 display 属性设置为内联表格：display: inline-table; 文字用 内部div标签 包围，同时将该内部div标签 display属性设置为表格单元：display: table-cell; html 代码： 123&lt;div class=&quot;div&quot;&gt; &lt;div class=&quot;paragraph&quot;&gt; w3cschool &lt;/div&gt;&lt;/div&gt; css 代码： 1234567891011.main &#123; height: 150px; width: 400px; background-color: LightSkyBlue; display: inline-table;&#125;.paragraph &#123; display: table-cell; vertical-align: middle;&#125; 最终可达到的效果： 使得某些文字在一段文字起到下标、上标效果。（注：也可直接使用 &lt;sub&gt;、 &lt;sup&gt; 标签达到效果） 12345678910111213141516&lt;html&gt;&lt;head&gt; &lt;style&gt; span.baseline &#123; vertical-align: baseline;&#125; span.sub &#123; vertical-align: sub; &#125; span.super &#123; vertical-align: super;&#125; span.pixel &#123; vertical-align: -10px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;This is a &lt;span class=&quot;baseline&quot;&gt;w3cschool&lt;/span&gt; example.&lt;/p&gt; &lt;p&gt;This is a &lt;span class=&quot;sub&quot;&gt;w3cschool&lt;/span&gt; example.&lt;/p&gt; &lt;p&gt;This is a &lt;span class=&quot;super&quot;&gt;w3cschool&lt;/span&gt; example.&lt;/p&gt; &lt;p&gt;This is a &lt;span class=&quot;pixel&quot;&gt;w3cschool&lt;/span&gt; example.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 下划： text-decoration text-decoration 指定文本如何装饰，如：增加下划线、上方水平线、删除线（也可用 &lt;s&gt; 标签实现）。 常用属性关键字有： none ： 默认值，这定义了一个正常的文本 inherit ： 从其父元素继承此属性 overline ：在文本上方绘制水平线 underline ： 在文本下方绘制水平线 line-through ： 在文本中绘制水平线（ 替换HTML标记） 比如给下面一段文字加上下划线： 12345678910&lt;html&gt;&lt;head&gt; &lt;style&gt; p.underline &#123; text-decoration: underline; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;underline&quot;&gt;w3cschool&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 效果图： 缩进：text-indent text-indent 属性指定在文本的第一行开始之前应该留下多少水平空间。 常用属性值以长度表示，其单位为：px、em、pt、cm 等。也可用 %、inherit(继承父元素缩进)。 ⚠️ 可使用负值，比如：text-indent: -40px 。 大写：text-transform text-transform 可以使得 文本字母 全部大写、小写、每个单词首字母大写，对应属性关键字为： uppercase：使得选中文本所有字母都大写 lowercase：使得选中文本所有字母都小写 capitalize ：使得选中文本每个单词首字母大写 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;style&gt; p.uppercase &#123; text-transform: uppercase;&#125; p.lowercase &#123; text-transform: lowercase;&#125; p.capitalize &#123; text-transform: capitalize;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;uppercase&quot;&gt; transforms all characters to uppercase.&lt;/p&gt;&lt;p class=&quot;lowercase&quot;&gt; transforms all characters to lowercase.&lt;/p&gt;&lt;p class=&quot;capitalize&quot;&gt; transforms the first character in each word to uppercase. &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 运行效果图： 间距：letter-spacing 、word-spacing letter-spacing 用于设置文本中字符之间的间距，常设属性方式： 关键字：normal(正常文本) 、inherit（继承父元素） 数值：px，pt，cm，mm 等测量单位定义字符额外空间，负值可以减少字符间距，更密集 。 word-spacing 指定文本中单词之间的空格，常设属性方式： 关键字：normal(正常文本) 、inherit（继承父元素） 数值：同前 盒模型 盒模型结构 属性工作顺序为顺时针：上 --&gt; 右 --&gt; 下 --&gt; 左 创建一个顶部10像素，底部15像素，右侧5像素，左侧10像素的 padding 。 1padding: 10px 5px 15px 10px; 盒模型宽高 高度 = height + ( padding-top + border-top + margin-top)+ (padding-bottom + border-bottom + margin-bottom) 宽度 = width + ( padding-left + border-left + margin-left )+ ( padding-right + border-right + margin-right ) 试问：下面盒模型的高度为多少？ 按照公式应该是：200 + (15 + 2 + 10 ) + (10 + 2 + 15) = 254px 边框：border border 属性可以自定义盒模型边框： 空格分隔分别表示：宽度 、边框样式 、颜色 。 1p &#123; border: 5px solid green; &#125; border-width、border-style、border-color border-width、border-style、border-color 属性可分别设置单独设置：宽度 、边框样式 、颜色 : 123456p&#123; border-style: solid; border-width: 2px; border-color: green;&#125; border-style 属性设置： 关键字：solid(实线)、dotted(虚线)、dashed(虚线)、double(双精度) 等 ⚠️ 还可为不同的边指定不同的边框：border-top-style，border-right-style … 宽高：width、height 元素的宽高属性一般设置： 数值：如指定高度 = 100px，height = 100px 百分比：如指定宽度占据整个屏幕宽，width = 100% 123456div &#123; border: 5px solid green; width: 100%; height: 90px;&#125; 最大、最小高宽 要设置元素的最小和最大高度或者宽度，可以使用以下属性： min-width ：元素的最小宽度 min-height ：元素的最小高度 max-width ：元素的最大宽度 max-height ：元素的最大高度 背景 背景色：background-color 前面我们可以使用属性 color 设置文本颜色；background-color 则可以设置元素指定背景颜色。常用属性值： 关键字：red、blue 等 十六进制：#fff、#000、#6e6e6e 等 RGB：rgb(255,255,255)、rgba(0,0,0,0.5) （rgba 可以实现透明背景色） 下面例子把：boby、h1、p 分配了不同的背景颜色。（字体颜色默认黑色） 12345678910111213141516171819202122&lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; body &#123; background-color:red; &#125; div &#123; background-color: #00ffff; &#125; p &#123; background-color:rgb(142,185,245); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;啊，我绿了！&lt;/div&gt; &lt;p&gt;啊，人生好蓝~&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 背景图：background-image background-image 用于设置背景图，设置属性值用相对/绝对路径指定： 指定路径：url(‘相对/绝对路径’) ⚠️ 如果要指定多个图片，以逗号分隔：background-image ： url(‘1.png’),url(‘2.png’); 特别的 background-image 不仅可以用于设置 整个页面，也可以设置 某个元素 背景图： 下面给元素设置一个背景图片。 1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; p &#123; height:100px; line-height: 100px; text-align: center; color: red; background-image:url(&quot;https://wpdotorg.files.wordpress.com/2008/11/boat.jpg&quot;) &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;我是p标签，我的颜色是红色，高度为100px，我的背景图是一艘小船。&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 重复：background-repeat background-repeat 指定如何重复背景图像，可设置属性值（关键字）： repeat：全区域重复 （即使不设置，背景图片默认全区域重复） repeat-x：沿x轴重复 repeat-y：沿y轴重复 no-repeat：不重复，只使用一次 herit：继承父元素的 background-repeat 属性值 滚动：background-attachment background-attachment 设置背景图片是 固定 的还是和 其余部分一起滚动 。可设置的参数（关键字）： scoll：默认值，背景图像会随着页面其余部分的滚动而移动 fixed：页面的其余部分滚动时，背景图像不会移动 inherit：从父元素继承 background-attachment 属性值 下面展示设置图片滚动的实例。 12345678910111213141516171819202122232425262728293031323334&lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; body &#123; background-image: url(&quot;https://wpdotorg.files.wordpress.com/2008/11/boat.jpg&quot;); background-repeat: no-repeat; background-attachment: scroll; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 列表样式 项标记：list-style-type list-style-type 可用于设置列表每项标记，比如：· 、□ 、…，参数可用关键字设置： none,circle(空心原点), square(空心□), decimal(有序数字), disc(实心原点), lower-alpha(有序字母) ⚠️ 有序列表 除了默认数字decimal 作为标记，上面属性只能使用 lower-alpha 字母等有序标记 。 以下是为实例设置不同项目标记。 1234567891011121314151617181920212223242526272829&lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; ol.lower-alpha &#123; list-style-type: lower-alpha; &#125; ul.circle &#123; list-style-type: circle; &#125; ul.square &#123; list-style-type: square; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ol class=&quot;lower-alpha&quot;&gt; &lt;li&gt;w3cschool&lt;/li&gt; &lt;/ol&gt; &lt;ul class=&quot;circle&quot;&gt; &lt;li&gt;w3cschool&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;square&quot;&gt; &lt;li&gt;w3cschool&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 项标记-图像：list-style-image 、list-style-position 进一步我们还可以使用list-style-image 设置图像作为项标记，用 list-style-position 指定标记位置： list-style-position:inside：指定位置在内容流中❔ list-style-position:outside：默认值，指定位置不在内容流中❔ 设置项标记为指定图像，并设置在内容流中。 123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; ul &#123; list-style-image: url(&quot;https://www.w3cschool.cn/statics/images/favicon.ico&quot;); list-style-position: inside; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;w3cschool&lt;/li&gt; &lt;li&gt;w3cschool&lt;/li&gt; &lt;li&gt;w3cschool&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; list-style list-style 属性是设置 list-style-type*、list-style-image、*list-style-position 简写属性： 1234ul &#123; list-style: square outside none;&#125; 下方是未简化版本： 123456ul&#123; list-style-type: square; list-style-position: outside; list-style-image: none;&#125; 执行结果： 表格样式 属性 描述 boder 该属性可依次指定：边框大小、边框类型、边框颜色 border-collapse 是否把表格边框合并为单一的边框 border-spacing 分隔单元格边框的距离 width、height 设置表格宽高，可用px、em等，也可用百分比 % caption-side 表格标题的位置 empty-cells 是否显示表格中的空单元格 table-layout 显示单元、行和列的算法 更多设置： text-align 、vertical-align ：设置文本对齐方式，见前 padding ：设置表格中内容与边框的距离 边框 ：boder 可为表格、表格单元设置边框、以及颜色和粗细，比如存在以下表格： ⚠️这其实是盒模型边框 boder设置 ，因为表格table、表格单元th、td 其实也是元素，是盒模型结构。 12345678910111213141516171819202122&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;th&gt;Firstname&lt;/th&gt;&lt;th&gt;Lastname&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Bill&lt;/td&gt;&lt;td&gt;Gates&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Steven&lt;/td&gt;&lt;td&gt;Jobs&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 把整个表格、表格第一行单元、表格其它行单元设置为 ：1px粗、实框、蓝色。 1234table, th, td&#123; border: 1px solid blue;&#125; 注意：不能只选中 table 设置，这样只有表格最外层被设置蓝色边框。每个单元格也要被选中！ 给四边设置样式 在前面我们通过 border 属性来指定边框：颜色、样式、宽度，但是边框上下左右都是统一颜色样式等。 实际上，元素盒子模型中边框可分为上、右、下、左四个矩形区域。我们并且可通过下面属性分别指定： border-color：指定边框颜色，可依次按 上、右、下、左 顺序指定四边 border-style： 指定边框样式，可依次按 上、右、下、左 顺序指定四边 border-width：指定边框宽度，可依次按 上、右、下、左 顺序指定四边 试着分析写出下面图形CSS代码。 显然，背景颜色为白色，边框颜色都是黑色，边框样式也一致都为 solid ，而边框宽度明显下边宽度要和上、左、右不同需要单独设置。 12345678#yin-yang &#123; width: 96px; height: 48px; background: #eee; border-style: solid; border-width: 2px 2px 50px 2px;&#125; 进阶：尝试画出下面的阴阳图形。 首先我们只需将上例中正方形通过 border-radius 属性设置为圆形即可 ： 12345678910#yin-yang&#123; position: relative; width: 96px; height: 48px; background: #eee; border-style: solid; border-width: 2px 2px 50px 2px; border-radius: 100%;&#125; 然后我们再尝试生成下面小圆：内圆为白，外环为黑色。 123456789#yin-yang::before&#123; content: &quot;&quot;; position:absolute; background-color:#eee; width:12px; height:12px; border:18px solid black;&#125; 最后再把小圆下移到直径和大圆直径重合： 1234#yin-yang::before&#123; top:50%;&#125; 同理，再画出一个小圆：内圆为黑，外环为白色。 123456789101112#yin-yang::after&#123; content: &quot;&quot;; position:absolute; background-color:black; width:12px; height:12px; border:18px solid #eee; border-radius: 100%; top: 50%; left: 50%;&#125; 深入了解 border 属性：梯形 在上面你可能理解边框是由上下左右是个矩形组成。实际上它可通过border-top 、border-right 属性分为上下左右四个梯形区域，每个梯形区域由盒子 相邻 内容区域边 和 盒子最外边 组成。 请看下例：设置文本区域为长宽相等50px正方形，边界都厚度为50px 。 12345678910111213141516&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;div&#123; width: 50px; height: 50px; border: 50px solid red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如果我们分别修改边框上下左右颜色，便可以发现其实是由4个梯形组成： 123456789div&#123; width: 50px; height: 50px; border-top: 50px solid red; border-right: 50px solid yellow; border-bottom: 50px solid blue; border-left: 50px solid green;&#125; 进一步我们把文本内容区域高宽设置为0，那么四个边框矩形区域可变为三角形： 123456789div&#123; width: 0px; height: 0px; border-top: 50px solid red; border-right: 50px solid yellow; border-bottom: 50px solid blue; border-left: 50px solid green;&#125; 现在我们接着例举几个实例进一步理解border属性。 试分析：下面的右三角形是怎么画出的？ 过程其实很简单，首先在上面基础上，我们把上下两个三角形设为透明： 123456789div&#123; width: 0px; height: 0px; border-top: 50px solid transparent; border-right: 50px solid yellow; border-bottom: 50px solid transparent; border-left: 50px solid green;&#125; 然后删除掉border-bottom 属性，这样由于右侧三角形不存在，div 宽度自动减去原右三角形宽（厚）度，表现为保留原来的左半部分： 最终css 样式设置： 12345678div&#123; width: 0px; height: 0px; border-top: 50px solid transparent; border-bottom: 50px solid transparent; border-left: 50px solid green;&#125; 同理，试着实现下三角形。 12345678div&#123; width: 0px; height: 0px; border-top: 50px solid red; border-right: 50px solid transparent; border-left: 50px solid transparent;&#125; 折叠：border-collapse border-collapse 可将表格边框是否折叠成单一边框，可设置的属性（关键字）： seperate：默认值，折叠成单一表格，每个单元都有自己的完整边框（比如上面表格） collapse：不折叠，每个相邻单元边合并 设置每个相邻单元格边合并。 12345678table, th, td&#123; border: 1px solid blue;&#125;table&#123; border-collapse:collapse;&#125; 距离：border-spacing border-spacing 设置分隔单元格边框的距离： 设置格式：border-spacing ：水平单元格相邻距离 垂直单元格相邻距离 ⚠️ 只有在 border-collapse:seperate 设置分开才生效！ 设置表格：水平单元格相距10px，垂直单元格相距30px。 12345table&#123; border-collapse: separate; border-spacing:10px 30px ; &#125; 宽高：width、height width、height 可以设置table、th、td宽高： 基本长度单位：px，em… 百分比：如100%，表格可以占据整个宽度 表格宽度设置为 100%，同时将 th 元素的高度设置为 50px。 12345678910111213141516171819202122232425262728293031323334353637&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;table,td,th&#123; border:1px solid black; // 设置边框&#125;// 宽度==屏幕宽，水平单元格宽度 = 屏幕宽 / 水平单元格数// 但如果是选择单元格td、th来设置width:100%; 宽度并不会平分，而是第一个水平单元格占据尽可能多宽度table&#123; width:100%; &#125;th&#123; height:50px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;th&gt;Firstname&lt;/th&gt;&lt;th&gt;Lastname&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Bill&lt;/td&gt;&lt;td&gt;Gates&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Steven&lt;/td&gt;&lt;td&gt;Jobs&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 自动宽度：table-layout table-layout 可以当单元格宽度*未明确设置*时 （表宽度可指定），如果设置每列列宽： auto ： 当列或单元格宽度未明确设置时，列宽将与组成列的单元格中的内容量成比例 fixed ： 当列或单元格宽度未明确设置时，列宽将不受组成列的单元格中的内容数量的影响 123456789101112131415161718table&#123; border-collapse: separate; width: 100%; border: 1px solid gray;&#125; td &#123; border: 1px solid gray;&#125;table.auto &#123; table-layout: auto;&#125;table.fixed &#123; table-layout: fixed;&#125; 综合练习 请尝试实现下面表格样式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;#customers &#123; font-family:&quot;Trebuchet MS&quot;, Arial, Helvetica, sans-serif; width:100%; border-collapse:collapse; &#125;#customers td, #customers th &#123; font-size:1em; border:1px solid #98bf21; // 为什么不设置 #customers？没有效果，因为和单元格重叠 padding:3px 7px 2px 7px; // 设置文字离边框距离 &#125;#customers th &#123; font-size:1.1em; text-align:left; background-color:#A7C942; // 标题单元格背景设置为深绿 color:#ffffff; // 标题文字设置为白色，而不是默认黑色 &#125;// 设置奇数行默认背景色，含标题#customers tr:nth-child(2n+1) &#123; background-color:#EAF2D3; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table id=&quot;customers&quot;&gt;&lt;tr&gt;&lt;th&gt;Company&lt;/th&gt;&lt;th&gt;Contact&lt;/th&gt;&lt;th&gt;Country&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Apple&lt;/td&gt;&lt;td&gt;Steven Jobs&lt;/td&gt;&lt;td&gt;USA&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;alt&quot;&gt;&lt;td&gt;Baidu&lt;/td&gt;&lt;td&gt;Li YanHong&lt;/td&gt;&lt;td&gt;China&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Google&lt;/td&gt;&lt;td&gt;Larry Page&lt;/td&gt;&lt;td&gt;USA&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 链接样式 我们可以根据前面学的： 文本样式：设置链接文字样式，比如去除下划线 text-decoration:none; 盒模型：设置链接的边框、宽高等，比如 boder : 2px solid green 背景图：设置链接的背景图等 … 同时比较特殊的是：我们可以定义链接不同状态下样式： a:link ： 普通的、未被访问的链接 a:visited ： 用户已访问的链接 a:hover ： 鼠标指针位于链接的上方 a:active ： 链接被点击的时刻 综合练习 尝试实现如下样式的导航栏。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;/* 步骤1：设置基本导航栏div区域背景色、高宽*/#menu&#123; background-color: #34495e; // 直接设置区域背景色 width: 100%; height: 40px;&#125;/* 步骤2：设置表格，去除列表项标记等 Q1:为什么要设置：overflow: hidden？ 因为ul元素子元素li 为了可以在一行显示设置了向左浮动。 设置overflow: hidden可以让ul包含li，而不是不显示了。*/ul&#123; list-style-type:none; margin:0; padding-left: 60px; overflow: hidden; /*可以使用overflow:hidden;技术让父元素包含浮动子元素*/&#125;/*li标签默认是块，为了在一栏显示，设置为float浮动*/li&#123; float:left; &#125;/* 步骤3：设置链接基本样式。 Q1:为什么设置display: block？ 1.可以让a标签整个区域被点击（而不是只有文字）2.可以设置a标签宽度、高度 Q2:为什么设置line-height: 40px; ？ 为了让文字垂直居中。水平居中不能解决垂直居中，而vertical-align: middle不起作用。 当然，也可以尝试设置 padding来模拟居中。 */a:link,a:visited&#123; display: block; width: 130px; /* 设置a标签宽度 == div宽度，点击后整个区域都可以点击*/ height: 40px; /* 高度 = 行高，可使得文字居中。直接vertical-align: middle;只能是表格单元格内起作用 */ // vertical-align: middle; line-height: 40px; text-decoration: none; text-align: center; color: white;&#125;/*a:focus 可以保证点击后背景一直是红色，直到点了其它导航项目*/a:hover,a:focus&#123; background-color: red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&#x27;menu&#x27;&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;#home&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#news&quot;&gt;News&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#about&quot;&gt;About&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 定位与布局 内联与块：display 网页上的每个元素都是一个盒模型，每个元素默认为块 或者内联行为方式： 块元素：尽可能 占据最大宽度，独占一行、前后有 换行符 ，width、height 可设置 常用如：div、p、h1~h6、ol、ul、table、from 等 内联元素：占据内容宽度，不独占一行、 不强制换行 ，width、height 不可设置 常见如：span、a、img 等 display 属性可决定盒模型元素的 行为方式 ： display:block ：使得元素行为方式为块 display:inline ：使得元素行为方式为内联 display:inline-block ：使得元素行为方式为内联-块 ，在内联的基础上又可以设置框高 display:none ：隐藏 一个元素，不占用任何空间 (visibility:hidden 占用空间 ) ，好像它不存在一样。 显隐：visibility visibility 用来设置元素是显示还是隐藏的，可设关键字： visibility:visible ：元素可见 visibility:hidden ：元素不可见，但是它占据的空间还存在 ，依然会影响布局 定位：position position 允许我们定位一个元素，常见定位方式有： static：静态默认定位， 定位元素总是按照页面的正常流动进行定位，忽略left、rigth等设置位置！ fixed： 固定定位，即使窗口被滚动也不会移动，可设置垂直或水平位置，相对于浏览器窗口定位 relative：相对定位，可设置垂直或水平位置，相对于它自身的起点位置定位 absolute ：绝对定位，可设置垂直或水平位置，相对最近已定位祖先元素 或者最初包含块 设置后在 原文档流中被完全删除，原占据空间关闭，好像不存在一样 因为绝对定位的框与文档流无关，可覆盖页面上的其它元素，通过 z-index 属性来设置 设置垂直或水平位置，通过属性：top、bottom、left、right 来设置： 必须要先对 position属性进行初始化设置定位方式才能使用！ position:stactic 设置的元素，top、bottom、left、right 会被忽略！ 固定定位：fixed 实例：固定定位后，div-a 移动到相对浏览器窗口指定位置，原来位置被填充。 脱离文档流，原空间不保留，随滚动条改变位置 相对浏览器窗口（左上角）位置定位 相对定位：relative 实例：相对定位后，div-a 移动到相对自身在文档流的指定位置，原来位置保留。 不脱离文档流，原空间保留 相对自身起点（左上角）定位 绝对定位：absolute 实例：绝对定位后，div-a 移动到相对浏览器窗口（最近包含块）指定位置，原来位置被填充。 脱离文档流，原空间不保留，但不随滚动条改变位置 相对最近已定位祖先元素定位，如果没有则相对最初包含块定位 重叠：z-index 如果两个元素发生重叠，可以通过设置z-index 属性改变层叠次序。定位元素沿 z 轴的位置，z 轴定义为垂直延伸到显示区的轴： 默认z-index = 0， z-index 值越大，则沿着z 轴正轴越远，离用户越近 z-index 属性必须要在设置了position 才能生效。（除了不能设置position:static ） 试着改变下面重叠红、蓝方块次序，把蓝色方块显示在上面。 123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt; &lt;style&gt; .blue &#123; background-color: #8EC4D0; width: 60px; height: 60px; &#125; .red &#123; background-color: #FF4D4D; width: 60px; height: 60px; margin-top: -30px; margin-left: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;blue&quot;&gt;blue&lt;/div&gt; &lt;div class=&quot;red&quot;&gt;red&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，初始两个div方块按照 后到显示在前 ，所以红色方块显示在前。 我们可以设置 .blue 的 position 属性为 relative （fixed、absolute 也可以，但是由于脱离文档流红色方块会上移动不方便设置）；然后增大它的 z-index 为 1。 ⚠️ 不用设置红色方块 .red 的 position 属性?? 12345678.blue&#123; background-color: #8EC4D0; position: relative; width: 60px; height: 60px; z-index:1 &#125; 浮动：float 无论多么复杂的布局，基本出发点：如何在一行显示多个div元素 。这就用到了浮动，浮动只有两个关键字设置： left：左浮动 right：右浮动 设置为浮动的框，会脱离文档流向左或向右移动，它们的移动规则是： 多个元素浮动，从上至下依次向左、向右浮动 假设 div 元素A是浮动的，如果A元素上一个元素也浮动则紧跟其后（如果一行能放下）；如果A元素上一个元素不浮动（是标准流中元素），那么相对垂直位置不会改变（顶部和其底部同一条水平线，但可以对应左、右移动） 浮动元素总是飘浮在标准流之上（理解为z-index大） 比如，存在下图4个非浮动div 元素： 设置 div2 ：向右浮动，试分析结果？ 首先，div2 脱离标准流所以释放空间，下方div3、div4 向上移动。而div2 上一个块元素div1 不是浮动元素，所以相对div2 垂直位置不变（顶部和其底部同一条水平线，表现为不向上浮动），但是会向右浮动，故最后结果是： 设置div2、div3、div4：向右浮动，试分析结果？ div2、div3、div4 都脱离标准流，多个元素浮动，从上至下则div2先右浮动，由于div2 上一个元素div1 不浮动故保持相对垂直位置不变（表现为不上浮），整体只移动到右端。 然后div3 向上浮动，由于它的上一个元素div2 是浮动的，所以紧靠其后。div4同理，紧靠div3 后。 故最终结果是： 浮动与文字 首先我们观察网页：设置图片向左浮动后，生成的文字环绕图片。 123456789101112131415161718192021&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;img &#123; float:left;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3388481411,1093632805&amp;fm=26&amp;gp=0.jpg&quot; /&gt;&lt;p&gt;...余告之曰：其形也，翩若惊鸿，婉若游龙。荣曜秋菊，华茂春松。髣髴兮若轻云之蔽月，飘飖兮若流风之回雪。远而望之，皎若太阳升朝霞；迫而察之，灼若芙蕖出渌波。秾纤得中，修短合度。肩若削成，腰如约素。延颈秀项，皓质呈露。芳泽无加，铅华弗御。云髻峨峨，修眉联娟。丹唇外朗，皓齿内鲜。明眸善睐，靥辅承权。瓌姿艳逸，仪静体闲。柔情绰态，媚于语言。奇服旷世，骨像应图。披罗衣之璀粲兮，珥瑶碧之华琚。戴金翠之首饰，缀明珠以耀躯。践远游之文履，曳雾绡之轻裾。微幽兰之芳蔼兮，步踟蹰于山隅。于是忽焉纵体，以遨以嬉。左倚采旄，右荫桂旗。攘皓腕于神浒兮，采湍濑之玄芝。余情悦其淑美兮，心振荡而不怡。无良媒以接欢兮，托微波而通辞。愿诚素之先达，解玉佩而要之。嗟佳人之信修，羌习礼而明诗。抗琼珶以和予兮，指潜川而为期。执眷眷之款实兮，惧斯灵之我欺。感交甫之弃言兮，怅犹豫而狐疑。收和颜而静志兮，申礼防以自持。...&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; ❔ 令人困惑的是：图片设置浮动已经脱离文档流不应该释放了空间不再影响布局了，为什么文字还能环绕它呢？ 就像我们修改图片为绝对定位： 1234img &#123; position: absolute;&#125; 文字不再环绕，而是好像当图片不存在一样： 这也就是绝对定位和浮动的最大区别，虽然它们都脱离了文档流： 绝对定位不会影响布局好像它不存在一样；但浮动会影响布局，其它内容（包括元素？）会围绕它 。 清除浮动：clear 经过上面浮动学习：元素浮动之前在标准流中，是 竖向排列 的，而浮动之后可以理解为 横向排列。 而清除浮动可以 打破横向排列 ，但是 清除浮动只能在需要被影响的元素内使用 ，请看下例： 已知下列 div1、 div2 元素都是左浮动从而在一行显示，如何使 div2 移至下一行打破横向排列？ 如果我们增加CSS 样式，设置 div1 右边不允许有浮动元素： 1234.div1&#123; clear:right;&#125; 很不幸，这是不起作用的！我们希望div2 移动到下一行，那么被影响的是 div2，所以只能设置 div2 左边不允许存在浮动元素： 1234.div2&#123; clear:left;&#125; 这样就可以使得 div2 向下移动一行。 那么，下列 div1、 div2 元素都是右浮动，如何使得div2 移至 div1 下边呢？ 同上，被影响的是 div2 元素，那么不允许 div2 右边存在浮动元素即可： 1234.div2&#123; clear:right;&#125; 溢出：overflow 当父元素不设置高度时候，高度随内容增加自适应高度。但是当我们指定了父元素的高度，如何解决内容增加溢出问题呢？ 1234567891011121314151617&lt;html&gt;&lt;head&gt;&lt;style&gt; div &#123; width: 850px; height: 60px; background-color: LightBlue; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;none&quot;&gt; 苏子愀（qiǎo）然，正襟危坐，而问客曰：“何为其然也？”客曰：“‘月明星稀，乌鹊南飞’,此非曹孟德之诗乎？西望夏口，东望武昌。山川相缪(liáo)，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳(zhú)舻(lú)千里，旌(jīng)旗蔽空，酾(shi)酒临江，横槊(shuò)赋诗，固一世之雄也，而今安在哉?况吾与子渔樵(qiáo)于江渚(zhǔ)之上，侣鱼虾而友麋(mí)鹿,驾一叶之扁舟，举匏（páo）樽以相属（zhǔ）。寄蜉(fú)蝣(yóu)于天地，渺沧海之一粟(sù)。哀吾生之须臾(yú)，羡长江之无穷。挟（xié）飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。” &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们可以通过设置overflow 属性值（关键字）： visible：默认值，超出内容依旧可以显示但是会溢出框 scroll：阻止溢出框，超出部分可以拖动滚动条显示（无论是否溢出都显示滚动条） hidden：隐藏内容溢出部分，溢出部分不可见 auto：如果内容溢出自动出现滚动条阻止溢出 overflow：hidden &amp; 浮动 &amp; 崩塌 overflow：hidden 在前面我们介绍可以隐藏溢出内容，它还有以下功能： 清除浮动：解决由于父元素不设置高度，子元素都是浮动元素使得父元素高度为0的问题 解除坍缩：解决父、子元素非浮动元素，第一个子元素设置margin-top属性 ，等价父元素设置该属性问题 清除浮动 在前我们知道，父级元素 不设置高度时，高度随着内容增加自动适应。 但是当子元素此时设置了浮动float ，由于子元素已经脱离了文档流，父元素检测不到子元素高度，那么父元素高度 == 0。 子元素浮动依旧显示，只是父元素高度为0好似隐藏了 如果设置了父元素高度，子元素可以重新显示，超出部分溢出 比如下面黑色父级div包含了两个蓝、红子级div 。 1234567891011121314151617181920212223242526272829&lt;html&gt;&lt;head&gt;&lt;style&gt; .div &#123; background-color: black; &#125;.div1&#123; background-color: aqua; width: 100px; height: 100px;&#125;.div2&#123; background-color: red; width: 100px; height: 100px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;div&quot;&gt; &lt;div class=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如果我们把两个子级div 设置为浮动： 1234.div1,.div2&#123; float:left;&#125; 神奇的发现子级div1、div2 存在而黑色父级div 消失了！其实也就是高度变为0了。 我们有三种解决办法： 第一种：给父元素设置高度 = 100，使得父级元素不因为子元素都为浮动元素，高度自动=0 第二种：黑色父级div 设置 overflow：hidden ，使得父级元素可以包含浮动子元素 父级div 出现了，允许子元素为浮动元素：高度为子元素高度，宽度因为div 是块元素占据一行。 第三种：设置 父元素为浮动 float:left，注意这种方法会使得父元素不再有块 独占一行 的特性 乍看好像父级元素没有出现，但我们审查元素可发现div 父级标签：高度 = 子元素高度，宽度也因为设置浮动不再独占一行自动调整为子元素宽度。 特别的：如果我们设置父元素为浮动 float:right，而子元素都是左浮动，会以父元素为准： 避免崩塌 首先我们来认识什么是崩塌？依旧以最开始示例为例： 我们尝试给第一个子元素 div1 设置外边距上为50px： 1234.div1&#123; margin-top:50px;&#125; 我们期待得到的效果是： 但实际是： 就好像是给父级元素div 设置了：margin-top:50px 。要解决这个问题我们可以： 给父元素div 设置 overflow：hidden ，这样可以得到我们期待的效果 由上我们得知满足崩塌的条件： 父元素、子元素都不是浮动元素 第一个子元素设置了 margin-top属性 聪明的你也已经想到，如果子元素是浮动元素也可以完全避免崩塌（无论父元素是否浮动）。这里不详述。 第二部分：CSS3 基础样式 圆角：border-radius 我们知道在CSS世界里，万物皆为框，每个元素都可视作为框。通过 border-radius 属性可指定圆半径为R，把元素框 R*R正方形四角换成 ----&gt; 半径为 R的1/4圆形。 怎么理解 把元素框正方形四角换成1/4圆形 ？ 比如我们指定div 元素：宽 = 150px，高 = 100px ，圆半径为50px 。 可以看到，原 150px*100px 矩形，它对应四角 50px*50px 矩形区域被替换成半径 = 50px 的半圆。 ⚠️ 必须设置：圆半径 ≤ {1/2 宽，1/2 高} min ，如果超过则形成图形等价于：圆半径 = {1/2 宽，1/2 高}min 那么怎么生成圆形呢？ 显然，当框宽高相等恰为正方形，我们在把生成的四个1/4圆半径 = 1/2正方形边长。那么便可形成圆形。 1234567div&#123; width: 150px; height: 150px; background-color:aquamarine; border-radius: 75px;&#125; 进一步理解 在前面我们理解border-radius 属性为： 指定圆半径为R，把元素框 R*R正方形四角换成 ----&gt; 半径为 R的1/4圆形： 1border-radius: 50px; 实际应该为： 指定长、短半径为R1、R2，把元素框 R1*R2矩形四角换成 ----&gt; 长、短半径分别为 R1、R2的1/4椭圆形： 1border-radius: 50px / 40px; /* 只指定其中一个长度，则长短半径相等，也就是1/4圆 */ 甚至你还可以依次指定：左上 --&gt; 右上 --&gt; 右下 —&gt; 左下的1/4椭圆长短半径（顺时针） 1border-radius: 50px 40px 30px 20px / 40px 30px 20px 10px ; 尝试把指定div 元素：宽 = 150px，高 = 100px ，变为椭圆形 。 显然，只要把四角：长半径 = 1/2 宽，短半径 = 1/2 高的四个1/4椭圆形即可： 1234567div&#123; width: 150px; height: 100px; background-color:aquamarine; border-radius: 75px / 50px;&#125; 伪元素 ::before、::after 在前面我们有一个概念叫做 伪类 ，一种用来描述状态的关键字 ： 常用伪类：:hover、:link、:active、:target、:not()、:focus 等 而常用伪元素有： 常用伪元素：::first-letter、::first-line、::before、::after、::selection 等 其中伪元素 ::before、::after，特有content样式用来给内容元素 前、后 插入额外的元素 。 为什么称伪元素为 “伪” ？它有什么特点呢？ 无法审查：实际在DOM文档中没有生成这些元素，只是表面可见，审查元素没有生成 content ：特有content样式，用于添加内容，可以为空但不能省略！ 利用伪元素可以做出一些非常有意思的功能，比如各种图形、小图标等。 生成图形：菱形、六角星等 试分析：下面菱形生成代码。 123456789101112131415161718192021#test&#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 50px solid red; position: relative;&#125;#test:after &#123; content: &#x27;&#x27;; position: absolute; left: -50px; top: 50px; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 50px solid red; &#125; 生成上三角 123456789#test&#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 50px solid red; position: relative;&#125; 根据前面 border 属性设置我们可以这么生成上三角： 宽高设置为0后，上下左右四个边框角都设置为： 1border-x: 50px solid transparent; 然后 border-bottom 、 border-top颜色设置为红色，border-left、border-right 设置为透明： 最后删除掉border-top 属性设置，使得只保留下半部分，至此成功生成上三角： 最后设置的 position: relative 属性是为了方便接下来生成的伪元素进行绝对定位。 生成下三角 照猫画虎我们生成一个下三角： 12345678910#test:after &#123; content: &#x27;&#x27;; /* 为空，但不能省略*/ position: absolute; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 50px solid blue;&#125; 看到这我们对生成的下三角的初始位置不禁有些疑惑： 下三角伪元素是绝对定位：即相对于最近设置了position属性的祖先元素 ，如果没有则是包含它的框。 按照这个理论，#test 并不是 #test::after 的祖先元素为什么还相对它定位呢？ 这个不太清楚暂不提。 为什么 #test::after 绝对定位起点是*#test* 上中心点（红色三角形顶点）？不应该是左上角吗？ 第一：绝对定义不是相对于元素框的左上角，而是内容部分左上角。 第二：由于内容部分为0，所以内容左上角就是框中心点。 第三：又因为框上半部分没有，中心点上移，也就是现在红色三角形的顶点。 调整定位 最后我们调整一下生成的下三角形在上三角下方，即可生成一个菱形： 123456#test:after&#123; left: -50px; top: 50px; border-top: 50px solid red;&#125; 制作小图标 尝试制作做下面：列表左侧下三角下拉图标，注意大小。 123456789101112131415161718192021222324252627282930313233343536&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;div ul&#123; position: relative;&#125;#catalog ul::before&#123; content: &quot;&quot;; position: absolute; width: 0px; height: 0px; border-top: 8px solid red; border-right: 8px solid transparent; border-left: 8px solid transparent; left: 18px; top: 6px;&#125;div ul li&#123; text-indent: 12px; list-style-type: none;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;catalog&quot;&gt; &lt;ul&gt;我是下拉框 &lt;li&gt;我是下拉1&lt;/li&gt; &lt;li&gt;我是下拉2&lt;/li&gt; &lt;li&gt;我是下拉3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;"},{"title":"","date":"2022-01-03T13:57:21.711Z","updated":"2022-01-03T13:57:21.711Z","comments":true,"path":"NO_post/待做.html","permalink":"https://hwh.zone/NO_post/%E5%BE%85%E5%81%9A.html","excerpt":"","text":"Linux 基础系列： 实战系列：Linux 端口是否通，更换动态库版本，更换库版本比如多个Python软硬链接、放通端口、之前的八股文整理"},{"title":"数据库（二）Redis基础","date":"2022-01-02T11:36:19.077Z","updated":"2021-12-03T03:41:02.915Z","comments":true,"path":"NO_post/数据库（二）Redis基础学习.html","permalink":"https://hwh.zone/NO_post/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89Redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.html","excerpt":"","text":"一、Redis 1.1概述 redis是一款高性能的NOSQL系列的非关系型数据库 。 NoSQL(NoSQL = Not Only SQL) : “不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。为了解决大规模数据集合多重数据、高性能查询数据带来的挑战，尤其是大数据应用难题。 由缓存到redis解释。 缓存思想 直接操作数据库通常是很费时的，我们可以把在内存开辟一块区域作为缓存，存储经常访问的数据。 缓存具体实现 缓存的实现有多种，比如开辟一块内存空间使用map集合。但是： map是运行到JVM中，只能固定分配一些内存，比较小 map集合如果涉及分布式，没法部署 redis 整台机器内存都可以被redis数据库分配 可以部署分布式 NOSQL和关系型 各自优势对比 NOSQL 关系型 【性能】：NOSQL是基于键值对的，（1）不需要经过SQL层的解析，所以性能非常高（2）NOSQL数据库将数据存储于缓存之中，而不是硬盘，查询快 【复杂查询】：复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询 【存储格式】：NOSQL的存储格式是key,value形式，可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型 【安全性&amp;事务】：事务支持使得对于安全性能很高的数据访问要求得以实现 【扩展性】：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难；NOSQL基于键值对，数据之间没有关联关系，所以非常容易水平扩展 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系： 关系数据库： 所有数据存储的位置 NoSQL： 备份（缓存）关系数据库的（常用？）数据 redis的应用场景 缓存（最重要） 聊天室的在线好友列表 任务队列。（秒杀、抢购、12306等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒 分布式集群架构中的session分离 下载&amp;安装 下载 下载地址：https://github.com/tporadowski/redis/releases/ 启动 解压后分别启动： 启动服务端：redis-server.exe （不要关闭！！） 启动服务端：redis-cli.exe 安装完成开始愉快使用了。 1.2 数据结构 基本操作 redis存储的是：&lt;key,value&gt;格式的数据，其中key都是字符串，value有5种不同的数据结构 : 字符串类型： string 1234567891011# 1.存储 : set &lt;key&gt; &lt;value&gt;127.0.0.1:6379&gt; set username zhangsan ok# 2.获取: get &lt;key&gt; 127.0.0.1:6379&gt; get username &quot;zhangsan&quot;# 3.删除 127.0.0.1:6379&gt; del username (integer) 1 哈希类型 hash ： map格式 1234567891011121314# 1.存储：hset &lt;key&gt; &lt;field&gt; &lt;value&gt;127.0.0.1:6379&gt; hset myhash username lisi(integer) 1# 2.获取: hget &lt;key&gt; &lt;field&gt;127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot;127.0.0.1:6379&gt; hgetall myhash # 获取所有键值对1) &quot;username&quot; 2) &quot;lisi&quot;# 3.删除: hdel &lt;key&gt; &lt;field&gt;127.0.0.1:6379&gt; hdel myhash username (integer) 1 列表类型 list ： linkedlist格式。支持重复元素 其实更相当一个队列。 12345678910111213141516171819# 1.存储 # lpush &lt;key&gt; &lt;value1&gt;: 将元素加入列表头部# rpush &lt;key&gt; &lt;value1&gt;: 将元素加入列表尾部127.0.0.1:6379&gt; lpush myList a(integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c(integer) 3# 2.获取 ：lrange &lt;key&gt; &lt;start&gt; &lt;end&gt; 范围获取127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot;# 3.删除：# lpop key： 删除列表最左边的元素，并将元素返回 # rpop key： 删除列表最右边的元素，并将元素返回 集合类型 set ： 不允许重复元素 1234567891011121314# 1. 存储：sadd &lt;key&gt; &lt;value1&gt; &lt;value2&gt; ...127.0.0.1:6379&gt; sadd myset a b(integer) 2 127.0.0.1:6379&gt; sadd myset a(integer) 0 # 没有更新成功！# 2. 获取所有元素：smembers &lt;key&gt;127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 2) &quot;b&quot; # 3. 删除：srem &lt;key&gt; &lt;value&gt; 127.0.0.1:6379&gt; srem myset a (integer) 1 有序集合类型 zset：不允许重复元素，且元素有顺序 每个元素都会关联一个double类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。 12345678910111213141516171819202122232425# 1.存储：zadd &lt;key&gt; &lt;score&gt; &lt;value&gt; 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 # 2. 获取：zrange &lt;key&gt; &lt;start&gt; &lt;end&gt; &lt;withscores&gt;（有序）127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;zhangsan&quot;2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot;6) &quot;500&quot;# 3.删除：zrem &lt;key&gt; &lt;value&gt; 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 通用命令 **keys *** : 查询所有的键 如果不知道自己以前存储的键，可以用这个命令获取： **type ** ： 获取键对应的value的类型 但是如果想知道，“myset”对应是什么类型呢？ **del **：删除指定的key value 区分具体数据结构，如hashmap ，删除某个数据。del &lt;key&gt; 直接将存储的hashmap都删了。 1.3 持久化 redis是一个内存数据库，当redis服务器重启 / 电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 RDB（默认） 在一定间隔时间中，检测key的变化情况，然后持久化数据 。 编辑redis.windwos.conf文件 123456# after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changedsave 60 10000 （测试）设置每10s检测一下，如果至少有5个key发生改变就保存 12# after 60 sec if at least 10000 keys changedsave 10 5 然后我们修改set 类型myset集合键name 5次： 关闭服务器，和客户端。但是可以看见在redis目录下生成了dump.rdb 文件： 再次启动服务器和客户端，发生name 依旧在： AOF 日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据。 编辑redis.windwos.conf文件 首先开启AOF : 将下面修改为 appendonly yes 修改AOF模式 默认是 appendfsync everysec （每秒进行记录） appendfsync always ： 每次操作都持久化 appendfsync no ： 不进行持久化，此时redis==相当大map集合 （测试）重启服务端、客户端 首先可以发现，多了个appendonly .aof 文件 随意保存一些数据，重启数据库可以发现数据依旧存在。 1.4 Jedis快速入门 Jedis是 一款java操作redis数据库的工具。 快速实践： 123456//1. 获取连接 Jedis jedis = new Jedis(&quot;localhost&quot;,6379); //2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //3. 关闭连接 jedis.close(); Jedis操作 下面是API相关调用，先不学了。 1.5 连接池 介绍 工具栏 1.6 案例分析 先从sql数据库查询，然后可使用redis缓存一些不经常发生变化的数据 。 环境搭建 查询数据库 redis缓存优化"},{"title":"数据库（一）MySQL基础笔记","date":"2022-01-02T12:12:03.325Z","updated":"2021-12-03T03:41:02.908Z","comments":true,"path":"NO_post/数据库（一）MySQL基础笔记.html","permalink":"https://hwh.zone/NO_post/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89MySQL%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"第一章 ：初识 MySQL 1.1 MySQL 概述 SQL &amp; 各大数据库 什么是 SQL? SQL 是 Structured Query Language （结构化查询语言）缩写 ，可用来对数据库进行：增、删、查、改 等操作。 SQL 大小写特点？ 关键字：SQL 语言关键字不区分大小写，在本笔记中总是大写 表名 &amp; 列名 ：有些数据库区分、有些不区分 ，在本笔记中总是小写 不同操作系统：同一个数据库可能在Linux上区分大小写，在Windows上不区分大小写。 SQL 和各大数据库之间的关系？ SQL 已经被ANSI组织定义为标准 ，如果我们使用标准 SQL 语言，理论上所有数据都可以支持。但是各大数据都在标准 SQL 上进行了扩展。 如果只使用标准 SQL 核心功能，那么所有数据库都可以执行，而对于各个数据库各自 方言（扩展功能），只能在各自数据库下执行。 关系模型 mysql 基于关系模型，对应其也就是一般我们常说的关系数据库。 什么是关系模型？ 关系模型把数据看作是一个二维表格，任何数据都可以通过*行号 +列号* 来唯一确定： ID 姓名 班级ID 性别 年龄 1 小明 201 M 9 2 小红 202 F 8 关系数据库 同前，基于关系模型数据库都可称为关系数据库，常用关系数据库可分为： 分类 举例 商用 Oracle、SQL Server、DB2 开源 MySQL，PostgreSQL 桌面 Access：适合桌面应用程序使用 嵌入式 Sqlite：适合手机应用和桌面程序 数据类型 对于每一个关系表，需要定义：每一列名字 &amp; 每一列数据类型，常用数据类型如下 名称 类型 说明 INT 整型 4字节整数类型，范围约 ±21亿 BIGINT 长整型 8字节整数类型，范围约 ±922亿亿 REAL 浮点型 4字节浮点数，范围约 ±-1038 DOUBLE 浮点型 8字节浮点数，范围约 ±10308 DECIMAL(M,N) 高精小数 由用户指定精度的小数，例如，DECIMAL(20,10) 表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字串 存储指定长度的字符串，例如，CHAR(100) 总是存储100个字符的字符串 VARCHAR(N) 变长字串 存储可变长度的字符串，例如，VARCHAR(100) 可以存储0~100个字符的字符串 BOOLEAN 布尔 存储 True 或者 False DATE 日期 存储日期，例如，2018-06-22 TIME 时间 存储时间，例如，12:20:59 DATETIME 日期 &amp; 时间 存储日期+时间，例如，2018-06-22 12:20:59 还有一些特殊类型：JSON 等。 1.2 安装 MySQL 安装参考：MySQL-mysql 8.0.11安装教程 1.2.1 下载 点击下载 ：MySQL-8.0.16-winx64.zip 下载地址 不用登陆，直接点击下面蓝字：No thanks,just start my download ，即浏览器开始下载。 1.2.2 解压 浏览器默认下载 zip 压缩包位置：C:\\Users\\86151\\Downloads\\mysql-8.0.16-winx64.zip，解压到你指定位置。 比如我解压到：D:\\软件\\mysql-8.0.16-winx64 1.2.3 配置环境变量 常规操作：搜索 高级系统设置 --&gt; 环境变量 --&gt; 系统变量 --&gt; 选中Path --&gt; 新建： 变量值：即解压后bin所在目录地址：D:\\软件\\mysql-8.0.16-winx64\\bin。 1.2.4 初始化 my.ini 由于解压目录并没有发现 my.ini 文件，所以要自行创建，创建位置：D:\\软件\\mysql-8.0.16-winx64\\my.ini 新建 .txt 文本文件，写入： ⚠️ 注意，下面 basedir &amp; datedir ，一定是你自己的 mysql 安装目录！ 1234567891011121314151617181920212223242526[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=D:\\软件\\mysql-8.0.16-winx64 # 切记此处一定要用双斜杠\\\\# 设置mysql数据库的数据的存放目录datadir=D:\\软件\\mysql-8.0.16-winx64\\\\Data # 此处同上# 允许最大连接数max_connections=200# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 然后重名为：my.ini 即可。 1.2.5 开始安装mysql 首先注意，安装 mysql 必须以管理员身份运行 cmd ，所以win10下：搜索cmd —&gt; 以管理员身份运行 然后依次进行以下操作： 切换到 bin 目录下 1C:\\Windows\\system32&gt; cd D:\\软件\\mysql-8.0.16-winx64\\bin 初始化数据库 出现错误，一般是 my.ini 目录没有配置好，见上。 1C:\\Windows\\system32&gt; mysqld --initialize --console 注意，上图生成了一个临时密码：I_?6&gt;&amp;l*_sw( ，记住它稍后会用到。 安装服务 使用 mysqld --install [服务名] ，服务名可不写，默认为 mysql 1C:\\Windows\\system32&gt; mysqld --install 然后，通过 net start mysql 启动服务： 出错：服务无法启动。后来发现 my.ini 文件的basedir &amp; datedir 没有成功保存修为自己的安装路径。 123C:\\Windows\\system32&gt; net start mysqlMySQL 服务正在启动 .MySQL 服务已经启动成功。 其余补充（以下命令不要执行）： 12net stop mysql # 停止mysql服务sc delete MySQL/mysqld -remove # 卸载mysql服务 更改密码 首先，进入到 mysql： 1C:\\Windows\\system32&gt; mysql -u root -p 会要求输入密码，密码就是上面生成的临时密码：I_?6&gt;&amp;l*_sw( 。 正确输入后会进入出现欢迎界面： 然后，键入语句修改密码为 123456： 1mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;; 第二章 ：关系模型 2.1 主键 记录与字段 在关系数据库中，一张表中的每一行数据被称为一条记录，一条记录就是由多个字段组成的 。 id class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 如上图共有 2 条记录，每条记录有 5个字段。 主键作用 主键用来区分不同记录，如上表 id 则可用来区分不同记录。 主键选取原则 主键不得轻易修改。 主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。 任何业务相关字段不用作主键。 如，身份证号也是一种业务场景，但是如果身份证号升位、变更，主键不得不修改，对业务产生巨大影响。 同理，还有：手机号、邮箱号等。 主键 id 两种类型 通常选取和业务完全无关字段，可命名为 id ，常见 id字段类型为： 自增整数类型 数据库会在插入数据时自动为每一条记录分配一个自增不重复整数，不用自己预先生成主键。 GUID类型 如：8f55d96b-8acc-4636-8cb8-76bf8abc2f57 是一个 GUID 标识符。 GUID 即 Globally Unique Identifier（全球唯一标识符），是微软使用的一个术语，由一个特定的算法，给某一个实体，如Word文档，创建一个唯一的标识，GUID值就是这个唯一的标识码。 联合主键 关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。 id_num id_type other columns 1 A … 2 A … 2 B … 如上表，id_num &amp; id_type 同时作为主键标识每一行数据（每一条记录），允许其中一个主键重复，只要不都重复即可。 2.2 外键 什么是外键？ 在一张表中，通过某个字段，可以把数据可另一张表联系起来，这种列称为外键。 如，在下列有两张构成 一对多 关系表中： ⚠️ 一对一、一对多、多对多：描述的是两个表之间的关系，单个表不存在这种描述！ 如：下两表，class 表中 每个 班级可以对应 student 表中 多 个学生，那么这就是一对多关系； 同理，如果存在一张 studentID 表，每个学号和 student 表 每个学生 一一对应，就是 一对一关系。 ​ student id name other columns… 1 小明 … 2 小红 … ​ class id name other columns… 1 一班 … 2 二班 … 如何在 student 表中，查到小明所属哪个班级呢？ 在 student 表中加入字段 class_id ，关联 class 表： ​ student id class_id name other columns… 1 1 小明 … 2 1 小红 … 如何通过编程实现外键呢？ 首先需要在表中增加一列 class_id ，然后添加外键约束： 1234ALTER TABLE student ADD CONSTRAINT fk_class_id -- 自定义约束名 FOREIGN KEY (class_id) -- 指定student表，外键字段REFERENCES class (id); -- 指定class表，关联外键字段 如果需要删除一个外键约束： 12ALTER TABLE studentDROP FOREIGN KEY fk_class_id; 前面介绍了：一对一、一对多，那么多对多关系如何实现？ 我们知道，上面 student 表 &amp; class 表 一对多关系是单向的，一个班级可以对应多个学生，反之不成立。 如果存在两个表，有双向一对多关系，如下面 teacher 表 &amp; class 表 ： ​ teacher id name 1 张老师 2 王老师 ​ class id name other columns… 1 一班 … 2 二班 … 在这两张表中，一个老师可以对应多个班级，一个班级对应多个老师，则是双向一对多关系。 要实现 多对多 ，则通过中间表关联这两个一对多关系即可： ​ 中间表 id teacher_id class_id 1 1 1 2 1 2 3 2 1 4 2 2 2.3 索引 索引的作用？ 索引注意有两个作用：一、加快查找记录速度 ；二、通过 唯一索引 保证某一列值具有唯一性。 加快索引 如下面存在一个 student 表 ： ​ student id class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 3 1 小军 M 88 我们可以加快 score 列的查询，为其创建索引： 12ALTER TABLE student ADD INDEX idx_score(score); 当然，可以同时为 score 列 &amp; name 列创建索引： 12ALTER TABLE studentADD INDEX idx_score_name(score,name); 那么是否创建索引一定可以加快索引速度呢？ 索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。 反之，如果记录的列存在大量相同的值，如 gender 列，大约一半记录值是M，另一半是F，对该列创建索引就没有意义，甚至会降低查询速度。 唯一索引 前面说到，一些和业务相关的信息如：身份证号、邮箱地址等，不适合作为主键。但是它们又有唯一性，如何保证它们不重复呢？ 这里，我们可以为其添加唯一索引，以保证 student 表 name 唯一性为例： 12ALTER TABLE studentADD UNIQUE INDEX uni_name(name); 有没有其它保持唯一性方法？ 我们还可以添加唯一性约束： 123ALTER TABLE studentADD CONSTRAINT uni_nameUNIQUE (name); 第三章 ： 增、删、改 2.0 登 首先，打开 cmd 切换到 mysql 安装的 bin 目录下进行登陆： 1234C:\\Users\\86151&gt;cd D:\\软件\\mysql-8.0.16-winx64\\binC:\\Users\\86151&gt;mysql -u root -pEnter password: ****** 输入密码后，进行基本 增、删、改 操作（ 查询数据 下一章）。 2.1 增 2.1.1 CREATE 创建 创建数据库 语法：CREATE TABLE &lt;数据库名&gt;; 1mysql&gt; CREATE DATABASE test; -- 注意有分号 我们可以用 SHOW DATEBASES 已存在的数据库： 创建数据表 创建 class 表 语法：CREATE TABLE &lt;表名&gt; (&lt;列名&gt; &lt;列类型&gt;); 1234567mysql&gt; USE test； -- 必须要先引用数据库testmysql&gt; CREATE TABLE class -&gt; ( -&gt; id INT, -- 自动增长C -&gt; name VARCHAR(10) NOT NULL, -&gt; PRIMARY KEY(id) -&gt; ); -- 命令要以分号结束 创建 student 表 12345678910mysql&gt; CREATE TABLE student -&gt; ( -&gt; id INT , -&gt; class_id INT, -&gt; name VARCHAR(10) NOT NULL, -&gt; gender VARCHAR(1), -&gt; score INT, -&gt; PRIMARY KEY(id) -&gt; );Query OK, 0 rows affected (0.14 sec) 设置 student 表外键 我们可以进一步，为 class_id 字段设置为外键： ⚠️ 解析错误：下面其实是一条语句，加 ，会出错！ ⚠️[3780]错误：student 表外键 class_id 与 class表中 id，NULL &amp; UNSIGNED 约束要一致！（为了方便删了这两个约束） 1234mysql&gt; ALTER TABLE student -&gt; ADD CONSTRAINT fk_class_id -&gt; FOREIGN KEY(class_id) -&gt; REFERENCES class(id); 查看表 语法：SHOW TABLES； 查看已经存在的数据表名 语法： DESCRIBE &lt;表名&gt; ; 查看表详细信息 2.1.2 ALTER + ADD ALTER 主要用于字段、约束方面。 增加字段 ALTER 命令 + ADD 子句 ：可用于增加字段（增加列） student 表增加一列，名为 xw 类型为 VARCHAR(1)；（还可增加默认值） 12ALTER TABLE student ADD xw VARCHAR(1); 增加索引 student 表 字段 score增加索引 12ALTER TABLE student ADD INDEX idx_score(score); 增加主键约束 给 test_stu 表新增字段 id，并设为主键。 12ALTER TABLE test_stuADD id INT NOT NULL AUTO_INCREMENT PRIMARY KEY; 1234insert into t_user( avatar, password, id, nickname, email, type, username) values (&#x27;https://unsplash.it/100/100?image=1005&#x27;,&#x27;96e79218965eb72c92a549dd5a330112&#x27;, &#x27;1&#x27;, &#x27;管理员&#x27;, &#x27;380141202@qq.com&#x27;, &#x27;1&#x27;, &#x27;hwh&#x27;); 2.1.3 INSERT 插入数据 下面插入表数据语法，是一条语句故没有， 123INSERT INTO &lt;表名&gt; ( &lt;字段1&gt;, &lt;字段2&gt;,...&lt;字段N&gt; ) VALUES ( value1, value2,...valueN ); ⚠️ 如果数据字符类似，必须加上单/双引号，如 ：“value” class表插入数据 123456mysql&gt; INSERT INTO class(id,name) -&gt; VALUES -&gt; (1,&quot;一班&quot;), -- 多行数据以 , 分隔 -&gt; (2,&quot;二班&quot;), -&gt; (3,&quot;三班&quot;), -&gt; (4,&quot;四班&quot;); student 表插入数据 由于代码较长，用 Notepad++ 写好代码保存 test.sql：SOURCE &lt;test.sql文件地址&gt; 执行。 12345678910111213141516-- 由于代码较长，下面是在Notepad++中编辑，而非命令行中INSERT INTO student(id,class_id,name,gender,score)VALUES (1,1,&quot;小明&quot;,&quot;M&quot;,90),(2,1,&quot;小红&quot;,&quot;F&quot;,95),(3,1,&quot;小军&quot;,&quot;M&quot;,95),(4,1,&quot;小米&quot;,&quot;F&quot;,73),(5,2,&quot;小白&quot;,&quot;F&quot;,81),(6,2,&quot;小兵&quot;,&quot;M&quot;,55),(7,2,&quot;小林&quot;,&quot;M&quot;,85),(8,3,&quot;小新&quot;,&quot;F&quot;,91),(9,3,&quot;小王&quot;,&quot;M&quot;,89),(10,3,&quot;小丽&quot;,&quot;F&quot;,88);-- 下面在cmd中执行，注意不要带 ；！！mysql&gt; source D:\\hwh\\uploadToGit\\code\\mysql\\test.sql 查看表中数据 实际就是查询数据 ：SELECT * FROM &lt;表名&gt;; 2.2 删 2.2.1 DROP 删除数据库 语法：DROP DATABASE &lt;数据库名&gt;; 1mysql&gt; DROP DATABASE hwh; 删除数据表 语法：DROP TABLE &lt;表名&gt;; 1mysql&gt; DROP TABLE temp_table; 2.2.2 DELETE 删除表中记录 为了测试是否删除，在 class 表中，增加一行记录：（5，“五班”） 语法：DELETE FROM &lt;表名&gt; WHERE &lt;条件&gt;； 1mysql&gt; DELETE FROM class WHERE id=5; 经过测试，记录被删除。 2.2.3 ALTER + DROP 删除字段、默认值 ALTER 命令 + DROP 子句 ：删除字段（列）、或者删除指定默认值 删除默认值： 1mysql&gt; ALTER TABLE student ALTER bust_size DROP DEFAULT; 删除字段（列）： 1mysql&gt; ALTER TABLE student DROP bust_size; 删除主/外键约束 语法： ALTER TABLE &lt;表名&gt; DROP FOREGIN/PRIMARY KEY &lt;外键名&gt;; 1ALTER TABALE test_stu DROP PRIMARY KEY ; --主键只有一个不用指定名字 删除索引 1 2.3 改 以下操作都基于 student 表： 2.3.1 UPDATE 语法：UPDATE &lt;表名&gt; SET &lt;字段1&gt; = &lt;新值1&gt; , ... WHERE &lt;条件1&gt; [AND | OR] &lt;条件2&gt;.. ⚠️ SET 设置多个值用 ，分隔； WHERE 设置多个条件用 AND 、OR 分隔； 更新某行记录字段值 修改 id = 10 记录，name 字段值。 123UPDATE student SET name=&#x27;刘婷&#x27;,score=89 WHERE id=10; 修改所有记录某字段值 所有人成绩 +1分。 123-- 不加 WHERE 限定，同时SET可用表达式UPDATE student SET score=score+1; 2.3.2 ALTER ALTER 命令主要是在我们，修改&lt;表名&gt; ；删除或增加 &lt;字段&gt;；修改&lt;字段类型&gt;、&lt;字段名&gt;。 和 UPDATE 区别？ ALTER 比 UPDATE 着眼于更宏观的字段上，而UPDATE 是修改记录某字段 具体值 ； ALTER 不仅可以更新，还可以进行 删除、增加操作； ALTER 还可用于修改 &lt;表名&gt;。 语法格式？ ALTER TABLE &lt;表名&gt; ADD/DROP/MODIFY/CHANGE/RENAME TO/ alter_tbl; 修改字段名、类型、默认值 ALTER 命令 + MODIFY 子句 ：可用于修改 字段类型、设置初始默认值 修改 xw 类型为 INT，初始默认值 B ; ⚠️ MODIFY 、CHANGE 只能在没有默认值设置初始默认值，不能修改默认值！ 12ALTER TABLE student MODIFY xw INT DEFAULT 2; ALTER 命令 + CHANGE 子句 ：可用于修改 字段名 &amp; 类型、设置初始默认值 修改 xw 名为 bust_size ，类型为 BIGINT ; 和 MODIFY 子句不同在于：CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;类型&gt; 12ALTER TABLE student CHANGE xw bust_size BIGINT; ALTER 命令 + SET子句 ：重新设置字段默认值 123ALTER TABLE student ALTER bust_size SET DEFAULT 1; -- 默认值2--&gt;1 修改表名 ALTER 命令 + RENAME TO 子句 ：修改表名 12ALTER TABLE student RENAME TO stu; 修改存储引擎 语法：ALTER TABLE &lt;表名&gt; &lt;旧引擎名&gt; = &lt;新引擎名&gt;; 第三章 ：查询数据 3.1 基本查询 SELECT * FROM &lt;表名&gt; 这是不带 WHERE 条件进行查询，查询显示：指定表所有数据。 1SELECT * FROM students; SELECT &lt;数学表达式&gt; SELECT 可用于数学计算，但那并不是强项，但可用于检测数据库了解是否有效。 1mysql&gt; SELECT 1+1; 3.2 条件查询 条件表达式 条件 举例1 举例2 说明 = score = 80 name = ‘abc’ 字符串需要用单引号括起来 &gt; score &gt; 80 name &gt; ‘abc’ 字符串比较：ASCII码；中文比较：根据数据库设置 &gt;= score &gt;= 80 name &gt;= ‘abc’ &lt; score &lt; 80 name &lt;= ‘abc’ &lt;= score &lt;= 80 name &lt;= ‘abc’ &lt;&gt; score &lt;&gt; 80 name &lt;&gt; ‘abc’ &lt;&gt; ：用于判断不相等，如举例1表示 score ≠ 80 LIKE name LIKE ‘ab%’ name LIKE ‘%bc%’ 判断相似：%表示任意字符。例如'ab%'将匹配 ‘ab’，‘abc’，‘abcd’ NOT、AND、OR NOT、AND、OR 可用于组成多条件查询，同时可配合 () 改变优先级。 SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt; 查询 student 表成绩80分以上男生，但不包含小兵。 123SELECT * FROM student WHERE NOT name=&#x27;小兵&#x27; AND score &gt; 80 AND gender=&#x27;M&#x27;; 其实，NOT 等价于 &lt;&gt; : 123SELECT * FROM studentWHERE name &lt;&gt; &#x27;小兵&#x27; AND score &gt; 80 AND gender = &#x27;M&#x27;; SELECT (列1，列2…) FROM &lt;表名&gt; WHERE &lt;条件&gt; 这种方式也称为 投影查询，结果集合只包含指定列，而非所有列。 查询 student 表成绩80分以上男生，但不包含小兵，结果只显示 id 、name 两列。 123 SELECT id,name FROM student WHERE name &lt;&gt; &#x27;小兵&#x27; AND score &gt; 80 AND gender = &#x27;M&#x27;; 3.2 查询进阶 3.2.1 排序 单条件查询 [单排序条件] 按一班成绩升序排列，并同时显示ta们：id、姓名、成绩。 1234SELECT id,name,scoreFROM student WHERE class_id = 1 ORDER BY score ; ⚠️ WHERE 要放在 ORDER BY 前，否则出错； 如果要降序：查询语句末加上 DESC 即可。 多条件查询 [多排序条件] 按一班成绩升序排列，成绩相同按性别降序，并同时显示ta们：id、姓名、成绩。 1234SELECT id,name,score FROM studentWHERE class_id = 1 ORDER BY score ,gender DESC ; 对于每个排序条件都要指定升序、降序：这里score默认升序、gender降序； gender值 是字符串，按ASCII 码规则进行排序。 3.2.2 分页 分页，解决 SELECT 查询时，数据量太多，指定显示 某页 数据。 其语法格式：&lt;SELECT查询&gt; LIMIT &lt;每页显示记录数&gt; OFFSET &lt;记录偏移量&gt; 查询实例 查询所有学生成绩降序排序，显示第二页数据，每页4条记录。 1234SELECT id,class_id,name,scoreFROM studentORDER BY score DESCLIMIT 4 OFFSET 4 ; -- (2-1)*4 = 4：0-3为第一页4条记录，第4条记录即是第二页第一条记录 显示第n页数据：LIMIT OFFSET * size 查询结果 3.2.3 多表查询 多表查询：返回的是笛卡尔乘积，即一张有n记录表 &amp; 一张m记录表 —&gt; 查询结果 m*n 记录表。 查询实例 查询 student 表、class 表，显示笛卡尔乘积结果。 12SELECT *FROM student s, class c; 查询 student 表、class 表，1班男生成绩降序排序。 1234SELECT s.id &#x27;学号&#x27;, c.id &#x27;班级号&#x27;,s.name &#x27;名字&#x27;,s.score &#x27;成绩&#x27;FROM student s, class cWHERE s.gender = &#x27;M&#x27; AND c.id = 1ORDER BY s.score DESC; student 表 &amp; class 表分别使用了别名 s 和 c ；查询结果列名也可以使用别名； 这样查询表，其实是在它们的 笛卡尔乘积表中查询。 查询结果 笛卡尔乘积查询结果1 查询结果2 123456789+--------+-----------+--------+--------+| 学号 | 班级号 | 名字 | 成绩 |+--------+-----------+--------+--------+| 3 | 1 | 小军 | 96 || 1 | 1 | 小明 | 91 || 9 | 1 | 小王 | 90 || 7 | 1 | 小林 | 86 || 6 | 1 | 小兵 | 56 |+--------+-----------+--------+--------+ 3.2.4 连接查询 查询 student 表中，显示学生信息[id、姓名、班级名、成绩]，要包含班级名称。 这题难点在于，班级名(name)在 class 表中， student 表中只有 class_id 。 如果用上面多表查询 要生成笛卡尔积表效率太低，所以我们使用连接查询。 内连接 内连接中，没有主表，只分为左右表。 原理：用从左表中取出每一条记录，去与右表中所有记录匹配，满足ON &lt;连接条件&gt; 被保留。 没有 ON &lt;连接条件&gt; ，将会生成成笛卡尔积表。 查询实例 1234SELECT s.id,s.name,c.name,s.scoreFROM student sINNER JOIN class cON s.class_id = c.id; INNER JOIN class c ：使得可以 SELECT 使用 class 表中name ; 将左表记录N_i 与 右表记录 M_j 比较，如果字段 s.class_id = c.id ，那么记录N_i 保留。 也就是说，比较次数 = 左表记录数 * 右表记录数，这比直接生成笛卡尔表查询高效。 查询结果 1234567891011121314+----+--------+--------+-------+| id | name | name | score |+----+--------+--------+-------+| 1 | 小明 | 一班 | 91 || 2 | 小红 | 一班 | 96 || 3 | 小军 | 一班 | 96 || 4 | 小米 | 一班 | 74 || 5 | 小白 | 二班 | 82 || 6 | 小兵 | 二班 | 56 || 7 | 小林 | 二班 | 86 || 8 | 小新 | 三班 | 92 || 9 | 小王 | 三班 | 90 || 10 | 刘婷 | 三班 | 90 |+----+--------+--------+-------+ 左外连接 左外连接中，左表为主表。 原理：以左表为主表，从里面取每一条记录和右表进行连接，分两种情况 满足ON &lt;条件&gt; 能匹配：保留该记录； 不满足ON &lt;条件&gt; 能匹配：保留该记录，但是其它字段置为NULL。 右外连接 右外连接中，右表为主表。 原理：同上。 查询实例 1234SELECT s.id,s.name,c.name,s.scoreFROM student sRIGHT OUTER JOIN class cON s.class_id = c.id; 把右表当主表去匹配左表：满足ON条件，正确保存；不满足，其余字段置为 NULL 。 查询结果 123456789101112131415+------+--------+--------+-------+| id | name | name | score |+------+--------+--------+-------+| 1 | 小明 | 一班 | 91 || 2 | 小红 | 一班 | 96 || 3 | 小军 | 一班 | 96 || 4 | 小米 | 一班 | 74 || 5 | 小白 | 二班 | 82 || 6 | 小兵 | 二班 | 56 || 7 | 小林 | 二班 | 86 || 8 | 小新 | 三班 | 92 || 9 | 小王 | 三班 | 90 || 10 | 刘婷 | 三班 | 90 || NULL | NULL | 四班 | NULL |+------+--------+--------+-------+ 3.2.5 子查询 子查询分类 子查询按对返回结果集调用方法，可分为： WHERE 子查询：把内层查询结果当做外层 查询条件； FROM 子查询：把内层查询结果当做外层 查询集合； EXISTS 子查询：把外层查询结果拿到内层，看内层查询是否成立。 IN 、ANY、SOME、ALL 最典型的当 WHRER 子查询结果，不是标量（一行一列），而是一个集合（多行多列）。 此时，不能使用：= &gt; &lt; &gt;= &lt;= &lt;&gt; 这些比较标量操作符；而用IN、ANY（SOME）、ALL 操作符。 IN：判断查询的表达式是否在子查询列表中，返回满足in列表中的满足条件的记录。 ANY：ANY关键字必须在一个比较操作符后面，表示与子查询返回任何值比较为 TRUE ，则返回 TRUE ； ALL：ALL关键字必须在一个比较操作符后面，表示与子查询返回所有值比较为 TRUE ，则返回 TRUE 。 子查询实例 查询实例1 获取所有比刘婷成绩好的男同学，学号、姓名、成绩。 12345678SELECT id,name,scoreFROM studentWHERE score &gt; ( SELECT score FROM student WHERE name = &#x27;刘婷&#x27; -- 这里没有 ;); 查询比刘婷成绩好的同学为父查询·····；由于刘婷成绩未知，所以还需要一个子查询查询刘婷成绩。 WHERE 子查询字段 == 父查询字段！（都只有 score） 查询实例2 新建一个 test_stu 表查询：test.sql 找出语文和数学都及格的同学名字。 12345678SELECT name FROM test_stuWHERE score &gt;= 60 AND project = &#x27;语文&#x27; AND name IN( SELECT name FROM test_stu WHERE score &gt;= 60 AND project = &#x27;数学&#x27;); 很明显要子查询，要查出语文成绩及格同学，可做父查询条件之一 ；然后把子查询查询数学结果做父查询条件之二。 一开始想用 FROM 子查询 限制查询集合，似乎并不太好用。 查询结果2 123456+--------+| name |+--------+| 张三 || 赵六 |+--------+ 3.2.6 聚合 ： 分组 &amp; 简单函数 函数只能在 SELECT 中使用？？ 聚合 &amp; 简单函数 聚合配合函数：用来统计表中信息，如总人数、平均分、最高分等。 聚合 &amp; count() 统计 student 表学生总人数。 1SELECT COUNT(*) stu_num FROM student; count(*) : 参数 * 代表统计所有列； stu_num : 是设置的别名。 12345+---------+| stu_num |+---------+| 10 |+---------+ 聚合 &amp; SUM()、AVG() 注意，SUM()、AVG() 用来计算一列总和/平均值，必须要是 数值类型 ( count() 是统计列，和类型无关) 。 统计女生总分，和平均分。 123SELECT SUM(score),AVG(score) FROM studentWHERE gender = &#x27;F&#x27;; SELECT name ,SUM(s.score),AVG(s.score) 不行，每个女生都有总分/平均分? 12345+------------+------------+| SUM(score) | AVG(score) |+------------+------------+| 434 | 86.8000 |+------------+------------+ 聚合 &amp; MIN() 、MAX() MAX()和MIN()不限于数值类型,如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。 统计学生中最高分，并同时显示姓名、班级、分数。 该题难点在于，由于还是显示班级，需要连接 class 表。 ON 条件：还想同时 MAX() 找出最高分，不太可行，用来给 student 表增加一列 c.name就行。 WHERE 条件：然后给新连接表找出最高分。 123456789SELECT s.name,c.name,s.scoreFROM student sINNER JOIN class cON s.class_id = c.idWHERE s.score &gt;= ALL ( SELECT score FROM student); 进一步优化：利用 MAX() 函数 123456789SELECT s.name,c.name,s.scoreFROM student sINNER JOIN class cON s.class_id = c.idWHERE s.score = -- 尝试 WHERE s.score = MAX(score) 出错，只能在SELECT中使用？( SELECT MAX(score) FROM student); 聚合 &amp; 分组 单条件分组 在前面，我们利用 coutn(*) 函数，可以很快统计出学生总数，但是如果要分别统计出男/女生数呢？难道，分别用 WHERE 条件限制一下再统计吗？ 如果，表可以分为两男、女两组，函数分别会分别统计两组信息再显示多好呀！ 分别统计出男/女平均分、学生总数。 123SELECT gender,AVG(score),COUNT(*)FROM studentGROUP BY gender; 这也就相当于：表分为男女两组，函数会分别计算两次 。 我们可以 SELECT gender ，但是下列语句会出错： 1SELECT class_id,gender,AVG(score),COUNT(*) -- 第一句SELECT增加class_id 因为，按性别分组，每个性别都要若干学生，自然对应多个班级 class_id ,试问如何显示？ 123456+--------+------------+----------+| gender | AVG(score) | COUNT(*) |+--------+------------+----------+| M | 83.8000 | 5 || F | 86.8000 | 5 |+--------+------------+----------+ 多条件分组 在 单条件分组 我们说到，下面写法是错误的： 123SELECT class_id,gender,AVG(score),COUNT(*) -- 第一句SELECT增加class_idFROM studentGROUP BY gender; 原因是：按 gender 分组只能分为 M/F 两组，显示只有两行统计结果，而每一行M/F都包括多个class_id ，没法显示，也不合逻辑。现在思考一个问题： 查询每个班级的男/女生平均分？ 123SELECT class_id,gender,AVG(score)FROM studentGROUP BY gender,class_id; 为什么这里又可以显示了？其实整个逻辑如下： 先按 class_id 分为 3 组，然后每组又按 gender 分为 2 组，所以总共是 6 组可以显示出来。 12345678910+----------+--------+------------+| class_id | gender | AVG(score) |+----------+--------+------------+| 1 | M | 93.5000 || 1 | F | 85.0000 || 2 | F | 82.0000 || 2 | M | 71.0000 || 3 | F | 91.0000 || 3 | M | 90.0000 |+----------+--------+------------+ 第四章：事务 4.1 事务简介 简单来说，事务就是让多个操作要么全部执行，要么全不执行，保证数据统一性。 比如，A向B进行转账必须保证，A 、B账户一方增，一方必须减。 1234-- 第一步：将id=1的A账户余额减去100UPDATE accounts SET balance = balance - 100 WHERE id = 1;-- 第二步：将id=2的B账户余额加上100UPDATE accounts SET balance = balance + 100 WHERE id = 2; 显然，这两条语句必须全部执行，但上面语句无法保证，这就需要开启事务。 隐式事务 对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为隐式事务。 显示事务 手动把多条事务作为一个事务执行，使用 BEGIN &lt;多条SQL语句操作&gt; COMMIT 形式。比如上面转账： 1234BEGIN; -- 分号UPDATE accounts SET balance = balance - 100 WHERE id = 1;UPDATE accounts SET balance = balance + 100 WHERE id = 2;COMMIT; -- 分号 COMMIT &amp; ROLLBACK 上面最终选择提交更新，如果写完SQL语句但又不想提交更新呢？可以用 ROLLBACK 撤销操作： 1234BEGIN; -- 分号UPDATE accounts SET balance = balance - 100 WHERE id = 1;UPDATE accounts SET balance = balance + 100 WHERE id = 2;ROLLBACK; -- 分号 4.2 隔离级别 概况：避免多个并发执行事务，对 同一条记录 进行操作，带来的数据不一致问题。 SQL 标准定义4种隔离级别，不同程度 的避免出现数据不一致情况。 同时，在MySQL中，使用 innoDB 默认隔离级别是 Repeatable Read 。 Isolation Level 脏读 不可重复读 幻读 隔离级别 概括 Read Uncommitted Yes Yes Yes 最低 脏读：两次读，中间撤 Read Committed - Yes Yes 较低 不可重读：两次读，中间更 Repeatable Read - - Yes 较高 幻读：两次读，中间插 Serializable - - - 最高 Read Uncommitted 根据上表，我们知道，Read Uncommitted 可能出现脏读。 什么是脏读？最终读取到已不在表中数据。 多并发下，事务A进行了更新操作，在事务B进行连续两次读过程中，发生撤回更新操作，导致读取无效C。 两次读，中间撤 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; 2 BEGIN; BEGIN; 3 UPDATE student SET score= 65 WHERE id = 1; 4 SELECT * FROM student WHERE id = 1; 5 ROLLBACK; 6 SELECT * FROM student WHERE id = 1; 7 COMMIT; 时刻3：事务A，更新 student 表设置分数为65； 时刻4：事务B，读到刚刚更新的分数65； 时刻5：事务A取消更新分数操作，导致上一个分数实际不是正确分数； 时刻6：验证性操作，再次读取数据发现分数和时刻4读取的不一致。 Read Committed 根据上表，我们知道，Read committed 可能出现不可重复读。 什么是不可重复读？两次连续读取的数据不一致，但最终读取的数据在表中。 在多并发下，事务B在进行两次读过程中，事务A恰好更新了数据，导致两次读取数据不一致。 两次读，中间更 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL READ COMMITTED; SET TRANSACTION ISOLATION LEVEL READ COMMITTED; 2 BEGIN; BEGIN; 3 SELECT * FROM studentWHERE id = 1; 4 UPDATE student SET score= 65 WHERE id = 1; 5 COMMIT; 6 SELECT * FROM student WHERE id = 1; 7 COMMIT; ❔ Read Committed下为什么不会出现脏读呢？ 💭 我的理解是，Read Committed 下只能读取到已经 COMMIT 更新的数据，不能读取未 COMMIT 操作数据。 ​ 脏读是未 COMMIT 前更新操作然后撤回又读取导致，所以也就不会出现脏读。 Repeatable Read 根据上表，我们知道，Repeatable Read 可能出现幻读。 什么是幻读？连续两次读，第一次不存在，但可以更新，更新后再次读取竟然又存在。 两次读，中间插 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; 2 BEGIN; BEGIN; 3 SELECT * FROM student WHERE id = 99; 4 INSERT INTO student (id, name) VALUES (99, ‘Bob’); 5 COMMIT; 6 SELECT * FROM student WHERE id = 99; 7 UPDATE student SET name = ‘Alice’ WHERE id = 99; 8 SELECT * FROM student WHERE id = 99; 9 COMMIT; 第6时刻：⚠️ 此时没有出现不可重复读，第6时刻读取到 id = 99 数据还是空。 第7时刻：但是发现可以更新数据，而且此时再去读取 id = 99 数据发现成功了！！AMAZING! ❔ 如果第 4 步是 UPDATE 操作 ，会出现不可重复读吗？ 💭 我猜测不会，因为 INSERT 操作也是更新，但是第6时刻读取数据为空？ 🕵 Repeatable Read 在同一个事务内的查询与事务开始时刻一致，在B事务过程中不会读到期间A中更新值。 Serializable Serializable是最严格的隔离级别，但是效率最低，一般不会设置。 在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。 第五章 ：存储过程和触发器"},{"title":"Java基础笔记","date":"2022-01-02T11:54:25.531Z","updated":"2021-12-03T03:41:02.893Z","comments":true,"path":"NO_post/JAVA基础笔记.html","permalink":"https://hwh.zone/NO_post/JAVA%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"第一章：初识java 1.0 快捷键 Alt + \\ : 查看本来所有方法，变量 Ctrl+Alt ： 跳出虚拟机 1.1 JDK安装与配置 JDK下载 下载地址：官网JDK下载 下载完毕后： 下载是exe文件，安装 到 D:/JDK 文件夹下（没有自己新建JDK文件夹） 下载是压缩包，解压到相应 D:/JDK 文件夹下即可。 配置环境变量（win10） 首先打开 系统属性—&gt;高级----&gt;环境变量： 如上图所示，新建一个系统变量JAVA_HOME: 接着选择编辑PATH变量： 选择新建一个%JAVA_HOME%\\bin ，并移动到最上方： %JAVA_HOME% : 表示引入的 前一个 系统变量 JAVA_HOME 路径 记得依次点击确定保存，关闭环境变量设置。 验证是否成功 win + r ---&gt; cmd ----&gt; java -version 查看，显示版本号则按照成功： 1.2 IDE : intelliJ IDEA 下载 &amp; 安装 官网地址：官网下载IDEA 傻瓜似安装，注意安装过程选择64位。 注册激活 第一次打开IDEA时会要求你注册激活，选择输入激活代码，博客激活码地址： 激活地址，第二个可用 1.3 第一个项目:HELLOJAVA 创建项目 选择 File–&gt;New–&gt;Project ,SDK 选择 安装 JDK 所在目录（同上）： 下一步选择 Project 所在文件夹： ⚠️ 先创建一个文件夹用来保存项目，该步不会自动创建一个Projiect对应文件夹！ 第一个 JAVA 文件 为了方便管理，可以先创建一个 Package（类似 C# 命令空间）。 右键选择 src---&gt; new ---&gt; package ，比如新建 package 名为：HELLOJAVA； 右键选中 HELLOJAVA 包，HELLOJAVA--&gt; new --&gt; class ，新建类名为 hello： 编辑hello.java 1234567public class hello //选择创建class，会自动创建同名类名&#123; public static void main(String[] args) //里面参数不能少 &#123; System.out.println(&quot;Hello JAVA&quot;); &#125;&#125; 配置 这个时候直接运行是运行不了的，还要设置一些东西，点击下图按钮添加配置信息： 选择模板 &amp; 主函数位置： 运行 选择 hello.java文件，右键选择 run “hello.main()” 即可。 第二章 ：JAVA基本知识 2.1 面对对象 实战 设计一个Hero 类对象VN，有一些属性；有加血函数等。 在Hero类中 12345678910111213public class Hero&#123; //设计一些属性 String name; //String 第一个S是大写 int HP; int moveSpeed; //函数：加血 void addHP(int blood) &#123; HP += blood; System.out.println(&quot;加血!&quot;); &#125;&#125; 在Hello类中 1234567891011121314151617public class hello&#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello JAVA&quot;); // 调用item类，实例出一个对象 Hero i = new Hero(); i.name = &quot;vn&quot;; i.HP = 2000; i.addHP(200); &#125;&#125;/* 输出结果： Hello JAVA 加血!*/ 总结 java 面对对象和 C# 目前有以下区别： java 每次 new --&gt; class ，在这个新类中只能写一个类，有多个类会报错 System.out.println 还不太熟，官方文档语焉不详的，待摸索怎么读官方文档。 2.2 变量 变量类型 整型 int（4种） 类型 缺省值 长度 范围 byte 0 8 -128 ~ 127 short 0 16 -32768 ~ 32767 int 0 32 -2147483648 ~ 2147483647 long 0 65 -9223372036854775808 ~ 9223372036854775807 即使声明 long 类型，也要以 L或者l结尾，否则是int类型 12long val = 1234567890; // 报错，被当成int类型超出范围long val = 1234567890L; // 正确 int 类型 也可以表示 4种进制 1234int decVal = 26; //默认int型int hexVal = 0x1a; //16进制int oxVal = 032; //8进制int binVal = 0b11010; //2进制 字符型 char 可以用char 类型表示一些转义字符： 1234567//以下是转义字符char tab = &#x27;\\t&#x27;; // 制表符char carriageReturn = &#x27;\\r&#x27;; // 回车char newLine = &#x27;\\n&#x27;; // 换行char doubleQuote = &#x27;\\&quot;&#x27;; // 双引号char singleQuote = &#x27;\\&#x27;&#x27;; // 单引号char backslash = &#x27;\\\\&#x27;; // 反斜杠 浮点型 float、double float 类型表示浮点数（整数时不报错）时要加f ： 12float f = 123.456; //报错，一定要加ffloat f1 = 123.456f; // 正确 double 类型表示浮点数不用加： 12double d = 123.456; //正确double d1 = 1.23456e2 // 科学技术法 = 1.23456 * 10^2 2020-12-30 总结： 在java中，long、float（double不用）类型，变量值还要+前/后缀对应，才能正确定义。 布尔型 boolean 1boolean b1 = true; 字符串 String String 类型其实并不是基本类型 , 而是 lmmutable 类型 ；而且一旦创建不能别改变。 这里一旦创建不能被改变，不能改变内容但是可以改变引用指向，比如下面： 12String str = &quot;hello&quot;;str = &quot;hello world&quot;; //改变成功，改变了引用 实际上又成功改变了，因为改变了str 原来指向“hello” —&gt; 转为指向 “hello world” 类型转换 低精度向高精度转换 这种转换是不需要强制转换的，默认转换就可以。 高精度向低精度转换 和以前学的无太大区别，注意以下几点： short &amp; char 转换 虽然二者位数相同但是还是要强制转换 123char c = &#x27;A&#x27;;short s = 80;c = (char) s; // 强制转换 int 以下数据相加 在 java 世界里，如果精度 &lt; int 进行 数值运算会被自动提升到int类型 123short a = 1;short b = 2;System.out.println(getType(a+b)); // int类型 也就是说下面必须要强制转换 : 1short c = (short)(a + b); // ※ ※ ※ 注意理解 ※ ※ ※ 变量修饰 final 当一个变量被 final 修饰的时候，该变量只有一次赋值的机会。 12final int i = 1;i = 5 // 出错，i已经被赋值过来 特别的注意，当 final 修饰参数时： 1234567public class HelloWorld&#123; public void method1(final int j) &#123; j = 5; //这个能否执行？ &#125;&#125; 此时是不能执行的，因为调用方法是 实参赋值给形参，j = 5 不能再赋值了。 2.3 输入、输出 输出 Println 字符串直接可以**+**连接，涉及到复杂一般还是 format ： 1System.out.println(&quot;hello&quot;+&quot; world &quot;); // 输出：hello world format %s ：表示字符串 %n：表示换行符 %d：表示整数 %8d，（默认）右对齐，占8长度 ；%-8d，左对齐，8长度；%08d，长度8不够补0。 12System.out.format(&quot;%08d，%n&quot;,123); // 输出 00000123System.out.format(&quot;%08d&quot;,123.45); // 出错，不能是浮点数 %f：表示浮点数 %.2f，表示保留两位小数。 1System.out.format(&quot;%.1f&quot;,123.456); // 四舍五入，保留一位小数：123.5 输入 输入一般是用 Scanner类 来捕捉用户输入。 基本使用 12345678910111213141516import java.util.Scanner; // 1. 引用Scanner类public class hello&#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); // 2. 实例化 Scanner对象 System.out.println(&quot;请输入一个整数&quot;); int a = s.nextInt(); // 读入整数 System.out.println(&quot;输入整数为 ：&quot; + a); System.out.println(&quot;请输入一行字符串&quot;); String str1 = s.nextLine(); // 3.读取回车键 String str1 = s.nextLine(); //读入字符串 System.out.println(&quot;输入字符串为 ：&quot; + str1); &#125;&#125; 读入输入数据首先需要引用 Scanner类 ，且实例化 整数、浮点数、字符串…都有对应 nextInt() 、nextFloat() 、nextLine() 等方法 特别注意 nextLine() 方法，前面有如 ：nextInt()读入数据 + 回车 ， 会读入回车~ 2.4 控制流程 switch switch 可以使用 byte,short,int,char,String,enum 2.5 数组 声明 &amp; 创建 一维数组 12345678910// 1.声明一个引用int a[]; int[] a;// 2.分配空间a = new int[5];// 3.分配空间 &amp; 赋值a = new int[5]&#123;1,2,3,4,5&#125;;a = new int[]&#123;1,2,3,4,5&#125;; // 省略：(1) [数组大小]a = &#123;1,2,3,4,5&#125;; // 省略：(1) [数组大小] (2) new 分配符 二维数组 12345678910// 1.声明一个引用int[][] a;// 2.分配空间int[][] a = new int[2][3];int[][] a = new int[2][]; // 虽然一维数组长度被省略，但是要访问必须指定一维数组长度// 3.分配空间 &amp; 赋值int[][] a = new int[][]&#123; &#123;1,2,4&#125;, &#123;4,5&#125;, &#123;6,7,8,9&#125;&#125;;int[][] a = &#123; &#123;1,2,4&#125;, &#123;4,5&#125;, &#123;6,7,8,9&#125;&#125;; // 省略：(1) [][] (2) new 分配符 增强型for循环 举例 循环打印数组内容。 12345int[] arr = &#123;1,2,3&#125;;for(int item : arr) // 类比C#：foreach(int item in arr)&#123; System.out.println(item);&#125; 输出 1234//输出 1 2 3 常用数组操作 复制 用 Arrays 类 实现： 首先注意，需要引用：import java.util.Arrays; 1234567891011121314/* 复制数组 : Arrays.copyOfRange(int[] original, int from, int to) - original : 被复制的数组 - from：复制起始位置 - to： 复制结束位置*/int[] srcArr = &#123;1,2,3,4,5&#125;;int[] destArr ; // 下面复制：自动给目标数组分配空间destArr = Arrays.copyOfRange(srcArr, 0, arr.length); for (int item : b)&#123; System.out.print(item + &quot;&quot;);&#125; 合并 以下利用系统方法 复制实现合并两个数组： 123456789101112131415161718/* 复制数组 : System.arraycopy(src, srcPos, dest, destPos, length) - src : 被复制的数组 - srcPos：被复制数组起始位置 - dest：目标数组 - destPos：复制到目标数组的起始位置 - length ：复制的长度*/int[] arr1 = &#123;1,2,3,4,5&#125;;int[] arr2 = &#123;6,7,8&#125;;int[] arr3 = new int[arr1.length + arr2.length];System.arraycopy(arr1, 0, arr3,0 ,arr1.length); // 必须新数组长度容下前2个数组System.arraycopy(arr2, 0, arr3,arr1.length ,arr2.length);for (int item : arr3)&#123; System.out.print(item + &quot;&quot;); // 最终输出： 1 2 3 4 5 6 7 8&#125; 转换成字符串 12345678/* 转字符串 :Arrays.toString(src); - src : 被转换的数组*/int[] srcArr = &#123;1,2,3,4,5&#125;;String content = Arrays.toString(srcArr);System.out.println(content); // 输出：[1, 2, 3, 4, 5] 排序 123456789/* 排序 : Arrays.sort(src); - src : 被排序的数组 返回值 : 无返回值！*/ int[] srcArr = &#123;1,2,3,4,5&#125;; Arrays.sort(srcArr); // 无返回值 System.out.println(Arrays.toString(srcArr)); // 输出：[1, 2, 3, 4, 5] 二分查找（必须先sort排序！） 12345678910/* 查找 : Arrays.binarySearch(src,elem); - src : 被搜索的数组 - elem : 被搜索的元素 返回值 : 被搜索元素的位置*/ int[] srcArr = &#123;1,2,3,4,5&#125;; Arrays.sort(srcArr); // 无返回值 System.out.println(Arrays.binarySearch(srcArr, 3)); // 输出：2（从0计数） 判断是否相同 System.out.println(Arrays.equals(a, b)); 填充 使用指定元素值，填充数组。 123int a[] = new int[3];Arrays.fill(a, 6); System.out.println(Arrays.toString(a)); // 输出：[6,6,6] 第三章：类和对象 3.1 基本概念 引用 区分 引用 与 = ? 12int h = 5; // 此时 = 表示赋值 ，h 是变量Hero h1 = new Hero(); // 此时 = 表示指向，h1 是引用 一个对象，有多个引用 12Hero h1 = new Hero();Hero h2 = h1; //h2指向h1所指向的对象 一个引用，有多个对象 下面 两次 new Hero() 产生了两个对象 12Hero garen = new Hero(); // garen 指向Hero对象1garen = new Hero(); // garen 指向Hero对象2 但是，同一时间只能指向同一个对象，所以对象1没有引用指向。 继承 使用 extends 关键字来实现继承： 123456789101112// 物品类public class Item&#123; String name; String price;&#125;// 草鞋类public class shone extends Item &#123; int speed;&#125; 参数 this参数 this 代表当前对象。 类函数参数 和 属性重名，this.属性名 访问属性 构造方法中调用另一个构造方法 ，this(参数) 传参（引用类型传参） 尝试写出下面程序输出结果。 12345678910111213141516171819202122232425/* 写出下面输出结果 */public class Hero &#123; String name; //姓名 float hp; //血量 public Hero(String name,float hp) &#123; this.name = name; this.hp = hp; &#125; //复活 public void revive(Hero h) &#123; h = new Hero(&quot;提莫&quot;,383); &#125; public static void main(String[] args) &#123; Hero teemo = new Hero(&quot;提莫&quot;,383); teemo.hp = teemo.hp - 400; // 受到400伤害，挂了 teemo.revive(teemo); // 复活 System.out.println(teemo.hp); &#125; &#125; 输出结果： -17 , 即原来死去teemo血量 虽然是传递引用，但是在 revive 方法中，此时 hp = 383 ; 退出方法后，h 指向的临时对象被销毁。 执行revive方法前，引用teemo指向 死去teemo对象 ； 执行revive方法时，引用teemo 复制一份给形参 h ，teemo 和 h 都是指向同一个对象；但是，形参引用h 又new了份新内存，现在它指向的是新Hero对象(无名) 。 参考这篇文章：对象传参 执行revive方法后，引用h 指向对象被销毁，引用teemo 始终指向死去teemo对象。 访问修饰符 似乎没有说，对象访问权限？ 下图，是类中属性、方法被修饰后各种情况访问权限。绿色表示可以访问；红色表示不可以。 静态方法和属性 静态属性static 什么时候使用？ 如果一个属性，每个英雄都不一样，比如name，这样的属性就应该设计为对象属性，因为它是跟着对象走的，每个对象的name都是不同的。 如果一个属性，所有的英雄都共享，都是一样的，那么就应该设计为类属性 = 静态属性。 静态方法static 什么时候使用？ 如果方法里访问了对象属性，那么这个方法，就必须设计为对象方法； 如果一个方法，没有调用任何对象属性，那么就可以考虑设计为类方法。 比如取随机数 ：Math.random() 其它特性 静态方法不能调用非静态方法、成员 ；反之却可以。 实例成员变量是属于某个对象的，而静态方法在执行时，并不一定存在对象。所以，不允许，静态方法调用实例成员变量。 对象属性初始化 初始化方法 注：静态属性初始化，除了第三种：不能在构造函数（*非静态函数不能调用静态属性？*可以！见前。）初始化，其余都可以！ 1234567891011121314public class Hero &#123; // 1.声明属性时 public String name = &quot;first&quot;; // 2.初始化块时 &#123; name = &quot;second&quot;; &#125; // 3.构造函数时 public Hero() &#123; name = &quot;third&quot;; &#125; &#125; 初始化顺序 那么问题来了，上述代码 name 最终被初始化 ？ 初始化属性： 静态变量 --&gt; 静态初始化块 --&gt; 变量 --&gt; 初始化块 --&gt; 构造器 所以，答案是 ： third。 3.2 单例模式 2020-12-23 总结： 单例模式应用场景 &amp; 特点 【场景】 例1：回收站。在windows桌面上打开了一个回收站，当我们试图再次打开一个新的回收站时，Windows系统并不会为你弹出一个新的回收站窗口。也就是说，在整个系统运行的过程中，系统只维护一个回收站的实例。这就是一个典型的单例模式运用。 例2：网站计数器。 网站的计数器，一般采用单例模式实现。如果存在多个计数器，每一个用户访问都刷新计数器值，计数值难以同步。 例3：程序日志。 web开发中读取配置文件都适合使用单例模式，如HttpApplication 就是单例的典型应用。 【特点】 优点：实现了对唯一实例访问的可控；对于一些需要频繁创建和销毁的对象来说可以提高系统的性能。 缺点： 不适用于变化频繁的对象； 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出； 如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失。 单例模式三元素 构造方法私有化 静态属性指向实例 public static的 getInstance方法，返回第二步的静态属性 饿汉单例模式 饿汉式 ：是立即加载的方式，无论是否会用到这个对象，都会加载 举例 ：数据库连接，构造立即初始化，启动时感觉会卡顿。 1234567891011121314public class GiantDragon &#123; // 1.私有化构造方法：类外无法 new 进行实例化 private GiantDragon()&#123;&#125; // 2.静态属性指向实例 private static GiantDragon instance = new GiantDragon(); // 3.每次获取实例都是 2. 中实例，实现单例 public static GiantDragon getInstance() &#123; return instance; &#125;&#125; 懒汉单例模式 饿汉式 ：非立即加载的方式，使用时才会加载。 举例 ：业务上有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式。 12345678910111213/* 部分代码略。同饿汉单例模式 ，不过将 2. &amp; 3.中进行一些改变 */ // 2.静态属性指向实例 ： 但不new！ private static GiantDragon instance = null; // 3.同前：不存在才创建一次，防止创建出不同对象。 public static GiantDragon getInstance() &#123; if(instance == null) instance = new GiantDragon(); else return instance; &#125; 3.3 枚举类型 枚举创建 enum是特殊class，enum声明定义的类型就是一个类。 e.g. 单独写一个颜色枚举类Color.java。 123456789101112131415161718enum Color &#123; RED(255, 0, 0), BLUE(0, 0, 255), BLACK(0, 0, 0), YELLOW(255, 255, 0); // rgb三属性 private int redValue; // 自定义数据域，private为了封装。 private int greenValue; private int blueValue; // 构造枚举值，比如RED(255,0,0) private Color(int r, int g, int b) &#123; this.redValue = r; this.greenValue = g; this.blueValue = b; &#125;&#125; 枚举 + switch 可以更好限定范围 &amp; 指定各种类型。 123456// 枚举调用：类名.枚举颜色，创建对象Color color = Color.RED; // 不用写后面参数switch (color) // switch 判断是引用（或变量），switch (Season s) 是错误写法&#123; // case break 判断代码&#125; 枚举常用方法 ordinal 返回枚举值在枚举类种的顺序。这个顺序根据枚举值声明的顺序而定。 12Color.RED.ordinal(); //返回结果：0Color.BLUE.ordinal(); //返回结果：1 compareTo Enum中的compareTo返回的是两个枚举值的顺序之差。当然，前提是两个枚举值必须属于同一个枚举类，否则会抛出ClassCastException()异常。 1Color.RED.compareTo(Color.BLUE); //返回结果 -1 [静态]values 静态方法，返回一个包含全部枚举值的数组。 12345Color[] colors=Color.values();for(Color c:colors)&#123; System.out.print(c+&quot;,&quot;); &#125; //返回结果：RED,BLUE,BLACK YELLOW,GREEN, toString 返回枚举常量的名称。 12Color c=Color.RED;System.out.println(c);//返回结果: RED valueOf 这个方法和toString方法是相对应的，返回带指定名称的指定枚举类型的枚举常量。 1Color.valueOf(&quot;BLUE&quot;); //返回结果: Color.BLUE equals 比较两个枚举类对象的引用。 12345//JDK源代码： public final boolean equals(Object other)&#123; return this==other; &#125; 第四章：接口与继承 4.1 接口 JAVA中使用接口，需要创建一个 new --&gt; class —&gt; 下拉选择 Interface —&gt; IAD.java 下面实现一个 AD英雄 implements AD接口。 在 IAD.java 中： 1234public interface IAD&#123; void ADAttack(); // 接口不能有体:&#123;&#125;&#125; 在 ADHero.java 中 12345678public class ADHero extends Hero implements IAD&#123; @Override // 加上这句IDE自动显示可以继承的方法；但没有这句也可自己写方法覆写。 public void ADAttack() &#123; System.out.println(&quot;输出了物理伤害！&quot;); &#125;&#125; 4.2 对象转换 基本概念 引用类型 &amp; 对象类型 通常，引用类型 和 对象类型 是一致的，如： 1ADHero ad = new ADHero(); 引用ad 指向了new出的新对象，它们类型都是 ADHero。 如果 引用类型 ≠ 对象类型：则是下述的类型转换问题。 向上转型 / 向下转型 “向上”、“向下”：是一种继承的概念，父类在子类上 ；类在继承的接口上。 向上转型：则指 子类转父类 ；类转为继承的接口。（可行） 向上转型 苹果手机 继承 手机，把苹果手机当做普通手机使用； 怡宝纯净水 继承 饮品， 把怡宝纯净水当做饮品来使用。 总结：特殊可转一般，子转父、子转接口。 子类转父类 下面 把物理英雄转普通英雄，显然是可行的： 123Hero h; // 不new！ADHero ad = new ADHero();h = ad; // 【注意】：h指向的是ADHero对象，但只能使用 Hero 类方法属性！ 子类转父接口 12ADHero ad = new ADHero();AD adi = ad; 向下转型（强制） 父类转子类，有的时候行，有的时候不行，所以必须进行强制转换。 父类转子类 下面，这种情况向下转型可行：因为第三行子类转父类，h指向ADHero对象（但只能使用 Hero 类方法属性）。 1234Hero h = new Hero();ADHero ad = new ADHero();h = ad; // 父类（基类）引用h 指向--&gt; ADHero对象ad = (ADHero) h; 所以上面代码表现的好像是，父类转子类成功，其实是 ADHero转换为ADHero。 父接口转子类 1234ADHero ad = new ADHero();AD Iad = ad; // 引用Iad指向 ADHero对象ADHero adHero = (ADHero) Iad; // ADHero 转 ADHero ，可行ADAPHero adapHero = (ADAPHero) Iad; // 不可行，ADHero 不能转 ADAPHero 没有继承关系转换 一定失败，不多言。 instanceof 123456ADHero ad = new ADHero();Hero h1 = ad;//判断引用h1指向的对象，是否是ADHero类型System.out.println(h1 instanceof ADHero); // 输出：true//判断引用h1指向的对象，是否是Hero的子类型System.out.println(h1 instanceof Hero); // 输出：true 4.3 重写 &amp; 隐藏 &amp; 重载 重写 重写：是不改变父类的方法名字和参数个数和类型，简单点说就是实现跟父类不一样的功能。 关键字：继承、不同类，和父类方法只有方法体不一样。 隐藏 隐藏：是有一个跟父类一样的静态方法，调用的时候就直接用子类的静态方法了。 关键字：继承、不同类，和父类方法只有方法体不一样、静态。 重载 重载：是方法重载,方法签名完全一致,参数类型和个数不同,JVM就可以识别并调用重载方法。 关键字：同类、和同类同名方法参数类型、个数、方法体都不同。 4.4 多态 多态一般分为：操作符多态；类多态，由类型向上转换 + 重写/重载 实现； 操作符多态 概念 如：+ 既可以表示 数字相加 也可表示 字符串连接 等，由运算符重载实现。 12int a = 3 + 5;int str = &quot;hello&quot; + &quot;world&quot;; 运算符重载 类多态 类多态一般需满足两个条件： 父类（接口）指向 子类对象 因为所谓类多态，就是可以用 基/父类 指向子类 调用方法有重写 同前，父类虽然在1. 指向子类对象，但只可以使用父类方法、属性；如果想调用子类方法，那么在父类和子类都声明同名方法，这样父类.方法()—&gt; 执行 —&gt; 子类.方法()。 类多态作业1：重写 实现多态 分别有以下两个类： MagicPortion类，*effec()*使用后回蓝； LifePortion 类，*effec()*使用后回血； Hero类对象 VN，VN调用本身方法 userItem(参数) 即可实现回血、回蓝等物品使用。 实现父类接口 Item 要实现多态，我们在外面使用一个父类引用指向不同子类对象，再用其调用子类方法。 这样，不必为不同子类对象生成不同对应引用，比如可使得函数参数统一等（见后）。 1234public interface Item&#123; void effect();&#125; 实现 MagicPortion、LifePortion 类 MagicPortion类，*effec()*使用后回蓝： 1234567public class MagicPortion implements Item&#123; public void effect() &#123; System.out.println(&quot;使用蓝瓶回蓝100！&quot;); &#125;&#125; LifePortion 类，*effec()*使用后回血： 1234567public class LifePortion implements Item&#123; public void effect() &#123; System.out.println(&quot;使用血瓶回血100！&quot;); &#125;&#125; Hero类表现多态 要表现多态，让父类指向子类对象，同时可以执行子类同名（重写）方法 1234567public class Hero&#123; void useItem(Item i) //父类接口Item做参数，可以接收不同子类对象 &#123; i.effect(); &#125;&#125; 这样，统一了函数参数，一个方法（不必重载）就可以实现各种物品使用。 123456// 在主函数main()中Hero VN = new Hero();Item i1 = new MagicPortion();Item i2 = new LifePortion();VN.useItem(i1); // 输出：使用蓝瓶回蓝100！VN.useItem(i2); // 输出：使用血瓶回血100！ 类多态作业2：隐藏static无法体现多态 如果将 Item 类改为以下： 1234567public class Item // 1.接口--&gt;类，隐藏只支持类&#123; static void effect() // 2.+static，关键字 &#123; System.out.println(&quot;物品产生一些效果&quot;); // 3.添加方法体 &#125;&#125; 然后在 MagicPortion &amp; LifePortion 类 effect() 也加上static关键字实现同名隐藏： 1public static void effect() 这个时候主函数输出： 1234// 在主函数main()中Hero VN = new Hero();Item i1 = new MagicPortion();VN.useItem(i1); // 输出：物品产生一些效果 原因如下： 隐藏 对方法都加上了static关键字，无法在 Item i1 = new MagicPortion(); ，实现引用 i1动态绑定 静态方法，也就无法实现多态！ 4.5 super &amp; final 利用super调用父类属性、方法 1234567public class ADHero extends Hero implements AD&#123; //在某个方法中 super.moveSpeed; // 1.调用父类属性 super.useItem(i); // 2.调用父类方法userItem super(); // 3.调用父类无参构造函数 &#125; final 修饰 修饰类：类无法被继承 如，可用自定义类 someString 继承系统类 String ，结果如何？ 不能继承，因为 系统类 String ，是被 final 关键字修饰的。 修饰方法：方法不能被重写 修饰变量：只能被赋值1次 如，可利用这点，设置一个常量。 1public static final int pi = 3.14; 修饰引用：只有1次指向引用的机会 4.6 抽象类 基本概念 类带有 abstract 关键字修饰就是抽象类； 含有抽象方法必须是抽象类； 123456public abstract class Hero&#123; // 抽象方法attack：[1] abstract修饰 [2] 无方法体 // Hero的子类会被要求实现attack方法 public abstract void attack();&#125; 抽象类不能被实例化，专门用来继承的。 抽象类 和 接口区别 默认方法实现 抽象类可以有非抽象方法，有方法体 ； 接口不能有。 抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。 再精辟点总结： 抽象类，既 1.非抽象类实现代码复用 2.又同时有抽象方法使得被继承类各自实现。 接口，是对类的行为进行约束，强制要求不同类实现相同行为。 构造函数 抽象类有；接口没有。 修饰符 抽象类除private 都有（抽象类目的是被继承，抽象方法是为被重写）；接口only public。 继承个数 [接口优] 抽象类只能被继承一次；接口可以有多个。 4.7 内部类 暂时不知道什么时候用得到，先不展开：讲解内部类链接 非静态内部类 静态内部类 匿名类 本地类 4.8 默认方法 默认方法是指 ：接口的抽象方法，加上 default 关键字，可以有方法体。 1234567public interface Mortal &#123; public void die(); default public void revive() &#123; System.out.println(&quot;本英雄复活了&quot;); &#125;&#125; 这样做的好处： 假设没有默认方法这种机制，那么如果要为Mortal增加一个新的方法revive,那么所有实现了Mortal接口的类，都需要做改动实现 revive。 但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法 4.9 UML图 类图解释 接口图解释 继承关系解释 实线：表示继承类，如下图 Spider 类继承 Animal 类； 虚线：表示继承接口，如下图 Cat类 继承 Pet 接口。 第五章：数字 和 字符串 5.1 拆箱、装箱 关于拆箱、装箱基本概念 所有的基本类型，都有对应的类类型 ，又称为封装类，也是数值与包类型转换。 下面是所有数值 基本类型，对应的类型型，它们又都是抽象类 Number 的子类。 如：基本类型 int --&gt; 对应封装类 Integer ； short --&gt; 对应封装类 Short … 装箱 装箱，即将 基本类型自动 转换成封装类型，自动又是通过**=** 号实现。 先看一个非装箱，自己调用构造方法实现 基本类型–&gt; 封装类型： 123// 非装箱转换成封装类 int i = 1; Integer it = new Integer(i); 如果 用 = 号 实现自动上述过程，则称为装箱： 123// = 自动装箱 int i = 1; Integer it = i; // = 自动实现类型转换，无需new 拆箱 和装箱类似，即将 封装类型自动 转换成 基本类型，自动又是通过**=** 号实现。 非拆箱，自己调用构造函数实现： 123// 非拆箱实现转换成基本类型 Integer it = new Integer(0); int i = it.intValue(); 拆箱实现： 123// = 自动拆箱 Integer it = new Integer(0); int i = it; // = 自动实现类型转换 拆箱、装箱之惑 存在的意义？ 为什么要有装箱、拆箱，它们的作用是什么？ java 是 面对对象编程，而基本数据类型不是对象，所有才有封装类 引用基本数据类型。 比如，下面打印出int型数据： 12int i = 0；System.out.println(i); 其实，查看源码，实际经过以下几个过程： 将 i 自动装箱成封装类 Integer 然后调用 Integer中 toString() 方法，打印出字符串输出到控制台。 5.2 类型转换 数值类型之间 位数低—&gt;高 低—&gt;高：byte,char(1) --&gt; short(2)–&gt; int(4) --&gt; long(8) --&gt; float(8) --&gt; double(16) 强制转换 如果是低位向高位转换，则自动转换；反之，则需要 () 强制转换。 123byte b = 1;short s = b; // 可，自动转换。b = (byte)s; // 强制 表达式类型提升 如果，数值类型参与运算，操作符两端类型要一致，有以下几个原则： byte、short和char 自动提升int型； 操作数含long型，则整个表达式类型提升为long型； 操作数含 float / double 型，则整个表达式提升为 float /double型表示； long、float、double，同时出现，提升优先：double &gt; float &gt; long 。 数值类型 &amp; char 基本规则和数值类型直接按位数，是否强制转换很相似，但有一点不同： char &amp; byte &amp; short 之间, 除了 byte 转换成 short 都是强制转换； 12345byte b = 0; char c = 1; short s = 2;s = (short) c; // 虽然short位数4，但是还是要强制转换c = (char) b;b = (byte) c; 数值类型 &amp; String 数值类型 &lt;— String String 转为 数值类型，一般有如下三种方法： 123456789101112 String str = &quot;12345&quot;;// 方法1：数值类型对应封装类.parse方法 int a1 = Integer.parseInt(str);// 方法2：手动装箱 --&gt; 手动拆箱// 等价自动拆箱：int a2 = Integer.valueOf(str); Integer it2 = Integer.valueOf(str); int a2 = it2.intValue(); // 可以更简单=自动拆箱：int a2 = it2;// 方法3：手动装箱 --&gt; = 自动拆箱 int a3 = new Integer(str); String &lt;— 数值类型 1234567 int i = 12345;// 方法1：数值类型对应封装类.toString方法 String str1 = Integer.toString(i);// 方法2：先装箱再拆箱：手动装箱--&gt; = 自动拆箱 String str2 = String.valueOf(i); int[] &amp; String int[] 转换 string 12345import java.util.*；// 1.调用Arrays类方法int[] arr = new&#123;1,2,3&#125;;string s = Arrays.toString(arr) String &amp; char &amp; char[] String转换为char 1234// String 和 char 之间转换String str = &quot;123&quot;; char c = str.charAt(0); // 转换成字符char[] c1 = str.toCharArray(); // 转换成字符数组 char 转换成 String 1234567char c1 = &#x27;1&#x27;; String str1 ;// 方法1：利用每种基本类型对应封装类都有的.toString方法str1 = Character.toString(c1);// 方法2：valueOf装箱 --&gt; =自动拆箱str1 = String.valueOf(c1); char[] 转换为string 1234567// 1.直接在构造String时建立。 char data[] = &#123;&#x27;s&#x27;, &#x27;g&#x27;, &#x27;k&#x27;&#125;; String str = new String(data);// 2.String有方法可以直接转换。 char[] cha = &#123;&#x27;s&#x27;,&#x27;g&#x27;,&#x27;h&#x27;&#125;; String n = String.valueOf(cha); String &amp; byte[] String转换为byte[] 和转换成 char 类似，可以调用对象本身的方法。 12String str = &quot;123&quot;; byte[] bytes = str.getBytes(); byte[] 转换成 String 也同 char 转 String 类似，利用装箱拆箱。 12byte[] bs = new byte[]&#123;1,2,3&#125;;String s = new String(bytes); 引用类型之间 123456public class Person &#123;&#125;public class Student extends Person &#123;&#125;// 主函数中Person p = new Person();Student s = new Student(); 向上转换，父类引用 &lt;— 子类引用，可转。 1p = s； // 子转父 其实，本质 p指向了 Student对象，虽然只能使用Person方法，等价这种写法： 1p = new Student(); // Student对象无名引用，转换成父类 Person 向下转换，子类引用 &lt;— 父类引用，抛出异常。 1s = (Student)p; // 抛出异常 如果无继承关系引用转换，编译错误！ 5.3 数学方法 123456789101112// 1.四舍五入Math.round(5.5); // 6// 2.随机数Math.random(); // [0-1) 之间随机数Math.random()*10; // [0-10) 之间随机数// 3.开方Math.sqrt(9)// 4.次方Math.pow(2,4)// 5.常数Math.PI // πMath.E // 自然常数 5.4 Sting 常用方法 单字符串操作 1String str = &quot;hello java!&quot;; 常用方法见下： 12345678910111213141516171819// 1.返回字符str.charAT(0); // 返回str第一个字符// 2.返回字符数组str.toCharArray(); // 3.截取字符串str.substring(3); // 从第3个字符开始截取str.substring(3,5); // [3,5):截取第3--&gt;第5字符，不含第5// 4.分隔字符串str.split(&quot;,&quot;); // 5.去除首尾空格str.trim(); // 6.大小写str.toLowerCase()str.toUpperCase()// 7.定位str.indexOf(&#x27;l&#x27;); // 返回l第一次出现位置：2str.lastIndexOf(&#x27;l&#x27;); // 返回l最后一次出现位置：3// 8.包含str.contains(&quot;java&quot;); // 返回：ture 多字符串操作 比较 12String str1 = &quot;the light&quot;;String str2 = new String(str1); 常用操作方法： 12345// 1.是否同一对象 System.out.println( str1 == str2); //虽然，内容相同但不是同一对象// 2.是否内容相同 System.out.println(str1.equals(str2)); //返回 ：ture System.out.println(str1.equalsIgnoreCase(str3)); // 忽略大小写，比较 以特定字符结束/开始 12String str1 = &quot;the light&quot;;String str2 = &quot;ht&quot;; 使用举例： 1234// 1.判断以特定字符开始System.out.println(str1.startsWith(str2)); // 返回false// 2.判断以特定字符结束System.out.println(str1.endsWith(str2)); // 返回ture 5.5 StringBuffer类 比String基本类型，能更好操作字符串：追加、删除、插入、反转等，而且性能佳！ 为什么StringBuffer可以变长？ 和String 和 StringBuffer 内部都维护了一个字符数组，但是StringBuffer 还有冗余长度。 声明 1StringBuffer sb = new StringBuffer(&quot;hello java!&quot;); 常用操作 123456789101112// 1.追加sb.append(&quot;啊，我死了！&quot;);System.out.println(sb); // hello java!啊，我死了！// 2.删除sb.delete(5,10);System.out.println(sb); // hello!啊，我死了！// 3.插入sb.insert(5, &quot;!&quot;);System.out.println(sb); // hello!!啊，我死了！// 4.反转sb.reverse(); //反转System.out.println(sb); // ！了死我，啊!!olleh 常用属性 12sb.length(); //内容长度：13sb.capacity(); //总容量：27（有冗余） 第六章：日期 6.1 Date类 什么是时间原点？ 时间原点是：1970/1/1 8:0:0 。所有的日期，以此为基准，每过一毫秒，就+1。 如何引进日期类库？ 1import java.util.Date; 创建 1234567// 1.不带参数，当前时间Date d = new Date();System.out.println(d); // 输出：Sat Jun 29 22:11:23 CST 2019// 2.带参数(整数)，时间：原点+整数/1000(秒)Date d1 = new Date(1000);System.out.println(d1); // 输出：Thu Jan 01 08:00:01 CST 1970 常用方法 12// 1.getTime:获取 当前时间 - 原点 毫秒数System.out.println(d.getTime()); 6.2 SimpelDateFormat 类 SimpelDateFormat 类 用来格式化日期输出。 如何引用？ 1import java.text.SimpleDateFormat; 格式Date对象 ⚠️注意，下面格式模式 MM 、HH 必须大写，否则出错！ 1234567Date d = new Date();// 1.创建SimpleDateFormat对象，并指定格式模式SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;);// 2.利用format方法，格式Date对象，并返回String类型String str = sdf.format(d); // 返回String类型// 3.输出测试System.out.println(str); // 输出：2019/06/29 22:53:00 格式String对象 ⚠️注意，parse方法，必须在一对 try catch 块中，否则编译错误。 123456789101112131415String str = &quot;2019/01/01 00:00:00&quot;;Date d = new Date();// 1.创建SimpleDateFormat对象，并指定格式模式SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;);// 2.parse方法，格式String对象，并返回Date类型try &#123; d = sdf.parse(str);&#125;catch (ParseException e)&#123; e.printStackTrace();&#125;// 3.输出测试System.out.println(d); // 输出测试：Tue Jan 01 00:00:00 CST 2019 6.3 Calendar类 Calendar 类 和 Date类相比，更容易进行“翻日历“，进行月份/天等修改。 如何引用？ 1import java.util.Calendar; 创建对象 ⚠️ 只能利用Calendar.getInstance() 获取单例，new需要重写函数。 1Calendar c = Calendar.getInstance(); 常用方法 123456789101112131415161718192021// 1.getTime(),返回Date类型对象Calendar c = Calendar.getInstance();Date d = c.getTime()；System.out.println(c.getTime()); // 输出：Sat Jun 29 23:08:53 CST 2019// 2.setTime(Date d),设置时间，无返回Date d1 = new Date(0);c.setTime(d1);System.out.println(c.getTime()); // 输出：Thu Jan 01 08:00:00 CST 1970// 3.add，在原日期(2019/6/29)上增加 年/月/日c.add(c.YEAR, 3); // 3年后c.add(c.MONTH, -1); // 前1个月c.add(c.DATE, 1); // 后1天System.out.println(c.getTime()); // 输出：Sun May 30 23:29:06 CST 2022// 4.set，可分别设置年月日，区分setTimec.add(c.YEAR, 2019); c.add(c.MONTH, 9); c.add(c.DATE, 1); System.out.println(c.getTime()); // 输出：Tue Oct 01 23:34:55 CST 2019 第七章：异常 7.1 异常分类 异常分为，Error &amp; Exception，它们都是 Throwable 子类； Exception，又分为运行时异常、可查异常。 7.2 异常处理 try cacth 尝试打开 LOL，抛出异常： 1234567891011121314151617import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;// 主函数中：File f= new File(&quot;d:/LOL.exe&quot;);try&#123; System.out.println(&quot;试图打开 d:/LOL.exe&quot;); new FileInputStream(f); // (1) 执行到这出现异常 ---&gt; 执行catch块 System.out.println(&quot;成功打开&quot;); &#125; catch(FileNotFoundException e) // (2) 出现异常开始处理 &#123; System.out.println(&quot;d:/LOL.exe不存在&quot;); System.out.println(e.toString()); &#125; 改进：如果不知道抛出异常类型？ 可以用父类 Exception，甚至Throwable 进行catch 处理。 123456// 利用父类进行catch(只修改catch块)catch(Exception e)&#123; System.out.println(&quot;d:/LOL.exe不存在&quot;); System.out.println(e.toString());&#125; 改进：如果有多个错误？ 可用多个 catch 块进行处理。 123try&#123; // 程序代码 &#125;catch(异常类型1 异常的变量名1) &#123; // 处理程序 &#125;catch(异常类型2 异常的变量名2) &#123; // 处理程序 &#125; try cacth finally 有时候希望，无论是否出现异常，都希望有段代码被执行，也就是finally块。 但是有下面几个结合return 情况，值得深思：java异常捕获 throw try cacth 理解不深，待实际操作补充。同时可见下：[自定义异常] 7.3 自定义异常 对 throws 作用理解不深，待补充。 自定义异常类 1234567class myException extends Exception // 继承Exception类&#123; public myException() &#123; System.out.println(&quot;flag = 0，发生异常！&quot;); &#125;&#125; 捕获异常 在 try中抛出异常，然后catch接住异常进行出现(不处理会编译错误)。 123456789101112// 主函数中int flag = 0; try &#123; if (flag == 0) throw new myException(&quot;flag == 0 &quot;); &#125; catch (myException e) &#123; // 处理异常代码 System.out.println(&quot;catch中捕获到异常！&quot; ); &#125; 第八章 ： IO流 8.1 文件对象 创建对象 1234import java.io.File;// 以当前项目路径(相对路径)创建对象 File f = new File(&quot;test.txt&quot;); 对象常用方法 1234567891011121314151617181920212223242526272829303132// 1.重命名文件 -- 不会改变f的name属性File f1 = new File(&quot;hwh.txt&quot;);f.renameTo(f1); // f.getName() 还是test.txt// 2.创建文件 -- 存在不会重新创建File f2 = new File(&quot;lt.txt&quot;);try&#123; f2.createNewFile(); // 创建了lt.txt文件 &#125;catch (IOException e) // 必须处理异常&#123; System.out.println(e.toString());&#125;// 3.创建文件夹:不会覆盖File f3 = new File(&quot;son&quot;);f3.mkdir(); // 创建了 son 文件夹 // 4.返回目录下文件 &amp; 文件夹// 以String数组返回String[] str = f3.list();System.out.println(str[0]); // 输出目录下第一个文件名字// 以File数组返回File[] fs = f.listFiles();// 5.其它方法f.exists(); // 判断文件是否存在f.isDirectory(); // 判断是文件夹f.isFile(); // 判断是文件f.length(); // 文件长度f.delete(); // 删除文件 8.2 文件流 当需要对文件进行 读取/写入 时，要建立文件 输出/输入 流。 ⚠️ 字符流可以一个字符一个字符也可以一行一行读取 ；字节流不可以。 字节流 字符流 按行读取 × 一次读取 √ 读取中文 √ 更方便 √ 字节流读写 以 字节（ASCII） 形式读取和写入数据：InputStream字节输入流 ；OutputStream字节输出流 。 都是 抽象 类，不提供具体实现，可用子类 FileInputStream &amp; FileOutStream 对文件进行读写。 [读]文件输入流：不用 try catch 捕获异常会报错 1234567891011121314151617181920212223242526import java.io.File;import java.io.FileInputStream;try&#123; // 1.创建文件对象 File f = new File(&quot;lt.txt&quot;); // lt.txt 内容：lt // 2.创建输入流对象 FileInputStream fis = new FileInputStream(f); // 3.文件读出数据 byte[] all =new byte[(int) f.length()]; fis.read(all); // 打印读取到byte数组文件内容 // 直接打印打印出的 ASCII码，强制转换成char字符 for (byte b : all) System.out.print((char)b); // 输出： lt // 4.流关闭 fis.close(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; [写]文件输出流：最后查看 hwh.txt 内容被写入 hwh 12345678910111213141516171819202122import java.io.File;import java.io.FileOutputStream;try&#123; // 1.创建文件对象 File f = new File(&quot;hwh.txt&quot;); // hwh.txt 内容为空 // 2.创建输入流对象 FileOutputStream fos = new FileOutputStream(f); // 3.数据写入文件 byte[] all = new byte[]&#123;104,119,104&#125;; // ASCII 104——&gt;h ; ASCII 119——&gt;w fos.write(all); // 4.流关闭 fos.close(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; 字符流读写 以 字符 对文件进行读写，Reader 字符输入流；Writer 字符输出流 ，同前都为 抽象类 。 用子类，FileReader &amp; FileWriter、对文件进行字符读写。 [读] FileReader : 注意是用字符数组 char[] 进行读写，而不是 String 12345678910111213141516171819202122232425import java.io.FileReader;try&#123; // 1.创建文件对象 File f = new File(&quot;lt.txt&quot;); // 2.创建字符流对象 FileReader fr = new FileReader(f); // 3.读取流对象内容 // String str = null; // 错误，应该是char[]数组 char cArr[] = new char[(int)f.length()]; fr.read(cArr); // 打印读取到char数组文件内容 for (char c : cArr) System.out.print(c); // 输出： lt // 4.流关闭 fr.close();&#125;catch (Exception e)&#123; System.out.println(e);&#125; [写] FileWriter ：同上注意char[]数组。最好 hwh.txt 文件内容为： hwh is a pig 12345678910111213141516171819202122import java.io.FileWriter;try&#123; // 1.创建文件对象 File f = new File(&quot;hwh.txt&quot;); // 2.创建输入流对象 FileWriter fw = new FileWriter(f); // 3.读取流对象内容 String str = &quot;hwh is a pig&quot;; char cArr[] = str.toCharArray() ; fw.write(cArr); // 4.流关闭 fw.close();&#125;catch (Exception e)&#123; System.out.println(e);&#125; 缓存流读写 缓冲流是字符流的子类 ，用于解决：字符流 &amp; 字节流 每读写1字节要IO操作。 [读]BufferedReader 12345678910111213141516171819202122232425262728293031323334import java.io.BufferedReader;try&#123; // 1.创建文件对象 // hwh.txt内容(空格表示换行)：黄 旺辉 不喜欢西瓜 File f = new File(&quot;hwh.txt&quot;); // 2.创建字符流对象 FileReader fr = new FileReader(f); // 3.创建缓存流：必须建立在一个存在流之上 BufferedReader br = new BufferedReader(fr); // 4.读取流对象内容:一次一行 // 输出：黄 旺辉 不喜欢西瓜 while(true) &#123; //一次读取一行，返回Sting类型 // 比前面；设置好char[] 、byte[] ,然后f.read()有所不同 // 比后面：不用考虑中文 char[] 、byte[] 转换成Sting类型 String line = br.readLine(); if(line == null) break; System.out.println(line); &#125; // 5.流关闭 br.close();&#125;catch (Exception e)&#123; System.out.println(e);&#125; [写] PrintWriter ，基本同上差不多步骤，简略说明下 12345import java.io.PrintWriter;// ...基本同上// 写操作，pw是PrintWriter对象，调用println方法读写即可。pw.println(&quot;刘婷是傻子&quot;); 数据流&amp;对象流 数据流 &amp; 对象流 都是字节流子类，建立数据流 &amp; 字符流必须要在一个存在的字节流之上。 数据流：主要可以进行格式化 顺序 读写，有 FileInputStream 、FileOutputStream 1234567891011121314151617181920212223242526272829303132333435import java.io.DataInputStream;import java.io.DataOutputStream;try&#123; // 1.创建文件对象 File f = new File(&quot;hwh.txt&quot;); // 2.创建字节流对象 FileOutputStream fos = new FileOutputStream(f); FileInputStream fis = new FileInputStream(f); // 3.创建数据流：必须建立在一个[字节流]之上 DataOutputStream dos = new DataOutputStream(fos); DataInputStream dis = new DataInputStream(fis); // 4.数据流顺序写 dos.writeBoolean(true); dos.writeInt(1); dos.writeUTF(&quot;yes&quot;); // 5.数据流顺序读 boolean b = dis.readBoolean(); int i = dis.readInt(); String s = dis.readUTF(); // 输出：顺序读到：bool:true ; int：1；String：yes System.out.format(&quot;顺序读到：bool:%b ; int：%d；String：%s &quot;,b,i,s); // 6.流关闭 dos.close(); dis.close();&#125;catch (Exception e)&#123; System.out.println(e);&#125; 对象流：指的是可以直接把一个对象以流的形式传输给其他的介质，比如硬盘 。暂时不详写用 到再说吧：对象流 1234import java.io.ObjectInputStream;import java.io.ObjectOutputStream;// 主函数中 8.3 中文读写问题 常用编码格式 IS0-8859-1、ASCII ：数字 &amp; 西欧字母 ，IS0-8859-1包含 ASCII，1字节。 GBK、GB2312、BIG5：中文简繁；中文 ；繁体中文，2字节 。 Unicode ：统一码，万国码，字母、数字、中文都为4 字节编码。 UTF-8：对 Uincode 进行的一种减肥子编码 ，字母、数字：1字节 ；中文：3 字节。 特别的 ANSI ：表示本地编码，中文OS则选用 GBK、英文 IS0。 中文编码读写 写 在记事本等中直接写中文：采用本地编码 ANSI保存。 在 java中写中文：执行后都会变为 Unicode（UTF-8?），然后字符流、字节流读写？ 读 读：字节流 &amp; 字符流读文本中中文，字符流比较麻烦略。 将字节流数组转换成 Sting 和对应字符编码。 1234567891011121314151617181920212223242526272829303132333435363738394041try&#123; // 1.创建文件对象 File f = new File(&quot;hwh.txt&quot;); // hwh.txt内容：黄 // 2.创建输入流对象 FileInputStream fis = new FileInputStream(f); // 3.读取流对象内容 byte[] all = new byte[(int)f.length()]; fis.read(all); // [测试] 直接输出 byte数组 for(byte b : all) &#123; /* byte 1字节，直接打印对应二进制整数：-23 -69 -124(uft-8编码中文3字节) 为了打印出16进制，先转换成int --&gt; 再调用toHexString方法 */ System.out.println(b); int i = b; /* 类型转换，输出：ffffffe9、ffffffbb、ffffff84 对应-23 -69 -124 补码：e9、bb、84(int4字节，byte1字节，补码前3字节添1不看) */ System.out.println(Integer.toHexString(i)); &#125; // 4.类型转换：把字节数组转换成 Sting UTF-8编码 // 类型转换第一种：new String装箱，= 自动拆箱 // 第二种转换：调用对象类型都有的.toString方法：all.toString() String str = new String(all,&quot;UTF-8&quot;); System.out.println(str); // 输出：黄 // 5.流关闭 fis.close();&#125;catch (Exception e)&#123; System.out.println(e);&#125; 第九章：集合框架 常用集合框架有： ArrayList、LinkedList、HashMap、HashSet 等。 Tips： System.out.println(集合类型对象)：可以直接装箱成String类型，然后拆箱输出，如[1,2,3]。 9.1 ArrayList ArrayList 是实现了 List 接口子类。相比常规数组，容量会自动增长，是一个动态数组（非链表）。 声明 123import java.util.ArrayList;ArrayList array = new ArrayList(); 常用方法 12345678910111213141516171819202122232425262728293031323334// 1. add -- 未泛型指定可添加不同类型对象Hero VN = new Hero();array.add(VN); // Hero类型对象array.add(&quot;pentaKill&quot;); // Sting类型对象// 2.contains：判断对象是否存在System.out.println(&quot;VN对象是否存在：&quot; + array.contains(VN));// 3.get ：获取指定位置对象 -- 从0计数System.out.println(&quot;第1个位置对象：&quot; + array.get(0));// 4.indexof：判断对象所处位置System.out.println(&quot;VN所处位置：&quot; + array.indexOf(VN));// 5.remove：可根据位置或者对象名删除array.remove(VN);array.remove(1);// 6.set: 只能替换指定位置对象,不能设置新元素System.out.println(&quot;替换第1个位置对象：&quot; + array.set(1, 5));// 7.size：获取数组已存元素个数（大小）System.out.println(&quot;替换第1个位置对象：&quot; + array.size());// 8.addAll:添加另外一个容器所有对象ArrayList array1 = new ArrayList();array.addAll(array1);// 9.toArray :ArrayList对象转换为数组// 加了toSting无变化，因为返回Objiect数组System.out.println(&quot;转换为数组：&quot; + array.toArray().toString()); // 10.clear：清空 9.2 LinkedList LinkedList &amp; ArrayList 都实现了 List接口，都有 add 、remove 、contains 等方法。 但同时，LinkedList 还实现了 Queue（队列） 、Deque（双向队列）接口。 声明 1234567// LinkList// 普通声明LinkedList l = new LinkedList();// 多态：声明双端队列Deque d = new LinkedList();// 多态：声明队列Queue q = new LinkedList(); 常用方法 Deque 暂未补充。 12345678910111213/* 1. LinkList 在头部、尾部进行操作 */// [查看]链表头尾元素l.getFirst(); l.getLast();// [删除]链表头尾元素l.removeFirst(); l.removeLast();/* 2. Queue 在头部、尾部进行操作 */// [添加]队列尾元素 -- q.add?用List接口方法一样吗？q.offer(1); q.offer(2);// [查看]链表头尾元素q.peek();// [取出]链表头尾元素，取出后会被删除q.poll(); 9.3 HashMap HashMap 可理解为一个字典，键值不能重复，不同键元素可重复（相同）。 声明 123import java.util.HashMap;HashMap dic = new HashMap(); // 也可泛型指定 Key ：Value 类型 常用方法 未详细列出，详细需查看：HashMap官方文档。 12345// 常用方法// 1.put -- 插入数据dic.put(1, &quot;啊我是1&quot;); dic.put(2, &quot;啊我竟然是2&quot;); dic.put(3, &quot;啊哈哈哈我是3&quot;);// 2.get -- 获取数据System.out.println(dic.get(2)); // 输出：啊我竟然是2 9.4 HashSet HashSet 没有键值，只保存元素。且不提供 get(index) 方法读取指定位置元素，遍历可利用迭代器。 类似的还有：LinkedHashSet &amp; TreeSet ，暂略。 声明 123import java.util.HashSet; HashSet hs = new HashSet(); 常用方法 123456789101112// 常用方法// 1.add -- 插入数据hs.add(1); hs.add(true); hs.add(&quot;一&quot;);// 2.可直接打印所有数据，不是按添加顺序System.out.println(hs); // 输出：[一, 1, true]// 3.[迭代遍历] 由于未提供get方法，不能普通for循环，但可以迭代器遍历for(Iterator it = hs.iterator();it.hasNext();)&#123; System.out.println(it.next()); // 输出：一 1 true&#125; 9.5 Collections类 Collections 类是专门用于处理集合类型的工具类，包含一系列诸如：排序、反转、混淆、交换 等方法。 类似于：Arrays 是数组的工具类。但是，只能处理实现了 List 接口类。Collections 类官方文档 基本使用 1234567891011121314import java.util.Collections;LinkedList&lt;Integer&gt; ll = new LinkedList&lt;Integer&gt;(); // [注]：不是int类型ll.add(1) ; ll.add(2) ; ll.add(3) ; ll.add(4) ; ll.add(5) ;// 常用方法：更多查看官方文档// 1.混淆Collections.shuffle(ll); // 2.排序Collections.sort(ll); System.out.println(ll); // 输出：[1, 2, 3, 4, 5]// 3.反转Collections.reverse(ll);// 4.交换Collections.swap(ll,0,4); 比较器：Comparable Comparable 是一个接口，通过覆写实现它的 compare 方法，来比较非数值类型的 sort 排序等。 如下，实现了通过比较 Hero类 HP属性来实现排序。 在Hero类中 也可在 Hero类中在覆写 compareTo方法，这样自带比较信息，而不用在主函数覆写Comparator 接口的 compare方法。 ⚠️ 在 Hero类中覆写了 toSting方法，这样打印Hero对象不显示：Hero@十六进制地址形式。 1234567891011121314151617181920public class Hero&#123; // 属性 String name; int HP; // 方法：构造函数 Hero(String name ,int hp) &#123; this.name = name; this.HP = hp; &#125; // 方法：类中覆写函数toString @Override public String toString() &#123; return &quot;英雄名：&quot; + name + &quot; 血量：&quot; + HP; &#125;&#125; 在主函数中 Q : System.out.println(ll); 如何实现打印出集合？ A: 首先，打印 ll 会将集合每个Hero对象装箱成Sting，然后调用 .toString()方法进行拆箱； ​ 由于Hero类中覆写了 .toString()方法，此时返回的不是默认Hero@十六进制地址形式 。 ​ 最后结合所有对象.toString() ,转换成String类型[…,…,…,…]打印出来。 123456789101112131415161718192021222324252627282930import java.util.Comparator;// 1.准备好一个集合类型 LinkList，插入十个Hero类型对象并设置不同随机hpLinkedList&lt;Hero&gt; heros = new LinkedList&lt;&gt;();for(int i = 0 ; i &lt; 10 ; i++)&#123; String name = &quot;hero&quot;+i; int hp = (int)(Math.random()* 1000); heros.add(new Hero(name,hp)); // 带int参数构造函数&#125;System.out.println(heros);// 2.[匿名类]覆写比较器compare方法（比较规则）Comparator&lt;Hero&gt; comparable = new Comparator&lt;Hero&gt;() &#123;@Overridepublic int compare(Hero h1,Hero h2)&#123; if(h1.HP &gt; h2.HP) return 1; else return -1; // 注意，别写0 &#125;&#125;;// 3.工具栏Collections进行排序Collections.sort(heros,comparable);// 4.直接打印输出查看System.out.println(heros); 9.x 迭代器初使用 根据学习C++经验，迭代器要和这些集合类型如 ArrayList 结合才能用。 声明一个集合 123456import java.util.Iterator;import java.util.List;// 利用 List接口多态实现 List array = new ArrayList();array.add(12345); array.add(&quot;上山打老虎&quot;); array.add(new Hero()); 普通for循环遍历集合 12for (int i = 0; i &lt; array.size();i++) System.out.println(array.get(i)); 迭代for循环遍历 123456// hasNext - 判断当前是否有下一个元素，有返回true// next - 返回当前元素类型。for (Iterator it = array.iterator();it.hasNext();)&#123; System.out.println(it.next());&#125; 第十章：泛型 10.1 泛型分类及作用 泛型集合 通过，泛型集合指定集合接受类型，如只能接受 Hero对象及其子类 如下，声明了一个非泛型对象数组集合，可添加不同对象，但也许我们只想添加Hero对象。 1234ArrayList heros = new ArrayList();heros.add(new Hero());heros.add(new Item());// 此时泛型还可以添加无关的 Item对象 通过泛型指定只能添加 Hero对象及其子类： 12345ArrayList&lt;Hero&gt; heros = new ArrayList&lt;Hero&gt;();heros.add(new Hero()); heros.add(new ADHero()); // 子类也可以添加heros.add(new Item()); // 编译错误 泛型方法 &amp; 泛型类 &amp; 泛型接口 这些泛型，可以接受不同参数实现代码精简。 12345678910111213141516171819202122232425262728293031323334// 泛型类，类中定义了非泛型方法&amp;泛型方法。public class Demo&lt;T&gt; &#123; // 1.[非泛型方法] 因为用的是类定义泛型 public void test(T a) &#123; System.out.println(a); &#125; // 2.[泛型方法] 这才是泛型方法，&lt;T&gt;声明在返回类型前 public &lt;T&gt; void test1(T a) &#123; System.out.println(a); &#125; // 3.[静态方法 &amp; 编译错误]下面编译错误，静态类不能用类定义的泛型 public static void test2(T a) &#123; System.out.println(a); &#125; // 4.[静态泛型方法] 用自己定义的泛型就不会出错 public static &lt;T&gt; void test2(T a) &#123; System.out.println(a); &#125;&#125;// 泛型接口类似泛型类声明interface InterDemo&lt;T&gt;&#123; // do something&#125; 泛型转型 暂时记住结论。 我们知道，子类是可以转换成父类（多态），但是子类泛型和父类泛型不能互转！ 10.2 泛型通配符 通配符作用 &lt; ? extends 类型名&gt; ：只能取 类型名、object，不能插入； &lt;?&gt; : 只能取object ，不能插入； &lt; ? super 类型名&gt; ： 只能取object ，能插入满足通配符匹配所有类型的子类。 &lt; ? extends 类型名&gt; 12345678910111213// 1. 因为不能插入，所以先定义一个&lt;APHero&gt;泛型集合插入一些数据ArrayList&lt;APHero&gt; apHeroList = new ArrayList&lt;APHero&gt;();apHeroList.add(new APHero());// 2.定义&lt;? extends&gt;泛型集合：指向上面泛型集合 ArrayList&lt;? extends Hero&gt; heroList = apHeroList;// 3.测试// [取，可行] 因为&lt;? extends&gt;代表保存的都是 Hero及其子类，取出来都可以转换成Hero类型Hero h = herolist.get(0);// [插，不可] 因为&lt;? extends&gt;可以是Hero及其子类，但只能确定为其中一个。// 比如， &lt;? extends&gt;已经代表是&lt;Hero&gt;,根据泛型集合限定插入类型，此时插入APHero类型会失败。heroList.add(new ADHero()); //编译错误 &lt;?&gt; 基本同*&lt; ? extends 类型名&gt;* ，由于少了 extends ，代表可以是指向任意泛型对象，而非某类及其子类。 但是，取数据也对应只能是 Object 类型。 1234567// ...同前// 3.测试// [取，可行]只能为object类型Object o = generalList.get(0);// [插，不可]generalList.add(new Item()); generalList.add(new Hero()); // 编译错误 &lt; ? super 对象名&gt; 和*&lt; ? extends 对象名&gt;* 对象名不同，*&lt; ? super 对象名&gt;*代表可指向 对象名及父类。 如：&lt; ? super Hero&gt; ，代表可指向 Hero及其父类Object 。所以： 可插入：Hero &amp; 子类ADHero等（父类泛型可以插入子类对象） 不可取：无法将父类泛型转换成子类（向下转换），但是不可以像*&lt;?&gt;取出来是Object*类型吗？可行 12345678910// 1.定义&lt;? super&gt;泛型ArrayList&lt;? super Hero&gt; heroList = new ArrayList&lt;Hero&gt;();// 2.测试// [取，不可] 无法向下转换，父类转换成子类Hero h = heroList.get(0); // 不可，编译错误Object O = heroList.get(0); // 可行// [插，可行]heroList.add(new Hero()); heroList.add(new ADHero()); // 子类可插入 通配符取出、插入总结 取出 无论是何种通配符，取出是只要满足 向上转换 规则即可。 如：&lt;? extends Hero&gt; ,是 Hero及子类，只要转换的对象类型是通配符匹配所有类型的父类（或同级），即可插入。 显然，Hero 是*&lt;? extends Hero&gt;所有类型父类，所以可以取出转换成Hero*： 123ArrayList&lt;? extends Hero&gt; heroList = new ArrayList&lt;Hero&gt;();Hero h = heroList.get(0); // 可行 但是， & ，Hero不满足通配符所代表的所有类型类型父类，所以出错； 以此推论，向上转换成Object则行。 1234ArrayList&lt;? super Hero&gt; heroList = new ArrayList&lt;Hero&gt;();Hero h = heroList.get(0); // 编译错误Object O = heroList.get(0); // 可行 插入 插入即&quot;向下插入&quot;，插入对象是通配符匹配所有类型的子类（或同级）。 如：* & * ,它们的子类是不确定的，所以不能插入。 而：&lt;? extends Hero&gt; ，ADHero、Hero 显然满足符合该通配符匹配的所有类型子类（同级），故可以插入。 第十一章：Lambda 11.1 匿名类 使用时机 在new创建：一个类对象 、 一个接口子类对象、一个抽象类子类对象时。 12345类|接口 名字 = new 类|接口()&#123; @override 重写方法;&#125;； 如，下面 new Runnable接口实现了一个匿名类： 123456789// Runnable是一个接口Runnable x = new Runnable()&#123; @Override public void run() &#123; System.out.println(this.getClass()); &#125; &#125;; 我们知道，接口是不能被实例化的，上述代码实际是这么一个实现过程： {}相当于一个继承了Runnable接口 BUT 匿名的类实现了Runnable接口方法； 该匿名类则可以通过多态 转换成父类接口Runnable类型。 总结 在实际开发中，我们可以看到有方法，用抽象类、接口作参数实现多态。 而我们实际需要的是一个子类对象，如果该方法仅仅调用1 次，用匿名类简化格式，不必特地实现一个类继承该接口、抽象类。 11.2 Lambda 基本用法 Lambda 语法 在 java中，其表达式格式语法一般是：(parameters) -&gt; &#123; statements; &#125; 。 在满足一定条件下，还可以进一步简写： 参数类型可选 ：不需要声明参数类型，编译器可以统一识别参数值； 只有一个参数 ： 参数 ()可选 主体{}只有一条语句 ：此时 return 关键字 &amp; {} ，可不写。注意 ！ 主体{} 不省略时，哪怕只有一条语句，函数有返回值return关键字不可省！ 主体{} 省略时，return 也必须省略！ 以下是一些简单示例： 1234567891011121314// 1. 不需要参数,返回值为 5 () -&gt; 5 // 2. 接收一个参数(数字类型),返回其2倍的值 x -&gt; 2 * x // 3. 接受2个参数(数字),并返回他们的差值 (x, y) -&gt; x – y // 4. 接收2个int型整数,返回他们的和 (int x, int y) -&gt; x + y // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void) (String s) -&gt; System.out.print(s) Lambda 用于简化匿名类 在 9.5 Collections类 一节，我们用 Collections.sort(heros，Comparator) 静态方法去比较 Hero 的HP属性，进而按HP大小打印heros数组中各Hero对象信息。 我们用到匿名类覆写实现了 Comparator 接口： 123456789101112131415// 2.[匿名类]覆写比较器compare方法（比较规则）Comparator&lt;Hero&gt; comparable = new Comparator&lt;Hero&gt;() &#123;@Overridepublic int compare(Hero h1,Hero h2)&#123; if(h1.HP &gt; h2.HP) return 1; else return -1; // 注意，别写0 &#125;&#125;;Collections.sort(heros,comparable);System.out.println(heros); 这里可以将匿名类简写为： 1Comparator&lt;Hero&gt; comparable = (Hero h1,Hero h2) -&gt; &#123; return h1.HP &gt; h2.HP ? 1:0;&#125;; 还可以进一步简化： 12345// 1.去掉参数类型 // 2.去掉&#123;&#125;(只有一条语句) // 3.去掉return（只有一条语句 + 没有&#123;&#125;）Comparator&lt;Hero&gt; comparable = (h1,h2) -&gt; h1.HP &gt; h2.HP ? 1:0; Lambda 用于把方法作参数 在上面我们通过匿名类 或者 lambda简化，最终创建了Comparator对象comparable，然后调用方法： 12Comparator&lt;Hero&gt; comparable = (h1,h2) -&gt; h1.HP &gt; h2.HP ? 1:0;Collections.sort(heros,comparable); 我们可以更进一步，直接传递 lambda 表达式作为参数： 1Collections.sort(heros,(h1,h2) -&gt; h1.HP &gt; h2.HP ? 1:0); 最终上面代码被成功简化成一行。 当然还有其它匿名方法例子，实现遍历输出： 1public void forEach(@NotNull java.util.function.Consumer&lt;? super E&gt; action) 123456// 创建一个集合ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();array.add(4);array.add(5);array.add(3);array.add(1);// forEach方法参数有一个Cosumer接口，通过lambda表达式创建一个继承Cosumer接口匿名对象array.forEach(n -&gt; System.out.println(n)); 11.3 Lambda 聚合操作 在上面我们介绍了，如果方法参数是一个接口或者抽象类等，可利用Lambda 表达式作为方法参数。表达式创建一个继承该接口 |抽象类的匿名类，这种方法也叫做匿名方法。 我们可以用同时使用多个匿名方法，实现聚合操作。 实例介绍 1234567891011121314// 创建一个Hero类型集合，准备多个对象指定HPArrayList&lt;Hero&gt; heros = new ArrayList&lt;Hero&gt;();for(int i = 0 ; i &lt; 10 ; i++)&#123; String name = &quot;hero&quot;+i; int hp = (int)(Math.random()* 1000); heros.add(new Hero(name,hp)); // 带int参数构造函数&#125;// heros对象有多个方法，进行聚合操作heros .stream() .sorted((h1,h2) -&gt; h1.HP &gt; h2.HP ? 1:-1) // 比较器接口 .forEach(n -&gt; System.out.println(n)); // Cosumer接口 更多操作 实例参考，具体待用到补充：聚合操作 以 源为 List 为例： 中间操作方法 filter ：匹配 distinct： 去除重复(根据equals判断) sorted ：自然排序 sorted(Comparator) ：指定排序 limit ：保留 skip ：忽略 结束操作方法 forEach()：遍历每个元素 toArray() ：转换为数组 min(Comparator) ： 取最小的元素 max(Comparator)： 取最大的元素 count()： 总数 findFirst()：第一个元素 第十二章：多线程 12.0 基本知识 线程与进程介绍 什么是进程？ 打开任务管理管理器，可以看到很多【正在运行】的应用程序，这就是对应进程。 正在运行的应用程序； 系统分配和调用资源的基本单位 线程？单线程与多线程？ 线程：是进程的单个顺序控制流，是执行的最小单位（执行路径） 单线程：e.g. 记事本程序 一个进程如果只有一条执行路径，则为单线程 多线程：e.g. 扫雷程序：计时、玩家扫雷 一个进程如果有多条执行路径，则为多线程程序 子线程设置名字 &amp; 源码分析 MyThread.java 123456789101112131415161718package com.itheima_01;public class MyThread extends Thread &#123; // 必须要定义这个 public MyThread() &#123;&#125; // 调用父类（Thread）构造函数（一个参数的方法） // 调用顺序看下截图 public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; for(int i=0; i&lt;100; i++) &#123; System.out.println(getName()+&quot;:&quot;+i); &#125; &#125;&#125; MyThreadDemo.java 12345678910111213141516171819202122package com.itheima_01;/* 方式1：继承Thread类 1:定义一个类MyThread继承Thread类 2:在MyThread类中重写run()方法 3:创建MyThread类的对象 4:启动线程 */public class MyThreadDemo &#123; public static void main(String[] args) &#123; MyThread my1 = new MyThread(); MyThread my2 = new MyThread(); my1.setName(&quot;11&quot;);// my1.run();// my2.run(); //void start​() 导致此线程开始执行; Java虚拟机调用此线程的run方法 my1.start(); my2.start(); &#125;&#125; 获取Main方法进程名 不能使用Thread对象方法：getName()，因为没继承Thread 应该用Thread静态方法，Thread.currentThread 获取当前执行对象, 再调用getName() 1String mainTreadName = Thread.currentThread.getName() 线程调度 线程主要有两种调度【模型】： 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些 Java使用的是抢占式调度模型 ，具有随机性。 随机性 ：因为CPU在某个时刻只能执行一条命令，线程只有得到CPU时间片（使用权），才可以执行。而抢占式调度模型多线程执行具有随机性，谁抢到CPU是不确定的。 线程优先级： 通过设置线程优先级，可以让某个线程得到CPU的概率变大。（但不意味着是绝对优先，只是概率增大） 方法名 说明 final int getPriority() 返回此线程的优先级 final void setPriority(int newPriority) 更改此线程的优先级 线程默认优先级是5；线程优先级的范围1-10 线程生命周期 📓 面试重点！ 变为阻塞 ：是由 运行 状态进入的， 且是被sleep() 一些阻塞式方法导致的 变为就绪： 可能是 新建 状态获得资源，也可能是 运行 状态进入 12.1 多线程快速入门 不使用多线程 下面有一个 Hero 类，实现了attack 方法，用于模拟游戏人物进行攻击： 123456789101112131415161718192021222324252627package LOL;public class Hero&#123; String name; int HP; Hero(String name ,int hp) &#123; this.name = name; this.HP = hp; &#125; // 函数：攻击 public void attack(Hero h,int damage) &#123; h.HP -= damage; System.out.format(&quot;[%s]正在攻击[%s],[%s]血量为:[%d]..\\n&quot;, name,h.name,h.name,h.HP); if (h.isDead()) &#123; System.out.println(h.name + &quot;--已经挂了！\\n&quot;); &#125; &#125; // 函数：判断是否死亡 public boolean isDead() &#123; return 0 &gt;= HP ? true :false; &#125;&#125; 我们在主函数中，实例化游戏人物VN，garren 各自分别攻击 teemo、bh ： 12345678910111213141516171819package LOL;public class hello&#123; public static void main(String[] args) &#123; Hero VN = new Hero(&quot;VN&quot;,2500); Hero teemo = new Hero(&quot;teemo&quot;,3000); Hero gareen = new Hero(&quot;gareen&quot;,5000); Hero bh = new Hero(&quot;bh&quot;,2800); // 英雄开始攻击 while (!teemo.isDead()) VN.attack(teemo,100); while (!bh.isDead()) gareen.attack(bh,100); &#125;&#125; 因为都在主函数中的主线程中，显然应该先是VN 攻击，然后garren 进行攻击，这样一种串行方式。 但是实际游戏中，VN 和 garren 是可以同时进行攻击的，如何实现呢？ 多线程实现并行攻击 根据上面思考，我们应该分别把 VN攻击teemo 和 garren攻击bh 放在不同线程中并行执行。 一般来说，实现多线程我们有三种方式： 继承 Thread 类 实现 Runnable 接口 匿名类的方式 1. 继承 Thread 类 通过继承Thread 类，然后覆写run() 方法，在run() 方法写上需要并发的操作 。这样，在实例化对象后，执行对象方法 start() 启动后便会分配线程来执行 run() 中操作。 1234567891011121314151617181920212223package 多线程;import LOL.Hero;public class KillThread extends Thread&#123; private Hero h1; private Hero h2; public KillThread(Hero h1,Hero h2) &#123; this.h1 = h1; this.h2 = h2; &#125; // 覆写父类Thread中run()方法 @Override public void run() &#123; while (!h2.isDead()) // 模拟不断攻击敌方英雄 h1.attack(h2,100); &#125;&#125; 然后在主函数，实例化 KillThread 对象，执行start() 方法来创建线程，然后执行方法run() 中操作。 显然，下面KillThread 对象kh1、kh2，分别创建了两个线程执行 VN攻击Teemo，garren攻击bh。 📓 创建两个线程，代码排版中是串行的，但是实际执行是并行的。 12345678910111213141516171819package LOL;public class hello&#123; public static void main(String[] args) &#123; Hero VN = new Hero(&quot;VN&quot;,2500); Hero teemo = new Hero(&quot;teemo&quot;,3000); Hero gareen = new Hero(&quot;gareen&quot;,5000); Hero bh = new Hero(&quot;bh&quot;,2800); // 如果执行 kt1.run()、kt2.run() 不会创建新线程,相当于串行操作 KillThread kt1 = new KillThread(VN, teemo); kt1.start(); KillThread kt2 = new KillThread(gareen, bh); kt2.start(); &#125;&#125; 根据下面部分输出截图，可以发现 VN攻击Teemo，garren攻击bh 可以并行执行： 2. 实现 Runnable 接口 通过 实现 Runnable 接口 和 继承 Thread 类来实现多线程，大同小异。 相比继承Thread类，实现Runnable接口的好处： 避免了Java单继承的局限性 适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想 唯一需注意的是，Runnable 接口 虽然要求实现 run() 方法，但是： 直接调用*run()*方法，并不会启动一个新的线程。[面试]需要借助线程对象 start()方法，才会启动一个新的线程。 下面创建一个 Battle 类，实现Runnable 接口，可以看到：除了没有继承 Thread 类，其余都一模一样。 1234567891011121314151617181920212223package 多线程;import LOL.Hero;public class Battle implements Runnable // 以下和继承Thread方式代码一样&#123; private Hero h1; private Hero h2; public KillThread(Hero h1,Hero h2) &#123; this.h1 = h1; this.h2 = h2; &#125; // 覆写父类Thread中run()方法 @Override public void run() &#123; while (!h2.isDead()) // 模拟不断攻击敌方英雄 h1.attack(h2,100); &#125;&#125; 在主函数需要借助 Thread 对象 *start()*方法，启动一个新线程，这也是和直接继承 Thread 类不同地方： 123456789101112131415161718package LOL;public class hello&#123; public static void main(String[] args) &#123; Hero VN = new Hero(&quot;VN&quot;,2500); Hero teemo = new Hero(&quot;teemo&quot;,3000); Hero gareen = new Hero(&quot;gareen&quot;,5000); Hero bh = new Hero(&quot;bh&quot;,2800); Battle battle1 = new Battle(gareen,teemo); new Thread(battle1).start(); // 把Battle对象当做Thread构造函数参数传递进去 Battle battle2 = new Battle(bh,leesin); new Thread(battle2).start(); &#125;&#125; 3. 匿名类 在 2.实现 Runnable 接口 中，我们难免会想到通过匿名类方式来实现，因为它满足： 通过继承接口/类方式实现一个类(Battle) 该类对象仅被调用一次 当然，在 3.继承 Thread 类 中也满足上述条件，可以通过匿名类实例KillThread 对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package LOL;public class hello&#123; public static void main(String[] args) &#123; Hero VN = new Hero(&quot;VN&quot;,2500); Hero teemo = new Hero(&quot;teemo&quot;,3000); Hero gareen = new Hero(&quot;gareen&quot;,5000); Hero bh = new Hero(&quot;bh&quot;,2800); /* // 匿名类生成本来的KillThread对象 Thread t1= new Thread()&#123; public void run() &#123; while(!teemo.isDead()) gareen.attackHero(teemo); &#125; &#125;; */ // 匿名类实现生成Battlel类对象 Runnable battle1 = new Runnable() &#123; @Override public void run() &#123; while (!teemo.isDead()) VN.attack(teemo,100); &#125; &#125;; // 注意要有 ; 分号 new Thread(battle1).start(); Runnable battle2 = new Runnable() &#123; @Override public void run() &#123; while (!bh.isDead()) gareen.attack(bh,100); &#125; &#125;; new Thread(battle2).start(); &#125;&#125; 当然，我们还可以更进一步，使用 lambada 表达式： 12345678910111213141516171819package LOL;public class hello&#123; public static void main(String[] args) &#123; Hero VN = new Hero(&quot;VN&quot;,2500); Hero teemo = new Hero(&quot;teemo&quot;,3000); Hero gareen = new Hero(&quot;gareen&quot;,5000); Hero bh = new Hero(&quot;bh&quot;,2800); // 更进一步：通过lambada表达式 Runnable battle1 = () -&gt; &#123;while (!teemo.isDead()) VN.attack(teemo,100);&#125;; new Thread(battle1).start(); Runnable battle2 = () -&gt; &#123;while (!bh.isDead()) gareen.attack(bh,100);&#125;; new Thread(battle2).start(); &#125;&#125; 12.2 多线程常用方法 sleep() 方法 sleep() 是 Thread 类静态方法，可以使 当前 线程阻塞，并指定暂停时间，重点在于理解 当前： 下面是14.1中 3.匿名类 在主函数实现多线程代码，删减了 garren 攻击 bh 创建线程部分。 1234567891011121314151617181920212223242526272829package LOL;public class hello&#123; public static void main(String[] args) throws InterruptedException &#123; Hero VN = new Hero(&quot;VN&quot;,2500); Hero teemo = new Hero(&quot;teemo&quot;,3000); Hero gareen = new Hero(&quot;gareen&quot;,5000); Hero bh = new Hero(&quot;bh&quot;,2800); // [1]暂停1s Thread.sleep(1000); // sleep要处理异常，为了方便直接在主函数throw // 匿名类实现 Runnable battle1 = new Runnable() &#123; @Override public void run() &#123; // [2]暂停2s Thread.sleep(2000); while (!teemo.isDead()) VN.attack(teemo,100); &#125; &#125;; new Thread(battle1).start(); &#125;&#125; 可以看到上面有两个位置发生暂停： [1]暂停1s：显然当前线程是主线程，所以会使得主线程暂停1s； [2]暂停2s：执行完 new Thread(battle1).start(); 启动新线程1，新线程1会执行 run() 方法。那么当前线程就是线程1，线程1被暂停2s。 yield() 方法 yield() 也是 Thread 类静态方法，使当前线程变为就绪状态 （sleep() 是阻塞），使得其他线程更多机会获取CPU。 但不能指定暂停时间，因为线程重新到就绪状态 后，执行yield()的线程有可能在进入就绪状态 马上又被执行。 1234567891011121314151617181920212223242526272829package LOL;public class hello&#123; public static void main(String[] args) throws InterruptedException &#123; Hero VN = new Hero(&quot;VN&quot;,2500); Hero teemo = new Hero(&quot;teemo&quot;,3000); Hero gareen = new Hero(&quot;gareen&quot;,5000); Hero bh = new Hero(&quot;bh&quot;,2800); // [1]主线程从运行--&gt;就绪 Thread.yield(); // 实际测试没有效果，后面代码还是执行主函数代码，主线程立马又被调度了 // 匿名类实现 Runnable battle1 = new Runnable() &#123; @Override public void run() &#123; while (!teemo.isDead()) VN.attack(teemo,100); // [2]VN攻击teemo线程从运行--&gt;就绪 Thread.yield(); // 让出CPU调度 &#125; &#125;; new Thread(battle1).start(); &#125;&#125; join() 方法 slepp()、yield()都是Thread类静态方法，但jion() 是Thread类实例对象方法。 一种特殊的wait，当前 运行线程调用另一个线程的join方法。 当前线程进入阻塞状态直到join的线程运行结束 ，等待该线程终止。 注意该方法也需要捕捉异常。- ⚠️ 此时有其它子线程，也必须等到调用jion() 的线程先执行完毕。 ​ 123456789101112131415161718192021222324252627282930313233343536/* void join()：等待这个线程死亡 */public class ThreadJoinDemo &#123; public static void main(String[] args) &#123; ThreadJoin tj1 = new ThreadJoin(); ThreadJoin tj2 = new ThreadJoin(); ThreadJoin tj3 = new ThreadJoin(); tj1.setName(&quot;康熙&quot;); tj2.setName(&quot;四阿哥&quot;); tj3.setName(&quot;八阿哥&quot;); // 1.启动主线程后，三个线程抢占执行，谁都可能执行 tj1.start(); tj2.start(); tj3.start(); // 2.主线程继续往下执行， // 遇到设置康熙线程jion后，主线程和另外两个阿哥线程 // 【都阻塞】，等待康熙线程执行完 try &#123; tj1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;public class ThreadJoin extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(getName() + &quot;:&quot; + i); &#125; &#125;&#125; setPriority() 方法 setPriority() 用于设置优先级，优先级的高的线程更高几率获得 CPU 调度。有以下几个需要知道知识点： 线程优先级表示 线程优先级表示用整数：1~10，也可以用java 内置的三种 INT 型常量表示： 最低优先级 1：Thread.MIN_PRIORITY 普通优先级 5：Thread.MAX_PRIORITY 最高优先级10：Thread.NORM_PRIORITY 默认线程优先级 Java默认的线程优先级是 父线程的优先级，而非普通优先级 Thread.NORM_PRIORITY 。 详细参考 操作系统 一书，这里以一个简单实例说明。 123456789101112131415161718192021222324252627282930313233343536373839404142package LOL;public class hello&#123; public static void main(String[] args) throws InterruptedException &#123; Hero VN = new Hero(&quot;VN&quot;,2500); Hero teemo = new Hero(&quot;teemo&quot;,3000); Hero gareen = new Hero(&quot;gareen&quot;,5000); Hero bh = new Hero(&quot;bh&quot;,2800); Thread t1 = new Thread()&#123; @Override public void run() &#123; while (!teemo.isDead()) VN.attack(teemo,100); &#125; &#125;; Thread t2 = new Thread()&#123; @Override public void run() &#123; while (!bh.isDead()) gareen.attack(bh,100); &#125; &#125;; // 获取线程优先级 System.out.format(&quot;t1优先级%d，t2优先级%d\\n&quot; ,t1.getPriority(),t2.getPriority()); // 重新设置线程优先级 t1.setPriority(Thread.MAX_PRIORITY); t2.setPriority(Thread.MIN_PRIORITY); // 获取优先级 System.out.format(&quot;t1优先级%d，t2优先级%d\\n&quot; ,t1.getPriority(),t2.getPriority()); // 启动线程 t1.start(); t2.start(); &#125;&#125; setDaemon() 方法 setDaemon() 用于设置守护线程。什么是守护线程？ 简单理解，一个 进程 中用于守护其它线程的线程，如果其它线程结束，只剩下守护线程，那么进程 结束。 守护线程通常会被用来做：日志、性能统计等工作。 12// t1线程被设为当前进程的守护线程 t1.setDaemon(true); 创建一个破解线程用穷举法匹配指定的某密码；创建一个日志守护线程，打印用过哪些密码匹配。 🔑 由于日志线程是守护线程，那么破解线程匹配成功结束，守护线程日志也就结束了； 🔑 设置一个公共容器 LinkList 答案查看：多线程常用方法 设置三个线程：“关羽”、“张飞”、“刘备” 。“刘备”为当前线程（也是主线程），“关羽”和“张飞”为守护线程。 下面示例中，“刘备”线程挂了后，“关羽”、“张飞” 也马上停止了（但还是挣扎了会）。 12.3 多线程同步 多线程同步问题，指多线程同时修改一个数据时，导致数据不一致等。解决多线程问题，通常通过： volatile关键字 ：可保证可见性； synchronized关键字 ：是一个同步锁，保证原子性和可见性； Lock 接口：保证原子性和可见性，详情暂略。 在解释 volatile &amp; synchronized 同步锁前，先了解一些并发编程基本概念。 思考下面售票案例：为什么控制台会：1. 输出相同票、2.出现负数票？ 主函数类 12345678910111213141516public class SellTicketDemo &#123; public static void main(String[] args) &#123; //创建SellTicket类的对象 SellTicket st = new SellTicket(); //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称 Thread t1 = new Thread(st,&quot;窗口1&quot;); Thread t2 = new Thread(st,&quot;窗口2&quot;); Thread t3 = new Thread(st,&quot;窗口3&quot;); //启动线程 t1.start(); t2.start(); t3.start(); &#125;&#125; SellTicket 线程类 123456789101112131415public class SellTicket implements Runnable &#123; private int tickets = 100; //在SellTicket类中重写run()方法实现卖票，代码步骤如下 @Override public void run() &#123; while (true) &#123; if (tickets &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot;张票&quot;); tickets--; &#125; &#125; &#125;&#125; 解释 相同票：打印出售票、 tickets-- 两条语句共享tickets变量，导致没有及时更新tickets变量 出现负数票： if (tickets &gt; 0) 语句判断和 tickets--共享tickets变量 ，没有及时更新tickets变量 1.如何解决多线程 安全问题出现的条件 是多线程环境 有共享数据 有多条语句操作（包含，读、写等）共享数据 为什么一定要求是一个线程有多条语句操作共享数据？ 如果两个线程，各只有一条语句操作数据，虽然线程执行具有随机性，但是无论哪个线程执行自己那条语句（是原子性语句）时，其它线程即使此刻抢占到CPU，修改了共享变量。但由于前一个线程不再会执行共享数据相关操作，因此实际是不影响的。 ⚠️ 区分多线程中线程来源同一个类和不同类情况。 两个线程来自同一个线程类两个对象 ，该类有多条语句修改共享类变量的操作 ；锁住类的共享操作数据语句保证同一时候只有一个线程对共享变量进行修改 【消费生产问题】两个线程来自不同线程类，但各有一条或多条语句对共享变量进行修改 ；使用P、V操作保证同一时候只有一个线程对共享变量进行修改。参考 ：7.生产者消费者 小节实例 JAVA中使用 wait()、notifyAll() 来实现，但是和PV操作逻辑是不一样的。 如何解决多线程安全？ 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可 Java提供了同步代码块的方式来解决 1234synchronized(任意对象) &#123; // 多条语句操作共享数据的代码&#125; synchronized同步方式优缺点？ 好处：解决了多线程的数据安全问题 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率 尝试synchronized解决售票问题 为什么下面这种方式，执行还是一样的问题？ 因为每次创建线程对象，锁对象new Object 也是重新创建的，三个线程对象三把锁，所以锁不住 因此，我们要定义一个公共的锁对象： 2.原子性、可见性、有序性 原子性 即一个或多个操作，要么全部执行，要么全部不执行，类似于数据库事务概念。 在 java 中，基本数据类型的变量的读取和赋值操作是原子性操作，其余不是，例如： 【面试高频】判断：下面语句1~4，都是原子性操作吗？（即是否每条语句包含的操作要么都完成/要么都不完成） 1234x = 10; // 语句1y = x; // 语句2x++; // 语句3x = x + 1; // 语句4 其实，除了第一条语句，其余都不是原子性操作。 x = 10：线程执行该语句将10写入内存； y = x：读取x值 --&gt; 然后将10写入内存，进行了两次操作； x++ ：读取x值 --&gt; 进行+1操作 --&gt; 写入新值，进行了三次操作； x = x + 1：同x++，三次操作。 所以，只有x=10这种简单赋值操作是原子性语句。在 java中提供了 synchronized 关键字 和Lock 接口来实现。 可见性 对于可见性，Java 提供了volatile 关键字来保证可见性，当然synchronized 关键字 和Lock 接口也可以保证。 可见性，即指一个共享变量被volatile 修饰时，它会保证修改的值会立即被更新到主存。当有其他线程需要读取时，它会去内存中读取新值。 有序性 在Java内存模型中，允许编译器和处理器对指令进行重排序。但是重排序过程不会影响到 单线程 程序的执行，却会影响到 多线程 并发执行的正确性。 在java 中，也是通过 volatile关键字来保证一定的“有序性&quot;。 12345678910//线程1:context = loadContext(); //语句1 context初始化操作inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;System.out.println(context); 由于指令重新排序，可能导致语句2先于语句1执行。即相当于inited = ture被执行 ， context = loadContext() 未被执行。然后线程2 错误判读已经初始化完毕 ，执行System.out.println(context); 打印出context 。 通过加上volatile 关键字对 inited 变量进行修饰，可以避免这种情况。 因为，程序执行到volatile修饰变量读/写操作时，保证在其前面的操作肯定已经完成，后面操作未执行。 1volatile inited = true; 3.volatile 关键字 volatile 关键字主要有两个作用：使被修饰变量具有可见性 &amp; 禁止指令重排保证可见性。 保证可见性，见前。这里结合实例保证被修饰变量具有可见性。 设计一个线程1不断学狗叫，一个线程2过1秒结束这令人窒息的操作。 12345678910111213141516171819202122232425262728293031323334353637383940// 线程类，有一个学狗叫操作import 多线程.test_Thread;public class test_Thread extends Thread&#123; public volatile boolean flag = true; @Override public void run() &#123; while (flag) System.out.println(&quot;我在学狗叫：汪汪汪~&quot;); &#125;&#125;// 主函数中public class test&#123; public static void main(String[] args) throws InterruptedException &#123; test_Thread t1 = new test_Thread(); Thread t2 = new Thread()&#123; // 匿名类方式生成一个线程1s后结束t1线程 @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; t1.flag =false; // 把flag设置为flase，由于可见性，将结束线程t1中while循环 &#125; &#125;; t1.start(); t2.start(); &#125;&#125; 实际输出：过了大概1s，线程1停止了学狗叫。 4.synchronized关键字 volatile 关键字可以保证可见性，但是不能保证原子性，会导致多线程出现脏数据等问题。例如下面例子： 1. 一个DEMO ⚠️ java 函数不能改变int类型实参，也不能加上ref 关键字改变！所以出此下策：把数组当做参数传递，组第一个元素是我们想通过函数改变的值。数组是引用类型，可以改变里面的值。 1234567891011121314151617181920212223242526272829303132333435363738// 线程类IncreaseThreadpublic class IncreaseThread extends Thread&#123; private int[] num; public IncreaseThread(int[] num) &#123; this.num = num; &#125; // 函数使得num值被修改 @Override public void run() &#123; num[0]++; &#125;&#125;// 主函数中import 多线程.IncreaseThread;public class test&#123; public static void main(String[] args) throws InterruptedException &#123; int[] num = new int[]&#123;0&#125;; Thread addThreads[] = new Thread[100000]; for (int i = 0 ; i &lt; 100000 ; i++) &#123; IncreaseThread ih = new IncreaseThread(num); ih.start(); addThreads[i] = ih; &#125; // 所有增加子线程都加入主线程中，保证子线程都【先】执行完 // *如果线程已经执行完，不会在执行吧？是 // *如果没有这行代码，子线程也会在主线程执行完继续执行 for (Thread t : addThreads) t.join(); System.out.println(num[0]); // 输出有时候是：999995 / 99996 .. &#125;&#125; 2. 分析结果 我们看到输出结果并非为100000，这是为什么？ 因为 num[0]++; 并非是原子性语句，它由三个操作：取num[0]值 --&gt; +1 操作 --&gt; 写入 num[0] 三个操作组成。 在多线程这将导致一个问题，例如恰好某时刻 num[0] = 100，存在线程A、B： 线程A，取出*num[0]*值 = 100，准备进行+1操作 线程B，恰好也取出*num[0]*值 = 100 线程A，执行num[0]++ 操作，num[0] = 101 线程B，也执行 num[0]++ 操作，所以 num[0] = 101没有被改变 所以线程A、B写入值都是101，没有正确顺序执行++操作。 这就是为什么每次运行结果都是 &lt;100000。 3. synchronized 同步锁 我们可以用synchronized 关键字保证同一时刻只有一个线程获取锁，然后执行同步代码。 【面试】synchronized只能修饰：类、方法或代码块，不能修饰变量。 在 IncreaseThread 类中给 run() 函数加上同步锁： 12345@Overridepublic synchronized void run()&#123; num[0]++;&#125; 保证了 num[0]++ 操作同一时刻只有一个线程可以执行。经过多次测试输出结果 == 100000。 ⚠️ 直接给 run() 加锁也许并不是一个好做法，这会使得里面所有需要并行操作都加锁。因为这里只有 num[0]++ 这一条语句故这样写。更好的做法是，单独设计一个函数包含++操作，然后给这个函数加锁，在run()中调用。 4. 匿名类使用同步锁 匿名类下就没法用synchronized关键字限定一个函数，然后run() 执行这个函数（当然你可以限定 run() …） 我们可以首先定义一个object 常量： 1final Object someObject = new Object(); 然后在匿名类中，synchronized (someObject)&#123; // 包含要原子性执行的语句 &#125;，下面是示例。 暂时不明白synchronized (someObject) 设置不同参数有何作用？ 123456789101112131415161718192021222324252627282930public class test&#123; public static void main(String[] args) throws InterruptedException &#123; int[] num = new int[]&#123;0&#125;; Thread addThreads[] = new Thread[100000]; final Object someObject = new Object(); for (int i = 0 ; i &lt; 100000 ; i++) &#123; Thread ih = new Thread() &#123; @Override public void run() // 不推荐：synchronized限定run() &#123; // synchronized体&#123;&#125;代码被独占 synchronized (someObject) &#123; num[0]++; &#125; &#125; &#125;; ih.start(); addThreads[i] = ih; &#125; // 所有增加子线程都加入主线程中，保证子线程都执行完 for (Thread t : addThreads) t.join(); System.out.println(num[0]); // 多次测试输出是：100000 &#125;&#125; 5. synchronized 同步方法 同步对象方法 给上述卖票代码加个else语句：偶数执行if，奇数执行else。esle语句存在一个方法，给它加上锁。 但是synchronized 关键字直接加到方法上会出问题： 同步对象方法的默认锁是this （默认且不能指认），而前述if语句的是的锁是obj ，两把锁是不一样的！ 因此要把锁改为this 1234567891011121314151617181920212223242526272829303132333435363738public class SellTicket implements Runnable &#123; private int tickets = 100; private Object obj = new Object(); private int x = 0; @Override public void run() &#123; while (true) &#123; if (x % 2 == 0) &#123; // synchronized (obj) &#123; // 应该改为this synchronized (this) &#123; if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot;张票&quot;); tickets--; &#125; &#125; else &#123; sellTicket(); &#125; x++; &#125; &#125;// private synchronized void sellTicket() &#123;// if (tickets &gt; 0) &#123;// try &#123;// Thread.sleep(100);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot;张票&quot;);// tickets--;// &#125;// &#125; 同步静态方法 同步静态方法默认锁是当前类 ，因此不能用对象方法的锁this 可以采用反射：&lt;类名&gt;.class 获取当前类的字节码 5.常见线程安全的类 共同点 不同点 HashMap &amp; Hashtable（安全） 都实现了Map接口，按键值对保存数据。 1.HashMap可以存null，Hashtable不可以。2. Hashtable是线程安全类，put()方法用synchronized 关键字修饰。 StringBuffer（安全） &amp;StringBuilder 操作字符串，可以进行字符串拼接等操作。 1.StringBuilder 是线程安全类，比如 public synchronized StringBuilder append(int i) 方法，用了synchronized关键字 ArrayList &amp; Vector（安全） 都是可扩展动态数组 1.同上查看源码得知，Vector 是线程安全类。 把非线程安全集合转为线程安全 借助工具类 Collections 中静态方法 Collections.synchronizedList() 可以进行非安全集合到安全转换。 注意：StringBuffer 不属于集合范畴，不能转换。 1234567ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt; ();// 错误写法：返回是list无法转换为 Arraylist//ArrayList&lt;Integer&gt; list2 = Collections.synchronizedList(list1);List&lt;Integer&gt; list2 = Collections.synchronizedList(list1);HashMap&lt;Integer,String&gt; map1 = new HashMap&lt;&gt; ();Map&lt;Integer,String&gt; map2 = Collections.synchronizedMap(map1); 6.Lock锁 创建Lock锁 123456789101112131415161718192021222324252627mport java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class SellTicket implements Runnable &#123; private int tickets = 100; private Lock lock = new ReentrantLock(); @Override public void run() &#123; while (true) &#123; try &#123; lock.lock(); // 加锁 if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot;张票&quot;); tickets--; &#125; &#125; finally &#123; lock.unlock(); // Lock要手动释放锁 &#125; &#125; &#125;&#125; 7.生产者消费者 生产者消费者问题 生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。 常用方法 案例分析 生产者消费者案例中包含的类： 奶箱类(Box)：存储一个共享成员变量mike，表示第x瓶奶，提供存储牛奶put()和获取牛奶get()的操作 生产者类(Producer)：实现Runnable接口，重写run()方法，调用存储牛奶put()的操作，循环放30瓶 消费者类(Customer)：实现Runnable接口，重写run()方法，调用获取牛奶get()的操作，死循环不断获取 测试类(BoxDemo)：里面有main方法，main方法中的代码步骤如下: 创建奶箱对象，这是共享数据区域 创建消费者创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作对象 把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作 创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递 启动线程 为什么Object.wait(),Object.notify(),Object.notifyAll()必须在同步块synchronized中执行呢? ⚠️ 重点看下面P、V逻辑和wait()、notify() 逻辑区分。 在Java中，我们使用wait()和nofify()或notifyAll()来实现线程间通信。一个线程在测试条件不满足后进入等待状态; 在经典的生产者-消费者问题中，生产者线程因缓存区满而等待，消费者线程在消费了缓存区的一个元素后通知生产者线程。 调用notify()和notifyAll()方法来通知一个或多个线程一个条件已经改变了。一旦通知线程退出同步方法或同步块，所有等待的线程会争抢它们等待对象上的对象锁。 获取锁的线程会从等待状态返回并继续执行。 下面只用synchronized关键字锁住put和get操作，由于消费者while(true)一直消费会导致控制台最后一直输出： 123456...用户拿到第30瓶奶用户拿到第30瓶奶用户拿到第30瓶奶用户拿到第30瓶奶用户拿到第30瓶奶 必须要设置进程间通信，只用生产者put() 了一瓶奶，才能允许消费者取get() 牛奶 。 12345678910111213141516171819public class BoxDemo &#123; public static void main(String[] args) &#123; //创建奶箱对象，这是共享数据区域 Box b = new Box(); //创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作 Producer p = new Producer(b); //创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作 Customer c = new Customer(b); //创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递 Thread t1 = new Thread(p); Thread t2 = new Thread(c); //启动线程 t1.start(); t2.start(); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115public class Box &#123; //定义一个成员变量，表示第x瓶奶 private int milk; //定义一个成员变量，表示奶箱的状态 private boolean state = false; //提供存储牛奶和获取牛奶的操作 public synchronized void put(int milk) &#123; //如果有牛奶，等待消费 */ if(state) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果没有牛奶，就生产牛奶 this.milk = milk; System.out.println(&quot;送奶工将第&quot; + this.milk + &quot;瓶奶放入奶箱&quot;); //生产完毕之后，修改奶箱状态 state = true; //唤醒其他等待的线程 notifyAll(); &#125; public synchronized void get() &#123; //如果没有牛奶，等待生产 if(!state) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果有牛奶，就消费牛奶 System.out.println(&quot;用户拿到第&quot; + this.milk + &quot;瓶奶&quot;); //消费完毕之后，修改奶箱状态 state = false; //唤醒其他等待的线程 notifyAll(); &#125;&#125;public class Box &#123; //定义一个成员变量，表示第x瓶奶 private int milk; //定义一个成员变量，表示奶箱的状态 private boolean state = false; //提供存储牛奶和获取牛奶的操作 public synchronized void put(int milk) &#123; //如果有牛奶，等待消费 if(state) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果没有牛奶，就生产牛奶 this.milk = milk; System.out.println(&quot;送奶工将第&quot; + this.milk + &quot;瓶奶放入奶箱&quot;); //生产完毕之后，修改奶箱状态 state = true; //唤醒其他等待的线程 notifyAll(); &#125; public synchronized void get() &#123; //如果没有牛奶，等待生产 if(!state) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果有牛奶，就消费牛奶 System.out.println(&quot;用户拿到第&quot; + this.milk + &quot;瓶奶&quot;); //消费完毕之后，修改奶箱状态 state = false; //唤醒其他等待的线程 notifyAll(); &#125;&#125;public class Producer implements Runnable &#123; private Box b; public Producer(Box b) &#123; this.b = b; &#125; @Override public void run() &#123; for(int i=1; i&lt;=30; i++) &#123; b.put(i); &#125; &#125;&#125; 12.4 线程交互 生成者、消费者问题：p = synchronized ，占有；v = this.wait 释放。 Sleep()方法 Wait()方法 sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会; wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问； sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁 wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。 在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。 wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。 ❔ 试着解释下面分别用 sleep(2000) 和 wait(2000)的输出结果： 123456789101112131415161718192021222324252627282930313233343536373839public class ThreadTest implements Runnable &#123; int number = 10; public void firstMethod() throws Exception &#123; synchronized (this) &#123; number += 100; // 执行到这number=110 System.out.println(number); &#125; &#125; public void secondMethod() throws Exception &#123; // synchronized 保证原子性，代码只能被全部执行或不执行 synchronized (this) &#123; /** * (休息2S,阻塞线程) * 以验证当前线程对象的机锁被占用时, 是否被可以访问其他同步代码块 */ Thread.sleep(2000); // 输出 2100 //this.wait(2000); // 输出 110 number *= 200; &#125; &#125; @Override public void run() &#123; try &#123; firstMethod(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws Exception &#123; ThreadTest threadTest = new ThreadTest(); Thread thread = new Thread(threadTest); thread.start(); // 执行firstMethod() threadTest.secondMethod(); &#125;&#125; 12.5 线程池快速入门 创建一个线程池 下面表示创建一个：拥有线程个数为10、最多可增长至15，允许线程空闲60s后被回收，线程池。 123456import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;// 主函数中ThreadPoolExecutor threadPool= new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); ThreadPoolExecutor 类用于实现线程池，其创建多线程的构造函数原型如下： ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, RejectedExecutionHandler handler) corePoolSize ：表示线程池最低拥有的线程数 maximumPoolSize ：表示线程池最多可增长到线程数 keepAliveTime &amp; unit：表示线程空闲后的存活时间，超过后会被回收，最终保持池中10个线程 workQueue ：存放任务的阻塞队列 handler：当队列和最大线程池都满了之后的饱和策略 执行任务 通过 ThreadPoolExecutor 对象 execute() 方法执行任务，接受的参数为 Runnable 类型。 public void execute( Runnable command ) 1234567threadPool.execute(new Runnable()&#123; @Override public void run() &#123; System.out.println(&quot;执行任务&quot;); &#125;&#125;; DEMO : 遍历搜寻文件夹 🎉 对指定文件夹进行遍历搜寻，如果找到文件含有“黄旺辉”字样，就分配一个线程对该文件进行处理。 1234567891011121314151617181920212223242526272829303132333435363738import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.io.File;public class test&#123; public static void main(String[] args) throws InterruptedException &#123; // 1.创建线程池 ThreadPoolExecutor threadPool= new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); // 2.搜寻指定文件 t.searchFile(&quot;D:/hwh/uploadToGit/本科&quot;,threadPool); &#125; // 函数：搜寻指定文件 public void searchFile(String root, ThreadPoolExecutor threadPool) &#123; File f = new File(root); // 每个文件/文件夹都一定会被遍历到：所以可以在这里判断是否是文件 if (f.getName().contains(&quot;黄旺辉&quot;)) // 找到满足条件文件开始分配任务 &#123; // 设定任务 Runnable task = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;子线程在对指定文件执行任务：&quot; + f.getName()); &#125; &#125;; // 分配线程执行任务 threadPool.execute(task); return; &#125; //递归搜寻 for(File file : f.listFiles()) searchFile(file.getAbsolutePath(),threadPool); &#125;&#125; 第十三章：网络编程 13.1 基本知识 服务器和客户端通信 上图表示，服务器IP：192.168.1.100 ，客户端IP：192.168.1.189，它们分别通过各自的端口 8080、1087 和对方进行通信。 如何获取本机IP地址？ 通过java自带API 获取本机IP可以通过java自带的API，引用类：java.net.InetAddress 1234567891011121314import java.net.InetAddress;import java.net.UnknownHostException;try&#123; // 调用getLocalHost()，必须处理异常UnknownHostException InetAddress host = InetAddress.getLocalHost(); String ip = host.getHostAddress(); System.out.println(&quot;本机IP地址是：&quot; + ip);&#125;catch (UnknownHostException e)&#123; System.out.println(e.getMessage());&#125; cmd命令：ipconfig 1C:\\Users\\86151&gt; ipconfig ping 命令 通过java自带API 直接复制粘贴，需要时再看。 123456789101112131415161718192021222324import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader; public class TestSocket &#123; public static void main(String[] args) throws IOException &#123; Process p = Runtime.getRuntime().exec(&quot;ping &quot; + &quot;192.168.2.106&quot;); // 缓存流，建立在字符流之上 // InputStreamReader类继承字符流类Reader，可使得字节流向字符流转换 // 注意加上 &quot;gbk&quot;，否则执行的命令乱码 Reader reader = new InputStreamReader(p.getInputStream(),&quot;gbk&quot;); BufferedReader br = new BufferedReader(reader); String line = null; StringBuilder sb = new StringBuilder(); while ((line = br.readLine()) != null) &#123; if (line.length() != 0) sb.append(line + &quot;\\r\\n&quot;); &#125; System.out.println(&quot;本次指令返回的消息是：&quot;); System.out.println(sb.toString()); &#125;&#125; 通过cmd命令ping ping某个IP地址，这个IP是网关地址 1C:\\Users\\86151&gt; ping 192.168.0.1 ping一个主机名，如果能返回说明：DNS解析正确，且本机或本网和外部连接正确 1C:\\Users\\86151&gt; ping baidu.com 13.2 实战测试网络连通 观察本地网络设置是否正确： ipconfig /all 检测本地TCP/IP 协议：Ping 127.0.0.1 IP地址由两个部分组成，即网络地址和主机地址 ，（IPV4）长4个字节，32位。根据网络地址占的字节数不同，分为A、B、C三类及特殊地址D、E。全0和全1的都保留不用。 A类：第1个字节为网络号，后3个字节为主机号。最前面为“0”，所以地址网络号取值于1~126之间 。而保留的127（01111111）+ 0.0.1 就是 本地回送地址 ，一般用于测试。 本机回送地址（Loopback Address），即主机IP堆栈内部的IP地址，主要用于（1）网络软件测试 以及（2）本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回，不进行任何网络传输。 有返回接收则配置正确。 检查本地IP地址是否有误：ping 本机IP 参考：好文：ping到底做了什么？ 有返回接收则配置正确，否则要重新配置下。 检查硬件问题 &amp; 本机与本地网络连接是否正常（非局域网可忽略）：ping 本机网关IP 网关和路由器区别？ 网关设备：一个大概念，不具体特指一类产品，只要 连接两个不同的网络的设备都可以叫网关； 路由器：一般特指能够 实现路由寻找和转发的 特定类产品，路由器很显然能够实现网关的功能。 默认网关：不是一个产品而是一个网络层的概念，PC本身不具备路由寻址能力，所以PC要把所有的IP包发送到一个 默认的中转地址 上面进行转发，也就是默认网关。 可以在路由器、三层交换机上，可以在防火墙上，可以在服务器上，所以和物理的设备无关。 检查本网或本机与外部连接是否正常： Ping 远程IP地址 有些 IP是ping不通的，因为有防火墙或者其它设置，这里百度找了个能ping通的。 在5. 基础上检查DNS解析：ping 域名 如果可以ping通，则说明域名解析可正常运行。 13.3 网络编程通信实战 ​ 在13.1中介绍了服务器和客户端通过各自端口进行简单通信。本节通过实战编程，实现服务端和客户端简单交流对话。 如何编程实现通信？ ​ 通过套接字：{ IP地址，端口号 } ，Java 有封装好类 ServerSocket &amp; Socket ，进而通过套接字输入、输出流 实现通信。 服务端通过 ServerSocket 对象 ss打开端口； 客户端创建套接字 Socket 对象 socket 连接到服务端，并通过 套接字建立 输出流 进行数据传输； 服务端通过 ServerSocket 对象 ss.accept() 方法，返回 Socket 对象（客户端的？），通过 输入流 读数据； 服务端进行回应，并关闭服务。 编程实现 客户端 - Client 1234567891011121314151617181920212223242526272829303132333435363738package QQ;import java.io.IOException;import java.net.Socket;import java.io.OutputStream;public class Client&#123; Socket socket; /** * 构造函数：套接字初始化连接的主机和端口 * @param host 指定连接的主机 * @param post 指定连接的端口 */ public Client(String host,int post) throws IOException &#123; socket = new Socket(host,post); &#125; /** * 客户端发送指定消息 * @param clientMsg 要发送的消息内容 */ public void msg(String clientMsg) throws IOException &#123; // 1.建立[套接字字节输出流]对象发生消息 OutputStream os = socket.getOutputStream(); // 2.客户端发消息 // 注意String类型 --&gt; byte[] os.write(clientMsg.getBytes()); // 3.注意：客户端套接字必须要关闭，才开始连接服务端 socket.close(); &#125;&#125; Q1 : 为什么设计每个方法 t hrows IOException ？ A1: 因为创建套接字对象socket | 调用对象方法 ，都要处理 IOException 异常，每个方法写 try catch 太麻 烦，不如先抛出异常，在主函数中统一处理。 Q2 : 为什么msg() 方法发送完消息立马关闭套接字 socket.close() ，而不是等服务器接收了再关闭 ？ A1: 事实上，只有先关闭套接字socket.close() ，客户端才会开始连接服务端！ 服务端 - Server ⚠️ ServerSocket 对象 ss.accept() 方法，必须客户端建立连接之后，否则会一直阻塞！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package QQ;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.io.InputStream;public class Server&#123; ServerSocket ss; Socket socket; /** * 打开端口，建立套接字对象监听端口 * @param post 要打开的服务端端口 */ public Server(int post) throws IOException &#123; ss = new ServerSocket(post); &#125; /** * 关闭套接字连接 */ public void close() throws IOException &#123; ss.close(); socket.close(); &#125; /** * 服务端对客户发来的消息进行回应 */ public void response() throws IOException &#123; // 1.注意：客户端必须已经连接，否则会一直阻塞 socket = ss.accept(); // 2.建立[套接字字节输入流]，读取客户端发过来的消息 InputStream is = socket.getInputStream(); byte[] all = is.readAllBytes(); // 3.类型转换: 将byte[] ---&gt; String String clientMsg = new String(all); // 4.回应客户端 System.out.println(&quot;服务端回复-小白兔回道：&quot; + reMsg(clientMsg)); &#125; public String reMsg(String clientMsg) &#123; if(clientMsg.contains(&quot;你好&quot;)) &#123; return &quot;你好！我是小白兔。&quot;; &#125; else if (clientMsg.contains(&quot;沙雕&quot;)) &#123; return &quot;你才是沙雕！你全家都是沙雕！&quot;; &#125; else if (clientMsg.contains(&quot;你叫什么&quot;)) &#123; return &quot;my name is dad&quot;; &#125; else if (clientMsg.contains(&quot;我好烦呀~&quot;)) &#123; return &quot;放下得自在。&quot;; &#125; return &quot;风太大，没听清！&quot;; &#125;&#125; 主函数串联 123456789101112131415161718192021try&#123; // 服务端打开端口 Server server = new Server(8886); // 客户端连接端口 Client client = new Client(&quot;127.0.0.1&quot;,8886); Scanner s = new Scanner(System.in); System.out.print(&quot;客户端-大灰狼说道：&quot;); String clientMsg = s.nextLine(); // 客户端通过套接字输出流发生消息 client.msg(clientMsg); // 服务端通过套接字输入流进行回应 server.response(); server.close();&#125;catch (IOException e)&#123; System.out.println(e.getMessage());&#125; 第十四章：JDBC 14.1 JDBC 快速入门 什么是 JDBC？ JDBC 即 Java DataBase Connection ，是JAVA 的一个 API 通过 JAVA 访问数据库。 其一般执行流程如下： 连接数据源，如数据库 进行增删查改指令 处理响应并返回结果 下载 JDBC 官网下载驱动包 下载地址：Download Connector/J 选择：Platform Independent —&gt; mysql-connector-java-8.0.16.zip ，然后下载： 坑：下面还有一个下载MySQL Installer ，是下载 mysql 全家桶 ！ 解压 解压之后会在下载目录出现：mysql-connector-java-8.0.16 文件夹，里面有我们要的 jar 包： 引用包 在工程目录下新建一个文件夹：lib ，然后将 mysql-connector-java-8.0.16.jar 包复制到该目录下。 在IDEA中，右键选择该jar 包 --&gt; Add as Library ，即可添加成功。 更好的添加包方法点击：IDEA导入包两种方法 简单 DEMO mysqlDB 类 在 mysqlDB 类中主要有三个函数，负责执行操作数据库对应三个流程： mysqlDB() 连接数据库 🔈 最新 SQL 驱动： 1.加载驱动程序 这步可以省略。 123456789public mysqlDB(String url,String user,String passwd) throws Exception&#123; this.URL = url; this.USER = user; this.PASSWD = passwd; // 1.加载驱动程序 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 2.获取数据库连接 conn = DriverManager.getConnection(url,user,passwd); System.out.println(&quot;成功连接数据库！&quot;);&#125; crudDB() 增删查改 crudBOY 表演时刻：执行指定 sql 语句。 1234567public ResultSet crudDB(String sql) throws Exception&#123; // 3.操作数据库 Statement s = conn.createStatement(); ResultSet rs = s.executeQuery(sql); return rs;&#125; exit() 退出 Statement 对象应该也关闭，这里没。 1234public void exit() throws Exception&#123; conn.close();&#125; 主函数中 在主函数中串接所有流程，和数据库进行 Connection 连接需提供 url ： url = “jdbc:mysql://&lt;地址&gt;:&lt;端口&gt;/&lt;数据库名&gt;?serverTimezone=UTC” &lt;地址&gt;：这里选择本机地址，127.0.0.1 / localhost &lt;端口&gt;：mysql 专用端口，3360 &lt;数据库名&gt;：预先准备好的数据库，test ⚠️?serverTimezone=UTC ：新版驱动器出现的问题，要指定 time zone value 。 123456789101112131415161718192021222324252627282930import JDBC_demo.mysqlDB;import java.sql.ResultSet;public class hello&#123; public static void main(String[] args) &#123; try &#123; final String url = &quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;; final String user = &quot;root&quot;; final String passwd = &quot;123456&quot;; String sql = &quot;SELECT * FROM student WHERE gender = &#x27;F&#x27;;&quot;; // 连接数据库--执行sql语句 mysqlDB mdb = new mysqlDB(url, user, passwd); ResultSet rs = mdb.crudDB(sql); // 读取指定列名数据 while(rs.next()) &#123; System.out.println(rs.getString(&quot;name&quot;) + rs.getInt(&quot;score&quot;)); &#125; mdb.exit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; mysqlDB 类完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package JDBC_demo;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;public class mysqlDB&#123; final String URL ; final String USER ; final String PASSWD ; Connection conn; /** * 构造函数：进行初始化和数据库连接 * @param url jdbc:mysql://127.0.0.1:3306/&lt;数据库名&gt; * @param user mysql账号 * @param passwd mysql密码 */ public mysqlDB(String url,String user,String passwd) throws Exception &#123; this.URL = url; this.USER = user; this.PASSWD = passwd; // 1.加载驱动程序 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 2.获取数据库连接 conn = DriverManager.getConnection(url,user,passwd); System.out.println(&quot;成功连接数据库！&quot;); &#125; /** * 执行增删查改 * @param sql 要执行的sql语句 */ public ResultSet crudDB(String sql) throws Exception &#123; // 3.操作数据库 Statement s = conn.createStatement(); ResultSet rs = s.executeQuery(sql); return rs; &#125; public void exit() throws Exception &#123; conn.close(); &#125;&#125; 14.2 查询技巧 ​ 因为，增、删、改并不需要处理返回的数据，比较简单就是执行sql 语句即可。但是查询较为复杂，这里来通过几个查询实例，来进一步熟悉 JDBC API。 验证用户登陆 student 表中没有设置密码字段，所以下面只验证了名字，简单表达意思。 123456789101112131415161718192021222324252627282930import JDBC_demo.mysqlDB;import java.sql.ResultSet;public class hello&#123; public static void main(String[] args) &#123; try &#123; final String url = &quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;; final String user = &quot;root&quot;; final String passwd = &quot;123456&quot;; String sql = &quot;SELECT * FROM student WHERE name = &#x27;&#x27;&quot; + &quot;刘婷&#x27;&quot;; // 连接数据库--执行sql语句 mysqlDB mdb = new mysqlDB(url, user, passwd); ResultSet rs = mdb.crudDB(sql); // 进行判断 if(rs.next()) // re.next() 返回的是bool类型，没有找到数据返回false System.out.println(&quot;账号密码正确&quot;); else System.out.println(&quot;账号密码错误&quot;); mdb.exit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 拼接字符串有个坑，要注意给字符串类型&quot;刘婷&quot;加上单/双引号： 1String sql = &quot;SELECT * FROM student WHERE name = &#x27;&#x27;&quot; + &quot;刘婷&#x27;&quot;; 获取总数 123456789101112131415161718192021222324252627282930import JDBC_demo.mysqlDB;import java.sql.ResultSet;public class hello&#123; public static void main(String[] args) &#123; try &#123; final String url = &quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;; final String user = &quot;root&quot;; final String passwd = &quot;123456&quot;; String sql = &quot;SELECT count(*) FROM student WHERE gender = &#x27;F&#x27;&quot;; // 连接数据库--执行sql语句 mysqlDB mdb = new mysqlDB(url, user, passwd); ResultSet rs = mdb.crudDB(sql); // 进行判断 rs.next(); // 读取下一行数据，这里是第一行 int girl_num = rs.getInt(1); // 获取第一列第一行数据 System.out.println(&quot;女生总数为：&quot; + girl_num ); mdb.exit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; rs.next() : 读取下一行数据，如果下一行数据不存在返回 false ； 输出结果： 12成功连接数据库！女生总数为：5 14.3 再谈 Statement &amp; eceute() 预编译 Statement Statement 弊端 在前面，我们知道 Statement 对象主要用于执行 sql 语句： 1234567public ResultSet crudDB(String sql) throws Exception&#123; // 3.操作数据库 Statement s = conn.createStatement(); ResultSet rs = s.executeQuery(sql); return rs;&#125; 但是，有以下几个弊端： 只能执行完整sql 语句，不能对 sql 语句进行模板化修改； 易遭受 sql 注入攻击，比如在前面我们拼接查询，是否存在用户sql 语句： 1String sql = &quot;SELECT * FROM student WHERE name = &quot; + name; // name 由用户输入 如果用户输入‘刘婷’ OR 1=1 ,而非 刘婷 ，那么拼接语句为： 1SELECT * FROM student WHERE name = &#x27;刘婷&#x27; OR 1=1; 如果用户表有100万条数据，那么显然会耗光内存，让数据库负载过高。 PreparedStatement PreparedStatement 和 Statement 都是用来执行 sql 语句。不同是PreparedStatement 可以通过 ？ 来预留sql 语句编辑位置，而非直接拼接。 下面展示重新封装crubDB() 方法为 *identityUser()*验证用户(同前只验证姓名)： 12345678910import java.sql.PreparedStatement; // 注意要引用PreparedStatement public ResultSet identityUser(String sql, String userName) throws Exception&#123; // 3.操作数据库 PreparedStatement ps = conn.prepareStatement(sql); ps.setString(1, userName); ResultSet rs = ps.executeQuery(); return rs;&#125; 在主函数中，调用如下： 12345678910111213141516171819202122232425262728import JDBC_demo.mysqlDB;import java.sql.ResultSet;public class hello&#123; public static void main(String[] args) &#123; final String url = &quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;; final String user = &quot;root&quot;; final String passwd = &quot;123456&quot;; String sql = &quot;SELECT * FROM student WHERE name = ?&quot;; // 连接数据库--执行sql语句 mysqlDB mdb = new mysqlDB(url, user, passwd); ResultSet rs = mdb.identityUser(sql,&quot;刘婷&quot;); // 进行判断 if(rs.next()) // re.next() 返回的是bool类型，没有找到数据返回false System.out.println(&quot;正在登陆...&quot;); else System.out.println(&quot;用户不存在！&quot;); mdb.exit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 注意，sql语句 不用给 ？ 代表的字符串类似加上单/双引号，会出错： 1String sql = &quot;SELECT * FROM student WHERE name = &#x27;?&#x27;&quot;; // 错误写法 因为，ps.setString(1, userName); 方法会自动设置好。 三种不同eceute 执行 sql 语句，通常头三种方法：eceute() &amp; executeUpdate() &amp; executeQuery() ，它们都是 Statement 对象方法，主要有以下区别。 返回值不同 eceute() 用来执行 sql 语句： 12Statement s = conn.createStatement();boolean rs = s.execute(sql); // 返回bool类型，判断执行是否成功 executeUpdate() &amp; executeQuery() 相似，但是三者返回值不同： 1int number = s.executeUpdate(sql); // 返回int类型，有多少语句被影响 1ResultSet rs = s.executeQuery(sql); // 返回ResultSet类型，可以查询返回数据 是否支持查询语句 executeUpdate() 可以进行 增、删、改： 123s.executeUpdate(sqlInsert); // 执行INSERT插入数据s.executeUpdate(sqlDelete); // 执行DELETE删除数据s.executeUpdate(sqlUpdate); // 执行UPDATE更新数据 但是不能查询表： 1s.executeUpdate(sqlSelect); // 出错：执行SELECT查询数据 executeQuery() 一般用于查询语句 ，进行其它更新操作会报错： java.sql.SQLException: Can not issue data manipulation statements with executeQuery(). execute() 没有限制可以进行：增、删、改、查 。 14.4 特殊操作 &amp; 事务 特殊操作 未展开讲，用到可查询：特殊操作 这里的特殊操作包括两种： 获取自增长id：如果表中id为AUTO_INCREMENT，无论是*execute()还是executeUpdate()*都不会返回自增长id。 获取表元数据：诸如，数据库服务器版本，驱动版本，都有哪些数据库等等 事务 为什么要使用事务，不在赘述，同 MySQL笔记，这里主要展示 JDBC 如何使用事务。 ⚠️ 支持事务前提：当前MySQL服务器本身要支持INNODB, 同时表类型为 INNODB 。 支持事务 在当发现无法执行事务时，再进行以下修改。 设置表类型为 INNODB 1ALTER TABLE teble_name ENGINE = innodb; 设置服务器支持 INNODB mysql 从 5.5 版本已将 innoDB 作为默认存储引擎。 点击查看： 开启MYSQL INNODB的办法 事务实例 在事务中的多个操作，要么都成功，要么都失败。 在 JDBC 中，主要是取消excute() 等之后 自动 提交，改为 手动 提交所有操作。 12345678910111213141516171819202122232425262728293031import JDBC_demo.mysqlDB;import java.sql.ResultSet;public class hello&#123; public static void main(String[] args) &#123; final String url = &quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;; final String user = &quot;root&quot;; final String passwd = &quot;123456&quot;; String sql = &quot;UPDATE student SET score = score + ? WHERE name = ?&quot;; // 连接数据库 mysqlDB mdb = new mysqlDB(url, user, passwd); PreparedStatement ps = mdb.conn.prepareStatement(sql); // 事务：刘婷+10分，小白-10分 mdb.conn.setAutoCommit(false); // 取消自动提交 ps.setInt(1, 10);ps.setString(2, &quot;刘婷&quot;); ps.executeUpdate(); // 看下面错误解析 ps.setInt(1, -10);ps.setString(2, &quot;小白&quot;); ps.executeUpdate(); mdb.conn.commit(); // 手动提交 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; ⚠️ 调试半小时犯的2个错误，有关： ps.executeUpdate(); 用ps.executeQuery() ，提示 ：Cannot issue data manipulation statements with executeQuery() 原因：executeQuery() 适用于 SELECT ，用户更新等操作会报错。 添加参数sql：ps.executeQuery(sql) ，在前面创建 PreparedStatement 对象已给参数 sql ，再添参数会出现解析错误。 14.5 数据库线程池(待)"},{"title":"categories","date":"2021-11-25T05:45:57.000Z","updated":"2021-11-25T05:47:33.936Z","comments":true,"path":"categories/index.html","permalink":"https://hwh.zone/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-11-25T05:45:14.000Z","updated":"2021-11-25T05:47:43.270Z","comments":true,"path":"tags/index.html","permalink":"https://hwh.zone/tags/index.html","excerpt":"","text":""},{"title":"机器学习（一）吴恩达笔记","date":"2022-01-02T11:36:19.076Z","updated":"2021-12-03T03:41:02.923Z","comments":true,"path":"NO_post/机器学习（一）吴恩达笔记.html","permalink":"https://hwh.zone/NO_post/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%B4%E6%81%A9%E8%BE%BE%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"吴恩达的机器学习最重要的还是课后的lab实验，后期会继续上传。这里先简单上传听课的笔记，略粗糙。 一 、绪论 1.1 监督学习 1.2 无监督学习 只把数据交给算法，自动给事物分群。 （BC都是无监督学习） 二、单变量线性回归 2.1 模型描述 卖房子 卖房子预测，既是一个监督学习模型，也是一个回归模型。 基本常识 符号 m：训练集 x &amp; y ：分别表示输入/输出变量 监督学习流程 2.2 代价函数 平方误差代价函数 简化版平方代价函数 改变参数 简化平代函数 ，改变一个参数θ1图像 平代函数，改变两个参数θ、θ1图像 用等高线图来表示（J(θ0,θ1)相同即等高） 2.3 梯度下降算法 — 自动寻找最小J(代价)算法 问题描述 如何最快下山？ 不同下山点会得到不同下山路径，即局部最优解。 梯度算法介绍 一定要同时更新，右边算法错误在于θ0更新值被用于 temp1，应该用旧值。 梯度下降算法寻找最小代价过程 如果斜率 == (d(J(θ))/dθ)θ &gt; 0 ，那么当前θ - α*斜率，就是使得θ减小，逼近函数底端 如果斜率 == (d(J(θ))/dθ)θ &gt; 0 ，那么当前θ - α*斜率，就是使得θ增大，逼近函数底端 学习速率α 学习速率大小影响 学习速率太小：逼近过程太慢 学习速度太大：可能会越过最低点（最小代价），甚至无法收敛 梯度下降算法特点 如果已经在局部最低点 此时，斜率为0，θ不会被更新，达到局部最优。 自动减小θ变化程度 原因是因为，越逼近最低点，斜率会自动变小，α*斜率变小—&gt; θ变化程度降低。、 总结 基本方程了解 推导成偏微分项过程 对θ0求导，结果如框1 对θ1求导，结果如框2 梯度下降过程 根据公式 θj=θj−α∗∂∂θ∗J(θ0,θ1)\\theta_j = \\theta_j - \\alpha*\\frac{\\partial}{\\partial_\\theta}*J(\\theta_0,\\theta_1) θj​=θj​−α∗∂θ​∂​∗J(θ0​,θ1​) 不断减少 θ值，梯度下降使之达到局部最优。 不断拟合hθ，使得贴近数据，达到预测 三 、多变量线性回归 3.1 多功能 多变量预测房价 预测函数改进 写出矩阵表达形式 3.2 多元梯度下降法 为什么假设的函数 h(θ)是一个线性形式？ 通过大概预测数据分布 关键是让 最小代价函数 J会最小，拟合原数据。假设成线性形式方便推导，计算。 多元梯度下降计算最小代价 多元更新θ规则 对θ更新的理解1 ​ 每一次更新θj都是，要利用到所有的数据集，计算出此时θj数据集所有不同特征{x1,x2,x3…xn}偏导数平均值，决定下一次θj的偏移值。 12345678910#开始迭代while True: cnt=cnt+1 diff = [0,0] #梯度下降 for i in range(m): diff[0]+=h(x_train[i])-y[i] diff[1]+=(h(x_train[i])-y[i])*x_train[i] theta0=theta0-alpha/m*diff[0] theta1=theta1-alpha/m*diff[1] 3.3 多元梯度实用技巧 代价函数J是一个类似这种图形（多元更复杂）： 特征缩放：使得特征规模在一个相近范围 如果数据集{x1,x2,x3…xn}中特征xi过大，可能会使得J(θ)变得狭长，收敛慢、且震荡等： 为什么会变这样？ 改变{x1,x2,x3…xn}不会使得θ发生变化? 更好的确定特征缩放范围 xi=X−umax−minx_i = \\frac{X - u}{max - min} xi​=max−minX−u​ 选择学习速率α 观测是否收敛方法 画出收敛过程图形（老师推荐） 设置某个限差 不推荐，因为一般难以判断。 不收敛举例 α过大 可能导致的情况：越过最低点，来回走；不断重复某个相似形状。 已经证明：只要α够小，代价函数J一定会减小。 α过小 一定收敛，但是过程太慢。 取α技巧（经验） 从一个较小合适值如0.001，每次是前一次3倍左右递增测试。 3.4 特征表达式和多项式回归 根据已知数据得出更好的特征 如，已知房子的长、宽特征，其实根据长*宽 这个新特征更好预测。 多元拟合举例（单一特征） 如下图房价是一个类似二次函数，那么可以选择多项式来拟合。 为了更加精确，还可以增加开平方等（后面房价变化平缓） 3.5 正规方程解法 方法1：求出偏微分置零—非线性 这种方法，根据公式令所有的偏微分方程 == 0 ，然后解出 θ0，θ1…θn。 方法2：公式解出—-线性 简单来说就是求解：（不对，应该参考：正规方程推导过程） Y=X∗θY = X*θ Y=X∗θ step1:XTY=XTX∗θstep1:X^TY = X^TX*θ step1:XTY=XTX∗θ step2:（XTX)−1XTY=θstep2:（X^TX)^{-1}X^TY = θ step2:（XTX)−1XTY=θ 可是一般也不会是线性解啊？θ有n个，数据集有很多个如m，就X为m*（n+1） m &gt;&gt; n，不一定有解啊？ step1:y=θ0+θ1∗x1+θ2∗x2....θn∗xnstep1: y = \\theta_0 + \\theta_1*x_1+ \\theta_2*x_2.... \\theta_n*x_n step1:y=θ0​+θ1​∗x1​+θ2​∗x2​....θn​∗xn​ 两种方法对比 如果正规方程，XTX不可逆（奇异矩阵） 一般不可逆情况很少。 使用pinv求逆而非inv（即使不可逆也可求出） 改变特征值/正则化删除多余特征 四、Octave/ Matalab使用 4.1 基本操作 改变提示符号 1octave:1&gt; PS1(&#x27;&gt;&gt; &#x27;) % 将octave：&lt;num&gt; &gt; &lt;命令&gt; 提示变成 &gt;&gt; &lt;命令&gt; HELP 帮助 查看函数定义等 1&gt;&gt; help PS1 常规运算 123456789101112&gt;&gt; 1+2 % 加ans = 3 &gt;&gt; 1-2 % 减ans = -1&gt;&gt; 1*2 % 乘ans = 2&gt;&gt; 1/2 % 除ans = 0.50000&gt;&gt; 1^2 % 幂ans = 1&gt;&gt; 1%2 % 取余ans = 1 布尔运算 12345678&gt;&gt; 1 == 2 # equalans = 0&gt;&gt; 1 ~= 2 # ...?ans = 1&gt;&gt; 1 &amp;&amp; 0 # ANDans = 0&gt;&gt; 1 || 0 # ORans = 1 矩阵运算 加减 A + 1 , A - 1 : 矩阵每一个数字都加减 1 12345678910&gt;&gt; A = [1 2 3 ; 4 5 6 ; 7 8 9;];&gt;&gt; B = [1 2 3 ; 4 5 6 ; 7 8 9;];&gt;&gt; A + 1ans = 2 3 4 5 6 7 8 9 10 乘除 A*B &amp; *A .B : 前者常规矩阵相乘，后者是用对应A(i,j) * B(i,j) 类似的还有：1 ./ A , A .^2 , .都是表示对矩阵每个元素的操作 12345678910111213&gt;&gt; A * Bans = 30 36 42 66 81 96 102 126 150&gt;&gt; A .*Bans = 1 4 9 16 25 36 49 64 81 函数 A '、pinv(A)abs(A)、log(A)、exp(A)、max(A) &amp; ceil(A)、floor(A) 向上、下取整 123456789101112&gt;&gt; A = [1 2 3 ; 4 5 6 ; 7 8 9;]A = 1 2 3 4 5 6 7 8 9&gt;&gt; A&#x27;ans = 1 4 7 2 5 8 3 6 9 sum(A)、prod(a) 、max(A)：返回每行元素和、乘积、最大值，以行向量表示。 max(A,B)：比较A 和 B 对应位置元素，求最大，组成新矩阵 max(A,[],1)、max(A,[],2)：分别获取每一列、行最大值 sum(A,1)、sum(A,2)：分别获取每一列、行和 12345678910111213141516171819202122232425&gt;&gt; sum(A) % 默认获取的是每一列的最大值ans = 12 15 18&gt;&gt; prod(A)ans = 28 80 162 &gt;&gt; [r,c]= max(A) % r 是每列最大数字 ； c是每列最大数字索引r = 7 8 9c = 3 3 3 &gt;&gt; max(A,[],2) % 返回每行最大ans = 3 6 9 find(A &lt; 3) ：返回矩阵所有小于3的元素，为一个列向量 12345&gt;&gt; find(A &lt; 3)ans = 1 4 布尔 A &lt; 3 、 A &gt; 3 : 相对矩阵每个元素都和3进行bool运算，返回0 或者1 123456&gt;&gt; A &lt; 3ans = 1 1 0 0 0 0 0 0 0 补充 A(😃 ：将A所有元素组成一个列向量。配合 max(A)就可以求矩阵A的最大值 1234567891011121314B = 1 4 7 2 5 8 3 6 9&gt;&gt; max(B) % max 默认求每列的最大值ans = 9 变量相关操作 定义变量 123&gt;&gt; a = pi % 变量会自动打印a = 3.1416&gt;&gt; a = pi; % 让变量不打印 display 打印变量 1234&gt;&gt; a = pi;&gt;&gt; display(a) a = 3.1416&gt;&gt; display(sprintf(&#x27;%0.2f&#x27;,a)) % 以C语言格式打印出来 format 打印变量 1234567&gt;&gt; format long &gt;&gt; aa = 3.141592653589793&gt;&gt; format short&gt;&gt; aa = 3.1416 clear清除变量 12clear a % 清除a变量clear % 清除所有变量 who,whos显示所有变量信息 12345678910111213141516&gt;&gt; whoVariables in the current scope:A a ans data &gt;&gt; whos % whos更加详细Variables in the current scope: Attr Name Size Bytes Class ==== ==== ==== ===== ===== A 15x15 1800 double a 1x1 8 double ans 1x14 14 char data 3x3 72 doubleTotal is 249 elements using 1894 bytes 向量和矩阵 常规生成矩阵 123456789101112131415&gt;&gt; A = [1 2; 3 4 ; 5 6] % 以；分隔矩阵行 ，以空格分隔每一行元素A = 1 2 3 4 5 6&gt;&gt; A = [1 2; % 另一种输入矩阵方法&gt; 3 4;&gt; 5 6]A = 1 2 3 4 5 6 快捷生成矩阵 ::指定起始和结束生成一个行向量 12345678&gt;&gt; A = 1:0.2:2 % 同时指定步长为 0.2A = 1.0000 1.2000 1.4000 1.6000 1.8000 2.0000&gt;&gt; A = 1 : 5 % 不指定步长（默认为1）A = 1 2 3 4 5 直接复制某矩阵指定多少元素，生成行向量，从上至下，从左至右开始算 1234567891011&gt;&gt; w = rand(3,3)w = 0.920009 0.424680 0.795883 0.890070 0.048942 0.592416 0.748348 0.784034 0.366445 &gt;&gt; v = w(1:3) % 1:3 表示第1 到 第3 个元素赋值给v行向量（第一列）v = 0.92001 0.89007 0.74835 用ones、zeros、magic函数指定行列，生成元素为1、0矩阵 或者幻方方阵 123456789101112131415161718&gt;&gt; ones(2,2)ans = 1 1 1 1&gt;&gt; 2*ones(2,2) % 还可以指定倍数ans = 2 2 2 2 &gt;&gt; magic(3) % 每行、列、对角 相加相等ans = 8 1 6 3 5 7 4 9 2 rand、randn生成随机矩阵（randn生成的矩阵符合高斯分布） 1234567891011&gt;&gt; rand(2,2)ans = 0.84394 0.39302 0.33943 0.18478&gt;&gt; randn(2,2)ans = -0.32139 0.19817 0.62788 0.42349 eye 生成单位矩阵 12345678&gt;&gt; eye(3)ans =Diagonal Matrix 1 0 0 0 1 0 0 0 1 图形显示矩阵 12&gt;&gt; A = rand(15,15);&gt;&gt; hist(A) 矩阵数据索引 A(i,j) 显示矩阵A，i行j列元素 12345678&gt;&gt; A = [1 2 3 ; 4 5 6; 7 8 9]A = 1 2 3 4 5 6 7 8 9&gt;&gt; A(2,2)ans = 5 A(i,:) 获取矩阵A，第i行所有元素 1234&gt;&gt; A(2,:)ans = 4 5 6 A(:,j) 获取矩阵A，第j列所有元素 123456&gt;&gt; A(:,2)ans = 2 5 8 A([i,j]😅 获取矩阵A，第i行和第j行元素 12345&gt;&gt; A([1,3],:)ans = 1 2 3 7 8 9 修改矩阵 A(:,j) = [column vector ] ： 修改矩阵第j列为新列向量 A(i,:) = [column vector ] ： 修改矩阵第i行为新行向量 12345678910111213&gt;&gt; A(:,2) = [8 ; 8 ; 8]A = 1 8 3 4 8 6 7 8 9&gt;&gt; A(2,:) = [7 7 7]A = 1 8 3 7 7 7 7 8 9 组合矩阵 [A,B] &amp; [A B] : 将矩阵B作为矩阵A的扩展列，形成新矩阵 12345678910111213&gt;&gt; A = [1 1 1]A = 1 1 1&gt;&gt; B = [2 2 2]B = 2 2 2&gt;&gt; [A,B]ans = 1 1 1 2 2 2 [A;B] : 将矩阵B作为矩阵A的扩展行，形成新矩阵，注意是分号； 12345&gt;&gt; [A;B]ans = 1 1 1 2 2 2 矩阵量度 size 返回矩阵大小 1234&gt;&gt; size(A)ans = 15 15 length 返回行长 12&gt;&gt; length(A)ans = 15 4.2 移动数据 路径相关 pwd ：当前路径 ； cd 切换目录 ； ls 显示当前目录文件 load 加载文件 12345678load data.datload(&#x27;data.dat&#x27;)&gt;&gt; data % 特别注意不要输入:后缀名！！！data = 1 2 3 4 5 6 7 8 9 save 存储数据 12345678data = 1 2 3 4 5 6 7 8 9&gt;&gt; v = data(1:3)&gt;&gt; save v.dat v 4.3 数据绘制 设置横轴坐标 &amp; 函数（中间数字为什么不能改变成 0.1？？） 123&gt;&gt; t = [0:0.01:2*pi];&gt;&gt; y1 = sin(t); &gt;&gt; y2 = cos(t); 绘制图形 123&gt;&gt; plot(t,y1)hold on; % 保持正弦图形在基础上再绘制余弦函数&gt;&gt; plot(t,y2) 添加信息 1234&gt;&gt; xlabel(&#x27;time&#x27;); % 增加x坐标轴标签&gt;&gt; ylabel(&#x27;value&#x27;); % 增加y坐标轴标签&gt;&gt; legend(&#x27;sin&#x27;,&#x27;cos&#x27;); % 用显示两条线代表什么函数&gt;&gt; title(&#x27;simple plot&#x27;) % 增加这幅图的标题 保存图片 cd &lt;保存路径&gt; ；&lt;保存图片名&gt; 1&gt;&gt; cd &#x27;C:\\Users\\Administrator\\Desktop&#x27;;print -dpng &#x27;myPlot.png&#x27; 同时显示两张图片 12&gt;&gt; figure(1);plot(t,y1);&gt;&gt; figure(2);plot(t,y2); 显示框分隔成两块 12345&gt;&gt; subplot(1,2,1); % 把界面分成1x2，选中第一个格子&gt;&gt; plot(t,y1); &gt;&gt; subplot(1,2,2); % 选中第二个格子&gt;&gt; plot(t,y2);&gt;&gt; axis([0.5 1 -1 1]) % 修改第二幅图的横坐标为[0.5,1],纵坐标为[-1,1] 绘制矩阵图像 矩阵中一个元素代表着一个色块， 123456789&gt;&gt; A = magic(3)A = 8 1 6 3 5 7 4 9 2&gt;&gt; imagesc(A) % 生成不同色块矩阵&gt;&gt; imagesc(A),colorbar,colormap pink; % 色块的颜色深浅由元素的数值决定。&gt;&gt; close % 关闭所有打开的绘制图像框 4.4 控制语句 for、while… for、while循环 for : 变量i会自＋1 while：i不会自加，需要自己设置初始值 12345678910111213141516171819&gt;&gt; rang = [1:3]rang = 1 2 3 &gt;&gt; for i = rang % 等价于 ： for i = [1:10]&gt; disp(i);&gt; end 1 2 3&gt;&gt; i = 0&gt;&gt; while i &lt; 3&gt; disp(i);&gt; i = i+1; % 加；，使得i不会输出&gt; end; 0 1 2 if 注意 if也要有end配合 12345678910&gt;&gt; i = 0 ;&gt;&gt; while true&gt; i = i+1;&gt; disp(i)&gt; if i == 3&gt; break;&gt; else if&gt; disp(&#x27;continue&#x27;)&gt; end&gt; end 调用自定义函数 定义一个后缀名为.m文件：square.m，写入函数： 12function y = square(x) % 函数头，函数名最好和文件名相同y = x^2; % 函数主体 在octave中CIL中调用 123&gt;&gt; cd C:\\Users\\86151\\Desktop % 先切换到文件所在目录&gt;&gt; square(10)ans = 100 也可返回多个值： 1234567function [a,b] = squareAndCube(x) a = x^2; b = y^3;&gt;&gt; % 在octave中调用 squareAndCube.m 中 squareAndCube函数&gt;&gt; [a,b] = squareAndCube(10)a = 100b = 1000 计算代价函数实例 4.5 矢量 矩阵化两数相乘求和 更复杂的举例 五、Logistic回归 5.1 分类 线性回归预测分类问题 例如预测，肿瘤是否良性问题。 我们将大于0.5的预测函数h肿瘤，预测为良性；小于0.5预测为恶性。 但是如果增加一个数据集，预测函数把原本属于恶性肿瘤预测为良性。 另外一个问题，预测函数h(x)值可以超过[0,1]范围。 5.2 假设陈述 Sigmoid函数 &amp; Logistic 函数 Sigmoid函数：g(z)=11+e−zSigmoid 函数：g(z) = \\frac{1}{1+e^{-z}} Sigmoid函数：g(z)=1+e−z1​ Logistic函数:hθ(x)=g(θTx)Logistic 函数 :h_\\theta(x) = g(\\theta^Tx) Logistic函数:hθ​(x)=g(θTx) 预测病人有 70% 概率患有恶性肿瘤。 5.3 决策界限 再理解Logistic 函数 当 z &gt; 0 时，g（z）&gt; 0.5 -----&gt; θ’ &gt; 0 时，g（θ’）&gt; 0.5。 那么如果设置 阀值 = 0.5，只需判断 θ’ &gt; 0 ? 便可分类了。 举例（一） 如果设定阀值= 0.5，按照前推论，预测 y = 1只需 ： θ0+θ1x1+θ2x2&gt;0\\theta_0+\\theta_1x_1+\\theta_2x_2 &gt; 0 θ0​+θ1​x1​+θ2​x2​&gt;0 不妨假设，θ0 = 0 ，θ1 = θ2 = 1。那么便是推得： x1+x2≥3,y=1;x1+x2&lt;3,y=0x_1 + x_2 ≥ 3 , y = 1 ; x_1 + x_2 &lt; 3 , y = 0 x1​+x2​≥3,y=1;x1​+x2​&lt;3,y=0 由此可以得到决策边界函数，如下图红色直线所示： x1+x2=3x_1 + x_2 = 3 x1​+x2​=3 举例（二） 基本推导过程同上，可以得到决策边界函数： x12+x22=1x_1^2+x_2^2 = 1 x12​+x22​=1 可能还有有更复杂的图形和参数： 5.4 代价函数 向量化 Logistic函数 选择新的代价函数 为什么要构造新的代价函数？ 线性回归代价函数的实际意义就是平方误差。而逻辑回归却不是，它的预测函数hθ(x)hθ(x)是非线性的。如果类比地使用线性回归的代价函数于逻辑回归，那J(θ)J(θ)很有可能就是非凸函数，即存在很多局部最优解，但不一定是全局最优解。我们希望构造一个凸函数，也就是一个碗型函数做为逻辑回归的代价函数。 原文链接：https://blog.csdn.net/ljp1919/article/details/79120761 原先总体代价函数： 将 左边 1/2(h_θ(x) - y)^2 替换成新的代价函数（不是总体代价函数！！）： 对于新代价函数理解： 在 y = 1 ，即数据集实际分类为1，Cost图像如下： 如果预测函数h(θ) = 0 ，即分类到0，和实际 1偏差，则代价 --&gt;无穷，惩罚这个函数？ 相反，如果预测结果h(θ) = 1，那么代价为—&gt;0，符合实际数据集 = 1。 同理，y = 0 时，实际分类为0，代价函数Cost图像如下： 但是，和前面代价函数相比怎么更新θ？？ 5.5 简化代价函数与梯度下降 简化代价 &amp; 回归函数 将先前代价函数写成一项： 那么新的总体代价函数是： 梯度下降 总体流程 不断调整θ，使得代价函数（总体）最小，最后得出回归预测函数。 详细过程 更新θ，和前类似，关键在于计算导数。（没推导出求导怎么出来的） 其中 θTx 为线性时，h(x) = g(θ0 + θ2x1+θ3x3…+θnxn)为： hθ(x)=11+e−θTxh_\\theta(x) = \\frac{1}{1+e^{-\\theta^Tx}} hθ​(x)=1+e−θTx1​ 5.6 高级优化 梯度算法简介 octave中调用梯度下降算法 写好代价函数算法 注意这里好像没有数据集，实际上这就是单纯求这个代价函数的最小值。 然后把θ迭代，直至收敛。 实际自己编写的 COSTFunction.m函数 调用梯度下降算法 5.7 多元分类：一对多 问题 我们知道用Logistic 函数对类型进行二维分类，那么如何进行多元分类呢？ 解决 采用“一对余”方法，简单来说。就是先n元分类变成2元分类，区分出一个。 然后循环上述，直至区分出所有。 六、正则化 6.1 过拟合问题 什么是过拟合 无论是之前的，线性回归和逻辑回归都有出现过度拟合。 线性回归过拟合 如下图所示，图三虽然千方百计很好的拟合了数据，保留了更多特征x3、x4…但是很显然它并不能得到一条很好的预测函数。 逻辑回归过拟合 如何解决过拟合 减少特征 减少特征分为人工或者模型选择算法来达到目的。但是减少特征会使得我们无视一些本该有用的特征变量。（比如房子是否明亮对预测价格也是有影响的） 正则化 保留所有特征，但是减少它们的量级。 6.2 代价函数 正则化举例 引子 依旧是图二，虽然保留更多特征，但是图形过于浮夸，并不是一个好的预测函数。我们可以通过正则化，减少特征 x3、x4的影响。 正则化 减少特征 x3、x4的影响，可以通过减少θ3、θ4来实现： 在我们使得代价函数越来越小的过程中，θ3、θ4则会趋于0。使得预测函数好像不存在θ3^3、θ4^4这两项一样，–预测函数越简单越不会出现过度拟合–。 正则化标准过程 确定特征 &amp; 参数 写出代价函数 加入正则新项 正则新项用来惩罚θ参数，注意一般不对θ0进入惩罚。 正则化不当后果 惩罚过大 使得参数 θ 都趋于0，那么预测函数会趋近于一条水平直线。 6.3 线性回归正则化 流程 列出代价函数正则表达式 进行梯度下降 根据以前的梯度下降公式可以得出： 加上正则化进行的变形梯度下降公式： 相比之前，每次更新都对θj*(1 - α*λ/m)，而 (1 - α*λ/m) 是一个比 1小一点的数，则相比未正则化前加快向0的方向趋近？？ 采用正规方程来解决(所有特征x都是一次，线性回归) 根据之前正规方程解出θ，推导过程： θ=(XTX)−1XTy\\theta = (X^TX)^{-1}X^Ty θ=(XTX)−1XTy 如果使用正则化则应该是： 注意：只要λ&gt;0，上式（）中一定可逆。 6.4 Logistic 回归正则化 流程 列出代价函数正则表达式 梯度下降算法 octave实现 写出costFunction函数 七、神经网络学习 7.1 非线性假设 ​ 在前面我们进行都是线性假设，如 ： h = θ0 + θ1x1 + θ2x2 ，而不会出现 x1x2、x1^2*x2…之类。 多项特征处理 两项特征时logistic回归 注意下面只有两个特征x1、x2，但是是非线性，进行回归分类。 多个特征时 举例识别汽车 流程 给每个样本集输入学习算法得出分类器 给一辆汽车标记两个像素位置pixel1、pixel2，并记录它们像素强度坐标 然后再记录另一辆汽车相同像素位置的？？？像素强度坐标 重复以上得出更多左边对它们进行分类 但是，一张50*50图片都有2500个像素点位置，对应2500个像素强度。如果还要包含所有的二次项特征约有300万个。 让分类器去判断一个新样本是否是汽车 7.2 神经元与大脑 略 7.3 模型展示 模型展示1 神经元 神经元模型 神经网络 具体解释 各个出现参数含义 ai^j ,第j 层“激活的神经元”用来计算前一层（j-1）输入x1、x2、x3的值； θ^j，用来控制从第j 到 j +1层的映射权重。 计算流程 ​ 第二层活动神经元ai^2 ，计算从第一层到第二层的映射，同时θ^1来控制映射权重。 ​ 然后第三层，计算最终结果： 在上面这个式中，非常类似于逻辑回归： Logistic函数:hθ(x)=g(θTx)Logistic 函数 :h_\\theta(x) = g(\\theta^Tx) Logistic函数:hθ​(x)=g(θTx) ​ 只不过，它不是直接利用x1、x2、x3特征作为输入，而是先利用第二层“神经元”进行计算。得出a0（多添加的basic单元）、a1、a2、a3。 总结 ​ 第j层有sj个单元，第j+1层有sj+1个单元，那么控制从j层到j+1层映射权重θj的个数应该是，第j+1层单元数 * （第j层单元数 + 1），即： sj+1∗（sj+1）,第j层会补一个x0s_{j+1} * （s_j + 1）,第j层会补一个x_0 sj+1​∗（sj​+1）,第j层会补一个x0​ 模型展示2 向量化神经网络公示 更复杂的神经网络举例 7.4 例子和直觉理解 直觉理解1 神经元函数计算 AND 如下图所示，有两个特征x1、x2只可能是 0 或者 1，同时给它们赋予权重 θ: -30、+20、+20（-30给增加的basic单元）。 那么对应的h(x)，为： hθ(x)=g(−30+20x1+20x2)h_\\theta(x)=g(-30+20x_1+20x_2) hθ​(x)=g(−30+20x1​+20x2​) 对应函数图形为： 那么输入x1、x2得出的特征值是 计算结果恰为 x1 &amp; x2，实现了神经网络逻辑AND运算。 神经网络计算OR 基本同上过程： 神经网络计算NOT 由于权重θ1 = - 20 ，当 x1 = 0 时， h = 1，趋近1 ； 反之 x2 = 1 ，h = 0 ，达到取反的效果。 ​ 进一步还可以得到，计算 NOT x_1 AND NOT x_2。 ​ 只有当 x1 = x2 = 0，h = 1。那么只需 对应权重θ1 、θ2 为一个较大负数，θ0 为一个整数，只要 x1、x2有一个不为0，那么结果必为0。 直觉理解2 组合成更复杂的神经网络计算 x1 XNOR x2 基本神经网络逻辑计算 组合计算x1 XNOR x2 ​ x1 XNOR x2，即 x1、x2相同才会为1。而它们直接基本组合很难计算出来，抓住相同二字，我们可以联想用AND。在此之前一层： x1 = x2 = 0，要经过计算得出为1，显然要用NOT x_1 AND NOT x_2 x1 = x2 = 1，要经过计算得出为1，显然要用 AND 即可 故有如下组合： 其他更复杂计算（手迹判别） 7.5 多元分类----以识别汽车、人、摩托举例 ​ 上节看到的识别手迹数字，就是一个多元分类问题（识别数字 0~9）。神经元网络实现多元分类，本质就是一对多法的扩展。 举例 ​ 简而言之，就是给出特征 x = {x1、x2、x3…}(如前面给出两个像素点像素强度x1、x2)，然后经过多层神经网络，输出预测最后的结果分类（一个4维向量）。 给出数据集 如下图，给出多个图形，每个图形都是一组（x^(i)，y^(i)），其中 x^(i) ：对应图像输入的特征，为一个n维向量 y^(i)：对应输出结果，用一个4维向量分别表示 行人、汽车、摩托车、货车。 训练 ？？？？？？？？下一章节分解。 预测结果 用上面训练好的神经网络来进行预测： 八 、神经网络的反向传播算法 8.1 代价函数 神经网络中字母记法 L : 代表神经网络层数，如下图为 L = 4 ; S_l ：代表第 l 层的单元数，如下图S_L = 4 （最后一层，同时也可记为 K = 4）。 K：一般记录为最后一层输出单元数 x^(i) 、y^(i) ：是向量，y^(i)表示第 i个数据集的输出，由于有4个输出单元所以4维。 如 第2个数据集，第一个输出单元是人，y^(i) = (1 0 0 0)T 代价函数 Logistic 回归代价函数 Logistic代价函数 ：∑m组数据（h(x)预测代价偏差） * 1/m ，然后正则化。 神经网络代价函数 代价函数理解 ​ ∑m组数据（K个输出单元h(x)预测代价偏差和） * 1/m ，然后正则化。 ​ 也就是说对于每组数组，最后都有四个输出单元，四个预测结果(车、人、摩托车…)，对实际预测偏差代价求和。然后再对m数据产生的代价求和。 正则化项理解 在神经网络中，控制从第j 层到 第 j+1 层权重θ数是 sj+1∗（sj+1）,第j层会补一个x0s_{j+1} * （s_j + 1）,第j层会补一个x_0 sj+1​∗（sj​+1）,第j层会补一个x0​ 不考虑，第j层 basic θ0 ，那么应该是： sj+1∗sjs_{j+1} * s_j sj+1​∗sj​ 所以不含输出层所有网络层的θ（取平方）累加便应该是 ∑l=1L−1∑i=1s1∑j=1sl+1(θjil)2\\sum_{l=1}^{L-1}\\sum_{i=1}^{s_1}\\sum_{j=1}^{s_l+1}(\\theta_{ji}^l)^2 l=1∑L−1​i=1∑s1​​j=1∑sl​+1​(θjil​)2 8.2 反向传播算法 梯度下降计算流程 而现在的关键就是，如何计算偏导项，这利用到前向传播 &amp; 反向传播算法。 向量化前向传播算法流程 下图给定一个训练例子(x,y)，进行前向传播得出h(x)预测结果（4输出单元结果）过程 那么至此，可以计算出各层的激活单元输出值 a^(4)。 向量反向传播算法 根据前向传播计算出的各单元激活值a^(4) ，可以进一步计算出反向传播。 计算输出层各激活单元单元激活值（预测值） 和 真实值误差 aj(4)a_j^{(4)}aj(4)​ 是最后一层单元输出值，也就是预测值；yjy_jyj​ 是实际的真实值，它们相减便是第4层第j个输出单元误差 接着，我们可以利用下图公式计算其余各层单元误差（此时误差是向量，代表第L层所有单元误差向量，而不是某个具体单元） 不用计算第一层误差，第一层是实际输入 其中： g′(z(i))=a(i)∗(1−a(i))g&#x27;(z^{(i)}) = a^{(i)} * (1-a^{(i)})g′(z(i))=a(i)∗(1−a(i)) 流程汇总 给定数据初始化 其中每个激活单元都有对应误差： Δij(l):表示第i组数据，第l层，第j个激活单元\\Delta_{ij}^{(l)}:表示第i组数据，第l层，第j个激活单元 Δij(l)​:表示第i组数据，第l层，第j个激活单元 计算所有数据神经网络误差和 在这个循环中 ： Δij(l):第一次循环：是第一次神经网络所有单元误差值；第二次循：第一次循环误差和+第二次循环误差和；以此类推。\\Delta_{ij}^{(l)}:第一次循环：是第一次神经网络所有单元误差值；\\\\ 第二次循：第一次循环误差和 + 第二次循环误差和；\\\\以此类推。 Δij(l)​:第一次循环：是第一次神经网络所有单元误差值；第二次循：第一次循环误差和+第二次循环误差和；以此类推。 上面 j 没有变化？？ 计算偏导项（跳出上诉循环后） 注意：第0个激活单元，不用加标准化项 经过数学证明可以得出，代价函数偏导项如下： 8.3 理解反向传播 前向传播 注意如何计算出z，又进一步计算出a ​ 反向传播 把最大似然函数，当做代价函数？和逻辑回归差不多，勉强可以理解。 误差 = 代价函数对 zj(l)z_j^{(l)}zj(l)​ 导数？ 演示反向传播如何进行 δ2(2)\\delta_2^{(2)}δ2(2)​ 的计算。 δ2(2)\\delta_2^{(2)}δ2(2)​ 根据箭头可知，第三层有两个箭头指向它，需要计算出 δ1(3)\\delta_1^{(3)}δ1(3)​ 、δ2(3)\\delta_2^{(3)}δ2(3)​ ，而 δ1(3)\\delta_1^{(3)}δ1(3)​ 、δ2(3)\\delta_2^{(3)}δ2(3)​ 需要先计算第四层误差。 首先计算出第四层误差： δ1(4)=y(i)−a1(4)\\delta_1^{(4)} = y^{(i)} - a_1^{(4)}δ1(4)​=y(i)−a1(4)​ 根据前一层单元误差 = 下一层对应单元（有箭头）* 权重 可计算出第三层单元误差： δ1(3)=θ11(3)δ1(4)\\delta_1^{(3)} = \\theta_{11}^{(3)} \\delta_1^{(4)}δ1(3)​=θ11(3)​δ1(4)​ δ2(3)=θ12(3)δ1(4)\\delta_2^{(3)} = \\theta_{12}^{(3)} \\delta_1^{(4)}δ2(3)​=θ12(3)​δ1(4)​ 则对应第二层单元误差： δ2(2)=θ12(2)δ1(3)+θ22(2)δ2(3)\\delta_2^{(2)} = \\theta_{12}^{(2)} \\delta_1^{(3)} + \\theta_{22}^{(2)} \\delta_2^{(3)}δ2(2)​=θ12(2)​δ1(3)​+θ22(2)​δ2(3)​ 但是前面不还是有后面那项吗？？？？ 8.4 展开参数 向量化 θ为什么有三个?? 8.5 梯度检测 8.6 随机初始化 8.7 组合 8.8 无人驾驶举例 九、应用机器学习的建议 9.1 评估假设 一部分数据（70%）用来训练模型，一部分数据（30%）用来测试验证。而验证通过计算误差方式来衡量数据集是否准确。常用方法有： 计算测试数据集代价函数 统计误差分类 9.2 模型选择 对于一个模型如何选择拟合函数？ 恰当的做法是把一个数据集分为：训练集(60%)、交叉验证集(20%)、测试集(20%)。 ⚠️ 注意这里定义的都是 误差 ，真正的代价函数 JθJ_\\thetaJθ​ 是可能会有正则项的！ 具体的训练过程为： 训练模型 选择不同的模型（预测函数）hθ1(x)h_{\\theta_1}{(x)}hθ1​​(x)、hθ2(x)h_{\\theta_2}{(x)}hθ2​​(x) …hθi(x)h_{\\theta_i}{(x)}hθi​​(x)，用 训练集 训练出对应的参数θ1\\theta_1θ1​ 、θ2\\theta_2θ2​ …θi\\theta_iθi​ 选择模型 利用 交叉验证集 计算不同模型下的误差 Jcv(θ1)J_{cv}(\\theta_1)Jcv​(θ1​)、 Jcv(θ2)J_{cv}(\\theta_2)Jcv​(θ2​)… Jcv(θi)J_{cv}(\\theta_i)Jcv​(θi​) ，选择误差最小对应的模型。 验证模型 最后利用 测试集 来对我们选择的模型进行最终验证。 9.3 诊断偏差和方差 如何判断我们的模型出现了高偏差或者高方差？ 出现高偏差（欠拟合） 此时训练误差和交叉验证误差都很大（误差都大说明模型不够好）。 出现高方差（过拟合） 训练误差很小，而交叉验证误差很大。说明在新的数据拟合差，只在训练数据集集合好，则属于过拟合情况。 9.4 正则化偏差、方差 在前我们知道选择模型可能会出现高偏差、方差问题： 高偏差：接近直线，不能很好拟合数据 高方差：复杂曲线，多项式过度拟合数据，而没有很好的泛化能力 因此我们可以通过正则化参数使得拟合函数在简单直线和复杂曲线中变化，以下图例可以直观说明： 通过改变参数 λ\\lambdaλ 来修正参数 θ1、θ2...θn\\theta_1 、\\theta_2 ...\\theta_nθ1​、θ2​...θn​ —&gt; 修正偏差和高方差。 9.4.1 如何选择正则参数 一般以 步长=0.02步长 = 0.02步长=0.02 递增来选择 λ\\lambdaλ 进行炼丹 ： 通过选择合适的 λ\\lambdaλ ，我们找到使得交叉验证误差 JcvJ_{cv}Jcv​ 最小的λ\\lambdaλ（红色曲线最低点） 9.5 学习曲线 对于一个给定数据集，我们选择模型假设函数对其进行训练。可以通过学习曲线来帮助我们直观选择参数。 出现高偏差 也就是出现欠拟合，如下图： 此时无论是 训练误差Jcv(θ)J_{cv}{(\\theta)}Jcv​(θ)、交叉验证误差 Jtrain(θ)J_{train}{(\\theta)}Jtrain​(θ) 都很大，这是由于我们选择的模型不当。 出现高偏差无论 用再多的数据集也无法降低误差 。 因此我们需要选择更复杂的多项式函数模型来拟合。 出现高方差 这是因此选择的模型过于复杂出现欠拟合。 此时 训练误差Jcv(θ)J_{cv}{(\\theta)}Jcv​(θ) 较小、交叉验证误差 Jtrain(θ)J_{train}{(\\theta)}Jtrain​(θ) 较大。但是可以通过增加数据集来减少Jtrain(θ)J_{train}{(\\theta)}Jtrain​(θ) 。 9.6 总结：算法效果不好？ 如果我们通过一个模型如下，进行训练： 首先通过画出 Jcv(θ)J_{cv}{(\\theta)}Jcv​(θ) 、 Jtrain(θ)J_{train}{(\\theta)}Jtrain​(θ) 图像，来判断我们的算法出现什么问题。 🎯 我们最终目标都是使Jtrain(θ)J_{train}{(\\theta)}Jtrain​(θ) 误差最小。 出现高偏差 增加更多特征：如 x3、x4 etc.x_3、x_4 \\ etc.x3​、x4​ etc. 增加多项特征：如 x12、x22、x1x2x_1^2、x_2^2、x_1x_2x12​、x22​、x1​x2​ 减少正则化参数λ\\lambdaλ ：使得拟合函数更加复杂 出现高方差 获取更多数据：更多数据可以有效降低误差 Jtrain(θ)J_{train}{(\\theta)}Jtrain​(θ) 减少更多特征：可避免过拟合 增加正则化参数 λ\\lambdaλ ：可降低 θ\\thetaθ ，使得拟合曲线简单一点。 9.6.1 关于神经网络 choose：小与大？ 小型神经网络一般不容易出现过拟合，大型神经网络容易出现过拟合，但可以使用正则化参数来解决。 所以一般可以选择大神经网络更好。 choose：隐藏层个数？ 一般选择1 个是比较合理的选项。 也可尝试多个，这样就需要根据 Jcv(θ)J_{cv}{(\\theta)}Jcv​(θ) 、 Jtrain(θ)J_{train}{(\\theta)}Jtrain​(θ) 等误差来判断，多少隐藏层个数是最好的选择。 十、机器学习系统设计 10.1 误差分析 10.1.1 建议措施 以下是一个邮件分类具体实例提高机器学习分类正确率。 先有一个邮件分类系统，它对500个 CVCVCV 验证集进行了 100 次 错误分类。我们人工检查这100个错误： 我们人工分类这是什么类型邮件，然后检查是什么原因（特征）导致分类错误: 类型：这 100封错误分类邮件，有四种类型 分类错误原因：邮件故意拼写错误、不寻常的邮件路径等 使用数值分析，来决定是否做某些优化。 比如，下面是否应该将 discount / discounted / discounting 等视作为一个单词？ 又如，是否应该忽略首字母大小写，mom / Mom 视作一个单词？ 我们应该尝试去进行优化前后 数值分析错误率对比，如果优化后分类错误更低那么就进行优化，反之则取消。 10.2 不对称性分类的误差评估 假设我们预测：癌症（y=1）,非癌症（y≠1）。我们可以画出类似下面的四方格子： 我们由此可以得出两个评估模型的数字概率： 查准率 ： 在这个模型中，查准率=预测正确为癌症数(y=1)所有预测为癌症数(y=1)查准率 = \\frac{预测正确为癌症数(y=1)}{所有预测为癌症数(y=1)}查准率=所有预测为癌症数(y=1)预测正确为癌症数(y=1)​ 召回率： 在这个模型中，召回率=预测正确为癌症数(y=1)实际为癌症数(y=1)召回率 = \\frac{预测正确为癌症数(y=1)}{实际为癌症数(y=1)}召回率=实际为癌症数(y=1)预测正确为癌症数(y=1)​ 查准率高说明 False pos 低False \\ \\ pos \\ 低False pos 低 (错误预测为癌症数低) ；召回率高说明False neg 低False \\ \\ neg \\ 低False neg 低 （错误预测为非癌症数低） 10.3 精确度和召回率的权衡 依旧以之前那个预测癌症为例。我们知道预测函数 0≤hθ(x)≤10 ≤ h_\\theta{(x)} ≤ 10≤hθ​(x)≤1 ，且通常我们当 hθ(x)&gt;0.5h_\\theta{(x)} &gt; 0.5hθ​(x)&gt;0.5，预测 y =1，即是癌症。 提高查准率：谨慎告诉病人得了癌症。 告诉病人得了癌症是一件需要谨慎判断的事情，所以我们可以通过提高 thresholdthresholdthreshold ，比如 hθ(x)&gt;0.99h_\\theta{(x)} &gt; 0.99hθ​(x)&gt;0.99 时才判断为1告诉病人得了癌症。 但是这样做会导致：查准率(正确预测为癌症数提高)得到提高，而召回率下降？(判断正确为癌症数下降)。 提高召回率：需要有可能患癌症病人及时得到治疗。 同上，此时只要降低 thresholdthresholdthreshold ，比如 hθ(x)&gt;0.01h_\\theta{(x)} &gt; 0.01hθ​(x)&gt;0.01 即判断病人或有癌症。 同样的，这样做会导致：查准率降低，而召回率提高？(判断正确为癌症数上升，实际为癌症数不变)。 10.3.1 如何综合评价算法查准率/召回率？ 对于下面三个不同算法，有三个不同查准率/召回率，选择哪个算法？ 如果不是希望：查准率/召回率 某个值更高，我们可以综合评价算法。但是，取平均值不是一个好的做法。我们采用一种叫做 F ScoreF\\ ScoreF Score 综合评价算法。 F ScoreF\\ ScoreF Score 越大则算法越好，比如极端情况：召回率=查准率=1召回率=查准率 = 1召回率=查准率=1 ， F Scoremax=1F\\ Score_{max} = 1F Scoremax​=1 10.4 机器学习数据 最成功的的不是那些拥有最好的算法的人，而是那些拥有最多数据的。 降低偏差：使用带有众多参数的算法来降低偏差，比如拥有复杂隐藏层的神经网络。 降低方差：使用大数据集来降低方差，使得测试集误差也会相应很小。 二者结合，机器学习，千秋万代，一统江湖。 十一、支持向量机(SVM) 11.1 优化目标 我们对此前的 logistic 回归代价进行一些修改。 yi=1时，代价函数=−log11+e(−θTx)y_i = 1 时，代价函数 = - log\\frac{1}{1+e^{(-\\theta^Tx)}}yi​=1时，代价函数=−log1+e(−θTx)1​ ：如左图，我们想要此时 z=θTx&gt;&gt;0z = \\theta^Tx &gt;&gt; 0z=θTx&gt;&gt;0 ，如果满足则代价越小，不满足则代价则越大。 而支持向量机代价函数 cost1(z)cost_1(z)cost1​(z) 则是一条折线，逼近于原本代价函数： z&gt;1时z &gt;1 时z&gt;1时：此时代价为0，换言之z&gt;1−&gt;hθ(x)始终=1−&gt;代价函数=−log11+e(−θTx)=0z &gt;1 -&gt; h_\\theta (x) 始终= 1 -&gt; 代价函数 = - log\\frac{1}{1+e^{(-\\theta^Tx)}} = 0z&gt;1−&gt;hθ​(x)始终=1−&gt;代价函数=−log1+e(−θTx)1​=0 z&lt;1z &lt; 1z&lt;1 时：此时代价函数近似原本 logistics 回归代价函数 yi=−1时，代价函数=−log(1−11+e(−θTx))y_i = -1 时，代价函数 = - log(1-\\frac{1}{1+e^{(-\\theta^Tx)}})yi​=−1时，代价函数=−log(1−1+e(−θTx)1​) ：如右图，其余类似上，不再赘述。 因此我们可以得到最终支持向量机的代价函数： SVM 代价函数是CA+BCA+BCA+B 形式，而不是 logistics 代价函数 A+λBA + \\lambda BA+λB 形式。这是因为我们更关注与第一项AAA 的优化而不是第二项。 假设函数是否有误？ 应该是 θTx≥1，hθ(x)=1;θTx≤−1，hθ(x)=0\\theta^Tx ≥ 1 ，h_\\theta(x) = 1 ; \\theta^Tx ≤ -1 ，h_\\theta(x) = 0θTx≥1，hθ​(x)=1;θTx≤−1，hθ​(x)=0 ？？ 11.2 直观上对大间隔的理解 再次回顾下此前支持向量机代价函数 JSVMJ_{SVM}JSVM​： 11.2.1 SVM：线性最大分隔 对于一个样本我们有多种进行分隔直线进行分类，就像下面这种： 显然，黑色直线具有直观上最好的分类效果，因为它离正负样本都拥有 最大间距 。 进一步直观理解 SVM 中正则化系数CCC 的作用：防止过拟合。 下面这张图展示不同情况下 CCC 可能导致的情况。 当 CCC 过大 时：此时分隔直线是上面红色直线，显然它发生了过拟合。类似于 logistics 回归 λ\\lambdaλ 过小 时，导致过拟合情况。 当CCC 不是很大时：此时分隔直线显然具有更好的泛化能力，不会发生过拟合。 11.3 大间隔分类数学原理 引子：对于两个向量 u=[u1u2]u = \\begin{bmatrix} u_1\\\\u_2 \\end{bmatrix}u=[u1​u2​​] 与 v=[v1v2]v= \\begin{bmatrix} v_1\\\\v_2 \\end{bmatrix}v=[v1​v2​​] ，uTvu^TvuTv 的几何意义怎么理解？ 直接给结论：uTvu^TvuTv = u1v1+u2v2u_1v_1 + u_2v_2u1​v1​+u2​v2​ = P⋅∣∣u∣∣P·||u||P⋅∣∣u∣∣ = v在u上的投影距离∗u的长度v 在u上的投影距离*u的长度v在u上的投影距离∗u的长度 注意：PPP 是有方向的，而范数 ∣∣u∣∣||u||∣∣u∣∣ 是没有方向只有距离。 11.3.1 数学分析 🎯 我们的目标是最小代价函数。 根据上面公式可知，等价为 min 12∑j=1nθj2min \\ \\frac{1}{2} \\sum_{j=1}^{n}\\theta_j^2min 21​∑j=1n​θj2​ （因为第一项可控？）： 在根据 引子数学公式引子数学公式引子数学公式 我们可以进一步表达如下： 直观观测SVM如何确定最大间隔。 绿色直线为决策直线 y=θTxy = \\theta^Txy=θTx，蓝色直线为 θ\\thetaθ 向量，且它们互相垂直 ? 令 θ0=0\\theta_0 = 0θ0​=0 可以保证决策直线一定经过原点。 图1：为什么SVM可以决策直线不好？ 我们要使得 min 12∑j=1nθj2==min∣∣θ∣∣2min \\ \\frac{1}{2} \\sum_{j=1}^{n}\\theta_j^2 == min|| \\theta||^2min 21​∑j=1n​θj2​==min∣∣θ∣∣2 ，同时还要满足条件： {p(i)⋅∣∣θ∣∣≥1，正样本p(i)⋅∣∣θ∣∣≤−1，负样本\\begin{cases} p^{(i)}·||\\theta|| ≥1 &amp;，正样本\\\\ p^{(i)}·||\\theta|| ≤-1 &amp;，负样本\\\\ \\end{cases} {p(i)⋅∣∣θ∣∣≥1p(i)⋅∣∣θ∣∣≤−1​，正样本，负样本​ 可以看到恰好使得等式成立的支持向量 x(1)、x(2)x^{(1)}、x^{(2)}x(1)、x(2) 在向量 θ\\thetaθ 上的投影p(1)、p(2)p^{(1)}、p^{(2)}p(1)、p(2) 都很小。 而我们又要满足上述条件，那么自然 ∣∣θ∣∣||\\theta||∣∣θ∣∣ 就要很大，这与我们的目标不符合，所以可判断决策直线不好。 图2：为什么SVM可以决策直线好？ 同上，此时支持向量在 θ\\thetaθ 向量上的投影 p(1)、p(2)p^{(1)}、p^{(2)}p(1)、p(2) 最大 —&gt; 那么 ∣∣θ∣∣min||\\theta||_{min}∣∣θ∣∣min​ 。 11.4 核函数 11.4.1 核函数（上） 如何进行复杂非线性分类？ 在此前我们进行复杂非线性分类，是增加更多特征 x1x2、x12、x22...x_1x_2、x_1^2、x_2^2...x1​x2​、x12​、x22​... 进行非线性分类： 决策边界是： θTX=θ0+θ1x1+θ2x2+θ3x1x2...\\theta^TX = \\theta_0+\\theta_1x_1 +\\theta_2x_2+\\theta_3x_1x_2...θTX=θ0​+θ1​x1​+θ2​x2​+θ3​x1​x2​... ，预测函数为 h(θTx)h(\\theta^Tx)h(θTx) 。 而现在我们可以利用相似度函数 fff 来产生更多特征，将上面特征 x1、x2、x1x2、x12、x22...x_1、x_2、x_1x_2、x_1^2、x_2^2...x1​、x2​、x1​x2​、x12​、x22​... 替换为 f1、f2、f3、f4..f_1、f_2、f_3、f_4..f1​、f2​、f3​、f4​.. 。 θTf=θ0+θ1f1+θ2f2+θ3f3...其中：fi=similarity(x,l(i))=exp(−∣∣x−l(i)∣∣22σ2)\\theta^Tf = \\theta_0+\\theta_1f_1 +\\theta_2f_2+\\theta_3f_3...\\\\ 其中： f_i = similarity(x,l^{(i)}) = exp(-\\frac{||x-l^{(i)}||^2}{2\\sigma^2}) θTf=θ0​+θ1​f1​+θ2​f2​+θ3​f3​...其中：fi​=similarity(x,l(i))=exp(−2σ2∣∣x−l(i)∣∣2​) l(i)l^{(i)}l(i) 即标记。 进一步理解相似度函数 l(i)、σl^{(i)} 、\\sigmal(i)、σ 作用。 l(i)l^{(i)}l(i) 会标记对应产生的不同特征 f1、f2...f_1、f_2 ...f1​、f2​... ，它可用来描述和特征 xxx 的偏离： 当 l(i)接近xl^{(i)} 接近 xl(i)接近x ，fff 输出为 111 ， 当 l(i)远离xl^{(i)} 远离 xl(i)远离x ，fff 输出为 000 。 σ\\sigmaσ 可用来控制当 x远离l(i)x 远离 l^{(i)}x远离l(i) 时，函数 fff 趋于0下降的速率。 初始 l(1)=[35]l^{(1)} = \\begin{bmatrix} 3\\\\ 5 \\end{bmatrix}l(1)=[35​] 当 x=[35]x = \\begin{bmatrix} 3\\\\ 5 \\end{bmatrix}x=[35​] ，此时函数值 = 1 (顶峰处)。如果 σ\\sigmaσ 较大，可以看出当 x偏离l(1)x 偏离 l^{(1)}x偏离l(1) 越多，则此时函数值趋于0会相比较其它图更快。 一张图进行总结如下： 一个实际计算实例。 11.4.1 核函数（下） 如何获取标记 l(1)、l(2)、l(3)...l^{(1)}、l^{(2)}、l^{(3)}...l(1)、l(2)、l(3)... ？ 初始选择 l(1)=x(1)、l(2)=x(2)、l(3)=x(3)...l^{(1)} = x^{(1)}、l^{(2)} = x^{(2)}、l^{(3)} = x^{(3)}...l(1)=x(1)、l(2)=x(2)、l(3)=x(3)... ？然后怎么更新 l(i)l^{(i)}l(i) ? θTf=θ0+θ1f1+θ2f2+θ3f3...+θmfm...其中：fi=similarity(x,l(i))=exp(−∣∣x−x(i)∣∣22σ2)\\theta^Tf = \\theta_0+\\theta_1f_1 +\\theta_2f_2+\\theta_3f_3...+\\theta_mf_m...\\\\ 其中： f_i = similarity(x,l^{(i)}) = exp(-\\frac{||x-x^{(i)}||^2}{2\\sigma^2}) θTf=θ0​+θ1​f1​+θ2​f2​+θ3​f3​...+θm​fm​...其中：fi​=similarity(x,l(i))=exp(−2σ2∣∣x−x(i)∣∣2​) 有多个样本就有多个核函数 fif_ifi​？ 核函数版代价函数。 11.5 使用SVM 我们可以使用成熟的库来实现SVM算法的应用。 那么，大量细节实现被隐藏了，我们仅需要选择参数 CCC 和 核函数fi核函数f_i核函数fi​。 线性核函数，实际没有应用到核函数，但我们保持这么一个称呼以便统一。 11.5.1 多分类 依旧是一对多，分类KKK个类别，训练 KKK 个线性 SVMsSVMsSVMs 。 给定一组特征(X,Y)(X,Y)(X,Y) ，K组训练权重θ\\thetaθ ， θ(i)TX{\\theta^{(i)}}^TXθ(i)TX对应概率最大则分类为 iii。 11.5.3 logistics 回归 &amp; SVM 以下列举了对于特征 nnn 与样本数 mmm 不同情况下，如何选择 logistics 回归 OR SVM 进行分类。 十二、无监督学习 12.1 K-means 算法"},{"title":"深度学习基础（一）Numpy&Pytorch","date":"2022-01-02T11:54:25.548Z","updated":"2022-01-02T11:42:51.773Z","comments":true,"path":"NO_post/深度学习基础（一）Numpy&Pytorch.html","permalink":"https://hwh.zone/NO_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89Numpy&Pytorch.html","excerpt":"","text":"矩阵，数组？Numpy 一、 常用方法 0 初次使用 安装：pip install numpy 引用：import numpy as np 1 创建数组：np.arange、np.ones… 基本方式 基本创建数组的办法，注意以下创建的都是 一维数组 (5,) ： 123456a = np.array([0, 1, 2, 3, 4]) # &gt;&gt;&gt;[0 1 2 3 4]b = np.array((0, 1, 2, 3, 4)) # &gt;&gt;&gt;[0 1 2 3 4]c = np.arange(5) # &gt;&gt;&gt;[0 1 2 3 4]d = np.linspace(0, 2*np.pi, 5) # 将[0,2π]等分为5份print(d) # &gt;&gt;&gt;[ 0. 1.57079633 3.14159265 4.71238898 6.28318531] 为了创建 多维数组 我们可以使用 reshape() 来改变数组维度： 12345678910&gt;&gt;&gt; np.arange(12).reshape((3,4)) # 2D:传入的是一个元组array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) &gt;&gt;&gt; np.arange(12).reshape((2,2,3)) # 3D:传入的是一个元组array([[[ 0, 1, 2], [ 3, 4, 5]], [[ 6, 7, 8], [ 9, 10, 11]]]) 当然你也可以选择传入多维列表： 123456&gt;&gt;&gt; A = np.array([[2,1,-2],[3,0,1],[1,1,-1]])&gt;&gt;&gt; A = np.array([[2,1,-2],[3,0,1],[1,1,-1]])&gt;&gt;&gt; Aarray([[ 2, 1, -2], [ 3, 0, 1], [ 1, 1, -1]]) 库函数生成 最后可以使用基本库函数 zeros、ones、eyes、empty、full、random来创建。 12345678910111213141516171819202122232425262728293031# 1D 创建一维可以直接传递一个数字&gt;&gt;&gt; np.zeros(6)array([0., 0., 0., 0., 0., 0.])&gt;&gt;&gt; np.ones(6)array([1., 1., 1., 1., 1., 1.])&gt;&gt;&gt; np.full(6,3)array([3, 3, 3, 3, 3, 3])# 2D 除了 eyes方法，其余都传递一个元组&gt;&gt;&gt; np.zeros((2,3))array([[0., 0., 0.], [0., 0., 0.]])&gt;&gt;&gt; np.empty((2,3)) # 不是空矩阵，而是内容随机array([[0., 0., 0.], [0., 0., 0.]])&gt;&gt;&gt; np.full((2,3),6)array([[6, 6, 6], [6, 6, 6]]) &gt;&gt;&gt; np.eye(3,3) # 对角矩阵：传递不是元组，而是两个数字array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]])&gt;&gt;&gt; np.random.random((2,3)) # 随机填充[0,1]之间的一个数值array([[0.91453011, 0.06663476, 0.18352908], [0.19449024, 0.06442752, 0.64491859]]) ​ 2 索引：切片、列表索引、布尔屏蔽 基本索引 索引一个数字类似于 python 多维列表 12345678&gt;&gt;&gt; a = np.array([[11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25], [26, 27, 28 ,29, 30], [31, 32, 33, 34, 35]]) &gt;&gt;&gt; a[2,4] 25 切片索引 1234567891011121314151617# 索引第2列&gt;&gt;&gt; a[:, 1] [12 17 22 27 32]# 索引第1列，指定开始选中数值&gt;&gt;&gt; a[1:4, 0] [16 21 26]# 索引第0行，指定开始选中数值&gt;&gt;&gt; a[0, 1:4] [12 13 14]# 每隔2行，每隔2列进行索引&gt;&gt;&gt; a[::2,::2] [[11 13 15] [21 23 25] [31 33 35]] 列表索引 依旧使用上面矩阵，我们可以指定一个列表来索引指定位置元素： 12345678910&gt;&gt;&gt; a = np.array([[11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25], [26, 27, 28 ,29, 30], [31, 32, 33, 34, 35]])&gt;&gt;&gt; L = [0,2,4]&gt;&gt;&gt; a[L] # 索引第 1、3、5行array([[11, 12, 13, 14, 15], [21, 22, 23, 24, 25], [31, 32, 33, 34, 35]]) 布尔屏蔽 布尔屏蔽是一个有用的功能，它允许我们根据我们指定的条件检索数组中的元素。 12345678910# 布尔屏蔽import matplotlib.pyplot as plta = np.linspace(0, 2 * np.pi, 50)b = np.sin(a)plt.plot(a,b)# 画出值大于0，且小于π/2的所有绿色点mask = (b &gt;= 0) &amp; (a &lt;= np.pi / 2)plt.plot(a[mask], b[mask], &#x27;go&#x27;)plt.show() 3 插入：np.c_ 、np.r_ 还有其它插入方式暂时不表，下面都仅限于插入 2D 数组，更高维暂未尝试。 按列插入：np.c_ 按列插入则要求，被插入的数组和原数组 行相同 。 123456789101112131415161718&gt;&gt;&gt; aarray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])# 1D 数组，但是第一维度相同（虽然看起来是行向量？）&gt;&gt;&gt; c0 = np.zeros((3,))&gt;&gt;&gt; np.c_[c0,a]array([[ 0., 0., 1., 2., 3.], [ 0., 4., 5., 6., 7.], [ 0., 8., 9., 10., 11.]])# 2D 数组，第一维度相同&gt;&gt;&gt; c1 = np.ones((3,1))&gt;&gt;&gt; np.c_[c1,a]array([[ 1., 0., 1., 2., 3.], [ 1., 4., 5., 6., 7.], [ 1., 8., 9., 10., 11.]]) 按行插入：np.r_ 123456789101112&gt;&gt;&gt; aarray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])# 按行插入：第2维度相等&gt;&gt;&gt; r0 = np.zeros((1,4))&gt;&gt;&gt; np.r_[r0,a]array([[ 0., 0., 0., 0.], [ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.]]) 二、Numpy 进阶 2.1 广播 以下整理自：numpy中的广播机制 什么是广播？ 当两个数组的形状并不相同的时候，我们可以通过扩展数组的方法来实现相加、相减、相乘等操作。 广播的条件是什么？ 数组维度 不同，后缘维度的轴长相符 数组维度 相同，其中有个轴为1 2.1.1 维度不同进行广播 (4,3) 是 2D，(3,) 是 1D，但是它们后缘维度相同，因此可以扩展 (3,4,2) 是 3D，(4,2) 是 1D，但是它们后缘维度相同 同理，还有 （4,2,3）和（2,3）是兼容的，（4,2,3）还和（3）是兼容的。 2.1.2 维度相同进行广播 虽然维度相同，但有一个为1，也可以进行广播。 PTboy：PyTorch 一、快速入门 本笔记主要参考：pytorch中文教程 、pytorch开源书籍中文教程 1.1 安装 进入 PyTorch官网 我们可以看到需要安装的软件和版本： Package：包管理软件，可以用 pip ，为了方便我们使用 Conda CUDA : 显卡加速软件，GPU 跑一定要下载，CPU 不用。我们显卡是 GTX 1650 ，GPU 勉强可以跑得动，故下载。 下面依次详细记录安装 Conda &amp; CUDA 。 1.1.1 安装 AnaConda 安装参考 ： Anaconda详细安装及使用教程 官网下载： AnaConda最新版本 。太慢了，选择 : 腾讯软件下载AnaConda 。 下载完毕后开始安装，一直下一步就好 ，有两个地方需要说明： 安装路径：安装路径需要英文懒得折腾，直接默认安装路径了 环境变量：在安装过程中可以勾选自动添加环境变量，记得勾选 如果安装成功，且环境变量配置成功，在 cmd 输入 conda -V 可以看到如下版本信息： Conda 使用初体验 以下操作都是命令行，在 cmd 环境中进行。 创建虚拟环境： 更新所有包：conda upgrade --all 创建虚拟环境：conda create --name ptboy python=3.7 切换环境 &amp; 查看已创建环境：activate ptboy &amp; conda env list 切换/退出 python 解释器：python 、exit() 包管理 ： 安装 / 卸载 包 ： conda install 要安装的包名 、conda remove 要卸载的包名 和 pycharm 连接： 下面略有不对，可参考这篇文章：Anaconda与pycharm连接 File --&gt; Settings --&gt; Project:你的项目名 ---&gt; Project Interpreter ，然后 Add ： 设置虚拟环境python解释器： 1.1.2 安装 CUDA &amp; cuDNN 安装 CUDA 🙂 狗日的fuck 中国移动网卡，浪费我一天时间检查网络，原来是你这🐶 东西限我速！ 首先我们去官网下载 CUDA ：CUDA 10.1 下载 点击右下角 Download[2.5GB] 下载即可。 下载完毕后，解压默认会提取到临时目录，不用修改（临时目录会自动删除） 一直下一步 --&gt; 自定义安装 ，勾选以下： ⚠️ 一般安装出错都是由于 Visual Studio Intergration ，所以去除掉，实际我也用不到 VS 环境。 如果需要VS环境，可参考这篇文章：CUDA安装失败原因解决 。 下一步，使用默认安装位置，不折腾了： 一直下一步安装，很快便会显示安装完成了。 接着便是最重要容易出错的 环境变量配置了 ： ⚠️ 下面都是默认安装路径，如果需要自定义安装注意修改环境变量路径名。 高级系统设置 --&gt; 环境变量 --&gt; 系统变量，添加以下几个环境变量： CUDA_SDK_PATH = C:\\ProgramData\\NVIDIA Corporation\\CUDA Samples\\v10.1 CUDA_LIB_PATH = %CUDA_PATH%\\lib\\x64 CUDA_BIN_PATH = %CUDA_PATH%\\bin CUDA_SDK_BIN_PATH = %CUDA_SDK_PATH%\\bin\\win64 CUDA_SDK_LIB_PATH = %CUDA_SDK_PATH%\\common\\lib\\x64 高级系统设置 --&gt; 环境变量 --&gt; 系统变量 --&gt; PATH , 添加： C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\lib\\x64 C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\bin C:\\ProgramData\\NVIDIA Corporation\\CUDA Samples\\v10.1\\common\\lib\\x64 C:\\ProgramData\\NVIDIA Corporation\\CUDA Samples\\v10.1\\bin\\win64 在cmd 键入 nvcc -V 来查看是否正确安装： 安装 cuDNN 我们继续开始安装 cuDNN ，下载cuDNN 地址：cuDNN 7.6.4 下载 ⚠️ 下载前要先注册会员，选择 QQ登陆马上就注册好了？ 点击上述红框位置下载即可，解压文件复制下图所示3个文件： 然后找到 CUDA 安装目录（我之前是默认），复制替换对应下面三个文件： 整体测试安装 切换到目录(默认) ：C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\extras\\demo_suite 可以看到上述两个程序：bandwidthTest.exe 、deviceQuery.exe 两个测试程序。 在 cmd 中运行这两个测试程序： 出现以上信息则证明安装成功。 第一次安装出错：原因是驱动版本跟不上 CUDA 版本。 解决办法如下，下载 NVIDIA GeForce Experience ：腾讯下载 NVIDIA GeForce Experience 。 打开软件更新驱动，下载 GeForce Game Ready Driver： 安装，会提示你更新驱动，直接更新就好。再次运行便会发现可以正常运行测试信息了。 1.1.3 安装 pytorch 进入官网，我们可以看到安装命令： 1conda install pytorch torchvision torchaudio cudatoolkit=10.2 -c pytorch 尝试替换源加快速度。 参数 -c pytorch 指的是 pytorh 官方仓库，由于速度太慢我们换成清华源： 12345conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/conda config --set show_channel_urls yes ⚠️ 一开始好像没有引用 pytorch 清华源（第三个），一直官方安装不成功。 再执行安装命令即可快速安装了： 1conda install pytorch torchvision cudatoolkit=10.1 最后切换到 python 解释器，输入 import torch ，不报错则安装成功了： 12(ptboy) C:\\Users\\86151&gt;python&gt;&gt;&gt; import pytorch 补充 一开始由于安装太慢尝试各种办法，删除了 .condarc文件(everything进行搜索) 默认通道 default （最后一行）。最终文件内容如下： 12345channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/show_channel_urls: true 1.1.4 安装使用 jupyter 该部分主要参考于 ：Jupyter Notebook介绍、安装及使用教程 快速启动 安装 进入到 cmd 界面进行安装。我最开始想在指定环境 activate ot下安装，显示缺少依赖。 我想后面还可以设置引用环境为 ot ，就不管了。 1conda install jupyter 启动 启动后界面那一堆文件，其实是我们家目录中的文件。 在 cmd 窗口输入下面命令，会自动在浏览器打开 jupyter。 ⚠️ 不要关闭 cmd 否则在 Jupyter 中也无法继续操作！ 1jupyter notebook 如果想换个浏览器打开，可以查看到 cmd 中有 token 值： 输入 http://localhost:8080 在键入上述token 即可！ 也可以使用 jupyter notebook list 查看token 值。 启动配置 指定端口启动： 1jupyter notebook --port &lt;port_number&gt; 启动但不打开服务器： 1jupyter notebook --no-browser 设置文件保存路径 仅说如何在 windows 设置，linux 参照最开始提到的教程。 默认保存文档是在家目录，我们可以修改想要保存文件的目录。首先查询配置文件地址： 1jupyter notebook --generate-config 编辑该配置文件：找到 c.NotebookApp.notebook_dir 取消注释配置自己想保存的路径 实际测试最好用 \\\\ , 成功后再启动就能看见一个清爽的界面 基本使用 主界面 &amp; 笔记本页面简介 根据上图我们创建一个.ipynb 文件，编辑上面测试代码 &amp; md文字 进行输出。 ESC 进入命令模式 ： a 在当前cell创建一个cell b 在当前cell之后创建一个cell m 进入 markdown 模式（单元格前面 In[] 没了） y 进入 code （单元格前面 In[] 又出现了） l 显示 cell 中总行数 dd 删除当前cell 扩展功能 扩展功能1 ： 关联 Jupyter Notebook和 conda 环境。 安装 nb_conda 1conda install nb_conda ⚠️ 出现报以下错误 摸不着头脑，我主要做了以下事就可以了： conda clean -- packages (好像没软用) 修改了下文件 .condarc 去除清华源换成别的源（？？） 愉快查看环境 此时在 jupyter 会增加一列 Conda 我们可以查看Conda 拥有的环境变量。 ⚠️ 但是此时不能直接点击切换环境，如 ot 查看环境又他娘报错： 解决报错： 切换 conda 环境 如果想要指定 conda 指定环境，经过测试要先在cmd 激活指定环境： 1activeta ot 然后再启动 Jupyter ，即发现此时 conda 环境以及切换到 ot ： 扩展2：在 jupyter 使用 markdowm ⚠️ 一开始报各种错误，又是 conda.exe 不存在 / 产生冲突。解决如下： 卸载 Anaconda 有些冲动了，感觉可以不卸载。 新建环境 base0 ⚠️ 最开始安装 3.7 版本，后面安装扩展显示报错产生冲突。 1conda create --name base0 --python=3.5 接下来以下命令都能正常执行了。 经过测试实际可行的安装扩展插件方法： 用 pip 安装扩展 1pip install conda-forge jupyter_contrib_nbextensions 解决安装的相关依赖 执行 1. 命令会显示要先安装 lxml 之类，为了速度先直接用conda 安装： 1conda install lxml 安装扩展 1pip install conda-forge jupyter_contrib_nbextensions 这样就可以快速安装好扩展了。 但是打开扩展可能出现下面问题： 尝试执行下面命令即可解决： 1jupyter contrib nbextensions install --sys-prefix --skip-running-check 安装扩展 1conda install -c conda-forge jupyter_contrib_nbextensions 开始使用 markdown 点击导航栏多出来的 Nbextensions 类目，勾选 Tableof Contents ⑵ 。 然后便可以在 Jupyter 中使用 markdown 了 ： 补充使用 加载各种 加载指定网址源码 1%load URL 加载本地 python 文件 1%load Python文件的绝对路径 🙂 其实你不想加载 python 文件再运行，也可直接运行文件。 1%run Python文件的绝对路径 使用 shell 命令 1!shell命令 !pwd : 获取当前笔记本所在绝对路径位置 也可在 jupyter 打开终端 ， new —&gt; Terminal 。 快捷键 按esc键进入命令模式，此时不能操作单元格 按enter或return键进入编辑模式，可编辑单元格 1.2 张量 1.2.1 生成张量 以下都需引入如下包。 12from __future__ import print_functionimport torch 库函数生成 类似于 numpy 库函数生成ndarray，但有时候 numpy 传入有时是triple，而 pytorch 传入基本都是 int 12345678# empty ： 没有初始化的张量（元素随机）torch.empty(5, 3)# rand：随机初始化张量torch.rand(5, 3)# zeros：生成全零张量torch.zeros(5, 3, dtype=torch.long) # 同时还指定元素类似为 long 直接构造 12x = torch.tensor([5.5, 3])print(x)Copy 输出： 1tensor([5.5000, 3.0000]) 根据已有张量构造 123456X = torch.zeros(3,3)print(X)# 根据X实例方法 new_ones 生成全0张量，大小也可改变（那不等于直接库函数创建？）X1 = X.new_ones(2,2,dtype=torch.double)print(X1) 输出： 12345tensor([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]])tensor([[1., 1.], [1., 1.]], dtype=torch.float64) 1.2.2 常用张量方法 形状相关 123456789101112# 1.查看形状X.size() # 输出：torch.Size([3, 3])# 2.改变形状 &gt;&gt;&gt; x = torch.randn(4, 4)torch.Size([4, 4])&gt;&gt;&gt; y = x.view(16)torch.Size([16])&gt;&gt;&gt; z = x.view(-1, 8) # 参数为-1，指的是这个维度根据：元素个数/其它维度 ，自动计算出来torch.Size([2, 8]) 索引操作 类似 numpy 进行各种索引操作。 12345&gt;&gt;&gt; x = torch.rand(3,3)&gt;&gt;&gt; xtensor([[0.3667, 0.7708, 0.9581], [0.0958, 0.6113, 0.3566], [0.6013, 0.0894, 0.2580]]) 切片索引： 123# 索引第2列&gt;&gt;&gt; x[:,1]tensor([0.7708, 0.6113, 0.0894]) 不想写了…今天是 2019 / 11 / 12 16:58 ，我是青青草原带灰狼哈哈 numpy数组 ⇄ Torch 张量 ndarray 数组每个元素之间是空格 ，Tensor 是 逗号 。 torch 张量 → numpy 数组 ： 1234# numpy()a = torch.ones(5) # 张量 : tensor([1., 1., 1., 1., 1.])b = a.numpy() # ndarray :[1. 1. 1. 1. 1.] torch 张量 ← numpy 数组 ： 1234# torch.form_numpy()a = np.ones(5) # ndarray：[1. 1. 1. 1. 1.]b = torch.from_numpy(a) # 张量： tensor([1., 1., 1., 1., 1.]) 1.2.3 张量运算 加减乘除 仅以加法为例，更多上百种运算参考：这里 1234567891011# 1.直接相加y = torch.rand(5, 3)print(x + y)# 2.库函数 torch.addtorch.add(x, y)# 3.张量实例本身函数（in-place）y.add_(x) # adds x to y# 其它in-place操作x.copy_(y) # 复制y到x 1.3 自动求导 pytorch 在所有神经网络的核心是 autograd 包，而autograd 包核心类是 torch.Tensor 。 如何进行自动求导 ： 给希望追踪对它进行求导的张量x，设置属性 requires_grad = True 当完成计算后，通过调用 backward(gradient) 方法，自动计算所有的梯度（自动累加到 grad 属性） 调用 backward() 方法需要指定一个参数gradient，该参数匹配张量形状 ？ 特别的，如果此时张量是标量，可不传入参数，等价此时 gradient = torch.tensor(1) 。 通过被追踪的张量 x 属性值 grad ，即 x.grad 便可求出它的梯度 如果不希望跟踪历史记录 ： 将代码块包装在 with torch.no_grad()： 中 1.3.1 关于 Function Function 是自动求导另外一个非常重要的*类* 。Tensor类 和 Function类互相连接并生成一个非循环图，它表示和存储了完整的计算历史。 每个张量都有一个.grad_fn属性，这个属性引用了一个创建了Tensor的Function （没太明白 ？） 1.3.2 向量求导（没太整明白） 已知 y⃗=f(x⃗)\\vec y = f(\\vec x)y​=f(x) ， 其中 y⃗\\vec yy​ 和 x⃗\\vec xx 都是向量，那么 y⃗\\vec yy​ 对 x⃗\\vec xx 的梯度形式应该是？ 在数学上，∂y⃗∂x⃗\\frac{\\partial \\vec y}{\\partial \\vec x}∂x∂y​​ 应该是一个雅可比矩阵，可记为 JJJ : J=[∂y⃗1∂x⃗1 ... ∂y⃗m∂x⃗1...∂y⃗1∂x⃗n ... ∂y⃗m∂x⃗n]J = \\begin{bmatrix} \\frac{\\partial \\vec y_1}{\\partial \\vec x_1} \\ ... \\ \\frac{\\partial \\vec y_m}{\\partial \\vec x_1} \\\\ ... \\\\ \\frac{\\partial \\vec y_1}{\\partial \\vec x_n} \\ ... \\ \\frac{\\partial \\vec y_m}{\\partial \\vec x_n} \\end{bmatrix} J=⎣⎡​∂x1​∂y​1​​ ... ∂x1​∂y​m​​...∂xn​∂y​1​​ ... ∂xn​∂y​m​​​⎦⎤​ 已知 l=g(y⃗)l=g(\\vec y)l=g(y​) 其中 lll 为标量 ，那么 ∂l∂y⃗\\frac{\\partial l }{\\partial \\vec y}∂y​∂l​ 梯度vvv 形式应该是？ v=[∂l∂y1 ... ∂l∂ym]Tv = \\begin{bmatrix} \\frac{\\partial l }{\\partial y_1} \\ ... \\ \\frac{\\partial l }{\\partial y_m} \\end{bmatrix} ^T v=[∂y1​∂l​ ... ∂ym​∂l​​]T 根据上述，我们已知 J=∂y⃗∂x⃗J = \\frac{\\partial \\vec y}{\\partial \\vec x}J=∂x∂y​​ ， v=∂l∂y⃗v =\\frac{\\partial l }{\\partial \\vec y}v=∂y​∂l​ , 那么 ∂l∂x⃗\\frac{\\partial l }{\\partial \\vec x}∂x∂l​ ? 根据链式法则： ∂l∂x⃗\\frac{\\partial l }{\\partial \\vec x}∂x∂l​ = ∂l∂y⃗⋅∂y⃗∂x⃗\\frac{\\partial l }{\\partial \\vec y} · \\frac{\\partial \\vec y}{\\partial \\vec x}∂y​∂l​⋅∂x∂y​​ ∂l∂x⃗=∂l∂y⃗⋅∂y⃗∂x⃗=J⋅v=[∂y⃗1∂x⃗1 ... ∂y⃗m∂x⃗1...∂y⃗1∂x⃗n ... ∂y⃗m∂x⃗n][∂l∂y1...∂l∂ym]=[∂l∂x1...∂l∂xm]\\frac{\\partial l }{\\partial \\vec x} = \\frac{\\partial l }{\\partial \\vec y} · \\frac{\\partial \\vec y}{\\partial \\vec x} = J·v = \\begin{bmatrix} \\frac{\\partial \\vec y_1}{\\partial \\vec x_1} \\ ... \\ \\frac{\\partial \\vec y_m}{\\partial \\vec x_1} \\\\ ... \\\\ \\frac{\\partial \\vec y_1}{\\partial \\vec x_n} \\ ... \\ \\frac{\\partial \\vec y_m}{\\partial \\vec x_n} \\end{bmatrix} \\begin{bmatrix} \\frac{\\partial l }{\\partial y_1} \\\\ ... \\\\ \\frac{\\partial l }{\\partial y_m} \\end{bmatrix} = \\begin{bmatrix} \\frac{\\partial l }{\\partial x_1} \\\\ ... \\\\ \\frac{\\partial l }{\\partial x_m} \\end{bmatrix} ∂x∂l​=∂y​∂l​⋅∂x∂y​​=J⋅v=⎣⎡​∂x1​∂y​1​​ ... ∂x1​∂y​m​​...∂xn​∂y​1​​ ... ∂xn​∂y​m​​​⎦⎤​⎣⎡​∂y1​∂l​...∂ym​∂l​​⎦⎤​=⎣⎡​∂x1​∂l​...∂xm​∂l​​⎦⎤​ 1.3.3 举个栗子 1import torch 栗子1 以下过程可表示为 ：out=14∑izi=14∑i3(xi+2)2out = \\frac{1}{4} \\sum_i z_i = \\frac{1}{4} \\sum_i 3(x_i+2)^2out=41​∑i​zi​=41​∑i​3(xi​+2)2 1234x = torch.ones(2,2,requires_grad=True) # 追踪张量xy = x + 2z = y * y * 3out = z.mean() out 调用方法 backward 进行反向传播，因为 out 是标量，所以可不用传参数： cvb n 1out.backward() 由于 x 设置了 requires_grad = True ，其梯度会被自动累加，我们可计算其梯度为： 12345x.grad# 输出# tensor([[4.5000, 4.5000],# [4.5000, 4.5000]]) Q : 没明白，根据 1.3.2 节，此时输出不该是一个 4*1 大小张量吗？ A: 非也，因为此时x 是 2*2 大小，而 1.3.2 节 x 是 m*1 大小 栗子2 以下过程可表示为： y=(x∗2)2∗y.data.normy = (x*2)^{2*y.data.norm}y=(x∗2)2∗y.data.norm 12345678910x = torch.randn(3, requires_grad=True)y = x * 2while y.data.norm() &lt; 1000: y = y * 2print(y)# 输出y# tensor([-920.6895, -115.7301, -867.6995], grad_fn=&lt;MulBackward&gt;) 显然，此时 yyy 是一个向量，那么此时调用 backward 进行反向传播需传递参数 gradient ： 依然不太明白此时 gradient 参数意义？ 大小和 x 保持一致，那么其中的列表值是什么意思呢？ 经过请教大师兄，解释如下： gradient 参数表示学习速率 α\\alphaα ，当 α=1\\alpha = 1α=1 时 x.grad = 512 ；α=0.1\\alpha = 0.1α=0.1 ,那么 x.grad = 51.2。 控制当前梯度变化速率，而且可对于每个不同样本 xix_ixi​ 进行控制。 123456gradients = torch.tensor([0.1, 1.0, 0.0001], dtype=torch.float)y.backward(gradients)print(x.grad)# tensor([ 51.2000, 512.0000, 0.0512]) 1.4 神经网络 我的神经网络都是没有好好训练啊，做笔记还在胡思乱写，现在反向传播还来得及吗？ 14.1 快速入门 定义网络 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import torchimport torch.nn as nnimport torch.nn.functional as Fclass Net(nn.Module): def __init__(self): super(Net, self).__init__() # class torch.nn.Conv1d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True) # 输入图像channels：1；输出channels：6；kernel = 5x5，方阵可只写一个数字5 self.conv1 = nn.Conv2d(1, 6, 5) self.conv2 = nn.Conv2d(6, 16, 5) # class torch.nn.Linear(in_features, out_features, bias=True) # in_features ： 输入样本的大小 # out_features： 输出样本的大小 # nn.Linear 传入相连两个layer各自大小，返回一个函数fc(x),可用来计算前向传播下一层layer值 self.fc1 = nn.Linear(16 * 5 * 5, 120) self.fc2 = nn.Linear(120, 84) self.fc3 = nn.Linear(84, 10) def forward(self, x): # torch.nn.functional.max_pool2d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False) # input：输入的张量。在这里激活函数为relu，会将神经元输入值映射到新值（输出值） x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2)) x = F.max_pool2d(F.relu(self.conv2(x)), 2) x = x.view(-1, self.num_flat_features(x)) # 和全连接层相连先平铺 x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = self.fc3(x) return x def num_flat_features(self, x): &quot;&quot;&quot; 平铺卷积层图像特征向量： 因为输入图片size = (1,1,32,32),表示输入1张大小为1@32*32的特征图 显然第一个参数1，指图片个数，也就是一次批处理的数量 &quot;&quot;&quot; size = x.size()[1:] # 除去批处理维度的其他所有维度，[1,16,5,5] --&gt; [16,5,5] num_features = 1 for s in size: num_features *= s return num_featuresnet = Net() 现在让我们进行前向传播和反向传播、更新权重等。下一节将会以实际例子来统合下面方法。 前向传播 12input = torch.randn(1, 1, 32, 32) # 随机输入一张图像out = net(input) # 前向传播 输出： 12tensor([[ 0.0399, -0.0856, 0.0668, 0.0915, 0.0453, -0.0680, -0.1024, 0.0493, -0.1043, -0.1267]], grad_fn=&lt;AddmmBackward&gt;) 损失函数 一个损失函数接受一对 (output, target) 作为输入，nn 包多个不同损失函数。 例如：均方误差损失函数MSE，nn.MSELoss() 123456output = net(input)target = torch.randn(10) # 本例子中使用模拟数据target = target.view(1, -1) # 使目标值与数据值形状一致,size=(1,10)criterion = nn.MSELoss()loss = criterion(output, target) # tensor(1.0263, grad_fn=&lt;MseLossBackward&gt;) 反向传播 Q : 传入一个随机梯度进行反向传播？ 有了 loss 函数我们便可以进行反向传播。 12net.zero_grad() # 清除所有参数的梯度缓存loss.backward(torch.randn(1, 10)) # 传入一个随机梯度进行反向传播？ 同时我们还可以查看反向传播后 conv1 层 bias 梯度： 12&gt;&gt;&gt; net.conv1.bias.gradtensor([ 0.0084, 0.0019, -0.0179, -0.0212, 0.0067, -0.0096]) 1.4.2 举个栗子：训练分类器 这部分主要参考：基于PyTorch的CIFAR10小记 训练一个图像分类器可按照以下顺序进行： 使用torchvision加载和归一化 CIFAR10 训练集和测试集 定义一个卷积神经网络 定义损失函数 在训练集上训练网络 在测试集上测试网络 1 加载数据 该部分主要参考于 ： 基于PyTorch的CIFAR10小记 测试数据集使用 CIFAR10，直接用torchvision 太慢，我们使用 链接 来进行下载。 下载完毕后，导入包和一些基本参数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import torchimport torchvisionimport torchvision.transforms as transformsimport matplotlib.pyplot as pltimport numpy as np# 参数设置EPOCHS = 20BATCH_SIZE = 512# 0.创建一个转换器，将torchvision数据集的输出范围[0,1]转换为归一化范围的张量[-1,1]# 为什么需要转换？transform = transforms.Compose\\([ transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])# 1.创建训练集trainset = torchvision.datasets.CIFAR10\\( root=&#x27;./data&#x27;, # 存放的目录 train=True, # 是否训练集 download=True, # 是否需要下载 transform=transform # 是否进行转换)# 2.创建测试集testset = torchvision.datasets.CIFAR10\\( root=&#x27;./data&#x27;, train=False, download=True, transform=transform)# 3.创建训练/测试加载器# shuffle -- 是否打乱顺序trainloader = torch.utils.data.DataLoader(trainset, batch_size=BATCH_SIZE, shuffle=True )testloader = torch.utils.data.DataLoader (testset, batch_size=BATCH_SIZE, shuffle=True )# 4.设置类别标签classes = (&#x27;plane&#x27;, &#x27;car&#x27;, &#x27;bird&#x27;, &#x27;cat&#x27;, &#x27;deer&#x27;, &#x27;dog&#x27;, &#x27;frog&#x27;, &#x27;horse&#x27;, &#x27;ship&#x27;, &#x27;truck&#x27;) 上面一些代码进行解释： 转换器 1transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))]) ToTensor(): 将一个取值是 [0,255]的PI.Image（或者 shape=(H,W,C) 的ndarray） —&gt; 取值是[0,1,0]的torch.FloadTensor（同时 shape=(C,H,W)） Normalize(mean, std) ： 给定均值 mean、std，会将Tensor正则化，即：Normalized_image=(image-mean)/std transforms.Compose([ transforms.CenterCrop(10),transforms.ToTensor() ]) 将多个 transform 组合起来使用，比如上面是进行了 中心裁剪 + ToTensor 2 定义网络 该网络定义在文件: CNN1.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import torchLR = 0.005 # 学习率class Net(torch.nn.Module): # 定义网络结构：3个卷积层 + 1个全连接层 def __init__(self): super(Net, self).__init__() # 3个卷积层 # 定义该卷积层依次经过： 3*3卷积核 --&gt; ReLU激活函数 --&gt; 池化层下采样 self.conv1 = torch.nn.Sequential\\ (# Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1) torch.nn.Conv2d(3, 16, 3, padding=1), # 3@32*32 -&gt; 16@32*32 torch.nn.ReLU(), # 第一个参数是卷积核大小2*2，第二个参数是stride torch.nn.MaxPool2d(2, 2) # 16*32*32 -&gt; 16*16*16 ) self.conv2 = torch.nn.Sequential\\ ( torch.nn.Conv2d(16, 32, 3, padding=1), # 16*16*16 -&gt; 32*16*16 torch.nn.ReLU(), torch.nn.MaxPool2d(2, 2) # 32*16*16 -&gt; 32*8*8 ) self.conv3 = torch.nn.Sequential\\ ( torch.nn.Conv2d(32, 64, 3, padding=1), # 32*8*8 -&gt; 64*8*8 torch.nn.ReLU(), torch.nn.MaxPool2d(2, 2) # 64*8*8 -&gt; 64*4*4 ) # 1个全连接层（2个？） self.fc1 = torch.nn.Sequential\\ ( # class torch.nn.Linear(in_features, out_features, bias=True) torch.nn.Linear(64*4*4, 32), torch.nn.ReLU(), # torch.nn.Dropout() ) self.fc2 = torch.nn.Linear(32, 10) # 前向传播 def forward(self, x): x = self.conv1(x) x = self.conv2(x) x = self.conv3(x) x = x.view(-1, 64*4*4) # 和全连接层相连先扁平化 x = self.fc1(x) x = self.fc2(x) return xnet = Net()net.cuda()# 损失函数：使用交叉熵criterion = torch.nn.CrossEntropyLoss() # 权重更新规则：使用Adam下降（optim.SGD,随机梯度下降）optimizer = torch.optim.Adam(net.parameters(), lr=LR) 3 训练函数 &amp; 测试函数 1234567891011121314151617181920212223242526272829# 5.训练函数def train(model, criterion, optimizer, trainloader, epochs=5, interval=50): print(&#x27;----- Train Start -----&#x27;) for epoch in range(epochs): running_loss = 0.0 # 遍历数据迭代器：获取数据信息 for step, (x,y) in enumerate(trainloader): # 获取输入 # [易错] 使用GPU训练，数据也需要设置cuda inputs, labels = x.cuda(),y.cuda() # 下面其实就是梯度下降过程，参考：https://www.zhihu.com/question/305638940 # 权重清零 optimizer.zero_grad() # 一次bacth计算出的梯度g(loss对weigth导数）用于 # 更新权重 w = w - α*g 后，下次g要清零重新计算 # 计算loss反向传播 output = model(inputs) # 期望输出值 loss = criterion(output, labels) # 该次代价 loss.backward() # 反向传播 optimizer.step() # 更新权重 # 输出每log_interval=50次批次平均loss # loss是张量：tensor(2.3109, device=&#x27;cuda:0&#x27;, grad_fn=&lt;NllLossBackward&gt;) running_loss += loss.item() if step % log_interval == (log_interval - 1): print(&#x27;[%d, %5d] loss: %.4f&#x27; %(epoch+1, step+1, running_loss/ interval)) running_loss = 0.0 print(&#x27;----- Train Finished -----&#x27;) 现在我们来开始设置测试函数： 1234567891011121314151617181920212223242526272829303132333435# 6.测试函数def test(model, testloader): print(&#x27;------ Test Start -----&#x27;) correct = 0 total = 0 with torch.no_grad(): for test_x, test_y in testloader: # 批处理数量，batch_size = 512: 一次输入512张图片 # images.shape = torch.Size([512,3,32,32]) lable.shape = torch.Size([512]) images, labels = test_x.cuda(), test_y.cuda() # output.shape = torch.Size([512,10]) output = model(images) # predicted.shape = torch.Size([512]) # torch.max : 返回每行最大值，如果[指定维度] 还会返回对应最大值索引 # output.data : 获取张量数据，返回还是一个张量？ _, predicted = torch.max(output.data, 1) # size() 方法：获取大小，返回一个张量如：torch.Size([3, 4]) # sum() 方法：求张量所有元素和，返回一个张量如：tensor(3.2860) # item() 方法：把[1]个元素大小的张量，转换为 python数值类型 total += labels.size(0) correct += (predicted == labels).sum().item() accuracy = 100 * correct / total print(&#x27;Accuracy of the network is: %.4f %%&#x27; % accuracy) return accuracyif __name__ == &#x27;__main__&#x27;: # train(CNN1.net, CNN1.criterion, CNN1.optimizer, trainloader, epochs=EPOCHS) test(CNN1.net, testloader) 最后测试准确率为：71.3% 左右。 4 规范代码结构 该部分主要参考： PyTorch实战指南 定义文件结构如下： 1234567891011121314151617├── checkpoints/├── data/│ ├── __init__.py│ ├── dataset.py│ └── get_data.sh├── models/│ ├── __init__.py│ ├── AlexNet.py│ ├── BasicModule.py│ └── ResNet34.py└── utils/│ ├── __init__.py│ └── visualize.py├── config.py├── main.py├── requirements.txt├── README.md 二、常用函数 归一：BatchNorm2d 中文文档解释 pytorch 中文文档 ：class torch.nn.BatchNorm2d 知乎问答：BN为什么效果好? ⚠️ 参数 num_features : 实际只传的是通道数！ 实例补充 参考：Pytorch中的Batch Normalization操作 假设存在4 个 batch ，每个特征图大小为：3*2*2 ，即通道数为 3 ，长宽为 2*2 。那么归一化如下： 每个batch ，从相同通道（比如第一个R通道）取出特征图其大小为 2*2 上述一共有 4 个 2*2 的特征图，对这16 个元素进行归一化操作 重复 1 2 两次 （一共3个通道），则对剩余两个通道的16*2 个元素也进行了归一化"},{"title":"前端基础（一）JavaScript基础笔记","date":"2022-01-02T11:54:25.545Z","updated":"2022-01-02T11:41:01.648Z","comments":true,"path":"NO_post/前端基础（一）JavaScript笔记.html","permalink":"https://hwh.zone/NO_post/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"第一章：快速入门 1.1 hello javaScript! 我们编写一个简单 test.js 文件，里面有一行代码输出 “hello javaScript!” ： 1alert(&quot;hello javaScript!&quot;); 然后在准备好的 .html 文件head 标签内引入test.js 文件： 123456789&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;!--这里默认当前路径是index.html所在目录--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;test.js&quot;&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 注意区分引入 .js文件 和 css文件区别： .js文件 用一对 &lt;script&gt;&lt;/script&gt; 标签包围引用 ；.css 文件用 标签指向： 1&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;main.css&quot; &gt; .js文件 用 src 属性指向 ；.css 文件用 href 属性指向。 引入 js / css文件不成功？ 没有保存文件 默认 VSCode 不会自动保存文件，如果不自己 ctrl+s ，打开浏览器 F12 --&gt; Source 发现 mian.css文件为空。 可以设置自动保存文件，或者自己手动保存解决。 错用 href 属性 引用 js文件 见前。 1.2 安装 codeRunner 插件 我们肯定不希望，每次输出一些信息，都要打开浏览器去查看： 1alert(&quot;我想输出一些信息&quot;); 如果可以直接在 VSCoder 中就打印出信息多好啊！但是直接写在js 文件中，只能在浏览器控制台查看。 1console.log(&quot;我想输出一些信息&quot;); 如何直接打印信息？ JavaScript 可以直接打印：数组、对象、字符串、数值类型等 第一种方式只能在浏览器中查看，后来两种可以直接在VS中查看。 在浏览器控制台中 使用VS自带终端 我们可以用vs自带终端，如果已经安装好 node.js 便可以直接在VS中输出： 其实，这就实现相当于在 cmd 中执行这段代码。 利用 CodeRunner 插件 下载好 CodeRunner 插件，也可以直接运行 js 文件： CodeRunner 运行乱码/报错 Node.js 是否安装 CodeRunner 还是通过 Node.js 来运行 js 文件，如果没有安装自然出错。 特别的，安装 Node.js 会自动配置好环境变量，所以基本可以排除环境变量配置错误导致该问题。 终端是否能输出 首先在 cmd 尝试运行 js文件 ，如果能正确输出 ；但是在 VS终端中还是运行报错/乱码。可以排除是Node.js 相关配置问题。 如果cmd 中也无法运行，尝试重新配置 node.js 环境变量或者直接卸载重新安装。 尝试以管理员身份运行VSCoder 我出现的乱码/无法执行问题以管理员身份运行成功解决。 1、2 均无问题， 可以尝试以管理员身份运行 VSCoder 。也可以设置每次打开都是以管理员身份： 右键 VSCoder 图标 —&gt; 属性 --&gt; 兼容性 —&gt; 以管理员身份运行此程序 --&gt; 应用。 1.3 基本语法 1. 变量和注释 javsScript 注释有单行注释 &amp; 多行注释两种方式： 12// alert(&quot;我不想被执行&quot;); /* alert(&quot;我不想被执行&quot;); */ javsScript 是弱类型语言，所有变量都可用 var &lt;变量名&gt; 形式定义。 123456789101112131415// 1.javsScript不区分整数和浮点型，统称Numbervar num = 3.5; var num1 = 3; var num2 = 1.234*e3;// 2.字符串var str = &#x27;我是单引号包围字符串&#x27;; var str1 = &#x27;&#x27;我是双引号包围字符串&#x27;&#x27;;// 3.布尔类型var b = false;// 4.比较运算符var b1 = false == 0; var b2 = false === 0;var b3 = 2 &gt; 4? ; // ...// 5.常量const PI = 3.14; // const&amp;let修饰都是块级作用域（见后） 小心！== 、NaN、浮点数 不推荐==比较运算符 不推荐使用 == 运算符，这是 JavaScript 语言设计缺陷，会出现难以意料的错误，推荐使用 ===来替换。 判断浮点数相等 由于计算机不能精确表示浮点数，所以判断两个浮点数是否相等，比较它们差值是否小于某个足够小值： 1Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true 判断是否NaN 12var num = NaN;alert(num === NaN); // 输出false 为什么输出 false ？这是因为 NaN和所有其它值都判断不相等，包括它自己，唯一判断方法是： 1isNaN(NaN); // true 判断 null ： 变量 === null； 判断 Array：Array.isArray(arr); typeof 可以判断出 Number、Boolean、String、function &amp; undefined 类型，例如： 判断全局变量是否存在：typeof window.myVar === 'undefined' 判断局部变量是否存在：typeof myVar === 'undefined' 。 全局变量 我们知道，常规定义全局变量，把变量不定义在任何嵌套{}中即可。 事实上，变量定义可不用 var 关键字，此时定义的也是全局变量： 12345num = 3.5; str = &#x27;我是字符串&#x27;; b = false;console.log(&#x27;num = &#x27;+num + &#x27; , str = &#x27;+ str + &#x27;, b = &#x27;+b); 如何理解此时定义的是全局变量？请看下例： 123456789function f()&#123; // 不用var关键字声明函数内部变量 a = 1 ; for(i = 1 ; i &lt; 3 ; i++);&#125;f();console.log(a); // 可访问，输出：1console.log(i); // 可访问，输出：3 a、i 看似是函数内部局部变量，实际已是全局变量，可以访问。 类型转换 由于 JavaScript 没有那么复杂类型，比如数值类型之间转换（int --&gt; double …）。 常用的有如 Number 、 String 、Boolean、object类型之间转换 ： 123456789101112131415161718192021222324252627282930313233343536// 类型转换// 1.任何类型转换为String类型： String()转换 OR .toStringvar num = 123.45 , b = true ;// toString()console.log(num.toString()); // 输出：123.45console.log(b.toString()); // 输出：true// String()console.log(String(num)); // 输出：123.45console.log(String(b)); // 输出：true// 2.任意类型转换成Number类型：用Number() OR parseInt()、parseFloat()var str = &#x27;123.45&#x27; , b = true ;// Number()console.log(Number(str)); // 输出：123.45console.log(Number(b)); // 输出：1// parseInt()、parseFloat()// 转换不了boolean类型！console.log(parseFloat(str)); // 输出：123.45console.log(parseFloat(b)); // 输出：NaN// 3.任意类型转换为Boolean类型：用Boolean()// 注意：只有 0、&#x27;&#x27;转换为：false ；其余全部转换为ture// 以下都转换为tureconsole.log(Boolean(&#x27;false&#x27;)); // 也是ture！只有数字0、&#x27;&#x27;会转换为false！！console.log(Boolean(&#x27;123.45&#x27;)); console.log(Boolean(123.45)); // 以下都转换为falseconsole.log(Boolean(&#x27;&#x27;)); console.log(Boolean(0)); 特别的，具体的值也可以调用 .toString() 方法，转换为 Sting 类型。 123 // 注意1.toString()出错，两个.. OR (1).toString()1..toString(); // 1false.toString(); // false 2. 字符串 如何优雅表示字符串 除了前面介绍用 ’ ‘ 或者 “ ” 包围，还可以用最新ES6标准，反引号 `` 包围多行字符串。 ⚠️ 反引号是左上角 ESC 正下方对应键 ~ ，切换到英文状态下可以打出**`** 1234alert(`我是多行字符串酷不酷`) 1alert(`我是\\n多行字符串\\n酷不酷`) // 和上面写法等价 字符串拼接 除了常见用 + 号进行拼接，还可以用ES6新增的模板字符串进行拼接。 ⚠️ 模板字符一定要使用反引号 ` ，否则${…}当字符串输出了。 12345var name = &#x27;hwh&#x27;;var age = 20;// var message = &#x27;我是&#x27;+ name + &#x27;,今年&#x27;+ age+&#x27;岁啦！&#x27;;var message = `我是$&#123;name&#125;,今年$&#123;age&#125;岁啦！`; // 一定要使用反引号 `,否则$&#123;..&#125;当字符串输出alert(message); 常用字符串操作 获取字符串指定位置字符 直接把字符串当做数组进行索引即可： 12var s = &#x27;hello world&#x27;;alert(s[0]); // 输出：h 但是字符串是不可变的，不能对其某个字符索引赋值，不会有任何效果（但不报错）： 12s[0] = &#x27;l&#x27;;alert(s); // 还是输出：hello world 常用字符串方法 12345678910111213// 1.转换字符串大小写var s = &#x27;Hello&#x27;;var upper = s.toUpperCase(); // 返回&#x27;HELLO&#x27;var lower = s.toLowerCase(); // 返回&#x27;hello&#x27;并赋值给变量lower// 2.返回字符在字符串中位置var str = &quot;hello javaScript!&quot;;alert(str.indexOf(&#x27;java&#x27;)); // 输出6：j是第6个字符，从0计数。前面有6字符： hello + 空格 // 3.字符串截取var s = &#x27;hello, world&#x27;s.substring(0, 5); // 从索引0开始到5（不包括5），返回&#x27;hello&#x27;s.substring(7); // 从索引7开始到结束，返回&#x27;world&#x27; 3. 数组 定义一个简单数组，通常有 直接定义 &amp; new 两种方式： 12345var s = []; // var s = new Array();var s1 = [1,2];// var s1 = new Array(1,2); 奇妙数组 JavaScript 和其它语言数组有很多不同，这里一一说道。 数组不限制类型 下面是一个长度 = 6，包含多种类型的数组。 1var arr = [1, 2, 3.14, &#x27;Hello&#x27;, null, true]; 改变数组大小很简单 以往语言要扩展数组总是一件复杂的事，比如 java 用集合 ArrayList 来实现。 JavaScript 直接改变数组 length 属性即可： 12345var arr = [1, 2, 3];// 扩大数组arr.length = 6; // arr数组变为：[1, 2, 3, undefined, undefined, undefined]// 缩小数组arr.length = 1; // arr数组变为：[1] 可以越界赋值 很多编程语言是不允许越界赋值数组，但JavaScript 允许，它会自动扩大数组。 12var arr = [1, 2, 3];arr[6] = 6; // arr数组变为：[1, 2, 3, undefined, undefined, 6] 但是，这种做法不被推荐，尽量保证索引不会越界！ 常用数组操作 以下是常用数组操作的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var arr = [1,2,3,4,5,6];// 1.数组转为字符串var str = String(arr);console.log(str); // 输出：1,2,3,4,5,6// 2.indexOf：返回指定元素位置var i = arr.indexOf(1);console.log(i); // 输出：0// 3.slice：左开右闭截取元素, 对应String的substring()方法// 不指定第二个参数，会截取第一个参数位置以后所有元素var sub03 = arr.slice(0,3) var sub3 = arr.slice(0) console.log(sub03); // 输出：[ 1, 2, 3 ]console.log(sub3); // 输出：[ 1, 2, 3, 4, 5, 6 ]// 4.push 和 pop 尾部增减元素arr.push(&quot;hello&quot;,&quot;js&quot;);console.log(arr); // 输出：[ 1, 2, 3, 4, 5, 6, &#x27;hello&#x27;, &#x27;js&#x27; ]arr.pop() ; arr.pop();console.log(arr); // 输出：[ 1, 2, 3, 4, 5, 6 ]// 5.unshift 和 shift 头部增减元素arr.unshift(&quot;A&quot;,&quot;B&quot;);console.log(arr); // 输出：[ &#x27;A&#x27;, &#x27;B&#x27;, 1, 2, 3, 4, 5, 6 ]arr.shift(); arr.shift();console.log(arr); // 输出：[ 1, 2, 3, 4, 5, 6 ]// 6.反转和排序arr.reverse(); console.log(arr); // 输出：[ 6, 5, 4, 3, 2, 1 ]arr.sort(); console.log(arr); // 输出：[ 1, 2, 3, 4, 5, 6 ]// 7.splice：从指定位置删除若干元素，再从该位置添加若干元素var arr = [&quot;c#&quot;,&quot;c&quot;,&quot;c++&quot;,&quot;python&quot;,&quot;java&quot;,&quot;javascript&quot;];// 删除&amp;添加：从索引1开始删除2个元素，然后再从原索引位置添加两个元素var delElem = arr.splice(1,2,&quot;1&quot;,&quot;2&quot;); // 返回被删除的元素:[&quot;c&quot;,&quot;c++&quot;]console.log(arr); // 输出：[ &#x27;c#&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;python&#x27;, &#x27;java&#x27;, &#x27;javascript&#x27; ]// 只删除：不设定2个参数以上就行var delElem1 = arr.splice(1,2);console.log(arr); // 输出：[ &#x27;c#&#x27;, &#x27;python&#x27;, &#x27;java&#x27;, &#x27;javascript&#x27; ]// 只添加：设置第二个参数为0，即删除0个元素var delElem2 = arr.splice(1,0,&quot;c&quot;,&quot;c++&quot;);console.log(arr); // 输出：[ &#x27;c#&#x27;, &#x27;c&#x27;, &#x27;c++&#x27;, &#x27;python&#x27;, &#x27;java&#x27;, &#x27;javascript&#x27; ]// 8.concat：连接两个数组,但不改变原数组，只是返回一个新数组var arr1 = [1,2,3,4,5];var arr2 = arr1.concat(&quot;hwh&quot;,[&quot;上&quot;,&quot;山&quot;,&quot;打&quot;,&quot;老&quot;,&quot;虎&quot;]);console.log(arr2); // 输出：[ 1, 2, 3, 4, 5, &#x27;hwh&#x27;, &#x27;上&#x27;, &#x27;山&#x27;, &#x27;打&#x27;, &#x27;老&#x27;, &#x27;虎&#x27; ]// 9.join：将数组转为字符串，可指定连接字符var arr3 = arr1.join(&#x27;~&#x27;);console.log(arr3); // 输出：1~2~3~4~5 多维数组 多维数组：如果某个元素是多维数组，那么就可以形成多维数组。 123// 多维数组var darr = [[1, 2, 3], [400, 500, 600], &#x27;-&#x27;];console.log(darr[1][1]); // 输出：500 4. 对象 注意：在 JavaScript 中没有类这个概率，通过原型链来实现类作为模板概念，在后详述。下面都是具体对象！ 例如下面创建一个hwh对象，类似于 python 使用键值对定义 map 。 当然，还可以给对象增添方法（注意，此时不叫函数！），详见 第二章：函数 2.3节 123456var hwh = &#123; name:&quot;huangwanghui&quot;, school:&quot;chongqingU&quot;, &#x27;stu-num&#x27;: 123456 // 注意：最后一行代码不要加逗号，否则在低版本IE可能会报错&#125; 访问对象属性 访问对象属性有两种办法： 通过&lt;对象名.属性名&gt; 形式 12console.log(hwh.name); // 输出：huangwanghuiconsole.log(hwh.school); // 输出：chongqingU 特别的，访问不存在属性不会报错，但是会返回 undefined ： 1console.log(hwh.school); // 输出：undefined 通过&lt;对象名['属性名']&gt; 形式 理论上，所有访问对象属性都可通过该方式，特别以下两种情况只能使用&lt;对象名['属性名']&gt;这种方式。 属性名不是标准变量名 如 ‘stu-num’ 含变量定义非法字符 - ，所以要用 ’‘ 包围，只能通过 &lt;对象名['属性名']&gt; 访问该属性。 12console.log(hwh.stu-num); // 输出：NaNconsole.log(hwh[&#x27;stu-num&#x27;]); // 输出：123456 循环遍历属性时 在下面遍历对象属性，为什么都是输出 undefined？ 123456// 遍历属性for(var a in hwh)&#123; console.log(a); // 输出：name shcool &#x27;stu-num&#x27; console.log(hwh.a); // 输出：undefined undefined undefined&#125; 因为，此时 hwh.a 相当于访问的是hwh对象一个属性名为a的属性，这自然是不存在的。 正确做法使用对象名['属性名']便可正常输出： 1234for(var a in hwh)&#123; console.log(hwh[a]); // 输出：huangwanghui chongqingU 123456&#125; 给对象增删属性 给对象增减属性较为简单，增加属性类似于数组增加元素，删除属性要利用 delete 关键字。 123456// 增删属性hwh.age = 23;console.log(hwh.age); // 输出：23delete hwh.age;console.log(hwh.age); // 输出：undefined 判断对象是否拥有某属性 判断对象是否用于某属性也有两种办法。 利用 in 判断一个属性是否存在 12console.log(&#x27;name&#x27; in hwh);console.log(&#x27;age&#x27; in hwh); 但是这种方法有一个问题，in 判断属性不一定属于 hwh，还可能是 hwh 继承得到的。 比如原型链中，hwh 肯定会指向所有属性都指向的 Object， Object 含有一个toString 属性： 1console.log(&#x27;toString&#x27; in hwh); // 输出：true 利用hasOwnProperty()方法 这种方法可以不会判断继承得到的属性属于对象。 1console.log(&#x27;toString&#x27; in hwh); // 输出：false 5. 条件判断 &amp; 循环 条件判断 JavaScript 把null、undefined、0、NaN &amp; 空字符串''视为false，其他值一概视为true，因此下面代码条件判断的结果是true。 12345var s = &#x27;123&#x27;;if (s.length) // 条件计算结果为3&#123; // do something&#125; 循环 在 JavaScript 循环和 java 等高级语言循环没有太大区别。 特别的，在 JavaScript 中数组也被看作是对象，它的索引则被视为一个属性。然而遍历数组时，如果使用 for…in循环时，如给数组增加一个属性，将导致一个难以意料的结果。 这个问题可以用 for…of 循环解决，它还可以专用于遍历集合类型，详见 7. iterable 类型 。 12345678910111213141516171819202122232425262728293031323334var num = [1,2,3,4,5,&quot;上山打老虎&quot;];// 1.普通for循环for(var i = 0 ; i &lt; num.length; i++)&#123; console.log(num[i]); // 输出： 1 2 3 4 5 上山打老虎&#125;// 2.for..in 循环// 除了前面用来遍历对象属性，遍历数组也类似// for..in 循环的到时 String 而不是 Number，for循环呢？// 直接输出i是数组序号：0 1 2 3 4 5 ，可理解为把数组当对象，序号是它“属性名”for(var i in num)&#123; console.log(i); // 输出： 0 1 2 3 4 5 console.log(num[i]);&#125;// 3.while 循环var i = 0;while(i&lt;6)&#123; console.log(num[i]); i++;&#125;// 4.do...while 循环// 注意：do...while 循环至少会执行一次！var j = 0;do&#123; console.log(num[j]); j++;&#125;while(j&lt;6); 6. Map &amp; Set 在前面 JavaScript 中 4.对象 中&#123;&#125; 表达方式可以视作其它语言 Map 或 Dictionary 数据结构键值对表达方式。 BUT，JavaScript 中 对象中键只能是字符串 ，而在本讲 Map &amp; Set 将不局限于这点，还可以是 Number等类型。 MAP MAP 基本创建、增 == 改、删操作，和： 123456789101112131415161718// map// 1.创建：注意是([[..],[..],[..]])形式外侧还有一个[]var m = new Map([[1,&quot;hwh&quot;],[2,&#x27;liuting&#x27;],[3,&#x27;xiaoming&#x27;]]); // 2.增加(修改)键值对m.set(4,&#x27;xiaobai&#x27;); // 不存在该键4，则是创建新键值对m.set(4,&#x27;xiaohei&#x27;); // 存在键值4，那么是修改键4对应键值对// 3.删除键值对m.delete(4);// 4.判断是否存在键值var b = m.has(4);console.log(b); // 由于被删除所以是：false// 5.获取键值对var a = m.get(2);console.log(a); // 输出：liuting 注意，当map 键是String 类型一定要加引号（对象如果变量名符合规范可以不加），而且访问也要加引号： 123var m = new Map([[&#x27;a&#x27;,1],[&quot;b&quot;,2]]); // m.get(a); // 出错m.get(&#x27;a&#x27;); MAP 和对象有什么区别？ MAP 和对象都是利用 键值对 形式构造，但是也有以下区别： 删除、添加元素方式不同 访问形式不同：MAP通过get() 方法，对象通过 对象.属性名 或者 对象[属性名]形式 访问速度不同：MAP 拥有极快的访问速度 支持key类型不同：MAP支持多种类型作为key，对象只支持字符串String 类型 Set Set和Map类似，也是一组key的集合，但不存储value。 由于key不能重复，所以，在Set中，没有重复的key。如，创建时出现重复key，只会保留一个。 1234567891011// Set// 1.创建：出现重复键值被过滤var s = new Set([1,2,2,3]); // 实际集合中数据：&#123;1, 2, 3&#125;// 类似的：map也只会保存最后插入的重复键值var m = new Map([[&#x27;a&#x27;,1],[&#x27;a&#x27;,2],[&quot;b&quot;,2]]); // 实际集合中数据：&#123;[&#x27;a&#x27;,2],[&quot;b&quot;,2]&#125;// 2.增加s.add(4);// 3.删除s.delete(4); Set 和数组 Array 区别？ 删除、添加元素方法不同 Set 可以去重，而且可以 快速查找 ，但无法实现按下标查找等操作 7. 如何优雅遍历集合 for … in 遍历集合 遍历数组 Array 可以用下标循环，如何遍历集合类型如 Map &amp; Set 类型？能用 for … in 循环吗？ 我们尝试用 for…in 循环遍历集合： 12345678var m = new Map([[1,&quot;hwh&quot;],[2,&#x27;liuting&#x27;],[3,&#x27;xiaoming&#x27;]]); var s = new Set([1,2,3]); // for...in 遍历集合for(var i in s)&#123; console.log(i); // 什么都没输出&#125; 很不幸，什么都没输出。 事实上，Array、Map &amp; Set 都属于iterable 类型。对于 iterable 类型可以用 for…of 循环输出： 123456789// for...of 遍历集合for(var i of m)&#123; console.log(i); // 输出：[ 1, &#x27;hwh&#x27; ] [ 2, &#x27;liuting&#x27; ] [ 3, &#x27;xiaoming&#x27; ]&#125;for(var i of s)&#123; console.log(i); // 输出：1 2 3&#125; forEach() 遍历集合 遍历集合更加优雅安全的方式是通过 iterable内置的forEach() 方法，它接受一个函数，每次迭代自动回调该函数。 forEach() 是一个高级方法，接收一个函数，用来遍历数组。详见 2.4 高阶函数 – forEach() 1234567891011121314151617181920212223242526272829303132// forEach() 遍历集合var m = new Map([[1,&quot;hwh&quot;],[2,&#x27;liuting&#x27;],[3,&#x27;xiaoming&#x27;]]); var s = new Set([1,2,3]); var arr = [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;];// 遍历Mapm.forEach( function(value) &#123; console.log(value); // 输出：hwh liuting xiaoming &#125;); // 遍历Sets.forEach( function(element) &#123; console.log(element); // 输出：1 2 3 &#125;);// 遍历Arrayarr.forEach( function(element) &#123; console.log(element); // 输出：A B C &#125;);// 遍历对象：注意不能遍历对象！！ for … in 循环的弊端：数组长度不一致 我们已经知道 ，Array 都属于iterable 类型 ，但我们用 for … in 可以遍历输出Array 。 但是，我们在前也知道，数组也是对象，它的下标就是属性名。如果我们给一个数组增加属性名，然后遍历： 12345678var arr = [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;];// 类似对象一般，给数组增加属性arr.name = &#x27;alpha&#x27;;for(var i in arr)&#123; console.log(i); // 输出属性名：0 1 2 name&#125; 依次输出的是数组的属性名，好吧，这没什么不正常。 但是我们再尝试打印此时的数组大小： 1console.log(arr.length); // 输出：3 噢…不忍直视，数组长度竟然是3，而不是4！ 为什么说for… of 循环可以避免这个问题呢？ 因为for… of 循环只会遍历，集合内的元素，这种不正当通过 数组名.属性 赋值方式不会被输出： 12345for(var i of arr)&#123; console.log(i); // 输出元素而非属性名：A B C &#125;console.log(arr.length); // 输出：3 这样循环遍历数组元素个数 === 数组长度，保证了一致性。 而且，你应该还注意到一个细节，此时输出的是元素，而非是属性名。 第二章 ：函数 2.1 函数基本入门 函数定义 在 JavaScript 中，定义函数有两种方式：一种类似于其它高级语言，但没有返回值类型；一种匿名函数方式。 123456789101112// 函数定义// 1.第一种类似其它高级语言定义函数，但没有返回值类型，js也不需要定义类型function max(a,b)&#123; return a &gt; b ? a : b;&#125;// 2.第二种匿名函数，其实函数也是对象，把函数名max1视作指向该函数的变量var max1 = function(a,b)&#123; return a &gt; b ? a : b;&#125; 在 JavaScript 中，这两种方式是完全等价的，自然调用方式也是一致的： 123// 调用函数console.log(max(1,2)); // 输出：2console.log(max1(1,2)); // 输出：2 ⚠️ 不加()，直接调用函数不会报错，只会输出函数名： 1console.log(max); // [Function: max] 但是可以把函数作为变量传递给另外一个变量： 12var my_max = max;my_max(1,2); // 2 小心你的 return 语句 JavaScript 引擎 会在行末自动添加分号，这可能会导致使用 return 产生意料之外的错误： 1234567function max(a,b)&#123; return a &gt; b ? a : b;&#125;// 调用maxmax(1,2); // 输出：什么都没有输出 你会惊喜的发现，什么都没有输出！这是因为，由于自动添加分号，函数实际已经变成： 12345function max(a,b)&#123; return ; // 这里被添加了分号，函数执行到这结束了 a &gt; b ? a : b;&#125; 所以，细心的你一定会避过这个坑吧？ 奇妙的函数参数 传递参数个数任意？ 如果是第一次接触 JavaScript ，在上面定义max 函数我们可以惊讶的发现，可以传递不止两个参数！ 12// 多个参数调用console.log(max(1,2,&#x27;A&#x27;,&#x27;B&#x27;)); // 输出：2 而且它还计算出了正确结果！ 事实上，JavaScript 允许传递任意个参数，如果函数内部不使用多余的参数自然也就不会影响到结果。 那么传递参数比实际定义少呢？ 1console.log(max(1)); // 输出：undefined 怎么处理所有参数？ 在上面虽然我们调用 max() 函数输入了多余参数，但是我还是想把多余参数给输出来，该如何处理？ 在函数内部利用 arguments ，可以获取所有参数。 12345678910111213// argumentsfunction max(a,b)&#123; if(arguments.length &gt; 2) // 输出超过定义个数的参数 &#123; for(var i = 2 ; i &lt; arguments.length ; i++ ) console.log(arguments[i]); &#125; return a &gt; b ? a : b;&#125;// 调用maxmax(1,2,&quot;hhh不许笑！&quot;); // 输出：hhh不许笑！ 一般常用的也就是：arguments.length &amp; arguments[i] 用来获取参数长度和指定索引参数。 优雅的处理多余参数 上面虽然用arguments 获取到所有参数，然后输出多余参数，但是总感觉很变扭。 但是有没有一种方式，让我们直接处理多余参数 ，而不是要从索引 2 先排除前两个参数？ 可以使用 rest 来达到这个目的，多余参数会以数组形式 交给 rest 变量： 12345678910// rest// 函数定义的时候要以：...rest来标识[从哪里开始算是多余参数]function max(a,b,...rest)&#123; console.log(rest); // 会以[数组]形式输出 return a &gt; b ? a : b;&#125;// 调用maxmax(1,2,&quot;hhh不许笑！&quot;); // 输出：[ &#x27;hhh不许笑！&#x27; ] 2.2 变量作用域与解构赋值 1. 快速了解变量作用域 变量作用域块{}知识基本和其它语言没有太大区别，但是有几个 JavaScript 所特有特性。 变量提升 执行下面函数会报错吗？如果不会，那么输出什么？ 123456789&#x27;use strict&#x27;;function f()&#123; var x = 1; console.log( x + y); var y = 2;&#125;f(); 执行这段代码，我们发现：编译器没有报错，但是输出 NaN 。 这是因为javascript 有一个很奇怪的特性：它会自动提升 变量的声明 到函数顶端，但是又不会提升 变量的赋值。 在编译器眼里，它看到的代码是这样的： 12345678910&#x27;use strict&#x27;;function f()&#123; var x = 1; var y ; // 提升了定义 console.log( x + y); // 执行后也并没有报错 y = 2; // 没有提升赋值&#125;f(); 所以虽然可以使用变量 y 但是又不能使用它的值，所以输出：NaN 。 避免错误 😋 对于这种怪异特性，我们最好提前用 var 声明所有要使用的变量。 1234567function f()&#123; var x = 1, y = 2, z; // do something &#125; 😋 用 let 关键字来限定变量范围，申明一个块级作用域。 由于这种变量提升特性，导致变量实际作用域是函数内部，会使得for 等循环语块无法定义具有局部作用域变量： 1234567891011function f()&#123; console.log(i); // 不报错可以使用i，但是输出：undefined for(var i = 0 ; i &lt; 3 ; i++) &#123; // do something &#125; console.log(i); // 可以使用i值，输出：3&#125;f(); 我们可以通过 let 关键字来达到，限定 i 为局部变量： 1234567891011function f()&#123; console.log(i); // 会报错，不能使用局部变量i for(let i = 0 ; i &lt; 3 ; i++) &#123; // do something &#125; console.log(i); // 会报错，不能使用局部变量i&#125;f(); 2. 全局作用域 不在任何函数内定义的变量就具有全局作用域。 特别的，顶层函数也是全局变量。虽然乍看有点难以理解，但是回想它的匿名函数写法，便一目了然。 1234567891011121314&#x27;use strict&#x27;;// 全局作用域var author = &#x27;hwh&#x27;;var f2 = function()&#123; return &#x27;顶层函数也是全局变量&#x27;;&#125;// 全局变量任意嵌套块中都可以调用&#123; console.log(author); console.log(f2());&#125; window 对象 window 是javascript 默认全局对象 ，所有全局变量 都被绑定到 window 上作为一个属性。 1234567// window// 调用window对象：console.log 会报错，用alert打开网页可正常输出？&#123;// console.log(window.author); // 出错 alert(window.author); // 打开网页输出：hwh alert(window.f2()); // 打开网页输出：顶层函数也是全局变量&#125; 可以看到，全局变量可以作为它的属性一样被调用。事实上 alert() 也是一个全局变量。 下面尝试给 函数变量 alert 赋值一个新的函数，使得它不能执行 alert() 原本输出功能。 123456789101112&#x27;use strict&#x27;;window.alert(&#x27;调用window.alert()&#x27;);// 定义一个变量保存函数（函数也是变量）var old_alert = window.alert;// 给alert赋一个新函数:window.alert = function () &#123;&#125;// 尝试调用alert()alert(&#x27;我还能输出吗？&#x27;); // 打开网页发现这句话不会被输出 更好的定义全局变量 全局变量会绑定到对象window上，不同的 JavaScript 文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。 减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如： 1234567891011// 唯一的全局变量NOTE:var NOTE = &#123;&#125;; // 对象？// 其他变量:NOTE.author = &#x27;hwh&#x27;;NOTE.version = 1.0;// 其他函数:NOTE.f = function () &#123; return 1;&#125;; 3. 解析构值 什么是解析构值？简单来说，可以 同时对一组变量进行赋值。 1234// 解析构值// 注意：解析构值涉及多个变量赋值，两边都要用[]包围var x,y,z,rest;[x,y,z] = [1,2,3]; 还可以像前一样，用... 标识rest ，以数组形式接收指定位置之后所有赋值。 123// 1.解析赋值：...rest[x,y,z,...rest] = [1,2,3,4,5];console.log(rest); // 输出：[ 4, 5] 解构数组 除了上述基本特点，解构数组还有以下特点： 12// 解析数组 var x,y,z,rest; 允许待赋值变量个数 ≠ 右侧变量数 12345678// 1. 允许待赋值变量个数 ≠ 右侧变量数// 待赋值变量 &gt; 右侧，剩余未赋值变量赋undefined [x,y,z] = [1,2]; // 等价于：[x,y,z] = [1,2,undefined];console.log(&#x27;x=&#x27;+x+&#x27;,y=&#x27;+y+&#x27;,z =&#x27;+z); // 输出 ：x=1,y=2,z=undefined// 待赋值变量 &lt; 右侧，只会对应依次将待赋值变量赋值完毕[x,y,z] = [1,2,3,4,5]; // 等价于：[x,y,z] = [1,2,3]; console.log(&#x27;x=&#x27;+x+&#x27;,y=&#x27;+y+&#x27;,z =&#x27;+z); // 输出：x = 1,y = 2,z = 3 设置默认值 123// 2.可以设置默认值[x,y,z = 666] = [1,2];console.log(&#x27;x=&#x27;+x+&#x27;,y=&#x27;+y+&#x27;,z =&#x27;+z); // 输出：x=1,y=2,z=666 忽略某些值 1234// 3.忽略值var a,b;[a, ,b ] = [1,2,3];console.log(&#x27;a = &#x27;+ a + &#x27;,b = &#x27;+ b); // 输出：a = 1,b = 3 解构对象 前面都是解构数组，对象由一对对键值组成，和解构数组自然有些不同。 123// 对象解构赋值var o = &#123;x:&#x27;one&#x27; , y:&#x27;two&#x27;,z:&#x27;three&#x27;,a:&#x27;four&#x27;,b:&#x27;five&#x27;&#125;;var &#123;x,y,z,a,b&#125; = o; 特别的，如果不是对一个已存在对象解构，而是进行无声明赋值，赋值语句有所不同： 12345// 这种无声明赋值，要求赋值语句周围有 (...)var x,y,z;( &#123;x,y,...rest&#125; = &#123;x:&#x27;one&#x27; , y:&#x27;two&#x27;,3:&#x27;three&#x27;,4:&#x27;four&#x27;,5:&#x27;five&#x27;&#125; );console.log(x); // 输出：oneconsole.log(rest); // 输出：&#123; &#x27;3&#x27;: &#x27;three&#x27;, &#x27;4&#x27;: &#x27;four&#x27;, &#x27;5&#x27;: &#x27;five&#x27; &#125; 对象解构还有以下一些基本特点： 1var o = &#123;x:&#x27;one&#x27; , y:&#x27;two&#x27;,z:&#x27;three&#x27;,a:&#x27;four&#x27;,b:&#x27;five&#x27;&#125;; 允许待赋值变量个数 ≠ 右侧变量数 123// 1.待赋值变量 &lt; 右侧，按对应键值赋值完毕,[顺序不影响]var &#123;x,b,a&#125; = o;console.log(&#x27;x=&#x27;+x+&#x27;,y=&#x27;+y+&#x27;,z =&#x27;+z); // 输出：x=one ,a=four ,b=five 左右两侧键值要对应 123// 2.左右两侧键值要对应var &#123;x,Y,z,a,b&#125; = o; // 左侧Y和右侧键值y，不对应console.log(Y); // 无法解构成功，输出：undefined 给新变量提供默认值和参数 12345// 3.给新变量提供默认值和参数var &#123;x:xx = 10, y:yy = 5&#125; = &#123;x: 3&#125;;console.log(xx); // 3console.log(yy); // 5 解构嵌套对象和数组 解构嵌套对象和数组，具有的基本特点和上面是一致的。主要不同在于： 解构嵌套对象要保证层次一致；解构嵌套数组，不仅要保证层次一致还要保证位置一致。 嵌套数组 数组本身有嵌套，解构赋值要保证嵌套位置和层次一致。 123// 1.数组嵌套let [x,[y,z]] = [1,[2,3]];let [[y,z],x] = [1,[2,3]]; // 出错位置不一致 嵌套对象 对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，保证层次一致。 123456789101112131415var person = &#123; name: &#x27;hwh&#x27;, age: 23, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, address: &#123; city: &#x27;FUZHOU&#x27;, street: &#x27;No.1 Road&#x27;, zipcode: &#x27;341000&#x27; &#125;&#125;;// 只需保证层次一致：赋值时按键值赋值，顺序位置可以调换var &#123;name, address: &#123;city, zipcode&#125;&#125; = person; 注意，address 并不是变量名，尝试输出会报错。它只是为了city、zipcode获取对象属性： 123456// 测试输出 console.log(address); // 报错，address不是变量 console.log(person.address); // 输出： &#123; city: &#x27;FUZHOU&#x27;, street: &#x27;No.1 Road&#x27;, zipcode: &#x27;341000&#x27; &#125;// 输出：name:hwh,city:FUZHOU ,zipcode:341000console.log(&#x27;name:&#x27;+name+&#x27;,city:&#x27;+ city,&#x27;,zipcode:&#x27;+ zipcode); 使用场景 交换两个变量 123// 1.交换变量x yvar x=1, y=2;[x, y] = [y, x] 快速获取页面域名 &amp; 路径 12// 2.快速获取页面域名和路径var &#123;hostname:domain, pathname:path&#125; = location; 减化函数参数定义 如下面可以方便快速创建一个对象。 1234function myDate(&#123;year, mon, day, hour=0, min=0, sec=0&#125;) &#123; return new Date(year + &#x27;-&#x27; + month + &#x27;-&#x27; + day + &#x27; &#x27; + hour + &#x27;:&#x27; + minute + &#x27;:&#x27; + second);&#125; 如上面函数接收一个对象作为参数，而不是去定义6个参数： 1function myDate(year,mon,day,hour=0,min=0,sec=0) 在调用函数的时候，根据解析构值，形参对象给实参对象赋值 ： 1myDate(&#123;2019,07,19&#125;); 2.3 方法与this大坑 在一个对象中绑定函数，称为这个对象的方法。 123456789101112131415//方法var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:function() &#123; var nowYear = new Date().getFullYear(); return nowYear - this.birth; // 调用对象里属性，不用this会报错 &#125;&#125;console.log(hwh.age()); // 输出：23console.log(hwh.age); // 输出：[Function: age] 我们知道，this 关键字是用来指向当前对象。在JavaScript 没有类这个概念，this 在上述代码指向的是 hwh 这个对象。this.birth 因此可以拿到 hwh 的 birth 属性。 在这里，我们也看到 JavaScript 中 this 关键字和常用高级语言第一个不同点： 即使是在对象内部，调用对象属性也要 this.属性名 进行调用，否则会出错。 但是，由于js本身设计缺陷，this 在函数内部不一定指向当前对象，也可能指向全局对象 window 。 1. 小心使用你的 this 新变量指向方法 如果你尝试用一个新变量 my_age 指向函数内部方法 age() : 123456789101112131415var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:function() &#123; var nowYear = new Date().getFullYear(); return nowYear - this.birth; // 调用对象里属性，不用this会报错 &#125;&#125;// 新变量指向对象方法var my_age = hwh.age;console.log(my_age()); // 输出： NaN why？？为什么突然报错？ 这是因为，以 对象名.方法名() 调用 this 指向当前对象 ；但是 单独调用函数 ，this 指向全局对象 window ！ 多层函数内部用 this 喜欢重构的你，又闲得蛋疼，突发奇想，在age方法内部再定义一个函数来返回值： 1234567891011121314151617var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:function() &#123; function getAge() &#123; var nowYear = new Date().getFullYear(); return nowYear - this.birth; // 调用对象里属性，不用this会报错 &#125; return getAge(); &#125;&#125;console.log(hwh.age()); // 输出：NaN 又出错了！虽然 this 关键字在 对象age方法内部 指向当前对象，但在 age方法内函数内 指向全局对象 window ！ 聪明的你也许会想，既然在 age方法内部还是指向当前对象，那我可以捕获此时this ，再在方法内部函数使用： 12345678910111213141516171819var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:function() &#123; // 捕获this var that = this; function getAge() &#123; var nowYear = new Date().getFullYear(); return nowYear - this.birth; // 调用对象里属性，不用this会报错 &#125; return getAge(); &#125;&#125;console.log(hwh.age()); // 输出：23 更优雅解决this 错误指向：改写为箭头函数，详见：2.6 箭头函数 。 提醒不要犯错：strict 模式 上述两种情况，还可以在 strict 模式下让函数的this 指向 undefined ，而不是window ，这样编译器会抛出错误。 12345&#x27;use strict&#x27;;// 上面函数写法...console.log(hwh1.age()); //抛出错误： Cannot read property &#x27;birth&#x27; of undefined 2. apply 方法 在前面，我们可以用 strict 模式，使得this 指向 undefined 让编译器提醒我们不要让 this 错误指向。 但是，可以控制 this 正确指向我们所期望的吗？ 每个函数本身拥有的apply() 方法，可以做到这点。 123456789101112131415161718192021&#x27;use strict&#x27;;function getAge()&#123; var nowYear = new Date().getFullYear(); return nowYear - this.birth; &#125;var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:getAge&#125;// 让getAge() 中this从指向 undefined (严格模式下不是window） --&gt; hwh// 参数1：表示方法要指向的对象// 参数2：表示方法需要的参数，用数组封装好。这里[]表示为空getAge.apply(hwh,[]); console.log(hwh.age()); // 输出23 call 方法 call 方法和 apply 方法很类似，能达到相同效果，它们唯一区别是传递参数不同。 比如，调用 Math.max(3, 5, 4)，分别用 apply() 和 call() 实现如下： 12Math.max.apply(null, [3, 5, 4]); // 5Math.max.call(null, 3, 5, 4); // 5 可以看到，apply() 需要把参数封装好 Araay 数组再传入 ； call() 则需逐个传入参数。 新的问题 在 新变量指向方法 小节中，我们尝试用 apply 来改变新变量函数指向： 1234567891011121314151617var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:function() &#123; var nowYear = new Date().getFullYear(); return nowYear - this.birth; // 调用对象里属性，不用this会报错 &#125;&#125;// 新变量指向对象方法var my_age = hwh.age;my_age.apply(hwh,[]); // 改变this指向不成功？console.log(my_age()); // 输出： NaN 却发现，my_age 方法指向并没有被改变，还是输出 NaN ? 之所以不尝试，多层函数内部用 this 一节用apply 改变，是因为无法取里层函数名。而直接尝试在里层函数里使用函数名，那就变成递归了！ 1234567891011121314151617var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:function() &#123; function getAge() &#123; // 只能在这里可以取到getAge函数名，可是变成了递归 // getAge.apply(hwh,[]); // 报错：无限递归 var nowYear = new Date().getFullYear(); return nowYear - this.birth; // 调用对象里属性，不用this会报错 &#125; return getAge(); &#125;&#125; 装饰器 利用 apply()，我们还可以动态改变函数的行为。 JavaScript 的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。（ 覆写？？） 增加统计调用多少次方法 parseInt() ，在不改变原有功能基础上。 12345678910111213141516// 装饰器 // 下面代码在 VSCode + codeRunner报错：window is not defined// 在浏览器中控制台可正常输出var count = 0;var oldParseInt = parseInt;window.parseInt = function()&#123; count++; return oldParseInt.apply(null,arguments);&#125;parseInt(&#x27;10&#x27;); parseInt(&#x27;10&#x27;); parseInt(&#x27;10&#x27;);console.log(count); // 输出：3 但是下面方法也能调用原函数，无法说明装饰器作用？ 123456window.parseInt = function()&#123; count++; // return oldParseInt(null,arguments); // 报错：parseInt是函数变量，这里返回的是函数值 return oldParseInt; // 成功输出 ：函数之间的赋值&#125; 2.4 高阶函数 在 JavaScript 中 ，变量可以指向函数，函数参数能接收变量，那么自然可以把 函数当做另一个函数参数传递 。 高阶函数，简单来说就是把函数当参数，类似于C/C++中函数指针和C#中委托。 下面是四个基本四则运算函数： 1234567891011// 加function add(a,b)&#123; return a+b;&#125;// 除function div(a,b)&#123; return a/b;&#125;// 乘、减.. 我们可以把它们当做参数，实现一个函数就可以计算四种不同运算： 123456function myfuc(a,b,f)&#123; return f(a,b);&#125;var result = myfuc(1,3,div); // 0.3333333.. 映射：map / reduce map() 这里的map() 和前面集合map 不同，它是一个方法，表现对数组每个元素进行某种映射关系。 假设存在一个数组：arr = [x1,x2,x3…] ，和回调函数 f(x)。 arr.map() 把函数 f(x) 作为参数 ，会返回一个新数组 [f(x1), f(x2), f(x3) …] 12345678910// mapfunction pow(x)&#123; return x*x;&#125;var arr = [1,2,3,4,5];var newArr = arr.map(pow);console.log(newArr); // 输出：[ 1, 4, 9, 16, 25 ] ❔ 数组的元素会自动作为回调函数f(x) 第一个形参的实参进行赋值，如果f(x) 没有参数呢？或者不止一个参数呢？ 123456789function pow()&#123; return 1;&#125;var arr = [1,2,3,4,5];// 如果没有参数，每一次pow函数返回值 1 作为新数组元素var newArr = arr.map(pow);console.log(newArr); // 输出：[ 1, 1, 1, 1, 1 ] 事实上回调函数 f(x) 有三个参数，通常我们只使用第一个参数，表示 Array 某个元素： 123456789101112131415var arr = [1,2,3,4,5];var newArr = arr.map( function(element,index,self) &#123; console.log(element); // 依次打印: 1,2,3,4,5 console.log(index); // 依次打印: 0,1,2,3,4 console.log(self); // self就是变量arr,每次都打印arr:[ 1, 2, 3, 4, 5 ] return element*element; &#125;);console.log(newArr); // 输出：[ 1, 4, 9, 16, 25 ] 试分析：把parseInt函数作为参数，为什么得到意料之外的结果？ 1234var arr = [&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;];var newArr = arr.map(parseInt);console.log(newArr); // 输出：[ 1, NaN, NaN, NaN, NaN ] 🙂 查看MDN文档：MDN-Array.map() reduce() reduce() 和 map() 类似：传入的参数函数f 循环每次对数组前两个元素运算，运算结果r作为数组首元素插入头部。 假设存在一个数组：arr = [x1,x2,x3,x4…] ，和某个函数 f(x,y)。 arr.map() 把函数 f(x,y) 作为参数 ，会返回一个值：f(f(x1,x2),x3) 12345678910// reducefunction sum(x1,x2)&#123; return x1+x2; &#125;var arr = [1, 2, 3, 4, 5];var s = arr2.reduce(sum);console.log(s); // 输出：15 当然无论是 map / reduce 传递参数都可以用 lambada 表达式进行简化： 1234var arr2 = [1, 2, 3, 4, 5];var s = arr2.reduce((x1,x2) =&gt; x1+x2);console.log(s); // 输出：15 自定规则：filter / sort … 下列高级函数都有以下特点： 根据传递的回调函数 自定义某种判断规则 对数组每个元素进行判断，根据返回结果 ture / false 决定对元素进行不同操作 filter() filter也是常用高级函数，它用于把Array 某些元素过滤掉，然后返回剩下的元素。 具体过程：*filter()*把传入的回调函数依次作用于每个元素 ，回调函数返回值为 ture 则该元素保留，否则删除。 1234567891011var arr = [1, 2, 3, 4, 5];var arr1 = arr.filter( function(x) &#123; return x % 2 == 0; // 只返回偶数 &#125;);console.log(arr1); // 输出：[ 2, 4 ] 给定数组Array ，去除里面重复的元素。（没看太明白） 123456789101112131415&#x27;use strict&#x27;;var r, arr = [&#x27;apple&#x27;, &#x27;strawberry&#x27;, &#x27;banana&#x27;, &#x27;pear&#x27;, &#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;orange&#x27;];r = arr.filter( // 数组当前元素、数组当前元素索引、数组本身分别作为回调函数3形参的实参值 function (element, index, self) &#123; return self.indexOf(element) === index; // 这里没太明白 &#125;);console.log(r.toString()); // 输出：apple,strawberry,banana,pear,orange sort() JavaScript 中的 sort() 高级排序函数，无传递回调函数情况下，排序的操作顺序如下： 先将数组的所有元素转换成 String 字符串 sort() 根据每个字符串 首字符 ASCII值 来从小到大排序 所以看起来会有下面&quot;奇怪&quot;结果：10 排在 2 前面 1[10, 20, 1, 2].sort(); // [1, 10, 2, 20] 这是因为数组元素先转换成 String 类型，按 首字符 ASCII值 排序规则： ‘1’ &gt; ‘2’ ==&gt; ‘10’ &gt; ‘2’。 定义自己的排序规则 我们来定义数字从小到大排序规则回调函数，使得能正常输出我们期望的数字排序结果。 排序规则：类比冒泡排序，判断两个元素大小，决定是否交换位置？ 123456789101112var arr = [10, 20, 1, 2];arr1 = arr.sort( function(x,y) &#123; if(x&gt;y) return 1; else return -1; &#125;);console.log(arr1); // 输出：[ 1, 2, 10, 20 ] 对应，冒泡排序写法： 123456789101112131415161718192021function cmp(x,y)&#123; if(x&gt;y) return 1; else return -1;&#125;var s = [10, 20, 1, 2];for(let i = 0; i &lt; arr.length ; i++)&#123; for(j = arr.length -1 ; j -i &gt; 0; j--) &#123; // cmp作为排序规则，决定是否交换两个元素 if(cmp(s[j],s[j-1]) == -1) &#123; temp = s[j]; s[j] = s[j-1]; s[j-1] = temp; &#125; &#125; console.log(s[i]); // 依次输出：1 2 10 20&#125; 如果，要求从小到大输出呢？ 重新定义下 何为大 即可。 123456789101112var arr = [10, 20, 1, 2];arr1 = arr.sort( function(x,y) &#123; if(x&gt;y) return -1; // 改成返回 -1 else return 1; // 改成返回 1 &#125;);console.log(arr1); // 输出：[ 20, 10, 2, 1 ] 同理，对应冒泡排序改换cmp排序规则（交换if / else返回值）。已测试成功输出，这里不再赘述。 every() every() 自定回调函数判断规则，对所有数组元素进行判断，如果回调函数都 返回ture ，说明所有元素都满足判断条件，那么*every()* 返回 ture，否则返回false 。 给定一个包含指定字符串数组，判断字符串是否满足指定测试条件。 123456789var arr = [&#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;];var b = arr.every( function (s) &#123; return s.length &gt; 0; &#125;); console.log(b);// true, 因为每个元素都满足 s.length&gt;0 find() 同上自定 回调函数判断规则，对所有元素进行判断。如果回调函数返回 ture ，则找到第一个元素， find() 返回该元素；如果所有元素都遍历完毕，没有返回 ture ，则说明未找到元素，find() 返回 undefined。 123456789var arr = [&#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;];var tmp = arr.find( function (s) &#123; s.toLowerCase() === s; // 找到第一个全是小写字母的字符串 &#125;); console.log(tmp);// 输出：pear findIndex() 和 find() 类型，不同在于 findIndex() 找到元素返回该索引而非返回元素；如果没找到元素则返回 -1。 特别：forEach() 同前 forEach 循环，它可用来遍历 数组、集合 。只单纯传递数组元素等信息，具体对数组元素等进行什么操作由传递的回调函数决定。 利用forEach() 尝试遍历一个数组。 12var arr = [&#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;];arr.forEach(console.log); 由于回调函数默认有三个参数：element、index、self ，console.log 接收这三个实参依次打印它们信息： 123Apple 0 [ &#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27; ]pear 1 [ &#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27; ]orange 2 [ &#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27; ] forEach() 遍历一个数组，只打印出数组元素。 我们可以重写 console.log 方法，让它只接收一个参数。 123456789var arr = [&#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;];var old_console_log = console.log;console.log = function(element) // 重写&#123; old_console_log(element);&#125;arr.forEach(console.log); // 依次输出：Apple pear orange forEach() 还可以遍历集合，如 Set、Map 等。注：不能遍历对象！遍历对象直接for 循环就行。 12345var arr2 = new Set([1,2,3]); arr2.forEach( console.log // 依次输出：1 2 3); 2.5 闭包 什么是闭包？ 前面我们了解到，函数可以作为 参数，那么函数自然也可作为 返回值。 闭包，简单来说就是携带状态的函数，其返回值是一个也是函数，而且它的状态可以完全对外隐藏起来。 它的作用有： 可创建函数工厂、减少函数参数 实现携带状态的闭包，获取函数内部局部变量且变量一直在内存中 函数工厂 计算指定 x 值的 2次方 / 3次方。 也许聪明的你，很快想到利用系统自带 API 计算x 次方： 1234var x = 5; // x值任意Math.pow(x,2); // 25Math.pow(x,3); // 125 但是，如果计算指定 x 值的 2次方 / 3次方是 常用 的，你觉得没必要每次都指定参数 幂次 ，干脆直接自定义 pow2 / pow3 函数，只接收参数 x ： 123456789101112function pow2(x)&#123; return Math.pow(x,2);&#125;function pow3(x)&#123; return Math.pow(x,3);&#125;pow2(5);pow3(5); 但是，如果计算 x 值的 4次方 / 5次方也 常用 ，定义4个函数显然不太简洁。 这里，可以用闭包创建一个函数工厂，返回同类我们需要的函数： 12345678910111213function creat_pow(n) // 创建pow函数工程，参数为指定幂次&#123; return function(x) // 返回函数，参数为变量x &#123; return Math.pow(x,n); &#125;&#125;var pow2 = creat_pow(2); // 注意这里参数是：幂次，返回计算指定幂次函数var pow3 = creat_pow(3);pow2(5); // 25 注意这里参数是：变量x，即闭包里隐藏的局部变量x，计算它的指定幂次pow3(5); // 125 在这里我们还可以看到，闭包函数pow 隐藏一个状态：变量x ，即pow 内部返回的匿名函数局部变量参数x 。从而把一个多参数函数，变为单参数函数。 又有，利用闭包快速生成不同类似函数，给Web进行事件绑定。 参照：闭包的应用 – 应用于web开发 更深入理解 “闭包” 难道闭包只是为了返回函数进而创建函数工厂 OR 减少函数参数吗？怎么理解闭包是携带状态的函数？请看下例： 我们知道，函数内部的局部变量，在函数退出后便自动消亡： 12345678910111213function creat_counter(initial)&#123; var n = initial; return function() &#123; return n++; &#125;&#125;var c = creat_counter(0); // 返回的是函数，故带上()是为了执行然后返回函数console.log(c()); // 1console.log(c()); // 2console.log(c()); // 3 非常奇怪的是，为什么这里的局部变量 n 实现了递增呢？变量n 不是应该在执行：var c = creat_counter(0); 后就已经消亡了吗？ 其实：在返回的函数中，实现了一个闭包环境，该闭包携带了外部无法访问的局部变量x 。 这是由于 creat_counter 是内部匿名子函数的父函数，而creat_counter 被赋值给全局变量 c，因此其内部变量n 、匿名子函数都在内存中，没有被垃圾回收机制回收。 这样父函数内部，子函数外部的局部变量n，在 JavaScript 类似类的私有变量。我们还可以返回一个对象，看起来更像是 类对象调用方法。 实现类似class机制封装私有变量的一个简单计数器。 1234567891011121314151617function creat_counter(initial)&#123; var n = initial; // 看起来就是一个私有变量，外部无法访问 function increase() &#123; return n++; &#125; // 返回一个对象，里面有inc属性，这样调用起来像是对象调用方法。 // 注意 inc:f2() 错误，带()是执行函数 return &#123;inc:increase&#125;; &#125;var c = creat_counter(0); // 返回的是对象，带上()是为了执行函数后返回对象// 看起来像是对象调用方法c.inc(); // 1c.inc(); // 2c.inc(); // 3 小心！返回函数不立即执行 我们需要注意一个问题，闭包返回的 函数fun 并不会立即执行，而是直到调用 函数fun() 才会执行。 这样，在我们返回函数引用任何后续会发生的变量都会产生意料之外结果，比如循环变量： 12345678910function count() &#123; var arr = []; // 定义一个数组，用于压入三个函数 for (var i=1; i&lt;=3; i++) // 循环压入一个匿名函数计算当前i^2：用箭头函数简写 arr.push( () =&gt; &#123; return i * i &#125;); return arr;&#125;var results = count();var f1 = results[0]; var f2 = results[1]; var f3 = results[2]; 当我们尝试执行 f1()、 f2()、 f3() 会发现一个出人意料的结果： 123f1(); // 16f2(); // 16f3(); // 16 全都是16！这是因为，由于变量提升，循环局部变量 i 已经是函数内部全局变量了。 同时，arr.push() 压入函数时，函数并未立即执行。等到 return arr 时，此时引用的变量i 已经执行完3次循环后变为 4 了。 我们有两种解决办法： 循环内部变量用 let 关键字声明，这样等到 return arr 时，函数引用的变量是对应循环次数局部变量 i 。 12for (let i=1; i&lt;=3; i++) // let arr.push( () =&gt; &#123; return i * i &#125;); 再创建一个函数 立即执行，用该函数的参数绑定循环变量当前的值，参照：廖雪峰教程–闭包 123456789for (var i=1; i&lt;=3; i++) arr.push( ( function (n) &#123; return function () &#123; return n * n;&#125; &#125; )(i) // 当前i赋值给函数形参n立即执行 ); 为什么直接压入匿名函数，而是要内部再返回一个函数，否则会报错？ 123456789101112131415161718function count() &#123; var arr = []; // 定义一个数组，用于压入三个函数 for (var i=1; i&lt;=3; i++) arr.push( ( function (n) &#123; return n * n; // 直接返回出错？？ &#125; )(i) ); return arr;&#125;var results = count();var f1 = results[0];console.log(f1()); // 报错： f1 is not a function 这是因为表面看arr.push() 压入的是一个函数，但由于立即执行，实际上压入的是函数返回值！所以才必须设计压入函数返回值是一个函数。 2.6 箭头函数 箭头函数和 Lambda 表达式都用于简写匿名函数，其语法也基本相同：(parameters) =&gt; &#123; statements; &#125;。 同时在满足一定条件下，还可以进一步简写： 参数类型可选 ：不需要声明参数类型，编译器可以统一识别参数值； 只有一个参数 ： 参数 ()可选 主体{}只有一条语句 ：此时 return 关键字 &amp; {} ，可不写。注意 ！ 主体{} 不省略时，哪怕只有一条语句，函数有返回值return关键字不可省！ 主体{} 省略时，return 也必须省略！ 利用箭头函数，实现给指定数组排序。 1234567&#x27;use strict&#x27;var arr = [10, 20, 1, 2];// arr.sort( (x, y) =&gt; x &gt; y ? 1: -1;); // 错误：函数作为参数不要加分号！arr.sort( (x, y) =&gt; x &gt; y ? 1: -1 );console.log(arr); // [1, 2, 10, 20] ⚠️ 试着指出下列箭头函数为什么不对？ 1arr.sort( (x, y) =&gt; &#123; x &gt; y ? 1: -1; &#125;); // 错误写法 主体{}只有一条语句，不省略{}时，语句要有分号 &amp; return不可省！ 1arr.sort( (x, y) =&gt; &#123; return x &gt; y ? 1: -1; &#125;); // 正确写法 优雅的解决 this 错误指向 在前面，我们提到 JavaScript 一个设计错误，在嵌套函数内部 this 会指向全局对象window (严格模式下指向 undefined) 而非调用函数的对象！为此我们提出一种解决办法：在嵌套函数里捕获this。 12345678910111213141516171819var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:function() &#123; // 捕获this，此时this不在嵌套函数内部还是指向调用对象 var that = this; function getAge() &#123; var nowYear = new Date().getFullYear(); return nowYear - this.birth; // 调用对象里属性，不用this会报错 &#125; return getAge(); &#125;&#125;console.log(hwh.age()); // 输出：23 现在我们可以箭头函数更加优雅的解决this 指向错误问题。 1234567891011121314var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:function() &#123; // 无需捕获this，此时this也能正确指向调用方法的对象 var getAge = () =&gt; new Date().getFullYear() - this.birth; return getAge(); // 注意：返回不是函数，而是调用后函数值 &#125;&#125;console.log(hwh.age()); // 输出：23 我的理解是，此时已经不是在嵌套函数内部调用this ，而在外层函数内调用this，不会出现this 错误指向问题。 因为在外层函数使用this 是可以自动绑定到当前调用函数的对象，但直接在对象内部调用this 还是会出错。 试分析：为什么对象内部直接this 调用属性出错。 1234567891011var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, my_birth: this.birth, age:() =&gt; new Date().getFullYear() - this.birth&#125;console.log(hwh.my_birth); // undefinedconsole.log(hwh.age()); // NaN 比如调用 hwh.my_birth 相当于以下过程： 12hwh = new hwh(); hwh.my_birth = this.birth; // 此时this指向了全局对象！ hwh.age() 调用错误同理。那么如何解决这个问题？ 目前除了apply、call 改变 this 指向（没试过），可声明一个函数在里面this 调用可以绑定到正确对象。 1234567891011121314var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, my_birth: function() &#123; return this.birth; &#125;, age:function() &#123; return () =&gt; new Date().getFullYear() - this.birth; &#125;&#125;console.log(hwh.my_birth); // 1996console.log(hwh.age()); // 23 2.7 generator generator 即生成器，是ES6 新引入数据类型，看上去像一个函数，但可以返回多次。 123456789101112function* f(x)&#123; yield x + 1; yield x + 2; yield x + 3;&#125;var myGenerator = f(0);var x1 = myGenerator.next(); console.log(x1); // 输出：&#123; value: 1, done: false &#125;var x2 = myGenerator.next(); console.log(x2); // 输出：&#123; value: 2, done: false &#125;var x3 = myGenerator.next(); console.log(x3); // 输出：&#123; value: 3, done: false &#125;var x4 = myGenerator.next(); console.log(x4); // 输出：&#123; value: undefined, done: true &#125; 它多个返回值可以 记录函数不同时刻的执行状态，从语法上看和函数有以下几个区别： 基本定义：函数是function f(x) ，而生成器要多出一个* ，function* f(x) 返回值：generator 生成器可以有多个返回值，记录函数不同时刻状态 使用：直接调用 generator 不是返回值，而是返回 一个生成器对象 ，可调用它的 next() 函数来输出返回值。 生成器不同返回值以对象形式保存：{value : 当前返回值，done: 判断是否已经输出完毕} 我们还可以更简洁用 for…of 循环来遍历generator 输出： 123456// 下面在浏览器里如是输出：如果直接在VSCode打印，还会在第一行输出：// Object [Generator] &#123;&#125;for(var x of myGenerator)&#123; console.log(x); // 依次输出：1 2 3&#125; 那么，generator 这种可以返回多个值，记录不同时刻执行状态的&quot;函数&quot;有什么作用呢？请看下例： 试着编写一个以 0、1 开头的斐波那契数列：0 1 1 2 3 5 8 13 21 34 … 按照以前思路，我们若要返回该斐波那契数列，必须要用 数组保存多个值 ，且看更优雅的generator 如何做到： 1234567891011121314151617181920function* fib(x)&#123; var a = 0, b = 1, c = -1; yield a; // 返回 0 yield b; // 返回 1 while(c &lt; x) &#123; c = a + b; [a,b] = [b,c]; yield c; &#125;&#125;var myGenerator = fib(5);for(var x of myGenerator)&#123; console.log(x); // 依次输出：0 1 1 2 3 5&#125; generator 不用数组来保存每次循环计算的值，而是直接将当前计算值的值 yield 返回即可。 generator 简化 AJAX （待） 第三章：标准对象 3.1 小城少年对象与坑 typeof 在 JavaScript 的世界里，一切都是对象，你喜欢但不喜欢你的姑娘也是。 typeof 操作符获取对象的类型，它总是返回一个 字符串。 1234567891011121314151617// 1.字符串、数值、布尔基本类型typeof 123; // &#x27;number&#x27;typeof true; // &#x27;boolean&#x27;typeof &#x27;str&#x27;; // &#x27;string&#x27;// 2.函数typeof Math.abs; // &#x27;function&#x27;// 3.预设特殊值typeof NaN; // &#x27;number&#x27;typeof undefined; // &#x27;undefined&#x27;typeof null; // &#x27;object&#x27;// 4.[] &#123;&#125; ?typeof []; // &#x27;object&#x27;typeof &#123;&#125;; // &#x27;object&#x27; 根据利用 tepeof 来判断一些变量。比如： 判读全局变量、局部变量是否存在。 判断全局变量是否存在：typeof window.myVar === 'undefined' 判断局部变量是否存在：typeof myVar === 'undefined' 。 判断是否 null、Array 。 我们从上也知道，typeof 无法判断出是否 null、Array (它们和 []、 {} 都是 object类型)，但可以： 判断 null ： 变量 === null； 判断 Array：Array.isArray(arr); 包装对象 和 java 类似，JavaScript 还提供了包装对象，比如 int 可封装转换为 integer 类型对象。 1234// 封装返回的是一个对象var n = new Number(123) ; console.log(n); // 输出：[Number: 123]var b = new Boolean(true); console.log(b); // 输出：[Boolean: true]var s = new String(&#x27;str&#x27;); console.log(s); // 输出：[String: &#x27;str&#x27;] 但是注意：包装对象看上去值和原来一样但是已经是 object 类型！ 12345678console.log(typeof n); // 输出：object console.log(typeof b); // 输出：objectconsole.log(typeof s); // 输出：object// 和此前不同！console.log(typeof 123); // 输出：numberconsole.log(typeof true); // 输出：booleanconsole.log(typeof &#x27;str&#x27;); // 输出：string 3.2 Date Date对象用来表示日期和时间，有以下三种创建其对象方式。 12345678910111213141516171819// 1.默认构造函数// 用now对象获取的时间始终是[当前最新]时间// 输出的是UTC时间，与本地时间相差8个小时var now = new Date(); console.log(now); // 输出：2019-07-23T08:25:35.884Z// 2.指定日期和时间构建// 默认参数 = 0var date = new Date(2019,6,23,16,20,30,123);console.log(date); // 输出：2019-07-23T16:20:30.123Z// 3.指定时间戳创建// 先将符合[ISO 8601格式]字符串---&gt;时间戳var timeStamp = Date.parse(&#x27;2019-07-23T16:20:30.123&#x27;);console.log(timeStamp); // 输出：1563870030123，这是一个时间戳// 转换为Date对象var date = new Date(timeStamp);console.log(date); // 输出：2019-07-23T16:20:30.123Z 常用的获取时间各种信息对象方法： 12345678910111213141516var now = new Date();now; // 2019-07-23T08:47:48.033Z// 对象方法now.getFullYear(); // 2019, 年份now.getMonth(); // 6, 月份，注意月份范围是0~11，6表示7月now.getDate(); // 23, 24号now.getDay(); // 2, 星期二now.getHours(); // 16, 24小时制now.getMinutes(); // 47, 分钟now.getSeconds(); // 48, 秒now.getMilliseconds(); // 033, 毫秒数now.getTime(); // 1563871956469, 时间戳// 静态方法console.log(Date.now()); // 输出：1563871956469 时区问题 我们看到上面输出的时间，并不是我们本地时间，而是UTC时间和本地相差8个小时，我们可以输出本地时间。 12345678910// 1.直接将当前时间转为本地时间console.log(now.toLocaleString()); // 输出：2019-7-23 5:10:21 PM// 2.获取时间戳，然后进行时区转换// 静态OR动态方法获取时间戳var timeStamp = Date.now(); // 或者 var timeStamp = new Date().getTime();// 直接用时间戳构建对象var date = new Date(timeStamp);console.log(date.toLocaleString()); // 输出：2019-7-23 5:10:21 PM 3.3 RegExp（待） RegExp 是专门用于正则解析的类，首先我们要对正则表达式熟悉。 正则表达式 3.4 JSON JSON 是 JavaScript Object Notation 的缩写，它是一种数据交换格式，实际上也是 JavaScript 的一个子集。 其支持的数据类型有： object：即JavaScript 的&#123; ... &#125;表示方式 (可嵌套) number、boolean、 string、null、array：和 JavaScript 中对应类型完全一致 json 数据可以是上面支持数据类型 任意一个或多个组合 ，而不是只能在object {…} 包含键值对形式 。 观察下面 json 格式数据{…}和 js 对象{…}有什么不同？ 1234567891011// 组合成json格式数据&#123; &quot;birth&quot;: 1996, &quot;gender&quot;: &quot;M&quot;, &quot;school&quot;: &quot;chongqingU&quot;, &quot;skills&quot;: [ &quot;3C&quot;, &quot;python&quot;, &quot;2j&quot; ]&#125; 只要是字符串，如键值必须用双引号 ‘’ ‘’ 而且 json 还规定字符集必须是 UTF-8，这样可以支持多语言了。 json 和 js 对象/数组/字符串（json支持）等 可以互相转换，这又称为序列化和反序列化。 序列化 将JavaScript 数据类型转换为 json 称之为序列化。如下面是一个对象： 12345678var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, skills: [&#x27;3C&#x27;,&#x27;python&#x27;,&#x27;2j&#x27;], age:function()&#123; return new Date().getFullYear() - this.birth; &#125;&#125; 在 JavaScript 内置了 json API，我们可以直接调用 JSON.stringify()来转换为 json 格式： 12345// @value：传递一个对象或者数组(?)// @replacer: 传递一个方法用来改变结果显示，或者传递数组筛选指定键值// @space : 传递空白字符等用来格式化结果，使得结果更易读JSON.stringify(hwh,null,&#x27; &#x27;); 尝试输出结果： 12345678910111213141516// 返回字符串var s = JSON.stringify(hwh,null,&#x27; &#x27;);console.log(typeof s); // 输出：string，说明转换后json格式数据是字符串console.log(s);// 序列化结果&#123; &quot;birth&quot;: 1996, &quot;gender&quot;: &quot;M&quot;, &quot;school&quot;: &quot;chongqingU&quot;, &quot;skills&quot;: [ &quot;3C&quot;, &quot;python&quot;, &quot;2j&quot; ]&#125; 特别的，允许的数据类型如果不属于json 支持类型，序列化时不会显示该类型，如 函数age键值对 没有显示。 当然，我们也可以转换其它json 支持的数据类型： 123console.log(JSON.stringify(&#x27;str&#x27;)); // 输出：&quot;str&quot;console.log(JSON.stringify(123)); // 输出：123console.log(JSON.stringify(true)); // 输出：true 进一步处理：传递函数 在前介绍，我们还可以通过第二个参数 @replacer 对键值对进行筛选、指定处理方法等。 筛选出JavaScript对象指定键值：birth、gender、school 对应键值对。 我们可以通过传递一个数组包含我们希望留下的键值，来达到目的。 123456789var s = JSON.stringify(hwh,[&#x27;birth&#x27;,&#x27;gender&#x27;,&#x27;school&#x27;],&#x27; &#x27;);console.log(s);// 序列化结果&#123; &quot;birth&quot;: 1996, &quot;gender&quot;: &quot;M&quot;, &quot;school&quot;: &quot;chongqingU&quot;&#125; 12345678// 数组好像不行？？var s = JSON.stringify([&#x27;hwh&#x27;,&#x27;lt&#x27;],[0],&#x27; &#x27;);// 序列化结果[ &quot;hwh&quot;, &quot;lt&quot;,] 将所有键值转换为大写。（为什么不能对键值 key 大写？只能修改属性？） 需要对键值对进行处理，可以传递一个函数，它会对所有键值对进行操作。 123456// 箭头函数// 必须判断是否是 string类型，因为如birth属性就是Number// 注意：typeof返回String类型字符串！// 为什么不能转换键值key为大写？var valueToUpper = (key,value) =&gt; typeof value === &#x27;string&#x27; ? value.toUpperCase():value; ⚠️ 传递的函数任何情况要有返回值！比如上面不打算对属性value 进行修改也要 return value 。 我们尝试输出结果： 12345678910111213var s = JSON.stringify(hwh,valueToUpper,&#x27; &#x27;);console.log(s);&#123; &quot;birth&quot;: 1996, &quot;gender&quot;: &quot;M&quot;, &quot;school&quot;: &quot;CHONGQINGU&quot;, &quot;skills&quot;: [ &quot;3C&quot;, &quot;PYTHON&quot;, &quot;2J&quot; ]&#125; 反序列化 我们也可以利用 JSON.parse() 将 json 格式字符串解析转换为 javaScript对象 。 123456789// 1.反序列化对象 JSON.parse(&#x27;&#123;&quot;name&quot;:&quot;hwh&quot;, &quot;age&quot;:23&#125;&#x27;); // Object &#123;name: &#x27;hwh&#x27;, age: 23&#125;// 2.反序列化数组JSON.parse(&#x27;[1,2,3,true]&#x27;); // [1, 2, 3, true]// 3.反序列化其它基本类型JSON.parse(&#x27;true&#x27;); // trueJSON.parse(&#x27;123.45&#x27;); // 123.45 ⚠️ 要解析的 json 数据一定要是字符串！ 1234567// 1.尝试解析对象？var hwh = &#123;&quot;name&quot;:&quot;hwh&quot;, &quot;age&quot;:23&#125;; // 这既不是对象（键值有&quot;&quot;），也不是字符串console.log(JSON.parse(hwh)); // 解析错误// 2.尝试解析数组？var arr = [1,2,3,true];console.log(JSON.parse(arr)); // 解析错误 进一步处理：传递函数 事实上JSON.parse() 有两个参数，还可传第二个函数参数 @reviver 对json 字符串进行处理： 把传递进来的json 字符串，键值name对应属性后加上“同学”。 123456789101112131415// 反序列化：json字符串转换为对象// JSON.parse(@text,@reviver)// @text：传递合法json字符串// @reviver：传递一个函数改变输出结果var json_hwh = &#x27;&#123;&quot;name&quot;:&quot;hwh&quot;, &quot;age&quot;:23&#125;&#x27;;var addSome = function(key,value)&#123; if(key === &quot;name&quot;) return value + &#x27;同学&#x27;; // 对value进行修改 else return value; // 易错：其它情况也一定要有返回值！否则最后解析为undefined的！&#125;var obj = JSON.parse(json_hwh,addSome); 尝试输出结果： 1234console.log(obj);// 反序列化结果&#123; name: &#x27;hwh同学&#x27;, age: 23 &#125; 第四章：面对对象编程 4.1 在 JS 世界面对对象 JavaScript 所有数据都可以看成对象，比如我们之前使用：Number、Array、string &amp; 基本的**{…} **定义的对象。 但这并没有真正发挥面对对象编程威力。 熟悉 java、C# 的你一定知道：类 &amp; 实例之间区别，就是模板与创建的实例对象。BUT ，在JavaScript 中并没有类和实例概念，在JavaScript 世界里是通过 原型（prototype） 等方式实现的。 1.创建对象 闲的蛋疼的你想创建一个hwh对象，他会唱 、跳、rap、喜欢打篮球，又懒得9点钟都不一定起床的你恰好看到你之前创建的一个student对象： 12345678910var student = &#123; name : &quot;小明&quot;, age: 18, school: &quot;chongqingU&quot;, sing: function () &#123; console.log(&quot;i am sing..&quot;); &#125;&#125; 可是hwh 不叫小明，也不是18岁啊！更重要的小明他居然不会跳、rap、🏀！ 熟悉原型链的你微微一笑，不慌不忙的创建了一个hwh 对象： 123456789101112131415161718var hwh = &#123; name: &quot;huangwanghui&quot;, age: 23, // 对象增加额外方法 jump: function() &#123; console.log(&quot;i am jump..&quot;); &#125;, rap: function() &#123; console.log(&quot;i am rap..&quot;); &#125;, play_basketball: function() &#123; console.log(&quot;i am playing basketball ..&quot;); &#125;&#125; 然后把hwh._proto_ 属性指向student，看上去好像继承了student： 1234567hwh.__proto__ = student; // 注意：proto左右各有两个_，不是一个！console.log(&quot;大家好，我是渣渣辉 :&quot; + hwh.name);hwh.sing(); // 唱：i am sing..hwh.jump(); // 跳：i am jump..hwh.rap(); // rap：i am rap..hwh.play_basketball(); // 打篮球：i am playing basketball .. 通过同名键值可以覆盖student原有键值，通过创建新键值对可以使得hwh 可以跳、rap、打篮球。 扩展了解 为什么这种方式看上去好像 “继承”了 student 属性？ 因为在JavaScript 中，实例对象hwh如果没有找到属性、方法它会自动在其 hwh._proto_ 对象属性中查找（_proto_ 是一个对象）。这个时候把对象student 赋值 hwh._proto_ ，那么就会自动查找对象 student 属性。 ⚠️ _proto_ 是每一个对象或函数都有的属性（默认指向 Object.prototype），但是函数还有 prototype 属性。 所以hwh._proto_ （也就是对象student ）中也有这个属性： 此时查找的原型链为： 如果是用后面介绍 构造函数创建hwh对象方式 ，其查找原型链为： Object.create()创建对象 通常在写 JavaScript 代码，不推荐 使用 对象名.__proto__ 方式改变对象原型。 我们应该用 Object.create(对象o) 创建一个基于对象o 原型新对象： 用Object.create() 方式创建基于原型student 的对象hwh ，相当 复制 了student对象。 1234567891011121314// 基于原型student创建对象hwhvar hwh = Object.create(student);// 对象修改属性hwh.name = &#x27;huangwanghui&#x27;;hwh.age = 23;// 对象增加方法hwh.jump = () =&gt; console.log(&quot;i am jump..&quot;);hwh.rap = () =&gt; console.log(&quot;i am rap..&quot;);hwh.play_basketball = () =&gt; console.log(&quot;i am playing basketball ..&quot;);// 测试调用console.log(hwh.name); // 输出：huangwanghuihwh.jump(); // 输出：i am jump.. 构造函数创建对象 前面我们介绍了两种基于student原型创建hwh 对象方式：其中 hwh.__proto___ = student 这种创建对象方式，我们不推荐修改实例hwh 的*_proto__* 属性。 而且我们知道，此前student 都是对象： 1234567891011// 原型对象studentvar student = &#123; name : &quot;小明&quot;, age: 18, school: &quot;chongqingU&quot;, sing: function () &#123; console.log(&quot;i am sing..&quot;); &#125;&#125; 我们把student 改写成一个函数： 1234567891011// 构造函数Studentfunction Student(name,age,school) // 构造函数首字母建议大写&#123; this.name = name; this.age = age, this.school = school, this.sing = function () // 必须全部用this引用函数内部变量 &#123; console.log(&quot;i am sing..&quot;); &#125;&#125; 函数内部看起来很像对象键值对形式只不过 键值:属性 变为：this.键值:属性，特别的 函数所有变量（“键值”）必须用this 引用 ，在函数内部（非strict 模式）this 指向全局对象window ；new 创建新对象后，会自动将 this 指向到新创建的对象。 这也就是构造函数，使用 new 它会返回一个实例对象： 实例对象 继承构造函数所有属性 实例对象 _proto_ 属性自动绑定为构造函数原型prototype 属性。 同样，自然我们也可以对对象进行增改： 1234567891011// new返回一个对象var hwh = new Student(&quot;hwh&quot;,23,&quot;chongqingU&quot;); // 对象增加额外方法hwh.jump = () =&gt; console.log(&quot;i am jump..&quot;);hwh.rap = () =&gt; console.log(&quot;i am rap..&quot;);hwh.play_basketball = () =&gt; console.log(&quot;i am playing basketball ..&quot;);// 测试输出hwh.sing(); // 输出：i am sing..hwh.jump(); // 输出：i am jump.. 同前，此时原型链查找顺序为： 对象student 原型对象prototype 会自动赋值给 hwh._proto_ （student.prototype 属性也是一个对象） 如果没有在实例hwh 中找到属性、方法就会自动在hwh._proto_ 中查找，等价于在 student.prototype 查找 对象student.prototype 又有个对象属性 student.prototype._proto_ 它被赋值为Object 原型Object.prototype 如果student.prototype 没有找到属性，就会接着在 student.prototype._proto_ 中查找（等价在原型Object.prototype 中查找） 最后还有还找到返回null 2. 初识原型链 当我们用对象名.xxx访问一个对象属性时，JavaScript 引擎查找顺序如下： 先在当前对象上查找该属性，如果没有找到； 在其原型对象上找，如果还没有找到； 一直上溯到 Object.prototype --&gt; null ； 上溯到null 说明未找到，返回 undefined 。 等等，这里原型链是什么？ 当我们创建一个 Array 对象： 1var arr = [1, 2, 3]; 数组 arr 它的原型链是： 1arr ----&gt; Array.prototype ----&gt; Object.prototype ----&gt; null 由于 Array.prototype 定义了 indexof() 、shift() 等方法，所以我们可以直接使用。 同理，创建一个函数 fun() 其原型链为： 1foo ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null 那么前面以构造函数创建的hwh对象原型链是？（参考 1.创建对象 — 构造函数创建对象 一节） 构造函数 创建的hwh对象其原型链： 1hwh ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null 或者用图表达： ⚠️ 这里 Array、Function、Student 都是构造函数，因此有prototype 属性 即函数原型（见下详述）。 ​ 注：每一个对象或函数都有*_proto_*属性（默认指向 Object.prototype），但只有函数才有 prototype 属性。 使用原型链基本原则 基本使用原型链原则： 原型链不应该过长，这会在查找对象属性花费过多时间。 构造函数名首字母应该为大写（像约定类名首字母大写）。 3.深入理解原型链 prototype &amp; _proto_ 在前我们知道构造函数也是可以拥有属性的，prototype 是只有函数才拥有的共有属性。属性prototype 又称为 函数原型，它是一个对象。 _proto_ 是所有对象、函数都有属性，它也是一个对象，指向生成它的构造函数原型prototype 属性。因为所有对象都派生自 Object 构造函数，所以默认指向原型object.prototype 属性。如果是通过构造函数创建的实例对象，则指向生成它的构造函数原型prototype 。 （而prototype 也是一个对象，所以不难理解它也有*_proto_*属性 ：prototype._proto_） 在函数原型上定义的方法、属性会被所有实例“继承”，（准确来说，构造函数new 出的实例才会继承构造函数所有属性，函数原型上定义的方法、属性只是可以通过原型链查找而被使用，看上去好像“继承”了）。 函数原型对象prototype主要包含的属性方法如下（prototype 是一个对象所以也有很多键值对属性）： 原型本身定义的 原型 属性、方法（只有通过 函数名.prototype.属性名 = 方法/属性 定义的才是原型方法、属性 ） constructor 属性：指向构造函数本身 _proto_ 属性：和原型链上级构造函数原型prototype属性等价 进一步理解函数原型对象？ 我们创建一个空构造函数 Student() ： 123456function Student() // 构造函数首字母建议大写&#123; this.name = &quot;hwh&quot;; // [注1]&#125;Student.prototype.shcool = &quot;chongqingU&quot;; // 给Student函数增加属性，这样可以增加到原型对象上Student.age = 23; // [注2] 试想一下，如果我们之前用对象来作为原型创建实例， 把函数Student()改为对象Student应该是： 1234567// [注1] 添加的属性name不属于函数原型方法属性，但可被创建的实例继承，是实例属性// [注2] 添加的属性age，既不属于函数原型方法属性，也不会被实例继承，只能自娱自乐Student &#123; school: &#x27;chongqingU&#x27;&#125; 这样我们便有了函数原型 Student.prototype 的一个初步雏形： 1234Student.prototype &#123; school: &#x27;chongqingU&#x27;&#125; 当然，实际的 Student.prototype 属性不会这么简单：它还拥有constructor属性指向构造函数本身 ；_proto_ 属性指向上一级构造函数原型prototype 。 我们尝试打印会出来类似下面结构： 123456789101112131415console.log(Student.prototype);&#123; shcool:&quot;chongqingU&quot; // 1.函数原型增加的原型属性：shcool constructor: ƒ doSomething(), // 2.constructor：指向Student本身 __proto__: &#123; // 3.__proto__：== object.prototype constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() &#125;&#125; 可以看到构造函数Student.prototype._proto_ 属性指向—&gt;上一级构造函数object.prototype 属性。 (_proto_ 属性默认指向Object 原型) 1Student.prototype.__proto__ === object.prototype; // ture t由上介绍我们也知道，用构造函数创建的实例*_proto_* 属性，会指向生成它的构造函数原型 prototype 属性。 利用构造函数Student 创建实例hwh 对象，打印出它的 _proto_ 属性。 12var hwh = new Student();console.log(hwh.__proto__); 下面打印出的实际就是原型 Student.prototype : 1234567&#123; shcool:&quot;chongqingU&quot; // 1.原型本身拥有的属性：shcool constructor: ƒ doSomething(), // 2.constructor：指向Student本身 __proto__: &#123; // 3.__proto__：== object.prototype // ... &#125;&#125; 总结一下，函数原型可看作是 构造函数的一个&quot;实例&quot; ，但是： 只有 函数名.prototype.属性 OR 函数名.prototype.方法 声明的属性/方法才是原型属性/方法 &quot;实例&quot;还自动拥有 constructor &amp; _proto_ 属性分别指向函数本身和下一级构造函数原型 原型链查找 好的聪明的你肯定想起来，我们前面写出的 Student 构造函数创建的 hwh 对象原型链： 和我们此前说过的原型链查找某属性规则： 1当前对象查找属性 ---&gt; 上一级原型查找 ---&gt; .... ---&gt; object原型查找 ---&gt; 还没找到则为null 用一张图概况整个过程应该是： 在对象 hwh 本身实例属性查找，未找到则在 hwh._proto_ 查找 hwh._proto__ 实际 ===上级原型Student.prototype ，在该原型中查找定义的原型属性、方法 未找到则在hwh._proto_.prototype._proto_ === Student.prototype._proto_ ===上级原型 Object.prototype，查找该原型中定义的属性、方法 还未找到则返回null 如果我们把构造函数Student 原型指向另外一个实例，那么原型链查找顺序如何变化？ 创建实例lt，它有属性name = “liuting” 。把Student.prototype指向lt后，分析原型链查找name过程。 123456function Student() &#123;&#125;var lt = new Student(); lt.name = &quot;liuting&quot;; 此时我们还可以看到：lt.__proto__ === Student.prototype 为ture ，指向生成它的构造函数原型。 而当把Student 原型指向lt 后： 1Student.prototype = lt; // Student原型指向lt lt.__proto__ === Student.prototype 为 false， lt._proto_ 还是保存原来未修改前的Student 函数原型**。 再用构造函Student数创建新对象hwh： 12var hwh = new Student();hwh.__proto__ === Student.prototype === lt; // ture 用一张图概括原型链变化应该是： 我们尝试输出 hwh.name，显然可以在原型链 实例lt 的 lt属性方法 找到 name 属性： 1console.log(hwh.name); // 输出:liuting 4.2 构造函数继承 我们定义一个构造函数 Student()： 12345function Student()&#123;&#125;var hwh = new Student(); 其原型链为： 1hwh ---&gt; Student.prototype ---&gt; Object.prototype ---&gt; null 现在我们又定义了个构造函数 People() : 1234function People()&#123; this.eat = () =&gt; console.log(&quot;i am eating&quot;);&#125; 我们希望Student 能继承 People ,从而可以使用 People 的 eat() 方法，并且把原型链修改为： 1hwh ---&gt; Student.prototype ---&gt; People.prototype ---&gt; Object.prototype ---&gt; null 那么该怎么办呢？ 1. 构造函数绑定 前面我们讲过apply方法：函数名.apply(对象名,[]) 。 可以将函数所有 绑定到this的属性 转而—&gt; 绑定到指定对象 上。（注：非严格模式下函数this 指向 undefined） 因此，我们可以将构造函数People 绑定到this的属性 —&gt; 绑定到构造函数Student 生成的对象上。 123456789function Student()&#123; // this指向Student构造函数创建的对象 // 将构造函数People绑定到this的属性(不是People所有属性) ---&gt; 绑定到Student对象上 People.apply(this,[]);&#125;var hwh = new Student();hwh.eat(); // 输出：i am eating 这样只是继承了Student 所有的属性，但是其原型链没有改变，还是： 1hwh ---&gt; Student.prototype ---&gt; Object.prototype ---&gt; null 之所以hwh 能调用 eat() 方法，是因为该方法已经绑定到 hwh 对象上。 2. prototype 模式 如果我们把 Student 原型指向 —&gt;一个 People 的实例，那么所有Student 实例都能“继承”People 属性、方法（准确来说，是通过原型链使得Student 实例对象hwh 可以使用构造函数People 的属性、方法）。 1234567Student.prototype = new People();// 良好习惯：修改了prototype要设置回prototype.constructorStudent.prototype.constructor = Student;var hwh = new Student();hwh.eat(); // 输出：i am eating 此时原型继承链为： 1hwh --&gt;Student.prototype == new People() --&gt;People.prototype --&gt;Object.prototype --&gt; null 用一张图表示为： 为什么有“良好习惯”？ 在上面我们修改了 Student.prototype 指向，立马有重新设置了 Student.prototype.constructor 指回Student 。 如果不这么做： 1234Student.prototype = new People();var hwh = new Student();hwh.eat(); // 输出：i am eating 不影响通过原型链使用People.eat() 方法，但我们尝试输出：hwh.constructor 1234567cosole.log(hwh.constructor);// 输出结果function People()&#123; this.eat = () =&gt; console.log(&quot;i am eating&quot;);&#125; 发现构造函数Student 生成的对象hwh.constructor 属性是指向构造函数People ！ 首先，我们要知道hwh 本身是没有constructor这个属性的。它是通过原型链查找到构造函数 People.prototype.constructor 属性的，自然它是指向构造函数 People 了： 但是对象hwh，是由构造函数Student() 生成的，我们在应该让hwh.constructor 指向生成它的构造函数Student()！ 所以就有了上面的 “良好习惯”： 1Student.prototype.constructor = Student; 但是，你可能会担心，这样People.prototype.constructor 不就被修改了吗？ 实际上，这样做只会在Student.prototype 也就是匿名对象 new People() +键值对：constructor : f Student() 看上去好像基本解决了原型链继承问题？但是由于要创建实例对象，开销较大。 3. 直接继承 prototype 通过直接把Student.prototype 原型属性直接指向 People.prototype 原型属性，来达到继承People 属性、方法。 通过这种方式，需要把People 的属性、方法绑定到原型对象People.prototype ： 1234function People()&#123;&#125;People.prototype.eat = () =&gt; console.log(&quot;i am eating&quot;); 好了，我们开始 “ 继承 ” People.prototype ： 123456Student.prototype = People.prototype;// 良好的习惯：每次修改函数原型，都应该设置回constructorStudent.prototype.constructor = Student;var hwh = new Student();hwh.eat(); // 输出：i am eating 看起来天衣无缝，而且这比第 2 种方法效率更高：不用创建 People 实例。 但这种方式的原型链为： 1hwh ---&gt; Student.prototype == People.prototype ---&gt; Object.prototype ---&gt; null 它没有体现 Student 和People之间原型继承关系，而且也隐藏了一个缺点。 继承 prototype 方式缺点 这种方式， Student.prototype 和 People.prototype 现在指向了 同一个对象 ，任何对 Student.prototype 修改都将反应在People.prototype 上。 我们在第二行修改了：Student.prototype.constructor = Student; ，会导致People.prototype.constructor 也被指向为构造函数 Student 。 123456People.prototype.constructor// 输出结果function Student()&#123;&#125; 我的疑问？ 为什么不可以直接设置 Student.prototype._proto_ 指向 People.prototype ？？？ 这种方式被很多博文都指出不应该提倡，原因影响性能？MDN-不推荐使用Object.prototype._proto_ 1234Student.prototype.__proto__ = People.prototype;var hwh = new Student();hwh.eat(); // 可以输出：i am eating 实现了原型链继承关系 同时因为没有修改Student.prototype ，不用设置 Student.prototype.constructor = Student 4. 利用空对象作为中介 一种基本完美的方法：既可体现原型链 Student 和People 继承关系，也不会导致constructor 之类问题。 由于第3种办法，会出现指向同一对象导致constructor 意料之外被修改问题，我们可以借用一个空函数作为中介。 123456789101112131415161718// 空函数F作为媒介function F()&#123;&#125;// 把F原型指向People原型F.prototype = People.prototype;// 此时Student.prototype原型指向空函数F实例对象Student.prototype = new F();// 良好习惯：每次修改函数原型，都应该设置回constructor// 由于此时Student.prototype 和 People.prototype不再指向同一对象// 此时修改constructor不会导致 People.prototype.constructor 被同步修改Student.prototype.constructor = Student; var hwh = new Student();hwh.eat(); // 输出：i am eating 噢，我的天！这是再变魔术吗？到底怎么一回事呢？ 1hwh ---&gt; Student.prototype == new F() ---&gt; F.prototype = People.prototype --&gt; Object.prototype ---&gt; null 5. 拷贝继承 这种方式比较暴力… 首先，把People 的属性、方法绑定到原型对象People.prototype ： 1234567function Student()&#123;&#125;function People()&#123;&#125;People.prototype.eat = () =&gt; console.log(&quot;i am eating&quot;); 接着实现将People 原型属性全部拷贝到 Student 原型属性上： 123456789// 遍历对象只需普通for循环// 遍历循环只能用&lt;对象名[&#x27;key&#x27;]&gt;方式，其中&#x27;&#x27;在[i]不用加，i已经是字符串for(var i in People.prototype)&#123; Student.prototype[i] = People.prototype[i];&#125;var hwh = new Student();hwh.eat(); // 输出：i am eating 可以看到，通过原型链 实例对象hwh 可以访问到构造函数Student.prototype.eat 属性方法。 4.3 class 继承 写的比较简单，需要时再补充。 初识 class 在ES6标准引入了 class 关键字，比原先JavaScript 基于原型链的对象模型更加简单。 现在有一个构造函数 Student 可用来new 出实例对象，它像下面这样： 123456function Student(name,age) &#123; this.name = name; this.age = age;&#125;Student.prototype.learn = function() &#123; console.log(&quot;i am learning..&quot;); &#125;; 把它改写成class ： 1234567891011121314151617181920class Student&#123; // 构造方法 // new生成实例对象时自动调用该方法，为所有类实例对象生成下列实例属性 constructor(name,age) &#123; this.name = name; this.age = age; &#125; // learn方法 learn() &#123; console.log(&quot;i am learning..&quot;); &#125;&#125;// 尝试调用var hwh = new Student(&#x27;hwh&#x27;,23);hwh.learn(); // 输出：i am learning.. 看起来比此前写法简单多了，但其实在JavaScript 类 class 本质还是函数： 1typeof Student; // function 另一方面，函数自然一定有原型属性prototype ： 当然，这个’'函数&quot;有点特殊，所有直接在类中定义的属性、方法会被直接绑定到函数原型上。 所以上面 class Student 等价这么写： 12345678910class Student&#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125;&#125;Student.prototype.learn = function() &#123; console.log(&quot;i am learning..&quot;); &#125;; 使用 class 实现继承 使用class 可以方便的实现继承，我想刚刚学完原型继承的你不会忘记被它支配的恐惧。 现在这有一个类 Girl_Student 继承 Student ，你可以这么写： 123456789101112131415161718class Girl_Student extends Student&#123; constructor(name,age,grade) &#123; // ES6规定必须调用父类构造函数一次 super(name,age); this.grade = grade; &#125; myGrade() &#123; console.log(&#x27;I am at grade: &#x27; + this.grade); &#125;&#125;var gs = new Girl_Student(&#x27;lt&#x27;,23,395);gs.myGrade(); // 调用自身方法：I am at grade 395gs.learn(); // 调用父类方法：i am learning.. 第五章：浏览器 5.1 浏览器常用对象 window window 对象不但充当全局作用域，而且表示 浏览器窗口，常用属性如下： 属性名 作用 innerWidth 内宽度，不包含菜单栏、工具栏等占位元素 innerHeight 内高度，不包含菜单栏、工具栏等占位元素 screen screen 对象表示 屏幕 的信息，常用属性有： 属性名 作用 width 屏幕宽度，以像素为单位 height 屏幕高度，以像素为单位 colorDepth 颜色位数，如16 navigator navigator 对象表示 浏览器 信息，常用属性有： 属性名 作用 appName 浏览器名称 appVersion 浏览器版本 language 浏览器语言 platform 操作系统类型 userAgent 浏览器设定的 user-Agent 字符串 location location 对象表示 当前页面URL 信息，常用属性有： 以 http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP 为例。 属性名 作用 href 完整地址：上面全部蓝字域名 protocol 协议名： http host 域名： www.example.com port 端口： 8080 pathname 路径名： /path/index.html search 查询？：?a=1&amp;b=2 hash 哈希？：TOP 还可以利用对象方法： 方法名 实例 reload() location.reload(); // 重新加载当前界面 assign() location.assign(‘https://www.baidu.com’); // 当前界面打开百度，必须带有协议类型！ history 已不推荐使用，简单介绍常用方法： 方法名 实例 back() history.back() // 相当点击浏览器后退按钮 forward() history.forward() // 相当点击浏览器前进按钮 不推荐使用的一个实例场景。 如果我们在登陆成功调用 history.back() 试图回到登陆前界面，又要重新登陆了！ document document 对象是浏览器中 DOM树根节点 ，可利用它进行操作DOM、获取cookie等，常用属性如下： 属性名 实例 cookie document.cookie() // 获取 cookie 更多操作DOM，详见下节分解。 5.2 操作DOM 1.获取节点 getElementBy…() 获取节点 注：标签也可称为元素、节点。 方法名 作用 getElementById() 根据 标签ID属性 来获取节点 getElementByName() 根据 name属性 来获取节点 getElementByClassName() 根据 标签class属性 来获取节点 getElementByTagName() 根据 标签名 来获取节点，如div、img 一些简单操作实例。 123456789// 返回ID为&#x27;test&#x27;的节点：var test = document.getElementById(&#x27;test&#x27;);// 获取节点test下的所有直属[子节点]:var cs = test.children;// 获取节点test下第一个、最后一个[子节点]：var first = test.firstElementChild;var last = test.lastElementChild; CSS选择器获取节点 我们也可以利用 CSS选择器 selector 语法来获取节点： 方法名 作用 querySelector(selector) 获取满足条件的第一个节点 querySelectorAll(selector) 获取满足条件的所有节点 基本选择器用法： 选择器类型 用法 标签选择器：标签名 document.querySelector(“div”) // 获取第一个div标签节点 类选择器：.类名 document.querySelector(“.key”) // 获取第一个class = key节点 ID选择器：#ID名 document.querySelector(“#uid”) // 获取第一个ID = uid 节点 属性选择器：[属性=属性名] document.querySelector(“[type=text]”) // 获取第一个name =&quot; text&quot; 节点 层级选择器 我们还可以进行选择器组合筛选指定元素后代： 关系选择器组合 作用 A B 匹配A元素中的子元素B，B可以是A 任意级别后代 A &gt; B 匹配A元素中的下级子元素B，只能是 直系后代 A + B 匹配A元素中的任一下一个兄弟元素B（同级） B ~ E 匹配B元素后面的拥有共同父元素的兄弟元素E 过滤器 过滤器一般不单独使用，附加到选择器上更精确定位元素 ：&lt;选择器&gt;：&lt;元素状态关键字&gt; ⚠️ 在jQuery 中冒号： 和选择器前一定要有空格！ 12$(&#x27;#test-form:radio&#x27;); // 错误写法：无法选择表单中单选框$(&#x27;#test-form :radio&#x27;); // 正确写法，要有空格！ 指定选定元素处于何种状态时的CSS样式 。 指定a标签处于各种状态的样式 以 在CSS中修改不同状态a 标签颜色为例。 1234567891011// link-匹配当前元素连接a :link &#123;color: slategray;&#125;// visited-匹配已访问过的连接a :link &#123;color: #4b2f89;&#125;// active-匹配元素当中激活状态（鼠标悬停）的链接a :active &#123;color: blue;&#125; // hover-匹配元素当中未激活状态的链接a :hover &#123;color: blue;&#125; 匹配一组兄弟元素某元素 分类 实例 :first-child 匹配一组p标签第一个p标签：p:first-child :nth-child() 匹配一组p标签第一个p标签：p:nth-child(1) 匹配表格中的奇数行：tr:nth-child(2n+1) 匹配表格中的偶数行：tr:nth-child(2n) 更多：:nth-last-child(an + b)、:nth-of-type(an+b)、:last-of-type … 表单相关 分类 实例 :input 选择 表单 以下标签：&lt;input&gt;，&lt;textarea&gt;，&lt;select&gt;和&lt;button&gt; :enabled 选择 表单 可以正常输入的&lt;input&gt;、&lt;select&gt; ：$(‘#test-form :enabled’) :disabled 选择 表单 那些不能输入的 &lt;input&gt;、&lt;select&gt;：$(‘#test-form :disabled’) :file 选择文件： input : file === input[type=file] :checkbox 选择复选框：input : checkbox=== input[type=checkbox] :radio 选择单选框：input : radio === input[type=radio] :focus 选择当前输入焦点：例如把光标放到一个&lt;input&gt;上，$(‘input:focus’) 便可选中 :checked 选择当前勾上的单选框和复选框：$(‘input[type=radio]:checked’) 选择表单id = test-form 下所有 &lt;input&gt;，&lt;textarea&gt;，&lt;select&gt;和&lt;button&gt; 节点。 12// 无法用：document.querySelectorALL(&#x27;#test-form :input&#x27;) ？？$(&#x27;#test-form :input&#x27;); 其它更多 分类 实例 :empty 匹配没有子元素的元素 :target 用于匹配URI中的ID标识（即：锚点）部分 获取节点基本信息 1&lt;input type=&quot;text&quot; id=&#x27;user&#x27;&gt; 可以获取基本属性等信息，不存在的属性字符串类型返回空字符串 “” ，布尔类型默认返回 false： 123456789101112var u = document.querySelector(&#x27;#user&#x27;);// 获取存在的属性u.type; // &quot;text&quot;u.id; // &quot;user&quot;// 获取不存在的属性u.name; // &quot;&quot;u.checked; // false// 文本框值u.value ; // &quot;hwh&quot;，已经在文本框中输入hwh 2.更新DOM 更新DOM节点文本 我们常用以下属性对DOM节点文本内容进行修改： 属性名 用法 innerHTML 可以插入HTML标签 &amp; 字符串 innerText 只能插入字符串，插入HTML标签会解析成字符串 textContent 同上，但会返回所有文本包括隐藏文本 更新标签、字符串实例。 1&lt;div id=&quot;content&quot;&gt; test &lt;/div&gt; 1234567891011var c = document.getElementById(&#x27;content&#x27;);c.innerText; // 输出：&quot;test&quot;// 1.插入HTMLc.innerHTML = &#x27;&lt;p&gt; hello test!&lt;/p&gt;&#x27;; // 打开浏览器div标签内输出：hello test!// 2.插入字符串c.innerText = &#x27;&lt;p&gt; hello test!&lt;/p&gt;&#x27;; // 打开浏览器div标签内输出：&lt;p&gt; hello test!&lt;/p&gt;// 3.插入字符串c.textContent = &#x27;&lt;p&gt; hello test!&lt;/p&gt;&#x27;; // 打开浏览器div标签内输出：&lt;p&gt; hello test!&lt;/p&gt; 更新CSS样式 获取节点后，利用 style 属性进行样式设置。 属性名 用法 style DOM节点 style 属性对应所有的CSS，可直接获取OR设置。 进行简单CSS样式设置。 12345var c = document.getElementById(&#x27;content&#x27;);// 设置CSSc.style.color = &#x27;#ff0000&#x27;;c.style.fontSize = &#x27;1200px&#x27;; ⚠️ 注意 fontSize 等在javaScript 中是驼峰命名，而在CSS中是 font-size ！ 3.插入DOM 在前我们利用：c.innerHTML = '&lt;p&gt; hello test!&lt;/p&gt;'; 可以在&lt;div&gt; ... &lt;/div&gt;插入HTML标签，但是会替换掉里面所有DOM节点内容。 为此我们可以利用以下方法： 方法名 用法 appendChild(newElem) 添加子节点newElem 为当前父节点对象 最后一个子节点 insertBefore(newElem，ref) 添加子节点newElem 为当前父节点对象 另一个子节点ref前 下面为预设好的HTML结构： 123456&lt;ul id=&quot;programLanguage&quot;&gt; &lt;li id=&quot;C#&quot;&gt;C#&lt;/li&gt; &lt;li id=&quot;C&quot;&gt;C&lt;/li&gt; &lt;li id=&quot;python&quot;&gt;python&lt;/li&gt; &lt;li id=&quot;java&quot;&gt;java&lt;/li&gt; &lt;/ul&gt; 创建一个新节点：&lt;li id=&quot;javascript&quot;&gt;javascript&lt;/li&gt; 插入到列表末尾。 123456789var ul_pl = document.getElementById(&#x27;programLanguage&#x27;);// 创建一个新节点var li_js = document.createElement(&#x27;li&#x27;);li_js.id = &#x27;python&#x27;;li_js.innerText = &#x27;javaScript&#x27;;// 插入到末尾ul_pl.appendChild(li_js); 创建一个新节点：&lt;li id=&quot;C++&quot;&gt;C++&lt;/li&gt; 插入到列 python 前。 12345678910var ul_pl = document.getElementById(&#x27;programLanguage&#x27;);var li_py = document.getElementById(&#x27;python&#x27;);// 创建一个新节点var li_cpp = document.createElement(&#x27;li&#x27;);li_cpp.id = &#x27;C++&#x27;;li_cpp.innerText = &#x27;C++&#x27;;// 插入到末尾ul_pl.insertBefore(li_cpp,li_py); 4. 删除DOM 要删除一个节点，首先要获得该节点本身以及它的父节点，然后调用父节点的removeChild()把自己删掉： 删除指定列表第三个节点。 123456var ul_pl = document.getElementById(&#x27;programLanguage&#x27;);// 获取列表第三个子节点var li3 = ul_pl.children[2];// 调用该付节点删除该子节点ul_pl.removeChild(li3); ⚠️ 注意： DOM树中节点虽然被删除，但是还在内存中，可以随时被添加到别的位置 children属性 实时变化，删除后父节点.chidren返回的列表会对应减少 5.3 操作表单 常用表单元素 &lt;form&gt; 元素定义 HTML 表单，收集用户输入 ：&lt;form&gt;... 表单元素...&lt;/form&gt; 。以下是常用表单元素： 常用表单元素 表单元素 描述 &lt;input&gt; 最重要的表单元素，含有不同类型的 input 元素 、复选框、单选按钮、提交按钮等。 &lt;select&gt; 定义下拉列表： &lt;textarea&gt; 定义多行输入文本域： &lt;button&gt; 按钮：点击后出发onclick事件代码，输出Hello World! 不同类型的 input 元素 ：有复选框、单选按钮、提交按钮等： 常用input类型 类型 描述 text 文本输入：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; password 密码输入：&lt;input type=&quot;password&quot; name=&quot;psw&quot;&gt; submit 提交表单按钮：&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; radio 单选按钮： ○Male ○Female （多个单选按钮组合成 多选一 ，name要相同） checkbox 复选框：□ I have a bike □ I have a car button 和前表单元素button类似，但没有后面&lt;/button&gt;： number 输入数值，并可对其作出限制： date 包含日期的输入字段： color 颜色选择器会出现输入字段： 更多输入类型：time（时间选择器）、datetime &amp; datetime-local（日期选择器）、search（搜索字段类似文本字段）、tel &amp; url &amp; email （可自动验证是否是电话、网址、邮箱地址） 操作表单 操作值 对于 text、password、hidden以及select 等直接value 获取、设置值即可： 12345// &lt;input type=&quot;text&quot; name = &quot;username&quot;&gt;var input = document.getElementsByName(&#x27;username&#x27;);input.value; // 用户输入值input.value = &quot;hello!&quot;; // 设置值 对于 radio 、checkbox，如果获取 value 始终是预设值，不能获取用户输入选择值。 应该用节点 checked属性判断用户选中： 1234567891011121314/*&lt;form&gt;&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; id=&quot;b&quot; value=&quot;Bike&quot;&gt;I have a bike&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; id=&quot;c&quot; value=&quot;Car&quot;&gt;I have a car &lt;/form&gt; */var bike = document.getElementsById(&#x27;b&#x27;);if(bike.checked)&#123; // do something&#125; bike.checked = false; // 设置按钮未被选中 提交表单 HTML 表单用于收集用户输入，比如下例收集用户输入的账号、密码验证登陆： 提交表单一般有如下三种方法： 通过 按钮提交 通过 form 对象 submit() 方法提交 ajax 方式提交 type=“submit” 表单提交 12345&lt;form action=&quot;demo_form.asp&quot; id=&quot;demo_form&quot; style=&#x27;text-align: center&#x27; method=&quot;GET&quot;&gt; &lt;p&gt;用户：&lt;input type=&quot;text&quot; id=&#x27;user&#x27; name=&#x27;user&#x27;&gt; &lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; id=&#x27;pwd&#x27; name = &#x27;pwd&#x27;&gt;&lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;立即登陆&quot; style=&#x27;width:210px&#x27;&gt; &lt;/form&gt; action 属性：定义提交表单执行的动作，如果省略则会被置为当前页面。在这里提交的表单值会交给脚本代码 demo_form.asp 处理。 method 属性：定义提交方式为GET 或者 POST 点击 立即登陆 按钮后，会自动把表单值提交给脚本文件 demo_form.asp 处理 。 服务器接收到的提交内容为（GET 方式提交）： 1user=hwh&amp;pwd=123456 ⚠️ 只有设置 name 属性的表单值才会被提交，提交的值构造方式为：name1:value1&amp;name2:value2… submit() 方法提交 可以通过：点击button、点击链接 等方式触发事件，js 调用form DOM对象submit() 方法提交表单数据。 ⚠️ 不推荐这种方式，扰乱了原有浏览器提交表单。 12345&lt;form action=&quot;demo_form.asp&quot; id=&quot;demo_form&quot; style=&#x27;text-align: center&#x27; method=&quot;GET&quot;&gt; &lt;p&gt;用户：&lt;input type=&quot;text&quot; id=&#x27;user&#x27; name=&#x27;user&#x27;&gt; &lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; id=&#x27;pwd&#x27; name = &#x27;pwd&#x27;&gt;&lt;/p&gt; &lt;input type=&quot;button&quot; id=&#x27;btn&#x27; value=&quot;立即登陆&quot; onclick=&quot;submitForm()&quot; style=&#x27;width:210px&#x27;&gt; &lt;/form&gt; 和前面 type=“submit” 表单提交方式 对比，type=“submit” 被修改为 —&gt; type=“button” button 按钮设置了属性 onclick ，绑定click 事件执行 submitForm() 函数。 12345var form = document.getElementById(&quot;demo_form&quot;);function submitForm()&#123; form.submit();&#125; 也可用 jQuery 实现 ： 123456789var form = $(&quot;#demo_form&quot;);var button = $(&quot;#btn&quot;);button.click( function() &#123; form.submit(); &#125;); 服务器接收到的提交内容为（GET 方式提交）： 1user=hwh&amp;pwd=123456 ajax 提交 ajax 方式提交需要先理解 5.5 AJAX 一节。 html 代码部分： 12345&lt;form action=&quot;&quot; id=&quot;demo_form&quot; style=&#x27;text-align: center&#x27; method=&quot;GET&quot;&gt; &lt;p&gt;用户：&lt;input type=&quot;text&quot; id=&#x27;user&#x27; name=&#x27;user&#x27;&gt; &lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; id=&#x27;pwd&#x27; name = &#x27;pwd&#x27;&gt;&lt;/p&gt; &lt;input type=&quot;button&quot; id=&#x27;btn&#x27; value=&quot;立即登陆&quot; onclick=&quot;submitForm()&quot; style=&#x27;width:210px&#x27;&gt; &lt;/form&gt; 点击登陆按钮，发送 ajax 请求 js 代码部分： 1234567891011121314function submitForm()&#123; // 创建对象 var xmlhttp = new XMLHttpRequest(); // 绑定onreadystatechange事件处理服务器响应 xmlhttp.onreadystatechange = function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) alert(xmlhttp.responseText) &#125; // 发送请求 xmlhttp.open(&quot;GET&quot;,&quot;/demo_form.asp&quot;,true); xmlhttp.send();&#125; 🙂 也可用 jQuery 实现 ajax 请求： 12345678910111213141516function submitForm()&#123; var userName = $(&#x27;#user&#x27;).val(); var password = $(&#x27;#pwd&#x27;).val(); $.ajax ( &#123; type: &quot;Get&quot;, url: &quot;/demo_form.asp&quot;, username: userName, password:password, dataType : &quot;json&quot;, success: function(respMsg)&#123;&#125; &#125; );&#125; 更多提交方式 更多提交方式，参考：六种提交 form 表单方式 5.4 操作文件 用到再提。 5.5 AJAX 什么是 AJAX ? 传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。 如何不重新加载界面更新内容？ AJAX = 异步 JavaScript 和 XML，可以实现网页异步更新，这意味着不重新加载网页而进行更新。 AJAX 应用实例 当我们使用百度搜索，在输入框输入搜索内容时，通过AJAX和服务器进行请求返回一列推荐搜索结果。在这个过程中，并没有重新加载界面。 那么在前端和服务器后台都是具体怎么实现沟通呢？这里以一个推荐姓名实例demo为例。 PART1 ： 前端html 前端 html 实现见下： 123456789101112131415&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot;&gt; // ajax部分... &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;请在下面的输入框中键入字母（A - Z）：&lt;/h3&gt;&lt;form action=&quot;&quot;&gt; 姓氏：&lt;input type=&quot;text&quot; id=&quot;txt1&quot; onkeyup=&quot;showHint(this.value)&quot; /&gt;&lt;/form&gt;&lt;p&gt;建议：&lt;span id=&quot;txtHint&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; PART2 ：前端 js 实现 AJAX 123456789101112131415161718192021222324// ajax部分...function success(res) &#123; console.log(&quot;拿到服务器成功响应结果：&quot; + res); &#125;function fail(res) &#123; console.log(&quot;拿到服务器失败响应结果：&quot; + res);&#125;function showHint(str)&#123; // 创建对象 var xmlhttp = new XMLHttpRequest(); // 绑定onreadystatechange事件处理服务器响应 xmlhttp.onreadystatechange = function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; success(xmlhttp.responseText); &#125; else &#123; fail(xmlhttp.responseText); &#125; &#125; // 发送请求 xmlhttp.open(&quot;GET&quot;,&quot;/ajax/gethint.asp?q=&quot;+str,true); xmlhttp.send();&#125; 以下细分ajax 执行过程： 创建对象 现代浏览器使用 XMLHttpRequest 对象 用于在后台与服务器交换数据： 1var xmlhttp=new XMLHttpRequest(); 对于IE5、6不得不使用 ActiveXObject 对象： 1var xmlhttp=new XMLHttpRequest(); 发送请求 如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() &amp; send() 方法： 方法 描述 open(method,url,async) 规定：请求的类型、URL处理脚本文件 、是否异步处理请求 send(string) 将请求发送到服务器：string 参数仅用于 POST 请求 12xmlhttp.open(&quot;GET&quot;,&quot;/ajax/gethint.asp?q=&quot;+str,true);xmlhttp.send(); 请求方法为GET 类型，在以下情况推荐使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 url = /ajax/gethint.asp?q= str ：/ajax/gethint.asp 是处理脚本通常为 ASP/PHP 文件 ；?q=str 是请求的参数，GET 方式必须向URL 添加信息。 true ：表示开启异步，XMLHttpRequest 对象如果要用于 AJAX 的话必须设置为 true 。 服务器响应 如需获得来自服务器的响应，使用 XMLHttpRequest 对象的 responseText 、 responseXML 属性： 属性 描述 responseText 获得字符串形式的响应数据 responseXML 获得 XML 形式的响应数据 同时，通过脚本和服务器交互过程，我们需要根据连接状态来触发执行操作。我们可以使用XMLHttpRequest 对象的 onreadystatechange 事件： 属性 描述 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 同前 responseText 、 responseXML 也是XMLHttpRequest 对象属性： 属性 描述 readyState 存有 XMLHttpRequest 的状态：从 0 --&gt; 4 发生变化 status 200: “OK” 404: 未找到页面 对应实际代码为： 1234567891011xmlhttp.onreadystatechange = function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; success(xmlhttp.responseText); &#125; else &#123; fail(xmlhttp.responseText); &#125;&#125; PART3 ：服务器端*.ASP* 脚本 以下为 gethint.asp 文件，根据用户输入字母返回推荐的名字： 🙂 当然你也可以用 PHP 实现，这里从略。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;%response.expires=-1dim a(30)&#x27;用名字来填充数组a(1)=&quot;Anna&quot;a(2)=&quot;Brittany&quot;a(3)=&quot;Cinderella&quot;a(4)=&quot;Diana&quot;a(5)=&quot;Eva&quot;a(6)=&quot;Fiona&quot;a(7)=&quot;Gunda&quot;a(8)=&quot;Hege&quot;a(9)=&quot;Inga&quot;a(10)=&quot;Johanna&quot;a(11)=&quot;Kitty&quot;a(12)=&quot;Linda&quot;a(13)=&quot;Nina&quot;a(14)=&quot;Ophelia&quot;a(15)=&quot;Petunia&quot;a(16)=&quot;Amanda&quot;a(17)=&quot;Raquel&quot;a(18)=&quot;Cindy&quot;a(19)=&quot;Doris&quot;a(20)=&quot;Eve&quot;a(21)=&quot;Evita&quot;a(22)=&quot;Sunniva&quot;a(23)=&quot;Tove&quot;a(24)=&quot;Unni&quot;a(25)=&quot;Violet&quot;a(26)=&quot;Liza&quot;a(27)=&quot;Elizabeth&quot;a(28)=&quot;Ellen&quot;a(29)=&quot;Wenche&quot;a(30)=&quot;Vicky&quot;&#x27;获得来自 URL 的 q 参数q=ucase(request.querystring(&quot;q&quot;))&#x27;如果 q 大于 0，则查找数组中的所有提示if len(q)&gt;0 then hint=&quot;&quot; for i=1 to 30 if q=ucase(mid(a(i),1,len(q))) then if hint=&quot;&quot; then hint=a(i) else hint=hint &amp; &quot; , &quot; &amp; a(i) end if end if nextend if&#x27;如果未找到提示，则输出 &quot;no suggestion&quot;&#x27;否则输出正确的值if hint=&quot;&quot; then response.write(&quot;no suggestion&quot;)else response.write(hint)end if%&gt; jQuery &amp; ajax jQuery 提供了对JavaScript ajax 高度的封装API ，常用方法如下： 函数 描述 $.ajax({name:val, name:val,…}) 常用于其他jQuery Ajax方法不能完成的请求 $.post(url, data, func, dataType) POST方式执行Ajax请求，从服务器加载数据。 $.get(url, data, func, dataType) GET方式执行Ajax请求，从服务器加载数据。 $.getJSON(url, data, func) GET方式从服务器加载JSON格式数据。相较于$.get()不必再指定dataType $.load(url, data, func) POST方式将服务器加载的数据插入指定DOM中，data不存在则以GET方式 $.getScript(url, func) GET方式执行Ajax请求，从服务器加载并执行回传的JavaScript。 注：上述方法 func 都是指在方法完成后执行的回调（callback）函数 。 格式：func(data, status, xhr) 参数：data — 服务器返回数据；status — 响应状态 ；xhr – XMLHttpRequest对象。一般关注 data 即可。 $.ajax() .ajax()∗完整参数形式为：∗.ajax()* 完整参数形式为：*.ajax()∗完整参数形式为：∗.ajax({name:val, name:val,…}) ，其参数为一个对象 {} ，可选字段为： url：链接地址，字符串表示 data：需发送到服务器的数据，GET、POST都可以，格式为 {A: ‘…’, B: ‘…’} type：指定请求类型为：“POST” 或 “GET” timeout：请求超时时间 / 毫秒 cache：是否缓存请求结果，bool表示 contentType：内容类型，默认为 “application/x-www-form-urlencoded” dataType：服务器响应的数据类型，字符串表示 success：请求成功后，服务器回调的函数 error：请求失败后，服务器回调的函数 complete：请求完成后调用的函数，无论请求是成功还是失败，都会调用该函数；如果设置了success与error函数，则该函数在它们之后被调用 async：是否异步处理，bool表示，默认为true；设置该值为false后，JS不会向下执行，而是原地等待服务器返回数据，并完成相应的回调函数后，再向下执行 username：访问认证请求中携带的用户名，字符串表示 password：返回认证请求中携带的密码，字符串表示 下面通过 $.ajax() 方法请求服务器加载一个txt文本。 html代码部分： 123456789101112&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;myDiv&quot;&gt;&lt;h2&gt;通过 AJAX 改变文本&lt;/h2&gt;&lt;/div&gt;&lt;button id=&quot;b01&quot; type=&quot;button&quot;&gt;点我加载txt&lt;/button&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;// ajax实现部分...&lt;/script&gt;&lt;/html&gt; 1234567891011// ajax实现部分...$(&quot;#b01&quot;).click(function()&#123; htmlobj=$.ajax (&#123; url:&quot;/jquery/test1.txt&quot;, type:&quot;GET&quot;, async:false &#125;); $(&quot;#myDiv&quot;).html(htmlobj.responseText);&#125;); 点击后显示： 回调函数 也可使用回调函数，如果成功就显示： 1234567891011// ajax实现部分...$(&quot;#b01&quot;).click(function()&#123; htmlobj=$.ajax (&#123; url:&quot;/jquery/test1.txt&quot;, type:&quot;GET&quot;, async:false, success:function(data)&#123; $(&quot;#myDiv&quot;).html(data); &#125; &#125;); &#125;); 回调函数success有参数 data ，接收服务器返回数据，这里接收的是文本：test1.txt 。 也可以使用链式调用回调函数，类似前面 Promise ： 12345678910111213// ajax实现部分...$(&quot;#b01&quot;).click(function()&#123; htmlobj=$.ajax (&#123; url:&quot;/jquery/test1.txt&quot;, type:&quot;GET&quot;, async:false &#125;) .done(function(data)&#123; $(&quot;#myDiv&quot;).html(data); &#125;) .fail(function (xhr,status)&#123; $(&quot;#myDiv&quot;).html(&#x27;失败:&#x27;+xhr.status+&#x27;原因:&#x27;+ status);&#125;) .always(function () &#123; alert(&#x27;请求完成: 无论成功或失败都会调用&#x27;);&#125;);&#125;); $.get() 简单的 GET 请求功能以*.get()∗取代复杂∗.get()* 取代复杂 *.get()∗取代复杂∗.ajax()* ，请求成功时可调用回调函数。 其格式为：$.get(url, data, func, dataType) url：链接地址，字符串表示 data：需要发生到服务器的数据，以键值对形式 func(data, status, xhr)：回调函数，data — 服务器返回数据；status — 响应状态 ；xhr – XMLHttpRequest对象。一般关注 data 即可。 dataType：服务器返回数据的格式 以*$.get()* 实现上述点击按钮加载指定文本。 123456789// ajax实现部分...$(&quot;#b01&quot;).click(function()&#123; htmlobj=$.get(&quot;/jquery/test1.txt&quot; ,function(data,status) &#123; $(&quot;#myDiv&quot;).html(data); &#125;); &#125;); 回调函数function(data,status) 参数data、status 分别接收服务器返回的数据、状态。 点击后显示： ⚠️ 经过测试，似乎只能在回调函数里接收数据，像*$.ajax()* 一样用responseText 获取返回数据不成功： 123456// ajax实现部分...$(&quot;#b01&quot;).click(function()&#123; htmlobj=$.get(&quot;/jquery/test1.txt&quot;); $(&quot;#myDiv&quot;).html(htmlobj.responseText); // 点击按钮加载数据不成功？？！&#125;); $.post() 和 $.get() 类似，接收参数一致，除了请求方式变为了 post 方式。 其格式为：$.post(url, data, func, dataType) 向指定界面发送 HTTP POST 请求，并获得返回的结果 。 12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt;&lt;script src=&quot;/jquery/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body style=&quot;text-align: center&quot;&gt;&lt;p&gt; 姓名：&lt;input id=&#x27;user&#x27;&gt; &lt;/p&gt;&lt;p&gt; 城市：&lt;input id=&#x27;city&#x27;&gt; &lt;/p&gt;&lt;button&gt;发送 POST 请求，获取返回结果 &lt;/button&gt;&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;$(&quot;button&quot;).click(function()&#123; $.post(&quot;/example/jquery/demo_test_post.asp&quot;, &#123; name:$(&#x27;#user&#x27;).val(), city:$(&#x27;#city&#x27;).val() &#125;, function(data,status) &#123; $(&#x27;#myDiv&#x27;).html(&quot;数据：&quot; + data + &quot;&lt;br&gt;状态：&quot; + status); &#125;);&#125;);&lt;/script&gt;&lt;/html&gt; $.load() $.load() 如果数据存在则以 POST 方式（不存在则以 GET 方式）加载服务器返回的数据到 指定 DOM 节点中 。 其格式为：$(selector).load(URL,data,func)。 举个例子 依旧以上 $.post() 所举实例为例，加载服务器返回的结果到指定节点中。 123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt;&lt;script src=&quot;/jquery/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body style=&quot;text-align: center&quot;&gt;&lt;p&gt; 姓名：&lt;input id=&#x27;user&#x27;&gt; &lt;/p&gt;&lt;p&gt; 城市：&lt;input id=&#x27;city&#x27;&gt; &lt;/p&gt;&lt;button&gt;发送 POST 请求，获取返回结果 &lt;/button&gt;&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;$(&quot;button&quot;).click(function()&#123; $(&#x27;#myDiv&#x27;).load(&quot;/example/jquery/demo_test_post.asp&quot;, &#123; name:$(&#x27;#user&#x27;).val(), city:$(&#x27;#city&#x27;).val() &#125; );&#125;);&lt;/script&gt;&lt;/html&gt; 上面会将返回的结果自动加载到指定节点 #myDiv 中，当然你也可以使用回调函数来自定义加载： 1234567891011121314$(&quot;button&quot;).click(function()&#123; $(&#x27;#myDiv&#x27;).load(&quot;/example/jquery/demo_test_post.asp&quot;, &#123; name:$(&#x27;#user&#x27;).val(), city:$(&#x27;#city&#x27;).val() &#125;, function(data,status,xhr) &#123; $(&#x27;#myDiv&#x27;).html(&quot;数据：&quot; + data + &quot;&lt;br&gt;状态：&quot; + status); &#125; );&#125;); 回调函数参数意义同前，显示结果为： 再举个例子 也可直接加载url 指定资源，不用传递其它参数。 点击按钮后，指定节点直接加载 demo_test.txt 文件内容。 1234567891011121314151617&lt;html&gt;&lt;head&gt;&lt;script src=&quot;/jquery/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 id=&quot;test&quot;&gt;请点击下面的按钮，通过 jQuery AJAX 改变这段文本。&lt;/h3&gt;&lt;button id=&quot;btn1&quot; type=&quot;button&quot;&gt;获得外部的内容&lt;/button&gt;&lt;/body&gt;&lt;script&gt; $(&quot;#btn1&quot;).click(function() &#123; $(&#x27;#test&#x27;).load(&#x27;/example/jquery/demo_test.txt&#x27;); &#125;);&lt;/script&gt;&lt;/html&gt; 点击后显示： 5.6 Promise 初识 Promise 先不理会那些复杂的概念，我们来直观了解下 Promise 是什么： 很容易得知，Promise 原来是一个构造函数： 在自己身上有 all()、reject()、resolve() 等方法 在原型上有 then()、catch() 等方法，then() 返回一个 Promise 对象。 那么 new Promise() 出来的对象自然也拥有以上方法。 举个栗子 原生 JavaScript 执行异步 在 JavaScript 世界里，所有代码都是单线程执行。因此 JavaScript 所有网络操作、浏览器事件都必须异步执行。 也就是说，在某个时间点，会执行某个函数。然后根据函数状态执行不同的处理函数，也就是常说的回调函数。 如，生成一个0-2之间的随机数，如果小于1，则等待1s后返回成功，否则返回失败。 123456789101112131415161718192021function success(str)&#123; console.log(str); &#125;function fail(str) &#123; console.log(str); &#125;function test()&#123; var timeOut = Math.random() * 2; log(&#x27;set timeout to: &#x27; + timeOut + &#x27; seconds.&#x27;); setTimeout(function () &#123; if (timeOut &lt; 1) &#123; success(&#x27;成功：生成随机数小于1&#x27;); &#125; else &#123; fail(&#x27;失败：生成随机数大于1&#x27;); &#125; &#125;, 1000);&#125;test(); 本文中所有异步操作均以 setTimeout为例子，而不使用 ajax 。 可以看到，执行test() —&gt; 延迟1s后执行匿名判断函数 —&gt; 根据判断结果执行回调函数：success() 、fail() 。 Promise 执行异步 如果我们用 Promise 对象来执行可以达到相同效果： 123456789101112131415161718192021222324252627282930313233function test(resolve, reject) &#123; var timeOut = Math.random() * 2; setTimeout(function () &#123; if (timeOut &lt; 1) &#123; var date = &#x27;生成随机数小于1&#x27;; resolve(date); // 传递参数date给Promise对象.then方法内部匿名函数参数 &#125; else &#123; var date = &#x27;生成随机数大于1&#x27;; reject(date); // 传递参数date给Promise对象.catch方法内部匿名函数参数 &#125; &#125;, 1000);&#125;var p1 = new Promise(test);var p2 = p1.then( function (result) &#123; console.log(&#x27;成功：&#x27; + result); // 如果执行成功输出：&#x27;成功：生成随机数小于1&#x27; &#125;);var p3 = p2.catch( function (reason) &#123; console.log(&#x27;失败：&#x27; + reason); // 如果执行失败输出：&#x27;失败：生成随机数大于1&#x27; &#125;); 咋看之下首先方法 function test(…) 和之前没什么区别，只不过多了两个函数参数 resolve, reject ，替换了之前回调函数 success、fail 在接下来代码中位置，整体逻辑没有变化。 resolve, reject 可以分别将 Promise 状态置为：fullfiled、 rejected resolve, reject 还可将自身的接收的参数（本例为date） ，分别传给then、catch 方法（见下） 只不过在下面多了一层对 test() 的封装：创建一个 Promise 对象，传递一个函数作为参数，承诺一定执行。 1var p1 = new Promise(test); 紧接着根据此时 Promise 状态是fullfiled、 rejected 执行 then() 还是 catch() 方法。 比如，随机数&lt;1 —&gt; 执行resolve() —&gt; Promise 状态为fullfiled ----&gt; 执行 then() 方法： 1234567var p2 = p1.then( function (result) &#123; console.log(&#x27;成功：&#x27; + result); // 如果执行成功输出：&#x27;成功：生成随机数小于1&#x27; &#125;); then(func) 参数为一个函数，同时它也拿到了resolve(date) 的参数date ，赋值给了result （我是这么理解的的）。 所以如果执行会打印出： 同理，随机数&gt;1 —&gt; 执行reject() —&gt; Promise 状态为 rejected ----&gt; 执行 catch() 方法： 1234567var p3 = p2.catch( function (reason) &#123; console.log(&#x27;失败：&#x27; + reason); // 如果执行失败输出：&#x27;失败：生成随机数大于1&#x27; &#125;); Promise 对象可以串联起来，所以上述代码可以简化为： 12new Promise(test).then (function (result)&#123; console.log(&#x27;成功：&#x27; + result); &#125; .catch(function (reason)&#123; console.log(&#x27;失败：&#x27; + reason); &#125; 这就完了？ 看到这儿你可能不屑一顾，这么传的神乎其神的 Promise 就这点能耐？把原来好好的 test() 方法，整两个参数然后用 Promise 封装一下就没了？ 当然，看到这你也可能发现了 Promise 其中一个优点：执行代码和处理结果的代码清晰地分离 。 比如上面：执行代码 test() 只负责整体逻辑传递数据，而处理代码接收数据进行处理由then() 、 catch() 完成。 更大优点，是用 Promise 处理多个异步操作，请看下节。 更正确的使用Promise姿势：处理多异步 试想有多个异步任务函数，job1、job2、job3…： 执行job1，job1执行成功 —&gt; 执行job2，job2执行成功 —&gt; 执行job3，job3执行成功 —&gt; … 显然job1成了一个多层回调函数，job2执行完成后也有相应回调函数job3执行，job3有回调函数job4… 如果不使用 Promise 意味着我们要层层嵌套 job1、job2、job3…。这既不易读，也不灵活，而我们使用 Promise 后 可以将代码简写为： 1p.then(job1).then(job2).then(job3).then...; 分别实现异步函数job1_add1、job2_mul2、job3_div3 依次对数字0进行 *+1、2、/3： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 新建一个Promise对象var p = new Promise(function (resolve, reject) &#123; resolve(0); // 传递数据：数字0&#125;);// job1任务：将传过来的数字加1,这里传过来的数字是0function job1_add1(num)&#123; /* 为什么返回 Promise 对象？ 首先我们要知道，setTimeout共有四个参数，后面两个参数会传入回调函数（这里是resolve） 我们知道，resolve参数可以被then方法拿到，这样在接下来的then方法可以获取到传递的参数: p.then(job1_add1).then(job2_mul2).then(job3_div3) 你也可以直接传递数据而非Promise对象，后面then也可以接收到： return num+1; */ console.log(&#x27;计算：&#x27;+ num + &#x27; + 1&#x27;); return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, num + 1); &#125;);&#125;// job2任务：将传过来的数字×2，这里传过来的是0+1 = 1function job2_mul2(num)&#123; console.log(&#x27;计算：&#x27;+ num + &#x27; * 2&#x27;); return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, num * 2); &#125;);&#125;// job2任务：将传过来的数字÷3，这里传过来的是 (0+1)*2 = 2function job3_div3(num)&#123; console.log(&#x27;计算：&#x27;+ num + &#x27; / 3&#x27;); return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 400, num / 3); &#125;);&#125;// 执行多异步任务p.then(job1_add1).then(job2_mul2).then(job3_div3); 执行结果： 更多有关 Promise 除了前面提到 then、catch 方法，Promise 还提供了静态 方法 all、race 等。 all() 方法 Promise 的all(PromiesArr) 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。 由于可以在一个回调中处理所有返回数据，这样比如在打开网页，预先加载需要用到的所有资源如图片等，等全部加载完在执行回调。 依旧以上面异步函数job1_add1、job2_mul2、job3_div3 为例： 异步执行三个异步函数，分别将各自传递的参数值进行：+1、*2、/3。 12345Promise.all([job1_add1(1),job2_mul2(2),job3_div3(3)]) .then(function(results) &#123; console.log(results); &#125;); 三个异步操作都执行完毕后，all(PromiesArr) 会把它们返回的数据组成数组传给 then()，也就是上面results。 注意是传递 Promise 对象数组，而非函数，下面这种写法错误： 1Promise.all([job1_add1,job2_mul2,job3_div3]) 这是传递的参数是函数数组，而非Promise对象 数组。只有函数都执行后才是Promise对象数组（job1_add1、job2_mul2、job3_div3 返回Promise对象）。 所以，all() 不能实现前面三个异步操作结果交互依次进行：+1、*2、/3，因为传递的参数值被写死了，它们不存在嵌套关系，更何况论传值了。 最后执行的结果为： race() 方法 有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现： 123456789101112var p1 = new Promise(function (resolve, reject)&#123; setTimeout(resolve, 500, &#x27;P1&#x27;);&#125;);var p2 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, &#x27;P2&#x27;);&#125;);Promise.race([p1, p2]).then(function (result) &#123; console.log(result); // &#x27;P1&#x27;&#125;); 练习：将AJAX 异步执行函数转为 Promise 对象 在前我们举个ajax应用实例：根据用户输入字母，触发showHint 方法ajax 方式请求服务器返回推荐姓名。 其中 ajax 实现部分见下： 123456789101112131415161718192021222324// ajax部分...function success(res) &#123; console.log(&quot;拿到服务器成功响应结果：&quot; + res); &#125;function fail(res) &#123; console.log(&quot;拿到服务器失败响应结果：&quot; + res);&#125;function showHint(str)&#123; // 创建对象 var xmlhttp = new XMLHttpRequest(); // 绑定onreadystatechange事件处理服务器响应 xmlhttp.onreadystatechange = function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; success(xmlhttp.responseText); &#125; else &#123; fail(xmlhttp.status); &#125; &#125; // 发送请求 xmlhttp.open(&quot;GET&quot;,&quot;/ajax/gethint.asp?q=&quot;+str,true); xmlhttp.send();&#125; 现要求：将ajax 异步执行函数*showHint()*转换为 Promise 对象简化异步处理。 最开始，我用Promise 对象直接封装 showHint： 123456789101112131415161718192021222324function showHint(str) // 参数不对，应该为 function showHint(resolve, reject)&#123; // 创建对象 var xmlhttp = new XMLHttpRequest(); // 绑定onreadystatechange事件处理服务器响应 xmlhttp.onreadystatechange = function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; resolve(xmlhttp.responseText); &#125; else &#123; reject(xmlhttp.status); &#125; &#125; // 发送请求 xmlhttp.open(&quot;GET&quot;,&quot;/ajax/gethint.asp?q=&quot;+str,true); xmlhttp.send();&#125;var p = new Promise(showHint);p.then (function(res)&#123; console.log(&quot;拿到服务器成功响应结果：&quot; + res);&#125;) .catch(function(res)&#123; console.log(&quot;拿到服务器失败响应结果：&quot; + res);&#125;); 但是这样有一个问题：function showHint(str){…} 参数不对，应该为： 1234function showHint(resolve, reject)&#123; ....&#125; 否则无法在后面使用 resolve、reject 函数！但是这样又无法使用函数自带 str 参数，所以解决办法为：把函数showHint 内部需要判断执行不同回调函数的部分，包装成 Promise对象返回： 123456789101112131415161718192021222324var p;function showHint(str) // 参数不对，应该为 function showHint(resolve, reject)&#123; // 创建对象 var xmlhttp = new XMLHttpRequest(); // 绑定onreadystatechange事件处理服务器响应 p = new Promise( function(resolve,reject) &#123; xmlhttp.onreadystatechange = function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; resolve(xmlhttp.responseText); &#125; else &#123; reject(xmlhttp.responseText); &#125; &#125; &#125;); // 发送请求 xmlhttp.open(&quot;GET&quot;,&quot;/ajax/gethint.asp?q=&quot;+str,true); xmlhttp.send();&#125; 这样就可以使用resolve、reject 函数了，然后再让返回的Promise对象执行 then 、catch ： 12p.then (function(res)&#123; console.log(&quot;拿到服务器成功响应结果：&quot; + res);&#125;) .catch(function(res)&#123; console.log(&quot;拿到服务器失败响应结果：&quot; + res);&#125;); 第六章：jQuery 6.1 选择器 在前 5.2节 介绍了： 获取DOM 节点：getElementby…() 方法 OR CSS 层级选择器 操作DOM 节点 通过 innerText、innerHtml 属性修改节点文本 通过 style 属性修改CSS 样式 通过 appendChild() 、insertBefore() 、*removeChild()*方法插入、删除节点 jQuery 提供获取DOM 节点方法 本质是 CSS 层级选择器 语法，不再赘述。但是还特别提供 find()、filter()、map() 方法进行查找和过滤，详见下。 查找和过滤 123456&lt;ul id=&quot;programLanguage&quot;&gt; &lt;li id=&quot;C#&quot;&gt;C#&lt;/li&gt; &lt;li id=&quot;C&quot;&gt;C&lt;/li&gt; &lt;li id=&quot;python&quot;&gt;python&lt;/li&gt; &lt;li id=&quot;java&quot;&gt;java&lt;/li&gt; &lt;/ul&gt; find()、next()、prev()、parent() 在前面我们知道怎么获取一个节点，但是如果获取一个节点后，还想获取它的子、兄弟、父节点呢？ jQuery 为我们提供了 find()、next()、prev() 方法来做到这一点： 123456789101112// find()var C = $(&#x27;#programLanguage&#x27;).find(&#x27;#C&#x27;);C.text(); // 输出: C// parent()var pl = C.parent(); pl; // 节点：ul#programLanguage// next()、prev()C.next(); // 节点：li#pythonC.prev(); // 节点：li#C# first()、last() 如果我们获取到一个节点数组，对节点数组的操作和普通数组操作有什么不同吗？ 普通数组可以使用的API方法和jQuery 对象提供的API多有不同，不可混为一谈，以下是常用一些方法： 12345var lis = $(&#x27;#programLanguage li&#x27;);lis.first(); // 获取第一个节点，等价于：#programLanguage li:first-childlis.last(); // 获取最后一个节点，等价于：#programLanguage li:last-childlis.slice(0, 2); // 输出：[C#,C], 数组的slice()方法一致 更多方法以后用到再提。 filter()、map() filter()、map() 和我们前介绍的高阶函数类似。 通过 filter() 过滤出 ’C‘ 开头编程语言。 123456789101112131415161718192021// filter()过滤符合条件的原对象数组元素// 返回：数组 var lis = $(&#x27;#programLanguage li&#x27;);var firstIsC = lis.filter( /* 过滤条件；首字母为C 注意：此时是DOM节点对象不是jQuery对象 why? 直接箭头函数this绑定window */ // () =&gt; this.innerHTML.indexOf(&#x27;C&#x27;) === 0 function() &#123; return this.innerHTML.indexOf(&#x27;C&#x27;) === 0; &#125;);// 输出测试firstIsC ; // jQuery.fn.init(2) [li#C#, li#C, prevObject: jQuery.fn.init(4)] 通过 map() 遍历返回所有对象节点文本。 12345678910111213// map()// 遍历所有对象元素返回一个数组var lis = $(&#x27;#programLanguage li&#x27;);var texts = lis.map( function() &#123; return this.innerHTML; &#125;);// 输出测试texts; // [&quot;C#&quot;, &quot;C&quot;, &quot;python&quot;, &quot;java&quot;] 综合练习 123456789101112131415161718&lt;form id=&quot;test-form&quot; action=&quot;#0&quot; onsubmit=&quot;return false;&quot;&gt; &lt;p&gt;&lt;label&gt;Name: &lt;input name=&quot;name&quot;&gt;&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;Email: &lt;input name=&quot;email&quot;&gt;&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/label&gt;&lt;/p&gt; &lt;p&gt;Gender: &lt;label&gt;&lt;input name=&quot;gender&quot; type=&quot;radio&quot; value=&quot;m&quot; checked&gt; Male&lt;/label&gt; &lt;label&gt;&lt;input name=&quot;gender&quot; type=&quot;radio&quot; value=&quot;f&quot;&gt; Female&lt;/label&gt; &lt;/p&gt; &lt;p&gt;&lt;label&gt;City: &lt;select name=&quot;city&quot;&gt; &lt;option value=&quot;BJ&quot; selected&gt;Beijing&lt;/option&gt; &lt;option value=&quot;SH&quot;&gt;Shanghai&lt;/option&gt; &lt;option value=&quot;CD&quot;&gt;Chengdu&lt;/option&gt; &lt;option value=&quot;XM&quot;&gt;Xiamen&lt;/option&gt; &lt;/select&gt; &lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; 输入值后，用 jQuery 获取表单的 JSON 字符串，如：&#123;&quot;name&quot;:&quot;Michael&quot;,&quot;email&quot;:...&#125;。 12345678910111213141516171819202122232425var obj = &#123;&#125;;// 限定状态:input 可获取：&lt;input&gt;，&lt;textarea&gt;，&lt;select&gt;和&lt;button&gt; 元素$(&#x27;#test-form :input&#x27;).filter( function() &#123; // 过滤节点数组中：未选中的radio单选框节点和submit按钮节点 // this是DOM对象，获取节点属性type、checked等 var isNotChecked = this.type === &#x27;radio&#x27; &amp;&amp; !this.checked; if( isNotChecked || this.type === &#x27;submit&#x27;) return false; else return true; &#125;).map( function() &#123; // select元素可直接获取name属性和选中的值 return obj[this.name] = this.value; &#125;)json = JSON.stringify(obj,null,&#x27; &#x27;); 6.2 jQuery 操作 DOM 修改 Text &amp; HTML jQuery 对象提供了 text()、html() 方法来获取节点文本和HTML文本，例如以下HTML结构： 123456&lt;ul id=&quot;programLanguage&quot;&gt; &lt;li id=&quot;C#&quot;&gt;C#&lt;/li&gt; &lt;li id=&quot;C&quot;&gt;C&lt;/li&gt; &lt;li id=&quot;python&quot;&gt;python&lt;/li&gt; &lt;li id=&quot;java&quot;&gt;java&lt;/li&gt; &lt;/ul&gt; 分别获取文本和HTML： 12$(&#x27;#C&#x27;).html(); // C$(&#x27;#C&#x27;).text(); // C 设置文本 &amp; HTML，只需给text()、html() 方法传递参数即可： 1$(&#x27;#C&#x27;).text(&#x27;我是西语言&#x27;); // 我是西语言 特别巧妙的是，jQuery 可以给选中多个节点设置文本、CSS、属性等，具有 批量操作 特点： 123456// docment对象不具有 批量操作 特点document.getElementsByTagName(&#x27;li&#x27;).innerText = &#x27;test&#x27;; // 设置不成功，节点内容未被改变document.querySelectorAll(&#x27;li&#x27;).innerText = &#x27;test&#x27;; // 设置不成功，节点内容未被改变// jQuery对象具有 批量操作 特点$(&#x27;li&#x27;).text(&#x27;test&#x27;); // 设置成功，所有li节点文本被设置 &#x27;test&#x27; 修改CSS 同前，也可用 CSS() 方法获取、修改CSS样式，也具有 批量操作 特点，关于该特点以下不再赘述。 获取CSS样式： 1$(&#x27;li&#x27;).css(&#x27;color&#x27;); // &quot;rgb(0, 0, 0)&quot; 设置CSS样式： 1$(&#x27;li&#x27;).css(&#x27;color&#x27;,&#x27;red&#x27;); // 文本全变为红色 清除CSS样式： 1$(&#x27;li&#x27;).css(&#x27;color&#x27;,&#x27;&#x27;); // 等价把该属性设置为空即可 显示和隐藏DOM 隐藏DOM节点，注意DOM树结构没有被改变： 1$(&#x27;li&#x27;).hide(); // 对应CSS设置：display = none; 显示DOM节点： 1$(&#x27;li&#x27;).show(); // 对应CSS设置：display = inline; 或者 display = block; 修改DOM信息 节点宽高：width()、heigth() 获取宽高： 12$(&#x27;li&#x27;).width(); // 1860$(&#x27;li&#x27;).heigth(); // 21.5126 ⚠️ 经过测试，多个标签显示的是其中一个标签宽高？ 12$(&#x27;#C&#x27;).width(); // 1860$(&#x27;#C&#x27;).heigth(); // 21.5126 设置宽高： 12$(&#x27;#C&#x27;).width(400); $(&#x27;#C&#x27;).heigth(1800); 节点属性：attr() 、removeAttr() 获取属性，不存在返回 undefined： 123$(&#x27;#C&#x27;).attr(&#x27;id&#x27;); // C$(&#x27;li&#x27;).attr(&#x27;id&#x27;); // C#，多个节点返回第一个节点指定属性值$(&#x27;#C&#x27;).attr(&#x27;name&#x27;); // undefined，不存在返回undefined 设置属性，类似CSS() 方法： 1$(&#x27;#C&#x27;).attr(&#x27;name&#x27;,&#x27;iamC&#x27;); // &lt;li id=&quot;C&quot; name=&#x27;iamC&#x27;&gt;C&lt;/li&gt; 删除属性： 1$(&#x27;#C&#x27;).removeAttr(&#x27;name&#x27;); 特别的，关于一些属性只有出现和没出现两种情况判断，如： checked、selected 。 对于以下HTML结构： 1&lt;input id=&quot;test-radio&quot; type=&quot;radio&quot; name=&quot;test&quot; checked=&quot;checked&quot; value=&quot;1&quot;&gt; 如果使用attr() 获取 checked 属性： 1$(&#x27;#test-radio&#x27;).attr(&#x27;checked&#x27;); // &#x27;checked&#x27; 虽然正确返回了属性值，但是 checked 属性只有[被选中]、[未被选中]两种情况，用 true、false返回更好： 1$(&#x27;#test-radio&#x27;).is(&#x27;:checked&#x27;); // true,用is()方法判断更好 ⚠️ 不知道为什么有时候 attr 设置选中无效，建议使用 prop 方法： 12$(&#x27;#test_checkbox&#x27;).attr(&#x27;checked&#x27;,&#x27;checked&#x27;); // 选中无效？$(&#x27;#test_checkbox&#x27;).prop(&#x27;checked&#x27;,true); // 可选中 selected 等同理不再赘述。 修改DOM结构 添加节点 如果我们要在以下 ul 节点添加子节点 &lt;li id=&quot;python&quot;&gt;python&lt;/li&gt;： 1234&lt;ul id=&quot;programLanguage&quot;&gt; &lt;li id=&quot;C#&quot;&gt;C#&lt;/li&gt; &lt;li id=&quot;C&quot;&gt;C&lt;/li&gt;&lt;/ul&gt; jQuery 虽然提供了html() 方法，但是会修改 ul 节点所有节点。 为此我们可以利用以下方法： 方法名 用法 append(newElem) 添加子节点newElem 为当前父节点对象 最后一个子节点 prepend(newElem) 添加子节点newElem 为当前父节点对象 第一个子节点 如果是同级节点对象，还可以用： 方法名 用法 after(newElem) 添加子节点newElem 为当前节点对象 下一个兄弟子节点 before(newElem) 添加子节点newElem 为当前节点对象 前一个兄弟子节点 将 python 新节点添加为ul 列表最后一个新节点。 父节点对象方法： 12var pl = $(&#x27;#programLanguage&#x27;);pl.append(&#x27;&lt;li id=&quot;python&quot;&gt;python&lt;/li&gt;&#x27;); 同级节点对象方法： 12var last = $(&#x27;#programLanguage li:last-child&#x27;);last.after(&#x27;&lt;li id=&quot;python&quot;&gt;python&lt;/li&gt;&#x27;); 删除节点 方法名 用法 remove() 删除当前节点对象，可作用于多个节点对象。 删除所有列表项。 1$(&#x27;li&#x27;).remove(); // 所有&lt;li&gt;被删除 综合测试 对于以下html 结构：除了列出语言外，请再添加 Pascal、Lua 、Ruby，然后按字母顺序排序节点。 1234567&lt;div id=&quot;test-div&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123456789101112131415161718192021var language = [&#x27;Pascal&#x27;,&#x27;Lua&#x27;,&#x27;Ruby&#x27;];var ul = $(&#x27;#test-div ul&#x27;);for(var i = 0; i &lt; language.length; i++ )&#123; ul.append(&#x27;&lt;li&gt;&lt;span&gt;&#x27; + language[i] + &#x27;&lt;/span&gt;&lt;/li&gt;&#x27;);&#125;// 获取所有li标签排序var lis = ul.find(&#x27;li&#x27;);lis.sort( function(x,y) &#123; // 不是jQuery对象，而是DOM对象？不能用x.text() &gt; y.text() if(x.innerText &gt; y.innerText) return 1; else return -1; &#125;);// 添加已排序好的li标签ul.html(lis); 表单输入框值 对于表单元素，jQuery 统一用val() 方法获取 DOM 对象 value 属性，统一输入框取值和赋值问题： 方法名 用法 val() 无参数获取文本框值；有参数设置文本框值。 对于以下 html 结构： 1 尝试对以上不同 input 类型输入框值操作。 123456789// 获取输入框值$(&#x27;#test-input&#x27;).val(); // &#x27;test&#x27;$(&#x27;#test-select&#x27;).val(); // &#x27;BJ&#x27;$(&#x27;#test-textarea&#x27;).val(); // &#x27;Hello&#x27;// 设置输入框值$(&#x27;#test-input&#x27;).val(&#x27;abc@example.com&#x27;); // 文本框的内容已变为abc@example.com$(&#x27;#test-select&#x27;).val(&#x27;SH&#x27;); // 选择框已变为Shanghai$(&#x27;#test-textarea&#x27;).val(&#x27;Hi&#x27;); // 本区域已更新为&#x27;Hi&#x27; 对应docment 对象 value 属性： 1document.querySelector(&#x27;#test-input&#x27;).value = &#x27;abc@example.com&#x27;; 不要尝试用 attr() 方法 1&lt;p&gt;用户名：&lt;input type=&quot;text&quot; id=&#x27;user&#x27;&gt; &lt;/p&gt; attr() 方法是用来获取、设置属性，用于文本框会导致意想不到的错误： 1$(&#x27;#user&#x27;).attr(&#x27;value&#x27;,&#x27;hwh&#x27;); // 成功设置文本框值为:&#x27;hwh&#x27; 但是当我们重新修改文本框值为：‘lt’，再去尝试获取文本框值： 1$(&#x27;#user&#x27;).attr(&#x27;value&#x27;); // &#x27;hwh&#x27; 读取结果还是hwh！这是因为实际html结构已经是： 1&lt;p&gt;用户名：&lt;input type=&quot;text&quot; id=&#x27;user&#x27; value=&#x27;hwh&#x27;&gt; &lt;/p&gt; 每次读取都是value值， 修改文本框内容不会改变value属性 。 6.3 事件 类似C#事件，常用有鼠标事件、键盘事件、其他事件等。 鼠标事件 常用鼠标事件，参数为函数用于处理事件： 事件方法 解释 click(func) 鼠标单击时触发 dblclick(func) 鼠标双击时触发 mouseenter(func) 鼠标进入时触发 mouseleave(func) 鼠标离开时触发 mousemove(func) 鼠标内部移动时触发 hover(func) 鼠标进入和退出时触发，相当于 mouseenter()+ mouseleave() 。 存在以下html结构： 1234&lt;ul id=&quot;programLanguage&quot;&gt; &lt;li id=&quot;C#&quot;&gt;C#&lt;/li&gt; &lt;li id=&quot;C&quot;&gt;C&lt;/li&gt;&lt;/ul&gt; 绑定 click 事件，点击 &lt;li#C&gt; 时触发。 12345678var C = $(&#x27;#C&#x27;);C.click( function() &#123; alert(&#x27;hello C!&#x27;); &#125;) 有时候还会用到一种 on() 方法绑定事件： 事件方法 解释 on(evet,func) on() 绑定事件，传入事件名称 &amp; 事件处理函数 12345678var C = $(&#x27;#C&#x27;);C.on(&#x27;click&#x27;, function() &#123; alert(&#x27;hello C!&#x27;); &#125;) 事件参数 所有时间 都会传入Event 对象作为参数，可以获取更多信息。 绑定 mousemove 事件，当鼠标在 &lt;div#testMouseMoveDiv&gt; 区域移动可以获取到鼠标位置。 1234567$(&#x27;#testMouseMoveDiv&#x27;).mousemove( function (e) &#123; $(&#x27;#testMouseMoveSpan&#x27;).text(&#x27;pageX = &#x27; + e.pageX + &#x27;, pageY = &#x27; + e.pageY); &#125;); 键盘事件 键盘事件仅作用在当前焦点的DOM上，通常是&lt;input&gt;和&lt;textarea&gt;： 事件方法 解释 keydown(func) 键盘按下时触发 keyup(func) 键盘松开时触发 keypress(func) 按一次键后触发 有以下html 结构： 12&lt;p&gt;用户名：&lt;input type=&quot;text&quot; id=&#x27;user&#x27;&gt; &lt;/p&gt; &lt;label id=&quot;check&quot;&gt;&lt;/label&gt;&lt;p&gt;密码：&lt;input type=&quot;text&quot; id=&#x27;pwd&#x27;&gt;&lt;/p&gt; 当用户在 &lt;input#user&gt; 输入完毕，右侧 &lt;lable#check&gt; 显示是否已存在用户名。 1234567891011var user = $(&#x27;#user&#x27;);user.change( function() &#123; if(this.value === &#x27;hwh&#x27;) $(&#x27;#check&#x27;).text(&#x27;用户存在！&#x27;).css(&#x27;color&#x27;,&#x27;red&#x27;); else $(&#x27;#check&#x27;).text(&#x27;可以使用！&#x27;).css(&#x27;color&#x27;,&#x27;blue&#x27;); &#125;); 其他事件 事件方法 解释 change(func) 当&lt;input&gt;、&lt;select&gt;或&lt;textarea&gt;的内容改变时触发 focus(func) 当 DOM 获得焦点时触发 blur(func) 当 DOM 失去焦点时触发 submit(func) 当&lt;form&gt;提交时触发 ready(func) 当页面被载入并且 DOM 树完成初始化后触发 有以下html 结构： 12&lt;p&gt;用户名：&lt;input type=&quot;text&quot; id=&#x27;user&#x27;&gt; &lt;/p&gt; &lt;label id=&quot;check&quot;&gt;&lt;/label&gt;&lt;p&gt;密码：&lt;input type=&quot;text&quot; id=&#x27;pwd&#x27;&gt;&lt;/p&gt; change(func) 事件：当用户在 &lt;input#user&gt; 输入完毕，右侧 &lt;lable#check&gt; 显示是否已存在用户名。 1234567891011var user = $(&#x27;#user&#x27;);user.change( function() &#123; if(this.value === &#x27;hwh&#x27;) $(&#x27;#check&#x27;).text(&#x27;用户存在！&#x27;).css(&#x27;color&#x27;,&#x27;red&#x27;); else $(&#x27;#check&#x27;).text(&#x27;可以使用！&#x27;).css(&#x27;color&#x27;,&#x27;blue&#x27;); &#125;); change 事件当输入框失去焦点才会触发（移到别处了不再输入了） 最好把函数直接写在change 里面，否则不知道为什么触发不了？ 1user.change(changeUserName()); // 封装好的函数写入不成？ ready 事件作用于docment对象，当DOM节点都载入浏览器触发：试分析以下错误？ 123456789101112131415&lt;html&gt;&lt;head&gt; &lt;script&gt; // 代码有误: $(&#x27;#testForm).on(&#x27;submit&#x27;, function () &#123; alert(&#x27;submit!&#x27;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id=&quot;testForm&quot;&gt; ... &lt;/form&gt;&lt;/body&gt; 标签内js代码在前，DOM 节点还没加载完毕就操作 节点所以出错。我们可以： - 把 标签在后 - 或者，用 *docment* 对象 *read* 事件函数 保证DOM节点都加载完毕 再绑定*submit*事件 1234567 $(document).ready(function () &#123; $(&#x27;#testForm).on(&#x27;submit&#x27;, function () &#123; alert(&#x27;submit!&#x27;); &#125;);&#125;); 也可以像前一般简化不用on方法： 1234567 $(document).on(&#x27;ready&#x27;, function () &#123; $(&#x27;#testForm).submit(function () &#123; alert(&#x27;submit!&#x27;); &#125;);&#125;); 甚至*read* 事件还可以再简化： *$(document).on('ready', function ()...* ---> *$(function ()..* 1234$(function () &#123; console.log(&#x27;init A...&#x27;);&#125;); ### 事件触发条件 事件的触发总是由用户操作引发的，但是，比如用JavaScript代码去改动文本框的值，不会触发`change`事件： 12var input = $(&#x27;#test-input&#x27;);input.val(&#x27;change it!&#x27;); // 无法触发change事件 我们可以通过直接调用无参数 *change()* 方法手动触发事件： 123var input = $(&#x27;#test-input&#x27;);input.val(&#x27;change it!&#x27;);input.change(); // 触发change事件 #### 浏览器安全限制 在浏览器中，有些 *JavaScript* 代码只有在用户触发下才能执行。例如，`window.open()`函数： 12345// 无法弹出新窗口，将被浏览器屏蔽:$(function ()&#123; window.open(&#x27;/&#x27;);&#125;); 这些“敏感代码”只能由用户操作来触发。 ### 综合测试 有以下 *Form* 表单： 1234567891011121314&lt;form id=&quot;test-form&quot; action=&quot;test&quot;&gt; &lt;legend&gt;请选择想要学习的编程语言：&lt;/legend&gt; &lt;fieldset&gt; &lt;p&gt;&lt;label class=&quot;selectAll&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; &lt;span class=&quot;selectAll&quot;&gt;全选&lt;/span&gt; &lt;span class=&quot;deselectAll&quot;&gt;全不选&lt;/span&gt; &lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;lang&quot; value=&quot;python&quot;&gt; Python&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;lang&quot; value=&quot;ruby&quot;&gt; Ruby&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;lang&quot; value=&quot;haskell&quot;&gt; Haskell&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;lang&quot; value=&quot;scheme&quot;&gt; Scheme&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/p&gt; &lt;/fieldset&gt;&lt;/form&gt; > 要求完成： > > - 当用户勾上“全选”时，自动选中所有语言，并把“全选”变成“全不选” > - 当用户去掉“全不选”时，自动不选中所有语言，并把“全不选”变成“全选” 12345678910111213141516171819&#x27;use strict&#x27;;var form = $(&#x27;#test-form&#x27;), langs = form.find(&#x27;[name=lang]&#x27;), selectAll = form.find(&#x27;label.selectAll :checkbox&#x27;), selectAllLabel = form.find(&#x27;label.selectAll span.selectAll&#x27;), deselectAllLabel = form.find(&#x27;label.selectAll span.deselectAll&#x27;), invertSelect = form.find(&#x27;a.invertSelect&#x27;);// 重置初始化状态:form.find(&#x27;*&#x27;).show().off();form.find(&#x27;:checkbox&#x27;).prop(&#x27;checked&#x27;, false).off();deselectAllLabel.hide();// 拦截form提交事件:form.off().submit(function (e) &#123; e.preventDefault(); alert(form.serialize());&#125;); 接上，绑定事件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var isAllSelected = false;selectAll.click( function() &#123; if(!isAllSelected ) &#123; langs.each ( /* 不能用lambada表达式，应该下面this都未绑定正确？ 经过测试在function()&#123;...&#125; this绑定正确。 */ // () =&gt; this.checked = &#x27;checked&#x27; // () =&gt; $(this).prop(&#x27;checked&#x27;,true) function() &#123; /* attr无法成功设置属性 ：不起作用？ */ // $(this).attr(&#x27;checked&#x27;,&#x27;checked&#x27;) ; $(this).prop(&#x27;checked&#x27;,true); // 测试成功 &#125; ) deselectAllLabel.show(); selectAllLabel.hide(); selectAll.prop(&#x27;checked&#x27;,false); isAllSelected = true; &#125; else &#123; langs.each ( /* 不能用lambada表达式，应该下面this都未绑定正确？ 经过测试在function()&#123;...&#125; this绑定正确。 */ // () =&gt; this.checked = &#x27;checked&#x27; // () =&gt; $(this).prop(&#x27;checked&#x27;,true) function() &#123; /* attr无法成功设置属性 ：不起作用？ */ // $(this).attr(&#x27;checked&#x27;,&#x27;checked&#x27;) ; $(this).prop(&#x27;checked&#x27;,false); // 测试成功 &#125; ) deselectAllLabel.hide(); selectAllLabel.show(); isAllSelected = false; &#125; &#125;); 可以利用*jQuery* 批量操作特点，不用*each()*遍历: 1234567891011121314151617181920212223242526var isAllSelected = false; // 判断此时单选框是：全部勾选 OR 全不勾选selectAll.click( function() &#123; if(!isAllSelected ) &#123; // 全部勾选 langs.prop(&#x27;checked&#x27;,true); // 全选隐藏、全不选显示 deselectAllLabel.show(); selectAllLabel.hide(); selectAll.prop(&#x27;checked&#x27;,false); isAllSelected = true; &#125; else &#123; // 全部取消勾选 langs.prop(&#x27;checked&#x27;,false); // 全选显示，全不选隐藏 deselectAllLabel.hide(); selectAllLabel.show(); isAllSelected = false; &#125; &#125;); ## 6.4 动画 用 *JavaScript* 实现动画，比如实现淡出效果，让选中元素在1s内改变 *CSS* *opacity（透明度）* 属性值至0。 本质都是通过修改CSS属性，*jQuery* 封装了函数让这一切变得更加简单。 ### 逐渐显隐 无参数的 *show()、hide()* 方法直接显示、隐藏元素；有参数指定时间可以实现动画效果。 | 方法 | 描述 | | :------------------------: | :----------------------------------------------------------: | | *show(timeSeconds,func)* | 在指定 *timeSeconds* 显示全部，*func* 指定显示完成后指定的方法 | | *hide(timeSeconds,func)* | 在指定 *timeSeconds* 隐藏全部，*func* 指定显示完成后指定的方法 | | *toggle(timeSeconds,func)* | 根据当前状态，自动调用 *show()、hide()* 方法 | - *timeSeconds* 以毫秒为单位，同时可以用 *‘slow’、‘fast’* 等特殊字符串作为参数值。 - 显示过程是从左上角 ---> 展开铺满整个平面 ；隐藏则是从右下角 --> 隐藏整个平面。 > :slightly_smiling_face: 简单实例 123456var div = $(&#x27;#test-show-hide&#x27;);// 在1秒钟内逐渐消失div.hide(1000); // 在0.6秒钟内逐渐显示div.show(&#x27;slow&#x27;); 就像此前说过，上面显示是从左上展开，下面方法可以从垂直方法逐渐展开、收缩 ~ just like 拉窗帘。 | 方法 | 描述 | | :-----------------------------: | :--------------: | | *slideUp(timeSeconds,func)* | 拉窗帘般显示 | | *slideDown(timeSeconds,func)* | 拉窗帘般收起隐藏 | | *slideToggle(timeSeconds,func)* | 自动调用上面方法 | ### 淡入淡出 *fadeIn() 、fadeOut()* 可通过不断设置 *DOM* *CSS* *opacity* 属性来实现淡入淡出动画效果。 | 方法 | 描述 | | :----------------------------: | :--------------: | | *fadeIn(timeSeconds,func)* | 淡入显示 | | *fadeOut(timeSeconds,func)* | 淡出隐藏 | | *fadeToggle(timeSeconds,func)* | 自动调用上面方法 | 存在以下表格： ![1565600702619](https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565600702619.png) > 试完成以下代码，使得每次删除表中第一项可以淡出显示。 123456789&#x27;use strict&#x27;;function deleteFirstTR() &#123; var tr = $(&#x27;#test-table&gt;tbody&gt;tr:visible&#x27;).first(); // 在以下完成事件绑定...&#125;deleteFirstTR(); 完成的代码如下： 1tr.fadeOut(1000,() =&gt; tr.remove()); ### 自定义动画 对上面提供的动画效果不满意？尝试自定义动画吧。 | 方法 | 描述 | | :-----------------------------------: | :----------------------------------------------------------: | | *animate(cssStyle，timeSeconds,func)* | 在指定*timeSeconds* 达到预设*cssStyle* 值，最后执行 *func* 函数 | 现在我们来试试自定义实现上面淡出删除表格效果吧。 > 淡出删除表格。 12345678910&#x27;use strict&#x27;;function deleteFirstTR() &#123; var tr = $(&#x27;#test-table&gt;tbody&gt;tr:visible&#x27;).first(); // 在以下完成事件绑定... tr.animate(&#123; opacity:0 &#125;, 1000, () =&gt; tr.remove())&#125;deleteFirstTR(); ### 串行动画 如果有两个动画效果： 12345var div = $(&#x27;#test-animates&#x27;);// 放大div.animate( &#123; width: &#x27;256px&#x27;, height: &#x27;256px&#x27;&#125;, 2000);// 缩小div.animate( &#123; width: &#x27;128px&#x27;, height: &#x27;128px&#x27;&#125;, 2000); 希望实现放大 --> 缩小 连续动画效果，如果这样简单的连续执行两个动画： 1div.animate( &#123; width: &#x27;256px&#x27;, height: &#x27;256px&#x27;&#125;, 2000).animate( &#123; width: &#x27;128px&#x27;, height: &#x27;128px&#x27;&#125;, 2000); 是无法实现的，因为：*动画需要执行一段时间，所以jQuery必须不断返回新的Promise对象才能后续执行操作* 。 所以我们需要借助 *delay()* 方法实现暂停，给予时间返回新的 *Promise* 对象执行后续操作： 123div.animate( &#123; width: &#x27;256px&#x27;, height: &#x27;256px&#x27;&#125;, 2000) .delay(1000) .animate( &#123; width: &#x27;128px&#x27;, height: &#x27;128px&#x27;&#125;, 2000); ### 动画没有效果？ *jQuery* 动画的原理是逐渐改变 *CSS* 值，而有些情况是无法改变成功的。例如： - *slideUp()* 逐渐把*CSS*属性*height* --> 0，但是非*block* 属性值*DOM* 元素对它们设置 *height* 是不起作用的。 - *animate()* 设置 *background-color* 没有效果，因为 *jQuery* 没有实现。"},{"title":"深度学习基础（二）OpenCV","date":"2022-01-02T11:54:25.546Z","updated":"2022-01-02T11:43:17.878Z","comments":true,"path":"NO_post/深度学习基础（二）OpenCV.html","permalink":"https://hwh.zone/NO_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89OpenCV.html","excerpt":"","text":"一、初识OpenCV 使用以下命令可以一键安装 OpenCV ： 1conda install -c menpo opencv 1.1 环境搭建 简单测试是否搭建成功OpenCV： 1234567891011import cv2 as cv# 1.测试打开图片src = cv.imread(&quot;C:/Users/86151/Pictures/1571142354306.png&quot;)# 打开一个名为“test”的窗口（不知道有什么用？）cv.namedWindow(&quot;test&quot;,cv.WINDOW_AUTOSIZE) # 打开指定路径图片cv.imshow(&quot;111&quot;,src)cv.waitKey(0) # 等待用户输入关闭图片，这里好像任意键关闭cv.destroyAllWindows()print(&quot;hello opencv!&quot;) 1.2 图像加载和保存 1.2.1 图片：读取+基本属性 显示图片同时打印一些基本信息。 123456789101112131415# 2.读取图片：中文路径好像会报错imageSrc = r&quot;C:/Users/86151/Pictures/1571142354306.png&quot;image = cv.imread(imageSrc)# 显示图片和基本信息cv.imshow(&quot;hwh&quot;,image)cv.waitKey(0)print(type(image)) # &lt;class &#x27;numpy.ndarray&#x27;&gt;print(image.shape) # (278, 1068, 3),依次对应：宽、高、通道数print(image.size) # 890712 = 278*1068*3print(image.dtype) # uint8,每个像素基本单元？# 保存图片cv.imwrite(&quot;D:/result.png&quot;,image) 图片使用 cv.imread 读取后三位 numpy 数组，例如 image[0,0,0] 索引第一个像素值。 栗子1：将图片RGB三通道进行拆分、合并分别展示。 首先我们可以利用 cv.split() 将图片进行分隔： 12345678910image = cv.imread(r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;)# cv.split：将图片分割为BGR三通道b,g,r = cv.split(image)cv.imshow(&#x27;r&#x27;,r)cv.imshow(&#x27;g&#x27;,g)cv.imshow(&#x27;b&#x27;,b)# cv.merge：合并成RGB（不是BGR）图像rgb = cv.merge([r,g,b])cv.imshow(&#x27;rgb&#x27;,rgb) 其它：numpy创建图片 12345# 创建一张三通道黑色图片：255*255*3image = np.zeros((255,255,3),np.uint8) # 每个像素值都占一个字节（0-255）cv.imshow(&#x27;black&#x27;,image)cv.waitKey(0) 1.2.2 视频：读取 123456789101112# 3.视频# VideoCapture：指定视频路径，不指定（参数=0）则是打开自带摄像头capture = cv.VideoCapture(0)while(1): ret,frame = capture.read() # cv.flip: 使图像镜像颠倒，恢复正常 frame = cv.flip(frame,1) cv.imshow(&quot;video&quot;,frame) # cv.waitKey:每处理一帧都等待50ms，同时当按下ESC(ASCII=27)退出 c = cv.waitKey(50) if c==27: break; 1.3 色彩空间 该部分主要参考：图像色彩空间总结 1.3.1 色彩空间初识 图像通道 从数学方式理解，一张图片是一个数值矩阵。如果有n 个通道，则指按*不同方式* 可分解成 n 个同大小、不同数值矩阵之和。 如下三通道RGB ，可将原始彩色图片 —&gt; 分解成 RGB 三通道： RGB 三个分量 R、G、B取值大小在 [0,255] 之间。 常用色彩空间有：BGR、RGB、GRAY、RGB、HSV、YUV 等 1.3.2 色彩空间转换 简单使用如下代码可以进行不同色彩空间的转换： 123456789101112# 4.色彩空间转换image = cv.imread(r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;)cv.imshow(&quot;standingCat&quot;,image)# 转换为GRAYgray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)cv.imshow(&quot;gray&quot;,gray)# 转换为RGBRGB = cv.cvtColor(image,cv.COLOR_BGR2RGB)cv.imshow(&quot;RGB&quot;,RGB)cv.waitKey(0) HSV空间颜色三通道范围 栗子 1：将视频中红色转换为 --&gt;白色突出显示，其余颜色都是黑色便于跟踪。 在图像处理中，通常不会直接对RGB图像做处理，因为RGB和人类视觉相差较远。故下面代码将每一帧都转换到 HSV 色彩空间。 1234567891011121314151617181920212223242526# 5.视频色彩空间转换capture = cv.VideoCapture(&quot;D:/hwh/uploadToGit/code/python/5_learn_pytorch/src/video1.mp4&quot;)while(True): ret,frame = capture.read() if ret == False: # 判断视频流是否读取完毕 break # 转换到hsv色彩空间，返回hsv帧 hsv = cv.cvtColor(frame,cv.COLOR_BGR2HSV) # 设置黑色像素三通道值阀值范围 # 将hsv帧转换为二值化mask帧 lower_hsv = np.array([0,43 ,46]) # 设置红色最低三通道值（在hsv色彩空间） upper_hsv = np.array([10,255,255]) # 设置红色最高三通道值（在hsv色彩空间） mask = cv.inRange(hsv,lowerb=lower_hsv,upperb=upper_hsv) # 显示原始视频 cv.namedWindow(&quot;testVideo&quot;,0) # 第二参数不明 cv.resizeWindow(&quot;testVideo&quot;,900,600) # 设置窗口大小 cv.imshow(&quot;testVideo&quot;,frame) # 显示当前读取的帧 # 显示mask二值化视频 cv.namedWindow(&quot;mask&quot;, 0) cv.resizeWindow(&quot;mask&quot;, 900, 600) cv.imshow(&quot;mask&quot;,mask) c = cv.waitKey(20) if c == 27: break 1.4 像素运算 1.4.1 基本加减乘除 试分析，下面两张图片进行加减乘除得到的结果。 定义基本代码： 加减操作： 1234# 图片相加add_image = cv.add(src1,src2);# 图片相减substract_image = cv.substract(src1,src2); 图片相加：黑色=0，白色=255。所以src1黑色背景相加对src2没影响，而src1白色字体和src2相加会超过255被截断依旧显示Linux白色字体。 图片相减：背景是黑色？因为src1背景黑色-src2 &lt; 0，依旧取0故结果为黑色 ； 字体五颜六色？因为src中Linux字体是白色=255，减去src2值，变成其它颜色了。 乘法操作： 图片相乘：背景黑色？因为src1黑色=0 * 第二张图对应部分 == 0 ，还是显示黑色 ； 字体是白色周围又五颜六色？ 这是因为 src1中Linux字体周围有反锯齿，周围边缘有平滑有模糊，它周围像素值并不为0，和src2相乘后，所以最终像素值并不为0而相乘值变大了就容易显示出其它颜色。 14.2 MASK（掩膜） MASK掩膜，即图和掩膜按位与进行运算，筛选出感兴趣的区域。 由于mask和原图像素值 ∈[0,255]∈[0,255]∈[0,255] ，所以定义逻辑与如下： mask和原图对应点像素值都 &gt;0&gt;0&gt;0 ，则为真，输出*原图像素像素值* 其中一个等于0，则为假，输出对于*点像素值为0* 这样定义mask意义在于： 对于自己敢兴趣的区域，mask=0，则按位与必为0（显示为黑色） 自己不感兴趣的区域设置 mask&gt;0 ,则依旧输出为原图像素像素值 举个简单的例子：更多参考 mask只能是二维矩阵，与原图 shape[:2] 相同（shape[:2] 是 1*3 矩阵，当其是一维矩阵 [:2] 索引的是前两个数字，而非前两行！） 1.4.3 逻辑操作 12345678image1 = cv.imread(r&quot;C:\\Users\\86151\\Pictures\\test1.jpg&quot;)image2 = cv.imread(r&quot;C:\\Users\\86151\\Pictures\\test2.jpg&quot;)# 逻辑与dst1 = cv.bitwise_and(image1,image2)# 逻辑或dst2 = cv.bitwise_or(image1,image2)# 取反 dst3 = cv.bitwise_not(image1) 上图是逻辑与结果 栗子1：inRang+mask 实例：结合上节利用将图像掩膜mask，突出显示某些指定颜色变化为白色（其余为黑色）。 我们可以通过 bitwise_and ，使得突出显示的颜色为原来颜色，而非白色。 12345678910111213141516171819202122232425262728capture = cv.VideoCapture(&quot;D:/hwh/uploadToGit/code/python/5_learn_pytorch/src/video1.mp4&quot;)while(True): ret,frame = capture.read() if ret == False: # 视频流读取完毕 break hsv = cv.cvtColor(frame,cv.COLOR_BGR2HSV) lower_hsv = np.array([0,43 ,46]) upper_hsv = np.array([10,255,255]) # 在这里mask∈&#123;0,255&#125;，只有两个数字 mask = # 前面两个参数原图进行相加（逻辑与不变？），然后通过掩膜mask按位与实现输出原图像素值？ dst = cv.bitwise_and(frame,frame,mask=mask) # 显示原始视频1 cv.namedWindow(&quot;testVideo&quot;,0) cv.resizeWindow(&quot;testVideo&quot;,600,400) cv.imshow(&quot;testVideo&quot;,frame) # 显示mask二值化视频2 cv.namedWindow(&quot;mask&quot;, 0) cv.resizeWindow(&quot;mask&quot;, 600, 400) cv.imshow(&quot;mask&quot;,mask) # 显示逻辑与操作视频3 cv.namedWindow(&quot;dst&quot;, 0) cv.resizeWindow(&quot;dst&quot;, 600, 400) cv.imshow(&quot;dst&quot;,dst) c = cv.waitKey(20) if c == 27: break 实际上原图 &amp; mask输出非黑部分和 原图区别还是挺大的啊？ 1.4.4 其它：对比度addWeight等 有点类是add，也是进行图像叠加不过会设置各种权重和参数。按下公式计算结果图： alpha ： src1 矩阵元素权重 ； beta ： src2 矩阵权重；gamma 最后各元素再相加值。 举例：可通过 addWeighted 调整图片的亮度、对比度等 生成一张纯0矩阵 blank ，那beta有什么用？乘上一个零矩阵不变？ 此时 alpha 即可是认为是对比度（等比增大元素像素值，黑色还是黑，别的会等比变大），gamma 可调节亮度（值越大越白–&gt;越亮） 12345678910111213# 7.addWeight 调整对比度image = cv.imread(r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;)# 创建一张和原图等大纯黑图h,w,c = image.shapeblank = np.zeros([h,w,c],dtype=image.dtype)# 增加对比度dst = cv.addWeighted(image,1.2,blank,1-1.2,10)# 显示图片cv.imshow(&#x27;image&#x27;,image)cv.imshow(&#x27;dst&#x27;,dst)cv.waitKey(0) 其它操作。 12345# 打印出图片三个通道像素均值m1 = cv.mean(src1)# 打印出图片三个通道像素均值和方差m1,dev1 = cv.meanStdDev(m1) 1.5 绘图与鼠标事件 该部分主要参照于：openCV-Python 中文教程 1.5.1 绘图 以下为简单实例，绘制矩形、多边形、圆、椭圆、添加文字等 12345678910111213141516171819202122232425262728293031image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)# 1.画线# 参数依次意义：原图，起始点坐标，终点坐标，线颜色，线厚度cv.line(image,(0,0),(250,250),(255,0,0),5)# 2.画矩形# 参数依次意义：原图，左上角坐标，右下角坐标，边颜色，边厚度cv.rectangle(image,(50,50),(250,250),(255,255,0),1)# 3.画圆# 参数依次意义：原图，圆心坐标，半径，边颜色，边厚度# 指定边厚度=-1，则圆会向内填充cv.circle(image,(250,250),20,(0,0,255),-1)# 4.画椭圆# 参数依次意义：原图，圆心坐标，(长轴，短轴)，旋转角度，椭圆弧起始角，椭圆弧终止角，颜色cv.ellipse(image,(250,250),(100,50),30,70,360,255,1)# 5.画多边形# 参数依次意义：原图，多边形各点坐标，是否闭合，边颜色# 指定多边形各点左边，[必须是int32]pts=np.array([[100,50],[200,300],[400,200],[500,100]],np.int32)cv.polylines(image,[pts],True,(46.46,46))# 6.添加文字# 参数依次意义：原图，绘制位置，字体类型，大小，颜色，粗细，类型font = cv.FONT_HERSHEY_SCRIPT_SIMPLEXcv.putText(image,&#x27;HELLO OPENCV!&#x27;,(100,200),font,2,(0,0,255),cv.LINE_4)cv.imshow(&#x27;result&#x27;,image)cv.waitKey(0) 1.5.2 鼠标事件 利用鼠标事件，实现对图片指定区域裁剪。 123456789101112131415161718192021222324252627282930# 9.鼠标事件# 1.创建回调函数：draw_circle(event,x,y,flags,param)# 2.绑定回调函数&amp;窗口：setMouseCallback(&#x27;window&#x27;,draw_circle)def draw_circle(event,x,y,flags,param): global ix,iy,drawing,mode # 触发左键按下事件：EVENT_LBUTTONDOWN if event == cv.EVENT_LBUTTONDOWN: ix,iy = x,y # 获取左键按下初始坐标 elif event == cv.EVENT_LBUTTONUP: cv.rectangle(image,(ix,iy),(x,y),(0,0,255),1) cv.imshow(&#x27;crop&#x27;,image[iy:y,ix:x]) # 未解决：用鼠标移动+拖拽事件来判断，会每次移动画一个矩形，最后出现很多矩形 # 已画的矩形又无法清除 # 触发鼠标移动 &amp; 左键拖拽事件 # elif event==cv.EVENT_MOUSEMOVE and flags==cv.EVENT_FLAG_LBUTTON: # if drawing == True: # elif event==cv.EVENT_LBUTTONUP: # drawing = Falseimage = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.namedWindow(&#x27;img&#x27;)cv.setMouseCallback(&#x27;img&#x27;,draw_circle)while(1): # 放在循环里，一直显示？ cv.imshow(&#x27;img&#x27;, image) k = cv.waitKey(1) if k == ord(&#x27;q&#x27;): break 二、进击！openCV！ 2.1 ROI与泛洪填充 简单来说：获取感兴趣区域ROI对它进行指定方式填充。 例子：截取指定区域，转换为GRAY图像并覆盖原图相同区域 123456789101112131415161718192021222324252627282930# ROI与填充# 该例子分为三个部分：# 1.实现指定图片对其进行部分截图# 2.将截图部分转换为灰色，并覆盖原图相同区域def crop_trans_Img(event,x,y,flags,param): global x0,y0,x1,y1 # 触发左键按下事件：EVENT_LBUTTONDOWN if event == cv.EVENT_LBUTTONDOWN: x0,y0 = x,y # 获取左键按下时初始坐标 # 触发左键抬起事件：EVENT_LBUTTONUP，裁剪指定区域图片并转换为灰度图 elif event == cv.EVENT_LBUTTONUP: x1,y1 = x, y # 指定裁剪区域 cv.rectangle(image,(x0,y0),(x1,y1),(0,0,255),1) # 获取裁决区域图 crop = image[y0:y1,x0:x1] # 裁剪区域转换为灰度图Gray gray_crop = cv.cvtColor(crop,cv.COLOR_BGR2GRAY) # 将[灰度图--&gt; BGR图] --&gt; 覆盖原图指定区域 image[y0:y1, x0:x1] = cv.cvtColor(gray_crop,cv.COLOR_GRAY2BGR)image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.namedWindow(&#x27;img&#x27;)cv.setMouseCallback(&#x27;img&#x27;,crop_trans_Img) # img窗口绑定回调函数while(1): cv.imshow(&#x27;img&#x27;, image) k = cv.waitKey(1) if k == ord(&#x27;q&#x27;): break 2.1.1 FloodFill：泛洪填充 定义，floodFill(image,mask,seePoint,newVal,rect,loDiff,upDiff,scalar,flags) : mask：必须宽高比原图大2像素；对不想填充区域设置为非零值，则不被填充（为原像素值） 即mask &gt; 0 区域依旧表现为原图像素值；mask = 0 ，则会被指定填充（前面讲mask=0，值=0，即黑色，和这有点不同的） loDiff、upDiff：定义指定视为连通可被填充像素值范围（彩色还要设置三通道这种低、高Diff） flags：填充方法选择，一般彩色图片选择cv.FLOODFILL_FIXED_RANGE ；还有可以选择cv.FLOODFILL_FIXED_MASK_ONLY 好像是只填充mask=0区域？？？？ 利用mask，实现对指定区域进行泛洪填充。 1234567891011image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)copyImg = image.copy()h,w = copyImg.shape[:2]# 设置mask，对于想感兴趣的区域设置0mask = np.ones([h+2,w+2],np.uint8)mask[100:800,200:700] = 0# 进行泛洪填充cv.floodFill(copyImg,mask,(250,250),(0,255,255),(20,20,20),(100,100,100),cv.FLOODFILL_FIXED_RANGE)cv.imshow(&#x27;flood&#x27;,copyImg)cv.waitKey(0) 2.2 模糊操作 2.2.1 均值模糊、中值模糊 均值模糊 作用：对随机噪声有很好去噪效果 实现：通过指定size=(h,w)size=(h,w)size=(h,w)的全1卷积核，计算新像素值 = (h,w)范围像素线性加权h∗w\\frac{(h,w)范围像素线性加权}{h*w}h∗w(h,w)范围像素线性加权​ API：blur(src,dst,ksize,anchor=Point(-1,-1), borderType=BORDER_DEFAULT ) 中值模糊 作用：对椒盐噪声有很好去噪效果 实现：指定长宽相同size=(h,h)size=(h,h)size=(h,h)卷积核， 在对图像进行卷积过程中，将卷积核区域内像素值从小–&gt;大排序，取中值像素作为整个区域像素值。 API : medianBlur( src,dst,ksize ) 实例1：调用openCV的API来实现均值模糊，中值模糊。 注：实际上好像下面都没有指定参数 dst 啊？ 12345678910image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;orign&#x27;,image)# 均值模糊avgBlurImg = cv.blur(image,(5,5))cv.imshow(&#x27;avgBlur&#x27;,avgBlurImg)# 中值模糊medianBlurImg = cv.medianBlur(image,5) # 必须是方阵，只指定一个数字即可cv.imshow(&#x27;medianBlur&#x27;,medianBlurImg)cv.waitKey(0) 实例2：自定义卷积核实现均值滤波。 12345# 自定义卷积核实现均值滤波kernel = np.ones([5,5],np.float32)/25autoAvgImg = cv.filter2D(image,-1,kernel=kernel)cv.imshow(&#x27;aotuAvgImg&#x27;,autoAvgImg)cv.waitKey(0) 效果和调用API 一样。 2.2.2 高斯模糊 和前均值模糊一样，也是进行卷积。只不过高斯模糊的卷积核附和高斯分布而已。 高斯分布（又为正态分布）： 高斯模糊 作用：对高斯噪声有较好处理效果 API : GaussianBlur(src,ksize,sigmaX,dst,sigmaY,borderType: Any = None) 实例1：简单调用接口实现对图片的高斯模糊。 123456789# 13.高斯模糊image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# GaussianBlur:调用高斯模糊# x标准差=sigmax=15，卷积核大小设置为0则会根据sigmax自动计算GaussianImg = cv.GaussianBlur(image,(0,0),15)cv.imshow(&#x27;guassian image&#x27;,GaussianImg)cv.waitKey(0) 实例2：利用高斯模糊对高斯噪声进行处理。 可发现高斯噪声对高斯模糊产生结果没什么影响。 12345678910111213141516171819202122232425262728# 14.高斯模糊对高斯噪声进行处理image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# 给图片加上高斯噪声h,w,c = image.shapefor row in range(h): for col in range(w): # 生成高斯随机噪声像素值 # loc:概率分布的均值；scale：概率分布标准差；size：输出的shape，默认输出一个 # 例如正态分布（μ=0,σ=1 ） == random.normal(loc=0, scale=1, size) s = np.random.normal(loc=0,scale=20,size=3) # 获取BGR三个通道对应像素值 b = image[row,col,0] g = image[row,col,1] r = image[row,col,2] # 给每个像素点加上高斯噪声生成的像素值 image[row, col, 0] = (b + s[0]) % 255 image[row, col, 1] = (g + s[1]) % 255 image[row, col, 2] = (r + s[2]) % 255cv.imshow(&#x27;Guassian noise&#x27;,image)# 高斯模糊对高斯噪声图片进行处理GaussianImg = cv.GaussianBlur(image,(0,0),15)cv.imshow(&#x27;GaussianImg&#x27;,GaussianImg)cv.waitKey(0) 2.2.3 EPF模糊：高斯双边、均值偏移 EPF，即边缘保留滤波。常用有基于高斯双边和均值偏移。 我们知道，在前 高斯模糊 只考虑了空间分布，而没有像素之间差异问题： 如果像素差异很大，说明实现显著特征，我们应该将它进行平滑吗？ 显然是不应该的，而且往往在 图像边缘 出现像素差异变大。在openCV中提供了：高斯双边、均值漂移 来实现边缘保留。 高斯双边模糊 高斯双边美颜效果杠杠的。 上述是高斯双边模糊原理图（没太明白） API : cv.bilateralFilter(src, d, sigmaColor, sigmaSpace[, dst[, borderType]]) d : 滤波器大小，d&gt;5d&gt;5d&gt;5 执行效率低，一般取d=5d=5d=5； d≤0d≤0d≤0 时由 sigmaSpace确定且成正比 sigmaColor ：值越大，交界处即边缘越模糊 sigmaSpace ：值越大，即颜色平均的地方越模糊 一个简单测试：利用高斯双边模糊把照片变得更美美的。 12345678910# 15.高斯双边模糊image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\testlx.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# d=0,由sigamColor确定；sigamColor=100 ；sigamSpace=15# 好像又略过了dst参数啊？？lx_beautiful = cv.bilateralFilter(image,0,100,15)cv.imshow(&quot;lx_beautiful&quot;,lx_beautiful)cv.waitKey(0) 均值飘移模糊 也能保留边缘，但是更类似于卡通效果。 均值飘移模糊： 原理：又是什么色彩聚类平滑滤波，结合泛洪填充可以进行图像分割？ API : pyrMeanShiftFiltering(src, sp, sr[, dst[, maxLevel[, termcrit]]]) sp、sr ： 值越大，则图像色彩平滑效果越好，但耗时也越多。 简单测试：均值漂移把照片变得… 12345678# 15.均值漂移模糊image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\testlx.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)lx_beautiful = cv.pyrMeanShiftFiltering(image,10,50)cv.imshow(&quot;lx_beautiful&quot;,lx_beautiful)cv.waitKey(0) 2.3 图像直方图 图像直方图： 意义：直方图是图像 像素强度 分布的图形表达方式，统计每一个强度值所具有的像素个数。 例如下列灰度直方图： xxx 轴代表灰度值（0-255） ； yyy 轴代表同一个灰度值点的数目。 彩色图像如何设置直方图？ 三个通道值还是∈[0,255]∈[0,255]∈[0,255] ,那么分别统计各个不同通道相同像素值就好了。 常用一些术语： range：每个特征空间的取值范围，例如 range=[0,255] bin：直条或组距，表示每个特征子空间的段的数目 下面图像14位是什么意思，为什么会有 2142^{14}214 不同像素值，不是只会 ∈[0,255]∈[0,255]∈[0,255] ? 这里指得应该是图像大小=14，然后灰度图会有 14∗1414*1414∗14 个像素点。 2.3.1 实例：直方图初应用 下面我们分别介绍两个API 来计算图像 直方图 和 直方折线图 ： matplotlib::plt.hist() 计算直方图 x ：数组，必须是(n,)数组，所以图像要用 image.ravel() 函数进行降维 bins ：指定bin个数 range ： 显示的区间 cv.calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate]]) 返回的是一个数组(histSize,1)，统计了指定 histSize 的像素强度统计个数。 实例1：利用matplotlib::plt.hist()绘制出图像不同像素强度统计数直方图 123456789# 16.直方图image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# 绘制直方图# image.ravel()将原图640*640*3维度降为一维 2288000=640*640*3# 注意这里是256不是255plt.hist(image.ravel(),256,[0,256])plt.show()cv.waitKey(0) 实例2：利用 cv.calcHist() 统计指定图像和通道的各个像素强度个数。 1234567891011# 17.绘制直方折线图？image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)color = (&#x27;blue&#x27;,&#x27;green&#x27;,&#x27;red&#x27;) # 三个通道各个像素统计折线不同颜色for i,color in enumerate(color): hist =cv.calcHist([image],[i],None,[256],[0,256]) plt.plot(hist,color=color) plt.xlim([0,256])plt.show() 2.3.3 直方图应用 直方图均衡化 直方图均衡化：利用图像直方图 对比度进行调整 的方法。可参考这篇文章 原理：待补充 API ： 直方图均衡化 ： cv.equalizeHist(src[, dst]) 局部直方图均衡化： cv2.createCLAHA(clipLimit=8.0, titleGridSize=(8, 8)) clipLimit ：颜色对比度的阈值 titleGridSize ：进行像素均衡化的网格大小，即在多少网格下进行直方图的均衡化操作 实例1：通过直方图均衡化提升图像质量。 123456789101112# 18.直方图均衡化image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)# 将原图转换为灰度图gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)cv.imshow(&#x27;origin_gay&#x27;,gray)# 直方图均衡化只能是灰度图，如果是彩色图？不能？dst = cv.equalizeHist(gray)cv.imshow(&#x27;equalHistImg&#x27;,dst)cv.waitKey(0) 实例2：局部图直方图均衡化，解决全局的均衡化整体亮度提升使得局部图像的细节变得模糊。 好像这张图不能体现局部直方图均衡化可以保留更多细节？下面这张图最右侧局部均衡化显然保存的人脸更多细节： 1234567891011121314# 19.局部直方图均衡化image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)# 将原图转换为灰度图gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)# 显示全局均衡化图像cv.imshow(&#x27;hist&#x27;,cv.equalizeHist(gray))# 实例化自适应直方图均衡化系数clahe = cv.createCLAHE(5.0,(8,8))dst = clahe.apply(gray)cv.imshow(&#x27;clahe&#x27;,dst)cv.waitKey(0) 直方图比较 手动创建图像直方图方法 create_rgb_hist 没有太明白？ 直方图反向投影 该小节例子使用的范围归一化到[0,255]，而不是一值归一化。可查看 OpenCV中矩阵的归一化 作用：用于图像分割或查找图像中感兴趣的对象 归一化: 计算反向直方图： 实例1：计算二维直方图并显示。 1234567891011# 20.显示hsv二维直方图image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# 计算直方图反向投影先转换到hsv色彩空间(?)hsv = cv.cvtColor(image,cv.COLOR_BGR2HSV)# hsv，因为亮度(v)很容易受到外界影响，所以我们认为颜色本质是hsv，h∈[0,180],v∈[0,256]hist = cv.calcHist([hsv],[0,1],None,[180,256],[0,180,0,256])cv.imshow(&#x27;hist2D&#x27;,hist)cv.waitKey(0) 实例2：提取照片头发为感兴趣区域，进行反向直方图投影。 ⚠️ 经过测试感兴趣区域应该是一类颜色，而不应该是整个脸什么的？ 123456789101112131415161718192021222324# 21.直方图反向投影# 读取roi图像并转换到hsv色彩空间roi = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\testlx_roi2.jpg&quot;)roi_hsv = cv.cvtColor(roi,cv.COLOR_BGR2HSV)cv.imshow(&#x27;roi&#x27;,roi)# 读取目标图像并转换到hsv色彩空间target = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\testlx.jpg&quot;)target_hsv = cv.cvtColor(target,cv.COLOR_BGR2HSV)cv.imshow(&#x27;target&#x27;,target)# 计算roi图像直方图并[范围]归一化到[0,255]# roi_hist.shape=(180,256)# 如果想效果更好，可以把bin不那么细化，即bin数目调整少点：[180,256] --&gt; [32,64]roi_hist = cv.calcHist([roi_hsv],[0,1],None,[180,256],[0,180,0,256]) # 归一化范围至0-256，cv.NORM_MINMAX常用的线性平移缩放归一化cv.normalize(roi_hist,roi_hist,0,256,cv.NORM_MINMAX)# 计算反向直方图投影dst = cv.calcBackProject([target_hsv],[0,1],roi_hist,[0,180,0,256],1)cv.imshow(&#x27;dst&#x27;,dst)cv.waitKey(0) 2.4 模板匹配 模板匹配即给定模板（template）在目标（target）中进行搜索匹配，画出锚框。 匹配：matchTemplate 原理：利用模板在目标图像匹配（卷积），返回所有匹配结果矩阵A 对于TM_SQDIFF 方法，结果矩阵A 中*最小值位置* 对应最佳匹配时模板图像*左上角* 位置 对于TM_CCORR or TM_CCOEFF 方法，A 中*最大值位置* 对应最佳匹配模板图像*左上角* 位置 原型：cv.matchTemplate(image, templ, method[, result[, mask]]) 例1：给定模板图像猫脸，在目标图像猫中画出对应模板图像位置红框。 12345678910111213141516171819202122232425262728# 22.模板匹配# 读取模板图像（猫脸）template = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat_roi.jpg&quot;)cv.imshow(&#x27;template&#x27;,template)th,tw = template.shape[:2] # shape=(h,w,c)# 读取目标图像（猫）target = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)# 模板匹配的三种方法methods = [cv.TM_SQDIFF_NORMED,cv.TM_CCOEFF_NORMED,cv.TM_CCORR_NORMED]tl = [0,0]for md in methods: # 采用指定方法md,进行模板匹配 result = cv.matchTemplate(target,template,md) # minMaxLoc：返回矩阵中最小值、最大值、最小值位置，最大值位置 minVal,maxVal,minLoc,maxLoc = cv.minMaxLoc(result) if md == cv.TM_SQDIFF_NORMED: tl = minLoc else: tl = maxLoc # 注意右下角 = （左上角x+宽，左上角y+高） cv.rectangle(target,tl,(tl[0]+tw,tl[1]+th),(0,0,255),2) cv.imshow(str(md),target)cv.waitKey(0) 2.5 图像二值化 什么是图像的二值化？该部分主要参考 : 图像二值化 一幅图像包括目标物体、背景还有噪声，要想*从多值的数字图像中直接提取出目标物体*，通过设定一个阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。这是研究灰度变换的最特殊的方法，称为图像的二值化（Binarization）。 例如：将图像上的像素点的灰度值设置为0或255，整个图像呈现出明显的只有黑和白的视觉效果。 1 hsv二值化： inRange 在之前我们还接触过 inRange 将图像进行二值化 ： 在 hsv 色彩空间中，对于指定 hmin−hmax、smin−smax、vmin−vmaxh_{min}-h_{max} 、s_{min}-s_{max} 、v_{min}-v_{max}hmin​−hmax​、smin​−smax​、vmin​−vmax​ 范围内像素值设置为白色其余为黑色。 这是针对在 hsv 色彩空间，而下面 threshold 是指对 单通道灰度图 进行二值化。 2 gray二值化：threshold 相关API : cv2.threshold(img, threshold, maxval,type) threshold : 是设定的阈值 maxval: 当灰度值大于（或小于）阈值时将该灰度值赋成的值 type : 当前二值化的方式（保持原样指的是保持原图像像素值） threshold 方法针对 单通道灰度图 ，彩色图要先转换为灰度图。 1234567891011121314151617181920212223242526272829303132# 23.图像二值化：thresholdimage = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)image_gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)cv.imshow(&#x27;origin_gray&#x27;,image_gray)# 进行二值化# THRESH_BINARY: 大于阈值=127，被置为255，小于阈值=127，被置为0# 这里maxVal=255，是大于阈值被设置的值，而不是默认就设置为255！ret1,binary1 = cv.threshold(image_gray,127,255,type=cv.THRESH_BINARY)cv.imshow(&#x27;THRESH_BINARY&#x27;,binary1)# THRESH_BINARY_INV: 和THRESH_BINARY设置相反ret2,binary2 = cv.threshold(image_gray,127,255,type=cv.THRESH_BINARY_INV)cv.imshow(&#x27;THRESH_BINARY_INV&#x27;,binary2)# THRESH_TRUNC：大于阈值部分被置为threshold，小于部分保持原样（原图像素值）# 这里及下面maxVal（0）设置不起作用，大于阈值为原图像值ret3,binary3 = cv.threshold(image_gray,127,0,type=cv.THRESH_TRUNC )cv.imshow(&#x27;THRESH_TRUNC&#x27;,binary3)# THRESH_TOZERO：小于阈值部分被置为0，大于部分保持不变（原图像素值）ret4,binary4 = cv.threshold(image_gray,127,0,type=cv.THRESH_TOZERO )cv.imshow(&#x27;THRESH_TOZERO&#x27;,binary4)# THRESH_TOZERO_INV ：大于阈值部分被置为0，小于部分保持不变 （原图像素值）ret5,binary5 = cv.threshold(image_gray,127,0,type=cv.THRESH_TOZERO_INV )cv.imshow(&#x27;THRESH_TOZERO_INV&#x27;,binary5)# [重要] cv.THRESH_OTSU：是最大间差法，按图像灰度特性将图像分为前景和背景两部分cv.waitKey(0) 3 gray二值化：adaptiveThreshold 该部分主要参考：自适应化阈值操作 自适应阈值，则是根据像素的 邻域块的像素值分布来确定该像素位置上的二值化阈值 ： 每个像素位置处的二值化阈值不是固定不变的，而是由其周围邻域像素的分布来决定的 亮度较高图像区域二值化阈值通常较高，而亮度低的图像区域的二值化阈值则会相适应变小 不同亮度、对比度、纹理的局部图像区域将会拥有相对应的局部二值化阈值 每一个像素计算阈值过程： 首先该像素点周围 B*B 区域内像素加权平均（对应方法有平均值法、高斯平均两种方法） 最后减去一个常数C，得到该像素点的阈值 相关API : cv.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst]) maxValue ：阈值？ adaptiveType : 指自适应的阈值 求平均值方法，同上有两种可选 ADAPTIVE_THRESH_MEAN_C ：先求出领域块中的均值，再减去常数C ADAPTIVE_THRESH_GAUSSIAN_C：局部邻域块的高斯加权和，最后减去常数C thresholdType ：阈值类型，有两种可选：THRESH_BINARY 或THRESH_BINARY_INV ？ 同前，THRESH_BINARY 大于阈值置为阈值，小于阈值置为0；THRESH_BINARY_INV 相反。 blockSize： 指定的领域块区域大小，通常为3、5、7 C : 上面说的常数C 实例：可以看到自适应阈值化很好的保留了 边缘信息 。 123456789101112# 24.自适应阈值：adaptiveThresholdimage = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)image_gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)cv.imshow(&#x27;origin_gray&#x27;,image_gray)# 自适应阈值# 不知道为什么设置C=10,blockSize=5(区域大小为5*5=25)adaptive_binary = cv.adaptiveThreshold(image_gray,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,25,10)cv.imshow(&#x27;adaptive_binary&#x27;,adaptive_binary)cv.waitKey(0) 4 超大图像二值化 该部分主要参考：超大图像二值化和空白过滤 处理超大图像的思路其实就是分块思想： 将图像分成一个个小块 对每个小块进行 threshold 、adaptiveThreshold 二值化操作，获取二值化图像 将原图（灰度图像）对应区域覆盖为上述的二值化图像 分别使用全局阈值/局部阈值对分块图像进行处理比较。 左侧全局阈值处理，导致每个分块之间的图像差距较大，出现分块边界 现象。 右侧局部阈值处理，就没有明显的分块现象 12345678910111213141516171819# 25.超大图像二值化def big_image_binary(image): print(image.shape) #(4208, 2368, 3) cw,ch = 256,256 h,w = image.shape[:2] #要二值化图像，要先进行灰度化处理 gray = cv.cvtColor(image,cv.COLOR_RGB2GRAY) for row in range(0,h,ch): for col in range(0,w,cw): roi = gray[row:row+ch,col:col+cw] #获取分块 # 全局阈值 # ret,binary = cv.threshold(roi,0,255,cv.THRESH_BINARY|cv.THRESH_OTSU) # 局部阈值 binary = cv.adaptiveThreshold(roi,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,127,20) gray[row:row + ch, col:col + cw] = binary #分块覆盖 print(np.std(binary),np.mean(binary)) cv.imwrite(&quot;binary2.jpg&quot;,gray) 空白区域过滤 简单来说就是我们认为该区域是空白图像，不进行二值化（但可全变为黑或者白）。 123456789101112131415161718192021# 空白区域过滤def big_image_binary(image): print(image.shape) #(4208, 2368, 3) cw,ch = 128,128 h,w = image.shape[:2] gray = cv.cvtColor(image,cv.COLOR_RGB2GRAY) # 要二值化图像，要先进行灰度化处理 for row in range(0,h,ch): for col in range(0,w,cw): roi = gray[row:row+ch,col:col+cw] # 获取分块 # 通过获取分块区域的方差和平均值来判断是否是空白区域 dev = np.std(roi) avg = np.mean(roi) if dev &lt; 15 and avg &gt; 200: # 满足条件，接近空白区域，让他变黑 gray[row:row + ch, col:col + cw] = 0 #全部都赋值为0 else: ret,binary = cv.threshold(roi,0,255,cv.THRESH_BINARY|cv.THRESH_OTSU) gray[row:row + ch, col:col + cw] = binary print(np.std(binary), np.mean(binary)) cv.imwrite(&quot;binary.jpg&quot;,gray 2.6 图像缩放 如果要进行对图像进行 放大或缩小 通常有以下几种方法（在openCV中提供）： ⚠️ 以下方法都可以进行 放大或缩小 （具体怎么实现缩小图像，还待理解） INTER_NEAREST ：最近邻插值法 INTER_LINEAR ： 双线性插值法（默认） INTER_AREA ： 基于局部像素的重采样，缩小图像通常选择 INTER_CUBIC ： 基于4x4像素邻域的3次插值法 INTER_LANCZOS4 ： 基于8x8像素邻域的Lanczos插值 在 openCV 中可使用以下API实现对图像缩放： 简单粗暴的 resize 函数 ：实现效率最高 cv::pyrUP 、cv::pyrDown ：对图像进行上采样、下采样，常用于图像金字塔中，下详 2.6.1 缩放：resize 函数原型： 实例：演示如何使用 resize 函数对图像进行缩放。 123456789101112# 26.resize# image.shape = (640, 640, 3)image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)print(image.shape)cv.imshow(&#x27;origin&#x27;,image)# resize到 512*512,采用双线性插值# 彩色图虽然有三通道，但是只需指定长、宽就行resize_image = cv.resize(image,(512,512),interpolation=cv.INTER_LINEAR)cv.imshow(&#x27;resize_image&#x27;,resize_image)cv.waitKey(0) 2.6.2 图像金字塔：pyrUP 、pyrDown 图像金字塔是一系列图像的集合，所有图像来源于同一张原始图像，通过梯次向下采样获得。 通常有两种类型的图像金字塔 ： 高斯金字塔(Gaussian pyramid)：用来向下采样 拉普拉斯金字塔(Laplacian pyramid)：用来从金字塔底层图像重建上层未采样图像，可以对图像进行最大程度的还原. 高斯金字塔 高斯金字塔用于下采样过程可描述如下： 对图像进行高斯内核卷积，其中高斯内核= ❔​ 这一步卷积不会缩小图像尺寸吗？ 将所有偶数行、列去除，这样得到的图形长、宽是原图12\\frac{1}{2}21​ 。 在openCV中提供了pyrDown 函数来实现下采样： 实例：使用高斯金字塔来缩放图像。 123456789101112131415# 27.高斯金字塔image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)# resize到 512*512image = cv.resize(image,(512,512),interpolation=cv.INTER_AREA)cv.imshow(&#x27;origin&#x27;,image)level = 3pyramid_imgs = []for i in range(level): dst = cv.pyrDown(image) pyramid_imgs.append(dst) image = dst cv.imshow(&#x27;L&#x27;+str(i),dst)cv.waitKey(0) 拉普拉斯金字塔 拉普拉斯金字塔中使用了上采样，其上采样过程如下： 将图像在每个方向上扩大为原来的两倍，新增的行和列以0填充 使用先前同样的内核(乘以4)与放大后的图像卷积，或得”新增像素”的近似值 ⚠️ 同上疑问，卷积这一步不会改变图像大小吗？那就不是放大2倍了？ 在openCV中提供了pyrUp 函数来实现上采样： 拉普拉斯金字塔图像可不仅仅通过对图像向上采样就得到，具体操作如下： 通过高斯金字塔得到一系列不同层级(0-L)图像G 先对最高层级图像G[L] --&gt; 上采样(pyrUp)得到EP[L-1] --&gt; G[L-1] - EP[L-1] == 拉普拉斯图L[L-1] 对次高层图像G[L-1] --&gt; 上采样(pyrUp)得到EP[L-2] --&gt; G[L-2] - EP[L-2] == 拉普拉斯图像L[L-2] 重复步骤 2-3 ，直至高斯金字塔最低层（原图第一次下采样图） 显然，根据上述步骤，拉普拉斯金字塔是通过 源图下采样对应层级 - 上采样相应层级 获取。保留的残差，为图像还原做准备（🙂 此处复原不是很清楚 ）。 实例：获取拉普拉斯金字塔图像。 12345678910111213# 28.拉普拉斯金字塔# 下面 pyramid_imgs 表示高斯金字塔下采样获得图像集合for i in range(level-1,-1,-1): # 左闭右开从[2,-1)，递减选择步伐=-1 if i != 0: expand = cv.pyrUp(pyramid_imgs[i], dstsize=pyramid_imgs[i - 1].shape[:2]) lpls = cv.subtract(pyramid_imgs[i - 1], expand) else: # 此时已经放大至原图大小 expand = cv.pyrUp(pyramid_imgs[i], dstsize=image.shape[:2]) lpls = cv.subtract(image, expand) cv.imshow(&#x27;lpls&#x27;+str(i),lpls)cv.waitKey(0) 2.7 图像梯度 该部分主要参考清晰易懂的：图像梯度的基本原理 我们知道用 均值滤波器 等 ，可以降低图像噪声，但是会使得图像变得模糊 。 Q1 : 那么模糊图像和清晰图像又是怎么区分定义的呢？ 图像模糊：因为图像轮廓不明显，换言之，轮廓边缘灰度变化不强烈 ，层次感不强。 自然我们可以通过使得 轮廓灰度变得强烈 —&gt; 联系到 图像梯度 。 那么梯度又是如何增强图像清晰度呢？ 首先我们了解下如何计算图像的梯度。 我们知道图像是一个离散二维函数，那么其 x、yx、yx、y 方向梯度可定义如下： 显然这就相当于 梯度 = 2个相邻像素之间差值 考虑下面这张图：左部分是图像某个X方向像素变化值，右侧部分是该像素X方向梯度值。 将 原图X方向像素值+该X方向梯度=新图X方向像素值原图X方向像素值 + 该X方向梯度 = 新图X方向像素值原图X方向像素值+该X方向梯度=新图X方向像素值 。 这样：将有梯度值的相邻像素的灰度值变大了；而没有灰度值变换的像素值不变。 特别的，我们还可以将 x和yx和yx和y方向结合来计算新图像素值。计算公式如下： 一般使用拟合公式，简化计算： M(x,y)M(x,y)M(x,y) 即认为是梯度变化值，原图像像素加上该值便可获得最终新图像素值。 2.7.1 图像求导：Sobel、Scharr、Lapacian OpenCV提供三种不同梯度滤波器（高通滤波器）：Sobel，Scharr和 Lapacian ： Sobel、Scharr ：用于求图像一阶导或二阶导 Lapacian ：求图像二阶导，对 Sobel 的部分优化 Sobel &amp; Scharr 感觉就是定义卷积核，然后进行卷积。但是不知道为什么这样可以求导。 Sobel 算子 ：高斯平滑和微分操作的结合体，因此抗噪声能力很好 ddepth：指图像深度，目标图像深度必须 &gt;= 原图像深度。-1 表示和原图像深度一致。 dx、dy：表示求导的方向，0 表示这个方向不进行求导，1 表示有。 ksize：卷积核大小，当 ksize=-1 ，会使用 3*3 Scharr卷积核。它的效果比Sobel好 Scharr 算子： 以Scharr 算子为例：实现计算图像指定方向的梯度。 12345678910111213141516171819202122232425# 29.图像求导：Sobel、Scharr、Lapacian# 演示Scharr算子求导梯度，Sobel同理image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# Scharr算子对图像求导# 为什么使用CV_32F？# 因为Scharr算子求导后会有负值&amp;大于255值。而原图是unit8位，即8位无符号数。# 所以scharr建立图像位置不够，需要使用32F有符号数据类型。grad_x = cv.Scharr(image,cv.CV_32F,1,0)grad_y = cv.Scharr(image,cv.CV_32F,0,1)# 经过处理后，别用convertScaleAbs()函数将其转回原来的uint8形式。# 否则将无法显示图像，而只是一副灰色的窗口。# dst = cv2.convertScaleAbs(src[, dst[, alpha[, beta]]])# 可选参数alpha是伸缩系数，beta是加到结果上的一个值。结果返回uint8类型的图片grad_x = cv.convertScaleAbs(grad_x)grad_y = cv.convertScaleAbs(grad_y)cv.imshow(&#x27;gradx&#x27;,grad_x)cv.imshow(&#x27;grady&#x27;,grad_y)cv.waitKey(0) ⚠️ 上面图不适合演示增加图像清晰度，可看下面这张图： 梯度图是x、yx、yx、y 方向分别计算然后绝对值相加： Laplacian 算子 作用 对噪声敏感，会产生双边效果。不能检测出边的方向。通常不直接用边检测。一般用来检测一个像素是在边的亮的一边还是暗的一边利用零跨越，确定边的位置。 原理 图像中的边缘区域，像素值会发生“跳跃”，对这些像素求导，在其*一阶导数极值处就是边缘* 。 API 实例：利用 Laplacian 检测图像的边。 12345678910# Lapacianimage = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)dst = cv.Laplacian(image,cv.CV_32F,ksize=3)dst = cv.convertScaleAbs(dst)cv.imshow(&#x27;Lapacian&#x27;,dst)cv.waitKey(0) 2.7.2 Canny边缘提取 该部分主要参考：边缘检测之Canny 作用：提取图像边缘 流程：详细流程算法实现参考上述文章链接 使用高斯滤波器，以平滑图像，滤除噪声 计算图像中每个像素点的梯度强度和方向 应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应 应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘 通过抑制孤立的弱边缘最终完成边缘检测 API threshold1、threshold2即对应阈值T低、T高T_低、T_高T低​、T高​： 像素值&gt;T高像素值&gt;T_高像素值&gt;T高​ : 被认为是边缘像素，保留 T低&lt;像素值&lt;T高T_低&lt;像素值&lt;T_高T低​&lt;像素值&lt;T高​ : 当该像素和高于上限的像素点连接才保留 像素值&lt;T低像素值&lt;T_低像素值&lt;T低​ : 不认为是边缘像素，舍弃 一般设置 T高/T低=3:1T_高/T_低 = 3:1T高​/T低​=3:1 或者 T高/T低=2:1T_高/T_低 = 2:1T高​/T低​=2:1 实例：利用Canny函数进行边缘检测。 123456789# 30.canny边缘检测image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# canny边缘检测，可以使用这种不用提供gradx、grady的APIedge_detect = cv.Canny(image,50,150)cv.imshow(&#x27;edge detect&#x27;,edge_detect)cv.waitKey(0) 2.8 直线、圆、轮廓检测 2.8.1 直线检测：霍夫变换 给定一副图像（一般是二值图像，像素值对检测直线没有作用）如何检测是否存在直线？ 一种很直观的想法：任选一对点，决定一条线，然后测试所有其他点是否接近这条线，从而得出接近这条特殊线的所有点的子集。 但是这种方法比较复杂，我们通常使用的 霍夫变换 。 在了解霍夫变换，我们先来了解什么是 对偶性 。 对偶性 我所理解的对偶性：将直角坐标系的 点 对应 参数空间的 直线。 在直角空间x−yx-yx−y，过点A(x0,y0)A(x_0,y_0)A(x0​,y0​) 所有直线确定一簇直线，都满足方程：y0=k∗x0+by_0=k*x_0+by0​=k∗x0​+b 。 如果转换参数空间 k−bk-bk−b ，那么过点A(x0,y0)A(x_0,y_0)A(x0​,y0​) 所有 直线就可以描述为 一条 直线：b=−kx0+y0b=-kx_0+y_0b=−kx0​+y0​: 在参数空间k−bk-bk−b ，斜率是点 AAA 横坐标 −x0-x_0−x0​ , 截距是点AAA 纵坐标 y0y_0y0​ 那么如果在直角坐标系存在多个点在同一直线l1(斜率=k1,截距=b1)l_1(斜率=k_1,截距=b_1)l1​(斜率=k1​,截距=b1​)上，也就是说：它们在参数空间k−bk-bk−b 必然会交于一点 (k1,b1)(k_1,b_1)(k1​,b1​) 。 如果有n个点在一条直线上，那么在参数空间就会存在对应交于n个点，那么在参数空间相交直线最多的点(k,b)(k,b)(k,b) , 就是我们在 x−yx-yx−y 直角坐标对应直线斜率和截距的解 。 霍夫变化&amp;参数空间选择 上述参数空间是选择直角坐标系空间 k−bk-bk−b , 但是这样会带来一个问题：无法检测垂直直线 因此我们考虑将参数空间转换到极坐标系 r−θr-\\thetar−θ : ⚠️ 为什么映射到极坐标是曲线？ 为什么给定恒等式 xcosθ+ysinθ=pxcos\\theta+ysin\\theta=pxcosθ+ysinθ=p 进行变换？ 同前，在极坐标系相交最多的点(θ，p)(\\theta，p)(θ，p) ，便可转换到直角坐标系求解对应斜率和截距。 理论上，一个点会对应无数条直线，在参数空间 p−θp-\\thetap−θ 自然也是连续的。但事实上，我们会规定直线的数量，将 θ\\thetaθ 离散化为等间距离散值，相应ppp 也离散为等间距离散值。 这样，参数空间就是一个等大小*网格* 。当参数空间有直线相交于这个点，则网格累加器+1： HoughLines() 霍夫变换，利用openCV检测图像具体流程可总结如下： 彩色图像-&gt;灰度图 去噪（高斯核） 边缘提取（canny、sobel） ⚠️ Canny方法中包含计算梯度，非最大信号抑制和双阈值输出 二值化（判断此处是否为边缘点，就看灰度值==255） 映射到霍夫空间 取局部极大值，设定阈值，过滤干扰直线 绘制直线、标定角点 下面代码没有进行第三步二值化，是因为 canny自带二值化吗？ 对的 rho：生成极坐标像素扫描步长（离散化） theta：生成极坐标时扫描角度步长（离散化） threshold：只有足够交点的极坐标才被认为是直线 实例：利用openCV &amp; 霍夫变换来检测图像直线。 为什么检测直线图像上面总是出现这些不正常直线？ 12345678910111213141516171819202122232425262728293031323334353637383940# 31.霍夫变换image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\building.jpg&quot;)# 0.高斯滤波（效果也不好，最好取消这步了）# image = cv.GaussianBlur(image,(3,3),0)cv.imshow(&#x27;origin&#x27;,image)# 1.转换为灰度图gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)# 2.边缘检测canny# 分别设定阈值像素为50、150，sobel算子大小=3edges = cv.Canny(gray,50,150,apertureSize=3)# 3.霍夫变换# 生成极坐标扫描步长=1，角度=1°，至少有200个交点才认为是直线lines = cv.HoughLines(edges,1,np.pi/180,200)# 4.画出直线for line in lines: r,theta = line[0] # 极坐标p、θ # 计算直线两端点 # 为什么是这么计算也不清楚？ cos = np.cos(theta) sin = np.sin(theta) x0 = r*cos y0 = r*sin # 计算直线最大点(x1,y1) x1 = int(x0 + 1000 * (-sin)) y1 = int(x0 + 1000 * (cos)) # 计算直线最小点(x2,y2) x2 = int(x0 - 1000 * (-sin)) y2 = int(x0 - 1000 * (cos)) # 画出直线 cv.line(image,(x1,y1),(x2,y2),(0,0,255),2)cv.imshow(&#x27;detect line&#x27;,image)cv.waitKey(0) HoughLinesP() 霍夫概率变换是霍夫变换的加强版： 原理：暂略，待补 API：效果和API接口都比霍夫变换要好很多 实例：利用openCV &amp; 霍夫变换来检测图像直线。 123456789101112131415161718192021# 32.霍夫概率变换image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\building.jpg&quot;)# 0.进行高斯模糊（实测效果变好）# ksize和sigma可以互相计算，故指定sigmaX=0image = cv.GaussianBlur(image,(3,3),0)cv.imshow(&#x27;origin&#x27;,image)# 1.转换为灰度图gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)# 2.边缘检测cannyedges = cv.Canny(gray,50,150,apertureSize=3)# 3.霍夫概率变换lines = cv.HoughLinesP(edges,1,np.pi/180,200,minLineLength=50,maxLineGap=10)for line in lines: x1,y1,x2,y2 = line[0] cv.line(image, (x1, y1), (x2, y2), (0, 0, 255), 2)cv.imshow(&#x27;detect line&#x27;,image)cv.waitKey(0) 2.8.2 圆检测：霍夫变换 在前，若干点在同一直线上，则它们必有一条直线y=kx+by=k x+by=kx+b 经过它们。为了解算出k、bk、bk、b 我们将这 若干点 变换到极坐标参数空间k−bk-bk−b 得到对应 若干曲线 , 这些曲线若存在交点A(ka,ba)A(k_a,b_a)A(ka​,ba​) 则说明存在一条直线 y=kax+bay=k_a x+b_ay=ka​x+ba​ 使得它们在同一直线上。 那如何确定几个点是在同一圆上？ 在 x−yx-yx−y 坐标系，圆表达式可写作：(x−a)2+(y−b)2=r(x-a)^2+(y-b)^2 = r(x−a)2+(y−b)2=r 。 同样将其映射到参数空间 r−a−br-a-br−a−b 中。 ⚠️ 上有三个参数rabrabrab，在OpenCV中可通过设定rrr 范围，循环遍历rrr 值，则只在二维空间a−ba-ba−b 寻找圆心(a,b)(a,b)(a,b) 即可。 那么，在二维空间a−ba-ba−b , 圆(x−a)2+(y−b)2=r(x-a)^2+(y-b)^2 = r(x−a)2+(y−b)2=r 被映射成什么样子？ 显然也是个圆，此时圆心是 (x,y)(x,y)(x,y) , rrr 已知 ：(a−x)2+(b−y)2=r(a-x)^2+(b-y)^2 = r(a−x)2+(b−y)2=r 。 假设在 x−yx-yx−y 坐标系存在三个点 a(x1,y1)、b(x2,y2)、a(x2,y2)a(x_1,y_1)、b(x_2,y_2)、a(x_2,y_2)a(x1​,y1​)、b(x2​,y2​)、a(x2​,y2​) 。显然它们任意一个点，由于圆心(a,b)(a,b)(a,b) 不确定，在x−yx-yx−y 坐标系可以画出无数个圆。 三个点映射到 a−ba-ba−b 二维空间，则为确定的一个圆，圆心分别为a(x1,y1)、b(x2,y2)、a(x2,y2)a(x_1,y_1)、b(x_2,y_2)、a(x_2,y_2)a(x1​,y1​)、b(x2​,y2​)、a(x2​,y2​) 如果它们在同一个圆上，那么必然存在一个圆，圆心为(a1,b1)(a_1,b_1)(a1​,b1​) 半径为rrr ，都经过这三个点。换言之，在参数空间这三个点对应的圆必然会交于一个点(a1,b1)(a_1,b_1)(a1​,b1​) 。由于在假设半径rrr 值情况遍历搜寻，那么此时半径已知。至此，圆就被确定下来了。 当然，上述过程三个点在参数空间对应的圆交于一个点，就确定一个点还是太少了。实际可以指定更多点交于一个点才认为确实存在圆。 HoughCircles() 下面是基本API用法。 method : 检测圆方法，例如霍夫梯度法：CV_HOUGH_GRADIENT dp：检测圆心的累加器图像的分辨率于输入图像之比的倒数。dp= 1时，累加器和输入图像具有相同的分辨率。如果dp=2，累加器便有输入图像一半那么大的宽度和高度 minDist：圆的圆心之间的最小距离。参数如果太小，多个相邻的圆可能被错误地检测成了一个重合的圆。反之，参数设置太大的话，某些圆就不能被检测出来了。 param1：默认值100。是第三个参数method设置的检测方法的对应的参数，对于霍夫梯度法CV_HOUGH_GRADIENT，它表示传递给canny边缘检测算子的高阈值，低阈值为高阈值的一半。 param2：默认值100。同上，对于霍夫梯度法CV_HOUGH_GRADIENT，它表示检测阶段圆心的累加器阈值。它越小的话，就可以检测到更多根本不存在的圆，而它越大的话，能通过检测的圆就更加接近完美的圆形了。 minRadius、maxRadius ： 表示设置圆半径的最小值和最大值。 实例：使用HoughCircles() 检测图像中存在的圆形。 123456789101112131415161718192021# 33.霍夫变换圆检测image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\circles.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# 霍夫变换易受噪声影响，先进行均值漂移滤波减少噪声dst = cv.pyrMeanShiftFiltering(image,10,100)# 转换为灰度图gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)# 霍夫变换圆检测# param1、param2调参很重要。最开始param1=50，效果很差，canny的高阈值设置太低circles = cv.HoughCircles(gray,cv.HOUGH_GRADIENT,1,20,param1=100,param2=30,minRadius=0,maxRadius=0)# 画圆[注意维度问题]# circles.shape=（1,3,3）,第一个维度不明。第二个维度是圆个数，第三个维度对应圆三个参数for i in circles[0,:]: cv.circle(image,(i[0],i[1]),i[2],(0,0,255),2)cv.imshow(&#x27;circles&#x27;,image)cv.waitKey(0) 2.8.3 轮廓检测 原理 待补充 findContours 原理不懂，API看得也稀里糊涂的。参数意义可以参考 ：轮廓发现 整个API操作步骤可以总结如下： 对图像进行高斯滤波，减少噪声 转换为二值图像：threshold 或者 canny 边缘提取都可 通过二值图像寻找轮廓：findContours 描绘轮廓：drawContours 实例1：寻找图像轮廓（通过threshold获取二值图像） 1234567891011121314151617181920212223242526272829# 34.轮廓发现（通过threshold获取二值图像）image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\circles.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# 0.高斯滤波图像减少噪声GaussianImg = cv.GaussianBlur(image,(3,3),0)# 1.转换为灰度图像grayImg = cv.cvtColor(GaussianImg,cv.COLOR_BGR2GRAY)# 2.threshold 获取二值图像# 如果选择二值方式是 cv.THRESH_BINARY，由于原图像素&gt;0,结果就是二值化图全白色# cv.THRESH_OTSU：是最大间差法，按图像灰度特性将图像分为前景和背景两部分ret,binaryImg = cv.threshold(grayImg,0,255,cv.THRESH_BINARY|cv.THRESH_OTSU)cv.imshow(&#x27;binaryImg&#x27;,binaryImg)# 3.findContours 轮廓提取# cv.RETR_EXTERNAL 获取外部轮廓 ； cv.CHAIN_APPROX_SIMPLE cloneImage,contours,heriachy= cv.findContours(binaryImg,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)# 4. drawContours 绘出轮廓for i,contour in enumerate(contours): # 注意第二个参数是传递所有轮廓！ cv.drawContours(image,contours,i,(0,0,255),-1) print(i)cv.imshow(&#x27;detect contours&#x27;,image)cv.waitKey(0) 实例2：寻找图像轮廓（通过canny获取二值图像） 123456789101112131415161718192021222324# 35.轮廓发现（通过canny获取二值图像）image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\circles.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# 0.高斯滤波图像减少噪声GaussianImg = cv.GaussianBlur(image,(3,3),0)# 1.转换为灰度图像grayImg = cv.cvtColor(GaussianImg,cv.COLOR_BGR2GRAY)# 2.canny 获取二值图像binaryImg = cv.Canny(grayImg,50,150)cv.imshow(&#x27;binaryImg&#x27;,binaryImg)# 3.findContours 轮廓提取cloneImage,contours,heriachy= cv.findContours(binaryImg,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)# 4. drawContours 绘出轮廓for i,contour in enumerate(contours): cv.drawContours(image,contours,i,(0,0,255),-1)cv.imshow(&#x27;detect contours&#x27;,image)cv.waitKey(0) 2.9 对象测量 这部分对象测量主要包含两个部分： 基于前2.8 节 发现轮廓 后对轮廓进行 计算弧长和面积 对发现的轮廓进行多边形拟合 2.9.1 面积&amp;多边形拟合… 原理 待补充 API cv.contourArea(contour) ：获取每个轮廓面积 cv.boundingRect(contour) ：获取轮廓的外接矩形 cv.moments(contour) ：求取轮廓的几何距 cv.arcLength(contour,True) ：求取轮廓的周长，指定闭合 过程总结 获取灰度图像：cvtColor 二值化图像：threshold 或 canny 发现轮廓：findContours 计算面积 / 周长/多边形拟合 等 实例：获取图像面积、绘出外接矩形框、根据几何距计算轮廓中心（不明白原理） 12345678910111213141516171819202122232425262728293031323334353637383940414243# 36.对象测量# 计算面积、绘出外接矩形、根据几何距计算轮廓中心（不明白）image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\circles.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# 1.转换为灰度图像grayImg = cv.cvtColor(image,cv.COLOR_BGR2GRAY)# 2.threshold 获取二值图像ret,binaryImg = cv.threshold(grayImg,0,255,cv.THRESH_OTSU)cv.imshow(&#x27;binaryImg&#x27;,binaryImg)# 3.发现轮廓cloneImage,contours,heriachy= cv.findContours(binaryImg,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)# 4.计算轮廓面积、外接矩形、求中心点# debug：在二值图像化没反应？for i,contour in enumerate(contours): # 计算轮廓面积 area = cv.contourArea(contour) # print(area) # 绘制外接矩形 x,y,w,h = cv.boundingRect(contour) cv.rectangle(image,(x,y),(x+w,y+h),(0,0,255),1) # 根据几何距获取中心点并绘制 m = cv.moments(contour) # 获取几何距 if m[&#x27;m00&#x27;] == 0: # 有可能出现 m[&#x27;m00&#x27;] == 0 continue else: cx = m[&#x27;m10&#x27;] / m[&#x27;m00&#x27;] # 中心x cy = m[&#x27;m01&#x27;] / m[&#x27;m00&#x27;] # 中心y cv.circle(image,(np.int(cx),np.int(cy)),1,(0,255,0),-1) # 拟合多边形 # 4是与阈值的间隔大小，越小越易找出，True是是否找闭合图像 # 返回拟合曲线 approxCurve = cv.approxPolyDP(contour, 4, True) # 如果拟合曲线的边数大于4则绘出（三角形、四边形等&lt;=4就不会绘出） if approxCurve.shape[0] &gt; 4: cv.drawContours(image, contours, i, (255, 0, 0), 2) cv.imshow(&#x27;draw&#x27;,image)cv.waitKey(0) 2.10 图像形态学"}],"posts":[{"title":"C++从零开始（十二）：Linux系统编程入门","slug":"C++从零开始（十二）：Linux系统编程入门","date":"2022-04-03T05:45:34.660Z","updated":"2022-06-16T14:09:21.171Z","comments":true,"path":"p/45495/","link":"","permalink":"https://hwh.zone/p/45495/","excerpt":"","text":"🌟《C++从零开始》 系列，毕业论文初稿写完三个月过去，终于又开始更新了…🥗 C++从零开始https://hwh.zone/p/62712 Linux系统编程作为《C++从零开始》三部曲之一，自有其极其重要的地位。 如果将Linux比作为一台性能出众的跑车，我们一定不会只满足于驾驶它上下班，只会挂挡、踩油门和控制方向之类的基本操作。我们想要更加了解它，挖掘更多的潜能。 学习系统编程便是让你做到这一点。 Linux系统内容纷繁复杂，在学习过程中《Linux系统编程手册》使我受益良多。在本部曲中，我将尽量用简洁的语言进行总结和扩展。 好了，轻松一点，让我们先从Linux的前身——UNIX历史说起吧。 UNIX历史 UNIX和C简史 1969年，bell实验室（隶属AT&amp;T电话公司），Ken Thompson，开发出了首个 UNIX 系统。 UNIX 是MULTICS（多信息及计算服务，Multiplexed Information and Computing Service）一词的双关语。 1970年，AT&amp;T 的工程师，在Digital PDP-11 小型机以汇编语言重写了UNIX。 1971年，Thompson 在 bell 实验室的同事，Dennis Ritchie设计实现了C语言。 C 语言由于其高效、灵活、功能丰富、表达力强和较好的可移植性等特点，迅速风靡起来。 1973 年，UNIX 已经被移植到了 PDP-11 小型机上，并以 C 语言对UNIX进行了重写。 1977年，因为法律禁止 AT&amp;T销售 UNIX，AT&amp;T公司允许高校使用UNIX，极大促进了UNIX的发展。第七版 UNIX 发布的重要意义还在于，从该版本起，UNIX 分裂为了两大分支：BSD 和 System V。 1979年，伯克利发布首个完整的，属于自己 UNIX 发布版 3BSD（伯克利软件发布，Berkeley Software Distribution）诞生。 在此期间，随着 AT&amp;T 不再对电信市场形成垄断，该公司被获准销售 UNIX。这也就催生出了另一种 UNIX 的变种—System V，日后，它也成为了某些商业 UNIX 实现的基石。 1983 年，加州大学伯克利分校的计算机系统研究组（Computer Systems Research Group）发布了 4.2BSD。 该版本的发布意义深远，因为其包含了完整的 TCP/IP 实现，其中包括套接字应用编程接口（API）以及各种网络工具。 Linux简史 在当时UNIX时代，计算机软件的消费者不但无权阅读自己所购软件的源码，而且还不能复制、更改及重新发行所购软件。Stallman认为，这只会造成程序员之间勾心斗角、敝帚自珍的局面，无法实现工作协同和成果共享。 1984年，MIT 的程序员Richard Stallman，发起了 GNU 项目（“GNU’s not UNIX”的递归缩写形式）。 GNU 项目由此制定了 GNU GPL协议：以 GPL 许可协议发布的软件不但必须开放源码，而且应能在 GPL 条款的约束下自由对其进行重新发布。可以不受限制的修改以 GPL 许可协议发布的软件，但任何经修改后发布的软件仍需遵守 GPL 条款； GNU 项目还开发出了Emacs 文本编辑器、GCC、bash shell 以及 glibc（GNU C 语言库），只要再拥有一个能够有效运作的内核，就能使 GNU 项目开发出的UNIX 系统“功德圆满”。 1991 年，Linus Torvalds，开发出UNIX内核“雏形”，可以编译并运行各种 GNU 程序。 为了传承 UNIX 历史悠久的光荣传统，总以字母“X”结尾，人们最终将这一内核命名为 Linux。 应 Torvalds 之邀，许多其他程序员也加入到了改进内核的行列中。随着时光的流逝，在一干程序员的不懈努力下，Linux 逐渐发展壮大，并被移植到了多种硬件架构之上。 标准化过程 20 世纪 80 年代末，UNIX 和 C 语言的实现“百花齐放”，所引发的可移植性问题迫使人们开展针对以上两者的标准化工作。 C 语言和 UNIX 系统的标准化进程也显得愈发重要。 C标准 C 语言标准独立于任何操作系统，换言之，C 语言并不依附于 UNIX 系统。 1989 年，美国国家标准委员会ANSI的C 语言标准（C89标准）获批。 这份标准在定义 C 语言语法和语义的同时，还对标准 C 语言库操作进行了描述，这包括 stdio 函数、字符串处理函数、数学函数、各种头文件等等。 随之于 1990 年，C89标准被国际标准化组织ISO采纳； 1999年，ISO 对 C 语言标准的修订版，C99标准正式被批准。 对 C 语言及其标准库的一系列修改，诸如，增加了 long long 和布尔数据类型、C++风格的注释（//）、受限指针以及可变长数组等。 操作系统接口 1989年，操作系统标准化的“第一次吃螃蟹”便催生出了 POSIX.1。 术语“POSIX（可移植操作系统 Portable Operating System Interface 的缩写）”； 符合 POSIX.1 标准的操作系统应向程序提供调用各项服务的 API，POSIX.1 文档对此作了规范。凡是提供了上述 API 的操作系统都可被认定为符合 POSIX.1 标准。 1988 年和 1990 年，IEEE 和 ISO 先后将 POSIX.1 采纳为标准。 2001 年，POSIX 1003.1-2001 标准颁布，取代了 SUSv2、POSIX.1、POSIX.2 以及大批的早期 POSIX 标准。 2008 年，人们继续完成对POSIX标准和 SUS 规范的修订，于是，合二为一的 POSIX 1003.1-2008 和 SUSv4 标准浮出水面。 对Linux发展历史有了简单了解后，我们再来了解Linux系统编程的一些基本概念吧。 一、基本概念 在本章中，主要将介绍Linux&amp;系统编程的基本概念，以期更好地理解后续章节。 1.1 Linux基本概念 1.1.1 操作系统与内核 操场系统与内核表现为包含关系。 操作系统，指完整的软件包，这包括用来管理计算机资源（即CPU、RAM和设备）的核心层软件，以及附带的所有标准软件工具，诸如命令行解释器、图形用户界面、文本编辑器等； 内核，则特指管理资源的核心层软件。 内核有什么用？ 内核所提供的核心层软件，一般执行以下主要任务： 进程调度，即用于控制进程对CPU使用。 CPU在一时间段只能执行一个任务，而Linux属于抢占式多任务操作系统，这意味着多个进程（一个运行中的程序我们称之为“进程”）可同时驻留在内存。分配CPU何时给哪些进程使用，以及每个进程能使用多长时间，都需要内核进行进程调度。 进程通信，用于多进程之间进行通信。 内存管理，而物理内存（RAM）仍然属于有限资源，内核必须以公平、高效地方式在进程间共享这一资源。 Linux通常采用虚拟内存管理机制，它有以下好处： 内存隔离，进程与进程之间&amp;进程与内核之间隔离。因此一个进程无法读取其它进程或内核的内容。 只需将进程一部分保存在内存中。不但降低了每个进程对内存的需求量，而且还能在 RAM 中同时加载更多的进程 文件系统，内核在磁盘之上提供了文件系统。 IO设备访问，如键盘、打印机等。 网络连接，内核以用户进程的名义收发网络消息（数据包）。 提供系统调用应用编程接口（API）：进程可利用内核入口点（也称为系统调用）请求内核去执行各种任务。 以上内容每一部分都将后续扩展开来分析探讨。 内核态和用户态 CPU 可在用户态和核心态两种不同状态运行，对应地将虚拟内存区域划分（标记）为用户空间部分或内核空间部分。 用户态，CPU 只能访问被标记为用户空间的内存，无法执行不利于系统运行的操作。 核心态，CPU 既能访问用户空间内存，也能访问内核空间内存，也能执行一些核心操作如：执行宕机（halt）指令去关闭系统，访问内存管理硬件等。 这样做保证了系统的安全和效率。 1.1.2 shell shell 也称之为命令解释器，主要用于读取用户输入的命令，并执行相应的程序以响应命令。 纵观 UNIX 历史，出现过以下几种重要的 shell（按时间顺序）： Bourne shell (sh)，历史最为悠久，由Steve Boume编写。Bourne shell 包含了在其他 shell 中常见的许多特性，I/O 重定向、管道、文件名生成（通配符）、变量、环境变量处理、命令替换、后台命令执行等。 C shell（csh），由 Bill Joy编写而成，控制语法与C语言有很多相似之处而因此得名。C shell 与 Bourne shell 并不兼容，且包含一些极为实用的特性，如命令历史记录，命令编辑等。 Korn shell（ksh），由David Korn 编写，不但兼容了sh还吸收了csh相关特性。 Bourne again shell（bash），这款 shell 是 GNU 项目对 Bourne shell 的重新实现，提供了与 C shell 和 Korn shel 所类似的交互式特性。 不过，设计 shell 的目的不仅仅是用于人机交互，对 shell 脚本（包含 shell 命令的文本文件）进行解释也是其用途之一。为实现这一目的，每款 shell 都内置有许多通常与编程语言相关的功能，其中包括变量、循环和条件语句、I/O 命令以及函数等。 1.1.3 用户和组 系统会对每个用户的身份做唯一标识，用户可隶属于多个组。 用户 系统的每个用户都拥有唯一的登录名（用户名）和与之相对应的整数型用户ID（UID）。 在系统文件/etc/passwd 显示了更具体的信息。 123456[root@roy-cpp cpp-learn]# cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologin... 以上7个字段分别对应：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 。下面对其中部分字段进行解释： 口令，一些系统中，存放着加密后的用户口令字，但这存在安全隐患。因此，在Linux使用了shadow技术，使用x或*进行替代，而把真正的加密后的用户口令字存放到/etc/shadow文件中。 用户标志号，即UID，为一个整数，范围为0~65535。0是超级用户root的标识号，1-99由系统保留，作为管理账号，普通用户的标识号从100开始。 组标志号，即GID，记录用户所属的用户组，对应着/etc/group文件中的一条记录。 注释性描述，记录着用户的一些个人情况，但并没有什么实际的用途。 主目录，用户在登录到系统之后所处的目录，各用户对自己的主目录有完整的读（r）、写（w）、执行（x）权限。 登陆shell，用户登录到系统后运行的命令解释器，即shell。 在/etc/passwd我们也注意到，除了我们熟知的root账户，还有一些其它系统账户：bin（拥有可执行的用户命令文件）、sys（拥有系统文件）、adm（拥有帐户文件）。 组 出于管理目的，比如为了控制对文件和其他资源的访问，将多个用户分组是非常实用的做法。 每个用户组都对应着系统组文件/etc/group 中的一行记录： 12345[root@roy-cpp cpp-learn]# cat /etc/grouproot:x:0:bin:x:1:daemon:x:2:sys:x:3: 以上4个字段分别对应， 组名:口令:组标识号:组内用户列表。 其中组内用户列表，是属于这个组的所有用户的列表，不同用户之间用逗号,分隔。 1.1.4 目录与文件 目录 Linux目录具有以下特点： 单根目录结构，Linux内核维护一套单根目录结构，存放系统所有文件。这和我们熟知Windows系统不同，它的每个磁盘（如C盘）都有各自的目录层级。 绝对路径与相对路径。 绝对路径以/开始，如上图中/etc/passwd ； 相对路径不以/开始，如上图中，在usr目录下，include/sys/types.h 、../home/mtk/.bashrc 分别可引用文件types.h和.bashrc。 文件 Linux文件主要值得关注以下三点： 文件类型，在Linux文件系统内，“一切皆为文件”。这意味着文件类型不仅包含普通文本文件，还包含：设备、管道、套接字、目录、符号链接等。 文件名，文件名最长可达 255 个字符。文件名可以包含除/和空 字符（\\0）外的所有字符。 此外，还应避免以连字符-作为文件名的起始字符，因为一旦在 shell 命令中使用这种文件名，会被误认为命令行选项开关。 文件IO模型，UNIX 系统 I/O 模型最为显著的特性之一是其 I/O 通用性概念。 也就是说，同一套系统调用（open()、read()、write()、close()等）所执行的 I/O 操作，可施之于所有文件类型，包括设备文件。 另外，值得注意的是，UNIX系统本质只提供字节流文件，因此没有“文件结束符”的概念。UNIX系统read()如何判断文件结束？读取文件时如无数据返回，便会认定抵达文件末尾。 1.1.5 进程 进程是正在执行的程序实例。 执行程序时，内核会将程序代码载入虚拟内存，为程序变量分配空间，建立内核记账（bookkeeping）数据结构，以记录与进程有关的各种信息（比如，进程 ID、用户 ID、组 ID 以及终止状态等）。 进程内存布局 下图展示了一个虚拟进程（程序）内存空间运行时分布布局。高地址的1GB（Windows默认2GB）空间分配给内核，也称为内核空间；剩下的3GB分给用户，也称用户空间（程序使用的）。 一个进程本质是由代码段、数据段、堆、栈四部分组成的 。 作为程序员，我们更关注的是用户空间中的内容，也就是： 栈（Stack）：存储代码中调用函数、定义局部变量(但不包含static修饰的变量)、保存的上下文等； 特点：存放的数据从栈顶（低地址）压入，也是从栈顶（低地址）弹出，所以有人说栈是向下生长的。函数退出时，所有数据会自动释放内存（出栈）。 文件映射区域 ： 栈和堆中间那个空白区域。动态库、共享内存等映射物理空间的内存，一般是 mmap 函数所分配的虚拟地址空间。 堆（Heap）：存储那些生存期与函数调用无关的数据，如动态分配的内存。堆（动态）分配的接口通常有malloc()、calloc()、realloc()、new等。 特点：相对于栈，堆是向上生长的；堆空间需要主动释放，否则会依然存在。 数据段（.data）：保存全局变量、常量、静态变量的内容的一块内存区域。 代码段（.text &amp; .init）： .text 用于存放整个程序中的代码， .init 用于存放系统中用来初始化启动你的程序的一段代码 。 进程创建、执行及终止 进程创建调用fork()函数，新创建进程被称为子进程。正如“fork”所暗示的， 子进程会复制父进程数据段、堆、栈等的副本并可以进行修改； 代码段在内存被标记为只读，则由父、子进程共享。 进程执行往往指的是，1）执行父进程共享代码其它函数，或2）调用execve()去加载执行全新程序。 execve()会销毁所有代码段、数据段及堆栈内容，并根据新段创建新段进行替换； 以execve()为基础，C语言库提供以“exec”打头的相关函数。 进程终止往往可通过，1）调用_exit()函数，或2）向进程传递信号杀死。 根据惯例，终止状态为 0 表示进程“功成身退”，非 0 则表示有错误发生。 特殊进程 init进程 系统引导时，内核会创建一个名为 init 的特殊进程，其主要任务是创建并监控系统运行所需的一系列进程。 1生万物，init 进程的进程号总为 1，且总是以超级用户权限运行，系统的所有进程不是由 init（使用 frok()）“亲自”创建，就是由其后代进程创建。 与日同辉，谁（哪怕是超级用户）都不能“杀死”init 进程，只有关闭系统才能终止该进程。 守护进程 守护进程指的是具有特殊用途的进程，系统创建和处理此类进程的方式与其他进程相同，但以下特征是其所独有的： 长生不老，守护进程通常在系统引导时启动，直至系统关闭前，会一直“健在”。 后台运行，且无控制终端供其读取或写入数据。 守护进程中的例子有 syslogd（在系统日志中记录消息）和 httpd（利用 HTTP 分发 Web 页面）。 环境列表 每个进程都有一份环境列表，即在进程用户空间内存中维护的一组环境变量。这份列表的每一元素都由一个名称及其相关值组成。 由 fork()创建的新进程，也会继承父进程的环境副本。 在大多数shell中，我们使用export命令进行创建环境变量： 123[root@roy-cpp cpp-learn]# export myval=&#x27;hello unix&#x27;[root@roy-cpp cpp-learn]# echo $myvalhello unix 我们还可以打印已预定义的环境变量： PATH，用户输入命令后，shell搜索的目录列表； HOME，用户登陆目录的路径名。 1234[root@roy-cpp cpp-learn]# echo $PATH /root/.vscode-server/bin/f80445acd5a3dadef24aa209168452a3d97cc326/bin/remote-cli:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin[root@roy-cpp cpp-learn]# echo $HOME/root 这些预定义的变量也很好地可以直接被shell脚本和程序进行访问。 进程通信 Linux 系统上运行有多个进程，有些进程必须相互合作以达成预期目的，因此彼此间需要通信和同步机制。 读写磁盘文件中的信息，来进程间通信是一种容易被接受且简单可行的办法。 但这种方法既慢又缺乏灵活性。因此，像所有现代 UNIX 实现那样，Linux 也提供了丰富的进程间通信（IPC）机制，如下所示。 信号（signal），用来表示事件的发生。 管道（亦即 shell 用户所熟悉的“|”操作符）和 FIFO，用于在进程间传递数据。 套接字，供同一台主机或是联网的不同主机上所运行的进程之间传递数据。 消息队列，用于在进程间交换消息（数据包）。 信号量（semaphore），用来同步进程动作。 共享内存，允许两个及两个以上进程共享一块内存。当某进程改变了共享内存的内容时，其他所有进程会立即了解到这一变化。 1.1.6 内存映射 内存映射（Memory-mapped，mmap），即将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和应用程序进程虚拟地址空间中一段虚拟地址的映射关系。 特别的，由某一进程所映射的内存可以与其他进程的映射共享。 有两种方式可以做到这一点： 两个进程都针对某一文件的相同部分加以映射； 由 fork()创建的子进程自父进程处继承映射。 但这也由此引发了一个问题：某个进程对共享页面内容的改动一定会为其他进程所见吗？ 其实这取决于创建映射时所传入的标志参数。 若传入标志为私有，则某进程对映射内容的修改对于其他进程是不可见的，而且这些改动也不会真地落实到文件上； 若传入标志为共享，对映射内容的修改就会为其他进程所见，并且这些修改也会造成对文件的改动。 内存映射用途很多，如文件 I/O（即映射内存 I/O）以及进程间通信（通过共享映射）。在后续我们还会更深入的探讨。 1.1.7 信号 尽管1.5.5将信号视为 IPC 的方法之一，但其在其他方面的广泛应用则更为普遍。 人们往往将信号称为“软件中断”。进程收到信号，就意味着某一事件或异常情况的发生。 信号的类型很多，每一种分别标识不同的事件或情况。采用不同的整数来标识各种信号类型，并以 SIGxxxx 形式的符号名加以定义。 信号发送，内核、其他进程（只要具有相应的权限）或进程自身均可向进程发送信号。 发生下列情况之一时，内核可向进程发送信号： 用户键入中断字符（通常为 Control-C）。 进程的子进程之一已经终止。 由进程设定的定时器（告警时钟）已经到期。 进程尝试访问无效的内存地址。 在 shell 中，可使用 kill 命令向进程发送信号。在程序内部，系统调用 kill()可提供相同的功能。 信号回复，收到信号时，进程会根据信号采取如下动作之一： 忽略信号。 被信号“杀死”。 先挂起，之后再被专用信号唤醒。 就大多数信号类型而言，程序可选择不采取默认的信号动作，而是忽略信号或者建立自己的信号处理器。信号处理器是由程序员定义的函数，会在进程收到信号时自动调用，根据信号的产生条件执行相应动作。 1.1.8 线程 在现代 UNIX 实现中，每个进程都可执行多个线程。 什么是线程？ 线程是操作系统能够进行运算调度的最小单位，被包含在进程之中，是进程中的实际运作单位。 每个线程都会执行相同的程序代码，共享同一数据区域和堆； 每个线程都拥有属于自己的栈，用来装载本地变量和函数调用链接信息。 为什么需要线程？ 线程的主要优点： 协同线程之间的数据共享（通过全局变量）更为容易、自然； 多线程创建、销毁等开销小； CPU利用率高，如果一个子任务阻塞，程序可以将CPU调度到另外一个子任务进行工作。这样CPU还是保留在本程序中，而不是被调度到别的进程去。这样，提高了本程序所获得的CPU时间和利用率。 线程之间如何通信？ 利用前述进程之间的通信方式（IPC）； 利用共享的全局变量进行通信，借助于线程 API 所提供的条件变量和互斥机制，进程所属的线程之间得以相互通信并同步行为。 1.1.9 会话、控制终端和控制进程 会话、控制终端和控制进程之间概念和关系如下。 会话 会话是一个或多个进程组的集合，会话中的所有进程都具有相同的会话标识符。 会话与shell的关系？ 使用会话最多的是支持任务控制的 shell，由 shell 创建的所有进程组与 shell 自身隶属于同一会话，shell 是此会话的会话首进程。 控制终端 当一个终端与一个会话相关联后，那么这个终端就称为该会话的控制终端，建立与控制终端连接的会话首进程（一般是shell）被称为控制进程(controlling process)。 控制终端关闭时，会话中各个进程的变化？ 简单来说，shell进程和前台所有进程会退出，后台无终端输出进程退出。 首先会发一个挂断信号SIGHUP给会话首进程（一般为shell），即shell进程退出。 当会话首进程shell退出时，挂断信号（SIGHUP）还会继续发送给前台进程组和后台有终端输出的所有进程。 若进程未对挂断信号（SIGHUP）进行处理时，所有收到该信号的进程将被终止。 如何让进程在终端关闭时，不受其影响进行执行？ 根据前述，若想进程在终端关闭时不受影响： 如果该进程无终端输出，让该进程成为后台进程； 如果该进程有终端输出，还忽略SIGHUP信号； 让程序对挂断信号SIGHUP进行处理。 针对1、2我们可以使用命令： 1nohup &lt;command&gt; &amp; nohub，忽略所有挂断（SIGHUP）信号； &amp;，程序进程进入后台运行。 实例：nohub python run.py &amp; 。 针对3，我们还可以让程序自动具备防退出功能。 123456789101112131415161718192021#include &quot;apue.h&quot;#include &lt;fcntl.h&gt; // 处理程序static void sig_hup(int signo)&#123; printf(&quot;received signup\\n&quot;);&#125; static int count; int main(void)&#123; setbuf(stdout,NULL); printf(&quot;pid = %d\\n&quot;,getpid()); // 注册挂断信号(SIGHUP)的处理程序 // 这样一来，我们的程序就不会因收到挂断信号而退出了 signal(SIGHUP, sig_hup); while(1) &#123; count++; &#125; exit(0);&#125; 1.10 /proc目录 Linux系统上的/proc目录是一种文件系统，即proc文件系统。 /proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件： 查看系统有关（1）硬件及当前（2）正在运行进程的信息； 更改其中某些文件来改变内核的运行状态。 例如，查看磁盘信息： 1234567[root@roy-cpp proc]# cat /proc/devices Character devices: 1 mem 4 /dev/vc/0 4 tty 4 ttyS... 1.2 系统编程基本概念 什么是系统编程？ 系统编程，是指进程（或者说程序）以API形式，去调用系统内核提供的一系列服务如： 创建进程 执行IO 进程通信 … 等来完成程序编写。 可以看到前述核心过程是调用系统内核服务，也就是我们常说的系统调用。 1.2.1 系统调用 在深入系统调用的运作方式之前，请务必牢记以下几点： 检测返回状态，无论何时，只要执行了系统调用或者库函数，检查调用的返回状态以确定调用是否成功，这是一条编程铁律。 核心态切换，系统调用将处理器从用户态切换到核心态，以便 CPU 访问受到保护的内核内存。 每个系统调用由数字标识，系统调用的组成是固定的，每个系统调用都由一个唯一的数字来标识。 每个系统调用都有对应参数。 现在我们来以具体的硬件平台x86-32为例，来分析系统调用发生时的步骤： 调用外壳函数，应用程序通过设置相应的参数来调用 C 语言函数库中的外壳函数，然后发起系统调用； 参数传入寄存器，内核希望将这些函数参数置入特定寄存器，因此，外壳函数会将上述参数复制到寄存器； 系统调用编号传入寄存器%eax，由于所有系统调用进入内核的方式相同，内核需区分每个系统调用，为此，外壳函数会将系统调用编号复制到一个特殊的 CPU 寄存器（%eax）中； 执行中断，外壳函数执行中断机器指令（int 0x80）→处理器从用户态切换到核心态→执行系统中断 0x80； 响应中断，保存寄存器值→审核系统编号有效性→查询服务列表sys_call_table→执行系统调用→返回状态参数给sys_call()； 关于sys_call_table，在 Linux/x86-32 上，execve()的系统调用号为 11(__NR_execve)。因此，在 sys_call_table 向量中，条目 11 包含了该 系统调用的服务例程 sys_execve()的地址。 结束中断，内核栈中恢复各寄存器值→系统调用返回值置于栈中→处理器切回用户态。 返回值错误处理，若系统调用服务例程的返回值表明调用有误，外壳函数会使用该值来设置全局变量 errno。 1.2.2 C语言函数库glibc GNU C 语言函数库[glibc](http://www. gnu.org/software/libc/)，是 Linux 上最常用的实现。 查看一下我们机器上的glibc版本吧： 12[root@roy-cpp TLPI]# /lib64/libc.so.6 GNU C Library (GNU libc) stable release version 2.17, by Roland McGrath et al. 动态库libc.so.6 可视为可执行文件，输出当前glibc版本，一般位于目录/lib64/libc.so.6 或 /lib/libc.so.6 下。 1.2.3 处理返回的错误 不检查状态值，少敲几行代码听起来的确诱人，但实际却得不偿失。 每个系统调用和库函数都会返回某类状态值，要了解调用是否成功，必须坚持对状态值进行检查。 这能节约我们大把的程序调试时间。 处理系统调用错误 绝大部分系统检查调用错误信息步骤： 先检查系统调用返回值是否错误（为-1），如果错误转2； 继续检查 errno号，来确定具体错误。 下面举一个例子。 123456789cnt = read(fd,buf1,len);if(cnt == -1) // 检查返回值&#123; if(errno == EINTR) // 检查errno号 std::cout &lt;&lt; &quot;read was interrupted by a signal.&quot; ; else // do something exit(-1);&#125; 检查errno号也可以直接替换使用perror(char* str) 函数，其会打印我们输入字符串str + 当前error对应的错误信息。 以下是一个更完整的例子展示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;fcntl.h&gt; /* For O_RDWR */#include &lt;unistd.h&gt; /* For open(), creat() */#include &lt;stdio.h&gt; #include &lt;string.h&gt; /* For strlen()*/#include &lt;stdlib.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;iomanip&gt; /* For setw() */int main()&#123; int fd = 0; int cnt = 0; char filename[20] = &quot;./test/1.txt&quot;; // 打开文件 fd = open(filename,O_RDWR|O_EXCL|O_TRUNC,S_IRWXG); std::cout &lt;&lt; &quot;open the file.&quot; &lt;&lt; std::endl; if(fd == -1) // 判断文件是否成功打开 &#123; perror(&quot;file open error.\\n&quot;); exit(-1); &#125; // 写数据 std::cout &lt;&lt; &quot;writ data to the file.&quot; &lt;&lt; std::endl; int i = 0, len = 0; char buf[100] = &#123;0&#125;; std::cout &lt;&lt; &quot;please input: &quot; &lt;&lt; std::endl; std::cin.getline(buf,100); len = strlen(buf); cnt = write(fd,buf,len); if(cnt == -1) &#123; perror(&quot;file write error.&quot;); exit(-1); &#125; close(fd); // 关闭文件 // 读取文件 char buf1[100] =&#123;0&#125;; std::cout &lt;&lt; &quot;read file.&quot; &lt;&lt; std::endl; fd = open(filename,O_RDONLY); // 再次打开文件 if(fd == -1) // 判断文件是否打开成功 &#123; perror(&quot;file open error.\\n&quot;); exit(-1); &#125; cnt = read(fd,buf1,len); if(cnt == -1) &#123; perror(&quot;file read error.&quot;); exit(-1); &#125; std::cout &lt;&lt; buf1; close(fd); return 0;&#125; 输出： 12345678[root@roy-cpp TLPI]# g++ -g chap3.cpp -o chap3.out [root@roy-cpp TLPI]# ./chap3.out open the file.writ data to the file.please input: hello royread file.hello roy 处理库函数调用错误 库函数调用和系统调用错误有些不同。 和系统调用一致：返回值为-1，配合error号进行检查； 出错返回值不一定为-1，如fopen出错返回NULL指针，配合error进行检查； 部分库函数根本不使用error。 在本章，主要介绍了Linux发展历史，以及Linux&amp;系统编程的基本概念。在下一章，我将主要介绍文件I/O相关知识。 更新记录 2022-06-16 ：更新笔记 第一次更新 参考文献 [1] http://shareinto.github.io/2016/11/17/linux-terminal/ [2] 黑马程序员教程：https://book.itheima.net/course/223/","categories":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/categories/C/"},{"name":"从零开始","slug":"C/从零开始","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"},{"name":"Linux系统编程","slug":"C/从零开始/Linux系统编程","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://hwh.zone/tags/%E6%95%99%E7%A8%8B/"},{"name":"系统编程","slug":"系统编程","permalink":"https://hwh.zone/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}]},{"title":"C++从零开始（十一）：C++进阶（下）STL","slug":"C++从零开始（十一）：C++进阶（下）STL","date":"2022-02-14T09:55:49.585Z","updated":"2022-02-23T08:37:50.948Z","comments":true,"path":"p/17467/","link":"","permalink":"https://hwh.zone/p/17467/","excerpt":"","text":"🌟《C++从零开始》 系列，开始更新中… C++从零开始https://hwh.zone/p/62712 九、STL STL 即“标准模板库”（ “Standard Template Library”） 的缩写， 是C++标准库的一部分，使用时不用单独安装，直接引入头文件即可。 比如： 12# include &lt;vector&gt; // 引入vector# include &lt;array&gt; // 引入array STL发展历史重要时刻一览： 1987年：贝尔实验室Stepanov 进行C++泛型软件库的研究； 1992年：Alex Stepanov 正式提出 STL（Standard Template Library）； 1994年：STL 正式纳入 C++ 标准化进程之中，随者 C++ 标准的改进，STL 也不断做着相应演化； 1998年：ANSI/ISO C++ 标准正式定案，STL 正式成为C++ 标准库不可或缺的重要组成部分。 STL 几乎所有的代码都采用了模板类和模版函数的方式，由此提供了很好的代码重用机会。 STL从广义上讲分为三类： container（容器），使得我们可以直接使用不同的数据结构，如vector（底层是数组）、list（底层是链表）、map（底层是红黑树）等来组织数据。这为我们高效组织不同数据，提供了极大的方便。 algorithm（算法），则方便了我们对容器（或数组）中的数据进行各种骚操作，如排序（sort）、查找（find）、合并（merge）等。STL算法提供了现成的接口（函数），可以快速实现上述操作。而且一般来说，STL的实现远比我们自身实现的算法要高效，尽量避免自己造轮子，直接使用STL中的接口函数更好。 iterator（迭代器），提供了遍历不同容器（或数组）的元素时的统一访问方式。这得益于STL为每种容器类设计了一个内嵌的iterator类，不同的容器都有自己专属的iterator，因此访问不同容器中的数据可统一使用container&lt;type&gt;::iterator方式： 12345vector&lt;int&gt; v &#123;1,2,3,4,5&#125;; // vectorvector&lt;int&gt;::iterator t = v.begin(); // iteratorarray&lt;int,5&gt; arr &#123;1,2,3,4,5&#125;; // arrayarray&lt;int,5&gt;::iterator t = arr.begin(); // iterator 普通数组名也可视为一个指向首元素的迭代器： 12int* arr = new int[5]&#123;1,2,3,4,5&#125;; *(arr++); // 2, arr作为迭代器 更妙的是，迭代器使得容器和算法的实现可以分开，必要时又可作为“粘合剂”将二者联系起来。 现在我们按：迭代器、容器、算法的顺序依次对STL进行详细介绍。 9.1 迭代器 正如前述，迭代器用于遍历容器（或数组）中存储的元素。 9.1.1 认识迭代器 容器迭代器：iterator STL 标准库为每一种标准容器定义了迭代器，我们可以按照下面方式进行访问： 1&lt;容器类名&gt;::iterator 就像： 12vector&lt;int&gt;::iterator;array&lt;int,5&gt;::iterator; 这里的类成员&lt;容器类名&gt;::iterator 对于不同容器，返回的是不同功能的迭代器。 容器 底层数据结构 迭代器类型 array 数组 随机访问迭代器 vector 数组 随机访问迭代器 deque 数组 随机访问迭代器 list 双链表 双向迭代器 set / multiset / map / multimap 红黑树 双向迭代器 forward_list 单链表 正向迭代器 unordered_map / unordered_set / … 哈希表 正向迭代器 stack / queue 对基础容器list、deque等进行封装 不支持迭代器 上述三种迭代器解释如下： 以下p、q代表对应的迭代器。 输入、输出迭代器：比较特殊，它们不是把容器（或数组）当做操作对象，而是把输入流/输出流作为操作对象。 输入迭代器：只读，一次传递 ，为输入迭代器预定义实现只有istream_iterator和istreambuf_iterator，用于从一个输入流中读取数据。其支持的操作符有 *p,++p,p++,p!=q,p == q ； 输出迭代器：只写，一次传递 ，为输出迭代器的预定义实现只有ostream_iterator和ostreambuf_iterator，用于向一个输出流写数据。支持的操作符和输入迭代器一致。 正向迭代器：结合了输入、输出迭代器几乎所有的功能，支持正向遍历、取值、赋值及相关比较操作。 操作 描述 p++ 或 ++p 返回p后一个元素的迭代器 *p 获取迭代器所指向元素的值 p = p+1 赋值操作 p == p+1 比较操作 p != p+1 比较操作 双向迭代器：具有正向迭代器的全部功能，除此之外还可以向后移动，即--p或p-- 。 额外操作（相比正向迭代器） 描述 p-- 或 --p 返回p前一个元素的迭代器 随机访问迭代器：具有双向迭代器的全部功能，除此之外还可以随机遍历容器元素（显然，指针就是这么一个迭代器）。 额外操作（相比双向迭代器） 描述 p+=i p 往后移动 i 个元素 p-=i p 往前移动 i 个元素 p+i 返回 p 后面第 i 个元素的迭代器 p-i 返回 p 前面第 i 个元素的迭代器 p[i] 返回 p 后面第 i 个元素的引用 此外，两个随机访问迭代器 p1、p2 ： 可以用 &lt;、&gt;、&lt;=、&gt;= 运算符进行比较； 表达式 p2-p1 也是有定义的，返回区间[p1,p2]的元素个数。 再思考不同容器对应的迭代器就很好理解了： 底层数据结构是数组的（array/vector/deque），具体随机访问的特性，自然最适合随机迭代器； 底层数据结构是双链表和红黑树的（list/set/map），无法随机访问，但可以前、后方向遍历，所以使用双向迭代器； 底层数据结构是单链表、哈希表的（forward_list/unordered_map / unordered_set），无法随机访问也无法正向遍历，最后只能使用正向迭代器。 stack / queue 为了维持特殊的数据访问规则“先进后出” / “先进先出”，不允许前/后/随机迭代器在这里使用，否则会破坏规则。 容器其它迭代器 每个容器类除了成员iterator还可能有其它的迭代器： 迭代器 使用格式 默认迭代器 &lt;容器类名&gt;::iterator 常量正向迭代器 &lt;容器类名&gt;::const_iterator 反向迭代器 &lt;容器类名&gt;::reverse_iterator 常量反向迭代器 &lt;容器类名&gt;::const_reverse_iterator 这些迭代器是对类成员iterator的进一步限制。 常量正向/反向迭代器：保留iterator的基本特性，但常量迭代器无法修改其指向的元素； 反向迭代器：保留iterator的基本特性，但iterator进行 ++ 操作时，迭代器会指向容器中的后一个元素；而反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。 操作 描述 p++ 或 ++p 返回p前一个元素的迭代器 不过以上 4 种定义迭代器，并不是每个容器都全部拥有。 部分容器同时支持以上 4 种方式，比如 array、deque、vector； 而有些容器只支持部分，例如 forward_list 容器只支持正向迭代器，不支持反向迭代器。 以vector为例演示vector类中四种迭代器成员的使用。 同前，vector的iterator是随机迭代器，常量迭代器和反向迭代器只是对iterator的进一步限制，但也具有随机迭代器的基本特性。 123456789101112131415161718192021222324252627282930313233#include &lt;vector&gt;#include &lt;iostream&gt;int main()&#123; vector&lt;int&gt; vec &#123;1,2,3,4,5&#125;; // vector默认的是随机迭代器 std::cout &lt;&lt; &quot;随机迭代器遍历：&quot;; vector&lt;int&gt;::iterator iter = vec.begin(); iter[1] = 20; // 随机迭代器特性[] for(; iter != vec.end() ; iter++) std::cout &lt;&lt; *(iter) &lt;&lt; &quot; &quot;; // 1 20 3 4 5 // 常量迭代器 std::cout &lt;&lt; &quot;\\n常量迭代器遍历：&quot;; vector&lt;int&gt;::const_iterator c_iter = vec.cbegin(); // c_iter[1] = 20; // error，只读 // 注意，rbegin()/crbegin() 返回的是尾元素迭代器 // 反向迭代器 std::cout &lt;&lt; &quot;\\n反向迭代器遍历：&quot;; vector&lt;int&gt;::reverse_iterator r_iter = vec.rbegin(); for(; r_iter != vec.rend() ; r_iter++) std::cout &lt;&lt; *(r_iter) &lt;&lt; &quot; &quot;; // 5 4 3 20 1 // 常量反向迭代器 std::cout &lt;&lt; &quot;\\n常量反向迭代器遍历：&quot;; vector&lt;int&gt;::const_reverse_iterator cr_iter = vec.crbegin(); // c_iter[1] = 20; // error，只读 return 0;&#125; 输出： 123[root@roy-cpp test]# ./test.out 随机迭代器遍历：1 20 3 4 5 反向迭代器遍历：5 4 3 20 1 实际编码中，可用auto关键字减少定义迭代器类型时的书写： 1auto iter = vec.begin(); 下文我们会默认采用这种书写方式。更多迭代器的使用示例会穿插在后文中。 9.1.2 迭代器和指针？ 迭代器和指针表现得和指针极为类似，以至于我们会产生疑惑：迭代器是什么？它就是指针吗？ 先说结论，迭代器不是指针，它只是指针的一层封装，在STL中实现为一个模板类。 为什么要进行这种封装？ 这样可统一不同容器的指针操作。比如，array/list/…底层都是利用指针算术运算查找元素，但具体的行为不同，采用iterator可把底层指针操作抽象出来，根据容器不同的底层数据结构来实现不同的++、–等指针操作。 源码简单观察迭代器。 1234567#include &lt;vector&gt;int main()&#123; vector&lt;int&gt; vec &#123;1,2,3,4,5&#125;; vector&lt;int&gt;::iterator iter = vec.begin(); &#125; F12查看vector&lt;int&gt;::iterator定义： iterator定义在模板类vector中，是 __gnu_cxx::__normal_iterator&lt;pointer, vector&gt; 的别名，注意到模板参数pointer； __normal_iterator是linux中STL自定义的迭代器模板，而pointer是普通指针类型别名，这里是int* 。 继续进入__normal_iterator类中： _M_current 类型为_Iterator ，即为pointer（这里是int*），它是一个指针，指向底层数组首元素 。 类中还有迭代器的各种操作，以++操作为例： 可见迭代器确实只是对指针进行了一层封装，本质还是通过指针实现了各种操作。 9.2 容器 STL中的容器也是模板类，本质是封装了不同的基本数据结构（数组、链表等）的模板类。STL提供三种标准容器，分别是： 序列容器 排序容器 哈希容器 这三种容器主要特点如下。 容器种类 包含的具体容器 底层数据结构 特点 序列容器 vector 向量容器、list 列表容器以及 deque 双端队列容器 数组或链表 序列容器中的元素以线性方式存储，但元素不是排好序的 排序容器 set 集合容器、multiset 多重集合容器、map 映射容器以及 multimap 多重映射容器 红黑树 排序容器中的元素，以键值对形式存储，默认是按键值排序好的 哈希容器 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射 哈希表 哈希容器中元素同样以键值对方式存储，但元素是未排序的，元素的位置由哈希函数确定 下面开始具体介绍。 9.2.1 序列式容器 本节主要探讨以下容器： 容器 底层数据结构 特点 迭代器类型 array 数组 大小固定、无法修改 随机迭代器 vector 数组 大小可变、只能尾部插入/删除 随机迭代器 deque 数组 大小可变、双向队列，头尾可高效插入/删除 随机迭代器 list 双链表 大小可变，双链表，头尾可高效插入/删除 双向迭代器 forward_list 单链表 大小可变，单链表，仅可在头部插入/删除 前向迭代器 它们最主要的区别，由底层数据结构决定。 array array 容器底层数据结构是普通的静态数组，所以array大小是固定的，无法动态扩展。 array 容器以类模板的形式定义在 &lt;array&gt; 头文件，如下所示： 12template&lt;typename _Tp, std::size_t _Nm&gt;struct array 这里实际是使用模板结构体struct，但在C++中和class差别不大，可以视为类模板。 在 array&lt;_Tp,_Nm&gt; 模板中： _Tp，用于指明容器中元素数据类型； _Nm，用于指明容器的大小。 一个简单使用实例。 12345678910111213141516#include &lt;iostream&gt;#include &lt;array&gt;int main()&#123; array&lt;int, 5&gt; arr &#123;10, 20, 30, 40, 50&#125;; // 初始化 auto first = arr.cbegin(); auto last = arr.cend(); while (first != last) &#123; std::cout &lt;&lt; *first &lt;&lt; &quot; &quot;; ++first; &#125; std::cout &lt;&lt; &quot;\\n&quot;; return 0; &#125; 输出： 底层实现 本节主要探讨以下问题： array底层数据结构？ array迭代器结构？ 我们前面说过array底层是一个容量大小固定的数组，它具体是什么样呢？ 1array&lt;int, 5&gt; arr&#123;10, 20, 30, 40, 50&#125;; F12查看array定义： 注意到上面红框处的代码： 12typedef _GLIBCXX_STD_C::__array_traits&lt;_Tp, _Nm&gt; _AT_Type;typename _AT_Type::_Type _M_elems; // typename说明_AT_Type::_Type是一个类型 成员 _M_elems便是底层数组。要分析出_M_elems类型，首先要知道_AT_Type::_Type是什么意思。 注意到第一行代码，_AT_Type是__array_traits&lt;_Tp, _Nm&gt;的别名，查看__array_traits定义： 123456789template&lt;typename _Tp, std::size_t _Nm&gt;struct __array_traits&#123; typedef _Tp _Type[_Nm]; // _Type是一个静态数组 static constexpr _Tp&amp; _S_ref(const _Type&amp; __t, std::size_t __n) noexcept &#123; return const_cast&lt;_Tp&amp;&gt;(__t[__n]); &#125;&#125;; 所以：_AT_Type就是一个array萃取类，而_Type是它的成员，也就是一个静态数组，类型为_Tp[_Nm]。 回到_M_elems相关定义： 1typename _AT_Type::_Type _M_elems; _M_elems真正面貌便呼之欲出，在这个例子中_Tp为int，_Nm为5 ，所以上述等价于： 1int[5] _M_elems; 每个容器都会有对应的迭代器，array的迭代器是什么？ 说出来你有点惊讶，array的迭代器就简单实现为指针。 iterator 即为_Tp * ； const_iterator 即为const _Tp * 。 所以你会发现即使array的iterator 没有实现operator++函数 ，依旧可以这么使用： 123array&lt;int,3&gt; arr&#123;1,2,3&#125;;auto iter = arr.begin(); // 等价于 int* iter = arr.begin(); iter++; // ok 因为此时就是对一个int*指针进行++操作。 array让我们可以灵活定义各种类型的数组，保证了安全性又几乎不损失效率。如果想使用静态数组（固定数组），array首选推荐使用。 成员函数 array具有众多的成员函数，方便我们对array进行各种操作。 我们先一睹为快。 迭代器相关 成员函数 功能 begin() 返回指向容器中第一个元素的正向迭代器 end() 返回指向容器最后一个元素之后一个位置的正向迭代器 rbegin() 返回指向最后一个元素的反向迭代器 rend() 返回指向第一个元素之前一个位置的反向迭代器 cbegin() 和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器 cend() 和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器 crbegin() 和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器 crend() 和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器 注意，如果是 const 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素； begin() 和 end() 为C++11新增，操作对象还可以是数组。 包含使用的一些小例子 主要成员函数 标粗部分是常用的函数。 成员函数 功能 size() 返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N max_size() 返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N empty() 判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快 at(n) 返回容器中 n 位置处元素的引用，作用类似[]，但该函数还会检查 n 是否有效，无效会抛出 out_of_range 异常 front() 返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器 back() 返回容器中最后一个元素的直接引用，该函数同样不适用于空的 array 容器 data() 返回一个指向容器首个元素的指针，利用该指针可实现复制容器中所有元素等类似功能 fill(val) 将 val 这个值赋值给容器中的每个元素 array1.swap(array2) 交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。 由于这些函数都比较简单，所以就不举例说明啦。 vector vector基本是平时最常用的容器之一，和 array 容器类似，底层数据结构都是数组，只不过array是静态数组大小固定，而vector底层是一个动态数组。 最让人欣慰的是，vector会动态扩展（但不会收缩）所占用的内存空间，即自动扩容，我们无需操心数组增长问题。 vector容器以类模板的形式定义在 &lt;vector&gt; 头文件，如下所示： 123template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt;class vector : protected _Vector_base&lt;_Tp, _Alloc&gt; 在 vector&lt;_Tp,_Alloc&gt; 模板中： _Tp ，用于指明容器中元素数据类型； _Alloc ，内存分配器，默认采用二级配置器，一般不用我们关心。 简单使用示例： 1234567891011121314151617#include &lt;iostream&gt;#include &lt;vector&gt;int main()&#123; // vector&lt;int,std::allocator&lt;int&gt;&gt; vec &#123;1,2,3,4,5,6&#125;; // 模板参数完整使用 vector&lt;int&gt; vec &#123;1,2,3,4,5,6&#125;; vec.push_back(&quot;7&quot;); // 继续插入数据，vector自动扩容，程序员无需关心 vec.push_back(&quot;8&quot;); vec.push_back(&quot;9&quot;); for (auto i = vec.begin(); i &lt; vec.end(); i++) &#123; std::cout &lt;&lt; *i &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; &quot;\\n&quot;; return 0; &#125; 可以看到，相比array，vector可以很方便的使用push_back等方法插入新数据。 输出： 12[root@roy-cpp test]# ./test.out 1 2 3 4 5 6 7 8 9 底层实现 在本节我们主要探讨以下问题： vector底层数据结构？ vector底层迭代器如何实现？ vector底层是如何进行初始化的？ vector底层自动扩容机制过程和原理？ 我们先了解下vector类继承结构及核心成员。 注意到，vector 继承了 _Vector_base ，_Vector_base专门负责vector的内存管理。 _Vector_base核心是内部类_Vector_impl ，它继承了_Tp_alloc_type 获得内存分配释放的功能。 _Vector_impl核心成员： M_start，_M_finish，_M_end_of_storage ：所有关于地址，容量大小等操作都需要用到这三个指针。 _M_start ，代表起始位置的指针 _M_finish ，代表已存储的元素的末尾位置 _M_end_of_storage， 代表整个vector空间的结束位置 _M_allocate和_M_deallocate：分别分配和释放vector所用内存，vector只需要负责元素构造和析构。 _M_allocate，最终通过malloc实现内存分配； _M_deallocate，通过free实现内存释放。 了解了vector类大致结构，再来依次回答节前的问题： vector底层数据结构？ vector底层是一个动态数组，初始化时会让指针_M_start （_Tp*类型）会指向分配内存。 vector迭代器如何实现？ 同前9.1.2节，在vector类中可找到iterator相关定义： 1typedef __gnu_cxx::__normal_iterator&lt;pointer, vector&gt; iterator; 进入__normal_iterator类中： 主要成员_M_current 类型为_Iterator ，即为pointer（这里是int*），它是一个指针，指向底层数组首元素 。 类中还封装迭代器的各种操作，以++操作为例： vector是如何进行初始化的？ 1vector&lt;string&gt; vec &#123;&quot;Hello&quot;, &quot;World&quot;&#125;; vector类在构造时分配初始数组内存。vector类支持多种构造函数，如普通构造函数、移动构造函数、拷贝构造函数等。 以普通构造函数为例： 12345678910/** * @brief 初始化为n个__value值，如果没指定就使用该类型默认值 * @param __n The number of elements to initially create. * @param __a An allocator.*/explicit vector(size_type __n, const value_type&amp; __value = value_type(),const allocator_type&amp; __a = allocator_type()) : _Base(__n, __a) &#123; _M_fill_initialize(__n, __value); // 初始化所有元素为__value &#125; 核心是调用了基类构造函数_Base(__n, __a) ： 1typedef _Vector_base&lt;_Tp, _Alloc&gt; _Base; 在_Vector_base 查到其定义： 关键函数_Vector_base::_M_create_storage实现为： _M_allocate 最终就是通过_M_impl.allocate实现； _M_impl.allocate 最终通过malloc实现内存分配。 综上所述，vector通过构造函数初始化，最终调用malloc分配了底层数组内存空间。 vector自动扩容机制实现的过程和原理？ 123vec.push_back(&quot;7&quot;); // 继续插入数据，vector自动扩容，程序员无需关心vec.push_back(&quot;8&quot;);vec.push_back(&quot;9&quot;); 如下所示，左图代表扩容前的存储结构，右图是扩容后的存储结构。 扩容条件： size()函数返回的是已用空间大小，capacity()返回的是总空间大小，capacity()-size()则是剩余的可用空间大小； 当size()和capacity()相等，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。 扩容过程： 重新分配一块两倍于原来大小的内存空间； 将原来的存储空间的元素，依次拷贝到新的2*capacity大小的存储空间之中。 成员函数 vector具有众多的成员函数，方便我们对vector进行各种操作。 我们先一睹为快。 迭代器相关 同array。 成员函数 功能 begin() 返回指向容器中第一个元素的正向迭代器 end() 返回指向容器最后一个元素之后一个位置的正向迭代器 rbegin() 返回指向最后一个元素的反向迭代器 rend() 返回指向第一个元素之前一个位置的反向迭代器 cbegin() 和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器 cend() 和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器 crbegin() 和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器 crend() 和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器 注意，如果是 const 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素； begin() 和 end() 为C++11新增，操作对象还可以是数组。 主要成员函数 标粗部分是常用的函数。 成员函数 功能 size() 返回容器中当前元素的数量 capacity() 返回当前容量 reserve() 增加容器的容量 max_size() 返回容器可容纳元素的最大数量 empty() 判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快 at(n) 返回容器中 n 位置处元素的引用，作用类似[]，但该函数还会检查 n 是否有效，如果不是会抛出 out_of_range 异常 front() 返回容器中第一个元素的直接引用 back() 返回容器中最后一个元素的直接引用 data() 返回一个指向容器首个元素的指针，利用该指针可实现复制容器中所有元素等类似功能 swap() 交换两个容器的所有元素 相比array独有的方法（可以尾部插入、删除元素等）： 成员函数 功能 push_back() 在容器的尾部添加一个元素 pop_back() 移出容器尾部的元素 emplace_back() 在容器的尾部添加一个元素 erase() 移出一个元素或一段元素，返回指向删除元素的下一个元素的迭代器 clear() 移出所有的元素，容器大小变为 0 关于删除vector空间释放有些小问题。 clear()、erase()方法均不会释放vector所占用的内存空间。 1234567891011121314151617#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; vector&lt;int&gt; vec &#123;1,2,3,4,5&#125;; std::cout&lt;&lt; vec.size() &lt;&lt; std::endl; // 5 std::cout&lt;&lt; vec.capacity() &lt;&lt; std::endl; // 5 vec.erase(vec.begin(), vec.begin()+1); std::cout&lt;&lt; vec.size() &lt;&lt; std::endl; // 4 std::cout&lt;&lt; vec.capacity() &lt;&lt; std::endl; // 5 , capacity未改变 vec.clear(); std::cout&lt;&lt; vec.size() &lt;&lt; std::endl; // 0 std::cout&lt;&lt; vec.capacity() &lt;&lt; std::endl; // 5 , capacity未改变&#125; 因为vector内存占用空间只增不减： 分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个； 所有内存空间，在vector对象析构时才能被系统回收。 换句话说，clear()、erase()方法只是减少了vector的size大小，没有改变capacity。 我们可以借助swap方法彻底删除。 1234567891011#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; vector&lt;int&gt; vec &#123;1,2,3,4,5&#125;; vector&lt;int&gt;().swap(vec); // swap std::cout&lt;&lt; vec.size() &lt;&lt; std::endl; // 0 std::cout&lt;&lt; vec.capacity() &lt;&lt; std::endl; // 0，彻底删除&#125; vector&lt;int&gt;()使用默认构造函数建立临时vector对象，再在该临时对象上调用swap成员； swap调用之后原来vector占用的空间就等于一个默认构造的对象的大小，而临时对象就具有原来对象vec的大小； 临时对象随即被析构，其占用的空间（原来vec的空间）也被释放。 另一方面，会动态增长和缩小的容器，如deque，便没有上面烦扰：clear()、erase()方法删除元素后，其内存也随之缩减。 下节我们一起来认识下吧。 deque vector 可以在尾部快速添加和移除元素，虽然理论上也可以在头部进行操作，但因为其底层是一个一维动态数组，因此无论是添加和移除元素都涉及到数组所有元素的移动，效率都奇差，因此STL相关头部操作的方法vector::push_front()都没有提供。 deque （双端队列）用于弥补 vector 的不足，在首尾两端都可以快速添加和删除，STL会提供头、尾插入、删除方法（vector头部操作效率低，STL只提供了尾部插入、删除相关方法），其直观形式表现如下： 不过这种“整体连续”是一种假象，deque底层实际实现为一个二维动态数组 。正式介绍其底层实现前，我们按老规矩先介绍容器上层封装和基本使用。 deque容器以类模板的形式定义在 &lt;deque&gt; 头文件，如下所示： 123template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt;class deque : protected _Deque_base&lt;_Tp, _Alloc&gt; 在 deque&lt;_Tp,_Alloc&gt; 模板中： _Tp，用于指明容器中元素数据类型； _Alloc，内存分配器，默认采用二级配置器，一般不用我们关心。 简单使用实例。 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123; std::cout&lt;&lt;&quot;size = &quot; &lt;&lt; d.size() &lt;&lt;&quot; : &quot;; // deque没有`capacity`()函数 for(auto first = d.begin(); first != d.end(); first++) std::cout&lt;&lt;*first&lt;&lt;&quot; &quot;; std::cout&lt;&lt;&quot;\\n&quot;; &#125;int main()&#123; deque&lt;int&gt; d &#123;1,2,3&#125;; d.push_back(4); d.push_front(0); printDeque(d); // size = 5 : 0 1 2 3 4 d.pop_back(); d.pop_front(); printDeque(d); // size = 3 : 1 2 3 return 0;&#125; 底层实现 本节我们主要探讨以下问题： deque底层数据结构及实现？ deque底层迭代器如何定义？ deque什么时候进行扩容？如何扩容？ deque底层如何插入、删除一个数据？ 我们先了解下deque类继承结构及核心成员（类似vector继承结构）。 注意到，deque继承了 _Deque_base ，_Deque_base专门负责vector的内存管理。 _Deque_base核心是内部类_Deque_impl ，它继承了_Tp_alloc_type 获得内存分配释放的功能。 12345678910111213template&lt;typename _Tp, typename _Alloc&gt;class _Deque_base&#123; public: ... protected: typedef typename _Alloc::template rebind&lt;_Tp&gt;::other _Tp_alloc_type; struct _Deque_impl: public _Tp_alloc_type &#123; _Tp** _M_map; // map数组，其中的每个元素都是一个指针（节点），指向一块缓冲区 size_t _M_map_size; iterator _M_start; iterator _M_finish; _Deque_impl核心成员： _M_map：二维动态数组map； _M_start，_M_finish：迭代器，start 迭代器记录着 map 数组中首个连续空间的信息，finish 迭代器记录着 map 数组中最后一个连续空间的信息。 deque的begin() 和 end() 方法就是通过他们实现的： 12iterator begin() &#123; return _M_start; &#125;iterator end() &#123; return _M_finish; &#125; 好了，现在我们可以依次回答节前的问题。 我们先探讨第一个问题：deque底层数据结构及实现？ deque 容器用二维动态数组（数组名假设为 map）存储着各个连续空间的首地址 ，每个连续空间是等长的内存缓存区域（下图中的strat和finish对应上面的_M_start和_M_finish）。 所以第一个问题答案总结如下：deque底层数据结构就是一个二维数组_Tp** ，由_Deque_impl类负责相关内存分配。 最后补充一点deque类中_Map_pointer介绍。 123456789101112template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt;class deque : protected _Deque_base&lt;_Tp, _Alloc&gt;&#123; typedef _Deque_base&lt;_Tp, _Alloc&gt; _Base; typedef typename _Base::_Tp_alloc_type _Tp_alloc_type; public: ... typedef typename _Tp_alloc_type::pointer pointer; ... protected: // _Map_pointer，一个二级指针，指向二维数组map typedef pointer* _Map_pointer; _Map_pointer是一个二维指针类型。 _Map_pointer其实就是_Tp**： 容易知道，_Map_pointer 是_Deque_base&lt;_Tp, _Alloc&gt;::_Tp_alloc_type::pointer* 别名； 查看_Tp_alloc_type定义： 123456class _Deque_base&#123; protected: // _Alloc是模板参数设置的分配器，_Tp是模板参数的类型 // _Tp_alloc_type是空间配置器的类型 typedef typename _Alloc::template rebind&lt;_Tp&gt;::other _Tp_alloc_type; _Tp_alloc_type 就是other的别名，经过一番艰难的求知，在三张图带你弄懂STL中内存分配器 中确定：other类型其实是allocator&lt;_Tp1&gt;这个类型，如果我们传参为int 那就是allocator&lt;int&gt; 。 查看pointer定义： 所以，最终pointer* 等价于__Tp** ，如果我们传入的类型为int，那就是int** 。 1typedef pointer* _Map_pointer; 继续第二个问题：deque迭代器如何定义？ 前面我们说过，_M_start，_M_finish都是iterator类型： 1typedef _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt; iterator; 查看_Deque_iterator定义： 12345678910111213template&lt;typename _Tp, typename _Ref, typename _Ptr&gt;struct _Deque_iterator&#123; typedef _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt; iterator; ... ... typedef _Tp** _Map_pointer; typedef _Deque_iterator _Self; _Tp* _M_cur; // 可以看成是原生指针，表示当前的元素位置 _Tp* _M_first; // 缓冲区开始处，可看成是第二维第一个元素的位置 _Tp* _M_last; // 缓冲区末端的下一个位置，第二维的最后元素的下一个位置 _Map_pointer _M_node; // _M_node指向第一维 相比deque的迭代器底层实现 ，vector中的迭代器就底层封装了一个光溜溜的_M_current指针， 简单了很多： 第三个问题：deque什么时候进行扩容？如何扩容？ 放一张图： deque何时及如何扩容一目了然： 扩容时机：map数组已满； 扩容方式：再申请一块更大的连续空间供 map 数组使用，将原有数据（很多指针）拷贝到新的 map 数组中，然后释放旧map数组的空间（不释放map数组中的指针指向的空间）。 最后一个问题：deque底层如何插入、删除一个数据？ 如果是插入操作，需分三种情况讨论：在容器的尾部插入、在容器的首部插入、在容器的指定位置前插入元素。这里仅以在容器的尾部插入为例分析。 在容器的尾部插入 此时，cur指向的是含有实际值的下一个位置，last表示最后一个实际值的下一个位置。 1push_back(const T&amp; t) 找到finish绑定的缓冲区，如果缓存区还有空闲位置（start.cur!=start.last），则在cur位置插入元素，并更新cur++ ，否则转2； 没有空闲位置可以插入元素，则在finish.node（这是第一维）的后一个位置申请一个缓冲区（如果map满了，触发扩容），并将finish绑定到该新缓冲区，重复1中步骤插入元素。 删除操作类似，同样需要分三种情况：在容器的尾部删除、在容器的首部删除、在容器的指定位置前删除元素。这里仅以在容器的尾部删除为例分析。 在容器的尾部删除 1pop_back() 找到finish绑定的缓冲区，如果finish所绑定的缓冲区上有1个或多个元素，将最后一个有效元素析构即可destroy(–finish.cur)，否则转2； finish所绑定的缓冲区为空，即finish.cur==finish.first： 先将该空缓冲区的空间释放掉deallocate_node(finish.first)； 再将finish绑定到上一个map结点和缓冲区； 12finish.set_node(finish.node-1);finish.cur=finish.last-1; 最后将最后一个元素析（也是当前要删除的元素）构destroy(finish.cur)。 从这里也可以看出，相比vector，deque确实会动态释放内存，不会只增不减。 成员函数 deque具有众多的成员函数，方便我们对deque进行各种操作。 我们先一睹为快。 迭代器相关 同array，vector。 成员函数 功能 begin() 返回指向容器中第一个元素的正向迭代器 end() 返回指向容器最后一个元素之后一个位置的正向迭代器 rbegin() 返回指向最后一个元素的反向迭代器 rend() 返回指向第一个元素之前一个位置的反向迭代器 cbegin() 和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器 cend() 和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器 crbegin() 和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器 crend() 和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器 注意，如果是 const 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素； begin() 和 end() 为C++11新增，操作对象还可以是数组。 主要成员函数 标粗部分是常用的函数。 头、尾操作效率均高，所以会都提供push_front() 、push_front()等头、尾部等插入、删除方法。 成员函数 功能 size() 返回容器中当前元素的数量 capacity deque没有该方法，vector有 reserve() deque没有该方法，vector有 max_size() 返回容器可容纳元素的最大数量 empty() 判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快 at(n) 返回容器中 n 位置处元素的引用，作用类似[]，但该函数还会检查 n 是否有效，如果不是会抛出 out_of_range 异常 front() 返回容器中第一个元素的直接引用 back() 返回容器中最后一个元素的直接引用 data() deque没有该方法，vector有 swap() 交换两个容器的所有元素 相比array独有的方法（可以头、尾部插入、删除元素等）： 成员函数 功能 push_back() 在容器的尾部添加一个元素 emplace_back() 在容器的尾部添加一个元素 push_front() 在容器的头部添加一个元素 emplace_front() 在容器头部生成一个元素 erase() 移出一个元素或一段元素，返回指向删除元素的下一个元素的迭代器 clear() 移出所有的元素，容器大小变为 0 pop_back() 移出容器尾部的元素 pop_front() 移除容器头部的元素 这些方法都比较简单，不过多介绍。 list list容器的底层是用双向链表实现的，甚至一些 STL 版本中（比如 SGI STL），list 容器的底层实现使用的是双向循环链表。 a）双向链表，b）循环链表 双链表相比数组有很多好处： 插入和删除操作效率高（但查找效率低），头、尾插入/删除操作也是，所以STL会都提供了push_front()、push_back()等头、尾部操作方法； 扩展方便； 内存空间不要求连续，可充分利用空间； … 这些也是list所具有的优点。另外一个好处可能现在有点难以理解（后文会解释）： 在vector中如果进行插入和删除操作会导致后续迭代器会失效，而在List中：插入不会导致迭代器失效；删除也只会使得当前迭代器失效，后续迭代器不会失效。 list容器以类模板的形式定义在 &lt;list&gt; 头文件，如下所示： 123template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt;class list : protected _List_base&lt;_Tp, _Alloc&gt; 在 list&lt;_Tp,_Alloc&gt; 模板中： _Tp，用于指明容器中元素数据类型； _Alloc，内存分配器，默认采用二级配置器，一般不用我们关心。 简单使用实例。 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; l)&#123; std::cout&lt;&lt;&quot;size = &quot; &lt;&lt; l.size() &lt;&lt;&quot; : &quot;; // list没有`capacity`()函数 for(auto first = l.begin(); first != l.end(); first++) std::cout&lt;&lt;*first&lt;&lt;&quot; &quot;; std::cout&lt;&lt;&quot;\\n&quot;; &#125;int main()&#123; list&lt;int&gt; l &#123;1,2,3&#125;; l.push_back(4); l.push_front(0); printList(l); // size = 5 : 0 1 2 3 4 l.pop_back(); l.pop_front(); printList(l); // size = 3 : 1 2 3 return 0;&#125; 因为list不止是链表还是双向链表，所以我们头、尾都是可以插入/删除的。 底层实现 本节我们主要探讨以下问题： list底层数据结构及实现？ list底层迭代器如何定义？ list底层如何插入、删除一个数据？ 我们先了解下list类继承结构及核心成员（类似vector、deque继承结构）。 注意到，list继承了 _List_base ，_List_base专门负责list的内存管理。 _List_base核心是内部类_List_impl ，它继承了_Tp_alloc_type 获得内存分配释放的功能。 1234567891011121314151617181920template&lt;typename _Tp, typename _Alloc&gt;class _List_base&#123; protected: typedef typename _Alloc::template rebind&lt;_List_node&lt;_Tp&gt; &gt;::other _Node_alloc_type; typedef typename _Alloc::template rebind&lt;_Tp&gt;::other _Tp_alloc_type; struct _List_impl: public _Node_alloc_type &#123; __detail::_List_node_base _M_node; // 头结点，不存储数据 _List_impl(): _Node_alloc_type(), _M_node() &#123; &#125; _List_impl(const _Node_alloc_type&amp; __a): _Node_alloc_type(__a), _M_node() &#123; &#125; ... &#125;; // _List_impl... _List_impl核心成员： _M_node：list头结点，不存储数据 好了，现在我们可以依次回答节前的问题。 第一个问题：list底层数据结构及实现？ list底层是链表，头结点为_M_node。头节点是_List_node_base类型，不存储数据。 但数据结点是_List_node 类型，存储数据。 借助_M_node可以实现，list中几乎所有的成员函数。 第二个问题：list底层迭代器如何定义？ 在list类中，找到iterator定义： 1typedef _List_iterator&lt;_Tp&gt; iterator; 其定义如下： 12345678910111213141516171819template&lt;typename _Tp&gt;struct _List_iterator&#123; // 定义一堆别名 typedef _List_iterator&lt;_Tp&gt; _Self; typedef _List_node&lt;_Tp&gt; _Node; typedef ptrdiff_t difference_type; // list为一个双向链表，迭代器必须具备前移、后移的能力，所以提供了bidirectional iterator typedef std::bidirectional_iterator_tag iterator_category; typedef _Tp value_type; typedef _Tp* pointer; typedef _Tp&amp; reference; // 构造函数1：实例化头结点_M_node指针 _List_iterator(): _M_node() &#123; &#125; // 构造函数2：给定值实例化 explicit _List_iterator(__detail::_List_node_base* __x): _M_node(__x) &#123; &#125; ... 继续看看具体_List_iterator相关函数。 operator++ 的后置自增，将当前 _M_node 移动到 _M_node-&gt;_M_next 所在的位置，并返回移动之后的迭代器。 123456// _Self 是_List_iterator&lt;_Tp&gt; 一个类型别名_Self&amp; operator++()&#123; _M_node = _M_node-&gt;_M_next; return *this;&#125; operator--大同小异。 12345_Self&amp; operator--()&#123; _M_node = _M_node-&gt;_M_prev; return *this;&#125; 最后一个问题：list底层如何插入、删除一个数据？ 大致应该就是链表的插入、删除相关操作。这里有机会再补上吧。 成员函数 list具有众多的成员函数，方便我们对list进行各种操作。 我们先一睹为快。 迭代器相关 同array、vector，deque。 成员函数 功能 begin() 返回指向容器中第一个元素的正向迭代器 end() 返回指向容器最后一个元素之后一个位置的正向迭代器 rbegin() 返回指向最后一个元素的反向迭代器 rend() 返回指向第一个元素之前一个位置的反向迭代器 cbegin() 和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器 cend() 和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器 crbegin() 和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器 crend() 和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器 注意，如果是 const 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素； begin() 和 end() 为C++11新增，操作对象还可以是数组。 主要成员函数 标粗部分是常用的函数。 list底层是双链表，只有双向迭代器没有随机迭代器，一些随机迭代器才支持的方法，比如at(n)、[n]都是不支持的； 头、尾操作效率均高，所以会提供push_front() 、push_back()等头、尾部等插入、删除方法。 成员函数 功能 size() list没有，vector、deque有 capacity list、deque没有该方法，vector有 reserve() list、deque没有该方法，vector有 max_size() 返回容器可容纳元素的最大数量 empty() 判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快 at(n) 不支持 front() 返回容器中第一个元素的直接引用 back() 返回容器中最后一个元素的直接引用 data() list、deque没有该方法，vector有 swap() 交换两个容器的所有元素 相比array独有的方法（可以头、尾部插入、删除元素等）： 成员函数 功能 push_back() 在容器的尾部添加一个元素 emplace_back() 在容器的尾部添加一个元素 push_front() 在容器的头部添加一个元素 emplace_front() 在容器头部生成一个元素 erase() 移出一个元素或一段元素，返回指向删除元素的下一个元素的迭代器 clear() 移出所有的元素，容器大小变为 0 pop_back() 移出容器尾部的元素 pop_front() 移除容器头部的元素 相比deque新增（链表的一些操作方法）： 成员函数 功能 splice() 将一个 list 容器中的元素插入到另一个容器的指定位置 remove(val) 删除容器中所有等于 val 的元素 remove_if() 删除容器中满足条件的元素 unique() 删除容器中相邻的重复元素，只保留一个 merge() 合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的 sort() 通过更改容器中元素的位置，将它们进行排序 reverse() 反转容器中元素的顺序 新增的函数有点意思，合适的时候进行补充。 迭代器失效 分析“迭代器失效”这个问题前，我们先回忆一下各个容器的底层数据结构： 容器 底层数据结构 对应的迭代器类型 array、vector、deque 数组 随机访问迭代器 list、forward_list 链表 双向迭代器 set / multiset / map / multimap 红黑树 双向迭代器 stack / queue list 和 deque 实现，封闭头部 不支持迭代器 好了，让我们正式开始吧。 看下面这段看似无害的代码： 1234567891011#include &lt;vector&gt;int main()&#123; vector&lt;int&gt; vec &#123;1,2,3,4,5&#125;; for(auto it=vec.begin(); it != vec.end(); it++) &#123; vec.erase(it); // 迭代器失效 &#125; return 0;&#125; 执行时却发生了错误： 12[root@roy-cpp test]# ./test.out Segmentation fault 这段代码对于list、vector、deque等容器都会出错（array例外，它没有erase()方法），究其原因就是出现迭代器失效。 迭代器it 初始化指向了第一个元素，判断条件成立进入循环体； 执行vec.erase(it)，it被删除； 执行it++出错，it已失效无法递增。 得益于erase方法的返回值是下一个有效的 iterator，解决办法也很简单。 123456789101112#include &lt;vector&gt;int main()&#123; vector&lt;int&gt; vec &#123;1,2,3,4,5&#125;; for(auto it=vec.begin(); it != vec.end(); ) &#123; it = vec.erase(it); // 迭代器失效 // it++; // it已经是下一个迭代器了不用++ &#125; return 0;&#125; 或者： ⚠️ 关联容器：map、set、multimap、multiset等可以使用两种方式，但list、vector、deque无法使用下面这种方式，否则会出错（为啥？）。 12345678910111213#include &lt;map&gt;int main()&#123; map&lt;int,int&gt; map1; map1.emplace(1,1); map1.emplace(2,2); for(auto it=map1.begin(); it != map1.end(); ) &#123; map1.erase(it++); // 迭代器失效 &#125; return 0;&#125; it++会复制一个it副本传递给erase() 函数； it执行++操作； 最后再执行erase()将 复制的it副本删除，它和it指向同一元素，所以最后it还是失效了。 迭代器失效总结如下： 如果底层数据结构是一维数组的（vector） 插入操作：插入位置及之后的迭代器都失效，因为插入位置后的所有元素都需要移动；如果还触发了扩容，则所有迭代器都失效； 删除操作：删除位置及之后的迭代器都失效，因为删除位置之后的元素都需移动； 如果底层数据结构是二维数组的（deque） 插入操作：首部或者尾部插入不会使迭代器失效，因为不影响其它元素位置，中间插入会使得所有迭代器失效，因为所有元素都被影响要移动； 删除操作：部或尾部删除元素只会使得被删除位置的迭代器失效，中间删除会使得所有迭代器失效，原因同上。 如果底层数据结构是链表的（list、forward_list） 插入操作：节点无需移动，所有迭代器有效； 删除操作：节点无需移动，仅删除的节点迭代器失效。 如果底层数据结构是红黑树的（set / multiset / map / multimap） 插入操作：不影响其它节点，所有迭代器有效； 删除操作：不影响其它节点，仅删除的节点迭代器失效。 forward_list forward_list底层实现和list一样，都是链表，但是forward_list使用的是单链表，而list是双链表。 单链表相比双链表灵活性差了很多： 尾部插入、删除操作效率低； 只能前向遍历，不能反向遍历（因此forward_list只有前向迭代器，而且不会具有 rbegin()、rend() 之类的成员函数）； … 但是单链表空间利用利用率更高（node不用保存前向指针），而且遵循奥卡姆剃刀原则：“若无必要，勿增实体”——在诸多可以满足需求的结构中，选择影响范围最小的。 所以只要是 list 容器和 forward_list 容器都能实现的操作，应优先选择 forward_list 容器。 forward_list 容器以类模板的形式定义在 &lt;forward_list &gt; 头文件，如下所示： 123template&lt;typename _Tp, typename _Alloc = allocator&lt;_Tp&gt; &gt;class forward_list : private _Fwd_list_base&lt;_Tp, _Alloc&gt; 在 forward_list&lt;_Tp,_Alloc&gt; 模板中： _Tp，用于指明容器中元素数据类型； _Alloc，内存分配器，默认采用二级配置器，一般不用我们关心。 简单使用实例。 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;forward_list&gt;void printList(const forward_list&lt;int&gt;&amp; fl)&#123; // forward_list 没有size()方法 // 用distance方法实现 std::cout&lt;&lt;&quot;size = &quot; &lt;&lt; std::distance(std::begin(fl), std::end(fl)) &lt;&lt;&quot; : &quot;; // forward_list 没有capacity()函数 for(auto first = fl.begin(); first != fl.end(); first++) std::cout&lt;&lt;*first&lt;&lt;&quot; &quot;; std::cout&lt;&lt;&quot;\\n&quot;; &#125;int main()&#123; forward_list&lt;int&gt; fl &#123;1,2,3&#125;; // fl.emplace_front(4); // 底层是单链表，不支持尾部相关操作的函数/迭代器 fl.emplace_front(0); // 头部插入，尾部不行 printList(fl); // size = 4 : 0 1 2 3 fl.pop_front(); // 头部删除 printList(fl); // size = 3 : 1 2 3 return 0;&#125; 注意到： forward_list只能头部进行了插入等操作，不能在尾部； forward_list没有size方法，只能用distance方法实现。 底层实现 本节我们主要探讨以下问题： forward_list底层数据结构及实现？ forward_list底层迭代器如何定义？ forward_list底层如何插入、删除一个数据？ forward_list底层实现和list极为相似，这里直接给出关键答案。 forward_list底层数据结构及实现？ forward_list底层是但链表，头结点为_M_head。头节点是_Fwd_list_node_base类型，不存储数据。 forward_list底层迭代器如何定义？ 没啥好说的，和list差不多。 forward_list底层如何插入、删除一个数据？ 就是单链表相关的操作，有头结点操作比较统一。 成员函数 forward_list具有众多的成员函数，方便我们对forward_list进行各种操作。 我们先一睹为快。 迭代器相关 和array、vector、deque，list不同，forward_list没有尾部相关迭代器函数。 成员函数 功能 begin() 返回指向容器中第一个元素的正向迭代器 end() 返回指向容器最后一个元素之后一个位置的正向迭代器 cbegin() 和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器 cend() 和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器 注意，如果是 const 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素； begin() 和 end() 为C++11新增，操作对象还可以是数组。 主要成员函数 标粗部分是常用的函数。 list、forward_list底层是链表，没有随机迭代器，一些随机迭代器才支持的方法，比如at(n)都是不支持的； forward_list底层是单链表，只有头部操作效率高，所以尾部操作相关的方法push_back()等STL不提供； 成员函数 功能 size() forward_list不支持，可用std::distance() 方法间接实现 capacity forward_list、list、deque没有该方法，vector有 reserve() forward_list、list、deque没有该方法，vector有 max_size() 返回容器可容纳元素的最大数量 empty() 判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快 at(n) - front() 返回容器中第一个元素的直接引用 data() forward_list、list、deque没有该方法，vector有 swap() 交换两个容器的所有元素 相比array独有的方法（可以头部插入、删除元素等）： 成员函数 功能 push_front() 在容器的头部添加一个元素 | emplace_front() | 在容器头部生成一个元素 | | erase() | 移出一个元素或一段元素，返回指向删除元素的下一个元素的迭代器 | | clear() | 移出所有的元素，容器大小变为 0 | | pop_front() | 移除容器头部的元素 | 相比deque新增（链表相关方法）： 成员函数 功能 splice() 将一个 forward_list容器中的元素插入到另一个容器的指定位置 remove(val) 删除容器中所有等于 val 的元素 remove_if() 删除容器中满足条件的元素 unique() 删除容器中相邻的重复元素，只保留一个 merge() 合并两个事先已排好序的 forward_list容器，并且合并之后的 forward_list容器依然是有序的 sort() 通过更改容器中元素的位置，将它们进行排序 reverse() 反转容器中元素的顺序 9.2.2 关联式容器 序列式容器元素是顺序存储的，而“关联式容器”是以键值对方式存储的，顾名思义每个元素都会和一个“键”相关联的。这种特性简单解释来说，就是查找到“键”就可以查找到相关元素。 在底层实现中，关联容器的“键值对”采用红黑树来存储，这使得可以很方便地实现排序，所以关联式容器的元素都会按照键值的大小做升序排序。 本节主要探讨以下容器： 除此之外，C++ 11 还新增了 4 种哈希容器，即 unordered_map、unordered_multimap 以及 unordered_set、unordered_multiset。严格来说，它们也属于关联式容器，但由于哈希容器底层采用的是哈希表，而不是红黑树，放在下节9.2.3讲解。 容器 底层数据结构 特点 迭代器类型 map 红黑树，下同 键必须唯一，会根据键大小默认升序排序 双向迭代器，下同 multimap 基本同map，但multimap 键可重复 set 键和值完全相同，键依旧唯一，默认升序 multiset 基本同set，但multiset 键可重复 pair 我们知道，关联式容器存储的是“键值对”形式的数据，即&lt;key,value&gt;形式。 C++STL专门提供了pair类模板，用来封装“键值对”这种形式的数据。 它被定义为： 123456template&lt;class _T1, class _T2&gt;struct pair&#123; _T1 first; _T2 second; ... 使用起来也很简单： 12345678910111213141516171819#include &lt;utility&gt;#include &lt;string&gt; int main()&#123; // 初始化 pair&lt;int,string&gt; kv1&#123;1,&quot;一&quot;&#125;; pair&lt;int,string&gt; kv2&#123;2,&quot;二&quot;&#125;; // 修改 kv1.first = -1; kv1.second =&quot;负一&quot;; // 比较:键值对完全相关返回true，否则false bool is_equal = kv1 == kv2 ? true : false; // swap交换键值对 kv1.swap(kv2);&#125; 你还可以使用make_pair 来创建pair对象： 1pair&lt;int,string&gt; kv3&#123;make_pair(3, &quot;三&quot;)&#125;; 后面我们会大量用到这种方式创建pair对象。 map 作为关联式容器的一种，map用 pair 类模板创建键值对，底层结构是红黑树而且还会根据各键值对的键的大小，进行升序排序。 map容器以类模板形式定义在 &lt;map&gt; 头文件，如下所示： 12345template &lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt; &gt;class map 在 map&lt;_Key,_Tp,_Compare,_Alloc&gt; 模板中： _Key，指定键的类型； _Tp，指定值的类型； _Compare：指定排序顺序，默认选用升序std::less&lt;_Key&gt;，也可以选用std::greater&lt;_Key&gt; 或者自定义排序规则； _Alloc，默认选用二级内存分配器。 特别的，关联式容器（如map）的键值key都是不能修改的，只能通过：先手动删除键值对，再插入，这种间接的方式修改。 假设关联容器允许修改键值的，因为其底层是红黑树： 首先需要删除该键，然后调节平衡 再插入修改后的键值，再调节平衡 如此一来，严重破坏了红黑树的结构，导致iterator失效，不知道应该指向之前的位置，还是指向改变后的位置。所以STL中将关联式容器的迭代器设置成const，不允许修改迭代器的值。 123auto map1 = std::map&lt;int,std::string&gt; &#123; std::make_pair(1,&quot;一&quot;),std::make_pair(2,&quot;二&quot;)&#125;;map1.find(&quot;two&quot;)-&gt;first = 0; // error，不允许修改 一个简单使用实例。 12345678910111213141516171819202122232425262728293031#include&lt;map&gt;#include&lt;utility&gt;#include&lt;iostream&gt;#include&lt;string&gt; void printMap(const map&lt;int,string&gt;&amp; m)&#123; std::cout&lt;&lt;&quot;size = &quot; &lt;&lt; m.size() &lt;&lt;&quot; : &quot;; // 打印键值对 for(auto iter = m.begin(); iter != m.end(); iter++) std::cout&lt;&lt;&quot;&lt;key=&quot;&lt;&lt; iter-&gt;first &lt;&lt;&quot;, value=&quot; &lt;&lt; iter-&gt;second &lt;&lt; &quot;&gt; &quot;; std::cout&lt;&lt;&quot;\\n&quot;; &#125;int main()&#123; // make_pair map&lt;int,std::string&gt; map1 &#123; std::make_pair(1,&quot;一&quot;),std::make_pair(2,&quot;二&quot;)&#125;; map1[1]; // &quot;一&quot; map1[2]; // &quot;二&quot; // 插入 map1.emplace(std::make_pair(0,&quot;零&quot;)); map1.emplace(std::make_pair(4,&quot;四&quot;)); printMap(map1); // 删除 map1.erase(3); map1.erase(4); printMap(map1);&#125; 在本例中，map初始化还可以简化为： 1map&lt;int,std::string&gt; map1 &#123; &#123;1,&quot;一&quot;&#125;,&#123;2,&quot;二&quot;&#125;&#125;; 输出（注意打印出来的顺序按key升序打印的）： 123[root@roy-cpp test]# ./test.out size = 4 : &lt;key=0, value=零&gt; &lt;key=1, value=一&gt; &lt;key=2, value=二&gt; &lt;key=4, value=四&gt; size = 3 : &lt;key=0, value=零&gt; &lt;key=1, value=一&gt; &lt;key=2, value=二&gt; 成员函数 map具有众多的成员函数，方便我们对map进行各种操作。 我们先一睹为快。 迭代器相关 同array、vector，deque、list。 成员函数 功能 begin() 返回指向容器中第一个元素的正向迭代器 end() 返回指向容器最后一个元素之后一个位置的正向迭代器 rbegin() 返回指向最后一个元素的反向迭代器 rend() 返回指向第一个元素之前一个位置的反向迭代器 cbegin() 和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器 cend() 和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器 crbegin() 和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器 crend() 和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器 注意，如果是 const 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素； begin() 和 end() 为C++11新增，操作对象还可以是数组。 主要成员函数 标粗部分是常用的函数。 关联容器虽然底层也是双向迭代器，不是随机迭代器，一些随机迭代器才支持的方法，比如at(n)、[n]是不支持的，但支持按键值查找at(key)、[key]方法； 关联容器不能在指定位置上删除、插入元素，所以STL没有提供push_back()、push_front()之类头尾操作方法，而是使用emplace() 或insert()。 成员函数 功能 empty() 若容器为空，则返回 true；否则 false size() 返回当前 map 容器中存有键值对的个数 max_size() 返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同 operator[key] map容器重载了 [] 运算符，获取指定键的值，查找失败添加新的键值对 at(key) 找到 map 容器中 key 键对应的值，查找失败引发 out_of_range 异常 insert() 向 map 容器中插入键值对，如果key重复会覆盖 erase() 删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对 swap() 交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。 clear() 清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0 emplace() 基本同insert，但相比insert效率更高 count(key) 在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。 相比序列容器，关联容器独有的一些函数： 成员函数 功能 find(key) 在 map 容器中查找键为 key 的键值对，找到返回对应迭代器（和at、[]不同，不是返回value），如果没找到返回和 end() 方法一样的迭代器 lower_bound(key) 返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器，如果没找到返回和 end() 方法一样的迭代器 upper_bound(key) 类似上，不过返回的是第一个大于 key的（不包含等于） 简单对比下operator[key] 和at(key) 这两种查询key的方式。 注意到，operator[key] 如果没查找到key，还会直接给map插入当前未查找到的key。 12345678910111213141516#include&lt;map&gt;#include&lt;string&gt; #include&lt;iostream&gt; int main()&#123; // 空map map&lt;int,std::string&gt; map1 &#123; &#125;; // at(key) // map1.at(1); // error程序终止，抛出异常 // [key] map1[1]; std::cout&lt;&lt; map1.begin()-&gt;first &lt;&lt;&quot;,&quot; &lt;&lt; map1.begin()-&gt;second &lt;&lt; std::endl;&#125; 编译器自动初始化了value：如果是基本数据类型，则值为 0；如果是 string 类型，其值为 “”，即空字符串。 输出： 12[root@roy-cpp test]# ./test.out 1,&quot;&quot; 底层实现 本节我们主要探讨以下问题： map底层数据结构及实现？ map底层迭代器如何定义？ map底层如何插入、删除一个数据？ 本节只做简单分析。 map底层数据结构及实现？ 前面我们说过，map底层是红黑树，可以在map代码中验证： 12345678910111213141516template &lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;,typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt; &gt;class map&#123; public: typedef _Key key_type; typedef _Tp mapped_type; typedef std::pair&lt;const _Key, _Tp&gt; value_type; ... private: typedef typename _Alloc::template rebind&lt;value_type&gt;::other _Pair_alloc_type; // 红黑树模板类 typedef _Rb_tree&lt;key_type, value_type, _Select1st&lt;value_type&gt;, key_compare, _Pair_alloc_type&gt; _Rep_type; /// The actual tree structure. _Rep_type _M_t; // map底层的红黑树 ... 具体展开就是对红黑树的分析了，大致了解到这就行。 map底层迭代器如何定义？ map中迭代器使用的是红黑中的迭代器： 1typedef typename _Rep_type::iterator iterator; 12345678910enum _Rb_tree_color &#123; _S_red = false, _S_black = true &#125;;struct _Rb_tree_node_base &#123; typedef _Rb_tree_node_base* _Base_ptr; typedef const _Rb_tree_node_base* _Const_Base_ptr; _Rb_tree_color _M_color; _Base_ptr _M_parent; // 父指针 _Base_ptr _M_left; // 左指针 _Base_ptr _M_right; // 右指针 map底层如何插入、删除一个数据？ 主要是红黑树相关删除、插入操作。 multimap multimap 容器具有和 map 极为相似的特性： multimap 容器的类模板也定义在&lt;map&gt;头文件； 也按键值对方式存储数据，底层也是红黑树结构； 会根据键值升序排序元素； 成员函数大部分相同； 键值无法修改； … 主要的不同体现在： multimap 可以同时存储多个键相同的键值对； multimap 除了find(key)，不能使用at(key) 或 operator[key] 等直接按key获取value的方式（很好理解，multimap会存在多个重复的键）。 multimap 也定义在 &lt;map&gt; 头文件，如下所示： 12345template &lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt; &gt;class multimap 在 multimap &lt;_Key,_Tp,_Compare,_Alloc&gt; 模板中： _Key，指定键的类型； _Tp，指定值的类型； _Compare：指定排序顺序，默认选用升序std::less&lt;_Key&gt;，也可以选用std::greater&lt;_Key&gt; 或者自定义排序规则； _Alloc，默认选用二级内存分配器。 一个简单使用实例（使用起来和map很相似）。 123456789101112131415161718192021222324252627282930#include&lt;map&gt;#include&lt;utility&gt;#include&lt;iostream&gt;#include&lt;string&gt; void printMMap(const multimap&lt;int,string&gt;&amp; m)&#123; std::cout&lt;&lt;&quot;size = &quot; &lt;&lt; m.size() &lt;&lt;&quot; : &quot;; // 打印键值对 for(auto iter = m.begin(); iter != m.end(); iter++) std::cout&lt;&lt;&quot;&lt;key=&quot;&lt;&lt; iter-&gt;first &lt;&lt;&quot;, value=&quot; &lt;&lt; iter-&gt;second &lt;&lt; &quot;&gt; &quot;; std::cout&lt;&lt;&quot;\\n&quot;; &#125;int main()&#123; // make_pair multimap&lt;int,std::string&gt; mmap1 &#123; std::make_pair(1,&quot;一&quot;),std::make_pair(1,&quot;壹&quot;)&#125;; // 键值相同，都是1 // map1[1] = &quot;one&quot;; // error，无法修改键值 // 插入 mmap1.emplace(std::make_pair(0,&quot;零&quot;)); mmap1.emplace(std::make_pair(4,&quot;四&quot;)); printMMap(mmap1); // 删除 mmap1.erase(3); mmap1.erase(4); printMMap(mmap1);&#125; 输出（自动排序）： 123[root@roy-cpp test]# ./test.out size = 4 : &lt;key=0, value=零&gt; &lt;key=1, value=一&gt; &lt;key=1, value=壹&gt; &lt;key=4, value=四&gt; size = 3 : &lt;key=0, value=零&gt; &lt;key=1, value=一&gt; &lt;key=1, value=壹&gt; 关于成员函数 multimap的成员函数，除了不能使用at(key)、operator[key] ，基本和map一致，故不单列了。 set map和set都是以红黑树作为底层数据结构，所以外部表现的也极为相似： 不允许出现键值重复； 所有的元素都会被自动排序； 不能通过迭代器来改变set的值，因为set的值就是键（关联容器的键值不允许修改）； 成员函数极为类似； … 主要区别在于： set容器存储的键值对（key-value）的key、value完全相同。在底层实现上，map底层区别也主要是修改红黑树存储的key、value保存一致； set容器除了find(key)，不能使用at(key) 或 operator[key]获取value ，虽然在底层实现上set的key等于value，但是不允许获取value。 对于第一个区别，我们查看set容器底层实现： 123456789101112131415161718template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;,typename _Alloc = std::allocator&lt;_Key&gt; &gt;class set&#123; ... public: typedef _Key key_type; typedef _Key value_type; // 和key_type一样 ... private: typedef typename _Alloc::template rebind&lt;_Key&gt;::other _Key_alloc_type; // 和map几乎一致 // 唯一区别在于红黑树类模板参数key_type和value_type其实是一样的 // 初始化时它们的值也一样 typedef _Rb_tree&lt;key_type, value_type, _Identity&lt;value_type&gt;, key_compare, _Key_alloc_type&gt; _Rep_type; _Rep_type _M_t; // Red-black tree representing set. 可以看到，底层实现上key、value的类型、值都会被设置为一样。set 容器类模板的定义中，也仅提供第 1 个参数（_Key）用于设定存储数据的类型。 set 容器以类模板形式定义在 &lt;set&gt; 头文件，如下所示： 1234template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt; &gt;loc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt; &gt;class set 在 set&lt;_Key,_Compare,_Alloc&gt; 模板中： _Key，指定键的类型； _Compare：指定排序顺序，默认选用升序std::less&lt;_Key&gt;，也可以选用std::greater&lt;_Key&gt; 或者自定义排序规则； _Alloc，默认选用二级内存分配器。 一个简单使用实例。 123456789101112131415161718192021222324252627282930#include&lt;set&gt;#include&lt;utility&gt;#include&lt;iostream&gt;#include&lt;string&gt; void printSet(const set&lt;int&gt;&amp; s)&#123; std::cout&lt;&lt;&quot;size = &quot; &lt;&lt; s.size() &lt;&lt;&quot; : &quot;; // 打印set键值 for(auto iter = s.begin(); iter != s.end(); iter++) std::cout&lt;&lt;&quot;key=&quot;&lt;&lt;*iter&lt;&lt; &quot; &quot;; // iter-&gt;first set不允许使用 std::cout&lt;&lt;&quot;\\n&quot;; &#125;int main()&#123; // 初始化 set&lt;int&gt; set1 &#123; 1,2,3,4 &#125;; // 键值不能相同 // set1[1]; // error，不能使用[key]或at(key) // 插入 set1.emplace(0); set1.emplace(4); printSet(set1); // 删除 set1.erase(3); set1.erase(4); printSet(set1);&#125; 输出： 123[root@roy-cpp test]# ./test.out size = 5 : key=0 key=1 key=2 key=3 key=4 size = 3 : key=0 key=1 key=2 关于成员函数 set、multimap的成员函数，除了不能使用at(key)、operator[key] ，基本和map一致（底层实现上就非常相似），故不单列了。 multiset multiset和map的主要区别在于： multiset可以存储相同的键值； multiset键值对相同； 除了map/unordered_map，multiset和set、multimap一样，也不能使用at(key) 或 operator[key]，但可以使用find(key) 。 multiset 也定义在 &lt;set&gt; 头文件，如下所示： 1234template &lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt; &gt;class multiset 在 multiset&lt;_Key,_Compare,_Alloc&gt; 模板中： _Key，指定键的类型； _Compare：指定排序顺序，默认选用升序std::less&lt;_Key&gt;，也可以选用std::greater&lt;_Key&gt; 或者自定义排序规则； _Alloc，默认选用二级内存分配器。 一个简单使用实例（使用起来和set很相似）。 1234567891011121314151617181920212223242526272829#include&lt;set&gt;#include&lt;utility&gt;#include&lt;iostream&gt;#include&lt;string&gt; void printMSet(const multiset&lt;int&gt;&amp; ms)&#123; std::cout&lt;&lt;&quot;size = &quot; &lt;&lt; ms.size() &lt;&lt;&quot; : &quot;; for(auto iter = ms.begin(); iter != ms.end(); iter++) std::cout&lt;&lt;&quot;key=&quot;&lt;&lt;*iter&lt;&lt; &quot; &quot;; // iter-&gt;first ，set、multiset不允许使用 std::cout&lt;&lt;&quot;\\n&quot;; &#125;int main()&#123; // make_pair multiset&lt;int&gt; mset1 &#123; 1,1,2,3 &#125;; // 存在键值相同 // mset1[1]; // error，不能使用[key]或at(key) // 插入 mset1.emplace(0); mset1.emplace(4); printMSet(mset1); // 删除 mset1.erase(3); mset1.erase(4); printMSet(mset1);&#125; 输出（自动排序）： 123[root@roy-cpp test]# ./test.out size = 6 : key=0 key=1 key=1 key=2 key=3 key=4 size = 4 : key=0 key=1 key=1 key=2 关于成员函数 multimap、set、multiset的成员函数，除了不能使用at(key)、operator[key] ，基本和map一致（底层实现上就非常相似），故不单列了。 9.2.3 无序关联式容器 本节主要介绍以下容器： 容器 底层数据结构 特点 迭代器类型 unordered_map 哈希表，下同 键必须唯一，会根据键大小默认升序排序 前向迭代器，下同 unordered_multimap 基本同前，但unordered_multimap键可重复 unordered_set 键和值完全相同，键依旧唯一，默认升序 unordered_multiset 基本同前，但unordered_multiset键可重复 正如名字“unordered”所暗示的，这些关联式容器是无序的，它们不会像之前的map/set/multimap/multiset/等关联容器一样，自动按键值大小对存储的键值对进行排序。 为什么无序关联容器不会自动排序了？ 这是因为“unordered”版本的关联式容器底层数据结构采用的是哈希表 而不是红黑树 ，哈希表结构不适合插入元素时进行排序。 哈希表（Hash table）是根据关键码值(Key value)而直接进行访问的数据结构。 例如， std::unordered_map在内存中的哈希表形式结构： 直观上来看： 哈希表是一个buckets数组（C++中使用vector实现）； 每个bucket是一个指针，指向它外挂的键值对链表（有时候我们用“bucket”指代外挂的链表）。 在哈希表查找指定key的value大致过程如下： 以 std::unordered_map 中 [key] 或 at(key) 查找过程为例。 使用hash(key)函数进行哈希映射，得到一个key对应的哈希值； 将哈希值和桶数量n 做哈希值 % n运算，元素结果即bucket的编号（下标），由此定位到具体的bucket上； 遍历查找定位的bucket外挂的键值对链表，如果找到key返回对应value（find(key)方法返回对应迭代器），如果没找到抛出异常（find(key)方法返回迭代器unordered_map::end()）。 为什么要重新设计哈希表作为底层结构？ 这涉及到红黑树和哈希表的数据结构特性： 查找、修改效率上：哈希表更快（哈希映射查找），常数级别O(1)，但哈希碰撞严重最坏O(n)；红黑树更慢（二叉树二分查找），但稳定O(logn)级别； 插入、删除效率上：哈希表更快，常数级别O(1)，红黑树更慢，但稳定O(logn)。 所以，选择哈希表作为底层结构的无序容器，增删查改效率通常是更好的。一般建议选择无序关联容器，除非你真的需要key有序。 unordered_map unordered_map 容器和 map 容器一样： 以键值对（pair类型）的形式存储数据； 存储的各个键值对的键互不相同且不允许被修改。 但由于 unordered_map 容器底层采用的是哈希表存储结构，该结构本身不具有对数据的排序功能，所以此容器内部不会自行对存储的键值对进行排序。 unordered_map 容器以类模板形式定义在 &lt;unordered_map&gt; 头文件，如下所示： 12345template&lt;class _Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred = std::equal_to&lt;_Key&gt;, class _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt; &gt;class unordered_map : __check_copy_constructible&lt;_Alloc&gt; 在 unordered_map&lt;_Key,_Tp,_Hash,_Pred,_Alloc&gt; 模板中： _Key，指定键的类型； _Tp，指定值的类型； _Hash：指定要使用的哈希函数，默认选用hash&lt;_Key&gt;，不过默认哈希函数只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类； _Pred：unordered_map不允许键值相等，而判断是否相等的规则，就由此参数指定； _Alloc，默认选用二级内存分配器。 使用简单举例。 和map的提供的上层函数接口基本一致，如emplace() 插入元素等。 12345678910111213141516171819202122232425262728#include&lt;unordered_map&gt;#include&lt;utility&gt;#include&lt;iostream&gt;#include&lt;string&gt; void printUMap(const unordered_map&lt;int,string&gt;&amp; m)&#123; std::cout&lt;&lt;&quot;size = &quot; &lt;&lt; m.size() &lt;&lt;&quot; : &quot;; // 打印键值对 for(auto iter = m.begin(); iter != m.end(); iter++) std::cout&lt;&lt;&quot;&lt;key=&quot;&lt;&lt; iter-&gt;first &lt;&lt;&quot;, value=&quot; &lt;&lt; iter-&gt;second &lt;&lt; &quot;&gt; &quot;; std::cout&lt;&lt;&quot;\\n&quot;; &#125;int main()&#123; unordered_map&lt;int,std::string&gt; umap1 &#123; &#123;1,&quot;一&quot;&#125;,&#123;2,&quot;二&quot;&#125;&#125;; umap1[1]; // &quot;一&quot; umap1[2]; // &quot;二&quot; // 插入 umap1.emplace(std::make_pair(0,&quot;零&quot;)); umap1.emplace(std::make_pair(4,&quot;四&quot;)); printUMap(umap1); // 删除 umap1.erase(3); umap1.erase(4); printUMap(umap1);&#125; 输出（未排序）： 123[root@roy-cpp test]# ./test.out size = 4 : &lt;key=4, value=四&gt; &lt;key=0, value=零&gt; &lt;key=2, value=二&gt; &lt;key=1, value=一&gt; size = 3 : &lt;key=0, value=零&gt; &lt;key=2, value=二&gt; &lt;key=1, value=一&gt; 成员函数 unordered_map 既可以看做是关联式容器，更属于自成一脉的无序容器。所以其成员函数可分为： 迭代器相关 基本方法 无序容器独有方法 我们先一睹为快。 迭代器相关 无序容器只有前向迭代器，尾部操作相关迭代器和函数都没有。 成员函数 功能 begin() 返回指向容器中第一个元素的正向迭代器 end() 返回指向容器最后一个元素之后一个位置的正向迭代器 cbegin() 和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器 cend() 和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器 注意，如果是 const 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素； begin() 和 end() 为C++11新增，操作对象还可以是数组。 基本方法（基本同map） 标粗部分是常用的函数。 无序关联容器虽然底层不是随机迭代器，一些随机迭代器才支持的方法，比如at(n)、[n]是不支持的，但支持按键值查找at(key)、[key]方法； 关联容器不能在指定位置上删除、插入元素，所以STL没有提供push_back()、push_front()之类头尾操作方法，而是使用emplace() 或insert()。 成员函数 功能 empty() 若容器为空，则返回 true；否则 false size() 返回当前 unordered_map容器中存有键值对的个数 max_size() 返回 unordered_map容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同 operator[key] map容器重载了 [] 运算符，获取指定键的值，查找失败添加新的键值对 at(key) 找到 map 容器中 key 键对应的值，查找失败引发 out_of_range 异常 insert() 向 map 容器中插入键值对，如果key重复会覆盖 erase() 删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对 swap() 交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。 clear() 清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0 emplace() 基本同insert，但相比insert效率更高 count(key) 在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。 无序容器独有方法 相比序列容器、有序容器，无序容器独有的一些哈希表相关方法： 成员函数 功能 bucket_count() 返回当前桶数量（一个线性链表代表一个桶） max_bucket_count() 返回最多可以使用多少桶 bucket_size(n) 返回第 n 个桶中存储键值对的数量 bucket(key) 返回以 key为键的键值对所在桶的编号 load_factor() 返回 unordered_map 容器中当前的负载因子，即负载因子 = 容器存储的总键值对 / 桶数 ， load_factor() = size() / bucket_count() max_load_factor() 返回或者设置当前 unordered_map 容器的负载因子 rehash(n) 将当前容器底层使用桶的数量设置为 n reserve() 将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个键值对（不超过最大负载因子）所需的数量，并重新整理容器 hash_function() 返回当前容器使用的哈希函数对象 对于无序容器的独有方法进行测试。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;using namespace std;void printUmapInfo(const unordered_map&lt;string, string&gt;&amp; umap)&#123; cout &lt;&lt; &quot;umap 初始桶数: &quot; &lt;&lt; umap.bucket_count() &lt;&lt; endl; cout &lt;&lt; &quot;umap 最大可使用桶数: &quot; &lt;&lt; umap.max_bucket_count() &lt;&lt; endl; cout &lt;&lt; &quot;umap 当前存在的键值对: &quot; &lt;&lt; umap.size() &lt;&lt; endl; cout &lt;&lt; &quot;umap 初始负载因子: &quot; &lt;&lt; umap.load_factor() &lt;&lt; endl; cout &lt;&lt; &quot;umap 最大负载因子: &quot; &lt;&lt; umap.max_load_factor() &lt;&lt; endl; cout &lt;&lt; &quot;—————————————————————————————————————&quot; &lt;&lt; endl;&#125;int main()&#123; // 创建空 umap 容器 unordered_map&lt;string, string&gt; umap; // 设置 umap 使用最适合存储 9 个键值对的桶数 umap.reserve(9); printUmapInfo(umap); // 向 umap 容器添加 3 个键值对 umap[&quot;name&quot;] = &quot;royhuang&quot;; umap[&quot;age&quot;] = &quot;25&quot;; umap[&quot;university&quot;] = &quot;chongqingU&quot;; printUmapInfo(umap); // 调用 bucket() 获取指定键值对位于桶的编号 cout &lt;&lt; &quot;“age”存储在第：&quot; &lt;&lt; umap.bucket(&quot;age&quot;) &lt;&lt;&quot;个桶&quot;&lt;&lt; endl; // 自行计算某键值对位于哪个桶 auto fn = umap.hash_function(); cout &lt;&lt; &quot;hash(age)%n，计算“age”存储在第：&quot; &lt;&lt; fn(&quot;age&quot;) % (umap.bucket_count()) &lt;&lt;&quot;个桶&quot;&lt;&lt; endl; return 0;&#125; 输出： 123456789101112131415[root@roy-cpp test]# ./test.out umap 初始桶数: 11umap 最大可使用桶数: 576460752303423487umap 当前存在的键值对: 0umap 初始负载因子: 0umap 最大负载因子: 1—————————————————————————————————————umap 初始桶数: 11umap 最大可使用桶数: 576460752303423487umap 当前存在的键值对: 3umap 初始负载因子: 0.272727umap 最大负载因子: 1—————————————————————————————————————“age”存储在第：5个桶hash(age)%n，计算“age”存储在第：5个桶 底层实现 unordered_map底层实现主要就是哈希表： 具体逻辑暂略。 unordered_multimap 回忆map和multimap的区别： map和multimap主要的不同体现在： multimap 可以同时存储多个键相同的键值对； multimap 除了find(key)，不能使用at(key) 或 operator[key] 等直接按key获取value的方式（很好理解，multimap会存在多个重复的键）。 multimap 也定义在 &lt;map&gt; 头文件，… unordered_map和unordered_multimap的区别同上： unordered_multimap可以同时存储多个键相同的键值对； unordered_multimap除了find(key)，不能使用at(key) 或 operator[key] 等直接按key获取value的方式 。 unordered_multimap也定义在 &lt;unordered_map&gt; 头文件中，使用起来基本和unordered_map没差，不再重复介绍了。 unordered_set 回忆set和map的区别： 主要区别在于： set容器存储的键值对（key-value）的key、value完全相同。在底层实现上，map底层区别也主要是修改红黑树存储的key、value保存一致 ; set容器除了find(key)，不能使用at(key) 或 operator[key]获取value ，虽然在底层实现上set的key等于value，但是不允许获取value。 unordered_set和unordered_map的区别同上。 unordered_multiset 回忆multiset和map的区别： multiset和map的主要区别在于： multiset可以存储相同的键值； multiset键值对相同； 除了map/unordered_map，multiset和set、multimap一样，也不能使用at(key) 或 operator[key]，但可以使用find(key) 。 unordered_map和unordered_multiset的区别同上。 9.2.4 容器适配器 本节主要介绍以下容器： 容器 底层数据结构 特点 迭代器类型 stack （默认）deque 元素“先进后出” 无 queue （默认）deque 元素“先进先出” 无 priority_queue （默认）vector 元素“先进优先级高先出” 无 或许你和第一次接触“容器适配器”这个名词的我，都会感到纳闷：这词听起来有些古怪，它是什么意思呢？它也是容器吗？ “容器适配器”是什么意思？ 在栈（stack）这种数据结构中，必须要满足“先进后出”这种特性。而我们之前的容器，如deque、list都无法满足这种特性。 但我们可以，比如对基础容器deque，进行一层封装：禁止头部进出只允许尾部进出，这样就适配了栈“先进后出”的特性。这种通过，封装某个序列式容器，并重新组合该容器中包含的成员函数来实现“需要的特性”的容器（必要时也可以自创新函数），就称为容器适配器。 所以，容器适配器自然也是容器。特别的，STL中的容器适配器，基础容器并不是固定的，还允许我们选择满足条件的基础容器。采用的底层基础容器不同，其执行效率也不尽相同，一般来说使用默认的就行。 stack stack 栈适配器是一种单端开口的容器，该容器模拟的就是栈存储结构，只能在栈顶插入、删除。 下图展示了stack的简单使用。 stack 容器以类模板的形式定义在 &lt;stack&gt; 头文件，如下所示： 12template&lt;typename _Tp, typename _Sequence = deque&lt;_Tp&gt; &gt;class stack 在 stack&lt;_Tp,_Sequence&gt; 模板中： _Tp，用于指明容器中元素数据类型； _Sequence，指定底层使用的基础容器。 简单使用实例。 在这个例子中，我们没有使用默认的deque作为基础容器，而是使用list。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;list&gt;using namespace std;int main()&#123; // 构建 stack 容器适配器 list&lt;int&gt; values&#123; 1, 2, 3 &#125;; // 基础容器list stack&lt;int, list&lt;int&gt;&gt; my_stack(values); // 查看 my_stack 存储元素的个数 cout &lt;&lt; &quot;size of my_stack: &quot; &lt;&lt; my_stack.size() &lt;&lt; endl; my_stack.push(4); cout &lt;&lt; &quot;size of my_stack: &quot; &lt;&lt; my_stack.size() &lt;&lt; endl; // 将 my_stack 中存储的元素依次弹栈，直到其为空 while (!my_stack.empty()) &#123; cout &lt;&lt; my_stack.top() &lt;&lt; endl; my_stack.pop(); // 将栈顶元素弹栈 &#125; return 0;&#125; 底层实现 stack底层就是封装了基础容器。 12345678template&lt;typename _Tp, typename _Sequence = deque&lt;_Tp&gt; &gt;class stack&#123; ... protected: // See queue::c for notes on this name. _Sequence c; // 底层基础容器，模板参数指定 ... 查看经典的stack::push()、stack::pop() 实现： 123456789101112131415push(const value_type&amp; __x) // 引用&#123; c.push_back(std::move(__x)); // 就是基础容器的push_back方法&#125;push(value_type&amp;&amp; __x) // 右值引用&#123; c.push_back(std::move(__x)); &#125;pop()&#123; __glibcxx_requires_nonempty(); c.pop_back(); // 基础容器的pop_back方法&#125; 确实主要还是借助基础容器的成员和方法实现。 成员函数 相比其它序列或关联式容器，stack 是一类存储机制简单、提供成员函数较少的容器。 特别的，容器适配器都没有迭代器，所以遍历元素：只能不断移除元素，去访问下一个元素。 成员函数 功能 empty() 当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false size() 返回 stack 栈中存储元素的个数 top() 返回一个栈顶元素的引用，类型为 T&amp;，如果栈为空，程序会报错。 push(const T&amp; val) 先复制 val，再将 val 副本压入栈顶，这是通过调用底层容器的 push_back() 函数完成的 push(T&amp;&amp; obj) 以移动元素的方式将其压入栈顶，这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。 pop() 弹出栈顶元素 emplace(arg…) arg… 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素 swap(stack &amp; other_stack) 将两个 stack 适配器中的元素进行互换，需要注意的是，进行互换的 2 个 stack 适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同 queue 和 stack 栈容器适配器不同，queue 容器适配器有 2 个开口，一个开口（尾部）专门用来加入元素，另一个开头（头部）专门用来移除元素。 这种存储结构最大的特点是，最先进入 queue 的元素，也可以最先从 queue 中出来，即“先进先出”。 下图展示了queue这种结构。 stack 容器以类模板的形式定义在 &lt;stack&gt; 头文件，如下所示： 12template&lt;typename _Tp, typename _Sequence = deque&lt;_Tp&gt; &gt;class stack 在 stack&lt;_Tp,_Sequence&gt; 模板中： _Tp，用于指明容器中元素数据类型； _Sequence，指定底层使用的基础容器。 简单使用实例。 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;list&gt;using namespace std;int main()&#123; // 构建 stack 容器适配器 list&lt;int&gt; values&#123; 1, 2, 3 &#125;; // 基础容器list queue&lt;int, list&lt;int&gt;&gt; my_queue(values); // 查看 my_stack 存储元素的个数 cout &lt;&lt; &quot;size of my_queue: &quot; &lt;&lt; my_queue.size() &lt;&lt; endl; my_queue.push(4); cout &lt;&lt; &quot;size of my_queue: &quot; &lt;&lt; my_queue.size() &lt;&lt; endl; // 将 my_stack 中存储的元素依次弹栈，直到其为空 while (!my_queue.empty()) &#123; cout &lt;&lt; my_queue.front() &lt;&lt; endl; //将栈顶元素弹栈 my_queue.pop(); &#125; return 0;&#125; 输出： 1234567[root@roy-cpp test]# ./test.out size of my_queue: 3size of my_queue: 41234 底层实现 同stack，queue底层就是封装了基础容器。 12345678template&lt;typename _Tp, typename _Sequence = deque&lt;_Tp&gt; &gt;class queue&#123; ... protected: // See queue::c for notes on this name. _Sequence c; // 底层基础容器，模板参数指定 ... queue::push、queue::pop方法实现： 123456789101112131415push(const value_type&amp; __x) // 引用&#123; c.push_back(std::move(__x)); // 就是基础容器的push_back方法&#125;push(value_type&amp;&amp; __x) // 右值引用&#123; c.push_back(std::move(__x)); &#125;pop()&#123; __glibcxx_requires_nonempty(); c.pop_front(); // 基础容器的pop_front方法，stack这里是pop_back，所以是尾部弹出&#125; 成员函数 queue 容器适配器拥有stack 成员函数基本所有函数（除了top()、emplace()）。 特别的，容器适配器都没有迭代器，所以遍历元素：只能不断移除元素，去访问下一个元素。 成员函数 功能 empty() 当 queue中没有元素时，该成员函数返回 true；反之，返回 false size() 返回 queue中存储元素的个数 top() queue没有 push(const T&amp; val) 先复制 val，再将 val 副本压入队尾，这是通过调用底层容器的 push_back() 函数完成的 push(T&amp;&amp; obj) 以移动元素的方式将其压入队尾，这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。 pop() 弹出队头（第一个）元素 emplace(arg…) queue没有 swap(queue &amp; other_stack) 将两个 queue适配器中的元素进行互换，需要注意的是，进行互换的 2 个 queue适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同 queue 独有的函数： 成员函数 功能 front() 返回 queue 中第一个元素的引用 back() 返回 queue 中最后一个元素的引用 priority_queue priority_queue 容器适配器中元素的进出，遵循“先进优先级高的先出”原则。 那priority_queue 中元素优先级是如何评定？ 每个 priority_queue 容器适配器在创建时，都制定了一种“排序规则”。根据此规则，该容器适配器中存储的元素就有了优先级高低之分。 比如这种“排序规则”，可以是：元素值从大到小或从小到大。 priority_queue中元素进出和queue有些不同： 进：不直接插到队尾，找到优先级最高的元素，并将其移动到队列的队头； 出：直接移出队头，然后找到当前优先级最高的元素，并将其移动到队头。 优先队列可以使用数组、二叉搜索树、链表和堆数据结构来实现。但是，最好的选择是堆数据结构，因为它有助于相对更快、更有效地实现优先级队列。 priority_queue容器以类模板的形式定义在 &lt;queue&gt; 头文件，如下所示： 1234 template&lt;typename _Tp, typename _Sequence = vector&lt;_Tp&gt;, typename _Compare = less&lt;typename_Sequence::value_type&gt; &gt;class priority_queue 在 priority_queue&lt;_Tp,_Sequence,_Compare&gt; 模板中： _Tp，用于指明容器中元素数据类型； _Sequence，指定底层使用的基础容器； _Compare ，指定排序规则。 简单使用例子。 注意priority_queue的初始化有些不同。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;list&gt;using namespace std;int main()&#123; // 构建 stack 容器适配器 deque&lt;int&gt; values&#123; 5, 1, 3&#125;; // 此时是无序的list // priority_queue&lt;int, deque&lt;int&gt;&gt; my_priority_queue(values); // error,不能使用这种方式初始化 priority_queue&lt;int, deque&lt;int&gt;&gt; my_priority_queue&#123;values.begin(),values.end()&#125; ; // 初始化指定两个迭代器 // 查看 my_priority_queue 存储元素的个数 cout &lt;&lt; &quot;size of my_priority_queue: &quot; &lt;&lt; my_priority_queue.size() &lt;&lt; endl; my_priority_queue.push(4); cout &lt;&lt; &quot;size of my_priority_queue: &quot; &lt;&lt; my_priority_queue.size() &lt;&lt; endl; // 将 my_stack 中存储的元素依次弹栈，直到其为空 while (!my_priority_queue.empty()) &#123; cout &lt;&lt; my_priority_queue.top() &lt;&lt; endl; // 输出有序 // 队头元素（最高优先级出栈） my_priority_queue.pop(); &#125; return 0;&#125; 输出（有序）： 1234567[root@roy-cpp test]# ./test.out size of my_priority_queue: 3size of my_priority_queue: 45431 成员函数 priority_queue 拥有的成员函数和tack更像（基本一致）： 有top() 方法，没有queue独有的front() 或back() 方法； 特别的，容器适配器都没有迭代器，所以遍历元素：只能不断移除元素，去访问下一个元素。 成员函数 功能 empty() 当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false size() 返回 stack 栈中存储元素的个数 top() 返回一个栈顶元素的引用，类型为 T&amp;，如果栈为空，程序会报错。 push(const T&amp; val) 先复制 val，再将 val 副本压入栈顶，这是通过调用底层容器的 push_back() 函数完成的 push(T&amp;&amp; obj) 以移动元素的方式将其压入栈顶，这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。 pop() 弹出栈顶元素 emplace(arg…) arg… 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素 swap(stack &amp; other_stack) 将两个 stack 适配器中的元素进行互换，需要注意的是，进行互换的 2 个 stack 适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同 9.2.5 容器最佳实践 在本节我们从基本使用、底层实现、常用函数等方面介绍了众多容器，它们可分为： 序列式容器：array、vector、deque、list 和 forward_list； 关联式容器：map、multimap、set 和 multiset； 无序关联式容器：unordered_map、unordered_multimap、unordered_set 和 unordered_multiset； 容器适配器：stack、queue 和 priority_queue。 这么多容器，实际编码该选择哪一个呢？ 回忆各个数据结构的特点。 特点 对应容器 对应迭代器 数组 查找效率高且可随机查找、（除尾部）插入删除效率低 array/vector/deque 随机迭代器 链表 空间利用率高，插入删除效率高，查找较数组低 list/forwar_list 双向或前向迭代器 红黑树 在STL中存储键值对，增删查改效率均高，还会排序 map/set/… 双向迭代器 哈希表 在STL中存储键值对，不会排序，但比红黑树效率更高 unordered_map/ unordered_set/… 前向迭代器 首先，一般来说除非需要键值有序，在无序关联式容器/关联式容器中，优先考虑无序关联式容器。现在，我们再从时间效率角度 出发考虑各种容器的选择： 如果查找元素效率要求高 ：选择unordered_map/unordered_set或array/vector/deque 如果数据可按键值对存储：选择unordered_map/unordered_set，O(1)常数级别查找键值； 如果只能顺序存储 ：选择array/vector/deque 如果存储的是静态数据：选array； 如果存储的是动态数据：只在尾部增、删选vector；头、尾均需要增、删选deque。 如果插入、删除效率要求高： 如果插入、删除位置有要求 ：list/forwar_list 如果只在头部插入、删除数据：选forwar_list； 如果头、尾均需插入、删除数据：选list。 如果插入、删除位置没要求：选择unordered_map/unordered_set，O(lgn)级别复杂度。 至于stack、queue 和 priority_queue则一般是在你需要：“先进后出”、“先进先出”或“按优先级别出队”，这种特殊情况才考虑。 9.3 算法 STL提供了许多算法，供我们来对容器（或数组）中数据进行操作，通常可分两类： 会改变它们所应用的序列的算法 不改变它们所应用的序列的算法 可通过引入于&lt;algorithm&gt;头文件来使用： 1#include &lt;algorithm&gt; 不过在本文中，主要还是按算法功能来进行介绍。而且本文不会对各种算法进行具体介绍，通常只是对常用算法进行简单概况。 为什么不详细介绍各类算法？ 主要原因如下： 本文已经足够长（~3W字），每个算法详细介绍的话，篇幅长度难以估计把控； 一般情况下我们只需对大致函数功能有所了解就行，实际编码可查看具体的API接口，再深入理解即可。 另外，作者在实际工作中如果对一些算法有“踩坑和理解”，还会补充到本文中。 9.3.1 sort C++ STL 标准库提供很多实用的排序函数，通过调用它们，我们可以很轻松地实现对普通数组或者容器中指定范围内的元素进行排序。 函数名 用法 sort (first, last) 对容器或普通数组中 [first, last) 范围内的元素进行排序，默认进行升序排序 stable_sort (first, last) 和 sort() 函数功能相似，不同之处在于，对于 [first, last) 范围内值相同的元素，该函数不会改变它们的相对位置 partial_sort (first, middle, last) 从 [first,last) 范围内，筛选出 muddle-first 个最小的元素并排序存放在 [first，middle) 区间中 partial_sort_copy (first, last, result_first, result_last) 从 [first, last) 范围内筛选出 result_last-result_first 个元素排序并存储到 [result_first, result_last) 指定的范围中 is_sorted (first, last) 检测 [first, last) 范围内是否已经排好序，默认检测是否按升序排序 is_sorted_until (first, last) 和 is_sorted() 函数功能类似，唯一的区别在于，如果 [first, last) 范围的元素没有排好序，则该函数会返回一个指向首个不遵循排序规则的元素的迭代器 9.3.2 merge 有些场景中，我们需要将 2 个有序序列合并为 1 个有序序列，这时就可以借助 merge() 实现。 函数名 用法 merge (first1, last1, first2, last2, result) first1、last1、first2 以及 last2 都为输入迭代器，[first1, last1) 和 [first2, last2) 各用来指定一个有序序列；result 为输出迭代器，指定存储位置 merge (first1, last1, first2, last2, result, comp) 同上，不过多了comp 用于自定义排序规则 举例： 123456789101112131415#include &lt;iostream&gt; // std::cout#include &lt;algorithm&gt; // std::merge#include &lt;vector&gt; // std::vectorusing namespace std;int main()&#123; // first 和 second 数组中各存有 1 个有序序列 int first[] = &#123; 5,10,15,20,25 &#125;; int second[] = &#123; 7,17,27,37,47,57 &#125;; // 用于存储新的有序序列 vector&lt;int&gt; myvector(11); // 将 [first,first+5) 和 [second,second+6) 合并为 1 个有序序列，并存储到 myvector 容器中 merge(first, first + 5, second, second + 6, myvector.begin()); return 0;&#125; 9.3.3 find find() 函数本质上是一个模板函数，用于在指定范围内查找和目标元素值相等的第一个元素。 函数名 用法 find(first, last, const T&amp; val) 该函数会返回一个输入迭代器，first 和 last 为输入迭代器，[first, last) 用于指定该函数的查找范围；val 为要查找的目标元素。 其它的“find”函数： find_if() 或 find_not_if()， 和find唯一不同的是，前者需要明确指定要查找的元素的值，而后者则允许自定义查找规则； find_end() 或 search()，用于在序列 A 中查找序列 B， 最后一次或第一次出现的位置； find_first_of()：在 A 序列中查找和 B 序列中，和B中任意元素相匹配的第一个元素。 举例： 12345678910111213141516171819202122#include &lt;iostream&gt; // std::cout#include &lt;algorithm&gt; // std::find#include &lt;vector&gt; // std::vectorusing namespace std;int main() &#123; // find() 函数作用于普通数组 char stl[] =&quot;royhuang&quot;; // 调用 find() 查找第一个字符 &#x27;r&#x27; char * p = find(stl, stl + strlen(stl), &#x27;r&#x27;); // 判断是否查找成功 if (p != stl + strlen(stl)) cout &lt;&lt; p &lt;&lt; endl; // find() 函数作用于容器 std::vector&lt;int&gt; myvector&#123; 10,20,30,40,50 &#125;; std::vector&lt;int&gt;::iterator it; it = find(myvector.begin(), myvector.end(), 30); if (it != myvector.end()) cout &lt;&lt; &quot;查找成功：&quot; &lt;&lt; *it; return 0;&#125; 9.3.4 reverse reverse函数可以反转一个容器中的元素。 函数名 用法 reverse(_first, last) reverse函数反转的范围是[first,last)，不包括last指向的元素 简单实例。 12345678910#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; int main () &#123; std::vector&lt;int&gt; myvector &#123;1,2,3,4,5&#125;; std::reverse(myvector.begin(),myvector.end()); // 5 4 3 2 1 return 0;&#125; 9.3.5 copy_n copy_n() 算法，可以从源容器复制指定个数的元素到目标容器中。 函数名 用法 copy_n(source_first, size, target_start) source_first 是指向源容器的起始位置的迭代器，size是要复制的元素总数， target_start是目标容器的开始迭代器 简单实例。 123456789101112131415#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std; int main()&#123; int arr[] = &#123; 10, 20, 30, 40, 50 &#125;; vector&lt;int&gt; v1(5); // 复制arr中5个元素到v1中 copy_n(arr, 5, v1.begin()); return 0;&#125; 9.3.6 fill和fill_n fill() 和 fill_n() 算法提供了一种为元素序列填入指定值的简单方式，fill() 会填充整个序列； fill_n() 则以给定的迭代器为起始位置，为指定个数的元素设置值。 函数名 用法 fill(first, last, value) 给容器在位置[first,last)，填充指定值value fill_n(first, 10, value) 从指定位置first开始，填充n个value 9.4 总结 本文是《C++从零开始之C++篇》最后一篇博客，因此除了STL总结部分，还特意补充了《C++篇》的总结。 9.4.1 STL总结 在这篇博客中，作者主要从：STL迭代器、STL容器、STL算法对STL进行了全面介绍，其中STL容器是重点阐述内容。 迭代器：本质是指针的一层封装，具体实现为模板类，每个容器都有自己的迭代器类。迭代器主要功能是，提供了统一访问各种容器的方式，同时也使得算法和容器得于解耦，必要时可以作为“粘合剂”将二者联系起来。 容器：容器用来组织存储数据，具体实现也是模板类，本质是对数组、链表、红黑树、哈希表等基本数据结构的封装。最后作者还对实践中各种容器的选择，进行了简单总结。 算法：STL中提供了大量的算法供我们使用，具体实现是模板函数。理论上如果能使用STL中算法就尽量使用，本文主要对：sort、merge、find、reverse、copy_n、fill等常用算法进行了简略介绍。 不过在本文成型中，也发现了一些不足： 博文过长~3W字，放在一篇文章中显得过长，不利于阅读； 作者水平有限，对STL底层分析及STL算法等尚缺乏相关知识或经验，写作中难免部分描述不清。 针对上述问题或未发现的一些问题，后期作者会尽量进行完善，并将更新记录同步在文后。 9.4.2 C++总结 在重庆今天这个让人有点昏昏欲睡的下午，STL篇终于完结，不禁舒了一口气，长达2.7w的总结既是《C++篇》最后一篇博客，也应该是目前我写的最长的一篇博客。 也终于可以回过神来，做一个小结。 时间回到~3个月前，大约是11.20号，也就是9月结束找工作痛快玩了2个月后，我感到空虚过于无所事事，开始折腾起了自己的网站。在个人网站总结完自己实习和秋招笔记后，也萌发了学习C++的想法——主要是想到自己在腾讯实习从Java转到C++的痛苦经历，就还是在工作前提前学习一遍C++吧（菜是原罪）。 于是便有了《C++从零开始》 这个系列。 这是我第一次尝试写框架这么大的系列文章（光C++篇已经~13W+字），整个系列完成估计至少有40W字。当然字数多少并不重要，在这个过程中学习到很多，比如明确了一个很重要的原则：“写的文章不是给自己看的笔记，而是给别人看的博客”。秉着这个原则，每篇博客写完，我都会代入一个“旁观者”视角，自己读几遍，看逻辑是否清晰、文章是否有错误等。所以，每篇博客甚至整个系列其实一直在完善中。但限于自己的水平，错误和描述不清晰的地方依旧不少，比如每次我自己重读时依旧能发现（好消息是越来越少了）。 whatever，相信不断进步&amp;完善，总能达到满意的效果。 《C++从零开始》 接下来将主要专注于Linux/C++开发方面的知识，所以接下来的内容分为两大篇章： 《C++从零开始之Linux/C++系统编程》 《C++从零开始之网络编程》 和《C++从零开始之C++》互为《C++从零开始》的三部曲。 敬请期待！ 更新记录 2022-02-19：更新笔记 第一次更新 参考资料 1.嗨课网-STL教程：https://haicoder.net/stl/stl-data-structure.html ↩2.迭代器（iterator）和指针（pointer）区别在哪？https://www.zhihu.com/question/54047747 ↩3.STL 源码剖析：https://www.kancloud.cn/digest/stl-sources/ ↩4.C++ STL: 容器vector源码分析：https://blog.csdn.net/Z_Stand/article/details/106866871 ↩5.stl源码分析之vector：https://www.cnblogs.com/coderkian/p/3888429.html ↩6.Priority Queue - Insertion, Deletion and Implementation in C++ ↩","categories":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/categories/C/"},{"name":"从零开始","slug":"C/从零开始","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"},{"name":"C++进阶","slug":"C/从零开始/C-进阶","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/tags/C/"},{"name":"教程","slug":"教程","permalink":"https://hwh.zone/tags/%E6%95%99%E7%A8%8B/"},{"name":"C++进阶","slug":"C-进阶","permalink":"https://hwh.zone/tags/C-%E8%BF%9B%E9%98%B6/"},{"name":"STL","slug":"STL","permalink":"https://hwh.zone/tags/STL/"}]},{"title":"C++从零开始（十）：C++进阶（上）模板","slug":"C++从零开始（四）：C++进阶（上）模板","date":"2022-02-11T08:17:22.936Z","updated":"2022-02-19T10:01:34.873Z","comments":true,"path":"p/51012/","link":"","permalink":"https://hwh.zone/p/51012/","excerpt":"","text":"🌟《C++从零开始》 系列，开始更新中… C++从零开始https://hwh.zone/p/62712 八、模板 模板（Template）是C++中的泛型编程的基础。 就像类是一种模板，可以创建不同的对象。模板（Template），也可以创建不同的“对象”，只不过这个“对象”是函数或类。 类为同一类型的不同对象，提供了一份“通用的代码”。而产生所需的不同对象，只需实例化类生成对象时通过： 分配内存：为不同对象分配不同内存，这决定了它们物理意义上的不同； 构造函数初始化：调用指定构造函数和参数进行初始化，可以让对象产生值意义上的不同。 模板类似，根据类模板/函数模板可以实例化出不同的类/函数。这些类之间或函数之间的差异性，是在实例化时： 编译器会为每个实例出来的类/函数分配不同空间； 另一方面，是实例化时我们可以指定不同的数据类型。 模板最大的好处便体现在第2点，让我们编写的类或函数和数据类型无关，从而实现了通用编程。 本文主要探讨以下内容： 函数模板、类模板的应用场景及基本使用； 模板参数； 模板特化应用场景及使用，包含全特化和偏特化。 8.1 模板初识 8.1.1 函数模板 我们可能实现过这么一个mySwap 函数： 123456void mySwap(int&amp;a , int&amp; b) &#123; int temp = a; a = b; b = temp;&#125; 这虽然简单到都不需要进行注释，但是如果哪一天我们希望交换的数类型是long 、char、std::string 等，这肯定就让你发愁了。 总不然定义茫茫多的、仅仅数据类型不同的函数吧？还好你知道函数模板： 123456789101112131415161718192021// template允许我们的函数不再受限于数据类型template&lt;typename T&gt; void mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;int main()&#123; int a = 0, b = 1; int a1 = 0, b1 = 1; long a2 = 0, b2 = 1; mySwap&lt;int&gt;(a,b); // （1）实例化模板指定数据类型 mySwap&lt;int&gt;(a1,b1); // （2） mySwap&lt;long&gt;(a2,b2); // （3）&#125; 为你的机智点赞。现在我们探讨一点高深的问题： 函数模板实例化生成的“对象”在哪里？（1）、（2）两处会分别声明两个对象吗？ 我可以将模板的声明（.h）和定义（.cpp）分开吗？ 函数对象生成 模板实例化生成的函数，由编译器在编译阶段完成。（1）、（2）两处只会生成一个具体函数： 注意到上图红框（1）、（2）处，都是执行函数模板生成的同一个函数。 函数模板的声明和定义无法分开 模板的声明和定义不可以分开，如果你尝试这么做： 123// swap.htemplate&lt;typename T&gt; void mySwap(T&amp; t1, T&amp; t2); 12345678// swap.cpptemplate&lt;typename T&gt; void mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125; 12345678// test.cpp# include &quot;swap.h&quot;int main()&#123; int a = 0, b = 1; mySwap&lt;int&gt;(a,b); &#125; 编译时会发生错误： 1234[root@roy-cpp test]# g++ -std=c++11 test.cpp swap.cpp -o test.out/tmp/ccrmjFSC.o: In function `main&#x27;:test.cpp:(.text+0x25): undefined reference to `void mySwap&lt;int&gt;(int&amp;, int&amp;)&#x27;collect2: error: ld returned 1 exit status 上述显示链接时找不到函数 mySwap&lt;int&gt;(int&amp;, int&amp;)的定义。 理一理整个编译过程： 预编译：源文件test.cpp、 swap.cpp进行头文件替换等； 编译：test.cpp、 swap.cpp 分别单独编译生成可执行文件test.o 、swap.o。 test.cpp 编译到 mySwap&lt;int&gt;(a,b) 发现一个函数调用，不过没关系，先在函数位置生成符号标记为未定义，在链接时再寻找这个函数； swap.cpp 进行编译，期望swap.o 生成我们所需的函数符号，但是很意外，没有任何符号被生成。 所以汇编完成后，链接时无法找到mySwap任何相关定义，链接报错。 为什么swap.o 没有生成具体函数？ 这是因为模板分两次编译： 第一次编译发生在 swap.cpp中（实例化前），仅对模板进行一些语法检查等，不生成具体函数，所以 swap.o 符号表没有生成任何符号； 第二次编译是在test.cpp中（实例化时），编译到调用代码mySwap&lt;int&gt;(a,b)时，才会去编译 swap.cpp中模板mySwap生成具体函数，因为这个时候编译器才知道需要的类型是int，知道生成什么参数类型的函数。 但是test.cpp 的头文件 swap.h 仅包含函数模板mySwap 的声明，无法得知其定义，所以编译器无法根据其生成具体函数。 最终导致链接时发生错误。 解决办法也很简单，模板的定义和声明都放在头文件中即可，这样生成函数对象的时候就可以看到函数模板完整定义。 试一试。 注意到我们还在swap.h 设置了宏开关，避免模板定义出现在头文件中时，而swap.h被多个文件引用，导致mySwap 出现重复定义。 1234567891011// swap.h#ifndef mySwap_H#define mySwap_Htemplate&lt;typename T&gt; void mySwap(T&amp; a, T&amp; b) // 定义和声明在一块儿&#123; T temp = a; a = b; b = temp;&#125;#endif 12345678// test.cpp# include &quot;swap.h&quot;int main()&#123; int a = 0, b = 1; mySwap&lt;int&gt;(a,b); &#125; 再次编译一切正常： 这个解决方案同样适合类模板。 什么是类模板？奥我们还没开始讲呢，看官老爷请看下文。 8.1.2 类模板 认识类模板 类模板同样使得我们编写的类不用再和数据类型相关，更加通用。 下面这个模板类StaticArray，允许我们创建不同成员数据类型的静态数组类。 12345678910111213template &lt;typename T, int size&gt; class StaticArray&#123;private: T m_array[size]&#123;&#125;;public: T* getArray() &#123; return m_array; &#125; T&amp; operator[](int index) &#123; return m_array[index]; &#125;&#125;; 简单使用一下： 123456int main()&#123; StaticArray&lt;int, 4&gt; myArray1&#123;&#125;; StaticArray&lt;long, 10&gt; myArray2&#123;&#125;; return 0;&#125; 感觉还不错。 也许你注意到，我们进行模板定义时好像有点“奇怪”： 12template &lt;typename T, int size&gt; class StaticArray 这里还使用了参数 int ， C++称之为“非模板类型参数”，而不是只使用“模板类型参数”，即typename 。 模板参数 “模板类型参数” ，是一个占位符类型，用于替代作为参数传入的类型。 “非模板类型参数”，则是预定义的类型，它允许以下类型： 整数类型（浮点类型在C++20起开始支持） 枚举类型 指向类对象/函数/类成员函数的指针/引用 std::nullptr_t 回顾我们之前的代码： 1StaticArray&lt;int, 4&gt; myArray1&#123;&#125;; 实例化类模板StaticArray 时，编译器会将 T替换为int，size 替换为 4 。此时，int 是一个类型参数，而 4 是一个非类型参数。 最终m_array是 int[4] 类型。 最后注意，非模板类型参数只能用表达式 初始化，非表达式 是不被允许的。 12int x = 4;StaticArray&lt;int, x&gt; myArray1&#123;&#125;; // error 8.2 模板特化 模板使得我们不用再担心仅仅因为数据类型不同，而去定义多个极为类相似的函数或类。 因为我们的类模板/函数模板，可以处理不同数据类型。也就是对于不同数据类型，我们都可以使用同一套模板代码。 这会带来另一个问题：同一套代码，对特定的数据类型也许并不能很好地处理。 这就依旧需要我们针对特定数据类型，准备特定模板。 之前的例子： 12345678910111213141516171819template &lt;typename T, int size&gt; // 类模板class StaticArray&#123;private: T m_array[size]&#123;&#125;;public: T* getArray() &#123; return m_array; &#125; T&amp; operator[](int index) &#123; return m_array[index]; &#125; void print() &#123; for (int i&#123; 0 &#125;; i &lt; size; ++i) std::cout &lt;&lt; m_array[i] &lt;&lt; &#x27; &#x27;; std::cout &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;; 现在有一个成员函数print期望可以打印StaticArray 的不同数据类型成员m_array。 注意，这个函数为数组m_array 每个元素都设置了空格 ' ' 。 这看起来没什么毛病： 对于非字符类型，在每个数组元素之间放置一个空格是有意义的： 11 2 3 4 5 但对于字符类型数组，char数组 ，你肯定不想打印出来的结果是这样的： 1h e l l o w o r l d ! 所以我们希望函数模板（成员函数print此时也是模板，作为类模板的成员），针对特定的数据类型char，能进行特别处理。 这就是模板特化的思想， 模板特化具体又分为模板全特化和偏特化： 全特化就是限定死模板实现的模板类型参数； 偏特化就是如果这个模板有多个类型参数，那么只限定其中的一部分。 8.2.1 函数模板特化 函数模板特化初识 先从普通函数模板特化说起，再谈论成员函数模板特化。 函数模板有两个重要的概念： 对于函数模板，只有全特化，不能偏特化； 编译器优先匹配：全特化&gt;偏特化&gt;函数模板。 1234567891011121314151617181920212223242526/* tmp.cpp */ // 函数模板template&lt;typename T1, typename T2&gt;void fun(T1 a , T2 b) &#123;&#125;// 全特化template&lt;&gt;void fun&lt;int ,char&gt;(int a, char b) // 声明时&lt;&gt;指定参数类型&#123;&#125;// 函数不存在偏特化：下面的代码是错误的/*template&lt;typename T1&gt;void fun&lt;T1,char&gt;( T1 a , char b) // 偏特化，error&#123;&#125;*/int main()&#123; fun&lt;int,double&gt;(1,2); // 匹配模板函数，使用时&lt;&gt;指定参数类型 fun&lt;int,char&gt;(1,2); // 匹配全特化&#125; 注意到： 全特化通过尖括号&lt;int,char&gt;，对模板两个类型参数都进行了限制，T1、T2分别限定为 int 、char； 偏特化&lt;T1,char&gt;，只对T2进行了限制为char，T1没有限制（部分限制）。 为什么函数模板不允许偏特化？ 函数可以进行重载，函数模板也不例外，也可以进行重载。 但因为函数重载就可以实现偏特化，所以偏特化没有必要。 123456789101112131415/* tmp.cpp */ // 函数模板1template&lt;typename T1, typename T2&gt;void fun(T1 a , T2 b);/*// 函数不存在偏特化：下面的代码是错误的template&lt;typename T1&gt;void fun&lt;T1,char&gt;( T1 a , char b); // 偏特化，error*/// 函数模板2，重载了模板1// 实现了偏特化template&lt;typename T1&gt;void fun(T1 a , char b); // 不是偏特化，注意没有&lt;&gt; 到目前为止，函数模板的偏特化还没有得到C++标准的支持，不排除它在将来会被纳入标准的可能。 函数模板重载可以实现偏特化，那也应该能实现全特化吧？ 1234567891011// 函数模板1template&lt;typename T1, typename T2&gt;void fun(T1 a , T2 b);// 1.全特化template&lt;&gt;void fun&lt;int ,char&gt;(int a, char b); // &lt;&gt;指定参数类型// 2.模板2，重载了函数模板1template&lt;&gt;void fun(int a, char b); 1、2两处代码被视为是等价的，全特化就是模板1的重载。 那为啥全特化被允许使用？不明白，有机会厘清一下。 不过请注意，全特化的函数模板已经不能称之为模板。 全特化接管了编译器的工作，实例化出了函数。查看tmp.cpp的符号表，也发现确实已有符号生成： 而模板（及偏特化）只有在编译到调用代码时才会进行实例化，生成具体函数符号。 成员函数模板全特化 继续前面的例子，我们采用函数模板全特化解决。注意，此时print是成员函数。 123456789101112131415161718192021222324252627282930#include&lt;cstring&gt;#include&lt;iostream&gt;template &lt;typename T, int size&gt; // 类模板class StaticArray&#123;private: T m_array[size]&#123;&#125;;public: T* getArray() &#123; return m_array; &#125; T&amp; operator[](int index) &#123; return m_array[index]; &#125; void print() &#123; for (int i&#123; 0 &#125;; i &lt; size; ++i) std::cout &lt;&lt; m_array[i] &lt;&lt; &#x27; &#x27;; std::cout &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;;template &lt;&gt; // 成员函数模板全特化void StaticArray&lt;char, 13&gt;::print()&#123; for (int count&#123; 0 &#125;; count &lt; 13; ++count) std::cout &lt;&lt; m_array[count]; // 去除了字符之间的空格&#125; 注意到，template &lt;&gt; 模板参数已为空，代码26行处StaticArray&lt;char, 13&gt;将原本参数T 被替换为char ，size 被替换为13 。 1234567int main()&#123; StaticArray&lt;char, 13&gt; char13&#123;&#125;; std::strcpy(char13.getArray(), &quot;Hello world!&quot;); // 数组不能作为左值，用strcpy复制 char13.print(); return 0;&#125; 再次编译输出正常： 12[root@roy-cpp test]# ./test.out Hello world! 但这个全特化例子，对模板所有类型的参数都限定死了，包括size。所以，我们只能处理特定长度为13的字符串。 虽然我们很想使用偏特化，只对T进行限制为char ，对size 不进行限制： 123456template &lt;int size&gt; // 函数模板偏特化？errorvoid StaticArray&lt;char, size&gt;::print()&#123; for (int count&#123; 0 &#125;; count &lt; 13; ++count) std::cout &lt;&lt; m_array[count]; &#125; C++不允许呀！那就试试函数重载吧。 但是成员函数print()根本没办法重载，因为它没有任何参数来对T 进行限制。除非它是一个普通函数： 12345678910111213template &lt;typename T, int size&gt;void print(StaticArray&lt;T, size&gt;&amp; array) // 非成员函数，有一个StaticArray类型参数&#123; for (int count&#123; 0 &#125;; count &lt; size; ++count) std::cout &lt;&lt; array[count] &lt;&lt; &#x27; &#x27;;&#125;template &lt;int size&gt;void print(StaticArray&lt;char, size&gt;&amp; array) // 函数重载，此时ok&#123; for (int count&#123; 0 &#125;; count &lt; size; ++count) std::cout &lt;&lt; array[count];&#125; 不过我们可以迂回一点：函数模板不能偏特化，不代表类模板不能偏特化（类没有重载，不会受到限制）。我们可以偏特化出一个类模板，专门让成员函数print处理不同长度的char 类型数据。 这就是类模板的偏特化。 8.2.2 类模板特化 类模板全、偏特化 我们使用类模板偏特化，让成员函数print 可以处理不同长度的char类型数据。 123456789101112131415161718192021// template &lt;typename T, int size&gt;template &lt;int size&gt; class StaticArray&lt;char,size&gt; // 类模板偏特化&#123;private: char m_array[size]&#123;&#125;;public: char* getArray() &#123; return m_array; &#125; char&amp; operator[](int index) &#123; return m_array[index]; &#125; void print() &#123; for (int i&#123; 0 &#125;; i &lt; size; ++i) std::cout &lt;&lt; m_array[i]; std::cout &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;; 试一试： 123456789101112int main()&#123; StaticArray&lt;char, 7&gt; char7&#123;&#125;; // 长度为7 std::strcpy(char7.getArray(), &quot;Hello&quot;); StaticArray&lt;char, 13&gt; char13&#123;&#125;; // 长度为13 std::strcpy(char13.getArray(), &quot;Hello world!&quot;); char7.print(); // ok char13.print(); // ok return 0;&#125; 输出： 类模板全特化使用类似，这里仅做一个简单对比： 1234567891011// 类模板template &lt;typename T, int size&gt; class StaticArray;// 类模板偏特化template &lt;int size&gt; class StaticArray&lt;char,size&gt;; // 尖括号指定参数// 类模板全特化template &lt;&gt; class StaticArray&lt;char,14&gt;; // 尖括号指定参数 指针偏特化 先观察下面这个例子： 1234567891011// 类模板1template &lt;typename T&gt;class Storage;// 模板1的全特化版本template &lt;&gt;class Storage&lt;char*&gt;;// 类模板2，模板1的偏特化版本template &lt;typename T&gt;class Storage&lt;T*&gt;; 或许让你有点惊讶，类模板2依旧被视为是类模板1的偏特化版本。即使我们没有准确地指定底层类型，只是告诉编译器它用于指针类型。 下面是具体实例应用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;cstring&gt;// 模板1：只适合存储（单个）非指针类型成员template &lt;typename T&gt;class Storage&#123;private: T m_value;public: Storage(T value): m_value &#123; value &#125; // 只能初始化非指针成员（单个），值复制方式 &#123; &#125; ~Storage() &#123; &#125;&#125;;// 模板2：模板1的偏特化版本，可以存储（单个）指针类型成员template &lt;typename T&gt;class Storage&lt;T*&gt;&#123;private: T* m_value;public: Storage(T* value): m_value &#123; new T &#123; *value &#125; &#125; // 适合初始化（单个）指针成员，new分配 &#123; &#125; ~Storage() &#123; delete m_value; &#125;&#125;;// 模板1的全特化版本：适合存储char*指针数组template &lt;&gt;class Storage&lt;char*&gt;&#123;private: char* m_value;public: Storage(char* value) &#123; int length &#123; 0 &#125;; while (value[length] != &#x27;\\0&#x27;) ++length; ++length; m_value = new char[length]; for (int count = 0; count &lt; length; ++count) m_value[count] = value[count]; &#125; ~Storage() &#123; delete m_value; &#125;&#125;;int main()&#123; Storage&lt;int&gt; my_int &#123; 5 &#125;; int x &#123; 7 &#125;; Storage&lt;int*&gt; my_int_ptr(&amp;x); char *name &#123; new char[40]&#123; &quot;royhuang&quot; &#125; &#125;; Storage&lt; char*&gt; my_name(name); delete[] name;&#125; 模板相关介绍over，下章我们开始介绍C++标准库STL。 更新记录 2022-02-11 ：更新笔记 第一次更新 参考资料 1.C++ 模板偏特化与全特化 – 珂酱 (kejiang.co) ↩2.C++模板template用法总结：https://blog.csdn.net/qq_35637562/article/details/55194097 ↩","categories":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/categories/C/"},{"name":"从零开始","slug":"C/从零开始","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"},{"name":"C++进阶","slug":"C/从零开始/C-进阶","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/tags/C/"},{"name":"教程","slug":"教程","permalink":"https://hwh.zone/tags/%E6%95%99%E7%A8%8B/"},{"name":"C++基础","slug":"C-基础","permalink":"https://hwh.zone/tags/C-%E5%9F%BA%E7%A1%80/"},{"name":"模板","slug":"模板","permalink":"https://hwh.zone/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"C++从零开始（九）：面对对象（下）继承和虚函数","slug":"C++从零开始（三）：面对对象（下）继承和虚函数","date":"2022-02-08T08:24:59.978Z","updated":"2022-02-19T10:00:56.454Z","comments":true,"path":"p/60158/","link":"","permalink":"https://hwh.zone/p/60158/","excerpt":"","text":"🌟《C++从零开始》 系列，开始更新中… C++从零开始https://hwh.zone/p/62712 七、继承和虚函数 7.1 继承 面对对象三大特性：封装、继承、多态，继承在面对对象中的重要性不言而喻。 本章主要探讨的问题： 为什么需要继承？ 继承的访问权限和成员访问权限的区别？ 继承的派生类出现和基类同样（函数签名、返回类型一致）的函数，会发生什么？ 派生类对象构造时，是如何进行构造的？ 多重继承优缺点及菱形问题。 7.1.1 为什么需要继承？ 想象这么一个问题：如果存在一些简单、基本的对象，如何来创建一个新对象？ 通常我们使用对象组合和对象继承两种方式。 对象组合。这符合我们最直观的认知，适合新对象与基本对象之间存在has-a 关系。 例如，一个房间有一张桌子和凳子。我们创建一个ClassRoom类，然后组合table 和 chair构成ClassRoom。 12345678class ClassRoom // 教室&#123; private: Table _table; // 桌子 Chair _chair; // 椅子 public: ClassRoom(Table table,Chair chair):_table(table),_chair(chair)&#123;&#125;&#125;; 对象继承，也是本节的重点。与对象组合通过组合其他对象来创建新对象不同，继承直接获取其他对象的属性和行为，然后进行扩展来创建新对象。 下面的ClassRoom 便继承了Room ，获取了Room的price 、area 属性，然后再进行扩展。 123456789101112131415161718class Room &#123; private: double _price; double _area; public: Room(double price,double area):_price(price),_area(area)&#123;&#125;&#125;;class ClassRoom: public Room&#123; private: Table _table; // 桌子 Chair _chair; // 椅子 public: ClassRoom(Table table,Chair chair,double price,double area): _table(table),_chair(chair),Room(price,area)&#123;&#125;&#125;; 上例的例子很好地展示了继承的作用：派生类通过继承来重用被继承类（基类），然后派生类可以添加、修改或隐藏相关功能来进行扩展。 这使得继承： 提高了代码的复用性、维护性 类与类之间产生了联系，这是多态的前提 不过另一方面，继承有违开发原则“高内聚、低耦合”，因为继承会增加类的耦合性（类与类之间关系变得紧密）。 whatever，善用继承是熟练运用OOP（Object Oriented Programming，OOP）思想的重要体现。 上面的例子也带来一些思考： 继承访问权限是什么？和之前的类成员访问权限有什么不同吗？ 1class ClassRoom: public Room 派生类怎么添加、修改或隐藏基类相关功能？ 派生类实例化时，构造函数、析构函数的顺序有什么讲究吗？为什么存在这么一个顺序？ 很多语言如Java是不允许多重继承的，而C++为什么要允许多重继承，多重继承会带来什么问题吗？ 带着问题来和我一起认识一下吧。 7.1.2 继承相关概念 继承权限和访问符 先从类成员访问符说起，类成员访问控制符实现了类的封装。 123456789class Base&#123;public: int _public &#123;&#125;; protected: int _protected &#123;&#125;; private: int _private &#123;&#125;; &#125;; 回顾一下private、public访问符： private：私有成员，该成员仅在类内可以被访问，在类体外（包括派生类）是隐藏状态； public：公有成员，该成员在类内、类外也都可以被访问，是类对外提供的可访问接口。 在继承中，我们引入了第三种访问修饰符： protected：保护成员，和私有成员类似，不过在派生类可以被访问。 回到我们本小节的重点：继承权限的访问符。 派生类隐式包含了基类的副本。不同继承权限的访问符，本质就是修改基类副本的公有成员、保护成员，在派生类中的访问权限（私有成员不受影响）。 核心概念强调： 派生类并非是修改了原有类（基类）成员的访问权限，而是修改派生类持有基类的副本原本的访问权限； 继承方式对私有成员无影响。 不同继承权限的基类副本访问权限修改规则： public继承：所有基类成员副本都保持原有权限； private继承：所有基类成员副本被修改为private； protected继承：所有基类成员副本被修改为protected； public继承是使用最常用继承方式，其次是private继承，protected继承基本不使用。 我们来实际验证下上述结论（protected继承不举例，因为基本不用）。 public继承。 注意到，派生类中的基类副本成员访问权限和基类一致。 12345678910111213141516171819202122232425262728293031323334class Base&#123;public: int m_public &#123;&#125;;protected: int m_protected &#123;&#125;;private: int m_private &#123;&#125;;&#125;;class Pub: public Base&#123;public: Pub() &#123; m_public = 1; // okay m_protected = 2; // okay // m_private = 3; // not okay &#125;&#125;;int main()&#123; Base base; base.m_public = 1; // okay base.m_protected = 2; // not okay base.m_private = 3; // not okay // 在派生类中和基类成员访问权限一致 Pub pub; pub.m_public = 1; // okay pub.m_protected = 2; // not okay pub.m_private = 3; // not okay return 0;&#125; private继承。 注意到，派生类中的基类副本成员的访问权限都被修改为private。 123456789101112131415161718192021222324252627282930313233343536class Base&#123;public: int m_public &#123;&#125;;protected: int m_protected &#123;&#125;;private: int m_private &#123;&#125;;&#125;;class Pri: private Base&#123;public: Pub() &#123; // m_public = 1; // not okay // 此时访问的基类成员，访问权限按基类成员来 m_protected = 2; // okay // m_private = 3; // not okay &#125;&#125;;int main()&#123; Base base; base.m_public = 1; // okay // 基类m_protected访问权限依旧是protected，类外无法访问 base.m_protected = 2; // not okay base.m_private = 3; // not okay // 派生类中的基本副本所有成员的访问权限为private Pub pub; pub.m_public = 1; // not okay pub.m_protected = 2; // not okay，派生类中的m_protected已经是private权限，无法访问 pub.m_private = 3; // not okay return 0;&#125; using修改访问权限 通过继承权限设置，虽然可以修改派生类基类副本原本的访问权限，但也有局限性： 不能修改基类副本单个成员访问权限，只能全部修改； 无法修改private成员权限（比如为private→public）。 using弥补了这个缺陷。 例如，我们可以只将基类某个公共成员设为私有（通常用来隐藏基类中某个功能）： 123456789101112131415161718192021222324#include &lt;iostream&gt;class Base&#123;public: int m_value &#123;&#125;;&#125;;class Derived : public Base&#123;private: using Base::m_value; // 类外访问的派生类基类副本成员m_value，并修改为private，无法访问public: Derived(int value) &#123; m_value = value; // 这个时候访问的是基类成员m_value（public修饰，不是派生类的基类副本），所以还可以访问 &#125;&#125;;int main()&#123; Derived derived &#123; 7 &#125;; std::cout &lt;&lt; derived.m_value; // error，无法访问 return 0;&#125; 自然，也可以将私有设为公有（不过这破坏了类的封装性，慎用）： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;class Base&#123;private: int m_value &#123;&#125;;public: Base(int value): m_value &#123; value &#125; &#123; &#125;protected: void printValue() const &#123; std::cout &lt;&lt; m_value; &#125;&#125;;class Derived: public Base&#123;public: // 此时初始化基类成员m_value，只能通过调用基类构造函数这种方式，因为它是private，无法直接访问 Derived(int value): Base &#123; value &#125; &#123; &#125; using Base::printValue; // 派生类基本副本成员m_value访问权限修改为public&#125;;int main()&#123; Derived derived &#123; 7 &#125;; derived.printValue(); // 7，ok return 0;&#125; 函数重写 前面我们提到过继承的好处：“派生类通过继承来重用被继承类（基类），然后可以通过添加、修改或隐藏相关功能可以进一步扩展” 。 这里的：添加、修改或隐藏相关功能，是如何做到的？ 答案是通过函数重写。 理解这个问题，首先要明白派生类对象是如何调用一个函数的（不考虑虚函数）： 编译器首先查看该成员是否存在派生类中，如果不存在转2； 沿着继承链往上走，查看是存在任何父类定义中，如果不存在转3； 不存在该函数，调用失败。 函数重写便是利用这个调用顺序：在派生类中定义一个和基类完全一致（不止同名，而且函数签名、返回类型完全一致）的函数，在函数体对原有功能进行修改，达到添加、修改、隐藏相关功能。因为编译器首先调用的会是派生类中的函数。 看一个实例吧。 下面派生类中对基类的print 实现了隐藏，你永远无法通过派生类访问到基类的print方法。 1234567891011121314151617181920212223242526class Base&#123;private: void print() const &#123; std::cout &lt;&lt; &quot;Base&quot;; &#125;&#125;;class Derived : public Base&#123;public: void print() const &#123; std::cout &lt;&lt; &quot;Derived &quot;; &#125;&#125;;int main()&#123; Derived derived; derived.print(); // calls derived::print() return 0;&#125; 输出： 1Derived 完全隐藏基类的方法也许并不是你所需要的，但你还可以对基类的print添加功能。 12345678910class Derived : public Base&#123;public: void print() const &#123; Base::print(); // 范围运算符调用基类print函数 std::cout &lt;&lt; &quot;Derived &quot;; // 添加打印输出 &#125;&#125;; 输出： 12BaseDerived 同时，我们应该注意到函数重载和函数重写的异同。 函数重写分别位于基类、派生类，而函数重载位于同一类中。 函数重写的函数签名完全一致（不止同名），而函数重载仅仅是同名，函数签名并不同。 函数重写是运行时多态的一种体现（一个方法在不同的子类中表现出不同的行为），为了能对基类的功能实现修改、隐藏等而生，而函数重载是为了解决命名空间污染问题而生。 7.1.3 派生类构造函数 我们知道派生类继承至基类，那派生类进行实例化时： 基类部分由谁负责初始化？是基类构造函数吗？ 派生类构造函数只负责初始化派生类扩展部分吗？ 基类和派生类构造函数执行顺序是怎么样的？ 构造顺序 上述答案分别是： 基类部分初始化由基类构造函数负责； 派生类构造函数只负责派生类扩展部分初始化； C++ 分阶段构造派生类，从最基类（在继承树的顶部）开始，到最子类（在继承树的底部）结束。 验证一下。 12345678910111213141516171819202122232425262728293031323334class A&#123;public: A()&#123; std::cout &lt;&lt; &quot;A\\n&quot;; &#125;&#125;;class B: public A&#123;public: B()&#123; std::cout &lt;&lt; &quot;B\\n&quot;; &#125;&#125;;class C: public B&#123;public: C()&#123; std::cout &lt;&lt; &quot;C\\n&quot;; &#125;&#125;;class D: public C&#123;public: D()&#123; std::cout &lt;&lt; &quot;D\\n&quot;; &#125;&#125;;int main()&#123; std::cout &lt;&lt; &quot;构造 A: \\n&quot;; A a; std::cout &lt;&lt; &quot;构造 B: \\n&quot;; B b; std::cout &lt;&lt; &quot;构造 C: \\n&quot;; C c; std::cout &lt;&lt; &quot;构造 D: \\n&quot;; D d;&#125; 输出： 1234567891011121314构造 A：A构造 B：A B构造 C：A B C构造 D：A B C D 可以看到， C++ 总是首先构造“第一个”或“最基”类，然后它按顺序遍历继承树并构造每个派生类； 基类构造函数和派生类构造各自负责相应的部分。 顺便一提，析构函数执行顺序恰恰和构造函数相反。 为什么要按这种构造顺序？ 子类继承了父类，了解父类的一切，且经常需使用父类的成员或函数，但父类对子类一无所知。为了安全，首先实例化父类可以确保父类成员在被派生类使用前，就已经准备好了。 另一方面，迄今为止，派生类实例化时的基类构造函数都是隐式调用的。 如果我们想在派生类初始化基类成员，该如何实现？ 能不能直接显式调用基类构造函数初始化？ 初始化基类成员 为了方便说明，先将基类成员m_id 声明为public，试想如何在派生类中对其初始化？ 12345678910111213#include &lt;iostream&gt;class Base&#123;public: int m_id &#123;&#125;; Base(int id=0) : m_id&#123; id &#125; &#123; std::cout&lt;&lt; &quot;In base, m_id = &quot; &lt;&lt; id &lt;&lt;std::endl; &#125; int getId() const &#123; return m_id; &#125;&#125;; 既然m_id已被声明为public，容易想到两种初始化方式： 派生类构造函数成员列表初始化； 派生类构造函数体内赋值。 但第一种方式不被C++允许，因为第一种成员列表方式会导致m_id 在基类和派生类初始化两次，而初始化只能有一次。 123456789101112class Derived: public Base&#123;private: double m_cost &#123;&#125;;public: // error，不被允许 Derived(double cost, int id): m_id&#123; id &#125;,m_cost&#123; cost &#125; &#123; std::cout&lt;&lt; &quot;In Derived, m_cost = &quot; &lt;&lt; m_cost &lt;&lt;std::endl; &#125; double getCost() const &#123; return m_cost; &#125;&#125;; 第二种方式是允许的，因为这是重新赋值，不是初始化： 123456789101112class Derived: public Base&#123;private: double m_cost &#123;&#125;;public: Derived(double cost, int id): m_cost&#123; cost &#125; &#123; m_id&#123; id &#125;; // ok std::cout&lt;&lt; &quot;In Derived, m_cost = &quot; &lt;&lt; m_cost &lt;&lt;std::endl; &#125; double getCost() const &#123; return m_cost; &#125;&#125;; 但这有两个问题： 不够优雅，是重新赋值，而不是直接初始化； 如果m_id 是private/const/引用，这种方式也无法使用。 如果可以在派生类直接调用基类构造函数初始化，那该多好呀！ 现在我们在派生类的构造函数成员列表中，显示调用了基类构造函数。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;class Base&#123;private: // 私有 int m_id &#123;&#125;;public: Base(int id=0) : m_id&#123; id &#125; &#123; std::cout&lt;&lt; &quot;In base, m_id = &quot; &lt;&lt; id &lt;&lt;std::endl; &#125; int getId() const &#123; return m_id; &#125;&#125;;class Derived: public Base&#123;private: double m_cost &#123;&#125;;public: // 直接调用基类构造函数Base&#123; id &#125;初始化 Derived(double cost, int id): Base&#123; id &#125;,m_cost&#123; cost &#125; &#123; std::cout&lt;&lt; &quot;In Derived, m_cost = &quot; &lt;&lt; m_cost &lt;&lt;std::endl; &#125; double getCost() const &#123; return m_cost; &#125;&#125;;int main()&#123; Derived d&#123;2.33,1&#125;;&#125; 输出： 12In base, m_id = 1In Derived, m_cost = 2.33 以上完美解决了初始化基类成员的需求，但注意： 基类构造函数Base&#123; id &#125;只被执行了一次，依旧是从继承链顶部往下构造，派生类只是指定了基类构造函数的参数； 成员列表的基类构造函数Base&#123; id &#125; 的顺序无关紧要，无论如何，基类构造函数总是率先执行的： 首先执行基类构造函数（根据派生类中指定的参数）； 然后执行派生类构造函数成员列表初始化； 最后执行派生类构造函数体内代码。 7.1.4 多重继承 多重继承优缺点 在前面我们提到： 很多语言如Java是不允许多重继承的，C++为什么要允许多重继承，多重继承会带来什么问题吗？ 这是个很有意思的问题，我们来说说多重继承的优缺点。 多重继承的优点很明显：简单，清晰，更有利于复用。 但它的缺点同样明显： 二义性。如果两个基类（B、C）具有同名的方法（do()），在派生类中必须指定此方法来源于哪个基类。如下图： 123D d&#123;&#125;;d.do(); // errord.B::do(); // ::范围限定，ok 菱形继承。但如果是菱形继承，不但会带来二义性问题，还会使得派生类中具有重复拷贝的问题。 如下图： 派生类D中拷贝了两份A的副本！另一方面这也加重了二义性问题，因为a 也存在了二义性问题，虽然它只在A中被定义了一次。 123D d&#123;&#125;;d.a(); // errord.B::a(); // ::范围限定，ok 范围限定虽然能解决，但终究不是好方法，不够优雅，重复数据拷贝的问题也依旧存在。 这也是为什么C#和Java中不支持类多继承，而是使用类单继承和接口多继承设计替代类多继承。 既然C++选择了多重继承，我们来看看二义性和重复拷贝的问题如何解决： 二义性：可通过范围限定符:: 消除二义性； 重复拷贝：存在菱形继承中，通常使用虚继承来解决。 虚继承 类通过虚继承可以指出它希望共享的虚基类，对于虚基类，无论在派生层次中被继承多少次，都只存在一份共享的基类子对象。 在上例中，我们可以让类B、C都虚继承A，这样A在D中只会有一次拷贝。 实际编码验证： 123456789101112131415161718192021222324class A&#123; public: int a&#123;&#125;;&#125;;class B : virtual public A&#123; public: void doSomething() &#123;&#125;&#125;;class C : virtual public A&#123; public: void doSomething() &#123;&#125;&#125;;class D : public B, public C&#123;&#125;;int main()&#123; D d&#123;&#125;; d.a; // ok，避免了重复拷贝，也间接消除了A中成员的二义性&#125; B、C、D共享了同一份A的副本。 注意，虚继承只是避免了重复拷贝的问题，并没有消除二义性，B、C中doSomething 依旧存在二义性问题。 我们熟悉的istream和ostream 也是虚继承于ios ： 123class istream : virtual public ios &#123;...&#125;;class ostream : virtual public ios &#123;...&#125;;class iostream : public istream, public ostream &#123;...&#125;; 最后我们再来探讨下，虚继承和非虚继承方式的构造函数执行顺序： 非虚继承，构造函数执行顺序：A→B→A→C→D； 虚继承，构造函数执行顺序：A→B→C→D。 可见非虚继承中，A被初始化了两次，虚继承中A确实只被初始化了一次。 析构函数执行顺序恰相反： 非虚继承，析构函数执行顺序：D→C→A→B→A； 虚继承，析构函数执行顺序：D→C→B→A。 最佳实践 事实证明，大多数可以使用多重继承解决的问题，也可以使用单继承来解决。 另一方面，很多现代编程语言，如 Java 和 C#，将类限制为普通类的单继承，只允许接口类的多继承。 所以，我们应该尽量避免在C++中使用多重继承，除非： 这个时候多继承是最好的选择； 被多继承的类是设计良好的接口类。 7.2 虚函数 首先回忆下C++的多态性行为表现：对象在不同上下文环境会表现出不同的特性。 这有点抽象，我们具体一点。 C++支持两种多态： 编译时多态（静态多态）：通过重载函数实现，函数地址早绑定，编译期间就可以确定函数的链接地址； 运行时多态（动态多态）：通过虚函数实现，函数地址晚绑定，运行期间根据虚表来确定函数链接地址。 重载的同名函数，在函数签名不同（不同的上下文环境），会调用不同的函数（表现不同的行为）。 虚函数的作用便体现在C++的动态多态性上，可以根据调用函数的对象的类型（不同的上下文环境），会执行不同的虚函数（表现不同的行为）。 其大致实现过程如下： 首先，在基类的函数前加上virtual关键字，也就是虚函数，同时在派生类中重写该函数； 然后，声明基类类型的指针（或引用），该指针（或引用）会指向派生类对象； 最后，使用基类指针（或引用）调用该虚函数，如果指向对象类型是派生类，就调用派生类的函数；如果指向对象类型是基类，就调用基类的函数 。 这便通过虚函数实现了C++动态多态性，下面我们开始具体探讨： 基类指针/引用指向派生类对象，会发生什么？ 虚函数是什么？虚函数实现多态的原理？ 析构函数、构造函数和虚函数之间的一些问题？ 基类指针/引用↔和派生类指针/引用之间的转换是安全的吗？（上行转换和下行转换） 对象切片引发的一些编码问题。 7.2.1 指向派生类对象的基类指针和引用 认识基类指针和引用 我们了解到，派生类由两部分组成： 继承的基类部分； 自身扩展的部分。 好了，愉快地接受这个设定后。下面类实例内存布局就很容易接受了： 注意，派生类Derived实例化后内存布局：先拷贝基类部分，再扩展了自身部分，所以基类部分在前。 现在有一个很有意思的问题： 理论上，派生类对象是包含基类部分的，那基类指针或引用能指向派生类对象吗？如果能，基类指针能使用派生类扩展部分的成员吗？ 答案分别是：能，不能。 123456789101112131415int main()&#123; Derived derived&#123; 5 &#125;; // 基类指针和引用都可以指向派生类 Base&amp; rBase = derived ; Base* pBase = &amp;derived; // 基类指针只能调用基类的方法（基类引用同理） pBase-&gt;getName(); // base，调用的是基类方法 pBase-&gt;getValue(); // 5 //pBase-&gt;getValueDoubled(); // error，不能调用派生类的方法 return 0;&#125; 另一方面，你可能会说这个例子很傻：“当我能使用派生对象时，为什么要使用指向派生对象基类的指针或引用？” 这涉及到多态的“接口重用原则”：不论传递过来的究竟是类的哪个对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。 我们举例说明。 为什么需要基类指针和引用？ 假设有多个派生类：Derived、Derived1、Derived2…等都派生于Base。现在外部有一个函数printName要求打印它们的名字： 1234void printName(Derived* pd)&#123; std::cout&lt;&lt;pd-&gt;getName()&lt;&lt;std::endl;&#125; 但是这个函数只能打印Derived的名字，Derived1等不能打印，因为Derived和Derived1等是不同类型： 12345Derived d;printName(d); // okDerived1 d1;printName(d1); // error，Derived类型不匹配Derived1 所以，为了Derived1、Derived2…DerivedN，都能被打印，我们不得不再定义N个基本一样的printName函数： 123456789void printName(Derived1* pd)&#123; std::cout&lt;&lt;pd-&gt;getName()&lt;&lt;std::endl;&#125;void printName(Derived2* pd)&#123; std::cout&lt;&lt;pd-&gt;getName()&lt;&lt;std::endl;&#125;... 这肯定会让你有点无奈，幸运的是，我们知道基类指针（或引用）可以接受派生类对象。于是一切便不用这么麻烦： 123456789101112void printName(Base* pBase)&#123; std::cout&lt;&lt;pBase-&gt;getName()&lt;&lt;std::endl;&#125;Derived d;Derived1 d1;Derived2 d2;printName(d); // ok, 打印：BaseprintName(d1); // ok, 打印：BaseprintName(d2); // ok, 打印：Base 但细心的你也注意到，打印全都是基类的名：即调用的是基类的getName函数，而不是派生类的getName 函数。显然，此时并没有体现类的动态多态性，因为getName函数的链接地址在编译时便确定了，链接的是基类的getName函数地址。 这也就是早绑定，如下图。 ↑可以看到，编译之后，getName 在汇编代码中已被替换为符号： _ZNK4Base7getNameB5cxx11Ev ，对应调用地址为400c02。 但如果getName是虚函数一切开始变得不一样。 如果基类的getName函数被声明为虚函数，其地址便会在运行时绑定为调用的派生类对象的getName函数地址。进而实现下面效果： 123printName(d); // ok, 打印：DerivedprintName(d1); // ok, 打印：Derived1printName(d2); // ok, 打印：Derived2 我们将从类实例化内存布局变化角度进行剖析。 7.2.2 虚函数和多态 虚函数实现多态 继续前面的例子，我们看看虚函数如何实现多态吧。 为了方便描述，这里只展示了派生类Derived、Derived1，注意派生类的签名、返回类型要和基类完全一致！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;string&gt;class Base&#123;protected: int m_value &#123;&#125;;public: Base(int value): m_value&#123; value &#125; &#123; &#125; // 基类getName函数被声明为虚函数 virtual std::string getName() const &#123; return &quot;Base&quot;; &#125; int getValue() const &#123; return m_value; &#125;&#125;;class Derived: public Base&#123;public: Derived(int value): Base&#123; value &#125; &#123; &#125; // 派生类getName函数的virtual可省略 virtual std::string getName() const &#123; return &quot;Derived&quot;; &#125; int getValueDoubled() const &#123; return m_value * 2; &#125;&#125;;class Derived1: public Base&#123;public: Derived1(int value): Base&#123; value &#125; &#123; &#125; // 派生类getName函数的virtual可省略 virtual std::string getName() const &#123; return &quot;Derived1&quot;; &#125; int getValueDoubled() const &#123; return m_value * 2; &#125;&#125;;void printName(Base* pBase)&#123; std::cout&lt;&lt;pBase-&gt;getName()&lt;&lt;std::endl;&#125;int main()&#123; Derived derived&#123;0&#125;; Derived1 derived1&#123;1&#125;; printName(&amp;derived); // Derived，调用的是派生类方法Derived::getName printName(&amp;derived1); // Derived1，调用的是派生类方法Derived1::getName return 0;&#125; 类似的： 1234Base* pBase = &amp;derived;pBase-&gt;getName(); // Derived，同上pBase = &amp;derived1;pBase-&gt;getName(); // Derived1 和前面非虚函数getName编译器早在编译期绑定了基类函数地址不同，虚函数采用晚绑定（动态绑定）：编译器检查到基类的getName函数是虚函数，不会早早绑定函数getName到特定入口地址。 下图说明了这个不同。 ↑此时getName 函数的地址是通过寄存器rax的值确定的，rax 存放的便是派生类的虚表中getName 函数地址，也就是所谓的晚绑定。 早绑定和晚绑定 本节对早绑定和晚绑定进行更全面的总结。 编译程序时，编译器会将 C++ 程序中的每条语句转换为一行或多行机器语言，遇到函数则是转换为一个可用地址。 123# 对应代码：add(1,2) # 转换为地址0x400937call 400937 &lt;_Z3addii&gt; 但在编译期间，我们不一定能确定要调用哪个函数，必须要在运行时才能确定。由此区分出了早绑定和晚绑定： 早绑定：在编译器期间就可以直接确定的调用函数，会将其转换为一个调用地址，这就是早绑定； 晚绑定：在编译期间不可以直接确定的调用函数，运行期间才转换为具体调用的地址，便是晚绑定。 下面这个例子：我们通过函数指针根据操作符指向相应运算函数，但操作符是在运行期间由用户确定的。 晚绑定一般通过函数指针实现。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;int add(int x, int y)&#123; return x + y;&#125;int subtract(int x, int y)&#123; return x - y;&#125;int multiply(int x, int y)&#123; return x * y;&#125;int main()&#123; int op; // 操作符由用户确定 std::cout &lt;&lt; &quot;Enter an operation (0=add, 1=subtract, 2=multiply): &quot;; std::cin &gt;&gt; op; // （1）晚绑定 int (*pFcn1)(int, int) = add; // （2）晚绑定 int (*pFcn2)(int, int) = nullptr; switch (op) &#123; case 0: pFcn2 = add; break; case 1: pFcn2 = subtract; break; case 2: pFcn2 = multiply; break; &#125; // （3）早绑定调用 add(1, 2); // （4）晚绑定调用 pFcn1(1, 2); // （5）晚绑定调用 pFcn2(1, 2); return 0;&#125; 注意到，（1）、（2）都是晚绑定。 对于（1），编译器同样无法在编译期间确定，函数指针pFcn1指向的是哪个函数。因为函数指针： 需要先读取pFcn1 保存的函数地址 才能再跳转到相应函数 显然，“读”这个操作在编译期间是无法完成的，所以pFcn1 无法确定指向哪个函数。 最后，我们再来直观对比下早绑定和晚绑定调用（3）、（4）、（5）时的不同。 早绑定（①处）：因为add(1,2)函数可直接被调用，所以在编译期间就被替换为函数入口地址_Z3addii（0x400877）； 晚绑定（②处）：PFcn1无法被直接调用，先将指针PFcn1 保存的函数地址（地址-16(%rbp)中的值，这个值是运行时计算的）存入寄存器rax 中，最后才根据寄存器保存的函数地址进行调用。 晚绑定（③处）：同②。 有了这些概念，我们可以开始探讨虚函数动态绑定实现的过程和原理，这不可避免涉及到虚表。 虚表 为了实现虚函数，C++ 使用了一种特殊形式的后期绑定，称为虚表（vtable）。 每个使用虚函数的类（或派生自使用虚函数的类）都有自己的虚表： 虚表是编译器期间设置的静态一维数组，数组每一个条目都是一个函数指针，它指向该类的虚函数； 每个类还有个隐藏指针*__vptr ，它可以被继承： 在创建类实例时，对象的虚表会被创建，*__vptr 会被类构造函数初始化指向该类的虚表（准确来说是在构造函数体进入前初始化的，也就是成员列表中）； 相比*this 指针，*__vptr是一个真正的指针，它使得每个类的对象都增加了一个指针的大小（4字节或8字节）。 虚表和虚表指针是在构造函数中进行创建和初始化的。 看一个简单的例子。 1234567891011121314151617181920class Base&#123;public: virtual void function1() &#123;&#125;; virtual void function2() &#123;&#125;;&#125;;class D1: public Base&#123;public: virtual void function1() &#123;&#125;; virtual void function3() &#123;&#125;; void function4() &#123;&#125;;&#125;;int main()&#123; D1 d1; Base* dPtr = &amp;d1; dPtr-&gt;function1(); return 0;&#125; 根据7.2.1 节我们知道，理论上基类指针dPtr只能“看到”派生类对象d1的基类部分。但这里却成功调用了d1 的成员虚函数function1 。 下图类实例布局形象地说明了原因： 创建派生类D1的实例d1 时，先构造了基类Base对象部分，然后用基类构造函数进行初始化，这个过程设置了基类对象的虚指针和虚表； 然后构造派生类扩展部分，派生类构造函数进行初始化： 原来继承的基类虚表，修改base::function1 → 为 Derived::function1 ； 增加派生类自己的虚函数Derived::function3 ； 完成其它初始化工作。 实例d1 构建完成（内存布局如上图）。 现在我们再来解释下面这行代码发生了什么： 1dPtr-&gt;function1(); 编译器识别出function1 是虚函数，开始分析此时调用对象，来确定使用哪个类对象的虚指针，进而确定虚表来找到相应虚函数指针地址； 指针dPtr比较特殊，它是基类的指针（引用同理），但指向的是派生类对象d1——这种情况，是根据指向派生类对象确定； 所以，最终根据dPtr-&gt;d1.*__vptr 来查找对象d1的虚表（上图的D1对象虚表），从而调用了D1::function1 。 调用function2类似： 1dPtr-&gt;function2(); 编译器识别出function2 是虚函数 ，同时确定了当前调用对象是d1 ; 根据d1虚指针查找d1 的虚表，进而找到function2函数指针，不过这个指针保存的是Base 虚表的function2函数地址； 最终调用了Base::function2 。 从汇编角度来验证上述过程（精简了些代码，不影响阅读）： 注意右侧红框处的汇编代码：1.确定对象类型→2.根据虚指针找到虚表→3.根据虚表和偏移计算虚函数指针地址→4.根据虚函数指针获取虚函数调用地址→5.调用函数。 123456789101112# 1.-8(%rbp)是堆上d1内存首地址，存入寄存器rax中movq -8(%rbp), %rax # 2.获取d1首地址保存的值，存在寄存器rax中。因为d1内存首地址，即是虚指针地址，所以获取了虚指针保存的内容，即虚表首地址放入寄存区rax中movq (%rax), %rax # 3.虚表首地址+偏移8个字节表示function2函数指针，然后存入寄存器rax中addq $8, %rax # 4.获取函数指针保存的值，即function2的函数地址，最终保存在rax中movq (%rax), %rax movq -8(%rbp), %rdxmovq %rdx, %rdi# 5.调用function2call *%rax 虚函数性能问题 迄今为止，我们介绍了三种函数调用方式： 早绑定方式：直接调用； 晚绑定方式：函数指针与虚函数。 其中，直接调用方式只需1次就可以找到调用的函数；函数指针需要两次：读取函数指针保存的函数地址→调用函数；而虚函数需要三次：读取虚指针*__vptr 找到虚表→读取虚表中要调用的虚函数指针保存的函数地址→调用函数。 显然这带来了额外的时间开销。 另外，任何使用虚函数的类对象都有一个 虚指针*__vptr ，所以创建对象也需要多余内存存储该指针，这还带来额外空间开销。 所以，虚函数虽好但不要过度哦。 7.2.3 虚函数二三事 override、final及协变类型 本节我们将主要介绍override、final及协变返回类型： override：在派生类函数标记该函数重写了基类的虚函数，以避免重写时派生类函数的返回类型、函数签名和基类虚函数不一致的书写错误； final：显式标记某个函数不希望不重写，如果被重写编译器会报错； 协变返回类型：基类函数返回类型是基类的指针（或引用），派生类返回重写函数的返回类型可以是派生类的指针（或引用），此时依旧视为重写。 先从override说起。 我们知道，派生类虚函数只有在其签名和返回类型完全匹配时才被视为重写。 一不留神可能就会出错： 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;class A&#123;public: virtual std::string getName(int x) &#123; return &quot;A&quot;; &#125; // 非常函数&#125;;class B : public A&#123;public: virtual std::string getName(int x) const &#123; return &quot;B&quot;; &#125; // 常函数&#125;; 所以，为了能让编译器帮我们自动检查，我们可以考虑在派生类B中，使用override关键字。 12345class B : public A&#123;public: virtual std::string getName(int x) const override &#123; return &quot;B&quot;; &#125; // error，编译器报错&#125;; 此时程序产生了编译错误。 使用override说明符没有产生性能损失，所以在派生类中的重写函数请尽量使用override说明符。 final说明符比较简单仅仅希望某个函数不会被重写。 和override说明符在同一位置使用（函数体前），二者也可以同时存在。 12345678910111213141516171819202122#include &lt;string&gt;class A&#123;public: virtual std::string getName() &#123; return &quot;A&quot;; &#125;&#125;;class B : public A&#123;public: // okay, 此时getName函数被final修饰 std::string getName() override final &#123; return &quot;B&quot;; &#125; &#125;class C : public B &#123;public: // error，无法重写B中的getName函数 std::string_view getName() override &#123; return &quot;C&quot;; &#125;&#125;; final也可以修饰类表示无法继承。 123class test final // 其它类无法继承test&#123;&#125; 最后是协变返回类型。 如果基类返回类型是基类的指针或引用，那么派生类重写函数的返回类型可以是派生类的引用或指针。此时依旧视为重写。 不过，下面这个例子藏了点玄机。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string_view&gt;class Base&#123;public: // 返回类型是：base* virtual Base* getThis() &#123; std::cout &lt;&lt; &quot;调用 Base::getThis()\\n&quot;; return this; &#125; void printType() &#123; std::cout &lt;&lt; &quot;Base\\n&quot;; &#125;&#125;;class Derived : public Base&#123;public: // 返回类型是Derived*，依旧视为是基类getThis的重写 Derived* getThis() override &#123; std::cout &lt;&lt; &quot;调用 Derived::getThis()\\n&quot;; return this; &#125; void printType() &#123; std::cout &lt;&lt; &quot;Derived\\n&quot;; &#125;&#125;;int main()&#123; Derived d&#123;&#125;; Base* b&#123; &amp;d &#125;; // 输出会是什么呢？ b-&gt;getThis()-&gt;printType(); return 0;&#125; 输出： 12调用 Derived::getThis()Base 结果分析： b-&gt;getThis()，因为getThis 是虚函数，所以getThis 在运行时才会被确定，b是d的指针，查找对象d虚表最终调用输出： 1调用 Derived::getThis() b-&gt;getThis() 虽然返回了Derived* ，但因为C++是静态语言，而printType 又未声明为虚函数，所以printType调用对象类型其实在编译时就已经确定为Base 。 所以最终Derived*只能向上转型为Base* ，调用Base::printType输出： 1Base 析构、构造函数与虚函数 析构、构造函数与虚函数之间需记住以下两点： 不要在构造函数或析构函数中调用虚函数； 析构函数可声明为虚函数，构造函数不能声明为虚函数。 我们先来讨论第一点：不要从构造函数或析构函数调用虚函数。 要解释这一点，我们需要回忆两个知识点： 每个类对象虚指针指向当前类虚表，虚指针根据当前调用的对象确定； 创建派生类对象时，先调用基类部分构造函数，再调用派生类构造函数；销毁派生类对象时，析构函数执行顺序和构造函数恰相反。 设想下，我们从基类的构造函数调用虚函数会发生什么？ 创建派生类对象，开始调用基类构造函数； 进入基类构造函数调用虚函数，即：this-&gt;虚函数()，当前this对象是基类对象而不是派生类对象 ，所以最终使用的是基类对象虚指针，在基类的虚表中调用了基类的虚函数版本而不是派生类中的； 最后再调用派生类构造函数。 类似的错误存在析构函数中： 销毁对象，开始调用派生类析构函数； 派生类部分被销毁，接着调用基类析构函数； 进入基类析构函数调用虚函数，同样的，此时对象是基类对象而不是派生类对象，所以虚函数始终解析为该函数的基类版本。 我们再来讨论第二点：析构函数可声明为虚函数，构造函数不能声明为虚函数。 析构函数声明为虚函数，特别是明确要作为基类中的析构函数，可以避免派生类内存没有被释放产生内存泄漏。这样释放基类内存时，会执行派生类析构函数，而派生类析构函数执行后还会调用基类析构函数，确保了内存被析构完全。 下面这个例子帮助理解： 注意，基类指针base 指向了new动态分配在堆上的派生类对象内存，所以只能我们显式delete管理堆内存释放。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;class Base&#123;public: ~Base() // 非虚函数 &#123; std::cout &lt;&lt; &quot;调用 ~Base()\\n&quot;; &#125;&#125;;class Derived: public Base&#123;private: int* m_array;public: Derived(int length): m_array&#123; new int[length] &#125; &#123; &#125; ~Derived() &#123; std::cout &lt;&lt; &quot;调用 ~Derived()\\n&quot;; delete[] m_array; &#125;&#125;;int main()&#123; Base *base = new Derived&#123;5&#125;; // 释放base指向的内存 delete base; return 0;&#125; 最终输出： 1调用 ~Base() 因为base指向的是堆上的派生类对象，所以这个对象离开作用域也不会自动释放，只能我们使用delete显式删除。 但此时只有基类部分执行了析构函数，派生类析构函数没有执行，导致m_array 持有的内存发生泄漏。 为了解决这个问题，需要将基类的析构函数声明为虚函数。修改如下： 1234virtual ~Base() // 虚函数&#123; std::cout &lt;&lt; &quot;调用 ~Base()\\n&quot;;&#125; 再次执行输出： 12调用 ~Derived()调用 ~Base() 这样，派生类的析构函数执行完还会执行基类的析构函数（反之不行）。 不过，构造函数不能声明为虚函数。 很好理解，因为这破坏了构造函数执行顺序：先基类构造函数→再派生类构造函数。 当基类构造被声明为虚函数时：先派生类构造函数ok，但基类构造函数永远等不到执行，派生类构造函数并没有义务调用基类构造函数。 综上所述： 永远不要从构造函数或析构函数调用虚函数； 当前类如果打算作为基类，请将析构函数声明为virtual（如果不打算作为基类，析构函数不用声明为virtual，但类最好标记为final）； 永远不要把构造函数声明为virtual。 纯虚函数、抽象基类与接口类 迄今为止，我们编写的虚函数都有函数体。C++允许我们创建一种特殊的函数，纯虚函数，它没有实体由派生类实现具体定义。 由此还引申出其它几个概念： 抽象基类：具有纯虚函数的类便是抽象基类； 接口类：没有成员变量，只有纯虚函数的类。 要创建一个纯虚函数，只需为函数赋值0即可。 12345678910111213141516#include &lt;string&gt;#include &lt;utility&gt;class Animal&#123;protected: // 保护成员 Animal() &#123; &#125;public: // 纯虚函数，=0 virtual const char* speak() const = 0; // 默认构造函数 virtual ~Animal() = default;&#125;; 这里我们声明了一个Animal 只作为基类，因此： Animal 构造函数被声明为protected ，避免其被外部被实例化；但是不要声明为private ，否则派生类无法实例化。 内部我们声明了纯虚函数speak() ，因为我们只希望它在派生类中被实现，基类实现没有意义。 此时Animal 因为包含纯虚函数，所以也被称为抽象基类。抽象基类不能被实例化，所以这里的Animal 构造函数，直接声明public也可以： 123456789101112131415#include &lt;string&gt;#include &lt;utility&gt;class Animal&#123;protected: // 保护成员public: Animal() &#123; &#125; // 纯虚函数，=0 virtual const char* speak() const = 0; // 默认构造函数 virtual ~Animal() = default;&#125;; 纯虚函数还有几个特质： 纯虚函数必须被派生类实现（重写）； 123456789101112131415class Cow: public Animal&#123;public: Cow() &#123; &#125; // const char* speak() const override &#123; return &quot;咪&quot;; &#125;&#125;;int main()&#123; Cow cow&#123;&#125;; std::cout &lt;&lt; cow.speak() &lt;&lt; &#x27;\\n&#x27;; // error，派生类Cow没有实现纯虚函数speak() return 0;&#125; 纯虚函数可以有函数体，不过只能在类外实现（不常用）。 123456789101112131415161718192021#include &lt;string&gt;#include &lt;utility&gt;class Animal&#123;protected: // 保护成员 Animal() &#123; &#125;public: // 纯虚函数，=0 virtual const char* speak() const = 0; // 默认构造函数 virtual ~Animal() = default;&#125;;const char* Animal::speak() const // 只能类外实现&#123; return &quot;？？？&quot;; // &quot;？？？&quot;是字符串常量，在常量区&#125; 最后值得一提的是，抽象类仍然具有虚表。 虚基类 7.1.4节中多重继承导致的“菱形问题”，我们最终解决方案是通过虚继承解决： 此时A被称为虚基类。 虚基类对象，在继承树中被所有对象共享，也就是只会构造一次； 派生虚基类最多的类，负责创建虚基类； 在上图中，B、C都只派生了一次虚基类A，而D派生了两次，所以由D负责构建虚基类A（调用虚基类的构造函数一次）。 7.2.4 动态转换与对象切片 上行转换和下行转换 基本概念： 上行转换：派生类指针或引用转换为→基类指针或引用，C++可以隐式地进行，这种转换是安全的； 下行转换：基类指针或引用转换为→派生类指针或引用 ，这种转换是不安全的，最好通过dynamic_cast 或 static_cast 显式完成。 下行转换既然是不安全的，为什么还要存在？ 我们经常会有这种需求：虽然只有基类指针，但还是想根据基类指针访问派生类相关的信息。 在这之前，我们已经有了解决方案：在基类声明和派生类函数一致的虚函数。但虚函数并非万灵药，因为: 这给基类带来了额外的负担，不得不在基类重复声明了一个虚函数。 考虑下面这个例子，说明了上述问题。 使用基类指针访问派生类getName方法。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;string&gt;#include &lt;iostream&gt;class Base&#123;public: Base() &#123; &#125; virtual ~Base() = default; // 不得不额外在基类声明一个虚函数，以便可解析到派生类中 // 实际上它什么也没做 virtual const std::string getName() const &#123; &#125;;&#125;;class Derived : public Base&#123;protected: std::string m_name&#123;&#125;;public: Derived(const std::string&amp; name): m_name&#123;name&#125; &#123; &#125; const std::string getName() const &#123; return m_name; &#125;&#125;;Base* getObject(bool returnDerived)&#123; if (returnDerived) return new Derived&#123; &quot;Derived&quot;&#125;; else return new Base&#123;&#125;;&#125;int main()&#123; Base* b&#123; getObject(true) &#125;; std::cout &lt;&lt; b-&gt;getName()&lt;&lt;std::endl; // Derived delete b; return 0;&#125; 虽然最终成功访问到派生类的getName方法，但是不得不在基类额外定义一个虚函数：即使它对基类是毫无作用的。 另一方面，考察这行代码： 1Base* b&#123; getObject(true) &#125;; getObject(true) 返回的是Derived类型指针； 然后上行转换为Base指针，。 也就是说Base指针b 保存了Derived对象的内存地址，只不过只能访问基类部分。但也天生具备了访问Derived对象的“潜质”，Derived对象的其它部分依旧存在。 我们可以利用dynamic_cast强制转换发掘这种潜力： 1234567891011// 此时基类的虚函数getName已被删除int main()&#123; Base* b&#123; getObject(true) &#125;; Derived* d&#123; dynamic_cast&lt;Derived*&gt;(b) &#125;; if (d) // 确保转换成功 std::cout &lt;&lt; d-&gt;getName() &lt;&lt; &#x27;\\n&#x27;; delete b; return 0;&#125; 输出： 1Derived 最后强调一下dynamic_cast 失败时的处理： dynamic_cast失败返回NULL（如果是引用，返回 std::bad_cast 异常），（最佳实践）请编码时务必进行判断，确保你的下行转换成功； static_cast 失败也不返回NULL，因此不建议使用static_cast，它过于粗暴不够安全。 下行转换还是虚函数？ 一般来说，使用虚函数应该优于向下转换。但是，有时向下转换是更好的选择： 当不能修改基类添加虚函数时（例如，基类是标准库的一部分）； 当需要访问特定于派生类的东西时（例如，仅存在于派生类中的函数）； 向基类添加虚函数没有意义时（例如，基类函数体没有实现的必要）。 不过能使用下行转换是建立在：你使用的基类指针或引用是否具有转换下行转换的潜质——指向的是派生类对象？ 如果不具有的话，比如指向的是一个基类对象，强行转换会出错。 1234567int main()&#123; Base* b&#123; getObject(false) &#125;; std::cout &lt;&lt;dynamic_cast&lt;Derived*&gt;(b)-&gt;getName()&lt;&lt;std::endl; delete b; return 0;&#125; 输出： 12[root@roy-cpp test]# ./test.out Segmentation fault 对象切片 在此之前，我们都是利用基类的指针或引用 指向了一个派生类对象，大概类似下面这样： 1234567int main()&#123; Derived derived&#123; 5 &#125;; Base&amp; ref&#123; derived &#125;; // 引用 Base* ptr&#123; &amp;derived &#125;; // 指针 return 0;&#125; 上面的ref、ptr 虽然只能“看到”derived的Base部分，但derived其它部分依旧是存在的。 如果不用指针或引用指向呢？就像这样： 123456int main()&#123; Derived derived&#123; 5 &#125;; Base base &#123; derived &#125;; // 非指针或引用 return 0;&#125; 上面base 复制了Derived 对象的 Base 部分，而 Derived 对象其它部分已被丢弃，不再存在 ，这就是对象切片。 对象切片很容易导致一些意料之外的问题，比如函数参数值传递时。 假设此时Base有一个虚函数getName，它的作用是打印出“Base”；派生类getName进行了重写，不过它打印的是“Derived”。 函数printName接受一个Base类型参数，是值传递方式，它主要任务是调用getName函数。 1234567891011void printName(const Base base) // 不是引用或指针传递&#123; base.getName();&#125;int main()&#123; Derived d&#123; 5 &#125;; printName(d); return 0;&#125; 输出： 1Base 因为发生了对象切片，即使getName是虚函数也不会调用Derived::getName，而是调用基类版本Base::getName（这也是为什么我们建议函数的类类型参数尽量声明为引用或指针）。 最后，我们再举一个例子来说明对象切片带来编码问题：使用vector实现多态时，发生了对象切片。 1234567891011121314151617#include &lt;iostream&gt;#include &lt;vector&gt;int main()&#123; std::vector&lt;Base&gt; v&#123;&#125;; Base b&#123;&#125;; Derived d&#123;&#125;; v.push_back(b); v.push_back(d); for (const auto* element : v) std::cout &lt;&lt; element-&gt;getName() &lt;&lt; &#x27;\\n&#x27;; return 0;&#125; 输出： 12BaseBase 与前面的示例类似，因为 std::vector 被声明为 Base 类型的向量，所以当将 d添加到向量时，d被切片了。 而且，尝试使用引用传参也不起作用： 1std::vector&lt;Base&amp;&gt; v&#123;&#125;; 会发生编译错误，因为std::vector的元素必须是可分配的，而引用不能重新分配（仅能初始化）。 最终解决方案是声明为指针传参： 1234std::vector&lt;Base*&gt; v&#123;&#125;;v.push_back(&amp;b); v.push_back(&amp;d); 重新编译，输出正常： 12BaseDerived 综上所述：尽管 C++ 支持通过对象切片将派生对象分配给基类对象，但这是个让人感到头疼的行为。 所以，请尽量避免使用切片； 确保函数参数是引用（或指针）。 下章我们开始介绍模板相关知识。 更新记录 2022-02-09 ：更新笔记 第一次更新 参考资料 1.What is the difference between &quot;IS -A&quot; relationship and &quot;HAS-A&quot; relationship in Java? ↩2.【C++基础之二十一】菱形继承和虚继承：https://blog.csdn.net/jackystudio/article/details/17877219 ↩3.多重继承的优缺点：https://blog.csdn.net/woodforestbao/article/details/4500406 ↩4.C++ 多态 ：https://zhuanlan.zhihu.com/p/37340242 ↩5.C++基类的析构函数为何要声明为虚函数 ：https://zhuanlan.zhihu.com/p/148290103 ↩6.C++类对象的内存结构 ：https://blog.csdn.net/MOU_IT/article/details/89045103 ↩","categories":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/categories/C/"},{"name":"从零开始","slug":"C/从零开始","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"},{"name":"C++面对对象","slug":"C/从零开始/C-面对对象","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/tags/C/"},{"name":"教程","slug":"教程","permalink":"https://hwh.zone/tags/%E6%95%99%E7%A8%8B/"},{"name":"继承","slug":"继承","permalink":"https://hwh.zone/tags/%E7%BB%A7%E6%89%BF/"},{"name":"虚函数","slug":"虚函数","permalink":"https://hwh.zone/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"}]},{"title":"C++从零开始（八）：面对对象（中）运算符重载","slug":"C++从零开始（三）：面对对象（中）运算符重载","date":"2022-01-27T06:47:34.826Z","updated":"2022-02-19T10:01:15.117Z","comments":true,"path":"p/43924/","link":"","permalink":"https://hwh.zone/p/43924/","excerpt":"","text":"🌟《C++从零开始》 系列，开始更新中… C++从零开始https://hwh.zone/p/62712 六、运算符重载 在前面我们接触过函数重载，让我们可以使用多个同名函数，只要它们有唯一的函数签名（由函数参数类型、个数、函数名组成）可以让编译器区分即可。 在C++中，运算符被视为函数，自然也可以进行重载。 认识下运算符这个特殊的函数。 运算符operator+ 作为函数，接收了两个int类型参数： 123int x &#123; 2 &#125;;int y &#123; 3 &#125;;x+y; 重载函数operator+ ，又接收了两个double 类型参数： 123double x &#123; 2 &#125;;double y &#123; 3 &#125;;x+y; 这都是C++为我们内置实现了operator+ 重载，用于C++基本类型之间运算。 我们也可以自定义重载自己的运算符函数。 虽然C++ 中几乎所有的运算符我们都可以进行重载，但要注意以下规则： 重载运算符中的至少一个操作数必须是用户定义的类型，比如重载operator+ 函数，一个参数是int，一个是double 是不行的； 无法更改运算符支持的操作数数量，优先级也被保留。 12345678910111213141516171819#include&lt;iostream&gt;class myInt&#123; private: int i; public: myInt(int a):i(a)&#123; &#125; int getValue()&#123;return i;&#125; &#125;;// 重载操作符形式myInt operator+(myInt&amp; i1,myInt&amp; i2)&#123; return myInt(i1.getValue()+i2.getValue());&#125;// 普通函数myInt add(myInt&amp; i1,myInt&amp; i2)&#123; return myInt(i1.getValue()+i2.getValue());&#125; 普通函数也可以实现重载运算符所需的功能，重载运算符有什么好处？ 重载运算符可以让程序表达更直观： 123456789int main()&#123; myInt i1&#123;1&#125;; myInt i2&#123;2&#125;; myInt i3 = i1+i2; // i3.getValue()=3，更直观 myInt i4 = add(i1,i2); // i3.getValue()=3 return 0;&#125; 如果重载运算符并不能让你的程序更清晰，请谨慎使用。 本章主要介绍： 重载运算符的友元/普通/成员三种方式。 特殊重载，如重载()、=介绍。 6.1 重载运算符的三种方式 重载运算符有三种不同的方式： 友元函数方式 普通函数方式 成员函数方式 按照顺序我们依次来看下。 6.1.1 友元函数 重载友元初识 下面展示了重载operator+ ，其余操作符- 、/ 、* 等类似。 注意到函数operator+ 是类MinMax 的友元函数，这样就可以使用MinMax的私有成员。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;class Cents&#123;private: int m_cents&#123;&#125;;public: Cents(int cents): m_cents&#123; cents &#125;&#123;&#125; // 类中声明友元函数原型 friend Cents operator+(const Cents&amp; c1, const Cents&amp; c2)&#125;;// 友元函数定义Cents operator+(const Cents&amp; c1, const Cents&amp; c2)&#123; return &#123; c1.m_cents + c2.m_cents &#125;;&#125;int main()&#123; Cents cents1&#123; 6 &#125;; Cents cents2&#123; 8 &#125;; Cents centsSum = cents1 + cents2 ; std::cout &lt;&lt; &quot;I have &quot; &lt;&lt; centsSum.getCents() &lt;&lt; &quot; cents.\\n&quot;; return 0;&#125; 输出： 1I have 14 cents. 更多例子：重载I/O运算符 下面是一个同时使用重载的 operator&lt;&lt; 和 operator&gt;&gt; 的示例 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344include &lt;iostream&gt;class Point&#123;private: double m_x&#123;&#125;; double m_y&#123;&#125;; double m_z&#123;&#125;;public: Point(double x=0.0, double y=0.0, double z=0.0): m_x&#123;x&#125;, m_y&#123;y&#125;, m_z&#123;z&#125;&#123;&#125; // 类型友元函数声明 friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point); friend std::istream&amp; operator&gt;&gt; (std::istream&amp; in, Point&amp; point);&#125;;std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point)&#123; out &lt;&lt; &quot;Point(&quot; &lt;&lt; point.m_x &lt;&lt; &quot;, &quot; &lt;&lt; point.m_y &lt;&lt; &quot;, &quot; &lt;&lt; point.m_z &lt;&lt; &#x27;)&#x27;; // 返回std::ostream对象out，这样就可以形成链式使用 // 像这样：out&lt;&lt;point1&lt;&lt;&quot; &quot; &lt;&lt; point2 return out;&#125;// 和前有点不一样，重载的参数类型不同std::istream&amp; operator&gt;&gt; (std::istream&amp; in, Point&amp; point)&#123; in &gt;&gt; point.m_x; in &gt;&gt; point.m_y; in &gt;&gt; point.m_z; // 同前返回std::istream对象in，形成链式 return in;&#125;int main()&#123; std::cout &lt;&lt; &quot;Enter a point: &quot;; Point point1; Point point2; // 链式输入 std::cin &gt;&gt; point1 &gt;&gt; point2; // 链式输出 std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; point1 &lt;&lt; &quot; &quot; &lt;&lt; point2&lt;&lt;&#x27;\\n&#x27;; return 0;&#125; 输出： 1234[root@roy-cpp test]# ./test.out Enter a point: 1 2 34 5 6You entered: Point(1, 2, 3) Point(4, 5, 6) 6.1.2 普通函数 使用友元函数虽然很方便，但也一定程度的破坏了类的封装性。因此我们建议尽量将重载运算符实现为普通函数。 下面是一个小例子。 注意到普通函数和实现为友元函数极为类似，除了友元函数需要在类中先声明函数原型 friend Cents operator+(const Cents&amp;,const Cents&amp;) ，其余没有区别。 123456789101112131415161718192021222324#include &lt;iostream&gt;class Cents&#123;private: int m_cents&#123;&#125;;public: Cents(int cents): m_cents&#123; cents &#125;&#123;&#125; // 访问私有成员的接口函数 int getCents() const &#123; return m_cents; &#125;&#125;;// 普通函数，非友元Cents operator+(const Cents&amp; c1, const Cents&amp; c2)&#123; return Cents&#123; c1.getCents() + c2.getCents() &#125;;&#125;int main()&#123; Cents cents1&#123; 6 &#125;; Cents cents2&#123; 8 &#125;; Cents centsSum = cents1 + cents2 ; // ok return 0;&#125; 6.1.3 成员函数 重载成员初识 成员重载运算符和友元重载运算符很类似，但是也有些不同： 重载的运算符被定义为成员而不是友元（例如，是Cents::operator+ 而不是operator+ ）； 左边的类类型参数const Cents&amp;被移除了，变成了隐含的 *this 对象。 看代码说话。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;class Cents&#123;private: int m_cents &#123;&#125;;public: Cents(int cents): m_cents &#123; cents &#125; &#123; &#125; // friend Cents operator+(const Cents &amp;cents, int value); // 对比普通函数声明： // 1. 少了friend声明，本来就是成员函数可以访问私有成员没必要 // 2. 左参数被省略，隐含为*this对象 Cents operator+ (int value); int getCents() const &#123; return m_cents; &#125;&#125;;// 对比普通函数多了Cents::（成员函数），多了左参数Cents Cents::operator+ (int value)&#123; // m_cents被视为this-&gt;m_cents return Cents &#123; m_cents + value &#125;;&#125;int main()&#123; Cents cents1 &#123; 6 &#125;; Cents cents2 &#123; cents1 + 2 &#125;; std::cout &lt;&lt; &quot;I have &quot; &lt;&lt; cents2.getCents() &lt;&lt; &quot; cents.\\n&quot;; return 0;&#125; 输出： 1I have 8 cents. 重载一元函数 正 (+)、负 (-) 和逻辑非 (!) 运算符都是一元运算符，这意味着它们只对一个操作数进行操作，也就是只对应用它们的对象进行操作，所以通常一元运算符重载被实现为成员函数。 下面是个简单的例子，注意负运算符和减号运算符之间没有混淆，因为它们具有不同数量的参数。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;class Cents&#123;private: int m_cents &#123;&#125;;public: Cents(int cents): m_cents(cents) &#123;&#125; // 重载-负运算符，成员函数方式 Cents operator-() const; int getCents() const &#123; return m_cents; &#125;&#125;;// 定义处Cents Cents::operator-() const&#123; return -m_cents; &#125;int main()&#123; const Cents nickle&#123; 5 &#125;; std::cout &lt;&lt; &quot;A nickle of debt is worth &quot; &lt;&lt; (-nickle).getCents() &lt;&lt; &quot; cents\\n&quot;; return 0;&#125; 6.1.4 最佳实现：使用什么方式重载 下面是一些经验法则： 普通函数或友元函数优先考虑普通函数，可避免封装性被破坏。 使用成员函数： 在处理修改左操作数的二元运算符（例如 operator+=）时，通常首选成员函数版本，因为最右边的操作数成为一个显式参数，不会混淆谁（左参数）被修改； 但是左参数类型必须要是当前类类型，如operator&lt;&lt;，它具有 ostream 类型的左操作数，此时按普通函数方式重载最好。 一元运算符通常也作为成员函数重载，此时成员版本没有参数。 使用普通函数： 在处理不修改左操作数的二元运算符（例如 operator+）时，普通或友元函数版本具有“对称”的额外好处，因为所有操作数都成为显式参数。 6.2 重载()运算符 到目前为止我们接触的运算符，参数类型虽然可以设置，但参数类型是固定的。 而重载括号运算符 operator() ，允许我们改变它的参数类型和数量。 这有什么用？ operator() 一大用处是用来实现函子（函数对象）。相比普通函数， 函子可以将任意数量的数据存储在成员变量，而不用在形参中定义避免了可能的值传递开销； 函子可以保存结果和状态，提高代码灵活性； 函数指针不能内联，函子可以，效率更高（没验证过）。 6.2.1 实现函子 请看下例。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;class Accumulator&#123;private: int m_counter&#123; 0 &#125;;public: int operator() (int i); int getCounter() &#123; return m_counter;&#125;&#125;;// 1.函子数据成员m_counter保存在类中，而不是形参中定义int Accumulator::operator() (int i)&#123; return (m_counter += i); &#125;int main()&#123; Accumulator acc&#123;&#125;; // 函子就像函数一样使用 std::cout &lt;&lt; acc(10) &lt;&lt; &#x27;\\n&#x27;; // 10 std::cout &lt;&lt; acc(20) &lt;&lt; &#x27;\\n&#x27;; // 30 // 2.函子保存了结果状态 acc.getCounter(); // 30 return 0;&#125; 函子更多的是应用在关联容器和STL，其中许多算法都是可以用函数或函数对象自定义比较器的。 请看下例。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt;class MyGreater&#123; public: bool operator()(int a, int b) &#123; return (a &gt; b); &#125;&#125;;bool myLesser(int a, int b)&#123; return (a &lt; b);&#125;void print(const std::array&lt;int,6&gt;&amp; arr)&#123; for (int i : arr) &#123; std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; &#125; std::cout &lt;&lt; &#x27;\\n&#x27;;&#125;int main()&#123; std::array&lt;int,6&gt; arr = &#123; 13, 90, 99, 5, 40, 80 &#125;; // std::sort第三个指针接受一个函数指针 // 普通函数，此时myLesser是函数地址 std::sort(arr.begin(), arr.end(), myLesser); print(arr); // 函子，此时MyGreater()也是函数地址，不要()迷惑 std::sort(arr.begin(), arr.end(), MyGreater()); print(arr); return 0;&#125; 输出： 1234[root@roy-cpp test]# g++ -std=c++11 test.cpp -o test.out[root@roy-cpp test]# ./test.out 5 13 40 80 90 99 99 90 80 40 13 5 6.3 重载=运算符 6.3.1 区分复制构造函数 复制构造函数和赋值运算符的用途几乎相同——都是将一个对象复制到另一个对象。 但它们最核心的区别在于作用的时机不同： 复制构造函数：只要对象在声明时用了另一个对象（可能是编译器创建的匿名对象）进行初始化，就会触发复制构造函数，也就是进行复制初始化。 赋值运算符：不是在对象声明时，而是一个已存在的对象被另一个对象重新赋值时 ，就会触发赋值运算符函数。 我们通过例子来理解。 1234567891011121314151617181920212223class Date&#123;private: int m_year&#123;&#125;; int m_month&#123;&#125;; int m_day&#123;&#125;;public: Date() = default; Date(int day,int month=1,int year=2022) &#123; std::cout&lt;&lt; &quot;构造函数被调用&quot;&lt;&lt;std::endl; m_year=year;m_month=month;m_day=day; &#125;; Date(Date const&amp; tmp): m_year(tmp.m_year),m_month(tmp.m_month),m_day(tmp.m_day) &#123; std::cout&lt;&lt; &quot;复制构造函数被调用&quot;&lt;&lt;std::endl; &#125; Date&amp; operator=(const Date&amp; date) &#123; std::cout&lt;&lt; &quot;oprator=被调用&quot;&lt;&lt;std::endl; m_year=date.m_year; m_month=date.m_year; m_day=date.m_year; &#125;&#125;; 主函数中： 1234567int main()&#123; // 都是复制初始化 Date date1 = 25; // 1 Date date2 = Date&#123;25&#125;; // 2 Date date3 = date2; // 3&#125; 1、2在对象date1、date2声明时用匿名对象进行初始化（编译器要使得= 左右操作类型一致，分别在=右侧创建了Date匿名对象，然后调用复制构造函数来初始化date1、date2）。 3处date3也是声明时使用了其它对象（date2）进行初始化，所以也会调用复制构造函数。 但是1、2处会被编译器优化使用普通构造函数初始化，所以最后输出： 123构造函数被调用构造函数被调用复制构造函数被调用 我们再来看看调用赋值运算符= 的情况： 1234567int main()&#123; Date date1 = 25; // 1 Date date2 = Date&#123;25&#125;; // 2 date2 = 31; // 3 date2 = date1; // 4&#125; 输出： 1234构造函数被调用构造函数被调用oprator=被调用oprator=被调用 也就是3、4处都是调用了赋值运算符= 进行赋值（不是初始化）： 3处，date2不是声明时进行初始化，而是使用编译器生成的匿名对象进行重新赋值 ； 4处，同理，date2不是声明时进行初始化 ，使用date1进行重新赋值 。 它们都符合前文所述：“而是一个已存在的对象被另一个对象重新赋值时 ，就会触发赋值运算符函数” 。 更新记录 2022-01-29 ：更新笔记 第一次更新 参考资料 1.C++STL中的函数对象 ：https://blog.csdn.net/CV_Jason/article/details/83899253 ↩","categories":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/categories/C/"},{"name":"从零开始","slug":"C/从零开始","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"},{"name":"C++面对对象","slug":"C/从零开始/C-面对对象","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/tags/C/"},{"name":"教程","slug":"教程","permalink":"https://hwh.zone/tags/%E6%95%99%E7%A8%8B/"},{"name":"C++基础","slug":"C-基础","permalink":"https://hwh.zone/tags/C-%E5%9F%BA%E7%A1%80/"},{"name":"运算符重载","slug":"运算符重载","permalink":"https://hwh.zone/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"}]},{"title":"C++从零开始（七）：面对对象（上）快速入门","slug":"C++从零开始（三）：面对对象（上）快速入门","date":"2022-01-24T07:37:07.955Z","updated":"2022-03-01T11:48:26.198Z","comments":true,"path":"p/17506/","link":"","permalink":"https://hwh.zone/p/17506/","excerpt":"","text":"🌟《C++从零开始》 系列，开始更新中… C++从零开始https://hwh.zone/p/62712 五、面对对象入门 C++和C一大主要区别，便是引入了入面对对象。 为什么需要引入面对对象？它有什么好处？ 5.1 为什么需要面对对象？ 5.1.1 从面向过程说起 在传统编程中，数据和处理该数据的函数是单独的实体，它们组合在一起以产生所需的结果。 也就是面向过程通常做法。 但是由于面向过程的这种分离，传统编程通常不能提供非常直观的现实表示： 1goToHome(you); 在这个例子中，行为主体you 和行为goToHome 被分隔了：you 被当做单独的数据实体，行为goToHome 被当做单独的函数实体。 面对对象则提供了更直观的表示能力。 因为面对对象将对象（行为主体）、属性和行为封装到独立、可重置的类中。 而这些属性和行为往往也被认为是密不可分的。 1you.goToHome(); 显然，这让对象（you）是谁，以及正在调用什么行为（goToHome）更清楚了。我们不再专注于编写函数，而是专注于定义行为集的对象。 这，也就是面对对象。 得益于这种专注于对象的行为，面对对象带来以下几个好处： 代码模块化 更容易理解、直观 可重用性高 现在我们来举一个更具体的例子进行对比：分别使用面向过程和面向对象的方式，打印年/月/日到屏幕上。 面对过程 按照面对过程的思想，Date当做独立变量组织了“年/月/日”，“打印”则当做独立行为（函数）。 123456789101112131415161718192021#include &lt;iostream&gt;struct Date&#123; int year &#123;&#125;; int month &#123;&#125;; int day &#123;&#125;;&#125;;void print(const DateStruct&amp; date)&#123; std::cout &lt;&lt; date.year &lt;&lt; &#x27;/&#x27; &lt;&lt; date.month &lt;&lt; &#x27;/&#x27; &lt;&lt; date.day;&#125;int main()&#123; Date today &#123; 2022, 1, 24 &#125;; today.day = 25; print(today); // 2022/1/25 return 0;&#125; 面向对象 面向对象则将Date视作行为主体（对象），“年/月/日”被当做其成员变量，“打印”则是其成员函数。此时明确了行为主体对象Date，建立了“年/月/日”和行为“打印”的关联。 1234567891011121314151617181920212223#include &lt;iostream&gt;class Date // class关键字&#123;public: int _year &#123;&#125;; // 成员变量 int _month &#123;&#125;; int _day &#123;&#125;; void print() // 成员函数 &#123; std::cout &lt;&lt; m_year &lt;&lt; &#x27;/&#x27; &lt;&lt; m_month &lt;&lt; &#x27;/&#x27; &lt;&lt; m_day; &#125;&#125;;int main()&#123; Date today &#123; 2022, 1, 24 &#125;; today._day = 25; // 主体对象.行为() today.print(); // 2022/1/25 return 0;&#125; 相信你对面对对象有了更深刻的理解，现在来更系统地了解面对对象基本组成吧。 5.1.2 面对对象组成 成员组成 其实，前面我们已经展示了面对对象最基本的组成：成员变量和成员函数。 面对对象还可以有成员类型 、嵌套类型。 成员类型 成员类型规定这个类基本数据类型，这样我们只需更新类型别名，而不必替换基本类型。 这样说有点难以理解，举个例子：vector类规定的类型size_type 。 size_t 归根究底就是类型long unsigned int 别名 也就是说下面两种写法是等价的。 12std::vector&lt;int&gt;::size_type x; // 等价：unsigned long int x std::cout&lt;&lt;typeid(x).name()&lt;&lt; &quot; &quot;; // m，表示unsigned long (int) stl_vector.h 变量基本都是使用的这种类型别名声明，比如我们熟悉的size() 方法声明： 回到前面：这样做有什么好处？ 当我们想修改vector使用的基本类型，只需要将修改类型别名就行： 12// #define __SIZE_TYPE__ long unsigned int#define __SIZE_TYPE__ int // 现在vector基本类型被你声明为int 嵌套类型 这个很好理解，只要：类类型、结构体类型、枚举类型在类中声明，就可以称其为嵌套类型。 以枚举类型嵌套为例。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;class Fruit&#123;public: // 此时枚举类型声明在类Fruit中 // 所以枚举类型此时是个嵌套类型 enum FruitType &#123; apple, banana, cherry &#125;;private: FruitType m_type &#123;&#125;;public: Fruit(FruitType type) :m_type &#123; type &#125; &#123;&#125; FruitType getType() const &#123; return m_type; &#125;&#125;;int main()&#123; // 注意枚举类型不限制作用范围 Fruit apple &#123; Fruit::apple &#125;; // 调用构造函数Fruit(FruitType type) apple.getType() ; // FruitType::apple return 0;&#125; 访问控制符 类成员访问控制符实现了类的封装，C++访问符包括： pprivate：私有成员，该成员仅在类内可以被访问，在类体外（包括派生类）是隐藏状态； public：公有成员，该成员在类内、类外也都可以被访问，是类对外提供的可访问接口。 在继承中，我们引入了第三种修饰符： protected：保护成员，和私有成员类似，不过在派生类可以被访问。 最佳实践：从降低类的耦合性来说，优先考虑private而不是protect。 Base 类中三种成员访问权限也可以用下图形象表示： 具体实例： 12345678910111213141516171819202122232425262728class Base&#123;public: int m_public &#123;&#125;; protected: int m_protected &#123;&#125;; private: int m_private &#123;&#125;; &#125;;class Derived: public Base&#123;public: Derived() &#123; m_public = 1; // ok m_protected = 2; // ok m_private = 3; // error，派生类访问私有成员 &#125;&#125;;int main()&#123; Base base; base.m_public = 1; // ok base.m_protected = 2; // error，类外访问保护成员 base.m_private = 3; // error，类外访问私有成员&#125; 下面这个例子，进一步说明protected访问说明符作用。 涉及到7.1 继承一些知识： 派生类由两个部分组成：继承的基类副本部分，派生类自身扩展的部分。 派生类实例化时，必须先调用基类构造函数初始化基类副本部分，再调用派生类构造函数初始化派生类部分。 假设我们有一个基类A，我们希望它： A不能被实例化； 但能被继承，派生类类可以实例化。 为了满足第一点，我们想到可以将A的构造函数声明为private。 但这样就无法满足第二点：派生类无法实例化，因为派生类无法调用基类副本的私有构造函数。 1234567891011121314class A&#123; private: A()&#123;&#125;&#125;class B: public A&#123; public: B()&#123;&#125;&#125;int main()&#123; B b ; // error: ‘A::A()’ is private&#125; 这个时候需要将A的构造函数声明为protected： 12protected: A()&#123;&#125; 这样派生类就可以调用基类的构造函数进行初始化基类副本了。 最佳实践：类成员变量是私有的，类成员函数是公开的。 为什么这么建议？ 对于普通人而言，遥控器就是一个简单的包括若干的按钮界面，用户只关心按钮按下的效果，但不关心具体是如何和电视通信。类似的，踩下油门踏板也不需要关心内燃机如何使得车轮转动。 这其实就是接口分离的思想：降低对象复杂性，使得我们在不了解对象如何工作的前提下，可以去使用对象。 三大特性之封装 结构分离思想也就是面对对象三大特性：封装，的重要组成部分。 怎么实现封装？ 在 C++ 中，我们通过访问说明符实现封装。类的所有成员变量都是私有的（隐藏实现细节），大多数成员函数都是公开的（向用户公开接口）。 封装具体有什么好处？ 降低对象复杂性，同前； 保护数据，类中定义的成员变量都是全局变量，意味着它可以被类任何对象修改，这很危险。使用private修饰避免了这一点，访问数据只能公共接口函数； 更容易调试，因为每个人都只能通过同一个公共函数修改某个值，这样值不正确时很容易进行debug； 更容易修改，… 另外两大特性将会在后面章节介绍： 继承：让某种类型（派生类）对象获得另一个类型对象（基类）的属性和方法。 多态：C++ 多态指相同对象收到不同消息，或不同对象收到相同消息时，产生不同的实现动作。 类和结构体这么像？ 看到这你不禁想吐槽，你说类这些功能： 嵌套、变量、函数 结构体都支持啊？甚至你还知道更多： 结构体支持继承、多态… 是的，在C++中类和结构体除了默认访问符外太像了，以至于很多开发人员认为这是个错误的设计。 确实，这的确有点不合理。根据前人经验—— 最佳实践：将 struct 用于纯数据结构，对同时具有数据和函数的对象使用 class。 也就是说，建议struct声明为POD(Plain Old Data)类型进行使用。 什么是POD类型？ 如果struct/class/enum等，只定义了常规数据类型(不含有自定义数据类型)，不使用封包或者其它面对对象特征，那么就是POD类型。 123456struct myDate // POD类型&#123; int i; float f; char c;&#125;; 5.2 构造函数及初始化 当一个类/结构体的所有成员都是公共成员时，我们可以直接列表初始化类/结构体： 123456789101112class Foo&#123;public: int m_x ; int m_y ;&#125;;int main()&#123; Foo foo1 &#123; 1, 2 &#125;; return 0;&#125; 但是前面我们也强调过，成员变量一般声明为private。 此时如何初始化private修饰的成员变量？ 如果私有成员变量仅仅是需要零值初始化，在类成员变量使用列表初始化&#123;&#125;即可 123456class Foo&#123;public: int m_x&#123;&#125; ; // 声明时列表初始化 int m_y&#123;&#125; ; // 声明时列表初始化&#125;; 如果私有成员变量需要指定值，使用构造函数可以指定初始化类的成员变量。 构造函数有特定命名规则： 和类同名 没有返回类型 从默认构造函数开始吧。 5.2.1 默认构造函数、初始化及类分配 默认构造函数 不带参数（或所有参数都具有默认值）的构造函数称为默认构造函数。 【注】没有一个构造函数被显式声明时，编译器会隐式声明一个默认构造函数。 123456789101112131415161718192021#include &lt;iostream&gt;class Fraction&#123;private: int m_numerator &#123;&#125;; int m_denominator &#123;&#125;;public: Fraction() // 默认构造函数 &#123; m_numerator = 0; m_denominator = 1; &#125;&#125;;int main()&#123; Fraction frac&#123;&#125;; // 默认构造函数 return 0;&#125; 执行Fraction frac&#123;&#125;时，会创建类Fraction的实例 frac，然后调用默认构造函数初始化对象frac。 有时候你也会看到下面初始化方式： 12Fraction frac;Fraction frac(); 这二者有什么不同吗？ 列表初始化和直接初始化 Fraction frac&#123;&#125; 通常称为列表初始化，而 Fraction frac / Fraction frac() 被称为直接初始化。 它们都会在执行时调用相关构造函数，但是&#123;&#125; 方式还可能会使得编译器调用构造函数之前，对成员变量进行零值初始化。 验证一下。 123456789101112131415161718192021222324#include &lt;iostream&gt;class Fraction&#123;private: int m_numerator ; // 去除&#123;&#125; int m_denominator ;public: Fraction() // 不做任何事 &#123; // m_numerator = 0; // m_denominator = 1; &#125;&#125;;int main()&#123; Fraction frac1&#123;&#125;; // 列表初始化 Fraction frac2; // 直接初始化 std::cout&lt;&lt;frac1.m_numerator&lt;&lt;std::endl; std::cout&lt;&lt;frac2.m_numerator&lt;&lt;std::endl; return 0;&#125; 输出： 1202082139952 可见列表初始化方式确实对成员变量进行了零值初始化，而进行直接初始化存的是垃圾值（这一点我们在1.2.4节也总结对比过，此时成员变量值都是默认初始化的垃圾值）。 类静态分配和动态分配 在这之前我们见到类的对象都是静态分配的： 12Fraction frac2;Fraction frac1&#123;&#125;; 编译器静态建立一个类对象，在栈空间中分配内存，所以该对象内存不需要我们管理，编译器负责释放。 我们还可以进行动态分配（new方式）： 1Fraction* pfrac = new Fraction&#123;&#125;; 此时编译器动态建立一个类对象，在堆空间上分配内存，需要我们使用delete显式删除管理内存。 类如何实现只能静态分配或只能动态分配对象 ？ 只能静态分配：把new、delete运算符重载为private； 只能动态分配：把构造设为private/protected属性，类静态函数分配对象。 下面是实例。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;// 只能静态分配，禁用new（声明为private）class A&#123;private: void* operator new(size_t t)&#123;&#125; // 注意函数的第一个参数和返回值都是固定的 void operator delete(void* ptr)&#123;&#125; // 重载了new就需要重载deletepublic: A()&#123;&#125; ~A()&#123;&#125;&#125;;// 只能动态分配（外部无法使用构造函数，也就无法实例化，只能通过内部函数动态分配内存返回）class B&#123;private: B()&#123;&#125;public: static B* create()&#123;return new B();&#125; // 静态函数，因为不能创建对象 ~B()&#123;&#125;&#125;;int main()&#123; A a; // 静态分配 B* b = B::create(); // 动态分配 return 0;&#125; 5.2.2 转换构造函数 C++ 会将任何构造函数视为隐式转换运算符，在4.X.1 用户自定义隐式转换有过详细介绍。 简单回忆一下。 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;class dog &#123; public: // 1.转换构造函数 dog(string name) &#123;m_name = name;&#125; // 2.类型转换重载 operator string()&#123; return m_name;&#125; private: string m_name;&#125;;int main() &#123; string dogname = &quot;dog&quot;; // 1.转换构造函数 dog d = dogname; // ok // 2.类型转换重载 std::cout &lt;&lt; &quot;my name is &quot; &lt;&lt; string(d) &lt;&lt; &quot;\\n&quot;; return 0;&#125; 具体过程涉及到复制初始化： 1dog d = dogname; // ok 表达式从右到左，构造函数dog(string)作为转换构造函数 ，编译器先创建dog临时匿名对象，使得=两边操作类型一致； 然后dog(string) 初始化匿名对象； 至此，完成了string类型隐式转换为dog 。接下来是复制初始化相关过程： 编译器创建对象d ； 调用复制构造函数，用匿名对象成员值复制初始化对象d 。 初始化相关工作细节&amp;原理请看下文。 5.2.3 再谈初始化🌟 回顾一下三种初始化方式。 下面是列表初始化&#123;&#125; 初始化（可能会对非静态成员进行零值初始化）。 12345678910111213141516171819class Date&#123;private: int m_year&#123;&#125;; int m_month&#123;&#125;; int m_day&#123;&#125;;public: Date() = default; Date(int day,int month=1,,int month=1int year=2022) // 带参数的构造函数，存在默认值 &#123; m_year=year;m_month=month;m_day=day; &#125;;&#125;;int main()&#123; Date date&#123;25&#125;; // 列表初始化，调用带参构造函数 return 0;&#125; 也可以使用直接初始化方式： 1Date date(25); // 直接初始化 甚至你还可以使用复制初始化： 1234Date date1 = 25; // 1，还进行了隐式转换，等价于Date date1 =Date(25)Date date2 = Date(25); // 2Date date3 = Date&#123;25&#125;; // 3Date date4 = date3; // 4 = 左侧是被初始化的对象，因为=左右两侧操作类型要相等，所以= 右侧会先生成一个（匿名）对象，对左侧对象成员进行（复制）初始化。 但是，我们建议避免使用类进行复制初始化，因为一般效率较低且不安全。 为什么会这样？复制初始化是怎么工作的？ 复制初始化 参考：C++的直接初始化与复制初始化 先说说直接初始化是如何工作的： 注意，构造函数没有创建对象，只进行初始化。 1Date date(25); // 直接初始化 编译器创建一个对象date ； 初始化static静态成员； 最后调用匹配的构造函数 Date(int day,int year=2022,int month=1)初始化date的非静态成员。 列表初始化类似，只是在调用构造函数前，可能还会对非静态成员进行零值初始化。 对于复制初始化，还涉及到编译器为我们隐式声明的复制构造函数。 一个空类默认会添加以下函数，包括复制构造函数： 12345678// 缺省构造函数Date();// 析构函数~Date();// 赋值运算函数Date&amp; operator=(const Date&amp;);// 复制构造函数 （copy constructor）Date(Date const&amp; tmp); 其中复制构造函数完整定义为： 123// 成员列表方式，下节介绍Date(Date const&amp; tmp):m_year(tmp.m_year),m_month(tmp.m_month),m_day(tmp.m_day) &#123;&#125; 回到复制初始化： 1Date date = Date(25); // 复制初始化 为了=两侧操作类型一致，编译器首先创建一个匿名对象，为方便记为tmp； 注：Date(25) 是一种匿名对象初始化方式，它隐藏了对象的名字，等价于： 1Date tmp(25); // 匿名对象假设为tmp 执行Date(25)，（匿名对象中的）构造函数 Date(int day,int year=2022,int month=1) 初始化临时对象； 编译器创建一个对象date ； 最后编译器再调用（对象date中）拷贝构造函数，将临时匿名对象tmp作为拷贝构造函数参数 ，date 每个成员值复制临时匿名对象成员。 只要对象在声明时用了另一个对象（可能是编译器创建的匿名对象）进行初始化，就会触发复制构造函数，也就是复制初始化。 另一方面，我们不要执着于表象，=不重要：复制初始化核心在于调用复制构造函数，而不是调用普通构造函数初始化。 下面这种方式虽然没有= ，看起来像直接初始化。但Date date5 声明时使用了对象date1 进行初始化，所以依旧是复制初始化。 1Date date5(date1); // 复制初始化 显然，这种“复制”效率可想而言是低下的，因为它还可能会创建临时匿名对象。 不过标准规定，为了提高效率，允许编译器在合适的地方进行优化，跳过创建临时匿名对象这一步，直接调用构造函数构造要创建的对象。 下面4个复制初始化哪些会执行复制构造函数？ 123456789101112131415161718192021222324252627class Date&#123;private: int m_year&#123;&#125;; int m_month&#123;&#125;; int m_day&#123;&#125;;public: Date() = default; Date(int day,int month=1,int year=2022) &#123; m_year=year;m_month=month;m_day=day; std::cout&lt;&lt; &quot;构造函数被调用&quot;&lt;&lt;std::endl; &#125;; Date(Date const&amp; tmp): m_year(tmp.m_year),m_month(tmp.m_month),m_day(tmp.m_day) &#123; std::cout&lt;&lt; &quot;复制构造函数被调用&quot;&lt;&lt;std::endl; &#125;&#125;;int main()&#123; // 都是复制初始化 Date date1 = 25; // 1 Date date2 = Date(25); // 2 Date date3 = Date&#123;25&#125;; // 3 Date date4 = date3; // 4&#125; 结果可能会让你有些惊讶：除了方式4 ，其余都没用调用复制构造函数： 123456[root@roy-cpp test]# g++ -std=c++11 test.cpp -o test.out[root@roy-cpp test]# ./test.out 构造函数被调用构造函数被调用构造函数被调用复制构造函数被调用 也就是除了方式4 ，编译器都进行了优化（1、2、3生成了匿名对象，编译器可以跳过）。所以方式1、2、3等价于： 123Date date1(25);Date date2(25);Date date3(25); 不仅如此，复制初始化效率低的同时还并不安全。 因为这种拷贝方式是浅拷贝，如果存在指针也只是复制其值，不会复制其指向的区域。 深拷贝和浅拷贝 浅拷贝会带来什么问题？ 浅拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现double free。 12345678910111213class Test&#123; int *p&#123;nullptr&#125;; public: Test()&#123;p = new int(4);&#125; ~Test()&#123;delete p;&#125; &#125;;int main()&#123; Test ob1; Test ob2 = ob1;&#125; 编译执行出错： 给各位看官分析下原因： Test ob1构造类对象ob1，这是调用了构造函数，为ob1.p分配了内存空间； Test ob2 = ob1，调用复制构造函数构造类对象ob2 = ob1; main()函数执行完毕，全局函数的运行周期结束，系统回收内存（析构函数除了显示delete执行，对象离开作用范围会自动执行）： 先调用ob1的析构函数，将ob1.p指向的内存释放； 再调用ob2的析构函数，将ob2.p指向的内存释放。 但是由于ob2.p的内存已经在上一步被释放，所以造成了double free。 解决这个问题也很简单： 禁止使用拷贝构造函数： 使用delete关键字禁止（推荐）： 12// C++11新特性deleteTest(Test &amp;ob) = delete; 或声明为private： 12private: // 尝试调用私有成员函数会出错 Test(Test &amp;ob)&#123;...&#125;; 让使用者无法使用默认构造函数。 深拷贝： 自己显示声明复制构造函数，对成员变量实现深拷贝（复制指针内存区域值）。 深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。 123456789101112131415161718192021class Test&#123; int *p&#123;nullptr&#125;; public: Test() &#123; p = new int[4](); &#125; ~Test()&#123;delete p;&#125; Test(const Test&amp; other) // 实现深拷贝 &#123; if(p) // p不空 delete p; if(other.p) // other.p不空 &#123; p = new int[4](); for(int i = 0; i&lt; 4 ; i++) p[i] = other.p[i]; &#125; &#125; &#125;; 成员初始化列表 怎么初始化类私有成员？ 看过前面文章的你肯定脱口而出：构造函数呀！ 还有吗？对了，还有列表初始化。就像这样： 1234567class Date&#123;private: int m_year&#123; 1900 &#125;; int m_month&#123; 1 &#125;; int m_day&#123; 1 &#125;; ... 但如果私有成员被const修饰呢？ 列表初始化依旧可以： 123const int m_year&#123; 1900 &#125;;const int m_month&#123; 1 &#125;;const int m_day&#123; 1 &#125;; 但是如果用户想使用构造函数初始化： 123// 带参数的构造函数，存在默认值Date(int day,int year,int month) &#123;m_year=year;m_month=month;m_day=day;&#125;; 出错： 12const int Date::m_yearexpression must be a modifiable lvalue 等价于： 12const int m_year&#123; 1900 &#125;;m_year = year; // 常量不能修改，出错 这种情况就需要用到成员初始化列表。 成员初始化列表可以让用户初始化私有变量，包括常量。 成员初始化列表在构造函数后接: 进行初始化。 123456789101112131415161718192021222324#include &lt;iostream&gt;class Date&#123;private: const int m_year&#123; 1900 &#125;; const int m_month&#123; 1 &#125;; const int m_day&#123; 1 &#125;;public: Date() = default; Date(int year,int month,int day ):m_year(year),m_month(month),m_day(day) // 带参数的构造函数，存在默认值 &#123;&#125; void printDay() &#123; std::cout&lt;&lt;m_day&lt;&lt;std::endl; &#125;&#125;;int main()&#123; Date d&#123;2022,1,26&#125;; d.printDay(); // 26，确实重新初始化了 return 0;&#125; 成员初始化还可以初始化数组成员。 在 C++11之前，只能通过成员初始化列表将数组成员归零： 1234567891011class Something&#123;private: const int m_array[5];public: Something(): m_array &#123;&#125; // 只归零 &#123; &#125;&#125;; 现在还可以赋值： 1234567891011class Something&#123;private: const int m_array[5];public: Something(): m_array &#123;1,2,3,4,5&#125; // 对数组进行赋值 &#123; &#125;&#125;; 最后注意，初始化列表中的变量是按照类声明顺序进行初始化，而不是列表指定的顺序。 成员列表初始化更快？ 准确来说： 对于内置数据类型，复合类型（指针，引用）,成员初始化列表和构造函数体内进行性能没有什么差别； 对于用户自定义类型（类类型），成员列表初始化会快很多。 这是因为对于用户自定义类型，使用成员列表初始化会少使用一次构造函数。 1234567891011121314151617// 准备好classAclass classA &#123;public: // 默认构造函数 classA() &#123; cout &lt;&lt; &quot;classA()&quot; &lt;&lt; endl; &#125; // 复制构造函数 classA(const classA&amp; a) &#123; cout &lt;&lt; &quot;copy classA()&quot; &lt;&lt; endl; &#125; // 析构函数 ~classA() &#123; cout &lt;&lt; &quot;~classA()&quot; &lt;&lt; endl; &#125; // 重载赋值运算符 classA&amp; operator=(const classA&amp; a) &#123; cout &lt;&lt; &quot;operator= in classA&quot; &lt;&lt; endl; return *this; &#125;&#125;; 理解这个问题需要一点前置知识： 什么时候会使用复制构造函数？声明一个对象时用另外一个已存在的对象进行初始化时，会调用复制构造函数。 123A a;A b = A(); // 编译器生成匿名，然后调用复制构造函数初始b（不过编译器会优化）A b = a; // 已存在的对象a调用复制构造函数初始化b 什么时候会使用赋值运算符？ 重载=赋值运算符在下章介绍。 当一个已存在的对象用另外一个已存在的对象进行赋值时。 123A a;A b;b = a; // a,b之前就已存在，此时a调用赋值运算符函数对b进行赋值 类对象成员初始化动作早于构造函数体执行前，和成员列表同时发生。 有了这些基础知识，我们来分析为什么成员列表初始化更快。 成员列表初始化方式： 12345678910111213class classC&#123;public: classC(const classA&amp; a) : mA(a) &#123;&#125; // 对mA进行成员列表初始化private: classA mA;&#125;;int main()&#123; classA class_a; classC c(class_a);&#125; 输出： 1234classA()copy classA()~classA()~classA() 代码11、12行处等价于： 12classA class_a; // 输出：classA()，执行构造函数，初始化对象class_aclassA mA = a; // 输出：copy classA()，也是调用复制构造函数方式 可以看到，类实例化给对象分配内存时（比如mA）： 同时执行成员列表初始化对mAJ进行初始化，即classA mA = a ； 再执行构造函数体。 构造函数体初始化 12345678910111213141516class classC&#123;public: classC(const classA&amp; a) &#123; mA = a; // 函数体内初始化 &#125;private: classA mA;&#125;;int main()&#123; classA class_a; classC c(class_a);&#125; 输出： 12345classA()classA()operator= in classA~classA()~classA() 上述代码14、15行处等价于： 123classA class_a; // 输出：classA()，执行构造函数，初始化对象class_aclassA mA; // 输出：classA()，执行构造函数，初始化对象mAmA = a; // 输出：operator= in classA，一个已存在的对象初始化另外一个已存在的对象，使用赋值初始化 可以看到： 由于类成员分配内存早于构造函数体执行，先执行classA mA，调用默认构造函数对mA进行默认初始化 ； 再执行构造函数体 ，也就是mA = a，这个时候是用赋值=函数进行重新赋值； 而成员列表初始化方式，在类成员分配内存时时同时使用复制构造函数进行初始化。 所以相比之下，成员列表初始化少调用了一次构造函数对类对象成员（mA）进行初始化，成员列表初始化效率更高。 最佳实践：初始化选择 迄今为止我们接触了好几种初始化方式： 类实例方式： 列表初始化 直接初始化 复制初始化 std::move 类声明初始化位置： 成员初始化列表初始化 普通构造函数体内初始化 怎么进行选择？ 类声明初始化位置： 类类型成员、常量成员、引用成员优先考虑成员初始化列表。因为成员初始化列表不在函数体内，效率更高； （补充其它情况：当调用一个基类的构造函数，而构造函数拥有一组参数时；当调用一个成员类的构造函数，而它拥有一组参数。） 如果类成员还需要在调用构造函数前就提供默认值，成员声明时使用&#123;&#125;。 1int m_year&#123; 1900 &#125;; 最后考虑普通构造函数。 类实例方式： 优先考虑列表初始化。因为列表初始化还可能会进行零值初始化，更安全，但效率相比直接初始化更低点。 如果是临时对象初始化场景，使用std::move移动构造函数初始化。 慎重使用复制初始化。因为这种方式还会创建临时对象，效率比较低，而且不安全（浅拷贝）——一般是需要显式声明复制构造函数实现对象复制时（深拷贝）才使用。 5.2.4 移动构造函数 什么是移动构造函数？ C++11之前，对象的拷贝控制由三个函数决定：拷贝构造函数（Copy Constructor）、拷贝赋值运算符（Copy Assignment operator）和析构函数（Destructor）。 C++11新增加了两个函数：移动构造函数（Move Constructor）和移动赋值运算符（Move Assignment operator）。 在前面我们介绍了两种方法来避免指针浅拷贝造成double free的问题。 在这里我们介绍第三种方法：被复制的对象的指针成员置为NULL： 指针的浅拷贝之所以危险，究其本质是因为被析构函数释放了两次。例如上述指针p 的空间就被释放了两次，导致double free。 如果被复制的对象不再被使用，我们可以在复制构造函数进行浅拷贝后将指针成员置为NULL，析构时判断指针被置为NULL就不被释放。这样就可以避免double free。 1234567891011121314151617181920212223242526class Test&#123; int *p &#123;nullptr&#125;; public: Test()&#123; p = new int(4); &#125; Test(Test&amp; other) &#123; if(p) delete p; p = other.p; // 浅拷贝 other.p = nullptr; // 浅拷贝后将拷贝对象指针成员置为NULL &#125; ~Test() &#123; if(p) // p不空，析构函数进行判断 &#123; delete p; &#125; &#125;&#125;;int main()&#123; Test ob1; Test ob2 = ob1; // ok&#125; 另一方面，这里ob2 直接使用了ob1 的空间（ob2.p指向的是ob1.p原来的空间），不就大大地降低内存分配成本吗？ 这也就是移动构造函数的初衷： 对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。 上面的拷贝构造函数已经可以称为是移动构造函数。 但这种方式也有局限性： 仅限于一个对象被复制后不再被使用的场景，比如这里ob1，因为ob1.p指向内存已经被置为NULL，也就是说我们希望接受的引用对象是一个右值（右值在表达式中产生，运算结束后立即消失，有着“阅后即焚”的特性）。 但构造函数参数无法声明为const Test&amp; other ，虽然可以接受右值引用了（非const引用必须用左值初始化），但other.p = nullptr 修改会编译出错。 有没有办法，让移动构造函数参数能接受右值引用，又能进行修改，最好是只接受右值引用？ 这个时候右值引用和std::move 便派上了用处。 右值引用和std::move 请看下例。 12345678910111213141516171819202122232425262728293031323334class Test&#123; int *p&#123;nullptr&#125;; public: Test()&#123;p = new int(4);&#125; Test(Test&amp; other) &#123; cout&lt;&lt; &quot;复制构造函数（浅拷贝）&quot;&lt;&lt;endl; if(p) delete p; p = other.p; // 浅拷贝 other.p = nullptr; // 置为null &#125; Test(Test&amp;&amp; other) // 使用右值引用 &#123; cout&lt;&lt; &quot;移动构造函数&quot;&lt;&lt;endl; if(p) delete p; p = other.p; // 浅拷贝 other.p = nullptr; // 置为null &#125; ~Test() &#123; if(p) // p不空 &#123; delete p; &#125; &#125;&#125;;int main()&#123; Test ob1; Test ob2 = std::move(ob1); // 构造函数参数接受右值&#125; 输出： 1移动构造函数 可以看到移动构造函数和我们之前实现的复制构造函数（浅拷贝）基本一致。除了： 声明时，Test(Test&amp;&amp; other) 的&amp;&amp; ，&amp;&amp; 表示右值引用，表示参数只接收右值； 在本例中，如果你尝试： 12345int main()&#123; Test ob1; Test ob2 = ob1;&#125; 输出： 1复制构造函数（浅拷贝） 因为ob1 是右值，不会执行移动构造函数。 其它例子： 123int a = 1;const int&amp;&amp; pb = a; // error，只能接受右值，a是左值const int&amp;&amp; pc = 2; // ok 使用时，Test ob2 = std::move(ob1) 的std::move ，std::move表示将一个左值转换为右值。 这里是将ob1 转换为右值。上个例子中也可以进行转换： 1int&amp;&amp; pb = std::move(a); // ok std::move 实际只是个类型转换器，实现如下： 123456template &lt;typename T&gt;typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t)&#123; // 显示类型转换，类型T转换为type return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);&#125; 也就是std::move 可以理解为： 12int&amp;&amp; pb = std::move(a);int&amp;&amp; pb = (int&amp;&amp;)a; std::move 单独出现没有意义，它只将左值对象转换为右值，表明这个原本的左值对象不会再被需要或使用。它本身不会对对象做任何事，具体的移动工作由外面以右值为形参的重载函数进行。 一句话总结：std::move 只进行了移动前的准备工作（返回一个右值），配合重载了右值为形参的函数对对象进行移动。 在上面的例子中： 12345int main()&#123; Test ob1; Test ob2 = std::move(ob1); &#125; std::move(ob1) 将对象ob1 转换为右值或者说将亡值，为转移对象ob1所有权做准备； 然后匹配了重载了右值引用的移动构造函数，由移动构造函数完成“移动”这个动作： 12p = other.p; // 浅拷贝other.p = nullptr; // 置为null 更深刻理解std::move 除了返回一个右值，没有对对象进行其它操作。 1234567int main()&#123; int a = 2; int&amp;&amp; p_a = std::move(a); a++; // a照常使用 std::cout&lt;&lt;a&lt;&lt;std::endl;&#125; std::move没有修改a 本身，只是提示这是个可移动的对象，需要自己调用有右值的重载函数，才会进行移动（函数内部实现了“移动”这个动作）。 总的来说移动构造函数有以下好处： 充分利用临时对象内存，避免了空间浪费； 但一切都建立在使用临时对象进行初始化这个场景下。 std::move(ob1)还可以扩展到其它以右值引用为形参移动语义函数中，最常见是在STL中，STL类大都支持移动语义函数。 例如，std::vector方法定义： 1234void push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val); void emplace_back (Args&amp;&amp;... args); 显然void push_back (value_type&amp;&amp; val); 可以接受移动语义： 1234567891011#include&lt;vector&gt;#include&lt;string&gt;int main() &#123; std::string str1 = &quot;royhuang&quot;; std::vector&lt;std::string&gt; vec; vec.push_back(str1); // 传统方法，copy vec.push_back(std::move(str1)); // 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串&#125; 同样，这种做法减少了开辟内存开销。 emplace_back类似： 12vec.emplace_back(std::move(str1)); // emplace_back效果相同，str1会失去原有值vec.emplace_back(&quot;axcsddcas&quot;); // 当然可以直接接右值 再次强调，移动语义函数也是建立在被拷贝对象再拷贝后就不再被需要的场景下，比如这里的str1视为“将亡值”。 5.2.5 委托构造函数 构造函数重载时，允许一个构造函数调用其它构造函数，这个过程称为委托构造函数 。 为什么要这么设计？ 因为C++中不能在构造函数中调用其它构造函数，也就是不能进行构造函数嵌套 。 下面便是一个错误的示范，猜猜输出结果是什么？ 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;class Point &#123;public: Point()&#123; Point&#123;0, 0&#125;;&#125;; // 调用其它构造函数 Point(int _x, int _y): x(_x), y(_y) &#123; &#125;; void show()&#123; cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;, y = &quot; &lt;&lt; y &lt;&lt;endl; &#125;; int getX() &#123;return x;&#125; int getY() &#123;return y;&#125;private: int x; int y;&#125;;int main() &#123; Point p1&#123;&#125;; p1.show(); // 是 x=0，y=0吗？ Point p2&#123;2,3&#125;; // 是 x=2，y=3吗？ p2.show(); return 0;&#125; 结果可能会让你有点意外： 12x = -1847177920, y = 32765x = 2, y = 3 好家伙x = -1847177920, y = 32765是什么鬼？Point{0, 0}没有初始化p1吗？ 回到案发现场： 1Point p1; 我们知道在C++中定义一个对象： 要先分配内存（此时，非静态成员还未初始化）； 再调用构造函数（初始化非静态成员）。 对于Point p1 ： 编译器给对象p1 分配了内存； 调用构造函数Point() 初始化，进入函数体开始执行构造函数Point(int,int) ； 执行构造函数Point(int,int)时，编译器又创建了临时匿名对象； 此时再调用Point(int,int) 初始化匿名对象非静态成员x=0，y=0，而不是对象p1； 所以最终对象p1 的x、y没有被初始化为{0,0}。 也就是构造函数发生嵌套时，不会初始化当前对象而是初始化新生成的匿名对象。 整个过程比较难理解的是第3点：为什么执行构造函数，编译器创建了临时对象，构造函数不是不会创建对象吗？ 构造函数虽然不创建对象，但是在构造函数执行前，编译器会分配一个匿名对象空间，构造函数确实只是负责将其初始化了。 是的，C++就是这么魔鬼。 不过，C++大魔王大慈大悲允许你使用委托构造函数方式进行构造函数嵌套。 赶紧带着感恩的心瞧一下吧。 123456789101112class Point &#123;public: Point(): Point&#123;0, 0&#125;&#123;&#125;; // 委托构造方式 Point(int _x, int _y): x(_x), y(_y) &#123; &#125;; void show()&#123; cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;, y = &quot; &lt;&lt; y &lt;&lt;endl; &#125;; int getX() &#123;return x;&#125; int getY() &#123;return y;&#125;private: int x; int y;&#125;; 偷偷再告诉你两种不太优雅的方式做到类似构造函数嵌套的效果。 把构造函数中的公共部分抽取出来定义一个成员函数(最好修饰为private)，然后在每个需要这个代码的构造函数中调用该函数即可。 使用placement new。因为placement new不会重新分配内存，其定义也证明了这一点： 1234inline void *__cdecl operator new(size_t, void *_P)&#123; return (_P); // 没有分配新的内存&#125; 这样调用构造函数Point(int,int) 时不会创建临时对象，而是依旧在对象p1内存中执行初始化操作： 1234567Point()&#123; new (this)Point&#123;0,0&#125;;&#125;; Point p1;p1.show(); // x=0，y=0 5.3 析构函数 什么是析构函数？ 析构函数是另一种特殊的类成员函数，在该类的对象被销毁时执行，帮助类清理对象。 和构造函数一样，析构函数没有参数、返回类型，与类同名。 析构函数什么时候执行？ 当一个栈上分配的对象正常超出范围，注意区分堆上分配的对象不会自动释放，需要手动； 1234567Class Test&#123; ...&#125;;Tets t1; // 此时t1在栈上，超出作用范围会自动释放Test* t2 = new Test&#123;&#125;; // 此时t2指向的对象分配在堆上 delete 关键字显式删除动态分配的对象。 类一定需要析构函数吗？ 如果只是包含普通成员变量的值，不需要析构函数； 如果是类对象持有动态内存、文件或数据库句柄，需要析构函数。 例如，下面数组指针m_array 需要显示定义析构函数进行清理，否则会发生内存泄漏。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cassert&gt;#include &lt;cstddef&gt;class IntArray&#123;private: int* m_array&#123;&#125;; // m_array持有动态内存 int m_length&#123;&#125;;public: IntArray(int length) &#123; assert(length &gt; 0); m_array = new int[static_cast&lt;std::size_t&gt;(length)]&#123;&#125;; m_length = length; &#125; ~IntArray() // 析构函数 &#123; std::cout &lt;&lt; &quot;~IntArray&quot; &lt;&lt; &#x27;\\n&#x27;; delete[] m_array; // 清理m_array持有的动态内存 &#125; void setValue(int index, int value) &#123; m_array[index] = value; &#125; int getValue(int index) &#123; return m_array[index]; &#125; int getLength() &#123; return m_length; &#125;&#125;;int main()&#123; IntArray arr &#123;10&#125;; // 直接初始化，arr分配在栈上 for (int count&#123; 0 &#125;; count &lt; arr.getLength(); ++count) arr.setValue(count, count+1); std::cout &lt;&lt; &quot;The value of element 5 is: &quot; &lt;&lt; arr.getValue(5) &lt;&lt; &#x27;\\n&#x27;; return 0; // 析构函数~IntArray执行&#125; 输出： 12The value of element 5 is: 6~IntArray RAII RAII（资源获取即初始化）是一种编程技术，其中资源使用与具有自动生命周期的对象（例如非动态分配的对象）的生命周期相关联。在 C++ 中，RAII 是通过具有构造函数和析构函数的类来实现的。 RAII 的主要优点是它有助于防止资源泄漏（例如内存未被释放），因为所有资源持有对象都会自动清理。 资源（内存、文件或数据库句柄等）在对象的构造函数中获取，在对象处于活动状态时使用该资源。 当对象被销毁时，资源在析构函数中被释放。 前例中的m_array持有的动态内存就是RAII一个很好的例子——在构造函数中分配，在析构函数中释放。 在标准库中，std::string 和 std::vector同样遵循RAII——动态内存在初始化时获取，并在销毁时自动清理。 5.4 友元函数和友元类 我们一直努力尽量宣扬类数据保密（private）的好处。 但是，如果有类A和类B联系的非常紧密，类B对象确实需要用到类A对象的私有成员，这怎么办？ （这种情况通常发生于重载运算符时，此时两个类通常联系得很紧密，其它情况确实不常见。） 将类A的私有成员公开（public）？显然不行，这样别的类对象也可以访问A的私有成员； 在类A专门设置接口函数获取私有成员值？也不行，道理同上。 如果能指定只能类B访问类A的私有成员该多好啊！ 5.4.1 友元函数 友元函数就做了这么一件事：指定某个普通函数或某个类的成员函数为本类的友元函数，由此可以使用本类的私有成员。 虽然这破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。但在某些场景下确实很有用。 举例说明普通函数/成员函数作为友元函数。 普通函数作为友元函数 注意：友元函数虽然声明在类中，但并不属于当前类成员。 下面这个例子展示了，在类Accumulator 把函数reset 作为友元函数。 123456789101112131415161718192021222324252627class Accumulator&#123;private: int m_value &#123; 0 &#125;;public: // 外部函数reset作为友元函数 // 友元函数声明在类外，Accumulator对象作为参数 friend void reset(Accumulator&amp; accumulator);&#125;;// 友元函数reset定义在类外void reset(Accumulator&amp; accumulator)&#123; // 现在reset可以使用类Accumulator对象的私有成员 accumulator.m_value = 0;&#125;int main()&#123; Accumulator acc; reset(acc); // ok return 0;&#125; 注意，我们必须将 Accumulator 对象acc传递给 reset()。 因为友元函数reset() 不是类的成员，没有 *this 指针，也没有可供使用的 Accumulator 对象，因此必须给定一个。 一个函数还可以同时是多个类的友元函数，但是每个类中都要声明这个函数。 下面外部函数printWeather 同时是类Humidity 和 Temperature 的友元函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;class Humidity; // 前向声明，否则代码14行处无法找到定义class Temperature&#123;private: int m_temp &#123;&#125;;public: Temperature(int temp=0): m_temp &#123; temp &#125; &#123;&#125; // 声明1：是类Temperature的友元函数 friend void printWeather(const Temperature&amp; temperature, const Humidity&amp; humidity);&#125;;class Humidity&#123;private: int m_humidity &#123;&#125;;public: Humidity(int humidity=0): m_humidity &#123; humidity &#125; &#123;&#125; // 声明2：是类Humidity的友元函数 friend void printWeather(const Temperature&amp; temperature, const Humidity&amp; humidity);&#125;;// 定义友元函数printWeathervoid printWeather(const Temperature&amp; temperature, const Humidity&amp; humidity)&#123; std::cout &lt;&lt; &quot;The temperature is &quot; &lt;&lt; temperature.m_temp &lt;&lt; &quot; and the humidity is &quot; &lt;&lt; humidity.m_humidity &lt;&lt; &#x27;\\n&#x27;;&#125;int main()&#123; Humidity hum(10); Temperature temp(12); printWeather(temp, hum); return 0;&#125; 成员函数作为友元函数 与使普通函数成为朋友类似，也可以让类成员函数作为友元函数。 下面是一个实例。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;class Humidity; // 前向声明class Temperature&#123;private: int m_temp &#123;&#125;;public: Temperature(int temp=0): m_temp &#123; temp &#125; &#123;&#125; // 这里不需要Humidity完整定义，前面前向声明就可以。 void printHumidity(const Humidity&amp; Humidity) &#123; std::cout &lt;&lt; &quot;The Humidity is &quot; &lt;&lt; Humidity.m_humidity; &#125;&#125;;class Humidity&#123;private: int m_humidity &#123;&#125;;public: Humidity(int humidity=0): m_humidity &#123; humidity &#125;&#123;&#125; // Humidity的友元函数是Temperature类中的printHumidity函数 // 注意，类Temperature一定要在前，因为编译器需要友元函数类Temperature完整定义 friend void Temperature:: printHumidity (const Humidity&amp; Humidity);&#125;; 5.4.2 友元类 也可以让整个类成为另一个类的朋友，这样友元类的所有成员都可以访问类的私有成员。 一个简单实例。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;class Storage&#123;private: int m_nValue &#123;&#125;; double m_dValue &#123;&#125;;public: Storage(int nValue, double dValue): m_nValue &#123; nValue &#125;, m_dValue &#123; dValue &#125; &#123;&#125; // Display是本类（Storage）的友元类 friend class Display;&#125;;class Display&#123;private: bool m_displayIntFirst;public: Display(bool displayIntFirst): m_displayIntFirst &#123; displayIntFirst &#125; &#123; &#125; void displayItem(const Storage&amp; storage) &#123; // Display可以使用Storage的私有成员 if (m_displayIntFirst) std::cout &lt;&lt; storage.m_nValue &lt;&lt; &#x27; &#x27; &lt;&lt; storage.m_dValue &lt;&lt; &#x27;\\n&#x27;; else std::cout &lt;&lt; storage.m_dValue &lt;&lt; &#x27; &#x27; &lt;&lt; storage.m_nValue &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;;int main()&#123; Storage storage(5, 6.7); Display display(false); display.displayItem(storage); // ok return 0;&#125; 5.5 隐藏的this指针 5.5.1 快速回忆 在2.1.4节，我们说过，每个类都有个隐藏的this指针。 快速回忆下： 编译器隐式为每个数据成员加上this 指针； 编译器隐式为每个函数显示加上了第一个参数Simple* const this 。 为方便理解，下面代码注释显示指示了this指针的位置。 123456789101112131415161718192021222324class Simple&#123;private: int m_id;public: Simple(int id): m_id&#123; id &#125; // Simple(Simple* const this,int id): this-&gt;m_id&#123; id &#125; &#123; &#125; void setID(int id) &#123; m_id = id; &#125; // void setID(Simple* const this,int id) &#123; this-&gt;m_id = id; &#125; int getID() &#123; return this-&gt;m_id; &#125;&#125;;int main()&#123; Simple simple&#123;1&#125;; simple.setID(2); // simple.setID(&amp;simple,2); std::cout &lt;&lt; simple.getID() &lt;&lt; &#x27;\\n&#x27;; return 0;&#125; 从代码22行处，也可以知道：this指针就是指向当前对象simple 。 大部分时候，我们都可以假装不知道this指针的存在，但在链接成员时this指针表现得很有用。 5.5.2 this指针链接成员函数 思考一下：经常使用的std::cout是如何实现连续打印多个字符串？ 1std::cout &lt;&lt; &quot;Hello &quot; &lt;&lt; &quot;World&quot;; 此时，std::cout 是一个对象，而 operator&lt;&lt; 是对该对象进行操作的成员函数： operator&lt;&lt; 打印第一个字符串&quot;Hello &quot;，然后返回当前对象，也就是*this； std::cout 对象 *this 调用operator&lt;&lt; 打印第二个字符串&quot;World&quot;。 举一个更具体的例子： 123456789101112131415161718192021#include &lt;iostream&gt;class Calc&#123;private: int m_value&#123;&#125;;public: Calc&amp; add(int value) &#123; m_value += value; return *this; &#125; Calc&amp; sub(int value) &#123; m_value -= value; return *this; &#125; Calc&amp; mul(int value) &#123; m_value *= value; return *this; &#125; int getValue() &#123; return m_value; &#125;&#125;;int main()&#123; Calc calc&#123;&#125;; calc.add(5).sub(3).mul(4); // 函数链接起来了 std::cout &lt;&lt; calc.getValue() &lt;&lt; &#x27;\\n&#x27;; return 0;&#125; 这种做法在类重载运算符时最常使用，下章一起来学习下吧。 更新记录 2022-02-02：更新笔记 修改std::move相关描述 2022-01-29：更新笔记 修改成员列表初始化相关描述增加移动构造函数相关描述 2022-01-28：更新笔记 修改复制初始化相关描述 2022-01-27：更新笔记 第一次更新 参考资料 1.C++构造函数的理解 : https://www.cnblogs.com/downey-blog/p/10470782.html ↩2.禁止拷贝构造，禁止bug：https://zhuanlan.zhihu.com/p/266353611 ↩3.为什么使用初始化列表会快一些？https://segmentfault.com/a/1190000039294789 ↩4.C++11右值引用和移动构造函数详解 ：https://zhuanlan.zhihu.com/p/365412262 ↩5.C++中的std::move函数到底是做什么的？https://www.zhihu.com/question/467449795 ↩","categories":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/categories/C/"},{"name":"从零开始","slug":"C/从零开始","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"},{"name":"C++面对对象","slug":"C/从零开始/C-面对对象","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/tags/C/"},{"name":"教程","slug":"教程","permalink":"https://hwh.zone/tags/%E6%95%99%E7%A8%8B/"},{"name":"快速入门","slug":"快速入门","permalink":"https://hwh.zone/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"面对对象","slug":"面对对象","permalink":"https://hwh.zone/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"}]},{"title":"C++从零开始（六）：务实基础（下）复合类型及转换","slug":"C++从零开始（二）：务实基础（下）之复合类型及转换","date":"2022-01-16T13:04:18.006Z","updated":"2022-02-26T07:45:01.285Z","comments":true,"path":"p/6587/","link":"","permalink":"https://hwh.zone/p/6587/","excerpt":"","text":"🌟《C++从零开始》 系列，开始更新中… C++从零开始https://hwh.zone/p/62712 四、复合类型及转换 什么是复合类型？这听起来好像是有点新奇的概念。 从基本数据类型（比如int、char）或其他复合数据类型构造出来的数据类型，就称为复合类型。 在前面我们已经接触过所谓的复合类型： 数组（std::string、std::array 等）、指针类型（函数指针或者说函数，指向对象的指针等）、引用类型。 举个例子，下面函数func 类型是void()(int, double) ，它由基本类型组成，使其成为复合类型： 123void func(int x, double y)&#123;&#125; 本章主要介绍的复合类型是结构体（注意结构体大小计算）和枚举（注意枚举作用范围问题），以及各种类型之间的转换： 用户隐式转换及发生的情况； 用户四种显示转换，包含C风格和C++风格； t特别补充，string类型和其它类型之间的转换。 4.1 结构体 4.1.1 从C谈起 在C语言中定义一个典型结构体struct如下： 123456789101112131415161718#include &lt;stdio.h&gt;// 1. 定义struct People &#123; char name[10]; char gender[5]; int age;&#125;; // *这里有个分号，易遗漏int main()&#123; // 2.声明&amp;初始化，结合&#123;&#125; struct People people = &#123;&quot;royhuang&quot;,&quot;male&quot;,25&#125;; // 3.访问，C/C++中结构体成员默认都是public可以直接访问 printf(&quot;your name: %s \\n&quot;,people.name); // royhuang return 0;&#125; 当时还是新手C玩家的我，很难说出struct到底带来什么好处。只能隐隐约约感觉到，struct组合多个且有逻辑关联的数据增强了程序逻辑性和可读性。 那么struct 除了组织有逻辑关联的数据提高代码可读性和一致性，在实际编码中还有其它应用吗？ 在第三章函数，我们提到过：结构体还可用于函数传递多个参数或者函数返回多个值。 传递多个参数 传递一个结构体作为参数： 12345678910111213void printPeople(const struct People&amp; people)&#123; printf(&quot;your name: %s \\n&quot;,people.name); printf(&quot;your gender: %s \\n&quot;,people.gender); printf(&quot;your age: %d \\n&quot;,people.age);&#125;int main()&#123; struct People people = &#123;&quot;royhuang&quot;,&quot;male&quot;,25&#125;; printPeople(people); return 0;&#125; 显然这相比传递多个参数要清爽很多（且不易出错）： 1void printPeople(const char* name, const char* gender, const int age) 返回多个值 函数只能返回一个参数，除了使用元组，结构体是不二的选择： 1234567struct People&amp; cleanPeople(People&amp; people)&#123; people.name=&quot;&quot;; people.gender=&quot;&quot;; people.age=-1; return people;&#125; 4.1.2 C++中struct C++中struct兼容了C，在此基础上还进行了扩展： C C++ 成员 只有数据 数据，函数等都可以 访问权限 public 默认public，有private 是否可以继承 否 是 在C中结构体声明必须带上struct 关键字，而C++中可以直接使用。 12struct People people1; // CPeople people1; // C++ C++中，struct增加了private访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了兼容C）。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;struct People&#123; char name[10]; char gender[5]; int age; // 构造函数 People(const char* peole_name,const char* peole_gender,int peole_age) &#123; strncpy(name,peole_name,10); strncpy(gender,peole_gender,5); age = peole_age; &#125; // 成员函数 void printPeople(const People&amp; people) &#123; std::cout&lt;&lt;&quot;your name:&quot; &lt;&lt;people.name&lt;&lt;std::endl; std::cout&lt;&lt;&quot;your gender: &quot;&lt;&lt;people.gender&lt;&lt;std::endl; std::cout&lt;&lt;&quot;your age: &quot;&lt;&lt;people.age&lt;&lt;std::endl; &#125; // 私有变量 private: char girl_friend[10];&#125;; // 分号int main()&#123; People people = &#123;&quot;royhuang&quot;,&quot;male&quot;,25&#125;; people.printPeople(people); return 0;&#125; 可以继承，实现了多态。 显然，C++中struct和class区别已经不大。 4.1.3 结构体大小和比较 参考：c++中的sizeof()运算符、C/C++中 sizeof 的用法总结 从基本数据类型说起。 对于short、int、long简单内置数据类型，可采用sizeof 关键字计算大小： 12345678int i; sizeof(int); // 值为4 sizeof(i); // 值为4，等价于sizeof(int) sizeof i; // 值为4 sizeof(2); // 值为4，等价于sizeof(int)，因为2的类型为int sizeof(2 + 3.14); // 值为8，等价于sizeof(double)，因为此表达式的结果的类型为double char ary[sizeof(int) * 10]; // OK，编译无误 题外话：sizeof和strlen的区别？ 运算符与函数：sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。 参数类型：sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\\0’的字符串。 值确定时机：sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。 12345678int main()&#123; const char* str = &quot;name&quot;; sizeof(str); // 取的是指针str的长度，是8 strlen(str); // 取的是这个字符串的长度，不包含结尾的 \\0。大小是4 return 0; &#125; 注意，基本数据类型的内存大小是和系统相关的，所以在不同的系统下取值可能不同。比如， long 类型与指针类型在 32 位机器上只占 4 字节，在 64 位机器上占 8 字节； int在32位/64位都占4字节。 本节均假设按64位机器考虑。 sizeof 计算结构体大小 结构体的sizeof为了提高存取效率，涉及到字节对齐问题。 其对齐规则如下: 顺序存储：分配内存的顺序是按照声明的顺序进行顺序存储； 偏移量：每个变量相对于起始位置的偏移量，必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止； 整体大小：最后整个结构体的大小必须是，变量类型最大值的整数倍。 以下实例说明。 1234567891011121314#include &lt;iostream&gt;using namespace std;struct A&#123; char a; double b; int c;&#125;;int main()&#123; cout &lt;&lt; sizeof(A) &lt;&lt; endl;&#125; 输出为：24，而不是1+8+4=13。这是因为 ： char a 的偏移量为 0，占用 1Byte； double b 指的下一个可用的地址的偏移量为 1，不是 sizeof(double)=8 的整数倍，需要补足 7Byte 才能是偏移量为 8； int c 指的下一个可用的地址的偏移量为 16，是 sizeof(int)=4 的整数倍，满足 int 的对齐方式； 结构体大小必须是最大成员大小的整数倍，（即结构中占用最大空间的类型所占用的字节数 sizeof(double)=8）的倍数，所以最后还需填充4byte。 嵌套结构体和unio共用体对齐规则又有所不同。 嵌套结构体 对于嵌套的结构体，需要将其展开。对嵌套结构体求 sizeof 时，上述原则变为： 展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大（非嵌套不要求最大）的成员的整数倍。 结构体大小必须是最大成员大小的整数倍，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体。 123456789101112131415161718#include &lt;iostream&gt;using namespace std;struct B&#123; char a; struct &#123; char b; int c; &#125; ss; short d;&#125;;int main()&#123; cout &lt;&lt; sizeof(B) &lt;&lt; endl;&#125; 该代码输出：16。分析过程同前，这里只给出图示。 Unio共用体 union 中变量共用内存，原则如下： 内存大小应以最长的为准； 满足上述条件下，还应是最长成员的整数倍大小。 例如，下面例子输出共用体大小为：24。 123456789101112131415#include &lt;iostream&gt;using namespace std;union C&#123; int a[5]; // 数组大小=成员*长度=5*4=20 char b; double c;&#125;;int main()&#123; // 最后输出补足4byte，满足是double(8字节)整数倍 cout &lt;&lt; sizeof(C) &lt;&lt; endl;&#125; 特别的，请思考： 将共用体内的 int a[5] 修改成 int a[6] 后，结果仍然不变；但如果将 int a[5] 修改成 int a[7]，结果就变成 32？ 你可在评论区写下你的见解。 扩展：sizeof计算类对象大小 关于类占用的内存空间，有以下几点需要注意： 虚函数：编译器需要为类构建虚函数表，类中需要存储一个指针指向这个虚函数表的首地址。 注意不管有几个虚函数，都只建立一张表，所有的虚函数地址都存在这张表里，类中只需要一个指针指向虚函数表首地址即可。 静态成员：被类所有实例所共享的，它不计入sizeof计算的空间。 普通函数或静态函数：都存储在栈中，不计入sizeof计算的空间。 类成员：采用字节对齐的方式分配空间； 以下为实例说明： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;class D&#123; public: // 虚函数：需要一个指针指向虚函数表 // 32位系统指针大小为 4Byte，64位系统指针大小为 8Byte virtual void funa(); virtual void funb(); // 普通函数或静态函数或静态成员：不计入 void func(); static void fund(); static int si; private: // char占1字节 char c; // int首先要偏移3字节，是sizeof(int)整数倍 // int本身占4字节 int i;&#125;;int main()&#123; // 最后总大小为：指针大小+1+3+4 = 12 OR 16 cout &lt;&lt; sizeof(D) &lt;&lt; endl;&#125; 以上输出为：12（32位系统）或者16（64位系统）。具体占用请查看代码中注释。 类成员对齐方式和结构体有所不同，未尽细节将在未来补充。 空类/结构体大小 思考源自于：空类的大小为什么是1？ 经过实践，无论是空类还是空结构体，其大小均为1而不是0。 看了一下比较信服的解答是： 如果长度是0，那么把他塞给一个指针，指针指到哪里呢？不考虑指针，这个类自己存在哪里呢？如果我一下子申明100万个实例，都不占用内存吗？ c++ 中规定不同的对象必须拥有不同的地址，如果为0会导致两个空类的地址一样。 但是为啥空类一定要有不同的地址来去区分不同的对象？ 结构体比较 C++结构体直接进行比较会出错： 1234567891011121314151617181920#include&lt;iostream&gt;struct A&#123; int a; float b; char* c;&#125;;int main()&#123; A a&#123;1,2,new char[4]&#123;&#x27;h&#x27;,&#x27;w&#x27;,&#x27;h&#x27;&#125;&#125;; A b&#123;1,2,new char[4]&#123;&#x27;h&#x27;,&#x27;w&#x27;,&#x27;h&#x27;&#125;&#125;; if(a==b) std::cout&lt;&lt;&quot;equal&quot;&lt;&lt;std::endl; else std::cout&lt;&lt;&quot;not equal&quot;&lt;&lt;std::endl;&#125; 输出： 1234[root@roy-cpp test]# g++ -std=c++11 test.cpp -o test.outtest.cpp: In function ‘int main()’:test.cpp:21:9: error: no match for ‘operator==’ (operand types are ‘A’ and ‘A’) if(a==b) 有两种办法解决这个问题： 结构体 a 和 b 每个元素逐个比较，指针比较它们的地址。 自己重载操作符== 。 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;struct A&#123; int a; float b; char* c; bool operator== (const A&amp; other) const &#123; bool a_is_equal = (a==other.a); bool b_is_equal = (b==other.b); bool c_is_equal = true; for(int i=0 ; i&lt;3 ; i++) &#123; if(c[i] != other.c[i]) &#123; c_is_equal =false; break; &#125; &#125; return a_is_equal &amp;&amp; b_is_equal &amp;&amp; c_is_equal; &#125;&#125;;int main()&#123; A a&#123;1,2,new char[4]&#123;&#x27;h&#x27;,&#x27;w&#x27;,&#x27;h&#x27;&#125;&#125;; A b&#123;1,2,new char[4]&#123;&#x27;h&#x27;,&#x27;w&#x27;,&#x27;h&#x27;&#125;&#125;; if(a==b) std::cout&lt;&lt;&quot;equal&quot;&lt;&lt;std::endl; else std::cout&lt;&lt;&quot;not equal&quot;&lt;&lt;std::endl;&#125; 输出： 12[root@roy-cpp test]# ./test.out equal 4.1.4 扩展阅读：为什么C++还保留struct？ 在C++中，除了默认访问控制符、模板参数，struct和class基本完全一致，struct存在的意义是什么，全用class不好吗？ struct class 继承默认权限 struct默认是public class默认是private 模板参数 不可以 可以 这里面的原因主要是： 历史包袱。给 C 语言程序开发人员有一个归属感； 兼容 。让 C++ 编译器兼容以前用 C 语言开发出来的项目，比如系统库stdlib.h 等。 4.2 枚举 4.2.1 枚举初识 和结构体类似，枚举也是组织了有逻辑关系的数据，不过枚举： 数据只能是同类型（我们定义的枚举类型）； 相比struct/class，枚举enum更像是一种弱组织类型，如果你有一组相关的常量最好使用枚举。 举个例子吧，用枚举组合三元色（常量）。 1234567891011121314#include &lt;iostream&gt;enum Color // 最佳实践：首字母大写&#123; red, blue, green,&#125;;int main()&#123; Color paint = red; return 0;&#125; 相比用0、1、2分别定义三元色，代码可读性提高了很多。 枚举是整数符号常量 枚举到底什么？ 好吧，标题已经出卖了答案：枚举其实就是整数符号常量（默认是int）。 和char 情况有点类似： 1char c = &#x27;A&#x27;; char 实际上存储的是一个 1 字节的整数值，即字符'A'被转换为整数值（在本例中为65）并存储。 只不过打印cout类对&lt;&lt;进行了重载，直接打印c 出来的是'A'： 1std::cout&lt;&lt;c; // A 回到枚举enum ： 枚举会自动分配一个整数值。默认情况下，第一个枚举器被分配整数值0，每个后续枚举器的值都比前一个+1； 我们也可以自定义枚举值。 1234567891011121314151617#include &lt;iostream&gt;enum Animal&#123; cat = -3, dog, // -2 pig, // -1 horse = 5, giraffe, // 6 chicken // 7&#125;;int main()&#123; Animal animal = dog; std::cout &lt;&lt; &quot;你的宠物是：&quot; &lt;&lt; animal; return 0;&#125; 输出： 1你的宠物是：-2 好吧你的宠物是-2，编译器隐式将枚举转换为了整数（并没有像char一样打印字符，std::cout没有对枚举类型Animal进行重载）。 不过，编译器不会将整数隐式转换为枚举数。 1Animal animal = -2; // error 需要显式转换： 1Animal animal = static_cast&lt;Animal&gt;(-2); 上面我们验证了enum的主要用法和特性，但可以更完美一点优雅打印枚举数吗，就像char一样？ 优雅打印枚举数 怎么优雅打印枚举数？ C++中并没有提供相关函数。这只有我们自己来实现，if-else或switch 逐个判断是最容易想到的： 1234567891011const std::string printAnimal(Animal animal)&#123; switch (animal) &#123; case cat: return &quot;cat&quot;; case dog: return &quot;dog&quot;; case pig: return &quot;pig&quot;; // 省略其它的判断 default: return &quot;???&quot;; &#125;&#125; 但这需要显式调用printAnimal 方法，看起来有点笨拙。 12Animal animal = dog;std::cout &lt;&lt; &quot;你的宠物是：&quot; &lt;&lt; printAnimal(animal); 直接重载std::cout 类运算符&lt;&lt;是更好的做法。 1234567891011std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Animal animal)&#123; switch (animal) &#123; case cat: return &quot;cat&quot;; case dog: return &quot;dog&quot;; case pig: return &quot;pig&quot;; // 省略其它的判断 default: return &quot;???&quot;; &#125;&#125; 现在，我们可以打印字符串看起来聪明了很多： 12Animal animal = dog;std::cout &lt;&lt; &quot;你的宠物是：&quot; &lt;&lt; animal; 输出： 1你的宠物是：dog 认识枚举作用域 枚举内部数据和枚举具有同样的作用范围，也就是枚举对内部数据作用范围无限制。 回到最开始的例子： 1234567891011121314enum Color&#123; red, green, blue, &#125;;int main()&#123; // 直接就使用了red // 也可以通过前缀Color::red Color paint = red; return 0;&#125; 可以看到，red 和 enum Color 作用域是一致的，都是全局类型。 这种设置，调用起来很方便，但是在两个不同枚举类定义相同的数据，会使得命令空间污染，导致编译错误。 12345678910111213enum Color&#123; red, green, blue, // blue 表示颜色&#125;;enum Feeling&#123; happy, tired, blue, // blue表示心情&#125;; 如果你再尝试调用，编译无法通过，两个blue 冲突： 1Color paint = blue; // error: redeclaration of ‘blue’ 虽然可以通过显式指定前缀避免错误： 1Color paint = Color::blue; 但终归是埋下了隐患。 更好的做法是使用命名空间namespace 限定范围，这样我们可以在不同枚举类定义相同的数据。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;namespace color&#123; enum Color &#123; red, green, blue, &#125;;&#125;namespace feeling&#123; enum Feeling &#123; happy, tired, blue, &#125;;&#125;int main()&#123; // 现在必须加上作用域区域的名称 color::Color paint = color::blue ; feeling::Feeling me = feeling::blue ; return 0;&#125; 最佳实践 使用枚举请显式指明枚举类型，比如color::blue 而非直接使用blue。 4.2.2 范围枚举 为什么需要范围枚举？ 非范围枚举看起来很好，但会带来一些问题： 隐式转换的危害。非范围枚举会隐式地将枚举类型转换为整数类型，这有时候会造成一些意料之外的错误（比如不同枚举类型进行比较，下举例说明）； 非强制要求前缀。这显然和我们刚刚提到的枚举最佳实践不符。 范围枚举的特性很好地解决了上述问题： 范围枚举是强类型的（不会隐式转换为整数）和强作用域的（必须指定前缀）； 其余和非范围枚举没什么区别。 范围枚举初识 范围枚举通过enum class 声明： 12345678910111213#include &lt;iostream&gt;enum class Color &#123; red, blue,&#125;;enum class Fruit&#123; banana, apple,&#125;; 先认识下范围枚举的强作用域： 1Color c = red; // error，identifier &quot;red&quot; is undefined 必须显式指定作用范围，契合了最佳实践： 1Color c = Color::red; // ok 再来认识范围枚举的强类型（不会隐式转换）。 无法直接打印 因为范围枚举不会隐式转换为int ，std::cout 无法直接打印。 1std::cout &lt;&lt; Fruit::banana; 除非你显式进行转换： 1std::cout &lt;&lt; static_cast&lt;int&gt;(Fruit::banana); 不能直接比较两个不同枚举类型 下面代码编译能通过吗？ 1234567891011int main()&#123; Color color = Color::red ; Fruit fruit = Fruit::banana ; if (color == fruit) std::cout &lt;&lt; &quot;color和fruit相等\\n&quot;; else std::cout &lt;&lt; &quot;color和fruit不相等\\n&quot;; return 0;&#125; 如果是无范围枚举上述代码不会编译出错，甚至会打印： 1color和fruit相等 因为red和banana 都被隐式转换为int类型，值都为0 。 但如果是范围枚举，上述代码会直接报错： 1compile error: the compiler doesn&#x27;t know how to compare different types Color and Fruit 范围枚举不会转换任何可以与另一种类型进行比较的类型。 不过，比较同一类型是ok的。 1if (Color::red == Color::blue) // ok 最佳实践 请尽量使用范围枚举，它更安全。 虽然在实际编码我们还是可能会使用非范围枚举，因为非范围枚举隐式转换可避免大量手动static_casting 。但是，只是偶尔的需要static_casting 便不能构成拒接范围枚举的理由。 4.X 类型转换🌟 什么是类型转换？ 将值从一种数据类型转换为另一种数据类型的过程，称为类型转换。 C++的类型有几种？ C++的类型转换分为两种，一种为隐式转换，另一种为显式转换： 隐式转换：编译器自动进行的类型转换，就是隐式转换； 显式转换：程序员显式使用_cast 类型转换符进行类型转换，就是显式转换。 C++ 中的绝大多数类型转换都是隐式类型转换。 所以，我们先来接触隐式类型转换吧。 4.X.1 隐式转换 隐式转换可以分为两个部分，标准转换和用户自定义转换，我们来看看它们是什么。 标准转换 标准转换就是编译器里内置的一些类型转换规则： 数值提升 数值转换 算术转换 数组退化成指针、函数转换成函数指针 数据类型指针到void指针的转换、nullptr_t到数据类型指针的转换 特定语境下要求的转换，比如if里要求bool类型的值、枚举类型转换为整型 … 可以看到，这些转换基本针对基本数据类型、指针、或数组这种内置的聚合类型的。 先从第一个数值提升说起吧。 数值提升 数值提升是什么？ 顾名思义，数值提升就是将更小的数据类型（比如char） 转换为更大的数据类型（通常是int或者double）。显然这种提升是安全的，它不会丢失精度。 数值提升也分为两个子类别：浮点提升和整数提升。 浮点提升 浮点提升规则很简单，就是float 可以隐式提升为double 。一个例子就能明白： 1234567891011#include &lt;iostream&gt;void printDouble(double d)&#123; std::cout &lt;&lt; d;&#125;int main()&#123; printDouble(4.0f); // 4.0f是float被隐式提升double return 0;&#125; 整型提升 char、bool、short 、int、long 都是整型。 整型提升说白了，就是比int 小的数据类型，尽量往int 或 unsigned int上靠。它的规则大致总结如下： 无符号或者有符号char、short 优先隐式转换为int，如果int不够容纳，则转换为 unsigned int； bool也转换为int，false变成0，true变成1。 举一个小例子。 12345678910111213141516#include &lt;iostream&gt;void printInt(int x)&#123; std::cout &lt;&lt; x;&#125;int main()&#123; short s = 3 ; // short printInt(s); printInt(&#x27;a&#x27;); // char printInt(true); // bool return 0;&#125; 数值之间的转换就结束了？ 看到这儿或许你会说作者是不是遗漏了，int→float 之类的整型提升介绍呢？ 其实，int→float 、还有宽类型→窄类型的转换都被归类为数值转换。当然这只是学术上的区别，你不必太过纠结这点。 数值转换 什么是数值转换？ 数值提升未提到的转换，都是数值转换。 回答这么敷衍？好吧，我具体一点。 数值转换可分为以下五种规则： 整型可转换为任何其它整型（不包括整型提升） 123short s = 3; long l = 3; char ch = s; 浮点类型转换为任何其他浮点类型（不包括浮点提升） 12float f = 3.0; long double ld = 3.0; 整数类型转换为任何浮点类型 1double d = 3; 将浮点类型转换为任何整数类型 1int i = 3.5; 将整数类型或浮点类型转换为 bool 1bool b1 = 3.0; 可以看到：数值转换和数值提升的规则综合起来就是一句话：C++中基本任意整型之间都可以进行隐式转换。 但数值转换会带来一些危险。 由于数值转换可以将：宽类型→窄类型、浮点类型→整数类型，这会导致精度丢失。 1234567// 浮点类型→整数类型 float a = 1.5; int b = a ; // a = 1.0 , 小数部分丢失 // 宽类型→窄类型 int a = 1000000; char d = a; // d = 64（&#x27;@&#x27;） , a被截断 另一点比较隐蔽，隐式转换总是转换为右值（显式转换也是）。 听起来好像没什么毛病，但是和引用结合起来就坏事了，我们知道引用只能用左值初始化。 123int a = 10; long &amp;b = a; // error，无法使用右值初始化引用 long &amp;b = static_cast&lt;long&gt;(a); // error,显式转换也是右值 解决办法也很简单： 12345678// 1.和引用类型保持一致 int a = 10; long tmp = a; long &amp;b = tmp; // 2.使用const修饰，这样可以接受右值初始化 int a = 10; const long &amp;b = a; 扩展到函数也是一样： 1234void func(const long&amp; value); int a = 10; func(a); 这也是为什么很多教程说尽量用const修饰引用：这样可以使得函数参数可以隐满足式转换规则。 算术转换 算术转换就是当操作数不是同一类型时，会隐式转换为同一类型进行再进行操作。 算术转换优先级列表： long double &gt; double &gt; float &gt; unsigned long long &gt; long long &gt; long &gt; unsigned int &gt; int 注意到最低优先级是int。 算术转换只有两条规则： 如果至少有一个操作数的类型在优先级列表中，则将具有较低优先级的操作数转换为具有较高优先级的操作数的类型； 否则（两个操作数的类型都不在列表中），两个操作数都进行类型提升。 一个简单例子。 123int i = 2;double d = 3.5;typeid(i + d).name(); // 最终类型为d，double优先级更高，所以i提升为double 指针相关转换 这些我们之前其实都基本见过： 数组退化成指针、函数转换成函数指针 数据类型指针到void指针的转换、nullptr_t到数据类型指针的转换 … 举个小例子加深下印象就好。 123456int* i = new int();void* ptr = i; // 所以之前说void类型接受任何类型的指针char* pc = 0; // int 转换为 Null 指针再转换为char*指针char* pc = nullptr; // nullptr转换为char*指针dog* pd = new yellowdog(); // 指针类型转换，子类 yellowdog 指针转换为父类 dog 指针 特殊语境下转换 以if为例，if接受bool类型。 1234if(3) // 3转换为bool类型，这里是true(非0值都转换为true)&#123; std::cout&lt;&lt;&quot;fine&quot;&lt;&lt;std::endl; &#125; bool也是整型，其实也就是前面说别的，C++中整型几乎都可以进行隐式转换。 别踩坑：char和int的转换？ 前面我们说到，char和int可以隐式转换。但这可能会带来一些意外的错误： 12char c = &#x27;1&#x27;;int a = c; // a=49 此时是将c 的ASCII码49（数字的ASCII码从48开始，即'0'开始） 赋值给变量a。 如果需要获取c存储值'1'： 12int a1 = c-48; // 方法1int a2 = c-&#x27;0&#x27;; // 方法2 用户自定义转换🌟 这部分内容有点超前，适合有一定面对对象基础的同学。 怎么进行用户定义转换？ 用户自定义的隐式转换是隐式转换的重头戏，一般指两方面内容: 转换构造函数，利用接受单个参数 或 第一个参数其余参数都提供了默认值 的构造函数，将其他类型对象→转换为本对象。 C++ 会将任何构造函数视为隐式转换运算符。 类型转换重载， 重载指定类型，将本类的对象→转换为指定类型对象。 两者合起来可以构成一个双向转换关系，下面我们看一个例子： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;class dog &#123; public: // 1.转换构造函数 dog(string name) &#123;m_name = name;&#125; // 2.类型转换重载 operator string()&#123; return m_name;&#125; private: string m_name;&#125;;void s2dog(cosnt dog&amp;)&#123; // nothing;&#125;int main() &#123; string dogname = &quot;dog&quot;; // 1.转换构造函数 dog d = dogname; // ok s2dog(&quot;dog&quot;); // ok // 2.类型转换 std::cout &lt;&lt; &quot;my name is &quot; &lt;&lt; string(d) &lt;&lt; &quot;\\n&quot;; return 0;&#125; 输出： 1my name is dog 第一种隐式转换方式看起来有点让人费解： 1dog d = dogname; 它也没有重载 = ，怎么就string→dog转换了？ 这是因为dog(string name) &#123;m_name = name;&#125; 有两层含义，除了构造函数外，它还可以作为隐式转换函数，将 string 对象转换为 dog 对象。 具体过程还涉及到复制初始化（5.2.2节详解）： 表达式从右到左，构造函数dog(string)作为转换构造函数 ，编译器先创建dog临时匿名对象，使得=两边操作类型一致； 然后构造函数dog(string) ，初始化匿名对象； 编译器创建对象d ； 调用复制构造函数，匿名对象作为复制构造函数参数，初始化对象d 。 用户自定义转换有什么危险？ 隐式转换总是或多或少有点危险，用户自定义隐式转换也不例外。 比如，我们只是想声明一个构造函数，但是会自动被识别为转换构造函数——将string →dog也许并不是我们的本意 。 通常编码需避免双向隐式转换，我们开头的例子是不好的编程实践。 如果不想构造函数进行隐式转换，可以用 explicit 进行声明： 1explicit dog(string) &#123;m_name = name;&#125; 此时进行隐式转换会出错： 1string dogname = &quot;dog&quot;; // error 只能进行显示转换： 1string dogname = static_cast&lt;dog&gt;(&quot;dog&quot;); 用户自定义转换有什么好处？ 隐式转换并不是一无是处，它仍然有存在的意义。 下面声明一个Rational 有理数类，处理数字类型。 123456789101112131415161718192021class Rational &#123;public: int num; int den; // 1.构造函数隐式转换 Rational(int numerator = 0, int denominator = 1) : num(numberator), den(denominator) &#123;&#125; // 2.重载运算符* Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs) &#123; return Rational(lhs.num*rhs.num, lhs.den*rhs.den); &#125;&#125;;int main() &#123; Rational r1 = 23; Rational r2 = r1 * 2; Rational r3 = 3 * r1;&#125; 上面代码定义了一个有理数类 Rational，它的构造函数接受 2 个默认参数，分别代表分子和分母，给该构造函数传递一个参数时，Rational 具有隐式转换的特性，所以我们可以直接将数字赋值给 Rational 对象，如：Rational r1 = 23; 。 为了避免双向转换，这里并没有定义将 Rational 转换为 int 的转换函数，而当我们想实现 Rational 对象和 int 之间自由的算术运算时，我们需要定义全局的操作符重载，如上面的 operator* 定义了有理数的乘法云算符。 最佳实践 类型转换是危险的操作，使用更长的操作符（后文将提到的显式转换）提醒同事和将来的自己注意安全。 4.X.2 显式转换 显式转换主要有两个作用： 完成C++隐式转换无法完成的工作，比如范围枚举中将eunm 类型→int ； 尽可能的替代隐式转换，在程序显式的声明这是个转换操作——这很专业。 C++/C总是难以分开的，先从C中显式转换说起吧。 C风格显式转换 在标准 C 编程中，转换是通过 () 运算符完成的，类型的名称要转换的值放在括号内。 12double x = 1.5;int y = (double)x; C风格的转换格式看起来很简单，但其实有不少缺点： 转换太过随意，可以在任意类型之间转换。可以把一个指向const对象的指针转换成指向非const对象的指针，把一个指向基类对象的指针转换成一个派生类对象的指针。这些转换之间的差距是非常巨大的，但是传统的C语言风格的类型转换没有区分这些。 C风格的转换没有统一的关键字和标示符。对于大型系统，做代码排查时容易遗漏和忽略。 为此，C++ 引入了_cast强制转换运算符。 C++显式转换 C++转换风格完美的解决了C风格两个问题： 对类型转换做了细分，提供了四种不同类型转换，以支持不同需求的转换； 类型转换有了统一的标示符，利于代码排查和审查。 四种不同类型的转换分别是： static_cast，命名上理解是静态类型转换，如int转换→char，转换失败不返回NULL。 dynamic_cast，命名上理解是动态类型转换，如子类和父类之间的多态类型转换，转换失败返回NULL。 ⚠️ 所以上行转换（子类→父类）这种安全转换用static_cast是可以的，但是下行转换（父类→子类）这种不安全的转换使用dynamic_cast，失败会返回NULL，会运行时检查。 const_cast，去除const属性，如常量指针/引用转换→非常量指针/引用。 reinterpret_cast，仅仅重新解释类型，没有进行二进制的转换。 static_cast 什么时候使用static_cast？ 基本数据类型之间的转换，如把int转换为char，带来安全性问题由程序员来保证； 把空指针转换成目标类型的空指针； 把任何类型的表达式转为void类型； （不推荐）类层次结构中基类和派生类之间指针或引用的转换：上行转换（子类→父类）是安全的；下行转换（父类→子类）由于没有动态类型检查，所以是不安全的。 隐式转换都建议使用static_cast进行标明和替换。 例如，下面隐式转换都可替换为显式的static_cast转换。 123456int n = 6;double d = static_cast&lt;double&gt;(n); // 基本类型转换int *pn = &amp;n;double *d = static_cast&lt;double *&gt;(&amp;n) // 无关类型指针转换，编译错误，应该使用reinterpret_castvoid *p = static_cast&lt;void *&gt;(pn); // 任意类型转换成void类型 dynamic_cast 什么时候使用dynamic_cast？ 只有在派生类之间转换时才使用dynamic_cast，type-id必须是类指针，类引用或者void*。 使用时基类必须要有虚函数，因为dynamic_cast是运行时类型检查，需要运行时类型信息，而这个信息是存储在类的虚函数表中，只有一个类定义了虚函数才会有虚函数表（如果一个类没有虚函数，那么一般意义上，这个类的设计者也不想它成为一个基类）。 和static_cast对比有什么区别？ 下行转换，dynamic_cast是安全的（当类型失败时，转换过来的是空指针），而static_cast是不安全的（当类型不一致时，转换过来的是错误意义的指针，可能造成踩内存、非法访问等各种问题）。 dynamic_cast还可以进行交叉转换。 一个简单示例。 12345678910111213141516171819202122232425262728293031class BaseClass &#123; public: int m_iNum; // 基类必须有虚函数，保持多态性才能使用dynamic_cast virtual void foo()&#123;&#125;;&#125;;class DerivedClass: public BaseClass &#123; public: char *m_szName[100]; void bar()&#123;&#125;;&#125;; int main()&#123; BaseClass* pb = new DerivedClass(); // 子类-&gt;父类，静态类型转换，正确但不推荐 DerivedClass *pd1 = static_cast&lt;DerivedClass*&gt;(pb); // 子类-&gt;父类，动态类型转换，正确 DerivedClass *pd2 = dynamic_cast&lt;DerivedClass*&gt;(pb); BaseClass* pb2 = new BaseClass(); // 父类-&gt;子类，静态类型转换，危险！访问子类m_szName成员越界 DerivedClass *pd21 = static_cast&lt;DerivedClass*&gt;(pb2); // 父类-&gt;子类，动态类型转换，安全的。结果是NULL DerivedClass *pd22 = dynamic_cast&lt;DerivedClass*&gt;(pb2); return 0;&#125; const_cast cosnt_cast是四种类型转换符中唯一可以对常量进行操作的转换符，用来去除常量性，程序员对这个操作负责。 常量指针转换为非常量指针，并且仍然指向原来的对象 常量引用被转换为非常量引用，并且仍然指向原来的对象 注意转换类型只能是指针或引用。 12345678910111213struct SA &#123; int i;&#125;;int main()&#123; const SA ra; ra.i = 10; // error，直接修改const类型 SA &amp;rb = const_cast&lt;SA&amp;&gt;(ra); rb.i = 10; // ok，去除了常量性 return 0;&#125; reinterpret_cast 非常危险的操作符，谨慎使用。 reinterpret_cast可以在指针和引用里进行肆无忌惮的转换； reinterpret_cast可以将整型转换为指针，也可以把指针转换为数组； reinterpret_cast是从底层对数据进行重新解释，依赖具体的平台，可移植性差。 一般用来不同类型的指针或引用之间转换。 1234int a = 1;int* p_a = &amp;a;bool* p_c = reinterpret_cast&lt;bool*&gt;(p_a);std::cout &lt;&lt; *p_c&lt;&lt; &quot;\\n&quot;; // 1 最佳实践 什么时候使用显式转换？ 在所有需要转换的地方都应该尽量使用显式转换。 四种显式转换该怎么选择？ ⚠️ 除了static_cast可用于非指针、引用类型，其它转换符都必须是指针或引用。 static_cast：基本类型转换、类下行转换、空指针和其它指针的转换； reinterpret_cast：不同类型的指针类型转换； const_cast：将常量指针/引用转换为非常量指针/引用； daynamic_cast：多态类之间的类型转换。 4.X.3 类型转换补充：string 这里主要总结下上面没提到，平时又经常用到的转换： string和char等基本类型的转换； string和char[]之间转换； string和其它类型数组（比如int[]）之间的转换。 1和2在1.8.3 &amp; 1.8.4 节都已介绍过，为了完整性这里再次进行简单总结。 string↔基本类型 string不是内置类型，使用static_cast是不行的，比如int↔string。 string↔基本类型有两种方式： 使用输入、输出流作为媒介实现； 使用C++11std::string内置的相关函数实现。 为了通用性，我们先介绍 std::istringstream和std::ostringstream 作为媒介如何实现转换。 std::istringstream ，即输入流：构造函数接受数据的输入，然后使用&gt;&gt; 提取流中数据； std::ostringstream ，即输出流：使用&lt;&lt; 接受数据的输入，使用成员方法如str() 提取流中数据。 下面是具体实例。 string→基本类型 基本思路：用string对象初始化输入流 → 输入流写入&gt;&gt;其它类型中（string此时会被自动转换）。 123456789101112#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;iostream&gt;int main() &#123; std::string str = &quot;233&quot;; int a; std::istringstream iStream(str); iStream&gt;&gt;a; // 输出流自动转换 return 0;&#125; string←基本类型 基本思路：用&lt;&lt;初始化输出流 → 输出流对象调用str()方法。 1234int b = 233;std::ostringstream oStream;oStream&lt;&lt;b;oStream.str(); 好消息，C++11给广大程序员带来了福音，提供了大量已经定义好的方法。 更多介绍，可参考：c++ string和其他类型互转 但注意，char↔string的转换方法未实现，我们可使用以下方式实现转换： 1234char c = &#x27;a&#x27;;std::string str = c; // char → stringc = str[0]; // string → char 下面对常用的转换方法进行介绍。 string→基本类型 常用方法原型： 123456// string→intint stoi( const std::string&amp; str, std::size_t* pos = 0, int base = 10 );// string→longlong stol( const std::string&amp; str, std::size_t* pos = 0, int base = 10 );// string→floatfloat stof( const std::string&amp; str, std::size_t* pos = 0 ); 使用实例： 12345678# include&lt;string&gt;int main()&#123; std::string str = &quot;123&quot;; int a = std::stoi(str); int float = std::stof(str); return 0;&#125; string←基本类型 常用方法原型： 12345// 函数重载std::string to_string( int value );std::string to_string( long value );std::string to_string( float value );std::string to_string( double value ); 使用实例： 123456789# include&lt;string&gt;int main()&#123; int a = 1; std::string str1 = std::to_string(a); float b = 1.2; std::string str1 = std::to_string(b); return 0;&#125; string↔char[] string和char[]数组之间的转换比较简单，因为string内置了相关方法。 char[]← string 如果是字符串常量，C++可以隐式转换： 12char c_arr[] = &quot;royhuang&quot;; // &quot;royhuang&quot;是string类型的字符串常量，可以隐式转换 char* p_c_arr = &quot;royhuang&quot;; // 这里没发生隐式转换，但p_c_arr指向了字符串常量 对于非字符串常量，std::string同样提供了c_str() 和 data() 等方法，不过要注意： 返回类型只能是const char* ，也就是必须为常量，且是指针 12345std::string str = &quot;royhuang&quot;; const char* c_arr1 = str.c_str();const char* c_arr2 = str.data();// const char c_arr3[] = str.data(); // 非法 char[] → string string构造函数接受字符串数组：string::string(const char* szCString) 。 123char c_arr[] = &quot;royhuang&quot;; std::string str&#123; c_arr &#125;; // 构造函数 但是如果涉及到字符串分隔符，就比较麻烦点，参考下文处理。 string→其它类型数组 如果是分割每一个字符为数组元素，可以转换为：string→char[]→其它类型数组。 下面展示了：string→int[] ，这里使用了容器vector。 123456789101112131415161718# include&lt;string&gt;int main()&#123; std::string str = &quot;123456&quot;; std::vector&lt;int&gt; i_arr; i_arr.reserve(10); // tips：预先分配一些空间 // 1.先转换为char数组 const char* c_arr = str3.c_str(); // 2.char数组再转换为其它类型数组 for(char c:str3) &#123; // 注意是c-&#x27;0&#x27;，不是static_cast&lt;int&gt;(c) // c-&#x27;0&#x27;算术类型提升为int i_arr.push_back(c-&#x27;0&#x27;); &#125; return 0;&#125; string←其它类型数组，没啥意义一般很少需要。 比如： 1int a[] = &#123;45,45,67,144&#125;; 转换为454567144 有啥用呢？一般不需要这么做。更多的反而是怎么将一个int类型转换string。 12int i = 2;string str = std::to_string(i); 其实上面介绍都是很特殊的string→数组情况：分割每一个字符为数组元素。但往往我们需要处理的是如何按指定规则分割子串为数组元素： 比如，如何将： 1string str = &quot;12,45,56&quot; ; 转换为： 1int arr[] = &#123;12,45,56&#125;; 最常见的便是按指定分隔符来分割字符串为新数组元素。 string指定分割→数组 对于指定分隔符来分割字符串，再转换为数组。一般而言有如下思路： 通过string成员函数：find+substr函数； 通过C语言中分割函数：strtok函数； 通过stringstream实现。 这里主要介绍第1、第3两种方式，完整的介绍可参考：C++字符串分割方法总结 。 find函数原型： size_t find (const string&amp; str, size_t pos = 0) const;； substr函数原型： string substr (size_t pos = 0, size_t len = npos) const; 。 以string→int[]为例 。 通过find+substr函数 12345678910111213141516171819202122232425262728#include &lt;string&gt;#include &lt;vector&gt;void strSplit(const std::string src_str, vector&lt;int&gt;&amp; vec, const char pattern)&#123; std::string str = src_str; str += std::string(pattern); // 方便处理最后一个字符串 size_t pre_pos = 0; size_t pos = str.find(pattern); while (pos != str.npos) // 如果没找到分隔符则终止 &#123; string temp = str.substr(pre_pos,pos); vec.push_back(std::stoi(temp)); // 保留剩下的字符串作为新串 str = str.substr(pos+1,str.length()); // 查找新字符串第一个分隔符的位置 pos = str.find(pattern); &#125; &#125;int main() &#123; std::string str = &quot;12,45,56&quot; ; std::vector&lt;int&gt; vec; strSplit(str,vec,&#x27;,&#x27;); return 0;&#125; 通过stringstream 这种方式更为简单。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;sstream&gt;void strSplit(const std::string src_str, vector&lt;int&gt;&amp; vec, const char pattern)&#123; std::stringstream input_ss(src_str); std::string sub_str&#123;&#125;; // sub_str接受返回的子串 while (getline(input_ss, sub_str, pattern)) // getline分割字符串 &#123; vec.push_back(std::stoi(sub_str)); &#125;&#125;int main() &#123; std::string str = &quot;12,45,56&quot; ; std::vector&lt;int&gt; vec; strSplit(str,vec,&#x27;,&#x27;); return 0;&#125; leetcode实战 以经典题型为例，将下面转换为多维数组，第一行输入的是长度。 3 11 12 13 14 15 16 17 18 19 完整实现代码如下：可见关键是如何实现分割字符串的函数（面试时这种常用函数最好直接背下）。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;sstream&gt;void strSplit(const std::string src_str, vector&lt;int&gt;&amp; vec, const char pattern)&#123; std::stringstream input_ss(src_str); std::string sub_str&#123;&#125;; // sub_str接受返回的子串 while (getline(input_ss, sub_str, pattern)) // getline分割字符串 &#123; vec.push_back(std::stoi(sub_str)); &#125;&#125;int main()&#123; int N = 0; // std::getline(std::cin,N); // getline不能接受类型int的参数，所以这里不使用 std::cin&gt;&gt;N; std::cin.ignore(); // 但是cin要处理换行符，getline不需要处理这个问题 std::vector&lt;vector&lt;int&gt;&gt; vec ; // vector比内置数组好用 for(int i=0; i&lt;N; i++) &#123; std::string input_str; // 读取一行字符串 std::getline(cin,input_str); vector&lt;int&gt; vec_tmp ; strSplit(input_str,vec_tmp,&#x27;,&#x27;); // 分割该行字符串 vec.push_back(vec_tmp); &#125; return 0;&#125; 最佳实践 不涉及到数组： 如果是基本类型之间的互转，隐式转换虽然也可以实现，但最好使用static_cast显式转换； 不过需要注意char↔int之间的转换，也许你并不需要char类型的ASCII值。 如果是指针、引用、多态、常量转非常量之间的转换，请使用显示转换； 如果string和基本类型转换，使用std::string 内置的函数库效率最高。 涉及到数组： 如果是string↔char[]，不涉及到分割子串，使用std::string 内置函数可以很方便进行转换； 如果是string→其它类型数组（单向，反向没多大意义），不涉及到分割子串 ，按string→char[]→其它类型数组转换即可； 如果是string→其它类型数组（单向），涉及到分割子串 ： 先借助find和substr函数切割出子串数组（string[]）； 再将每个子串转换为其它类型（内置函数实现，如stoi）。 最后，请尽量避免使用隐式转换。 更新记录 2022-01-22 ：更新笔记 第一次更新 参考资料 1.C++中已经有面向对象的概念，那struct还有啥存在的意图：https://www.zhihu.com/question/23174488 ↩2.C++中四种强制类型转换区别详解：https://blog.csdn.net/chen134225/article/details/81305049 ↩3.没有学不会的C++：用户自定义的隐式类型转换 ：https://juejin.cn/post/6844903798100459533 ↩","categories":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/categories/C/"},{"name":"从零开始","slug":"C/从零开始","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"},{"name":"C++基础","slug":"C/从零开始/C-基础","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/tags/C/"},{"name":"教程","slug":"教程","permalink":"https://hwh.zone/tags/%E6%95%99%E7%A8%8B/"},{"name":"C++基础","slug":"C-基础","permalink":"https://hwh.zone/tags/C-%E5%9F%BA%E7%A1%80/"},{"name":"结构体","slug":"结构体","permalink":"https://hwh.zone/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"枚举","slug":"枚举","permalink":"https://hwh.zone/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"类型转换","slug":"类型转换","permalink":"https://hwh.zone/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"}]},{"title":"C++从零开始（三）：务实基础（上）快速入门","slug":"C++从零开始（二）：务实基础（上）之快速入门","date":"2022-01-16T12:56:08.897Z","updated":"2022-06-16T07:32:33.557Z","comments":true,"path":"p/26224/","link":"","permalink":"https://hwh.zone/p/26224/","excerpt":"","text":"🌟《C++从零开始》 系列，开始更新中… C++从零开始https://hwh.zone/p/62712 一、快速开始 1.1 认识C++ 1.1.1 为什么需要C++ 前有Java后有Python、Go、Rust，C++作为一个“老古董”似乎有点格格不入了？ 其实不然，C 和 C++ 的底层设计理念可以概括为“信任程序员”——这既美妙又危险。但也正是C++ 允许程序员高度自由地做他们想做的事，因此，在需要高性能和精确控制内存和其他资源的情况下表现出色 。 例如，下面是C++擅长的一些领域，它们对性能要求通常极其苛刻： 视频游戏 实时系统（例如用于运输、制造等……） 高性能金融应用（例如高频交易） 图形应用和模拟 生产力/办公应用 嵌入式软件 音视频处理 人工智能和神经网络 如果你想更了解计算机的本质，也对这些领域感兴趣，C/C++应该是你不二的选择。 1.1.2 C++组成 标准的C++由两个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等，包含标准模板库（STL），提供了大量的方法，用于操作数据结构等。 C++ 标准库简单来说就是提供一些预定的库及函数，方便我们编写代码。整体可以分为两部分： 标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的，函数库继承自 C 语言。 输入/输出 I/O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数 面向对象类库： 这个库是类及其相关函数的集合。 标准的 C++ I/O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库 同时，为了编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译， C++ 采用ISO标准。 ISO标准发展历史一览如下： 1.1.3 第一个C++程序 🖱 从梦开始的地方，写一个经典hello.cpp 。 12345678910#include &lt;iostream&gt;using namespace std; /* main() 是程序开始执行的地方 */ int main()&#123; cout &lt;&lt; &quot;Hello World&quot;&lt;&lt;endl; // 输出 Hello World return 0;&#125; 确保g++程序可被识别（加入到环境变量中），在包含源文件 hello.cpp 的目录中，编译并执行： 123$ g++ hello.cpp$ ./a.outHello World g++编译代码的方式将在本文大量使用，在前文：g++/Makefile/CMake快速入门 ，我们也仔细介绍过。如果还不太了解，可以一读。 在上述程序中还使用了C++的注释： 单行注释：// 注释内容 多行注释：/* 注释内容 */ 特别的，在 /* */ 注释内部，// 字符没有特殊的含义；在 // 注释内，/* */ 也没有特殊的含义。 1.2 变量 “变量”一词来源于数学，是计算机表示能储存计算结果或能表示值的抽象概念，但这种说法不够深刻。 应该从CPU角度理解，变量就是某块内存区域地址别名，这块内存区域保存变量的值。下面举一个实例： 12int x = 0;x = 1; 对应汇编代码： 12movl $0, -12(%rbp)movl $1, -12(%rbp) 当CPU执行int x = 0，会在内存（这里是栈）腾出一块区域（-12(%rbp)）用来存储变量x；然后x所代表的内存区域（-12(%rbp)）被存入0。 继续执行x=1，1被存入变量x所代表的内存区域。 可以看到，变量的存在使得我们：不用记住为分配x的内存地址是什么，我们通过变量名x就可以使用分配的内存区域。因为使用x时，编译器会将变量x隐式自动翻译成对应的内存地址，同时进行间接寻址（可以理解为使用x等价于*x）。 12int x = 0; // 编译器眼里：int* x = -12(%rbp); *x = 0;x = 1; // 编译器眼里： *x = 1; 说完深层次的概念，我们来了解变量基本的一些定义&amp;使用。 123456789101112/* a simple example*/#include &lt;iostream&gt;using namespace std;extern char c, ch; // char类型变量c,chint months; // int类型变量months/* main() 是程序开始执行的地方 */int main()&#123; int empoly_salary = 20000; // int类型变量empoly_salary return 0;&#125; 可以看到组成变量的基本三要素：名称、类型及值。 名称：变量的名称可以由字母、数字和下划线字符组成。 类型：用于指定变量存储的大小和布局。在C++中有基本类型和其它的如枚举等类型。 基本类型：C++ 七种基本数据类型如下。 类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 其它类型 C++ 也允许定义各种其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等。这是我们后续笔记会继续提到的知识点。 在上面我们提到了变量三要素：名称、值和类型。由此可以引发几个小问题： C++变量名称有什么命令规则或规律吗？ C++不同的位置（如，main函数体内、外）定义的变量有什么区别吗？ C++的变量存储有上限吗？比如int类型的变量最多可以存储多大的数据？ 实际写代码中，变量不一定立马给它赋值（初始化），变量的初始化值会是什么呢？为什么常说变量不初始化是一个不好的行为？ 1.2.1 标识符和命令规则 C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。 C++ 标识符内不允许出现标点字符，比如 @、&amp; 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，Manpower 和 manpower 是两个不同的标识符。 下面列出几个有效的标识符： 12mohd zara abc move_name a_123myname50 _temp j a23b9 retVal 1.2.2 局部变量和全局变量 一般来说有三个地方可以声明变量： 函数或一个代码块内部，称为局部变量； 函数参数中，称为形式参数； 所有函数外部，称为全局变量。 在之前的例子中： 12345678910111213/* a simple example*/#include &lt;iostream&gt;using namespace std;// main函数体外，全局变量extern char c, ch; int months; int main()&#123; int empoly_salary = 20000; // main函数体内，局部变量 return 0;&#125; 【扩展思考】特别的，如果局部变量和全局变量的名称相同，调用时以谁的值为准？ 答案：以局部变量值为准，请看下例。 1234567891011121314#include &lt;iostream&gt;using namespace std;// main函数体外，全局变量extern char c, ch; int months; int empoly_salary = 24000; int main()&#123; int empoly_salary = 20000; // main函数体内，局部变量 cout&lt;&lt; empoly_salary&lt;&lt;endl; return 0;&#125; 代码输出值：20000。局部变量的值会覆盖全局变量的值。 【深入总结】全局变量和局部变量的区别和总结 声明位置不同：局部变量声明在函数或代码块内部；全局变量声明在所有函数的外部。 生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在； 使用方式不同：通过声明后全局变量在程序的各个部分都可以用到，分配在全局数据段并且在程序开始运行的时候被加载；局部变量分配在堆栈区，只能在局部使用。 1.2.3 变量类型 七种基本类型 在前面我们提到： 变量其实只不过是程序可操作的存储区的名称，类型决定了变量存储的大小和布局。 C++有七种基本类型 类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 这些基本类型可以使用一个或多个类型修饰符进行修饰： signed、unsigned、short、long 例如， wchar_t 是这样来的： 1typedef short int wchar_t; 所以 wchar_t 实际上和 short int 一样。 每种类型需占用不同的字节数，存储上下限如下所示： 类型 描述 取值范围 字节数 int 整型，表示整数 -2^-31^ ~ 2^31^-1 4 unsigned int 无符号整型，表示整数 0 ~ 2^32^-1 4 bool 布尔类型 true或false 1 char 字符类型，是整型 -128~127 1 unsigned char 无符号字符类型，是整型 0~255 1 float 单精度浮点值，表示实数 3.4×10^-38^ ~ 3.4×10^38^ 4 double 双精度浮点值，表示实数 1.7×10^-308^ ~ 1.7×10^308^ 8 long 长整型 -2^-31^ ~ 2×10^31^-1 4 unsigned long 无符号长整型 0 ~ 2^32^-1 4 unsigned long long 无符号长整型，64位 0 ~ 2×10^64^-1 8 short 短整型 -2^-15^ ~ 2^15^-1 2 unsigned short 无符号短整型 0 ~ 2^16^-1 2 如何比较浮点变量？ 这是一个很有意思的小问题，它涉及到计算机一些底层表示。 永远不要使用== 比较两个浮点变量，因为计算机不能精确表示非2的指数幂小数。 你或许表示疑问：直接==比较不可以吗？ 12345678910float a = 2.33;float b = 2.33;if( a == b)&#123; std::cout&lt;&lt;&quot;不相等&quot;&lt;&lt;std::endl;&#125;else&#123; std::cout&lt;&lt;&quot;相等&quot;&lt;&lt;std::endl;&#125; 输出： 1相等 — 这没毛病啊老铁？ 不，老铁问题大的很勒！ 下面比较便出现了意料之外的结果。 1234567891011float a = 2.33;float b = 2.34;if((b-a) == 0.01)&#123; std::cout&lt;&lt;&quot;相等&quot;&lt;&lt;std::endl;&#125;else&#123; std::cout&lt;&lt;&quot;不相等&quot;&lt;&lt;std::endl;&#125; 输出： 1不相等 这是因为b 、a 在底层二进制中不能精确表示，只能无限趋近。实际存储中，计算机只会截断保留一定长度的二进制数，并不能精确表示浮点数 。 以IEEE 754标准为例，单精度（总32位）尾数保留23位，其余指数8位，符号位1位（在线转换地址）。 在浮点运算中，计算机也是使用二进制进行计算： 最开始a=b=2.33 ，判断a=b 是否相等：计算机通过对比每一个bit ，因为b 和a 底层二进制表示相等，所以直接比较两个相等浮点数不会出错； 但是如果是a-b ，浮点数参与了运算：因此操作数b 和a 本来就是不精确的二进制表示，计算出来的二进制结果自然无法精确表示的0.01。 100111100001000111101011100001010 # 32位，0.01对应二进制表示 所以参与了运算的浮点数b-a 再和0.01 比较出错。 但也并不是所有的浮点数都不能精确表示，2的整数冥的浮点数便可以精确表示。 IEEE 754存储标准如下。 根据标准，0.5=1.0∗2−10.5=1.0*2^{-1}0.5=1.0∗2−1 ，显然0.5 可以被精确表示。 1.2.4 变量初始化🌟 初始化是指声明变量但没有定义它（没有指定初值）时，编译器进行的默认初始化（赋值）操作。 先讲讲上述概念中出现的新名词，“声明”和“定义”。 声明和定义的区别？ 说清楚这个问题，要分变量和函数两个方面讨论。 声明可以多次，定义只能有一次。 如果是变量。 声明（一般在.h文件中）：仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间； 12extern int a ; // 仅声明，别处定义extern int b = 10; // 声明，同时进行定义，为变量b分配了空间且存储了值10 ⚠️ 注意如果不是extern关键字修饰的变量，C++中的变量声明时编译器会自动定义（默认初始化）。 下面进行举例说明。 12 /*other.h*/int a; // 声明+定义（存储值0） 如果有多个.cpp 文件include “other.h” ，会重复定义多次a（定义只能有一次）。 main.cpp 1234567 #include &lt;iostream&gt; #include &quot;other.h&quot; // 引入头文件other.h，变量a被定义一次, using namespace std; int main() &#123;&#125; other.cpp 1#include &quot;other.h&quot; // 引入头文件other.h，变量a被定义一次 尝试编译出错： 123[root@roy-cpp test]# g++ -std=c++11 main.cpp other.cpp -o main.out /tmp/cc2DsgGi.o:(.data+0x0): multiple definition of `a&#x27;/tmp/ccDlbvUg.o:(.data+0x0): first defined here 更糟糕的是，此时采用ifndef防止预编译重复定义没有用，更多ifndef 解释参考：C++防止头文件被重复引入的3种方法 。 1 /other.h/ #ifndef OTHER_H #define OTHER_H int a; #endif 12因为此时`main.cpp` 、`other.cpp` 是分别编译的，`main.cpp` 中的`define OTHER_H` 对`other.cpp` 不起作用。 为了避免这种问题，为了避免这种问题我们只有将头文件中变量声明为extern： 1extern int a; 再次编译正常： 1[root@roy-cpp test]# g++ -std=c++11 main.cpp other.cpp -o main.out main.cpp 和 other.cpp 都是拥有a的声明，声明可以多次。 定义（一般在.cpp文件中）：要在定义的地方为其分配存储空间，相同变量可以在多处声明（外部变量extern），但只能在一处定义。 1int a; // 声明也是定义，编译器默认初始化 如果是函数。 声明（一般在.h文件中）：把函数的位置、参数和返回类型等信息告诉编译器； 1int Max(int x, int y); 函数定义不会被默认初始化，故无需extern。 定义（一般在.cpp文件中）：在源文件中实现具体函数，并为其分配内存。 1234int Max(int x, int y) &#123; return x &gt; y ? x : y;&#125; 最佳实践：头文件里应该放什么？ 参考：muduo 中做法。 在头文件test.h中： 全局变量：注意用extern关键字修饰，只声明。 1extern int a; 函数：只声明 1int Max(int x, int y); 如果是内联函数可直接定义。 1234inline void func()&#123; // do something&#125; 内联函数会被直接替换，不用担心重复定义的问题。 结构体：声明+定义。 1234struct S&#123; bool isOK;&#125;; 由于结构体已经被定义，如果有多个.cpp 文件 include了test.h 容易出现重复定义。这也是为什么开源文件中往往在.h 文件中使用#ifndef 避免头文件被重复引入。 1234567#ifndef XXX_H#define XXX_Hstruct S&#123; bool isOK;&#125;;#endif 类：类声明+定义，内部成员只声明。 同上，需注意使用#ifndef 。 123456789class MyClass&#123; public: int get_value(); private: int value;&#125;; 普通成员函数（普通构造函数或析构函数、访问函数等）建议在类中（头文件）定义；重要的成员函数应在与类同名的 .cpp 文件中定义。 其它：define宏定义。 在源文件test.cpp中： 实现test.h相关定义。 12345678910111213141516# include &quot;test.h&quot;int a = 1; // 定义变量int Max(int x, int y) // 定义函数&#123; return x &gt; y ? x : y;&#125;// 定义结构体成员// 不用，直接使用即可// 定义类成员（往往是重要的类成员函数）int MyClass::get_value()&#123; return value;&#125; 默认初始化 变量值声明时的初始化值不仅和变量的类型有关系，也和变量声明的位置有关系： 对于内置类型变量（如 int ，double，bool等） 函数体之外的变量：会进行&quot;零值初始化&quot; ； 函数体之内的变量：此时该变量是未定义值，在一些IDE中如VS2017使用会报错；在一些编译器中如VSCode2020可以被使用，部分会被初始化，部分指向内存中“野值”； 静态变量（包括局部静态变量）：进行&quot;零值初始化&quot;。 对于类成员变量（Class）： 原生类型：int类型或者指针类型等，他们不会被初始化。但是，他们会使用类实例内存地址中任何已经存在的野值作为自己的值； 对象类型：如string类型，默认构造器会被调用初始化为空串&quot;&quot;； 引用类型：无法通过编译。 对于以上描述我们进行实例验证。 【实例】不同情况初始化验证。 我们先给出各种情况下总结，具有验证请查看下方代码。 int/float/double bool string/char 指针 引用 局部变量 野值 0 &quot;&quot;，'' 野值 出错 全局变量/静态变量 0 0 &quot;&quot;，'' 0 出错 类成员 野值 野值 &quot;&quot;，野值 &quot;&quot;/野值 出错 以下是实际代码验证。 函数体外变量函数体内变量静态变量类成员变量 函数体外变量 可以看到，函数体外的所有变量（全局变量）都已经被零值初始化：整数/浮点类型/指针初始化为0；字符串类型被初始化空串。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;// 1.数值类型int num; // 0 float f; // 0double d; // 0// 2.bool 类型bool b; // 0// 3.字符串类型string str; // &quot;&quot; char c; // &#x27;&#x27;// 4.指针: 零值// 旧版本C++, 0 成为指示无效内存位置值string *str_ptr; // 0int *ptr; // 0// 5.引用：出错string &amp;str_ref; // error: not initializedint &amp;int_ref; // error: not initializedint main()&#123; // 打印测试代码略 return 0;&#125; 函数体内变量 VSCode（g++ 4.6+）中给部分局部变量进行了“初始化”，直接使用并未报错。但是，浮点类型和指针的值都指向了野值。 函数体内变量变量不初始化，是个危险且错误的编程行为，使得代码很难调试。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;int func()&#123; // 1.数值类型 int num; // 野值：9.88131e-324 float f; // 野值：5.88128e-39 double d; // 野值：2.07385e-317 // 2.bool 类型 bool b; // 0 // 3.字符串类型 string str; // &quot;&quot; char c; // &#x27;&#x27; // 4.指针: 零值 // 指针指向内存中随机地址值，这非常危险 string *str_ptr; // 0x400a10 int *ptr; // 0x400be0 // 5.引用：出错 string &amp;str_ref; // error: not initialized int &amp;int_ref; // error: not initialized&#125;int main()&#123; // 打印测试代码略 return 0;&#125; 静态变量 特别的，静态变量不论是局部静态变量还是全局静态变量都会进行零值初始化。初始化规则同全局变量。 ❓ 局部静态变量，每次进入函数都会被初始化吗？ 静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序main执行之前，编译器已经为其分配好了内存，即只会被初始化一次。 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int count_calls() &#123; // 主程序执行就已被初始化 // 后续进入函数不会再执行初始化变为0 static int ctr; // 默认初始化为 0 return ++ctr;&#125;// 这段程序将输出从 1 到 10 的数字。int main() &#123; for(int i=0; i != 10; ++i) &#123; cout &lt;&lt; count_calls() &lt;&lt; endl; &#125; return 0;&#125; 类成员变量 可以看到，类成员变量值如果不给定初始化：基本类型变量指向野值；引用类型会非法警告。 但是，对象类型string会被“零值初始化”（空串）。这是因为string类型的默认构造函数被调用，而string的默认构造会将string类型值初始化为空串。 显然，类成员变量最好在使用前进行初始化。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class test&#123; public: // 1.数值类型 int num; // 野值：1760379232 float f; // 野值：4.59149e-41 double d; // 野值：4.59149e-41 // 2.bool 类型 bool b ; // 野值：2 // 3.字符串类型 string str; // &quot;&quot; 空,对象类型，会调用string构造函数初始化，所以是&quot;&quot; char c; // 野值 // 4.指针 // 指针指向内存中随机地址值，这非常危险 string *str_ptr; // 0 int *ptr; // 0x400d00 // 5.引用：出错 string &amp;str_ref; // not initialized int &amp;int_ref; // not initialized public: // 默认构造函数：不做任何操作 test() &#123;&#125;;&#125;;int main()&#123; test t; // 打印测试代码略 return 0;&#125; 1.3 关键字 在前面的例子，多次见到的extern关键字是什么意思呢？ 1extern char c, ch; 在这之前，我们先简单介绍一下什么是关键字，有个整体的概念和了解。 关键字是预定义的单词，对编译器具有特殊的含义。例如，前面我们看到的int、float等基本变量类型也是关键字的一部分。 下表列出了 C++ 中的关键字。这些关键字不能作为常量名、变量名或其他标识符名称。 本节主要介绍存储类相关关键字。 存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期，这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类： extern static mutable thread_local (C++11) 特别的，从 C++ 11 开始，auto 关键字不再是 存储类说明符，但auto是c++11中非常优雅的关键字。为了更好的说明它的作用，在3.X节中会正式提到它。 1.3.1 extern关键字 extern顾名思义，外面的、外来的。 extern 可以置于变量或者函数前，扩展变量/函数的定义域： 第一种情况，首先将声明的变量/函数作用域，从声明扩展到本文件结束；如果依旧未找到定义转情况二。 第二种情况，声明变量/函数定义在其它文件中，在链接时会在其它文件寻找其定义（这样在编译时，本文件未找定义也不报错）。 分别举两个例子说明两种情况。 第一种情况，变量在本文件定义 【例1】变量声明后不想立即初始化，在调用后才会进行初始化。如何在调用时就获取正确的值？ 使用 extern 关键字对变量c, ch 作“外部变量声明”，使作用域扩展到从声明开始到本文件结束 ，这样编译器就会在本文件其它区域寻找其定义。 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; // 作用域扩展到文件结尾 extern char c, ch; cout&lt;&lt;c&lt;&lt;endl; cout&lt;&lt;ch&lt;&lt;endl; return 0;&#125;// 真正定义的地方char c=&#x27;h&#x27;, ch=&#x27;H&#x27;; 输出： 1234[root@roy-cpp test]# g++ -std=c++11 main.cpp other.cpp -o main.out[root@roy-cpp test]# ./main.out hH 而如果没有使用extern关键字，输出为空（默认初始化的值）： 1 如果本文件没找到定义，extern还会去其它文件中寻找定义。 第二种情况，变量在其它文件定义 c, ch是在别的文件中声明 【例2】变量c, ch 是在别的.cpp文件中声明的，但又需要在 main 函数中调用它们（引入头文件中也没有它们的定义）。 使用extern关键字声明即可解决，这样编译阶段不会出错，链接时会去寻找它们的定义（如果extern修饰函数/类等效果等同前向声明，3.1.1节）。 main.cpp 123456789101112#include &lt;iostream&gt;using namespace std;// 声明外部变量，头文件中也没有c,ch的定义extern char c, ch; int main()&#123; cout&lt;&lt;c&lt;&lt;endl; cout&lt;&lt;ch&lt;&lt;endl; return 0;&#125; other.cpp 1char c=&#x27;h&#x27;, ch=&#x27;H&#x27;; 没使用extern关键字声明编译会出错，使用后编译正常： 12g++ -std=c++11 main.cpp other.cpp -o main.out./main.out 输出： 12hH 不过这个做法有点刻意，根据我们之前的最佳实践，声明和定义最好分开。变量c, ch 应该声明在.h文件中。 此时extern关键字的作用是告诉编译器， other.h 变量a定义在别处/文件中。 main.cpp 12345678910#include &lt;iostream&gt;#include &quot;other.h&quot; // 引入头文件using namespace std; int main()&#123; cout&lt;&lt;c&lt;&lt;endl; cout&lt;&lt;ch&lt;&lt;endl; return 0;&#125; other.h 1extern char c, ch; // 只声明 other.cpp 1char c=&#x27;h&#x27;, ch=&#x27;H&#x27;; // 实际定义 编译正常： 123[root@roy-cpp test]# g++ -std=c++11 main.cpp other.cpp -o main.out h H 最佳实践：什么时候使用extern和头文件 引入头文件就可以使用在其它文件的变量/函数/类，为什么还需要extern？ extern将声明、定义分离。extern可以用于头文件把全局变量的声明和定义分离，避免重复定义； 只需要使用个别其它文件的变量/函数等。有时候我们只想使用头文件定义的个别变量/函数，但是这样不得不引入头文件所有的相关变量/函数等声明。在大项目编译中，过度使用头文件会让编译速度显著变慢。 这里我们没有include “other.h” , 因为我们只需要它的Max 函数，使用extern关键字即可。 C++和C代码混编时。 下节说明。 extern “C” extern关键字还可用于extern “C”，使得C和C++混编不会出错，它有两层含义： 声明的变量是extern的，它只是在这里声明，定义在别的地方； 声明的变量按C方式进行编译。 第2点是本节的核心内容。 ⚠️ 以下情况仅在用gcc编译代码时出现，g++编译不会出错（节末解释）。 准备三个文件：a.c、a.h、main.cpp ，在main.cpp中调用a.c中的函数printHello 。 尝试gcc编译： 很不幸报错了： 1main.cpp:(.text+0x5): undefined reference to `printHello()&#x27; 链接过程中找不到符号 printHello ，为什么会这样？ 这是因为gcc 对 cpp和c代码变量的符号处理不同导致的。 我们知道从代码到可执行程序需要经过，预编译→编译→汇编→链接，其中编译和链接大致如下： 编译：代码展开、语法检查，还包括将变量转成符号； 链接：将未定义的符号，解析重定位到其定义实现的地方。 查看a.o链接前的符号表： 1234[root@roy-cpp test1]# gcc -c a.c -o a.o[root@roy-cpp test1]# nm a.o0000000000000000 T printHello U puts a.c 编译后的符号名（printHello）和代码中的定义一样。 再查看main.o链接前的符号表： 123[root@roy-cpp test1]# nm main.o0000000000000000 T main U _Z10printHellov main.cpp 编译后printHello符号名变为_Z10printHellov ，这是什么鬼？ 对于C++代码：如果是数据变量并且没有嵌套，符号名也是本身；如果变量名有嵌套（在名称空间或类里）或者是函数名，符号名就会按如下规则来处理。 符号以_Z开始； 如果有嵌套，后面紧跟N，然后是名称空间、类、函数的名字，名字前的数字是长度，以E结尾； 如果没嵌套，则直接是名字长度后面跟着名字； 最后是参数列表，v 表示void。 因为main.cpp 的符号_Z10printHellov 是未定义的，它需要解析重定位到定义的地方，也是a.o 中。但显然符号_Z10printHellov 和 printHello 不同，因此链接时在a.o找不到相关符号导致报错，无法正确重定义： 1main.cpp:(.text+0x5): undefined reference to `printHello()&#x27; 这个时候extern “C” 就派上用场了：在C++文件指定代码/头文件按C的方式进行编译。 将a.h 修改如下： 12345678#ifdef __cplusplus extern &quot;C&quot;&#123; #endifvoid printHello();#ifdef __cplusplus&#125;#endif 再次查看main.o 符号表： 1234[root@roy-cpp test1]# gcc -c main.cpp -o main.o[root@roy-cpp test1]# nm main.o0000000000000000 T main U printHello 一切正常。整个过程详细变化如下： gcc 根据main.cpp 文件名后缀识别为cpp文件； 预编译：将main.cpp 中 \\#include &quot;a.h&quot; 展开，因为cpp文件都会存在宏定义__cplusplus，所以#ifdef __cplusplus 成立。最终展开为： 123extern &quot;C&quot;&#123; void printHello();&#125; 编译：编译到 extern “C”{…} 中的变量printHello 按C方式编译成符号printHello 。 再次尝试编译也确实正常输出了： 123[root@roy-cpp test1]# gcc main.cpp a.c -o main.out[root@roy-cpp test1]# ./main.out hello C ! 但是g++编译不使用extern “C”汇编C和C++代码也不会出错 ，因为g++将c或cpp代码都按cpp方式编译。 下面是测试。 查看此时a.c编译后的a.o 符号表（cpp风格）： 1234[root@roy-cpp test1]# g++ -c a.c -o a.o[root@roy-cpp test1]# nm a.o U puts0000000000000000 T _Z10printHellov 1.3.2 static关键字 static关键字常于各种面试题、书籍中，为什么需要static关键字？为什么它如此重要？ 我们从面向过程和面向角度两个角度分析。 面向过程角度 一、作用域隐藏。当一个工程有多个文件的时候，用static修饰的函数或变量只能够在本文件中可见，文件外不可见。 对比全局变量/函数：全局变量/函数访问具有全局性，其它文件通过extern关键字或引用头文件，是可以使用本文件中定义的全局变量/函数。 但有时我们并不希望这样，因为这暴露了我们不想暴露的变量/函数，这个时候static可以更好的限定作用范围。 由此还引申另外一个好处：不同的人编写不同的函数时，不用担心是否会与其它文件中的函数同名，因为同名也没有关系（限定作用范围在本文件内）。 下面我们通过两个小例子来理解。 例子1：静态变量 可以看到，静态static变量即使被extern关键字修饰，依旧不能被其它文件引用。 12345678910111213141516171819/*other.cpp*/int global_var = 1;static int static_var = 1;/*main.cpp*/#include &lt;iostream&gt;using namespace std;extern int global_var;extern int staic_var;int main()&#123; // 编译正确，other.cpp中的global_var被正确打印输出 cout&lt;&lt;global_var&lt;&lt;endl; // 编译错误，undefined reference to `staic_var&#x27; cout&lt;&lt;staic_var&lt;&lt;endl; &#125; 例子2：静态函数 将静态函数static_func 定义在other.h （实现在other.cpp），无法通过编译：undefined reference to static_func()。 1234567891011121314151617181920212223242526272829/*other.h*/static int static_func();int global_func();/*other.cpp*/#include &lt;iostream&gt;using namespace std; static int static_func() &#123; cout&lt;&lt;&quot;i am static_func in other.cpp&quot;&lt;&lt;endl; &#125; int global_func() &#123; cout&lt;&lt;&quot;i am global_func in other.cpp&quot;&lt;&lt;endl; &#125;/*main.cpp*/#include &lt;iostream&gt;#include &quot;other.h&quot; using namespace std;int main()&#123; // 出错：undefined reference to &#x27;static_func()&#x27; global_func(); static_func();&#125; 尝试编译出错： 1g++ -std=c++11 main.cpp other.cpp -o main.out 但如果我们不使用头文件，static_func可以被成功使用？ 123456789101112131415161718192021222324/*other.cpp*/#include &lt;iostream&gt;using namespace std;static int static_func() &#123; cout&lt;&lt;&quot;i am static_func in other.cpp&quot;&lt;&lt;endl; &#125;int global_func() &#123; cout&lt;&lt;&quot;i am global_func in other.cpp&quot;&lt;&lt;endl; &#125;/*main.cpp*/#include &lt;iostream&gt;#include &quot;other.cpp&quot;using namespace std;int main()&#123; // 均被正确执行了 global_func(); static_func(); &#125; 这是因为此时static_func 已经被视为在同一个文件中。 注意到： 头文件 #include &quot;other.cpp&quot; ，预编译时直接替换为 other.cpp 中内容， 相当直接在main.cpp 定义了static_func 。同一个文件中调用静态函数static_func自然是可以的。 预编译后的文件如下所示。 而之前生成的预编译文件是不会包含静态函数的定义（只有头文件other.h中的静态函数声明），所以实际定义还是在别的文件（other.cpp）中，因此调用时会出错。 所以我们在g++编译时都不用把other.cpp作为源文件（预编译时已经替换了）。 二、全局生命周期。用static修饰的变量或函数生命周期是全局的（即使是局部静态变量），存储在静态数据区（全局数据区）。 即在main函数执行前就会被初始化。 我们举两个实例，来更好的理解“全局生命周期”这个概念。 例1，在normal_add函数中定义了局部变量count ，每次函数退出，count也随之销毁。所以每次打印的都是进入函数初始化后的值+1。 1234567891011121314151617#include &lt;iostream&gt; using namespace std; static int i ; // 全局访问性，全局生命周期 int normal_add() &#123; int count = 0; // 局部访问性，局部访问周期 return ++count; &#125; int main() &#123; for(int j = 0 ; j &lt; 3 ; j++) cout&lt;&lt; normal_add()&lt;&lt;endl; return 0; &#125; 例2，在static_add 中定义了局部静态变量count 。它只会被初始化一次（内存只被分配一次，见下例解释），随着函数退出也不销毁，保持最新的值。 123456789101112131415161718#include &lt;iostream&gt; using namespace std; static int i ; // 全局访问性，全局生命周期 int static_add() &#123; static int count = 0; // 局部访问性，局部访问周期 return ++count; &#125; int main() &#123; // 虽然多次（3次）进入了函数static_add // 但count只在第一次进入函数被初始化了一次 for(int j = 0 ; j &lt; 3 ; j++) cout&lt;&lt; static_add()&lt;&lt;endl; &#125; 三、初始化零值。 static修饰的（局部/全局）变量和全局变量一样，不显示定义时会进行零值初始化。 面向对象角度 一、类只拷贝一份。类中static修饰的静态数据成员或静态成员函数是属于类的，所有对象只有一份拷贝，因此它的值可以被所有对象更新，在类未实例化就可以使用。 特别的， static类对象必须要在类外进行初始化，因为static修饰的变量先于对象存在。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;class test&#123;private: static int i;public: static int j;&#125;;int test::i = 0;int test::j = 0;int main()&#123; // 1.类未实例化就可以被使用 // 2.static 像普通类成员可以被修饰为private // test::i = 1; // 访问错误，私有静态变量 test::j = 1; // 访问正确，公有静态变量 // 3.所有对象只有一份拷贝，更新的同一块存储区域 // 但如果是普通类数据成员，下面输出都是1。 test a, b ,c ; cout&lt;&lt;++a.j&lt;&lt;endl ; // 2 cout&lt;&lt;++b.j&lt;&lt;endl ; // 3 cout&lt;&lt;++c.j&lt;&lt;endl ; // 4&#125; 这种特性可以很好的实现类多个对象的变量共享。 在后面面对对象笔记中，有机会我们还会更深入探讨下static的用法，比如与虚函数的关系。 最后，总结下全局变量和静态变量。 全局变量/函数和static变量/函数的区别？ 存储方式。全局变量/函数和static变量/函数都是静态存储方式，存储在全局数据区。 作用域。全局变量/函数是可见性全局性，其它文件中可通过extern关键字/引用头文件，来进行使用，但静态变量/函数只能在本类使用。 初始化。staic变量/函数只被初始化一次，但全局变量则不然可以被初始化多次。 面对对象。类静态成员、函数只被拷贝一份，为全对象共享。 1.4 常量 在前面我们认识的“变量”，即意为“变化可被修改的值”，灵活性强。 在C++中还存在“常量”，即“不希望被修改的值”，定义以后无法被修改。 如何定义一个常量？ 1.4.1 定义常量 🖋 把常量定义为大写字母形式，是非常好的编程实践。 在 C++ 中，有两种简单的定义常量的方式： 使用 #define 预处理器。 1#define NAME value 使用 const 关键字。 1const type NAME = value; 以下是更多的实例（以const关键字定义为例）。请注意不同数据类型常量定义的区别。 1.4.2 常量类型 整数常量 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。 整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。 12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; const int VALUE = 123; const int VALUE = 123L; // 自动转换为long类型 const int VALUE = 123u; // 自动转换为unsiged int类型 const int VALUE = 0x123; // 16进制 const int VALUE = 0123; // 8进制 return 0;&#125; 浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。 以下仅给出关键代码。 12const float VALUE = 3.14159;const float VALUE = 314159e-5; // 使用科学计数法 布尔常量 布尔常量共有两个，即true和false。 以下仅给出关键代码。 12const bool VALUE = true; const bool VALUE = false; 我们不应把 true 的值看成 1，把 false 的值看成 0。即如下定义通常不建议进行： 123// 不建议的做法const bool VALUE = 1; const bool VALUE = 0; 字符常量 字符常量是括在单引号中。 字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\\t’），或一个通用的字符（例如 ‘\\u02C0’）。 以下给出关键代码进行示例。 123const char VALUE = &#x27;X&#x27;; // 普通字符const char VALUE = &#x27;\\n&#x27;; // 转义字符，即换行符const char VALUE = &#x27;\\u02C0&#x27;; // 通用字符，打印输出 字符串常量 字符串字面值或常量是括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。 123const string VALUE = &quot;\\n&quot;; // 转义字符，即换行符const string VALUE = &quot;\\u02C0&quot;; // 通用字符，打印输出const string VALUE = &quot;hello world&quot;; 1.4.3 const 和constexpr C++11 引入了一个关键字常量表达式constexpr，它确保变量必须在编译时被初始化，而const修饰的变量可以在编译时或运行时被初始化。 换句话说，constexpr 语义才是真正意义上的常量，运行时不能初始化。 12345678910#include &lt;iostream&gt;using std::cin;int main()&#123; int i = 0; const int j = i + 1; // ok，const修饰的值在运行时被初始化 constexpr int j = i + 1; // error，运行时无法初始化 return 0;&#125; 上述代码编译出错： 1234[root@roy-cpp test]# g++ -std=c++11 test.cpp -o test.outtest.cpp: In function ‘int main()’:test.cpp:1817:25: error: the value of ‘i’ is not usable in a constant expression constexpr int j = i+1; constexpr有什么好处？ constexpr 可以显示地告诉编译器表示式是确定值且可以被优化，const 修饰的编译器只能隐式跟踪是运行时常量还是编译时常量。 比如上述代码： 123const int i = 0; // 修改为常量const int j = i + 1; // ok，const修饰的值在运行时被初始化constexpr int j = i + 1; // ok，在编译时这行代码被优化 由于i也是常量，表达式int j = i + 1显然也一定会是常量。我们由此可以显示声明为constexpr，这样表达式会被编译器大胆地在编译期进行优化，提高编译速度。 在对性能要求苛刻的高并发场景，constexpr是个不错的选择。 1.4.4 define &amp; const &amp; 函数 🌟 define宏定义和const的区别？ 文本替换：define是在编译的预处理阶段起作用，属于文本插入替换；而const是在编译、运行的时候起作用； 类型检查：define只做替换，不做类型检查和计算，也不求解，容易产生错误；const常量有数据类型，编译器可以对其进行类型安全检查； 内存占用：define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表； 空间分配：宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。 define宏定义和函数的区别？ 文本替换：define是在编译的预处理阶段起作用，属于文本插入替换；函数调用在运行时需要跳转到具体调用函数； 类型检查：define只做替换，不做类型检查和计算，也不求解，容易产生错误；函数参数具有类型，需要检查类型； 其它：函数有返回值，在最后不用加分号。 1.5 运算符 运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。 除了常见的：算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符外，我们先来看看其它的一些重要运算符。 运算符 描述 备注 sizeof sizeof 运算符一个对象或类型所占的内存字节数。 重要，4.1.3节给出具体示例 Condition ? X : Y 条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 .、 -&gt; 成员运算符用于引用类、结构和共用体的成员。 Cast 强制转换运算符把一种数据类型转换为另一种数据类型。 4.X节详述 &amp; 取地址运算符 &amp; ，可获取变量的地址。例如 ，int var =3; int *ptr=&amp;var，获取变量var的地址。 * 间接寻址运算符 *， 获取指定地址的变量的值。例如，int val = *ptr ,此时var=3。 1.5.1 运算符汇总 该小节详细列出各类运算符，仅为查表用。读者可略过。 非特别说明，下例中假设变量 A 的值为 10，变量 B 的值为 20。 算术运算符关系运算符逻辑运算符位运算符赋值运算符 算术运算符 运算符 描述 实例 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 – 自减运算符，整数值减少 1 A-- 将得到 9 关系运算符 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 不为真。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 &gt; 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A &gt; B) 不为真。 &lt; 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A &lt; B) 为真。 &gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A &gt;= B) 不为真。 &lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A &lt;= B) 为真。 逻辑运算符 假设变量 A 的值为 1，变量 B 的值为 0。 运算符 描述 实例 &amp;&amp; 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 (A &amp;&amp; B) 为假。 || 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 (A || B) 为真。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 !(A &amp;&amp; B) 为真。 位运算符 p q p &amp; q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 赋值运算符 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A &lt;&lt;= 左移且赋值运算符 C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2 &gt;&gt;= 右移且赋值运算符 C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2 &amp;= 按位与且赋值运算符 C &amp;= 2 等同于 C = C &amp; 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 |= 按位或且赋值运算符 C |= 2 等同于 C = C | 2 1.5.2 运算符优先级 不同运算符在编译时优先级是不同的。 例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。 列出所有优先级比较，供需要时查表所用。读者不应过分关注下面细节。 类别 运算符 结合性 后缀 () [] -&gt; . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* &amp; sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 &lt;&lt; &gt;&gt; 从左到右 关系 &lt; &lt;= &gt; &gt;= 从左到右 相等 == != 从左到右 位与 AND &amp; 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND &amp;&amp; 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |= 从右到左 逗号 , 从左到右 1.6 循环 循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式： 1.6.1 快速入门 C++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 可以在 while、for 或 do…while 循环内使用一个或多个循环。 循环控制语句更改执行的正常序列。 控制语句 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 1.6.2 循环判断 C++ 编程语言提供了以下类型的判断语句。 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if…else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 1.6.3 ?: 运算符 条件运算符在实际编码中，用来替代 if…else 语句。因为很多时候可以简化代码，用的比较多。 1Exp1 ? Exp2 : Exp3; 1.6.4 无限循环 如果条件永远不为假或不存在时，则循环将变成无限循环。 1234567891011#include &lt;iostream&gt;using namespace std; int main ()&#123; for( ; ; ) &#123; printf(&quot;This loop will run forever.\\n&quot;); &#125; return 0;&#125; 按 Ctrl + C 键可以终止一个无限循环。 1.7 数组 存储一个由相同类型元素构成的顺序集合，称之为数组。 1.7.1 静态数组 静态数组声明且未初始化时必须确定数组大小，否则会报错。 初始化：可以使用列表&#123;...&#125; 快速赋值，不可使用new int[]&#123;...&#125;赋值（这是指针分配空间的方式） 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;#define LEN 3int main()&#123; // 静态数组 // 一维 // 【声明】 int array1[LEN] ; // 未初始化，指定大小=3 // 【赋值】 int array2[] = &#123;1,2,3&#125;; // 已初始化，编译器可推断大小=3 // int array2[] = new int[]&#123;1,2,3&#125;; // 出错，这是动态数组赋值的方式 int array3[LEN]&#123;1,2,3&#125;; // C++11支持不用=号进行赋值 // 二维 // 【声明】 int array4[LEN][LEN]; // 【赋值】 array4[LEN][LEN] = &#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125;&#125;; return 0;&#125; 1.7.2 动态数组 声明静态数组很简单，但很多时候我们更希望申请一个动态数组（比如声明时并不确定数组的内容）。 动态数组可以声明时不指定大小 ，但是使用前一定要分配空间（可不初始化，会默认初始化）。 初始化：可使用new int[]&#123;...&#125;赋值，不可以使用列表&#123;...&#125; 快速赋值 删除：注意是使用delete[] ，不是delete 1234567891011121314151617181920212223242526272829303132333435363738394041424344int main()&#123; // 1.一维 // 【声明】 int* array1; // 动态数组可不声明大小 // array1[1] = 2; // 编译出错，分配空间前就使用 int* array2 = new int[LEN]; // 【赋值】 // C++11支持快速为动态数组赋值 // 而不是C风格那样傻乎乎for循环挨个赋值 int* array3 = new int[LEN]&#123;1,2,3&#125;; // 但下列这种静态数组赋值方式是错误的 // int* array3 = &#123;1,2,3&#125;; // 编译出错，requires one element in initialize // 【释放】 delete[] array3; // 2.二维 // 【声明】 int** array4; // 【赋值】 /* // 不能用下面初始化方法 int** array5 = new int[LEN] &#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125;&#125;; ; */ int** array5 = new int*[LEN] &#123; new int[LEN]&#123;1,2,3&#125;, new int[LEN]&#123;3,4,5&#125;, new int[LEN]&#123;4,5,6&#125; &#125;; // 或者 int** array5 = new int*[LEN]; for(int i = 0; i &lt; LEN; i++) array5[i] = new int[LEN]&#123;(i+1)*1,(i+2)*1,(i+3)*1&#125;; // 【释放】 for(int i = 0; i &lt; LEN; i++) delete[] array5[i]; return 0;&#125; 1.7.3 数组默认初始化 在前面，我们了解到了局部变量/全局变量/静态变量/类成员的默认初始化值。数组的默认初始化值会什么呢？ 经过实验，数组默认初始化规则，基本等同局部变量/全局变量/静态变量/类成员的规则。只不过数组是以集合形式出现的。 int/float/double bool string/char 指针 引用 局部变量 野值 0 &quot;&quot;，'' 野值 出错 全局变量/静态变量 0 0 &quot;&quot;，'' 0 出错 类成员 野值 野值 &quot;&quot;，野值 &quot;&quot;/野值 出错 局部数组（其它同） 野值 野值 &quot;&quot;，'' 野值 出错 但是很多时候我们希望给（局部）数组进行初始化（比如0值）。如果数组很长，你肯定不希望逐个进行初始化化，虽然可以用循环但看起来也不那么聪明的样子。 让我们看看初始化数组的技巧。 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;#define LEN 3int main()&#123; // 快速0值初始化，其它类型同理，如flaot/double/bool // 1.静态数组：&#123;0&#125; int array1[LEN] = &#123;0&#125;; // 0,0,0 int array2[LEN] = &#123;1&#125;; // 1,0,0，如果第一个数字不是0，则只有其它是0 // 2.动态数组 int* array3 = new int[LEN](); // 0,0,0,记得指定长度 // 3.更通用的做法: std::fill() // 分别指定：数组起始地址，地址终地址，要填充的值 fill(array1,array1+LEN,0); return 0;&#125; 1.7.4 数组不是指针 在前面数组和动态数组（指针方式）不同初始化方式（指针需要new分配），你也应该隐隐约约感受到指针和数组是两个不同的东西。虽然很多时候数组会退化为指针使用，但将数组视为指针这是不对的。 比如，静态数组一旦初始化是不能重新赋值的，但是动态数组可以。 123456int arr1[3] = &#123;1,2,3&#125;;int arr3[3] = &#123;4,5,6&#125;;arr1 = arr3; // errorint* arr2 = new int[3]&#123;1,2,3&#125;; arr2 = new int[4]&#123;1,2,3,4&#125;; // ok 那么，数组和指针究竟有哪些不同？它什么时候退化为指针？怎么去更深层次的理解？ 这些东西不适合放在这里详细讲解，因为你还不具备很多相关知识。请参考：2.1.3#指针和数组。 1.7.5 数组小结🌟 下面我们总结一下数组常用声明、初始化方式。 【注1】仅以一维数组为例。 【注2】动态数组记得使用delete[]释放空间。 声明 显示初始化 快速初始化 静态数组 int arr[LEN]; int arr[LEN]={…};int arr[]={…};int arr[]{…}; int arr[LEN]={0};fill(arr,arr+LEN,0); 动态数组 int* arr;int* arr = new int[LEN]; int arr = new int[LEN]{…}* int* arr = new int[LEN]();fill(arr,arr+LEN,0); 1.8 字符串 1.8.1 C风格字符串 在C中我们使用字符串其实是字符数组。 用字符数组存放 用字符指针管理串 char str1[ ]=“royhuang”; char *str2=“hwh”; char字符数组 定义一个C 风格的字符串： 1char my_name[] = &quot;royhuang&quot; ; 猜猜my_name的长度？8？不，是9。因为C风格的字符串还会自动在末尾添加一个终止符，即：royhuang\\0 。 1sizeof(my_name)/sizeof(my_name[0]); // 9 strlen 可以忽略空字符： 1strlen(my_name); // 8 C风格字符数组，无法二次重新赋值，但数组存储的内容可以被修改。 下面举例说明。 数组不能重新赋值： 1my_name = &quot;hwh&quot;; // error，无法被修改 数组存储的内容可以被修改： 12my_name[0]=&#x27;z&#x27;cout&lt;&lt;my_name; // zoyhuang 指针数组 定义一个指针数组： 1char* my_name = &quot;royhuang&quot; ; 如果你对指针有所了解，一定会纳闷：指针都没给它分配指向的空间，怎么就可以存入char数组？ 下面才符合我们之前对动态数组的认知： 1234567891011121314// C风格动态数组// malloc分配空间char* my_name = (char*)malloc(10*sizeof(char));// for赋值for(int i=0 ; i&lt;10 ; i++) // for循环赋值&#123; my_name[i]=&#x27;&#x27;; &#125;/*// C++风格// new分配空间，还可以同时初始化char* my_name = new char[10]&#123;&quot;royhuang&quot;&#125;;*/ 这一切都要感谢编译器的“幕后工作”： 1char* my_name = &quot;royhuang&quot; ; // 发生了什么？ 等价于： 编译器首先在常量区分配一个字符数组（可以看做是匿名数组），这里假设为tmp_my_name ； 1char* tmp_my_name[] = &quot;royhuang\\0&quot;; 题外话，正因为&quot;royhuang\\0&quot;保存在常量区（只读），所以上述方式分配的动态数组无法修改： 1my_name[0] = &#x27;z&#x27;; // 错误，尝试修改常量区的值 然后将tmp_my_name 拷贝给my_name： 123// my_name 并没有分配空间// 只是保存了数组（首元素）地址my_name = tmp_my_name; 题外话，正因为my_name 只是保存了数组地址（本质是指针，而不是数组），所以动态数组可以重新改变指向。 1my_name = &quot;hwh&quot;; // ok 常用方法 C++提供了cstring.h 供我们操作C字符串（不适用std::string！），这里给出一些常用方法： 123456#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;char source[]=&quot;royhuang&quot;;char dest[5]; 复制字符串 下面这种方式容易造成溢出： 1strcpy(dest, source); // 溢出 &gt; 5 c中建议使用strncpy，C++11则首选strcpy_s： 1234567// 确保编译器支持此函数，需要先define#define __STDC_WANT_LIB_EXT1__ 1// linux下strcpy_s无法使用，使用strncpy// strncpy(dest, source, 5);strcpy_s(dest, 5, source); cout&lt;&lt;dest&lt;&lt;endl; 输出： 1royhu 长度和容量 123char name[10] = &quot;royhuang&quot;;strlen(name) ; // 7，不包含终止符size(name); // 10 其它有用的方法 strcmp() ：比较两个字符串（如果相等则返回 0 ）； strncmp() ： 比较两个字符串到特定数量的字符（如果相等则返回 0）； strcat() ： 将一个字符串附加到另一个（危险）； strncat() ：将一个字符串附加到另一个字符串（带缓冲区长度检查）。 最佳实践 C风格的字符串通常使用麻烦：合并字符串不方便、char*需管理内存分配、不自动增长需考虑越界的问题等。 因此在C++中最佳字符串实践： 不建议使用C风格的字符串，请尽量使用std::string； 如果一定要使用，请使用有固定缓冲区大小的 C 样式字符串。 认识下std::string 究竟有何般魔力吧。 1.8.2 string初识 std::string 是什么？ C++ 支持两种不同类型的字符串：std::string（作为标准库的一部分）和 C 风格的字符串（从 C 语言继承而来）。 std::string 是使用 C 风格的字符串实现的，参考：C++ string 源码实现对比 。 可以看到 string 其实就是 basic_string&lt;char&gt;，通过 basic_string 可以构造出不同字符类型的字符串类型。比如 wstring 就是 basic_string&lt;wchar_t&gt;。 1234typedef basic_string&lt;char&gt; string;typedef basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt; string; typedef basic_string&lt;wchar_t, char_traits&lt;wchar_t&gt; allocator&lt;wchar_t&gt; &gt; wstring; 也就是说std::string是一个对象，不是数组。 在c++中可以通过 #include &lt;string&gt; 引入字符串std::string 。 12345678910#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; // string my_name &#123;&#125;; // 空串 string my_name = &quot;royhuang&quot;; cout&lt;&lt;my_name&lt;&lt;endl;&#125; std::string 好在哪里？ 回忆我们提到的C风格字符串缺点： C风格的字符串通常使用麻烦：合并字符串不方便、char*需管理内存分配、不自动增长需考虑越界的问题等。 std::string 则不存在这些问题： 合并字符串方便：string内置append方法和重载了+操作符。 123string s1 = &quot;royhuang&quot;;s1.append(&quot;cqu&quot;); // royhuangcqus1 = s1+&quot;1996&quot;; // royhuangcqu1996 无需管理内存 。使用char* 需要显示使用delete[] 删除内存，string会自动管理。 自动动态增长。同上： 1s1.append(&quot;cqu&quot;); // 字符串长度自动增长 1.8.3 string转换为C风格 实际编码中，总有或多或少的原因，我们要将string转换为C风格字符串（C风格字符串如何转换为string在下一节：string常用方法介绍）。 了解一下吧。 c_str() 方法 原型：const char* string::c_str () const 。 12string sSource&#123; &quot;abcdefg&quot; &#125;;sSource.c_str(); data() 方法 原型：const char* string::data () const。 12string sSource&#123; &quot;abcdefg&quot; &#125;;sSource.data(); copy() 方法 原型：size_type string::copy(char *szBuf, size_type nLength, size_type nIndex = 0) const。 123string sSource&#123; &quot;sphinx of black quartz, judge my vow&quot; &#125;;char szBuf[20];sSource.copy(szBuf, 5, 10); 输出： 1black 继续看看string更多的用法吧。 1.8.4 string常用方法 字符串是编程中经常要处理的，这里列出常用的方法供熟悉和查阅。 为了尽量简洁，下面仅给出关键性代码。 构造初始化访问容量大小基本修改注意初始化string的只能是常量（const）类型。 当然你可能见过最简单的方法，使用操作符= 来初始化字符串。 1string str = string(&quot;royhuang&quot;); 当然，你还可以用C风格的字符串，也就是C风格字符串如何转换为string。 12string str = &quot;royhuang&quot;; // 字符串string str = &#x27;5&#x27;; // 字符 这里= 是重载过后的运算符。现在我们来了解一下：如何通过构造函数进行初始化。 string() 方法 原型：string::string()。创建一个空字符串。 12// 空串，默认初始化string sSource; string::string(const string&amp; strString) 此构造函数创建一个新字符串作为 strString 的副本。 1234567// 指定字符串值初始化string sSource&#123; &quot;my string&quot; &#125;; string sNewSource&#123; sSource &#125;;// 特别的，还接受char* szCString 类型作为参数const char *szSource&#123; &quot;my string&quot; &#125;;string sNewSource&#123; szSource &#125;; string::string(const char szCString)* 使用常量C风格字符串初始化。 12const char *szSource&#123; &quot;my string&quot; &#125;;string sOutput&#123; szSource &#125;; string::string(const string&amp; strString, size_type unIndex, size_type unLength) 创建一个新字符串，最多包含 strString 中的 unLength 字符，从索引 unIndex 开始。如果遇到 NULL，即使未达到 unLength，字符串复制也会结束。 12345678// 截取指定长度初始化string sSource&#123; &quot;my string&quot; &#125;;string sOutput&#123; sSource, 3 &#125;;std::cout &lt;&lt; sOutput&lt;&lt; &#x27;\\n&#x27;; // stringstd::string sOutput2(sSource, 3, 4);std::cout &lt;&lt; sOutput2 &lt;&lt; &#x27;\\n&#x27;; // stri 想用非字符串类型初始化？ 如果你尝试用非字符类型串初始化，比如数字： 1string sFour&#123; 4 &#125;; 会报错：无法将参数 1 从“int”转换为“std::basic_string” 。也就是说试图将int转换为string失败了。 有什么好办法吗？好办法就是我们先将非string类型，比如上文int类型，转换为string。 好吧，果然是经典废话大师。具体来说我们是使用std::ostringstream 类来转换为string类型。 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;template &lt;typename T&gt;inline std::string ToString(T tX)&#123; // 初始化--&gt;读入--&gt;调用str方法 ostringstream oStream; oStream &lt;&lt; tX; // tX加入到流中 return oStream.str();&#125;int main()&#123; string sFour&#123; ToString(4) &#125;; string sSixPointSeven&#123; ToString(6.7) &#125;; string sA&#123; ToString(&#x27;A&#x27;) &#125;; cout &lt;&lt; sFour &lt;&lt; &#x27;\\n&#x27;; // 4 cout &lt;&lt; sSixPointSeven &lt;&lt; &#x27;\\n&#x27;; // 6.7 cout &lt;&lt; sA &lt;&lt; &#x27;\\n&#x27;; // A&#125; 好了，知道你一定求知若渴：那string类型怎么转换为其它类型呢？类似的，我们使用std::istringstream。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;template &lt;typename T&gt;inline bool FromString(const std::string&amp; sString, T &amp;tX)&#123; // 初始化--&gt;写入--&gt;调用str方法 istringstream iStream(sString); // 将流中数据写入到tX中 return !(iStream &gt;&gt; tX).fail(); // extract value into tX, return success or not&#125;int main()&#123; double dX; FromString(&quot;3.4&quot;, dX) FromString(&quot;ABC&quot;, dX)&#125; 重载符号[] 12string sSource&#123; &quot;abc&quot; &#125;;sSource[2] = &#x27;D&#x27;; // abD at() 方法 相比性能较慢，因为它会对传入的参数index进行异常检查。但是相对的，如果你不确定传入的index是否有效： just use it. 12string sSource&#123; &quot;abc&quot; &#125;;sSource.at(2) = &#x27;D&#x27;; // abD size_type string::length() const 和 size_type string::size() const 两个函数都可以返回字符串中的当前字符数，不包括空终止符。 123string source&#123; &quot;012345678&quot; &#125;;source.length() // 9 source.size() // 9 bool string::empty() const 如果字符串没有字符则返回真，否则返回假。 1source.empty() // false size_type string::capacity() const 注意，length()方法返回的是实际存储的字符数量，但是capacity()方法返回的编译器给string类型初始化分配的容量大小。 编译器一般会为用户提供了一些缓冲空间，所以一般capacity()&gt;length()capacity()&gt;length()capacity()&gt;length()。 123string s &#123; &quot;012345678&quot; &#125;;s.length() ; // 9s.capacity() ; // 16 为什么要这么做？ 考虑这么一种情况，你初始化了一个字符串str，length()=8。如果你在后面还继续串联构造更大字符串，这个时候每串联一次编译器就要重新分配str大小。 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; // for rand() and srand()#include &lt;ctime&gt; // for time()int main()&#123; string str&#123;&#125;; // length 0 for (int count&#123; 0 &#125;; count &lt; 16; ++count) str += &#x27;a&#x27;; cout &lt;&lt; str;&#125; 当串联的次数过多时，显然这会对性能造成较大的影响。所以更更聪明的做法，除了系统默认分配更大的容量，还可以自定义提前reserve分配更大的容量。 void string::reserve(size_type unSize) 提前分配更大的容量。 1str.reserve(16); 定义公共代码如下。 12string sStr1(&quot;red&quot;);string sStr2(&quot;blue&quot;); 交换两个字符串 void swap (string &amp;str1, string &amp;str2)。 1swap(sStr1, sStr2); 追加字符串 string&amp; string::operator+= (const string&amp; str)。 1sStr1 += sStr2 ; // 新字符串：redblue 或者使用append()方法，效果一样。 1sStr1.append(sStr2) 特别对于C风格字符串，如下。 +=/append 方式 要求都是常量！ 1234string sString(&quot;one&quot;);// &quot; two&quot;、&quot; three&quot;都是C风格字符串sString += &quot; two&quot;;sString.append(&quot; three&quot;); push_back ，仅限字符 不要求是常量，如下： 12345string sString(&quot;one&quot;);sString += &#x27; &#x27;;sString.push_back(&#x27;2&#x27;);cout &lt;&lt; sString &lt;&lt; endl; 输出： 1one 2 插入字符串 string&amp; string::insert (size_type index, const string&amp; str)。 1sStr1.insert(2,sStr2); // reblued 当然也可以插入C风格字符串，但是只能是常量字符串。 1sStr1.insert(2,&quot;hwh&quot;); 比较 常用方法如下。 方法 作用 ==, != 比较两个字符串是否相等/不相等（返回 bool） &lt;, &lt;=, &gt; &gt;= 比较两个字符串是否小于/大于彼此（返回 bool） compare() 比较两个字符串是否相等/不相等（返回 -1、0 或 1） 子串 见下。 方法 作用 + 子串相加 substr() 获取子串 搜索 大致如下。 方法 作用 find() 查找第一个字符/子串 find_first_of() 查找指定搜索字符的第一次出现位置的索引 find_last_of() 查找指定搜索字符的最后一次出现位置的索引 1.8.5 输入输出流 在本笔记中，“流（stream）”一词会被大量提到。不可避免的，我们先来了解下其基本概念。 什么是流？ 抽象地说，流只是一个可以顺序访问的字节序列。随着时间的推移，流可能会产生或消耗无限量的数据。 以我们通常处理的输入流和输出流为例。 输入流：保存来自数据生成器（例如键盘、文件或网络）的输入。例如，保存用户当前键盘的输入。 输出流：用于保存特定数据使用者的输出，例如监视器、文件或打印机。将数据写入输出设备时，该设备可能尚未准备好接受该数据——例如，当程序将数据写入其输出流时，打印机可能仍在预热。数据将位于输出流中，直到打印机开始使用它。 C++中的输入、输出流 istream类是与输入流处理时的主类。对于输入流，**提取运算符 (&gt;&gt;)**用于从流中删除值。 ostream类是与输出流处理时的主类。对于输出流，**插入运算符 (&lt;&lt;)**用于将值加入流中。 当然，C++已经预定义好四个标准流对象，我们可以直接使用它们： cin ：标准输入流对象（通常是键盘）； cout ：标准输出流对象（通常是监视器）； cerr ：标准错误输出流对象（通常是监视器），提供无缓冲输出； clog ：标准错误输出流对象（通常是监视器），提供缓冲输出。 无缓冲输出通常被立即处理，而缓冲输出通常作为块存储和写出。因为 clog 不经常使用，所以经常从标准流列表中省略它。 istreamostream istream最佳实践 （C风格）使用setw避免缓存区溢出 使用提取运算符&gt;&gt;从输入流中读取信息，第一个常见问题便是要避免缓冲区溢出。尤其是在C风格的字符串中，这应该成为你的肌肉反应。 12char buf[10]; cin&gt;&gt;buf; // 输入：12345678910 流程：上例中，输入流中存在：12345678910，cin每次读取一个字符串放入buf中，遇到空格、制表符、换行符才会终止。 但由于你的小调皮，输入了超过10个字符。因为这超过了缓存预定大小（10），很不幸发生了Segmentation fault。 正确的做法应该是，我们要限制从流中读取的最大字符数（小于10），然后再放入buf中。 12345#include &lt;iomanip&gt;char buf[10];cin&gt;&gt;setw(10)&gt;&gt;buf;cout&lt;&lt;buf; 现在程序只读取流中的前 9 个字符（为终止符留出空间）。任何剩余的字符都将留在流中，等待下一次提取。 1123456789 （C风格）使用getline读取整行 如前提到，cin如果遇到：空格、制表符、换行符，就会自动停止提取。比如： 12345#include &lt;iomanip&gt;char buf[20];cin&gt;&gt;setw(20)&gt;&gt;buf; // 输入：i am royhuangcout&lt;&lt;buf; 输出结果却不如意： 1i 当然，聪明的你想到直接用循环读取字符：遇到空格、制表符等开始下一个循环，直至遇到\\n 才结束循环。 123char buf[20];int i=0;while (cin&gt;&gt;buf[i++]); 输出结果： 1i am royhuang 但上面的方式存在两个问题：1）循环不够优雅；2）没有限制输入字符最大长度。 为此，你说可以使用get方法。 12char buf[20];cin.get(buf,20); 看上去一切都很美好。但是这里忽略了一个问题，换行符\\n还在流中。 请看下例。 1234567 char buf[20]; cin.get(buf,20); cout&lt;&lt;buf&lt;&lt;endl; char company[10]; cin.get(company,10);cout&lt;&lt;company&lt;&lt;endl; company还未来得及输入，便结束： 使用getline可读入换行符： 1234567 char buf[20]; cin.getline(buf,20); // \\n 也并读入 cout&lt;&lt;buf&lt;&lt;endl; char company[10]; cin.get(company,10);cout&lt;&lt;company&lt;&lt;endl; 一切正常了。 （string）std::string+cin 和前面C风格字符串读取大同小异，不过C++中使用的是标准库中std::get和std::getline 函数。 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main()&#123; // 虽然uni初始化为空串，但是赋值后超过长度（length）会自动增长容量（capacity） string name&#123;&#125;; cout&lt;&lt; &quot;input your name: &quot;; cin&gt;&gt;name; string uni&#123;&#125;; cout&lt;&lt; &quot;input your university: &quot;; getline(cin,uni); cout&lt;&lt; &quot;your university is: &quot;&lt;&lt;uni&lt;&lt;endl; return 0;&#125; 出现前述类似读入\\n问题： 我们输入royhuang并按下回车时，等于输入了royhuang\\n ：royhuang 被正确赋值给name ，但是\\n 留在了缓冲区等待下一次cin读取。下一次的cin还没等我们再次输入，便发现了缓冲区\\n就完成此次读取了。 我们有两个办法解决这个问题： 提前读入\\n：第6行cin&gt;&gt;name; 替换—&gt;getline(cin,name); ； 忽略\\n：第13行 getline(cin,uni);—&gt;getline(cin&gt;&gt;ws,uni);，ws 表示忽略前面的空白字符。 好了，世界又好起来了。 其它有用的istream函数 ignore()丢弃流中的第一个字符。 ignore(int nCount)丢弃前 nCount 个字符。 peek()允许您从流中读取字符，而无需将其从流中删除。 unget()将读回的最后一个字符返回到流中，以便下次调用时可以再次读取。 putback(char ch)允许您将您选择的字符放回流中以供下一次调用读取。 这个小节主要如何 iostream 输出类 (ostream) 格式化输出内容。 前缀正数+ std::ios::showpos：如果设置，则用 + 前缀正数。 1cout &lt;&lt; showpos &lt;&lt; 5 &lt;&lt; &#x27;\\n&#x27;; 输出： bool标识 std::ios::boolalpha：如果设置，布尔值打印“真”或“假”。如果未设置，布尔值打印 0 或 1。 1cout &lt;&lt; boolalpha &lt;&lt; true &lt;&lt; &quot; &quot; &lt;&lt; false &lt;&lt; &#x27;\\n&#x27;; 输出： 科学计数法 1cout &lt;&lt; uppercase &lt;&lt; 12345678.9 &lt;&lt; &#x27;\\n&#x27;; 输出： 10/2/8/进制 123cout &lt;&lt; hex &lt;&lt; 11 &lt;&lt; &#x27;\\n&#x27;;cout &lt;&lt; dec &lt;&lt; 11 &lt;&lt; &#x27;\\n&#x27;;cout &lt;&lt; oct &lt;&lt; 11 &lt;&lt; &#x27;\\n&#x27;; 输出： 设置宽度、填充字符、对齐方式 12345cout &lt;&lt; -12345 &lt;&lt; &#x27;\\n&#x27;; cout &lt;&lt; setw(10) &lt;&lt; -12345 &lt;&lt; &#x27;\\n&#x27;;cout &lt;&lt; setw(10) &lt;&lt; left &lt;&lt; -12345 &lt;&lt; &#x27;\\n&#x27;; cout &lt;&lt; setw(10) &lt;&lt; right &lt;&lt; -12345 &lt;&lt; &#x27;\\n&#x27;; cout &lt;&lt; setw(10) &lt;&lt; internal &lt;&lt; -12345 &lt;&lt; &#x27;\\n&#x27;; 输出： 12345-12345 -12345 -12345 -12345 - 12345 更新记录 2021-12-25 ：更新笔记 第一次更新 参考资料 1.c++中的变量初始化：https://www.dyxmq.cn/program/code/c-cpp/cpp-variable-default-init.html ↩2.cpp类初始化：https://aiden-dong.gitee.io/2020/01/08/cpp%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/ ↩3.C++ 教程：https://cloud.tencent.com/edu/learning/course-1844-21266 ↩4.C语言extern关键词：http://c.biancheng.net/cpp/html/448.html ↩5.C++ 中的static关键字使用场景：https://cloud.tencent.com/developer/article/1695037 ↩6.C++ 循环：https://www.w3cschool.cn/cpp/cpp-loops.html ↩","categories":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/categories/C/"},{"name":"从零开始","slug":"C/从零开始","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"},{"name":"C++基础","slug":"C/从零开始/C-基础","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/tags/C/"},{"name":"教程","slug":"教程","permalink":"https://hwh.zone/tags/%E6%95%99%E7%A8%8B/"},{"name":"C++基础","slug":"C-基础","permalink":"https://hwh.zone/tags/C-%E5%9F%BA%E7%A1%80/"},{"name":"快速入门","slug":"快速入门","permalink":"https://hwh.zone/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}]},{"title":"C++从零开始（四）：务实基础（中）指针和引用","slug":"C++从零开始（二）：务实基础（中）之指针","date":"2022-01-14T08:35:15.067Z","updated":"2022-03-01T11:38:26.315Z","comments":true,"path":"p/24237/","link":"","permalink":"https://hwh.zone/p/24237/","excerpt":"","text":"🌟《C++从零开始》 系列，开始更新中… C++从零开始https://hwh.zone/p/62712 二、指针&amp;引用 第一次学C++，指针和引用令当时还是初学者的我感到非常的困惑： 普通变量就可以代表一块内存区域，我们可以直接使用原始变量，为什么还需要指针？ 指针解决了普通变量的不足，为什么又引入引用的概念？ 引用本质是什么？为什么操作引用等价操作变量本体？ 希望曾经的我，现在的你可以在本章找到答案。 2.1 指针 2.1.1 为什么需要指针 重新审视变量 变量可以理解为某块内存区域地址别名，这块内存区域保存变量的值。 下面举一个实例： 12int x = 0;x = 1; 对应汇编代码： 12movl $0, -12(%rbp)movl $1, -12(%rbp) 当CPU执行int x = 0，会在内存（这里是栈）腾出一块区域（-12(%rbp)）用来存储变量x；然后x所代表的内存区域（-12(%rbp)）被存入0。 继续执行x=1，1被存入变量x所代表的内存区域。 可以看到，变量的存在使得我们：不用记住为分配x的内存地址是什么，我们通过变量名x就可以使用分配的内存区域。因为使用x时，编译器会将变量x隐式自动翻译成对应的内存地址，同时进行间接寻址（可以理解为使用x等价于*x）。 12int x = 0; // 编译器眼里：int* x = -12(%rbp); *x = 0;x = 1; // 编译器眼里： *x = 1; 既然有好用又好记的变量x就可以，为什么还要画蛇添足般地显示使用指针变量，去存储内存地址，再来操作变量x： 1234// 声明一个指针变量，它存入x的地址int* p_x = &amp;x;// 使用间接操作符*，访问p_x存储的内存区域*p_x = 10; 对应的汇编代码也变得臃肿起来，因为还多了空间去存储指针p_x（即使没有汇编相关基础也建议阅读一遍）： 123456789# -12(%rbp)地址赋值给寄存器rax，也就是变量x的地址leaq -12(%rbp), %rax # cpu腾出一块内存区域（对应地址-8(%rbp)）给指针p_x，# 并把变量x的地址赋值给p_xmovq %rax, -8(%rbp)# p_x的值存储到寄存器rax中movq -8(%rbp), %rax# 将立即数10存储到变量x代表的内存区域中movl $10, (%rax) 现在我们来说说C++中指针的好处。 指针的好处 事实证明，指针在许多情况下都很有用（上面的例子当然是使用变量更好）： 遍历数组。指针可以很方便的遍历数组，因为数组是使用指针实现的； 动态分配内存。在C++中只能使用指针来动态分配内存； 函数作为参数时。可以用来将一个函数作为参数传递给另一个函数，即函数指针； 实现多态性。它们可用于实现多态性，在面对对象中会详细介绍； 指向另一个结构/类。在一些更高级的数据结构中很有用，例如链表和树。 但另一个事实是，除了在C++中，指针的使用并非那么必要。其它的高级语言中，很多已经摒弃了指针（如.NET或Java）： 遍历数组：传统的for循环、迭代器都可以替代； 动态分配内存：很多高级语言如Java不用指针即可动态分配内存（new方式）； 函数作为参数：在java中可以通过使用接口实例等方式间接实现； 实现多态性：java无需指针即可实现； 指向另外一个结构类 ：java等直接使用引用即可。 最佳实践 根据多位C++大师的建议，实际编码尽量不要使用指针，替代使用引用或者标准库是种更好的方式。 但种种原因，作为一个C++程序员，很多情况还是避免不了去接触和使用。因此，我们还是很有必要深层次了解指针的用法和原理。 2.1.2 指针简介 指针初识 声明指针使用*，这个时候*不是间接操作符，它只是指针语法的一部分： 12int a = 10;int* p_a; // p_a也是变量，不过是指针变量，存储的是一个地址（a的），下面简称为指针 这里有两个注意事项： 指针变量在声明时如果没被初始化，默认初始化规则和普通变量一样，可能包含垃圾值（比如局部指针变量）； p_a被称为“整数指针”，实际含义应该是“指向整数的指针”。 👀 眼保健操环节。 区分以下指针类型？ 123int *p[10]int (*p)[10]int *p(int) 指针和数组[] 结合一般才要注意区分，其余情况大多是表示指针。 int *p[10] ，强调数组概念，此时p表示数组，每个元素都是int* 类型； int (*p)[10] ，用() 圈住*p ，强调指针概念，此时指针p 指向一个int 类型数组，等价于 int *p = new int(10*sizeof(int)); ； int *p(int) ，这是函数声明本质还是指针，指针p 存储的函数的地址，后面的(int) 表示是个函数。 特别的还有： 1int (*p)(int) 同前，用() 圈住*p ，更强调指针概念，后面的(int) 表示是个函数。 赋值是使用地址运算符&amp;： 从下也可以看到，指针和普通变量在cpu眼中无多大区别，只不过指针用来存储地址。 1p_a = &amp;a; // &amp;a获取了变量a的地址。 &amp;p_a可获取指针p_a的地址。 12cout&lt;&lt;p_a&lt;&lt;endl; // a的地址，0x7ffc4f78721ccout&lt;&lt;&amp;p_a&lt;&lt;endl; // 指针p_a的地址，0x7ffe903aae20 地址运算符需要注意以下几点： 地址运算符 (&amp;) 返回不是变量的地址，而是一个包含变量地址的指针 ： 1std::cout &lt;&lt; typeid(&amp;a).name() &lt;&lt; &#x27;\\n&#x27;; 输出： 1int * 指针只能使用左值进行赋值 什么是左（l）值和右（r）值？可参考下一小节：l值和r值。 12345int a = 0;int* b = a; // 合法，变量b是左值int* b = 1; // 非法，文字1是右值int* b = a+1; // 非法，表达式a+1也是右值 变量可以修改存储其它的值，指针也可以指向其他的内存区域（存取它的地址）： 12int b = 11; p_a = &amp;b; 使用指针是通过间接操作符* ： 12cout&lt;&lt; *p_a &lt;&lt;endl ; // 10, 读取值*p_a = 11; // 修改 指针大小取决于编译可执行文件的体系结构——32 位可执行文件使用 32 位内存地址——因此，32 位机器上的指针是 32 位（4 字节）。对于 64 位可执行文件，指针将是 64 位（8 字节）。 它和指向的对象大小无关。 12345678int a = 10;int* p_a = &amp;a;char b = &#x27;1&#x27;;char* p_b = &amp;b;cout&lt;&lt;sizeof(p_a)&lt;&lt;endl;cout&lt;&lt;sizeof(p_b)&lt;&lt;endl; 在作者64位机器上输出： 1288 l值和r值 什么是左值（l值）？ 左值是具有地址（在内存中）的值。例如： 变量是一种左值（读作 ell-value），因为所有变量都有地址； 当我们进行赋值时，赋值运算符=的左侧必须是左值，但=右侧可以是左值也可以是右值。 例如： 12345int a = 1; // 正确，变量a可作为左值int b = a; // 正确，变量b也可作为右值5 = 6; // 出错，5不是左值，没有地址a+1 = 3; // 错误，a+1是右值 你可能会疑惑为什么表达式a 是左值，a+1 是左值？ 因为a+1没有自己的地址（临时计算的结果存入寄存器中），从根本否定了它是左值。 那什么又是右值？ 与左值相反的便是右值（r值，即没有内存地址），右值可以文字、表达式等： 12int a = 1; // 正确，1是右值a = a+1; // 正确，a+1是右值 特别的，在赋值运算时，所有左值会隐式转换为右值。 1int b = a; // a被隐式转换为右值 空指针 空指针是一个特殊的指针，可以通过“0”来为指针分配空值，表示没有指向任何东西。 1int *p = 0; 这似乎听起来没什么用？ 根据变量的最佳实践，声明时最好进行初始化，这个时候我们可以将指针设为空值完成最佳实践。 如下，此时指针p未被初始化（也称野指针），就被使用了。 1234567int main() &#123; int* p; // 未初始化 std::cout&lt;&lt; *p &lt;&lt; std::endl; // 未初始化就被使用 return 0;&#125; 根据最佳实践声明同时进行初始化，int* p = 0 ，然后再使用。 但使用0值表示空指针不安全，请使用nullptr关键字。 因为文字0不是任何类型，在少数情况下，编译器无法判断我们是使用空指针还是整数0。 123456789101112131415161718#include&lt;iostream&gt;using namespace std;void print(int* p)&#123; cout&lt;&lt;&quot;int* &quot;&lt;&lt;endl;&#125;void print(int p)&#123; cout&lt;&lt;&quot;int &quot;&lt;&lt;endl;&#125;int main()&#123; print(0); // 虽然我们希望传入空指针，但是编译器解释为int return 0;&#125; 输出： 1int 为了解决上述问题，C++11 引入了一个新的关键字nullptr ，称为 空指针。 C++ 会隐式地将 nullptr 转换为任何指针类型。 1int *p = nullptr ; 在上面的例子中，nullptr被隐式转换为整数指针，然后将nullptr的值赋给ptr。这具有使整数指针 ptr 成为空指针的效果。 void指针 void指针，也称为泛型指针，是一种特殊类型的指针，可以指向任何数据类型的对象。 123456int nValue;float fValue;void* ptr;ptr = &amp;nValue;ptr = &amp;fValue; 但也有由于这种不确定的包容特性，我们需要在使用void指针时转换为具体的指针： 1*static_cast&lt;int*&gt;(voidPtr) = 1; void指针有什么用？ 这种特性使得void指针可以在一个函数处理多种类型的数据。 以下函数展示了如何使用“泛型指针”作为函数参数（C++20前是不允许使用auto类型的参数），去处理多种类型的实参。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cassert&gt;enum class Type&#123; tInt, tFloat,&#125;;void printValue(void* ptr, Type type)&#123; switch (type) &#123; case Type::tInt: std::cout &lt;&lt; *static_cast&lt;int*&gt;(ptr) &lt;&lt; &#x27;\\n&#x27;; break; case Type::tFloat: std::cout &lt;&lt; *static_cast&lt;float*&gt;(ptr) &lt;&lt; &#x27;\\n&#x27;; break; break; default: assert(false &amp;&amp; &quot;type not found&quot;); break; &#125;&#125;int main()&#123; int nValue&#123; 5 &#125;; float fValue&#123; 7.5f &#125;; printValue(&amp;nValue, Type::tInt); printValue(&amp;fValue, Type::tFloat); return 0;&#125; 但一方面它看起来也很傻： 因为我们往往有更好的办法替代void指针，比如模板。 相比前面代码更加清晰，简洁。 12345template &lt;typename T&gt;void printValue(T ptr)&#123; std::cout &lt;&lt; ptr &lt;&lt; &#x27;\\n&#x27;; &#125; void指针也并不安全，它没有类型检查 没有编译器自动的类型检查，你又粗心写作了传入的参数类型，这显然很糟糕。 12float fValue2&#123; 5.4 &#125;;printValue(&amp;fValue2, Type::tInt); 最佳实践：尽量减少使用void指针，除非真的找不到第二个更好的办法来进行替代。 箭头运算符再思考 对于普通类/结构体的对象，我们使用成员选择运算符.选择成员。 12345678struct Person&#123; int age; double weight;&#125;;Person person;person.age = 5; 但我们也被告知，如果是个指针对象，请使用箭头-&gt;运算符： 12Person* p_person = &amp;person ;p_person-&gt;age = 6; 但这个时候，我们不禁想起以前如何使用一个指针： 12int a = 10;int* p_a = &amp;a; 使用间接操作符* 让我们获取了指针指向的对象，然后进行操作： 1*p_a = 11; 那么我们用* 获取p_person 指向的结构体对象，不就可以像普通结构体对象一样使用成员运算符.吗？ 1(*p_person).age = 6; // 等价于：person.age = 6; 更多的例子： 12Person* p_person2 = new Person();(*p_person2).age = 7; 2.1.3 指针和数组 指针和数组它们之间的区别有时很具有迷惑性，特别是很多时候编译器会将数组退化成指针使用。以至于有些人错误地将数组等价于指针。 现在我们来进行仔细的区分和总结。 指针加减法 不过在此之前，先了解下指针加减法有利于更好地继续往下分析。 C++ 语言允许对指针执行整数加减运算： 如果ptr指向一个整数，ptr + 1则为 ptr 之后内存中下一个整数的地址；ptr - 1是前一个整数的地址ptr。 换句话说，在计算指针算术表达式的结果时，编译器总是将整数操作数乘以所指向对象的大小。 1234567891011121314#include &lt;iostream&gt;int main()&#123; int value&#123; 7 &#125;; int* ptr&#123; &amp;value &#125;; std::cout &lt;&lt; ptr &lt;&lt; &#x27;\\n&#x27;; std::cout &lt;&lt; ptr+1 &lt;&lt; &#x27;\\n&#x27;; std::cout &lt;&lt; ptr+2 &lt;&lt; &#x27;\\n&#x27;; std::cout &lt;&lt; ptr+3 &lt;&lt; &#x27;\\n&#x27;; return 0;&#125; 输出： 12340x7ffd05328dfc0x7ffd05328e000x7ffd05328e040x7ffd05328e08 可以看到每个地址相差4字节（一个int大小），比如：0x7ffd05328e00-0x7ffd05328dfc=4。这里的地址是虚拟地址，4就表示4个字节。 指针和数组的区别🌟 “万物皆为指针，数组首当其冲”。 声明一个（静态）数组很简单： 123int arr1[3] = &#123;1,2,3&#125;;int new_arr[3] = &#123;4,5,6&#125;;arr1 = new_arr; // error，数组无法重新分配指向新，可以理解为此时数组是常量指针（区分指向常量的指针） 但很多时候我们更希望申请一个动态数组（比如声明时并不确定数组的内容）： 12int* arr2 = new int[3]&#123;1,2,3&#125;;arr2 = new int[2]&#123;1,2&#125;; // ok，指针可以分配新内存区域 new int[3]&#123;1,2,3&#125; 返回了一个int* 指针，存储分配的数组空间首地址，然后赋值给arr2 。 体会一下下面场景下的arr2 和 arr1 表现何其像： 作为表达式使用时 此时数组表现的就是指针，存储了数组元素首地址。 1234567891011121314int arr1[3] = &#123;1,2,3&#125;;int* arr2 = new int[3]&#123;1,2,3&#125;;// 1.打印数组/指针cout&lt;&lt;arr1&lt;&lt;endl; // 0x7fff61b6b7d0，数组首元素地址cout&lt;&lt;arr2&lt;&lt;endl; // 0x97b010，数组首元素地址，因为动态数组分配在堆上不在栈上，地址空间位数显得有些不同// 2.打印数组/指针首元素cout&lt;&lt;*arr1&lt;&lt;endl; // 1cout&lt;&lt;*arr2&lt;&lt;endl; // 1// 3.打印第二个元素cout&lt;&lt;*(arr1+1)&lt;&lt;endl; // 2cout&lt;&lt;*(arr2+1)&lt;&lt;endl; // 2 这是因为C++中如果把数组作为表达式使用，会衰减为一个指针。 数组作为参数时 将数组作为参数传递时，数组在函数内部表现得已经是一个指针。 123456789101112131415#include &lt;iostream&gt;using namespace std;void printSize(int arr[])&#123; cout &lt;&lt; &quot;in printArray: &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl; &#125;int main()&#123; int array[] = &#123;1,2,3,4,5&#125;; cout &lt;&lt;&quot;in main: &quot; &lt;&lt; sizeof(array) &lt;&lt; endl; printSize(array); return 0;&#125; 输出： 12in main: 20in printArray: 8 这种情况是因为，在C++中复制数组代价可能会昂贵。因此将数组传递给函数时，不会复制数组，而是固定数组衰减为指针，然后将指针传递给函数。 上述述代码中，数组array类型是int[5] ，作为实参时，退化为指针int * ，保存的数组中第一个元素的地址即&amp;array[0]，然后复制一份给形参arr。 题外话，当整个结构或类传递给函数时不会衰减。 也正是因为C++ 使用数组语法 [] 会将数组衰减为指针。这意味着以下两个函数声明是相同的： 12void printSize(int array[]); void printSize(int* array); // 最佳实践：指针语法 (*) 优于数组语法 ([])，它更表明实际接受的参数类型，C++也不用隐式转换 所以说，数组≠指针，只是在某些场景下退化成了指针而已，比如作为表达式或者函数参数时。 更准确来说是退化成了常量指针！因为数组本身默认是常量数组，无法作为左值。 123456void print(int arr[])&#123; arr = 0x778555622; // error，作为左值 new_arr = new int[]&#123;1,2,3&#125;; arr = new_arr; v // error，作为左值&#125; 题外话，正由于这种特性，我们往往不得不传递数组参数时还传递数组长度。因为你无法根据指针获取到其长度。 123456789101112131415#include &lt;iostream&gt;using namespace std;void printArray(int arr[],int len)&#123; for(int i=0; i&lt;len; i++) cout&lt;&lt;arr[i]&lt;&lt;endl;&#125;int main()&#123; int len = sizeof (arr) / sizeof (arr[0]); printArray(array,len); return 0;&#125; 这里我们进行更详细的总结，数组和指针的区别。 数组和指针关键区别在于：类型、是符号不是变量、sizeof等。 sizeof ：sizeof(数组) 打印的是数组的长度（容量*存储类型所占字节数），但是sizeof(指针) 打印的是指针长度，一般是4字节或8字节； 类型：数组类型是 type[LEN] ，指针类型是 type* ； 定义：数组是一个符号，没有自己的存储空间；指针是一个变量，有自己的内存空间，存储其它变量的地址。 可以修改一个指针： 12int* array = new int[5]&#123;1,2,3,4,5&#125;;array = NULL; // 正确，array是指针，存储是数组首地址 但你尝试修改数组内容是会出错的： 12int array[] = &#123;1,2,3,4,5&#125;;array = NULL; // 编译错误，array是符号，不是可以被修改的左值 另外，如果你尝试打印array的地址，也会发现它并没有属于自己的地址： 123int array[] = &#123;1,2,3,4,5&#125;;cout&lt;&lt;array; // 0x7ffffabf61f0，array[0]的地址cout&lt;&lt;&amp;array; // 0x7ffffabf61f0，没有数组自己的地址，而是array[0]的地址 &amp;array 返回一个指向整个数组的指针，这个指针也指向数组的第一个元素，只是类型信息不同（类型&amp;array 是 int(*)[5]）。 但是每个指针都有自己的地址： 123int* array = new int[5]&#123;1,2,3,4,5&#125;;cout&lt;&lt;array; // 0x7f3010，array[0]的地址cout&lt;&lt;&amp;array; // 0x7ffcff233b48，指针本身的地址 修改。数组无法被重新初始化/分配，指针（动态数组）可以。 []再理解 前面我们提到，C++ 使用数组语法 [] 会将数组衰减为指针* ，让我们更好地访问数组元素： 123int arr1[3] = &#123;1,2,3&#125;;arr[1]; // 等价于 *(arr+1) 上述事实证明，当编译器看到下标运算符（[]）时，它实际上将其转换为指针加法和间接寻址。 为了更好说明这一点，请看下面代码：输出会是什么呢？ 12345678910#include &lt;iostream&gt;int main()&#123; int arr[]&#123; 1, 2, 3 &#125;; std::cout &lt;&lt; 2[arr] &lt;&lt; &#x27;\\n&#x27;; return 0;&#125; 输出： 12 下标运算符 ( []) 等同于加法和间接法，操作数可以交换，因此它等价于： 1*(2+arr) cout 和数组 不知道读者有没有注意到一个有趣的事情，cout会自动遍历char数组打印所有字符。 12char c_arr[] = &quot;hello&quot;;cout&lt;&lt;c_arr&lt;&lt;endl; 输出： 1hello 理论上，此时输出应该是数组首选组h的首地址。就像下面的int数组： 12int i_arr[] = &#123;1,2,3&#125;;cout&lt;&lt;i_arr&lt;&lt;endl; 输出： 10x7fff74ecdc70 这是因为std::cout上的&lt;&lt;运算符已重载， 实际上是几个不同的函数，都命名为operator&lt;&lt;。它的行为取决于操作数类型，编译器由此决定要调用哪个函数。 如果给它一个char*或const char*，它会把操作数当作一个指向C样式字符串(第一个字符)的指针，并顺序移动输出剩下的字符串。 上面99% 的情况下都很棒，但它依旧可能会导致意想不到的结果。 下面代码尝试打印一个char类型字符的地址。 123456789#include &lt;iostream&gt;int main()&#123; char c&#123; &#x27;Q&#x27; &#125;; std::cout &lt;&lt; &amp;c; return 0;&#125; 输出： 1Q╠╠╠╠╜╡4;¿■A 好吧，这种情况不一定会发生，编译器可能已经给我们做了优化。但是如果发生了，你需要知道为什么： &amp;c 具有 char* 类型，因此 std::cout 尝试将其打印为字符串，直到遇到\\0; 但很不幸地下一个地址是垃圾值，直到它终止前打印了一堆垃圾字符串。 这个例子在现实情况不太可能发生，但对我们理解std::cout 如何工作很有帮助。 2.1.4 指针和const 指针和const的组合通常让人感觉很迷惑，国内的相关考试也没少折磨过作者。本节，作者将尽量尝试用清晰、简洁的语言说明。 指向常量的指针 一个指向常量值的指针是指向常量值的（非常量）指针，它通常被如此声明（const位于*左侧即可）： 123456int value = 5;// 下面两种声明方式等同// 只能使用右值进行初始化/赋值// 可以指向非常量变量，但通过指针访问时该变量被视为常量const int* p_value = &amp;value;int const * p_value = &amp;value; “指向常量值的指针”，这里强调了两个要素： 指针是非const的，所以它本身可以被修改（存储的地址）； 指针指向的变量是const的，它不能通过指针被修改（存储的地址对应的内存区域，即变量）。 听起来有点绕，举个例子说明： 指针指向的变量无法被修改 1234int value = 5;const int* p_value = &amp;value; // 指向“const int”// 尝试修改变量value的值*p_value = 6; // 非法 更深刻地理解：指针指向整个内存区域都不能被修改。 12const int* p_array = new int&#123;1,2,3&#125;;cout&lt;&lt;*(p_array+1)&lt;&lt;endl; // ok p_array指向的好像只是是首元素（保存的是首元素地址），但其实应该理解为，指向的是分配给数组的整个连续内存区域。 如下，p_array所指向的内存区域任意数组元素都不能被修改： 1*(p_array+1) = 0; // 等价于：p_array[1] = 0; 出错： 1error: assignment of read-only location ‘*(p_array + 4u)’ 这种做法也使得我们可以放心地定义指向常量的数组。 指针本身可以被修改 123456int value = 5;const int* p_value = &amp;value; // 指向“const int”// 尝试修改指针的值int value1 = 6;p_value = &amp;value1; // 合法 那怎么让指针本身可以无法被修改？ 常量指针 常量指针，可以使得指针本身无法被修改，即指针对应内存区域存储的值（通常是存储一个地址）。 它通常被如此声明（const位于*右侧）： 1234int value = 5;// 声明常量指针// 只能使用右值进行初始化/赋值int* const p_value = &amp;value; “常量指针”，同样包含了两个要素： 指针是const的，所以它本身不可以被修改（存储的地址）； 指针指向的变量是非const的，它能通过指针被修改。 依旧是举个例子说明： 123456789int value1 = 5;const int* p_value1 = &amp;value1; // 指向“int”// 尝试修改指向的变量*p_value1 = 7; // 合法// 尝试修改指针的值int value2 = 6;p_value1 = &amp;value2; // 非法 好吧，或许有些变态般的需求，指针指向的值和指针都不可以被修改。请看下个小节。 指向常量的常量指针 最后，可以通过在类型之前和变量名之前使用const关键字，来声明指向const 值的 const 指针： 12int value = 5 ;const int* const ptr = &amp;value ; 正如你所需要的，指针和其指向的变量都无法被修改。 最佳实践 或许你有些疑问：const可以让指针或变量不被修改，很多时候可以保持程序的严谨、健壮性。这看起来确实有些优点，但它真的那么重要吗？ 事实上，const非常重要&amp;有用！ 多位大师，比如候捷就曾说过：“程序写得是否大气严谨，大胆使用const就是直观的评价指标”。 所以，大胆的在你的代码中使用const吧。 扩展：函数与const 选择性阅读：本节额外涉及到，3.4 函数参数 &amp; 面对对象基本知识。 const是衡量一个程序员是否老道的一个标准，除了修饰变量之外，主要便用于修饰函数。 123const int&amp; fun(int&amp; a); // 修饰返回值int&amp; fun(const int&amp; a); // 修饰形参int&amp; fun(int&amp; a) const&#123;&#125; // const成员函数 const修饰返回值 const常用于返回值是引用类型的时候。 由于通常不会是局部变量的引用（返回局部引用是危险的，3.5.3节），那么通常是返回是，函数参数/成员变量/全局变量等。如果我们并不希望它们被修改，使用const修饰便可以做到这一点。 举个例子。 下面演示了没有const修饰函数返回值时，出现了我们并不期望的情况。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class Salary&#123;private: int base; // base是不期望被修改的，但无法在这里被声明为constpublic: Salary() &#123; base = 20000; &#125; ~Salary()&#123;&#125;; int&amp; get_base() &#123; return base; &#125;&#125;;int main()&#123; Salary s; // 修改base s.get_base() = 22000; // 修改成功 cout&lt;&lt;s.get_base()&lt;&lt;endl; return 0;&#125; 输出： 122000 但是，我们如果用const修饰函数返回值，私有成员base 便无法被修改（无法作为左值）。 1234const int&amp; get_base() &#123; return base;&#125; 再次尝试修改会报错：error: assignment of read-only location ‘s.Salary::get_base()’ 12// 再次尝试修改base，非法s.get_base() = 22000; const修饰形参 多数情况下，我们都会选择 pass by reference（按引用传递参数）。如果我们不希望修改实参的话，传递的引用参数请务必优先考虑加上const关键字。 这个很好理解。 123456789101112131415#include &lt;iostream&gt;using namespace std;void onlyPrint(const int&amp; b)&#123; b = 1; // error，b无法作为左值 cout&lt;&lt;b&lt;&lt;endl;&#125;int main()&#123; int a = 0; onlyPrint(a); return 0;&#125; 特别的，值传递传递用const修饰没有意义，因为形参本来就是拷贝了实参一份，和实参无关。 1234void onlyPrint(const int b) // 无意义，形参b和实参a完全独立&#123; ...&#125; const成员函数 这种情况多数情形下很容易被忽视，其实这个是非常重要的一个内容。 在前面const返回值避免了私有成员base被修改，但是依旧可能在函数返回前就不小心把base 修改了： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class Salary&#123;private: int base; // base是不期望被修改的public: Salary() &#123; base = 20000; &#125; ~Salary()&#123;&#125;; const int&amp; get_base() &#123; base = 22000; // 不小心在return前就修改了base return base; &#125;&#125;;int main()&#123; Salary s; cout&lt;&lt;s.get_base()&lt;&lt;endl; // 22000 return 0;&#125; 这个时候我们可以用const修饰整个成员函数，去避免成员函数修改对象成员变量 。 12345const int&amp; get_base() const&#123; base = 22000; // error，无法修改base return base;&#125; 不过我们依然有疑问，const成员函数修饰了究竟是什么？ 为什么要发出这种疑问，作者是不是神经质了？请看下例。 假设此时的get_data() 还没有被const修饰，也没做什么修改对象成员的事（很乖）： 1234const int&amp; get_base() &#123; return base;&#125; 你尝试调用get_data方法出错了： 12const Salary s;s.get_base(); 报错： 1error: passing ‘const Salary’ as ‘this’ argument of ‘const int&amp; Salary::get_base()’ 好吧，不要和我说常量对象不能调用非常量函数之类的，我更想知道上面的报错是什么意思，深层次的原因是什么… 报错大意是说，get_base() 函数有一个参数叫做this，尝试将实参 const Salary 传递给this 时出错。这由此需要解释两个问题： get_base() 哪来的叫做this参数？ this 指针是什么？ 其实在C++中任何成员函数的参数都隐含this 指针，不过不需要你显示写出来（熟悉python的同学是不是立马想到self？）。 比如，我们的get_base 在编译器眼中应该是这样的： 1234const int&amp; get_base(Salary* this) &#123; return base;&#125; this 指针指向正在操作成员函数的对象（在这里是s ）,此时对象的类型是const Salary 。 调用s.get_base() 在编译器眼里等价于： 12const Salary s;s.get_base(&amp;s); 而我们的get_base函数参数类型是Salary* ，传递的形参&amp;s类型是const Salary* 。它们是不匹配的，故报错。 这也说明了，const 成员函数其实就是修饰了成员函数中this参数，也就是当前对象。 12345 const int&amp; get_base() const &#123; base = 22000; // 不小心在return前就修改了base return base;&#125; 等价于： 12345const int&amp; get_base(const Salary* this) &#123; this-&gt;base = 22000; // 修改常量对象this，故出错 return base;&#125; 扩展：类对象和const const修饰的对象，不能进行修改对象成员变量的尝试。 最明显的一点就是，const修饰的对象不能调用非const修饰的函数，即使函数没有修改任何数据成员。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class Salary&#123;private: int base; // base是不期望被修改的public: Salary() &#123; base = 20000; &#125; ~Salary()&#123;&#125;; int&amp; print_base() &#123; cout&lt;&lt;base&lt;&lt;endl; return base; &#125;&#125;;int main()&#123; const Salary s; // const修饰对象 s.print_base; // error，不能调用非const的函数 return 0;&#125; 通过编译也很简单，const修饰函数即可： 12345int&amp; print_base() const&#123; cout&lt;&lt;base&lt;&lt;endl; return base;&#125; 2.1.X 智能指针🌟 从内存泄漏说起 和内存碎片概念区分。 一般我们常说的内存泄漏是指堆内存的泄漏。 使用malloc,、realloc、 new等函数从堆中分配到块内存后，没有相应的调用free或delete释放该内存块，导致这块内存就不能被再次使用。这就是内存泄漏。 例1，双重分配泄漏内存。 12int* ptr = new int();ptr = new int(); // ptr指向了新一块内存，原来存储的内存地址丢失 例2，类似指针不释放原先指向的内存区域。 123int value = 5;int* ptr = new int(); // 堆上分配内存，返回分配的内存首地址ptr = &amp;value; // 堆上内存没有释放，其ptr保存的地址丢失 上面感受可能不够直观，我们来举个具体例子。 下面一个很简单int堆内存（4字节）忘记使用delete释放，执行了百万次（比如线上代码的高频基础函数），便损失了40M内存。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;int main()&#123; system(&quot;free -m&quot;); // 内存泄漏*100W次 for(int i=0; i&lt;1000000; i++) &#123; int* s = new int(); s = new int(); // delete s; &#125; system(&quot;free -m&quot;); return 0;&#125; 输出（栈占用了1M内存）： 试想：如果不是简单int，而是复杂的大对象，很快就能把服务器所有内存干完。 避免内存泄漏的几种方式 在C++11前，我们通常通过以下方法尽量保证内存不被泄漏。 利用&quot;查找&quot;功能，查询new与delete，看看内存的申请与释放是不是成对释放的，这使你迅速发现一些逻辑较为简单的内存泄漏情况。 计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄漏； 将基类的析构函数声明为虚函数，让子类去调用父类的析构函数，避免父类没有申请的空间没有被释放。 当然，我们还可以使用一些检测工具： Linux下可以使用Valgrind工具 Windows下可以使用CRT库 但无论如何，在传统 C++ 中，『记得』手动释放资源，总不是最佳实践。 人远没有机器可靠，我们总可能在什么时候就忘记去是否内存资源。幸运的是，在C++11智能指针的概念中，对对象使用了引用计数，让程序员不再需要关心内存释放问题。 智能指针简介 为了减少出现内存泄漏的情况，在C++ 11 中，移动语义的引入，结合 RAII ，采用代理模式的思想，管理动态分配对象的生命周期。 C++11提供四种智能指针供使用: 指针类别 支持 备注 unique_ptr C++ 11 拥有独有对象所有权语义的智能指针 shared_ptr C++ 11 拥有共享对象所有权语义的智能指针 weak_ptr C++ 11 std::shared_ptr 所管理对象的弱引用 auto_ptr C++ 17中移除 拥有严格对象所有权语义的智能指针 本文主要关注， std::shared_ptr、std::unique_ptr、std::weak_ptr，使用它们需要包含头文件 &lt;memory&gt;。 std::shared_ptr std::shared_ptr 是一种智能指针，一个动态分配的对象可以在多个 std::shared_ptr 之间共享。 对象每多一个shared_ptr 指针计数就+1，反之-1； 为保证线程安全，引用计数的增减必须是原子操作。 动态分配的控制块包括了引用计数，弱引用计数，自定义的析构器等等数据。 配套使用的还有std::make_shared方法 ： 消除显式的使用 new，分配创建传入参数中的对象， 并返回这个对象类型的std::shared_ptr指针。 这样一来，std::shared_ptr 能够通过访问引用计数来确定自身是否是最后一个指向该对象的：如果是，则析构该对象；否则将引用计数减一。 一个简单使用实例。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;memory&gt;void foo(std::shared_ptr&lt;int&gt; i) &#123; (*i)++;&#125;int main() &#123; // 原先创建对象需显示new声明：int* pointer = new int&#123;10&#125;; // shared_ptr消除了new显示声明 std::shared_ptr&lt;int&gt; pointer = std::make_shared&lt;int&gt;(10); foo(pointer); std::cout &lt;&lt; *pointer &lt;&lt; std::endl; // 11 // pointer离开作用域，此时引用计数为1，判断出自己是最后一个指向对象 // 自动调用delete析构该对象 return 0;&#125; std::shared_ptr 还有其它的一些有用方法： get() 方法来获取原始指针； reset() 来减少一个对象的引用计数； use_count()来查看一个对象的引用计数。 使用auto 关键字替代std::shared_ptr&lt;int&gt; 声明。 *注释的数字表示一开始声明的对象，被多少shared_ptr所指向。 12345678910auto pointer = std::make_shared&lt;int&gt;(10); // 1auto pointer2 = pointer; // 2auto pointer3 = pointer; // 3int *p = pointer.get(); // 不会增加引用计数pointer.use_count(); // 3pointer2.reset();pointer3.reset();pointer.use_count(); // 1 std::shared_ptr 看着很美好，但它存在循环引用的问题。 请看下例。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;memory&gt;struct A;struct B;struct A &#123; std::shared_ptr&lt;B&gt; pointer; ~A() &#123; std::cout &lt;&lt; &quot;A 被销毁&quot; &lt;&lt; std::endl; &#125;&#125;;struct B &#123; std::shared_ptr&lt;A&gt; pointer; ~B() &#123; std::cout &lt;&lt; &quot;B 被销毁&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; auto a = std::make_shared&lt;A&gt;(); // 此时指针a指向的对象记为A对象 auto b = std::make_shared&lt;B&gt;(); // 此时指针b指向的对象记为B对象 cout&lt;&lt;a.use_count()&lt;&lt;endl; // A对象计数：1 cout&lt;&lt;b.use_count()&lt;&lt;endl; // B对象计数：1 a-&gt;pointer = b; b-&gt;pointer = a; cout&lt;&lt;a.use_count()&lt;&lt;endl; // A对象计数：2，内部引用B对象 cout&lt;&lt;b.use_count()&lt;&lt;endl; // B对象计数：2，内部引用A对象，发生循环引用 return 0;&#125; 此时运行对象A、B均不会被销毁（引用计数不为）。 12341122 main 函数退出前，B 对象的引用计数为2，A 对象的引用计数为 2； main 函数退出后：b 指针销毁，B 对象的引用计数变为 1；a 指针销毁，A 对象的引用计数变为1； 这样就导致了 对象A、B的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄漏。 std::weak_ptr 的存在便可以解决这个问题。 std::weak_ptr std::weak_ptr是一种弱引用（相比较而言 std::shared_ptr 就是一种强引用）。 std::weak_ptr 是针对 std::shared_ptr 功能的扩展， 不能解引用，也不能检查是否为空，主要作用是用于观察 std::shared_ptr 的内部状态，查看其引用计数，查看指针是否空悬，是一种具有临时所有权语义的智能指针。 为什么需要std::weak_ptr？ 一种常用的用法就是前面所说，打断 std::shared_ptr 所管理的对象组成的环状引用。 上代码解释。 和前面唯一的区别是只在结构体B内部替换了std::shared_ptr --&gt; std::weak_ptr。 12345678910111213141516struct A &#123; std::shared_ptr&lt;B&gt; pointer; // 强引用 ~A() &#123; std::cout &lt;&lt; &quot;A 被销毁&quot; &lt;&lt; std::endl; &#125;&#125;;struct B &#123; std::weak_ptr&lt;A&gt; pointer; // 替换为弱引用 ~B() &#123; std::cout &lt;&lt; &quot;B 被销毁&quot; &lt;&lt; std::endl; &#125;&#125;; 主函数中： 1234567891011int main() &#123; auto a = std::make_shared&lt;A&gt;(); // 此时指针a指向的对象记为A对象 auto b = std::make_shared&lt;B&gt;(); // 此时指针b指向的对象记为B对象 cout&lt;&lt;a.use_count()&lt;&lt;endl; // A对象计数：1 cout&lt;&lt;b.use_count()&lt;&lt;endl; // B对象计数：1 a-&gt;pointer = b; b-&gt;pointer = a; cout&lt;&lt;a.use_count()&lt;&lt;endl; // A对象计数：1，内部弱引用B对象，引用计数没有增加 cout&lt;&lt;b.use_count()&lt;&lt;endl; // B对象计数：2，内部引用A对象，发生循环引用&#125; 执行结果，一切岁月静好（析构函数被执行）： 1234561112A 被销毁B 被销毁 可见弱引用不会引起引用计数增加（A对象的引用计数始终是1），当换用弱引用时候，最终的释放流程如图所示（虚线表示弱引用）： main 函数退出前，B 对象的引用计数为2，A 对象的引用计数为 1； b 指针销毁，B 对象的引用计数变为 1； a 指针销毁，A 对象的引用计数变为0，A 对象立刻析构，A 对象析构的过程中会导致其包含的 b 指针被销毁，从而导致 B 对象的引用计数变为0，使得 B 对象也被正常析构。 std::unique_ptr 在前面std::shared_ptr，可以使得多个智能指针共有一个对象： 123auto pointer = std::make_shared&lt;int&gt;(10); // 引用计数：1auto pointer2 = pointer; // 引用计数：2auto pointer3 = pointer; // 引用计数：3 然而std::unique_ptr 是一种独占的智能指针， 是具有专属所有权语义（exclusive ownership semantics）的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全。 为什么需要std::unique_ptr？ 避免内存泄漏，这没什么好说的； 避免更大开销，相比于shared_ptr，它的开销更小，甚至可以说和裸指针相当，它不需要维护引用计数的原子操作等等。 回到前面，既然std::unique_ptr是独占，也就是不可复制。 12auto pointer = std::make_unique&lt;int&gt;(10); // 引用计数：1auto pointer2 = pointer; // 报错，此时pointer2无法作为左值，即无法将pointer复制给pointer2 std::make_unique 在C++14才被支持（C++11委员主席原话说他忘了）需要我们自己实现： 12345template&lt;typename T, typename ...Args&gt;std::unique_ptr&lt;T&gt; make_unique( Args&amp;&amp; ...args )&#123; return std::unique_ptr&lt;T&gt;( new T( std::forward&lt;Args&gt;(args)... ) );&#125; 虽然unique_ptr不能复制，但我们可以利用 std::move 将对象所有权转移给其它的 unique_ptr，例如： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;memory&gt;struct Foo &#123; Foo() &#123; std::cout &lt;&lt; &quot;执行Foo构造函数&quot; &lt;&lt; std::endl; &#125; ~Foo() &#123; std::cout &lt;&lt; &quot;执行Foo析构函数&quot; &lt;&lt; std::endl; &#125; void foo() &#123; std::cout &lt;&lt; &quot;执行Foo函数foo&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; std::unique_ptr&lt;Foo&gt; p1 = make_unique&lt;Foo&gt;(); p1-&gt;foo(); // std::move转移p1指向的Foo对象所有权给p2 std::unique_ptr&lt;Foo&gt; p2 = std::move(p1); p2-&gt;foo(); // 函数退出前（准确来说，是离开作用域前），Foo对象被销毁 return 0;&#125; 输出： 1234执行Foo构造函数执行Foo函数foo执行Foo函数foo执行Foo析构函数 创建对象，构造函数进行初始化并由智能指针p1 管理，输出“执行Foo构造函数”； 执行foo函数，输出“执行Foo函数foo”； std::move转移原先p1 所指向的Foo对象（内存区域）所有权转移给了p2 ，因此并没有创建新对象，故代码16行处不会产生输出； 执行foo函数，“执行Foo函数foo”； p2 管理的对象离开作用范围，析构函数自动执行，“执行Foo析构函数”。 2.2 引用 在本章开篇我们便已提到，尽量避免使用指针。最重要的原因便是指针它的不安全性与不确定性，一个crazy的野指针可能会让你更加crazy。 条件允许的话，请多多使用引用： 更安全。引用使用前必须初始化，且不能为空；指针可以随意改变他的指向的对象（野指针的一大温床），但引用不可以。 效率更高。指针最后析构时，要处理内存释放问题。 数组不会退化为指针。将数组引用作为参数时，不会像指针传递一样退化为指针。 现在我们来进行更详细的介绍。 2.2.1 引用简介 引用初识 声明一个引用很简单，类型+&amp; 即可： 12int a = 0;int&amp; b = a; // 引用声明必须初始化 引用就是变量的别名，对引用的任何操作等价于操作于本体。 12b = 1;cout&lt;&lt;a&lt;&lt;endl; // 1 变量a、b被视为同义词。在b上返回地址，会打印a的地址： 12std::cout &lt;&lt; &amp;a &lt;&lt; &#x27;\\n&#x27;; // 0x7fff16db208cstd::cout &lt;&lt; &amp;b &lt;&lt; &#x27;\\n&#x27;; // 0x7fff16db208c 特别的引用还有两个重要特性： 无法修改引用指向，可以理解为引用默认就是常量引用。 12int c = 2;b = c; // 等价于：b=2，无法重新指向c 就像指针一样，引用只能用左值（l值）进行赋值 （结合下节理解）因为只有左值才有属于自己内存地址，才能引用时间接寻址找到本体变量。 12345int a = 0;int&amp; b = a; // 合法，变量b是左值int&amp; b = 1; // 非法，文字1是右值int&amp; b = a+1; // 非法，表达式a+1也是右值 从汇编角度看引用 引用到底是什么？变量的别名？是指针？初学者难免都要被绕晕。 这里先给出结论：引用的本质就是一个常量指针，指针在CPU眼中也和一个普通变量没什么区别。 铁证如下，堂下引用还不露出原型？ 123456789101112int main()&#123; int a = 0; // 使用引用 int&amp; b = a; b = 1; // 使用指针 int* c = &amp;a; *c = 2;&#125; 对应汇编代码： 可以看到使用指针（②处）和使用引用（①处）汇编代码基本一致。以指针汇编代码为例： 12345678# 将变量a的地址（-20(%rbp)）存入寄存器raxleaq -20(%rbp), %rax# 为指针c分配内存（-16(%rbp)），同时将变量a的地址存入movq %rax, -16(%rbp)# 指针的值（变量a的地址）存入寄存器raxmovq -16(%rbp), %rax# 将立即数通过间接寻址(),赋值给变量amovl $2, (%rax) 这说明，引用在编译器眼里就是一个指针，存储了变量地址，使用引用时编译器会自动加上间接操作符*，本质还是一样的 。 不过这个“指针”还是“常量指针”，所以引用本身无法被修改且必须初始化（const修饰的特性）。 12int&amp; b = a; // 编译器眼里等价于：int* const b = &amp;a;b = 1; // 编译器眼里等价于：*b=1 希望看到这儿的你有种豁然开朗的感觉。 2.2.2 引用和const 前面我们说到，引用本身就不能改变，因此“引用”本来就具备“常量引用”特性（无法修改）。 在C++中也不存在“常量引用”这个概念： 12int a = 1;int&amp; const b = a; // error: ‘const’ qualifiers cannot be applied to ‘int&amp;’ 但存在指向指向常量的引用。 指向常量的引用 就像“指向常量的指针”，指向常量的引用可以用常量或非常量的左值进行初始化： 12345678int a = 0;const int b = 1;const int&amp; c = a; // ok，a是左值const int&amp; d = b; // ok，b是左值a = 2 ; // okc = 3 ; // error，指向常量的引用将变量当做常量，即使变量本身不是声明为常量 但指向常量的引用，还可以使用文字右值初始化（这和普通引用/指针不同）： 1const int&amp; e = 5; // ok 引用作为函数参数 引用作为函数参数相比指针作为参数更加推荐，原因就是本节开头所说：安全、效率高、避免了数组退化问题。 条件允许的话，我们还建议你尽量使用const修饰引用，这可以避免传递的参数被修改。 12345void printIt(const int&amp; x)&#123; // x = 1 ; // 不合法 std::cout &lt;&lt; x;&#125; 2.2.3 指针和引用小结 前面核心内容总结： 本质：引用本质就是常量指针，指针本质就是存储了其它变量地址的变量。 声明/赋值：引用和指针都只能用左值进行初始化/赋值（但指向常量的引用可以用右值初始化），引用还必须声明时就初始化。 const+指针/引用：const位于&amp; / * 前后具有不同语义；const让修饰的变量无法被修改。 智能指针：善于使用智能指针帮我们自动管理内存释放，循环引用使用std::weak_ptr进行解决。 指针和引用的区别： 本质：指针本质是变量，引用本质是指针也是变量； 初始化：引用必须初始化（且不能为NULL），指针不必要初始化（但不初始化就使用是使用野指针）； 赋值：引用和指针都只能用左值进行初始化/赋值（但指向常量的引用可以用右值初始化）； 修改：引用一旦初始化之后就不可以再改变，指针变量可以重新指向别的变量； … 2.3 功力提升 2.3.1 循环你真的会了吗：for_each&amp;迭代器 少年，想更优雅的遍历假装高手吗？ 来使用更简单、更安全的循环称为for-each循环、迭代器替换普通的for循环吧。 for_each for 循环遍历元素时更加的灵活（比如指定长度的数组元素），但也很容易出错。比如你不小心写错了数组长度： 123int arr[] = &#123;1,2,3&#125;;for(int i=1 ; i&lt;4 ; i++) std::cout&lt;&lt;arr[i]&lt;&lt;std::endl; // 出错，访问arr[3]越界 for-each 提供了更简单、安全的方式，特别你需要获取所有元素的情况。 for-each 还适合std::array、std::vector等容器； for-each 不适合指向数组的指针（动态数组），因为指针不是数组，无法遍历（根本原因是无法根据指针知道数组的长度）。 for-each语句的语法如下所示： 12for (element_declaration : array) statement; 试一试： 12345int arr[] = &#123;1,2,3&#125;;for(int num:arr)&#123; std::cout&lt;&lt;num&lt;&lt;std::endl;&#125; 好起来了。 我们还可以优化上面的程式，让世界更美好： 使用引用。for-each 用值复制方式把数组每个元素复制给num ，这显然有点糟糕，使用引用更好。 const修饰。一个大气的程序员要善于使用const，这里显然不需要改动 这里还是使用auto关键字自动推断类型（懒蛋狂喜）。 1234567int arr[] = &#123;1,2,3&#125;;// auto关键字会消除&amp;和const语义，所以这里显示声明// 请参考，3.X节：再谈autofor(const auto&amp; num:arr)&#123; std::cout&lt;&lt;num&lt;&lt;std::endl;&#125; 美好的世界值得吟诗一首。 深圳夏天的阳光刺得眼睛眯成一条缝 腾讯大厦外天空蓝得可以看见白云 感觉一切暖洋洋、软绵绵 我也慢悠悠、晃荡荡 好像就要飘去外太空 — by royhuang 迭代器 迭代器 旨在用来遍历容器的对象（例如，数组中的值，或字符串中的字符），提供对每个元素的访问。 迭代器并没有那么神秘，我们熟悉的指针（应该已经熟悉了吧？）就可以当做迭代器。 依旧是改写之前的例子： 12345678const int* begin = arr; // 注意，此时end指向的数组尾元素下一个位置，不是尾元素const int* end = begin+sizeof(arr)/sizeof(arr[0]);// 此时ptr就是迭代器for(const int* ptr = begin ; ptr != end ; ptr++)&#123; std::cout&lt;&lt;*ptr&lt;&lt;std::endl;&#125; 对于标准库容器 还通常会直接提供对迭代的支持，无需自己写。 以std::array 为例： 1234567891011121314151617#include &lt;array&gt;#include &lt;iostream&gt;int main()&#123; std::array array = &#123;1, 2, 3&#125;; auto begin = array.begin(); auto end = array.end() ; // 数组尾元素的下一个元素 // 迭代器基于for循环 for (auto p=begin ; p != end; ++p) &#123; std::cout &lt;&lt; *p &lt;&lt; &#x27; &#x27;; &#125; std::cout &lt;&lt; &#x27;\\n&#x27;; return 0;&#125; 输出： 11 2 3 当然你使用for 或者 for_each 循环遍历库容器也是ok的。 小结 遍历数组、库容器等可以使用for循环、for_each循环以及迭代器（基于for循环）。 库容器都支持迭代器，因此对于库容器，使用for循环+迭代器更好（复杂的循环最好的做法是结合库函数使用，比如std::sort ，2.3.3节介绍）。 2.3.2 使用更好的数组：array&amp;vector 在前面我们详细讨论了固定数组和动态数组，尽管两者都内置于 C++ 语言中，但它们都有缺点： 固定数组衰减为指针，这样做时会丢失数组长度信息； 动态数组存在混乱的释放问题，并且难以无误地调整大小。 因此我们说使用array&amp;vector替代C++内置数组，是更好的编程实践。 std::array：替代静态数组 std::array 提供固定的数组功能，当传递给函数时不会衰减，而且超出范围时会自行清理。 声明和使用一个std::array变量很简单： 12345#include &lt;array&gt;// C++17前不允许省略长度std::array&lt;int, 3&gt; my_array = &#123;1,2,3&#125;;my_array[1]; // 和普通数组一样使用 注意到std::array 和普通数组差别很大（可以重新赋值）： 1my_array = &#123;3,4,5&#125;; // 重新赋值，内置的数组更像是个常量指针，一旦初始化不能重新赋值 验证一下std::array 作为函数参数不会退化为指针。 1234567891011121314151617#include&lt;iostream&gt;#include&lt;array&gt;void printArray(const std::array&lt;float, 5&gt;&amp; my_array)&#123; for (const auto&amp; elem : my_array) // 不会衰减为指针，可以使用for_each循环 std::cout &lt;&lt; elem &lt;&lt; &#x27; &#x27;; std::cout &lt;&lt; &#x27;\\n&#x27;;&#125;int main()&#123; std::array&lt;float, 5&gt; my_array = &#123; 9.0, 7.2, 5.4, 3.6, 1.8 &#125;; printArray(my_array); return 0; // my_array被自动释放&#125; 输出： 19 7.2 5.4 3.6 1.8 优化：使用模板让函数支持任意类型的参数、长度的数组。 1234567template &lt;typename T, std::size_t size&gt; void printArray(const std::array&lt;T, size&gt;&amp; my_array)&#123; for (const auto&amp; elem : my_array) std::cout &lt;&lt; elem &lt;&lt; &#x27; &#x27;; std::cout &lt;&lt; &#x27;\\n&#x27;;&#125; 这涉及到模板相关知识，暂不细表。 当然，std::array不限于数字作为元素，可以在常规数组中使用的每种类型都可以在std::array中使用。 请看下面的结构数组。 注意相比普通结构体数组，array结构体数组初始化还要多一对大括号。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;array&gt;#include &lt;iostream&gt;struct House&#123; int number&#123;&#125;; int stories&#123;&#125;; int roomsPerStory&#123;&#125;;&#125;;int main()&#123; /* House houses[] = &#123; &#123; 13, 4, 30 &#125;, &#123; 14, 3, 10 &#125;, &#123; 15, 3, 40 &#125; &#125;; */ std::array&lt;House, 3&gt; houses = &#123; &#123; // 外侧多了一对大括号，否则初始化会出错 &#123;13, 4, 30 &#125;, &#123;14, 3, 10 &#125;, &#123;15, 3, 40 &#125; &#125;, &#125;; for (const auto&amp; house : houses) &#123; std::cout &lt;&lt; &quot;House number &quot; &lt;&lt; house.number &lt;&lt; &quot; has &quot; &lt;&lt; (house.stories * house.roomsPerStory) &lt;&lt; &quot; rooms\\n&quot;; &#125; return 0;&#125; 输出： 123House number 13 has 120 roomsHouse number 14 has 30 roomsHouse number 15 has 120 rooms std::array 有用的方法。 公共代码： 1234#include&lt;iostream&gt;#include&lt;array&gt;std::array&lt;int, 5&gt; my_array = &#123; 1,2,3,4,5 &#125;; 获取大小 1myArray.size(); // 5 排序 2.3.3节有详细的介绍。 123#include &lt;algorithm&gt; // for std::sortstd::sort(myArray.begin(), myArray.end()); 小结：std::array 声明时必须要指定长度有点笨拙，但它有很多优点----比如不会退化为指针、不用手动释放内存，标准库众多函数支持。所以尽可能地去使用它替代普通静态数组吧。 std::vector：替代动态数组 相比std::array 提供固定的数组 ，std::vector 同样会自动管理数组内存，不衰减为指针。 而且 std::vector 还支持可变的数组，也就是动态数组。 一个简单例子，注意到 std::vector声明时不必指明长度（动态数组特性）： 1234567#include &lt;vector&gt;std::vector&lt;int&gt; array; // 动态数组，可稍后初始化，不必指针长度std::vector&lt;int&gt; array2 = &#123; 9, 7, 5, 3, 1 &#125;;array2 = &#123;1,2,3&#125;; // 可以重新分配array[1]; // 使用和普通数组一样 类似的，std::vector 作为函数参数不会退化为指针，这里不再重复验证。 std::vector 有用的方法。 公共代码： 1234#include&lt;iostream&gt;#include&lt;vector&gt;std::vector&lt;int&gt; my_array = &#123; 1,2,3,4,5 &#125;; 获取大小 1my_array.size(); // 5 调整大小 调大后多余空间默认用0填充。 1234my_array.resize(8); for (int i : my_array) std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; // 1 2 3 4 5 0 0 0 向下调整，只打印resize后长度包含的元素。 1234my_array.resize(3); for (int i : my_array) std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; // 1 2 3 小细节：std::vector 中容量和长度并不相等。 长度是数组中使用了多少元素，而容量是在内存中分配了多少元素。 为了避免频繁的resize分配空间（调整数组大小通常代价比较昂贵），std::vector 中长度和容量不一定相等。 下面代码看起来好像一切正常。 1234std::vector&lt;int&gt; array2 = &#123; 9, 7, 5, 3, 1 &#125;;std::cout &lt;&lt; array2.size() &lt;&lt;std::endl;std::cout &lt;&lt; array2.capacity() &lt;&lt;std::endl; 输出： 1255 但是我们如果进行resize后再看 ： 123array2.resize(3);std::cout &lt;&lt; array2.size() &lt;&lt;std::endl; // []基于长度，array[4]非法std::cout &lt;&lt; array2.capacity() &lt;&lt;std::endl; 输出： 1235 容量依旧是5 并没有随之改变，即预留了一些空间，这样如果再次发生resize&lt;=5可以不用重新分配空间。 123array2.resize(4);std::cout &lt;&lt; array2.size() &lt;&lt;std::endl;std::cout &lt;&lt; array2.capacity() &lt;&lt;std::endl; 输出： 1245 # 数组实际上没有进行resize，还是之前的容量4 leetcode神器：std::vector 还有一大用途是作为堆栈使用。 一个简单的小例子。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;void printStack(const std::vector&lt;int&gt;&amp; stack)&#123; for (auto element : stack) std::cout &lt;&lt; element &lt;&lt; &#x27; &#x27;; std::cout &lt;&lt; &quot;(cap &quot; &lt;&lt; stack.capacity() &lt;&lt; &quot; length &quot; &lt;&lt; stack.size() &lt;&lt; &quot;)\\n&quot;;&#125;int main()&#123; std::vector&lt;int&gt; stack&#123;&#125;; printStack(stack); // (cap 0 length 0) // 3--&gt;2--&gt;1 依次压入 stack.push_back(3); printStack(stack); // 3 (cap 1 length 1) stack.push_back(2); printStack(stack); // 3 2 (cap 2 length 2) stack.push_back(1); printStack(stack); // 3 2 1 (cap 4 length 3) // 1--&gt;2--&gt;3 依次弹出 stack.pop_back(); printStack(stack); // 3 2 (cap 4 length 2) stack.pop_back(); printStack(stack); // 3 (cap 4 length 1) stack.pop_back(); printStack(stack); // (cap 4 length 0) return 0;&#125; 有两个细节需注意： 容量经过：0–&gt;1–&gt;2–&gt;4，四次调整容量，比较影响性能； 当vector被调整大小时，可能会分配比需要的更多的容量（第三次push进1后，容量从2–&gt;4，而不是2–&gt;3）。 为了避免容量被频繁调整，我们可以提前分配一定容量（leetcode避免超时）。 12// 添加到代码14行处stack.reserve(5); // 预分配容量5 再次打印出容量变化： 1234567(cap 5 length 0)3 (cap 5 length 1)3 2 (cap 5 length 2)3 2 1 (cap 5 length 3)3 2 (cap 5 length 2)3 (cap 5 length 1)(cap 5 length 0) perfect~整个过程除了第一次调整过容量，便没有再次调整过了。 2.3.3 多使用标准库算法 前面我们说到，库容器std::array、std::vector一大好处就是被标准库支持很多相关算法。 对于新手程序员玩家来说，自己写循环遍历数组是经常需要做的事。简单的可能只是为了打印下数组，复杂点可能还要去处理数组排序、查找、计数等。 但如果我们使用的库容器，就可以很好配合C++标准库函数，轻松地完成复杂的循环处理操作（大佬预先帮你写好接口不舒服嘛？）。 C++标准库提供的函数功能分为三类： Inspectors ：检查器，仅只读容器中的数据，比如搜索和计数； Mutators ：修改器，修改容器中数据，比如排序或分发； Facilitators：促进器，根据数据成员的值生成结果。 本节将介绍常用的一些算法，虽然只是一小部分，但是大部分算法工作方式相似。关键在于了解其工作原理，就可以轻松使用其它算法。 遍历：std::for_each std::for_each简介： 输入：列表，每个列表元素的操作规则； 输出：指定操作后的列表； 应用：当我们希望对列表执行相同操作时。 举例说明：对列表每个元素超级加倍。 1234567891011121314151617181920212223#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt;void doubleNumber(int&amp; i) // 超级加倍&#123; i *= 2;&#125;int main()&#123; std::array&lt;int,6&gt; arr = &#123; 1, 2, 3, 4 &#125;; // 对迭代器获取的每个元素进行指定操作（doubleNumber） std::for_each(arr.begin(), arr.end(), doubleNumber); for (int i : arr) &#123; std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; &#125; std::cout &lt;&lt; &#x27;\\n&#x27;; return 0;&#125; 输出： 12 4 6 8 相比之下似乎内置的for_each 循环还能实现得更简单？这个例子没看到相比for 循环有什么优势？ 相比for 循环，for_each 能更清晰表达我们的意图也更不容易出错（不用定义额外的索引变量i）； std::for_each支持并行化，更适合大项目/大数据。 排序：std::sort std::sort简介： 输入：列表，两个元素比较规则； 输出：排序后的列表； 应用：当我们希望对列表进行排序时。 std::sort 排序实例。 123456789101112131415161718192021222324#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt;bool greater(int a, int b)&#123; // Order @a before @b if @a is greater than @b. return (a &gt; b);&#125;int main()&#123; std::array&lt;int,6&gt; arr = &#123; 13, 90, 99, 5, 40, 80 &#125;; // greater定义列表两个元素比较规则 std::sort(arr.begin(), arr.end(), greater); for (int i : arr) &#123; std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; &#125; std::cout &lt;&lt; &#x27;\\n&#x27;; return 0;&#125; 输出： 199 90 80 40 13 5 好消息，因为降序排序很普遍，C++大开方便之门提供了自定义类型std::greater ，而不用我们自己写一个比较函数。 1std::sort(arr.begin(), arr.end(), std::greater&lt;int&gt;()); 注意到，std::greater 调用有点奇怪，因为它是个模板类（参数类型要求是函数指针）：1）&lt;int&gt; 传入模板参数，2）类中重载了操作符() ，返回一个函数对象。 查找：std::find &amp; std::find_if std::find简介： 输入：列表，被查找的元素； 输出：（找到时）元素的指针，（未找到时）尾元素的指针； 应用：当我们希望查找某个元素时时。 下面代码展示：找到容器指定的某个元素，并进行修改替换。 12345678910111213141516171819202122232425262728293031#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt;int main()&#123; std::array&lt;int,6&gt; arr = &#123; 13, 90, 99, 5, 40, 80 &#125;; std::cout &lt;&lt; &quot;输入要查找的元素，和欲替换的值: &quot;; int search=-1; int replace=-1; std::cin &gt;&gt; search &gt;&gt; replace; // 查找元素 auto found = std::find(arr.begin(), arr.end(), search); // 如果没找到 if (found == arr.end()) &#123; std::cout &lt;&lt; &quot;未找到指定元素： &quot; &lt;&lt; search &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; // 如果找到，还进行替换 *found = replace; &#125; std::cout &lt;&lt;&quot;found: &quot; &lt;&lt; *found &lt;&lt; &#x27;\\n&#x27;; return 0;&#125; 输出： 1234567[root@roy-cpp test]# ./test.out 输入要查找的元素，和欲替换的值 99 -1found: -1[root@roy-cpp test]# ./test.out 输入要查找的元素，和欲替换的值 12 -1未找到指定元素： 12found: 1767305032 如果还希望更灵活去自定义查找规则，请使用std::find_if 。 std::find_if简介： 输入：列表，列表每个元素的查找规则； 输出：（找到时）元素的指针，（未找到时）尾元素的指针； 应用：当我们希望自定义查找某个元素时时。 一个示例，std::find_if查找子字符串“nut”： 123456789101112131415161718192021222324252627282930#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt;#include &lt;string_view&gt;bool containsNut(std::string_view str)&#123; // str.find可用来查找指定子串 // 找到返回true，否则false return (str.find(&quot;nut&quot;) != std::string_view::npos);&#125;int main()&#123; // &quot;walnut&quot;包含要查找的子串&quot;nut&quot; std::array&lt;std::string_view, 4&gt; arr = &#123; &quot;apple&quot;, &quot;banana&quot;, &quot;walnut&quot;, &quot;lemon&quot; &#125;; auto found = &#123; std::find_if(arr.begin(), arr.end(), containsNut) &#125;; if (found == arr.end()) &#123; std::cout &lt;&lt; &quot;没找到“nuts”\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;找到了： &quot; &lt;&lt; *found &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125; 输出： 1找到了： walnut 本来至少需要三个循环，使用标准库函数只用几行代码就完成了。 统计：std::count &amp; std::count_if std::count和std::count_if统计指定元素或满足自定义的查找规则的元素出现次数。 在下面的示例中，我们将计算有多少元素包含子字符串“nut”： 12345678910111213141516171819#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt;#include &lt;string_view&gt;bool containsNut(std::string_view str)&#123; return (str.find(&quot;nut&quot;) != std::string_view::npos);&#125;int main()&#123; std::array&lt;std::string_view, 5&gt; arr = &#123; &quot;apple&quot;, &quot;banana&quot;, &quot;walnut&quot;, &quot;lemon&quot;, &quot;peanut&quot; &#125;; auto nuts = &#123; std::count_if(arr.begin(), arr.end(), containsNut) &#125;; std::cout &lt;&lt; &quot;共计：&quot; &lt;&lt; nuts &lt;&lt; &quot; nut(s)\\n&quot;; return 0;&#125; 输出： 1共计：2 nut(s) 2.3.X 最佳实践 善于使用容器+算法库中的函数，而不是编写自己的函数来做同样的事情，这可以使我们的代码更简单、更健壮。 具体来说，数组立马想到std::array、std::vector ；简单循环立马想到for_each 或者 std::for_each ；循环还需要结合复杂的操作，请尽量使用std::sort 等标准库算法。 更新记录 2021-01-30 ：更新笔记 修改智能指针相关描述 2021-01-07 ：更新笔记 第一次更新 参考资料 1.梳理c++ const 修饰函数：https://zhuanlan.zhihu.com/p/110159656 ↩2.第 5 章 智能指针与内存管理：https://changkun.de/modern-cpp/zh-cn/05-pointers/#5-1-RAII-%E4%B8%8E%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0 ↩3.理解 C++ 智能指针：https://supwills.com/post/understanding-cpp-smart-pointer/ ↩","categories":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/categories/C/"},{"name":"从零开始","slug":"C/从零开始","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"},{"name":"C++基础","slug":"C/从零开始/C-基础","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/tags/C/"},{"name":"教程","slug":"教程","permalink":"https://hwh.zone/tags/%E6%95%99%E7%A8%8B/"},{"name":"C++基础","slug":"C-基础","permalink":"https://hwh.zone/tags/C-%E5%9F%BA%E7%A1%80/"},{"name":"指针","slug":"指针","permalink":"https://hwh.zone/tags/%E6%8C%87%E9%92%88/"}]},{"title":"C++从零开始（五）：务实基础（下）函数","slug":"C++从零开始（二）：务实基础（下）之函数","date":"2021-12-09T05:31:37.851Z","updated":"2022-02-19T09:59:54.082Z","comments":true,"path":"p/51595/","link":"","permalink":"https://hwh.zone/p/51595/","excerpt":"","text":"🌟《C++从零开始》 系列，开始更新中… C++从零开始https://hwh.zone/p/62712 三、函数 3.1 基本概念 怎么定义函数？ 以前，我比较倾向将函数定义为顺序执行的语句集合。现在我认为更恰当的说法应该是：函数是一个可重用的语句序列，旨在完成特定的工作。 C++ 中函数一般形式如下： 1234return_type function_name( parameter_list )&#123; // body of the function&#125; 上面包含一个函数的所有组成部分： 返回类型(return_type)：一个函数可以返回一个值，return_type 是函数返回的值的数据类型。不需要返回值，return_type 是关键字 void。 函数名称(function_name)：函数的实际名称，函数名和参数列表一起构成了函数签名。 所谓”签名“则意味着这可以唯一标识一个函数。 参数列表(parameter_list)：参数就像是占位符。当函数被调用时，可向参数传递一个值，这个值被称为实际参数，参数列表包括函数参数的类型、顺序、数量。 参数列表的顺序、类型、数量不完全一致的话，形成不同函数签名，即是不同函数。 函数主体(boby)：函数主体包含一组定义函数执行任务的语句。 特别的，C++是不支持嵌套函数的。 1234567891011#include&lt;iostream&gt;using namespace std;int main&#123; // 编译出错 int max1(int num1=0, int num2) &#123; return num1&gt;num2?num1:num2; &#125;&#125; 3.1.1 前向声明🌟 前向声明初识 在很多IDE中，如果你尝试在main函数使用未在之前定义的函数，会出现编译错误： 1234567891011121314#include&lt;iostream&gt;using namespace std;int main&#123; max(1,2); // 编译错误 return 0;&#125;// 函数返回两个数中较大的那个数int max(int num1, int num2) &#123; return num1&gt;num2?num1:num2;&#125; 这是因为max函数定义在main函数之后，顺序编译到代码第6行max(1,2)时找不到max的定义，所以main不知道max是什么（是的怎么这么笨？）。 解决这个问题，可以： 将max函数整体定义在main函数前； 前向声明。 前向声明告诉编译器标识符在实际定义之前就已经存在，这样编译器会在链接时进行符号链接寻找标识符的定义。 感觉和extern关键字很像？请见下节对比。 123456789101112131415#include&lt;iostream&gt;using namespace std;int max(int num1, int num2) ; // 前向声明int main()&#123; max(1,2); // 编译正确 return 0;&#125;// 函数返回两个数中较大的那个数int max(int num1, int num2) &#123; return num1&gt;num2?num1:num2;&#125; 如果max定义在其它文件（max.cpp）中： 12345/*max.cpp*/int max(int num1, int num2) &#123; return num1&gt;num2?num1:num2;&#125; 你在main中（定义在main.cpp）中，可以不通过include “main.cpp”而使用前置声明： 12345678910/*main.cpp*/#include&lt;iostream&gt;using namespace std;int max(int num1, int num2) ; // 前向声明,会在链接的时候寻找max的定义，编译器时不报错int main()&#123; max(1,2); // 编译正确 return 0;&#125; 编译（一切正常）： 12g++ main.cpp max.cpp -o main.out./main.out 但经过我的实践，在很多编译器中进行了优化。同一个文件的函数即使不进行前向声明，上面的代码也不会报错。 而且，在Google code style 也明确指出尽量不要使用前置声明： 尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。 那么，前向声明还存在的意义是什么？ 减少编译时间。使用include也可以使用别的的文件中定义的变量，但是也会把头文件其它不需要的变量引入。如果只是需要使用很少的外部变量，使用前向声明能减少编译的头文件展开。 打破循环引用。 循环引用 前置声明现在用来解决多文件中循环引用的问题。 以类循环引用为例。 想象这么一个情况：A.h定义了Class A，它需要引用B.h定义的Class B，也就是要写入#include “B.h” ；类似的情况，B.h也需要写入#include “A.h”。 这就造成了两个类互相引用，但由于C++蛋疼顺序编译的规则。如果是先编译A.h，引用的类B则找不到实现的定义；如果是先编译B.h，则找不到类A的定义。形成“先有鸡还有先有蛋”的世纪难题。 我们举一个具体的例子。 123456789101112131415161718192021222324252627282930313233/* A.h */#ifndef A_H#define A_H#include &quot;B.h&quot;class A&#123; private: B *b;&#125;;#endif/* B.h */#ifndef B_H#define B_H#include &quot;A.h&quot;class B&#123; private: A *a;&#125;;#endif/*test.cpp*/#include &quot;A.h&quot;#include &quot;B.h&quot;int main()&#123; A a; B b; return 0;&#125; 尝试编译一下： 1g++ test.cpp -o test.out 显示在B.h中找不到A的定义： 现在我们从底层编译过程探讨下这个循环引用出现的原因和解决方案。 我们知道编译四大流程为：预编译→编译→汇编→链接，先看看预编译源文件test.cpp产生的test.i。 1g++ -E test.cpp -o test.i 预编译后内容如下： 下面是test.i中具体内容。 123456789101112131415161718192021class B&#123; private: A *a; // 前面没有A的定义&#125;;# 4 &quot;A.h&quot; 2class A&#123; private: B *b;&#125;;# 10 &quot;test.cpp&quot; 2int main()&#123; A a; B b; return 0;&#125; 可以看到，test.i中第6行代码A* a，在类B中引用了A ，但是前面没有关于A 的定义。这为后面编译出错埋下了伏笔。 预编译后完成后，我们进行第2个阶段：编译。 1g++ -S test.cpp -o test.s Error！出现了最开始的“未定义”错误： 也就是说这个错误在编译阶段就产生了：当C++按顺序编译到 A *a 这行时，编译器进行语法检查，发现在前面找不到A相关的定义，于是报错。 怎么解决这个问题？ 我们可以在B.h 中进行前向声明，解决这个错误。 类似于全局变量，这样A作用范围就到本文件结尾：即编译器还会在test.i 中其它位置寻找A的定义； 不仅如此，即使test.i中不存在，编译器还会在链接时符号解析时寻找A的定义，而不是在编译时就报错。 这样编译器就不会在编译阶段报错了。 123456789101112#ifndef B_H#define B_H#include &quot;A.h&quot;class A; // 前向声明，class B&#123; private: A *a;&#125;;#endif 新的预编译文件test.i文件也在相应位置多了一行Class A;（其余无变化）: 123456class A;class B&#123; ...&#125;... 如果不使用#ifndef 、#define 和#endif？ #ifndef 、#define 和#endif，即条件编译：只有满足要求代码才参与编译，否则不参与编译。基本用法为： 12345#ifndef 标识符 程序段1 #else 程序段2 #endif 在本节中，对B.h和A.h都使用了条件编译：防止头文件被重复定义，在链接时出现大量重定义错误。 1234#ifndef A_H // 或B_H#define A_H // 或B_H// A_H或B_H中的代码 #endif 以A.h为例： 如果A.h被第一个文件引入时，会定义标识符A_H ，这个时候A.h其后的代码会被预编译插入到文件中； 如果其它文件存在代码#include “A.h” ，尝试预编译替换为A.h中内容； 因为A_H 已被定义，直接跳转到#endif结束，避免了头文件重复引入。 在本节中，如果对B.h和A.h都不使用条件编译，预编译时不但会出现重定义错误还会出现无限嵌套： main.cpp中：#include “A.h” 被替换为A.h中具体内容； A.h中： 由于在头文件引入了 #include “B.h” ，所以 #include “B.h”也会被替换为B.h中具体内容； B.h中： 重复引入了 #include “A.h”，重复替换头文件A.h，跳转到步骤2发生无限嵌套。 extern和前向声明 extern和前向声明作用非常相似：都可以用来声明函数/结构体/类等是在外部定义的，这样在编译时不出错，在链接时会在其它.o寻找相关定义。 但是extern关键字和前向声明也有些不同： extern可以作用于变量，前向声明无法声明变量（变量会默认初始化），只能声明函数/结构体/类等； extern还有extern “C”相关用法； extern是一个关键字，前向声明是种声明方式（使用前声明）。 最佳实践：extern/前向声明/include 如果只是少量地要使用别的文件中定义的变量/函数/结构体/类等：请使用extern关键字，它可以减少编译时间； 虽然函数/结构体/类等使用前向声明也可以但不推荐，使用extern更好。 打破循环引用。前向声明。 其余情况使用include更好，代码逻辑更清晰。 3.1.2 最佳实践：什么时候使用函数 作为曾经稚嫩的（现在不那么稚嫩的）程序员，什么时候使用函数是一个挺纠结的问题。参考learncpp 中建议： 多次出现的语句应该组成一个函数。例如，如果我们以相同的方式多次读取用户的输入，那么这是一个很好的函数候选。 具有明确定义的输入和输出目标的代码。例如，如果我们有一个要排序的项目列表，那么进行排序的代码将是一个很好的功能，即使它只完成了一次。输入是未排序的列表，输出是排序的列表。 一个函数应该执行有且只有一项任务。 当一个函数变得太长、太复杂或难以理解时。可以将其拆分为多个子函数，也就是重构。 3.2 函数重载 在前面我们提到：函数通过函数签名来唯一确定一个函数，而函数签名由 函数名&amp;参数列表 组成。 比如，两个函数函数名相同而参数列表不同，这个时候是同一函数吗？ 显然不是，因为函数签名中的参数列表不同，因此是两个函数，这也就是函数重载。 3.2.1 为什么需要函数重载？ 重载函数通常用来命名一组功能相似的函数。这样做的好处： 减少了函数名的数量； 避免了名字空间的污染，对于程序的可读性有很大的好处。 请看下例。 我们有两个函数：一个返回两个整数相加的值，一个返回两个浮点数相加的值。我们定义了多个名称但极其相似（功能、名字etc.）的函数。它们核心功能虽然都是add，但却对应多个不同的函数名，增加了记忆负担。 123456789int addInteger(int x, int y)&#123; return x + y;&#125;double addDouble(double x, double y)&#123; return x + y;&#125; 优雅的做法应该是：每个函数同名，编译器靠参数类型、数量、顺序来自动匹配调用。 123456789101112131415161718192021int add(int x, int y)&#123; return x + y;&#125;int add(int x, int y,int z)&#123; return x + y;&#125;double add(double x, int y)&#123; return x + y;&#125;int main()&#123; add(1,2); // 匹配第一个add add(1,2,3); // 匹配第二个add add(3.4,5); // 匹配第三个add return 0;&#125; 3.2.2 二义性匹配 前面介绍的都是传递的参数和定义函数参数完全匹配的简单情况。但实际上，还会出现函数调用中的参数类型与任何重载函数中的参数类型不完全匹配 。 这会发生什么？ 1234567891011121314151617#include &lt;iostream&gt;using namespace std;void print(int x)&#123; cout &lt;&lt; &quot;print int : &quot;&lt;&lt; x &lt;&lt;endl;&#125;void print(double d)&#123; cout &lt;&lt; &quot;print double : &quot;&lt;&lt; d &lt;&lt;endl;&#125;int main()&#123; print(&#x27;a&#x27;);&#125; 输出： 1print int : 97 发生了什么？print('a') 匹配了 print(int)? 97又是什么？ 这是因为编译器如果找不到完全匹配的函数，会自动进行隐式转换将某些窄整数和浮点类型自动提升为更宽类型。所有这里的char('a') 自动提升为int ，匹配到了print(int) , 97是a 的ASCII编码。 特别的，由于匹配到了print(int) ，便不会自动继续提升类型去匹配print(double)。 关于类型转换 会在第十章统一总结，这里先简单了解下即可。 特别的，如果上述过程（数字转换找不到）未找到匹配项，编译器将尝试通过任何用户定义的转换找到匹配项。 这涉及到类型重载，会在下篇文章面对对象 进行讲解。这里只要了解这个例子即可。 123456789101112131415161718192021class X &#123;public: operator int() &#123; return 0; &#125; // 用户自定义从X转换int&#125;;void print(int)&#123;&#125;void print(double)&#123;&#125;int main()&#123; X x; print(x); // 匹配print(int) return 0;&#125; 在这里例子中（也是一般函数参数匹配流程总结）： 编译器寻找是否存在print(X) ，不存在转至第2步； 编译器检查x是否可以类型提升，不能进行第3步； 编译器将查找任何用户定义的转换，存在，进行转换。 3.3 函数模板 在前面函数重载中，我们通过将两个功能相似仅参数列表不同的函数，改为同名函数让编译器通过函数签名来区分，减少了思维负担。 但是考虑一种更特殊的情况，两个函数不仅功能极其相似，连参数列表的个数都相同。 123456789101112131415161718#include &lt;iostream&gt;using namespace std;void print(int x, int y)&#123; cout &lt;&lt; &quot;print result : &quot;&lt;&lt; x+y &lt;&lt;endl;&#125;void print(double x, double y)&#123; cout &lt;&lt; &quot;print result : &quot;&lt;&lt; x+y &lt;&lt;endl;&#125;int main()&#123; print(1,2); print(3.0,4.0);&#125; 总感觉哪里不对，似乎造成了很多代码重复？它们只是参数类型不同啊，函数体、名字什么都一样？ 在C++中提供了函数模板，用来优雅地应对这种情况。 1234567891011121314#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt; // template和typename是关键字，T是类型名void print(T x, T y)&#123; cout &lt;&lt; &quot;print result : &quot;&lt;&lt; x+y &lt;&lt;endl;&#125;int main()&#123; print(1,2); print(3.0,4.0);&#125; 不错，一切顺眼了很多。 3.3.1 模板函数是如何工作的？ 在前文我们介绍了函数模板，如下： 12345template &lt;typename T&gt; void print(T x, T y)&#123; cout &lt;&lt; &quot;print result : &quot;&lt;&lt; x+y &lt;&lt;endl;&#125; 但函数模板实际上并不是函数——它们的代码不是直接编译或执行的。函数模板只有一个功能：为每个具有一组唯一参数类型的函数，调用创建（并编译）一个函数。 让我们看一个简单的例子，展示了一个不同以往的模板函数调用方式funName&lt;actual_type&gt;(arg1, arg2)： 123456789101112131415#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;void print(T x, T y)&#123; cout &lt;&lt; &quot;print result : &quot;&lt;&lt; x+y &lt;&lt;endl;&#125;int main()&#123; print&lt;int&gt;(1,2); // print(1,2); return 0;&#125; 但相比funName(arg1, arg2) 这种方式，上面的才是更接近本质的调用方式。 因为print(1,2)，本质就是编译器克隆了函数模板void print(T x, T y)，将模板类型T替换为我们指定的实际类型&lt;int&gt;，最终生成指定类型的函数void print&lt;int&gt;(int x, int y) 。 亲眼看一看：实例化完成后编译的内容。 由于直接使用 g++ -S 生成的是汇编代码，不太直观，我们借助https://cppinsights.io/ 观察模板实例化后的代码。 12print&lt;int&gt;(1,2);print&lt;double&gt;(1,2); 实例化后，编译器确实生成了两个函数：void print&lt;int&gt;(int x, int y)、void print&lt;double&gt;(double x, double y)供我们调用。 上述从函数模板创建指定类型的函数的过程，称为函数模板实例化。如果这个过程是因为函数调用而产生的，则称为隐式实例化。 实例化函数每次调用都会发生吗？仅在第一次函数调用时实例化，对该函数的进一步调用将路由（指向）到已实例化的函数。 最佳实践：优先使用普通函数调用方式，即print(1,2) 。 3.3.2 多个函数模板类型 多个函数模板类型适用于函数拥有多个不同类型参数的情况。 请看下例： 1234567891011121314#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;T max(T x, T y)&#123; return (x &gt; y) ? x : y;&#125;int main()&#123; cout &lt;&lt; max(2, 3.5) &lt;&lt; &#x27;\\n&#x27;; // compile error return 0;&#125; 继续往下阅读前，请思考：为什么编译会出错？有什么好的解决办法吗？ 为什么编译出错？ 根据调用的函数max(2, 3.5) ，编译器会尝试寻找匹配的函数，没找到转下一步； 编译器尝试根据函数模板max(T,T)，生成函数max(int,double) 。显然这是不可能生成不同类型的参数。 函数调用解析出错。 当然你可能还会问：为什么编译器不会生成函数max(double,double)，这调用时max(int,double) 中int可以隐式转换为double呢? 因此，类型转换仅在解析函数重载时进行，而不是在执行模板参数推导时进行。 有什么好的解决办法吗？ 当然，最简单办法是传参时便进行类型转换： 1cout &lt;&lt; max(static_cast&lt;double&gt;(2), 3.5) &lt;&lt; &#x27;\\n&#x27;; 这样函数模板就可以生成函数max(double,double)，从而正确被调用了。但这很不cool。 或者你又想到了，我们不是新学会一种调用函数模板的方法吗，它可以显示指定转换类型，编译器就不用自己去推导了： 1cout &lt;&lt; max&lt;double&gt;(2, 3.5) &lt;&lt; &#x27;\\n&#x27;; 这也是ok的。 但最佳的解决办法，还是从根源解决：既然是调用参数类型有多个，而模板函数参数类型只有一个导致出现上面的问题。 那为什么不直接定义模板函数时也定义为多个类型呢？ 多个模板类型参数 1234567891011121314#include &lt;iostream&gt;using namespace std;template &lt;typename T,typename U&gt;T max(T x, U y)&#123; return (x &gt; y) ? x : y;&#125;int main()&#123; cout &lt;&lt; max(2, 3.5) &lt;&lt; &#x27;\\n&#x27;; // compile error return 0;&#125; 好了，一切看起来挺不错，让我们输出一下： 13 啊？大惊失色。为什么输出结果是3而不是3.5？ 因为函数内部结果3.5为double 类型，返回的是T类型，已经被编译器自动推断（根据传的参数2）替换为int 类型。因此将3.5强制转换为3。 那我们直接指定返回类型T 变为U 不就行了吗？很可惜，不行。因为T、U的实际类型都是根据调用时传的参数进行推断的，而调用时传递参数的位置可以随意换动。 12// cout &lt;&lt; max(2, 3.5) &lt;&lt; &#x27;\\n&#x27;; cout &lt;&lt; max(3.5, 2) &lt;&lt; &#x27;\\n&#x27;; 此时U被推断为int 类型。更好的做法是使用auto关键字，自动推导函数的返回类型。 12345template &lt;typename T,typename U&gt;auto max(T x, U y)&#123; return (x &gt; y) ? x : y;&#125; 输出： 13.5 好了，一切都好起来了。关于auto关键字还会在后面做更详细的总结，希望你有了个初步的认识。 3.4 函数参数🌟 ⚠️ 本节知识设计到较多指针和引用相关内容，此前无基础建议先阅读：第二章：指针和引用。 在正式探讨函数参数前，我们先了解下函数中的两种参数： 形式参数：函数声明时表示的变量，函数调用时才分配内存。 实际参数：调用函数数实际传递的参数值，必须是确定的值。 12345void foo(int x, int y) // x,y 是形参&#123;&#125;foo(6, 7); // 6,7 是实参，被赋值给形参x,y 它们更多的区别会在3.4.6节中进行对比。 本节核心：按值传递、按引用传递和按指针传递，这 3 种向函数传递参数的主要方式。我们一起了解下吧。 3.4.1 按值传递 什么是按值传递？ 一般来说，C++ 中的非指针参数都是按值传递：实参的值被复制到相应函数形参中。 按值传递既然是复制，即只是将实参的副本传递给函数，那么函数修改副本（形参）的值是不能影响到实参值。请看下例： 123456789101112131415#include &lt;iostream&gt;void foo(int y)&#123; y = 6;&#125;int main()&#123; int x&#123; 5 &#125;; cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &#x27;\\n&#x27;; foo(x); // 实参x复制一份给y cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &#x27;\\n&#x27;; return 0;&#125; 输出： 12x = 5x = 5 x的值并没有被改变，虽然foo 函数内容修改了传递过来的值，但那只是x的副本。 上图对这一过程进行形象说明，注意到实参x、形参y对应的是不同内存区域（地址都不一样）。 什么时候用值传递？ 按值传递通常用于需要传递的参数不希望被修改的时候，实参可以是：变量（例如 x）、数字（例如 6）、表达式（例如 x+1）、结构和类以及枚举数。 但是按值传递也有明显的缺点，应该避免以下几种情况使用： 复制结构和类。复制结构和类开销过大，导致明显性能损失； 希望参数被改变； 返回多个值。 其它情况优先考虑值传递。 3.4.2 按引用传递 为什么需要引用传递？ 在前面我们说到值传递的几个缺点：复制结构和类开销大、无法改变参数、只能返回一个值。 对应，如果你不希望以上发生，请使用引用传递。 引用就相当于变量别名，操作引用等价于直接操作本体变量。请看下例： 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;void getAdd(int x_add_1, int&amp; y_add_2,int&amp; z_add_3)&#123; x_add_1 += 1; y_add_2 += 2; z_add_3 += 3;&#125;int main()&#123; // print(1.2,2); int x = 0 ,y = 0 , z =0; getAdd(x,y,z); cout &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; y &lt;&lt; endl; cout &lt;&lt; z &lt;&lt; endl; return 0;&#125; 输出： 123023 上述过程简略分析。 引用传递变量 y 、z 均被修改（x值传递未被修改）。 类似值传递。例如，引用传递中的y_add_2 也是被调函数栈上的一个局部变量，它保存了y的地址。对于引用参数的任何处理都会通过间接寻址，等价直接操作实参y本体。 特别的，引用还有几个特点（2.2节）： 引用必须使用右值进行初始化，除非是执行常量的引用； 引用传递值必须被初始化，所以不必担心空值。 这么棒了你后面还讲指针传递干嘛？ 一般来说，我们确实推荐尽量使用引用传递参数，但是地址传递参数还是有它的用武之地。 比如，引用传递值可以使得函数“返回”多个值： 1void getAdd(int x_add_1, int&amp; y_add_2,int&amp; z_add_3); 但是观察这个表达式，输入参数x_add_1 ，和输出参数（返回值）y_add_2、z_add_3 放在一块，无法很好的区分哪些是要被修改的（输出参数）。毕竟，它们连调用都是这么相似： 12 int x = 0 ,y = 0 , z =0;getAdd(x,y,z); 你能区分哪些是x、y、z哪些输出参数吗？ 3.4.3 按指针传递 为什么要需要指针传递值? 前面说到，引用传值用来“返回”多个参数时，很难区分哪些参数是输出参数，连调用时都过分相似（多胞胎搞人心态是吧？）。 上面代码修改为指针传值后，函数形参由&amp;变为*： 123456void getAdd(int x_add_1, int* y_add_2,int* z_add_3)&#123; x_add_1 += 1; *y_add_2 += 2; // y_add_2存的是y的地址，使用*操作符取值 *z_add_3 += 3;&#125; 调用时（y、z可以很好的认出是输出参数）： 12int x = 0 ,y = 0 , z =0;getAdd(x,&amp;y,&amp;z); // &amp;--取地址运算符 输出： 123023 上面，y_add_2 获取了形参&amp;y保存的值，即变量y的内存地址。通过取值运算符*y_add_2 ，可以获取变量y的内存区域操作权，即可以修改y的值了（+2）。因此变量y的值被修，z同理。 惊讶！指针其实值传递？ 这就是说我们像值传递一样将实参的值（一般是某个变量的地址）复制了一份给形参，形参也作为局部变量在栈中开辟了内存空间。 换句话说，指针是按值传递的！当然，这其实没多大惊讶（除非你和作者一样是个惊讶怪），因为我们早在2.1节分析过，指针本质就是一个变量，它有自己的值（其它变量的地址）和自己的地址。 请看下例，试分析：为什么pfive值没有被修改成功？ 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;// 变量 ptr保存了p_five的值（five的地址）void setNull(int* ptr)&#123; ptr = NULL; &#125;int main()&#123; int five = 5; cout&lt;&lt;&amp;five&lt;&lt;endl; int* pfive = &amp;five; // p_five = &amp;five = 0x7ffdb136b8e4 cout&lt;&lt;&amp;pfive&lt;&lt;endl; setNull(pfive); // 将p_five指向null cout&lt;&lt;pfive&lt;&lt;endl; // 输出此时p_five内存地址 return 0;&#125; 输出： 12340x7ffd037a0ecc0x7ffd037a0ec00x7ffd037a0ea80x7ffd037a0ecc 显然pfive没有修改成功（NULL）。整个过程如图所示： 局部变量pfive 保存了&amp;five的值，即five 的地址； 随后pfive作为实参，其值（five地址）复制给形参ptr，编译器给形参ptr开辟了空间专门保存five地址； 随后ptr=NULL，但是影响不到pfive，二者是不同的变量拥有各自独立的空间。 这验证了我们之前的结论：指针传值只是复制了实参值给形参，只不过这个实参值一般是某个变量的地址。 那如果我们想在指针传值时修改形参就可以影响实参？ 显然这就是引用的做法，对形参的任何修改直接等价操作实参本体。不过为了更好的讲解，我们先总结一下前面引用、指针传值的用法。 我们知道引用相当于变量的别名，使用引用时可以认为就是在使用变量本身。 1int&amp; a_ref = a; // 使用a_ref和使用a没什么区别 又如之前的引用传值： 1234567891011void func(int&amp; var)&#123; // var = ...;&#125;int main()&#123; int tmp = 0; func(tmp); return 0;&#125; 此时形参是int&amp; var ，实参tmp ，实参值初始化形参var，就相当于： 1int&amp; var = tmp; 也可以推广到函数其余参数传递情况： 值传递 1234567891011void func(int var)&#123; // var = ...;&#125;int main()&#123; int tmp = 0; func(tmp); return 0;&#125; 实参值初始化形参var等价于： 1int var = tmp; 指针传递 1234567891011void func(int* var)&#123; // *var = ...;&#125;int main()&#123; int tmp = 0; func(&amp;tmp); return 0;&#125; 实参值初始化形参var等价于： 1int* var = &amp;tmp; 好了，接受了上面的概念，我们再来说说怎么修改形参ptr 等价于修改实参pfive？ 1234567891011121314151617#include &lt;iostream&gt;using namespace std;// 变量 ptr保存了p_five的值（five的地址）void setNull(int* ptr)&#123; ptr = NULL; &#125;int main()&#123; int five = 5; int* pfive = &amp;five; setNull(pfive); // 将p_five指向null cout&lt;&lt;p_five&lt;&lt;endl; // 输出此时p_five内存地址 return 0;&#125; 显然，引用可以做到这点：将ptr 视为pfive的别名： 1int*&amp; ptr = pfive; 只需将第5行修改为： 1void setNull(int*&amp; ptr) 我们再尝试输出： 10 // 表示指针指向NULL 3.4.4 最佳实践 传引用快还是传指针快？ 虽然前面的分析，你对引用和指针传递有一定的了解、区分。 但如果要你回答这么一个问题：是传引用快还是传指针快？ 先上结论：一样快。 因为引用就是特殊的指针，它底层实现和指针是一致的。 准备一段地址传参代码： 1234567891011void func(int* y)&#123; *y = 2;&#125;int main()&#123; int x = 0 ; func(&amp;x); return 0;&#125; main对应汇编代码如下： 123456789101112131415main: # 保存main栈帧信息 pushq %rbp movq %rsp, %rbp subq $16, %rsp # 用0初始化x（对应地址为-4(%rbp)，并将x压栈 movl $0, -4(%rbp) # 将x地址保存到寄存器rax中，然后保存在rdi中 leaq -4(%rbp), %rax movq %rax, %rdi # 调用函数func call _Z4funcPi movl $0, %eax leave ret 可以看到main中最终将实参&amp;x（变量x的地址）保存在寄存器rdi中 。 接着我们开始重头戏func函数：指针通过保存变量地址到寄存器中，实现对变量所在内存区域进行修改，因此修改指针就是直接影响变量。 12345678910111213_Z4funcPi: # 保存func栈帧相关信息 pushq %rbp movq %rsp, %rbp # 进行地址复制：将寄存器rdi的值（实参&amp;x）复制给形参y（对应地址-8(%rbp)），并将y压栈 movq %rdi, -8(%rbp) # 进行赋值运算：先用寄存器rax保存形参y的的值（x的地址），然后将2复制给x movq -8(%rbp), %rax movl $2, (%rax) nop popq %rbp # 返回main ret 现在我们将上述代码从地址传递改为引用传递： 1234567891011void func(int&amp; y)&#123; y = 2;&#125;int main()&#123; int x = 0 ; func(x); return 0;&#125; 查看其汇编代码：不能说毫不相干，只能说和之前指针传值的汇编代码完全一模一样。 也就是说，引用本质和指针一样，都是通过保存变量对应内存区域地址，来实现操作变量。对引用的任何操作，都会通过间接寻址直接操作变量本身，只不过相比指针隐藏了一些细节（编译器对使用引用会自动加上*，2.2.1节）。 参数传递选择规则 有引选引。 优先选用引用传递（引用：拜托了），除非： 希望参数不被修改，选择按值传递，否则转下一步； 需要返回空指针、or返回局部变量内存、OR数组，选择按指针传递，否则转下一步。 数组怎么使用引用传参？ 这是个很有意思的问题。 先看看数组的引用： 12int array[] = &#123;1,2,3,4,5&#125;;int (&amp;arr)[5] = array; 此时数组的类型可以认为是int [5] ，&amp;arr 便是声明一个array的别名。 因此，我们如此使用数组的引用作为参数： 123456789101112131415#include &lt;iostream&gt;using namespace std;void modify_array(int (&amp;arr)[5])&#123; arr[0] = 0;&#125;int main()&#123; int array[] = &#123;1,2,3,4,5&#125;; modify_array(array); cout&lt;&lt;array[0]&lt;&lt;endl; return 0;&#125; 输出： 10 可以看到，确实被成功修改了。但int (&amp;arr)[5] 编译器要检查数组实参和形参的大小，扩展性太差！ 为此，我们使用模板进行改进（其余不变）： 12345678910111213template&lt;typename T,int N&gt;void modify_array(T (&amp;arr)[N])&#123; arr[0] = 0;&#125;int main()&#123; int array[] = &#123;1,2,3,4,5&#125;; modify_array(array); cout&lt;&lt;array[0]&lt;&lt;endl; return 0;&#125; 完美！ 3.4.5 参数传递总结 一些面试常考题对前面所学进行总结和验证。 形参和实参的区别？ 何时分配内存：形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元（这一部分内容还会在8.6函数返回值 详细举例）；实参在调用前就已经分配了内存。 参数类型： 实参可以是常量、变量、表达式、函数等，在进行函数调用时，它们都必须具有确定的值；实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。 单向传递。只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 值传递、指针传递、引用传递的区别？ 请看下表。 值传递 引用传递 指针（地址）传递 拷贝内容 实参的副本（数组例外，会退化为指针） 给实参起个别名 指针（4字节或8字节） 效率 低，特别是拷贝结构体或类对象时 高（推荐），起个别名即可 高，拷贝指针即可 是否修改 是 是 不能修改为其它对象的引用 初始化 不必要 一定要 不必要 何时使用 参数不希望被修改时 优先选用引用、传递结构或类对象、希望参数被修改 返回多个值、需传递空指针（引传递用不允许空值）、返回局部变量内存（3.5中详述） 指针传递、引用传递底层区别？ 指针传递本质是值传递。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。 所以形参指针（内容）变了（保存了其它变量地址），实参指针不会变。 引出传递本质是间接寻址。引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，通过栈中存放的地址访问主调函数中的实参变量。 符号表不同。程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同，编译器直接处理为操作引用对象）。 3.4.6 特殊参数 在这一小节将来认识下比较特殊的两类参数。 命令行参数 如果你运行过一些开源代码/库，经常会要求你输入指定参数： 1$ program arg1 arg2 这为我们提供了一个可以向其他函数输入参数的方法，特别是你无法修改源码或程序需要用户提供参数时。当然，还可以通过配置文件实现，这里暂不表。 下面形式的main函数可以接受命令行参数： 12int main(int argc, char* argv[])int main(int argc, char** argv) 其中： argc：传递的参数量个数，至少为1，因为至少存在argv[0] 指向函数本身名称； argv： C风格二维数组，存储参数。例如，argv[0][0]指向第一个数组第一个字符，argv[0]是第一个数组第一个字符的地址。 一个简单的程序，打印用户输入的姓名和年龄： 12345678910#include &lt;iostream&gt;using namespace std;int main(int argc , char* argv[])&#123; cout&lt;&lt;&quot;the count of paramters: &quot;&lt;&lt; argc&lt;&lt;endl; cout&lt;&lt;&quot;the name of program: &quot;&lt;&lt; argv[0] &lt;&lt;endl; cout&lt;&lt;&quot;your name: &quot;&lt;&lt; argv[1]&lt;&lt;endl; cout&lt;&lt;&quot;your age: &quot;&lt;&lt; argv[2]&lt;&lt;endl;&#125; 特别的，操作系统对如何处理特殊字符（如双引号和反斜杠）有特殊的规则。 双引号：以双引号传递的字符串被认为是同一字符串的一部分（即使它们之间存在空格）； 1./test.out &quot;royhuang cqu&quot; 25 斜杠：如果要包含文字双引号，则必须反斜杠双引号。 1./test.out \\&quot;royhuang\\&quot; 25 省略号（可变参数） 到目前为止，在我们看到的所有函数中，函数将采用的参数数量必须事先知道。但是，在某些情况下，能够将可变数量的参数传递给函数会很有用。 1return_type function_name(argument_list, ...); 例如：我们要编写一个函数来计算一组整数的平均值。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdarg&gt; // needed to use ellipsisusing namespace std;double findAverage(int count, ...)&#123; double sum&#123; 0 &#125;; // 通过预定义宏va_list获取参数列表 va_list list; // 通过宏va_start对va_list初始化 va_start(list, count); // 求和 for (int arg&#123; 0 &#125;; arg &lt; count; ++arg) &#123; // 通过宏va_arg获取具体参数 sum += va_arg(list, int); &#125; // 使用完后通过宏va_end清理va_list va_end(list); return sum / count;&#125;int main()&#123; cout &lt;&lt; findAverage(5, 1, 2, 3, 4, 5) &lt;&lt; &#x27;\\n&#x27;; cout &lt;&lt; findAverage(6, 1, 2, 3, 4, 5, 6) &lt;&lt; &#x27;\\n&#x27;;&#125; 上述结果输出： 1233.5 看起来这很棒。但是我们并不推荐使用省略号： 省略号很危险：无法判断传递的参数个数是正确 假设你只传递了5个参数，而实际要求是6个： 1findAverage(6, 1, 2, 3, 4, 5) 在作者的机器上，这产生了奇怪的结果： 1699773 va_arg(list, int) 返回的前5个值是我们传入的值。它返回的第 6 个值（没有报错）是一个垃圾值堆栈。结果，我们得到了一个垃圾答案。 省略号很危险：类型检查被暂停 如果你尝试传递一个浮点数（1.0）作为参数： 1findAverage(6, 1.0, 2, 3, 4, 5, 6) 结果一定让你大吃一惊（这是什么？这么大的数字？） 11.78782e+008 这是因为va_arg(list, int) 指定预期类型是int ，但是我们又传递double类型参数。这导致： va_arg 的第一次调用将只读取 double 的前 4 个字节（产生垃圾结果）； va_arg 的第二次调用将读取 double 的后 4 个字节（产生另一个垃圾结果）； 因此，我们的总体结果是垃圾。 限定省略号：参数数量和类型 幸运的是，我们可以人为的传递一个“解码器字符串”，它告诉程序如何解释参数（限定了数量和类型）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdarg&gt; // needed to use ellipsisusing namespace std;double findAverage(std::string decoder, ...)&#123; double sum&#123; 0 &#125;; va_list list; va_start(list, decoder); int count = 0; while (true) &#123; char codetype&#123; decoder[count] &#125;; switch (codetype) &#123; default: case &#x27;\\0&#x27;: va_end(list); return sum / count; case &#x27;i&#x27;: sum += va_arg(list, int); ++count; break; case &#x27;d&#x27;: sum += va_arg(list, double); ++count; break; &#125; &#125;&#125;int main()&#123; cout &lt;&lt; findAverage(&quot;iiiii&quot;, 1, 2, 3, 4, 5) &lt;&lt; &#x27;\\n&#x27;; cout &lt;&lt; findAverage(&quot;iiiiii&quot;, 1, 2, 3, 4, 5, 6) &lt;&lt; &#x27;\\n&#x27;; cout &lt;&lt; findAverage(&quot;iiddi&quot;, 1, 2, 3.5, 4.5, 5) &lt;&lt; &#x27;\\n&#x27;;&#125; 看起来很好，但是一般情况我们完全有其它合理的解决方案。比如：为什么不将... 换成一个数组？ 换成其它方案：动态数组 一般情况，我们都要避免使用省略号，选择其它的方案。比如这里我们完全可以传递一个数组作为参数。 1double findAverage(int len, int* nums); 3.5 函数返回值 在前面我们学习了按值、引用和地址向函数传递参数，如果作为函数返回值会有什么不同呢？ 按值返回的是value的副本？ 按指针返回的是value的地址？局部变量在退出函数被销毁时，它的地址不是没有了吗？ 按引用返回的是value的别名？局部变量在退出函数被销毁时，别名还有用吗？ 请看下文分解。 3.5.1 按值返回 和按值传参一样，按值返回很安全，因为它只返回value的副本，不用担心返回之后value发生什么变化。 1234567891011int doubleValue(int x)&#123; int value&#123; x * 2 &#125;; return value; &#125; int main()&#123; int res = doubleValue(1); return 0;&#125; 当然，它的缺点也和按值传参一致，返回大型结构或类时很慢。一般希望值不被修改或者返回局部变量时使用值传递。 返回局部变量？函数调用结束时局部变量不就被销毁了，为什么还能返回？ 在函数调用过程中是局部变量被压到栈中，当函数退出时，临时变量出栈，确实已经被销毁。 但局部变量作为返回值时在函数调用时，有些特别的变化。 C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit。 由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。 下图的汇编代码也表明了这一点： 这也就是为啥：上述代码value虽然作为返回值但也是局部变量，函数调用结束时，依旧正确返回了其值。 现在让我们来特别关注一下按地址/引用返回局部变量的情况。 3.5.2 按指针返回 和按指针传递参数类似，按指针返回的只是将value 的地址复制一份返回，所以速度很快。 危险：返回局部变量地址 局部变量在函数退出时就会被销毁，如果尝试返回局部变量的地址，这种行为非常的危险（地址对应的内存可能已被释放）： 12345678910111213141516#include &lt;iostream&gt;using namespace std;int* doubleValue(int i)&#123; int d_value = i*2; return &amp;d_value; // 返回局部变量地址&#125;int main()&#123; int value = 3; int* p = doubleValue(value); cout&lt;&lt;*p&lt;&lt;endl; return 0;&#125; 输出： 编译器（VSCode）给出了警告，虽然输出值很幸运是正确的。但这是因为局部变量d_value对应栈空间还存在没有被重新分配使用，通过地址获取到了正确的值。 很显然这种做法很危险，你并不知道什么时候就返回的是一个垃圾值，因此不建议你去尝试。 那按指针返回还有什么用途吗？ 按指针返回常用于将动态内存返回给调用者，因为动态分配的内存不会在函数退出时被销毁。 1234567891011int* allocateArray(int size)&#123; return new int[size]; // 动态分配空间&#125;int main()&#123; int* array&#123; allocateArray(25) &#125;; delete[] array; return 0;&#125; 不过，分配空间（new[]）和删除空间（delete[]）在代码不同的函数中，使得谁负责删除资源和是否需要删除资源变得有点难以理解。 这里更好的做法是使用智能指针，第二章有相关介绍。 另外一个用途就是返回按地址传递的参数。 12345678910111213int* doubleValue(int* p_i)&#123; *p_i = (*p_i)*2; return p_i; // 返回指针参数p_i&#125;int main()&#123; int value = 3; int* p = doubleValue(&amp;value); cout&lt;&lt;p&lt;&lt;endl; return 0;&#125; 不说说返回地址其它用途吗？ 既然提到返回地址很快，那用来返回结构体、类不应该很好吗？然而并不是。道理同参数传递中尽量建议使用引用一样： 引用更安全。引用一定会被初始化，不能为空。 引用效率更好。比如它不用管理指针析构释放之类的问题。 3.5.3 按引用返回 与按指针返回类似，按引用返回的值不能是局部变量。 危险：不要返回局部引用 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int&amp; doubleValue(int i)&#123; int d_value = i*2; return d_value; // 返回局部引用&#125;int main()&#123; int value = 3; int&amp; ref = doubleValue(value); cout&lt;&lt;ref&lt;&lt;endl; return 0;&#125; 道理同上按指针返回，除非你想哪天收到一个对垃圾的引用。 什么时候按引用返回 除了上述说的按值返回、按指针返回的情况，其它时候一般都建议按引用返回。 比如返回大型数据结构、类等，以及返回按引用传递参数时。 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int&amp; doubleValue(int&amp; i)&#123; i = i*2; return i; // 返回按引用传递的参数i&#125;int main()&#123; int value = 3; int&amp; ref = doubleValue(value); cout&lt;&lt;ref&lt;&lt;endl; return 0;&#125; 3.5.4 小结 编码时选择何种方式返回参数？ 和选择何种方式传递参数很像： 不想修改value就是想返回value一个副本，or返回局部变量（见下节述）用值传递，否则转下一步； 需要动态内存分配时、返回按地址传递的参数，选择地址传递，否则转下一步； 其它情况，一般选用引用传递（返大型结构体、类、按引用传递的参数）。 3.5.5 返回多个值 在3.4.3 介绍了使用地址传递参数，达到类似返回多个参数的效果。但是这种做法比较别扭，也不够优雅。C++有两种比较好的方式： 使用结构体 将要返回的多个参数定义为一个结构体，最后直接返回结构体。 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;struct S&#123; int m_x; double m_y;&#125;;S add()&#123; S s; s.m_x++; s.m_y++; return s; // 值传递，复制一个s的副本返回&#125;int main()&#123; S s = add(); cout &lt;&lt; s.m_x &lt;&lt; &#x27; &#x27; &lt;&lt; s.m_y &lt;&lt; &#x27;\\n&#x27;; return 0;&#125; 相比返回数组，结构体允许定义更多类型的值，显然更灵活。元组 std::tuple 也可以定义不同类型元素序列。 使用元组 见下例，使用元组返回多个不同类型的值。 12345678910111213141516#include &lt;tuple&gt;#include &lt;iostream&gt;using namespace std;tuple&lt;int, double&gt; returnTuple() &#123; return &#123; 5, 6.7 &#125;;&#125;int main()&#123; tuple s&#123; returnTuple() &#125;; cout &lt;&lt; get&lt;0&gt;(s) &lt;&lt; &#x27; &#x27; &lt;&lt; get&lt;1&gt;(s) &lt;&lt; &#x27;\\n&#x27;; return 0;&#125; 3.6 内联函数 函数给我们提供了非常多有用的功能： 代码可以重复使用； 提供类型检查，确保参数类型匹配（类似函数的宏不会）； 便于阅读、调试； … 3.6.1 那函数有什么缺点吗？ 函数的一个主要缺点是每次调用函数时，都会发生一定量的性能开销（中断等），比如： CPU 必须存储它正在执行的当前指令的地址（因此它知道稍后返回到哪里）以及其他寄存器； 必须创建所有函数参数并赋值，并且程序必须跳转到新位置； … 当然，对于大型复杂的函数，函数调用时间相比函数运行时间微不足道。但是对于比较轻巧的函数，若是频繁调用，函数调用的时间便很可观了。 此时，我们希望这些轻巧又被经常调用的函数，最好不好进行这些复杂调用、返回操作。 如何做到这一点？类似于预编译头文件的替换，直接把函数体嵌入到每一个调用了它的地方，重复地嵌入。 请看下例： 1234567891011inline int min(int x, int y)&#123; return x &gt; y ? y : x;&#125;int main()&#123; min(5, 6) ; min(3, 2) ; return 0;&#125; min(int,int) 被声明为内联函数。在编译时，相当直接在相应调用位置替换为实际min(int,int)函数体： 123456int main()&#123; return 5 &gt; 6 ? 6 : 5 ; return 3 &gt; 2 ? 2 : 3 ; return 0;&#125; 小问题：内联函数这么棒，那把所有的函数写成内联函数? 内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。 只适合比较简单的函数。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义； 占用内存空间多。另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间。 典型的空间换时间策略。 3.6.2 内联函数什么时候被替换？ 在前面我们知道，宏会由预处理器对宏进行替代（预编译阶段）。而内联函数也会通过编译器来实现展开替换（编译阶段）。 为了更好地验证所学，我们通过反汇编来对比加上inline前后代码的不同之处对比。 准备一个更简单的代码： 1234567891011inline int add(int y)&#123; y++;&#125;int main()&#123; int x = 0; add(x); return 0;&#125; 生成可执行文件后进行反汇编： 12g++ -save-temps -fverbose-asm -g test.cpp -o test.outobjdump -S --disassemble test.out 关键性代码截图如下： 可以看到main 函数体内被直接插入了add函数的代码（绿色框）。 但是如果add函数是非内联函数： 12// 防止编译器自己优化，强制声明为非内联函数int __attribute__ ((noinline)) add(int y) 反汇编结果如图所示，add函数代码并没有插入到main函数体内。 3.6.3 内联函数和宏对比 一个常考的面试题，加深下印象。 替换时机。宏在预编译时被替换，内联函数是在运行时（至少不是预编译时）； 调试。内联函数在运行时可调试，而宏定义不可以; 安全。编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会； 访问。内联函数可以访问类的成员变量，宏定义则不能。 3.7 函数指针 3.7.1 函数和指针 在前一节，通过反汇编，你也看到了（在main函数中）调用（add）函数是通过一个地址，例如： 1callq 40052d&lt;_Z3addi&gt; 其中 40052d 便是函数add 的地址。让我们尝试打印一下函数地址： 123456789101112131415#include&lt;iostream&gt;using namespace std;int func(int a)&#123; cout&lt;&lt;a&lt;&lt;endl;&#125;int main()&#123; // 如果你的编译器打印出来的地址是1 // 需要转换为空指针，强制编译器打印出地址：(void*)func cout&lt;&lt;func&lt;&lt;endl; return 0;&#125; 输出： 10x4007ad 可以看到，就像指针一样，func 保存的也是一个地址，只不过它保存的是函数地址。有函数地址就可以调用函数，此时可将函数压入栈（3.8节详述）。 像指针一样？那么可以像下面这样，使用int*指针保存函数指针吗？ 12int* p_func = func;p_func(3); 很不幸报错了： 主要原因是因为：虽然func 和p_func都是指针，但它们类型是不一样的。函数func 类型是int(*)() ,而我们给出的指针p_func类型是int* ，无法赋值。就像你不能将string* 类型指针赋值给int* 类型指针。 所以，我们至少还得让他们参数类型一致： 12int (*p_func)() = func;p_func(3); 依旧报错了： 这是因为函数指针p_func的类型参数和函数func不一致，编译器类型检查时出错。 题外话：为什么是在运行时报错，而不在编译代码时报错？ 因为函数指针是在运行时才会进行解析。 我们还应该指定其参数类型： 12int (*p_func)(int) = func;p_func(3); 一切到此就好起来了。p_func此时获得了函数的地址，就可以像func一样使用了。 特别的下面这种方式也是正确的： 12int (*p_func)(int) = &amp;func; // 函数名多了个&amp;，func和&amp;func打印出来其实是一样的，都是函数地址p_func(3); 3.7.2 为什么需要函数指针：回调函数 虽然，前面我们了解了怎么定义和使用函数指针。但不禁还是有疑惑：使用函数指针p_func 调用函数func不是多此一举？直接使用func不就好了？ 想象这么一种情况： 你有一个函数假定为funcA , 但你的功能需要外部自定义一些规则，这些规则用户自定义的； 所以你需要一个“参数”来保存这些特定的规则，而这个规则显然是一个逻辑集合——换句话，它应该是个函数。 那么这个“参数”是不是应该是函数类型？某个函数如果作为参数传递给另一个函数，就是回调函数。 我们举一个更具体的例子： 我们定义一个排序函数，将数字进行排序：但排序的规则由用户自定义，它可能是从大到小排列，也可能是从小到大或者其它——总之它取决于用户怎么定义“规则”。 我们给定一个排序函数如下，它有一个参数bool (*comparisonFcn)(int, int)用来定义排序规则： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include &lt;functional&gt;using namespace std;// 交换数组值void swap(int* arr,int idx_i,int idx_j)&#123; int tmp = arr[idx_i]; arr[idx_i] = arr[idx_j]; arr[idx_j] = tmp;&#125;// 自定义排序规则bool myCompare(int a, int b)&#123; return a &gt; b? false: true;&#125;// 冒泡排序void bubbleSort(int* arr, int len, bool (*compare)(int,int))&#123; for(int i = 0; i &lt; len; i++) // 外轮=n-1 // * j=0,每次都是从头开始比较 for (int j=0; j&lt; len-i-1; j++ ) // 内轮=余下乱序数-1 &#123; if (compare(arr[j],arr[j+1])) swap(arr,j,j+1); &#125;&#125;int main()&#123; int array[] = &#123;5,4,1,3,2&#125;; int len = sizeof(array)/sizeof(array[0]); bubbleSort(array,len,myCompare); for(int i=0; i&lt;len ;i++) cout&lt;&lt;array[i]&lt;&lt;endl; return 0;&#125; 输出： 1234554321 显然这种方式，优雅且灵活，除了定义的函数指针实在过于丑陋。当然在上述myCompare 函数中，你甚至可以定义一些奇怪的规则： 1234567bool myCompare2(int a, int b)&#123; if ((a % 2 == 0) &amp;&amp; !(b % 2 == 0)) return false; else return true;&#125; 你可以尝试输出试一试。 3.7.3 更优雅地使用函数指针 前面我们提到，函数指针的声明实在过于丑陋： 12bool (*compare)(int,int);bool (*)(int,int) compare; 好消息你现在有两种方式让它看起来顺眼很多： 1. 类型别名 12345678// 类型别名using bool_compare = bool(*)(int,int);// 函数中使用：就行使用普通的类型一样void bubbleSort(int* arr, int len, bool_compare compare)&#123; // ...&#125; 2. function std::function是标准库 &lt;functional&gt; 头文件的一部分。 1#include &lt;functional&gt; 我们将之前的排序函数，重新定义为： 1void bubbleSort(int* arr, int len, std::function&lt;bool(int,int)&gt;) 在主函数中，如此调用： 123456789101112// 其余函数代码同前，略int main()&#123; int array[] = &#123;5,4,0,1,3,2&#125;; int len = sizeof(array)/sizeof(array[0]); std::function&lt;bool(int,int)&gt; compare = myCompare; bubbleSort(array,len,compare); for(int i=0; i&lt;len ;i++) cout&lt;&lt;array[i]&lt;&lt;endl; return 0;&#125; 输出： 123456543210 3. function是什么？ 有一个很有意思的事情，函数定义必须要和主函数中传递的参数类型一致（都是std::function），不能定义为指针： 1void bubbleSort(int* arr, int len, bool(*)(int,int) compare) 如果你这个时候这样调用函数： 123// 在main中std::function&lt;bool(int,int)&gt; compare = myCompare;bubbleSort(array,len,compare); 会报错：error: cannot convert ‘std::function&lt;bool(int, int)&gt;’ to ‘bool (*)(int, int)’。 因为std::function本质是一种类模板，不是函数，是对通用、多态的函数封装。 通过std::function对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，形成一个std::function对象。让我们不再纠结那么多的可调用实体，一切变的简单粗暴。 换句话说，std::function就是函数的容器，它自己是个类对象。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。 我们来看看它的原型： 12template&lt; class R, class... Args &gt;class function&lt;R(Args...)&gt; 类为function，R是返回值类型，Args是函数的参数类型。再回想我们之前的调用： 1std::function&lt;bool(int,int)&gt; compare = myCompare; 很显然，此时compare 本质是一个function类对象，只不过重载了其函数调用操作符()，所以使用的时候可以直接像函数一样调用。 特别的，function类还重载了赋值操作符=，这样可以将可调用的函数实体赋值给它。其函数调用操作符重载函数里间接的调用赋值时传进来的调用实体。 4. 使用auto 使用auto关键字自动推断类型，可更简便地使用函数指针： 1auto compare = myCompare; 但是这个时候compare隐藏了类型具体定义，如果希望读者更了解这段代码意义，使用typedef 应该是个更好的做法。 3.7.4 CPU眼中的函数指针：变量 去繁归真，我们来看看CPU眼中的函数指针是什么？ 答案可能会让你惊奇：它在CPU眼中不过是一个过度包装的变量而已，就像指针一样也只是变量。 参考：CPU眼里的“函数指针”：过度包装的“变量” - 阿布的视频 - 知乎 3.7.5 小结 什么是函数指针？ 函数指针是指向特殊的数据类型（即函数）的指针变量。 函数的名字也可视为是函数的指针； 使用重载后的() 即函数名() 便是调用一个函数。 它在CPU眼中不过是过度包装的“变量”。 函数指针的声明&amp;赋值方式？ 以下为例。 12int (*p_func)(int) = func int (*p_func)(int) = &amp;func 函数指针的用途？ 函数指针还允许将函数作为参数传递给其他函数，即回调函数。 3.8 栈和堆🌟 在这一节中，我们来了解程序运行时，函数调用更底层的过程。不过在这之前，我们先了解下内存布局。 3.8.1 内存布局 内存布局初识 323232位系统4GB（232=4GB2^{32}=4GB232=4GB）。 下图展示了一个虚拟进程（程序）内存空间运行时分布布局，注意到此时还多了堆&amp;栈用来给程序运行时进行空间分配。 一个程序（比如hello.out）本质是由数据段、代码段、.bss段（图中和数据段合并了）三个组成的。 另外，高地址的1GB（Windows默认2GB）空间分配给内核，也称为内核空间；剩下的3GB分给用户，也称用户空间（程序使用的）。 作为程序员，我们更关注的是用户空间中的内容，也就是： 栈（Stack）：存储代码中调用函数、定义局部变量(但不包含static修饰的变量)、保存的上下文等； 特点：存放的数据从栈顶（低地址）压入，也是从栈顶（低地址）弹出，所以有人说栈是向下生长的。函数退出时，所有数据会自动释放内存（出栈）。 文件映射区域 ： 栈和堆中间那个空白区域。动态库、共享内存等映射物理空间的内存，一般是 mmap 函数所分配的虚拟地址空间。 堆（Heap）：存储那些生存期与函数调用无关的数据，如动态分配的内存。堆（动态）分配的接口通常有malloc()、calloc()、realloc()、new等。 特点：相对于栈，堆是向上生长的；堆空间需要主动释放，否则会依然存在。 .bss段：全称Block Started by Symbol，也就是未被初始化的全局变量、静态变量的内容的一块内存区域。比如： 12345static int a; // a保存.bss段int b; // b保存在.bss段int main()&#123;&#125; 数据段（.data）：保存全局变量、常量、静态变量的内容的一块内存区域，区别.bss段在于变量已经被初始化。比如： 1234567static int a = 1; // a保存在.data段中静态区，1是文字常量在代码区int b = 2; // b保存在.data段中全局区，2是文字常量在代码区char* str = &quot;royhuang&quot;; // str保存在栈上，&quot;royhuang&quot;是字符常量，保存在常量区const int c = 3; // c保存在.data段中常量区，3是文字常量在代码区int main()&#123;&#125; 代码段（.text &amp; .init）： .text 用于存放整个程序中的代码， .init 用于存放系统中用来初始化启动你的程序的一段代码 。 一个程序本质其实都是由.bss段、数据段、代码段三个组成的。 静态存储区探讨 前面我们认识到C++内存布局分为： 堆：存放动态分配的内存； 栈：存放临时分配局部变量； 代码段：存储程序指令，也可能包含只读的常量（如文字常量）； .bss段和数据段：分别存储初始化和未初始化的全局变量和静态变量，数据段还可以存储常量。 .bss段和数据段主要区别在于是否初始化，这里我们不做区分，统称为静态存储区。 根据.bss段和数据段存储的数据类型，静态存储区又可分为： 静态变量区，存储静态变量 全局变量区，存取全局变量 常量区，存储字符串常量和全局常量（局部常量存储在栈中），只读 示例代码： 1234567891011121314151617// a保存在静态变量区，1是文字常量在代码区，此时a值为1static int a = 1; // b保存在全局变量区（此时值为2），2是文字常量在代码区，此时b值为2int b = 2; // c保存在常量区，3是文字常量在代码区，此时c的值为3const int c = 3; // str保存在全局区，&quot;royhuang&quot;是字符常量，保存在常量区，此时str只是保存&quot;royhuang&quot;地址char* str1 = &quot;royhuang&quot;; // str是数组，保存在全局区，此时str复制了字符串常量&quot;hwh&quot;，所以值为&quot;hwh&quot;char str2[] = &quot;hwh&quot;;int main()&#123; int d = 4; // d在栈上，4是文字常量在代码区，d的值在【运行时】被赋值为4 const int f = 5; // 区分c，此时f是局部变量保存在栈上，f在【运行时】被赋值为5 static int g = 6; // 同a char* str3 = &quot;roy&quot;; // 同str1，不过此时str3保存在栈上,&quot;roy&quot;在常量区&#125; 对应汇编代码也验证了这一点（静态变量区内容汇编代码未展示）： 还应注意到： 存储在静态存储区的变量的值，在编译期间就确定了； 而堆、栈上变量的值是运行时动态分配的。 继续分析下面这个问题： 1234567int main()&#123; char str[] = &quot;royhuang&quot;; str[0] = &#x27;h&#x27;; // ok char* pstr = &quot;royhuang&quot;; pstr[0] = &#x27;h&#x27;; // error，为什么？&#125; char str[] = &quot;royhuang&quot; ，str 保存在栈上，运行时将常量区的字符串常量“royhuang”，赋值给了数组str ，修改str数组成员是合法的； char* pstr = &quot;royhuang&quot; ，pstr 保存在栈上，但运行时只是将字符串常量“royhuang”的地址，赋值给了指针pstr ，尝试修改常量区的成员是非法的！ 3.8.2 函数调用过程 在这一小节我们来深入探讨下函数调用时的原理和过程。 栈帧 前面我们说到，栈是位于进程的高地址位置，且栈顶是向下增长的。在函数调用时，栈会专门使用一个独立的栈帧保存函数调用需要的所有信息。这对后面理解函数执行过程很关键。 一个典型的栈帧如下： 栈帧保存的内容：每一次函数调用需要的函数返回地址、参数、临时变量、保存的上下文等； esp和ebp ：非常重要的两个寄存器，记录了当前栈帧的栈顶位置和栈底位置（对于X86-64平台上来说，对应的寄存器则为rsp及rbp） 。 可以看到在上图压栈（push）会使得esp向下移动（地址变小）。 汇编分析 我们准备的验证代码： 1234567891011121314#include &lt;iostream&gt;using namespace std;int foo(int sp1, int sp2) &#123; int res = sp1 + sp2; return res;&#125;int main() &#123; int res = foo(1, 2); return 0;&#125; 反汇编的代码及分析如下。 main函数汇编代码 1234567891011main: pushq %rbp # 寄存器rbp保存上一个栈帧栈底位置 movq %rsp, %rbp # 寄存器rsp指向栈顶位置，用rsp内容初始化寄存器rbq subq $16, %rsp movl $2, %esi # 立即数寻址，将foo第二个参数存入寄存器esi中 movl $1, %edi # 将foo的第一个参数存入寄存器edi中 call _Z3fooii # 调用foo，转到分析foo函数汇编代码，此时call还将下一条指令当做返回地址压入到栈中 movl %eax, -4(%rbp) # 返回函数结果给res，它的地址是-4(%rbp) movl $0, %eax # eax被置为0，主函数退出 leave ret foo函数汇编代码 123456789101112_Z3fooii: pushq %rbp # 保存main的栈底地址rbp，用于返回 movq %rsp, %rbp # 重置foo函数的栈帧 movl %edi, -20(%rbp) # 参数1入栈 movl %esi, -24(%rbp) # 参数2入栈 movl -20(%rbp), %edx # 参数1存入edx movl -24(%rbp), %eax # 参数2存入eax addl %edx, %eax # 加法运算，结果保存在eax中 movl %eax, -4(%rbp) # 将运算结果赋值给result,它的位置为rbp-4 movl -4(%rbp), %eax # 将result赋值给eax，eax为函数返回值 popq %rbp # 跳转到main函数（栈底），然后还需要跳到返回地址 ret 栈压入顺序：当前栈帧状态信息（如rbp）—&gt; 当前函数的参数（逆序）—&gt;当前函数的局部变量等—&gt;…—&gt;退出。 在调用函数（main）函数中 保存上一个栈帧的rbp，重置main栈帧的rbp； 按照与被调函数foo的形参顺序相反的顺序压入栈中（在本例是直接存入寄存器中，因为直接传入常量foo(1,2)）； call指令调用： 调用者函数（main）使用call指令调用被调函数（foo），为foo函数分配栈帧空间，并把call指令的下一条指令的地址当成返回地址压入栈中（这个压栈操作是隐含的） 在被调用函数（foo）函数中 保存main栈帧的rbp，重置foo栈帧的rbp； 被调参数sp1、sp2压入栈中； 执行foo函数体中代码，返回值res入栈，然后保存在寄存器eax中 ； 执行完毕，栈帧所有数据出栈； popq %rbp 和 ret 跳转main中call指令的下一条指令地址继续执行。 回到调用函数（main）函数中 返回值res（寄存器eax中内容）压入栈； 继续main函数中后续代码执行； main函数退出。 3.8.3 malloc/free 原理 从静态分配说起 我们之前接触数据通常保存在： 栈，比如函数内部局部变量； 数据段，静态区、全局区、常量区； .bss段，未初始化的数据。 上面的数据有两个共同点： 变量/数组的大小必须在编译时知道。 内存分配和释放自动发生（当变量被实例化/销毁时）。 大多数时候，这很好。那什么时候在堆上分配内存？ 很多时候，我们需要在堆上动态申请/释放内存。 不知道分配对象的大小。比如我们想创建声明一个数组，但是事先并不知道数组的大小（稍后才能知道）。这个时候无法使用静态数组分配，因为它必须指定数组的大小； 分配的对象太大。栈等空间不够。 在C中，我们常常使用malloc/free在堆上分配和释放内存： 12345// 分配：大小为4的int数组int* array ;array = (int*)malloc(4*sizeof(int));// 释放free(array); malloc和free函数底层是如何去实现的，如何在堆上分配内存的？ 从堆块说起 主要参考：malloc 的实现原理 内存池 mmap sbrk 链表 什么是堆？ C++使用动态内存分配器（下简称分配器）进行动态内存分配，它维护一个进程的虚拟内存区域，也就是堆。 分配器眼里的堆是什么？如何进行管理？ 分配器将堆视为一组不同大小的块（block）的集合来维护。每个块就是一个连续的虚拟内存片（chunk）,要么是已分配的，要么是空闲的。 chunk结构图： 正在使用的chunk标识意义 prev_size： 表示前一个 chunk 的 size,程序可以使用这个值来找到前一个 chunk 的开始地址（P=0才有效）； size： 表示当前chunk的size大小； A：为1表示属于主分配区（已分配），否则属于非主分配区（未分配）； M：为 1 表示该 chunk 是从 mmap 映射区域分配的，否则是从 heap 区域分配的； P：为1表示前一个chunk在使用中，为0表示空闲。 空闲chunk标识意义 fd、bk ：分别指向前、后的空闲chunk，通过这种方式将将大小相近的chunk连成一个双向链表； 具体来说，分配器通过bins+空闲链表（非常类似哈希表），对堆块进行管理。 一个典型的堆整体结构： 可以看到，内存分成了大小不同的chunk，然后通过bins来组织起来；相似大小的chunk用双向链表链接起来，一个链表被称为bin。 unsorted bin：即bin[1]（bin[0]没有被使用），用于维护free释放的chunk； small_bins：即bins[2,63)，用于维护＜512字节的内存块，其中每个元素对应的链表中的chunk大小相同，均为index*8； large_bins：即bins[64,127)，用于维护&gt;512字节的内存块，每个元素对应的链表中的chunk大小不同，index越大，链表中chunk的内存大小相差越大； 在堆中，还有一个很特殊的top chunk。 产生时机：程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk，所以它不属于任何一个 bin； 作用：在于当所有的 bin 都无法满足用户请求的大小时，就使用top chunk进行分配，并将剩下的部分作为新的 top chunk。堆顶指针brk位于top chunk的顶部，移动brk指针，即可扩充top chunk的大小。 现在我们再来探讨malloc分配的过程。 malloc原理 glibc在内存池中查找合适的chunk时，采用了最佳适应的伙伴算法。 第一次分配内存时会进行堆初始化： 一开始时，brk和start_brk是相等的，这时实际heap大小为0； 如果第一次用户请求的内存大小&lt; mmap分配阈值，则（通过移动brk指针扩展堆大小）malloc会申请(chunk_size+128kb) align 4kb大小的空间作为初始的heap。 往后会按照顺序：bins查找分配–&gt;brk扩展堆分配—&gt;mmap分配： 如果分配内存&lt;max_fast=默认64B，在fast bins 中查找相应的空闲块； 如果分配内存&lt;512字节，则通过内存大小定位到smallbins对应的index上： 如果smallbins[index]为空，进入步骤3； 如果smallbins[index]非空，直接返回第一个chunk。 如果分配内存&gt;512字节，定位到largebins对应的index上： 如果largebins[index]为空，进入步骤3； 如果largebins[index]非空，扫描链表，找到第一个大小最合适的chunk，如size=12.5K，则使用chunk B，剩下的0.5k释放并放入unsorted_list中。 遍历unsorted_list： 查找合适size的chunk，如果找到则返回； 否则，将这些chunk都归类放到smallbins和largebins里面。 在bin更大的链表寻找：从index++更大的链表继续寻找： 查找合适size的chunk，如果找到则返回，同时还会将chunk拆分，并将剩余的加入到unsorted_list中。 找不到则通过top chunk。 通过top chunk分配：默认top chunk分配的最大大小为128K（也是mmap分配的阈值）： top chunk大小&gt;分配的内存，则返回合适大小chunk，剩余的作为新的 top chunk； top chunk大小&lt;分配的内存&lt;128K，移动brk指针扩展top chunk大小，满足分配； 分配的内存&gt;128K，通过mmap分配内存。 通过mmap分配。在进程的虚拟地址空间中（堆和栈中间的文件映射区域）找一块空闲的虚拟内存返回地址。 总结以上，内存分配（malloc）主要由两种系统调用完成：brk和mmap（不考虑共享内存）。 brk：分配内存 &lt; DEFAULT_MMAP_THRESHOLD，走__brk，将数据段(.data)的最高地址指针_edata，往高地址推； mmap：分配内存 &gt; DEFAULT_MMAP_THRESHOLD，走__mmap，直接调用mmap系统调用。在进程的虚拟地址空间中（堆和栈中间的文件映射区域）找一块空闲的虚拟内存。 其中，DEFAULT_MMAP_THRESHOLD是mmap分配阈值，默认为128K。 值得注意的是，这两种方式分配的都是虚拟内存，没有分配物理内存。只有实际调用发生缺页中断时，才会建立虚拟内存和物理内存之间的映射关系。 不过这里有个小问题，既然brk、mmap提供了内存分配的功能，直接使用brk、mmap进行内存管理不是更简单吗，为什么需要glibc呢？ 因为系统调用本身会产生软中断，导致程序从用户态陷入内核态，比较消耗资源。试想，如果频繁分配回收小块内存区，那么将有很大的性能耗费在系统调用中。 因此，为了减少系统调用带来的性能损耗，glibc采用了内存池的设计，增加了一个代理层，每次内存分配，都优先从内存池中寻找，如果内存池中无法提供，再向操作系统申请。 free原理 前面我们说到，C++将对视为堆视为一个个chunk（block）的集合，每个chunk的结构如下： malloc分配好内存，返回的是User data的起始地址，header则保存了当前chunk的一些信息。 但free并非真的直接将相应内存区域返回操作系统： 如果free 释放mmap 分配内存，free可以很顺利就释放掉其相关的虚拟和物理内存，返回操作系统； 如果free 释放 brk分配的内存，free只是标记chunk可被重新分配并加入空闲链表（A=0），但没有真的删除任何数据！ 123456int* a = new int(1);cout&lt;&lt;&quot;a = &quot;&lt;&lt;*a&lt;&lt;endl; // 1free(a);cout&lt;&lt;&quot;a = &quot;&lt;&lt;*a&lt;&lt;endl; // 0，数据被清除，但没被操作系统回收*a=2;cout&lt;&lt;&quot;a = &quot;&lt;&lt;*a&lt;&lt;endl; // 2，依据可以被使用，虽然这很危险 具体加入到空闲链表何处，也分三种情况考虑： 如果该chunk和top chunk相邻，则将其和top chunk合并； 特别的，如果top chunk&gt;128K，会执行内存紧缩（trim）操作移动brk指针。 如果free的chunk的大小在0x20~0x80之间（fastbin的范围），那么该chunk直接放到fast bin上； 如果free的chunk的大小大于0x80（大于fast bin的范围），此时不会直接放到small bin或者large bin上面，而是放到unsorted bin上面； 最佳实践：删除一个指针时，请将指针设置为 nullptr。 否则的话，使用一个指向的内存已经被释放的一种指针，是使用悬空指针。 （区分野指针是指使用时还没被初始化） 123cout&lt;&lt;*a&lt;&lt;endl; // 危，此时a是悬空指针，已经被free(a)a = nullptr; // 最佳实践：将已经释放的指针置空cout&lt;&lt;*a&lt;&lt;endl; // 此时编译器会报错，ok 可以看到，如果free的chunk没有和top chunk相邻被合并，其又太小的话，可能永远不会被使用——这就产生了内存碎片。 如下图： free(A)后，由于chunk A无法和top chunk合并，在堆中便产生了内存空洞，也就是内存碎片。幸运的是，它还足够大（40K），有很大概率其空间是能够被利用的。 小细节：free如何知道释放多大空间？ 在前面地址传递我们知道：向一个函数传递指针的时候，它的长度信息往往会被截断（如果是数组名），无法标示数组的长度。因此，在函数中我们也无法获取它的长度信息，除非显示传递一个长度参数。 那free如何知道释放多大的空间？ 原因很简单，free根本不用关系chunk大小，malloc分配的时候就是分配一个合适大小chunk。chunk包含header和user data。free只是将header中的相关标记为可用，加入空闲链表中即可。 3.8.4 new /delete 原理 在3.8.3节介绍了C语言中的动态内存分配方式：malloc，malloc函数分配失败返回指针空值，成功返回首地址。 现在我们来认识一下C++中的动态内存管理方式：new和delete。 准备好一个公共类Stu： 12345678910111213141516171819202122#include &lt;iostream&gt; #include &lt;stdlib.h&gt;using namespace std;class Stu &#123; public: Stu() &#123; cout &lt;&lt; &quot;默认构造函数初始化&quot; &lt;&lt; endl; &#125;; Stu(int num, string name):_num(num), _name(name) &#123; cout &lt;&lt; &quot;自定义构造函数初始化&quot; &lt;&lt; endl; &#125; ~Stu() &#123; cout &lt;&lt; &quot;析构销毁&quot; &lt;&lt; endl; &#125; private: int _num; string _name;&#125;; new原理 无论是new还是delete，它们在内置类型/自定义类型上使用有些不同。 new底层实现（内置类型） 对于内置类型来说，new和malloc功能基本一致： 分配内存空间； 返回内存空间地址。 不过new还可以进行初始化。 1234// 初始化单个：等同于int* a = (int*)malloc(sizeof(int));int* a = new int;// 初始化单个：同时进行初始化int* c = new int(10); new在C++中被定义为一个运算符，它会在底层调用全局函数operator new。 我们可以通过查看int* array = new int; 对应汇编源码验证： 123456# 首先在寄存器edi中存入数组大小（4，一个int大小）movl $4, %edi# 调用operator new分配空间call operator new(unsigned long)# 寄存器rax保存new返回的首地址给a（对应地址 -16(%rbp)）movq %rax, -16(%rbp) operator new只是malloc的一层封装： 12345678910111213141516171819202122232425void* __CRTDECL operator new(size_t const size)&#123; for (;;) &#123; // malloc if (void* const block = malloc(size)) &#123; return block; &#125; if (_callnewh(size) == 0) &#123; if (size == SIZE_MAX) &#123; __scrt_throw_std_bad_array_new_length(); &#125; else &#123; __scrt_throw_std_bad_alloc(); &#125; &#125; // The new handler was successful; try to allocate again... &#125;&#125; 执行流程： 当malloc申请空间成功时直接返回return (p)； 申请空间失败，尝试执行空间不足应对措施（malloc中失败直接返回空指针）； 如果改应对措施用户设置了，则继续申请，否则抛异常。 从源码中能看出的是operator new在底层是利用malloc分配内存，因此可以说new只是malloc一层封装。 new底层实现（自定义类型） 但对于自定义类型，new还会调用构造函数初始化： 调用operator new为对象分配内存； 调用对象的构造函数对对象进行初始化； 返回分配的内存空间地址。 分析下例： 123456789int main() &#123; // malloc分配对象 cout &lt;&lt; &quot;malloc:&quot; &lt;&lt; endl; Stu* a = (Stu*)malloc(sizeof(Stu)); // new分配对象 cout &lt;&lt; &quot;new:&quot; &lt;&lt; endl; Stu* b = new Stu(1, &quot;张三&quot;); &#125; 输出： 123malloc:new:自定义构造函数初始化 可以看到malloc分配的方式不会调用构造函数，但是new还会调用构造函数。 因此也可以理解为malloc分配出来的只不过是一个和类一样大小的空间（在前面我们称为chunk），并不能称作是一个对象，而new和delete分配出来的才能被成为对象。 new与new[] new[]和new有些细微区别： new[]是调用operator new[]对多个对象进行分配，operator new[]本质还是多次调用operator new； 但operator new[]还会多申请4个字节的空间保存此次对象个数。 为什么要这么做？ 使用delete[] 释放空间时可以知道被释放的对象个数。 当然，对于自定义类型，类似new，还会调用N次构造函数对N个对象进行初始化。 举例说明。 123456// malloc分配对象 cout &lt;&lt; &quot;malloc:&quot; &lt;&lt; endl;Stu* a = (Stu*)malloc(3*sizeof(Stu));// new分配对象cout &lt;&lt; &quot;new:&quot; &lt;&lt; endl;Stu* b = new Stu[3]; 输出： 12345malloc:new:默认构造函数初始化默认构造函数初始化默认构造函数初始化 delete原理 delete也分两种情况讨论： 对于内置类型：底层调用free实现，和free无多大区别（也没有异常处理）； 对于自定义类型：除了调用free释放对象空间，在此之前还会调用对象的析构函数。 通过具体例子来看看。 delete底层实现（内置类型） 先看一个简单的例子： 12int* a = new int;delete a; 查看对应的汇编源码，核心是调用operator delete： 1234567891011121314151617/*int* a = new int;*/# 首先在寄存器edi中存入数组大小（4，一个int大小）movl $4, %edi# 调用operator new分配空间call operator new(unsigned long)# 寄存器rax保存new返回的首地址给a（对应地址 -16(%rbp)）movq %rax, -16(%rbp)/*delete a*/movq -16(%rbp), %raxtestq %rax, %raxje .L2movl $4, %esimovq %rax, %rdi# 核心是调用operator delete# 前面在干什么？暂不清楚。call operator delete(void*, unsigned long) operator delete也只是free的一层封装（没有异常处理）： 12345678void __CRTDECL operator delete(void* const block) noexcept&#123; #ifdef _DEBUG _free_dbg(block, _UNKNOWN_BLOCK); #else free(block); #endif&#125; delete底层实现（自定义类型） 但对于自定义类型，delete还会调用析构函数： 调用对象的析构函数清理对象； 调用operator delete清理内存； 一个小例子： 1234567891011121314int main() &#123; // malloc分配对象 cout &lt;&lt; &quot;malloc:&quot; &lt;&lt; endl; Stu* a = (Stu*)malloc(sizeof(Stu)); cout &lt;&lt; &quot;free:&quot; &lt;&lt; endl; free(a); // new分配对象 cout &lt;&lt; &quot;new:&quot; &lt;&lt; endl; Stu* b = new Stu; cout &lt;&lt; &quot;delete:&quot; &lt;&lt; endl; delete b; return 0; &#125; 输出： 123456malloc:free:new:默认构造函数初始化delete:析构销毁 可见free不会调用析构函数，但delete会。 delete与delte[] delete[]用来删除多个对象（和new[]成对出现），本质是对每个对象调用delete清理。 大致流程如下： 首先根据对象数组前4个字节，获取对象个数N； 对后续每个对象使用delete删除。 同样的，对于自定义类型还会调用对象的析构函数： 12345678910111213141516int main() &#123; // malloc分配多个对象 cout &lt;&lt; &quot;malloc:&quot; &lt;&lt; endl; Stu* a = (Stu*)malloc(3*sizeof(Stu)); cout &lt;&lt; &quot;free:&quot; &lt;&lt; endl; // free释放内存 free(a); // new[]分配对象 cout &lt;&lt; &quot;new:&quot; &lt;&lt; endl; Stu* b = new Stu[3]; cout &lt;&lt; &quot;delete:&quot; &lt;&lt; endl; // delete[] 释放内存 delete[] b; return 0; &#125; 输出： 12345678910malloc:free:new:默认构造函数初始化默认构造函数初始化默认构造函数初始化delete:析构销毁析构销毁析构销毁 这里有两个有意思的小细节： malloc出的对象不会调用析构函数； 我们只用了一次free(a) 释放了分配对象数组a ，而对象数组b实际通过delete[] 调用了多次delete。 这个细节也验证了我们之前结论： malloc分配出来的只不过是一个我们需要的大小（这里是3个stu）的内存空间，它并没有真的分配了3个stu对象，所以free一次就可以释放这块内存。 但new[]是真正分配了3个stu对象内存空间，所以要delete多次且会执行析构函数。 plain/nothrow/placement new 在C++中，new有三种典型的使用方法：plain new，nothrow new和placement new。 plain new 言下之意就是普通的new，就是我们常用的new，在C++中定义如下： 1234// plain new原型void* operator new(std::size_t) throw(std::bad_alloc);// plain new对应deletevoid operator delete(void *) throw(); 可见plain new在空间分配失败的情况下，抛出异常std::bad_alloc而不是返回NULL。 因此通过判断返回值是否为NULL是徒劳的，请使用try-catch捕获异常： 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; try &#123; char *p = new char[10e11]; delete p; &#125; catch (const std::bad_alloc &amp;ex) &#123; cout &lt;&lt; ex.what() &lt;&lt; endl; &#125; return 0;&#125; 输出： 1bad allocation nothrow new nothrow new在空间分配失败的情况下不抛出异常，而是返回NULL，定义如下： 1234// nothrow new原型void * operator new(std::size_t,const std::nothrow_t&amp;) throw();// 对应delete原型void operator delete(void*) throw(); 举个例子： 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; char *p = new(nothrow) char[10e11]; if (p == NULL) &#123; cout &lt;&lt; &quot;alloc failed&quot; &lt;&lt; endl; &#125; delete p; return 0;&#125; 输出： 1alloc failed placement new placement new允许在一块已经分配成功的内存上重新构造对象或对象数组。 placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。定义如下： 1234// placement new原型void* operator new(size_t,void*);// 对应deletevoid operator delete(void*,void*); 主要用途：反复使用一块较大的动态分配的内存，来构造不同类型的对象或者他们的数组； 使用析构函数删除而不是delete：placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存）。这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。 举个例子： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class ADT&#123; int i; int j;public: ADT() &#123; i = 10; j = 100; cout &lt;&lt; &quot;ADT construct i=&quot; &lt;&lt; i &lt;&lt; &quot;,j=&quot;&lt;&lt;j &lt;&lt;endl; &#125; ~ADT() &#123; cout &lt;&lt; &quot;ADT destruct&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; char *p = new(nothrow) char[sizeof ADT + 1]; if (p == NULL) &#123; cout &lt;&lt; &quot;alloc failed&quot; &lt;&lt; endl; &#125; // 使用指针p申请的内存来构建类ADT对象adt // placement new：不必担心失败，只要p所指对象的的空间足够ADT创建即可 ADT *adt = new(p) ADT; /* delete adt; // error，不能在此处调用delete */ // 调用析构函数删除adt adt-&gt;ADT::~ADT(); // delete删除p delete[] p; return 0;&#125; 输出： 12ADT construct i=10,j=100ADT destruct 小结 new和delete分别是malloc和free的一层封装，对于自定义类型还会分别调用构造函数初始化/析构函数清理内存。不过new相比malloc还会有一层申请空间失败应对措施，以及可以初始化。 new[]/delete[]，是分别用来分配对象数组/清理对象数组的，本质是多次调用了new/free。值得注意的是，new[]分配的对象数组，还会多分配4个字节标识对象的个数。 在C++中有plain new，nothrow new和placement new。plain new就是最普通的new，分配错误返回bad alloc异常；nothrow new分配失败返回NULL异常；placement new不分配内存，请只调用析构函数进行释放，否则可能会导致double free。 3.8.5 问答测验 本节是八股重灾区，因为特地准备一些常见面试问题来巩固所学。 堆栈的区别？ 主要的区别如下： 申请方式：栈由系统自动分配，比如函数中的局部变量int a ，调用函数时会自动为a开辟空间；堆是程序员申请并负责释放，并指明大小，例如 int* array= new int[LEN]&#123;1,2,3&#125;; ，但指针array本身是存于栈中。 存储内容：栈存放和函数相关的数据，如定义局部变量(但不包含static修饰的变量)、保存的上下文等；堆存放函数无关的数据，如动态分配的内存。 大小限制：栈空间默认是4M，连续的 ；堆是不连续的内存区域，一般是 1G - 4G，大小受限于计算机系统中有效的虚拟内存。 申请效率：栈由系统自动分配，计算机在底层对栈提供支持，速度快；堆是由程序员new分配的内存，一般速度比较慢，但更灵活。 存储效率：栈的存取效率更高。请看下例： 123456789int main()&#123; int arr1[] = &#123;1,2,3&#125;; int* arr2 = new int[3]&#123;1,2,3&#125;; int a = arr1[0]; int b = arr2[0]; return 0;&#125; 转成汇编语言分析： new / malloc 的异同？ 都可用于内存的动态申请，返回用户分配使用空间的首地址。 本质：new是关键字，malloc是函数，所以malloc还需要引入库文件，new不用； 返回值类型：malloc返回的是void类型指针（必须进行类型转换），new返回的是具体类型指针； 空间计算：new会自动分配空间大小，编译器会根据类型信息自行计算，malloc需要手工计算； 类型安全：new是类型安全的，malloc不是； 12int *p = new float[2]; // 编译错误int *p = (int*)malloc(2 * sizeof(double));// 编译无错误 构造函数： new调用名为operator new的标准库函数分配足够空间，如果是自定义类型还会调用相关对象的构造函数，malloc则不会； 分配失败措施：new是malloc的一层封装，如果分配失败还会有相应措施执行，抛出bac_alloc异常；malloc返回null。 free / delete 的异同？ 都可用于内存的动态释放。 本质：delete 是关键字，free 是函数，所以free 还需要引入库文件，delete 不用； 返回值类型：free返回的是void类型指针（必须进行类型转换），delete 返回的是具体类型指针； 析构函数： delete 调用名为operator delete的标准库函数分配足够空间，如果是自定义类型还会调用相关对象的析构函数，free 则不会。 new实现原理？delete实现原理？ new原理：operator new分配内存 （底层是malloc实现）—&gt; （自定义类型）分配的内存上调用构造函数初始化—&gt;返回指向该对象的指针； delete原理：operator delete清理内存 （底层是free实现）—&gt; （自定义类型）删除内存前还会调用析构函数； malloc/free底层原理？ 参考前文。这里只简略说明： malloc：brk初始化分配–&gt;后续分配通过内存池：bins+双向链表实现—&gt;太大则top chunk 和mmap分配； free：将chunk标记可使用，并加入空闲链表。在上一个步骤free的时候，发现最高地址空闲内存超过128K，还会内存紧缩。 被free回收的内存是立即返还给操作系统吗？ 如前，free回收只是标识这块内存空闲，同时会加入空闲链表中等待下一次分配。 delete和free可以混用吗? 我们知道delete也只是free一种封装，只有自定义类型时delete会调用析构函数。new和malloc同理。 所以在以下情况是可以free/delete混用： 对象是基本类型时。 free掉new申请的内存。 123int* a = new int(1);// delete a;free(a); delete掉malloc申请的内存。 12 int* a = (int*)malloc(sizeof(int));delete a; 上面也适用于new/malloc混用。 自定义的类型，但没有显示定义析构函数。 delete和free混用。 12345678910111213141516171819#include &lt;stdlib.h&gt; class test&#123; private: int a; public: test()&#123;a = 0;&#125;;&#125;;int main() &#123; test* t1 = (test*)malloc(sizeof(test)); delete(t1); test* t2 = new test(); free(t2); &#125; 如果是自定义类型，malloc混用new需要显示调用构造函数的逻辑实现（或者该类不会有构造函数作用）。 malloc、realloc、calloc的区别？ malloc malloc申请20个int类型的空间。 12// void* malloc(unsigned int num_size);int *p = malloc(20*sizeof(int)); realloc malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的； 12// void* calloc(size_t n,size_t size);int *p = calloc(20, sizeof(int)); realloc 给动态分配的空间分配额外的空间，用于扩充容量。 1// void realloc(void *p, size_t new_size); 为什么C++没有垃圾回收机制？这点跟Java不太一样。 资源消耗。实现一个垃圾回收器会带来额外的空间和时间开销； 你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark； 然后需要单独开辟一个线程在空闲的时候进行free操作。 C++本身原因。垃圾回收会使得C++不适合进行很多底层的操作。 3.9 Lambda表达式 很多时候我们常常需要定义一个简单、甚至只被使用一次的函数，额外地定义了一个函数调用既浪费了空间，甚至未必有简化成一行代码好理解。 另外，前面的学习我们了解到C++是不允许函数嵌套的，但lambda可以被函数嵌套（lambda并不是函数，下文细说）。 lambda表达式就为我们做了这么一件事：将一个简单函数简化为一行，还允许我们在一个函数进行嵌套lambda。 3.9.1 lambda初识 第一个lambda C++中lambda表达式格式如下： 1234[ captureClause ] ( parameters ) -&gt; returnType&#123; Statement;&#125; captureClause：允许我们使用lambda外部的变量，这一点在3.9.5中详述，这里先略过； parameters：传递的参数，可空； returnType：返回类型，编译器会自动推断，可空； Statement：代码体，一般就一行，当然多行也行。 一个最简单的lambda表达式可定义为： 1[]()&#123;&#125; 现在举例说明用法。 我们之前写过一个冒泡函数bubbleSort：它有一个参数，允许我们传递定义排序规则，即myCompare函数来实现排序。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;// 交换数组值void swap(int* arr,int idx_i,int idx_j)&#123; int tmp = arr[idx_i]; arr[idx_i] = arr[idx_j]; arr[idx_j] = tmp;&#125;// 自定义排序规则bool myCompare(int a, int b)&#123; return a &gt; b? false: true;&#125;// 冒泡排序void bubbleSort(int* arr, int len, bool (*compare)(int,int))&#123; for(int i = 0; i &lt; len; i++) // 外轮=n-1 // * j=0,每次都是从头开始比较 for (int j=0; j&lt; len-i-1; j++ ) // 内轮=余下乱序数-1 &#123; if (compare(arr[j],arr[j+1])) swap(arr,j,j+1); &#125;&#125;int main()&#123; int array[] = &#123;5,4,1,3,2&#125;; int len = sizeof(array)/sizeof(array[0]); bubbleSort(array,len,myCompare); for(int i=0; i&lt;len ;i++) cout&lt;&lt;array[i]&lt;&lt;endl; return 0;&#125; 我们将这个myCompare函数改为更简洁lambda表达式： 1234bool myCompare(int a, int b)&#123; return a &gt; b? false: true;&#125; 改为： 1[](int a, int b)&#123;return a &gt; b? false: true;&#125; 这样我们如此调用bubbleSort函数：代码更加的紧凑，上下文更清晰，一眼明白我们排序的规则。 12// bubbleSort(array,len,myCompare);bubbleSort(array,len,[](int a, int b)&#123;return a &gt; b? false: true;&#125;); 输出： 1234512345 lambda本质探讨🌟 虽然3.9.2节（下节）的名字叫做“lambda与函数指针”，但值得提前声明的一点是：lambda并不是函数，它是一种特殊的对象，称为函数对象（也称为函数子）。函数不能嵌套，但lambda可以。 怎么理解函数对象？ C++函数对象实质上是实现了对()操作符的重载。C++函数对象不是函数指针，但它的调用方式与函数指针一样，后面加个括号就可以了。 12345678910111213141516171819class Add&#123;public: const int operator()(const int a,const int b) &#123; return a+b; &#125;&#125;;int main()&#123; // addFunction的Add类对象，此也是函数对象 Add addFunction; // 像函数（指针）一样调用 cout&lt;&lt;addFunction(2,3)&lt;&lt;endl; // 5 cout&lt;&lt;addFunction.operator()(2,3)&lt;&lt;endl; // 5 cout&lt;&lt;Add()(2,3)&lt;&lt;endl; // 5 return 0;&#125; 函数对象相比普通函数有什么好处吗？ 函数对象带有状态：函数对象相对于普通函数是“智能函数”，这就如同智能指针相较于传统指针。因为函数对象除了提供函数调用符方法，还可以拥有其他方法和数据成员。所以函数对象有状态。即使同一个类实例化的不同的函数对象其状态也不相同，这是普通函数所无法做到的。而且函数对象是可以在运行时创建。 每个函数对象有自己的类型：对于普通函数来说，只要签名一致，其类型就是相同的。但是这并不适用于函数对象，因为函数对象的类型是其类的类型。这样，函数对象有自己的类型，这意味着函数对象可以用于模板参数，这对泛型编程有很大提升。 函数对象一般快于普通函数：因为函数对象一般用于模板参数，模板一般会在编译时会做一些优化。 回到lambda表达式。 我们看看一个lambda表达式是如何被转换成函数对象。 准备代码： 12345int main()&#123; auto add = [](auto x, auto y) &#123; return x + y; &#125;; int x = add(2, 3); // 5&#125; 依旧是https://cppinsights.io/，观察编译过程变化： 编译器如何将我们写的lambda表达式转换为函数对象便一目了然： 首先为我们生成类__lambda_3_16 （①处），它有一个内联函数（②处），重载了符号()； 代码30行处，为我们生成了lambda函数对象add，也就是我们定义的lambda表达式名； 随后调用了函数对象add （③处），完成整个转换过程。 存储lambda 虽然一般来说我们不需要像函数一样给lambda表达式一个名字，但是有时候也需要能将lambda表达式（作为右值）存储起来，供以后使用。 在C++中提供三种方式： 使用函数指针方式存储：只有在capture clause为空时； 使用function方式存储：capture clause不为空时，也可以使用； 先来看看函数指针方式。 函数指针指向不仅限于函数，只要是函数对象都可以指向。lambda作为函数对象，自然是可以被其存储的。 1bool (*myCompare)(int, int) = [](int a, int b) &#123;return a &gt; b? false: true;&#125;; 用 auto 关键字可简化函数指针类型书写： 1auto myCompare = [](int a, int b) &#123;return a &gt; b? false: true;&#125;; 再来关注下std::function方式。 前面我们提到过：std::function本质就是类模板，也就是函数容器，可以将函数指针/函数转换成（函数）对象进行处理。 1function&lt;bool(int,int)&gt; myCompare = [](int a, int b) &#123;return a &gt; b? false: true;&#125;; lambda参数 Lambda表达式的参数和普通函数的参数相比有些限制（C++11）： 参数列表中不能有默认参数； 不支持可变参数（比如使用auto关键字）； 12// C++11:编译出错，参数类型无法使用autoauto myCompare = [](auto a, auto b) &#123;return a &gt; b? false: true;&#125;; 所有参数必须有参数名。 关于第2点，从C++14开始，lambda表达式支持泛型：其参数可以使用自动推断类型的功能，而不需要显示地声明具体类型。 具体介绍参考3.9.2节。 3.9.2 泛型lambda（C++14） 什么是泛型lambda？ 从 C++14 开始，我们被允许auto用于参数。当 lambda 具有一个或多个auto参数时，编译器将从对 lambda 的调用中推断出需要哪些参数类型。 这使得具有一个或多个auto参数的lambda可适用于多种类型，它们也被称为泛型 lambda。 看一个小例子： 123456int main()&#123; auto add = [](auto x, auto y) &#123; return x + y; &#125;; int x = add(2, 3); // 5 double y = add(2.5, 3.4); // 5.9&#125; 是不是非常像模板函数？ 1234567891011template &lt;typename T&gt;auto add(T x, T y)&#123; return x + y;&#125;int main()&#123; int x = add(2, 3); // 5 double y = add(2.5, 3.4); // 5.9&#125; add(2, 3) 、add(2.5, 3.4) 分别让函数模板生成了函数实例 add(int, int)、 add(double, double)。 auto关键字自动推断lambda参数类型，让lambda表达式起到了和模板函数相同的效果。前面我们说到，模板函数会为每种不同类型生成实例函数：那泛型lambda也会为不同类型生成一个lambda表达式吗？ 答案是肯定的。 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243int main()&#123; class __lambda_3_16 &#123; public: template&lt;class type_parameter_0_0, class type_parameter_0_1&gt; inline /*constexpr */ auto operator()(type_parameter_0_0 x, type_parameter_0_1 y) const &#123; return x + y; &#125; #ifdef INSIGHTS_USE_TEMPLATE template&lt;&gt; inline /*constexpr */ int operator()(int x, int y) const &#123; return x + y; &#125; #endif #ifdef INSIGHTS_USE_TEMPLATE template&lt;&gt; inline /*constexpr */ double operator()(double x, double y) const &#123; return x + y; &#125; #endif private: template&lt;class type_parameter_0_0, class type_parameter_0_1&gt; static inline auto __invoke(type_parameter_0_0 x, type_parameter_0_1 y) &#123; return x + y; &#125; &#125;; __lambda_3_16 add = __lambda_3_16&#123;&#125;; int x = add.operator()(2, 3); double y = add.operator()(2.5, 3.3999999999999999);&#125; 在上面代码中： 编译器自动生成了lambda类__lambda_3_16 类__lambda_3_16 ，根据40、41行函数调用的不同参数类型，分别生成了两个成员函数。 12345template&lt;&gt; inline /*constexpr */ int operator()(int x, int y) const template&lt;&gt; inline /*constexpr */ double operator()(double x, double y) const 注意到，两个函数都重载了操作符() 。 代码39行，生成了类__lambda_3_16 对象add，add就是我们定义的泛型lambda名，显然此时add也是函数对象，可以用名字()方式调用。 1__lambda_3_16 add = __lambda_3_16&#123;&#125;; 代码40、41行调用了不同的类__lambda_3_16 不同重载函数。 12int x = add.operator()(2, 3);double y = add.operator()(2.5, 3.3999999999999999); 更好地理解泛型闭包行为🌟 前面已经说到，泛型lambda会为每种不同类型生成成员函数 。 同时，我们也了解局部静态变量同样具有全局的生命周期，下面这个例子展示了这种特性： 1234567891011121314151617#include&lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;auto myCount(int value)&#123; cout&lt;&lt;&quot;the type of your input:&quot;&lt;&lt;typeid(value).name()&lt;&lt;endl; static int count = 1; return count++; &#125;int main()&#123; cout&lt;&lt;myCount(0)&lt;&lt;endl; cout&lt;&lt;myCount(0)&lt;&lt;endl; return 0;&#125; 输出： 1234the type of your input:i1the type of your input:d2 count 虽然是局部变量，但是由于是静态变量函数存储在全局数据段，和堆栈无关，退出也不会销毁。所以被myCount函数共享，可进行计数。 但是如果我们myCount替换成泛型函数，即允许参数类型为auto，一切开始变得不一样了。 123456789101112131415161718#include&lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;// C++20支持参数类型为autoauto myCount(auto value)&#123; cout&lt;&lt;&quot;the type of your input:&quot;&lt;&lt;typeid(value).name()&lt;&lt;endl; static int count = 1; return count++; &#125;int main()&#123; cout&lt;&lt;myCount(1)&lt;&lt;endl; cout&lt;&lt;myCount(1.2)&lt;&lt;endl; return 0;&#125; 输出： 1234the type of your input:i1the type of your input:d1 此时静态变量count没有被myCount函数共享？这是因为此时myCount函数已经是泛型函数。 执行代码第13行，推断出value为int类型，编译器生成函数int myCount&lt;int&gt;(int value)，它拥有自己作用范围的静态变量count； 执行代码第14行，类似的，无法匹配上一次生成函数int myCount&lt;int&gt;(int value)。所以编译器还需生成函数int myCount&lt;double&gt;(double value)，它也拥有自己作用范围的静态变量count。 两个myCount 是重载函数，但它们并不一样，自然无法共享各自的局部静态变量count。 类似的结果也出现在泛型lambda、函数模板中。 下面以泛型lambda为例进行展示： 12345678910111213141516171819#include &lt;typeinfo&gt;using namespace std;auto myCount&#123; [](auto value) &#123; cout&lt;&lt;&quot;the type of your input:&quot;&lt;&lt;typeid(value).name()&lt;&lt;endl; static int count = 1; return count++; &#125;&#125;;int main()&#123; cout&lt;&lt;myCount(1)&lt;&lt;endl; cout&lt;&lt;myCount(1.2)&lt;&lt;endl; return 0;&#125; 输出： 1234the type of your input:i1the type of your input:d1 查看编译转换后的代码验证： 3.9.3 使用标准库函数 和array配合时，lambda表达式会接受数组两个元素，定义它们的比较规则 lambda表达式常配合标准库函数使用，简洁优雅。 下面展示了几个排序用例。 例1：std::sort和lambda配合用在std::array上 1234567891011121314151617181920#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt;#include &lt;functional&gt; // for std::greaterint main()&#123; std::array&lt;int,6&gt; arr = &#123; 13, 90, 99, 5, 40, 80 &#125;; // 此时lambda参数接受数组两个元素，返回它们的比较规则（bool类型） // 可以结合之前我们写的冒泡排序自定义规则理解，此时是在双重for循环中接受数组相邻两个元素进行比较 std::sort(arr.begin(), arr.end(), [](int a,int b )&#123;return a&gt;b;&#125;); for (int i : arr) &#123; std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; &#125; std::cout &lt;&lt; &#x27;\\n&#x27;; return 0;&#125; 输出： 199 90 80 40 13 5 对于常见的操作（例如加法、求反或比较），标准库附带了许多可直接使用的函数对象。 比如这个例子可用std::greater替代我们写的lambda表达式。 1std::sort(arr.begin(), arr.end(), std::greater); 例2：排序对象是结构数组、类数组、RDD等 struct Student用来存储学生姓名和分数的，将下面Student数组按成绩进行排序。 12345678910111213141516171819202122232425262728293031#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt;#include &lt;string&gt;struct Student&#123; std::string name&#123;&#125;; int points&#123;&#125;; // 需要初始化函数 Student(const char my_name[],const int my_points) &#123; name = std::string(my_name); points = my_points; &#125;&#125;;std::array&lt;Student, 8&gt; arr&#123; &#123; &#123; &quot;Albert&quot;, 3 &#125;, &#123; &quot;Ben&quot;, 5 &#125;, &#123; &quot;Christine&quot;, 2 &#125;, &#123; &quot;Dan&quot;, 8 &#125;, &#123; &quot;Enchilada&quot;, 4 &#125;, &#123; &quot;Francis&quot;, 1 &#125;, &#123; &quot;Greg&quot;, 3 &#125;, &#123; &quot;Hagrid&quot;, 5 &#125; &#125;&#125;; 实现流程如下： 明确lambda接受的参数是数组两个元素，这里元素是结构体Student对象； 假设两个Student对象分别是stu1、stu2，它们比较的规则应该是：stu1.points&gt;stu2.pointsstu1.points&gt;stu2.pointsstu1.points&gt;stu2.points 。 12345678int main()&#123; // 排序 std::sort(arr.begin(),arr.end(),[](Student s1,Student s2)&#123;return s1.points&gt;s2.points;&#125;); // 输出 std::for_each(arr.begin(),arr.end(),[](Student s)&#123;std::cout&lt;&lt;s.name&lt;&lt;std::endl;&#125;); return 0;&#125; 3.9.4 捕获 为什么需要捕获 前面我们说过lambda表达式原理： 每定一个lambda表达式，会生成一个匿名类，这个类重载了()运算符； 使用lambda表达式，其实就是返回一个闭包类实例。 既然是闭包，当然无法使用外部的变量，请看下例： 123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int a = 1; []() &#123; cout&lt;&lt;a&lt;&lt;endl; // 无法使用外部变量a &#125;; return 0;&#125; 通过捕获可以让我们使用外部变量a。 按值捕获 下面展示了按值捕获方式。 123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int a = 1; [a]() &#123; cout&lt;&lt;a&lt;&lt;endl; &#125;; return 0;&#125; 按值捕获只是将变量a 复制一份，而且由于lambda匿名生成了重载函数() 被const修饰，所以不能在lambda表达式内部修改数据成员a的值。 要想修改a的值，需要声明为mutable： 1234[a]()mutable&#123; cout&lt;&lt;a++&lt;&lt;endl; &#125;; 此时重载函数的const关键字不会被声明。 但mutable这种方式，我们依旧无法修改lambda外部变量a的值，毕竟lambda内部变量a只是值复制了一份。 123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123; int a = 1; auto print = [a]() mutable &#123; cout&lt;&lt;a++&lt;&lt;endl; &#125;; print(); cout&lt;&lt;a&lt;&lt;endl; return 0;&#125; 输出： 1211 要想能修改lambda外部的变量，有两种方式： 声明外部变量为a为static： 123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123; static int a = 1; auto print = []() &#123; cout&lt;&lt;a++&lt;&lt;endl; &#125;; print(); // 1 cout&lt;&lt;a&lt;&lt;endl; // 2 return 0;&#125; 注意到此时，不用mutable也可以捕获外部静态变量a，因为此时a具有全局生命周期，可被隐式捕获（下个小节详细列出）。 用引用捕获的方式。 按引用捕获 引用捕获方式： 123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123; int a = 1; auto print = [&amp;a]() // 引用捕获 &#123; cout&lt;&lt;a++&lt;&lt;endl; &#125;; print(); cout&lt;&lt;a&lt;&lt;endl; return 0;&#125; 输出： 1212 原因很简单，修改引用时会通过间接寻址到本体外部的变量a，然后进行修改的。 混合捕获 上面的例子，要么是值捕获，要么是引用捕获，Lambda表达式还支持混合的方式捕获外部变量，这种方式主要是以上几种捕获方式的组合使用。 捕获形式 说明 [] 不捕获任何外部变量 [变量名, …] 默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符） [this] 以值的形式捕获this指针 [=] 以值的形式捕获所有外部变量 [&amp;] 以引用形式捕获所有外部变量 [=, &amp;x] 变量x以引用形式捕获，其余变量以传值形式捕获 [&amp;, x] 变量x以值的形式捕获，其余变量以引用形式捕获 隐式捕获 前面介绍的都是显示捕获，在C++中，如果变量被声明为static或者const，其实是可以隐式捕获使用的。 请回答：下面变量哪些可以在main不显式捕获它们的情况下使用？ 1234567891011121314151617181920212223242526272829303132333435int i&#123;&#125;;static int j&#123;&#125;;int getValue()&#123; return 0;&#125;int main()&#123; int a&#123;&#125;; constexpr int b&#123;&#125;; static int c&#123;&#125;; static constexpr int d&#123;&#125;; const int e&#123;&#125;; const int f&#123; getValue() &#125;; static const int g&#123;&#125;; static const int h&#123; getValue() &#125;; []() &#123; a; b; c; d; e; f; g; h; i; j; &#125;(); return 0;&#125; 除了a、f，其余都是被static或者const修饰，可以隐式被lambda捕获。 3.X 再谈 auto 前面我们或多或少了使用了auto关键字，它的作用也很明显：自动类型推断。 12auto a = 10;typeid(a).name() // i 但像这种简单类型变量声明不建议使用auto关键字，直接写出变量的类型更加清晰易懂。 现在进行常见场景下auto总结&amp;使用。 auto用法总结 代替冗长复杂、变量使用范围专一的变量声明 比如：存储函数指针或lambda表达式、模板对象声明等。 STL标准库将在后续进行总结。 想象一下在没有auto的时候，我们操作标准库时经常需要这样（难受啊兄弟）： 12345678910#include&lt;string&gt;#include&lt;vector&gt;int main()&#123; std::vector&lt;std::string&gt; vs; for (std::vector&lt;std::string&gt;::iterator i = vs.begin(); i != vs.end(); i++) &#123; //... &#125;&#125; 使用auto能简化代码（舒服了）： 12345678910#include&lt;string&gt;#include&lt;vector&gt;int main()&#123; std::vector&lt;std::string&gt; vs; for (auto i = vs.begin(); i != vs.end(); i++) &#123; //.. &#125;&#125; 又如函数指针声明比较复杂，存储时不好书写： 12345678910111213#include&lt;iostream&gt;using namespace std;int func(int a)&#123; cout&lt;&lt;a&lt;&lt;endl;&#125;int main()&#123; int (*p_func)(int,int) = func; return 0;&#125; 如果有lambda表达式，类似： 1bool (*myCompare)(int, int) = [](int a, int b) &#123;return a &gt; b? false: true;&#125;; auto优化后： 1auto (*myCompare)(int, int) = [](int a, int b) &#123;return a &gt; b? false: true;&#125;; 在定义模板函数时，用于声明依赖模板参数的变量类型 若不使用auto变量来声明v，则无法进行定义，因为其类型无法确定。 123456template &lt;typename _Tx,typename _Ty&gt;void Multiply(_Tx x, _Ty y)&#123; auto v = x*y; std::cout &lt;&lt; v;&#125; 在C++11中如果v作为返回值，还需要在尾部指定返回类型（否则会发出警告）： 12345template &lt;typename _Tx, typename _Ty&gt;auto multiply(_Tx x, _Ty y)-&gt;decltype(x*y)&#123; return x*y;&#125; decltype用于计算出表达式x*y的类型。 注意事项 auto关键字必须初始化 需要在声明时auto就可以推断出变量类型。 12auto a = 10; // okauto b; // error auto会自动去除右值的引用、const语义，需要显示声明 右值引用语义被去除。 1234int a = 10;int&amp; b = a;auto c = b; // 此时c的类型是int不是int&amp; 需要显示声明为引用： 1auto&amp; c = b; // 此时c的类型才是int&amp; auto还会去除const语义。 1234const int a = 10;auto b = a; // 此时b为int类型，而不是const intb = 100; // b可以被修改 需要显示声明为const常量： 12const auto b = a;b = 100; // 非法，无法被修改 有个有意思的问题：如果auto&amp; 还会去除const语义吗？理论上来说，此时引用是某种意义上等价本体的，自然类型也应该是一致的。 答案是不会的。 1234const int a = 10;auto&amp; b = a; // 此时b为const int，const语义未被去除b = 100; // 非法 auto关键字不去除指针的语义 请看下例，auto正确推导除了变量的类型为指针： 123456789int main()&#123; int a = 10; auto b = &amp;a; // b是int*类型 cout&lt;&lt;*b&lt;&lt;endl; // 10 return 0;&#125; auto不能作为函数形参 这样做的话，声明的函数实际上就是个函数模板了。 1234auto func(auto a)&#123; ...&#125; 但这种做法在C++20中已被支持。 更新记录 2021-02-8：更新笔记 3.8.1节增加了静态存储区相关描述 2021-01-16 ：更新笔记 第一次更新 参考资料 1.C++中引用传递与指针传递的区别：https://blog.csdn.net/u013130743/article/details/80806179 ↩2.C/C++ 程序的内存布局：https://blog.csdn.net/m0_45047300/article/details/118389444 ↩3.内存分配的原理--molloc/brk/mmap：http://abcdxyzk.github.io/blog/2015/08/05/kernel-mm-malloc/ ↩4.C++ lambda表达式与函数对象：https://www.jianshu.com/p/d686ad9de817 ↩5.C++ auto 关键字的使用：https://cloud.tencent.com/developer/article/1660750 ↩","categories":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/categories/C/"},{"name":"从零开始","slug":"C/从零开始","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"},{"name":"C++基础","slug":"C/从零开始/C-基础","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/tags/C/"},{"name":"教程","slug":"教程","permalink":"https://hwh.zone/tags/%E6%95%99%E7%A8%8B/"},{"name":"C++基础","slug":"C-基础","permalink":"https://hwh.zone/tags/C-%E5%9F%BA%E7%A1%80/"},{"name":"函数","slug":"函数","permalink":"https://hwh.zone/tags/%E5%87%BD%E6%95%B0/"}]},{"title":"C++从零开始（一）：环境搭建（上）VSCode远程开发","slug":"C++从零开始（一）：环境搭建（上）之VSCode远程开发","date":"2021-12-05T08:28:39.054Z","updated":"2022-02-19T09:58:13.301Z","comments":true,"path":"p/18652/","link":"","permalink":"https://hwh.zone/p/18652/","excerpt":"","text":"🌟《C++从零开始》 系列，开始更新中… C++从零开始https://hwh.zone/p/62712 实习的时候，公司会给每个人配置一台远程服务器，用于日常开发。体验下来感觉很不错的： 所有的开发代码、环境均运行在云端，任何一台机器可直连快速开发，本地无需任何部署环境或者代码等； 实际C/C++开发大部分也是在Linux环境上完成的，拥有一台自己的（云）Linux开发机还是很有必要的（省去了Win上开发各种怪问题）。 因此，在这个C++系列中，所有的代码也将以：本地（Win）+远程（Linux）形式进行开发。 好了，让我们快速开始吧。 快速开始 本文开发环境如下： 本地：Win10 + VSCode 远程：CentOS 7 （腾讯云） 云上开发 腾讯云/阿里云服务器都有学生优惠≈10元/月，以下是撸羊毛详细过程。 进入学生优惠购买界面，以腾讯云为例：腾讯云学生优惠 地区可选 上海三区 &amp; 广州四区等，广州离重庆更近一点所以选择 广州四区 。 选择操作系统为：CentOS 7.6.64 付费&amp;设置密码 点击立即购买后，记得设置好相应root密码。 现在你可以右上角点击：控制台–&gt;云服务器，查看你购买的云服务器： 你应该看到上图类似界面。红框部分是对应 内网&amp;公网IP，记录下来后面多次要用到。 本地配置 配置SSH Win10默认自带安装OpenSSH，下面我们直接进入到环境变量配置环节。 用everything进行搜索ssh.exe ，并记录OpenSSH文件夹路径： win10搜索环境变量—&gt;编辑系统环境变量—&gt;环境变量，找到系统变量(S)—&gt;选择Path—&gt;编辑： 选择：新建–&gt;输入OpenSSH路径 保存后退出。 测试：打开CMD，输入ssh ，出现如下则环境变量配置成功（被系统成功识别）： 安装相关插件 安装Remote-SSH：左侧Extension图标 —&gt; 输入 Remote-SSH —&gt;安装即可。注意，需要远程和本地都进行安装。 安装C/C++插件：同上安装不再赘述。 配置Remote-SSH 如图所示选择.ssh/config 文件进行配置： 打开文件后，需要设置以下字段： Host：自定义即可 HostName：云主机公网IP User：登陆的用户 以下为示例： 登陆测试 点击下图按钮进行登陆： 输入密码后，便可以看到远程服务器已经成功连接。 hello cpp! 现在我们来编写一个简单的cpp文件，体验远程编码的快感。 打开远程服务器文件夹 File—&gt;Open Folder—&gt;指定文件夹路径。 hello.cpp文件编写 新建文件hello.cpp–&gt;编写如下代码： 123456#include&lt;iostream&gt;int main()&#123; std::cout&lt;&lt;&quot;Hello Cpp!&quot;&lt;&lt;std::endl;&#125; 编译输出 1g++ -g hello.cpp -o hello.out 执行我们刚刚生成的可执行文件：hello.out 至此，顺利完成了初步的远程开发环境配置。 或许聪明的你已经想到：远程开发怎么在本地进行debug呢？ 远程Debug VSCode中进行远程调试，通常需配置以下文件[1]： launch.json：最重要的文件，配置调试器与需要调试的可执行文件进行调试； c_cpp_properties.json： c与cpp选项，实际开发主要作用是，解决系统环境的头文件找不到的情况； setting.json ：可以对VS Code进行页面风格、代码格式、字体颜色大小等的编辑设置，这里只用来将其它语言识别为cpp； 更多作用可参考：settings.json是什么?对VS Code有什么用？ tasks.json：通常用来执行比较简单的编译指令，所以一般不用，不进行过多介绍。 下面正式进行相关配置介绍[2]。 ⚠️ 以下过程执行前提： 你已经根据前面步骤，成功编译生成了一个可执行文件，如：hello.out ； 编译生成的执行文件可以被Debug，e.g.，g++带上-g参数。 launch.json 菜单栏依次选择：Run—&gt; Add Configuration—&gt; 选择C++ (GDB/LLDB) —&gt; 选择g++ build and debug active file。 如果以上创建过程报错：VScode找不到任务c/c++：g++.exe生成活动文件 。 需要你先打开一个cpp文件，再执行上面步骤。 VSCode会根据你的机器环境，自动创建launch.json 。正如前所言该文件的作用，我们需进行以下配置： 配置调试器信息：创建文件时系统自动配置好了，所以不用管； 配置可执行文件：也就是我们编译生成的可执行文件路径 当然我们还可以为可执行文件设置参数，格式如下： 注释多余参数：preLaunchTask（调试会话开始前执行的任务），不需要。 最终完整的配置示例文件如下： 123456789101112131415161718192021222324252627&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, // 将要进行调试的可执行文件的路径 &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/bin/hello.out&quot;, // 调试的可执行文件参数 &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], // &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot; &#125; ]&#125; c_cpp_properties.json VSCode开发过程中，经常容易出现：明明路径正确引用其它头文件，但VSCode就是一直提示无法找到。所以在这个文件中，提供了includePath参数，让编译器顺利找到其它路径的文件。 在菜单栏中：F1—&gt;选择C/Cpp: Edit configurations，让VSCode根据实际环境自动生成c_cpp_properties.json。 以下给出示例配置： 12345678910111213141516&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [ &quot;$&#123;workspaceFolder&#125;/**&quot; ], &quot;defines&quot;: [], &quot;compilerPath&quot;: &quot;/usr/bin/gcc&quot;, &quot;cStandard&quot;: &quot;gnu11&quot;, &quot;cppStandard&quot;: &quot;gnu++11&quot;, &quot;intelliSenseMode&quot;: &quot;linux-gcc-x64&quot; &#125; ], &quot;version&quot;: 4&#125; setting.json 这里只用来，将其它语言识别为CPP，不太重要。按以下配置好了就行。 在菜单栏中：F1—&gt;输入 “Open Settings”—&gt; 选择 “Preferences: Open Settings (JSON)” ，自动生成该文件。 编辑以下内容： 12345678910111213141516171819202122232425&#123; &quot;files.associations&quot;: &#123; &quot;*.tcc&quot;: &quot;cpp&quot;, &quot;cctype&quot;: &quot;cpp&quot;, &quot;clocale&quot;: &quot;cpp&quot;, &quot;cstdarg&quot;: &quot;cpp&quot;, &quot;cstdint&quot;: &quot;cpp&quot;, &quot;cstdio&quot;: &quot;cpp&quot;, &quot;cstdlib&quot;: &quot;cpp&quot;, &quot;cwchar&quot;: &quot;cpp&quot;, &quot;cwctype&quot;: &quot;cpp&quot;, &quot;exception&quot;: &quot;cpp&quot;, &quot;initializer_list&quot;: &quot;cpp&quot;, &quot;iosfwd&quot;: &quot;cpp&quot;, &quot;iostream&quot;: &quot;cpp&quot;, &quot;istream&quot;: &quot;cpp&quot;, &quot;limits&quot;: &quot;cpp&quot;, &quot;new&quot;: &quot;cpp&quot;, &quot;ostream&quot;: &quot;cpp&quot;, &quot;streambuf&quot;: &quot;cpp&quot;, &quot;type_traits&quot;: &quot;cpp&quot;, &quot;typeinfo&quot;: &quot;cpp&quot; &#125;, &quot;C_Cpp.errorSquiggles&quot;: &quot;Enabled&quot;&#125; 测试 现在让我们波澜不惊的在hello.cpp ，打上断点，按上F5 进行调试。 发现可以顺利进行远程调试，跨越了你离技术专家的一小步 😃 。 体验优化 免密登陆 每次连接到远程服务器要输入密码，实在让暴躁开发的我难以忍受。现在让我们来配置免密登陆，减少服务器被我再次remake的风险。 本地生成密钥对 打开cmd —&gt; 输入 ssh-keygen -t rsa 生成密钥对。 在该过程会有三个系统提示，一直回车即可； 该过程会显示密钥保存路径，记录下来。 打开密钥保存路径—&gt;打开id_rsa.pub 文件，并复制其全部内容。 远程密钥配置 在VSCode打开远程服务器终端，输入： 1vim ~/.ssh/authorized_keys 按下 i 进入插入模式 —&gt; 粘贴刚刚复制的密钥—&gt;按下:，输入wq! 进行保存。 登陆测试 现在你可以重新登陆远程服务器，发现可以愉快的免密登陆了。 如果依旧不行，建议在第一步生成密钥对时，选择覆盖之前密钥。 文件同步 工作中经常需要同步本地和服务器之间的文件，通常有以下几种方式： FileZilla软件同步 ； VSCode 中STFP插件同步； 命令行SCP命令同步。 在这里我们主要介绍1、2两种方式。 STFP插件FileZilla因为本文主要是基于VSCode开发，所以介绍一下使用VSCode相关插件进行同步[3]。 安装SFTP插件 左侧Extension图标 —&gt; 输入 STFP —&gt;安装即可。注意，需要远程和本地都进行安装。 工作区：准备 在本地路径下：创建新文件夹—&gt;使用VSCode打开，文件夹被自动加入到工作区中。 配置sftp.json 在：F1—&gt; 输入SFTP —&gt;选择 SFTP: config ，进行文件配置： 123456789&#123; &quot;name&quot;: &quot;roy-cpp&quot;, // 随意 &quot;host&quot;: &quot;119.111.111.111&quot;, // 你的云主机公网IP &quot;protocol&quot;: &quot;sftp&quot;, &quot;port&quot;: 22, &quot;username&quot;: &quot;root&quot;, // 登陆用户名 &quot;remotePath&quot;: &quot;/home/royhuang/syn&quot;, // 随意，不存在会自动创建 &quot;uploadOnSave&quot;: true&#125; 指定本地同步文件夹 在：F1—&gt;输入SFTP —&gt;选择SFTP: Sync Local -&gt; Remote ，将会显示本地工作区的文件夹。 选择一个文件夹，作为我们同步到远端的本地路径（输入登陆用户密码后确定）。 同步设置完成后，在VSCode底部会显示SFTP标识： （可选）BUG解决：No Such File 这是SFTP的一个Bug，参考stackoverflow进行解决。 找到sftp.js（Win下可用everything进行搜索），通常是在以下路径：C:\\Users\\account_name\\.vscode\\extensions\\liximomo.sftp-1.12.9\\node_modules\\ssh2-streams\\lib\\sftp.js 修改第388行，将 ： 1if ( code === STATUS_CODE . OK ) &#123; 替换为： 1if (code === STATUS_CODE.OK || code === STATUS_CODE.NO_SUCH_FILE) &#123; 保存文件后，重启VSCode一般可解决。 测试 本地 准备测试文件，放入之前设置的本地同步文件夹中 用VSCode打开该同步文件夹：选择测试文件–&gt;右击–&gt;选择底部Upload 上传 远程服务器 VSCode打开远程服务器同步文件夹 ，发现文件已经被顺利上传 当然远程文件也可同步到本地：选择测试文件–&gt;右击–&gt;选择底部DownLoad下载即可。 尽情愉快玩耍吧！ 这里引用之间写的教程 ，文件路径可能有点奇怪，但不影响阅读。 该小节将介绍如何使用FTP软件将本地（Windows）文件上传到服务器(Linux)。 下载软件 FTP工具我们选择Filezilla ，下载地址：Filezilla下载 点击进行下载安装，安装过程较为简单不再赘述。 连接服务器 依次点击：文件 --&gt; 站点管理器 --&gt; 新站点 上传文件 如下图所示，左侧为本地文件，右侧为服务器文件目录（默认为 /home/hadoop） 上传完毕后，可在服务器上查看文件： 写在最后 看到这里，相信聪明的你已经将远程开发环境顺利搭建起来。同时，使用g++编译了个小demo，还顺手进行了一次不错的调试体验。 但在实际开发中，对于如何优雅去编译我们的项目，是个不小的问题。为此，我们还需要学习下： g++/Makefile/CMake 原理及基础命令； 项目构建逻辑及编译。 在下一篇文章：环境搭建（下）g++/Makefile/CMake快速入门 ，和我一起学习下吧。 更新记录 2021-12-06 ：第一次更新 初稿完成并发布 参考资料 1.vscode中c++的三个配置文件的作用：https://blog.csdn.net/zhxue_11/article/details/89457545 ↩2.vscode C++远程调试运行：https://zhuanlan.zhihu.com/p/104131448 ↩3.vscode使用sftp快速同步服务器文件：https://blog.csdn.net/qq_24798295/article/details/90228795 ↩","categories":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/categories/C/"},{"name":"从零开始","slug":"C/从零开始","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"},{"name":"C++环境搭建","slug":"C/从零开始/C-环境搭建","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/tags/C/"},{"name":"教程","slug":"教程","permalink":"https://hwh.zone/tags/%E6%95%99%E7%A8%8B/"},{"name":"远程开发","slug":"远程开发","permalink":"https://hwh.zone/tags/%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/"},{"name":"C++环境搭建","slug":"C-环境搭建","permalink":"https://hwh.zone/tags/C-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门","slug":"C++从零开始（一）：环境搭建（下）之CMake快速入门","date":"2021-12-05T08:24:40.924Z","updated":"2022-02-19T09:58:33.518Z","comments":true,"path":"p/2834/","link":"","permalink":"https://hwh.zone/p/2834/","excerpt":"","text":"🌟《C++从零开始》 系列，开始更新中… C++从零开始https://hwh.zone/p/62712 作为一名C/C++程序员，g++/Makefile/CMake等相关工具是必备的基础。但之前使用中一直存在一些困惑，因此参考了一些资料[1][2][3]，动笔写了这篇文章，希望可以帮助自己或大家： 对编译处理过程有个基本认知； 能初步使用编译工具g++/Makefile/CMake； 能初步使用CMake编译大型项目。 才疏学浅，若有错误不吝指正。 g++ 在下文中，我们将多次利用了g++编译代码。为了方便后续学习Makefile和CMake，我们先进行简单总结。 以hello.cpp为例。 12345678#include &lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt;endl; return 0;&#125; 快速入门 程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。 当然，用 gcc 来编译链接 C++ 程序是可行的，如下例所示： 1$ gcc hello.cpp -lstdc++ -o hello.out 不过我们还是主要熟悉g++基本用法来编译C++代码。 g++最简单的编译方式 1$ g++ hello.cpp 由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行： 12$ ./a.outHello, world! 指定可执行程序文件名 我们使用 -o 选项指定可执行程序的文件名，以下实例生成一个 名为hello.out 的可执行文件： 1$ g++ hello.cpp -o hello.out 执行 hello.out: 12$ ./hello.outHello, world! 多个 C++ 代码文件 如 a.cpp、b.cpp，编译命令如下： 1$ g++ a.cpp cpp、b.cpp -o test.out 生成一个 test.out可执行文件。 g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 hello.cpp 文件： 1g++ -g -Wall -std=c++11 hello.cpp -o hello.out g++ 常用命令选项 选项 解释 -ansi 只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。 -c 只编译并生成目标文件。 -DMACRO 以字符串&quot;1&quot;定义 MACRO 宏。 -DMACRO=DEFN 以字符串&quot;DEFN&quot;定义 MACRO 宏。 -E 只运行 C 预编译器。 -g 生成调试信息。GNU 调试器可利用该信息。 -IDIRECTORY 指定额外的头文件搜索路径DIRECTORY。 -LDIRECTORY 指定额外的函数库搜索路径DIRECTORY。 -lLIBRARY 连接时搜索指定的函数库LIBRARY。 -m486 针对 486 进行代码优化。 -o FILE 生成指定的输出文件。用在生成可执行文件时。 -O0 不进行优化处理。 -O 或 -O1 优化生成代码。 -O2 进一步优化。 -O3 比 -O2 更进一步优化，包括 inline 函数。 -shared 生成共享目标文件。通常用在建立共享库时。 -static 禁止使用共享连接。 -UMACRO 取消对 MACRO 宏的定义。 -w 不生成任何警告信息。 -Wall 生成所有警告信息。 编译过程初探 现在让我们从一个简单的例子，来一步步探讨下编译过程。 准备的hello.cpp程序如下： 12345678#include &lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt;endl; return 0;&#125; 我们对它进行简单的编译&amp;输出： 1g++ hello.cpp -o hello.out # 文件名可包含指定路径 可以看到，当前路径生成了hello.out文件，这是一个可执行的二进制文件。 hello.out本质是什么 ? 一个程序（比如hello.out）本质是由数据段、代码段、.bss段组成。 下图展示了一个虚拟进程（程序）内存空间运行时分布布局（下图.bss段和数据段合并了）： 注意到此时还多了堆&amp;栈用来给程序运行时进行空间分配； 高地址的1GB（Linux下如此，Windows默认2GB）空间分配给内核，也称为内核空间；剩下的3GB分给用户，也称用户空间。 栈（Stack）：存储代码中调用函数、定义局部变量(但不包含static修饰的变量)、保存的上下文等； 文件映射区域 ： 栈和堆中间那个空白区域。动态库、共享内存等映射物理空间的内存，一般是 mmap 函数所分配的虚拟地址空间。 堆（Heap）：存储那些生存期与函数调用无关的数据，如动态分配的内存。 .bss段：全称Block Started by Symbol，也就是未被初始化的全局变量、静态变量的内容的一块内存区域。 数据段（.data）：保存全局变量、常量、静态变量的内容的一块内存区域，区别.bss段在于变量已经被初始化。比如： 代码段（.text &amp; .init）： .text 用于存放整个程序中的代码； .init 用于存放系统中用来初始化启动你的程序的一段代码 。 回来神来，让我们继续执行一下试试： 我们的代码被正确执行了。但这整个过程的细节被隐藏了，如果不了解清楚对我们以后的学习工作阻碍很大。 正式开始接触细节前，我们先大致了解下上述编译过程（四步）： 预处理：资源进行等价替换，生成预编译文件（.i文件）； 编译 ：生成汇编代码（.s文件）； 汇编 ：将汇编代码最终生成机器代码（.o文件）； 链接：动态或静态链接外部函数/库(lib)/变量，生成可执行的二进制(hex)文件/静态库(.a)文件/动态库(.so)文件。 现在让我们来逐步分析。 预处理 预处理的主要作用：通过内建功能对预处理指令进行等价文本替换。 一般地，C/C++ 程序的源代码中包含以 # 开头的各种编译指令，被称为预处理指令。根据ANSI C 定义，主要包括：文件包含、宏定义、条件编译和特殊控制等4大类[7]。 文件包含：例如常用的预处理指令 #include &lt;iostream&gt; ，预编译阶段会使用系统目录下iostream文件中的全部内容，替换 #include &lt;iostream&gt; 。 #include &quot;xxx.h&quot; ，表示使用当前目录下xxx.h文件，&lt;&gt; 是在系统目录下查找。 宏定义展开及处理： 预处理阶段会将定义的常量符号进行等价替换，e.g. #define A 100 , 所有的宏定义符号A都会被替换成100。还会将一些内置的宏展开，比如用于显示文件全路径的__FILE__。 条件编译处理: 如 #ifdef，#ifndef，#else，#elif，#endif等，这些条件编译指令的引入，使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预处理时会将那些不必要的代码过滤掉，防止文件重复包含等。 其它：特殊控制处理… 特别的，预处理过程还会发生： 添加行号和文件名标识： 比如在文件hello.i中就有类似 # 2 &quot;main.c&quot; 2 的内容，以便于编译时编译器产生调试用的行号信息，编译时产生编译错误或警告时能够显示行号； 清理注释内容等。 在这一步，我们亲眼瞧瞧预处理的等价文本替换究竟做了什么： 1g++ -E hello.cpp &gt; hello.i # 输出文件重定向到hello.i中 可以看到： 文件包含：我们之前引入的头文件 #include &lt;iostream&gt; ，预处理后会将#include &lt;iostream&gt; 代码替换为iostream文件的内容，插入到hello.i中。 文件过长，以下是部分截图： 特别的，iostream文件本身也#include了头文件，同样会被替换，也就是进行大杂烩嵌套拼接。 其它，条件编译处理、添加行号和标识等也一并可以（左图）观察到。 编译 编译过程是整个程序构建的核心部分，也是最复杂的部分之一，其工作就是把预处理完生成的 .i 文件进行一系列的词法分析、语法分析、语义分析以及代码优化，最终产生相应的汇编代码文件，也就是 .s 文件。 1g++ -S hello.cpp -o hello.s # 该命令包含等价替换过程 打开当前目录下hello.s ，入目即是熟悉的汇编天书： 汇编 相对来说比较简单，每个汇编语句都有相对应的机器指令，只需根据汇编代码语法和机器指令的对照表翻译过来就可以了。 有了上述汇编代码后，我们便可以将其转换为机器码（.o文件，即object file）。 1g++ -c hello.cpp -o hello.o # -c 表示不进行链接，只生成目标文件 但是在这一步还不能直接执行，会报错： 这是因为我们还没有链接其它相应的文件，因此会报错。我们来试试链接再生成可执行代码： 1g++ hello.o -o hello.out 然后执行：./hello.out 假装惊喜的发现（是的就是这么戏精），文件确实已经被成功执行了。 那么，链接过程中究竟发生了什么？为什么一定要链接后才能执行？ 链接 链接过程究竟做了什么？ 链接就是进行符号解析和重定位的过程[4]。 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。 为什么一定要进行符号解析和重定位？ 比如我们上一步生成的可执行文件hello.o 执行出错，就是因为符号std::cout没有进行解析和重定位。 在前面预处理阶段，我们知道 #include&lt;iostream&gt; 会被替换为头文件iostream中的内容。 但头文件iostream中的符号，如cout只是被定义，并没有实现： 1extern ostream cout; /// Linked to standard output 具体是在libstdc++.so.6中被实现的。我们必须要让编译器找到libstdc++.so，也就是通过链接，然后将cout符号解析重定向libstdc++.so中。这样，cout才可以被正常执行。 准备代码片段 为了更清楚的说明整个过程，我们不妨换一个例子，不使用系统库文件（预处理后的文件太复杂）。 Main.cpp 12345678extern int shared;extern void swap(int*,int*);int main() &#123; int a = 100; swap(&amp;a, &amp;shared);&#125; Libtest.cpp 123456int shared = 1;void swap(int *a, int *b)&#123; *a ^= *b ^= *a ^= *b;&#125; 可以看到：Libtest.cpp不引用任何外部变量符号，但Main.cpp文件会引用Libtest.cpp中的shared变量 和 swap函数。 那么，Main.cpp中外部符号即shared和swap，怎么样才能被正确解析到Libtest.cpp中？ 链接前置知识 下面有不理解的地方，建议阅读：ELF学习–重定位文件 继续讲解前，我们还需补充几个基本概念[5]： 符号和外部符号 在链接中，我们将函数和变量统称为符号（Symbol）； 在本目标文件中使用，而又没有在本目标文件中定义的全局符号，称为外部符号（External Symbol）。 重定位表 由于外部符号在编译后并不能确定其位置地址（链接重定位后才能确定）。所以需要这么一个文件：将需要重定位的外部符号进行标记。 比如，编译后Main.o 文件符号表： 12g++ -c Main.cpp -o Main.o # -c参数表示不进行链接objdump -r Main.o 可见，shared和swap()为外部符号被标记记录，显然，这些符号是需要被解析重定向的。 但是Libtest.o中没有外部符号，因此其重定位表为空。 12g++ -c Libtest.cpp -o Libtest.oobjdump -r Libtest.o 重定位表为空。 符号表 目标文件使用符号表（Symbol Table）来记录本目标文件中的全局符号的信息。 e.g. 自定义的全局符号地址，这样别的文件中引用了该自定义的全局符号，就可以查找其真实地址。 Main.o符号表 1readelf -s Main.o Main.o定义了全局符号main，使用到了外部符号shared和swap。 UND 即表示未定义需要重定义。 Libtest.o的符号表 1readelf -s Libtest.o Libtest.o定义了符号shared和swap，没有使用到外部符号 静态链接过程 静态链接的主要目的：1）将多个目标文件合并，2）并处理各目标文件用到的外部符号（e.g. main.cpp 中的 swap和shared），对外部符号重定位（ 调整地址到真正定义实现的地方，e.g.，swap→Libtest.o），最后生成可独立运行的可执行文件。 现在我们进行静态链接： 123456g++ -static Main.cpp Libtest.cpp -o main.out# 等价于g++ -c Main.cpp -o Main.og++ -c Libtest.cpp -o Libtest.og++ -static Main.o Libtest.o -o main.out # 目标文件（可执行文件）静态链接 静态链接一般采用两步链接（Two-pass Linking）的方法，下面以链接 Main.cpp 和 Libtest.cpp为例具体说明。 第一步，空间与地址分配。 扫描所有的编译生成的可重定向文件（Main.o和Libtest.o）并合并，同时获得其以下信息： 全局符号表：包含所有的符号定义和符号引用； 符号名 状态 所在目标文件 … main 定义 Main shared 引用 Main swap 引用 Mian shared 定义 Lib swap 定义 Lib 段信息：各个段的长度、属性和位置。 第二步，符号解析与重定位。 查看全局符号表，发现shared需要重定位； 在全局符号表发现Libtest.o定义了shared； 查看Libtest.o的符号表以及第一步的段信息，确定shared的地址； 再查看Main.o的重定位表，找到所有shared需要重定位的地址，修改为shared的真实地址； Main.o和Libtest.o被合并，必须要查看重定位表，知道哪些是属于Main的share，进行重定位。 继续查看全局符号表，发现swap 需要重定位，过程同上； 直至所有的符号引用都被修改为真实地址，结束。 我们可以反编译一下最后的可执行文件，看看是否如上所示已经全部重定义完成： 1objdump -d main.out &gt; tmp.txt 例如，主函数中调用的swap函数的地址被修正为40050d。 其它信息合并 在静态链接下，链接器还会将各个目标文件的代码段和数据段【合并拷贝】到可执行文件，因此静态链接下可执行文件当中包含了所依赖的所有代码和数据。 在本例中，Main.o和Libtest.o中的代码段和数据段被合并拷贝到可执行文件中，然后进行解析重定位。 下图进行了图解展示合并过程。 看到这里，相信你已经明白，在静态链接中外部符号： 为什么要被解析重定位：外部符号能被定位到真正实现的地方； 如何被解析重定位：通过符号表实现。 同时，静态链接还会将需要的目标文件进行合并，因此体积比较大。 动态链接过程 为什么需要动态链接？ 试试想想以下两种糟糕的情况： 空间浪费： 假设你是个腾讯技术专家，你写的代码Libtest.cpp性能挺好，于是开源出来生成一个静态库给其它人也用用。 12gcc -c Libtest.cpp -o libtest.oar cqs libtest.a libtest.o github反应不错，你的大作很受欢迎，基本机器上每个程序都调用了你的库。但是由于每个程序都静态链接你的静态库libtest.a，导致每个程序都会【拷贝】Libtest.a中的代码，造成了很大的空间浪费。 更新困难： 不幸的是，你不但技术精湛头发稀少同时精力旺盛，经常对你的大作libtest.a进行更新。这样你每更新一次，为了跟上你技术专家的步伐，所有的程序都要重新编译一次，来静态链接拷贝你的最新代码。情况严重的话，这可能收到一些礼貌的问候。 聪明的你，自然想到号召大家使用动态链接： 对那些组成程序的目标文件，比如你的libtest，不进行直接链接，而只是将必要信息写入了可执行文件，等到程序要运行时才进行链接。这样他们只用下载你大作libtest.so最新的版本，可执行文件运行时就会自动（动态）链接新版本，从而不用重新编译了。 于是你开心地开始尝试下动态链接： 1234567# 生成动态库# 生成的动态库的名字必须是lib+名字.sog++ -shared -o libtest.so Libtest.cpp# 保存在/usr/lib64/下mv libtest.so /usr/lib64/# 动态链接你的大作libtest.so，可以直接使用-ltest来引用g++ Main.cpp -L/usr/lib64/ -ltest -o main.out 得到可执行文件main.out。 但是main.out仅包含了libtest.so 的相关符号信息，并没有将 libtest.so和 main.out合并。只有当我们执行 ./main.out ，此时才会动态加载Libtest.so 。 前面提到的hello.out中的std::cout 也是动态链接的： 编译生成了可执行文件hello.out ，但此时hello.out只包含了cout符号信息； 执行可执行文件hello.out时 ，根据cout符号信息加载libstdc++.so.6 动态库。 从上也回答本节开头的问题：动态链接生成的可执行文件体积小，避免了空间浪费，同时灵活性强。这也就是使用动态链接的主要原因。 那么，动态链接的需要的动态库，和静态链接需要的静态库又是什么呢？ 静态库和动态库 Windows下的静态库和动态库分别为.lib和.dll 结尾的文件，本节中仅以在Linux系统中说明相关概念。 Linux 下的库有两种[8]：静态库(.a)和共享库（动态库，.so） ，都采用以下方式进行链接： 1234# 【例】Main.cpp动态链接libtest.so，静态链接需加上-static参数# -L：指定搜素路径，:可分隔多个路径# -l：指定库名，前缀&quot;lib&quot;和后缀&quot;.a&quot; 或&quot;.so&quot;省略g++ Main.cpp -L/usr/lib64/ -ltest -o main.out 静态库 特点：编译过程中已经被载入可执行程序，因此体积较大； 命名：.a为后缀，lib为前缀， 例如 libtest.a ； 生成：先生成.o 文件，再用ar工具可生成； 12g++ -c Libtest.cpp -o libtest.oar cqs libtest.a libtest.o 链接路径： 参数-L：ld会去找gcc/g++命令中的参数-L指定的路径； 环境变量：gcc的环境变量LIBRARY_PATH，它指定程序静态链接库文件搜索路径； 默认库：再找默认库目录 /lib、 /usr/lib、 /usr/local/lib。 动态库 特点：可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小； 命名：.so为后缀，lib为前缀，通常还会加上版本号， 例如 libtest.a.0.1 ; 生成：g++工具可生成； 12g++ -c Libtest.cpp -o libtest.og++ -shared libtest.o -o libtest.so.1.0 链接路径： 参数-L：ld会去找gcc/g++命令中的参数-L指定的路径； 环境变量：gcc的环境变量LD_LIBRARY_PATH，它指定程序动态链接库文件搜索路径； 配置文件：配置文件 /etc/ld.so.conf 中指定动态库路径； 默认库：再找默认库目录 /lib、 /usr/lib。 全过程总结 源码到执行全过程分析。 在linux中程序的加载（不是链接），涉及到linker和loader两个工具。linker主要涉及动态链接库的使用，loader主要涉及软件的加载。 上图是一个典型的编译将源文件main.cpp 生成可执行文件myProc.out 并执行的过程 ： 12g++ main.cpp -L/usr/lib -laaa -lbbb -o myProc.out ./myProc.out 链接前：依次按预处理→编译→汇编，生成可执行文件main.o ； 链接：分静态链接和动态链接。 静态链接：对main.o 中未定义的符号进行解析重定位到静态库aaa.o 中，然后把需要的目标文件lib1.o 、lib2.o 和main.o 的.text段、.data段、.bss段进行合并生成初步的可执行文件myProc.out ； 动态链接：此时main.o 中依旧有部分符号没有被解析，它们的实现存于动态库bbb.so中 ，但动态链接仅将bbb.so 相关符号信息保存在myProc.out中。 现在我们获取最终的可执行文件myProc.out。 执行：执行可执行文件。 myProc.out 由代码段（.text，只读可执行），数据段（.data，只读），.bss段组成，现在看看如何被加载到内存中。 1./myProc.out # 开始执行程序，通过loader加载器加载程序 内存映射。loader启动通过mmap系统调用，将代码段和数据段映射到虚拟内存中 ，不占物理内存； 动态库加载。动态链接器将编译时指明依赖的动态链接库，映射到虚拟内存中； 执行.text 中指令。程序开始运行，通常伴随着栈、堆空间分配等。 编译工具简介 在前面我们简单使用g++进行文件编译、执行。当然，主要还是偏“务虚”探讨了下编译的过程及原理。 接下来，我们将偏”务实“的介绍一下基本三大编译工具的使用 ：g++/Makefile/CMake。 三者关系如上图所示。 gcc/g++：Linux编译器有gcc/g++，随着源文件的增加，直接用gcc/g++命令的方式效率较低，于是发明了Makefile来进行编译； Makefile： Makefile描述了整个工程的编译、链接等规则，可以有效的减少大工程中需要编译和链接的文件，只编译和链接那些需要修改的文件。然而随着工程体量的增大，Makefile也不能满足需求，于是便出现了Cmake工具； CMake：CMake是一个跨平台的编译(Build)工具，可以用简单的语句来描述所有平台的编译过程。早期的make需要程序员写Makefile文件进行编译，而现在CMake能够通过对CMakeLists.txt的编辑，轻松实现对复杂工程的组织。 具体实操练习掌握。 Makefile 快速入门 Makefile基本格式如下： 12&lt;target&gt; : &lt;prerequisites&gt; [tab] &lt;commands&gt; target（目标） ： 目标文件, 可以是 Object File, 也可以是可执行文件； prerequisites（前置条件） ： 生成target所需要的文件或者目标； command（命令）： make需要执行的命令(任意的shell命令)，Makefile中的命令必须以 [tab],即四个空格 开头。 基本语法 先熟悉以下偏理论总结上的东西，实践时互相验证效果更好~ Makefile包含了五个重要的东西：显示规则、隐晦规则、变量定义、文件指示和注释。 显示规则： 即需要指明target和prerequisite文件。 一条规则可以包含多个target，这意味着其中每个target的prerequisite都是相同的； 当其中的一个target被修改后，整个规则中的其他target文件都会被重新编译或执行。 隐晦规则：make自动推导功能所执行的规则。 变量和定义：Makefile中定义的变量，一般是字符串。 文件指示：通常指以下 Makefile中引用其他Makefile； 指定Makefile中有效部分； 定义一个多行命令。 注释：只有行注释# 。 一起试试 我们准了一段代码DisplayImage.cpp：使用c++和opencv对图片进行读取和显示。 为了方便阅读，代码已经尽量精简。 12345678910111213#include &lt;stdio.h&gt;#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char** argv )&#123; // 读取 Mat image = cv.imread( argv[1], 1 ); // 显示 cv.namedWindow(&quot;Display Image&quot;, WINDOW_AUTOSIZE ); cv.imshow(&quot;Display Image&quot;, image); cv.waitKey(0); return 0;&#125; 这里先给出已完成的Makefile文件： 12345678910export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/home/royhuang/lib/pkgconfigCXXFLAGS:=$(shell pkg-config --cflgs --libs opencv)DispalyImage:DispalyImage.o g++ DispalyImage.o -o DispalyImageDispalyImage.o:DispalyImage.cpp g++ -c DispalyImage.cpp -o DispalyImage.oclean: rm *o test 现在建议我们从下往上分析： 编写clean ：删除所有的.o文件和可执行文件，避免过多的中间文件产生； 编写 DispalyImage.o:DispalyImage.cpp ：根据之前的格式，target : prerequisites ，这个时候 target 为 DispalyImage.o ，prerequisites 为DispalyImage.cpp 。 下一行的g++命令，将cpp文件进行编译为object file（.o 文件）。 12DispalyImage.o:DispalyImage.cpp g++ -c DispalyImage.cpp -o DispalyImage.o 编写 DispalyImage:DispalyImage.o ：在上一步我们得到了编译后的目标文件 DispalyImage.o 。现在我们可以build生成可执行文件DispalyImage。 12DispalyImage:DispalyImage.o g++ DispalyImage.o -o DispalyImage 应用OpenCV库和头文件 。 123export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/home/royhuang/lib/pkgconfigCXXFLAGS:=$(shell pkg-config --cflgs --libs opencv) PKG_CONFIG_PATH ：添加指定路径到环境变量。如上例，添加了路径/home/royhuang/lib/pkgconfig到环境变量 ，这样我们就可以直接在命令行中使用pkg-config命令 。 CXXFLAGS ：指定文件（.h文件或lib文件）的路径，使得编译时可以找到相应头文件和库文件。 在本例中，pkg-config命令可查看opencv的include头文件的路径： 12# --libs 参数可查看库文件shell pkg-config --cflgs opencv 同时引入头文件和库文件： 1pkg-config opencv --cflgs --libs opencv 有了makefile文件后，我们就可以make生成可执行文件DisplayImage了： 1234# 自动查找当前目录下叫“Makefile”或“makefile”的文件make # 显示图像./DisplayImage ../01.jpg 从上也可总结出：Makefile 包含了所有的规则和目标，而 make 则是为了完成目标而去解释 Makefile 规则的工具。 总的来说，Makefile的基本套路就是以上，熟练使用需要实际项目多练习下。 进阶学习 这里准备举一些较复杂的项目，怎么来编写Makefile文件。 但是一般较复杂的项目我现在一般用CMake，也是后文需要介绍的。因此这里复杂项目Makefile编写案例，暂时留白，后续补上。 当然，你可以先看看：Make 命令教程 - 阮一峰 。 CMake 早期的make需要程序员写Makefile文件，进行编译。而现在CMake能够通过对CmakeLists.txt的编辑，轻松实现对复杂工程的组织。 快速入门 首先，我们在Linux系统（CentOS）下安装下CMake： 1sudo yum install cmake 一般使用CMake生成Makefile并编译的流程如下： 编写CMakeLists.txt，假定其路径为PATH； 执行命令cmake PATH生成Makefile； 最后使用make进行编译。 一起试试 我们准备一个hello.cpp 文件，它所在的目录如下所示。 123|-- build # cmake生成的中间文件都放这|-- hello.cpp|-- CMakeLists.txt # 每个子目录下都要有CMakeLists.txt文件 文件内容很简单： 1234567/* hello.cpp */ #include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot;Hello Cpp!&quot;&lt;&lt;endl;&#125; 我们编写的CMakeLists.txt，每一行代码解释如下： 12345678910111213141516# 命令格式：&lt;命令名&gt;(参数 参数值) ，中间参数空格隔开# 设置项目名project(helloDemo)# 限定CMAKE最低版本CMAKE_MINIMUM_REQUIRED(VERSION 2.6)# 搜索当前目录所有源代码文件，并赋值给PROJECT_ROOT_SRCSaux_source_directory(. PROJECT_ROOT_SRCS)# 增加C++11特性add_definitions(-std=c++11)# add_executable 从一组源文件编译出一个可执行文件 # 这里将$&#123;PROJECT_ROOT_SRCS&#125;中文件编译，生成可执行文件hello.outadd_executable(hello.out $&#123;PROJECT_ROOT_SRCS&#125;) 开始编译： 12345# 生成makefile等中间文件# 生成的可执行文件 【如果要可以被调试】，还要带上参数：cmake -DCMAKE_BUILD_TYPE:STRING=Debugcd ./build &amp;&amp; cmake ..# 生成可执行文件make 最后执行刚刚生成的可执行文件： 1./hello.out 看到这里，相信你对CMake有了个基本的认知。在前面我们也知道，CMake通常是用来编译大型项目的。 那么，大型项目结构是什么样的？又如何进行编译呢？ 大型项目结构 主要参考：cpp-project-structure。 这里假定项目名为 my_poject ，一个完整的大项目结构通常如下。 1234567891011121314151617181920212223242526272829303132333435my_poject ├── deploy # 存放部署、交付的文件 │ └── bin # 项目生成的可执行文件│ └── lib # 项目生成的库文件│ └── include # 项目对外提供的头文件├── build # 存放cmake产生的中间文件│ └── release│ └── debug ├── doc # 存放项目文档├── src # 存放资源文件│ └── pic ├── 3rdparty # 存放第三方库│ └── lib # 库文件 │ └── include # 头文件├── my_poject # 项目【代码源文件】| └── module_1│ ├── 1.cpp│ ├── 1.h│ ├── CMakeLists.txt| └── module_2│ ├── 2.cpp│ ├── 2.h│ ├── CMakeLists.txt├── tools # 项目构建支持工具，如编译器├── scripts # 脚本文件，如预处理脚本├── config # 配置文件│ └── xxx.yml │ └── yyy.yml ├── test # 测试代码├── LICENSE # 版权信息├── CMakeLists.txt├── build.sh # 构建项目的脚本├── .gitignore├── README.md # 项目说明文件└── sample # 示例代码 编译复杂项目 现在我们举一个复杂点的，多层级项目如何用CMake进行编译。 整个目录结构如下（为方便，进行了精简）： 1234567891011121314151617181920212223|-- 3rdparty | |-- include| `-- lib|-- deploy | |-- bin| `-- lib|-- build|-- hello # 整个项目源码| |-- module1| | |-- people.cpp| | |-- people.h| | `-- CMakeLists.txt| |-- module2| | |-- bird.cpp| | |-- bird.h| | `-- CMakeLists.txt| |-- hello.cpp| |-- CMakeLists.txt|-- LICENSE|-- README.md|-- src| `-- video| `-- 1577414323962.mp4 其中hello目录下各源文件如下： moule1/people 相关源码 123456789101112/*people.cpp*/#include &quot;people.h&quot;void people_hello()&#123; std::cout&lt;&lt;&quot;people say : Hello Cpp!&quot;&lt;&lt;std::endl;&#125;/*people.h*/#include&lt;iostream&gt;void people_hello(); moule2/bird 相关源码 123456789101112/*bird.cpp*/#include &quot;bird.h&quot;void bird_hello()&#123; std::cout&lt;&lt;&quot;bird say : Hello Cpp!&quot;&lt;&lt;std::endl;&#125;/*bird.h*/#include&lt;iostream&gt;void bird_hello(); hello/hello.cpp 源码 12345678#include &quot;./module1/people.h&quot;#include &quot;./module2/bird.h&quot;int main()&#123; people_hello(); bird_hello();&#125; 最后给出各个目录下的CMakeLists.txt文件。 module1module2hello module1 编译生成动态库libmodule1.so 。 12345678# 查找当前目录（module1）下的相关文件,并赋值给MODULE1_SRCaux_source_directory(. MODULE1_SRC)# 将指定的源文件（MODULE1_SRC）生成库文件libmodule1.so# 【注1】不需要写全libmodule1.so，只需写module即可，cmake会自动补全。# 【注2】SHARED参数指定生成动态库（.so文件），不加参数默认生成静态库（.a）文件add_library(module1 SHARED $&#123;MODULE1_SRC&#125;) module2 编译生成动态库libmodule2.so ，基本同前。 123456# 查找当前目录（module2）下的相关文件,并赋值给MODULE2_SRCaux_source_directory(. MODULE2_SRC)# 将指定的源文件（MODULE1_SRC）生成库文件libmodule1.soadd_library(module2 SHARED $&#123;MODULE2_SRC&#125;) hello 编译生成可执行文件hello.out ，然后链接libmodule1.so和 libmodule2.so。 12345678910111213141516171819202122232425262728293031323334353637# 命令格式：&lt;命令名&gt;(参数 参数值) ，中间参数空格隔开# 设置项目名project(helloDemo)# 设置可执行文件保存路径set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/../deploy/bin)# 限定CMAKE最低版本CMAKE_MINIMUM_REQUIRED(VERSION 2.6)# 将module1和module2文件夹加入子目录,这样cmake就可以去其中查找编译# 【注1】没有这个会报错，ld:找不到 -lmoudle1 和 -lmoudle2# 【注2】这里只能用相对路径，不是hello项目下的路径，是指# build下的相对路径。# 因为最后make是在build路径下，libmoudule1.so和# libmoudule2.so是分别保存在build/moudle1 和build/module2下ADD_SUBDIRECTORY(./module1) ADD_SUBDIRECTORY(./module2)# 搜索当前目录所有源代码文件，并赋值给PROJECT_ROOT_SRCSaux_source_directory(. PROJECT_ROOT_SRCS)# 增加C++11特性add_definitions(-std=c++11)# 【编译】# add_executable 从一组源文件编译出一个可执行文件 # 这里将$&#123;PROJECT_ROOT_SRCS&#125;中文件编译，生成可执行文件hello.outadd_executable(hello.out $&#123;PROJECT_ROOT_SRCS&#125;)# 【链接】# 将目标文件与库文件进行链接，不显示指示文件后缀（如 module1.so），优先链接动态库TARGET_LINK_LIBRARIES( hello.out module2 module1) 特别的，如果你还引用了第三方库，还应该做如下修改。 假设你引用的第三方库为ffmpeg ，相关头文件和库文件都放在3rdparty目录下。 增加ffmpeg库文件和头文件搜索路径 1234# 头文件搜索路径include_directories($&#123;PROJECT_SOURCE_DIR&#125;../3rdparty/inclue)# 库文件搜索路径link_directories($&#123;PROJECT_SOURCE_DIR&#125;../3rdparty/lib) 链接ffmepeg相应库 123456789101112131415# 链接ffmpeg库# 将目标文件与库文件进行链接TARGET_LINK_LIBRARIES( hello.out module2 module1 libavcodec.so # 显示指定动态库 libavdevice.so libavfilter.so libavformat.so libavutil.so libpostproc.so libswresample.so libswscale.so) 准备好所有的文件后，我们开始进行cmake构建： 12cd ./buildcmake ../hello &amp;&amp; make 在bin 下执行： 1../deploy/bin/hello.out 👨‍💻 CMake相关介绍到此完结。 写在最后 这篇博客主要介绍了编译的基本过程和原理，以及常用的编译工具（g++/Makefile/CMake）使用。 从构思大纲到最后初步完工大概用了五天，比最初预估的进度多花了一倍时间。最主要的原因就是中间我一直在删删改改，特别是写编译过程初探这一节：每写完一个版本，我就自己先看一遍再问自己：你真的能看明白吗？还是有些不理解的地方，就继续Google些资料看，直到把自己说服----至少文章逻辑上自恰了。同时也更深刻地体会到了：自己觉得懂了可能不是真的懂了，能把别人讲明白才可能算是懂了。 C++环境相关介绍就先告一段落了，接下来准备整理一下C++基础相关知识（有事情做的感觉还不错😀 ），回复完论文评审意见后尽快开始更新。 更新记录 2022-01-24 ：更新笔记 增加可执行文件执行过程分析 2021-12-20 ：更新笔记 增加g++相关介绍 2021-12-10 ：上传初稿 第一次更新，发布初稿 参考资料 1.g++，CMake和Makefile了解一下 ： https://zhuanlan.zhihu.com/p/55027085 ↩2.Linux下使用CMake编译C++：https://zhuanlan.zhihu.com/p/373256365 ↩3.阮一峰--编译器的工作过程：http://www.ruanyifeng.com/blog/2014/11/compiler.html ↩4.符号解析：https://www.jianshu.com/p/2786533a34c9 ↩5.计算机原理系列之七-链接过程分析：https://luomuxiaoxiao.com/?p=572 ↩6.静态链接与动态链接在链接过程和文件结构上的区别：https://www.polarxiong.com/ ↩7.gcc编译生成可执行文件的过程中发生了什么：https://blog.csdn.net/albertsh/article/details/89309107 ↩8.C/C++中关于静态链接库(.a)、动态链接库（.so）的编译与使用：https://blog.csdn.net/qq_27825451/article/details/105700361 ↩9.cpp_new_features：https://github.com/0voice/cpp_new_features/blob/main/ ↩","categories":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/categories/C/"},{"name":"从零开始","slug":"C/从零开始","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"},{"name":"C++环境搭建","slug":"C/从零开始/C-环境搭建","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/tags/C/"},{"name":"教程","slug":"教程","permalink":"https://hwh.zone/tags/%E6%95%99%E7%A8%8B/"},{"name":"CMake","slug":"CMake","permalink":"https://hwh.zone/tags/CMake/"},{"name":"Makefile","slug":"Makefile","permalink":"https://hwh.zone/tags/Makefile/"},{"name":"g++","slug":"g","permalink":"https://hwh.zone/tags/g/"},{"name":"C++环境搭建","slug":"C-环境搭建","permalink":"https://hwh.zone/tags/C-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"C++从零开始（零）","slug":"C++从零开始（零）：写在前面","date":"2021-12-05T08:22:28.029Z","updated":"2022-02-19T10:13:23.895Z","comments":true,"path":"p/62712/","link":"","permalink":"https://hwh.zone/p/62712/","excerpt":"","text":"🖋 《C++从零开始》系列，持续更新中… 写在前面 为什么写这份笔记 这个系列虽然名为：《C++从零开始》，但细细算来，我已经不止系统性地学过C++一次了。说来惭愧，每次目的也都是为了对付考试，取个不错的成绩而下点苦工罢了。 阴差阳错，我明年即将入职腾讯，并以C++开始自己职业生涯的第一站，正好在校还有段较清闲的时光，于是下笔写了这个C++系列笔记。一是分享记录、以讲代学，希望能对同样学习C++的读者有点帮助；二是好记性不如烂笔头，同时帮助自己时时记忆和温习；三是开源分享、贡献一点力量，中文（文字版）开源教程/笔记太少，希望能自己整理一份精炼也足够清晰的C++总结记录。 动笔前，我仔细构思了下该系列笔记的整体结构，下节会开始介绍具体介绍。 特别的，这个系列处于初建状态，文章可能会由于更新等原因和之前版本有所不同； 所有的文章更新记录变化，可以在第三大节：更新记录中查看。 谁适合阅读本文 这个系列虽然叫做“从零开始”，但如果你真的零基础，阅读了前面《环境搭建》两篇文章便可能要开始怀疑自己是不是适合做程序员了。 当然作者并非有意让你感到这种沮丧的情绪，一是希望以讲代学 的方式帮助自己和读者提高C++水平，二是因为希望这个系列的阅读人群： 具有一定编程语言基础，比如C、Python、Java，有C++最好； 希望进一步提高、巩固C++基础，看完本系列能达到校招大厂C++至少“及格线”水平（因此本系列也插入了很多“八股文”相互验证）。 如果你真的需要更基础的教程，但因为作者还没有在中文互联网找到比较好的开源文字教程，英文教程倒是找到不少（不禁再次感慨英文的重要性），因此对于零基础的同学，分别推荐英、中（文字）教程一份： 英文：强烈推荐—learncpp，英文如果阅读吃力建议安装谷歌翻译插件； 中文：腾讯云C++教程，偏基础，适合英文阅读过于困难又无基础的同学。 总目录 ⏰ 最后更新时间：2022/02/11 17:00 。 从零开始系列暂分为三部曲：《C++篇》、《Linux/C++系统编程篇》、《网络编程篇》，以及可能补充的《C++开源分析》部分。 文章 备注 C++篇 C++从零开始（一）：环境搭建（上）VSCode远程开发 ✔️更新完成 C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门 ✔️更新完成 C++从零开始（三）：务实基础（上）快速入门 ✔️更新完成 C++从零开始（四）：务实基础（中）指针和引用 ✔️更新完成 C++从零开始（五）：务实基础（下）之函数 ✔️更新完成 C++从零开始（六）：务实基础（下）复合类型及转换 ✔️更新完成 C++从零开始（七）：面对对象（上）快速入门 ✔️更新完成 C++从零开始（八）：面对对象（中）运算符重载 ✔️更新完成 C++从零开始（九）：面对对象（下）继承与虚函数 ✔️更新完成 C++从零开始（十）：C++进阶（上）模板 ✔️更新完成 C++从零开始（十一）：C++进阶（下）STL ✔️更新完成 Linux/C++篇 C++从零开始（十二）：Linux/C++之 🔨 更新ing C++从零开始（）：Linux/C++之 C++从零开始（）：Linux/C++之 C++从零开始（）：Linux/C++之 C++从零开始（）：Linux/C++之 网络编程篇 未定 C++开源 C++从零开始（）：C++开源之Zaver源码分析 C++从零开始（）：C++开源之实现自己的ffmpeg转码器 C++从零开始（）：C++开源之SRS源码分析 写在最后 ⏲ 更新时间：2021/12/05 17:00 。 从玩到无聊开始学习到十二月初给自己挖了个大坑，play hard study hard 居然不知不觉成了我的行为习惯。当然，玩到胖了十多斤并不是我本意… 借此机会，提前许下几个新年愿望（是的，就是这么突然）： 三个月内顺利更新完这个系列大部分文档； 多花点时间学习，不能过分玩乐； 少熬夜，多喝茶； 如意考试顺利。 敬请期待~ 😋 （顺便分享一下我的新插件一首应景的小诗） [飞鸟集][泰戈尔]闲暇在动作时 便是工作。 静止的海水荡动时 便成波涛。 更新记录 2022-02-19：文章更新 C++从零开始（十一）：C++进阶（下）STL更新完成 2022-02-11：文章更新 C++从零开始（十）：C++进阶（上）模板更新完成 2022-02-08：文章更新 C++从零开始（九）：面对对象（下）继承与虚函数 更新完成 2022-01-31：文章更新 C++从零开始（八）：面对对象（中）运算符重载 更新完成🙂 新年快乐！ 2022-01-27 ：文章更新 C++从零开始（七）：面对对象（上）快速入门更新完毕 2022-01-22 ：文章更新 C++从零开始（六）：务实基础（下）复合类型及转换更新完毕 2022-01-18 ：文章更新 C++从零开始（三）：务实基础（上）之快速入门更新完毕C++从零开始（四）：务实基础（中）之指针和引用 更新完毕C++从零开始（五）：务实基础（下）之函数 更新完毕 2021-12-10 ：文章更新 C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门更新完毕 2021-12-06 ：文章更新 C++从零开始（一）：环境搭建（上）之VSCode远程开发 更新完毕 2021-12-05 ：第一次更新 初步确定《C++从零开始系列》大纲即将更新：C++基础系列 参考资料 1.阿秀的求职笔记：https://interviewguide.cn/ ↩2.zavar开源地址: https://github.com/zyearn/zaver ↩3.ffmpeg-trancode开源地址: https://github.com/leichn/exercises/tree/master/source/ffmpeg/ffmpeg_transcode ↩4.SRS开源地址：https://github.com/ossrs/srs ↩5.腾讯云C++教程：https://cloud.tencent.com/edu/learning/course-1844-21296 ↩","categories":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/categories/C/"},{"name":"从零开始","slug":"C/从零开始","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/tags/C/"},{"name":"教程","slug":"教程","permalink":"https://hwh.zone/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Hexo+Github Pages快速打造属于自己的网站","slug":"Hexo快速打造属于自己网站","date":"2021-11-29T12:10:54.202Z","updated":"2022-02-08T16:55:32.080Z","comments":true,"path":"p/56326/","link":"","permalink":"https://hwh.zone/p/56326/","excerpt":"","text":"⚠️ 阅读本文前，你需要具备： 会打字 熟练掌握Ctrl+C/Ctrl+V 或许有一点的网络知识 如果操作遇到困难，可在文章下方进行留言😃。 前言 迫不及待？建站效果实时预览：royhuang‘s blog 。 royhuang's bloghttps://www.hwh.zone 第一次建站时还是三年前用WordPress搭建，网站放在腾讯云VPS上运行。因为机器配置较低比较卡，有次暴躁debug把整个服务器remake了，不了了之。再后面又因为对Java Web开发比较感兴趣，折腾了SpringBoot Web开发和前后端相关知识，打算自己完全前后端自主开发一个博客。因为主客观各种原因，做了一个残次品，阴差阳错最后要以C++开始自己职业生涯第一站，也没有最终完善。 趁着这段时间，使用Hexo+Github Pages 作为最终建站方案折腾了几天，总体来说效果还比较满意。为了后来人少踩点坑，同时为自己糟糕的记忆留点回忆，特此记录。 主流建站方式比较 在正式开始前，我们不妨先来分析下主流建站方式，做到心中有数。自然，此节也可以略过。 建站难度 所需知识 定制化程度 适合人群 备注 WordPress ⭐️⭐️ Linux、Git基本知识 一般 Web开发小白人群 之前写的教程：教练,我想建网站！ Java Web ⭐️⭐️⭐️⭐️ Web前后端开发知识，多且杂 非常高，前后端代码全栈开发 Java Web开发人员 Hexo + Github Pages ⭐️⭐️ Linux、Git基本知识 较高，基于配置文件修改较方便 Web开发小白人群 不需要备案域名 Hexo + 腾讯云 ⭐️⭐️ 同上 同上 同上 域名需要备案，但网站访问速度会变快很多 根据以上，我们可以根据不同情况进行选择： Java Web全栈搭建？ 适合Java Web为技术栈的专业人员，可以作为个小项目； 但如果你并非专业的Java Web开发人员，不想学习复杂的Java Web体系，但是又具备开发基础知识，想搭建一个漂亮的博客：WordPress 和 Hexo是你不二的选择。 WordPress还是Hexo[3] ？ 作为都体验过的人，我说说一下自己比较主观的对比： WordPress优点：很简单，适合特别小白的同学； WordPress缺点：占用资源多，响应慢；不支持原生markdown（每次要导出.html太痛苦了）；主题也不够合心意（不美观）。 所以我自己（有开发基础）还是推荐使用Hexo。 Hexo + Github Pages 还是 Hexo + 腾讯云? Github Pages 托管网站：因为服务器在国外（Github），域名无需备案，但访问速度会比较慢，也无需购买云服务器； 腾讯云托管网站：需要购买云服务器（或COS），且域名需要备案，但访问速度会很快。 因为本文考虑更低成本，我也比较懒不想备案，访问速度虽然慢点但还能接受，所以采用Hexo + Github Pages作为最终的建站方案。 好了，现在让我们开始激动人心的环节吧，动手搭建自己的网络快乐小窝。 Hexo + Github Pages Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub Pages上（无需云服务器），是搭建博客的首选框架[2]。 用大白话来说就是： Hexo：用来将我们写的文章，渲染生成本地生成静态网页 ，但只有你自己能看到； Github Pages : 将Hexo生成的静态网页，部署托管到云服务器（Github Pages，VPS，COS均可）上，这样别人也可以访问。 快速开始 以下主要操作均已在虚拟机中经过二次验证。 准备工作：Github &amp; Git 创建Github个人仓库 ⚠️ 注意命令方式必须为：你的Github用户名.github.io ，这种形式。 登陆用户名和昵称分不清?你的个人主页，下面红框所示才是你的用户名。 我已创建过该项目，故显示重复 安装Git Git下载地址 , 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，则Git安装成功。 同时还需配置基本Github相关信息，主要是用户名和邮箱： 12$ git config --global user.name &quot;Wanghui-Huang&quot; $ git config --global user.email &quot;380141202@qq.com&quot; 本文默认你具备基本Git相关知识，故不再赘述，如果不具备可以学习：Git基础笔记 。 安装Node.js Hexo基于Node.js，自然需要安装相关组件。 下载 Node.js , 一直默认安装即可（不要随意勾选）。 安装成功后，分别输入 node -v &amp; npm -v，出现以下版本信息则安装成功： 搭建Hexo 新建文件夹 我们在合适的路径新建一个文件夹，命名随意，我命名为：www.hwh.zone。 安装Hexo 1npm install -g hexo-cli 初始化博客 12cd ./www.hwh.zone/hexo init blog 本地测试验证 ⚠️ 注意以下命令全部都在：./www.hwh.zone/blog 路径下执行。 1234cd ./blog/hexo new test_my_site # 生成一篇新文章hexo g # 生成静态文件（网页）hexo s # 本地生成静态网站预览 执行完毕后，输入：http://localhost:4000 ，出现以下页面则生成成功： 如果hexo s 执行成功，浏览器却打不开，通常是端口（4000）被占用。可以设置hexo使用别的端口： 1hexo server -p 4001 然后输入：http://localhost:4001 ，重新打开即可。 现在你已经初步搭建好了自己的网站，现在让我们开始发布自己的网站，让更多人看到~ 配置远程推送信息 在 ./www.hwh.zone/blog 路径下，找到主配置文件：__config.yml ： [注1]：因为这个文件很重要，特附图示例 。 [注2]：该配置文件对缩进等都严格要求，建议用IDE打开编辑（比如VScode），不易出错。 在文件最下方配置相关信息： ⚠️ 注意： : 后面需要留一个空格 ，repo地址最后需要带上 .git ! 安装Git插件 1npm install hexo-deployer-git --save 写一篇自己的文章 _posts 路径下的 md 文件，会被Hexo自动解析、渲染生成网页。我们所有的博客都是放在这个目录的。 我们在：www.hwh.zone\\blog\\source\\_posts 路径下，写一篇属于自己的文章： 开始发布网站 以上命令如果不出错，依次执行以下命令： 123456# 清除缓存网页hexo clean # 生成静态网页hexo g# 推送发布网站，要输入Github账号和token（注意不是密码，github从上月开始已经使用token验证身份，生成token可参考：https://zhuanlan.zhihu.com/p/38800965）hexo d 🐛 解决BUG：OpenSSL SSL_read：Connection was reset，erron 10054。 第一种情况：未解除SSL验证 打开git，切换到www.hwh.zone/blog 目录下 取消SSL验证 1git config --global http.sslVerify &quot;false&quot; 第二种情况：开了小飞机，让小飞机重新换个服务器重新连接。 欣赏你自己的网站~！ 现在我们在浏览器输入：Wanghui-Huang.github.io , 可以看到我们第一篇博客已经正式发布了！🤙 愉快的多欣赏一下吧~ TIPS 💡 一般我们发布文章（或修改主题CSS样式等）, 流程如下： hexo clean &amp;&amp; hexo g &amp;&amp; hexo s ，打开 localhost:4000本地预览； 本地进行修改，e.g. 文章增改、CSS样式修改； F5刷新下网页即可看到修改后的文章或样式，一般不需要重新执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo d ； 但是如果出现刷新无效，此时最好重新执行下以上三个命令； 最后再执行hexo d , 发布文章。 主题&amp;美化：以Butterfly为例 hexo的众多开发者，无私提供了非常多主题供我们进行主题美化。去Hexo官网或在Github-hexo theme ，搜索一个你喜欢的主题： 在这里，我使用主题 Github-Butterfly ，作为最终的选择。 快速开始 下载主题 1git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly ⚠️ 下载完毕后，文件重命名为 butterfly ， 放在 www.hwh.zone\\blog\\themes 目录下。 应用主题 在Hexo根目录下主配置文件 _config.yml , 进行配置： 1theme: butterfly 安装必要插件 1npm install hexo-renderer-pug hexo-renderer-stylus --save 测试查看 重新生成静态网页： 123hexo cleanhexo ghexo d 打开 ：http://localhost:4000 , 可看到主题已经被成功替换。 基本配置 如果你想参考我的配置信息，可在进行附录中查看。 在这一节我们将进行主题的基本信息设置，包括但不限于： 网站基本信息设置 背景图片设置 目录相关设置 … 但是在本文并不准备将以上设置过程详细列出，因为官网对这些的描述已经非常清晰和简洁。因此，强烈建议你参考官网文档：butterfly主题配置官方文档 ，根据个人喜欢进行这些基本设置。 在这里将主要记录：官网文档未提及的优化，以及根据官网文档配置时遇到的问题解决办法。 Markdowm渲染优化 本节涉及：数学公式、脚注、表情、标题大小等设置。 数学公式表情脚注标题大小标签外挂按照 官方文档 , 进行配置： 修改主题配置文件，加载katex.min.css ⚠️ per_page 属性不能设置true，否则会出现bug：公式被渲染两次。 123456katex: enable: true # true 表示每一頁都加載katex.js # false 需要時加載，須在使用的Markdown Front-matter 加上 katex: true per_page: false # 不要选择为true！！ hide_scrollbar: true 然后在需要打开数学公式渲染的文章，开头设置：katex: true 安裝 hexo-renderer-markdown-it 12345npm un hexo-renderer-marked --save # 如果有安裝這個的話，卸載npm un hexo-renderer-kramed --save # 如果有安裝這個的話，卸載npm i hexo-renderer-markdown-it --save # 需要安裝這個渲染插件npm install @neilsustc/markdown-it-katex --save #需要安裝這個katex插件 修改Hexo根目录配置文件 123456markdown: plugins: - plugin: name: &#x27;@neilsustc/markdown-it-katex&#x27; options: strict: false 表情插件配置过程如下： 安装插件 1npm install markdown-it-emoji --save 根目录配置文件添加插件 脚注直接安装插件即可： 1npm install hexo-reference --save 如果安装后，本地（typora）可以正确渲染，hexo无法正确渲染：多半是脚注使用出现语法错误。 在正文中：严格按照[^1] 写入脚注，不要用任何空格！ 在链接中：严格按照[^1]: 写入引用链接，不要用任何空格！ butterfly主题标题大小默认的过小，不易于和正文进行区分。 为此，我们需要： 找到\\www.hwh.zone\\blog\\themes\\butterfly\\source\\css\\_third-party 路径下的normalize.min.css 文件 手动设置 h1~h5标题大小 标签外挂插件 Tag Plugins Plus ，提供了丰富的markdown文件编写美化： 时间轴 各种卡片 音频、视频插入 … 可以让你的文章看起来美观许多，具体配置请参考：Tag Plugins Plus官网 。 文档清晰简洁，这里不再赘述。 支持评论功能 官网文档虽然给了很多种设置的评论方式，但就我自己尝试而言，Utterances和Twikoo属于比较方便的方式。 Utterances主要优点： 和Gitalk类似，但不需要过多的权限设置； 相比Facebook Comments 等无需翻墙； 相比Disqus等UI更简洁美观。 唯一美中不足的便是不能匿名评论，留言必须要用Github账号先登录。Twikoo在下文进行介绍。 Utterances（免费）Twikoo（付费）以下是Utterances设置过程： 在Github创建一个public的项目 不再赘述过程，我使用的是：https://github.com/Wanghui-Huang/gittalk ，这个项目。 安装 utterances 点击：https://github.com/apps/utterances ，安装app（右上方处Install按钮）。 安装成功后，会出现下面Configure按钮： 设置相关信息 点击Configure按钮，进入设置界面，注意红框处相关信息设置： 设置完毕后保存。 主题文件配置 修改主题配置文件：repo修改为你刚刚创建的repo，形式为 你的用户名.项目名 继续修改配置文件，指定评价插件名： 测试 &amp; bug解决 选择任意一篇文章，可以看到评论框已经顺利出现： 经过实际测试，依旧会出现评论框无法显示的问题： 我的问题是因为使用了自己的域名，https不安全便会出现这个问题； 如何使用自己的域名，后续小节有详细教程 &amp; 踩坑记录。 可以在 Github项目：Wanghui-Huang.github.io → Setting→Pages ，勾选Enforce HTTPS ： 三连重新生成静态网页： 123hexo cleanhexo ghexo s 便可以看到评论框已经正确显示了。 虽然Utterances已经足够简洁优秀且免费，但是Twikoo基于腾讯云开发，在国内速度很快&amp;支持匿名，价格也足够实惠（包年大约6元/月）。另一方面，支持下东家业务最后选择了这个方案。 腾讯云函数配置 这一部分看官网文档即可，很详细不再赘述。 Butterfly主题配置 修改 主題配置文件 ： 12345twikoo: envId: blog-comments-5g2cfs******* # 腾讯云函数配置完后的id region: ap-shanghai # 默认上海 visitor: true # 显示文章浏览数 option: 测试 静态网页生成三连，便可以看到已经生成成功了： 其它补充 链接太长不好分享？ 想要一个属于自己的漂漂域名？ 网站发布后本地图片全挂？ … 在这里我们依次进行解决各种问题，让你的网络小窝看起来更加的专业。 使用短连接 hexo 默认生成文章长链接具有以下几个缺点： 如果文章名包含中文，将会被转码，链接不雅观且长； 长链接不利于搜索引擎收录； 长链接不方便分享给他人。 因此，参考[4]，我们利用Hexo-abbrlink插件，生成唯一文章短链接。 安装插件 1npm install hexo-abbrlink --save 修改根目录配置文件 url：你的域名 ，如果是Github Pages命令方式为 https://你的用户名.github.io permalink：按下图修改 permalink_defaults：注释掉 三连重新生成 123hexo cleanhexo ghexo s 测试 生成完毕后，可以看到，在每一篇文章开头，自动多出了以下属性： 1abbrlink: 56326 # 这个id每篇文章都不一样 文章链接也变成了短链接的形式： 使用图床 使用markdown最头疼的地方，估计就是图片问题了：文章图片通常保存在本地，发布网站还是分享给他人通常还需要单独保存图片。显然，这一点也不cool。 幸运的是，我们可以使用图床，将图片通通保存在云端，本地只需像如下引用个链接即可： 1![image-20211203121301172](https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203121301172.png) 特别的，配合Typora，所有本地图片可以自动上传到云端，可以说是很方便了。 因此，本文参考[5]，使用Typora配合腾讯云COS存储搭建图床。 为什么选择要付费的腾讯云COS？ 在这之前我也选择了其它的免费图床，使用体验不太佳： 速度很慢，而且限制一天上传的数量和频率，有时候需要集中上传本地文件的大量图片便很不友好了； 腾讯云COS虽然付费，但是价格很便宜，10元可以租10G/年。 因此，最终我还是选择了腾讯云COS存储作为图床。 下载Typora 下载地址：腾讯云高速下载 ，默认安装即可。 下载PicGo 下载地址：官网下载 ，默认安装即可。 腾讯云创建COS存储 进入腾讯云对象存储，在存储桶列表中点击创建存储桶： 设置存储信息如下： 密钥管理 密钥需要等会儿在配置文件中用到，因此我们需要提前设置好。 如果没有密钥，则新建密钥： 记录以下：SecretID 和 SecretKey，等下要用到。 配置PicGo 打开PicGo后，图片上传选择腾讯云COS，然后进行以下设置： 测试PicGO 在左上【上传区】，任意拖拽一张图片，如果上传成功则说明配置成功。 配置Typora 打开Typora：文件→偏好设置→图像： 测试Typora配置 在右侧栏中左下角，找到【验证图片上传选项】，测试是否成功； 打开typora，任意在文章中粘贴一张本地图片，看是否会自动上传。 以上成功，便可以愉快的开始编写文章了，开始你的大文豪生活了。 使用自己的域名 xxxxx.github.io 看起来丑丑的，怎么拥有一个自己的漂漂域名呢？ 买一个属于自己的域名 点击：腾讯云域名注册 ，注册一个自己的域名。 实名认证 参考官方文档：域名实名认证 , 不进行实名认证可能无法进行正常域名解析。 域名解析设置 进入腾讯云解析设置： 分别添加以下解析记录： 配置CNAME：我的域名 www.hwh.zone 可以解析到原本域名Wanghui-Huang.github.io ，这个时候 www.hwh.zone相当是个别名，也就是暴露给别人看到的名字。 配置A记录：可以把域名www.hwh.zone 直接解析到 Github IP地址 （二次保障能解析到Github IP地址）。 不理解CNAME作用？有了A记录解析为什么还要CNAME？可参考：cname记录是什么？他存在的意义是什么？ 申请免费SSL证书 参考官方文档：域名型（DV）免费 SSL 证书申请流程 Github Page设置 在 Github项目：Wanghui-Huang.github.io → Setting→Pages ，设置你自己的域名 ： 创建CNAME文件 进入本地博客文件夹目录，例如我的：www.hwh.zone\\blog\\source ： 新建文件CNAME→输入你的域名 ⚠️ 注意：域名不要带www. 保存文件 ⚠️ 保存文件类型为所有文件，不是TXT文件！ 测试 网站三连发布后，浏览器输入：你的域名 ，便可以正常开始解析了。 如果遇到错误，可以在下方评论留言。 网站备案 网站备案后通常有不少好处[6]，对于个人博客来说最重要的三个便是： 加快网站的访问速度； 利于搜索引擎收录； Github Pages访问较慢，备案后可以将服务器部署到（国内服务器）腾讯云COS或者腾讯云VPS上，访问速度极大加快。 但这不影响网站域名的正常解析（除了慢点），因为毕竟网站部署在国外服务器（Github）上。 另外，网站备案经过我的尝试相比之前简便很多，只需要在腾讯云全程线上备案登记注册就好。但因为我身份证归属省份（江西），根据当地政策备案需要关闭网站，所以放弃折腾了。后续有时间补上。 写在最后 断断续续写了大概一天，终于记录完了Hexo建站的基本所有的过程。因为没怎么运动，肩膀一直隐隐酸痛还是坚持写完了，可以说是身残志坚了。 后续的话可能会继续更新这篇文章，更好的打造自己的小窝，但主要还是更新一些C++和音视频相关博文： C++从零开始系列：C++基础、C++11特性学习、C++八股总结、C++开源源码分析； 音视频系列：待定； 其它：备案完成后，更新部署到腾讯云COS上教程。 欢迎继续关注，一起学习。 更新记录 2021-12-06 ：更新文档 修改备案相关描述；新增腾讯云COS相关描述。 2021-12-05 ：更新文档 支持标签外挂，并新增安装教程优化文章版式：分栏书写更新配置文件 2021-12-01 ：第一次更新 上传初稿并发布 附录 以下配置文件最终更新时间：2021/12/05 00:00 。 royhuang’s 主配置文件 点击这里查看：_config.yml royhuang’s Butterfly配置文件 点击这里查看：_config.butterfly.yml 1.Butterfly 官方教程：https://butterfly.js.org/posts/21cfbf15/ ↩2.Hexo 知乎教程：https://zhuanlan.zhihu.com/p/26625249 ↩3.从wordpress到hexo：https://www.wenjinyu.me/zh/from-wordpress-to-hexo-my-blog-should-have-been-like-this/ ↩4.Hexo-abbrlink插件生成唯一文章链接：https://zhuanlan.zhihu.com/p/112318081 ↩5.Typora+PicGo+腾讯云COS实现图片上传功能：https://www.daimajiaoliu.com/daima/56a7c8410d4cc09 ↩6.网站域名备案的好处有哪些？https://www.ggcx.com/news/2105/251639.html ↩","categories":[{"name":"建站","slug":"建站","permalink":"https://hwh.zone/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"网站建设","slug":"网站建设","permalink":"https://hwh.zone/tags/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"},{"name":"hexo","slug":"hexo","permalink":"https://hwh.zone/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"https://hwh.zone/tags/github-pages/"}]},{"title":"校招笔记（八）_计算机基础_场景&智力题","slug":"校招笔记（八）_计算机基础_场景和智力题","date":"2021-11-26T13:37:19.761Z","updated":"2021-12-25T16:15:05.950Z","comments":true,"path":"p/31667/","link":"","permalink":"https://hwh.zone/p/31667/","excerpt":"","text":"我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。 备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 八、场景题&amp;智力题 8.1 场景题 1. 设计一个微信运动排行榜？（Redis） 被CSIG伤过的的心还可以爱谁（第一次回答） “可以使用mysql, 将用户的好友列表关联的运动记录查询出来，然后通过order by 来进行排序，就可以实现了。” 一旦数据量大达到千万级别的时候，不可避免地会出现慢查询，效率就会降低。所以这不是面试官想听到的回答！ Redis–高效 使用Redis的有序集合 zset（有序且不重复） 。因为 zset 排序的下标从0 开始，自带一个score 值，该值可以当作排行的标准 。 添加用户和步数： zadd key score member 查询指定排名范围内用户： （从小到大）zrange key start stop withscores or （从大到小）zrevrange key start stop withscores 根据上面，所以用户按score从小到大排序完毕了，如果还要获取排名也可以使用下面命令： 查询指定用户排名 ： zrank key member or zrevrank key member 一个简单的排行榜就设计完成了。 如果面试官进一步问：一周排行榜怎么设计？ 一周的数据其实就是7天数据的累加，累加完后再排序，一个月的数据原理也是一样。可以使用 ： ZINTERSTORE ： 计算给定一个或多个有序集的交集并将结果放到一个新的有序集合destination中。 1ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX] 默认情况使用的函数是求和。 所以可以使用： 1zunionstore last_seven_days 7 20210315 20210316 20210317 20210318 20210319 20210320 20210321 2. 海量数据问题 参考：https://blog.csdn.net/v_JULY_v/article/details/6279498 在海量数据中，针对top K类问题，通常比较好的方案是： Top数问题：小根堆 有1亿个浮点数，如何找出其最大的10000个？ 直接进行排序，大约需要10^8*4字节 = 400M ，如果内存够可以直接进行排序；如果内存不够采用： 最小堆法 ：（1）先读入10000个数来创建大小为10000的最小堆（假设这10000个数是最大的10000个，然后每次和这10000中最小的比较）（2）遍历后续数字，和堆顶最小数字比较：如果小于堆顶数字，继续；如果大于堆顶数字，则替换堆顶并重新调整为最小堆（3）整个过程直至1亿个数全部遍历完为止 分治法。 （1）1亿分为100份，每份100万个数据，找到每份的最大的1万个 （2）在剩下的100*1万个数据找到最大的1万个 哈希法。 如果这1亿个书里面有很多重复的数，先通过Hash法，把这1亿个数字去重复。 然后再采用方法 1 或 2 。 最多重复（频率最高）：Hash映射+HashMap频率计算 【最多重复】海量日志数据，提取出某日访问百度次数最多的那个IP。 分治法（基于Hash）。 （1）按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中 （2）对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map （3）可以得到1024个小文件中的出现次数最多的IP ，再根据常规排序得到。 ⚠️ 使用Hash分散ip可以保证相同ip都在同一个文件夹，如果只是简单均分是不行的。 【最多重复】有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。 同上，分治法（基于Hash）。 首先计算下：1G / 1M = 1000个小文件，为保险分为2000个（1）Hash(词)%2000 映射到2000个文件中（2）分别计算2000个文件频率最高的那个单词，然后常规排序即可（2000个单词占：2k*16B=32KB&lt;&lt;1M） 【最多重复】有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。 同上，分治法（基于Hash）。 顺序读取10个文件，然后将query重新映射到若干个文件中，保证相同query都在同一个文件。其余同上。 不重复数：位图 【不重复】 在2.5亿个整数中找出不重复的整数。注，内存不足以容纳这2.5亿个整数。 采用2位图（BitMap）。00表示不存在，01表示出现一次，10表示多次，11无意义，需要2.5∗108b=2.5∗0.1Gb=0.25Gb=25MB2.5*10^8b = 2.5*0.1Gb=0.25Gb=25MB2.5∗108b=2.5∗0.1Gb=0.25Gb=25MB。但是我们需要把所有的整数都表示出来2∗232bit=1GB2*2^{32}bit=1GB2∗232bit=1GB（1）扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变（2）查看bitmap，把对应位是01 的整数输出即可。 注，int类型占32个字节，2322^{32}232 表示其能表示的整数个数。 【不重复·腾讯】给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？ 采用2位图（BitMap）。 需要40亿bit，大约500M，但实际是要表示所有整数，故还是1GB。其余同上。 共同数 【相同数】 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？ 分治法（基于Hash）。 （1）分别将a，b两个大文件各自映射为10000个小文件，这样相同url会映射到a,b相同哈希值小文件中。（2）在a,b每一对小文件找到相同的url。 3. 分布式相关 谈一谈，分布式集群中如何保证线程安全？ 对于单一服务来说，只要保证一台机器上的对于共享资源的访问是同步进行的就能保证线程安全了；但是对于分布式系统而已，保证一台服务器的同步，并不能保证访问共享资源是同步的； 所以可以考虑使用分布式锁的方式来保证分布式中的线程的安全线，这样不同的服务不同的线程通过竞争分布式锁来获取共享资源的操作权限； 例如redis的分布式锁、zookeeper锁，都可以作为分布式线程安全的手段。 在淘宝购物，这个场景下，你会怎样来设计消息队列？ 什么是消息队列？ 消息队列（MQ）可以简单理解为：把要传输的数据放在队列中，一种先进先出的结构。 怎么去设计淘宝消息队列？ 待补充。 4. 微信抢红包 例如一个人在群里发了100块钱的红包，群里有10个人一起来抢红包，每人抢到的金额随机分配。 所有人抢到的金额之和要等于红包金额，不能多也不能少。 每个人至少抢到1分钱。 要保证红包拆分的金额尽可能分布均衡，不要出现两极分化太严重的情况。 二倍均值法：假设剩余红包金额为m元，剩余人数为n，那么有如下公式： 每次抢到的金额 = [0.01，m /n × 2 - 0.01] 这个公式，保证了每次随机金额的平均值是相等的，不会因为抢红包的先后顺序而造成不公平。 举例说明： 假设有5个人，红包总额100元。100÷5×2 = 40，所以第1个人抢到的金额随机范围是[0.01，39.99]元，在正常情况下，平均可以抢到20元。假设第1个人随机抢到了20元，那么剩余金额是80元。80÷4×2 = 40，所以第2个人抢到的金额的随机范围同样是[0.01，39.99]元，在正常的情况下，还是平均可以抢到20元。假设第2个人随机抢到了20元，那么剩余金额是60元。60÷3×2 = 40，所以第3个人抢到的金额的随机范围同样是[0.01，39.99]元，平均可以抢到20元。以此类推，每一次抢到金额随机范围的均值是相等的。 8.2 智力题 1. 厉害了我的杯 有一种玻璃杯质量确定但未知，需要检测。 有一栋100层的大楼，该种玻璃杯从某一层楼扔下，刚好会碎。 现给你两个杯子，问怎样检测出这个杯子的质量，即找到在哪一层楼刚好会碎？ 参考：https://cloud.tencent.com/developer/article/1497944 2. 赛马问题 64匹马，8个跑道，问最少比赛多少场，可以选出跑得最快的4匹马。 Assumptions：每场比赛每个跑道只允许一匹马，且不存在并列情形。 3. 三人三鬼过桥 有三个人跟三个鬼要过河,河上没桥只有条小船,然后船一次只能渡一个人和一个鬼,或者两个鬼或者两个人,无论在哪边岸上,只有是人比鬼少的情况下(如两鬼一人,三鬼两人,三鬼一人)人会被鬼吃,然而船又一定需要人或鬼操作才能航行(要有人或鬼划船),问,如何安全的把三人三鬼渡过河对岸? 参考回答 先两鬼过去。在一鬼回来。对面有一鬼。这边有三人两鬼。 再两鬼过去。在一鬼回来。对面有两鬼。这边有三人一鬼。 再两人过去。一人一鬼回来。对面一人一鬼。这边两人两鬼。 最后两人过去。一鬼回来。对面三人。这边三鬼。 剩下的就三个鬼二个过去一个回来在接另外个就OK了。 3. 给定随机函数，生成别的随机数 给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？ 由大的生成小的容易，比如由Rand7()生成Rand5()，所以我们先构造一个大于7的随机数生成函数。 记住下面这个式子： 1234// 生成1到N^2之间的随机数,可以看作是在数轴上撒豆子。N是跨度/步长，是RandN()生成的数的范围长度// RandN()-1的目的是生成0到N-1的数，是跳数。后面+RandN()的目的是填满中间的空隙Copy to clipboardErrorCopiedRandNN= N( RandN()-1 ) + RandN() ; 比如Rand25= 5( Rand5()-1 ) + Rand5()可以生成1到25之间的随机数。我们可以只要1到21（3*7）之间的数字，所以可以这么写 1234567int rand7()&#123; int x=INT_MAX; while(x&gt;21)&#123; x=5*(rand5()-1)+rand5(); &#125; return x%7+1;&#125;Copy to clipboardErrorCopied 4. 砝码称轻重，找出最轻的 其实这都是一类题，这里列举几个经典的： 1、有一个天平，九个砝码，其中一个砝码比另八个要轻一些，问至少要用天平称几次才能将轻的那个找出来？ 参考回答：至少2次。第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个； 第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个；至少称2次． 2、十组砝码每组十个，每个砝码都是10g重，但是现在其中有一组砝码每个都只有9g重，现有一个能显示克数的秤，最少称几次能找到轻的那组？ 参考回答：至少1次。 将砝码分组1~10，第一组拿一个，第二组拿两个以此类推。。第十组拿十个放到秤上称出克数x，则y = 550 - x，第y组就是轻的那组。 5. 利用空瓶换饮料，最多喝几瓶 1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶？ 第一种思路 拿走3瓶，换回1瓶，相当于减少2瓶。 但是最后剩下4瓶的时候例外，这时只能换1瓶。所以我们计算1000减2能减多少次，直到剩下4.（1000-4=996，996/2=498）所以1000减2能减498次直到剩下4瓶，最后剩下的4瓶还可以换一瓶，所以总共是1000+498+1=1499瓶。 第二种思路 1000瓶饮料，3个空瓶子能换1瓶饮料，最多可以喝几瓶？ 第一种思维：可以考虑成dp思路 初始情况，3个瓶子时将发生一次交换，因此视为特殊情况 之后每增加两个瓶子又可以再换一瓶 即dp[i] = dp[i - 2] + (i - (i - 2)) + 1 由dp[i - 2]可求得dp[i] (i - (i - 2))，即为当前增加的2瓶饮料（写成这样便于理解） 1即为增加了2个空瓶，之后又可以换一瓶饮料 简化为dp[i] = dp[i - 2] + 2 + 1 12345678910111213public int method(int n) &#123; // n为0/1/2的特殊情况省略了 // 定义dp数组 int[] dp = new int[n + 1]; // 初始状态 dp[0] = 0; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; dp[i] = dp[i - 2] + 2 + 1; &#125; return dp[n]; &#125;Copy to clipboardErrorCopied 回归正题 特殊情况：从上面的分析中，留下2个瓶子 剩下998个瓶子相当于每消耗2个瓶子即可获得一瓶，即为499瓶 最后剩下的2个瓶子无法再进行兑换，因此总共为1000 + 499 = 1499 第二种思维 因为兑换一瓶饮料需要三个空瓶，这瓶饮料如果是找老板借来的，那么喝完后这个空瓶将会还给他，同时需要附赠给他另外两个空瓶，即每消耗手里两个空瓶就获得一瓶饮料 但是值得注意的是，上面只是一种假设，实际情况老板是不会借给你的，因此我们至少需要保留2个空瓶，这样可以在998个瓶子剩下一个瓶子时，对其进行补足为3个空瓶，从而兑换一瓶新饮料 此时使用998个瓶子进行上述的兑换，将获得499瓶饮料 之前留下的两个瓶子正好无法兑换，最终获得饮料为1000 + 499 = 1499瓶 6. 毒药毒白鼠，找出哪个瓶子中是毒药 有1000个一模一样的瓶子，其中有999瓶是普通的水，有1瓶是毒药。任何喝下毒药的生命都会在一星期之后死亡。现在你只有10只小白鼠和1个星期的时间，如何检验出哪个瓶子有毒药？ 参考回答 将10只老鼠剁成馅儿，分到1000个瓶盖中，每个瓶盖倒入适量相应瓶子的液体，置于户外，并每天补充适量相应的液体，观察一周，看哪个瓶盖中的肉馅没有腐烂或生蛆。（你要是胆子够大就可以这么回答，是个狼人） 首先一共有1000瓶，2的10次方是1024，刚好大于1000，也就是说，1000瓶药品可以使用10位二进制数就可以表示。从第一个开始： 第一瓶 ： 00 0000 0001 第二瓶： 00 0000 0010 第三瓶： 00 0000 0011 …… 第999瓶： 11 1111 0010 第1000瓶： 11 1111 0011 需要十只老鼠，如果按顺序编号，ABCDEFGHIJ分别代表从低位到高位每一个位。 每只老鼠对应一个二进制位，如果该位上的数字为1，则给老鼠喝瓶里的药。 观察，若死亡的老鼠编号为：ACFGJ，一共死去五只老鼠，则对应的编号为 10 0110 0101，则有毒的药品为该编号的药品，转为十进制数为：613号。（这才是正解，当然前提是老鼠还没被撑死） 类似问题：8瓶酒一瓶有毒，用小老鼠测试。每次测试结果8小时后才会得出，而你只有8个小时的时间。最少需要（ ）老鼠测试？ A 、2 B、3 C、4 D、6 解析：用3位2进制代表8瓶酒，如下表所示 瓶序号 二进制 中毒情况 第一瓶 000 全没中毒 第二瓶 001 只有第一个老鼠中毒 第三瓶 010 只有第二个老鼠中毒 第四瓶 011 第一个老鼠、第三个老鼠同时中毒 第五瓶 100 只有第三个老鼠中毒 第六瓶 101 第一个老鼠、第三个老鼠同时中毒 第七瓶 110 第二个老鼠、第三个老鼠同时中毒 第八瓶 111 三个老鼠同时中毒 其中，第一个老鼠喝下最低位为1对应的酒，第二个老鼠喝下中间位为1对应的酒，第三个老鼠喝下最高位为1对应的酒。 最后将所有中毒的老鼠，对应的位次进行与操作即可以知道那瓶毒药有毒了。 7. 利用烧绳子计算时间 现有若干不均匀的绳子，烧完这根绳子需要一个小时，问如何准确计时15分钟，30分钟，45分钟，75分钟。。。 计算15分钟：对折之后两头烧(要求对折之后绑的够紧，否则看45分钟解法) 计算30分钟：两头烧 计算45分钟：两根，一根两头烧一根一头烧，两头烧完过了30分钟，立即将第二根另一头点燃，到烧完又过15分钟，加起来45分钟 计算75分钟：将30和45分钟的方式加起来就可以了 其余类似 8. 在24小时里面时针分针秒针可以重合几次 24小时中时针走2圈，而分针走24圈，时针和分针重合24-2=22次，而只要时针和分针重合，秒针一定有机会重合，所以总共重合22次。 9. 100个奴隶猜帽子颜色 一百个奴隶站成一纵列，每人头上随机带上黑色或白色的帽子，各人不知道自己帽子的颜色，但是能看见自己前面所有人帽子的颜色． 然后从最后一个奴隶开始，每人只能用同一种声调和音量说一个字：”黑”或”白”， 如果说中了自己帽子的颜色，就存活，说错了就拉出去斩了，说的参考回答所有奴隶都能听见。 是否说对，其他奴隶不知道。 在这之前，所有奴隶可以聚在一起商量策略，问如果奴隶都足够聪明而且反应足够快，100个人最大存活率是多少？ 参考回答：这是一道经典推理题 最后一个人如果看到奇数顶黑帽子报“黑”否则报“白”，他可能死 其他人记住这个值（实际是黑帽奇偶数），在此之后当再听到黑时，黑帽数量减一 从倒数第二人开始，就有两个信息：记住的值与看到的值，相同报“白”，不同报“黑” 99人能100%存活，1人50%能活 变种：每个奴隶只能看见前面一个人帽子颜色又能最多存活多少人？ 增加限制条件后，上面的方法就失效了，此时只能约定偶数位奴隶说他前一个人的帽子颜色，奇数奴隶获取信息100%存活，偶数奴隶50几率存活。 10. 小猴子搬香蕉 一个小猴子边上有100根香蕉，它要走过50米才能到家，每次它最多搬50根香蕉，（多了就被压死了），它每走 1米就要吃掉一根，请问它最多能把多少根香蕉搬到家里？ （提示：他可以把香蕉放下往返的走，但是必须保证它每走一米都能有香蕉吃。也可以走到n米时，放下一些香蕉，拿着n根香蕉走回去重新搬50根。） 这种试题通常有一个迷惑点，让人看不懂题目的意图。此题迷惑点在于：走一米吃一根香蕉，一共走50米，那不是把50根香蕉吃完了吗？如果要回去搬另外50根香蕉，则往回走的时候也要吃香蕉，这样每走一米需要吃掉三根香蕉，走50米岂不是需要150根香蕉？ 其实不然，本题关键点在于：猴子搬箱子的过程其实分为两个阶段，第一阶段：来回搬，当香蕉数目大于50根时，猴子每搬一米需要吃掉三根香蕉。第二阶段：香蕉数&lt;=50，直接搬回去。每走一米吃掉1根。 第一阶段：假如把100根香蕉分为两箱，一箱50根 第一步，把A箱搬一米，吃一根。 第二步，往回走一米，吃一根。 第三步，把B箱搬一米，吃一根。 这样，把所有香蕉搬走一米需要吃掉三根香蕉。这样走到第几米的时候，香蕉数刚好小于50呢？ 100−(n∗3)&lt;50&amp;&amp;100−(n−1∗3)&gt;50100-(n*3)&lt;50 \\&amp;\\&amp; 100-(n-1*3)&gt;50 100−(n∗3)&lt;50&amp;&amp;100−(n−1∗3)&gt;50 走到16米的时候，吃掉48根香蕉，剩52根香蕉。这步很有意思，它可以直接搬50往前走，也可以再来回搬一次，但结果都是一样的。 到17米的时候，猴子还有49根香蕉。这时猴子就轻松啦，直接背着走就行。 第二阶段：走一米吃一根 把剩下的50-17=33米走完。还剩49-33=16根香蕉。 11. N只蚂蚁走树枝，问总距离或者总时间 问题：放N只蚂蚁在一条长度为M树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间为多少？ 这个其实就一个诀窍：蚂蚁相碰就往反方向走，可以直接看做没有发生任何事：大家都相当于独立的 A蚂蚁与B蚂蚁相碰后你可以看做没有发生这次碰撞，这样无论是求时间还是距离都很简单了。 12. N个强盗分配M个金币，求方案使得自己分配最多 5个海盗抢到了100枚金币，每一颗都一样的大小和价值。 他们决定这么分： 抽签决定自己的号码（1，2，3，4，5） 首先，由1号提出分配方案，然后大家5人进行表决，当 半数以上的人同意时（ 不包括半数，这是重点），按照他的提案进行分配，否则将被扔入大海喂鲨鱼。 如果1号死后，再由2号提出分配方案，然后大家4人进行表决，当且仅当半超过半数的人同意时，按照他的提案进行分配，否则将被扔入大海喂鲨鱼。 依次类推… 假设每一位海盗都足够聪明，并且利益至上，能多分一枚金币绝不少分，那么1号海盗该怎么分金币才能使自己分到最多的金币呢？ 从后向前推，如果1至3号强盗都喂了鲨鱼，只剩4号和5号的话，5号一定投反对票让4号喂鲨鱼，以独吞全部金币。所以，4号惟有支持3号才能保命。 3号知道这一点，就会提出“100，0，0”的分配方案，对4号、5号一毛不拔而将全部金币归为已有，因为他知道4号一无所获但还是会投赞成票，再加上自己一票，他的方案即可通过。 不过，2号推知3号的方案，就会提出“98，0，1，1”的方案，即放弃3号，而给予4号和5号各一枚金币。由于该方案对于4号和5号来说比在3号分配时更为有利，他们将支持他而不希望他出局而由3号来分配。这样，2号将拿走98枚金币。 同样，2号的方案也会被1号所洞悉，1号并将提出（97，0，1，2，0）或（97，0，1，0，2）的方案，即放弃2号，而给3号一枚金币，同时给4号（或5号）2枚金币。由于1号的这一方案对于3号和4号（或5号）来说，相比2号分配时更优，他们将投1号的赞成票，再加上1号自己的票，1号的方案可获通过，97枚金币可轻松落入囊中。这无疑是1号能够获取最大收益的方案了！ 1号强盗分给3号1枚金币，分给4号或5号强盗2枚，自己独得97枚。分配方案可写成（97，0，1，2，0）或（97，0，1，0，2）。 变种：就是只需要一半人同意即可，不需要一半人以上同意方案就可以通过，在其他条件不变的情况下，1号该怎么分配才能获得最多的金币？ 4号：4号提出的方案的时候肯定是最终方案，因为不管5号同意不同意都能通过，所以4号5号不必担心自己被投入大海。那此时5号获得的金币为0，4号获得的金币为100。 5号：因为4号提方案的时候 ，自己获取的金币为0 。所以只要4号之前的人分配给自己的金币大于0就同意该方案。 4号：如果3号提的方案一定能获得通过（原因：3号给5号的金币大于0， 5号就同意 因此就能通过），那自己获得的金币就为0，所以只要2号让自己获得的金币大于0就会同意。 3号：因为到了自己提方案的时候可以给5号一金币，自己的方案就能通过，但考虑到2号提方案的时候给4号一个金币，2号的方案就会通过，那自己获得的金币就为0。所以只要1号让自己获得的金币大于0就会同意。 2号：因为到了自己提方案的时候只要给4号一金币，就能获得通过，根本就不用顾及3 号 5号同意不同意，所以不管1号怎么提都不会同意。 1号：2号肯定不会同意。但只要给3号一块金币，5号一块金币（因为5号如果不同意，那么4号分配的时候，他什么都拿不到）就能获得通过。 所以参考回答是： 98，0，1，0，1。 14. 火枪手决斗，谁活下来的概率大？ 问题：彼此痛恨的甲、乙、丙三个枪手准备决斗。甲枪法最好，十发八中；乙枪法次之，十发六中；丙枪法最差，十发四中。如果三人同时开枪，并且每人每轮只发一枪；那么枪战后，谁活下来的机会大一些？ 一般人认为甲的枪法好，活下来的可能性大一些。但合乎推理的结论是，枪法最糟糕的丙活下来的几率最大。 那么我们先来分析一下各个枪手的策略。 如同田忌赛马一般，枪手甲一定要对枪手乙先。因为乙对甲的威胁要比丙对甲的威胁更大，甲应该首先干掉乙，这是甲的最佳策略。 同样的道理，枪手乙的最佳策略是第一枪瞄准甲。乙一旦将甲干掉，乙和丙进行对决，乙胜算的概率自然大很多。 枪手丙的最佳策略也是先对甲。乙的枪法毕竟比甲差一些，丙先把甲干掉再与乙进行对决，丙的存活概率还是要高一些。 我们根据分析来计算一下三个枪手在上述情况下的存活几率： 第一轮：甲射乙，乙射甲，丙射甲。 甲的活率为24%（40% X 60%） 乙的活率为20%(100% - 80%) 丙的活率为100%（无人射丙） 由于丙100％存活率，因此根据上轮甲乙存活的情况来计算三人第二轮的存活几率： 情况1：甲活乙死（24% X 80% = 19.2%） 甲射丙，丙射甲：甲的活率为60%，丙的活率为20%。 情况2：乙活甲死（20% X 76% = 15.2%） 乙射丙，丙射乙：乙的活率为60%，丙的活率为40%。 情况3：甲乙同活（24% X 20% = 4.8%） 重复第一轮。 情况4：甲乙同死（76% X 80% = 60.8%） 枪战结束。 据此来计算三人活率： 甲的活率为(19.2% X 60%) + (4.8% X 24%) = 12.672% 乙的活率为(15.2% X 60%) + (4.8% X 20%) = 10.08% 丙的活率为(19.2% X 20%) + (15.2% X 40%) + (4.8% X 100%) + (60.8% X 100%) = 75.52% 通过对两轮枪战的详细概率计算，我们发现枪法最差的丙存活的几率最大，枪法较好的甲和乙的存活几率却远低于丙的存活几率。 15. 先手必胜的问题 100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿？ 寻找每个回合固定的拿取模式，最后一次是我拿，那么上个回合最少剩下6本。那么只要保持每个回合结束后都剩下6的倍数，并且在这个回合中我拿的和对方拿的加起来为6（这样这个回合结束后剩下的还是6的倍数），就必胜。 关键是第一次我必须先手拿（100%6=4）本（这不算在第一回合里面）。 16. 掰巧克力问题或者参加辩论赛 1、掰巧克力问题 NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？ 2、1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛？ 每次拿起一块巧克力，掰一下（无论横着还是竖着）都会变成两块，因为所有的巧克力共有NM块，所以要掰NM-1次，-1是因为最开始的一块是不用算进去的。 每一场辩论赛参加两个人，消失一个人，所以可以看作是每一场辩论赛减少一个人，直到最后剩下1个人，所以是1000-1=999场。","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"场景题","slug":"场景题","permalink":"https://hwh.zone/tags/%E5%9C%BA%E6%99%AF%E9%A2%98/"},{"name":"智力题","slug":"智力题","permalink":"https://hwh.zone/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/"}]},{"title":"校招笔记（七）_计算机基础_数据结构","slug":"校招笔记（七）_计算机基础_数据结构","date":"2021-11-26T13:20:04.945Z","updated":"2021-12-03T03:55:43.335Z","comments":true,"path":"p/61434/","link":"","permalink":"https://hwh.zone/p/61434/","excerpt":"","text":"我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。 备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 七、数据结构和算法 1. 如何对快排进行优化？ 三数取中法和随机交换法 快排将选取的基准点经过调整放到合适的位置，之后将这个基准点左右两边的区间分别递归的进行快排。 如果基准点的数据比较小，将会导致调整后基准点处于靠近两侧的位置，那么两边的区间长度将会严重失去平衡. 三数取中法：指的是选取基准点之前我们可以拿出数列中间位置元素的值，将它和首尾的元素进行比较，之后将这三个数中的中间数交换到数列首位的位置，之后将这个数作为基准点，尽量减小之后的分区后左右两边的区间长度之差。 三路分割法 三路法同样是针对含有大量【重复数列】的优化。 3路法的思想是将数列分成3个区间，分别是小于、等于和大于基准点的区间。那么分区之后，对于等于基准点的区间内的元素，我们就不需要对其做任何处理了，只需要递归的处理小于和大于基准点的元素即可。 结合插入排序 当待排序序列的长度分割到一定大小后，使用插入排序。 对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排。 2.快排和堆排的区别？什么时候使用快排和堆排？ 快排和堆排区别？ 综合性能：实际应用中，虽然堆排序的时间复杂度要比快速排序稳定（快排最差退化成O(N^2)） ，但是统计意义上这种情况较少，所以综合性能还是快排更优； 交换次数： 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序； 访问友好： 堆排序数据访问的方式没有快速排序友好。 对于快速排序来说，数据是顺序访问的；而堆排序来说，数据是跳着访问的。比如，堆排序中，最重要的一个操作就是数据的堆化。对堆顶节点进行堆化，会一次访问数组下标1，2，4，8的元素，而不是像快排那样，局部顺序访问，所以对CPU缓存是不友好的。 快排和堆排使用场景？ 快排： 绝大多数场合。 堆排： topK问题、优先队列（需要在一组不停更新的数据中不停地找最大/小元素） 在N个元素中找到top K，时间复杂度是O(N log K)，空间复杂的是O(K)，而快速排序的空间复杂度是O(N)。 3. 【面试重点】有哪些排序算法，各算法的时间复杂度 ? 哪些是稳定的？为什么是稳定的？ 3.1 如果数据大致有序的，用什么排序比较好？ 如果是大致有序，用 插入排序 比较好： 直接插入排序是将第i个元素插入到已经排序好的前i-1个元素中 ，当元素基本有序时。和前i-1个元素末尾比较一次就可以直接插入。 在相比使用其它排序： 归并排序： 归并排序和数组是否有序无关，都是O(nlgn)。 归并排序是把一个有n个记录的无序文件看成由n个长度为1的有序子文件组成的文件，然后进行两两归并，得到[n/2]个长度为2或1的有序文件，再两两归并 。 快速排序： 数组基本有序时，此时如果使用基点是最后一个元素，划分的两个子数组极为不平衡，每次划分比较次数都很多。所以不推荐。 4. 二叉查找树，红黑树和平衡二叉树的区别？（有了二叉查找树、平衡树（AVL）为啥还需要红黑树？） 总结来说：平衡树是为了解决二叉查找树退化为链表的情况；而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。 二叉查找树退化成单链表 正常使用二叉查找树是类似于二分查找 O（logn），但是极端情况： 构建的二叉树所有节点都只有右子树或左子树，此时时间复杂度退化成O(N) 平衡二叉树频繁左右旋 平衡二叉树就是为了解决二叉查找树退化成一颗链表而诞生了，平衡树具有如下特点： 具有二叉查找树的全部特性； 每个节点的左子树和右子树的高度差至多等于1。 避免了二叉查找树极端情况产生，但是： 每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。 平衡树性能大打折扣。 红黑树规不需要频繁着调整 红黑树具有如下特点： 最坏情况下，也能在 O(logn) 的时间复杂度查找到某个节点。 与平衡树不同的是，红黑树在插入、删除等操作，（🚩*1）不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整，这也是我们为什么大多数情况下使用红黑树的原因； 但是，单单在查找方面的效率的话，平衡树比红黑树快。 具有二叉查找树的特点； 根节点是黑色的； 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据； 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的； 每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。 4.1 为什么红黑树不需要频繁调整？ 详细理解红黑树一篇不错的文章：百图详解红黑树，想不理解都难 平衡二叉树这种高度差为 1 的要求太严格了，尤其是对于频繁删除、插入的场景非常浪费时间。 但是由于红黑树： 具有二叉树所有特点。 每个节点只能是红色或者是黑色。 根节点只能是黑色，且黑色根节点不存储数据。 任何相邻的节点都不能同时为红色。 红色的节点，它的子节点只能是黑色。 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 不追求插入、删除等操作绝对平衡，只需满足上述条件即可。它的旋转次数少，插入最多两次旋转，删除最多三次旋转。 所以在搜索、插入、删除操作较多的情况下，红黑树的效率是优于平衡二叉树的。 5.快速排序的过程 ？ 手撕一个二分查找 和快排？ 二分查找 12345678910111213141516171819202122232425// binary search public int binarySearch(int[] arr, int value) &#123; int left = 0,right = arr.length-1; int mid ; while (left&lt;=right) //*&lt;= 而不是&lt; &#123; mid = (left+right)/2; if(value == arr[mid]) &#123; return mid; // 如果数组存在待查找元素，按照逻辑一定会是mid &#125; else if(value &lt; arr[mid]) &#123; right = mid-1; &#125; else // value &gt; arr[mid] &#123; left = mid+1; &#125; &#125; return -1; &#125; 快速排序 123456789101112131415161718192021222324252627public int[] quick_sort(int[] arr,int left,int right) &#123; if(right&lt;=left)&#123;return null;&#125; // 选择基准：数组最右数字 // *如果选择最左，思考交换过程 // *partition 左侧始终是比pivot小的数 int pivot = arr[right]; int partition = left; // 遍历分区元素 // 小于基准的放基准左边，大于的放基准右边 // * 终止条件：i &lt; right 而非 right-1！ for(int i=left; i&lt; right;i++) &#123; if(arr[i]&lt;pivot) // 实际只交换小于到左边即可 &#123; swap(arr,i,partition); partition++; &#125; &#125; // *基准插入位置partition位置 swap(arr,partition,right); //递归的排序 quick_sort(arr,left,partition-1); quick_sort(arr,partition+1,right); return arr; &#125; 6. 布隆过滤器原理？为什么使用多个哈希函数？其它相关应用？ 参考：详解布隆过滤器的原理，使用场景和注意事项 “布隆说：不存在的那么一定不存在” “布隆说：存在的那么只是可能存在” 7.1 从HashMap说起—当你判断某个元素时候你在想什么？ 通常我们怎么判断一个数组，是否存在某个元素呢？ 聪明的你一定想到HashMap：（1）HashMap将数组所有元素使用哈希函数，映射到HashMap上（HashMap本身也是一个数组）（2）然后就可以在O(1)级别判断某个元素是否存在。 但是这种做法通常会导致以下问题： 一旦数组很大，比如上亿，HashMap将会占据非常大的内存； 数组很大，不大可能一次性能在内存构建HashMap； 而且HashMap，通常存在负载因子，是不能充分利用内存的。 为此，我们可以从以下方向优化： 只存储key。但是，因为我们只要判断某个元素（key）是否存在， 不需要取出对应key的value—也就是不需要存储value。 key映射为bit数组索引。key映射为bit数组索引，即位图对应索引， 索引对应数值用 0/1 就可以标识为是否存在该key。 为此，我们可以【第一阶段优化】如下： 看样子似乎是满足我们要求了，但是依旧存在以下问题： 只使用一个hash函数，空间利用率低。 一个hash函数只能将key散列到一个位置 ，虽然hash尽量优良映射均匀，但是空间利用率依然不算高。 因此，我们可以多个函数，将key同时映射到多个位置，即使发生哈希冲突，某个位置被覆盖，其它依旧存在，变相的降低了哈希冲突。 7.2 数据结构及原理 布隆过滤器，最终结构如下：一个bit数组，采用多个hash函数进行映射。 7.3 布隆函数优缺点 优点 存储/插入/查询时间复杂度，都是常数级别O(1) 保密性好，因为不需要存储数据本身 存储数据大，可以存储非常大的数据本身 缺点 随着元素数量增加，误算率会增加 不能删除元素，因为删除某个元素，要把其对应所有hash函数散列的位置如A,B，置为0 。其它元素的可能散列到位置A，再去判断这个元素是否存在就会出现误判。 7.4 应用场景 解决缓存穿透，防止不存在的元素去查询数据库 防止重复被攻击，用户第一次请求，将请求参数放入布隆过滤器中，当第二次请求时，先判断请求参数是否被布隆过滤器命中。可以提高缓存命中率 判断用户是否阅读过某视频或文章， 比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"数据结构","permalink":"https://hwh.zone/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"校招笔记（六）_计算机基础_Redis","slug":"校招笔记（六）_计算机基础_Redis","date":"2021-11-26T13:16:21.848Z","updated":"2021-12-03T03:55:32.600Z","comments":true,"path":"p/31215/","link":"","permalink":"https://hwh.zone/p/31215/","excerpt":"","text":"我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。 备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 六、Redis 6.1 Redis基本 1.什么是 Redis？ Redis 是一个开源（BSD 许可）、基于内存（读写快）、支持多种数据结构的存储系统，可以作为数据库、缓存和消息中间件。 支持的数据结构有5种：字符串（String）、哈希（hash）、列表（list）、集合（set）、有序集合（sorted set）。 1.1 有MySQL不就够用了吗？为什么要用Redis这种新的数据库？ 主要是因为 Redis 具备高性能和高并发两种特性。 高性能：除了第一次读取硬盘比较慢，后面加载到缓存，读取速度都相关快，性能高； 高并发：直接操作缓存能够承受的并发请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分热点数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。 1.2 C++ / JAVA 中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？ 缓存分为本地缓存和分布式缓存 。 本地缓存不具一致性。以Java为例 ，使用自带的map或者guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性； Redis分布式缓存具有一致性。 使用redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性； Redis可以使用更大内存作为缓存。 Redis可以使用几十G内存作为缓存，Map不行，比如JVM最多使用几个G ； Redis可以持久化。 Redis可以实现持久化，而Map是内存对象，程序重启就没了； Redis可以处理百万级别并发； Redis有丰富的API &amp; 缓存过期等机制。 2. 【重点】redis的数据类型，以及每种数据类型的使用场景？ 数据类型 使用场景 String 存储key-value键值对，注意redis中String可修改。统计在线人数；也可以存储视频、图片等 hash 购物车：hset [key] [field] [value] 命令， 存放键值对，一般可以用来存某个对象的基本属性信息，例如，用户信息，商品信息等 set 全局去重，JVM自带的set不适合分布式集群情况 zset 排行榜，比如微信运动排行榜 list 分页功能，lrange做基于redis的分页功能，性能很好；模仿一个消息队列 3.说一下 Redis有什么优点和缺点 ？ 优点 缺点 速度快：因为在内存中 存储有限：因为Redis是内存数据库，大小和机器本身内存有关 支持多种数据结构： String，List，Set，Hash，Sorted Set等 完成重同步耗费CPU资源和带宽 持久化存储：RDB和AOF 当Redis重启后通过把硬盘文件重新加载到内存，速度比较慢，这个时候redis做不了其它事。 高可用：内置 Redis Sentinel （哨兵），实现主从故障自动转移。 内置 Redis Cluster ，提供集群方案。 丰富特性：Key过期、计数、分布式锁 4. Redis的数据结构？key是怎么存储的？ 参考：【大课堂】Redis底层数据存储原理 概述 Redis底层采用数组， key就是对应数组的索引 ，采用Hash(key)映射到数组上。解决冲突采用链地址法。 具体可看参考下文。 底层存储原理 redis 中以redisDb作为整个缓存存储的核心，保存着我们客户端需要的缓存数据。 其结构如下： 123456789typedef struct redisDb &#123; dict *dict; // 最重要--字典类型，保存数据库的键值对 dict *expires; // 重要--字典类型，保存过期的时间 dict *blocking_keys; // 和ready_key 实现BLPOP等阻塞命令 dict *ready_keys; // 同上 dict *watched_keys; // 实现watch命令，记录正在被watch的key int id; // 数据库id，默认16个，支持单个 long long avg_ttl; /* Average TTL, just for stats */ &#125; redisDb; 现在我们来查看，dict 的结构。 dict的结构 12345678910/* 字典 : 每个字典使用两个哈希表，用于实现渐进式 rehash */typedef struct dict &#123; // type存储了hash函数，key和value的复制函数等，比较以及销毁函数 dictType *type; // privdata保存一些私有数据，决定了*type保存的函数，实现了【多态】 void *privdata; dictht ht[2]; // 哈希表（2 个）, 正常使用ht[0],rehash就会扩容使用ht[1] int rehashidx; // 记录 rehash 进度的标志，值为 -1 表示 rehash 未进 int iterators; // 当前正在运作的安全迭代器数量&#125; dict; 上述dictht就是个hash表，包含： 12345678910typedef struct dictht &#123; // 哈希表节点指针数组（俗称桶，bucket） dictEntry **table; // 指针数组的大小 unsigned long size; // 指针数组的长度掩码，用于计算索引值，其实永远都是size-1 unsigned long sizemask; // 哈希表现有的节点数量 unsigned long used;&#125; dictht; dictEntry 指针数组（table）。key 的哈希值最终映射到这个数组的某个位置上（对应一个 bucket）。如果多个 key 映射到同一个位置，就发生了冲突，那么就拉出一个 dictEntry 链表。 12345678910// 哈希表节点dictEntrytypedef struct dictEntry &#123; void *key; // redis的键 union &#123; void *val; // 存储了对应string/set/list/hash/zset的数据 uint64_t u64; int64_t s64; &#125; v; struct dictEntry *next; //链表后续节点&#125;dictEntry; size：标识 dictEntry 指针数组的长度。它总是 2 的指数次幂。 上面dictEntry 的value 最终指向了redisObject对象，我们来观察下其结构。 Redis Object 1234567typedef struct redisObject &#123; unsigned type:4; // 类型 ，比如string，set等，才能确定是哪种数据结构使用什么API操作 unsigned encoding:4; // encoding 表示 ptr 指向的具体数据结构,这个对象使用什么数据结构实现 unsigned lru:REDIS_LRU_BITS; // 对象最后一次被访问的时 int refcount; // 引用计数 void *ptr; // 指向底层数据结构的指针 robj; 4.1 String、list、hash、set、zset的底层结构是什么？ 参考：图解redis五种数据结构底层实现(动图哦) 版本：redis 3.0.6中版本各种数据结构的实现 String embstr和raw都是由SDS动态字符串构成的 ，底层结构应该都是char数组吧 ； int ，就是指int类型。 list hash set intset是集合键的底层实现方式之一，是int类型数组。 zest 4.2 讲讲redis的hash表扩容方式？ 参考：[redis学习笔记]redis渐进式rehash机制 扩容条件 服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 （保存的key超过哈希表大小）； 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ； 渐进式rehash 新建一个哈希表大小，为2^N 次方，并分配内存，此时字典同时持有：ht[0] 和 ht[1] 两个哈希表 同hashmap：哈希表掩码sizemask为size-1，当size满足2的n次方时，计算每个key的索引值时只需要用key的hash值与掩码sizemask进行位与操作，替代求余操作，计算更快。 哈希表赋值给字典的ht[1]，然后将rehashidx赋值为0，表示rehash工作开始 rehashidx也标识了，当前rehash进行到了哪个槽 在 rehash 进行期间，：每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] 。 当 rehash 工作完成之后， 程序将 rehashidx 属性的值**+1** 随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] 。此时rehashidx=-1，表示rehash完成。 采取分而治之的方式， 将 rehash 键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。 渐进式rehas优缺点 优点：避免redis阻塞 缺点：rehash需要分配一个新的hash表，会使得内存爆增，使得大量key被驱逐 4.3 rehash过程中增删查改怎么操作呢？ 增加： 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作 删除（delete）、查找（find）、更新（update）等： 同时在ht[0] &amp; ht[1]两个表进行。 比如：要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找。 5. 说说Redis有序集合zset的底层结构？ zset底层的存储结构包括ziplist或 skiplist &amp; dic ，当满足以下两个条件的时候使用ziplist： 有序集合保存的元素数量小于128个 有序集合保存的所有元素的长度小于64字节 其余情况用skiplist。 什么是ziplist？ ziplist是一个经过特殊编码的双向链表，以O(1)的时间复杂度在表的两端提供push和pop操作。 ziplist将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。 使用原因：一个普通的双向链表，链表中每一项都占用独立的一块内存，各项之间用地址指针（或引用）连接起来；这种方式会带来大量的内存碎片，而且地址指针也会占用额外的内存。 具体结构 entry：表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构。 什么是skiplist ? 跳表是在单链表上实现多级索引，可以实现 二分查找 的有序链表。 跳表插入、删除、查找元素的时间复杂度跟红黑树都是一样量级的，时间复杂度都是O(logn)。 主要形式 在单链表上进行多级索引。 构建过程 上面链表是如何构建的呢，请见下图。 ⚠️ skiplist为了避免上下两层出现严格1:2数量对应关系后，新插入节点会打乱这种关系，而需要把新插入节点后所以节点都进行调整。 它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。 查找过程 zset : &lt;key&gt; &lt;score&gt; &lt;member&gt; 在上图中，我们没有区分member和score，但是实际上链表是按score进行排序，查找也是在比较score。 以查找 和 插入23为例。 从最高层（第4）层开始查找，因为7&lt;23 ,本应该继续往后查找，但是后继节点为null，所以往下一层进行查找 此时第3层，满足7&lt;23&lt;37 ，继续往下一层继续查找 此时第2层，7&lt;23 &amp; 19&lt;23 ，往下第二层的下一个节点（19）查找；此时满足19&lt;23&lt;37 ，继续往下一层 此时第1层，一直往后遍历到22，发现22&lt;23&lt;26 ： 如果此时是查询23：返回null，不存在 此时是插入23：生成新节点 &amp; 随机生成层数，（1）将新节点各层指针指向对应层的下一个节点（不存在则指向null）（2）将新节点节点各层前一个节点对应层数的指针指向新节点 5.1 Redis为什么不用红黑树 参考 ： 知乎回答 虽然跳表操作时间复杂度和红黑树相同 ，但是： 实现简单：跳表代码实现更易读 区间查找：跳表区间查找效率更高 6. Redis持久化方式有哪些？以及有什么区别？ Redis 提供两种持久化机制 RDB 和 AOF 机制。 各自优点 RDB AOF 【方便】只有一个文件 dump.rdb ，方便持久化 【数据安全】 AOF 持久化有 always，每进行一次命令操作就记录到 AOF 文件中一次。 【容灾性好】一个文件可以保存到安全的磁盘 【性能】最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化 【启动效率高】相对于数据集大时，比 AOF 的启动效率更高 各自缺点 RDB AOF 【安全性低】 RDB 是间隔一段时间进行持久化 【启动效率低】数据集大的时候，比 RDB 启动效率低。 【恢复慢】AOF 文件比 RDB 文件大，且恢复速度慢。 6.1 AOF 重写了解吗？ AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。 AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任伺读入、分析或者写入操作。 具体过程如下： 在执行 BGREWRITEAOF 命令，开始重写； Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令； 当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾 ； 最后，服务器用新的AOF文件替换旧的 AOF文件，以此来完成AOF文件重写操作。 7. Redis持久化有两种，那应该怎么选择呢？ 参考：https://zhuanlan.zhihu.com/p/39412293 如果Redis中的数据完全丢弃也没有关系（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化； 单机环境： 如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF； 主从架构： master：完全关闭持久化（包括RDB和AOF），这样可以让master的性能达到最好； slave：关闭RDB，开启AOF（如果对数据安全要求不高，开启RDB关闭AOF也可以），并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；然后关闭AOF的自动重写，然后添加定时任务，在每天Redis闲时（如凌晨12点）调bgrewriteaof。 8. （不太理解）pipeline有什么好处，为什么要用 pipeline？ 使用 pipeline（管道）的好处在于可以将多次 I/O 往返的时间缩短为一次，但是要求管道中执行的指令间没有因果关系； 用 pipeline 的原因在于可以实现请求/响应服务器的功能，当客户端尚未读取旧响应时，它也可以处理新的请求。如果客户端存在多个命令发送到服务器时，那么客户端无需等待服务端的每次响应才能执行下个命令，只需最后一步从服务端读取回复即可。 9.怎么使用 Redis实现消息队列？ 如何实现延时队列？ 消息队列：一般使用 list 结构作为队列， rpush 生产消息， lpop 消费消息。当 lpop 没有消息的时候，要适当sleep 一会再重试； 延时队列： ：使用sortedset ，拿时间戳作为 score ，消息内容作为 key 调用 zadd 来生产消息，消费者用zrangebyscore 指令获取符合条件的数据轮询进行处理。 什么是延时队列？ 当用户发送一个消息请求给服务器后台的时候，服务器会检测这条消息是否需要进行延时处理： 如果需要就放入到延时队列中，由延时任务检测器进行检测和处理； 如果不需要进行延时处理的任务，服务器会立马对消息进行处理，并把处理后的结果返会给用户。 【举个例子】 点外卖时，下单后不会立即安排配送，而是等待一段时间让商户接单才正式安排配送，否则超时取消 6.2 Redis单线程模型 1.为什么 Redis 使用单线程模型？单线程模型效率也能那么高？ 采用单线程，避免了不要的上下文切换和竞争条件； 其次 CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。 【效率高的原因】 . 1. C语言实现，效率高 纯内存操作 基于非阻塞的IO复用模型机制（可能会跟自己挖坑） 单线程的话就能避免多线程的频繁上下文切换问题（为什么单线程效率高） 丰富的数据结构（全程采用hash结构，读取速度非常快，对数据存储进行了一些优化，比如zset压缩表，跳表等） 2.（新，易忘）说说 Redis 的单线程模型 ？ 这问题是因为前面回答问题的时候提到了 Redis 是基于非阻塞的IO复用模型。如果这个问题回答不上来，就相当于前面的回答是给自己挖坑了。 redis 内部使⽤⽂件事件处理器 file event handler ，这个⽂件事件处理器是单线程的，所以redis 才叫做单线程的模型。它采⽤ IO 多路复⽤机制一个线程同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进⾏处理。 ⽂件事件处理器的结构包含 4 个部分： 多个 socket IO 多路复⽤程序 ⽂件事件分派器 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器） （1） IO 多路复⽤程序会监听多个 socket，（2）会将 socket 产⽣的事件放⼊队列中排队，（3）事件分派器每次从队列中取出⼀个事件，（4）把该事件交给对应的事件处理器进⾏处理。 3. 你说Redis是单线程的，那如何处理高并发？比如1000个并发请求同时发生？ Redis采用了IO多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求。 详见上一个问题。 Redis可以采用主从架构，master负责写，slave负责读。 4.说说你对Redis事务的理解 ？ Redis 中的事务是一组命令的集合，是 Redis 的最小执行单位。 Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的 Redis会将一个事务中的所有命令序列化，然后按顺序执行。 需要注意的地方 Redis 事务不支持回滚：不像 MySQL 的事务一样，要么都执行要么都不执行； 因为回滚需要增加很多工作，而不支持回滚则可以保持简单、快速的特性。 Redis 服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断，直到事务命令全部执行完毕才会执行其他客户端的命令。 5.为什么Redis的操作是原子性的，怎么保证原子性的？ 原子性。 因为Redis是单线程的， Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。 事务性。 Redis中的事务其实是要保证批量操作的原子性。 6.3 Redis缓存 1.为什么要用缓存 ？怎么提高缓存命中率？ 为什么用缓存？ 把热点数据存入内存中，提高读写性能。 提高命中率？ 增加缓存空间 提升缓存更新频率 提前加载数据到缓存中 2.缓存雪崩、缓存穿透、缓存击透、缓存预热、缓存更新、缓存降级等？ 参考：https://juejin.cn/post/6844904173725548557 缓存雪崩 简而言之：Redis 挂掉了，请求全部走数据库 。 例如： 对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库； key过期解决： 在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。 更通用情况的做法： 事发前：实现 Redis 的高可用 (主从架构 + Redis Cluster)，尽量避免 Redis 挂掉这种情况发生； 事发中：万一 Redis 真的挂了，我们可以设置本地缓存 (ehcache)+ 限流 (hystrix)，尽量避免我们的数据库被干掉； 事发后：redis 持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。 缓存穿透 查询一个一定不存在的数据 ，导致每次请求都要到数据库去查询，失去了缓存的意义 。 解决1： 使用布隆过滤器 (BloomFilter) 提前拦截，不合法就不让这个请求到数据库层； 解决2：当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去，下次再请求的时候，就可以从缓存里边获取了。 缓存击穿 在平常高并发的系统中，大量的请求同时查询一个key时，此时这个高热key正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为缓存击穿。 解决1：使用互斥锁(mutex key)。 是只让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据就行。 如果是单机，可以用synchronized或者lock来处理，如果是【淘特】分布式环境可以用分布式锁就可以了。 解决2： key永不过期。 把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建。 缓存预热 系统上线后，将相关的缓存数据直接加载到缓存系统。 这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。 缓存更新 LRU(访问时间最旧淘汰)/LFU(把频次低的淘汰掉) 超时剔除：设置key过期时间 主动更新：开发设置生命周期 缓存降级 降级的情况，就是缓存失效或者缓存服务挂掉的情况下，我们也不去访问数据库。我们直接访问内存部分数据缓存或者直接返回默认数据。 对于应用的首页，一般是访问量非常大的地方，首页里面往往包含了部分推荐商品的展示信息。这些推荐商品都会放到缓存中进行存储，同时我们为了避免缓存的异常情况，对热点商品数据也存储到了内存中。同时内存中还保留了一些默认的商品信息。 如下图所示： 3. Redis 设置key过期后如何处理？Redis缓存刷新策略（内存淘汰机制）有哪些？ Redis 设置过期时间 Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置⼀个过期时间。 如我们⼀般项⽬中的 token 或者⼀些登录信息，尤其是短信验证码都是有时间限制的，过期后基本不会使用 过期后采用什么策略进行删除？ 定期删除：redis默认是每隔 100ms 就随机抽取⼀些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这⾥是随机抽取的。为什么要随机呢？你想⼀想假如 redis 存了⼏⼗万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！ 惰性删除：定期删除可能会导致很多过期 key 到了时间并没有被删除掉，所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存⾥，除⾮你的系统去查⼀下那个 key，才会被redis给删除掉。 内存淘汰策略 ：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没⾛惰性删除，此时会怎么样？如果大量过期key堆积在内存⾥，导致redis内存块耗尽了。所以有内存淘汰策略。 volatile-lru：从已设置过期时间的数据中挑选最近最少使⽤的数据淘汰 volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据中任意选择数据淘汰 allkeys-lru：当内存不⾜以容纳新写⼊数据时，在键空间中，移除最近最少使⽤的key（这个是最常⽤的） allkeys-random：从数据集中任意选择数据淘汰 no-eviction：禁⽌驱逐数据，也就是说当内存不⾜以容纳新写⼊数据时，新写⼊操作会报错。这个应该没⼈使⽤吧！ 4. Redis报内存不足怎么处理？ 增加 Redis 可用内存： 修改件 redis.conf 的 maxmemory 参数； 使用分布式集群，提高存储量； 设置缓存淘汰策略：提高内存的使用效率； 5. 【重点】缓存和数据库谁先更新呢？ （保持缓存和数据库一致性） 参考：https://learnku.com/articles/22363 对于读（查询）操作 一般我们对读操作的时候有这么一个固定的套路： 如果我们的数据在缓存里边有，那么就直接取缓存的； 如果缓存里没有我们想要的数据，我们会先去查询数据库，然后将数据库查出来的数据写到缓存中； 最后将数据返回给请求。 不用更新（写）数据库，只用更新（写）缓存。 对于写操作导致双写问题 如何保证缓存(redis)与数据库(MySQL)的一致性 写操作会更新数据库，那么缓存也要进行更新，此时会发生数据库和缓存不一致的问题。 键的过期时间：能保证缓存和数据库的数据最终是一致的。 因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据重新写入到缓存中。 除了设置过期时间，我们还需要做更多的措施来尽量避免数据库与缓存处于不一致的情况发生。 直接看结论： 不考虑更新缓存而是直接删除缓存，因为更新逻辑较为复杂涉及到其它数据，更新cache消耗会比较大。 先删除缓存，再更新数据库 在高并发下可能会导致数据长时间不一致 采用异步更新缓存的策略，不会导致数据不一致，但在数据库更新完成之前，都需要到数据库层面去读取数据，读的效率不太好——保证了数据的一致性，适用于对一致性要求高的业务 先更新数据库，再删除缓存 (Cache Aside Pattern 设计模式) 在高并发下不会导致数据长时间不一致 在更新数据库期间，cache中的旧数据会被读取，可能会有一段时间的数据不一致，但读的效率很好。——保证了数据读取的效率，如果业务对一致性要求不是很高，这种方案最合适 先删除缓存，再更新数据库 ⚠️ 只有读才会更新缓存！！ 正常情况 A线程进行写操作，先淘汰缓存，再更新数据库 B线程进行读操作，发现缓存中没有想要的数据，从数据库中读取更新后的新数据 ，并更新缓存 高并发异常 A线程进行写操作，先淘汰缓存，但由于网络原因等未及时更新数据库 B线程读取缓存失败，去读取数据库的是旧值 ，并将旧数据放入缓存 A线程再更新数据库成功（同步情况下写操作不更新redis而读操作更新redis），此时缓存（旧）和数据库（新）不一致 而且没有设置键过期，会保持很长时间的数据不一致。 解决方案 异步更新缓存 ：B线程读操作不更新缓存，而是由A线程写操作更新数据库成功后，通过binlog异步更新缓存 延时双删： A线程休眠M秒（确保事务都已提交），再更新数据库成功后，再次删除缓存。其它线程进行读操作时，缓存中无数据，从数据库中读取的是更新后的新数据，又再次一致了。 先更新数据库，再删除缓存 正常情况 A线程进行写操作，先更新数据库，再删除缓存 B线程进行读操作，发现缓存中没有想要的数据，从数据库中读取更新后的新数据 ，并更新缓存 高并发异常 A线程进行写操作，先更新数据库，但未来得及删除缓存 B线程进行读操作，读取缓存的旧数据（背错一次），此时数据不一致 A线程再删缓存 但其它线程进行读数据的时候更新缓存，更新缓存又一致了，不一致的时间很短。 但是还可能会考虑：3. A线程删除缓存失败 ，此后读取的一直都是旧数据了。 解决方案 消息队列进行删除补偿。如果Redis删除发现报错，将Redis的key作为消息发送到消息队列中，系统收到消息队列再次对Redis进行删除操作。 6.4 集群相关 1. Redis的同步机制了解是什么？ Redis主从复制可以根据是否是全量分为：全量同步和增量同步。 主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。 全量同步 Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份： ​ 1）从服务器连接主服务器，发送SYNC命令； 2）主服务器接收到SYNC命名后，开始执行BGSAVE命令（1）生成RDB文件 （2）并使用缓冲区记录此后执行的所有写命令； 3）主服务器BGSAVE执行完后，向所有从服务器发送RDB快照文件，并在发送期间继续记录被执行的写命令； 4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令； 增量同步 Slave初始化后开始正常工作时：主服务器发生的写操作同步到从服务器的过程。 主服务器每执行一个写命令就会向从服务器发送相同的写命令； 从服务器接收并执行收到的写命令。 2.【新补充】 Redis集群架构模式有哪几种？集群的原理是什么？ 待补充：Redis 架构模式详解（单机、主从、哨兵、集群模式） 1. 单机模式 QPS（每秒查询速度）大约在几万左右。 安装一个 Redis，启动起来，业务调用即可。 优点： 部署简单；成本低；高性能 缺点： 单节点宕机风险 ; 单机高性能受限于 CPU 的处理能力 2. 主从复制 Redis 的复制（Replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品。 被复制的服务器为主服务器（Master），而通过复制创建出来的复制品则为从服务器（Slave）。 主要优缺点： 优点： Master/Slave 角色方便水平扩展，降低 Master 读压力，转交给 Slave 节点； 缺点： 可靠性保证不是很好，主节点故障便无法提供写入服务；没有解决主节点写的压力 ；主节点宕机，需要人为干预。 3. 哨兵模式 Redis 2.8版本后引入了哨兵的概念。 主从模式中，当主节点宕机之后，从节点是可以作为主节点顶上来继续提供服务，但是需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点数据，整个过程需要人工干预。 为此，引入了哨兵（Sentinel）这个概念，在主从复制的基础上，哨兵实现了自动化故障恢复。哨兵模式由两部分组成，哨兵节点和数据节点： 哨兵节点：哨兵节点是特殊的 Redis 节点，不存储数据； 数据节点：主节点和从节点都是数据节点。 哨兵工作原理： 每个 Sentinel 以每秒一次的频率向它所知的 Master，Slave 以及其他 Sentinel 节点发送一个 PING 命令； 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过配置文件 own-after-milliseconds 选项所指定的值，则这个实例会被 Sentinel 标记为主观下线； 如果一个 Master 被标记为主观下线，那么正在监视这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 是否真的进入主观下线状态； 当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认 Master 的确进入了主观下线状态，则 Master 会被标记为客观下线； 如果 Master 处于 ODOWN 状态，则投票自动选出新的主节点;将剩余的从节点指向新的主节点继续进行数据复制； 若没有足够数量的 Sentinel 同意 Master 已经下线，Master 的客观下线状态就会被移除。若 Master 重新向 Sentinel 的 PING 命令返回有效回复，Master 的主观下线状态就会被移除。 哨兵模式优缺点： 优点：（1）主从自动切换，更加健壮 缺点： （1）主从切换需要时间还是会丢失数据；（2）没有解决主节点写压力 （3）动态扩容复杂 4. 集群模式 Redis 3.0 版本引入了Redis Cluster集群模式。 如上图所示：该集群中包含 6 个 Redis 节点，3 主 3 从，分别为 M1，M2，M3，S1，S2，S3。除了主从 Redis 节点之间进行数据复制外，所有 Redis 节点之间采用 Gossip 协议进行通信，交换维护节点元数据信息 Redis Cluster 采用无中心结构，每个节点都可以保存数据和整个集群状态，每个节点都和其他所有节点连接。 Cluster 一般由多个节点组成，节点数量至少为 6 个才能保证组成完整高可用的集群，其中3个为主节点，3个为从节点； 4.1 Redis 集群分片概念 单机、主从、哨兵的模式数据都是存储在一个master节点上，其他节点进行数据的复制。 集群模式就是把数据进行分片存储，当一个分片数据达到上限的时候，还可以分成多个分片。 Redis Cluster 采用虚拟哈希槽分区，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式： HASH_SLOT = CRC16(key) % 16384 每一个主节点负责维护一部分槽以及槽所映射的键值数据。 举例说明： 有 3 个节点的集群环境如下 节点 A 哈希槽范围为 0 ~ 5500； 节点 B 哈希槽范围为 5501 ~ 11000； 节点 C 哈希槽范围为 11001 ~ 16383。 增加数据： （1）根据上述公式计算新增的key存储 ，映射到相应节点（假设为B） 增加节点： （1）从各个节点拿出一部分哈希槽分配到新增的D节点上即可 删除节点： （1）删除A节点，只需将A节点的哈希槽移动到其它节点接口 4.2 Reids集群的主从模式 Redis Cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点复制主节点数据备份，当这个主节点挂掉后，就会通过这个主节点的从节点选取一个来充当主节点，从而保证集群的高可用。 4.3 优缺点总结 优点： （1）无中心结构 ，多节点存储数据；（2）节点动态删除、移动数据分布方便；（3）部分节点不可用，集群依旧可用（哈希槽 + 从节点备份并故障晋升主节点）； 缺点： （1）异步复制，无法保证数据一致性（2）集群搭建复杂（3）mget,pipeline等命令。它们需要把请求分散到多个节点执行、再聚合。节点越多，性能越低 3.说说 Redis哈希槽的概念？什么情况下会导致整个集群不可用？ Redis 没有使用哈希一致性算法，而是使用哈希槽。Redis 中的哈希槽一共有 16384 个，计算给定密钥的哈希槽，我们只需要对密钥的 CRC16 取摸 16384。 假设集群中有 A、B、C 三个集群节点，不存在复制模式下，每个集群的节点包含的哈希槽如下： 节点 A 包含从 0 到 5500 的哈希槽； 节点 B 包含从 5501 到 11000 的哈希槽； 节点 C 包含从 11001 到 16383 的哈希槽； 这时，如果节点 B 出现故障，整个集群就会出现缺少 5501 到 11000 的哈希槽范围而不可用。 4. Redis 常见性能问题和解决方案有哪些？ Redis 常见性能问题和解决方案如下： Master不做持久化， Slave 做 AOF：Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件；如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次； 同局域网：为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内； 尽量避免在压力很大的主库上增加从库； 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;-Slave3….；这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变 6.5 Redis Key相关 1.假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？ 我们可以使用 keys 命令和 scan 命令，但是会发现使用 scan 更好。 keys命令 虽然可以查询但不太推荐： 时间长且会导致线程阻塞： 时间长是因为O(N)遍历 ； 阻塞是因为Redis单线程，要等遍历完，这使得Redis要等keys执行完毕才能恢复生产（在生成环境中这是不被允许的）。 没有分页功能： 一次查找所有的结果 scan命令 推荐： 不会阻塞，但查找出的元素可能重复，需要客户端去重下 为什么不会阻塞？ 因为 scan 是通过游标方式查询的 ，查询过程中会把游标返回给客户端，单次返回空值且游标不为 0，则说明遍历还没结束，客户端继续遍历查询。 2.如果有大量的 key 需要设置同一时间过期，一般需要注意什么？ 如果有大量的 key 在同一时间过期，那么可能同一秒都从数据库获取数据，给数据库造成很大的压力，导致缓存雪崩。 解决方案： 最好给数据的过期时间加一个随机值，让过期时间更加分散 3.什么是 bigkey？会存在什么影响？ bigkey 是指键值占用内存空间非常大的 key。例如一个字符串 a 存储了 200M 的数据。 bigkey 的主要影响有： 网络阻塞：获取 bigkey 时，传输的数据量比较大，会增加带宽的压力； 超时阻塞：因为 bigkey 占用的空间比较大，所以操作起来效率会比较低，导致出现阻塞的可能性增加。 4. Redis如何解决 key冲突？ Redis 如果 key 相同，后一个 key 会覆盖前一个 key。 如果要解决 key 冲突，最好给 key 取好名区分开，可以按业务名和参数区分开取名，避免重复 key 导致的冲突。 5. 如何解决Redis的并发竞争Key问题 ？ 多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同。 解决方案：分布式锁（zookeeper 和 Redis 都可以实现分布式锁）。 zookeeper分布式锁：（1）每个客户端对某个方法加锁时，在zookeeper上的 与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点；（2）判断是否获取锁的方式很简单，只需要判断有 序节点中序号最小的一个；（3）当释放锁的时候，只需将这个瞬时节点删除即可。 同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。 6. Redis删除key的底层原理实现？ 参考：https://www.hoohack.me/2019/06/24/redis-expire-strategy Redis在启动的时候，会注册两种事件： 时间事件： Redis处理后台操作的一类事件，比如客户端超时、删除过期key 文件事件： redis注册的回调函数是serverCron，在定时任务（惰性删除）回调函数中，通过调用databasesCron清理部分过期key 定时删除 对于每一个设置了过期时间的key都会创建一个定时器，一旦到达过期时间就立即删除： 缺点：占用了大量的CPU资源去处理过期的数据，会影响Redis的吞吐量和响应时间。 惰性删除 每次访问key的时候，都会调用expireIfNeeded函数判断key是否过期，如果是，清理key： 缺点：大量的过期key没有被再次访问，因此不会被清除，导致占用了大量的内存。 定期删除 每隔一段时间，扫描Redis中过期key字典，并清除部分过期的key： 缺点：折中方案 Redis单线程清理key的时机 Redis是以单线程运行的，在清理key是不能占用过多的时间和CPU，需要在尽量不影响正常的服务情况下，进行过期key的清理。 以随机删除为例 server.hz配置了serverCron任务的执行周期，默认是10，即CPU空闲时每秒执行十次； 每次清理过期key的时间不能超过CPU时间的25% ； 如果是快速清理模式（在beforeSleep函数调用），则一次清理的最大时间是1ms； 依次遍历所有的DB； 从db的过期列表中随机取20个key，判断是否过期，如果过期，则清理； 如果有5个以上的key过期，则重复步骤5，否则继续处理下一个db ； 在清理过程中，如果达到CPU的25%时间，退出清理过程。 Redis4.0使用BIO处理 Redis4.0以前，删除指令是del，del会直接释放对象的内存，但是，如果删除的key是一个非常大的对象，那么删除操作就会导致单线程卡顿，Redis的响应就慢了。 在Redis4.0版本引入了unlink指令，能对删除操作进行“懒”处理，将删除操作丢给后台线程，由后台线程BIO来异步回收内存。 内存淘汰策略 Redis的内存淘汰策略，是指内存达到maxmemory极限时，使用某种算法来决定清理掉哪些数据，以保证新数据的存入。","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"数据库","permalink":"https://hwh.zone/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"https://hwh.zone/tags/Redis/"}]},{"title":"校招笔记（五）_计算机基础_MySQL","slug":"校招笔记（五）_计算机基础_MySQL","date":"2021-11-26T12:57:42.047Z","updated":"2022-03-24T14:30:14.678Z","comments":true,"path":"p/56848/","link":"","permalink":"https://hwh.zone/p/56848/","excerpt":"","text":"我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。 备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 五、MySQL 5.1 MySQL基本 0. 关系型数据库和非关系数据库的区别？ 关系型数据库的优点 容易理解，因为它采用了关系模型来组织数据； 可以保持数据的一致性； 数据更新的开销比较小； 支持复杂查询（带where子句的查询）。 非关系型数据库的优点 不需要经过SQL层的解析，读写效率高； 基于键值对，数据的扩展性很好； 支持多种类型数据的存储，如图片，文档等等。 1.介绍一下数据库三范式？ 参考：https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html 第一范式： 数据库表中的所有字段值都是不可分解的原子值 。 数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储。 第二范式： 第二范式基于第一范式，且要求：数据库表中的每一列都和主键相关，且不能只与主键的某一部分相关（主要针对联合主键而言）, 即不存在部分依赖； 下表是以：订单编号&amp;商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的订单编号相关，而仅仅是与商品编号相关。 所以根据第二范式，将它进行拆分三个表： 第三范式： 基于第二范式，数据表中的每一列数据都和主键直接相关，即不存在传递依赖； 比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。 2. MySQL数据库引擎有哪些？ MySQL查看所有的数据引擎： 1mysql&gt; show engines; MySQL常用引擎包括：MYISAM、Innodb、Memory、MERGE， MYISAM （读：my+i+son） 以select、insert为主的应用基本上可以使用这引擎。 优点：全表锁，拥有较高的执行速度，占用空间小； 缺点 ：不支持事务，不支持外键，并发性能差。 Innodb Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，它的设计目标是处理大容量数据库系统。 优点：行级锁，支持事务，支持自动增长列，支持外键约束，并发能力强 缺点： 占用空间是MYISAM的2倍，处理效率相对也更低 Memory 主要用于内容变化不频繁的代码表。 优点：全表锁，存储在内存中，默认使用Hash，检索效率非常高 缺点： 会占用和数据量成正比的内存空间且，mysql重启时会丢失，不适合精确查找 MERGE 是一组MYISAM表的组合。 2.1 InnoDB、MyISAM、Memory 【索引】（按数据结构分） 参考：https://segmentfault.com/a/1190000037683781 2.2 为什么Innodb使用自增id作为主键？ 如果不使用自增主键， 如身份证号、学号，每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置（涉及到B+树分裂等）， 频繁的移动、分页操作造成了大量的碎片； 如果使用自增主键， 那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。 3.说说InnoDB与MyISAM的区别？ 见前。 3.1 说说InnoDB与MyISAM在B+数索引方式区别？ MyISAm , B+Tree叶节点的data域存放的是数据记录的地址，在索引检索的时候，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引” ； InnoDB， 树的节点data域保存了完整的数据记录，这个索引的key是数据表的主键（自增id） ；而其它索引都叫做辅助索引， 助索引的data域存储相应记录主键的值而不是记录地址。 在根据主索引搜索时，直接找到key所在的节点即可取出数据； 在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 3.2 【百度】说说InnoDB与MyISAM在适用场景上的区别？ MyISAM ，没有事务， 适合插入不频繁，查询非常频繁； Innodb： 有事务，适合可靠性要求比较高，或者更新和查询比较频繁。 4. 为什么 SELECT COUNT(*) FROM table 在 InnoDB 比MyISAM 慢？ 对于 SELECT COUNT(*) FROM table 语句，在没有 WHERE 条件的情况下，InnoDB 比 MyISAM 可能会慢很多，尤其在大表的情况下。 InnoDB 是去实时统计结果，会全表扫描； 而 MyISAM内部维持了一个计数器，预存了结果，所以直接返回即可。 5.简单说一说drop、delete与truncate的区别？ SQL中的drop、delete、truncate都表示删除，但是三者有一些差别： 删除类型： drop删除表结构；delete、truncate删除表内容。 删除速度： drop&gt; truncate &gt;delete 生效速度： drop和truncate ，操作立即生效，不能回滚也不触发触发器；delete事务提交后才生效，会触发相应触发器。 6.什么是视图？ 游标？ 视图是一种虚拟的表，通常是一个表或者多个表的行或列的子集，具有和物理表相同的功能。 可以对视图进行增，改，查，操作，但对视图的修改不影响基本表； 相比多表查询，获取数据速度更容易。 游标，是对查询出来的结果集作为一个单元来有效的处理。 一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。 7.什么是内联接、左外联接、右外联接？ 内联接（Inner Join）：两个表（或连接）中某一数据项相等的连接称为内连接。 连接的结果是形成一个新的数据表。 内连接中参与连接的表（或连接）的地位是相等的； 左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示； 右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示。 8.说说在 MySQL 中一条查询 SQL 是如何执行的？ 例如：select name from t_user where id=1 取得链接，使用使用到 MySQL 中的连接器； 查询缓存，key 为 SQL 语句，value 为查询结果，如果查到就直接返回； 在 MySQL 8.0 版本已经将查询缓存删除，也就是说 MySQL 8.0 版本后不存在此功能。 分析器，分为词法分析和语法分析。此阶段只是做一些 SQL 解析，语法校验。所以一般语法错误在此阶段； 优化器，是在表里有多个索引的时候，决定使用哪个索引；或者一个语句中存在多表关联的时候（join），决定各个表的连接顺序； 执行器，开始执行语句。执行语句的时候还要判断是否具备此权限，如果有权限：（1）根据表的引擎定义，使用引擎提供的接口，获取表的第一行，判断id是否等于1 ；（2）如果不是则继续调用引擎接口去获取下一行，继续判断；（3）直至取到这个表的最后一行 9. MySQL 中 varchar 与 char 的区别？ int(3) 呢？ char 是一种固定长度的类型，varchar 则是一种可变长度的类型。 float(3,2) 和 int(3) float(3,2) : &quot;浮点型&quot;的长度是用来限制数字存储范围的。比如 float(3,2) 只能够写入 0.00~999.99。 int(3) ：&quot;整型&quot;的长度并不会限制存储的数字范围，都是-2147483648 ~ 2147483647 。只限制显示长度。 10.超键、主键、候选键和外键有什么区别？ 超键(super key)：在关系中能唯一标识元组的属性集称为关系模式的超键； 候选键(candidate key)：不含有多余属性的超键称为候选键，是超键的子集； 主键(primary key)：用户选作元组标识的一个候选键程序主键，是候选键的子集 ； 外键：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。 下面举例说明（假设姓名不重复唯一）： 身份证 姓名 性别 年龄 超键： 身份证、姓名、（姓名、性别）、（姓名、性别、年龄）都可以作为超键； 候选键 ：身份证、姓名 都唯一，都可以作为候选键； 主键： 在候选键选一个作为主键，例如：身份证。 11. 解释⼀下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池? 池化设计思想 我们常⻅的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。 数据库连接池 数据库连接本质就是⼀个 socket 的连接。数据库服务端还要维护⼀些缓存和⽤户权限信息之类的所以占⽤了⼀些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重⽤这些连接。 为什么要用数据库连接池？ 为每个⽤户打开和维护数据库连接，尤其是对动态数据库驱动的网站应⽤程序的请求，既昂贵⼜浪费资源。在连接池中，创建连接后，将其放置在池中，并再次使⽤它，因此不必建⽴新的连接。如果使⽤了所有连接，则会建⽴⼀个新连接并将其添加到池中。 12. 如果数据不存储在磁盘而是在内存，用什么数据结构？为什么Mysql不使用hash？ 参考：为什么hash作为内存使用的经典数据结构? 数据放在磁盘，使用B+树，核心是为了减少磁盘IO，因为磁盘IO的代价很大（是内存的十万倍）。 我们使用hash寻找数据的时候，数据随机分散到各个物理位置，不是有序的数据。而内存设备也是随机访问设备，内存很适合用hash方式来读取数据。 随机访问：存储器单元的内容可以根据需要自由取出或存储，而且访问的速度与存储器单元的位置无关 。(通过行，列地址总线就可以快速定位存储的数据) 但是磁盘，每次访问数据，是需要先定位，然后顺序移动；如果下个数据不在磁头附近，又要重新定位。 如果Hash索引磁盘数据，（1）每次访问都要IO不能范围（2）数据太多，Hash索引保存不了键值，而高度为3的B+数就能保存千万级别的数据（3）当数据量很大时，hash冲突的概率也会非常大（4）组合索引可以支持部分索引查询，如(a,b,c)的组合索引，查询中只用到了阿和b也可以查询的，如果使用hash表，组合索引会将几个字段合并hash，没办法支持部分索引 （5）当需要按照索引进行order by时，hash值没办法支持排序 。 13.【字节】Mysql Join的原理？ 参考：https://zhuanlan.zhihu.com/p/54275505 1select * from user tb1 left join level tb2 on tb1.id=tb2.user_id 简单嵌套循环 双层for 循环 ，通过循环外层表的行数据，逐个与内层表的所有行数据进行比较来获取结果。 索引嵌套循环连接 通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去进行比较， 这样极大的减少了对内层表的匹配次数。 从原来的匹配次数=外层表行数 * 内层表行数,变成了 外层表的行数 * 内层表索引的高度，极大的提升了 join的性能； 注意，要为表user_level 去建立索引 缓存块嵌套循环连接 其优化思路是减少内层表的扫表次数。 通过简单的嵌套循环查询的图，我们可以看到，左表的每一条记录都会对右表进行一次扫表，扫表的过程其实也就是从内存读取数据的过程，那么这个过程其实是比较消耗性能的。 所以缓存块嵌套循环连接算法意在通过一次性缓存外层表的多条数据，以此来减少内层表的扫表次数，从而达到提升性能的目的。如果无法使用Index Nested-Loop Join的时候，数据库是默认使用的是Block Nested-Loop Join算法的。 当level 表的 user_id 不为索引的时候，默认会使用Block Nested-Loop Join算法。 13.1 join和left join区别? join相当于我们平时用的where，就是把两张表中同时满足a.id=b.id的数据找出来； left join是以左表（a）为参考对象，相当于做一个for循环，把a表的数据一条一条的读取出来，然后根据a.id=b.id的条件到b表中查找数据。 13.2 unio和unio all的区别? 如果我们需要将两个select语句的结果作为一个整体显示出来，我们就需要用到union或者union all关键字。 1select employee_id,job_id from employees union select employee_id,job_id from job_history union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。 13.3 unio 和 join的区别? 参考：https://www.jb51.net/article/30975.htm join是对两个表进行联合，相当于where，满足条件的行会被选出，其中列会被扩充！ 但unio是连接结果集，需要满足列个数相同，只会保存第一个表列个数，列个数不会被扩充！ 5.2 分布式数据库 0. 【字节】分布式数据库锁如何实现？ 什么时候用到分布式数据库？ 水平拆分 ：数据量大到单机数据库已存储不下时， 可以对数据进行拆分，化整为零，将数据均匀分布到多个数据库节点中。 读写分离：主要用在数据量并不大，单机数据库能够hold得住，但读请求很高的情况下。此时，可以配置多个只读数据库节点，来分担主节点的读请求。通过数据复制机制，在主节点和只读节点之间进行数据的实时同步，保证主从节点的数据一致性。 分布式数据库锁？ 直接锁表，代价比较大 加入排它锁，查询语句后面增加for update（这里我们希望使用行级锁，就要给method_name添加索引） Zookeeper实现分布式锁 1. 请说说MySQL数据库的锁？ MySQL 中常见锁如下： 【按使用方式划分】 共享锁：不堵塞，多个用户可以同一时刻读取同一个资源，相互之间没有影响； 排它锁（写锁）：一个写操作阻塞其他的读锁和写锁，只允许一个用户进行写入，防止其他用户读取正在写入的资源。 【按锁粒度划分】 表锁：系统开销最小，会锁定整张表，不会出现死锁；但是由于粒度太大，因此造成锁的冲突几率大，并发性能低。MyISAM 使用表锁。 行锁：容易出现死锁，发生冲突概率低，并发性能高。InnoDB 支持行锁。 必须有索引才能实现，否则会自动锁全表，那么就不是行锁。 【按思想划分】 乐观锁 悲观锁 2.说说什么是锁升级？什么情况发生锁升级？ 区分一下sycronized锁升级。 锁升级是指将当前锁的粒度降低：行锁→页锁→表锁。 发生锁升级的情况： 当一条SQL语句对同一个对象上持有的锁数量超锁了阈值，默认这个阈值为5000，但是对于不同对象不会发生锁升级 锁资源占用的内存超过激活内存的百分之40 就会发生锁升级 2.1 为什么说innoDB 引擎不存在锁升级的问题 ？ 待补充。 2.2 什么时候触发行锁和表级锁？ mysql默认存储引擎都是innodb，默认是使用行锁 。 触发行级锁 ，行级锁锁的是索引记录 ，使用了索引所以就会触发行级锁。 触发表级锁，有以下三种情况 其实不管是读操作(select)还是写操作(update,delete,insert),只要涉及到带有筛选条件的语句，如果筛选条件中没有用到索引，就会触发全表扫描。 全表更新：事务需要更新大部分数据或全部数据，如果使用行级锁，会导致事务执行效率低，从而导致其他事务长时间等待锁和更多的锁冲突 多表级联：事务涉及多张表，比较复杂的关联查询，很可能造成死锁，这种情况若能一次性锁住事务涉及的表，从而避免死锁，减少数据库事务回滚所带来的开销 筛选条件中未用到索引： 全表扫描 用到索引，但区分度程度不高 ：innodb认为全表扫描比走索引效率更高导致索引失效，这个时候就要通过explain去查看下查询计划，看下查询语句是否真的用到了索引 2.3 行锁适合的场景？ A用户消费，service层先查询该用户的账户余额，若余额足够，则进行后续的扣款操作；这种情况查询的时候应该对该记录进行加锁。 1for update # 操作该记录时加上 否则，B用户在A用户查询后消费前先一步将A用户账号上的钱转走，而此时A用户已经进行了用户余额是否足够的判断，则可能会出现余额已经不足但却扣款成功的情况。 3.怎样尽量避免死锁的出现？ 设置获取锁的超时时间，至少能保证最差情况下，可以退出程序，不至于一直等待导致死锁； 设置按照同一顺序访问资源，类似于串行执行； 避免事务中的用户交叉； 保持事务简短并在一个批处理中； 使用低隔离级别。 4.解释一下悲观锁和乐观锁？ 悲观锁： 悲观锁是基于一种悲观的态度类来防止一切数据冲突。它是以一种预防的姿态 在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作。一般数据库本身锁的机制都是基于悲观锁的机制实现的。 特点： 完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁；但是造成性能消耗 实现 ： 12345678# 加读锁LOCK tables test_db READ # 释放锁UNLOCK TABLES# 加写锁LOCK tables test_db WRITE # 释放锁UNLOCK TABLES 乐观锁： 对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁，使得多个任务可并行对数据操作。但是使用一种验证机制来避免数据冲突 （一般通过加版本后对比来实现）。 特点： 并发类型的锁，本身不加锁但通过业务实现锁的功能 ，没有锁操作因此性能更高。 实现形式： （1）两个请求同时操作操作标Name字段，二者查询需检索的数据都是一样的： （2）请求1修改字段数据“zhangsan”→“lisi” ，并将版本号增加+1 ，验证版本号一直后提交 1update A set Name=lisi,version=version+1 where ID=#&#123;id&#125; and version=#&#123;version&#125; （3）请求2也想修改“zhangsan”→“liming” ，但是提交时由于 版本号不一致，无法提交成功 4.1 数据库乐观锁和悲观锁，如何实现？ 实现乐观锁 利用版本号，如MVCC； 时间戳：同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似。 也是在更新提交的时候，将当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。 实现悲观锁 直接加上读锁或者写锁，SELECT … FOR UPDATE 。 5.介绍一下分布式数据库全局ID唯一且自增，如何生成？ （或者问分库分表之后，id 主键如何处理？） 因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要⼀个全局唯⼀的 id来支持。 UUID：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。 ID自增量为分布式数据库个数，缺点是扩展性不好； snow flake算法：snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。 核心思想： 使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 不同ID），最后还有一个符号位，永远是0。 Leaf算法：分号段 8.介绍一下哈希算法？和一致性哈希算法？ 哈希算法 介绍： 哈希算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。 分布式应用中缺点： 在分布式的存储系统中，要将数据存储到具体的节点上。如果采用哈希算法：key%N（key是数据的key，N是机器节点数） 。出现机器加入或退出集群（N变了，映射值不一样了），所有的数据映射都无效了。 一致性哈希算法 介绍：解决普通哈希算法造成负载均衡时，在服务节点数量变动时出现哈希失效 问题 实现： 构建环：按照常用的hash算法来将对应的key哈希到一个具有2^32次方个节点的空间中（即0 ~ (2^32)-1）。 Note: 节点的个数可以自定义, hash环我们可以用TreeMap来实现, 因为treeMap是排序的，我们刚好可以利用上。 映射服务器节点： 将各个服务器使用Hash进行一个哈希，确定每台机器其在哈希环上的位置。 一般用服务器ip或唯一主机名进行哈希。 映射数据。 对于要存储的数据：ojectA、objectB、objectC、objectD ，首先通过特定哈希函数计算出hash值 ，散列到环上。然后从数据所在位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。 出现服务器变动。 如果此时NodeC宕机了，此时Object A、B、D不会受到影响，只有Object C会重新分配到Node D。避免了大量数据迁移，减小了服务器的的压力 。 9. （再理解）介绍一下MVVC？ MVCC（Multi-Version Concurrency Control）多版本并发控制，是 数据库控制并发访问的一种手段。 特别要注意MVCC只在读已提交(RC) 和可重复读（RR） 这两种事务隔离级别下才有效 是数据库引擎（InnoDB） 层面实现的，用来处理读写冲突的手段（不用加锁），提高访问性能 MVCC协议中，事务提交不会覆盖原数据，而是产生新版本数据，每个数据有多个历史版本，但同一时刻只有最新的版本有效； MVCC是在并发访问数据库时，通过对数据做多版本管理，避免【因为写锁的阻塞而造成读数据的并发阻塞】问题。可以让读取数据同时修改，【修改数据时同时可读取】。简单来说，就是不对数据库加上读写锁！ 9.1 MVCC 如何实现 ？ 参考：Innodb MVCC实现原理 总结性回答 MVCC是以一个多版本并发控制系统，它主要通过以下两个部分实现： 每行记录：记录最近操作该行记录的事务ID，和上一版本数据的指针（指向undo log） readview：每次读（写不可以） 可以获取一个readview，记录当前活跃的事务ID ，可以在写的过程进行读 写的时候并发读，通过比较当前行记录的事务ID和readview活跃的事务ID，来决定是否读取该行记录还是上一版本的数据。 MVCC实现的核心部分为： 事务版本号：每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。 表的隐藏列 ：每一行 有如下三个重要字段属性： 隐藏列 作用 DB_TRX_ID 记录操作该行事务的ID DB_ROLL_PTR 指向上一个版本的数据（在undo log）的指针 DB_ROW_ID 隐藏ID，当表没有合适的索引作为聚簇索引时，会用该ID创建聚簇索引 undo log ：每一行记录被修改之前的日志。 当事务被回滚时，可以用通过undo log日志对数据进行还原。 一个小例子：修改某行记录name从 “张三→李四” read view。在innodb 中每个SQL语句执行前都会得到一个read_view，保存了当前数据库系统中正处于活跃（没有提交）的事务的ID号。 根据事务的隔离性，这些事务ID列表不会被其它事务看到。 其相关重要属性如下： 属性 作用 trx_ids 当前系统：活跃（未提交）事务版本号集合 low_limit_id 当前系统：最大版本事务号+1 up_limit_id 当前系统：活跃的最小事务版本号 creator_trx_id 当前read view：事务版本号 具体原理可以描述如下： 举个例子，假设有一个user_info表，初始数据如下： 现在有事务A，B同时对id=1 这行数据进行操作，先开启事务A（未提交），此时执行事务B，最后返回什么结果呢？ 事务A（写），执行 update user_info set name =”李四” 获得事务编号：102 当前事务A的视图为：（写）不会获得read view！ 事务B（读），执行 select * fom user_info where id=1 获得事务B编号：103 当前事务B的视图为： trx_ids 当前活跃的事务：102,103 low_limit_id 当前最大事务id+1:104 up_limit_id 当前最小事务id：102 creator_trx_id 当前事务id：103 不同隔离级别下，read view的工作方式： 读未提交：不会获得read view的副本（等于没有并发控制所以会出现脏读） 读提交：每一次select都会获得一个read view的副本，所以会造成【不可重复读】 可重复读：同一个事务select只会获得一次read view副本（select的时候不允许修改），所以不会出现不可重复读。 事务A（写），开始执行update语句：（1）把原数据拷贝到undo log，（2）然后进行修改name字段：“张三→李四”，（3）并设置DB_TRX_ID 隐藏字段：99→102 （4）设置DB_ROLL_PTR隐藏字段：执行上个事务版本地址 此时，事务A还并未提交，依旧是处于活跃状态。 事务B（读），开始执行select语句，查询到是事务A修改后的语句 把数据和read view （视图）匹配： 保证（1）数据已提交，没有其他事物修改，否则去找上一版本的数据。 当前数据记录的事务id &lt; 事务B视图中最小活跃事务id : 说明数据，是在事务B的read view 创建前就存在，所以可以显示。 当前数据记录的事务id &gt; 事务B视图中最大活跃事务id ：说明数据，是在事务B的read view 创建后才存在，此时不应该显示。 事务B视图中最小活跃事务id&lt;= 当前数据记录的事务id &lt;= 事务B视图中最大活跃事务id ： 说明有其它事务在修改这行记录数据，但可能还没有提交。把id和事务B的read view的活跃事务集合trx_ids进行匹配： 如果数据记录的ID不存在trx_ids，说明已经提交了事务，可以显示 如果存在trx_ids，说明数据还没提交，此时事务B查询到数据不能显示（除非此时数据记录的事务id == 事务B的id，由于是自己的当然可以显示） 事务B（读），根据上述匹配规则，此时不能读，应该去undo log中找到上一版本数据。 此时事务B的id=103，数据记录的事务id=102 ：满足条件3，且此时trx_ids存在事务id=102，说明事务A（id=102）还没提交，因此不能显示。 故，最终查找的数据为： 可以看到，整个过程MVCC事务A【写】没有加锁，只是进行版本号控制 &amp; undo log，可以进行并发【读】。 9.2 MVCC 版本号如何变化的？更新的数据如何确定版本的？【幻读】又是怎么解决的呢？ 版本号变化 每条记录有三个隐藏列：（1）DB_TRX_ID （2）DB_ROLL_PTR （3）DB_ROW_ID 每一次新事务，update更新语句，都会将（1）拷贝数据到undo log（2）DB_ROLL_PTR指向上个数据的版本undo log（3）DB_TRX_ID修改为新事务的id 。 为什么MVCC可解决幻读 在RR（可重复读级别下）不会出现幻读。例如： 开启事务1，获得事务ID为1； 事务1执行查询，得到readview； 开始事务2； 执行insert； 提交事务2； 执行事务1的第二次查询 (因为这里是RR级别，所以不会再去获得readview，还是使用第一次获得的readview，所以当前read view 事务的ID不会更新，即不会加入插入事务2)； 最后得到的结果是，插入的数据不会显示，因为插入的数据事务ID &gt; readview里的最大活跃事务ID。 9.3 mvvc 和 for update的区别 是否加锁： mvvc不加锁，只通过多版本来进行并发控制；for update会加锁（即X/写锁）。 9.4 （快手）MVCC作用，如何实现RC，RR? 参考：https://zhuanlan.zhihu.com/p/73078137 作用如下： 最简单的描述，读写不阻塞，读的时候可以写 提高性能 实现RC，RR两个隔离级别： MVCC 读某一个数据时，根据隔离级别，事务选择要读取哪个版本的数据，过程中完全不需要加锁。 Read Committed ：一个事务读取数据时总是读这个数据最近一次被commit的版本 ，所以可以避免脏读（快手）； Repeatable Read ： 一个事务读取数据时总是读取当前【事务开始之前】最后一次被commit的版本（所以底层实现时需要比较当前事务和数据被commit的版本号），所以避免了幻读（快手）。 举个简单的例子： 一个事务A（txnId=100）修改了数据X，使得X=1，并且commit了 另外一个事务B（txnId=101）开始尝试读取X，但是还X=1。但B没有提交。 第三个事务C（txnId=102）修改了数据X，使得X=2。并且提交了 事务B又一次读取了X。这时 如果事务B是Read Committed。那么就读取X的最新commit的版本，也就是X=2 如果事务B是Repeatable Read。那么读取的就是当前事务（txnId=101）之前X的最新版本，也就是X被txnId=100提交的版本，即X=1。 注意，这里B不论是Read Committed，还是Repeatable Read，都不会被锁，都能立刻拿到结果。这也就是MVCC存在的意义。 5.3 索引相关 🛰 强烈建议对索引更深刻理解，先看完美团这篇技术文章：MySQL索引原理及慢查询优化 0. MySQL索引原理及慢查询优化 0.1 为什么要需要索引 答到：遍历磁盘开销太大这个关键。 数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分读入内存来计算 。 磁盘的成本大概是访问内存的十万倍左右 ， 每次去遍历磁盘找到数据再读入内存，是难以接受的。因此需要一种快速找到磁盘数据的方式，就像字典通过字母索引→快速定位单词。因此索引由此而出现。 0.2 局部性原理（磁盘IO一次读取大小） 在继续往下讲之前，先来讲讲磁盘读取局部性原理。 局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。 因此，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内。 每次IO读取的数据，分为下面情况： Linux：上以页为单位，一次一页（4K） 数据库：mysql（InnoDB引擎）一页（16K）; SQL Server/ Oracle，默认块，大小都是8KB 0.3 索引→B+树 相比二叉树，平衡树等，B+树 作为高度可控的多路搜索树 ，可以很好的满足要求。（详细选择原因，可以参考：5.3 索引相关–问答6） B+树基本结构 浅蓝色是一个磁盘块，数据项就是被组织索引那列的字段值。 如果是Innodb引擎，使用聚簇索引就是按照每张表的主键 构造索引，那么此时数据项就是主键值。 蓝色部分（如17,35）是数据项；黄色部分（如P1,P2,P3）是指针，指向下个磁盘块（页地址）。 1. 为什么B+树非叶子节点不存放数据？ IO次数取决于b+数的高度h，每个磁盘块大小也是一定（一页）的。如果数据项占的空间越小，一个磁盘块数据项的数量越多，树的高度越低，B+可以更高阶（指针占用先忽略）。 所以磁盘非叶子节点不保存数据，是为了保存更多的数据项和指针，这样一颗B+树叶子节点就能存储更多的数据。 2. 数据查找过程？ 以查找数据项=28 ，过程为例： （1） 先 加载（一般常驻内存） 根页面1（磁盘块1），因为17&lt;28&lt;35 所以使用P2指针 ， 找到磁盘块3（页面3）地址 （2）在 IO加载 磁盘块3，因为 26&lt;28&lt;30 ，因此根据此时的P2 指针，找到磁盘块8所在的地址 （3） IO加载 磁盘块8，因为此时是叶子节点，可以得到数据项=28对应的那行记录 。 仅仅最多3次磁盘IO就找到了数据，这提升是巨大的。 3. 高度为3的B+数可以存储多少数据？ 叶子节点一页存储的记录数 mysql一页16K，所以一页存储16K/1K = 16条 记录。（实际真实业务场景一条记录一般就是1K） 非叶子节点一页存储的指针数 由于数据项也要占用空间，其和指针只相差1，按成对算。 假设主键ID（数据项）为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节 。那么一共14字节。 所以一页可以存储：16K / 14B ≈ 1K 个指向页面的指针。 计算可以存储多少页 高度为3的B+树，第3层叶子节点存储真实数据页，前2层是存储数据项+指针。第二层指针==叶子节点存储的页面数。 第一层：根页面可以存储1K个指针，每个指针指向一个新的页面 第二层：存储 1K*1K = 1M ，约一百万个指针，指向一百万个叶子数据页面 所以一共存储：1M*16≈16M ，即千万级别的数据。 0.4 慢查询优化 （暂略） 1. MySQ索引的原理和数据结构能介绍一下吗？索引的缺点？ 索引原理： 本质是用来优化查询速度。用一个数据结构组织某一列的数据，然后如果你要根据那一列的数据查询的时候，就可以不用全表扫描，只要根据那个特定的数据结构快速去找到那一列的值。 数据结构： MySQL索引通过B+树来实现（按数据结构分也有hash索引、fulltext索引）。 索引缺点： （1）占用磁盘存储空间 （2）降低表更新速度，表发生变化，索引也要发生变化 2. MySQL 索引类型有哪些？ 按数据结构分类可分为：B+tree索引、Hash索引、Full-text索引。 按物理存储分类可分为：聚簇索引、二级索引（辅助索引）。 按字段特性分类可分为：主键索引、普通索引、前缀索引。 按字段个数分类可分为：单列索引、联合索引（复合索引、组合索引）。 主键索引：索引列中的值必须是唯一的，不允许有空值； 唯一索引：索引列中的值必须是唯一的，但是允许为空值； 普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值； 全文索引：只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引； 字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引； MyISAM和InnoDB中都可以使用全文索引。 前缀索引：在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定； 空间索引： MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。 MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。 2.1 什么是覆盖索引？ 我们在非聚簇索引一般只获得了，记录的key值（Innodb引擎），还需要回到聚簇索引中再次查询。 覆盖索引： 从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。 一个小例子。 以name和age两个字段建立联合索引，sql命令与建立后的索引树结构如下： 12ALTER TABLE student DROP INDEX I_name;ALTER TABLE student ADD INDEX I_name_age(name, age); 此时执行如下sql： 1SELECT age FROM student WHERE name = &#x27;小李&#x27;； 在非聚簇索引中包含了age信息，那么直接返回12，不需要再到聚簇索引中查询。 【重点】3.什么时候使用索引比较好？什么时候不要使用索引？ 3.1 什么时候用索引 特别的，主键自动建立唯一索引。 频繁作为查询条件的字段应该创建索引 ； 查询中与其他表关联的字段，外键关系建立索引； 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度（索引就是排序加快速查找）； 查询中统计或者分组字段。 3.2 什么时候不用索引 经常增删改的列不要建立索引（因为每次更新不单单是更新记录，还会更新索引，保存索引文件）； 表记录太少不要建立索引； （被CSIG问过）区分度低，数据重复且分布平均的字段不适合做索引； 例如性别字段，只有男女，不适合建立索引。 因为从索引中拿到的只是地址，要想真正访问到数据还是要对表进行一次IO； 假如你要从表的100万行数据中取几个数据，那么利用索引迅速定位，访问索引的这IO开销就非常值了； 但如果你是从100万行数据中取50万行数据，就比如性别字段，那你相对需要 访问50万次索引，再访问50万次表，加起来的开销并不会比直接对表进行一次完整扫描小。 text，image等类型不应该建立索引，这些列的数据量大； 多个单列索引并不是最佳选择 MySQL 只能使用一个索引，会从多个索引中选择一个限制最为严格的索引 ； 参加运算 或 作为函数参值等字段，不要建立索引，这会使得索引失效而全表扫描 。 4.主键与唯一索引有什么区别？ 主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键； 主键不允许为空值，唯一索引列允许空值； 一个表只能有一个主键，但是可以有多个唯一索引； 主键可以被其他表引用为外键，唯一索引列不可以； 主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本质差别。 5. b+树和b树有什么区别？ B树： 索引与数据存储在每个节点中（增加了IO次数）； 搜索过程有可能在非叶子节点结束（最好情况下O(1)O(1)O(1)）。 B+树： 所有数据按顺序存储在叶子节点中； 所有叶子节点被双向链连接； 搜索过程固定时间复杂度（O(log⁡n)O(\\log n)O(logn)）； （优点易忘）适合范围查找，降低磁盘IO次数。 6.为什么MySQL使用B+树作为索引？而不是平衡二叉树、红黑树、B树、或者Hash？ 不用平衡二叉树或者红黑树： 树的查询时间和树的结构有关，B+树是一颗多路搜索数，可以降低树的高度提高查询速度。 不用B树： （1）无法范围查询，而B+树所有叶子节点形成有序链表便于范围查询；（2）N阶B+数，B树，B+数可以存储n个关键字，而B树是n个。 不用Hash： （1）B+树允许分配加载节点，如果内存数据太大B+树更好（2）B+树更适合范围查询 用Hash需要把数据全部加载到内存中，如果数据量大，是一件很消耗内存的事，而采用B+树，是基于按照节点分段加载，由此减少内存消耗。 6.1 无限增加树的路数是不是可以有最优的查找效率？ 这样会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。 有序数组没法一次性加载进内存，这时候B+树的多路存储威力就出来了，可以每次加载B+树的一个结点，然后一步步往下找。 7. B+树怎么进行分裂、合并的？知道具体步骤吗？ 参考：https://www.cnblogs.com/nullzx/p/8729425.htm 8. MySQL聚簇索引和非聚簇索引的区别是什么？ 主要区别 聚簇索引 ： 找到索引就找到了需要的数据，那么这个索引就是聚簇索引; 所以Innodb主键就是聚簇索引，修改聚簇索引其实就是修改主键；但在Myisam下主键索引是非聚集索引。 InnoDB 会隐式定义一个主键来作为聚簇索引（但是这个主键如果更改代价较高，故建表时要考虑自增ID不能频繁update这点）。 非聚簇索引：索引的存储和数据的存储是分离的 , 找到了索引但没找到数据，需要根据索引上的值(主键/地址)再次回表查询，也叫做辅助索引。 MyISM使用的是非聚簇索引 ，下图叶节点的data域存放的是数据记录的地址 。 聚簇索引查找过程 首先澄清一个概念，聚簇索引和和辅助索引。 Innodb存储引擎的B+树分为，聚簇索引保存的是放着一整行的数据；辅助索引都引用主键作为data域。 例如，下图以Col3建立一个Innodb辅助索引 ： 对于MyISAM，主索引和辅助索引（Secondary key）在结构上没有任何区别。只是主索引要求key是唯一的，而辅助索引的key可以重复。 例如，下图以Col2建立一个MyISAM的辅助索引： 1Select * Where name=‘Alice’ 首先根据辅助索引 ，在叶子节点找到0X56对应主键值18 ；然后在聚簇索引，根据18 找到对应行数据。 8.1 看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，这不是多此一举吗？聚簇索引的优势在哪？ 重复访问同一页更快：由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘； B+树的每个节点的数量都是一个mysql分区页的大小(阿里面试) 。 辅助索引使用主键值作为指针： 辅助索引使用主键作为&quot;指针&quot;而不是使用地址值作为指针（MyISAM） ，减少了当出现【行移动】或者数据页分裂时（地址值变化）辅助索引的维护工作 。 8.2 为什么name,age这些字段不适合做索引？ 在InnoDB中每一个表都会有聚集索引，如果表定义了主键，则（默认）主键就是聚簇索引。 一个表只有一个聚集索引，其余为普通索引。所以name，age就是普通索引，也就是作为辅助索引。 在使用普通索引name查询时，会先加载普通索引： （1）通过普通索引查询到实际行的主键 （2）再使用主键通过聚集索引查询相应的行 （3）以此循环查询所有的行 若直接全量搜索聚集索引，则不需要在普通索引和聚集索引中来回切换。相比两种操作的总开销可能扫描全表效率更高。 9. MySQL联合索引如何使用？什么是最左匹配原则？ 参考：https://blog.csdn.net/Abysscarry/article/details/80792876 对多个字段同时建立的索引(有顺序，ABC，ACB是完全不同的两种联合索引。 1234567891011CREATE TABLE `test` ( `id` int(4) NOT NULL AUTO_INCREMENT, `a` varchar(10) NOT NULL, `b` varchar(10) NOT NULL, `c` varchar(10) NOT NULL, `d` varchar(10) NOT NULL, `e` varchar(10) NOT NULL, PRIMARY KEY (`id`), # 联合索引(a,b,c) UNIQUE KEY `idx_a_b_c` (`a`,`b`,`c`) USING BTREE ) ENGINE=I 以联合索引(a,b,c)为例： 建立这样的索引相当于建立了索引a、ab、abc三个索引。一个索引顶三个索引当然是好事，毕竟每多一个索引，都会增加写操作的开销和磁盘空间的开销。 a,c组合也可以但不是为他建立了索引，但实际上只用到了a的索引，c并没有用到！ 最左匹配原则 最左优先，在检索数据时从联合索引的最左边开始匹配，即是where条件必须有联合索引的第一个字段。 不包含第一个字段 不会走索引 1select * from test where b = &#x27;333&#x27; and c = &#x27;333&#x27;; where和索引顺序不一样 会走索引，和顺序无关。 where 后面列的顺序是被优化器优化了的，所以才会觉得无影响，你可以查看一下优化器优化后的语句，会帮你调整为满足最左前缀的顺序。 1select * from test where c = &#x27;333&#x27; and b = &#x27;333&#x27; and a = &#x27;333&#x27;; 9.1 联合索引的好处？ 10. （还要补充）介绍一下索引失效的原因？ 很不错的一篇文章：索引失效原理，终于有人讲明白了 结合这篇文章：https://juejin.cn/post/6844904073955639304 假设mysql 存在联合索引（a,b），显然也是一颗B+树: 不符合最左匹配失效 情况1 ：select * from testTable where b=2 联合索引是通过第一个索引a 来构建B+树，进行定位二分查找的，不能直接通过b 来进行二分查找。 情况2：like查询失效 12345where name like &quot;a%&quot; # 会有效，因为可以匹配到首字母where name like &quot;%a%&quot; # 首字母是任意匹配的，所以索引用不上where name like &quot;%a&quot; # 同上，不能根据尾字母来索引 范围查询失效 1select * from testTable where a&gt;1 and b=2 首先a字段在B+树上是有序的，所以可以用二分查找法定位到1，然后将所有大于1的数据取出来，a可以用到索引。 b有序的前提是a是确定的值，那么现在a的值是取大于1的，可能有10个大于1的a，也可能有一百个a。 大于1的a那部分的B+树里，b字段是无序的（开局一张图），所以b不能在无序的B+树里用二分查找来查询，b用不到索引。 多个单列索引 我们首先建立了三个单列索引：userid，mobile，billMonth。然后使用以下查询语句： 1EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE userid=&#x27;2222&#x27; AND mobile=&#x27;13281899972&#x27; AND billMonth=&#x27;2018-04&#x27; explain 结果分析，最终只有userid 这一个索引有效。 此处userid 、mobile 、billMonth这三个索引列都能用，只不过优化器判断使用userid这一个索引能最高效完成本次查询，故最终explain展示的key为userid。 特别的，如果改为 or 进行判断： 1EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE userid=&#x27;2222&#x27; OR mobile=&#x27;13281899972&#x27; 此时两个索引 userid &amp; mobile都用上了。 mysql 5.0 版本之前 使用or只会用到一个索引, 自从5.0版本开始 ，引入了index_merge索引合并优化！也就是说，我们现在可以利用上多个索引去优化or查询了。 或者索引加上了运算 1select * from t where c - 1 = 1000; 这种情况不会有效，应该是： 1select * from t where c = 1000 + 1; 又比如用了函数操作： 1select * from t where pow(c,2) = 1000; 11. 【⚠️ 新增】索引实战篇 参考：https://zhuanlan.zhihu.com/p/115778804 where a=xxx and b=xxx order by c ，如何建立索引？ 建立联合索引（a,b,c） ，因为这样的话无需做一次额外的排序操作。 因为建立联合索引时，根据最左匹配原则，先按a排序，再按b排序，最后按c 排序。根据联合索引检索到，a=xxx and b=xxx条件时，再去检索c本身已排序的。那么不用 order by c ，不用进行文件排序。 注意，建立联合索引 （a,b） , 则是走不到 sort的！ where a=xxx order by b,c ，如何建立索引？ 道理同上，建立（a,b,c） 。 where a &gt; 1 ORDER BY b，怎么建立索引？ 建立索引（a）即可，因为a是范围查询： 建立（a,b）的 话b也用不上，因为是a是范围查询； 建立（b,a）, b按索引排好序，a&gt;1可以用上？错误，因为先where筛选才会order by！ where a=1 and b=2 and c&gt;3 and d=4 ，如何建立索引？ 建立联合索引，(a,b,d,c) 即可。 但是对于建立(a,b,c,d) ，a,b,c三个字段能用到索引，而d就匹配不到，因为遇到了范围查询，在c&gt;3这个范围内，d不是有序的；但是c=3，这个范围内，d是有序的！ where a &gt; 1 and b = 2 and c &gt; 3，如何建立索引？ 建立（b,c）或者（b,a）即可，但至少有一个索引要失效（遇上范围查询）。 WHERE a IN (1,2,3) and b &gt; 1，怎么建立索引？ 还是对(a，b)建立索引，因为IN在这里可以视为等值引用，不会中止索引匹配，所以还是(a,b)！ 11.1 有个字段值可能正，可能负，查询该字段要绝对值，但计算会导致索引失效，怎么优化？ 拆成两列1列只存绝对值，另起一列tinyint来表示正负或者方向； 先查询到结果，然后再查询的结果上进行操作（取绝对值）？ 12. order by 怎么进行排序的？怎么优化？ 参考：https://segmentfault.com/a/1190000040357292 假设存在以下数据： 此时进行如下查询： 1select city, order_num, user_code from `order` where city=&#x27;广州&#x27; order by order_num limit 1000; 建立索引(city)：order by过程 1ALTER TABLE `order` ADD INDEX city_index ( `city` ); 用 explain 看看执行情况 注意到最后一个 extra 字段的结果是：Using filesort，表示需要排序。其实 MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。 完整执行过程 初始化 sort_buffer，放入 city、order_num、user_code 这三个字段； 从索引 city 找到第一个满足 city=’ 广州’条件的主键 id，也就是图中的 ID_3； 到主键 id 索引取出整行，取 city、order_num、user_code 三个字段的值，存入 sort_buffer 中； 从索引 city 取下一个记录的主键 id； 重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_X； 对 sort_buffer 中的数据按照字段 order_num 做快速排序； 其中，按 order_num 排序这个步骤，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size。 按照排序结果取前 1000 行返回给客户端。 优化1：使用rowid 上面的全字段排序其实会有很大的问题，你可能发现了。我们需要查询的字段都要放到 sort_buffer 中，如果查询的字段多了起来，内存占用升高，就会很容易打满 sort_buffer 。 sort_buffer 只存 order_num 和 id 字段。 初始化 sort_buffer，确定放入两个字段，即 order_num 和 id； 从索引 city 找到第一个满足 city=’ 广州’条件的主键 id，也就是图中的 ID_3； 回表，取 order_num、id 这两个字段，存入 sort_buffer 中； 从索引 city 取下一个记录的主键 id； 重复步骤 3、4 直到不满足 city=’ 广州’条件为止，也就是图中的 ID_X； 对 sort_buffer 中的数据按照字段 order_num 进行排序； 遍历排序结果，取前 1000 行，再次回表取出 city、order_num 和 user_code 三个字段返回给客户端。 优化2：建立联合索引 参见索引部分解释，不再赘述。 从索引 (city,order_num) 找到第一个满足 city=’ 广州’条件的主键 id； 回表，取 city、order_num、user_code 三个字段的值，作为结果集的一部分直接返回； 从索引 (city,order_num) 取下一个记录主键 id； 重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’ 广州’条件时循环结束。 5.3 事务相关 1.请介绍一下数据库事务？和事务特性（ACID）？ 数据库事务： 数据库事务指的是一组数据操作，事务内的操作要么就是全部成功，要么就是全部失败。 e.g. 假设一个网购付款的操作，用户付款后要涉及到订单状态更新、扣库存以及其他一系列动作，这就是一个事务，如果一切正常那就相安无事，一旦中间有某个环节异常，那整个事务就要回滚，总不能更新了订单状态但是不扣库存吧。 事务特性：（1） 原子性（Atomicity）：一个事务必须视为一个不可分割的最小工作单元，要么都成功要么都失败（2）一致性（Consistency）：数据库总能从一个一致性的状态转换到另一个一致性的状态（3）隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的（4）持久性（Durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中 1.1 四大特性得不到保障会出现什么情况？ 我们以从A账户转账50元到B账户为例进行说明一下ACID这四大特性。 原子性 : 原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。即要么转账成功，要么转账失败，是不存在中间的状态。 如果无法保证原子性会怎么样？ 会出现数据不一致的情形，A账户减去50元，而B账户增加50元操作失败。系统将无故丢失50元~ 一致性 ：一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的。 那什么是合法的数据状态呢？这个状态是满足预定的约束就叫做合法的状态，再通俗一点，这状态是由你自己来定义的。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的。 如果无法保证一致性会怎么样？ 例一: A账户有200元，转账300元出去，此时A账户余额为-100元。 你自然就发现了此时数据是不一致的，为什么呢？因为你定义了一个状态，余额这列必须大于0。 例二：A账户200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。 你也知道此时数据是不一致的，为什么呢？因为你定义了一个状态，要求A+B的余额必须不变。 隔离性 ：隔离性是指多个事务并发执行的时候，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 如果无法保证隔离性会怎么样？ 假设A账户有200元，B账户0元。A账户往B账户转账两次，金额为50元，分别在两个事务中执行。 如果无法保证隔离性，A可能就会出现扣款两次的情形，而B只加款一次，凭空消失了50元，依然出现了数据不一致的情形！ 持久性 : 根据定义，持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 如果无法保证持久性会怎么样？ 在MySQL中，为了解决CPU和磁盘速度不一致问题，MySQL是将磁盘上的数据加载到内存，对内存进行操作，然后再回写磁盘。好，假设此时宕机了，在内存中修改的数据全部丢失了，持久性就无法保证。 设想一下，系统提示你转账成功。但是你发现金额没有发生任何改变，此时数据出现了不合法的数据状态，我们将这种状态认为是数据不一致的情形。 1.2 数据库如何保证四大特性（如何实现事务）？ 数据库事务的 ACID 四大特性是事务的基础，了解了 ACID 是如何实现的，我们也就清楚了事务的实现，接下来我们将依次介绍数据库是如何实现这四个特性的。 保证原子性 主要是利用Innodb的undo log。 undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。 例如 (1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据 (2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作 (3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操 undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。 保证一致性 数据库对于 ACID 中的一致性的定义是这样的：如果一个事务原子地在一个一致地数据库中独立运行，那么在它执行之后，数据库的状态一定是一致的。 它的第一层意思就是对于数据完整性的约束，包括主键约束、引用约束以及一些约束检查等等，在事务的执行的前后以及过程中不会违背对数据完整性的约束，所有对数据库写入的操作都应该是合法的，并不能产生不合法的数据状态。 第二层意思其实是指逻辑上的对于开发者的要求，我们要在代码中写出正确的事务逻辑，比如银行转账，事务中的逻辑不可能只扣钱或者只加钱，这是应用层面上对于数据库一致性的要求。 保证隔离性 在 SQL 标准中定义了四种数据库的事务的隔离级别：READ UNCOMMITED、READ COMMITED、REPEATABLE READ 和 SERIALIZABLE； 数据库对于隔离级别的实现就是使用并发控制机制对在同一时间执行的事务进行控制： 锁： MySQL 和常见数据库中的锁都分为两种，共享锁（Shared）和互斥锁（Exclusive），前者也叫读锁，后者叫写锁。 mvcc实现：实现RC和RR。 保证持久性 利用Innodb的redo log，为什么要使用redo log，请看下面： 正如之前说的，Mysql是把磁盘上的数据先加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失； 如果事务提交前直接把数据写入磁盘，只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。 redo log解决方案： 当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作； 当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)； 当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和binlog内容决定回滚数据还是提交数据。 1.3 binlog日志是做什么的？ 参考：https://www.cnblogs.com/kevingrace/p/5907254.html MySQL的二进制日志binlog可以说是MySQL最重要的日志，它记录了所有的DDL和DML语句（除了数据查询语句select），以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。 DDL ，即 Data Definition Language 数据库定义语言。 主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。 DML，即Data Manipulation Language 数据操纵语言。 主要的命令是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言。 binlog日志有两个最重要的使用场景： MySQL主从复制：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves来达到 master-slave数据一致的目的。 自然就是数据恢复了，通过使用mysqlbinlog工具来使恢复数据。 2.介绍一下（并发）事务不同隔离级别？对应可能出现的问题？ 参考：https://www.cnblogs.com/shan-kylin/p/9543294.html 下面排它锁和共享锁都是行锁，锁住一行。 Read uncommitted： 顾名思义，就是一个事务可以读取另一个未提交事务的数据。但这种情况会出现脏读： 因为写数据的时候添加一个X锁（排他锁，拿到锁的事务可以写，其它事务只能等待阻塞）；但读不受限制，读不加锁。 由于读不加锁，读的是可能是修改前（未提交）的数据，也就是脏读。 Read Committed ：写数据的时候加上X锁（排他锁），读数据的时候添加S锁（共享锁，拿到锁的事务可以查看但无法修改和删除，其它事务【只能加S锁】【不能加其它锁】如X锁）。解决脏读，但会导致出现不可重复读的问题。 初始x=100,； 事务A读x，加上S锁，读到x=100，立即释放S锁且未提交； 事务B修改x，加上X锁，修改x=50，提交 ； 事务A再次读取x，加上S锁，读取x=50，发现和第一次读取不一致，提交事务。 上述过程，事务A在提交前读取两次不一样的x值，为不可重复读。 Repeatable read ：MySQL 默认隔离界别 , 开始读取数据（事务开启）时，【S】锁不再立即释放，其它事务就不能加上【X】锁修改数据。解决了脏读、不可重复读，但是可能会出现幻读：- Mysql官方给出的幻读解释是：只要在一个事务中，第二次select（读）多出了row就算幻读。 现在做如下修改： 写：X锁保持不变 读：S锁，读完不再立即释放，而是在提交的时候再释放。 这样的话，保证事务A在提交前，读取的x是一致的。解决了不可重复读，但依旧可能出现幻读。例如，X锁不能阻止（表中其它记录）插入操作，因为只锁住了当前记录，是行级锁。 事务A加上X锁，更新了所有用户年龄从20→18； 过一会儿再读发现还有一个用户没修改，还是20岁？出现幻觉了吗？ 这是因为，其它事务B同时插入了一行新数据，年龄就是20岁。所以再读发现没修改。 Serializable： 序列化，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。耗费性能，一般不用。 2.1【猿辅导】 怎么解决幻读？ 解决幻读使用两种方式： 间隙锁 间隙锁（Gap Lock）：当我们用【范围条件】而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁； 举例： 假如user表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL： 1select * from user where user_id &gt; 99 for update; 是一个范围条件的检索，InnoDB不仅会对（1）符合条件的user_id值（100、101）的记录加锁，也会对（2）user_id大于101（这些记录并不存在）的“间隙”加锁。 如何解决幻读？ 产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”，导致下次读取产生幻读。如果锁住了间隙，自然也就没锁的问题了。 mvvc 在RR（可重复读级别下）不会出现幻读。例如： 开启事务1，获得事务ID为1。 事务1执行查询，得到readview。 开始事务2。 执行insert。 提交事务2。 执行事务1的第二次查询 (因为这里是RR级别，所以不会再去获得readview，还是使用第一次获得的readview，所以当前read view 事务的ID不会更新，即不会加入插入事务2) 最后得到的结果是，插入的数据不会被读取显示，因为插入的数据事务ID &gt; readview里的最大活跃事务ID。 5.4 MySQ优化 0. 分页查询慢的原因？如何优化？ 参考：https://juejin.cn/post/6844904141878214664 在偏移量非常大的时候，也就是翻页到很靠后的页面时，查询速度会变得越来越慢，例如： 1select * from t_order order by id limit 1000000000, 10; 这是因为，需要查询 100000000010 (100000000000 + 10) 条记录，然后只返回最后 10 条，并将前面的 100000000000 条记录抛弃，这样当翻页越靠后时，代价就变得越来越高。 优化方法： 最大id法 举例：查询第一页的时候是limit 400000,10 查询到的最后一条id是4000000，那么下一页的查询只需要查询id大于400000的10条数据即可。 语句： 1explain select * from user where id &gt; 4000000 limit 10; BETWEEN … AND 1select * from user where id BETWEEN 4000000 and 4000010 分表查询 mysql推荐一张表的存储不要超过500w数据，查询400w不到1秒对于一般的查询来说已经可以了，如果还要更快的话，我建议使用分表存储，分表又分两种情况，水平分表于垂直分表。 延迟关联（个人推荐） 1select * from table a,(select id from table limit 100000,20) b on a.id=b.id 1. SQL优化手段有哪些？ 查询语句中不要使用select 尽量减少子查询，使用关联查询（left join,right join,inner join）替代 减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代(在确认没有重复数据或者不用剔除重复数据时，union all会更好) 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 2.请问如何防止SQL被注入？ 什么是SQL注入？ 攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。 例如：用户登录，攻击者输入：用户名 = liangzone，密码 = ‘ or ‘1’=’1 ，那么拼接后的语句是： 1select * from user where name = ‘lianggzone’ and password = ‘’ or ‘1’=‘1’ 攻击者就可以查询出所有的用户表信息！ 如何防范SQL注入？ Web端：1）有效性检验； 2）限制字符串输入的长度 服务器端：1）不用拼接SQL字符串， 2）使用预编译的PrepareStatement， 3）有效性检验，4）过滤SQL需要的参数中的特殊字符，比如单引号、双引号。 3. MySQL 如何做到高并发解决方案？ 在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。 增加数据库索引，进而提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢） 主从读写分离分库，让主服务器负责写，从服务器负责读。 将数据库表进行拆分表，使得数据库的表尽可能小，提高查询的速度。 使用分布式架构，分散计算压力。 4. 大表如何进行优化？ 当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，⼀些常⻅的优化措施如下。 限定数据的范围：务必禁⽌不带任何限制数据范围条件的查询语句。⽐如：我们当⽤户在查询订单历史的时候，我们可以控制在⼀个⽉的范围内； 读/写分离：经典的数据库拆分⽅案，主库负责写，从库负责读； 垂直分区：根据数据库⾥⾯数据表的相关性进行拆分。 例如，⽤户表中既有⽤户的登录信息⼜有⽤户的基本信息，可以将⽤户表拆分成两个单独的表，甚⾄放到单独的库做分库。 简单来说垂直拆分是指数据表列的拆分，把⼀张列⽐较多的表拆分为多张表。 水平分区 : 保持数据表结构不变，通过某种策略存储数据分⽚。这样每⼀⽚数据分散到不同的表或者库中，达到了分布式的⽬的。 ⽔平拆分可以支撑⾮常大的数据量。 其它数据库结构方面优化： 范式优化： 比如消除冗余（节省空间。。） 反范式优化：比如适当加冗余等（减少join） 5. 数据库如何去重？ 参考：MySQL数据库行去重复和列去重复 5.1 行去重 存在行重复，则无法建立 唯一索引 等。 用distinct 得到我们要保留的数据也是可以的。 下面假设的是email字段重复。 查看我们的分组后 1select *,count(id) from demo_table group by email having count(id)&gt;1 order by id; 执行结果： 12345678910+----+------+--------------+-----------+| id | name | email | count(id) |+----+------+--------------+-----------+| 1 | u1 | u1@email.com | 4 || 2 | u2 | u2@email.com | 4 || 3 | u3 | u3@email.com | 3 || 4 | u4 | u4@email.com | 2 || 5 | u5 | u5@email.com | 2 |+----+------+--------------+-----------+5 rows in set (0.00 sec) 保留每个分组最小的id，表中其余都删除 在表中删除不符合要求的数据： 1delete from demo_table where id not in (select min(id) from demo_table group by email); 但是似乎有保护机制，无法直接删除： 1ERROR 1093 (HY000): You can&#x27;t specify target table &#x27;demo_table&#x27; for update in FROM clause 创建临时表再删除 12345678# 创建临时表保存每个分组中最小的那个idcreate table tmp_table as select min(id) from demo_table group by email;# 删除表中数据delete from demo_table where id not in (select * from tmp_table);# 删除临时表drop table tmp_table; 5.2 列重复 先找到重复字段的行 1select * from demo_table as a, demo_table as b where a.id=b.id and a.name=b.email; 执行结果： 12345678910+----+--------------+--------------+----+--------------+--------------+| id | name | email | id | name | email |+----+--------------+--------------+----+--------------+--------------+| 31 | 31@email.com | 31@email.com | 31 | 31@email.com | 31@email.com || 32 | 32@email.com | 32@email.com | 32 | 32@email.com | 32@email.com || 33 | 33@email.com | 33@email.com | 33 | 33@email.com | 33@email.com || 34 | 34@email.com | 34@email.com | 34 | 34@email.com | 34@email.com || 35 | 35@email.com | 35@email.com | 35 | 35@email.com | 35@email.com |+----+--------------+--------------+----+--------------+--------------+5 rows in set (0.00 sec) 重复记录的id都已经找出来了，删除就参考上述方式处理了。 6. select慢的原因？慢查询的优化策略？ 6.1 select 很慢的原因 参考：腾讯面试：一条SQL语句执行得很慢的原因有哪些? 如果是偶尔很慢 针对这种情况，这条SQL语句的书写本身是没什么问题的。可能是其它原因导致： 被加锁。 要执行的这条语句，刚好这条语句涉及到的表，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了；或者，表没有加锁，但要使用到的某个一行被加锁了 。 数据库在刷新脏页 ？ 看链接，不太明白流程。 如果是经常很慢 没用到索引 索引失效了 ： （1）联合索引不满足最左匹配（不包含第一个索引）； （2）like语句不满足最左匹配（不包含第一个索引） （3）或者索引加上了运算 1select * from t where c - 1 = 1000; 这种情况不会有效，应该是： 1select * from t where c = 1000 + 1; （4）或者函数操作用上索引 1select * from t where pow(c,2) = 1000; 数据库使用非聚簇索引 我们在进行查询操作的时候，例如： 1select * from t where 100 &lt; c and c &lt; 100000; 此时使用的非聚簇索引（辅助索引），只是存储了主键的key ，还是要再次通过聚簇索引去查找。效率可能不必全表扫描高。 7. select…for update用法？ 数据库-MySQL中for update的作用和用法 for update是一种行级锁，又叫排它锁。 一旦用户对某个行施加了行级加锁，则该用户可以查询也可以更新被加锁的数据行，其它用户只能查询但不能更新被加锁的数据行。 123456-- 开启事务begin;SELECT * FROM user WHERE id=3 FOR UPDATE;SELECT * FROM user WHERE id=3 and name=&#x27;Tom&#x27; FOR UPDATE;-- 提交事务commit; 8. 场景题：假如选择MySQL数据库，一天五万条增量，运维三年，有哪些优化手段？ 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率； 选择合适的表字段数据类型和存储引擎，适当的添加索引； MySQL库主从分库读写分离； 找规律分表，减少单表中的数据量提高查询速度； 添加缓存机制，比如Memcached，Apc等； 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE。","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"MySQL","slug":"MySQL","permalink":"https://hwh.zone/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://hwh.zone/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"校招笔记（四）_计算机基础_操作系统","slug":"校招笔记（四）_计算机基础_操作系统","date":"2021-11-26T12:55:27.544Z","updated":"2021-12-03T03:56:06.218Z","comments":true,"path":"p/15646/","link":"","permalink":"https://hwh.zone/p/15646/","excerpt":"","text":"我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。 备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 四、操场系统 4.1 操作系统基础 0. （百度安全一面） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？ 存储器：内存 控制器：南桥北桥 运算器：CPU 输入设备：键盘 输出设备：显示器、网卡 1. 什么是操作系统？ 操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基⽯； 操作系统本质上是运行在计算机上的软件程序 ； 操作系统为用户提供⼀个与系统交互的操作界面 ； 操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。 2. 什么是系统调用呢？ 能不能详细介绍⼀下？ 根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别： 用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。 系统态(kernel mode)：可以简单的理解系统态运行的进程或程序⼏乎可以访问计算机的任何资源，不受限制。 我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！ 这些系统调用按功能大致可分为如下⼏类： 设备管理。完成设备的请求或释放，以及设备启动等功能。 ⽂件管理。完成⽂件的读、写、创建及删除等功能。 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。 进程通信。完成进程之间的消息传递或信号传递等功能。 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。 3. CentOS 和 Linux的关系？ Linux意思较广广义的范围，多指是Linux内核。CentOS是RedHat的一个分支，RedHat是Linux的一个发行版本，RedHat与CentOS的区别在于，RedHat收费，CentOS免费。 4. 什么是分布式，优缺点？集群？ 分布式 根据业务需求进行拆分成N个子系统，多个子系统相互协作才能完成业务流程子系统之间通讯使用RPC远程通讯技术。 集群 同一个工程部署在多个不同的服务器上。 分布式优点 1.把模块拆分，使用接口通信，降低模块之间的耦合度。 2.把项目拆分成若干个子项目，不同的团队负责不同的子项目。 3.增加功能时只需要再增加一个子项目，调用其它系统的接口就可以。 4.可以灵活的进行分布式部署。 分布式缺点 1.系统之间交互需要使用远程通信，接口开发增加工作量。 2.各个模块有一些通用的业务逻辑无法共用。 5. 在Linux/windows栈空间的大小？ Linux环境下由操作系统决定，一般是8KB ， 通过ulimit命令查看以及修改 在Linux下通过如下命令可查看和设置栈的大小： 12$ ulimit -a # 显示当前栈的大小 （ulimit为系统命令，非编译器命令） $ ulimit -s 32768 # 设置当前栈的大小为32MCopy to clipboardErrorCopied Windows环境下由编译器决定，VC++6.0一般是1M \\ Windows平台下栈的大小是被记录在可执行文件中的（由编译器来设置)，即：windows下可以由编译器决定栈大小，而在Linux下是由系统环境变量来控制栈的大小的。 6. ASCII、Unicode和UTF-8编码的区别？ ASCII : ASCII 只有127个字符，表示英文字母的大小写、数字和一些符号 ； 常用中文需要两个字节，且不能和ASCII冲突，中国定制了GB2312编码格式。 Unicode： Unicode就是将不同语言统一到一套编码格式中，通常两个字节表示一个字符，而ASCII是一个字节表示一个字符 ； 如果你编译的文本是全英文的，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。 UTF-8 : 把Unicode编码转化为 “可变长编码” UTF-8编码，UTF-8编码将Unicode字符按数字大小编码为1-6个字节，英文字母被编码成1个字节，常用汉字被编码成2个字节。 6.1 三者区别和联系 在计算机内存中，统一使用Unicode编码 ； 当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码 举例说明： 例1 ：记事本编辑（内存）→保存（磁盘）。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。 例2：网络传输服务器→浏览器。 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。 7. 什么是并发和并行？同步和异步？ 并发和并行 并发： 是指宏观上在一段时间内能同时运行多个程序； 并行 ：则指同一时刻能运行多个指令。 同步和异步 同步：可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。 异步：执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 8. 什么是共享？ 共享定义： 系统中的资源可以被多个并发进程共同使用 ； 共享方式：互斥共享和同时共享： 互斥共享： 在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问 ，如：打印机。 4.2 进程和线程 1.请问64位和32位的区别？ 运行能力不同：64位可以一次性可以处理8个字节的数据量，而32位一次性只可以处理4个字节的数据量，因此64位比32位的运行能力提高了一倍。 内存寻址不同：64位最大寻址空间为2的64次方，理论值直接达到了16TB，而32位的最大寻址空间为2的32次方，为4GB，换而言之，就是说32位系统的处理器最大只支持到4G内存，而64位系统最大支持的内存高达亿位数。 运行软件不同：由于32位和64位CPU的指令集是不同的。所以需要区分32位和64位版本的软件。 为了保证兼容性，64位CPU上也能运行老的32位指令，但反过来32位系统不可以运行64位的软件。 2.介绍一下线程和进程的区别？ 根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小 包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程 内存分配：同一进程的线程共享本进程的【地址空间和资源】，而进程之间的地址空间和资源是相互独立的 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉，所以多进程要比多线程健壮。 线程没有独立的地址空间，如果崩溃，会发信号，如果没有错误处理的handler，OS一般直接杀死进程。 能否独立：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行 2.1 线程和协程之间的区别？ 进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序 ; 线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，和多个线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束； 协程是用户态的轻量级线程，也是线程内部调度的基本单位 。 协程和线程的区别如下（补充了和进程的区别，方便对比）。 进程 线程 协程 定义 资源分配和拥有的基本单位 程序执行的基本单位 用户态的轻量级线程，线程内部调度的基本单位 切换情况 进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置 保存和设置程序计数器、少量寄存器和栈的内容 先将寄存器上下文和栈保存，等切换回来的时候再进行恢复 切换者 操作系统 操作系统 用户 切换过程 用户态-&gt;内核态-&gt;用户态 用户态-&gt;内核态-&gt;用户态 用户态(没有陷入内核) 调用栈 内核栈 内核栈 用户栈 拥有资源 CPU资源、内存资源、文件资源和句柄等 程序计数器、寄存器、栈和状态字 拥有自己的寄存器上下文和栈 并发性 不同进程之间切换实现并发，各自占有CPU实现并行 一个进程内部的多个线程并发执行 同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理 系统开销 切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大 切换时只需保存和设置少量寄存器内容，因此开销很小 直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快 通信方面 进程间通信需要借助操作系统 线程间可以直接读写进程数据段(如全局变量)来进行通信 共享内存、消息队列 2.2 一个进程可以创建多少个线程，和什么有关？ 一个进程可用虚拟空间是（C++）2G，默认情况下，（假设）线程的栈的大小是1MB（Linux是8kb），则理论上最多只能创建2048个线程。如果要创建多于2048的话，必须修改编译器的设置。 2.3 进程之间的同步方式？（区分通信方式） 临界区。 对临界资源进行访问的那段代码称为临界区。 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。 同步和互斥。 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。 互斥：多个进程在同一时刻只有一个进程能进入临界区。 信号量。 常见的 P 和 V 操作。 特别的，如果信号量的取值只能为 0 或者 1，那么就成为了互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。 条件变量。 使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。 管程引入了条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。 123456789101112131415161718192021222324252627282930313233343536373839404142// 管程：解决生产者、消费者问题monitor ProducerConsumer condition full, empty; integer count := 0; condition c; procedure insert(item: integer); begin if count = N then wait(full); insert_item(item); count := count + 1; if count = 1 then signal(empty); end; function remove: integer; begin if count = 0 then wait(empty); remove = remove_item; count := count - 1; if count = N -1 then signal(full); end;end monitor;// 生产者客户端procedure producerbegin while true do begin item = produce_item; ProducerConsumer.insert(item); endend;// 消费者客户端procedure consumerbegin while true do begin item = ProducerConsumer.remove; consume_item(item); endend; 3.请问【进程】之间如何进行通信？ 可以分为如下两个方面： 本地进程之间的通信方式 远程进程之间的通信方式 1. 本地进程之间的通信方式（没有同步互斥！！） 无名管道 ：半双工通信方式，数据(消息)单向流动，只能是字节流格式的消息。 优点：简单方便 缺点：单向通信、只能用于具有亲缘关系（一般指父子）的进程之间、缓冲区有限 有名管道：半双工通信方式，数据也称为命名管道：是一种文件类型，以一种特殊设备文件形式存在于文件系统中。 优点：可以实现任意关系的进程间的通信（无法同步） 缺点： 长期存于系统中，使用不当容易出错、缓冲区有限 消息队列：消息队列是消息的链表,存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少,管道只能承载无格式字节流以及缓冲区大小受限等特点。 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题 缺点：信息的复制需要额外消耗CPU的时间，不适宜于信息量大或操作频繁的场合 共享内存 直接对内存存取，通信快，但是多个进程可以同时操作，需要用信号量进行同步。 信号量 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 优点：可以同步进程； 缺点：信号量有限 注解：P操作就是对S减一，V操作就是对S加一 同步：S = 0，进程A执行完进行V操作，进程B执行前执行P操作，这样B就可以等A执行完再执行； 互斥：S = 1，进程执行前进行P操作，执行后进行V操作。 2.远程进程之间的通信方式 首要解决的问题是如何唯一标识一个进程？本地上采用PID即可，但是网络中 TCP/IP五层网络模型中传输层的 “套接字：IP+端口” 套接字交互 优点：1）传输数据为字节级，传输数据可自定义，数据量小效率高；2）传输数据时间短，性能高；3) 适合于客户端和服务器端之间信息实时交互；4) 可以加密,数据安全性强 缺点：1) 需对传输的数据进行解析，转化成应用级的数据。 远程过程调用（RPC） 4. 请问【线程】间同步方式（通信方式）？ 【1. Linux下线程通知方式】 互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有⼀个，所以可以保证公共资源不会被多个线程同时访问。 ⽐如 Java 中的synchronized 关键词和各种 Lock锁 都是这种机制。 信号量(Semphares) ：它允许同⼀时刻多个线程访问同⼀资源，但是需要控制同⼀时刻访问此资源的最大线程数量 条件变量 : 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级 比如Wait/Notify 【2. Windows下线程通知方式】 全局变量：需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防编译器对此变量进行优化 ； CEvent对象：CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法； Message消息机制：常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。 5.什么时候用多线程 / 多进程？ 需要频繁创建销毁的优先用线程 ：创建和销毁的代价是很难承受的 ； 需要进行大量计算的优先使用线程 ：此时耗费很多CPU，切换频繁，用线程更轻量； 任务间相关性比较强的用多线程，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单； 考虑多进程： 扩展到多机分布的用多进程，多核分布的用多线程 ； 其它一般用多线程比较好 6.【线程】调度算法？ 在资源一定的情况下，调度算法需要在吞吐量（Throughput）、平均响应时间（延迟，Average Response Time）、公平性、调度引起的额外开销（overhead）等几个方面做权衡。 先进先出算法（FIFO，First-In-First-Out） 优点： 最少的任务切换开销（因为没有在任务执行过程中发生切换，故任务切换开销为0） 最大的吞吐量（因没有任务切换开销，在其他一定的情况下，吞吐量肯定是最大的） 最朴实的公平性（先来先做） 缺点： 平均响应时间高：耗时只需10毫秒的任务若恰巧在耗时1000毫秒的任务后到来，他则需要1010毫秒才能执行完成，绝大部分时间都花在等待被调度。 最短耗时任务优先算法 优先调度耗时短的任务，需要预先知道每个任务的耗时情况，这在实际情况中是不大现实的。 （优点）平均响应时间较低：这里有一点，因为将时间长的任务无限往后推移，实际计算的平均响应时间的任务都是执行较快的任务，统计出来的平均响应时间必然较低的。 （缺点）耗时长任务饥饿：耗时长的任务迟迟得不到调度，不公平，容易形成饥饿 。 （缺点）开销大：频繁的任务切换，调度的额外开销大。 时间片轮转算法 给队列中的每个任务一个时间片，第一个任务先执行，时间片到了之后，将此任务放到队列尾部，切换到下个任务执行，解决最短耗时任务优先算法中耗时长任务饥饿的问题 。 （特点）时间片设置问题： 算法介于FIFO和SJF之间，若时间片足够大，则退化到FIFO ；若分片足够小（假设不考虑任务切换的开销），则任务的完成时间顺序是以耗时从小到大排列。 （优点）公平调度：每个任务都能够得到公平的调度 （优点）不会饥饿：耗时短的任务即使落在耗时长的任务后面，也能够较快的得到调度执行 （缺点）开销大：任务切换引起的调度开销较大，需要多次切换任务上下文 （缺点）时间片不太好设置 最大最小公平算法 7.【进程】调度算法？ 先来先服务调度算法 短作业(进程)优先调度算法 时间片轮转法 多级反馈队列调度算法 优先权调度算法 8. CPU上下文切换？有什么类型？线程发生在什么地方？ 参考：https://zhuanlan.zhihu.com/p/52845869 什么是 CPU 上下文 ？ CPU 寄存器和程序计数器 就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前，必须的依赖环境。 CPU 寄存器 是 CPU 内置的容量小、但速度极快的内存。 什么是 CPU 上下文切换? 通常指以下过程： 前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来; 然后加载新任务的上下文到这些寄存器和程序计数器; 最后再跳转到程序计数器所指的新位置，运行新任务。 CPU 上下文切换的类型？ 根据任务的不同，可以分为以下三种类型 : 进程上下文切换 - 线程上下文切换 - 中断上下文切换 。 进程上下文切换 进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。 内核空间（Ring 0）具有最高权限，可以直接访问所有资源； 用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。 从用户态到内核态的转变，需要通过系统调用来完成，在这个过程中就发生了 CPU 上下文切换（两次，用户态-内核态-用户态））。 系统调用 : 查看文件时read()、wirte() 操作就发生了系统调用。 但是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。 而进程上下文切换 ，比系统调用时多了一步：在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来。 线程上下文调用 线程是调度的基本单位，而进程则是资源拥有的基本单位。 【面试高频】发生线程上下文切换的场景 前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。 前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据（栈、寄存器等)不共享的数据 中断上下文切换 9.如何杀死一个进程？进程终止的方式？ linux命令：kill -9 &lt;pid&gt; 接受能导致进程终止的信号：ctrl+c (^C)、SIGINT(SIGINT中断进程) main函数的自然返回，return 调用exit函数，属于c的函数库 3、调用_exit函数，属于系统调用 调用abort函数，异常程序终止，同时发送SIGABRT信号给调用进程 9.1 终端退出，终端运行的进程会怎么样？ 终端在退出时会发送SIGHUP给对应的bash进程， bash进程收到这个信号后首先将它发给session下面的进程 一个session就是一个shell终端会话窗口。 如果程序没有对SIGHUP信号做特殊处理，那么进程就会随着终端关闭而退出 9.2 怎么让进程后台运行？ 命令 + &amp; 即可，实际上，这样是将命令放入到一个作业队列中了 ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程 nohup + &amp;，将标准输出和标准错误缺省会被重定向到 nohup.out 文件中，忽略所有挂断（SIGHUP）信号 setsid + 命令，使其父进程编程init进程，不受HUP信号的影响 将命令+ &amp;放在()括号中，也可以是进程不受HUP信号的影响 10. 外中断和异常的区别？ 外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。 异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。 11. 什么是父进程、子进程、进程组、作业和会话？ 父进程： 已创建一个或多个子进程的进程 ； 子进程： 由fork创建的新进程被称为子进程（child process），函数被调用一次，但返回两次； fork之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系： （1）它们共享代码空间，（2）数据空间是互相独立的，但子进程数据空间中的内容是父进程的完整拷贝，（3）指令指针也完全相同，（4）子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同）。 除了：fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号pid 。 进程组： 进程组就是多个进程的集合，其中肯定有一个组长，其进程PID等于进程组的PGID ； 作业： shell分前后台来控制的不是进程而是作业（job）或者进程组（Process Group）。 一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，shell可以运行一个前台作业和任意多个后台作业，这称为作业控制。、 会话。 一个或多个进程组的集合，一个会话可以有一个控制终端。在xshell或者WinSCP中打开一个窗口就是新建一个会话。 12. 什么是守护进程、僵尸进程、孤儿进程？ 参考：Linux 之守护进程、僵死进程与孤儿进程 守护进程 在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。 举例：常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。 一个守护进程的父进程是init进程，也是一个孤儿进程 ，一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。 孤儿进程 一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 僵尸进程 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息（子进程必须等到父进程捕获到了子进程的退出状态才真正结束），那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。 11.1 如何避免僵尸进程？ 通过signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收； 如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN); 表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。 父进程调用wait/waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞； waitpid可以通过传递WNOHANG使父进程不阻塞立即返回。 如果父进程很忙可以用signal注册信号处理函数，在信号处理函数调用wait/waitpid等待子进程退出; 通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等待回收。 4.3 socket编程 暂略 4.4 内存管理 1.介绍一下操作系统的堆和栈？ 栈内存：栈内存首先是一片内存区域，存储的都是局部变量，栈内存的更新速度很快，因为局部变量的生命周期都很短。 局部变量：方法内的变量，for循环内部定义的也是局部变量等。 堆内存：存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象）。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。 1.1 什么时候会栈溢出？ 栈能使用的内存是有限的，一般是 1M~8M，这在编译时就已经决定了，程序运行期间不能再改变。 如果程序使用的栈内存超出最大值，就会发生栈溢出（Stack Overflow）错误，程序就崩溃了； 一般常见的情况，如递归过深 2. 介绍一下什么内存管理？常用的内存管理机制？ 内存管理 操作系统的内存管理主要负责内存的（1）分配与回收（malloc 函数：申请内存，free 函数：释放内存），（2）另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。 常用内存管理机制 简单分为连续分配管理方式和非连续分配管理方式这两种。连续分配管理方式是指为⼀个用户程序分配⼀个连续的内存空间，常见的如块式管理 。同样地，非连续分配管理方式允许⼀个程序使用的内存分在离散或者说不相邻的内存中，常见的如页式管理 和 段式管理。 块式管理 ： 远古时代的计算机操系统的内存管理方式。将内存分为⼏个固定大小的块，每个块中只包含⼀个进程。如果程序运行需要内存的话，操作系统就分配给它⼀块，如果程序运行只需 要很小的空间的话，分配的这块内存很大⼀部分⼏乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。 页式管理 ：把主存分为大小相等且固定的⼀页⼀页的形式，页较小，相对相⽐于块式管理的划分⼒度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。 段式管理 ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。段式管理把主存分为⼀段段的，每⼀段的空间⼜要⽐⼀页的空间小很多 。 但是，最重要的是段是有实际意义的，每个段定义了⼀组逻辑信息，例如，有主程段 MAIN、子程序段 X、数据段 D及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。 段页式管理机制 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲页，也就是说 段页式管理机制中段与段之间以及段的内部的都是离散的。 2.1 介绍一下逻辑地址和物理地址？ 我们编程⼀般只有可能和逻辑地址打交道，⽐如在 C 语⾔中，指针⾥面存储的数值就可以理解成为内存⾥的⼀个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。 物理地址指的是真实物理内存中地址，更具体⼀点来说就是内存地址寄存器中的地址。 2.2 操作系统在内存管理需要做什么？ 内存空间的分配与回收； 从逻辑上对内存空间进行扩充； 逻辑地址与物理地址的转换； 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。 3. 介绍一下快表和多级页表？ 在分页内存管理中，很重要的两点是： 虚拟地址到物理地址的转换要快。 解决虚拟地址空间大，页表也会很大的问题。 快表介绍 快表理解为⼀种特殊的高速缓冲存储器（Cache），其中的内容是页表的⼀部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。 但有时快表不命中要访问两次缓存，不过总体还是提高了性能。 多级页表介绍 引⼊多级页表的主要⽬的是为了 避免把全部页表⼀直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景。 4. 分页机制和分段机制的共同点和区别 ？ 共同点 ： 分页机制和分段机制都是为了提高内存利用率，较少内存碎片。 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。 区别 ： 页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。 分页仅仅是为了满⾜操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满⾜用户的需要。 5. 【待扩充】CPU 寻址了解吗?为什么需要虚拟地址空间? 现代处理器使用的是⼀种称为 虚拟寻址(Virtual Addressing) 的寻址⽅式。使用虚拟寻址，CPU 需要虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有⼀个被称为 内存管理单元（Memory Management Unit, MMU） 的硬件。 如果直接把物理地址暴露出来的话会带来严重问题，⽐如可能对操作系统造成伤害以及给同时运行多个程序造成困难。 6. 如果系统中具有快表后，那么地址的转换过程变成什么样了？ 简单来说：cup计算页号 → 快表查询是否有该页号 → 否则页表查询 计算页号和页偏移量。 CPU给出逻辑地址，由某个硬件算得页号、页内偏移量； 快表中查找内存块号。 将页号与快表中的所有页号进行比较，如果找到匹配的页号，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址； 页表中查找内存块号。 如果快表中查找不存在，访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。 7. 进程内存分配动态分区算法？ 首次适应法。 算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区； 实现方式：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分[表)，找到大小能满足要求的第-一个空闲分区。 优点： 综合性能最好，开销小。 最佳适应法。 算法思想：为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区； 实现方式： 空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 优点： 会有更多的大分区被保留下来，更能满足大进程需求 缺点： 产生很多太小的、难以利用的碎片，算法开销大 最坏适应法。 算法思想： 为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。 实现方式：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 优点： 可以减少难以利用的小碎片 缺点： 大分区容易被用完，不利于大进程，算法开销大 领近适应法。 算法思想： 首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。 实现方式：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始 ，查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 优点： 算法开销小 8. 什么是内存覆盖和内存交换？ 内存覆盖 思想： 把用户空间分成为一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。 特点：打破了必须将一个进程的全部信息装入内存后才能运行的限制 。 内存交换 思想： 内存空间紧张 时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存。 4.5 虚拟内存 0. 什么是虚拟技术 ？从时间和空间两方面来说。 虚拟技术把一个物理实体转换为多个逻辑实体 ： 时分复用技术 ： 如多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换 ； 空分复用技术： 物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。 1. 介绍一下局部性原理吧？ 局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装⼊部分程序到内存就开始运行。 局部性原理表现在以下两个⽅面： 时间局部性：如果程序中的某条指令⼀旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产⽣时间局部性的典型原因，是由于在程序中存在着大量的循环操作。 时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。 空间局部性：⼀旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在⼀段时间内所访问的地址，可能集中在⼀定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也⼀般是以向量、数组、表等形式簇聚存储的。 空间局部性通常是使用教大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。 虚拟内存技术实际上就是建⽴了 “内存⼀外存”的两级存储器的结构，利用局部性原理实现髙速缓存。 2.介绍一下，什么是虚拟内存？页式存储？ 虚拟内存 虚拟内存是一种存储机制，可为用户提供一个拥有很大主内存的错觉。通过将辅存的一部分作为主存来完成。在虚拟内存中，用户可以存储比可用主内存更大的进程。 每个进程创建加载的时候，会被分配一个大小为4G的连续的虚拟地址空间，仅仅是每个进程“认为”自己拥有4G的内存。等到进程真正运行的时候，需要某些数据并且数据不在物理内存中，才会触发缺页异常，进行磁盘数据拷贝到物理内存中 页式存储 大部分虚拟存储系统采用的是一种称为分页（paging）的技术。这种方式叫做虚拟页式存储管理。 物理内存空间划分为固定大小的内存块，称为物理页面，或者是页框（page frame） 虚拟地址空间也划分成大小相同的块，称为虚拟页面，或者简称页面（page） 页表：将虚拟页面映射为相应的物理页面。 3. 虚拟内存的技术实现 ？ 虚拟内存的实现需要建⽴在离散分配的内存管理⽅式的基础上。 虚拟内存的实现有以下三种⽅式： 请求分页存储管理 ：建⽴在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是⽬前最常用的⼀种实现虚拟存储器的⽅法。请求分页存储管理系统中，在作业开始运行之前，仅装⼊当前要执行的部分页即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调⼊到主存，同时操作系统也可以将暂时不用的页面置换到外存中。 请求分段存储管理：建⽴在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理⽅式就如同请求分页储存管理⽅式⼀样，在作业开始运行之前，仅装⼊当前要执行的部分段即可运行；在执行过程中，可使用请求调⼊中断动态装⼊要访问但⼜不在内存的程序段；当内存空间已满，而⼜需要装⼊新的段时，根据置换功能适当调出某个段，以便腾出空间而装⼊新的段。 请求段页式存储管理 4. 请你介绍一下页面置换算法？ 当发⽣缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择⼀个页面将其移出内存，以便为即将调⼊的页面让出空间。用来选择淘汰哪⼀页的规则叫做页面置换算法，我们可以把页 ⾯置换算法看成是淘汰页面的规则。 OPT （最佳页面置换算法）：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最⻓时间内不再被访问的页面,这样可以保证获得最低的缺页率。 但由于⼈们⽬前无法预知进程在内存下的若千页面中哪个是未来最⻓时间内不再被访问的，因⽽该算法无法实现。⼀般作为衡量其他置换算法的⽅法。 FIFO（First In First Out） （先进先出页面置换算法）: 总是淘汰最先进⼊内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。 LRU （Least Currently Used）（最近最久未使用页面置换算法）：LRU算法赋予每个页面⼀个访问字段，用来记录⼀个页面⾃上次被访问以来所经历的时间 T，当须淘汰⼀个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。 LFU （Least Frequently Used）（最少使用页面置换算法）: 该置换算法选择在前时期使用最少的页面作为淘汰页。 5.你怎么理解操作系统里的内存碎片，有什么解决办法？ 内存碎片分为：内部碎片和外部碎片。 内部碎片： 已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间； 内存泄漏：不再会被使用的对象的内存不能被回收 。 外部碎片： 还没有被分配出去（不属于任何进程），但由于太小了无法分配，给申请内存空间的新进程的内存空闲区域。 6. 什么是内存抖动？ 现象：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸； 原因： 程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够) ； 解决： 分配更多的物理块 4.6 并发和死锁 0. 介绍几种典型的锁？ 读写锁。 可以同时读，但写必须互斥，只允许一个写； 互斥锁。 一次只能一个线程拥有锁，其它只能等待； 条件变量： 互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定；而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足； 自旋锁。 如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。 1. 【重点】什么是线程死锁？什么情况下会发生死锁？解决死锁的策略有哪些？ 什么是死锁 死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。 发生死锁的条件 互斥：一个资源只能给一个进程使用； 占有并等待：进程持有资源并申请新资源，在申请到需要的资源之前，已有的资源不释放； 不可剥夺：进程申请到的资源在使用完之前，不可以被其他进程使用； 循环等待：各个进程的资源请求形成首尾连接循环等待。 解决方法：预防，避免，检测与恢复三种 预防：破坏死锁会发生的四个条件 破坏互斥：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的 破坏请求和保持：实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源； 破坏不剥夺条件 ：占用部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源； 破坏循环等待：资源分类标号，进行有序分配。 避免： 它不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配 安全序列：找到一种能让进程安全执行完的有序序列&#123;P1，P2，...，Pn&#125; 银行家算法：系统在为进程分配资源之前，首先计算此次资源分配的安全性，如果是安全的，则进行分配；如果这次分配会导致进入不安全状态，不进行分配。 恢复： 用资源分配图、进程等待图来协助这种检测出死锁，然后进行恢复。 系统重新启动，但代价很大 撤消参与死锁的全部或部分进程，剥夺资源 1.1 什么时候需要使用分布式锁？ 在单体应用的时候，如果多个线程要访问共享资源的时候，我们通常线程间加锁的机制，在某一个时刻，只有一个线程可以对这个资源进行操作，其他线程需要等待锁的释放，Java中也有一些处理锁的机制，比如synchronized。 而到了分布式的环境中，当某个资源可以被多个系统访问使用到的时候（例如，有多个客户端需要访问并操作同一个资源，还需要保持这个资源一致性的时候，就需要使用【分布式锁），为了保证大家访问这个数据是一致性的，那么就要求再同一个时刻，只能被一个系统使用，这时候线程之间的锁机制就无法起到作用了，因为分布式环境中，系统是会部署到不同的机器上面的，那么就需要【分布式锁】了。 2. （待补充）请你解释一下，通常系统CPU比较高是什么原因？ 首先查看是哪些进程的CPU占用率最高 3.说一下NIO，BIO，AIO区别? 参考：JAVaGuide 【BIO（同步阻塞）】 BIO：同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把 。 【NIO（同步非阻塞）】 NIO 本身是基于 事件驱动 的思想来实现的，其目的就是解决 BIO 的大并发问题： BIO 模型中，如果需要并发处理多个 I/O 请求，那就需要多线程来支持； IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。 【AIO（异步非阻塞）】 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型 。 AIO： 异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。 异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 0. 4. 【重点】介绍一下select，poll，epoll 原理？ 参考 select、poll、epoll的原理与区别 4.1 从阻塞I/O &amp; 非阻塞I/O说起 阻塞I/O 在linux中，默认情况下所有的socket都是阻塞的。 当用户进程调用了read()/recvfrom()等系统调用函数，它会进入内核空间中； 当这个网络I/O没有数据的时候，内核就要等待数据的到来，此时用户进程被阻塞； 当内核空间的数据准备好了，它就会将数据从内核空间中拷贝到用户空间； 用户进程才解除阻塞的的状态，重新运行读取数据。 非阻塞I/O linux下，可以通过设置socket使其变为非阻塞模式，这种情况下，当内核空间并无数据的时候，它会马上返回结果而不会阻塞。 当用户进程调用了read()/recvfrom()等系统调用函数，它会进入内核空间中； 如果内核空间中的数据还没有准备好，那么它并不会阻塞用户进程，而是立刻返回一个error； 对于应用进程来说，它发起一个read()操作后，并不需要等待，那么它可以再次调用read()/recvfrom()等函数； 当内核空间的数据准备好了，它就会将数据从内核空间中拷贝到用户空间； 用户进程才解除阻塞的的状态，重新运行读取数据。 多路复用I/O就是我们说的select，poll，epoll等操作，复用的好处就在于单个进程就可以同时处理多个网络连接的I/O，能实现这种功能的原理就是select、poll、epoll等函数会不断的轮询它们所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 4.2 select原理 更加深刻对比理解：Linux编程之select 1int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); select函数监视的文件socket描述符分3类，分别是writefds、readfds、和exceptfds； 调用后select函数会阻塞（不是线程），直到有描述符就绪（有数据 可read、可write、except、超时timeout），函数返回。 123456789101112131415&#123; select(socket); while(1) &#123; sockets = select(); // 还是要从内核拷贝到用户 for(socket in sockets) &#123; if(can_read(socket)) &#123; read(socket, buffer); process(buffer); &#125; &#125; &#125;&#125; 详细执行原理如下： 用户首先将需要进行IO操作的socket添加到select中，然后阻塞函数select（不是线程）等待系统调用返回； 当数据到达时，socket被激活，select函数返回，会唤醒其等待队列上睡眠的内核进程，即在socket可读写时唤醒，或者在超时后唤醒； 每次调用select查看fd，都需要把fd集合拷贝进行系统调用陷入内核态 。 返回select()函数的调用结果给用户进程，返回就绪socket描述符的数目，超时返回0，出错返回-1； 在select()函数返回后还是需要轮询去找到就绪的socket描述符的（将此前传入内核空间的fd_set拷贝到用户空间），此时用户进程才可以去操作socket； 进程调用read() / recvfrom() 读取数据 。 select优点： 从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。 那为什么还要使用select？ 使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的； 而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。 select缺点： 描述符数量：select支持的文件描述符数量太小了，默认是1024 ； 系统开销：每次调用select都需要把fd集合拷贝进行系统调用陷入内核态，这个开销在fd很多时会很大 ； 二次轮询：select需要二次查询拷贝所有文件描述fd_set进行遍历查看是否有描述符准备就绪。 4.3 poll原理 1234567int poll (struct pollfd *fds, unsigned int nfds, int timeout);struct pollfd &#123; int fd; /* file descriptor */ short events; /* requested events to watch */ short revents; /* returned events witnessed */&#125;; 不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd指针实现。 poll使用链表维护这些socket描述符，而select使用的是数组（位图）。 其他的都差不多和select()函数一样，poll()函数返回后，需要轮询pollfd来获取就绪的描述符，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。 poll缺点： 解决了selec第一个缺点（文件描述符数量太少），但是依旧存在后面两个缺点。 系统开销：每次调用poll都需要把fd集合拷贝进行系统调用陷入内核态，这个开销在fd很多时会很大 ； 二次轮询：poll需要二次查询拷贝所有文件描述fd_set进行遍历查看是否有描述符准备就绪。 4.3 epoll原理 1234567// epoll只有epoll_create()、epoll_ctl()、epoll_wait() 3个系统调用函数。int epoll_create(int size); int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); epoll_create 创建一个epoll文件描述符的epfd（或者称之为句柄）, epoll使用一个epfd文件描述符管理多个socket描述符。 当创建好epoll句柄后，它就是会占用一个fd值，必须调用close()关闭，否则可能导致fd被耗尽 。 epoll_ctl 该函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，以及删除事件。相关参数： 使用红黑树对监视的文件描述符进行：添加、修改、删除等。 epdf：由epoll_create()函数返回的epoll文件描述符（句柄）； op ： op是操作的选项，注册要监听的目标socket描述符fd到epoll句柄中 ；修改epoll句柄已经注册的fd的监听事件；从epoll句柄删除已经注册的socket描述符 ； fd：指定监听的socket描述符； event：事件 1234567891011typedef union epoll_data &#123; void *ptr; int fd; uint32_t u32; uint64_t u64;&#125; epoll_data_t;struct epoll_event &#123; uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */&#125;; epoll_wait() epoll_wait()函数的作用就是等待监听的事件的发生，类似于调用select()函数。 相关参数如下： 函数的返回值表示需要处理的事件数目，如返回0表示已超时。 events：用来从内核得到事件的集合。 maxevents ：告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的指定的size。 timeout：超时时间。 epoll高效运行过程 参考：彻底搞懂epoll高效运行的原理 执行epoll_create会在内核的高速cache区中建立一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。接着用户执行epoll_ctl 函数添加文件描述符会在红黑树上增加相应的结点。 select：创建3个文件描述符集并拷贝到内核中 ; poll：将传入的struct pollfd结构体数组拷贝到内核中进行监听。 调用epoll_wait 阻塞，等待可读事件； 内核在检测到满足条件的socket描述符会调用回调函数 ，回调函数将文件描述符放在就绪链表中 ； 而select/poll 都需要 ，遍历所有文件描述符fd_set 。 而执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，只需调用回调函数。 epoll_wait只用观察就绪链表中有无数据即可，最后将链表的数据返回给读写事件数组events &amp;返回就绪的数量，只用遍历events依次处理即可。 这里返回的文件描述符是通过mmap让内核和用户空间共享同一块内存实现传递的，减少了不必要的拷贝。 而select/poll 只返回socket就绪数目， 还需要将所有的文件描述符再次从内核→用户，遍历就绪的socket文件描述符。 4.4 select，poll，epoll 各自区别？ 不错的文章：https://www.codenong.com/cs105364662/ 相同点： select，poll，epoll 都是 IO 多路复用的机制（NIO？yes）； IO 多路复用的本质是通过一种机制，让单个进程可以监视多个描述符，当发现某个描述符就绪之后，能够通知程序进行相应的操作。 select，poll，epoll 都是同步 IO 。 不同点： IO 效率：（1）select 只知道有 IO 事件发生，却不知道是哪几个流，只能采取轮询所有流（ fd_set 集合）的方式，故其具有 O(n) 的无差别轮询复杂度，处理的流越多，无差别轮询时间就越长；（2）poll 与 select 并无区别，它的时间复杂度也是O(n)；（3）epoll 会将哪个流发生了怎样的 IO 事件通知我们（当描述符就绪时，系统注册的回调函数会被调用，将就绪描述符放到 readyList 里面），它是事件驱动的，其时间复杂度为 O(1)； 操作方式：select 和 poll 都是采取遍历的方式，而 epoll 则是采取了回调的方式； 底层实现：select 的底层实现为数组，poll 的底层实现为链表；而 epoll 的底层实现为红黑树； 最大连接数：select 的最大连接数为 1024 或 2048；而 poll 和 epoll 是无上限的； 对描述符的拷贝：select 和 poll 每次被调用时都会把描述符集合从用户态拷贝到内核态，而 epoll 在调用 epoll_ctl 时会拷贝进内核并保存，之后每次 epoll_wait 时不会拷贝； 性能：epoll 在绝大多数情况下性能远超 select 和 poll，但在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，因为 epoll 的通知机制需要很多函数回调 。 4.5 ET , LT 模式介绍？各自优缺点？ 参考：https://cloud.tencent.com/developer/article/1636224 边缘触发模式（Edge Trigger，ET），只有一个事件从无到有才会触发； 低电平 =&gt; 高电平 。 水平触发模式（Level Trigger，LT），一个事件只要有，就会一直触发。 低电平 =&gt; 高电平 ; 2. 处于高电平状态 举例说明 socket 的读事件 LT模式，只要 socket 上有未读完的数据，就会一直产生 EPOLLIN 事件； ET模式，socket 上每新来一次数据就会触发一次，如果上一次触发后，未将 socket 上的数据读完，也不会再触发，除非再新来一次数据。 对于 socket 写事件 LT模式，如果 socket 的 TCP 窗口一直不饱和，会一直触发 EPOLLOUT 事件； ET模式，只会触发一次，除非 TCP 窗口由不饱和变成饱和再一次变成不饱和，才会再次触发 EPOLLOUT 事件。 优缺点 使用 LT 模式，我们可以自由决定每次收取多少字节（对于普通 socket）或何时接收连接（对于侦听 socket），但是可能会导致多次触发； 使用 ET 模式，我们必须每次都要将数据收完（对于普通 socket）或必须理解调用 accept 接收连接（对于侦听socket），其优点是触发次数少。 5. 操作系统底层是怎么实现原子操作的？ 处理器使用基于对缓存加锁或总线加锁的方式，来实现多处理器之间的原子操作。 总线锁： 处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存； 总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据 缓存锁：相比总线锁，缓存锁即降低了锁的力度。核心机制是基于缓存一致性协议来实现的。 详细参考：JMM基础（总线锁、缓存锁、MESI缓存一致性协议、CPU 层面的内存屏障） 4.7 其它 1. 常见的磁盘调度算法？ 读写一个磁盘块的时间的影响因素有： 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上） 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上） 实际的数据传输时间 其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。 先来先服务。 按照磁盘请求的顺序进行调度。 优点：公平、简单； 缺点：未对寻道做任何优化，使平均寻道时间可能较长。 最短寻道优先。 优先调度与当前磁头所在磁道距离最近的磁道。 优点： 平均寻道时间比较低； 缺点：不公平，如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去。 电梯扫描算法。 电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。 优点： 性能较好，同时不会存在饥饿现象。 2. 服务器高并发的解决方案你知道多少？ 应用数据与静态资源分离：将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据； 客户端缓存 ：例如先生成静态页面，然后用ajax异步请求获取动态数据； 集群和分布式 ：使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度； 反向代理： 在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"操作系统","slug":"操作系统","permalink":"https://hwh.zone/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"校招笔记（三）_计算机基础_计算机网络","slug":"校招笔记（三）_计算机基础_计算机网络","date":"2021-11-26T12:53:16.543Z","updated":"2021-12-03T03:55:53.544Z","comments":true,"path":"p/46361/","link":"","permalink":"https://hwh.zone/p/46361/","excerpt":"","text":"我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。 备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 三、计算机网络 3.1 ISO/OSI模型 和 TCP/IP 模型 1.请你简要介绍一下TCP/IP 五层协议 和 ISO/OSI七层协议？ 应用层：为用户的应用程序（如：电子邮件、文件传输和仿真终端）*提供网络服务； 表示层： 可以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取； 会话层： 通过运输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求； 运输层: 任务是为两台主机中进程之间的通信提供通用的*数据传输服务，传输的是报文段（tcp）/用户数据报（udp）； 复用：多个应用层进程可同时使用下面运输层的服务。 分用：运输层把收到的信息分别交付上面应用层中的相应进程。 网络层： 为主机间*提供通信服务。在发送数据时，网络层把运输层的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报 数据链路层（忘）： 两台主机通信，总是在一段一段的链路上传送的，这就需要需要专门的链路层的协议。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的*IP数据报组装成帧，在两个相邻结点间的链路上传送帧。每一帧包括数据和必要的控制信息。 物理层：主要作用是传入比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0），定义物理设备标准（例如网线的接口类型、光线的接口类型、各种传输介质的传输速率）。 2.请你简要介绍一下各层的协议？ 物理层：暂无 （快手）数据链路层：数据链路层主要是负责传输数据， PPP（点到点协议）：在点对点连接上传输多协议数据包提供了一个标准方法，PPP 最初设计是为两个对等节点之间的 IP 流量传输提供一种封装协议。这种链路提供全双工操作，并按照顺序传递数据包。 设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。 以太网（Ethernet)： CSMA/CD 协议： 冲突检测的载波监听多路访问技术(载波监听多点接入/碰撞检测)。 许多计算机以多点接入的方式连接在一根总线上，每个主机都必须不停地监听信道。发送前监听，如果忙则等待，如果空闲则发送。 若检测到信道有干扰信号，则表示产生了碰撞，于是就要停止发送数据，计算出退避等待时间，然后使用 CSMA 方法继续尝试发送。 网络层： 可参考 IP：网络协议，非常重要的中间层协议，TCP和UDP必须基于IP工作 ICMP：非常重要的中间层协议，用于在 IP主机、路由器 之间传递控制消息 IGMP：网络组消息协议，用来在IP主机和与其直接相邻的组播路由器之间建立、维护组播组成员 ARP：地址解析协议，建立IP→MAC地址映射表 RARP：反向地址解析协议，某个网络设备的MAC物理地址转换为IP地址 运输层:TCP(Transmission Control Protocol) 面向连接的，数据传输的单位是报文段，能够提供可靠的交付。 UDP(User Datagram Protocol) ：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付” 应用层：如支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议，DNS，POP3，SNMP，Telnet等等。 2.1 RARP 工作原理？ RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。 网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。 主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包； RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机； 主机收到RARP回应后，就使用得到的IP地址进行通讯。 3. 端口在哪一层？有效端口范围？ 端口在传输层。传输层以下的包封装过程： 数据报在传输层：加源端口号和目的端口号； 在网络层加上：源ip和目的ip ； 在数据链路层转化成：数据桢进行校验； 在物理层变成信号（电、光、等信号）发送出去。 UDP和TCP报头使用两个字节存放端口号，端口一共有一共有65535个。 知名端口号从0~1023，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口） ； 动态端口的范围是从1024~65535。 3.2 运输层 0. TCP报文头？UDP报文头？ 参考：IP、TCP、UDP报文头说明 TCP报文头 来源端口：向目标主机指明接入他的主机所使用的端口号 用于目标主机回应 目标端口：指明要连接的目标主机的端口号 从这也可以看书，端口占16bit，故范围是0~65535。 顺序号：数据包编号， 表明发送的数据包的顺序 。其值通常应该为上次发送包中的顺序号+1 ，若该数据包是整个TCP连接中的第一个包(SYN包) 则该值随意(通常随机) 确认号：通常该值是接受到的顺序号+1 ，若该数据包是整个TCP连接中的第一个数据包(SYN包) 则该值随意(通常为0) 首部长度：TCP头长度 。表明包好多少个32Bit 包括可选头(如果有) 值为TCP头大小除以4 ： 如：没有可选头TCP头为20字节 则该值为5 标志位： 紧急标志位(URG)：开启时表明此数据包处于紧急状态应该优先处理 确认标志位(ACK)：开启时表明确认号有效 否则忽略确认号 推送标志位(PSH)：开启时表明应该尽快交付给应用进程 而不必等到缓存区填满才推送 复位标志位(RST)：开启时表明TCP连接出现连接出现错误 数据包非法拒绝连接 同步标志位(SYN)：开启时表明一个连接的请求或者接受报文 终止标志位(FIN)：开启时表明释放一个连接 窗口大小：表示期望接受到的每个数据包字节数 校验和：该值为TCP报文头括数据部分中每16Bit的二进制反码求和 紧急指针：若指定该值 他应该是一个偏移量 该值加上顺序号表示紧急数据最后一个字节的顺序号 可选字段：包含最大载荷与窗口比例等信息 注：若使用该字段则长度必须为32Bit的倍数 不足则填充0 UDP报文 来源端口：向目标主机指明接入他的主机所使用的端口号 用于目标主机回应 目标端口：指明要连接的目标主机的端口号 数据包长度：UDP头和数据总长度字节数 检验和：该值为UDP报文头括数据部分中每16Bit的二进制反码求和 注：UDP检验和不是必须的 1. 请你说明一下，TCP协议的3次握手（进行连接）？ 参考：三次握手与四次挥手面试官想考我们什么？ TCP中，对确认ACK报文是不需要发送确认的 。 简略过程 ⚠️ SYN 和ACK报文是一起发的！！ 1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN©。此时客户端处于 SYN_Send 状态。 2、第二次握手：（⚠️ SYN+ACK是在一个包里发的！（字节一面） ）服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。 3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。 服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。 1.1 ISN （Initial Sequence Number）是固定的吗？ ISN作用 三次握手，其中一个重要功能是客户端和服务端交换 ISN，以便让对方知道接下来接收数据的时候如何按序列号组装数据。 ISN为什么不固定（还是不太理解） ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。 防止在网络中被延迟的分组在以后被重复传输，而导致某个连接的一端对它作错误的判断； 如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。 2.为什么要三次握手？ 1.用来确定服务端和客户端的发送能力是否正常； 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。 2.指定自己的初始化序列号，为后面的可靠传送做准备； 如果只有两次握手，那么客户端的起始序列号可以确认，服务端的起始序列号将得不到确认。 如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成。 2.1 三次握手可以携带数据吗？ 第一次、第二次握手不可以携带数据 ， 第三次可以携带数据： 对于第一次握手，不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。 如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，消耗服务器空间来接收数据； 对于第三次握手，客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，已经知道服务器的接收、发送能力正常，所以能携带数据。 3.请你说明一下，TCP协议的4次挥手（断开连接）？ 为什么不像三次握手一样执行三次即可？ 因为第二次和第三次对于被动方来说，意义是不一样的。 第二次是为了让主动方闭嘴（不再发挥手请求），自己该干嘛还是干嘛（但是自己可能还有数据美处理完）。 第三次是为了表示“我的活儿干完了，可以结束了”。 通常server接收到挥手的时候，手里还有活儿没做完。 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。 收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。 （1）客户端A发送一个FIN，报文中会指定一个序列号M，用来关闭客户A到服务器B的数据传送，此时客户端处于FIN_WAIT1状态； （2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号M+1。和SYN一样，一个FIN将占用一个序号，此时服务端处于 CLOSE_WAIT状态； （3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A和序列号N，此时服务端处于 LAST_ACK 的状态； （4）客户端A发回ACK报文确认，并将确认序号设置为收到序N+1，此时客户端处于 TIME_WAIT 状态，需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态；服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 3.1 为什么TCP四次挥手要基于全双工，不基于半双工呢？基于半双工可以改为三次挥手吗？ 半双工：同时只能有一端发送消息 ； 全双工：两端都可以随机接受/发送。 在四次挥手过程中，似乎C/S两端都是等待对方发送FIN/ACK，才会发送对应的ACK/FIN版本。同一时刻只有一方在发送消息，满足半双工。 但是，半双工模式效率会更低：比如C端（客户端）发送FIN报文请求关闭，但是S端（服务端）依旧可以同时发生数据 ，这个时候效率更高。 3.2（重点） 服务器出现大量close_wait的连接的原因是什么？有什么解决方法？ close_wait状态是在，TCP四次挥手的时候服务器收到FIN，但是没有发送自己的FIN时出现的。服务器出现大量close_wait状态的原因有两种： 服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法 服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收 处理方法： 停止应用程序 修改程序里的bug 4. 为什么要有TIME_WAIT 状态？为什么等待是2MSL？ 要确保服务器是否已经收到了客户端最后的ACK 报文，如果没有收到的话，服务器会重新发 FIN + ACK报文给客户端，客户端再次收到 FIN + ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。 确保之前连接的一些数据不在滞留在网络中：确保已经失效连接请求报文段不会再出现在本连接中，客户端发完最后一个ACK报文段后，再经过2MSL可以使得本连接中所有的报文段都从网络中消失。客户端就可以放心地释放TCP占用的资源、端口号，连接任何服务器。 如果客户端直接CLOSED，然后又再次向服务器发起一个新连接，有可能新、老连接的端口号一样的。假设新、老连接端口号一致，若老连接的一些数据仍滞留在网络中，这些滞留数据在新连接建立后才到达服务器，鉴于前后端口号一致，TCP协议就默认这些数据属于新连接，于是数据就这样乱成一锅粥了。 4.1 为什么是2MSL? MSL是报文在网络中最长生存时间，这是一个工程值(经验值)，不同的系统中可能不同 。 考虑最坏 情况，客户端A最后一次挥手发送给服务端B的ACK报文丢失了： ACK从最多经过1MSL会到达服务端，超过1MSL服务端会重发FIN 服务端重发的FIN最多经过1MSL到达A 所以为了确保，客户端能接收到服务端重发的FIN报文。 5. 【重点】请问TCP为什么要更可靠？哪种场景会有所应用？ 超时重传：当 TCP 发出⼀个报文段后，它启动⼀个定时器，等待⽬的端确认收到这个报⽂段。如果不能及时收到⼀个确认，将重发这个报⽂段； 数据排序：TCP有专门的序列号ISN字段，可提供数据re-order； 流量控制：滑动窗口和计时器的使用。TCP窗口中会指明双方能够发送接收的最大数据量； ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待对方确认。在收到确认后再发下⼀个分组。 拥塞控制：TCP的拥塞控制由4个核心算法组成。“慢启动”（Slow Start）、“拥塞避免”（Congestion avoidance）、“快重传 ”（Fast Retransmit）、“快恢复”（Fast Recovery）； 校验和： TCP 将保持它⾸部和数据的检验和。这是⼀个端到端的检验和，⽬的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报⽂段和不确认收到此报⽂段。 【应用场景】 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用 比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议 5.1 超时重传机制原理？ 基本原理：在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。 TCP中有四种计时器（Timer），分别为： 重传计时器：在滑动窗口协议中，接受窗口会在连续收到的包序列（连续ARQ）中的最后一个包向接收端发送一个ACK。当网络拥堵的时候，发送端的数据包和接收端的ACK包都有可能丢失。TCP为了保证数据可靠传输，就规定在重传的“时间片”到了以后，如果还没有收到对方的ACK，就重发此包，以避免陷入无限等待中。 坚持计时器：在滑动窗口协议中，当发送TCP收到窗口大小为0的确认ACK时，就坚持启动计时器。当坚持计时器期限到时，发送TCP就发送一个特殊的报文段，叫做探测报文。这个报文段只有一个字节的数据。他有一个序号，但他的序号永远不需要确认；甚至在计算机对其他部分的数据的确认时该序号也被忽略。探测报文段提醒接受TCP：确认已丢失，必须重传。 保活计时器：保活计时器使用在某些实现中，用来防止在两个TCP之间的连接出现长时间的空闲。假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远的处于打开状态。 通常设置为两小时。若服务器过了两小时还没有收到客户的信息，他就发送探测报文段。若发送了10个探测报文段（每一个像个75秒）还没有响应，就假定客户除了故障，因而就终止了该连接。 时间等待计时器：四次挥收后time waiter状态中使用。 5.2 介绍一下ARQ协议 ？ ⾃动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之⼀。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。 ARQ包括停⽌等待ARQ协议和连续ARQ协议。 停⽌等待ARQ协议。 停⽌等待协议是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待对方确认（回复ACK）。如果过了⼀段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下⼀个分组；在停⽌等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。 优点：简单 缺点：信道利用低，等待时间长 连续ARQ协议。连续 ARQ 协议可提高信道利用率。发送方维持⼀个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方⼀般采用累计确认，对按序到达的最后⼀个分组发送确认，表明到这个分组为⽌的所有分组都已经正确收到了。 优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。 缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 ⽐如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传⼀次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的N 个消息。 5.2 介绍一下连续ARQ协议滑动窗口和流量控制？ TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报⽂中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 5.3 介绍一下拥塞控制？ 为了进行拥塞控制，TCP 发送方要维持⼀个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让⾃⼰的发送窗口 == 取为拥塞窗口和接收方的接受窗口中较小的⼀个。 TCP的拥塞控制采用了四种算法： 慢开始： 慢开始算法的思路是当主机开始发送数据时，如果⽴即把大量数据字节注⼊到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测⼀下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过⼀个传播轮次RTT，cwnd加倍； 拥塞避免： 拥塞避免算法的思路是让拥塞窗⼝cwnd缓慢增大，即每经过⼀个往返时间RTT，就把发送放的cwnd加1； 快重传/快恢复： 区分快重传，连续ARQ中间丢失是Go back n。 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是⼀种拥塞控制算法，它能快速恢复丢失的数据包。如果接收机接收到⼀个【不按顺序】的数据段，它会⽴即给发送机发送⼀个重复确认（而不是等到自己发送数据时才捎带确认）。如果发送机接收到三个重复确认，它会假定确认指出的数据段丢失了，并⽴即重传这些丢失的数据段（而不必继续等待为该报文段设置的重传计时器的超时）。 5.4 如何区分流量控制和拥塞控制？ 流量控制属于通信双方协商，拥塞控制涉及通信链路全局； 流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。 6.如何提高客户端并发数？ 客户端建立的tcp数量受限于最大文件句柄数，一个连接就会建一个文件句柄，在linux 上默认是1024。 使用ulimit 可以修改最大进程数（最大为65535） 7.说说HTTP、TCP、Socket 的关系是什么？ TCP/IP 代表传输控制协议/网际协议，指的是一系列协议族； HTTP 本身就是一个协议，是从 Web 服务器和本地浏览器的超文本传送协议； Socket 是 TCP/IP 网络的 API ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。 8. 什么是半连接队列？泛洪攻击（DDos攻击的一种），以及解决策略 ？ 半连接队列 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。 已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。 泛洪攻击 在 TCP 的三次握手机制的第一步中，客户端会向服务器发送 SYN 报文段。 服务器接收到 SYN 报文段后会为该 TCP分配缓存和变量，如果攻击分子伪造大量不存在的IP地址，大量地往服务器发送 SYN 报文段，服务器的连接资源终将被耗尽，导致内存溢出无法继续服务。 当服务端接收到 SYN 后进入 SYN-RECV 状态，此时的连接称为半连接，同时会被服务端写入一个半连接队列。 想象一下，如果攻击者在短时间内不断的向服务端发送大量的 SYN 包而不响应，那么服务器的半连接队列很快会被写满，从而导致无法工作。 解决策略 设置验证机制：当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源 Id，目的 Id，端口号以及只有服务器自己知道的一个秘密函数生成一个 cookie，并把 cookie作为序列号响应 给客户端。 如果客户端是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段。接下来服务器会根据确认报文的源 Id，目的 Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1 等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源 。 防火墙过滤： 暂不了解具体 9.为什么DNS（域名解析）用UDP，而区域传送用TCP? DNS用UDP：客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。 区域传送用TCP： TCP协议可靠性好，TCP协议传输的内容大，而UDP最大只能传512字节。 10.说一下 TCP 粘包是怎么产生的？怎么解决粘包？ TCP粘包 TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。 客户端要发送原信息是A和B两个数据包，服务端接收到之后，可能出现如下情况： 正常情况：读取到了A和B两个数据包； 粘包：A和B两个数据包一起读取了； 拆包：读取了A数据包的一部分，A的另一部分和B数据包一起读取了。 TCP粘包原因 【发送方】TCP默认使用Nagle算法。客户端通过socket给服务端发送数据，为了传输更有效率，会将多次间隔较小的且数据量小的数据，通过nagle算法，合并成一个大的数据块，然后进行封包。这样做提高了效率，缺点就是你发送到服务端的数据，服务端不知道是不是完整的，不知道哪几小块数据拼起来才是原来的数据； 【接收方】来不及接收缓存区的包，导致多个包接收； TCP连接复用造成的粘包问题； 流量控制，拥塞控制也可能导致粘包。 解决粘包 解决问题的关键在于如何给每个数据包添加边界信息： Nagle算法问题导致的，需要结合应用场景适当关闭该算法； 发送端给每个数据包添加包 首部 ，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了； 数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开 ； 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。 11. TCP, UDP的区别？ UDP 在传送数据之前不需要先建立连接。远地主机在收到 UDP 报⽂后，不需要给出任何确认。虽然UDP 不提供可靠交付，但在某些情况下 UDP 确是⼀种最有效的⼯作方式（⼀般用于即时通信） ⽐如： QQ 语⾳、 QQ 视频 、直播等等 TCP 提供面向连接的服务。在传送数据之前必须先建⽴连接，数据传送结束后要释放连接。 TCP 不提供⼴播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握⼿来建⽴连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这⼀难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的⾸部增大很多，还要占用许多处理机资源。 TCP ⼀般用于⽂件传输、发送和接收邮件、远程登录等场景。 数据包： TCP是报文段，UDP是用户数据报。 应用场景 ： TCP用于一些需要可靠传输的场景； UDP则应用一些即时通信场景，不需要可靠传输的场景。 长度：UDP在DNS最长只能是512字节，TCP会更长。 3.3 网络层 1.请简单解释一下，ARP协议和ARP攻击? ARP协议：地址解析协议，建立IP/MAC地址映射表 ARP攻击： 2.什么是ICMP协议，它的作用是什么？ 用于在IP主机、路由器之间传递控制消息。 控制消息是指：网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。 3.请你讲一下路由器和交换机的区别？ 动态IP：路由器可以给你的局域网自动分配IP，虚拟拨号，就像一个交通警察，指挥着你的电脑该往哪走，你自己不用操心那么多了。交换机只是用来分配网络数据的。 路由器可以把一个IP分配给很多个主机使用，这些主机对外只表现出一个IP。交换机可以把很多主机连起来，这些主机对外各有各的IP。 寻址方式：路由器在网络层，路由器根据IP地址寻址，路由器可以处理TCP/IP协议，交换机不可以；交换机在中继层，交换机根据MAC地址寻址。 防火墙：路由器提供防火墙的服务，交换机不能提供该功能。集线器、交换机都是做端口扩展的，就是扩大局域网(通常都是以太网)的接入点，也就是能让局域网可以连进来更多的电脑。路由器是用来做网间连接，也就是用来连接不同的网络。 4.请解释ping命令过程？ 域名在DNS服务器查找IP地址； 通过Ping程序发送ICMP包； 同一网段的情况下，调用IP层的ARP协议请求广播（不同网段的情况下，交给路由器处理），查找目标主机的MAC地址； 目标主机ARP协议收到请求后，将本机MAC地址填充并发送ARP应答回到请求发送方； 请求发送方发送ICMP数据到目标主机； 目标主机响应ICMP包； 请求主机收到目标主机的ICMP响应包。 5. （补充介绍）介绍一下IPV6？一共多少位？ 源IP和目的IP地址都是，128（4*32）位（图中标识不清晰）！ 6. 介绍一下IP地址分类？C类哪些是保留地址？网络号全 0 全 1 ，主机号全 0 全1 分别什么含义？ IP地址分类 IP地址 == &#123;&lt;网络号&gt;，&lt;主机号&gt;&#125; A类： 第1位固定为0，网络号只有7位 。0（0000 0000）的IP地址是保留地址，意思是“本网络” ； 127（0111 1111）的IP地址也是保留地址，作为本地环回软件测试 。 特别的，主机号全1的是广播地址，它代表了网络全部的主机。 B类： 第1、2位固定为10，网络号有14位可以使用 。 B类地址网络号为128.0（1000 000 0000 0000）的IP地址是不指派的，所以可指派的网络号需要减一。 C类： 第1、2、3位固定为110，网络号有21位可以使用 。 （快手问）C类IP地址包含私有C类地址，范围从192.0.0.0 到223.255.255.255，其中私有C类地址范围从192.168.0.0 到192.168.255.255。 全0或者全1的含义 网络号全0：（1）如果主机号也为全0，那么此类ip地址可以当源端但不可以做目的端 （2）如果主机号不全为0，那么此类ip地址的使用和（1)相同，只是它代表的是网络上特定的主机 网络号全1：全1的网络号和任意的主机号组合当做回环地址来使用。 例如：127（0111 1111）的IP地址 主机号全0： 全为0，所得到的地址就是192.168.100.0，它是一个网络地址，代表的是一个网段； 主机号全1： 机号全1 代表的是广播地址，广播地址是不可以做源端的，但是可以做目的端。 3.4 应用层 1.请你谈谈DNS的寻址过程？ （1）检查浏览器缓存、检查本地hosts文件：是否有这个网址的映射，如果有，就调用这个IP地址映射，解析完成。 （2）如果没有，则查找本地DNS解析器缓存：是否有这个网址的映射，如果有，返回映射，解析完成。 本地dns服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动等。 （3）如果没有，则查找填写或分配的首选DNS服务器：称为本地DNS服务器。服务器接收到查询时： 如果要查询的域名包含在本地配置区域资源中，返回解析结果，查询结束，此解析具有权威性。 如果要查询的域名不由本地DNS服务器区域解析，但服务器缓存了此网址的映射关系，返回解析结果，查询结束，此解析不具有权威性。 （4）如果本地DNS服务器也失效： 如果未采用转发模式（迭代，从上至下）（1）本地DNS服务器就把请求发至13台根DNS，根DNS服务器收到请求后，会判断这个域名（如.com）是谁来授权管理，并返回一个负责该顶级域名服务器的IP，（2）本地DNS服务器收到顶级域名服务器IP信息后，继续向该顶级域名服务器IP发送请求，（3）该服务器如果无法解析，则会找到负责这个域名的下一级DNS服务器（如http://baidu.com）的IP给本地DNS服务器，循环往复直至查询到映射，（4）将解析结果返回本地DNS服务器，再由本地DNS服务器返回解析结果，查询完成。 如果采用转发模式（递归，从下至上）（1）则此DNS服务器就会把请求转发至上一级DNS服务器，（2）如果上一级DNS服务器不能解析，则继续向上请求，（3）最终将解析结果依次返回本地DNS服务器，本地DNS服务器再返回给客户机，查询完成。 1.1 怎么获取13台根服务器？ ping -R ? 抓包？ 1.2 解释一下DNS劫持和DNS污染？ 参考：什么是http劫持 ? 一、DNS劫持 DNS劫持某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，返回给用户一个错误的查询结果。 劫持过程 客户端发起域名请求到DNS解析服务器（一般是LocalDNS），但此时DNS解析服务器被攻击篡改； 被攻击篡改后的DNS解析服务器将请求转发给虚假服务器； DNS查询没有任何认证机制且基于UDP不可靠连接，因此很容易被篡改。 虚假服务器返回响应虚假信息给被攻击篡改后的DNS解析服务器（也可能直接不响应）； 解决办法 DNS劫持的本质是运营商的DNS解析服务器被攻击篡改 使用国外免费公用的DNS服务器解决。例如OpenDNS（208.67.222.222）或GoogleDNS（8.8.8.8） 直接使用ip进行访问 二、DNS污染 DNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。因为是不是劫持单个DNS服务器，而是监听所有的，所以个人比较难防范。 污染原理 通过对UDP端口53上的DNS查询进行入侵检测； 由于通常的DNS查询没有任何认证机制，而且DNS查询通常基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改。 一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。 解决办法 VPN代理或者域名远程解析的方法解决 通过修改Hosts，手动设置域名正确的IP地址 2. Forward和Redirect的区别？ 浏览器 URL 地址：Forward 是服务器内部的重定向，服务器内部请求某个 servlet，然后获取响应的内容，浏览器的 URL 地址不会变化；Redirect 是客户端请求服务器，然后服务器给客户端返回了一个302 状态码和新的 location，客户端重新发起 HTTP 请求，服务器给客户端响应 location 对应的 URL 地址，浏览器的 URL 地址发生了变化。 数据的共享：Forward 是服务器内部的重定向，request 在整个重定向过程中是不变的，request 中的信息在 servlet 间是共享的。Redirect 发起了两次 HTTP 请求分别使用不同的request。 请求的次数：Forward 只有一次请求；Redirect 有两次请求。 3.请你简单讲解一下，负载均衡反向代理模式的优点、缺点？ 联系实际：正反向代理、科学上网、VPN之间的关系 和翻墙基本原理（看他的其他文章补充） 【基本介绍】 反向代理（Reverse Proxy）：方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器； 优点： 网络络外部用户不能直接访问真实的服务器，具备额外的安全性 缺点： 反向代理是处于OSI参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反向代理服务器；限制了应用范围； 针对每一次代理，代理服务器就必须打开两个连接，一个对外，一个对内，因此在并发连接请求数量非常大的时候，代理服务器的负载也就非常大了，在最后代理服务器本身会成为服务的瓶颈。 反向代理负载均衡技术：是把将来自internet上的连接请求以反向代理的方式动态地转发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。 实现：apache mod_proxy、netscape proxy等，也可以在高速缓存器、负载均衡器等硬件设备上实现。 优点：可以将优化的 负载均衡策略和代理服务器的高速缓存技术结合在一起，提升静态网页的访问速度，提供有益的性能 缺点： 3.1 请解释下负载均衡的相关算法？ 不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。 给配置高、负载低的机器配置更高的权重，让其处理更多的请求； 给配置低、负载高的机器分配较低的权重，降低系统负载。 下面是几种比较相关的算法。 加权轮询算法 参考：加权轮询算法 基本定义 假设有 N 台实例 S = {S1, S2, …, Sn}，权重 W = {W1, W2, …, Wn} currentPos 表示当前选择的实例 ID，初始化为 -1； currentWeight 表示当前权重，初始值为 max(S)； max(S) 表示 N 台实例的最大权重值，gcd(S) 表示 N 台实例权重的最大公约数。 算法过程 从上一次调度实例起，遍历后面的每个实例； 若所有实例已被遍历过一次，则减小 currentWeight 为 currentWeight - gcd(S)，并从头开始遍历；若 currentWeight 小于等于 0，则重置为 max(S)； 直到 遍历的实例的权重 &gt;= currentWeight 时结束，此时实例为需调度的实例； 每次调度重复步骤 1、2、3； 算法实例 例如，上述 4 个服务，最大权重 max(S) 为 4，最大公约数 gcd(S) 为 1。其调度过程如下： 算法优缺点 优点： 相比 简单轮询 方式，通过权重进行分配，更加均匀 缺点：如下一个极端情况 服务实例 S = {a, b, c}，权重 W = {5, 1, 1}，使用加权轮询调度生成的实例序列为 {a, a, a, a, a, b, c}，那么就会存在连续 5 个请求都被调度到实例 a。 关于这点，可以采用 平滑加权轮询 调度算法 。 一致性哈希算法 负载均衡算法中的哈希算法，就是根据某个值生成一个哈希值，然后对应到某台服务器上去，即哈希环。 但是可能出现一种，哈希倾斜的情况：A负责的区域太大，B，C负责的小。这个时候采用虚拟节点去解决，这里不表。 3.2 DNS 负载均衡是什么策略？ 参考： 原理： 还是不太明白，DNS递归查询本身就是个负载均衡策略吧？多台服务器满足同一个查询服务？ 4.请说明一下http和https的区别？ https协议要申请证书到ca，需要一定经济成本； http是明文传输，https是加密的安全传输； （🚩*1）连接的端口不一样，http是80，https是443； http连接很简单，没有状态； https是ssl加密的传输，身份认证的网络协议，相对http明文传输比较安全。 4.1 讲一讲http的请求报文和响应报文？协议？ 请求报文和协议 一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。 请求行 ：由请求方法字段、URL字段和HTTP协议版本字段3个字段组成。 HTTP协议 : 的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。 请求头部： 请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔 。 请求头部通知服务器有关于客户端请求的信息。 User-Agent：产生请求的浏览器类型。 Accept：客户端可识别的内容类型列表。 Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。 请求数据 : 请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。 响应报文和协议 HTTP响应也由四个部分组成，分别是：状态行、响应头、空格、响应数据。 状态行 ： 状态行（status line）通过提供一个状态码来说明所请求的资源情况。如404等 4.2 一个TCP连接中多个HTTP请求发生可以【同时】一起发生吗？ HTTP/1.1单个 TCP 连接在同一时刻只能处理一个请求。意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠； Pipelining 技术 &amp; Multiplexing。 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行； 那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？ 维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求； 和服务器建立多个 TCP 连接。 5.请说明一下http1.0 和https1.1 区别？ 长连接 HTTP1.0默认使用短连接，每次HTTP请求都需要建立新的TCP连接，连接不能复用； HTTP1.1支持持久连接和请求的流水线处理（但不是并发！！），在一个TCP连接上可以传送多个HTTP请求和响应，减少建立和关闭TCP连接的消耗和延迟，提高效率 host字段 在HTTP1.0中为每台服务器绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname） HTTP1.1的请求消息和响应消息都应支持Host头域（补充：F12 抓包可以看到），且请求消息中如果没有Host头域，会报400 Bad Request错误 缓存处理 HTTP1.1则引入了更多的缓存控制策略 带宽优化及网络连接的使用 HTTP1.0中存在浪费带宽现象，例如：（1）客户端只需要某个对象的一部分，而服务器却将整个对象发送过来；(2) 下载大文件不支持断点续传功能，在发生断连后需要重新下载完整的包； HTTP1.1则在请求头中引入range头域，它允许只请求资源的某个部分(因此也支持断点重传)，即返回码是206； 新增一些错误通知状态码 如：409（Conflict）表示请求的资源与资源的当前状态发生冲突 。 6.请说明一下http1.0 和https2.0 区别？ 7.请讲一下浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程？ 在浏览器地址栏中输入URL； DNS域名解析，获得域名相对应的IP地址（详见：应用层DNS寻址过程）； 浏览器首先会从（1）本地浏览器缓存、hosts文件是否存在相应的域名、IP对应关系，如果有则向这个IP地址发送请求，如果没有则向（2）本地DNS解析器缓存中查找，如果都没有，（3）再去DNS服务器中找IP。 浏览器向服务器发起TCP连接，与浏览器建立TCP三次握手；然后 向服务器发送HTTP请求，请求数据包 HTTP请求是由三部分组成：请求行、请求报头和请求正文。 与服务器建立了连接后，就可以向服务器发起请求了。发送HTTP请求的过程就是构建HTTP请求报文，并通过TCP协议发送到服务器指定端口（HTTP协议80/8080，HTTPS协议443）。 服务端（由web服务器）处理收到的请求 服务器端收到请求后，由web服务器（准确来说应该是HTTP服务器）处理请求，诸如Apache、Ngnix、IIS 。 服务器返回相应结果（响应报文）至浏览器 HTTP响应报文也是由三部分组成：状态码、响应报头和响应报文。 状态码是由三位数组成，第一个数字定义了响应的类别： 1XX：指示信息，表示请求已接受，继续处理； 2XX：成功，表示请求已被成功接收、理解、接受； 3XX：重定向，要完成请求必须进行更进一步的操作； 4XX：客户端错误，请求有语法错误或无法实现； 5XX：服务器端错误，服务器未能实现合法的请求。 四次挥手关闭TCP连接 四次挥手，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。 浏览器解析渲染页面 浏览器在 收到HTML、CSS、JS文件后，就需要进行渲染。 （1）浏览器解析HTML文件构建DOM树，（2）然后解析CSS文件构建渲染树，（3）等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上 8.请解释一下SSL工作过程（Https传输过程）？ https是http的扩展，在传输层使用了安全协议：安全套接字层SSL(Secure Socket Layer)。 参考：https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html 公钥通常用于加密会话密钥、验证数字签名，或加密可以用相应的私钥解密的数据。公钥和私钥是通过一种算法得到的一个密钥对(即一个公钥和一个私钥)。 通过这种算法得到的密钥对能保证在世界范围内是唯一的。 使用这个密钥对的时候,如果用其中一个密钥加密一段数据，必须用另一个密钥解密。 SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。 所以基本过程是： （1） 客户端向服务器端索要并验证公钥。 （2） 双方协商生成&quot;对话密钥&quot;。 （3） 双方采用&quot;对话密钥&quot;进行加密通信。 协商加密算法。客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求； （1） 支持的协议版本，比如TLS 1.0版。 （2） 一个客户端生成的随机数，来生成&quot;对话密钥&quot;。 （3） 支持的加密方法，比如RSA公钥加密。 （4） 支持的压缩方法。 服务器回应。服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello； （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。 （2） 一个服务器生成的随机数，稍后用于生成&quot;对话密钥&quot;。 （3） 确认使用的加密方法，比如RSA公钥加密。 （4） 服务器证书。 客户端鉴别。客户端收到服务器回应以后，（1）首先验证服务器证书：如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。 （2）如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息： （1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。 （2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。 （3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。 会话秘钥计算。 服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的&quot;会话密钥&quot;（使用3个随机数生成更安全）； （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。 （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。 安全数据传输。双方用会话秘钥加密和解密之间传送的数据。 8.1 公钥如何保证不被篡改？说一说证书。 将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。 服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。 进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过（证书不可信浏览器会提示），就可以开始通信了。 8.2 公钥加密计算量太大，如何减少耗用的时间？ 每一次对话（session），客户端和服务器端都生成一个&quot;对话密钥&quot;（session key），用它来加密信息。由于对话密钥是对称加密，所以运算速度非常快，而服务器公钥只用于加密&quot;对话密钥&quot;本身，这样就减少了加密运算的消耗时间。 8.3 为什么有的时候刷新页面不需要重新建立 SSL 连接？ TCP 连接有的时候会被浏览器和服务端维持一段时间，TCP 不需要重新建立，SSL 自然也会用之前的。 9. 介绍一下常见的几种非对称加密算法？优缺点？ 非对称加密 非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。 常用非对称加密算法 RSA：由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的 DSA（Digital Signature Algorithm）：数字签名算法，是一种标准的 DSS（数字签名标准） ECC（Elliptic Curves Cryptography）：椭圆曲线加密 非对称加密优缺点 优点： 可以更安全地将公开密钥传输给通信发送方； 缺点： 运算速度慢。 10.公钥加密–私钥解密与公钥解密–私钥加密有什么区别? 主要是应用场景不同。 加解密：公钥加密，私钥解密 不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密 签名：私钥签名，公钥验签 是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证 https可以只有非对称加密吗? https验证证书阶段是非对称加密，但是在数据传输阶段是对称加密。https不可以只有非对称加密： 非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的； 在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。 11. HTTPS 为什么安全？为什么需要CA证书？只有认证机构可以生成证书吗？HTTPS 绝对安全吗？ 安全：因为 HTTPS 保证了传输安全，防止传输过程被监听、防止数据被窃取，可以确认网站的真实性； CA证书： HTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器，而 HTTPS 协议主要解决的便是网络传输的安全性问题，所以需要CA证书 证书生成： 如果需要浏览器不提示安全风险，那只能使用认证机构签发的证书。但浏览器通常只是提示安全风险，并不限制网站不能访问，所以从技术上谁都可以生成证书，只要有证书就可以完成网站的 HTTPS 传输。 不绝对安全： 不是绝对安全的，可以通过中间人攻击。 CA证书不是可以解决“中间人”吗？ 过程原理： 本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器 中间人服务器返回中间人自己的证书（但是这一步服务器不是会对服务器证书进行验证吗？） 客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输 中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密 中间人以客户端的请求内容再向官方网站发起请求 因为中间人与服务器的通信过程是合法的，官方网站通过建立的安全通道返回加密后的数据 中间人凭借与官方网站建立的对称加密算法对内容进行解密 中间人通过与客户端建立的对称加密算法对官方内容返回的数据进行加密传输 客户端通过与中间人建立的对称加密算法对返回结果数据进行解密 12. http应答码中的301/2/4、500、502、503、504状态码进行解释？ 200： 请求成功。 500： 500 (服务器内部错误) 服务器遇到错误，无法完成请求。 例如，服务器无法识别请求方法时可能会返回此代码。 501：服务器不支持请求的功能，无法完成请求 502： 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503： 由于超载或系统维护，服务器暂时的无法处理客户端的请求。 504(及时)：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 13.介绍一下http请求get、post等？ 重点区分一下get和post： get ：GET方法用于使用给定的URI从给定服务器中检索信息，即从指定资源中请求数据。 GET请求是可以缓存的，浏览器历史记录中查找到GET请求；长度有限制；不安全，url会暴露请求的参数 post：POST方法用于将数据发送到服务器以创建或更新资源 。 POST请求不会被缓存；长度无限制；更安全 特别的：GET产生一个TCP数据包;POST产生两个TCP数据包。 get：http header和body一并发送出去 ； post：浏览器先发送header，服务器响应100 continue，浏览器再发送body 。 ⚠️ post是不一定会发生两个的。 HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送； header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。 13.1 Get方法长度有限制是怎么回事？ HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器 / 服务器的原因。 服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制； 浏览器也会设置url有限。 13.2 POST 方法相比GET方法是绝对安全吗？ POST 比 GET 安全，因为数据在地址栏上不可见； POST不是绝对安全，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。 想要安全，只有使用HTTPS。 14. HTTP是不保存状态的协议,如何保存用户状态? Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太⼀样。 Cookie ⼀般用来保存用户信息 我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以⾃动帮你登录的⼀些基本信息给填了； ⼀般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了⼀个 Token 在 Cookie中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录⼀般要将 Token 重写)； 登录⼀次网站后访问网站其他页面不需要重新登录。 Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。 既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在Cookie 中附加⼀个 Session ID 来方式来跟踪。 15. cookie 、session的作用和区别？ Cookie 作用： 服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。 Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。 Session 作用： Session 代表着服务器和客户端一次会话的过程，Session 对象存储特定用户会话所需的属性及配置信息。 二者区别 作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端； 有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效； 安全性： Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些； 存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie； 存取类型的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。 15.1 Session的共享方式？（好未来问过） 参考：Session如何共享 问题描述 在集群环境中，假设客户端第一次访问服务A，服务A响应返回了一个sessionId并且存入了本地Cookie中。第二次不访问服务A了，转去访问服务B； 访问服务B的时候，会将sessionId加入到请求头中，而服务B因为通过sessionId没有找到相对应的数据，因此它就会创建一个新的sessionId并且响应返回给客户端 这样就造成了不能共享Session的问题。 解决方案 使用Cookie实现。 将系统用户的Session信息加密、序列化后，以Cookie的方式， 统一种植在根域名下（如：.host.com），利用浏览器访问该根域名下的所有二级域名站点时，会传递与之域名对应的所有Cookie内容的特性，从而实现用户的Cookie化Session在多服务间的共享访问。 数据库同步session。 每次将session数据存到数据库中。这个方案还是比较可行的。 缺点： Session的并发读写能力取决于MySQL数据库的性能，对数据库的压力大，同时需要自己实现Session淘汰逻辑，以便定时从数据表中更新、删除 Session记录，当并发过高时容易出现表锁。 使用token代替session。 就是Token方式替代了，但是还是没解决。 Spring-Sesion实现 。将原本需要由Web服务器创建会话的过程转交给Spring-Session进行创建。Spring-Session会将原本应该保存在Web服务器内存的Session存放到Redis中。然后Web服务器之间通过连接Redis来共享数据，达到Sesson共享的目的。 16. Cookie 和 Session有什么关联？（问过）token有什么作用，优点，（JWT）结构是什么？ 参考：一文彻底搞懂Cookie、Session、Token到底是什么 为什么需要session？ 既然浏览器已经通过Cookie实现了有状态这一需求，那么为什么又来了一个Session呢？ 如果将账户的一些重要信息都存入Cookie中的话，一旦被拦截，那么我们所有的账户信息都会丢失掉。所以就出现了Session，在一次会话中将重要信息保存在Session中，浏览器只记录SessionId一个SessionId对应一次会话请求。 session和cookie二者关联 以用户一次登录为例。 用户第一次请求服务器的时候，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；并将此 Session 的唯一标识信息 SessionID 返回给浏览器； 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名； 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端； 服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。 什么是Token？ Session是将要验证的信息存储在服务端，并以SessionId和数据进行对应，SessionId由客户端存储，在请求时将SessionId也带过去，因此实现了状态的对应。 但是，而Token是在服务端将用户信息经过Base64Url【编码，不是加密】过后传给在客户端，每次用户请求的时候都会带上这一段信息，因此服务端拿到此信息进行解密后就知道此用户是谁了。 这个方法叫做JWT(Json Web Token)。 一个例子理解：基于Token的身份验证流程，在服务端不需要存储用户的登录记录 。 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 Token在服务器端，可以保存在Redis缓存中。 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 Token的优点 无状态，可扩展和解耦： 使用 token 而不是 cookie 的最大优点应该就是无状态，后端不需要保持对 token 的记录，每个 token 都是独立的，包含了检查其有效性的所有数据，并通过申明传达了用户信息。 在 JWT 中存储数据 ： 当使用 cookie 进行验证时，你是将 session id 存储到 cookie 里，JWT 允许你存储任何类型的元数据，只要是合法的 JSON。 自包含：由于串包含了用户所需要的信息，避免了多次查询数据库。 JWT介绍 JWT有三部分组成：Header，Payload，Signature。 Header： 一个Json对象，描述JWT的元数据，通常是下面这样子的。 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, # 签名的算法为HS256 &quot;typ&quot;: &quot;JWT&quot; # Token类型为JWT&#125; Payload： 也是一个Json对象，用来存放实际需要传输的数据，也可以自己定义一些私有字段，如： 1234&#123; &quot;name&quot;: &quot;xiaoMing&quot;, &quot;age&quot;: 14&#125; Signature： 对前面的两部分的数据进行签名，防止数据篡改 。 首先需要定义一个秘钥，这个秘钥只有服务器才知道，不能泄露给用户，然后使用Header中指定的签名算法(默认情况是HMAC SHA256)。算出签名以后将Header、Payload、Signature三部分拼成一个字符串，每个部分用.分割开来，就可以返给用户了。 16.1 session和cookie应该如何去选择（适用场景）？ Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session； Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；考虑安全考虑session 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中，一般是cookie和session配合使用的。 17.说说HTTP、TCP、Socket 的关系是什么？ TCP/IP 代表传输控制协议/网际协议，指的是一系列协议族； HTTP 本身就是一个协议，是从 Web 服务器传输超文本到本地浏览器的传送协议； Socket 是 TCP/IP 网络的 API ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。 3.5 其它 1. 介绍一下CDN ？ CDN分发节点各个数据都一样吗？ CDN，即内容分发网络 解决静态网页加载 不同地区用户访问服务器速度不同，可以把静态网页放在不同地区的服务器，这样用户可以就近去连接，大大提升体验； 发展转换成，就近接入解决访问网络资源 如一个电信用户送请求，进入解析系统，会让用户连接到最近的边缘节点，然后请求数据； 如果边缘节点没有数据，则去访问源节点； 源节点也没有，就会去访问主干节点，去联通服务器中查找； 最后返回数据。 CDN分发节点各个数据不一样 不一样，就相当于DNS服务器缓存了些域名→ip数据，如果没有的话还要向上级查询，最终把源站数据拉下来。 2. 什么是CDN三级溯源？ CDN目的。CDN 系统设计的首要目标是尽量减少用户的访问响应时间 CDN实现思路。为达到这一目标，CDN 系统应该尽量将用户所需要的内容存放在距离用户最近的位置。也就是说，负责为用户提供内容服务的 Cache设备应部署在物理上的网络边缘位置，我们称这一层为 CDN边缘层 。 CDN系统架构。CDN 系统中负责全局性管理和控制的设备组成 中心层 ，中心层同时保存着最多的内容副本，当边缘层设备未命中时，会向中心层请求，如果在中心层仍未命中，则需要中心层向源站回源。 各位同学们好： 我们今年大数据课程已经接近尾声，这门课已经开设了三年，每年都会邀请同学们来共同建设。每年我们也都会根据同学们的反馈进行完善，今年我们预计会进行一次更大的系统性更新。 按照当初承诺，现在我们统计下大家开源贡献，请按照示例，在进行下方评论完成填写。 [注1] ：为保证大家隐私情况，该Issue会在三天内统计完毕后关闭，请及时填写~ 组号 贡献类型（文档建设、Issue、PR等） 链接（或其它证明截图） 贡献人 备注 01组 issue test-issue 张三（20196666）、李四（20197777） 感谢大家的积极参与！","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"校招笔记（二）_计算机基础_Linux&Git","slug":"校招笔记（二）_计算机基础_Linux&Git","date":"2021-11-26T12:41:34.011Z","updated":"2021-12-03T03:54:55.587Z","comments":true,"path":"p/44980/","link":"","permalink":"https://hwh.zone/p/44980/","excerpt":"","text":"我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。 备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 二、Linux &amp; Git 2.1 Linux 2.1.1 常用命令 查看80端口状态？ 1netstat -ntulp | grep 80 -t : 指明显示TCP端口 -u : 指明显示UDP端口 -l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序) -p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序 -n : 不进行DNS轮询，显示IP(可以加速操作) 怎么查看指定端口是否开放？ 通过 netstat 命令，注意加上-a参数，看是否有0.0.0.0:22 在被监听。 通过lsof命令，如果没有任何显示，则端口没有被打开。 查看进程状态？怎么退出？怎么搜索进程？怎么查看某一个进程的内存和CPU使用情况？ 所有进程状态 12ps -aux # 内存中进程信息ps -l # 本次登陆所有的进程信息 退出进程： exit 搜索进程： ps -ef 1ps -ef | grep &lt;进程名&gt; -e相当于-a是全部列出，-f是显示UID等； 查看指定进程（如kalfa）CPU和内存占用 1ps -aux | grep java 1.3是CPU占用率，12.7是内存占用率，943100是物理内存使用量 还可以使用 top命令查看指定进程（PID）的内存和CPU使用率： 1top -p 2913 查看占用指定端口的进程 ？ 1lsof -i :8040 这一步只能获取进程名，还要ps 命令进一步获取进程id 如果要杀死相应进程： 1kill -9 &lt;进程id&gt; 任务管理器（cpu占用率、内存占用率、进程）？ 1top （总忘）还可以使用 top命令查看指定进程（PID）的内存和CPU使用率： 1top -p 内存使用情况 和 磁盘使用情况？ 1free -m # 内存使用情况 磁盘使用情况 1df -m -m : 以Mb为单位显示磁盘使用量和占用率 统计单词个数 1grep -o &lt;单词&gt; &lt;文件地址&gt; ｜ wc -l # -l表示统计行数 修改用户权限及常用参数？ 1chmod &lt;参数(可选)&gt; &lt;模式&gt; &lt;文件/文件夹&gt; 常用参数： -R ：递归的修改文件夹下所有子文件/文件夹的所属用户 【示例】如何修改 /test5/5.txt ，权限从rw-r--r-- —&gt; r--rwxrwx ？ 1234# 用户（U）权限[减去写]权限chmod u-w /test5/5.txt# 组（G）/其他用户（O）权限[加上写、执行]chmod go+wx /test5/5.txt 查看文件的命令有哪些？ 123456vi 文件名 #编辑方式查看，可修改cat 文件名 #显示全部文件内容more 文件名 #分页显示文件内容less 文件名 #与 more 相似，更好的是可以往前翻页tail 文件名 #仅查看尾部，还可以指定行数head 文件名 #仅查看头部,还可以指定行数 你平时怎么查看日志的？ Linux查看日志的命令有多种: tail、cat、tac、head、echo等，本文只介绍几种常用的方法。 tail（最常使用） 命令格式: tail[必要参数][选择参数][文件] 123tail -n 10 test.log 查询日志尾部最后10行的日志;tail -n +10 test.log 查询10行之后的所有日志;tail -fn 10 test.log 循环实时查看最后10行记录(最常用的) 一般还会配合着grep搜索用，例如 : 1tail -fn 1000 test.log | grep &#x27;关键字&#x27; 如果一次性查询的数据量太大,可以进行翻页查看，例如： 1tail -n 4700 aa.log |more -1000 可以进行多屏显示(ctrl + f 或者 空格键可以快捷键) 其它配合的命令 123456history # 所有的历史记录history | grep XXX # 历史记录中包含某些指令的记录history | more # 分页查看记录history -c # 清空所有的历史记录!! 重复执行上一个命令查询出来记录后选中 : !323 怎么让进程后台运行？ 命令后面加上**&amp;**即可，实际上，这样是将命令放入到一个作业队列中了； 通常配合nohup ，忽略发送给子命令的挂断SIGHUP信号（终端关闭）： 1nohup subcommand &amp; ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程； ctrl + c 是进程终止。 运行指令前面**+ setsid**，使其父进程编程init进程，不受SIGHUP信号的影响。 2.1.2 其它问题 1.请问/proc 目录有什么用？ Linux系统上的/proc目录是一种文件系统，即proc文件系统。 /proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件： 查看系统有关（1）硬件及当前（2）正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。 2. Linux的软/硬链接是什么？有什么区别？ 参考：“软链接”和“硬链接”的区别 什么是链接 ？ 文件在Linux上被分成两部分：用户数据 (user data) 与元数据 (metadata) 。 用户数据：即文件数据块，保留记录文件真实内容的地方 元数据： 是文件的附加属性，如创建大小、时间，所有信息等。其中inode号 ，是文件的唯一标识。 系统通过inode号快速找到文件，有一种方式可以快速寻找到数据元信息，那就是软/硬链接。 现在我们创建一个新文件myfile： 1234$ touch myfile &amp;&amp; echo &quot;This is a plain text file.&quot; &gt; myfile$ cat myfileThis is a plain text file. 来展示二者区别。 硬链接 建立 myfile 的一个硬链接 hard ，可以看到二者的inode 是一致的，也就是说指向了同一个物理区块。 硬链接inode ：指向文件的地址 &amp; 维护了一个引用计数，只要有文件还指向这个区块，它就不会从硬盘消失。 12345$ ln myfile hard # 建立硬链接hard$ ls -li25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 hard25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 myfile 操作硬链接更新文件，等价更新原文件 使用hard硬链接修改文件，发现原文件也被修改了。 12345$ echo &quot;New line&quot; &gt;&gt; hard$ cat myfileThis is a plain text file.New line 删除原文件，使用硬链接依旧可以显示 因为磁盘块还有硬链接在引用，所以不会消失。 12345$ rm myfile # 删除原文件$ cat hard # 硬链接依旧可以显示This is a plain text file.New line 软链接 建立一个soft软链接如下，可以看到二者的inode号是不一样的。 软连接的inode ：保存真实的文件的绝对路径地址，找到软链接，还要根据inode号找到真实文件路径。 12345$ ln -s myfile soft # 建立软连接soft$ ls -li25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 myfile25869216 lrwxr-xr-x 1 unixzii staff 6 7 8 17:47 soft -&gt; myfile 操作软链接更新文件，等价更新原文件 因为软链接就是相当个快捷方式，当然更新原文件。 删除原文件，使用软链接不会显示 因为软件inode指向的绝对地址，已经不存在文件了，所以当然不存在文件了。 1234$ rm myfile$ cat softcat: soft: No such file or directory 软硬连接区别总结 inode号不同。硬链接原文件/链接文件公用一个inode号，说明他们是同一个文件，而软链接原文件/链接文件拥有不同的inode号，表明他们是两个不同的文件； 链接数目不同。 软链接的链接数目不会增加；硬链接每多一个链接就会+1。 文件大小不同。硬链接文件显示的大小是跟原文件是一样 ；软链接显示的大小与原文件就不同了，BBB大小是95B，而BBBsoft是3B，因为BBB共有3个字符。 文件系统限制。 软链接没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。 建立软链接就是建立了一个新文件：当访问链接文件时，系统就会发现他是个链接文件，它读取链接文件找到真正要访问的文件。 3. 查询日志的top10 IP? 命令如下： 1cat log | cut -d &#x27; &#x27; -f 1 | sort | uniq -c | sort -nr | awk &#x27;&#123;print $0&#125;&#x27; | head -n 10 cat *.log ：将文本内容打印到屏幕 cut：截取指定IP那一列 sort ，按IP ASCII码排序：进行排序，默认是按照ascii码进行排序的 uniq -c ，统计重复的IP ：统计相邻的行的重复数量，结果是类似 3 127.13.13.13 ，前面的数字代码重复的行数 sort|uniq -c 统计重复的行数 sort -n，再次排序 ：是按照数值进行由小到大进行排序， -r是表示逆序，-t是指定分割符，-k是执行按照第几列进行排序 awk ，只显示IP：按照分割符将一行分割为多个列，第一列用1表示，第二列用​2表示，依次类推 awk -F&quot; &quot; '&#123;print $2&#125; ，表示用空格作为分隔符进行分割，打印出第2列 head -n ：表示取前n个 2.2 Git 讲git原理的的一篇不错文章 2.2.1 常问命令 1.什么是Git？是用什么语言编写的？ Git是一个 分布式 代码控制系统 ； Git使用 C 语言编写：使得 GIT 很快，C 语言减少运行时开销来做到这一点。 2.如何在Git中创建存储库？ 如果项目不存在，创建 然后运行 git init ，会在目录下创建一个 .git 目录 3.列举工作中常用的几个git命令？ git add : 增加文件 git commit -m ：提交文件 git status ：拉取远程分支 git push ：合并当前分支和主分支 git pull OR git fetch/git merge ：拉取远程分支 4.讲讲Git commit 基本参数？ 参考：https://www.cnblogs.com/qianqiannian/p/6005628.html git commit -m “message” ：简要说明这次提交的语句 git commit -a ：即使没有经过 git add ，也可以将所有 修改 或 删除 的文件提交到本地仓库，但新建的文件不会提交 git commit --amend ：追加提交，它可以在不增加一个新的commit-id 的情况下将新修改的代码追加到前一次的commit-id中， 5.在Git中，你如何还原已经 push 并公开的提交？ 删除或修复新提交中的错误文件，并将其覆盖推送到远程存储库： 1git commit -m &quot;commit message&quot; 创建一个新的提交，撤消在错误提交中所做的所有更改： 1git revert &lt;name of bad commit&gt; 6. git pull 和 git fetch 有什么区别？ git pull 取回远程主机某个分支的更新，再与本地的指定分支合并 （可能要解决冲突）。 git fetch 从远程获取最新版本到本地，不会自动合并 ，需要手动执行 git merge 7.什么是 git stash?你一般什么情况下会使用它？ 经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是git stash命令。储藏(stash)可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用 使用情况： 当前分支还没处理完，不能去commit提交，但是要去处理一个紧急开发项目，使用 git stash 处理完后git stash pop 继续处理工作 8.如果本次提交误操作，如何撤销？ 场景1:改乱了（包括删除等）工作区某个文件的内容（git add 之前）： 1git checkout -- &lt;file&gt; 丢弃之前所有的修改。 场景2:撤销提交到索引区的文件 （git add 之后）： 1git reset HEAD &lt;file&gt; 此时回到了场景1，然后再使用 git checkout 场景3： 撤销已经提交之后的文件（git commit之后）： 回退版本号。 12$ git reflog # 查看版本$ git reset --hard 3928 # 回退版本 场景4： 撤销已经push到远程分支之后的文件（git push之后） 创建一个新的提交，撤消在错误提交中所做的所有更改： 1git revert &lt;name of bad commit&gt; 删除或修复新提交中的错误文件，并将其覆盖推送到远程存储库： 1git commit -m &quot;commit message&quot; 9.使用过git merge和git rebase吗？它们之间有什么区别？ 都是用来合并分支的，但是： git merge &lt;当前分支要合并的分支&gt; ： 在当前分支合并&lt;指定要合并的分支&gt;，会自动在当前分支（下图为master）创建一个commit节点，保留了要合并的分支（下图为branch1）的提交记录 git rebase &lt;当前分支变基的基点分支&gt; ：相当将当前分支（下图为branch1）的分支节点（5,6） 依次提交到基点分支（master）的4节点之后，保留了更干净的历史记录，没有生成行的commit 节点","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://hwh.zone/tags/Git/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Linux","slug":"Linux","permalink":"https://hwh.zone/tags/Linux/"}]},{"title":"校招笔记（一）_Java_JVM","slug":"校招笔记（一）_Java_JVM","date":"2021-11-26T12:06:06.920Z","updated":"2021-12-03T03:56:42.625Z","comments":true,"path":"p/42516/","link":"","permalink":"https://hwh.zone/p/42516/","excerpt":"","text":"我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。 备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 1.6 JVM相关 1.6.1 常问问题 1. （被问过）JVM启动的基本配置参数有哪些？（或者说调优参数） 「堆栈内存相关」 -Xms： 设置初始堆的大小 -Xmx： 设置最大堆的大小 -Xmn ：设置年轻代大小，相当于同时配置-XX:NewSize和-XX:MaxNewSize为一样的值 -Xss： 每个线程的堆栈大小 -XX:NewSize 设置年轻代大小(for 1.3/1.4) -XX:MaxNewSize 年轻代最大值(for 1.3/1.4) -XX:NewRatio 年轻代与年老代的比值(除去持久代) -XX:SurvivorRatio Eden区与Survivor区的的比值 -XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。 -XX:MaxTenuringThreshold设定对象在Survivor复制的最大年龄阈值，超过阈值转移到老年代 「垃圾收集器相关」 -XX:+UseParallelGC：选择垃圾收集器为并行收集器。 -XX:ParallelGCThreads=20：配置并行收集器的线程数 -XX:+UseConcMarkSweepGC：设置年老代为并发收集。 -XX:CMSFullGCsBeforeCompaction=5 由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行5次GC以后对内存空间进行压缩、整理。 -XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片 「辅助信息相关」 -XX:+PrintGCDetails 打印GC详细信息 -XX:+HeapDumpOnOutOfMemoryError让JVM在发生内存溢出的时候自动生成内存快照,排查问题用 -XX:+DisableExplicitGC禁止系统System.gc()，防止手动误触发FGC造成问题. -XX:+PrintTLAB 查看TLAB空间的使用情况 2.说说堆和栈的区别？ 功能不同：栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象； 注：无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。 共享性不同：栈内存是线程私有的； 堆内存是所有线程共有的； 异常错误不同：如果栈内存或者堆内存不足，都会抛出异常但不同； 栈空间不足：java.lang.StackOverFlowError。 堆空间不足：java.lang.OutOfMemoryError； 空间大小：栈的空间大小远远小于堆的。 3.【重点】请问JVM运行时内存布局分布？ 哪些是线程共享的？ 从概念上大致分为 6 个（逻辑）区域，参考下图。注：Method Area 中还有一个常量池区，图中未明确标出。 总的来看，JVM 把内存划分为“栈(stack)”与“堆(heap)”两大类 线程私有的： 程序计数器：当同时进行的线程数超过CPU数或其内核数时，就要通过时间片轮询分派CPU的时间资源，不免发生线程切换。这时，每个线程就需要一个属于自己的计数器来记录下一条要运行的指令； 虚拟机栈： 每个java方法执行时都会创建一个桢栈来存储方法的： 变量表、操作数栈、动态链接方法、返回值、返回地址等信息； 栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法），“栈帧参考” ； 本地方法栈： 与虚拟机栈作用相似。但它不是为Java方法服务的，而是调用操作系统原生本地方法时，所需要的内存区域。 本地方法被执行的时候，在本地方法栈也会创建⼀个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。 线程共享的： 堆：GC 垃圾回收的主站场，用于存放类的实例对象及 数组实例等； 方法区： 线程共享的，用于存放被虚拟机加载的类的元数据信息： 如 常量、静态变量和 即时编译器编译后的代码； 运行时常量池：字符串，int -128~127 范围的值等，它是 方法区 中的一部分。 3.1 JVM 堆中又怎么分的？为什么要这么划分？为什么要取消永久代用元空间代替？ 参考：https://zhuanlan.zhihu.com/p/111809384 堆划分：堆又被划分为，新生代，老年代。新生代又被划分为eden和survivor区。 为什么划分新生代、老年代？ 因为有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率。 代替： 在java7版本前，堆和方法区连在了一起，但这并不能说堆和方法区是一起的，它们在逻辑上依旧是分开的。但在物理上来说，它们又是连续的一块内存。 也就是说，方法区和前面讲到的Eden和老年代是连续的。 永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。 在Java8中，元空间(Metaspace)登上舞台，方法区存在于元空间(Metaspace)。同时，元空间不再与堆连续，而且是存在于本地内存（Native memory）。本地内存（Native memory），也称为C-Heap，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。 元空间存在于本地内存，意味着只要本地内存足够，它不会出现像永久代中“java.lang.OutOfMemoryError: PermGen space”这种错误。看上图中的方法区，是不是“膨胀”了。 3.2 程序计数器存哪些东西？能为空吗？ 程序计数器是用于存放下一条指令所在单元的地址的地方。 如果正在执行的是Native方法，这个计数器值为空（Ubdifined）。 4. （新）说一下Java创建对象的过程？ 类加载检查： 虚拟机遇到⼀条 new 指令时，⾸先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 分配内存： 在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把⼀块确定大小的内存从 Java 堆中划分出来。 （重要）分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整⼜由所采用的垃圾收集器是否带有压缩整理功能决定。 初始化对象字段零值。 内存分配完成后，进行对象初始化操作。 例如给对象中（区分类加载过程，初始化类变量）所有的基本数据变量赋上初始化值， 当我们没有对它们进行赋值操作时就可以使用对象了。 设置对象头： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 执行init() &amp; 构造函数。然后执行对象内部生成的init方法，然后执行构造器方法（程序员设置的）。 内存地址赋给引用： 在虚拟机会将刚创建好对象的内存地址赋给引用对象。完成此操作后，便可以在程序中通过引用访问对象的实例数据。 4.1 什么是指针碰撞？空闲列表？TLAB? 三种虚拟机划分堆内存区域的方法，TLAB也可用来给堆内存分配空间。 指针碰撞 一般情况下，JVM的对象都放在堆内存中（发生逃逸分析除外）。当类加载检查通过后，Java虚拟机开始为新生对象分配内存。 如果Java堆中内存是绝对规整的，所有被使用过的的内存都被放到一边，空闲的内存放到另外一边，中间放着一个指针作为分界点的指示器，所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例，这种分配方式就是指针碰撞。 空闲列表 如果Java堆内存中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，不可以进行指针碰撞。 虚拟机必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表。 TLAB TLAB 是虚拟机在内存的eden 区划分出来的一块专用空间，是线程专属的。 在启用TLAB 的情况下，当线程被创建时，虚拟机会为每个线程分配一块TLAB 空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提高分配效率。 虚拟机通过 -XX:UseTLAB 设定它的。 4.2 JVM如何保证对象分配的线程安全问题？ 因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全： TLAB： 为每⼀个线程预先在Eden区分配⼀块⼉内存TLAB，JVM在给线程中的对象分配内存时，⾸先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用的CAS进行内存分配。 CAS+失败重试： CAS 是乐观锁的⼀种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为⽌。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。 5.描述一下对象分配【原则】？（区分前面new对象【过程】） JVM 中的堆可划分为两大部分，新生代和老年代，大小比例为1:2： 新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to 区 具体回收过程： 对象的正常流程：Eden 区 -&gt; Survivor 区 -&gt; 老年代。 新的对象优先在 Eden 区分配（大对象直接进入老年区，避免在Eden区及两个Survivor区之间发生大量的内存复制） ,当 Eden 区没有足够空间时，会发起一次Minor GC； Minor GC采用复制回收算法的改进版本回收Eden中对象： 先将Eden存活对象迁移到 to 区，然后清空Eden 最后交换to和from区域标签 每经过一次Minor GC （在交换区）后对象年龄加1，对象年龄达到15次后将会晋升到老年代； 对象提前晋升到老年代，动态年龄判定：如果在 Survivor 区中相同年龄所有对象大小总和大于 Survivor 区大小的一半， 年龄大于或等于该年龄的对象就可以直接进入老年代； 老年代空间不够时进行Full GC。 5.1 对象一定分配到堆上吗？ 参考：面试官：是不是所有的对象和数组都会在堆内存分配空间 小伙，来给我讲一下是不是所有的对象和数组都会在堆内存分配空间？ 并不是，这涉及到对象逃逸。请看下面的代码： StringBuffer对象，最终会被return，也就是会被该方法之外的给利用。 发生了对象逃逸。 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。 但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。 6.对象的访问定位有哪两种方式? 建⽴对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，⽬前主流的访问方式有：①使用句柄和 ②直接指针两种。 句柄： 如果使用句柄的话，那么Java堆中将会划分出⼀块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据（存放在方法区）各⾃的具体地址信息； 使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。 直接指针： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。 使用直接指针访问方式最大的好处就是速度快，它节省了⼀次指针定位的时间开销。 7.如何判断对象是否需要回收（死亡）？ 可达性分析：根据引用的关系构造引用链（有向图），在图中不可达的对象就是要被回收的； 引用计数：有地方引用该对象，计数器++，引用失效，计数器–，有循环引用的问题。 8. 如何判断一个常量是废弃变量？如何判断一个类是无用类？ 判断常量是废弃变量 运行时常量池主要回收的是废弃的常量。 假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量&quot;abc&quot; 就是废弃常量，如果这时发⽣内存回收的话而且有必要的话，“abc” 就会被系统清理出常量池。 判断类是无用类？ 虚拟机可以对满足下面3个条件的无用类进行回收，这⾥说的仅仅是“可以”，而并不是和对象⼀样不使用了就会必然被回收。 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例； 加载该类的 ClassLoader 已经被回收； 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 1.6.1 GC相关 不错的GC介绍文章：一文看懂 JVM 内存布局及 GC 原理 1.请介绍GC基本原理？有什么优点？GC可以马上回收内存吗？如何主动让虚拟机回收？ 当程序员创建对象时，GC就开始监控这个对象的地址、大小及使用情况 ，当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间 ： 基本原理： GC采用有向图的方式记录和管理堆(heap)中的所有对象 ，并确定对象是否“可达” GC优点：（1）使得程序员不用考虑内存管理 （2）Java中的对象不再有&quot;作用域&quot;的概念，只有对象的引用才有&quot;作用域&quot; （3）有效防止内存泄漏 马上回收： 程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。 主动回收： 手动执行System.gc() ，但是Java语言规范 并不保证 GC一定会执行。 1.1 本地java程序默认启动的是什么垃圾回收器？ cmd执行命令： 1java -XX:+PrintCommandLineFlags -version 输出：-XX：UseParallelGC。 2.什么是GC Root？可以作为GC Root的对象？ GC Root ： 判断对象是通过可达性分析，所以所有的可达性算法都会有起点 ，这就是 GC Root。 特点：当前时刻存活的对象！ 通过GC Root 找出所有活的对象，那么剩下所有的没有标记的对象就是需要回收的对象。 GC Root对象： （1）虚拟机栈中引用的对象；（2）方法区中的静态变量、常量对象；（3）本地方法引用的对象；（4）被synchronized修饰的对象等。 3.哪些内存区域需要GC? （无需）线程独享区域：PC Regiester、JVM Stack、Native Method Stack，其生命周期都与线程相同（即：与线程共生死），所以无需 GC; （需）线程共享的 Heap 区、Method Area 则是 GC 关注的重点对象。 4.什么时候会触发Full GC？ 调用 System.gc() ； 老年代空间不足； 通过Minor GC后进入老年代的平均大小大于老年代的可用内存； 如果发现统计之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC。 方法区空间不足。 JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space 。 为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。 5.什么时候触发 Minor GC ? 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？ 什么时候触发Minor GC ? 当Eden区不足时就会触发 Minor GC 。 minor gc运行频繁 产生了太多朝生夕灭的对象导致需要频繁minor gc 新生代空间设置太小 minor gc运行很慢 新生代空间设置过大； 对象引用链较长，进行可达性分析时间较长； 新生代survivor区设置的比较小，清理后剩余的对象不能装进去需要移动到老年代，造成移动开销； 内存分配担保失败，由minor gc转化为full gc； 采用的垃圾收集器效率较低，比如新生代使用serial收集器。 6.描述一下GC算法？ GC算法包含：引用计数法，标记清除，标记复制，标记压缩。 引用计数：对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用； 标记清除： 垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象；然后，在清除阶段，清除所有未被标记的对象，但会产生很多垃圾碎片 ； 标记复制： 将内存对半分，总是保留一块空着（上图中的右侧），将左侧存活的对象（浅灰色区域）复制到右侧。避免了内存碎片问题，但是内存浪费很严重，相当于只能使用 50%的内存； 标记压缩（标记整理）：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存（类似于 windows 的磁盘碎片整理），避免垃圾碎片。 6.1 新生代和老年代用哪些算法？stw问题会发生在新生代吗? 针对新生代，采用标记复制算法 参考：https://tech.meituan.com/2017/12/29/jvm-optimize.html 大多数对象在新生代中被创建，其中很多对象的生命周期很短。每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。 HotSpot实现的复制算法流程如下: 当Eden区满的时候,会触发第一次Minor gc，把还活着的对象拷贝到Survivor From区；当Eden区再次触发Minor gc的时候,会扫描Eden区和From区域，对两个区域进行垃圾回收,经过这次回收后还存活的对象,则直接复制到To区域,并将Eden和From区域清空。 当后续Eden又发生Minor gc的时候,会对Eden和To区域进行垃圾回收,存活的对象复制到From区域,并将Eden和To区域清空。 部分对象会在From和To区域中复制来复制去，如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15)，最终如果还是存活,就存入到老年代。 针对老年代对象存活率高的特点 在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。 老年代的垃圾回收（又称Major GC）通常使用标记-清理或标记-整理算法。整堆包括新生代和老年代的垃圾回收称为Full GC（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。 7.什么是Stop The World ? 什么是安全点？安全区域？ Stop The World 进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为「Stop The World」。也简称为STW。JVM在暂停的时候，需要选准一个时机。 由于JVM系统运行期间的复杂性，不可能做到随时暂停，因此引入了安全点的概念。 安全点 安全点，即程序（非GC先）执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。 安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，Java虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。只要不离开这个安全点，Java虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。 如何保证中断时所有线程都在安全点 抢先式中断（Preemptive Suspension） 抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机采用这种方式来暂停线程从而响应GC事件。 主动式中断（Voluntary Suspension） 主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 8. 常见的垃圾回收器有哪些（比如G1）？ Serial收集器。 Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是⼀个单线程收集器了。它的单线程 的意义不仅仅意味着它只会使用⼀条垃圾收集线程去完成垃圾收集⼯作，更重要的是它在进行垃圾收集⼯作的时候必须暂停其他所有的⼯作线程（ “Stop The World”），直到它收集结束。 ParNew收集器。 ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全⼀样。 新⽣代采用标记-复制算法，⽼年代采用标记-整理算法。 Parallel Scavenge收集器。 Parallel Scavenge 收集器类似于ParNew 收集器。 那么它有什么特别之处呢？ Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量。 如果对于收集器运作不太了解的话，⼿⼯优化存在的话可以选择把内存管理优化交给虚拟机去完成也是⼀个不错的选择。- 新⽣代采用标记-复制算法，⽼年代采用标记-整理算法。 （重点）CMS收集器。CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的。 CMS收集器仅作用于老年代的收集，基于 “标记-清除” 。 优点： 并发收集、低停顿。 缺点（快手）： CMS收集器对CPU资源非常敏感；CMS收集器无法处理浮动垃圾（Floating Garbage）。 （重点）G1收集器。 G1重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。区域划分的好处就是带来了停顿时间可预测的收集模型：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。 并行与并发：G1能充分利⽤CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核⼼）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。 分代收集：虽然G1可以不需要其他收集器配合就能独⽴管理整个GC堆，但是还是保留了分代的概念。 空间整合：与CMS的“标记–清除”算法不同，G1从整体来看是基于标记-整理算法实现的收集器；从局部上来看是基于标记-复制算法实现的。 可预测的停顿：这是G1相对于CMS的另⼀个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建⽴可预测的停顿时间模型，能让使用者明确指定在⼀个⻓度为M毫秒的时间片段内。 8.1 介绍一下CMS 和 G1 垃圾回收器原理？ 参考：弄明白CMS和G1，就靠这一篇了 CMS收集器 CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的。 CMS收集器仅作用于老年代的收集，是基于标记-清除算法的，它的运作过程分为4个步骤： 初始标记（CMS initial mark） : 需要STW，标记一下GC Roots能直接关联到的对象 ； 并发标记（CMS concurrent mark）：从GC Roots开始堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行； 重新标记（CMS remark）：需要STW ，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录 ； 并发清除（CMS concurrent sweep）： 清除对象。 G1收集器 在堆的结构设计时，G1打破了以往将收集范围固定在新生代或老年代的模式，G1将堆分成许多相同大小的区域单元，每个单元称为Region。Region是一块地址连续的内存空间，G1模块的组成如下图所示： 区域划分的好处就是带来了停顿时间可预测的收集模型：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。 和CMS挺像的。 初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。 并发标记（Concurrent Marking）：是从GC Roots开始堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。 最终标记（Final Marking）：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。 筛选回收（Live Data Counting and Evacuation）：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。 8.2 为什么CMS不用标记-压缩算法？ CMS主要关注低延迟，因而采用并发方式。 在并发清理垃圾时，如果采用压缩算法，这涉及到移动存活的对象。如果不进行停顿会很难处理，违背了CMS初衷，所以采用标记-清除算法。 9.什么是内存泄漏？ 广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄漏。 内存泄漏场景： 静态集合类、数组添加对象以后遗漏了对于他们的处理，例如HashMap和Vector； 各种连接，如数据库连接、网络连接、IO连接； 单例模式； 变量不合理的作用域。 1.6.2 类加载 1. 介绍一下类文件结构？ Class⽂件字节码结构组织示意图 。 魔数: 确定这个⽂件是否为⼀个能被虚拟机接收的 Class ⽂件。 Class ⽂件版本：Class ⽂件的版本号，保证编译正常执行。 常量池 ：常量池主要存放两大常量：字面量和符号引用。 访问标志：标志用于识别⼀些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。 当前类索引,⽗类索引 ：类索引用于确定这个类的全限定名，⽗类索引用于确定这个类的⽗类的全限定名，由于 Java 语⾔的单继承，所以⽗类索引只有⼀个，除了 java.lang.Object 之外，所有的 java 类都有⽗类，因此除了 java.lang.Object 外，所有 Java 类的⽗类索引 都不为 0。 接口索引集合：接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 implents (如果这个类本身是接口的话则是 extends ) 后的接口顺序从左到右排列在接口索引集合中。 字段表集合：描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。 方法表集合 ：类中的方法。 属性表集合： 在 Class ⽂件，字段表，方法表中都可以携带⾃⼰的属性表集合。 2. 什么是类加载器？请你解释一下java程序运行的过程？ 参考 ： 一个简单java程序的运行全过程 类加载器是一个用来加载类文件的类 。 我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存。主要分为以下3大步、5小步： 编译。 将编译的.java 文件编译为.class字节码文件，然后交给JVM运行； 加载 ：class字节码文件从各个来源通过类加载器装载入内存中 。 来源：包本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译 类加载器 ：一般包括启动类加载器，扩展类加载器，系统类加载器，以及用户的自定义类加载器 （代码加密防止反编译）。 链接： 分为，验证、准备、解析（”正-中-准-心“）三阶段 验证： 保证加载进来的字节流符合虚拟机规范； 文件格式的验证，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？ 元数据的验证，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？ 字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。 符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？ 准备：类变量（注意，不是实例变量 ）分配内存，并且赋予初值（虚拟机根据不同类型设定的初始值）； 这些变量所使用的内存都将在方法区中进行分配 ，进行零初始化： 即数字类型初始化为 0 ，boolean 初始化为 false，引用类型初始化为 null 等 解析：将常量池内的 符号引用 替换为 直接引用 的过程。 符号引用：即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。 直接引用：可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量。 🌾 实例： 调用方法hello()，方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。 初始化。 初始化就是执行类的 cinit()的过程。 ❔ 和准备阶段那个初始化看得我有点迷糊？ 在编译阶段，编译器收集所有的静态字段的赋值语句及静态代码块，并按 语句出现的顺序 拼接出一个类初始化方法 &lt;clinit&gt;()。此时，执行引擎会调用这个方法对静态字段进行代码中编写的初始化操作。 3.知道类的生命周期吗？ 在类加载的过程再加上： 使用。new出对象程序中使用 卸载。执行垃圾回收 4.请你介绍一下类加载器？ JVM预定义的三种类型类加载器： 启动类加载器（BootstrapClassLoader）：是一般用本地代码实现，负责将 &lt;Java_Runtime_Home&gt;/lib下面的类库加载到内存中； 标准扩展类加载器（ExtensionClassLoader）：&lt; Java_Runtime_Home &gt;/lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中； 系统类加载器（AppClassLoader）：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量或者系统属性java.class.path所指定的目录中加载类，是用户自定义加载器的默认父加载器。 5.请你介绍一下双亲委派机制？为什么要这么做？ 双亲委派机制。某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载； 为什么要这么做？防止内存中出现多份同样的字节码 。 比如两个类A和类B都要加载System类： 如果不用委托：而是自己加载自己的，那么类A就会加载一份System字节码，然后类B又会加载一份System字节码，这样内存中就出现了两份System字节码。 如果使用委托机制：会递归的向父类查找，也就是首选用Bootstrap尝试加载，如果找不到再向下。这里的System就能在Bootstrap中找到然后加载，如果此时类B也要加载System，也从Bootstrap开始，此时Bootstrap发现已经加载过了System那么直接返回内存中的System即可而不需要重新加载，这样内存中就只有一份System的字节码了。 5.1 如何自定义类加载器 ，如何打破双亲委派机制 ？ 自定义类加载器 &amp; 打破双亲委派机制 在实现自己的ClassLoader之前，我们先看一下JDK中的ClassLoader是怎么实现的： 1234567891011121314151617181920212223 1 protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) 2 throws ClassNotFoundException 3 &#123; 4 // First, check if the class has already been loaded 5 Class c = findLoadedClass(name); 6 if (c == null) &#123; 7 try &#123; 8 if (parent != null) &#123; 9 c = parent.loadClass(name, false);10 &#125; else &#123;11 c = findBootstrapClass0(name);12 &#125;13 &#125; catch (ClassNotFoundException e) &#123;14 // If still not found, then invoke findClass in order15 // to find the class.16 c = findClass(name);17 &#125;18 &#125;19 if (resolve) &#123;20 resolveClass(c);21 &#125;22 return c;23 &#125; 1、如果不想打破双亲委派模型，那么只需要重写findClass方法即可 （1）继承ClassLoader （2）重写findClass()方法 2、如果想打破双亲委派模型，那么就重写整个loadClass方法 （1）继承ClassLoader （2）重写findClass()方法6 （3）调用defineClass()方法 tomcat 为什么要违背双亲委托机制？ 双亲委托机制不能满足tomcat的业务需求； Webapp类加载器需要独立加载自身的class以及依赖的jar； 例如，webapp1依赖的spring版本为4.x，另一个webapp2依赖的spring版本为5.x. 如果使用双亲委托，那么spring的版本只能存在一个，没法满足这个需求。","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"JAVA","slug":"校招笔记/JAVA","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://hwh.zone/tags/JAVA/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"}]},{"title":"校招笔记（一）_Java_锁","slug":"校招笔记（一）_Java_锁","date":"2021-11-26T12:03:48.668Z","updated":"2021-12-03T03:57:29.165Z","comments":true,"path":"p/45493/","link":"","permalink":"https://hwh.zone/p/45493/","excerpt":"","text":"我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。 备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 1.5 锁 【新增】 java常用的并发工具类？ 这篇不错：《今天面试了吗》- 并发编程之AQS同步工具类 JUC就是java.util.concurrent包，这个包俗称JUC，里面都是解决并发问题。 常用四大并发工具包（以下都是基于AQS实现的）： CountDownLatch： CyclicBarrier描述的是“允许一组线程相互等待，直到到达某个公共屏障点，才会进行后续任务”。 而CountDownLatch所描述的是“在完成一组正在其他线程中执行的操作之前，它允 一个或多个线程一直等待”。 在API中是这样描述的：用给定的计数初始CountDownLatch。由于调用了countDown方法，所以在当前计数到达零之前，await方法会一直受阻塞。之后，会释放所有等待的线程，await的所有后续调用都将立即返回。这种现象只出现一次（计数无法被重置。如果需要重置计数，请考虑使CyclicBarrier）。 CyclicBarrier：CyclicBarrier是一个同步辅助类。它允许一组线程互相等待，直到到达某个公共屏障点。在涉及一组固定大小的线程的程序里，这些线程必须不时的互相等待，此时CyclicBarrier 很有用。因为CyclicBarrier在释放等待线程后可以重用，因此成为循环的屏障。 使用**await()**方法，每个线程调用await()方法告诉CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。当所有线程都到达了屏障，结束阻塞，所有线程可继续执行后续逻辑。 Semaphore：信号量Semaphore是一个控制访问多个共享资源的计数器，和CountDownLatch一样，其本质上是一个“共享锁”。在API是这么介绍信号量的：一个计数信号量，从概念上讲，信号量维护了一个许可集。 ExChanger ：Exchanger是一个同步器，字面上就可以看出这个类的主要作用是交换数据。Exchanger有点类似CyclicBarrier，前面说到CyclicBarrier是一个栅栏，到达栅栏的 线程需要等待一定数量的线程到达后，才能通过栅栏。Exchanger可以看成是一个双向的栅栏。线程1到达栅栏后，会首先观察有没有其他线程已经到达栅栏，如果没有就会等待。如果已经有其他线程（比如线程2）到达了，就会以成对的方式交换各自携带的信息，因此Exchanger非常适合两个线程之间的数据交换。 1.5.1 synchronized 相关 1.1 [重点]说一说自己对于 synchronized 关键字的了解? synchronized 底层原理 ? 参考：Java面试常见问题：Monitor对象是什么？ 深入分析Synchronized原理(阿里面试题) 基本了解 synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock 来实现的； Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。 moniter介绍 Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用。 在HotSpot虚拟机中，Monitor是基于C++的ObjectMonitor类实现的，其主要成员包括： _owner：指向持有ObjectMonitor对象的线程 _WaitSet：存放处于wait状态的线程队列，即调用wait()方法的线程 EntryList：存放处于等待锁block状态的线程队列 _count：约为_WaitSet 和 _EntryList 的节点数之和 _cxq: 多个线程争抢锁，会先存入这个单向链表 _recursions: 记录重入次数 底层原理 synchronized 关键字底层原理属于 JVM 层面。 ① synchronized同步语句块的情况 1234567public class SynchronizedDemo &#123; public void method() &#123; synchronized (this) &#123; System.out.println(&quot;synchronized 代码块&quot;); &#125; &#125;&#125; 通过 JDK ⾃带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息： ⾸先切换到类的对应⽬录执行 javac SynchronizedDemo.java 命令⽣成编译后的 .class ⽂件，然后执行 javap -c -s-v -l SynchronizedDemo.class synchronized同步语句块的实现使用的是monitorenter和 monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。 当执行monitorenter 指令时，线程试图获取锁也就是获取 monitor的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1 ; monitor对象存在于每个Java对象的对象头中 synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因。 相应的在执行monitorexit 指令后，将锁计数器设为0，表明锁被释放； 如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外⼀个线程释放为⽌。 ② synchronized修饰方法的的情况 12345public class SynchronizedDemo2 &#123; public synchronized void method() &#123; System.out.println(&quot;synchronized 方法&quot;); &#125; &#125; synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是ACC_SYNCHRONIZED 标识，该标识指明了该方法是⼀个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问。 当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。 1.2 请你谈谈关于Synchronized和ReentrantLock？ 相似点 都是阻塞式同步：一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待； 线程阻塞和唤醒的代价是比较高的（操作系统需要在用户态与内核态之间来回切换，代价很高，不过可以通过对锁优化进行改善）。 都是可重入锁：是同一个线程可重复获得锁，每获得一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。 不同点 实现原理： Synchronized是java语言的关键字，是原生语法层面的互斥， JVM 层面；ReentrantLock是JDK 1.5后的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成； 是否避免死锁： synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；Lock不会主动适应 unLock() 释放，必须手动在finally释放；相⽐synchronized，ReentrantLock增加了⼀些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件） 线程等待可中断： Lock可以让等待锁的线程响应中断，线程可以中断去干别的事务；而synchronized却不行，使用synchronized时，等待的线程会一直等待下去； 公平锁： synchronized的锁是非公平锁，ReentrantLock默认情况下也是非公平锁，但可以通过带布尔值的构造函数要求使用公平锁； 选择性通知： synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。 Condition是JDK1.5之后才有的，它具有很好的灵活性，⽐如可以实现多路通知功能也就是在⼀个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使⽤notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，⽤ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有⼀个Condition实例，所有的线程都注册在它⼀个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。 1.3 synchronized锁住的是什么，在项目中遇到了吗？ synchronized本身并不是锁，锁本身是一个对象，synchronized最多相当于“加锁”操作，所以synchronized并不是锁住代码块。 （重点）Java中的每一个对象都可以作为锁，具体表示有三种形式： 面试中面试官经常会说：“单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁方式实现单例模式的原理呗！” 12345678910111213141516public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123;&#125; public synchronized static Singleton getUniqueInstance() &#123; //先判断对象是否已经实例过，没有实例化过才进⼊加锁代码 if (uniqueInstance WX null) &#123; //类对象加锁 synchronized (Singleton.class) &#123; if (uniqueInstance WX null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; uniqueInstance 采用 volatile 关键字修饰也是很有必要的， 1uniqueInstance = new Singleton(); 这段代码其实是分为三步执行： 为 uniqueInstance 分配内存空间 初始化 uniqueInstance 将 uniqueInstance 指向分配的内存地址 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致⼀个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回uniqueInstance，但此时 uniqueInstance 还未被初始化。 1.4 synchronized锁的优化机制了解吗？ 参考：死磕Synchronized底层实现 美团技术团队 synchronized本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括： 自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁； 锁的状态从低到高依次为：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁。 常见的锁： 无锁：无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。 锁到底存在哪里呢？答案就是对象头中。 对象头主要又包括了两部分数据：Mark Word（标记字段）、Class Point（类型指针）。 初始mark word 将是可偏向状态，此时的 是否偏向锁 为 0，表示当前没有任何一个线程持有该锁。 偏向锁：在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。 JDK1.6 中为了提高一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能，引入了偏向锁。在第一次获得锁时，会有一个 CAS 操作（见下）；之后该线程再获取锁，只会执行几个简单的命令，而不是开销相对较大的 CAS 命令。 CASE 1 : 线程第一次获得锁，如果未偏向，通过 CAS 指令： 插入线程ID : 向mark word插入线程ID 偏向锁标识：将 mark word 中的偏向锁标识从0→1 锁标志位：不修改！因为不变！ 如果操作成功：，则说明获得了偏向锁，以后当前线程等于owner就可以零成本的直接获得锁； 如果操作失败，说明有其它线程获取了锁： 如果偏向线程还存在：直接进行升级为轻量级锁； 如果偏向线程不存在：先修改锁标识为01→00 ，再升级为轻量级锁。 CASE 2 : 这是一次可重入，偏向线程是自己。 在当前线程栈中找到一个可用的 Lock Record ：并将其 obj 指向锁对象 &amp; Displaced Mark Word 置为null 轻量级锁：当发现多线程竞争时，偏向锁会升级为轻量级锁，一般来说，会在 safepoint（此时用户代码不会执行）中去查看偏向的线程是否还存活。 如果偏向的线程已经不存活或者不在同步块中，则将对象头的 mark word 改为无锁状态（unlocked），重新偏向新的线程； 如果存活且还在同步块中，原偏向的线程继续拥有锁，当前线程则走入到轻量级锁的加锁逻辑中； 轻量级锁的处理流程 ： 发现已经有偏向的线程了，则会先 撤 销偏向锁，然后升级为轻量锁 。通过CAS命令更新： 修改此前 当前线程栈帧Lock Record： （1）Displaced Mark Word 复制 mark word （此时无锁状态）中的现有内容 修改mark word ：mark word 指向当前线程栈帧Lock Record的 Displaced Mark Word的地址，见上图； 修改锁标志位： 01 → 00 上述CAS更新成功，则当前线程获得了对象的锁 ； 如果不成功： 检查Mark Word是否指向当前线程的栈帧的Lock Record ，是则是一次可重入 设置Lock Record第一部分（Displaced Mark Word）为null，起到了一个重入计数器的作用。然后结束。 如果不是则是进行自旋等待 当1.自旋超过一定的次数（默认10），或者2.一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。 重量级锁：内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。 Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁Monitor，称为内部锁或者Monitor锁。 Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。 如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。线程去获取重量级锁，其实就是就尝试获取对象的monitor锁。 即将 monitor锁的 Owner字段修改为当前线程ID 。 如果获取成功，此时线程获得了锁，CAS修改 ： 修改mark word ：然后将对象头mark word 改为指向该 monitor 的指针。 锁标志位：00 → 10 1.5 为什么说Synchronized是非公平锁，这样的优缺点是什么？ 并非是按照申请锁的时间前后给等待线程分配锁的，每当锁被释放后，任何一个线程都有机会竞争到锁。 优点：这样做的目的是为了提高执行性能； 缺点：是可能产生线程饥饿现象。 1.6 为什么说synchronized是一个悲观锁？乐观锁的实现原理又是什么？ 没看完，了解了下核心问题：https://www.cnblogs.com/jojop/p/14022029.html synchronized悲观锁 Synchronized显然是一个悲观锁，因为它的并发策略是悲观的： 不管是否会产生竞争，任何的数据都必须加锁。 synchronized原理 Synchronized是通过获取对象内部的一个叫做监视器锁（monitor）来实现的，每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权。 监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者； 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1； 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。 乐观锁实现原理：CAS 参考好文：一文彻底搞懂CAS实现原理 1.7 （CAS原理重点）什么是CAS？CAS的缺点？说说CAS源码实现？ 乐观锁的核心算法是CAS（Compared And Swap，比较并交换）： 关键逻辑： CAS，有几个重要的参数： （1）this，Unsafe 对象本身，需要通过这个类来获取 value 的内存偏移地址。 （2）valueOffset，value 变量的内存偏移地址。 （3）expect，期望更新的值。 （4）update，要更新的最新值。 如果原子变量中的 value 值等于 expect，则使用 update 值更新该值并返回 true，否则返回 false。 CAS特性： CAS具有原子性，它的原子性由CPU硬件指令实现保证。 【缺点1】ABA问题：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。 解决ABA： 在变量前面加上版本号，每次变量更新的时候变量的版本号都+1，即A-&gt;B-&gt;A就变成了1A-&gt;2B-&gt;3A 【缺点2】只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。 【缺点3】循环时间长开销大：对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。 CAS源码分析 参考：Java CAS 原理分析 CAS 全称是 compare and swap，是一种用于在多线程环境下实现同步功能的机制。 CAS 操作包含三个操作数 – 内存位置、预期数值和新值。CAS 的实现逻辑是将内存位置处的数值与预期数值想比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。 Java 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的，下面是具体分析。 背景介绍 在多核心时代下，多个核心通过同一条总线和内存以及其他硬件进行通信。 CPU 的多个核心同时对同一片内存进行操作，会导致错误。例如，递增指令inc dword ptr [...]，等价于DEST = DEST + 1。该指令包含三个操作读-&gt;改-&gt;写，涉及两次访存。 核心1,2从内存读取数据1，并写到各自寄存器中 核心1将寄存器中数据1→2 核心2将寄存器中数据1→2 然后都写回主存，此时为2 可以看到，由于核心2在核心1写入主存操作完成前进行读取，导致并不是我们期望的3 。 通过在递增inc 指令前添加 lock 前缀，可以让核心独占某个内存区域，由此可以避免上面问题。lock 前缀保证核心独占某片内存区域，有两种方式： 总线锁。总线被锁定后，其他核心就不能访问内存了，可能会导致其他核心短时内停止工作； 缓存锁。若某处内存数据被缓存在处理器缓存中，处理器发出的 LOCK# 信号不会锁定总线，而是锁定缓存对应的内存区域。其他处理器在这片内存区域锁定期间，无法对这片内存区域进行相关操作。（不是乐观机制都可以操作吗？不能写入内存？） 源码分析 我们分析，java.util.concurrent.atomic 包下的原子类 AtomicInteger 中的 compareAndSet 方法 。 AtomicInteger具体实现中，compareAndSet 实际上只是一个壳子，主要的逻辑封装在 Unsafe 的 compareAndSwapInt 方法中； compareAndSwapInt是一个native方法 1public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x); 123456789101112131415161718192021222324252627282930313233public class AtomicInteger extends Number implements java.io.Serializable &#123; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; // 计算变量 value 在类对象中的偏移 valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; public final boolean compareAndSet(int expect, int update) &#123; /* * compareAndSet 实际上只是一个壳子，主要的逻辑封装在 Unsafe的compareAndSwapInt 方法中 */ return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; // ......&#125;public final class Unsafe &#123; // compareAndSwapInt 是 native 类型的方法，继续往下看 public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); // ......&#125; 下面我们进入unsafe.cpp（compareAndSwapInt是native方法）具体实现中，看看调用： 12345678910111213141516171819202122232425// unsafe.cpp/* * 这个看起来好像不像一个函数，不过不用担心，不是重点。UNSAFE_ENTRY 和 UNSAFE_END 都是宏， * 在预编译期间会被替换成真正的代码。下面的 jboolean、jlong 和 jint 等是一些类型定义（typedef）： * */UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;); oop p = JNIHandles::resolve(obj); // 根据偏移量，计算 value 的地址。这里的 offset 就是 AtomaicInteger 中的 valueOffset jint* addr = (jint *) index_oop_from_field_offset_long(p, offset); // 调用 Atomic 中的函数 cmpxchg，该函数声明于 Atomic.hpp 中 return (jint)(Atomic::cmpxchg(x, addr, e)) == e;UNSAFE_END// atomic.cppunsigned Atomic::cmpxchg(unsigned int exchange_value, volatile unsigned int* dest, unsigned int compare_value) &#123; assert(sizeof(unsigned int) == sizeof(jint), &quot;more work to do&quot;); /* * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载 * 接下来分析 atomic_windows_x86.inline.hpp 中的 cmpxchg 函数实现 */ return (unsigned int)Atomic::cmpxchg((jint)exchange_value, (volatile jint*)dest, (jint)compare_value);&#125; 分析 Windows 平台下的 Atomic::cmpxchg 函数为例，看看具体实现。 123456789101112131415161718// atomic_windows_x86.inline.hpp#define LOCK_IF_MP(mp) __asm cmp mp, 0 \\ __asm je L0 \\ __asm _emit 0xF0 \\ __asm L0: inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) &#123; // 判断是否是多核 CPU int mp = os::is_MP(); __asm &#123; // 将参数值放入寄存器中 mov edx, dest // 注意: dest 是指针类型，这里是把内存地址存入 edx 寄存器中 mov ecx, exchange_value mov eax, compare_value LOCK_IF_MP(mp) // 核心比较写入操作 cmpxchg dword ptr [edx], ecx &#125;&#125; 其中LOCK_IF_MP实际内容如下： 12345678910111213141516171819202122232425 // LOCK_IF_MP cmp mp, 0 /* * 如果 mp = 0，表明是线程运行在单核 CPU 环境下。此时 je 会跳转到 L0 标记处， * 也就是越过 _emit 0xF0 指令，直接执行 cmpxchg 指令。也就是不在下面的 cmpxchg 指令前加 lock 前缀。 */ je L0 /* 0xF0 是 lock 前缀的机器码，这里没有使用 lock，而是直接使用了机器码的形式。*/ _emit 0xF0L0: /* * 比较并交换。简单解释一下下面这条指令，熟悉汇编的朋友可以略过下面的解释: * cmpxchg: 即“比较并交换”指令 * dword: 全称是 double word，在 x86/x64 体系中，一个 * word = 2 byte，dword = 4 byte = 32 bit * ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元 * [edx]: [...] 表示一个内存单元，edx 是寄存器，dest 指针值存放在 edx 中。 * 那么 [edx] 表示内存地址为 dest 的内存单元 * * 这一条指令的意思就是，将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值 * 进行对比，如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中。 */ cmpxchg dword ptr [edx], ecx &#125;&#125; 实际举例说明 AtomicInteger 类主要利用 CAS (compare and swap) + volatile 来保证原子操作。AtomicInteger 的主要方法都是通过调用Unsafe类方法去实现，如 compareAndSet 实际是调用AtomicInteger 的compareAndSwapInt方法。 下面以 getAndIncrement实现来说明。 getAndIncrement调用了 Unsafe的getAndAddInt方法，传递了（1）当前this对象，（2）value偏移量，用来计算得到value值（3）要加上的值，由于是递增所以是1 ⚠️ 为什么不传value的值，而是偏移量？ 传偏移量是为了计算value所在的内存地址，进而获取最新的value值。 getAndAddInt采用CAS方式进行更新，还需要进行当前期望值的计算 通过getIntVolatile获取到线程此时内存value值（期望值），也就是记录执行CAS前的内存最新value值； 然后开始执行Unsafe的 compareAndSwapInt ，主要是通过Atomic::cmpxchg 逻辑来实现 （1）将要dest（value内存地址），compareValue（期望值），exchange_value（要更新的值）写入寄存器中 （2）线程如果是运行多核CPU，上LOCK#锁，将dest内存区域锁住 ；否则不上LOCK#锁 （3）执行cmpxchg（比较并交换命令），如果dest的value值（执行CAS中的最新value值） == compareValue，则写入exchange_value ； （4）否则写入失败，通过不断自旋（循环）期望得到执行 1.8 请说明一下synchronized的可重入怎么实现？ 每个锁关联一个线程持有者对象和一个计数器。 当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁（即monitor对象）而调用相应方法。 当一个线程请求成功后，JVM对象头会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。 而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。 当线程退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁。 1.9 在synchronized偏向锁过程中，调用hashcode方法，markword会发生什么？ 第一次调用Hashcode：当对象的hashCode()方法（非用户自定义）第一次被调用时，JVM会生成对应的identity hash code值，并将该值存储到Mark Word中 。 后续如果该对象的hashCode()方法再次被调用则不会再通过JVM进行计算得到，而是直接从Mark Word中获取，保证唯一相同。 无锁状态：在无锁状态下，Mark Word中可以存储对象的identity hash code值 ； 偏向锁状态：需要计算其identity hash code的话，则它的偏向锁会被撤销（因为没有保存的位置），并且锁会膨胀为轻量级锁或者重量锁 ； 轻量锁状态：线程栈帧的Lock Recode可以记录存储Displaced Mark Word ，所以轻量级锁可以和identity hash code 共存 ； 重量级锁状态：ObjectMonitor类里有字段HashCode可以记录非加锁状态下的mark word，所以重量级锁也可以和identity hash code共存； 1.10 Synchronized 确定不可中断吗？如果一个线程访问Synchronized 代码，其它线程可以能否中断？比如使用Stop？是在中断前还是中断后获取锁？ 参考：https://blog.csdn.net/deel_feel/article/details/105771902 正确说法时：只有获取到锁之后才能中断，等待锁时不可中断。 1.5.2 Reetrantlock 相关 ReentrantLock意思为可重入锁 。 2.1 非公平锁和公平锁在reetrantlock里的实现过程是怎样的？ 美团技术文章-java-lock 公平锁：那么锁的 获取顺序 就应该符合请求的 绝对时间顺序，FIFO 非公平锁：只要CAS设置同步状态成功state，则表示当前线程获取了锁 但公平锁还需要判断当前节点是否有前驱节点，如果有，则表示有线程比当前线程更早请求获取锁，因此需要等待。 【源码分析】 基本结构 根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS，添加锁和释放锁的大部分操作实际上都是在Sync中实现的。 Sync有公平锁FairSync和非公平锁NonfairSync两个子类； ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。 公平和非公平锁区分 公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在CAS获取同步状态时，多了一个限制条件：hasQueuedPredecessors()。 该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。 2.2 ReentrantLock的实现原理？ ReentrantLock的实现基于队列同步（AbstractQueuedSynchronizer，后面简称AQS）。关于AQS的实现原理见下。 ReentrantLock的核心，是通过修改AQS中state的值来同步锁的状态。 2.3 希望等待一段时间锁没有获取，可以自动放弃用哪种锁？ Lock（ReentranLock） 但是基于AQS的源码哪里体现了？ 应该Lock锁的代码里自己的实现吧。 1.5.3 AQS 相关 3.1 什么是AQS请你简单介绍一下？ AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。 AQS是⼀个用来构建锁和同步器的框架，使⽤AQS能简单且高效地构造出应用⼴泛的大量的同步器。 例如：ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue等等皆是基于AQS的。当然，我们⾃⼰也能利⽤AQS非常轻松容易地构造出符合我们⾃⼰需求的同步器。 3.2 请介绍一下AQS原理？ 后续建议研读：从ReentrantLock的实现看AQS的原理及应用 先带着问题来进行看下面内容： Q：某个线程获取锁失败的后续流程是什么呢？ A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。 Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？ A：是CLH变体的FIFO双端队列。 Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？ A：可以详细看下2.3.1.3小节。 Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？ A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。 Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？ A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。 核心原理概览 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。 如果被请求的共享资源被占用，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是⽤CLH队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。 CLH(Craig,Landin,and Hagersten)队列是⼀个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成⼀个CLH锁队列的⼀个结点（Node）来实现锁的分配。 AQS使用⼀个int成员变量state来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队⼯作。AQS使⽤CAS对该同步状态进行原子操作实现对其值的修改。 1private volatile int state; //共享变量，使⽤volatile修饰保证线程可见性 状态信息通过protected类型的getState，setState，compareAndSetState进行操作 。 AQS 对资源的共享方式 AQS定义两种资源共享方式，可以通过修改state字段来实现多线程的独占（经典如ReentranLock）和共享模式。 Exclusive（独占）：只有⼀个线程能执行，如ReentrantLock。⼜可分为公平锁和非公平锁： 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的 Share（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。 AQS详细原理 最终参考：从源码角度彻底理解ReentrantLock(重入锁) 以下是基于ReentractLock语境下进行分析。 加锁过程：非公平锁 简单来说：新建线程→CAS尝试快速获取锁→tryAcquire()CAS修改state→addWaiter() 获取失败CAS尝试插入队尾入队→acquireQueued等待前驱线程唤醒继续CAS获取锁 加锁流程从lock.lock()开始 123public void lock() &#123; sync.lock();&#125; 进入该源码,正确找到sycn的实现类后可以看到真正有内容的入口方法： CAS尝试快速加锁，在ReentranLock只有state=0，才能更新成功（因为是非多线程共享资源） 获取锁失败执行acquire方法 12345678 // 加锁流程真正意义上的入口 final void lock() &#123; //以cas方式尝试将AQS中的state从0更新为1 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread());//获取锁成功则将当前线程标记为持有锁的线程,然后直接返回 else acquire(1);//获取锁失败则执行该方法&#125; acquire 在主要的逻辑都在if判断条件中,这里面有3个重要的方法tryAcquire()，addWaiter() 和 acquireQueued() 。 12345 public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; acquire流程1：tryAcquire() tryAcquire()在公平和非公平下获取的方式不一样，这里只说非公平实现。 如果state==0（未被其它线程持有），CAS尝试获取锁, 如果当前线程==持有锁的线程，可重入 ，state+1 否则 reture false获取锁失败，加入等待队列 123456789101112131415161718final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread();//获取当前线程实例 int c = getState();//获取state变量的值,即当前锁被重入的次数 if (c == 0) &#123; //state为0,说明当前锁未被任何线程持有 if (compareAndSetState(0, acquires)) &#123; //以cas方式获取锁 setExclusiveOwnerThread(current); //将当前线程标记为持有锁的线程 return true;//获取锁成功,非重入 &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; //当前线程就是持有锁的线程,说明该锁被重入了 int nextc = c + acquires;//计算state变量要更新的值 if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc);//非同步方式更新state值 return true; //获取锁成功,重入 &#125; return false; //走到这里说明尝试获取锁失败&#125; acquire流程2：addWaiter() 主要逻辑如下： 首先通过new Node()创建一个空结点； 如果队列不空**，以CAS方式让新节点插入到队尾; 如果队列为空，执行enq(node) 逻辑 1234567891011121314151617181920212223242526272829private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode);//首先创建一个新节点,并将当前线程实例封装在内部,mode这里为null // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node);//入队的逻辑这里都有 return node; &#125; private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail;//t指向当前队列的最后一个节点,队列为空则为null if (t == null) &#123; // Must initialize //队列为空 if (compareAndSetHead(new Node())) //构造新结点,CAS方式设置为队列首元素,当head==null时更新成功 tail = head;//尾指针指向首结点 &#125; else &#123; //队列不为空 node.prev = t; if (compareAndSetTail(t, node)) &#123; //CAS将尾指针指向当前结点,当t(原来的尾指针)==tail(当前真实的尾指针)时执行成功 t.next = node; //原尾结点的next指针指向当前结点 return t; &#125; &#125; &#125; &#125; acquire流程3：acquireQueued() 线程加入同步队列后，获取锁的流程是什么呢？ 简单来说，就是不断判断当前是否是老二，并尝试去获取锁。 SIGNAL ：意味着线程释放锁后会唤醒后面阻塞的线程。毕竟，只有确保能够被唤醒，当前线程才能放心的阻塞 123456789101112131415161718192021222324final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; //死循环,正常情况下线程只有获得锁才能跳出循环 for (;;) &#123; final Node p = node.predecessor();//获得当前线程所在结点的前驱结点 //第一个if分句 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); //将当前结点设置为队列头结点 p.next = null; // help GC failed = false; return interrupted;//正常情况下死循环唯一的出口 &#125; //第二个if分句 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; //判断是否要阻塞当前线程 parkAndCheckInterrupt()) //阻塞当前线程 interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; 解锁：非公平锁 加锁：公平锁 简单来说：新来线程→【必须】先CAS加入等待队列→等待前驱节点释放锁（state=0），如果是老二则获取锁。 公平锁加锁入口加锁从： 123finally void lock() &#123; acqiuire();&#125; 在之前非公平锁的逻辑中，线程有三次机会获取锁： 新创建时，CAS尝试修改state=1，去获取 可重入，当前获取锁线程为自己 前驱节点释放锁，自己作为老二被唤醒 而公平锁，只能按加入队列的先后次序 &amp; 可重入获得锁 ： 所有线程在获取锁前必须先加入同步队列 如果state=0，hasQueuedPredecessors判断当前是头节点，则获取锁 3.3 为什么基于FIFO的同步队列可以实现非公平锁？ 因为非公平锁，除了等前驱节点唤醒去获取锁 ，还有以下三种方式获取锁： 新创建时，CAS尝试修改state=1，去获取 公平锁：进来先执行hasQueuedPredecessors() , 看等待队列是否有有效节点，有的话不能获取锁！ 可重入，当前获取锁线程为自己 公平锁：也可以 同步队列等待，等待唤醒获取锁 公平锁：也可以 并且在锁释放时：是先释放锁（修改state=-1），再去唤醒后继节点 会导致新来的线程，可能在后继节点被唤醒前就获取了锁，这就不会公平 3.4 【易忘】为什么非公平锁性能好？ .线程不必加入等待队列就可以获得锁,不仅免去了构造结点并加入队列的繁琐操作 ，节省了线程阻塞、唤醒的开销（这涉及到上下文的切换）； 减少CAS竞争。如果线程必须要加入阻塞队列才能获取锁,那0将变得异常激烈,CAS操作虽然不会导致失败线程挂起,但不断失败重试导致的对CPU的浪费也不能忽视 3.4 AQS 有哪些组件，请简单介绍一下？介绍一下CountDownLatch的应用场景 ？ Semaphore(信号量)：Semaphore(信号量)可以指定多个线程同时访问某个资源； synchronized 和 ReentrantLock 都是⼀次只允许⼀个线程访问同时某个资源。 计数信号量具备两种操作动作，称为V（signal()）与P（wait()）（即部分参考书常称的“PV操作”）。V操作会增加信号标S的数值，P操作会减少它。 运行P（wait()），信号标S的值将被减少。企图进入临界区段的进程，需要先运行P（wait()）。当信号标S减为负值时，进程会被挡住，不能继续；当信号标S不为负值时，进程可以获准进入临界区段。 CountDownLatch （倒计时器）： CountDownLatch是⼀个同步⼯具类，用来协调多个线程之间的同步。这个⼯具通常用来控制线程等待，它可以让某⼀个线程等待直到倒计时结束，再开始执行。 CyclicBarrier(循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能⽐ CountDownLatch 更加复杂和强大。主要应用场景和CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让⼀组线程到达⼀个屏障（也可以叫同步点）时被阻塞，直到最后⼀个线程到达屏障时，屏障才会开⻔，所有被屏障拦截的线程才会继续⼲活。 CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调⽤**await()**方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。 CountDownLatch的应用场景 我们要读取处理6个⽂件，这6个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这6个⽂件的处理的结果进行统计整理。 为此我们定义了⼀个线程池和count为6的 CountDownLatch 对象 。使用线程池处理读取任务，每⼀个线程处理完之后就将count-1，调用 CountDownLatch 对象的 await() 方法，直到所有⽂件读取完之后，才会接着执行后面的逻辑。 123456789101112131415161718192021222324252627public class CountDownLatchExample1 &#123; // 处理⽂件的数量 private static final int threadCount = 6; public static void main(String[] args) throws InterruptedException &#123; // 创建⼀个具有固定线程数量的线程池对象（推荐使用构造方法创建） ExecutorService threadPool = Executors.newFixedThreadPool(10); final CountDownLatch countDownLatch = newCountDownLatch(threadCount); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadnum = i; threadPool.execute(() → &#123; try &#123; //处理⽂件的业务操作 ...... &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; //表示⼀个⽂件已经被完成 countDownLatch.countDown(); &#125; &#125;); &#125; countDownLatch.await(); threadPool.shutdown(); System.out.println(&quot;finish&quot;); &#125;&#125; 1.5.4 Volatile 关键字 4.0 JMM 是什么 ？ 缓存一致性协议MESI ? CPU内存屏障？JAVA内存屏障？ 参考：并发编程-（4）-JMM基础（总线锁、缓存锁、MESI缓存一致性协议、CPU 层面的内存屏障） JMM定义 全称Java Memory Model（java内存模型）是一系列的Java虚拟机平台对开发者提供的多线程环境下的内存可见性、是否可以重排序等问题的无关具体平台的统一的保证。 MESI 缓存一致性协议协议 缓存不一致问题 CPU处理速度，远大于I/O设备（磁盘），为了解决了处理器与内存的速度矛盾，引入了高速缓存。但是由此也带来了缓存不一致的问题。 每个线程都会缓存内存的数据在各自寄存器中，在不同 CPU 中运行的不同线程看到同一份内存的缓存值不一样就会存在缓存不一致的问题。 MESI协议内容 为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，最常见的就是 MESI 协议： MESI 表示缓存行的四种状态，分别是： 在 MESI 协议中，每个缓存的缓存控制器不仅知道自己的 读写操作，而且也监听(snoop)其它 Cache 的读写操作。 M(Modify) 表示共享数据只缓存在当前 CPU 缓存中， 并且是被修改状态，也就是缓存的数据和主内存中的数据不一致。 E(Exclusive) 表示缓存的独占状态，数据只缓存在当前 CPU 缓存中，并且没有被修改。 S(Shared) 表示数据可能被多个 CPU 缓存，并且各个缓存中的数据和主内存数据一致。 I(Invalid) 表示缓存已经失效。 对于 MESI 协议，从 CPU 读写角度来说会遵循以下原则： CPU 读请求：缓存处于 M、E、S 状态都可以被读取，I 状 态 CPU 只能从主存中读取数据； CPU 写请求：缓存处于 M、E 状态才可以被写。对于 S 状 态的写，需要将其他 CPU 中缓存行置为无效才可写。 Store Bufferes（存储缓存） CPU 缓存行的状态是通过消息传递来进行的，如果 CPU0 要对一个在缓存中共享的变量进行写入，首先发送一个失效的消息给到其他缓存了该数据的 CPU。并且要等到他们的确认回执。CPU0 在这段时间内都会处于阻塞状态。 为了避免阻塞带来的资源浪费。在 cpu 中引入 了 Store Bufferes（存储缓存） 和 Invalidate Queue（无效队列）。 CPU0 写入共享数据时，直接把数据写入到 store bufferes 中，同时发送 invalidate 消息，然后继续去处理其他指令； 收到其他所有 CPU 发送了 invalidate ACK消息时，再将 store bufferes 中的数据数据存储至 cache 中； 最后再从本地Cache同步到主内存。 CPU层面内存屏障 内存屏障就是将 Store Bufferes 中的指令写入到内存，从而使得其他访问同一共享内存的线程的可见性。 硬件层的内存屏障分为两种：Load Barrier （读屏障）和 Store Barrier（写屏障）及 Full Barrier（全屏障）是读屏障和写屏障的合集。 写屏障：强制把写缓冲区/高速缓存中的脏数据等写回主内存 读屏障：将缓冲区/高速缓存中相应的数据失效。 JAVA 内存屏障 java的内存屏障通常所谓的四种，LoadLoad（LL）, StoreStore（SS）, LoadStore（LS）, StoreLoad（SL)实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。 LoadLoad（LL）屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。 StoreStore（SS）屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。 LoadStore（LS）屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。 StoreLoad（SL）屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。 4.1 什么是HappenBefore原则？ 在 JMM 中，如果一个操作执行的结果需要对另一个操作【可见】，那么这两个操作必须要存在 happens-before 关系。这两个操作可以是同一个线程，也可以是不同的线程。 它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见 。 HappenBefore原则 as-if-serial 规则（程序顺序执行）：单个线程中的代码顺序不管怎么重排序，对于结果来说是不变的。 volatile 变量规则，对于 volatile 修饰的变量的写操作， 一定 happen-before 后续对于 volatile 变量的读操作; 监视器锁规则（monitor lock rule）：对一个监视器的解锁，happens-before于随后对这个监视器的加锁。 传递性规则：如果A happens-before B，且B happens-before C，那么A happens-before C。 start 规则：如果线程 A 执行操作 ThreadB.start(),那么线程 A 的 ThreadB.start()操作 happens-before 线程 B 中的任意操作。 join 规则：如果线程 A 执行操作 ThreadB.join()并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join()操作成功返回。 举例说明：什么是指令重排序？ 请看下面代码： 假设 线程A执行writer()方法之后，线程B执行reader()方法，那么线程B执行4的时候一定能看到线程A写入的值吗？ 12345678910111213141516class VolatileExample &#123; int a = 0; volatile boolean flag = false; public void writer() &#123; a = 1; //1 flag = true; //2 &#125; public void reader() &#123; if (flag) &#123; //3 int i = a; //4 ... &#125; &#125;&#125; 答案是肯定的。因为根据happens-before规则，我们可以得到如下关系： 根据程序顺序规则，1 happens-before 2；3 happens-before 4 根据volatile规则，2 happens-before 3； 根据传递性规则，1 happens-before 4 。 因此，综合运用程序顺序规则、volatile规则及传递性规则，我们可以得到1 happens-before 4，即线程B在执行4的时候一定能看到A写入的值。 4.2 Volatile 关键字原理 参考：https://www.cnblogs.com/paddix/p/5428507.html 。 此题考察的是volatile这个关键字。可以从volatile的作用和volatile的原理这三个方面来进行回答。volatile只能保证变量的可见性、有序性，但是不能保证原子性。 可见性实现原理 为了实现volatile可见性和happen-befor的语义。JVM底层是通过一个叫做“内存屏障（基于MESI）”的东西来完成（也实现了有序性 ？）。 线程本身并不直接与主内存进行数据的交互，而是通过线程的工作内存来完成相应的操作。这也是导致线程间数据不可见的本质原因。 使用MESI 协议，使得任意一个线程修改了 volatile 修饰的变量，其他线程可以马上识别到最新值。 最终目标：保证了缓存的一致性。 具体的话，下面是用内存屏障来实现的。 修改本地工作内存，强制刷回主内存； 强制让其他线程的工作内存失效过期； 其他线程重新从主内存加载最新值； 有序性实现原理 参考：https://blog.csdn.net/qq_42764468/article/details/106898608 从源代码到最终执行的指令，可能会经过三种重排序： 【指令】重排序，JMM 会要求编译器生成指令时，会插入内存屏障来禁止处理器重排序。 JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止：①特定类型的编译器重排序和②处理器重排序，为程序员提供一致的内存可见性保证。 编译器重排序，JMM 禁止了特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。 内存重排序：由于处理器会使用读/写缓冲区，出于性能的原因，内存会对读/写进行重排序 JVM 是使用内存屏障来禁止【指令】重排，从而达到：可见性 + 部分有序性效果。 lock前缀指令实际相当于一个内存屏障？ 下面不是可见性吗？？？ 对volatile变量的写操作与普通变量的主要区别有两点： 修改volatile变量前，会强制将修改后的值刷新的主内存中。 每个volatile写操作前插入StoreStore（SS）屏障 修改volatile变量后，会导致其他线程工作内存中对应的变量值失效，因此，再读取该变量值的时候就需要重新从读取主内存中的值。 在写操作后插入StoreLoad屏障； 对volatile变量的读操作类似： 在每个volatile读操作前插入LoadLoad（LL）屏障； 确保Load2及后续Load指令加载数据之前能访问到Load1加载的数据。 在读操作后插入LoadStore（LS屏障）。 确保Store2和后续Store指令执行前，可以访问到Load1加载的数据。 4.3 volatile为什么不能保证原子性？ 参考：为什么volatile能保证有序性不能保证原子性 对于i++这种复合操作，即使使用volatile关键字修饰也不能保证操作的原子性，可能会引发数据不一致问题。 12private volatile int i = 0;i++; 上述i++操作，其实分为三个操作： 线程读取i temp = i + 1 i = temp A,B两个线程多线程操作时： A线程读取i并执行了 temp = i + 1的操作， 此时的 i（0） 的值还没有变化 此时B也读入i并执行temp = i + 1操作，此时i（0）也没变化 ⚠️ 虽然有MESI协议，但是temp不保存变量i所在内存区域，是cpu内部的计算，不会被立马刷新内存！ 当A写入i = temp（1）时，由于可见性立马在主存被刷新了值 i=1 当B也写入i = temp时，此时A依旧是1，而不是2 4.4 并发编程的三个重要特性 ？ 原子性 : ⼀个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的⼲扰而中断，要么所有的操作都执行，要么都不执行。 synchronized 可以保证代码片段的原子性。 可见性 ：当⼀个变量对共享变量进行了修改，那么另外的线程都是⽴即可以看到修改后的最新值。 volatile 关键字可以保证共享变量的可见性。 有序性：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。 volatile 关键字可以禁⽌指令进行重排序优化。 4.5 说说 synchronized 关键字和 volatile 关键字的区别？ synchronized关键字和volatile关键字比较： volatile关键字是线程同步的轻量级实现，所以volatile性能肯定⽐synchronized关键字要好。 volatile关键字只能用于变量，而synchronized关键字可以修饰方法以及代码块。 synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引⼊的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多⼀些。 volatile关键字只能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发⽣阻塞 1.5.5 Atomic 原子类 5.1 什么是Atomic 原子类？ 所以，所谓原子类说简单点就是具有原子/原子操作特征的类。 在我们这⾥ Atomic 是指⼀个操作是不可中断的。即使是在多个线程⼀起执行的时候，⼀个操作⼀旦开始，就不会被其他线程⼲扰。 5.2 JUC 包中的原子类是哪4类? 5.3 Volatile 和 atomic 变量区别？ Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。 而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。 5.4 讲讲 AtomicInteger 的使用 ？ 1234567public final int get() //获取当前的值public final int getAndSet(int newValue)//获取当前的值，并设置新的值public final int getAndIncrement()//获取当前的值，并⾃增public final int getAndDecrement() //获取当前的值，并⾃减public final int getAndAdd(int delta) //获取当前的值，并加上预期的值boolean compareAndSet(int expect, int update) //如果输⼊的数值等于预期值，则以原子方式将该值设置为输⼊值（update）public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet设置之后可能导致其他线程在之后的⼀小段时间内还是可以读到旧的值。 使用示例： 123456789101112class AtomicIntegerTest &#123; // 基本类型也要是原子类 private AtomicInteger count = new AtomicInteger(); //使⽤AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。 public void increment() &#123; count.incrementAndGet(); &#125; public int getCount() &#123; return count.get(); &#125;&#125; 5.5（重点提问） AtomicInteger 原理？ AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。 我们以自增方法为例： getAndIncrement 123public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125; 可以看到，本质是在调用 unsafe中的 getAndAddInt unsafe中的compareAndSwapInt方法参数。 1compareAndSwapInt(Object o, long offset,int expected,int x); // x是准备更新的值 123456789101112131415public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125;// Unsafe中的方法public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; // getIntVolatile方法获取到期望值value后去调用compareAndSwapInt方法，失败则进行重试 do &#123; // var5是计算得到的期望值，获取此时内存的最新值（因为value是votilate修饰，修改总是被能及时看到） var5 = this.getIntVolatile(var1, var2); // 计算传入compareAndSwapInt的四个参数 // var1：传入的this对象；var2：value内存偏移值；var5：期望值，希望和【var2】一致； var5+var4：var5+var4（1），递增 &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 最终总结如下 AtomicInteger 类主要利用 CAS (compare and swap) + volatile 来保证原子操作。AtomicInteger 的主要方法都是通过调用Unsafe类方法去实现，如 compareAndSet 实际是调用AtomicInteger 的compareAndSwapInt方法。 下面以 getAndIncrement实现来说明。 getAndIncrement调用了 Unsafe的getAndAddInt方法，传递了（1）当前this对象，（2）value偏移量valueoffset，用来计算得到value值（3）要加上的值，由于是递增所以是1 ⚠️ 为什么不传value的值，而是偏移量？ 传偏移量是为了计算value所在的内存地址，进而获取最新的value值。 getAndAddInt采用CAS方式进行更新，还需要进行当前期望值的计算 通过getIntVolatile获取到线程此时内存value值（期望值），也就是记录执行CAS前的内存最新value值； 然后开始执行Unsafe的 compareAndSwapInt ，主要是通过Atomic::cmpxchg 逻辑来实现 （1）将要dest（value内存地址），compareValue（期望值），exchange_value（要更新的值）写入寄存器中 （2）线程如果是运行多核CPU，上LOCK#锁，将dest内存区域锁住 ；否则不上LOCK#锁 （3）执行cmpxchg（比较并交换命令），如果dest的value值（执行CAS中的最新value值） == compareValue，则写入exchange_value ； （4）否则写入失败，通过不断自旋（循环）期望得到执行","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"JAVA","slug":"校招笔记/JAVA","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://hwh.zone/tags/JAVA/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"}]},{"title":"校招笔记（一）_Java_多线程","slug":"校招笔记（一）_Java_多线程","date":"2021-11-26T12:01:58.657Z","updated":"2021-12-03T03:56:53.300Z","comments":true,"path":"p/8959/","link":"","permalink":"https://hwh.zone/p/8959/","excerpt":"","text":"我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。 备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 1.4 多线程 0.三个线程，如何让他们按顺序打印A、B、C？如果是循环打印10次呢？依次打印1~100呢？交替打印奇偶10次呢？ 参考：https://zhuanlan.zhihu.com/p/370130458 0.1 synchronized + 条件变量 synchronized + 条件变量（循环打印1次） 思路如下： 新建三个线程1、2、3 ，分别负责打印A、B、C；同时，每个线程对应一个条件变量：num%3==当前线程条件变量? ； 把打印的代码用synchronized 加锁，每个线程拿到锁后，while循环判断是否满足当前线程的条件变量 ； 如果满足 ，便执行后续逻辑打印当前线程，之后notifyall()唤醒其它线程； 如果不满足，执行wait等待释放锁； 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.*;class Wait_Notify_ACB &#123; private int num; private static final Object LOCK = new Object(); private void printABC(int targetNum) &#123; // targetNum ： 每个线程应该满足的对应条件变量 synchronized (LOCK) &#123; while (num % 3 != targetNum) &#123; // while ：线程阻塞在wait(),再次被唤醒应该先检查下是否满足条件，因为这个时候未必轮到当前线程执行；用if会导致直接往下执行。 try &#123; LOCK.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; num++; System.out.print(Thread.currentThread().getName()); LOCK.notifyAll(); &#125; &#125; public static void main(String[] args) &#123; Wait_Notify_ACB wait_notify_acb = new Wait_Notify_ACB (); new Thread(() -&gt; &#123; wait_notify_acb.printABC(0); &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; wait_notify_acb.printABC(1); &#125;, &quot;B&quot;).start(); new Thread(() -&gt; &#123; wait_notify_acb.printABC(2); &#125;, &quot;C&quot;).start(); &#125;&#125; synchronized + 条件变量（循环打印10次） 打印10次，只需让三个线程，尝试去竞争10次锁即可。所以在synchronized前加上for循环即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.*;class Wait_Notify_ACB &#123; private int num; private static final Object LOCK = new Object(); private void printABC(int targetNum) &#123; // targetNum ： 每个线程应该满足的对应条件变量 for(int i = 0 ; i&lt;10 ;i++) &#123; synchronized (LOCK) &#123; while (num % 3 != targetNum) &#123; // while ：线程阻塞在wait(),再次被唤醒应该先检查下是否满足条件，因为这个时候未必轮到当前线程执行；用if会导致直接往下执行。 try &#123; LOCK.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; num++; System.out.print(Thread.currentThread().getName()); LOCK.notifyAll(); &#125; &#125; &#125; public static void main(String[] args) &#123; Wait_Notify_ACB wait_notify_acb = new Wait_Notify_ACB (); new Thread(() -&gt; &#123; wait_notify_acb.printABC(0); &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; wait_notify_acb.printABC(1); &#125;, &quot;B&quot;).start(); new Thread(() -&gt; &#123; wait_notify_acb.printABC(2); &#125;, &quot;C&quot;).start(); &#125;&#125; synchronized + 条件变量（打印1~100) 设置一个全局变量，synchronized 中加锁函数对num+1，保证只要每次只有一个线程能执行。 123456789101112131415161718192021222324252627282930313233343536373839404142class Wait_Notify_100 &#123;​ private int num; private static final Object LOCK = new Object(); private int maxnum = 10;​ private void printABC(int targetNum) &#123; while (true) &#123; synchronized (LOCK) &#123; while (num % 3 != targetNum) &#123; //想想这里为什么不能用if代替，想不起来可以看公众号上一篇文章 if(num &gt;= maxnum)&#123; break; &#125; try &#123; LOCK.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if(num &gt;= maxnum)&#123; break; &#125; num++; System.out.println(Thread.currentThread().getName() + &quot;: &quot; + num); LOCK.notifyAll(); &#125; &#125; &#125; public static void main(String[] args) &#123; Wait_Notify_100 wait_notify_100 = new Wait_Notify_100 (); new Thread(() -&gt; &#123; wait_notify_100.printABC(0); &#125;, &quot;thread1&quot;).start(); new Thread(() -&gt; &#123; wait_notify_100.printABC(1); &#125;, &quot;thread2&quot;).start(); new Thread(() -&gt; &#123; wait_notify_100.printABC(2); &#125;, &quot;thread3&quot;).start(); &#125; &#125; synchronized + 条件变量（奇偶打印10次） 12345678910111213141516171819202122232425262728293031class Wait_Notify_Odd_Even&#123; private Object monitor = new Object(); private volatile int count; Wait_Notify_Odd_Even(int initCount) &#123; this.count = initCount; &#125; private void printOddEven() &#123; synchronized (monitor) &#123; while (count &lt; 10) &#123; try // 这里不用while循环判断，是因为下次notifyAll的一定是奇数或偶数 &#123; System.out.print( Thread.currentThread().getName() + &quot;：&quot;); System.out.println(++count); monitor.notifyAll(); monitor.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //防止count=10后，while()循环不再执行，有子线程被阻塞未被唤醒，导致主线程不能退出 monitor.notifyAll(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Wait_Notify_Odd_Even waitNotifyOddEven = new Wait_Notify_Odd_Even(0); new Thread(waitNotifyOddEven::printOddEven, &quot;odd&quot;).start(); Thread.sleep(10); //为了保证线程odd先拿到锁 new Thread(waitNotifyOddEven::printOddEven, &quot;even&quot;).start(); &#125;&#125; 0.2 join join()方法**：在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行**。 基于这个原理，我们使得三个线程按顺序执行，然后循环多次即可。无论线程1、线程2、线程3哪个先执行，最后执行的顺序都是线程1——&gt;线程2——&gt;线程3。 代码如下： 1234567891011121314151617181920212223242526272829303132class Join_ABC &#123; public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 10; i++) &#123; Thread t1 = new Thread(new printABC(null),&quot;A&quot;); Thread t2 = new Thread(new printABC(t1),&quot;B&quot;); Thread t3 = new Thread(new printABC(t2),&quot;C&quot;); t1.start(); t2.start(); t3.start(); Thread.sleep(10); //这里是要保证只有t1、t2、t3为一组，进行执行才能保证t1-&gt;t2-&gt;t3的执行顺序。 &#125; &#125; static class printABC implements Runnable&#123; private Thread beforeThread; public printABC(Thread beforeThread) &#123; this.beforeThread = beforeThread; &#125; @Override public void run() &#123; if(beforeThread!=null) &#123; try &#123; beforeThread.join(); System.out.print(Thread.currentThread().getName()); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;else &#123; System.out.print(Thread.currentThread().getName()); &#125; &#125; &#125;&#125; 0.3 Lock 该方法很容易理解，不管哪个线程拿到锁，只有符合条件的才能打印。 123456789101112131415161718192021222324252627 class Lock_ABC &#123; private int num; // 当前状态值：保证三个线程之间交替打印 private Lock lock = new ReentrantLock(); private void printABC(int targetNum) &#123; for (int i = 0; i &lt; 10; ) &#123; lock.lock(); if (num % 3 == targetNum) &#123; num++; i++; System.out.print(Thread.currentThread().getName()); &#125; lock.unlock(); // 不符合要求直接释放锁，不会像sync一样阻塞在sync或wait处 &#125; &#125; public static void main(String[] args) &#123; Lock_ABC lockABC = new Lock_ABC(); new Thread(() -&gt; &#123; lockABC.printABC(0); &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; lockABC.printABC(1); &#125;, &quot;B&quot;).start(); new Thread(() -&gt; &#123; lockABC.printABC(2); &#125;, &quot;C&quot;).start(); &#125;&#125; 0.4 Semaphore Semaphore：用来控制同时访问某个特定资源的操作数量，或者同时执行某个制定操作的数量。Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。 一个线程要访问共享资源，先使用acquire()方法获得信号量，如果信号量的计数器值大于等于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。如果计数器值为0,线程进入休眠； 当某个线程使用完共享资源后，使用release()释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。 12345678910111213141516171819202122232425262728293031class SemaphoreABC &#123; private static Semaphore s1 = new Semaphore(1); //因为先执行线程A，所以这里设s1的计数器为1 private static Semaphore s2 = new Semaphore(0); private static Semaphore s3 = new Semaphore(0); private void printABC(Semaphore currentThread, Semaphore nextThread) &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; currentThread.acquire(); //阻塞当前线程，即信号量的计数器减1为0 System.out.print(Thread.currentThread().getName()); nextThread.release(); //唤醒下一个线程，即信号量的计数器加1 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; SemaphoreABC printer = new SemaphoreABC(); new Thread(() -&gt; &#123; printer.printABC(s1, s2); &#125;, &quot;A&quot;).start(); Thread.sleep(10); new Thread(() -&gt; &#123; printer.printABC(s2, s3); &#125;, &quot;B&quot;).start(); Thread.sleep(10); new Thread(() -&gt; &#123; printer.printABC(s3, s1); &#125;, &quot;C&quot;).start(); &#125;&#125; 1.4.1 线程基本 1. 什么是线程和进程？如何保证线程安全？ 1.1 什么是线程和进程？ 什么是进程？ 进程是程序的⼀次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行⼀个程序即是⼀个进程从创建，运行到消亡的过程。 如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe ⽂件的运行）。在Windows操作系统中，一个程序只对应一个进程，里面可以有一个或多个线程。 什么是线程？ 线程与进程相似，但线程是⼀个⽐进程更小的执行单位。⼀个进程在其执行的过程中可以产⽣多个线程。 与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有⾃⼰的程序计数器、虚拟机栈和本地方法栈 所以系统在产⽣⼀个线程，或是在各个线程之间作切换⼯作时，负担要⽐进程小得多，也正因为如此，线程也被称为轻量级进程。 ⼀个 Java 程序的运行是 main 线程和多个其他线程同时运行。 1.2 如何保证线程安全？ 原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现； 可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的； 有序性，是保证线程内串行语义，避免指令重排等。 1.3 为什么程序计数器、虚拟机栈和本地方法栈是线程私有的? 程序计数器为什么是私有 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪⼉了。 所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。 虚拟机栈和本地方法栈为什么私有 虚拟机栈： 每个 Java 方法在执行的同时会创建⼀个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直⾄执行完成的过程，就对应着⼀个栈帧在 Java 虚拟机栈中⼊栈和出栈的过程。 本地方法法栈： 和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合⼆为⼀。 所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。 2.创建线程的方式（非线程池）？ 哪种最好？ 一般有三种方式来进行创建： 继承Thread类：（1）定义Thread类的子类，并重写该类的run方法（2）创建Thread子类的实例对象 （3）调用对象start()方法 优点：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用this即可获取当前线程； 缺点：因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了。 实现Runnable接口：（1）定义runnable接口的实现类，并重写该接口的run()方法 （2）创建实现类的实例对象（3）调用线程对象的start()方法来启动该线程 通过Callable和Future创建线程：（1）创建Callable接口的实现类，并实现call()方法（2）创建Callable实现类的实例，并使用FutureTask类来包装Callable对象（3）使用FutureTask对象作为Thread对象的target创建并启动新线程（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值 其中 实现Runnalbe接口更好 ，使用实现Runnable接口的方式创建的线程可以处理同一资源，从而实现资源的共享。 3.如何停止一个正在运行的线程？ 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止； 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法； 使用interrupt方法中断线程。 12345678910111213141516171819202122232425262728293031class MyThread extends Thread&#123; volatile boolean stop = false; public void run() &#123; while (!stop) &#123; System.out.println(getName() + &quot; is running&quot;); try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;week up from blcok...&quot;); stop = true; // 在异常处理代码中修改共享变量的状态 &#125; &#125; System.out.println(getName() + &quot; is exiting...&quot;); &#125;&#125;class InterruptThreadDemo3&#123; public static void main(String[] args) throws InterruptedException &#123; MyThread m1 = new MyThread(); System.out.println(&quot;Starting thread...&quot;); m1.start(); Thread.sleep(3000); System.out.println(&quot;Interrupt thread...: &quot; + m1.getName()); m1.stop = true; // 设置共享变量为true m1.interrupt(); // 阻塞时退出阻塞状态 Thread.sleep(3000); // 主线程休眠3秒以便观察线程m1的中断情况 System.out.println(&quot;Stopping application...&quot;); &#125; &#125; 4.什么是Daemon线程？它有什么意义？ 所谓后台(daemon)线程，也叫守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。 意义：JVM的垃圾回收线程就是Daemon线程，Finalizer也是守护线程。 5.说说CyclicBarrier和CountDownLatch的区别？ 两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于： CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值**-1**而已，该线程继续运行； CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务 CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了 6.请你简要说明一下线程的基本状态以及状态之间的关系？ 新建状态：new语句创建的线程对象处于新建状态，仅被分配了内存； 等待状态： 当线程在new之后，并且在调用start方法前，线程处于等待状态 ; 就绪状态： 其他线程调用它的**start()**方法，该线程就进入就绪状态，只差等待cpu的使用权 ; 运行状态： 线程占用CPU，执行程序代码 ; 阻塞状态： 阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。阻塞状态分为三种： 等待阻塞: 运行的线程执行**wait()**方法，JVM会把该线程放入等待池中； 同步阻塞: 运行的线程在获取对象同步锁时，若该同步锁被别的线程占用，则JVM会把线程放入锁池中； 其他阻塞: 运行的线程执行Sleep()方法，或者发出I/O请求时，JVM会把线程设为阻塞状态。 死亡状态： 线程执行完run()方法中的代码，或者遇到了未捕获的异常，就会退出run()方法，结束生命周期 7. notify()和notifyAll()有什么区别？ notify可能会导致死锁（why？），而notifyAll则不会； 使用notifyall,可以唤醒 所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。 8. sleep()和wait() 有什么区别？ 继承的类：sleep()方法，我们首先要知道该方法是属于Thread类中的；而wait()方法，则是属于Object类中的； sleep() 是 Thread 类静态方法，可以使 当前 线程阻塞，并指定暂停时间，重点在于理解 当前。休眠时间期满后，该线程不一定会立即执行被CPU调度，只是到了就绪状态。 是否释放锁：sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁；当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池； 用处： Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行； 再次唤醒： wait() 方法被调用后，线程不会⾃动苏醒，需要别的线程调用同⼀个对象上的 notify() 或者notifyAll() 方法。sleep() 方法执行完成后，线程会⾃动苏醒。 8.1 Thread类中的yield方法有什么作用？ yield() 也是 Thread 类静态方法，使当前线程变为就绪状态 （sleep() 是阻塞），使得其他线程更多机会获取CPU。执行yield()的线程有可能在进入到暂停状态后马上又被执行。 8.2 java 中Wait、Sleep和Yield方法的区别？ https://www.jianshu.com/p/25e959037eed 9. volatile 是什么?可以保证有序性吗? 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存； 禁止进行指令重排序。 能保证有序性，因为禁止指令重排。 10. 为什么wait, notify 和 notifyAll这些方法不在thread类里面？ https://www.zhihu.com/question/321674476 明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。 简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。 11.为什么wait和notify方法要在同步块中调用？ wait()方法强制当前线程释放对象锁。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法； 在调用对象的notify()和notifyAll()方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。 12. （没细看）Java中interrupted 和 isInterruptedd方法的区别？ interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法。 1.4.2 线程池 1.请你解释一下什么是线程池（thread pool）？ 线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 除此之外： 提高性能，利用多线程压榨CPU算力； 提高线程的可管理性，限制线程数量并可以进行统一的分配、调优和监控。 1.1 请介绍一下使用线程池任务执行过程？ 核心参数：其中corePool是核心线程池（保活线程），maximumPool是总线程池（保活线程+工作线程），blockQueue 是等待任务队列，rejectedExecutionHandler是拒绝策略： 流程：corePoolSize→队列→maximumPool→拒绝策略 未达到corePoolSize时，核心线程池会开辟新线程运行任务（可以使用已有线程吗？），任务结束后线程不销毁； 达到corePoolSize，而任务队列未满时，新任务提交到等待队列，线程空闲时间超过keepAliveTime时被销毁； 任务队列也满了，但未超过最大线程数，新建工作线程执行任务； 超过最大线程数时，按拒绝策略处理，包括：抛出异常、使用调用者线程运行任务、丢弃新任务、丢弃队列头任务等。 1.2 线程池会回收核心线程吗？ 参考：线程池是怎么回收空闲线程的 会，可以通过allowCoreThreadTimeOut参数来进行设置。 先回忆一下整体线程池流程 excute方法 我们的任务放到线程池后，是从调用execute执行开始的。 核心是addWorker办法， 里面最最重要的就是初始化Worker同时启动thread。 Worker实现了Runnable接口，我们直接看它的run方法，看截图的③处标记，抽离出来一个runWorker方法： 也就是说：①处是一个while循环，getTask方法就是从线程池队列取任务，如果取不到任务就会执行 ​ ②一旦跳出while循环，即进入到processWorkExit方法，这就是回收Worker getTask方法 可以看到，①判断是否回收线程的条件，timed ，有两种情况要回收线程： wc&gt;corePoolSize ，当前线程数大于核心线程数 allowCoreThreadTimeOut，核心线程超时，所以核心线程是会被回收的 然后②处就是从任务队列取任务了，带了timeOut参数的poll方法超时 ，未能从任务队列获取任务即返回null，从而实现最终的线程回收。 不是processWorkExit处理吗，怎么在getTask处理，还是得好好看看。 2.请介绍一下什么是生产者消费者模式？ 生产者消费者问题是线程模型中的经典问题： 生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。 3.线程池的拒绝策略有哪些？ 主要有4种拒绝策略： AbortPolicy：直接丢弃任务，抛出异常，这是默认策略 CallerRunsPolicy：只用调用者所在的线程来处理任务 DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务 DiscardPolicy：直接丢弃任务，也不抛出异常 4.如何创建一个线程池（四大方法）？相关参数（七大参数）是什么? java通过Executors提供四大方法： newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程； newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待； newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行； newSingleThreadExecutor： 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 七大参数设置： corePoolSize：当使用了LinkedBlockingQueue = new LinkedBlockQueue的时候，队列长度默认无限长，会导致线程数量永远等于corePoolSize，任务激增时任务响应时间也激增； maximumPoolSize：线程池中线程个数，增加线程的公式：(任务数−queueCapacity)×(原线程数÷原任务数)(任务数-queueCapacity) \\times (原线程数 \\div 原任务数)(任务数−queueCapacity)×(原线程数÷原任务数)； keepAliveTime：线程最大（空闲）存活时间； rejectedExecutionHandler：线程被拒绝的解决方案，可以自己重写； workQueue ： 阻塞队列； unit：keepAliveTime的单位 ； threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程一般默认即可 5.线程池核心线程数corePoolSize怎么设置呢？ 分为CPU密集型和IO密集型来考虑： CPU密集型。这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。 比 CPU 核心数多出来的一个线程 ：是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。 IO密集型。这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 ： 核心线程数=CPU核心数量*2 6.（不熟悉）Java线程池中队列常用类型有哪些？ ArrayBlockingQueue ：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序； LinkedBlockingQueue :一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于 ArrayBlockingQueue ； SynchronousQueue : 一个不存储元素的阻塞队列； PriorityBlockingQueue： 一个具有优先级的无限阻塞队列，PriorityBlockingQueue 也是基于最小二叉堆实现。 7.有三个线程T1,T2,T3,如何保证顺序执行？ 因为在每个线程的run方法中用join()方法限定了三个线程的执行顺序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class JoinTest2&#123; // 1.现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行 public static void main(String[] args) &#123; final Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;t1&quot;); &#125; &#125;); final Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // t2线程内run方法最开始，引用t1.join，等待t1线程执行完 t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;t2&quot;); &#125; &#125;); Thread t3 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // t3线程内run方法最开始，引用t2.join，等待t2线程执行完 t2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;t3&quot;); &#125; &#125;); //这里三个线程的启动顺序可以任意，大家可以试下！ t3.start(); t2.start(); t1.start(); &#125;&#125; 1.4.3 多线程 1.请简述一下实现多线程同步的方法？ 为什么需要使用多线程？使用多线程会带来什么问题？ 同步方法：可以使用synchronized、lock、volatile和ThreadLocal来实现同步。 为什么需要使用多线程？ 减少上下文切换开销（共享进程的堆和方法区 ，注意，减少≠没有） 利用好多线程机制可以大大提高系统整体的并发能⼒以及性能 多核时代 ：多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算⼀个复杂的任务，我们只用⼀个线程的话，CPU 只会⼀个 CPU 核⼼被利用到，而创建多个线程就可以让多个 CPU 核⼼被利用到，这样就提高了 CPU 的利用率。 带来的问题？ 内存泄漏、上下⽂切换、死锁还有受限于硬件和软件的资源闲置问题。 2. 什么是线程安全？如何保证线程安全？ 好文：一文搞懂CAS 什么是线程安全？ 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 如何保证线程安全？ 使用 synchronized 关键字 。开销比较大 使用Lock 锁 。高并发场景下，使用 Lock 锁要比使用synchronized 关键字，在性能上得到极大的提高。因为 Lock 底层是通过 AQS + CAS 机制来实现的。 使用 Atomic 原子类 。使用 Lock 方式，一旦 unlock() 方法使用不规范，可能导致死锁。 Atomic 原子类，因为其底层基于 CAS 乐观锁来实现的，性能较高。 使用Volatile？不可行！ 因为无法保证原子性。 3.线程安全需要保证几个基本特征？ 原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。 可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将 线程本地状态反映到主内存上，volatile 就是负责保证可见性的。 有序性，是保证线程内串行语义，避免指令重排等。 4. 【待补充】如何在线程安全的情况下实现一个计数器？ 可以使用加锁，比如synchronized或者lock。也可以使用Concurrent包下的原子类。 5.多线程中的i++线程安全吗？请简述一下原因？ 不安全，因为i++不是原子性操作。i++分为读取i值，对i值加一，再赋值给i++，执行期中任何一步都是有可能被其他线程抢占的。 6.介绍一下ThreadLocal原理？ 一篇讲的不错的文章：https://www.cnblogs.com/wupeixuan/p/12638203.html 当多线程访问共享可变数据时，涉及到线程间同步的问题，并不是所有时候，都要用到共享数据，所以就需要线程封闭出场了。数据都被封闭在各自的线程之中，就不需要同步，这种通过将数据封闭在线程中而避免使用同步的技术称为线程封闭。 ThreadLocal 是 Java 里一种特殊变量，它是一个线程级别变量，每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞态条件被彻底消除了，在并发模式下是绝对安全的变量。 使用示例 在下面例子中，TreadLocal 做到多个线程对同一对象 set 操作，但是 get 获取的值还都是每个线程 set 的值，体现了线程的封闭。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ThreadLocalDemo &#123; /** * ThreadLocal变量，每个线程都有一个副本，互不干扰 */ public static final ThreadLocal&lt;String&gt; THREAD_LOCAL = new ThreadLocal&lt;&gt;(); public static void main(String[] args) throws Exception &#123; new ThreadLocalDemo().threadLocalTest(); &#125; public void threadLocalTest() throws Exception &#123; // 主线程设置值 THREAD_LOCAL.set(&quot;wupx&quot;); String v = THREAD_LOCAL.get(); System.out.println(&quot;Thread-0线程执行之前，&quot; + Thread.currentThread().getName() + &quot;线程取到的值：&quot; + v); new Thread(new Runnable() &#123; @Override public void run() &#123; String v = THREAD_LOCAL.get(); // 此时新建线程Thread-0取到的是null，意味着不同线程取到的值不同的 System.out.println(Thread.currentThread().getName() + &quot;线程取到的值：&quot; + v); // 设置 threadLocal THREAD_LOCAL.set(&quot;huxy&quot;); v = THREAD_LOCAL.get(); System.out.println(&quot;重新设置之后，&quot; + Thread.currentThread().getName() + &quot;线程取到的值为：&quot; + v); System.out.println(Thread.currentThread().getName() + &quot;线程执行结束&quot;); &#125; &#125;).start(); // 等待所有线程执行结束 Thread.sleep(3000L); v = THREAD_LOCAL.get(); System.out.println(&quot;Thread-0线程执行之后，&quot; + Thread.currentThread().getName() + &quot;线程取到的值：&quot; + v); &#125;&#125;/* 输出结果 */// 虽然Thread-0已经改变了值，但是main取到的值依旧是一样的。/*Thread-0线程执行之前，main线程取到的值：wupxThread-0线程取到的值：null重新设置之后Thread-0线程取到的值为：huxyThread-0线程执行结束Thread-0线程执行之后，main线程取到的值：wupx*/ ThreadLocal原理 ThreadLocal有一个静态内部类ThreadLocalMap，ThreadLocalMap又包含了一个Entry数组，Entry本身是一个弱引用，他的key是指向ThreadLocal的弱引用，Entry具备了保存key value键值对的能力。 ThreadLocalMap ThreadLocalMap 是 ThreadLocal 的静态内部类，当一个线程有多个 ThreadLocal 对象时时，需要一个容器来管理多 ThreadLocal，ThreadLocalMap 的作用就是管理线程中多个 ThreadLocal。 从源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构，底层是数组，有初始化大小，也有扩容阈值大小，数组的元素是 Entry，Entry 的 key 就是 ThreadLocal 的引用，value 是 ThreadLocal 的值。ThreadLocalMap 解决 hash 冲突的方式采用的是线性探测法，如果发生冲突会继续寻找下一个空的位置 1234567891011121314151617181920212223242526272829303132static class ThreadLocalMap &#123; /** * 键值对实体的存储结构 */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; // 当前线程关联的 value，这个 value 并没有用弱引用追踪 Object value; /** * 构造键值对 * * @param k k 作 key,作为 key 的 ThreadLocal 会被包装为一个弱引用 * @param v v 作 value */ Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; // 初始容量，必须为 2 的幂 private static final int INITIAL_CAPACITY = 16; // 存储 ThreadLocal 的键值对实体数组，长度必须为 2 的幂 private Entry[] table; // ThreadLocalMap 元素数量 private int size = 0; // 扩容的阈值，默认是数组大小的三分之二 private int threshold;&#125; Set方法 调用 ThreadLocal对象.set(value)，实际在调用当前线程的ThreadLocalMap对象.set(this,value) ，会把当前 threadLocal 对象作为 key，想要保存的对象作为 value，存入 map。 set 方法的流程主要是： 先获取到当前线程的引用 利用这个引用来获返回当前线程到 ThreadLocalMap 如果 map 为空，则去创建一个 ThreadLocalMap 如果 map 不为空，就利用 ThreadLocalMap 的 set (this当前对象，value) 添加键值对 12345678910111213141516171819202122232425/** * 为当前 ThreadLocal 对象关联 value 值 * * @param value 要存储在此线程的线程副本的值 */public void set(T value) &#123; // 返回当前ThreadLocal所在的线程 Thread t = Thread.currentThread(); // 返回当前线程持有的map ThreadLocalMap map = getMap(t); if (map != null) &#123; // 如果 ThreadLocalMap 不为空，则直接存储&lt;ThreadLocal, T&gt;键值对 // 此时this是ThreadLocal对象，这是在ThreadLocal类中 map.set(this, value); &#125; else &#123; // 否则，需要为当前线程初始化 ThreadLocalMap，并存储键值对 &lt;this, firstValue&gt; createMap(t, value); &#125;&#125;/** * 返回当前线程 thread 持有的 ThreadLocalMap对象 */ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; Get方法 调用ThreadLocal对象.get() 方式时，实际在调用ThreadLocalMap对象.getEntry(this) 方法。this是当前ThreadLocal对象。 get 方法的主要流程为： 先获取到当前线程的引用 获取当前线程内部的 ThreadLocalMap对象 如果 map 存在，则获取当前 ThreadLocal 对应的 value 值 如果 map 不存在或者找不到 value 值，则调用 setInitialValue() 进行初始化 1234567891011121314151617181920212223/** * 返回当前 ThreadLocal 对象关联的值 * * @return */public T get() &#123; // 返回当前 ThreadLocal 所在的线程 Thread t = Thread.currentThread(); // 从线程中拿到 ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) &#123; // 从 map 中拿到 entry ThreadLocalMap.Entry e = map.getEntry(this); // 如果不为空，读取当前 ThreadLocal 中保存的值 if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T) e.value; return result; &#125; &#125; // 若 map 为空，则对当前线程的 ThreadLocal 进行初始化，最后返回当前的 ThreadLocal 对象关联的初值，即 value return setInitialValue();&#125; resize 方法 当前线程的 ThreadLocalMap 中的 ThreadLocal 的个数超过容量阈值时，ThreadLocalMap 就要开始扩容了。 1// 略 7.为什么ThreadLocal造成内存泄漏？ ThreadLocalMap 是 ThreadLocal 的静态内部类，当一个线程有多 个ThreadLocal 时，需要一个容器来管理多个 ThreadLocal，ThreadLocalMap 的作用就是管理线程中多个 ThreadLocal。 源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构： 底层是数组Entry[] table，数组的元素是 Entry类：Entry 的两个属性， key 是 ThreadLocal类型的引用，value 是 ThreadLocal 的值。 原因：ThreadLocalMap的key为弱引用（有用但非必需，下一次GC会被回收），value为强引用（GC过程不会被回收），有可能造成key被GC，value没被GC，ThreadLocalMap中出现null为key的Entry，产生内存泄漏（软引用：有用但非必需，内存溢出之前被回收）； 解决： 调用set()、get()和remove()方法时，会自动清理掉key为null的记录，但使用ThreadLocal方法后手动remove()。 8.什么是多线程中的上下文切换？ 一个线程让出处理器使用权，就是“切出”；另外一个线程获取处理器使用权，就是“切入”。在这个切入切出的过程中，操作系统会保存和恢复相关的进度信息，这个进度信息就是我们常说的“上下文”，上下文中一般包含了寄存器的存储内容以及程序计数器存储的指令内容。 9.请问什么是死锁(deadlock)? 死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。 10. JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？ 最简单方法：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。 因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。或者通过破坏死锁的四个条件： 互斥 ： 不可能破坏。 破坏请求和保持条件：进程必须 等所有要请求的资源都空闲时才能申请资源， 这种方法会使资源浪费严重 。允许进程获取初期所需资源后，便开始运行，运行过程中再逐步释放自己占有的资源。 破坏不可抢占条件： 方法代价大，实现复杂。 破坏循坏等待条件 ：对各进程请求资源的顺序做一个规定，避免相互等待。这种方法对资源的利用率比前两种都高，但是前期要为设备指定序号，新设备加入会有一个问题，其次对用户编程也有限制。","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"JAVA","slug":"校招笔记/JAVA","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://hwh.zone/tags/JAVA/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"}]},{"title":"校招笔记（一）_Java_集合","slug":"校招笔记（一）_Java_集合","date":"2021-11-26T11:59:26.560Z","updated":"2021-12-03T03:57:05.285Z","comments":true,"path":"p/21069/","link":"","permalink":"https://hwh.zone/p/21069/","excerpt":"","text":"我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。 备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 1.3 集合 1.3.1 集合类 1.请说明Java集合类框架的基本接口有哪些？ Collection：代表一组对象，每一个对象都是它的子元素。 Set：不包含重复元素的Collection。 List：有顺序的collection，并且可以包含重复元素。 Map：可以把键(key)映射到值(value)的对象，键不能重复。 2.（补充：举例说明）说说什么是fail-fast？ fail-fast 机制是 Java 集合（Collection）中的一种错误快速反馈机制。当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。 例如：当某一个线程 A 通过 iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了，那么线程 A 访问集合时，就会抛出 ConcurrentModifificationException 异常，产生 fail-fast 事件。这里的操作主要是指 add、remove 和 clear，对集合元素个数进行修改。 3.请说明List、Map、Set三个接口区分？ 重复元素：List以特定索引来存取元素，可以有重复元素；Map以键值对映射，不能有重复key；Set元素不能重复 继承collection： List、Set继承于collection；Map和前二者明显区分，不继承collection 实现方式： List是线性结构的容器 ，典型实现有ArrayList 、LinkedList、Vector； Map、Set都有 基于哈希存储和排序树 的两种实现版本，前者实现有 HashMap和Hashtable ，后者有HashSet 4.请讲讲你所知道的常用集合类以及主要方法？ 最常用的集合类是List 和 Map。 List：典型实现有ArrayList 、LinkedList、Vector ，大小可变，适合用于按数值索引元素类型； Map： 其中每个键映射到一个值，实现有 HashMap和Hashtable 。 1.3.2 Map &amp; Set 1.请你介绍一下map的分类和常见的情况？ java为数据结构中的映射定义了一个接口java.util.Map ， 它有四个实现类,分别是HashMap、 Hashtable、 LinkedHashMap、 和TreeMap. Hashmap ：根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度。 遍历：访问快，遍历时取得的数据随机 线程：不支持线程同步（但可以用Collections的synchronizedMap 实现同步） key和记录：HashMap允许键和值是null Hashtable ：和Hashmap类似，是其子类。但其： 线程： 支持线程同步，也导致写入比较慢（一个时候只能一个线程写入） key和记录：不允许记录的键或者值为空 ； LinkedHashMap ：HashMap的一个子类，保存了记录插入顺序： 遍历：遍历先得到的记录是先插入、一般情况比HashMap慢。 TreeMap ： 实现SortMap接口，默认是按键值的升序排序， 遍历：当用遍历TreeMap时，得到的记录是排过序的 线程：线程安全 一般情况下，我们用的最多的是HashMap, 在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列。 1.1 TreeMap的底层实现？ TreeMap实现了SotredMap接口，它是有序的集合。而且是一个红黑树结构，每个key-value都作为一个红黑树的节点。如果在调用TreeMap的构造函数时没有指定比较器，则根据key执行自然排序。这点会在接下来的代码中做说明，如果指定了比较器则按照比较器来进行排序。 自然排序：TreeMap的所有key必须实现Comparable接口，所有的key都是同一个类的对象 定制排序：创建TreeMap对象传入了一个Comparator对象，该对象负责对TreeMap中所有的key进行排序，采用定制排序不要求Map的key实现Comparable接口。等下面分析到比较方法的时候在分析这两种比较有何不同。 2.请问HashMap和Hashtable区别？ 共同点：都实现Map接口 不同点： 对Null key 和Null value的支持：HashMap允许键和值是null，而Hashtable不允许键或者值是null； 线程安全：Hashtable是同步的线程安全，而HashMap不是； 初始容量大小和每次扩充容量大小不同： （1）创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16，之后每次扩充，容量变为原来的2倍 ；（2）创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小，也就是说 HashMap 总是使用2的幂作为哈希表的大小； 底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表⻓度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有转换为红黑树这样的机制； 继承父类：HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。 3.请问Map接口实现：HashMap、Hashtable和ConcurrentHashMap区别？ 都是key-value存储形式。 底层数据结构：HashMap与ConcurrentHashMap底层数据结构相似（数组+链表+红黑树），Hashtable没有红黑树； 线程安全：Hashtable的synchronized修饰在方法，是对象级的加锁，同一时间只有一个线程能对数据进行操作；ConcurrentHashMap使用了修饰具体对象的synchronized（锁一个桶）和CAS机制，实现了更细粒度的锁； 地址计算： HashMap使用key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16)；- Hashtable使用(key.hashCode() &amp; 0x7fffffff) % tab.length() ConcurrentHashMap使用(key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16)) &amp; 0x7fffffff。 4.说一说红黑树特征？ 紧接上个问题，面试官很有可能会问红黑树。 每个节点是黑色是红色 根节点和叶子节点是黑色 红色节点不能相邻 从一个节点到子孙节点路径上相同数目的黑节点 5. hashmap的基本原理，扩容方式（rehash）？ 很棒的一篇文章：https://www.jianshu.com/p/dde9b12343c1 更棒的一篇文章：https://zhuanlan.zhihu.com/p/81587796 HashMap定义 HashMap继承了Map端口，实现了Serializable等接口。存储HashMap的是一个Entry[]数组，Entry是一个单向链表： 所以我们说HashMap实现的是一个数组+链表 。 1234public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;implements Map&lt;K,V&gt;, Cloneable, Serializable&#123; transient Entry&lt;K,V&gt;[] table; Entry类 Entry在HashMap中实现为一个静态内部类，封装了key和value，还有类型为Entry的next指向下一个Entry引用。 12345static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; 图解HashMap 根据前面所知，我们可以得到HashMap的实现如下（默认初始化容量为16）： put方法实现 输入的key根据hash(key) 计算出hash值 123456public V put(K key, V value) &#123; // 对key为null的处理 if (key == null) return putForNullKey(value); // 根据key算出hash值 int hash = hash(key); hash方法如下（JDK1.8版本） 下面这段代码也叫扰动函数 ，参考：JDK 源码中 HashMap 的 hash 方法原理是什么？ 混合原始哈希码的高位和低位，以此来加大低位的随机性 。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。 1234567static final int hash(Object key) &#123;int h;// key.hashCode()：返回散列值也就是hashcode// ^ ：按位异或// &gt;&gt;&gt;⽆符号右移，忽略符号位，空位都以0补⻬return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 相⽐于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差⼀点点，因为毕竟扰动了 4 次。 Object类HashCode实现 详细源码分析参考 ：Java Object.hashCode()返回的是对象内存地址？ JDK8 的默认hashCode的计算方法是通过和当前线程有关的一个随机数+三个确定值，运用Marsaglia’s xorshift scheme随机数算法得到的一个随机数 。 可以通过在JVM启动参数中添加-XX:hashCode=4，改变默认的hashCode计算方式： hashCode == 0 ：返回一个Park-Miller伪随机数生成器生成的随机数 ，OpenJdk 6 &amp;7的默认实现； hashCode == 1：此类方案将对象的内存地址，做移位运算后与一个随机数进行异或得到结果 ； hashCode == 2：此类方案返回固定的1； hashCode == 3：此类方案返回一个自增序列的当前值； hashCode == 4：此类方案返回当前对象的内存地址。 根据indexFor(hash, table.length) ，计算在table中下标 key.hashcode得到hash → 经过高低16异或扰动得到行hash → indexFor计算下标 indexFor() 实际就是hash值取余：hash%(table.lenght-1) 。但在具体实现中通过位运算实现： 123static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; 计算原理。 顺便说一下，这也正好解释了为什么HashMap的数组长度要取2的整次幂。因为这样（数组长度-1）正好相当于一个低位掩码。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。 1234 10100101 11000100 00100101&amp; 00000000 00000000 00001111 （16）------------------------------------------ 00000000 00000000 000000101 位运算要求length 一定是偶数。length-1则一定是奇数。 这样h &amp; (length-1)进行位运算出现的结果可奇可偶，不会一直是偶数，浪费奇数空间。而length为2的幂次，可以保证length一定是偶数，这也是扩容为什么要求一定是2的幂次。 遍历table中下标为i的Entry单向链表，找是否有相同的key已经在HashMap中，如果有，就替换value为最新的值；没有就直接插入。所以HashMap中只能存储唯一的key。 1234567891011int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 先判断hash值是否一样，如果一样，再判断key是否一样 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; 如果是第一次put上面for循环不会执行，而是addEntry方法直接把key和value封装成Entry，然后加入到table中的实现。 123modCount++;addEntry(hash, key, value, i);return null; 这涉及到HashMap的扩容机制。 扩容机制 当HashMap中存储的元素个数达到扩容的阀值 ，那如何进行扩容？ ⚠️ 在jdk1.8版本以后，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。 我们再来看看addEntry方法中的扩容相关代码： 扩容就是通过resize()方法创建一个长度为原来2倍的新table ； resize()方法内部通过遍历的方式，将老table的数据，重新计算hash并存储到新table的适当位置，最后使用新的table，并重新计HashMap的扩容阀值。 12345678910111213141516 void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; //初始化一个新的Entry数组 Entry[] newTable = new Entry[newCapacity]; //！！将数据转移到新的Entry数组里 transfer(newTable); //HashMap的table属性引用新的Entry数组 table = newTable; //修改阈值 threshold = (int)(newCapacity * loadFactor);13 &#125; transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里： 12345678910111213141516171819void transfer(Entry[] newTable) &#123; //src引用了旧的Entry数组 Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; //！！重新计算每个元素在数组中的位置 int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上元素 &#125; while (e != null); &#125; &#125; &#125; newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式 。下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。 get方法实现 用key的hash值算出key对应的Entry所在链表在在table的下标，然后遍历下标即可。 5.1 为什么HashMap默认链表长度超过8转为红黑树，而不是6、7或9？ 在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为 8 的时候，概率仅为 0.00000006。源码中注释如下： 123456789100: 0.606530661: 0.303265332: 0.075816333: 0.012636064: 0.001579525: 0.000157956: 0.000013167: 0.000000948: 0.00000006more: less than 1 in ten million 这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。 特别的，默认是链表长度达到 8 就转成红黑树，而当长度降到 6 就转换回去，这体现了时间和空间平衡的思想。长度较小时，使用链表空间占用少，时间也不会长（因为链表短）。 5.2 HashMap 多线程操作导致死循环问题？ 总结： HashMap之所以在并发下的扩容造成死循环，是因为，多个线程并发进行时，因为一个线程先期完成了扩容，将原的链表重新散列到自己的表中，并且链表变成了倒序，后一个线程再扩容时，又进行自己的散列，再次将倒序链表变为正序链表，于是形成了一个环形链表。 12345678910111213141516171819void transfer(Entry[] newTable) &#123; //src引用了旧的Entry数组 Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; //！！重新计算每个元素在数组中的位置 int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125; &#125; map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。 设置断点让线程1和线程2同时debug到transfer方法的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。 注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的新链表。 线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。 e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。 5.3 说说HashMap的put方法？ 根据key值计算在数组中的位置： 如果定位到的数组位置没有元素 就直接插入； 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 hash值&amp;equals对象相同就直接覆盖，不同就采用头插法插入元素。 123456789101112//table[i]的位置已经存在元素，遍历链表for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; //调用 equals 方法判断key是否相等，若相等，该key对应的键值对已经存在，用新的value取代旧的value if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; 5.4 说说HashMap的get方法？ 根据key值计算在数组中的位置： 遍历链表或者在红黑树，比较key来获取value 5.5 【百度】rehash扩容时机？在插入前还是插入后？ rehash过程在put函数中，其大致扩容时机如下： 计算hash，定位到桶；且遍历桶外挂链表，如果有相同key则覆盖； 123456789101112131415161718public V put(K key, V value) &#123; if (key == null) // 【百度】怎么处理key或value为NULL的情况？ return putForNullKey(value); int hash = hash(key);//计算键的hash值 int i = indexFor(hash, table.length);//通过hash值对应到桶位置 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;//顺序遍历桶外挂的单链表 Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;/ V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i);//遍历单链表完毕，没有找到与键相对的Entry，需新建一个Entry return null; &#125; 【如果没有找到相同key，说明要插入一个新entry】 ，执行addEntry，插入前先验证下是否扩容； 123456789101112131415void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);//将容量扩容为原来的2倍 hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length);//扩容后的，该hash值对应的新的桶位置 &#125; createEntry(hash, key, value, bucketIndex);//在指定的桶位置上，创建一个新的Entry &#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);//链表的头插法插入新建的Entry size++;//更新size &#125; 因此总结扩容时机如下： 在执行put时，如果遍历指定桶外挂链表没有找到相同key的节点时，说明需要新建一个entry，这个时候在插入前验证下是否要扩容。 5.6 hashmap在1.7版本之前为什么使用头插法？ 1.7版本之前采用头插法，1.8之后采用尾插法。 头插法会改变链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题；而尾插法，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题 。 既然有多线程并发问题，那为什么1.8之前还要使用头插法？ 局部性原理： 最近访问过的数据下次大概率会再次访问，把刚访问过的元素放在链表最前面可以直接被查询到，减少查找次数 不是为了适应多线程而设计： 只有在并发情况下，头插法才会出现链表成环的问题，多线程情况下，HashMap 本就非线程安全，这就相当于你在它的规则之外出了问题。 5.7 为什么 HashMap 的负载因子设置成 0.75，而不是 1 也不是 0.5？ 在 HashMap 中，临界值（threshold） = 负载因子（loadFactor） * 容量（capacity）。 那么如何能有效的避免哈希碰撞呢？ 我们先反向思维一下，你认为什么情况会导致 HashMap 的哈希碰撞比较多？ 无外乎两种情况： 容量太小。容量小，碰撞的概率就高了。狼多肉少，就会发生争抢。 hash 算法不够好。算法不合理，就可能都分到同一个或几个桶中。分配不均，也会发生争抢。 为了避免哈希碰撞，HashMap 需要在合适的时候进行扩容。那就是当其中的元素个数达到临界值的时候（等全满了再扩容，那么在此之前容量太少，导致碰撞的概率过高），而这个临界值前面说过和 loadFactor 有关，换句话说，设置一个合理的 loadFactor，可以有效的避免哈希冲突。 JVM中原话： 一般来说，默认的负载因子 (0.75) 在时间和空间成本之间提供了很好的权衡。更高的值减少了空间开销，但增加了查找成本(反映在 HashMap 类的大多数操作中，包括 get 和 put)。 另一方面，为了保证负载因子（loadFactor） * 容量（capacity）的结果是一个整数，这个值是 0.75(3/4) 比较合理，因为这个数和任何 2 的幂乘积结果都是整数。 5.8 Hashmap 怎么处理key和value为null的情况？ 6. Hashtable 源码分析 参考：Java集合之Hashtable源码解析 构造函数 和HashMap还是挺相似的，但是默认初始容量是11（HashMap是16）。 123456789101112131415161718192021222324252627282930313233private transient Entry&lt;?,?&gt;[] table;//数组 private transient int count;//键值对的数量 private int threshold;//阀值 private float loadFactor;//加载因子 private transient int modCount = 0;//修改次数 public Hashtable(int initialCapacity, float loadFactor) &#123;//下面的三个构造函数都是调用这个函数，来进行相关的初始化 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor); if (initialCapacity==0) initialCapacity = 1; this.loadFactor = loadFactor; table = new Entry[initialCapacity];//这里是与HashMap的区别之一，HashMap中table threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1); initHashSeedAsNeeded(initialCapacity); &#125; public Hashtable(int initialCapacity) &#123;//指定初始数组长度 this(initialCapacity, 0.75f); &#125; public Hashtable() &#123;//从这里可以看出容量的默认值为16，加载因子为0.75f. this(11, 0.75f); &#125; public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123; this(Math.max(2*t.size(), 11), 0.75f); putAll(t); &#125; put方法 和HashMap整体过程依旧很像，但有4点注意： put方法是加锁synchronized，所以线程安全 Hashtable计算hash值的hash(key)，不允许为null，所以会抛出异常 获取数组散列的下标 (hash &amp; 0x7FFFFFFF) % tab.length 和HashMap hash &amp; length-1 不同 (hash &amp; 0x7FFFFFFF) % tab.length 是（1）hash &amp; 0x7FFFFFFF 保证hash是正数 （2）然后取余 相比之下，HashMap是位运算进行了优化，更高效 Hashtable没有链表转红黑树的机制 12345678910111213141516171819202122232425262728public synchronized V put(K key, V value) &#123;//这里方法修饰符为synchronized,所以是线程安全的。 if (value == null) &#123; throw new NullPointerException();//value如果为Null,抛出异常 &#125; Entry tab[] = table; int hash = hash(key);//hash里面的代码是hashSeed^key.hashcode（）,null.hashCode（）会抛出异常，所以这就解释了Hashtable的key和value不能为null的原因。 int index = (hash &amp; 0x7FFFFFFF) % tab.length;//获取数组元素下标,先对hash值取正，然后取余。 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; V old = e.value; e.value = value; return old; &#125; &#125; modCount++;//修改次数。 if (count &gt;= threshold) &#123;//键值对的总数大于其阀值 rehash();//在rehash里进行扩容处理 tab = table; hash = hash(key); index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; Entry&lt;K,V&gt; e = tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++; return null; &#125; rehash方法（扩容） 和HashMap依旧很像，但是扩容每次是 old*2+1 。 get方法 也是相比Hashmap直接加了 synchronized 进行修饰，保证线程安全。 1234567891011public synchronized V get(Object key) &#123;//没有什么特殊性，就是加了一个synchronized，就是根据index来遍历索引处的单链表。 Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return e.value; &#125; &#125; return null; &#125; 6.1 （容易忘）HashMap 和 Hashtable 的区别 ？ 关于null，HashMap允许key和value都可以为null，而Hashtable则不接受key为null或value为null的键值对。 关于线程安全，HashMap是线程不安全的，Hashtable是线程安全的，因为Hashtable的许多操作函数都用synchronized修饰。 Hashtable与HashMap实现的接口不一致，但Hashtable继承Dictionary，而HashMap继承自AbstractMap，即父类不同 默认初始容量不同，扩容大小不同。HashMap的hash数组的默认大小是16，而且一定是2 的指数old*2；Hashtable中hash数组默认大小是11，增加的方式是old*2+1。 6.2 ConcurrentHashMap 和 Hashtable 的区别 ？ ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。 底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构⼀样，数组+链表/红黑⼆叉树。Hashtable 和 JDK1.8 之前的HashMap 的底层数据结构类似都是采用数组+链表/红黑树 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的； 实现线程安全的方式（重要）： ①在JDK1.7的时候ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提高并发访问率。到JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同⼀把锁，全表锁) :使用 synchronized 来保证线程安全，效率非常低下。当⼀个线程访问同步方法时，其他线程也访问同步方法，可能会进⼊阻塞或轮询状态，如使用 put 添加元素，另⼀个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。 7. ConcurrentHashMap线程安全的具体实现方式/底层具体实现 ？ 参考：https://www.cnblogs.com/huangjuncong/p/9478505.html javaGuide Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。 Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 Segment 数组 + HashEntry 数组 + 链表 进化成了 Node 数组 + 链表 / 红黑树，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。 JDK 1.7 实现 Java 7 中 ConcurrentHashMap 的存储结构如下图。 存储结构 ConcurrentHashMap 为了提高本身的并发能力，在内部采用了一个叫做 Segment 的结构，一个 Segment 其实就是一个类 HashTable 的结构，Segment 内部维护了一个链表数组。 两次Hash。ConcurrentHashMap 定位一个元素的过程需要进行两次Hash操作，第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部。 因此，这一种结构的带来的副作用是 Hash 的过程要比普通的 HashMap 要长，但是带来的好处是写操作的时候可以只对元素所在的 Segment 进行操作即可，不会影响到其他的 Segment。 1. ConcurrentHashMap的成员变量和构造函数 ConcurrentHashMap扩容： 元素数量增加导致ConrruentHashMap需要扩容，ConcurrentHashMap不会增加Segment的数量，而只会增加Segment中链表数组的容量大小。 需要对整个ConcurrentHashMap做rehash，而只需要对Segment里面的元素做一次rehash就可以了。 核心初始化函数逻辑如下： 2的指数是为了可以使用移位操作加快hash计算过程。 计算出Segment的数量ssize，是不大于concurrencyLevel的最大的2的指数 12345int ssize = 1;while (ssize &lt; concurrencyLevel) &#123; ++sshift; ssize &lt;&lt;= 1;&#125; 根据intialCapacity确定Segment的容量的大小，每一个Segment的容量大小也是2的指数 123456int c = initialCapacity / ssize;if (c * ssize &lt; initialCapacity) ++c; int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap &lt; c) cap &lt;&lt;= 1; 下面是完整代码： segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到 。默认是 32 - sshift = 28 segmentMask，默认是 ssize - 1 = 16 -1 = 15 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 默认初始容量static final int DEFAULT_INITIAL_CAPACITY = 16;// 默认加载因子static final float DEFAULT_LOAD_FACTOR = 0.75f;// 默认segment层级static final int DEFAULT_CONCURRENCY_LEVEL = 16;// 最大容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// segment最小容量static final int MIN_SEGMENT_TABLE_CAPACITY = 2;// 一个segment最大容量static final int MAX_SEGMENTS = 1 &lt;&lt; 16;// 锁之前重试次数static final int RETRIES_BEFORE_LOCK = 2;// 构造函数：无参public ConcurrentHashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);&#125;// 构造函数：指定初始容量public ConcurrentHashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);&#125;// 构造函数：指定初始容量，负载因子public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123; this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);&#125;// 构造函数：指定初始容量，负载因子，并发级别public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; // 找到两种大小的最匹配参数 int sshift = 0; // segment数组的长度是由concurrentLevel计算来的，segment数组的长度是2的N次方， // 默认concurrencyLevel = 16, 所以ssize在默认情况下也是16,此时 sshift = 4 // sshift相当于ssize从1向左移的次数 int ssize = 1; while (ssize &lt; concurrencyLevel) &#123; ++sshift; ssize &lt;&lt;= 1; &#125; // 段偏移量，默认值情况下此时segmentShift = 28 this.segmentShift = 32 - sshift; // 散列算法的掩码，默认值情况下segmentMask = 15 this.segmentMask = ssize - 1; if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; int c = initialCapacity / ssize; if (c * ssize &lt; initialCapacity) ++c; int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap &lt; c) cap &lt;&lt;= 1; // create segments and segments[0] Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])new HashEntry[cap]); // 创建ssize长度的Segment数组 Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize]; UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] this.segments = ss; &#125; 2.来查看具体代码定义，Segment的成员变量： Segment 继承于 ReentrantLock，不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理。 1234567static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; transient volatile int count; //Segment中元素的数量 transient int modCount; //对table的大小造成影响的操作的数量(比如put或者remove操作) transient int threshold; //阈值,Segment里面元素的数量超过这个值那么就会对Segment进行扩容 final float loadFactor; //负载因子,用于确定threshold transient volatile HashEntry&lt;K,V&gt;[] table; //链表数组,数组中的每一个元素代表了一个链表的头部&#125; 3. 继续查看HashEntry组成： 和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。 123456789101112131415161718192021 /** * ConcurrentHashMap列表Entry。注意，这不会作为用户可见的Map.Entry导出。 */static final class HashEntry&lt;K,V&gt; &#123; final int hash; final K key; volatile V value; volatile HashEntry&lt;K,V&gt; next; HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; // 设置具有volatile写语义的next字段。 final void setNext(HashEntry&lt;K,V&gt; n) &#123; UNSAFE.putOrderedObject(this, nextOffset, n); &#125; // 下面不太重要，略。 put() 方法实现 相比Hashtable，1.7版本concurrentHashmap的更加细粒度，只有定位到段，才会锁住。也就是段锁！ 而Hashtable直接锁住整个方法。 计算key的hash值 ; 根据hash值，segmentShift，segmentMask定位到哪个Segment； 如果指定位置的 Segment 为空，则初始化这个 Segment； 在对应的 Segment 中进行具体的 put。 1234567891011121314public V put(K key, V value) &#123; Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); int hash = hash(key); // hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算 // 其实也就是把高4位与segmentMask（1111）做与运算 int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment // 如果查找到的 Segment 为空，初始化 s = ensureSegment(j); return s.put(key, hash, value, false);&#125; Segment 中进行具体的 put的源码如下： 判断元素个数是否超过了阈值或者segment中数组的长度超过了MAXIMUM_CAPACITY，如果满足条件则rehash扩容！ 由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。 tryLock() 获取锁，获取不到使用scanAndLockForPut方法继续获取； 这里面的第一步中的 scanAndLockForPut 操作这里没有介绍，这个方法做的操作就是不断的自旋 tryLock() 获取锁。当自旋次数大于指定次数时，使用 lock() 阻塞获取锁。 计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry ； 遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待； 如果这个位置上的 HashEntry 不存在： 如果当前容量大于扩容阀值，小于最大容量，进行扩容。 直接头插法插入。 如果这个位置上的 HashEntry 存在： 判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致，一致则替换值 不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。 如果当前容量大于扩容阀值，小于最大容量，进行扩容。 直接链表头插法插入。 如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; // 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。 HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try &#123; HashEntry&lt;K,V&gt;[] tab = table; // 计算要put的数据位置 int index = (tab.length - 1) &amp; hash; // CAS 获取 index 坐标的值 HashEntry&lt;K,V&gt; first = entryAt(tab, index); for (HashEntry&lt;K,V&gt; e = first;;) &#123; if (e != null) &#123; // 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value K k; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; oldValue = e.value; if (!onlyIfAbsent) &#123; e.value = value; ++modCount; &#125; break; &#125; e = e.next; &#125; else &#123; // first 有值没说明 index 位置已经有值了，有冲突，链表头插法。 if (node != null) node.setNext(first); else node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; // 容量大于扩容阀值，小于最大容量，进行扩容 if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) rehash(node); else // index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头 setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; &#125; &#125; &#125; finally &#123; unlock(); &#125; return oldValue;&#125; 扩容 rehash rehash在put()内部被触发。 ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表头插法插入到指定位置。 1int idx = e.hash &amp; sizeMask; // 新位置计算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private void rehash(HashEntry&lt;K,V&gt; node) &#123; HashEntry&lt;K,V&gt;[] oldTable = table; // 老容量 int oldCapacity = oldTable.length; // 新容量，扩大两倍 int newCapacity = oldCapacity &lt;&lt; 1; // 新的扩容阀值 threshold = (int)(newCapacity * loadFactor); // 创建新的数组 HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity]; // 新的掩码，默认2扩容后是4，-1是3，二进制就是11。 int sizeMask = newCapacity - 1; for (int i = 0; i &lt; oldCapacity ; i++) &#123; // 遍历老数组 HashEntry&lt;K,V&gt; e = oldTable[i]; if (e != null) &#123; HashEntry&lt;K,V&gt; next = e.next; // 计算新的位置，新的位置只可能是不变或者是：老的位置+老的容量。 int idx = e.hash &amp; sizeMask; if (next == null) // Single node on list // 如果当前位置还不是链表，只是一个元素，直接赋值 newTable[idx] = e; else &#123; // Reuse consecutive sequence at same slot // 如果是链表了 HashEntry&lt;K,V&gt; lastRun = e; int lastIdx = idx; // 新的位置只可能是不变或者是：老的位置+老的容量。 // 遍历结束后，lastRun 后面的元素位置都是相同的 for (HashEntry&lt;K,V&gt; last = next; last != null; last = last.next) &#123; int k = last.hash &amp; sizeMask; if (k != lastIdx) &#123; lastIdx = k; lastRun = last; &#125; &#125; // ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。 newTable[lastIdx] = lastRun; // Clone remaining nodes for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123; // 遍历剩余元素，头插法到指定 k 位置。 V v = p.value; int h = p.hash; int k = h &amp; sizeMask; HashEntry&lt;K,V&gt; n = newTable[k]; newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n); &#125; &#125; &#125; &#125; // 头插法插入新的节点 int nodeIndex = node.hash &amp; sizeMask; // add the new node node.setNext(newTable[nodeIndex]); newTable[nodeIndex] = node; table = newTable;&#125; get方法 注意，Hashtable 会使用Synchronized进行修饰，所以不支持并发。但是ConcurrentHashmap 没有使用同步机制： 1.7版本 。使用unsafe方法（）等方式直接操作来保证并发处理的安全性，使用的是硬件的安全机制。 1.8版本。没有使用同步，也没有使用unsafe方式。所以是并发的。 到这里就很简单了，get 方法只需要两步即可。 计算得到segment的位置 u CAS方式获取segment数组对象 segment[u] 计算HashEntry数组的下标 i CAS方式获取HashEntry[i]，即数组首节点 12345678910111213141516171819public V get(Object key) &#123; Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead HashEntry&lt;K,V&gt;[] tab; int h = hash(key); long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; // 计算得到 key 的存放位置 if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; (tab = s.table) != null) &#123; for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) &#123; // 如果是链表，遍历查找到相同 key 的 value。 K k; if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) return e.value; &#125; &#125; return null;&#125; JDK 1.8 实现 1.8版本分析，建议参考：https://www.cnblogs.com/zerotomax/p/8687425.html 。 可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。当冲突链表达到一定长度时，链表会转换成红黑树。 和JDK1.8的HashMap是很相似 , 抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。 存储结构和属性 12345678910111213141516171819202122private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;private static final int DEFAULT_CAPACITY = 16; // hashmap也是16static final int TREEIFY_THRESHOLD = 8; // 超过8扩容static final int UNTREEIFY_THRESHOLD = 6;static final int MIN_TREEIFY_CAPACITY = 64; // 超过64红黑树static final int MOVED = -1; // 表示正在转移static final int TREEBIN = -2; // 表示已经转换成树static final int RESERVED = -3; // hash for transient reservationsstatic final int HASH_BITS = 0x7fffffff; // Node数组存储元素transient volatile Node&lt;K,V&gt;[] table;//默认没初始化的数组，用来保存元素private transient volatile Node&lt;K,V&gt;[] nextTable;//转移的时候用的数组/** * 用来控制表初始化和扩容的，默认值为0，当在初始化的时候指定了大小，这会将这个大小保存在sizeCtl中，大小为数组的0.75 * 当为负的时候，说明表正在初始化或扩张， * -1表示初始化 * -(1+n) n:表示活动的扩张线程 */private transient volatile int sizeCtl; 在ConcurrentHashMap中使用了unSafe方法，通过直接操作内存的方式来保证并发处理的安全性，使用的是硬件的安全机制。 123456789101112131415161718192021/* * 用来返回节点数组的指定位置的节点的原子操作 */ @SuppressWarnings(&quot;unchecked&quot;) static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123; return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE); &#125; /* * cas原子操作，在指定位置设定值 */ static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123; return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v); &#125; /* * 原子操作，在指定位置设定值 */ static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123; U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v); &#125; 初始化 1234567891011121314151617//空的构造public ConcurrentHashMapDebug() &#123; &#125;//如果在实例化对象的时候指定了容量，则初始化sizeCtlpublic ConcurrentHashMapDebug(int initialCapacity) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(); int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); this.sizeCtl = cap; &#125;//当出入一个Map的时候，先设定sizeCtl为默认容量，在添加元素public ConcurrentHashMapDebug(Map&lt;? extends K, ? extends V&gt; m) &#123; this.sizeCtl = DEFAULT_CAPACITY; putAll(m); &#125; put方法 123public V put(K key, V value) &#123; return putVal(key, value, false); &#125; 再来看putVal ： 可以发现相比HashTable直接对方法进行加锁synchronized / 1.7版本的ConcurrentHashMap 进入的开头尝试获取锁，1.8版本的ConcurrentHashMap 锁更加细粒度化。 只有：（1）table不为初始化 （2）定位到table位置i不存在元素（此时会用CAS方式进行添加）（3）数组也没有在进行扩张（MOVED=-1） 此时才会进行synchronized 添加元素（不会锁住rehash方法，最后才判断是否扩容）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* * 当添加一对键值对的时候，首先会去判断保存这些键值对的数组是不是初始化了， * 如果没有的话就初始化数组 * 然后通过计算hash值来确定放在数组的哪个位置 * 如果这个位置为空则直接添加，如果不为空的话，则取出这个节点来 * 如果取出来的节点的hash值是MOVED(-1)的话，则表示当前正在对这个数组进行扩容，复制到新的数组，则当前线程也去帮助复制 * 最后一种情况就是，如果这个节点，不为空，也不在扩容，则通过synchronized来加锁，进行添加操作 * 然后判断当前取出的节点位置存放的是链表还是树 * 如果是链表的话，则遍历整个链表，直到取出来的节点的key来个要放的key进行比较，如果key相等，并且key的hash值也相等的话， * 则说明是同一个key，则覆盖掉value，否则的话则添加到链表的末尾 * 如果是树的话，则调用putTreeVal方法把这个元素添加到树中去 * 最后在添加完成之后，会判断在该节点处共有多少个节点（注意是添加前的个数），如果达到8个以上了的话， * 则调用treeifyBin方法来尝试将处的链表转为树，或者扩容数组 */final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException();//K,V都不能为空，否则的话跑出异常 int hash = spread(key.hashCode()); //取得key的hash值 int binCount = 0; //用来计算在这个节点总共有多少个元素，用来控制扩容或者转移为树 for (Node&lt;K,V&gt;[] tab = table;;) &#123; // Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) tab = initTable(); //第一次put的时候table没有初始化，则初始化table else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; //通过哈希计算出一个表中的位置因为n是数组的长度，所以(n-1)&amp;hash肯定不会出现数组越界 if (casTabAt(tab, i, null, //如果这个位置没有元素的话，则通过cas的方式尝试添加，注意这个时候是没有加锁的 new Node&lt;K,V&gt;(hash, key, value, null))) //创建一个Node添加到数组中区，null表示的是下一个节点为空 break; // no lock when adding to empty bin &#125; /* * 如果检测到某个节点的hash值是MOVED，则表示正在进行数组扩张的数据复制阶段， * 则当前线程也会参与去复制，通过允许多线程复制的功能，一次来减少数组的复制所带来的性能损失 */ else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; /* * 如果在这个位置有元素的话，就采用synchronized的方式加锁， * 如果是链表的话(hash大于0)，就对这个链表的所有元素进行遍历， * 如果找到了key和key的hash值都一样的节点，则把它的值替换到 * 如果没找到的话，则添加在链表的最后面 * 否则，是树的话，则调用putTreeVal方法添加到树中去 * * 在添加完之后，会对该节点上关联的的数目进行判断， * 如果在8个以上的话，则会调用treeifyBin方法，来尝试转化为树，或者是扩容 */ V oldVal = null; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; //再次取出要存储的位置的元素，跟前面取出来的比较 if (fh &gt;= 0) &#123; //取出来的元素的hash值大于0，当转换为树之后，hash值为-2 binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; //遍历这个链表 K ek; if (e.hash == hash &amp;&amp; //要存的元素的hash，key跟要存储的位置的节点的相同的时候，替换掉该节点的value即可 ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) //当使用putIfAbsent的时候，只有在这个key没有设置值得时候才设置 e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; //如果不是同样的hash，同样的key的时候，则判断该节点的下一个节点是否为空， pred.next = new Node&lt;K,V&gt;(hash, key, //为空的话把这个要加入的节点设置为当前节点的下一个节点 value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123; //表示已经转化成红黑树类型了 Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, //调用putTreeVal方法，将该元素添加到树中去 value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) //当在同一个节点的数目达到8个的时候，则扩张数组或将给节点的数据转为tree treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); //计数，可能也会触发扩容 return null; &#125; 扩容transfer 扩容主要是通过transfer方法来进行的。 只有在往map中添加元素的时候，在某一个节点的数目已经超过了8个，调用treeifyBin() 触发数组的扩容/转换为数； 使用**addCount()**添加元素数组元素，会进行判断达到了sizeCtl的数量的时候，则会调用transfer方法来进行扩容 treeifyBin() 某一个节点的数目已经超过了8个，执行treeifyBin() 。 当需要扩容的时候，调用的时候tryPresize方法 （1）tryPresize方法并没有加锁，允许多个线程进入，如果数组正在扩张，则当前线程也去帮助扩容使用transfer方法 （2）transfer比较复杂还没有详细看，它里面使用的synchronized 进行单个节点处理扩容 （查看上面看transfer源码） 否则synchronized进行链表转换为树 1234567891011121314151617181920212223242526272829/* * 当数组长度小于64的时候，扩张数组长度一倍，否则的话把链表转为树 */ private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123; Node&lt;K,V&gt; b; int n, sc; if (tab != null) &#123; System.out.println(&quot;treeifyBin方\\t==&gt;数组长：&quot;+tab.length); if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) //MIN_TREEIFY_CAPACITY 64 tryPresize(n &lt;&lt; 1); // 数组扩容 else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123; synchronized (b) &#123; //使用synchronized同步器，将该节点出的链表转为树 if (tabAt(tab, index) == b) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; //hd：树的头(head) for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val, null, null); if ((p.prev = tl) == null) //把Node组成的链表，转化为TreeNode的链表，头结点任然放在相同的位置 hd = p; //设置head else tl.next = p; tl = p; &#125; setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));//把TreeNode的链表放入容器TreeBin中 &#125; &#125; &#125; &#125; &#125; addCount() addCount也主要是调用transfer，这里主要还是寄一下transfer的源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187/** * Moves and/or copies the nodes in each bin to new table. See * above for explanation. * 把数组中的节点复制到新的数组的相同位置，或者移动到扩张部分的相同位置 * 在这里首先会计算一个步长，表示一个线程处理的数组长度，用来控制对CPU的使用， * 每个CPU最少处理16个长度的数组元素,也就是说，如果一个数组的长度只有16，那只有一个线程会对其进行扩容的复制移动操作 * 扩容的时候会一直遍历，知道复制完所有节点，没处理一个节点的时候会在链表的头部设置一个fwd节点，这样其他线程就会跳过他， * 复制后在新数组中的链表不是绝对的反序的 */ private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123; int n = tab.length, stride; if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) //MIN_TRANSFER_STRIDE 用来控制不要占用太多CPU stride = MIN_TRANSFER_STRIDE; // subdivide range //MIN_TRANSFER_STRIDE=16 /* * 如果复制的目标nextTab为null的话，则初始化一个table两倍长的nextTab * 此时nextTable被设置值了(在初始情况下是为null的) * 因为如果有一个线程开始了表的扩张的时候，其他线程也会进来帮忙扩张， * 而只是第一个开始扩张的线程需要初始化下目标数组 */ if (nextTab == null) &#123; // initiating try &#123; @SuppressWarnings(&quot;unchecked&quot;) Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; nextTab = nt; &#125; catch (Throwable ex) &#123; // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; &#125; nextTable = nextTab; transferIndex = n; &#125; int nextn = nextTab.length; /* * 创建一个fwd节点，这个是用来控制并发的，当一个节点为空或已经被转移之后，就设置为fwd节点 * 这是一个空的标志节点 */ ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); boolean advance = true; //是否继续向前查找的标志位 boolean finishing = false; // to ensure sweep(清扫) before committing nextTab,在完成之前重新在扫描一遍数组，看看有没完成的没 for (int i = 0, bound = 0;;) &#123; Node&lt;K,V&gt; f; int fh; while (advance) &#123; int nextIndex, nextBound; if (--i &gt;= bound || finishing) &#123; advance = false; &#125; else if ((nextIndex = transferIndex) &lt;= 0) &#123; i = -1; advance = false; &#125; else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123; bound = nextBound; i = nextIndex - 1; advance = false; &#125; &#125; if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; int sc; if (finishing) &#123; //已经完成转移 nextTable = null; table = nextTab; sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); //设置sizeCtl为扩容后的0.75 return; &#125; if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123; if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) &#123; return; &#125; finishing = advance = true; i = n; // recheck before commit &#125; &#125; else if ((f = tabAt(tab, i)) == null) //数组中把null的元素设置为ForwardingNode节点(hash值为MOVED[-1]) advance = casTabAt(tab, i, null, fwd); else if ((fh = f.hash) == MOVED) advance = true; // already processed else &#123; synchronized (f) &#123; //加锁操作 if (tabAt(tab, i) == f) &#123; Node&lt;K,V&gt; ln, hn; if (fh &gt;= 0) &#123; //该节点的hash值大于等于0，说明是一个Node节点 /* * 因为n的值为数组的长度，且是power(2,x)的，所以，在&amp;操作的结果只可能是0或者n * 根据这个规则 * 0--&gt; 放在新表的相同位置 * n--&gt; 放在新表的（n+原来位置） */ int runBit = fh &amp; n; Node&lt;K,V&gt; lastRun = f; /* * lastRun 表示的是需要复制的最后一个节点 * 每当新节点的hash&amp;n -&gt; b 发生变化的时候，就把runBit设置为这个结果b * 这样for循环之后，runBit的值就是最后不变的hash&amp;n的值 * 而lastRun的值就是最后一次导致hash&amp;n 发生变化的节点(假设为p节点) * 为什么要这么做呢？因为p节点后面的节点的hash&amp;n 值跟p节点是一样的， * 所以在复制到新的table的时候，它肯定还是跟p节点在同一个位置 * 在复制完p节点之后，p节点的next节点还是指向它原来的节点，就不需要进行复制了，自己就被带过去了 * 这也就导致了一个问题就是复制后的链表的顺序并不一定是原来的倒序 */ for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123; int b = p.hash &amp; n; //n的值为扩张前的数组的长度 if (b != runBit) &#123; runBit = b; lastRun = p; &#125; &#125; if (runBit == 0) &#123; ln = lastRun; hn = null; &#125; else &#123; hn = lastRun; ln = null; &#125; /* * 构造两个链表，顺序大部分和原来是反的 * 分别放到原来的位置和新增加的长度的相同位置(i/n+i) */ for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123; int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) /* * 假设runBit的值为0， * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同为0的节点)设置到旧的table的第一个hash计算后为0的节点下一个节点 * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点 */ ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else /* * 假设runBit的值不为0， * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同不为0的节点)设置到旧的table的第一个hash计算后不为0的节点下一个节点 * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点 */ hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); &#125; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; &#125; else if (f instanceof TreeBin) &#123; //否则的话是一个树节点 TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt; (h, e.key, e.val, null, null); if ((h &amp; n) == 0) &#123; if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; &#125; else &#123; if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; &#125; &#125; /* * 在复制完树节点之后，判断该节点处构成的树还有几个节点， * 如果≤6个的话，就转回为一个链表 */ ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; &#125; &#125; &#125; &#125; &#125; &#125; get方法 get操作中，根本没有使用同步机制，也没有使用unsafe方法，所以读（get）操作是支持并发操作的。 123456789101112131415161718192021222324252627/* * 相比put方法，get就很单纯了，支持并发操作， * 当key为null的时候回抛出NullPointerException的异常 * get操作通过首先计算key的hash值来确定该元素放在数组的哪个位置 * 然后遍历该位置的所有节点 * 如果不存在的话返回null */ public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; int h = spread(key.hashCode()); if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; else if (eh &lt; 0) return (p = e.find(h, key)) != null ? p.val : null; while ((e = e.next) != null) &#123; if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null; &#125; 7.1 你知道 ConcurrentHashMap 的工作原理吗？ Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。 主要采用锁机制，在对某个Segment进行操作时，将该Segment锁定，不允许对其进行非查询操作 Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 Segment 数组 + HashEntry 数组 + 链表 进化成了 Node 数组 + 链表 / 红黑树，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。 CAS无锁算法，这种乐观操作在完成前进行判断，如果符合预期结果才给予执行 7.2 请问ConcurrentHashMap中变量使用final和volatile修饰有什么用呢？其中链表是final的next属性，那么发生删除某个元素，如何实现的？ ConcurrentHashMap被final修饰的变量，（部分）如下： 1234567891011121314// 默认初始容量static final int DEFAULT_INITIAL_CAPACITY = 16;// 默认加载因子static final float DEFAULT_LOAD_FACTOR = 0.75f;// 默认segment层级static final int DEFAULT_CONCURRENCY_LEVEL = 16;// 最大容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// segment最小容量static final int MIN_SEGMENT_TABLE_CAPACITY = 2;// 一个segment最大容量static final int MAX_SEGMENTS = 1 &lt;&lt; 16;// 锁之前重试次数static final int RETRIES_BEFORE_LOCK = 2; HashEntry中被volatile修饰的部分变量如下： 12345static final class HashEntry&lt;K,V&gt; &#123; final int hash; final K key; volatile V value; // 保证可见性 volatile HashEntry&lt;K,V&gt; next; 使用final。用来实现不变模式（immutable），他是多线程安全里最简单的一种保障方式。因为你拿他没有办法，想改变它也没有机会。不变模式主要通过final关键字来限定的。在JMM中final关键字还有特殊的语义。Final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让不可变形对象不需要同步就能自由地被访问和共享。 使用volatile。保证某个变量内存的改变对其他线程即时可见，在配合CAS可以实现不加锁对并发操作的支持。 7.3 HashTable与ConcurrentHashMap有什么区别，描述锁分段技术。 锁机制。 所有访问HashTable的线程都必须竞争同一把锁，效率更低；ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 底层数据结构。 1.8之后很相似，都是数组+链表/红黑树 ； 1.8之前，ConcurrentHashMap是Segement数组 + HashEntry数组 + 链表。 7.4 （阿里·淘特）ConcurrentHashMap1.8为什么不使用分段锁？ 先说分段锁的优点： 保证在操作不同段 map 的时候可以并发执行；操作同段 map 的时候，进行锁的竞争和等待。这相对于直接对整个map同步synchronized是有优势的。 但是分段锁也有一些不可忽视的缺点： 分成很多段时会比较浪费内存空间(不连续，碎片化)； 操作map时竞争同一个分段锁的概率非常小（段散列比较好的时候）时，分段锁反而会造成更新等操作的长时间等待； 当某个段很大时，分段锁的性能会下降。 综上考虑1.8不再使用分段锁。 7.5 为什么1.8中 get() 方法不加锁？ 因为链表每个节点的val和next都使用volatile修饰，保证了可见性。 7.6 为什么1.8不使用lock而是使用sync？ 因为sync加入锁升级机制（jdk1.6之后），已经优化的不错了； lock通过reentranclock实现，reentranlock是通过AQS实现，需要增加额外内存开销（CLH双向队列）。 7.7 ConcurrenthashMap使用的时候有可能出现不安全的情况？ 参考：https://blog.csdn.net/luzhensmart/article/details/108133560 查了一些资料后发现，原来ConcurrentHashMap的线程安全指的是，它的【每个方法】单独调用（即原子操作）都是线程安全的，但是代码总体的互斥性并不受控制。以上面的代码为例，最后一行中的： 1234567891011121314public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; this.addup(); &#125; &#125; private void addup() &#123; if (!map.containsKey(KEY)) &#123; map.put(KEY, 1); &#125; else &#123; map.put(KEY, map.get(KEY) + 1); &#125; &#125; 在上面一个线程内部进行了100次加法，但是其实加1在线程内部本身也并不是原子操作。 实际上并不是原子操作，它包含了三步： map.get 加1 map.put 是由于在上面的代码中，map本身是一个共享变量。当线程A执行map.get的时候，其它线程可能正在执行map.put，这样一来当线程A执行到map.put的时候，线程A的值就已经是脏数据了，然后脏数据覆盖了真值，导致线程不安全。 8. HashMap 和 HashSet区别 ？ 如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了clone() 、 writeObject() 、 readObject() 是 HashSet ⾃⼰不得不实现之外，其他方法都是直接调用 HashMap 中的方法。 HashMap HashSet 实现了Map接⼝ 实现Set接⼝ 存储键值对 仅存储对象 调⽤ put() 向map中添加元素 调⽤ add() ⽅法向Set中添加元素 HashMap使⽤键（Key）计算Hashcode：int hash = hash(key); HashSet使⽤成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()⽅法⽤来判断对象的相等性。 9. 说说HashSet的基本原理？ 底层结构 HashSet底层原理完全就是包装了一下HashMap ，只不过存储的时候value是默认存储了一个Object的静态常量，取的时候也是只返回key，所以看起来就像List一样。 初始化 123456789101112131415161718private transient HashMap&lt;E,Object&gt; map; public HashSet() &#123; map = new HashMap&lt;&gt;();&#125; public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity);&#125; public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor);&#125; public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125; add()方法 可以看到这三个方法都是直接调用的HashMap的实现。 1234567891011public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125; public boolean contains(Object o) &#123; return map.containsKey(o);&#125; add其实就是调用HashMap的put方法，那么如何保证唯一性？ 如果哈希值和key都一样，就会直接拿新值覆盖旧值，而HashSet就是利用这个特性来保证唯一性。 其实和HashMap就是一样的。 12if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; contains方法（Get()方法 ） hashset没有get方法，因为没有意义：不需要获取某个键值对应的value。 具体实现直接调用hashmap的containsKey()方法： 过程和hashmap的get方法过程差不多，返回为null则是不存在。 123public boolean contains(Object o) &#123; return map.containsKey(o);&#125; 9. 1 HashSet如何检查重复 ？ 把对象加⼊ HashSet 时，HashSet先计算对象的hashcode 值； 根据hashcode值计算出要加⼊的位置，同时也会与其他加⼊的对象的hashcode值作⽐教； 如果没有相符的hashcode，HashSet会假设对象没有重复出现； 如果发现有相同hashcode值的对象，这时会调用 equals() 方法来检查hashcode相等的对象是否真的相同，如果两者相同，HashSet就不会让加⼊操作成功。 9.2 【新】contains()方法在HashSet和ArrayList的实现区别？ Arraylist 因为底层是object数组，判断某个对象是否存在，其实是通过遍历来进行判断的。 123456789101112131415161718 public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;//#1 &#125;/* 返回指定元素在列表中第一次出现的索引，如果该列表不包含该元素，则返回-1。*/ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; Hashset Hashset是hash值 &amp;&amp; 遍历链表equals() 都相等，来判断的。 12if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; 10. comparable 和 Comparator的区别？ 参考：https://www.cnblogs.com/xujian2014/p/5215082.html Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。 例如Person类，实现Comparable接口，使得所有Person类对象可以按照各自年龄大小进行排序。 12345@Override public int compareTo(Person p) &#123; return this.age-p.getAge(); &#125; Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。 Person类没有实现Comparable接口，该如何比较大小呢？我们可以新建一个类，让其实现Comparator接口，从而构造一个“比较器&quot;。 12345@Override public int compare(Person o1, Person o2) &#123; return o1.getAge()-o2.getAge(); &#125; Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。。 11. 如何选用集合? 需要存储键值对： Map接口的集合 需要排序时选择TreeMap 不需要排序时就选择HashMap 需要保证线程安全就选⽤ConcurrentHashMap 只需要存储元素，实现collection接口的集合，又分为： 需要保证元素唯一–Set接口的集合 HashSet 不需要元素唯一–List接口结合 查找比较多：ArrayList 增删比较多：LinkedList 1.3.3 List 1.用过 ArrayList 吗？说一下它有什么特点？ 自动扩容： 当加入数据达到一定程度后，会实行自动扩容，即扩大数组大小 ； 底层实现：底层是使用数组实现，add(int,o)，添加到某个位置，那么可能会挪动大量的数组元素，并且可能会触发扩容机制； 线程不安全 2. ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？ 线程安全： Vector线程安全，ArrayList 不是； Vector耗时：Vector 类的所有方法都是同步的。可以由两个线程安全地访问⼀个Vector对象、但是⼀个线程访问Vector的话代码要在同步操作上耗费大量的时间。 3. Array &amp; ArrayList不同点? Array可以包含基本类型和对象类型，ArrayList只能包含对象类型 ； Array大小是固定的，ArrayList的大小是 动态变化 的 ； ArrayList提供了更多的方法和特性: addAll()，removeAll()，iterator()。 4. Arraylist 与 LinkedList 区别? 索引/插入：ArrayList按序号索引，索引快插入慢；LinkedList不是，索引慢，插入快； 内存方面： Arraylist 是线性连续存储， 内存利用更低；LinkedList 是链表，内存利用更高（将内存零散空间串联），但也更占有内存（每个节点存储了两个引用）； 线程安全： ArrayList 和 LinkedList 都是不同步的，也就是都不保证线程安全； 底层数据结构： Arraylist 底层使用的是 Object数组； LinkedList 底层使用的是双向链表 数据结构 ； JDK1.6之前为循环链表，JDK1.7取消了循环。 5. 【源码解读】说说ArrayList的扩容机制吧 ？为什么是扩容1.5倍？默认大小是多少。 逐源码分析扩容机制 先把回答写在下面： ArrayList/vector默认大小都是10，但vectot扩容是2倍。 1. 扩容机制： 使用无参构造函数创建的数组长度为0，当第一次add后数组长度为10 ； 如果继续add超过10后，也就是不满足minCapacity（最小需要容量） - elementData.length &gt; 0 会触发扩容机制。 将新容量更新为旧容量的1.5倍 ，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】。 最后检查设置的新容量是否大于最大容量MAX_ARRAY_SIZE ，进入hugeCapacity() : 如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8 。 2. 为什么是1.5倍？ 因为，int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)，所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同。 比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数。 ArrayList总览 ArrayList继承于AbstractList ，实现了List,RandomAccess,Cloneable,java.io.Serializable 这些接口。 1234public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; &#125; RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问； ArrayList 实现了Cloneable 接口 ，即覆盖了函数clone()，能被克隆； ArrayList 实现了 java.io.Serializable 接口，这意味着ArrayList支持序列化，能通过序列化去传输。 ArrayList 核心源码解读（先耐心看一遍） 直接点击上面链接 逐源码分析扩容机制 查看。 【重点】JDK8 扩容机制 解读 从构造函数说起 （JDK8）ArrayList 有三种方式来初始化 : 以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。 jdk8中的ArrayList的对象的创建类似于单例的懒汉式。JDK8的内存优化也值得我们在平时开发中学习。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 /** * 默认初始容量大小 */ private static final int DEFAULT_CAPACITY = 10; /** * 空数组（用于空实例）。 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //用于默认大小空实例的共享空数组实例。 //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 保存ArrayList数据的数组 */ transient Object[] elementData; // non-private to simplify nested class access /** * ArrayList 所包含的元素个数 */ private int size; /** /** * 带初始容量参数的构造函数。（用户自己指定容量） */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123;//初始容量大于0 //创建initialCapacity大小的数组 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123;//初始容量等于0 //创建空数组 this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123;//初始容量小于0，抛出异常 throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125; &#125; /** *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回 *如果指定的集合为null，throws NullPointerException。 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 再看add方法 这里以无参构造函数创建的 ArrayList 为例分析 。 JDK11 移除了 ensureCapacityInternal() 和 ensureExplicitCapacity() 方法 12345678910/** * 将指定的元素追加到此列表的末尾。 */ public boolean add(E e) &#123; //添加元素之前，先调用ensureCapacityInternal方法 ensureCapacityInternal(size + 1); // Increments modCount!! //这里看到ArrayList添加元素的实质就相当于为数组赋值 elementData[size++] = e; return true; &#125; 再看 ensureCapacityInternal() 方法 第2步（JDK7）可以看到 add 方法 首先调用了ensureCapacityInternal(size + 1) 。 当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。 然后开始调用 ensureExplicitCapacity() 方法 123456789//得到最小扩容量 private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 获取默认的容量和传入参数的较大值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; 调用 ensureCapacityInternal() 进入ensureExplicitCapacity()这个方法 123456789//判断是否需要扩容 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) //调用grow方法进行扩容，调用此方法代表已经开始扩容了 grow(minCapacity); &#125; 我们来仔细分析一下： 当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 ensureCapacityInternal() 方法 ，所以 minCapacity 此时为 10。此时，minCapacity - elementData.length &gt; 0成立，所以会进入 grow(minCapacity) 方法。 当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，minCapacity - elementData.length &gt; 0 不成立，所以不会进入 （执行）grow(minCapacity) 方法。 添加第 3、4···到第 9 个元素时，依然不会执行 grow 方法，数组容量都为 10。 直到添加第 10 个元素，minCapacity &lt; elementData.length不成立。进入 grow 方法进行扩容。 elementData.length（实际容量）&gt;= minCapacity（最小需要容量） , 执行 grow() int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数。 将新容量更新为旧容量的1.5倍 ，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】。 最后检查设置的新容量是否大于最大容量MAX_ARRAY_SIZE ，进入hugeCapacity() : 如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8 。 1234567891011121314151617181920212223/** * 要分配的最大数组大小 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * ArrayList扩容的核心方法grow。 */ private void grow(int minCapacity) &#123; // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; //将oldCapacity 右移一位，其效果相当于oldCapacity /2， //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍， int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】， if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE， //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); 设置完新容量 newCapacity ，进行Arrays.copyOf Arrays的copyOf()方法传回的数组是新的数组对象，改变传回数组中的元素值，不会影响原来的数组。 第二个自变量指定要建立的新数组长度，如果新数组的长度超过原数组的长度，则保留数组默认值，例如： 使用 Arrays.copyOf()方法主要是为了给原有数组扩容。 contains()方法 就是遍历数组看是否存在该元素。 123456789101112131415161718 public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;//#1 &#125;/* 返回指定元素在列表中第一次出现的索引，如果该列表不包含该元素，则返回-1。*/ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 5.1 多线程操作ArrayList会出现什么错误？ 从ArrayList的（1）添加元素（add/addAll）和（2）获取元素（get） 两个角度来说： 多线程添加元素 假设此时minCapacity（最小需要容量）= 10 ，此时数组容量是10。A,B两个线程各需要添加若干元素，同时 判断此时不需要扩容，后续可能就会发生数组越界。 多线程获取元素 一个线程正在修改某个元素，另外一个线程此时正在读，那么读到的就是修改前的元素，也就是脏数据。 5.2 arraylist可以存多少数据？ Integer.MAX_VALUE = 2147483647 。 arraylist底层是一个数组对象：Object[] arr = new Object[10]，数组的大小只能设置int类型。所以能存储2147483647 字节数据。 6. 说一下LinkedList底层原理？ 参考：Java集合系列之三：LinkedList底层原理 LinkedList实现了List接口和Deque接口的，底层的双端链表结构使它支持高效的插入和删除操作，也具有队列的特性，非线程安全的。 相比ArrayList要简单很多，主要是双向链表那些操作。 底层结构 核心属性、构造方法和Node定义如下。 123456789101112131415161718192021222324252627282930public class LinkedList&lt;E&gt;extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; transient int size = 0; //LinkedList中存放的元素个数 transient Node&lt;E&gt; first; //头节点 transient Node&lt;E&gt; last; //尾节点 //构造方法，创建一个空的列表 public LinkedList() &#123;&#125; //将一个指定的集合添加到LinkedList中，先完成初始化，在调用添加操作 public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125;// Node节点 private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; add() 方法 朴实无华的双向链表尾插法。获得当前最后一个节点最为当前节点的前置节点，同样把当前节点设置为前置节点的后置节点，然后把当前节点作为最后一个节点，因为只需要创建一个节点与前一个节点建立前后关系即可，时间复杂度是O(1)。 123456789101112131415161718192021public boolean add(E e) &#123; linkLast(e); return true;&#125; void linkLast(E e) &#123; // 获得当前最后一个节点作为前置节点，可能为空 final Node&lt;E&gt; l = last; // 初始化当前节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 把当前节点作为最后的节点 last = newNode; // 第一次添加设置为第一个节点 if (l == null) first = newNode; else // 把当前节点设置为前置节点的后置节点 l.next = newNode; size++; modCount++;&#125; add(int index,E e) 按索引插入元素，首先判断是不是第一个添加的元素，如果是的话，直接使用add()方法添加就可以了，如果不是则需要根据索引来遍历寻找链表上对应位置。 这里用了个小技巧，判断索引是在前半段还是在后半段，从短的那头开始遍历，找到之后，新建一个节点，建立新的前置节点和后置节点的关系。时间复杂度是O(n)，n为size/2。 get(int index)方法 get()方法是用的上面介绍过的node()方法，时间复杂度是O(n)，n为size/2。 12345678910111213141516171819202122232425262728 public E get(int index) &#123; // 判断数组越界 checkElementIndex(index); // 遍历寻找节点 return node(index).item; &#125;// 获得被插入索引上的元素Node&lt;E&gt; node(int index) &#123;// assert isElementIndex(index);// 如果索引是在链表的前半段if (index &lt; (size &gt;&gt; 1)) &#123; // 获得第一个节点 Node&lt;E&gt; x = first; // 往后找到插入索引位置上的节点 for (int i = 0; i &lt; index; i++) x = x.next; return x;&#125;// 如果索引是在链表的前半段else &#123; // 获得最后个节点 Node&lt;E&gt; x = last; // 往前找到插入索引位置上的节点 for (int i = size - 1; i &gt; index; i--) x = x.prev; return x;&#125; 1.3.4 迭代器 1.请简单说明一下什么是迭代器？ Iterator提供了统一遍历操作集合元素的统一接口, Collection接口实现Iterable接口。 每个集合都通过实现Iterable接口中iterator()方法返回Iterator接口的实例, 然后对集合的元素进行迭代操作； 在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出ConcurrentModificationException 异常. 但是可以通过Iterator接口中的remove()方法进行删除。 2.请你说说Iterator和ListIterator的区别？ 遍历类型：Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List； 遍历方向：Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向； 功能区别：ListIterator实现了Iterator接口，并包含其他的功能","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"JAVA","slug":"校招笔记/JAVA","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://hwh.zone/tags/JAVA/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"}]},{"title":"校招笔记（一）_Java_面对对象","slug":"校招笔记（一）_Java_面对对象","date":"2021-11-26T11:57:22.483Z","updated":"2021-12-03T03:57:17.880Z","comments":true,"path":"p/7257/","link":"","permalink":"https://hwh.zone/p/7257/","excerpt":"","text":"我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。 备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 1.2 面对对象 1.2.1 基本问题 1.介绍一下面对对象七大原则？三大特性？ 七大原则 单一职责原则： 就一个类来说，应该仅有一个引起它变化的原因。也就是说，一个类应该只有一个职责。 如果有多个职责，那么就相当于把这些指责耦合在起，一个职责的变化就可能削弱或抑制了这个类完成其他职责的能力，引起类的变化的原因就会有多个。所以在构造一个类时， 将类的不同职责分离至两个或多个类中(或者接口中)，确保引起该类变化的原因只有一个。 开闭原则(OCP)： 软件组成实体应该是可扩展的，但是不可修改。开放-封闭原则认为应该试图设计永远也不需要改变的模块。可以添加新代码来打展系统的行为，不能对已有的代码进行修改。 这个原则很好的实现了面向对象的封装性和可重用性。 李氏替换原则(LSP)： 子类应当可以替换父类并出现在父类能够出现的任何地方。 以圆和椭圆为例，圆是椭圆的一一个特殊子类。因此任何出现椭圆的地方，圆均可以出现。 依赖倒置原则(DIP)： 在进行业务设计时，与特定业务有关的依赖关系应该尽量依赖接口和抽象类，而不是依赖于具体类。具体类只负责相关业务的实现，修改具体类不影响与特定业务有关的依赖关系。 为此，在进行业务设计时，应尽量在接口或抽象类中定义业务方法的原型，并通过具体的实现类(子类)来实现该业务方法，业务方法内容的修改将不会影响到运行时业务方法的调用。 接口分离原则(ISP)： 采用多个与特定客户类有关的接口 比采用一个通用的涵盖多个业务方法的接口要好。 举例：如果拥有一个针对多个客户的类，为每一个客户创建特定业务接口，然后使该客户类继承多个特定业务接口将比直接加载客户所需所有方法有效。 组合重用原则 ：能用组合实现的地方，尽量用组合来实现，而不要使用继承来扩展功能。 097因为组合能更好地实现封装，比继承具有更大的灵活性和更稳定的结构。 迪米特原则 : 一个对象应该对于其他对象有最少的了解，这样做的好处就是可以有效地降低类之间的耦合要求。 三大特性 封装。封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果⼀个类没有提供给外界访问的方法，那么这个类也没有什么意义了。 继承。 继承是使用已存在的类的定义作为基础建⽴新类的技术，新类的定义可以增加新的数据或新的功能，也可以用⽗类的功能，但不能选择性地继承⽗类。通过使用继承我们能够非常方便地复用以前的代码。 子类拥有⽗类对象所有的属性和方法（包括私有属性和私有方法），但是⽗类中的私有属性和方法子类是无法访问，只是拥有。 子类可以拥有⾃⼰属性和方法，即子类可以对⽗类进行扩展。 子类可以用⾃⼰的方式实现⽗类的方法。 多态。（1）静态多态：重载 （2）动态多态：所谓多态就是指程序中定义的引用变量所指向的具体类型和&lt;通过该引用变量发出的方法调用在编程时并不确定，而是在【程序运行期间才确定】。即⼀个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。 在 Java 中有两种形式可以实现多态：继承（多个子类对同⼀方法的重写）和接口（实现接口并覆盖接口中同⼀方法）。 1.1 java多态的原理？【阿里&amp;待重写】 多态分两种：（1）【编译】时多态（静态多态）（2）运行时多态（动态多态）。 静态多态 重载（overload）就是编译时多态的一个例子，编译时多态在编译时就已经确定。 运行时运行的时候调用的是确定的方法。 动态多态 我们通常所说的多态指的都是运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时（链接过程）才能确定。 通常动态多态的实现方法： 子类继承父类（extends） 类实现接口（implements） 核心之处就在于对父类方法的改写或对接口方法的实现，以取得在运行时不同的执行效果。 多态运行的原理 详细建议查看：深入理解Java多态的实现原理 背景介绍 类加载 时会将类的元数据信息（类的方法代码、类变量、成员变量的定义等等）保存到方法区，方法区主要分为两部分： 常量池：Java 类引用的一些常量信息，比如类的符号引用信息 方法区其它部分： 保存方法表等 链接过程 类的多态就发生在 链接的解析 过程，将 符号引用替换为直接引用。 原理简述（子类方法继承） 参考：https://www.huaweicloud.com/articles/9b805c24ab31a65f5883c0dfeaf5a39b.html 2.请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？ 构造函数： 每一个类都有构造函数，程序员没有创建时，编译器会默认创建一个构造函数；对象被创建时，构造函数被调用； 构造函数重载： 和方法重载类似，一个类可以创建多个构造函数，每个构造函数都有唯一参数列表； 复制构造函数： Java不支持像C++中那样的复制构造函数。 3.请说明Java中的方法重写(Overriding)和方法重载(Overloading)是什么意思？构造函数能否被重写？ Overriding ： 方法重写是说子类重新定义了父类的方法，有相同的方法名，参数列表和返回类型 ； Overloading： 同一个类里面两个或者是多个方法同名 ，但 参数列表不同不同。 特别的重写要求返回类型一致，但重载不要求返回类型一致！ 构造函数不能被 override（重写）！但是可以 overload（重载）,所以你可以看到⼀个类中有多个构造函数的情况。 3.1 f（List&lt;String&gt; l） f（List&lt;Integer&gt; l）是重载么？ 不是重载。 静态类型一致，并不会因为泛型而改变。因为编译期间，会对泛型进行擦除。 4.介绍一下接口和抽象类的区别？ 设计层面 接口，是对类的行为进行约束，强制要求不同类实现相同行为 ； 抽象类，既 1.非抽象类实现代码复用 2.又同时有抽象方法使得被继承类各自实现。 方法实现 抽象类可以有非抽象方法，有方法体 ； 接口不能有。 抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。 构造函数 抽象类有；接口没有。 修饰符 抽象类除private 都有（抽象类目的是被继承，所以抽象方法是为被重写，不能私有）；接口默认public。 继承个数 [接口优] 抽象类只能被继承一次；接口可以有多个。 5. Java的四种引用？强软弱虚 ？ 强引用 ：强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方式： 12String str = new String(&quot;str&quot;);System.out.println(str); 软引用： 软引用在程序内存不足时，会被回收（“软”，没钱用了第一个被打劫），使用方式： 可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。 123// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，// 这里的软引用指的是指向new String(&quot;str&quot;)的引用，也就是SoftReference类中TSoftReference&lt;String&gt; wrf = new SoftReference&lt;String&gt;(new String(&quot;str&quot;)); 弱引用：是只要JVM垃圾回收器发现了弱引用，就会将之回收，使用方式： 可用场景： Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用。一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。 1WeakReference&lt;String&gt; wrf = new WeakReference&lt;String&gt;(str); 虚引用：无法通过虚引用来获取对一个对象的真实引用； 虚引用必须与ReferenceQueue一起使用，当GC准备回收一个对象，如果发现它还有虚引用，就会在回收之前，把这个虚引用加入到与之关联的ReferenceQueue中。 可用场景： 对象销毁前的一些操作，比如说资源释放等。 Object.finalize() 虽然也可以做这类动作，但是这个方式即不安全又低效。 12PhantomReference&lt;String&gt; prf = new PhantomReference&lt;String&gt;(new String(&quot;str&quot;),new ReferenceQueue&lt;&gt;()); 6. JAVA创建对象的机制？ new创建新对象 通过反射机制 采用clone机制 通过序列化机制 7.简述Java的对象结构？ Java对象由三个部分组成：对象头、实例数据、对齐填充。 对象头。 在JVM中，对象在内存中除了本身的数据外还会有个对象头，对于普通对象而言，其对象头中有两类信息：mark word和类型指针。 如果是数组对象，还有数组长度。 mark word(32位) 具体的内容包含对象的hashcode、分代年龄、轻量级锁指针、重量级锁指针、GC标记（分代年龄）、偏向锁线程ID、偏向锁时间戳。 当对象状态为偏向锁时，mark word存储的是偏向的线程ID；当状态为轻量级锁（lightweight locked）时，mark word存储的是指向线程栈中Lock Record的指针；当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针。 存储类型指针，也就是指向类的元数据的指针，通过这个指针才能确定对象是属于哪个类的实例； 数组长度：另外对于数组而言还会有一份记录数组长度的数据。 实例数据。 来存储对象真正的有效信息（包括父类继承下来的和自己定义的）； 对齐填充。JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）。 8. Object有哪些常用方法？ equals方法 hashCode方法 wait方法 notify方法 notifyAll方法 1.2.2 反射 1.请说明一下JAVA中反射的实现过程和作用分别是什么？ （快手）优缺点？ 定义 反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。 jdbc就是典型的反射 : 1Class.forName(&#x27;com.mysql.jdbc.Driver.class&#x27;);//加载MySQL的驱动类 实现和作用 JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。 实现： （1）代码会编译成一个.class文件 （2）类加载器加载进JVM的内存中，在方法区创建了Object类的Class对象 不是new出来的对象，而是类的类型对象，每个类都只有一个Class对象，作为方法区类的数据结构的接口。 我们便是通过这个class对象来进行反射获取类的信息。 作用： 反射机制指的是程序在运行时能够获取自身的信息。在JAVA中，只要给定类的名字，那么就可以通过反射机制来获取类的所有信息。 根据类名在运行时创建实例（类名可以从配置文件读取，不用new） 反射优缺点 优点：（1）对于任意一个类，都能够知道这个类的所有属性和方法；（2）对于任意一个对象，都能够调用它的任意一个方法 缺点： 性能降低 ： 反射包括了一些动态类型，所以JVM无法对这些代码进行优化 安全限制： 使用反射技术要求程序必须在一个没有安全限制的环境中运行 内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用 2. 解释一下JAVA代理模式？动态代理的原理？ 参考这个：JAVA面试50讲之9：动态代理的原理是什么？ 代理模式是给某一个对象提供一个代理，并由【代理对象】控制对【原对象】的引用(使用)。 优点：代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；可以灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务。 缺点：由于使用了代理模式，因此程序的性能没有直接调用性能高；使用代理模式提高了代码的复杂度。 根据代理模式又可以分为：静态代理和动态代理。 2.1 静态代理 静态代理：由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口、被代理类、代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。 代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。 一个班的同学（Student）要向老师交班费，但是都是通过班长（StudentProxy）把自己的钱转交给老师。这里，班长就是代理学生上交班费，班长就是学生的代理。 公共Person接口 1234/public interface Person &#123; //上交班费 void giveMoney(); &#125; Student实现Person接口 1234567891011public class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void giveMoney() &#123; System.out.println(name + &quot;上交班费50元&quot;); &#125;&#125; StudentsProxy实现Person接口 实现了Peson接口，同时持有一个Student对象，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为。 ⚠️ 自己实现的giveMoney，调用的是被代理的学生对象.giveMoney() 方法！ 123456789101112131415/public class StudentsProxy implements Person&#123; //被代理的学生 Student stu; public StudentsProxy(Person stu) &#123; // 只代理学生对象 if(stu.getClass() == Student.class) &#123; this.stu = (Student)stu; &#125; &#125; //代理上交班费，调用被【代理学生的上交班费】行为 public void giveMoney() &#123; stu.giveMoney(); &#125;&#125; 使用实例1 123456789101112public class StaticProxyTest &#123; public static void main(String[] args) &#123; //被代理的学生张三，他的班费上交有代理对象monitor（班长）完成 Person zhangsan = new Student(&quot;张三&quot;); //生成代理对象，并将张三传给代理对象 Person monitor = new StudentsProxy(zhangsan); //班长代理上交班费，实际上是调用被代理对象的giveMoney方法 monitor.giveMoney(); &#125;&#125; 使用实例2：扩充增强原对象方法 班长在帮张三上交班费之前，想要先反映一下张三最近学习有很大进步，通过代理模式很轻松就能办到 。 1234567891011121314151617public class StudentsProxy implements Person&#123; //被代理的学生 Student stu; public StudentsProxy(Person stu) &#123; // 只代理学生对象 if(stu.getClass() == Student.class) &#123; this.stu = (Student)stu; &#125; &#125; //代理上交班费，调用被代理学生的上交班费行为 public void giveMoney() &#123; System.out.println(&quot;张三最近学习有进步！&quot;); stu.giveMoney(); &#125;&#125; 2.2 动态代理 上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就已经编译完成 。 然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成“的 。 优点： 可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 比如说，想要在每个代理的方法前都加上一个处理方法： 12345678910111213 public void giveMoney() &#123; //调用被代理方法前加入处理方法 beforeMethod(); stu.giveMoney(); &#125;// 代理类其它方法public void giveHomework() &#123; //调用被代理方法前加入处理方法 beforeMethod(); stu.giveHomework(); &#125; 除了giveMonney还有很多其他的方法（giveHomework），那就需要写很多次beforeMethod方法，麻烦。 简单实现 12345 //创建一个与代理对象相关联的InvocationHandler InvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu);//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法 Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler); 公共Person接口 1234/public interface Person &#123; //上交班费 void giveMoney(); &#125; Student实现Person接口 12345678910111213141516public class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void giveMoney() &#123; try &#123; //假设数钱花了一秒时间 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(name + &quot;上交班费50元&quot;); &#125;&#125; 增加一个计算方法执行时间的检测方法： 12345678910111213public class MonitorUtil &#123; private static ThreadLocal&lt;Long&gt; tl = new ThreadLocal&lt;&gt;(); public static void start() &#123; tl.set(System.currentTimeMillis()); &#125; //结束时打印耗时 public static void finish(String methodName) &#123; long finishTime = System.currentTimeMillis(); System.out.println(methodName + &quot;方法耗时&quot; + (finishTime - tl.get()) + &quot;ms&quot;); &#125;&#125; StuInvocationHandler 实现 InvocationHandler接口 并没有像之前一样：用一个代理类 StudentsProxy实现公共Person接口，而是代理类StuInvocationHandler 实现InvocationHandler接口。 但二者都是持有被代理的对象Student引用。 InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。 通过反射，可以执行被代理对象Student的相应方法giveMoney()。 123456789101112131415161718192021222324public class StuInvocationHandler&lt;T&gt; implements InvocationHandler &#123; //invocationHandler持有的被代理对象 T target; public StuInvocationHandler(T target) &#123; this.target = target; &#125; /** * proxy:代表动态代理对象 * method：代表正在执行的方法 * args：代表调用目标方法时传入的实参 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;代理执行&quot; +method.getName() + &quot;方法&quot;); */ //代理过程中插入监测方法,计算该方法耗时 MonitorUtil.start(); // 原来的代理对象Student中的方法 Object result = method.invoke(target, args); MonitorUtil.finish(method.getName()); return result; &#125;&#125; 具体实例 123456789101112131415public class ProxyTest &#123; public static void main(String[] args) &#123; //创建一个实例对象，这个对象是被代理的对象 Person zhangsan = new Student(&quot;张三&quot;); //创建一个与代理对象相关联的InvocationHandler InvocationHandler stuHandler = new StuInvocationHandler&lt;Person&gt;(zhangsan); //创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法 Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)； //代理执行上交班费的方法 stuProxy.giveMoney(); &#125;&#125; 2.3 动态代理的原理 从 JVM 角度来说，动态代理是在运行时，通过反射动态生成类字节码，并加载到 JVM 中的。 3. 如何利用反射创建一个对象？ 过程如下。 1234567891011121314151617181920212223242526272829303132333435363738import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Test &#123; public static void main(String[] args) &#123; try &#123; //1. 得到Stu类的运行时Class描述符 //简单理解为你现在有了这个类，可以调用相应的方法进行实例化了 Class&lt;?&gt; stu = Class.forName(&quot;Stu&quot;); //2.从getDeclaredConstructor()的字面意思就能理解，得到所有声明的构造器 //这里得到的是所有声明的构造器，getConstructor()则只能得到被public修饰的构造器 Constructor&lt;?&gt; declaredConstructor = stu.getDeclaredConstructor(new Class[]&#123;String.class, int.class&#125;); //3. 使用newInstance()方法创建对象并传入参数 //简单的理解为Stu o = new Stu(&quot;zhangsan&quot;, 01) Stu o = (Stu) declaredConstructor.newInstance(new Object[]&#123;&quot;zhangsan&quot;, 01&#125;); //4.调用Stu这个类里面的方法 // getDeclaredMethod()方法能调用到所有声明的方法 Method method = stu.getDeclaredMethod(&quot;toString&quot;, new Class[]&#123;&#125;); //5. 简单的理解为o.toStirng() String invoke = (String)method.invoke(o, new Object[]&#123;&#125;); System.out.println(invoke); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"JAVA","slug":"校招笔记/JAVA","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://hwh.zone/tags/JAVA/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"}]},{"title":"校招笔记（一）_Java_Java入门","slug":"校招笔记（一）_Java_Java入门","date":"2021-11-26T11:53:12.060Z","updated":"2021-12-03T03:56:32.443Z","comments":true,"path":"p/51787/","link":"","permalink":"https://hwh.zone/p/51787/","excerpt":"","text":"我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。 备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 1.1 JAVA入门 1.1.1 JAVA基本 1.介绍一下JVM&amp;JRE&amp;JDK？ JAVA语言有什么特点？ JVM&amp;JRE&amp;JDK JVM: 即java虚拟机，针对不同操作系统，JVM把Java代码翻译成对应操作系统可以识别的内容，实现跨平台 ； JRE : JVM + 核心类库 = JRE ， 即Java运行时环境。只有JVM不能运行，它还需要核心类库，才能保证Java运行 ； JDK: JRE + java开发工具（编译器等) = JDK ，Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具。 Java语言特点 简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 可靠性； 安全性； 支持多线程（ C++ 语⾔没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语⾔却提供了多线程支持）； 2.什么是Java虚拟机？为什么Java被称为平台无关的编程语言？ java虚拟机，是执行字节码文件（.class）的虚拟机进程； 在 Java 中，JVM 可以理解的代码就叫做 字节码 （即扩展名为 .class 的⽂件），它不面向任 何特定的处理器，只面向虚拟机。 java源程序（.java）被编译器编译成字节码文件（.class）。然后字节码文件，将由java虚拟机，解释成机器码（不同平台的机器码不同）。 3. 请你谈谈Java中是如何支持正则表达式操作的？（补充实例） Java中的String类提供了支持正则表达式操作的方法，包括： matches()、replaceAll()、replaceFirst()、split() 此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，如： 123456789101112import java.util.regex.Matcher;import java.util.regex.Pattern;class RegExpTest &#123; public static void main(String[] args) &#123; String str = &quot;成都市(成华区)(武侯区)(高新区)&quot;; Pattern p = Pattern.compile(&quot;.*?(?=\\\\()&quot;); Matcher m = p.matcher(str); if(m.find()) &#123; System.out.println(m.group()); &#125; &#125;&#125; 实例示范（PCG问过） 参考：https://www.runoob.com/regexp/regexp-syntax.html 特殊字符 普通字符 实例示范 匹配邮箱 匹配电话号码 1234//匹配电话号码String phone = &quot;18637866964&quot;;String reg = &quot;^1[3,5,7,8,9]\\\\d&#123;9&#125;$&quot;;System.out.println(phone.matches(reg)); 匹配第一个出现的数字 下面好像是不对的。 123String phone = &quot;avss1sdp22&quot;;String reg = &quot;\\d?&quot;;System.out.println(phone.matches(reg)); 4.（补充例子）请你简单描述一下正则表达式及其用途。 在编写处理字符串的程序时，经常会有查找 符合某些复杂规则的字符串 的需要。 计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具； 绝大多数语言都提供了对正则表达式的支持。 5.&amp;和&amp;&amp;区分？ 共同点：都要求运算符左右两端的布尔值 都是true 整个表达式的值才是true 区别：&amp;&amp;之称为短路运算，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。 好处： e.g. ：右边判别式有如果有空指针NullPointerException异常判断风险，可以避免。 6.值传递和引用传递区分？ 值传递是该变量的一个副本， 改变副本不影响原变量； 引用传递是对象地址的副本，引用对象进行操作会同时改变原对象。 7.十进制与二进制？ 请你讲讲一个十进制的数在内存中是怎么存的？ 补码形式。 为什么会出现4.0-3.6=0.40000001这种现象？ 2进制的小数无法精确的表达10进制小数，计算机在 计算10进制小数的过程中要先转换为2进制进行计算 ，这个过程中出现了误差。 8.（重要）equals与==的区别 很清晰严谨的一篇文章：https://www.cnblogs.com/skywang12345/p/3324958.html == 基本类型：比较的是值是否相同； 引用类型：比较的是引用（对象地址）是否相同； equals 要看类是否覆盖equals()方法，将它分为两种情况： 若某个类没有覆盖equals()方法，当它的通过equals()比较两个对象时，实际上是比较两个对象（地址）是不是同一个对象。这时，等价于通过“==”去比较这两个对象； 我们可以覆盖类的equals()方法，来让equals()通过其它方式比较两个对象的内容（而不是地址）是否相等。 String 中的 equals 方法是被重写过的： 因为 object 的 equals 方法是⽐教的对象的内存地址 而 String 的 equals 方法（1）先比较对象地址是否相等 ，相同则ture，否则（2）再比较值是否相等 7.请解释hashCode()和equals()方法有什么联系？ 面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode方法？” 建议看文中例子理解：https://www.cnblogs.com/skywang12345/p/3324958.html hashCode()介绍 hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该 对象在哈希表中的索引位置。 我们仅在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。 其它情况下hashCode() 则根本没有任何作用，所以，不用理会hashCode()。 在这种情况下对象相等，hashcode值也会不相等。 为什么要有hashcode() hashCode() 的作用就是获取哈希码，也称为散列码；它实际上是返回⼀个 int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。 hashCode()在散列表中才有用，在其它情况下没用。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。 先判断hashcode，而不是直接遍历O(n)复杂度用equals()判断，减少判断时间。 如果hashcode一样，会调用equals()去比较。 HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加⼊操作成功。如果不同的话，就会重新散列到其他位置。 7.1 为什么重写了equals()一定要重写hashcode()方法？ 参考：为什么重写了equals()，还要重写hashCode()？ 在Hashmap / Hashset中，通过计算hash = hash(key.hashcode) 然后进行取余操作，快速定位到数组中。 因为map中是不允许重复key的，所以对内部get()/add()方法：对于散列到数组同一位置的对象来说，如果hash相等 &amp;&amp; equals()判断相等 ，是要进行覆盖的。 12//调用 equals 方法判断key是否相等，若相等，该key对应的键值对已经存在，用新的value取代旧的value if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; 如果我们只重写了equals方法：用来判断两个对象是否相等。但是依旧可能出现：两个相同对象equals相等，但hashcode不等，被散列到不同桶上，map中依旧出现了重复键值对！ 所以，需要重写hashcode方法，保证相同对象一定是散列到同一个位置（具有同样的hash值）。 7.2 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么？ 不一定正确，如果在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。 其它情况下可能会出现题目描述的情况。 8. 自动拆箱和装箱？ 8.1 介绍一下int&amp;Integer？ Java为了编程的方便还是引入了基本数据类型，但是 为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class） int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换： 1234567891011// e.g. public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; // false 两个引用没有引用同一对象 System.out.println(a == b); // true a自动拆箱成int类型再和c比较 System.out.println(a == c); &#125; Java 为每个原始类型提供了包装类型： （8种基本类型）原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 8.2 拆箱、装箱存在的意义？ 为什么要有装箱、拆箱，它们的作用是什么？ java 是 面对对象编程，而基本数据类型不是对象，所有才有封装类 引用基本数据类型进行操作。比如，下面打印出int型数据： 12int i = 1； System.out.println(i); // 自动装箱 其实，查看源码，实际经过以下几个过程： 将 i 自动装箱成封装类 Integer 然后调用 Integer中 toString() 方法，打印出字符串输出到控制台。 自动装箱和拆箱？ 自动装箱：就是自动将基本数据类型转换为包装器类型 自动拆箱：就是自动将包装器类型转换为基本数据类型 8.3 char和byte的区别 ， 能否强制转换？ 区别： Char是无符号型的，可以表示一个整数，不能表示负数，大小范围 是0—65535；而byte是有符号型的，可以表示-128—127 的数 char可以表中英文字符，byte不可以 强制转换： 可以，但是会出现精度丢失。 9. String &amp; StringBuffer&amp; StringBuilder 区别？为什么String不可变? 请解释String &amp; StringBuffer区别？ 共同点：它们可以储存和操作字符串，即包含多个字符的字符数据； 可否修改：String类提供了数值不可改变的字符，StringBuffer可以修改字符串，需要 字符数据要改变 时用。 典型地，你可以使用StringBuffers来动态构造字符数据。 请解释 StringBuilder&amp; StringBuffer 区别？ 共同点：AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共⽗类。都可以修改字符串，操作字符串方法丰富。 12345678910111213abstract class AbstractStringBuilder implements Appendable, CharSequence&#123; /** * The value is used for character storage. */ char[] value; /** * The count is the number of characters used. */ int count; AbstractStringBuilder(int capacity) &#123; value = new char[capacity]; &#125; 线程安全：单线程且操作大量字符串用StringBuilder,速度快，但线程不安全，可修改；在多线程且操作大量字符串用StringBuffer，线程安全，可修改。 StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 为什么String 不可变？ String 类中使用 final 关键字修饰字符数组来保存字符串， 所以 String 对象是不可变的。 1private final char value[] 10.说说深拷贝和浅拷贝？ 浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址； 因此，可能会出现出现浅拷贝时释放同一个内存的错误。 深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存。 11. 【新增】介绍一下JDK1.8的新特性？ JDK1.8新增了非常多的特性，如： Lambda表达式：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。 方法引用：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法：默认方法就是一个在接口里面有了一个实现的方法。 新工具：新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。 Stream API：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。 Date Time API：加强对日期与时间的处理。 Optional类：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。 Nashorn，JavaScript引擎：JDK1.8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。 12. 【新增】java一个程序能不能有多个main方法？一个类里呢？ 一个程序里，多个class都有main方法 可以，默认第一个为入口，其余为普通函数。 12345678class Class1 &#123; public static void main(String[] args) &#123; &#125;&#125;public class Class2 &#123; public static void main(String[] args) &#123; &#125;&#125; 一个类有多个main方法 可以，其余就相当是重载。但是具有以下sigature（签名）的主要方法将被视为app入口点： 1public static void main(String[] args) 1.1.2 关键字 1.请你讲讲Java里面的final关键字是怎么用的？ 修饰类：表示不能被继承，final类 成员变量 可以设为final；但final类所有方法 ，都被隐式指定为final方法； 修饰方法：防任何继承类修改它的含义 ； 在早期的Java实现版本中，会将final方法转为内嵌调用，效率会更高； 修饰变量、引用：基本类型的话一旦初始化不能修改；引用类型，不能指定其他对象 。 2. 【重点】请你谈谈关于Synchronized和lock ？ Synchronized：是一个关键字，修饰类、方法 或 代码块 ，保证在同一时刻最多只有一个线程执行该段代码； 作用范围： 修饰一个类/静态方法，作用的对象是这个类的所有对象。 修饰一个方法/代码块，作用的对象是调用这个方法/代码块的对象。 Lock：是一个接口，Lock能完成synchronized所实现的所有功能。 Lock接口是不能直接实例化的，需要靠它的实现类ReentrantLock来进行实例化。 区别： 锁释放：synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；Lock不会主动适应 unLock() 释放，必须手动在finally释放。； 线程等待： Lock可以让等待锁的线程可以响应中断，线程可以中断去干别的事务；而synchronized却不行，使用synchronized时，等待的线程会一直等待下去； 成功获取锁： 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 3. instanceof关键字的作用？ instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例。 123int i = 0;System.out.println(i instanceof Integer);//编译不通过 i必须是引用类型，不能是基本类型System.out.println(i instanceof Object);//编译不通过 12Integer integer = new Integer(1);System.out.println(integer instanceof Integer);//true 4. final有哪些用法? 被final修饰的类不可以被继承 ； 被final修饰的方法不可以被重写，而且JVM会尝试将其内联，以提高运行效率； 被final修饰的变量不可以被改变； 被final修饰的引用，那么表示引用不可变，引用指向的内容可变； 被final修饰的常量，在编译阶段会存入常量池中。 5. static都有哪些用法 ? 修饰静态变量和静态方法 ：都属于类的静态资源，类实例所共享 ； 修饰静态块：用于初始化操作。 12345public calss PreCache&#123; static&#123; //执行相关操作 &#125;&#125; 修饰静态包：在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用方法名。 12345678910import static java.lang.Math.*; public class Test &#123; public static void main(String[] args) &#123; //System.out.println(Math.sin(20));传统做法 System.out.println(sin(20)); &#125;&#125; 6. 谈一谈transient关键字？ 参考 : Java中的关键字 transient Java中序列化操作 Java中对象的序列化指的是将对象转换成以【字节序列】的形式来表示，这些字节序列包含了对象的数据和信息。 当然，序列化后的最终目的是为了反序列化，恢复成原先的Java对象，要不然序列化后干嘛呢，所以序列化后的字节序列都是可以恢复成Java对象的，这个过程就是反序列化。 一个序列化后的对象可以被写到数据库或文件中，也可用于网络传输，一般当我们使用缓存cache（内存空间不够有可能会本地存储到硬盘）或远程调用rpc（网络传输）的时候，经常需要让我们的实体类实现Serializable接口，目的就是为了让其可序列化。 关于transient关键字 Java中transient关键字的作用，向虚拟机表明: transient变量不是对象的持久状态的一部分。 简单地说，就是让某些被修饰的成员属性变量不被序列化，例如： 类中的字段值可以根据其它字段推导出来，如一个长方形类有三个属性：长度、宽度、面积（示例而已，一般不会这样设计），那么在序列化的时候，面积这个属性就没必要被序列化了； 其它，看具体业务需求吧，哪些字段不想被序列化； 7.1 HashMap中源码modCount为什么用tranisent修饰？ modCount主要用于判断HashMap是否被修改（像put、remove操作的时候，modCount都会自增）。 对于这种变量，一开始可以为任何值，0当然也是可以（new出来、反序列化出来、或者克隆clone出来的时候都是为0的），没必要持久化其值。 1.1.3 Java异常 1. Java常见异常和分类？ 常见分为两类，Error和Exception ： Error ：指程序无法恢复的异常情况，对于其所有类型，都不要求程序处理。 常见错误：Stackoverflow，outOfMemory Exception： 程序有可能恢复的错误，又分为IOException &amp; RuntimeException ，常见错误： IOException：FileNotFoundExcepetion RuntimeException : 空指针，参数不合法，类未找到等 2. OOM产生原因和分析？ OOM，全称“Out Of Memory”，翻译成中文就是“内存用完了”，来源于java.lang.OutOfMemoryError 。 java.lang.OutOfMemoryError: Java heap space （堆溢出） 产生原因 内存泄漏； 堆分配太小； 解决办法 内存泄漏要手动去释放内存，比如数据库连接池，单例模式 通过虚拟机参数-Xms,-Xmx等修改，对内存大小 java.lang.OutOfMemoryError: PermGen space （永久代（方法区）溢出） 产生原因 即方法区溢出了： 一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区 ； 过多的常量尤其是字符串也会导致方法区溢出。 解决办法 永久代的内存分配增大 ：-XX:PermSize和-XX:MaxPermSize java.lang.StackOverflowError ------&gt; 不会抛OOM error，但也是比较常见的Java内存溢出。 线程栈相关的内存异常有两个： StackOverflowError(方法调用层次太深，内存不够新建栈帧) OutOfMemoryError（线程太多，内存不够新建线程） java.lang.OutOfMemoryError: Metaspace Java中普通I/O采用输入/输出流方式实现，输入流InputStream（ 终端—&gt;直接内存-&gt;JVM），输出流（JVM-&gt;直接内存-&gt;终端），这一过程中有kenel与JVM之间的拷贝（很多次）。 为了使用直接内存，Java是有一块区域叫DirectBuffer，不是JavaHeap而是cHeap的一部分。 但由于直接内存没有被java虚机完全托管，若使用不当，也容易触发溢出，导致宕机。 3. try catch finally，try里有return，finally还执行么？ 执行，并且finally的执行早于try里面的return ： 不管有木有出现异常，finally块中代码都会执行； 当try和catch中有return时，finally仍然会执行； finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的。 4.说说你是怎么处理异常的？ try-catch-finally try 块负责监控可能出现异常的代码 catch 块负责捕获可能出现的异常，并进行处理 finally 块负责清理各种资源，不管是否出现异常都会执行 其中 try 块是必须的，catch 和 finally 至少存在一个标准异常处理流程 5. web网页卡怎么排查？cpu100%怎么排查？OOM怎么排查？ web网页卡顿 用户端：硬件配置低、资源不足；CPU 或者内存资源不足, 比如用户是否使用了 Chrome 这种 “吃内存大户” 的浏览器并且打开了很多网页? 网络分析：DNS 解析慢；未设置 CDN，如果没有设置 CDN, 在跨线路访问(比如用户是铁通, 但是服务器部署在联通, 这种情况就是跨线路), 地理位置相差很远 等情况 ；用户端的带宽不足或所处环境网络不佳； 服务端：服务端响应慢，性能比较差 。 cpu100% 参考：https://www.cnblogs.com/dennyzhangdd/p/11585971.html 执行top命令：查看所有进程占系统CPU的排序； 极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。 执行top -Hp 进程号命令：查看java进程下的所有线程占CPU的情况； 执行printf &quot;%x\\n 10命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，咱们需要把线程号转成16进制。 执行jstack 进程号 | grep 线程ID” 查找某进程下–&gt;线程ID(jstack堆栈信息中的nid)=0xa的线程状态。 代码中有大量消耗CPU的操作，导致CPU过高，系统运行缓慢： jstack，可直接定位到代码行。例如某些复杂算法，甚至算法BUG，无限循环递归等等。 如果有死锁，会直接提示关键字：deadlock。步骤4，会打印出业务死锁的位置。 执行jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一致统计）”，查看某进程GC持续变化情况，如果发现返回中FGC很大且一直增大–&gt;确认Full GC! 也可以使用“jmap -heap 进程ID”查看一下进程的堆内从是不是要溢出了，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。 jstat命令监控GC情况，可以看到Full GC次数非常多，并且次数在不断增加。 执行jmap -dump:format=b,file=filename 进程ID，导出某进程下内存heap输出到文件中。 OOM 参考：https://www.cnblogs.com/valjeanshaw/p/13130102.html 先通过内存映像工具对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。 1jmap -dump:format=b,file=$java_pid.hprof #java_pid为java进程ID 然后看具体是报什么错：很明显下面是堆溢出。 123456789java.lang.OutOfMemoryError: Java heap spaceDumping heap to oom.out ...Heap dump file created [3196858 bytes in 0.016 secs]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3332) at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124) at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:700) at java.lang.StringBuilder.append(StringBuilder.java:214) at jvm.OomDemo.main(OomDemo.java:13)","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"JAVA","slug":"校招笔记/JAVA","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://hwh.zone/tags/JAVA/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"}]},{"title":"校招笔记（零）_写在前面","slug":"校招笔记（零）_写在前面","date":"2021-11-26T10:26:04.423Z","updated":"2021-12-11T14:42:18.346Z","comments":true,"path":"p/29708/","link":"","permalink":"https://hwh.zone/p/29708/","excerpt":"","text":"转眼就到了属于我的毕业季，还记得初来学校的期待和兴奋，却从“小师弟”眨眼变成了“老油条”。实习和秋招也算正式告一段落，对于我这种懒蛋，有幸拿到了腾讯、美团、Shoope SG等 后端开发岗 offer，勉强算是一个 “happy ending”。找工作是今年我经历的最重要事情之一，同时也想给师弟师妹提供一点帮助，便整理了这份 （互联网）校招笔记。 直入主题 互联网校招主要形式和考察内容如下： 考察形式 线上考察，视频面试（大部分公司）或电话面试（阿里等部分公司喜欢这种方式）。 考察内容 算法能力 俗称“刷题”，一般面试都是常见题，理论上刷完Leetcode-Top100，能做到烂熟于心（指现场秒背题或模板），大厂面试一般没有多大问题。 当然针对心仪公司，可以在面试前更加针对性地练习该公司的常出题，这一点上codeTop是一个不错的网站。 计算机基础 俗称“八股”，考察范围包含：计算机网络、Linux、数据库、操作系统、常见中间件&amp;框架、智力题等。可以看得到考察范围非常广，但是考察的题目非常固定。所以只要背熟常见题目问答便能不错地应对面试，这也是该部分内容被称为“八股文”的原因。 项目 &amp; 实习 项目顾名思义，就是实际做的开发项目（如果是算法岗则对应论文）。根据面试经验，一个好的开源项目是非常加分的。 实习通常是指大厂实习，在竞争这么激烈的情况下，如果没有实习，秋招想进入互联网大厂将会变得很困难。 根据以上内容，这份校招笔记争取尽量全面覆盖，整个目录安排如下： [注1]：本份笔记除自身总结外，主要参考资料来源于[1][2][3]，特此注明。 备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 下面是一些奇怪没有脑袋的絮絮叨叨，迫不及待年入百万可以根据上面目录直接开始学习了，以下可略过。 算法还是后端？ 读了个（末流）985硕士，也有篇不错的（水）论文，最后去做了当时本科毕业就能做的开发岗？—《本科同学竟是我的面试官》系列。 如果你和我有一样的困惑和选择，不妨来看看我的经历，也许会有点帮助。在这之前，我们先分析下算法和后端的各自优劣。 算法 P.K. 后端 在这里我将从，起薪、门槛、竞争强度、未来发展等维度来分析二者优劣。 [注1]：以下均以一线大厂（腾讯、阿里、字节、美团等）为基准。 [注2]：CV=Computer Vision，NLP=Natural Language Processing 。 [注3]：非特别说明，不考虑特例情况。 算法 后端 起薪 同级别比后端高：1~2K/月 中档薪资：40W+ 简历门槛 211硕士起 211本起（部分知名双非） 竞争强度 CV&gt;&gt;搜广推&gt;NLP CV&gt;Java后端&gt;&gt;C++后端&gt;其它 未来发展 二者发展相差不大，和个人强相关 二者发展相差不大，和个人强相关 其它 可以看到，CV竞争强度远大于其它算法岗位，即使和后端中竞争最激烈的Java后端相比，也依旧更大。 在读研期间，我个人研究方向就是CV领域（Object Tracking），有一篇论文（CCF-A，三审）和几篇专利。但是并没有信心去竞争CV相关岗位（学历和论文无优势），也对深度学习产生了迷茫：调参和模型缝补也许并不是我想做的事，虽然有更底层的研究方向但自己的数学基础不够牢靠。 就这样，带着七分迷茫三分盲目自信 的我一股脑扎进Java的苦海。可是Java后端岗位的竞争激烈程度远超我想象，实习和秋招一直都在失业边缘疯狂试探。无论是实习还是秋招，最后我接受的Offer都是C++后端岗位(腾讯) ，可以说是现实Java小丑了。 现在回头想想，Java后端竞争之所以这么激烈也基本是必然的：互联网的高薪（和996）吸引了大量其它专业转行的同学，而Java相比C++：易上手速成、需求大、生态丰富（培训班一条龙服务），自然是首选。 那么：到底是选择Java后端还是C++后端呢? 这里我也简单分析一下各自优劣，大家可以根据个人情况进行抉择。 Java后端 P.K. C++后端 一家之言，仅供参考。 在这里我将从，起薪&amp;门槛、岗位需求，竞争强度、未来发展等维度来分析二者优劣。 [注1]：以下均以一线大厂（腾讯、阿里、字节、美团等）为基准。 [注2]：非特别说明，不考虑特例情况。 Java后端 C++后端 备注 起薪&amp;门槛 基本一致 基本一致 岗位需求 非常多 一般 今年嵌入式爆热，C++岗位需求预计会增加 竞争强度 非常大，Java&gt;&gt;C++ 一般 未来发展 相差不大，和个人相关 相差不大，和个人相关 其它 银行和国企等养老性质单位对Java需求比较大，后期职业发展有更多选择 C++岗位需求主要是大厂，后期职业发展跳槽可选较少 对口公司 阿里、美团等 腾讯、百度、华为等 相信看到这里的聪明你，根据自己的技术倾向、意向公司等已经有了大概的思路： 想更容易去大厂，做一些更底层（网络、存储、操作系统、安全方面等）的事情，C++自然是不错的选择； 但是未来考虑去一些养老单位养老，对Web开发、移动开发等更感兴趣的话，Java应该是更好的选择。 求职时间节点 整个实习和秋招，由于自己的拖延和懒散，所有的时间节点基本都是在DDL上反复横跳。如果不是运气还不错，现在说不定正在寝室抱着浅蓝色床单哭泣 😭 ，留下不学无术的泪水。 所以根据自己的经验，整理了一份我认为的完美求职时间节点，同时也整理了一份工作小丑时间节点安排，供对比参考。 [注1]：年份以当年应届求职年份为准。 自律大佬 ⛹ 工作小丑 😹 1月份 刷完Leetcode-Top100，准备项目 玩 2月份 二刷LeetCode，开始背诵八股，优化项目 继续玩 3月份 八股基本烂熟，开始面试（找实习）小试锋芒 焦虑的玩 4月份 LeetCode和八股烂熟，收获众多大厂实习Offer，赢来工作小丑羡慕的赞叹 特别焦虑，开始一边羡慕一边投简历，面试被无情暴打 5月份 开始第一段大厂实习 极度焦虑，开始熬夜准备刷题和八股，继续面试 6月份 已实习两个月，同时面试收获了第二个大厂Offer，波澜不惊 终于收获Offer，现代范进中举，奔走相告 7月份 开始第二段大厂实习，开始提前批 实习第一个月，下班就是玩，提前批那是个啥？ 8月份 第二段大厂实习二个月，提前批收获校招Offer，同时无意外转正 实习两个月，继续无视提前批，运气好也转正了 9月份 Offer收割机+SSP收割机称号达成，羡慕听到麻 又玩了半个月，开始投简历，捡了几家Offer，彻底躺平 10月份 开始准备选调 白菜收割机称号达成，最终无奈选一颗大白菜结束秋招 关于实习：可以看到，工作小丑如果不是运气好转正，秋招凭借实习经历（另一方面也说明了实习的重要性）拿了几个Offer，整个求职过程并不乐观。 关于提前批 ：实习的时候一定要去准备提前批，提前批HC众多（特别是好岗位），难度也较低（亲身感受） ，拿到Offer的概率相比秋招会大很多。 所以，大家尽量早点充分准备，找工作不至于长期处于焦虑状态。拼运气自然不如拼实力，当然也要劳逸结合，有空闲多和师兄打打LOL放松下也是很有必要的 🕹 ，哈哈。 一些有用的app &amp; 网站 未必全面，仅供参考。 [注1]：各大公司校招官网，比如：腾讯校园招聘 ，最好先去提前一次性注册好简历。 应用/网站名 作用 网站 牛客网 找内推、看面经、求职交流等 Leetcode 刷题 codeTop 刷题 超级简历 制作简历的不二之选 royhuang’s blog 毛遂自荐，看看八股 github 神奇的地方，多在这里找各种资源：面经总结、项目教程等 APP 牛客网 同上 脉脉 求职信息交流，国内最大的职场交流APP 闲鱼 各种教学视频课程，不妨这里先搜一搜 🔼 以上大概就是我求职所用到的，全部网站或APP，不算多但基本有点用。 写在最后 碎碎念又写了小几K字了，9月底结束秋招时，便想着把自己求职的笔记总结&amp;经历复盘。不知不觉又拖延/玩了两个月，这个星期把网站搞好了也正好顺手开始整理。写到这里，终于有了初步了结，感觉像是De一个大BUG 🐛 ，心情都舒畅了起来。 后面还会继续更新没填好的坑，e.g. 怎么准备一个秋招项目。也会开始记录一些C++音视频相关方向博文，和一些生活记录（虽然大部分时间都是无聊地待在寝室或家里）。当然，如果还有什么想要和我说的，可以在下面留言。 最后，给上我最诚挚的祝福： “ 明年请务必倒挂我，谢谢。” 更新记录 2021-11-29 ：更新文档 更新校招心得记录 &amp; 重新分类整理笔记支持评论系统 2021-11-24 ：第一次更新 上传所有笔记并发布 1.Java Guide：https://github.com/Snailclimb/JavaGuide ↩2.阿秀C++面试笔记：https://github.com/forthespada/InterviewGuide ↩3.牛客网面经：https://www.nowcoder.com/interview/center ↩","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"目录","slug":"目录","permalink":"https://hwh.zone/tags/%E7%9B%AE%E5%BD%95/"},{"name":"后端","slug":"后端","permalink":"https://hwh.zone/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Git基础笔记（初步整理）","slug":"Git基础笔记","date":"2021-11-25T09:17:16.561Z","updated":"2022-01-02T12:12:14.051Z","comments":true,"path":"p/43848/","link":"","permalink":"https://hwh.zone/p/43848/","excerpt":"","text":"一、Git 简介 1.1 安装 安装地址 官网下载：Git官网下载 设置用户信息 主要是设置 ： 名字 &amp; Email 地址。 12$ git config --global user.name &quot;hwh&quot;$ git config --global user.email &quot;380141202@qq.com&quot; git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 1.2 创建版本库 创建仓库 ​ windows可以直接在桌面创建一个名为：&quot;Git&quot;文件夹，下有“test”子文件夹，子文件夹含有一个名为“readme.md”文件。 ​ 然后切换到其目录下（这里切换的是&quot;Git&quot;文件夹，而非“test”子文件夹） 123$ cd Git/$ pwd/c/Users/86151/Desktop/Git 初步提交过程 初始化仓库 12$ git initInitialized empty Git repository in /Users/michael/learngit/.git/ 修改仓库文件 将“test”子文件夹，下readme.md文件，增加内容。 添加文件到仓库 注意：可以同时 一次添加多个文件到仓库！ 1$ git add test/readme.md 提交文件 可以增加m参数：添加修改信息 1$ git commit -m &#x27;第一次文件改动&#x27; 二、时光机穿梭 2.0 更多控制修改提交 概览 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff &lt;filepath&gt;可以查看修改内容。 实操 再次修改文件 可以先清除原文件，再增添readme.md文档内容 ： 123“i am huitailang , here is my first test word .“ “这是我第二次修改这个文件” 使用 git status，查看状态发现readme.md文件已被修改但未提交（no changes） 1$ git status 查看具体修改了什么内容 git diff &lt;filepath&gt;查看文件具体修改， 1$ git diff test/readme.md 添加仓库 1$ git add test/readme.md 同时可用 git status，查看此时状态会显示，readme.md将要被提交修改。 提交仓库 1$ git commit -m &quot;这是我第二次修改&quot; ​ 再用 git status，查看仓库当前状态，显示没有需要提交的修改，而且工作目录是干净的（working tree clean）。 2.1 版本回退 概览 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本 实操 N次修改文件 先多修改几次文件提交，得到多个版本。 版本回退 查看版本历史 git log 查看当前版本和之前的历史，git relog 查看所有版本历史 1$ git log # 可以加上 --pretty=oneline 参数使显示更简洁 回退版本 git reset --hard &lt;指定版本&gt;：可用于回到指定版本，&lt;指定版本&gt;方式： HEAD ^ HEAD ^ 回到上个版本；HEAD ^ ^ 回到上上 个版本，依此类推。 1$ git reset --hard HEAD^^ # 回到上上个版本 HEAD~&lt;数字&gt; 回到前&lt;数字&gt;版本。如HEAD~100，回到前100个版本。 : commit ID 不用打全，一般打前面几个字符即可。如，如果回退第2版本，git log，只能看到第2版本及之前的版本信息。那么可用 git reflog查看所有版本ID，然后指定ID，回到第4版本。 1$ git reflog 12$ git reset --hard 3928d # 再次回到第四次修改版本HEAD is now at 3928d9f 第四次修改 2.2 工作区和暂存区 概览 理解工作区和暂存区的区别，暂存区是版本库的一个子集 比较文件有三个不同命令 git diff git diff --cached git diff --HEAD 工作区 工作区就是我们能看到的目录，如我前面创建的Git文件夹就是一个工作区 版本库 &amp; 暂存区 工作区有一个隐藏目录.git，不属于工作区而是Git版本库，版本库包含 Git自动创建的分支master&amp;指向master的指针HEAD stage（或叫index）暂存区 暂存区工作 git add 这一步实际上就是把文件修改（已存在被修改 OR 新文件）添加到暂存区，可以add多个文件，一次被提交。 git commit 把暂存区的所有内容提交到当前分支。 但是注意，git commit 后暂存区文件不会消失，始终是上一次git add之后文件！ git diff &amp;git diff --cached &amp;git diff HEAD git diff 比较的是工作区文件和暂存区文件区别。 git diff --cached 比较的是暂存区文件和仓库分支文件区别。 git diff --HEAD 比较的是工作区文件和仓库分支最新版本区别。 暂存区：就是 .git / index 这个文件，git add 会把工作区修改的文件添加到暂存区，即使 git commit 后也不会空，始终保存最近一次 git add后的内容。 仓库分支：始终保存上次git commit 内容。 2.3 管理修改 概览 git管理的是修改，而非文件 实操 新建一个文件 readme1.txt，然后依次： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit ​ 用git diff HEAD test/readme1.txt 比较工作区和版本分支，会发现第二次修改没有被提交，说明git只把git add后暂存区内容提交了，而不管理文件。 如果要把第二次修改也提交了，需要进行以下操作： 第一次修改 -&gt; git add -&gt; 第二次修改-&gt; git add -&gt; git commit 2.4 撤销修改 概览 场景1：改乱了工作区某个文件的内容，想直接丢弃工作区的修改时 用命令git checkout -- file。 场景2：不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改 第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1 第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交 参考版本回退一节，不过前提是没有推送到远程库。 实操 场景1 不小心在文件里增加了一句话： 刘婷是傻子 用 git checkout命令撤回工作区修改，有两种情况 readme.txt修改但未被放到暂存区，撤销修改就回到和版本库一样状态； readme.txt修改且添加到暂存区后，撤销修改就回到添加到暂存区后的状态。 ⚠️ 总之，就是让文件回到最近一次git commit或git add时的状态。 🕵所以，也可用于恢复误删的文件（撤销工作区删除操作） 1git checkout -- test/readme.md 场景2 不小心在文件里增加了一句话，而且已经git add提交到暂存区 刘婷是傻子哈哈哈 命令git reset 不仅可以回退版本 而且可以把暂存区的修改撤销。 ⚠️之所以不直接 git checkout 是因为此时会用暂存区内容覆盖工作区，显然不行。 1git reset HEAD test/readme.md # HEAD表示最新版本 然后此时再用git checkout ，暂存区内容覆盖工作区 1git checkout -- test/readme.md 再次查看文件发现，‘’刘婷是傻子哈哈哈‘’ 的胡话已经被没了，暂存区也没了。 场景3 又说胡话，不但 git add 且git commit（暂存区和版本库HEAD都是修改后版本） 刘婷是傻子哈哈哈哈哈哈 这个时候只有回退版本了 1$ git reflog # 查看版本号 12$ git reset --hard 3928HEAD is now at 3928d9f 第四次修改 2.5 删除文件 rm 删除 原理 rm 删除文件，只相当于删除了 工作区文件，如果要恢复文件撤销工作区修改即可。 1rm test/readme.md 恢复 用git checkout -- &lt;file&gt;，它会用最新版本库文件（如果已经git add 用最新暂存区内容，见前）覆盖工作区文件，则相当于撤销工作区修改 1git checkout -- test/readme.md git rm 删除 原理 git rm 删除文件，不但相当于删除工作区文件 &amp; 而且git add添加到暂存区。 所以此时直接git checkout 是用暂存区内容覆盖 工作区，显然是没用的。 恢复 先恢复暂存区 1git reset HEAD test/readme.md # HEAD表示最新版本 再用暂存区覆盖工作区 1git checkout -- test/readme.md 彻底删除 如前所述，git rm 已经删除了 ①工作区文件 ② 添加到暂存区，那么此时只需要 1git commit --m &#x27;彻底删除&#x27; # 将③版本库内容也修改 那么文件就会从工作区、暂存区、版本库全部删除。 彻底删除恢复 如果已经commit，那么只能git reset回退版本 12$ git reset --hard 3928HEAD is now at 3928d9f 第四次修改 三、远程仓库 3.1 添加远程库上传本地文件 以下操作基于默认你 创建好 github 账号 &amp; 创建好一个仓库 设置好本地ssh -key 而且已经同时在github网页服务端账号设置里添加 ssh -key 添加用户信息 12$ git config --global user.name &quot;hwh&quot;$ git config --global user.email &quot;380141202@qq.com&quot; 初始化本地仓库 如果本地仓库从未被初始化才需要，初始化会创建一个隐藏的 .git 文件管理版本。 cd切换 + git init cd命令切换到后本地仓库； git init 初始化本地仓库，会为你创建一个 .git文件，已经初始化不用。 手动 bash ⚠️ 很奇怪的是，这样 git add . --&gt; git commit --&gt; git push后，会把整个父文件夹推送上去。 比如：地址 TEST 文件夹下有 README.md ，推送后github上显示的 TEST文件夹，而不是我想的README.md文件。 右击本地仓库，选择Git Bash here 把本地仓库添加到版本库 12$ git add . # add . 提交所有新建、修改文件$ git commit -m &#x27;第一次添加本地仓库到版本库&#x27; 本地仓库关联远程库 git remote add &lt;远程库名设置&gt; &lt;远程仓库地址&gt; 显然这里把远程仓库地址设置为 origin。 1$ git remote add origin git@github.com:huangwanghuiYY/gitTest.git 推送到远程库 下面代码表示：将本地master分支推送到远程仓库origin。 1$ git push -u origin master # 第一次推送带 -u 参数 -u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。 1$ git push origin master 3.2 从远程库克隆 ​ 当我们想多人协作时会用到克隆。比如有一个不错的开源项目，你可以克隆到本地仓库进行修改等。 确定要克隆的仓库 比如我的XSurvey项目。 git clone 进行克隆 克隆会在当前文件夹创建克隆的仓库，克隆仓库以XSuery为名，下含项目文件。 1$ git clone git@github.com:huangwanghuiYY/XSurvey.git 四、分支管理 4.1 创建和合并分支 这一节，涉及大量图形，廖雪峰教程 讲的很好，这里尽量精简记录心得。 概述 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 实操记录 主分支 ​ master分支也是一条时间线，每次提交 master 分支都会向前移动一步，随着不断提交 master分支也就越长。 ⚠️下图有两个指针：HEAD &amp; master ，HEAD严格来说不是指向提交。HEAD指向master，master指向最新分支。 新分支创建切换 创建新分支 1234$ git branch dev1 # 新建分支$ git branch # 查看分支 dev1* master # * 表示当前所在的分支（master） ​ 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master指向的提交。 切换到当前分支 1$ git checkout -b dev1 如果checkout 加上 -b参数，表示 创建 &amp; 切换两个操作 1$ git checkout dev1 切换到当前分支，其实把head指向master所指向的提交。 ⚠️这张图，还表示dev分支还执行了一次提交。 合并分支 12$ git checkout master # 先切回master分支（即HEAD指向master）$ git merge dev1 # 表示当前分支（master）合并 dev1分支 根据上图我们可以看到： ​ dev分支向前走了一步，dev指向了当前最新提交，而master指针依然指向上次提交。 ​ 如果要合并，那么直接让master指向dev指向的当前提交 。相当于，master也提交过一次。 删除分支 12$ git branch -d devDeleted branch dev (was b17d20e). ​ 删除分支，等价于删除创建分支后的提交记录（上图红色线），但由于master指向了最新提交，等价复制dev1的提交记录（蓝色线）。 ​ 4.2 解决同时修改冲突 产生冲突原因 在master分支上 在当前master分支上，创建一个新分支 dev2 同时master分支上，对README.md文件增加一句话 i said master ⚠️ 然后，git add --&gt; git commit 在dev2分支上 checkout切回master分支上，对README.md文件增加一句话 i said dev2 ⚠️ 然后，git add --&gt; git commit 合并 12$ git checkout master$ git merge dev2 显示，README.md文件同时被修改，发生冲突（也可用 git status 查看） vim 查看文件显示具体冲突： 1$ vim README.md #当前HEAD指向master，所以下图显示HEAD 解决冲突 Ⓜ️此时两个README.md已经是一个文件了，文件内容就是上图vim查看的所有内容 。 我们再命令行端口也可以看到，提示我们在 master|MERGING 合并中。 ​ 我们打开文件，修改文件内容为：（第一句话有误，此时实在master分支上，不用在意） 这是的dev分支，我增加了一句话 修改冲突，这里变成这样。其实不修改直接提交也解决冲突，只是没解决同时修改。 然后再提交，发现冲突已经解决： 12$ git add README.md $ git commit -m &#x27;解决冲突&#x27; 4.3 分支管理策略 – 禁用Fast forward 概览 通常，合并分支时，如果可能，Git会用Fast forward模式，则直接把 master 的指针直接指向了 dev 分支的最新提交，这样两个分支的最新提交的 commit id 就是一样的。但这种模式下，删除分支后，会丢掉分支信息。 加上--no-ff参数，强制禁用Fast forward模式，使用普通模式。Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 实操 默认已经创建好分支 dev3，且修该了文，进行了一次commit。 然后下面都是在 master分支上尝试合并操作 切回master 1$ git checkout master 合并分支 –no–ff ： 普通模式合并。 -m ：由于本次合并dev要创建一个新的commit，所以加上-m参数，添加描述。 1$ git merge --no-ff -m &quot;merge with no-ff&quot; dev 查看历史 123456$ git log --graph --pretty=oneline --abbrev-commit* e1e9c68 (HEAD -&gt; master) merge with no-ff|\\ | * f52c633 (dev) add merge|/ * cf810e4 conflict fixed Fast forward模式 &amp; 普通模式 对比 FF模式不用--no-ff，实际上只是将master的指针update成dev分支而已。用的还是dev的commit ID。 普通模式用，则是重新commit一次，有了新的commit ID，保留了分支版本记录。 Fast forward模式 普通模式 4.4 BUG分支—git stash 概览 ​ 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； ​ 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 实操（应用场景） master 上面发布的是A的1.0版本 dev 上开发的是A的2.0版本 ，刚刚新建了test文件 &amp;修改README.md： 这里是dev分支。 这时，用户反映 1.0版本存在漏洞，有人利用这个漏洞开外挂 需要从dev切换到master去填这个漏洞，正常必须先提交dev目前的工作，才能切换。 如果不commit切换分支： 1$ git checkout master 发现当前工作目录，是dev分支工作目录！ 解释1 一个本地的git repo只有一个工作区和暂存区，但是有多个分支的提交区，而我们的checkout只是将HEAD指针从一个分支切换到另一个分支。 所以： 切换后工作区内容是branch的工作内容 经过测试，如果切回dev分支，进行add --&gt; commit 再切回master就回到 master工作区。 而dev的工作还未完成，不想提交，所以先把dev的工作stash一下，然后切换到master： 先git add test ⚠️ 为什么要先add test文件？ test文件是新建，还未被git管理！让git add追踪test文件，否则即使 git stash ，test文件也依然会出现在master工作目录中！ 1$ git add test git stash 然后切换 12$ git stash$ git checkout master 恢复dev工作目录 简单恢复： 1$ git stash pop # 恢复的同时把stash内容也删了 有多个因此目录，可以配合下面目录恢复： 123$ git stash list stash@&#123;0&#125;: WIP on dev: f52c633 add merge$ git stash apply stash@&#123;0&#125; # 恢复不会删除stash内容 在master建立分支issue101并切换。 在issue101上修复漏洞。 修复后，在master上合并issue101 。 切回dev，恢复原本工作，继续工作。 4.5 删除分支 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。 4.6 多人协作 查看分支 1$ git remote -v # 带-v参数查看更加详细 push 推送分支 git push &lt;远程库名&gt; &lt;要推送分支名&gt; ​ 推送本地主分支master到 origin master，相当用本地master版本覆盖远程origin master版本。 ⚠️ git push 只能用户该项目属于自己的情况，因为要输入账号密码！参与他人开源： 成为该开源项目贡献者（由项目作者设置） fork 该项目 ----&gt; clone到本地----&gt; 修改 ----&gt; 发起 pull requset —&gt; 讨论 &amp; 等待合并 还有其他更多情况，如产生冲突等，查看：pro git 中文# 对项目做出贡献 1$ git push origin master 推送其他分支到远程库 ，也可以查看。 1$ git push origin dev clone 克隆分支工作 多人协作时，大家都会往远程库master和dev分支上推送各自的修改。 克隆主分支 ⚠️ 克隆只能克隆master分支！！ 现在，模拟你的小伙伴，在另一台电脑（注意要把SSH Key添加到GitHub）克隆： 1$ git clone git@github.com:michaelliao/Python-100-Days 克隆远程dev分支开发 由于只能克隆master分支，而又要在远程dev分支开发，那么： 1$ git checkout -b dev origin/dev 之后就可进行修改 —&gt; 提交 ：git push了 git pull 一种应用情况：A、B都克隆了项目，在远程分支dev上进行开发（分别在本地也克隆dev分支） A修改了文件 README，并进行了push提交 。 你也修改了README，进行提交修改，会出错，原因是 ⚠️远程分支比你的本地更新！ 只有先 pull 最新分支你的分支合并 —&gt; 解决冲突—&gt;提交 git pull命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并，它的完整格式稍稍有点复杂。 在默认模式下，git pull是git fetch后跟git merge FETCH_HEAD的缩写。 git pull == git fetch+ git merge （默认是检索头部合并到当前分支） ⚠️ 使用–rebase，它运行git rebase而不是git merge。 1$ git pull&lt;可选参数&gt; &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 示例 比如，要取回origin主机的next分支，与本地的master分支合并： 1$ git pull origin next:master 省略当前分支名 如果远程分支(next)要与当前分支合并，则冒号后面的部分可以省略。上面命令可以简写为： 1$ git pull origin next 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再执行git merge。 12$ git fetch origin$ git merge origin/next 省略远程分支名 某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。 Git也允许手动建立追踪关系，指定master分支追踪origin/next分支： 1$ git branch --set-upstream master origin/next 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。 1$ git pull origin 上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”(remote-tracking branch)进行合并。 省略远程主机名 如果当前分支只有一个追踪分支，连远程主机名都可以省略。 1$ git pull git fetch和git pull的区别 git fetch：相当于是从远程获取最新版本到本地，不会自动合并。 123$ git fetch origin master$ git log -p master..origin/master$ git merge origin/master 以上命令的含义： 首先从远程的origin的master主分支下载最新的版本到origin/master分支上 然后比较本地的master分支和origin/master分支的差别 最后进行合并 上述过程其实可以用以下更清晰的方式来进行： 123$ git fetch origin master:tmp$ git diff tmp $ git merge tmp git pull：相当于是从远程获取最新版本并merge到本地 1git pull origin maste 五、标签管理 5.1 创建标签 5.2 操作标签 六、使用Github 6.1 简单上传 设置用户信息 12$ git config --global user.name &quot;hwh&quot;$ git config --global user.email &quot;380141202@qq.com&quot; git init 初始化仓库 1$ git init 本地创建ssh key 1$ ssh-keygen -t rsa -C &quot;380141202@qq.com&quot; # 后面会要求设置密码可不设置 然后会在：C:\\Users\\80651\\.ssh 生成ssh key 文件，其下有一个公钥 id_rsa.pub，记事本打开复制。 打开github设置 打开github 在个人设置中添加**2.**中ssh key。 可用 ssh -T查看是否成功 1$ ssh -T git@github.com 对文件一些操作 比如，这里以增加一个README文件，然后git commit 提交到版本库。 12$ git add README # 也可add . 提交所有新建、修改文件$ git commit -m &#x27;增加readme&#x27; push 上传到版本库 1$ git push origin master Q : git push 出现错误 ‘’ error: failed to push some refs to git‘’ A : 一般是因为github中的README.md文件不在本地代码目录中 添加 -f 参数强制覆盖 1git push -f origin master 通过如下命令进行github与本地代码合并: 12$ git pull --rebase origin master # 先和本地代码合并$ git push # 然后再上传 6.2 参与开源项目 可参考：GitHub的Pull Request 是指什么意思 七、自定义Git 服务器端安装Git 1$ yum install git 创建用户 &amp; 组 管理仓库目录 12$ groupadd git$ useradd git -g git # -g 参数表示把用户gituser主组设置为 git 创建目录 我们先创建一个目录gitrepo用来管理其下仓库，一般习惯在 /var下创建。 12$ cd /var$ mkdir gitrepo 给其设置好用户 &amp; 组，便于管理 1$ chown -R gituser:git gitrepo # 把目录gitrepo 设置用户gituser &amp; 组 git ls -l 查看是否设置成功： 创建仓库 创建hwhComputer2Backup.git仓库，并初始化用来上传电脑备份。 12$ cd gitrepo # 注意先切换到git下$ git init --bare hwhComputer2Backup.git 创建证书 在本地电脑上 执行以下命令创建ssh 公钥。会在：C:\\Users\\80651\\\\.ssh 生成ssh key 文件，其下有一个公钥 id_rsa.pub。 1$ ssh-keygen -t rsa -C &quot;380141202@qq.com&quot; # 后面会要求设置密码可不设置 切回服务端 裸机需创建/home/git/.ssh/authorized_keys文件。 123$ cd gitrepo/$ mkdir .ssh$ touch .ssh/authorized_keys 然后把本地电脑上公钥复制导入，一行一个（？） 1$ vim .ssh/authorized_keys 再次修改权限 创建的子目录 用户 &amp; 组 默认是 root root ⚠️由于.ssh &amp; 仓库 hwhComputer2Backup.git 都不属于 gituser ，所有还需设置权限。否则进行 push pull 操作 没有足够权限。 12$ cd /var$ chown -R gituser:git gitrepo 本地上传文件 添加用户信息 12$ git config --global user.name &quot;hwh&quot;$ git config --global user.email &quot;380141202@qq.com&quot; 初始化本地仓库 12$ cd D:/hwh/uploadToGit$ git init 把本地仓库添加到版本库 错误：c#程序练习 does not have a commit checked out 解决：是因为 c#程序练习 这个文件夹已经被初始化，查看隐藏文件可以发现 .git文件删除其即可。 12$ git add . # add . 提交所有新建、修改文件$ git commit -m &#x27;第一次备份文件&#x27; 本地仓库关联远程库 移除当前远程连接： 1git remote remove origin git remote add origin &lt;服务端用户名&gt;@&lt;远程库名地址&gt;:&lt;远程仓库地址&gt; ⚠️&lt;服务端用户名&gt; : 是在服务端的用户！ 1$ git remote add origin gituser@129.28.154.240:/var/gitrepo/hwhComputer2Backup.git 推送到远程库 似乎由于 ssh key 设置不对，git push 要输入用户 gituser 的密码 123456？ 1$ git push -u origin master # 第一次推送带 -u 参数 等待上传服务器(速度有点慢)： 八、debug 记录 ERROR：由于存在 &gt;100M 文件，提交后报错，不允许提交超过100M 文件，进行如下操作： 压缩并删除&gt;100M文件 将相应文件加入 .gitignore 再次commit --&gt; push 依旧报相同错误。 解决办法如下，参考：Fixing the “GH001… 删除文件 建议可以先回退最近的commit 分支 利用以下命令删除所有在仓库中 &gt;100M 的文件： 1git filter-branch -f --index-filter &#x27;git rm --cached --ignore-unmatch &lt;大于100M文件URL&gt;&#x27; 例如，我的例子： 1git filter-branch -f --index-filter &#x27;git rm --cached --ignore-unmatch Experiment/Ex4_CustomerForecast/src/train.csv&#x27; 再次提交 为了保险，可以先： 1git rm -r --cached ./ # 本地代码不会被删除 接下来正常：git add --&gt; git commit --&gt; git push 即可","categories":[{"name":"Git","slug":"Git","permalink":"https://hwh.zone/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://hwh.zone/tags/Git/"}]},{"title":"校招笔记（九）_计算机基础_相关补充","slug":"校招笔记（九）_计算机基础_相关补充","date":"2021-11-25T08:29:59.274Z","updated":"2021-12-11T15:17:34.067Z","comments":true,"path":"p/5582/","link":"","permalink":"https://hwh.zone/p/5582/","excerpt":"","text":"我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。 备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 九、相关补充 9.1 （要扩充）设计模式 没有足够实际代码经验，只好先写这些应付下面试。 1.说说什么是单例模式 ?手写一个？ 单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。 手写单例模式 参考：https://www.runoob.com/design-pattern/singleton-pattern.html 记忆：“2private + 1public ” 饿汉式 线程安全 ， 但：类加载时就初始化，浪费内存。 1234567891011121314151617public class SingleObject &#123; // 创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); // *让构造函数为 private，这样该类就不会被实例化 private SingleObject()&#123;&#125; // 获取唯一可用的对象 public static SingleObject getInstance()&#123; return instance; &#125; public void showMessage()&#123; System.out.println(&quot;Hello World!&quot;); &#125; &#125; 懒汉式（不加锁） 只有真正调用获取实例对象时，才会创建一次。 1234567891011121314public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; // 调用时才判断 if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 懒汉式（加锁） 线程安全，但加锁性能不够高 123456789101112public class Singleton&#123; private static Singleton instance; private Singleton ()&#123;&#125; // 就是多了个synchronized关键字 public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 双检锁式 懒汉式（加锁）虽然可以保证只创建一个单例，但其性能不高，因为每次访问整个方法都加锁。 因此出现双检索式，在instance=new DoubleCheckSingleton(); 进行加锁 ， return instance;不加锁！ 为什么要进行两次检查instance==null？ 第一层检查作用 主要为了提高性能。如果没有第一层，上来就要加锁比较耗费性能 第二层检查作用 解决多线程并发问题。假设是第一次开始执行getInstance方法： A，B两个线程，此时instance==null ，A，B都通过了第一层检查。 假设A先拿到锁，往下执行创建一个实例，然后释放了锁； 此时B也拿到了锁，如果没有第二层检查，B会进行重新new一个实例，违背单例模式！ 12345678910111213141516171819202122232425262728public class DoubleCheckSingleton&#123; // volitale 关键字修饰，避免指令重排，因为初始化操作是不原子化的 ： // (1) 给DoubleCheckSingleton类的实例instance分配内存 // (2) 调用实例instance的构造函数来初始化成员变量 // (3) 将instance指向分配的内存地址 // 在多线程中，A可能是 1→3→2的顺序，执行到1→3，此时另外一个线程看到instance不为null（因为前面线程执行了3）就直接返回实例。而此时并没有被分配内存故可能出现问题。 private volatile static DoubleCheckSingleton instance; // 私有的构造方法 private DoubleCheckSingleton() &#123;&#125; public static DoubleCheckSingleton getInstance()&#123; if(instance==null)&#123; //第一层检查，是否存在实例 synchronized (DoubleCheckSingleton.class)&#123; if(instance==null)&#123; //第二层检查，防止出现另外一个线程阻塞在synchronized，获得锁后重复创建实例 instance=new DoubleCheckSingleton(); &#125; &#125; &#125; return instance; &#125; &#125; 2.说说你对代理模式的理解？ 代理模式是给某一个对象提供一个代理，并由代理对象控制对原对象的引用。 优点：代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；可以灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务。 缺点：由于使用了代理模式，因此程序的性能没有直接调用性能高；使用代理模式提高了代码的复杂度。 3.说说简单工厂模式？ 简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 比如，一台咖啡机就可以理解为一个工厂模式，你只需要按下想喝的咖啡品类的按钮（摩卡或拿铁），它就会给你生产一杯相应的咖啡，你不需要管它内部的具体实现，只要告诉它你的需求即可； 【优点】工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品； 【缺点】 不易拓展，一旦添加新的产品类型，就不得不修改工厂的创建逻辑； 产品类型较多时，工厂的创建逻辑可能过于复杂，一旦出错可能造成所有产品的创建失败，不利于系统的维护。 4.说说抽象工厂模式？ 抽象工厂模式是在简单工厂的基础上将未来可能需要修改的代码抽象出来，通过继承的方式让子类去做决定。 【简单工厂模式缺点】以上面的咖啡工厂为例，某天我的口味突然变了，不想喝咖啡了想喝啤酒，这个时候如果直接修改简单工厂里面的代码，这种做法不但不够优雅，也不符合软件设计的“开闭原则”，因为每次新增品类都要修改原来的代码。 【抽象工厂】抽象工厂里只声明方法，具体的实现交给子类（子工厂）去实现，这个时候再有新增品类的需求，只需要新创建代码即可。如，创建一个啤酒工厂而不是咖啡工厂。 5.装饰器模式是什么？ 不够深入。 装饰器模式是指动态地给一个对象增加一些额外的功能，同时又不改变其结构。 9.2 分布式问题【校招必问】 非常系统的总结文档：分布式相关：第一页 CAP 理论指的是什么：C（Consistency）是数据一致性、A（Availability）是服务可用性、P（Partition tolerance）是分区容错性。 问题引入 现在有一个分布式系统 A，它有一个副本 A1，在正常情况下，客户端 Client 写数据到系统 A，然后数据从 A 节点同步到 A1 节点，再返回给 Client 成功状态。 但由于网络是不可靠的，节点 A 和 A1 的网络随时会因为中断而出现分区。所谓网络分区就是由于网络不通导致节点 A 和 A1 被隔离在不同的网络子集中，此时节点 A 的数据就不能及时同步到节点 A1 中了。 9.1.1 在CAP基础上讲讲BASE？举实例说说？ BASE 理论，它是 CAP 理论的延伸。BASE 是 Basically Available（基本可用）、Soft State（软状态）和 Eventually Consistent（最终一致性）三个单词的简写，作用是保证系统的可用性，然后通过最终一致性来代替强一致性，它是目前分布式系统设计中最具指导意义的经验总结。 其实是做了“可用性”方面的妥协，比如： 电商网站在双十一大促等访问压力较大的时候，关闭商品排行榜等次要功能的展示，从而保证商品交易主流程的可用性，这也是我们常说的服务降级； 为了错开双十一高峰期，电商网站会将预售商品的支付时间延后十到二十分钟，这就是流量削峰； 在你抢购商品的时候，往往会在队列中等待处理，这也是常用的延迟队列。 软状态和最终一致性指的是允许系统中的数据存在中间状态，这同样是为了系统可用性而牺牲一段时间窗内的数据一致性，从而保证最终的数据一致性的做法。 9.1.2 亿级商品分布式存储问题？ 1.如何设计一个支持海量商品存储的高扩展性架构？ 从这一点出发会考察你Hash（哈希）分片的具体实现原理。 以商品 ID 作为关键字进行分片，系统会通过一个 Hash 函数计算商品 ID 的 Hash 值，然后取模，就能得到对应的分片； 2.在做分库分表时，基于 Hash 取模和一致性 Hash 的数据分片是如何实现的？ 解决 Hash 分片的缺点，既保证数据均匀分布，又保证扩展性 ，最终采用一致性 Hash ：它是指将存储节点和数据都映射到一个首尾相连的哈希环上。 具体见前，一致性哈希相关算法描述 3.在电商大促时期，如何对热点商品数据做存储策略 ？ 问题 一致性 Hash 提升了稳定性，使节点的加入和退出不会造成大规模的数据迁移，但本质上 Hash 分片是一种静态的分片方式，必须要提前设定分片的最大规模，而且无法避免单一热点问题， 某一数据被海量并发请求后，不论如何进行 Hash，数据也只能存在一个节点上，这势必会带来热点请求问题。 解决 做 Range（范围）分片。 与 Hash 分片不同的是，Range 分片能结合业务逻辑规则，例如，我们用 “Category（商品类目）” 作为关键字进行动态分片时，不是以统一的商品一级类目为标准，而是可以按照一、二、三级类目进行灵活分片。例如，对于京东强势的 3C 品类，可以按照 3C 的三级品类设置分片；对于弱势品类，可以先按照一级品类进行分片，这样会让分片间的数据更加平衡。 4.强一致性和最终一致性的数据共识算法是如何实现的？ 9.1.3 海量并发，分布式事务一致性问题？ 什么是分布式事务问题？ 一次大的操作由多个小操作组成，这些小的操作分布在不同的服务器上，分布式事务需要保证这些小操作要么全部成功，要么全部失败。 举一个实例： 京东旅行系统，拆分成多个子系统，如商品系统、促销系统、订单系统。用户下单时，订单系统生成订单，商品系统扣减库存，促销系统扣减优惠券，只有当三个系统的事务都提交之后，才认为此次下单成功，否则失败。 解决方案 有两阶段提交协议（Two-Phase Commit，2PC）、3PC 、TCC 和基于消息队列的实现方式。 错误回答：方案很多，可以选择 2PC ，2PC 实现的流程是… 错误原因： 因为在实际工作中，很少采用前几种方案（互联网中落地方案代价大），基本都是基于 MQ 的可靠消息投递的方式来实现。 正确回答：先介绍目前主流实现分布式系统事务一致性的方案（也就是基于 MQ 的可靠消息投递的机制）然后回答出可实现方案和关键知识点。另外，为了和面试官进一步交流，你可以提出 2PC 或 TCC （这是一种交流方案）。 回答一、基于 MQ 的可靠消息投递方案 什么是MQ 核心的五个概念： Queue: 真正存储数据的地方 Exchange: 接收请求，转存数据 Bind: 收到请求后存储到哪里 消息生产者:发送数据的应用 消息消费者: 取出数据处理的应用 场景实例 订单系统（1）完成订单后，（2）购物车系统减购物车中的商品。 订单系统在消息队列上开启一个事务（没有创建订单）； 订单系统给消息服务器发送一个“半消息”； 这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的。 半消息发送成功后，订单系统就可以执行本地事务了，在订单库中创建一条订单记录，并提交订单库的数据库事务。 然后根据本地事务的执行结果决定提交或者回滚事务消息。 如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。 购物系统消费这条拿到的订单系统消息（确认了订单系统事务执行完毕），这样就可以继续下一步购物操作 9.1.4 分布式锁问题 06 分布式系统中，如何回答锁的实现原理？ 分布式锁是解决协调分布式系统之间，同步访问共享资源的一种方式。详细来讲：在分布式环境下，多个系统在同时操作共享资源（如写数据）时，发起操作的系统通常会通过一种方式去协调其他系统，然后获取访问权限，得到访问权限后才可以写入数据，其他系统必须等待权限释放。 基于redis的分布式锁 使用setnx命令加锁 12345678public static void wrongGetLock1(Jedis jedis, String lockKey, String requestId, int expireTime) &#123; // 第一步：加锁 Long result = jedis.setnx(lockKey, requestId); if (result == 1) &#123; // 第二步：设置过期时间 jedis.expire(lockKey, expireTime); &#125;&#125; setnx命令，意思就是 set if not exist，如果lockKey不存在，把key存入Redis，保存成功后如果result返回1，表示设置成功，如果非1，表示失败，别的线程已经设置过了。 expire()，设置过期时间，防止死锁，假设，如果一个锁set后，一直不删掉，那这个锁相当于一直存在，产生死锁。 解决setnx与expire不是一个原子操作 加锁总共分两步，第一步jedis.setnx，第二步jedis.expire设置过期时间，setnx与expire不是一个原子操作，如果程序执行完第一步后异常了，第二步jedis.expire(lockKey, expireTime)没有得到执行，相当于这个锁没有过期时间，有产生死锁的可能。 解决方案为：一步操作 123456789101112131415161718192021222324252627282930313233public class RedisLockDemo &#123; private static final String SET_IF_NOT_EXIST = &quot;NX&quot;; private static final String SET_WITH_EXPIRE_TIME = &quot;PX&quot;; /** * 获取分布式锁 * @param jedis Redis客户端 * @param lockKey 锁 * @param requestId 请求标识 * @param expireTime 超期时间 * @return 是否获取功 */ public static boolean getLock(Jedis jedis, String lockKey, String requestId, int expireTime) &#123; // 两步合二为一，一行代码加锁并设置 + 过期时间。 if (1 == jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime)) &#123; return true;//加锁成功 &#125; return false;//加锁失败 &#125; // 解锁：对应del删除key即可 public static void unLock(Jedis jedis, String lockKey, String requestId) &#123; // 第一步： 使用 requestId 判断加锁与解锁是不是同一个客户端 if (requestId.equals(jedis.get(lockKey))) &#123; // 第二步： 若在此时，这把锁突然不是这个客户端的，则会误解锁 jedis.del(lockKey); &#125; &#125;&#125; ​ 基于Zoopkeeper的分布式锁 sync，lock也只能保证你当前机器线程安全，这样分布式访问还是有问题。 建议参考：https://www.cnblogs.com/aobing/p/12650036.html 一个机器接收到了请求之后，先获取 zookeeper 上的一把分布式锁（zk会创建一个 znode），执行操作；然后另外一个机器也尝试去创建那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等待，等第一个机器执行完了方可拿到锁。 下面是创建临时顺序节点的情况： 客户端调用create()方法创建名为“/dlm-locks/lockname/lock-”的临时顺序节点。 客户端调用getChildren(“lockname”)方法来获取所有已经创建的子节点。 客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，就是看自己创建的序列号是否排第一，如果是第一，那么就认为这个客户端获得了锁，在它前面没有别的客户端拿到锁。 如果创建的节点不是所有节点中需要最小的，那么则监视比自己创建节点的序列号小的最大的节点，进入等待。直到下次监视的子节点变更的时候，再进行子节点的获取，判断是否获取锁。 基于关系型数据库 MySQL 实现分布式锁 参考：https://juejin.cn/post/6844904137172189198 利用 Mysql 的锁表，创建一张表，设置一个 UNIQUE KEY（如，利用主键ID的唯一性） 这个 KEY 就是要锁的 KEY，所以同一个 KEY 在mysql表里只能插入一次了。 这样对锁的竞争就交给了数据库，处理同一个 KEY 数据库保证了只有一个节点能插入成功，其他节点都会插入失败。 定义加锁、解锁代码如下： 123456789def lock ： exec sql: ins ert into lockedtable (xxx) values (xxx) if result == true : return true else : return falsedef def unlock ： # 解锁就是删除 exec sql: delete from lockedOrder where order_id=&#x27;order_id&#x27; 9.3 其它问题 1. 【字节-懂车帝】什么是跨域？ 参考：https://www.jianshu.com/p/f049ac7e2220 跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。 同源策略限制了一下行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 JS 对象无法获取 Ajax请求发送不出去 具体的一些实例： 非跨域 1http://www.xxxyyy.cn/index.html 调用 http://www.xxxyyy.cn/server.php 非跨域 跨域：主域不同 1http://www.xxxyyy.cn/index.html 调用 http://www.xxx.cn/server.php 跨域：子域名不同 1http://abc.xxxyyy.cn/index.html 调用 http://def.xxx.cn/server.php 跨域：端口不同 1http://www.xxx.cn:**8080**/index.html 调用 http://www.xxx.cn/server.php 跨域：协议不同 1**https**://www.xxx.cn/index.html 调用 **http**://www.xxx.cn/server.php","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"分布式","slug":"分布式","permalink":"https://hwh.zone/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hwh.zone/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}],"categories":[{"name":"C++","slug":"C","permalink":"https://hwh.zone/categories/C/"},{"name":"从零开始","slug":"C/从零开始","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"},{"name":"Linux系统编程","slug":"C/从零开始/Linux系统编程","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"},{"name":"C++进阶","slug":"C/从零开始/C-进阶","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E8%BF%9B%E9%98%B6/"},{"name":"C++面对对象","slug":"C/从零开始/C-面对对象","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"},{"name":"C++基础","slug":"C/从零开始/C-基础","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E5%9F%BA%E7%A1%80/"},{"name":"C++环境搭建","slug":"C/从零开始/C-环境搭建","permalink":"https://hwh.zone/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"建站","slug":"建站","permalink":"https://hwh.zone/categories/%E5%BB%BA%E7%AB%99/"},{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"JAVA","slug":"校招笔记/JAVA","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/"},{"name":"Git","slug":"Git","permalink":"https://hwh.zone/categories/Git/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://hwh.zone/tags/%E6%95%99%E7%A8%8B/"},{"name":"系统编程","slug":"系统编程","permalink":"https://hwh.zone/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"https://hwh.zone/tags/C/"},{"name":"C++进阶","slug":"C-进阶","permalink":"https://hwh.zone/tags/C-%E8%BF%9B%E9%98%B6/"},{"name":"STL","slug":"STL","permalink":"https://hwh.zone/tags/STL/"},{"name":"C++基础","slug":"C-基础","permalink":"https://hwh.zone/tags/C-%E5%9F%BA%E7%A1%80/"},{"name":"模板","slug":"模板","permalink":"https://hwh.zone/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"继承","slug":"继承","permalink":"https://hwh.zone/tags/%E7%BB%A7%E6%89%BF/"},{"name":"虚函数","slug":"虚函数","permalink":"https://hwh.zone/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"},{"name":"运算符重载","slug":"运算符重载","permalink":"https://hwh.zone/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"name":"快速入门","slug":"快速入门","permalink":"https://hwh.zone/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"面对对象","slug":"面对对象","permalink":"https://hwh.zone/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"},{"name":"结构体","slug":"结构体","permalink":"https://hwh.zone/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"枚举","slug":"枚举","permalink":"https://hwh.zone/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"类型转换","slug":"类型转换","permalink":"https://hwh.zone/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"name":"指针","slug":"指针","permalink":"https://hwh.zone/tags/%E6%8C%87%E9%92%88/"},{"name":"函数","slug":"函数","permalink":"https://hwh.zone/tags/%E5%87%BD%E6%95%B0/"},{"name":"远程开发","slug":"远程开发","permalink":"https://hwh.zone/tags/%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/"},{"name":"C++环境搭建","slug":"C-环境搭建","permalink":"https://hwh.zone/tags/C-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"CMake","slug":"CMake","permalink":"https://hwh.zone/tags/CMake/"},{"name":"Makefile","slug":"Makefile","permalink":"https://hwh.zone/tags/Makefile/"},{"name":"g++","slug":"g","permalink":"https://hwh.zone/tags/g/"},{"name":"网站建设","slug":"网站建设","permalink":"https://hwh.zone/tags/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"},{"name":"hexo","slug":"hexo","permalink":"https://hwh.zone/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"https://hwh.zone/tags/github-pages/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"场景题","slug":"场景题","permalink":"https://hwh.zone/tags/%E5%9C%BA%E6%99%AF%E9%A2%98/"},{"name":"智力题","slug":"智力题","permalink":"https://hwh.zone/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/"},{"name":"数据结构","slug":"数据结构","permalink":"https://hwh.zone/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数据库","slug":"数据库","permalink":"https://hwh.zone/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"https://hwh.zone/tags/Redis/"},{"name":"MySQL","slug":"MySQL","permalink":"https://hwh.zone/tags/MySQL/"},{"name":"操作系统","slug":"操作系统","permalink":"https://hwh.zone/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Git","slug":"Git","permalink":"https://hwh.zone/tags/Git/"},{"name":"Linux","slug":"Linux","permalink":"https://hwh.zone/tags/Linux/"},{"name":"JAVA","slug":"JAVA","permalink":"https://hwh.zone/tags/JAVA/"},{"name":"目录","slug":"目录","permalink":"https://hwh.zone/tags/%E7%9B%AE%E5%BD%95/"},{"name":"后端","slug":"后端","permalink":"https://hwh.zone/tags/%E5%90%8E%E7%AB%AF/"},{"name":"分布式","slug":"分布式","permalink":"https://hwh.zone/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hwh.zone/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}