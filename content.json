{"meta":{"title":"royhuang's blog","subtitle":"hello world","description":"tech & life","author":"Wanghui Huang","url":"https://hwh.zone","root":"/"},"pages":[{"title":"[404]","date":"2021-11-24T11:41:16.226Z","updated":"2021-11-24T11:41:16.226Z","comments":true,"path":"404.html","permalink":"https://hwh.zone/404.html","excerpt":"","text":""},{"title":"categories","date":"2021-11-25T05:45:57.000Z","updated":"2021-11-25T05:47:33.936Z","comments":true,"path":"categories/index.html","permalink":"https://hwh.zone/categories/index.html","excerpt":"","text":""},{"title":"Hi there 👋","date":"2021-11-26T10:03:01.132Z","updated":"2021-11-26T10:03:01.132Z","comments":true,"path":"about/index.html","permalink":"https://hwh.zone/about/index.html","excerpt":"","text":"I am Wanghui Huang (royHuang). 🔭 I am studying for a master’s degree in Chongqing University and will graduate in July, 2022. What’s more, I will officially join Tencent next year. 📫 If you want know me more : www.hwh.zone, this is my personal blog. 💬 Ask me about deep learning(object tracking) , C++, Java and my projects on hwh199601@qq.com. ⚡ Fun fact: this is a less funny boy."},{"title":"tags","date":"2021-11-25T05:45:14.000Z","updated":"2021-11-25T05:47:43.270Z","comments":true,"path":"tags/index.html","permalink":"https://hwh.zone/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"校招笔记（八）_计算机基础_场景&智力题","slug":"校招笔记（八）_计算机基础_场景和智力题","date":"2021-11-26T13:37:19.761Z","updated":"2021-11-26T16:28:16.812Z","comments":true,"path":"2021/11/26/校招笔记（八）_计算机基础_场景和智力题/","link":"","permalink":"https://hwh.zone/2021/11/26/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80_%E5%9C%BA%E6%99%AF%E5%92%8C%E6%99%BA%E5%8A%9B%E9%A2%98/","excerpt":"","text":"备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 🚩 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 八、场景题&amp;智力题 8.1 场景题 1. 设计一个微信运动排行榜？（Redis） 被CSIG伤过的的心还可以爱谁（第一次回答） “可以使用mysql, 将用户的好友列表关联的运动记录查询出来，然后通过order by 来进行排序，就可以实现了。” 一旦数据量大达到千万级别的时候，不可避免地会出现慢查询，效率就会降低。所以这不是面试官想听到的回答！ Redis–高效 使用Redis的有序集合 zset（有序且不重复） 。因为 zset 排序的下标从0 开始，自带一个score 值，该值可以当作排行的标准 。 添加用户和步数： zadd key score member 查询指定排名范围内用户： （从小到大）zrange key start stop withscores or （从大到小）zrevrange key start stop withscores 根据上面，所以用户按score从小到大排序完毕了，如果还要获取排名也可以使用下面命令： 查询指定用户排名 ： zrank key member or zrevrank key member 一个简单的排行榜就设计完成了。 如果面试官进一步问：一周排行榜怎么设计？ 一周的数据其实就是7天数据的累加，累加完后再排序，一个月的数据原理也是一样。可以使用 ： ZINTERSTORE ： 计算给定一个或多个有序集的交集并将结果放到一个新的有序集合destination中。 1ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX] 默认情况使用的函数是求和。 所以可以使用： 1zunionstore last_seven_days 7 20210315 20210316 20210317 20210318 20210319 20210320 20210321 2. 海量数据问题 参考：https://blog.csdn.net/v_JULY_v/article/details/6279498 在海量数据中，针对top K类问题，通常比较好的方案是： Top数问题：小根堆 有1亿个浮点数，如何找出其最大的10000个？ 直接进行排序，大约需要10^8*4字节 = 400M ，如果内存够可以直接进行排序；如果内存不够采用： 最小堆法 ：（1）先读入10000个数来创建大小为10000的最小堆（假设这10000个数是最大的10000个，然后每次和这10000中最小的比较）（2）遍历后续数字，和堆顶最小数字比较：如果小于堆顶数字，继续；如果大于堆顶数字，则替换堆顶并重新调整为最小堆（3）整个过程直至1亿个数全部遍历完为止 分治法。 （1）1亿分为100份，每份100万个数据，找到每份的最大的1万个 （2）在剩下的100*1万个数据找到最大的1万个 哈希法。 如果这1亿个书里面有很多重复的数，先通过Hash法，把这1亿个数字去重复。 然后再采用方法 1 或 2 。 最多重复（频率最高）：Hash映射+HashMap频率计算 【最多重复】海量日志数据，提取出某日访问百度次数最多的那个IP。 分治法（基于Hash）。 （1）按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中 （2）对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map （3）可以得到1024个小文件中的出现次数最多的IP ，再根据常规排序得到。 ⚠️ 使用Hash分散ip可以保证相同ip都在同一个文件夹，如果只是简单均分是不行的。 【最多重复】有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。 同上，分治法（基于Hash）。 首先计算下：1G / 1M = 1000个小文件，为保险分为2000个（1）Hash(词)%2000 映射到2000个文件中（2）分别计算2000个文件频率最高的那个单词，然后常规排序即可（2000个单词占：2k*16B=32KB&lt;&lt;1M） 【最多重复】有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。 同上，分治法（基于Hash）。 顺序读取10个文件，然后将query重新映射到若干个文件中，保证相同query都在同一个文件。其余同上。 不重复数：位图 【不重复】 在2.5亿个整数中找出不重复的整数。注，内存不足以容纳这2.5亿个整数。 采用2位图（BitMap）。00表示不存在，01表示出现一次，10表示多次，11无意义，需要2.5∗108b=2.5∗0.1Gb=0.25Gb=25MB2.5*10^8b = 2.5*0.1Gb=0.25Gb=25MB2.5∗108b=2.5∗0.1Gb=0.25Gb=25MB。但是我们需要把所有的整数都表示出来2∗232bit=1GB2*2^{32}bit=1GB2∗232bit=1GB（1）扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变（2）查看bitmap，把对应位是01 的整数输出即可。 注，int类型占32个字节，2322^{32}232 表示其能表示的整数个数。 【不重复·腾讯】给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？ 采用2位图（BitMap）。 需要40亿bit，大约500M，但实际是要表示所有整数，故还是1GB。其余同上。 共同数 【相同数】 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？ 分治法（基于Hash）。 （1）分别将a，b两个大文件各自映射为10000个小文件，这样相同url会映射到a,b相同哈希值小文件中。（2）在a,b每一对小文件找到相同的url。 3. 分布式相关 谈一谈，分布式集群中如何保证线程安全？ 对于单一服务来说，只要保证一台机器上的对于共享资源的访问是同步进行的就能保证线程安全了；但是对于分布式系统而已，保证一台服务器的同步，并不能保证访问共享资源是同步的； 所以可以考虑使用分布式锁的方式来保证分布式中的线程的安全线，这样不同的服务不同的线程通过竞争分布式锁来获取共享资源的操作权限； 例如redis的分布式锁、zookeeper锁，都可以作为分布式线程安全的手段。 在淘宝购物，这个场景下，你会怎样来设计消息队列？ 什么是消息队列？ 消息队列（MQ）可以简单理解为：把要传输的数据放在队列中，一种先进先出的结构。 怎么去设计淘宝消息队列？ 待补充。 4. 微信抢红包 例如一个人在群里发了100块钱的红包，群里有10个人一起来抢红包，每人抢到的金额随机分配。 所有人抢到的金额之和要等于红包金额，不能多也不能少。 每个人至少抢到1分钱。 要保证红包拆分的金额尽可能分布均衡，不要出现两极分化太严重的情况。 二倍均值法：假设剩余红包金额为m元，剩余人数为n，那么有如下公式： 每次抢到的金额 = [0.01，m /n × 2 - 0.01] 这个公式，保证了每次随机金额的平均值是相等的，不会因为抢红包的先后顺序而造成不公平。 举例说明： 假设有5个人，红包总额100元。100÷5×2 = 40，所以第1个人抢到的金额随机范围是[0.01，39.99]元，在正常情况下，平均可以抢到20元。假设第1个人随机抢到了20元，那么剩余金额是80元。80÷4×2 = 40，所以第2个人抢到的金额的随机范围同样是[0.01，39.99]元，在正常的情况下，还是平均可以抢到20元。假设第2个人随机抢到了20元，那么剩余金额是60元。60÷3×2 = 40，所以第3个人抢到的金额的随机范围同样是[0.01，39.99]元，平均可以抢到20元。以此类推，每一次抢到金额随机范围的均值是相等的。 8.2 智力题 1. 厉害了我的杯 有一种玻璃杯质量确定但未知，需要检测。 有一栋100层的大楼，该种玻璃杯从某一层楼扔下，刚好会碎。 现给你两个杯子，问怎样检测出这个杯子的质量，即找到在哪一层楼刚好会碎？ 参考：https://cloud.tencent.com/developer/article/1497944 2. 赛马问题 64匹马，8个跑道，问最少比赛多少场，可以选出跑得最快的4匹马。 Assumptions：每场比赛每个跑道只允许一匹马，且不存在并列情形。 参考：https://zhuanlan.zhihu.com/p/103572219","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"场景题","slug":"场景题","permalink":"https://hwh.zone/tags/%E5%9C%BA%E6%99%AF%E9%A2%98/"},{"name":"智力题","slug":"智力题","permalink":"https://hwh.zone/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/"}]},{"title":"校招笔记（七）_计算机基础_数据结构","slug":"校招笔记（七）_计算机基础_数据结构","date":"2021-11-26T13:20:04.945Z","updated":"2021-11-26T16:29:54.822Z","comments":true,"path":"2021/11/26/校招笔记（七）_计算机基础_数据结构/","link":"","permalink":"https://hwh.zone/2021/11/26/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 🚩 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 七、数据结构和算法 1. 如何对快排进行优化？ 三数取中法和随机交换法 快排将选取的基准点经过调整放到合适的位置，之后将这个基准点左右两边的区间分别递归的进行快排。 如果基准点的数据比较小，将会导致调整后基准点处于靠近两侧的位置，那么两边的区间长度将会严重失去平衡. 三数取中法：指的是选取基准点之前我们可以拿出数列中间位置元素的值，将它和首尾的元素进行比较，之后将这三个数中的中间数交换到数列首位的位置，之后将这个数作为基准点，尽量减小之后的分区后左右两边的区间长度之差。 三路分割法 三路法同样是针对含有大量【重复数列】的优化。 3路法的思想是将数列分成3个区间，分别是小于、等于和大于基准点的区间。那么分区之后，对于等于基准点的区间内的元素，我们就不需要对其做任何处理了，只需要递归的处理小于和大于基准点的元素即可。 结合插入排序 当待排序序列的长度分割到一定大小后，使用插入排序。 对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排。 2.快排和堆排的区别？什么时候使用快排和堆排？ 快排和堆排区别？ 综合性能：实际应用中，虽然堆排序的时间复杂度要比快速排序稳定（快排最差退化成O(N^2)） ，但是统计意义上这种情况较少，所以综合性能还是快排更优； 交换次数： 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序； 访问友好： 堆排序数据访问的方式没有快速排序友好。 对于快速排序来说，数据是顺序访问的；而堆排序来说，数据是跳着访问的。比如，堆排序中，最重要的一个操作就是数据的堆化。对堆顶节点进行堆化，会一次访问数组下标1，2，4，8的元素，而不是像快排那样，局部顺序访问，所以对CPU缓存是不友好的。 快排和堆排使用场景？ 快排： 绝大多数场合。 堆排： topK问题、优先队列（需要在一组不停更新的数据中不停地找最大/小元素） 在N个元素中找到top K，时间复杂度是O(N log K)，空间复杂的是O(K)，而快速排序的空间复杂度是O(N)。 3. 【面试重点】有哪些排序算法，各算法的时间复杂度 ? 哪些是稳定的？为什么是稳定的？ 3.1 如果数据大致有序的，用什么排序比较好？ 如果是大致有序，用 插入排序 比较好： 直接插入排序是将第i个元素插入到已经排序好的前i-1个元素中 ，当元素基本有序时。和前i-1个元素末尾比较一次就可以直接插入。 在相比使用其它排序： 归并排序： 归并排序和数组是否有序无关，都是O(nlgn)。 归并排序是把一个有n个记录的无序文件看成由n个长度为1的有序子文件组成的文件，然后进行两两归并，得到[n/2]个长度为2或1的有序文件，再两两归并 。 快速排序： 数组基本有序时，此时如果使用基点是最后一个元素，划分的两个子数组极为不平衡，每次划分比较次数都很多。所以不推荐。 4. 二叉查找树，红黑树和平衡二叉树的区别？（有了二叉查找树、平衡树（AVL）为啥还需要红黑树？） 总结来说：平衡树是为了解决二叉查找树退化为链表的情况；而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。 二叉查找树退化成单链表 正常使用二叉查找树是类似于二分查找 O（logn），但是极端情况： 构建的二叉树所有节点都只有右子树或左子树，此时时间复杂度退化成O(N) 平衡二叉树频繁左右旋 平衡二叉树就是为了解决二叉查找树退化成一颗链表而诞生了，平衡树具有如下特点： 具有二叉查找树的全部特性； 每个节点的左子树和右子树的高度差至多等于1。 避免了二叉查找树极端情况产生，但是： 每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。 平衡树性能大打折扣。 红黑树规不需要频繁着调整 红黑树具有如下特点： 最坏情况下，也能在 O(logn) 的时间复杂度查找到某个节点。 与平衡树不同的是，红黑树在插入、删除等操作，（🚩*1）不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整，这也是我们为什么大多数情况下使用红黑树的原因； 但是，单单在查找方面的效率的话，平衡树比红黑树快。 具有二叉查找树的特点； 根节点是黑色的； 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据； 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的； 每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。 4.1 为什么红黑树不需要频繁调整？ 详细理解红黑树一篇不错的文章：百图详解红黑树，想不理解都难 平衡二叉树这种高度差为 1 的要求太严格了，尤其是对于频繁删除、插入的场景非常浪费时间。 但是由于红黑树： 具有二叉树所有特点。 每个节点只能是红色或者是黑色。 根节点只能是黑色，且黑色根节点不存储数据。 任何相邻的节点都不能同时为红色。 红色的节点，它的子节点只能是黑色。 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 不追求插入、删除等操作绝对平衡，只需满足上述条件即可。它的旋转次数少，插入最多两次旋转，删除最多三次旋转。 所以在搜索、插入、删除操作较多的情况下，红黑树的效率是优于平衡二叉树的。 5.快速排序的过程 ？ 手撕一个二分查找 和快排？ 二分查找 12345678910111213141516171819202122232425// binary search public int binarySearch(int[] arr, int value) &#123; int left = 0,right = arr.length-1; int mid ; while (left&lt;=right) //*&lt;= 而不是&lt; &#123; mid = (left+right)/2; if(value == arr[mid]) &#123; return mid; // 如果数组存在待查找元素，按照逻辑一定会是mid &#125; else if(value &lt; arr[mid]) &#123; right = mid-1; &#125; else // value &gt; arr[mid] &#123; left = mid+1; &#125; &#125; return -1; &#125; 快速排序 123456789101112131415161718192021222324252627public int[] quick_sort(int[] arr,int left,int right) &#123; if(right&lt;=left)&#123;return null;&#125; // 选择基准：数组最右数字 // *如果选择最左，思考交换过程 // *partition 左侧始终是比pivot小的数 int pivot = arr[right]; int partition = left; // 遍历分区元素 // 小于基准的放基准左边，大于的放基准右边 // * 终止条件：i &lt; right 而非 right-1！ for(int i=left; i&lt; right;i++) &#123; if(arr[i]&lt;pivot) // 实际只交换小于到左边即可 &#123; swap(arr,i,partition); partition++; &#125; &#125; // *基准插入位置partition位置 swap(arr,partition,right); //递归的排序 quick_sort(arr,left,partition-1); quick_sort(arr,partition+1,right); return arr; &#125; 6. 布隆过滤器原理？为什么使用多个哈希函数？其它相关应用？ 参考：详解布隆过滤器的原理，使用场景和注意事项 “布隆说：不存在的那么一定不存在” “布隆说：存在的那么只是可能存在” 7.1 从HashMap说起—当你判断某个元素时候你在想什么？ 通常我们怎么判断一个数组，是否存在某个元素呢？ 聪明的你一定想到HashMap：（1）HashMap将数组所有元素使用哈希函数，映射到HashMap上（HashMap本身也是一个数组）（2）然后就可以在O(1)级别判断某个元素是否存在。 但是这种做法通常会导致以下问题： 一旦数组很大，比如上亿，HashMap将会占据非常大的内存； 数组很大，不大可能一次性能在内存构建HashMap； 而且HashMap，通常存在负载因子，是不能充分利用内存的。 为此，我们可以从以下方向优化： 只存储key。但是，因为我们只要判断某个元素（key）是否存在， 不需要取出对应key的value—也就是不需要存储value。 key映射为bit数组索引。key映射为bit数组索引，即位图对应索引， 索引对应数值用 0/1 就可以标识为是否存在该key。 为此，我们可以【第一阶段优化】如下： 看样子似乎是满足我们要求了，但是依旧存在以下问题： 只使用一个hash函数，空间利用率低。 一个hash函数只能将key散列到一个位置 ，虽然hash尽量优良映射均匀，但是空间利用率依然不算高。 因此，我们可以多个函数，将key同时映射到多个位置，即使发生哈希冲突，某个位置被覆盖，其它依旧存在，变相的降低了哈希冲突。 7.2 数据结构及原理 布隆过滤器，最终结构如下：一个bit数组，采用多个hash函数进行映射。 7.3 布隆函数优缺点 优点 存储/插入/查询时间复杂度，都是常数级别O(1) 保密性好，因为不需要存储数据本身 存储数据大，可以存储非常大的数据本身 缺点 随着元素数量增加，误算率会增加 不能删除元素，因为删除某个元素，要把其对应所有hash函数散列的位置如A,B，置为0 。其它元素的可能散列到位置A，再去判断这个元素是否存在就会出现误判。 7.4 应用场景 解决缓存穿透，防止不存在的元素去查询数据库 防止重复被攻击，用户第一次请求，将请求参数放入布隆过滤器中，当第二次请求时，先判断请求参数是否被布隆过滤器命中。可以提高缓存命中率 判断用户是否阅读过某视频或文章， 比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"数据结构","permalink":"https://hwh.zone/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"校招笔记（六）_计算机基础_Redis","slug":"校招笔记（六）_计算机基础_Redis","date":"2021-11-26T13:16:21.848Z","updated":"2021-11-26T16:29:36.828Z","comments":true,"path":"2021/11/26/校招笔记（六）_计算机基础_Redis/","link":"","permalink":"https://hwh.zone/2021/11/26/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80_Redis/","excerpt":"","text":"备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 🚩 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 六、Redis 6.1 Redis基本 1.什么是 Redis？ Redis 是一个开源（BSD 许可）、基于内存（读写快）、支持多种数据结构的存储系统，可以作为数据库、缓存和消息中间件。 支持的数据结构有5种：字符串（String）、哈希（hash）、列表（list）、集合（set）、有序集合（sorted set）。 1.1 有MySQL不就够用了吗？为什么要用Redis这种新的数据库？ 主要是因为 Redis 具备高性能和高并发两种特性。 高性能：除了第一次读取硬盘比较慢，后面加载到缓存，读取速度都相关快，性能高； 高并发：直接操作缓存能够承受的并发请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分热点数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。 1.2 C++ / JAVA 中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？ 缓存分为本地缓存和分布式缓存 。 本地缓存不具一致性。以Java为例 ，使用自带的map或者guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性； Redis分布式缓存具有一致性。 使用redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性； Redis可以使用更大内存作为缓存。 Redis可以使用几十G内存作为缓存，Map不行，比如JVM最多使用几个G ； Redis可以持久化。 Redis可以实现持久化，而Map是内存对象，程序重启就没了； Redis可以处理百万级别并发； Redis有丰富的API &amp; 缓存过期等机制。 2. 【重点】redis的数据类型，以及每种数据类型的使用场景？ 数据类型 使用场景 String 存储key-value键值对，注意redis中String可修改。统计在线人数；也可以存储视频、图片等 hash 购物车：hset [key] [field] [value] 命令， 存放键值对，一般可以用来存某个对象的基本属性信息，例如，用户信息，商品信息等 set 全局去重，JVM自带的set不适合分布式集群情况 zset 排行榜，比如微信运动排行榜 list 分页功能，lrange做基于redis的分页功能，性能很好；模仿一个消息队列 3.说一下 Redis有什么优点和缺点 ？ 优点 缺点 速度快：因为在内存中 存储有限：因为Redis是内存数据库，大小和机器本身内存有关 支持多种数据结构： String，List，Set，Hash，Sorted Set等 完成重同步耗费CPU资源和带宽 持久化存储：RDB和AOF 当Redis重启后通过把硬盘文件重新加载到内存，速度比较慢，这个时候redis做不了其它事。 高可用：内置 Redis Sentinel （哨兵），实现主从故障自动转移。 内置 Redis Cluster ，提供集群方案。 丰富特性：Key过期、计数、分布式锁 4. Redis的数据结构？key是怎么存储的？ 参考：【大课堂】Redis底层数据存储原理 概述 Redis底层采用数组， key就是对应数组的索引 ，采用Hash(key)映射到数组上。解决冲突采用链地址法。 具体可看参考下文。 底层存储原理 redis 中以redisDb作为整个缓存存储的核心，保存着我们客户端需要的缓存数据。 其结构如下： 123456789typedef struct redisDb &#123; dict *dict; // 最重要--字典类型，保存数据库的键值对 dict *expires; // 重要--字典类型，保存过期的时间 dict *blocking_keys; // 和ready_key 实现BLPOP等阻塞命令 dict *ready_keys; // 同上 dict *watched_keys; // 实现watch命令，记录正在被watch的key int id; // 数据库id，默认16个，支持单个 long long avg_ttl; /* Average TTL, just for stats */ &#125; redisDb; 现在我们来查看，dict 的结构。 dict的结构 12345678910/* 字典 : 每个字典使用两个哈希表，用于实现渐进式 rehash */typedef struct dict &#123; // type存储了hash函数，key和value的复制函数等，比较以及销毁函数 dictType *type; // privdata保存一些私有数据，决定了*type保存的函数，实现了【多态】 void *privdata; dictht ht[2]; // 哈希表（2 个）, 正常使用ht[0],rehash就会扩容使用ht[1] int rehashidx; // 记录 rehash 进度的标志，值为 -1 表示 rehash 未进 int iterators; // 当前正在运作的安全迭代器数量&#125; dict; 上述dictht就是个hash表，包含： 12345678910typedef struct dictht &#123; // 哈希表节点指针数组（俗称桶，bucket） dictEntry **table; // 指针数组的大小 unsigned long size; // 指针数组的长度掩码，用于计算索引值，其实永远都是size-1 unsigned long sizemask; // 哈希表现有的节点数量 unsigned long used;&#125; dictht; dictEntry 指针数组（table）。key 的哈希值最终映射到这个数组的某个位置上（对应一个 bucket）。如果多个 key 映射到同一个位置，就发生了冲突，那么就拉出一个 dictEntry 链表。 12345678910// 哈希表节点dictEntrytypedef struct dictEntry &#123; void *key; // redis的键 union &#123; void *val; // 存储了对应string/set/list/hash/zset的数据 uint64_t u64; int64_t s64; &#125; v; struct dictEntry *next; //链表后续节点&#125;dictEntry; size：标识 dictEntry 指针数组的长度。它总是 2 的指数次幂。 上面dictEntry 的value 最终指向了redisObject对象，我们来观察下其结构。 Redis Object 1234567typedef struct redisObject &#123; unsigned type:4; // 类型 ，比如string，set等，才能确定是哪种数据结构使用什么API操作 unsigned encoding:4; // encoding 表示 ptr 指向的具体数据结构,这个对象使用什么数据结构实现 unsigned lru:REDIS_LRU_BITS; // 对象最后一次被访问的时 int refcount; // 引用计数 void *ptr; // 指向底层数据结构的指针 robj; 4.1 String、list、hash、set、zset的底层结构是什么？ 参考：图解redis五种数据结构底层实现(动图哦) 版本：redis 3.0.6中版本各种数据结构的实现 String embstr和raw都是由SDS动态字符串构成的 ，底层结构应该都是char数组吧 ； int ，就是指int类型。 list hash set intset是集合键的底层实现方式之一，是int类型数组。 zest 4.2 讲讲redis的hash表扩容方式？ 参考：[redis学习笔记]redis渐进式rehash机制 扩容条件 服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 （保存的key超过哈希表大小）； 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ； 渐进式rehash 新建一个哈希表大小，为2^N 次方，并分配内存，此时字典同时持有：ht[0] 和 ht[1] 两个哈希表 同hashmap：哈希表掩码sizemask为size-1，当size满足2的n次方时，计算每个key的索引值时只需要用key的hash值与掩码sizemask进行位与操作，替代求余操作，计算更快。 哈希表赋值给字典的ht[1]，然后将rehashidx赋值为0，表示rehash工作开始 rehashidx也标识了，当前rehash进行到了哪个槽 在 rehash 进行期间，：每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] 。 当 rehash 工作完成之后， 程序将 rehashidx 属性的值**+1** 随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] 。此时rehashidx=-1，表示rehash完成。 采取分而治之的方式， 将 rehash 键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。 渐进式rehas优缺点 优点：避免redis阻塞 缺点：rehash需要分配一个新的hash表，会使得内存爆增，使得大量key被驱逐 4.3 rehash过程中增删查改怎么操作呢？ 增加： 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作 删除（delete）、查找（find）、更新（update）等： 同时在ht[0] &amp; ht[1]两个表进行。 比如：要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找。 5. 说说Redis有序集合zset的底层结构？ zset底层的存储结构包括ziplist或 skiplist &amp; dic ，当满足以下两个条件的时候使用ziplist： 有序集合保存的元素数量小于128个 有序集合保存的所有元素的长度小于64字节 其余情况用skiplist。 什么是ziplist？ ziplist是一个经过特殊编码的双向链表，以O(1)的时间复杂度在表的两端提供push和pop操作。 ziplist将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。 使用原因：一个普通的双向链表，链表中每一项都占用独立的一块内存，各项之间用地址指针（或引用）连接起来；这种方式会带来大量的内存碎片，而且地址指针也会占用额外的内存。 具体结构 entry：表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构。 什么是skiplist ? 跳表是在单链表上实现多级索引，可以实现 二分查找 的有序链表。 跳表插入、删除、查找元素的时间复杂度跟红黑树都是一样量级的，时间复杂度都是O(logn)。 主要形式 在单链表上进行多级索引。 构建过程 上面链表是如何构建的呢，请见下图。 ⚠️ skiplist为了避免上下两层出现严格1:2数量对应关系后，新插入节点会打乱这种关系，而需要把新插入节点后所以节点都进行调整。 它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。 查找过程 zset : &lt;key&gt; &lt;score&gt; &lt;member&gt; 在上图中，我们没有区分member和score，但是实际上链表是按score进行排序，查找也是在比较score。 以查找 和 插入23为例。 从最高层（第4）层开始查找，因为7&lt;23 ,本应该继续往后查找，但是后继节点为null，所以往下一层进行查找 此时第3层，满足7&lt;23&lt;37 ，继续往下一层继续查找 此时第2层，7&lt;23 &amp; 19&lt;23 ，往下第二层的下一个节点（19）查找；此时满足19&lt;23&lt;37 ，继续往下一层 此时第1层，一直往后遍历到22，发现22&lt;23&lt;26 ： 如果此时是查询23：返回null，不存在 此时是插入23：生成新节点 &amp; 随机生成层数，（1）将新节点各层指针指向对应层的下一个节点（不存在则指向null）（2）将新节点节点各层前一个节点对应层数的指针指向新节点 5.1 Redis为什么不用红黑树 参考 ： 知乎回答 虽然跳表操作时间复杂度和红黑树相同 ，但是： 实现简单：跳表代码实现更易读 区间查找：跳表区间查找效率更高 6. Redis持久化方式有哪些？以及有什么区别？ Redis 提供两种持久化机制 RDB 和 AOF 机制。 各自优点 RDB AOF 【方便】只有一个文件 dump.rdb ，方便持久化 【数据安全】 AOF 持久化有 always，每进行一次命令操作就记录到 AOF 文件中一次。 【容灾性好】一个文件可以保存到安全的磁盘 【性能】最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化 【启动效率高】相对于数据集大时，比 AOF 的启动效率更高 各自缺点 RDB AOF 【安全性低】 RDB 是间隔一段时间进行持久化 【启动效率低】数据集大的时候，比 RDB 启动效率低。 【恢复慢】AOF 文件比 RDB 文件大，且恢复速度慢。 6.1 AOF 重写了解吗？ AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。 AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任伺读入、分析或者写入操作。 具体过程如下： 在执行 BGREWRITEAOF 命令，开始重写； Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令； 当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾 ； 最后，服务器用新的AOF文件替换旧的 AOF文件，以此来完成AOF文件重写操作。 7. Redis持久化有两种，那应该怎么选择呢？ 参考：https://zhuanlan.zhihu.com/p/39412293 如果Redis中的数据完全丢弃也没有关系（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化； 单机环境： 如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF； 主从架构： master：完全关闭持久化（包括RDB和AOF），这样可以让master的性能达到最好； slave：关闭RDB，开启AOF（如果对数据安全要求不高，开启RDB关闭AOF也可以），并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；然后关闭AOF的自动重写，然后添加定时任务，在每天Redis闲时（如凌晨12点）调bgrewriteaof。 8. （不太理解）pipeline有什么好处，为什么要用 pipeline？ 使用 pipeline（管道）的好处在于可以将多次 I/O 往返的时间缩短为一次，但是要求管道中执行的指令间没有因果关系； 用 pipeline 的原因在于可以实现请求/响应服务器的功能，当客户端尚未读取旧响应时，它也可以处理新的请求。如果客户端存在多个命令发送到服务器时，那么客户端无需等待服务端的每次响应才能执行下个命令，只需最后一步从服务端读取回复即可。 9.怎么使用 Redis实现消息队列？ 如何实现延时队列？ 消息队列：一般使用 list 结构作为队列， rpush 生产消息， lpop 消费消息。当 lpop 没有消息的时候，要适当sleep 一会再重试； 延时队列： ：使用sortedset ，拿时间戳作为 score ，消息内容作为 key 调用 zadd 来生产消息，消费者用zrangebyscore 指令获取符合条件的数据轮询进行处理。 什么是延时队列？ 当用户发送一个消息请求给服务器后台的时候，服务器会检测这条消息是否需要进行延时处理： 如果需要就放入到延时队列中，由延时任务检测器进行检测和处理； 如果不需要进行延时处理的任务，服务器会立马对消息进行处理，并把处理后的结果返会给用户。 【举个例子】 点外卖时，下单后不会立即安排配送，而是等待一段时间让商户接单才正式安排配送，否则超时取消 6.2 Redis单线程模型 1.为什么 Redis 使用单线程模型？单线程模型效率也能那么高？ 采用单线程，避免了不要的上下文切换和竞争条件； 其次 CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。 【效率高的原因】 . 1. C语言实现，效率高 纯内存操作 基于非阻塞的IO复用模型机制（可能会跟自己挖坑） 单线程的话就能避免多线程的频繁上下文切换问题（为什么单线程效率高） 丰富的数据结构（全程采用hash结构，读取速度非常快，对数据存储进行了一些优化，比如zset压缩表，跳表等） 2.（新，易忘）说说 Redis 的单线程模型 ？ 这问题是因为前面回答问题的时候提到了 Redis 是基于非阻塞的IO复用模型。如果这个问题回答不上来，就相当于前面的回答是给自己挖坑了。 redis 内部使⽤⽂件事件处理器 file event handler ，这个⽂件事件处理器是单线程的，所以redis 才叫做单线程的模型。它采⽤ IO 多路复⽤机制一个线程同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进⾏处理。 ⽂件事件处理器的结构包含 4 个部分： 多个 socket IO 多路复⽤程序 ⽂件事件分派器 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器） （1） IO 多路复⽤程序会监听多个 socket，（2）会将 socket 产⽣的事件放⼊队列中排队，（3）事件分派器每次从队列中取出⼀个事件，（4）把该事件交给对应的事件处理器进⾏处理。 3. 你说Redis是单线程的，那如何处理高并发？比如1000个并发请求同时发生？ Redis采用了IO多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求。 详见上一个问题。 Redis可以采用主从架构，master负责写，slave负责读。 4.说说你对Redis事务的理解 ？ Redis 中的事务是一组命令的集合，是 Redis 的最小执行单位。 Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的 Redis会将一个事务中的所有命令序列化，然后按顺序执行。 需要注意的地方 Redis 事务不支持回滚：不像 MySQL 的事务一样，要么都执行要么都不执行； 因为回滚需要增加很多工作，而不支持回滚则可以保持简单、快速的特性。 Redis 服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断，直到事务命令全部执行完毕才会执行其他客户端的命令。 5.为什么Redis的操作是原子性的，怎么保证原子性的？ 原子性。 因为Redis是单线程的， Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。 事务性。 Redis中的事务其实是要保证批量操作的原子性。 6.3 Redis缓存 1.为什么要用缓存 ？怎么提高缓存命中率？ 为什么用缓存？ 把热点数据存入内存中，提高读写性能。 提高命中率？ 增加缓存空间 提升缓存更新频率 提前加载数据到缓存中 2.缓存雪崩、缓存穿透、缓存击透、缓存预热、缓存更新、缓存降级等？ 参考：https://juejin.cn/post/6844904173725548557 缓存雪崩 简而言之：Redis 挂掉了，请求全部走数据库 。 例如： 对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库； key过期解决： 在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。 更通用情况的做法： 事发前：实现 Redis 的高可用 (主从架构 + Redis Cluster)，尽量避免 Redis 挂掉这种情况发生； 事发中：万一 Redis 真的挂了，我们可以设置本地缓存 (ehcache)+ 限流 (hystrix)，尽量避免我们的数据库被干掉； 事发后：redis 持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。 缓存穿透 查询一个一定不存在的数据 ，导致每次请求都要到数据库去查询，失去了缓存的意义 。 解决1： 使用布隆过滤器 (BloomFilter) 提前拦截，不合法就不让这个请求到数据库层； 解决2：当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去，下次再请求的时候，就可以从缓存里边获取了。 缓存击穿 在平常高并发的系统中，大量的请求同时查询一个key时，此时这个高热key正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为缓存击穿。 解决1：使用互斥锁(mutex key)。 是只让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据就行。 如果是单机，可以用synchronized或者lock来处理，如果是【淘特】分布式环境可以用分布式锁就可以了。 解决2： key永不过期。 把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建。 缓存预热 系统上线后，将相关的缓存数据直接加载到缓存系统。 这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。 缓存更新 LRU(访问时间最旧淘汰)/LFU(把频次低的淘汰掉) 超时剔除：设置key过期时间 主动更新：开发设置生命周期 缓存降级 降级的情况，就是缓存失效或者缓存服务挂掉的情况下，我们也不去访问数据库。我们直接访问内存部分数据缓存或者直接返回默认数据。 对于应用的首页，一般是访问量非常大的地方，首页里面往往包含了部分推荐商品的展示信息。这些推荐商品都会放到缓存中进行存储，同时我们为了避免缓存的异常情况，对热点商品数据也存储到了内存中。同时内存中还保留了一些默认的商品信息。 如下图所示： 3. Redis 设置key过期后如何处理？Redis缓存刷新策略（内存淘汰机制）有哪些？ Redis 设置过期时间 Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置⼀个过期时间。 如我们⼀般项⽬中的 token 或者⼀些登录信息，尤其是短信验证码都是有时间限制的，过期后基本不会使用 过期后采用什么策略进行删除？ 定期删除：redis默认是每隔 100ms 就随机抽取⼀些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这⾥是随机抽取的。为什么要随机呢？你想⼀想假如 redis 存了⼏⼗万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！ 惰性删除：定期删除可能会导致很多过期 key 到了时间并没有被删除掉，所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存⾥，除⾮你的系统去查⼀下那个 key，才会被redis给删除掉。 内存淘汰策略 ：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没⾛惰性删除，此时会怎么样？如果大量过期key堆积在内存⾥，导致redis内存块耗尽了。所以有内存淘汰策略。 volatile-lru：从已设置过期时间的数据中挑选最近最少使⽤的数据淘汰 volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据中任意选择数据淘汰 allkeys-lru：当内存不⾜以容纳新写⼊数据时，在键空间中，移除最近最少使⽤的key（这个是最常⽤的） allkeys-random：从数据集中任意选择数据淘汰 no-eviction：禁⽌驱逐数据，也就是说当内存不⾜以容纳新写⼊数据时，新写⼊操作会报错。这个应该没⼈使⽤吧！ 4. Redis报内存不足怎么处理？ 增加 Redis 可用内存： 修改件 redis.conf 的 maxmemory 参数； 使用分布式集群，提高存储量； 设置缓存淘汰策略：提高内存的使用效率； 5. 【重点】缓存和数据库谁先更新呢？ （保持缓存和数据库一致性） 参考：https://learnku.com/articles/22363 对于读（查询）操作 一般我们对读操作的时候有这么一个固定的套路： 如果我们的数据在缓存里边有，那么就直接取缓存的； 如果缓存里没有我们想要的数据，我们会先去查询数据库，然后将数据库查出来的数据写到缓存中； 最后将数据返回给请求。 不用更新（写）数据库，只用更新（写）缓存。 对于写操作导致双写问题 如何保证缓存(redis)与数据库(MySQL)的一致性 写操作会更新数据库，那么缓存也要进行更新，此时会发生数据库和缓存不一致的问题。 键的过期时间：能保证缓存和数据库的数据最终是一致的。 因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据重新写入到缓存中。 除了设置过期时间，我们还需要做更多的措施来尽量避免数据库与缓存处于不一致的情况发生。 直接看结论： 不考虑更新缓存而是直接删除缓存，因为更新逻辑较为复杂涉及到其它数据，更新cache消耗会比较大。 先删除缓存，再更新数据库 在高并发下可能会导致数据长时间不一致 采用异步更新缓存的策略，不会导致数据不一致，但在数据库更新完成之前，都需要到数据库层面去读取数据，读的效率不太好——保证了数据的一致性，适用于对一致性要求高的业务 先更新数据库，再删除缓存 (Cache Aside Pattern 设计模式) 在高并发下不会导致数据长时间不一致 在更新数据库期间，cache中的旧数据会被读取，可能会有一段时间的数据不一致，但读的效率很好。——保证了数据读取的效率，如果业务对一致性要求不是很高，这种方案最合适 先删除缓存，再更新数据库 ⚠️ 只有读才会更新缓存！！ 正常情况 A线程进行写操作，先淘汰缓存，再更新数据库 B线程进行读操作，发现缓存中没有想要的数据，从数据库中读取更新后的新数据 ，并更新缓存 高并发异常 A线程进行写操作，先淘汰缓存，但由于网络原因等未及时更新数据库 B线程读取缓存失败，去读取数据库的是旧值 ，并将旧数据放入缓存 A线程再更新数据库成功（同步情况下写操作不更新redis而读操作更新redis），此时缓存（旧）和数据库（新）不一致 而且没有设置键过期，会保持很长时间的数据不一致。 解决方案 异步更新缓存 ：B线程读操作不更新缓存，而是由A线程写操作更新数据库成功后，通过binlog异步更新缓存 延时双删： A线程休眠M秒（确保事务都已提交），再更新数据库成功后，再次删除缓存。其它线程进行读操作时，缓存中无数据，从数据库中读取的是更新后的新数据，又再次一致了。 先更新数据库，再删除缓存 正常情况 A线程进行写操作，先更新数据库，再删除缓存 B线程进行读操作，发现缓存中没有想要的数据，从数据库中读取更新后的新数据 ，并更新缓存 高并发异常 A线程进行写操作，先更新数据库，但未来得及删除缓存 B线程进行读操作，读取缓存的旧数据（背错一次），此时数据不一致 A线程再删缓存 但其它线程进行读数据的时候更新缓存，更新缓存又一致了，不一致的时间很短。 但是还可能会考虑：3. A线程删除缓存失败 ，此后读取的一直都是旧数据了。 解决方案 消息队列进行删除补偿。如果Redis删除发现报错，将Redis的key作为消息发送到消息队列中，系统收到消息队列再次对Redis进行删除操作。 6.4 集群相关 1. Redis的同步机制了解是什么？ Redis主从复制可以根据是否是全量分为：全量同步和增量同步。 主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。 全量同步 Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份： ​ 1）从服务器连接主服务器，发送SYNC命令； 2）主服务器接收到SYNC命名后，开始执行BGSAVE命令（1）生成RDB文件 （2）并使用缓冲区记录此后执行的所有写命令； 3）主服务器BGSAVE执行完后，向所有从服务器发送RDB快照文件，并在发送期间继续记录被执行的写命令； 4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令； 增量同步 Slave初始化后开始正常工作时：主服务器发生的写操作同步到从服务器的过程。 主服务器每执行一个写命令就会向从服务器发送相同的写命令； 从服务器接收并执行收到的写命令。 2.【新补充】 Redis集群架构模式有哪几种？集群的原理是什么？ 待补充：Redis 架构模式详解（单机、主从、哨兵、集群模式） 1. 单机模式 QPS（每秒查询速度）大约在几万左右。 安装一个 Redis，启动起来，业务调用即可。 优点： 部署简单；成本低；高性能 缺点： 单节点宕机风险 ; 单机高性能受限于 CPU 的处理能力 2. 主从复制 Redis 的复制（Replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品。 被复制的服务器为主服务器（Master），而通过复制创建出来的复制品则为从服务器（Slave）。 主要优缺点： 优点： Master/Slave 角色方便水平扩展，降低 Master 读压力，转交给 Slave 节点； 缺点： 可靠性保证不是很好，主节点故障便无法提供写入服务；没有解决主节点写的压力 ；主节点宕机，需要人为干预。 3. 哨兵模式 Redis 2.8版本后引入了哨兵的概念。 主从模式中，当主节点宕机之后，从节点是可以作为主节点顶上来继续提供服务，但是需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点数据，整个过程需要人工干预。 为此，引入了哨兵（Sentinel）这个概念，在主从复制的基础上，哨兵实现了自动化故障恢复。哨兵模式由两部分组成，哨兵节点和数据节点： 哨兵节点：哨兵节点是特殊的 Redis 节点，不存储数据； 数据节点：主节点和从节点都是数据节点。 哨兵工作原理： 每个 Sentinel 以每秒一次的频率向它所知的 Master，Slave 以及其他 Sentinel 节点发送一个 PING 命令； 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过配置文件 own-after-milliseconds 选项所指定的值，则这个实例会被 Sentinel 标记为主观下线； 如果一个 Master 被标记为主观下线，那么正在监视这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 是否真的进入主观下线状态； 当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认 Master 的确进入了主观下线状态，则 Master 会被标记为客观下线； 如果 Master 处于 ODOWN 状态，则投票自动选出新的主节点;将剩余的从节点指向新的主节点继续进行数据复制； 若没有足够数量的 Sentinel 同意 Master 已经下线，Master 的客观下线状态就会被移除。若 Master 重新向 Sentinel 的 PING 命令返回有效回复，Master 的主观下线状态就会被移除。 哨兵模式优缺点： 优点：（1）主从自动切换，更加健壮 缺点： （1）主从切换需要时间还是会丢失数据；（2）没有解决主节点写压力 （3）动态扩容复杂 4. 集群模式 Redis 3.0 版本引入了Redis Cluster集群模式。 如上图所示：该集群中包含 6 个 Redis 节点，3 主 3 从，分别为 M1，M2，M3，S1，S2，S3。除了主从 Redis 节点之间进行数据复制外，所有 Redis 节点之间采用 Gossip 协议进行通信，交换维护节点元数据信息 Redis Cluster 采用无中心结构，每个节点都可以保存数据和整个集群状态，每个节点都和其他所有节点连接。 Cluster 一般由多个节点组成，节点数量至少为 6 个才能保证组成完整高可用的集群，其中3个为主节点，3个为从节点； 4.1 Redis 集群分片概念 单机、主从、哨兵的模式数据都是存储在一个master节点上，其他节点进行数据的复制。 集群模式就是把数据进行分片存储，当一个分片数据达到上限的时候，还可以分成多个分片。 Redis Cluster 采用虚拟哈希槽分区，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式： HASH_SLOT = CRC16(key) % 16384 每一个主节点负责维护一部分槽以及槽所映射的键值数据。 举例说明： 有 3 个节点的集群环境如下 节点 A 哈希槽范围为 0 ~ 5500； 节点 B 哈希槽范围为 5501 ~ 11000； 节点 C 哈希槽范围为 11001 ~ 16383。 增加数据： （1）根据上述公式计算新增的key存储 ，映射到相应节点（假设为B） 增加节点： （1）从各个节点拿出一部分哈希槽分配到新增的D节点上即可 删除节点： （1）删除A节点，只需将A节点的哈希槽移动到其它节点接口 4.2 Reids集群的主从模式 Redis Cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点复制主节点数据备份，当这个主节点挂掉后，就会通过这个主节点的从节点选取一个来充当主节点，从而保证集群的高可用。 4.3 优缺点总结 优点： （1）无中心结构 ，多节点存储数据；（2）节点动态删除、移动数据分布方便；（3）部分节点不可用，集群依旧可用（哈希槽 + 从节点备份并故障晋升主节点）； 缺点： （1）异步复制，无法保证数据一致性（2）集群搭建复杂（3）mget,pipeline等命令。它们需要把请求分散到多个节点执行、再聚合。节点越多，性能越低 3.说说 Redis哈希槽的概念？什么情况下会导致整个集群不可用？ Redis 没有使用哈希一致性算法，而是使用哈希槽。Redis 中的哈希槽一共有 16384 个，计算给定密钥的哈希槽，我们只需要对密钥的 CRC16 取摸 16384。 假设集群中有 A、B、C 三个集群节点，不存在复制模式下，每个集群的节点包含的哈希槽如下： 节点 A 包含从 0 到 5500 的哈希槽； 节点 B 包含从 5501 到 11000 的哈希槽； 节点 C 包含从 11001 到 16383 的哈希槽； 这时，如果节点 B 出现故障，整个集群就会出现缺少 5501 到 11000 的哈希槽范围而不可用。 4. Redis 常见性能问题和解决方案有哪些？ Redis 常见性能问题和解决方案如下： Master不做持久化， Slave 做 AOF：Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件；如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次； 同局域网：为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内； 尽量避免在压力很大的主库上增加从库； 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;-Slave3….；这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变 6.5 Redis Key相关 1.假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？ 我们可以使用 keys 命令和 scan 命令，但是会发现使用 scan 更好。 keys命令 虽然可以查询但不太推荐： 时间长且会导致线程阻塞： 时间长是因为O(N)遍历 ； 阻塞是因为Redis单线程，要等遍历完，这使得Redis要等keys执行完毕才能恢复生产（在生成环境中这是不被允许的）。 没有分页功能： 一次查找所有的结果 scan命令 推荐： 不会阻塞，但查找出的元素可能重复，需要客户端去重下 为什么不会阻塞？ 因为 scan 是通过游标方式查询的 ，查询过程中会把游标返回给客户端，单次返回空值且游标不为 0，则说明遍历还没结束，客户端继续遍历查询。 2.如果有大量的 key 需要设置同一时间过期，一般需要注意什么？ 如果有大量的 key 在同一时间过期，那么可能同一秒都从数据库获取数据，给数据库造成很大的压力，导致缓存雪崩。 解决方案： 最好给数据的过期时间加一个随机值，让过期时间更加分散 3.什么是 bigkey？会存在什么影响？ bigkey 是指键值占用内存空间非常大的 key。例如一个字符串 a 存储了 200M 的数据。 bigkey 的主要影响有： 网络阻塞：获取 bigkey 时，传输的数据量比较大，会增加带宽的压力； 超时阻塞：因为 bigkey 占用的空间比较大，所以操作起来效率会比较低，导致出现阻塞的可能性增加。 4. Redis如何解决 key冲突？ Redis 如果 key 相同，后一个 key 会覆盖前一个 key。 如果要解决 key 冲突，最好给 key 取好名区分开，可以按业务名和参数区分开取名，避免重复 key 导致的冲突。 5. 如何解决Redis的并发竞争Key问题 ？ 多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同。 解决方案：分布式锁（zookeeper 和 Redis 都可以实现分布式锁）。 zookeeper分布式锁：（1）每个客户端对某个方法加锁时，在zookeeper上的 与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点；（2）判断是否获取锁的方式很简单，只需要判断有 序节点中序号最小的一个；（3）当释放锁的时候，只需将这个瞬时节点删除即可。 同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。 6. Redis删除key的底层原理实现？ 参考：https://www.hoohack.me/2019/06/24/redis-expire-strategy Redis在启动的时候，会注册两种事件： 时间事件： Redis处理后台操作的一类事件，比如客户端超时、删除过期key 文件事件： redis注册的回调函数是serverCron，在定时任务（惰性删除）回调函数中，通过调用databasesCron清理部分过期key 定时删除 对于每一个设置了过期时间的key都会创建一个定时器，一旦到达过期时间就立即删除： 缺点：占用了大量的CPU资源去处理过期的数据，会影响Redis的吞吐量和响应时间。 惰性删除 每次访问key的时候，都会调用expireIfNeeded函数判断key是否过期，如果是，清理key： 缺点：大量的过期key没有被再次访问，因此不会被清除，导致占用了大量的内存。 定期删除 每隔一段时间，扫描Redis中过期key字典，并清除部分过期的key： 缺点：折中方案 Redis单线程清理key的时机 Redis是以单线程运行的，在清理key是不能占用过多的时间和CPU，需要在尽量不影响正常的服务情况下，进行过期key的清理。 以随机删除为例 server.hz配置了serverCron任务的执行周期，默认是10，即CPU空闲时每秒执行十次； 每次清理过期key的时间不能超过CPU时间的25% ； 如果是快速清理模式（在beforeSleep函数调用），则一次清理的最大时间是1ms； 依次遍历所有的DB； 从db的过期列表中随机取20个key，判断是否过期，如果过期，则清理； 如果有5个以上的key过期，则重复步骤5，否则继续处理下一个db ； 在清理过程中，如果达到CPU的25%时间，退出清理过程。 Redis4.0使用BIO处理 Redis4.0以前，删除指令是del，del会直接释放对象的内存，但是，如果删除的key是一个非常大的对象，那么删除操作就会导致单线程卡顿，Redis的响应就慢了。 在Redis4.0版本引入了unlink指令，能对删除操作进行“懒”处理，将删除操作丢给后台线程，由后台线程BIO来异步回收内存。 内存淘汰策略 Redis的内存淘汰策略，是指内存达到maxmemory极限时，使用某种算法来决定清理掉哪些数据，以保证新数据的存入。","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://hwh.zone/tags/Redis/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"数据库","permalink":"https://hwh.zone/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"校招笔记（五）_计算机基础_MySQL","slug":"校招笔记（五）_计算机基础_MySQL","date":"2021-11-26T12:57:42.047Z","updated":"2021-11-26T16:30:49.298Z","comments":true,"path":"2021/11/26/校招笔记（五）_计算机基础_MySQL/","link":"","permalink":"https://hwh.zone/2021/11/26/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80_MySQL/","excerpt":"","text":"备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 🚩 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 五、MySQL 5.1 MySQL基本 0. 关系型数据库和非关系数据库的区别？ 关系型数据库的优点 容易理解，因为它采用了关系模型来组织数据； 可以保持数据的一致性； 数据更新的开销比较小； 支持复杂查询（带where子句的查询）。 非关系型数据库的优点 不需要经过SQL层的解析，读写效率高； 基于键值对，数据的扩展性很好； 支持多种类型数据的存储，如图片，文档等等。 1.介绍一下数据库三范式？ 参考：https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html 第一范式： 数据库表中的所有字段值都是不可分解的原子值 。 数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储。 第二范式： 第二范式基于第一范式，且要求：数据库表中的每一列都和主键相关，且不能只与主键的某一部分相关（主要针对联合主键而言）, 即不存在部分依赖； 下表是以：订单编号&amp;商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的订单编号相关，而仅仅是与商品编号相关。 所以根据第二范式，将它进行拆分三个表： 第三范式： 基于第二范式，数据表中的每一列数据都和主键直接相关，即不存在传递依赖； 比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。 2. MySQL数据库引擎有哪些？ MySQL查看所有的数据引擎： 1mysql&gt; show engines; MySQL常用引擎包括：MYISAM、Innodb、Memory、MERGE， MYISAM （读：my+i+son） 以select、insert为主的应用基本上可以使用这引擎。 优点：全表锁，拥有较高的执行速度，占用空间小； 缺点 ：不支持事务，不支持外键，并发性能差。 Innodb Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，它的设计目标是处理大容量数据库系统。 优点：行级锁，支持事务，支持自动增长列，支持外键约束，并发能力强 缺点： 占用空间是MYISAM的2倍，处理效率相对也更低 Memory 主要用于内容变化不频繁的代码表。 优点：全表锁，存储在内存中，默认使用Hash，检索效率非常高 缺点： 会占用和数据量成正比的内存空间且，mysql重启时会丢失，不适合精确查找 MERGE 是一组MYISAM表的组合。 2.1 InnoDB、MyISAM、Memory 【索引】（按数据结构分） 参考：https://segmentfault.com/a/1190000037683781 2.2 为什么Innodb使用自增id作为主键？ 如果不使用自增主键， 如身份证号、学号，每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置（涉及到B+树分裂等）， 频繁的移动、分页操作造成了大量的碎片； 如果使用自增主键， 那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。 3.说说InnoDB与MyISAM的区别？ 见前。 3.1 说说InnoDB与MyISAM在B+数索引方式区别？ MyISAm , B+Tree叶节点的data域存放的是数据记录的地址，在索引检索的时候，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引” ； InnoDB， 树的节点data域保存了完整的数据记录，这个索引的key是数据表的主键（自增id） ；而其它索引都叫做辅助索引， 助索引的data域存储相应记录主键的值而不是记录地址。 在根据主索引搜索时，直接找到key所在的节点即可取出数据； 在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 3.2 【百度】说说InnoDB与MyISAM在适用场景上的区别？ MyISAM ，没有事务， 适合插入不频繁，查询非常频繁； Innodb： 有事务，适合可靠性要求比较高，或者更新和查询比较频繁。 4. 为什么 SELECT COUNT(*) FROM table 在 InnoDB 比MyISAM 慢？ 对于 SELECT COUNT(*) FROM table 语句，在没有 WHERE 条件的情况下，InnoDB 比 MyISAM 可能会慢很多，尤其在大表的情况下。 InnoDB 是去实时统计结果，会全表扫描； 而 MyISAM内部维持了一个计数器，预存了结果，所以直接返回即可。 5.简单说一说drop、delete与truncate的区别？ SQL中的drop、delete、truncate都表示删除，但是三者有一些差别： 删除类型： drop删除表结构；delete、truncate删除表内容。 删除速度： drop&gt; truncate &gt;delete 生效速度： drop和truncate ，操作立即生效，不能回滚也不触发触发器；delete事务提交后才生效，会触发相应触发器。 6.什么是视图？ 游标？ 视图是一种虚拟的表，通常是一个表或者多个表的行或列的子集，具有和物理表相同的功能。 可以对视图进行增，改，查，操作，但对视图的修改不影响基本表； 相比多表查询，获取数据速度更容易。 游标，是对查询出来的结果集作为一个单元来有效的处理。 一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。 7.什么是内联接、左外联接、右外联接？ 内联接（Inner Join）：两个表（或连接）中某一数据项相等的连接称为内连接。 连接的结果是形成一个新的数据表。 内连接中参与连接的表（或连接）的地位是相等的； 左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示； 右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示。 8.说说在 MySQL 中一条查询 SQL 是如何执行的？ 例如：select name from t_user where id=1 取得链接，使用使用到 MySQL 中的连接器； 查询缓存，key 为 SQL 语句，value 为查询结果，如果查到就直接返回； 在 MySQL 8.0 版本已经将查询缓存删除，也就是说 MySQL 8.0 版本后不存在此功能。 分析器，分为词法分析和语法分析。此阶段只是做一些 SQL 解析，语法校验。所以一般语法错误在此阶段； 优化器，是在表里有多个索引的时候，决定使用哪个索引；或者一个语句中存在多表关联的时候（join），决定各个表的连接顺序； 执行器，开始执行语句。执行语句的时候还要判断是否具备此权限，如果有权限：（1）根据表的引擎定义，使用引擎提供的接口，获取表的第一行，判断id是否等于1 ；（2）如果不是则继续调用引擎接口去获取下一行，继续判断；（3）直至取到这个表的最后一行 9. MySQL 中 varchar 与 char 的区别？ int(3) 呢？ char 是一种固定长度的类型，varchar 则是一种可变长度的类型。 float(3,2) 和 int(3) float(3,2) : &quot;浮点型&quot;的长度是用来限制数字存储范围的。比如 float(3,2) 只能够写入 0.00~999.99。 int(3) ：&quot;整型&quot;的长度并不会限制存储的数字范围，都是-2147483648 ~ 2147483647 。只限制显示长度。 10.超键、主键、候选键和外键有什么区别？ 超键(super key)：在关系中能唯一标识元组的属性集称为关系模式的超键； 候选键(candidate key)：不含有多余属性的超键称为候选键，是超键的子集； 主键(primary key)：用户选作元组标识的一个候选键程序主键，是候选键的子集 ； 外键：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。 下面举例说明（假设姓名不重复唯一）： 身份证 姓名 性别 年龄 超键： 身份证、姓名、（姓名、性别）、（姓名、性别、年龄）都可以作为超键； 候选键 ：身份证、姓名 都唯一，都可以作为候选键； 主键： 在候选键选一个作为主键，例如：身份证。 11. 解释⼀下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池? 池化设计思想 我们常⻅的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。 数据库连接池 数据库连接本质就是⼀个 socket 的连接。数据库服务端还要维护⼀些缓存和⽤户权限信息之类的所以占⽤了⼀些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重⽤这些连接。 为什么要用数据库连接池？ 为每个⽤户打开和维护数据库连接，尤其是对动态数据库驱动的网站应⽤程序的请求，既昂贵⼜浪费资源。在连接池中，创建连接后，将其放置在池中，并再次使⽤它，因此不必建⽴新的连接。如果使⽤了所有连接，则会建⽴⼀个新连接并将其添加到池中。 12. 如果数据不存储在磁盘而是在内存，用什么数据结构？为什么Mysql不使用hash？ 参考：为什么hash作为内存使用的经典数据结构? 数据放在磁盘，使用B+树，核心是为了减少磁盘IO，因为磁盘IO的代价很大（是内存的十万倍）。 我们使用hash寻找数据的时候，数据随机分散到各个物理位置，不是有序的数据。而内存设备也是随机访问设备，内存很适合用hash方式来读取数据。 随机访问：存储器单元的内容可以根据需要自由取出或存储，而且访问的速度与存储器单元的位置无关 。(通过行，列地址总线就可以快速定位存储的数据) 但是磁盘，每次访问数据，是需要先定位，然后顺序移动；如果下个数据不在磁头附近，又要重新定位。 如果Hash索引磁盘数据，（1）每次访问都要IO不能范围（2）数据太多，Hash索引保存不了键值，而高度为3的B+数就能保存千万级别的数据（3）当数据量很大时，hash冲突的概率也会非常大（4）组合索引可以支持部分索引查询，如(a,b,c)的组合索引，查询中只用到了阿和b也可以查询的，如果使用hash表，组合索引会将几个字段合并hash，没办法支持部分索引 （5）当需要按照索引进行order by时，hash值没办法支持排序 。 13.【字节】Mysql Join的原理？ 参考：https://zhuanlan.zhihu.com/p/54275505 1select * from user tb1 left join level tb2 on tb1.id=tb2.user_id 简单嵌套循环 双层for 循环 ，通过循环外层表的行数据，逐个与内层表的所有行数据进行比较来获取结果。 索引嵌套循环连接 通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去进行比较， 这样极大的减少了对内层表的匹配次数。 从原来的匹配次数=外层表行数 * 内层表行数,变成了 外层表的行数 * 内层表索引的高度，极大的提升了 join的性能； 注意，要为表user_level 去建立索引 缓存块嵌套循环连接 其优化思路是减少内层表的扫表次数。 通过简单的嵌套循环查询的图，我们可以看到，左表的每一条记录都会对右表进行一次扫表，扫表的过程其实也就是从内存读取数据的过程，那么这个过程其实是比较消耗性能的。 所以缓存块嵌套循环连接算法意在通过一次性缓存外层表的多条数据，以此来减少内层表的扫表次数，从而达到提升性能的目的。如果无法使用Index Nested-Loop Join的时候，数据库是默认使用的是Block Nested-Loop Join算法的。 当level 表的 user_id 不为索引的时候，默认会使用Block Nested-Loop Join算法。 13.1 join和left join区别? join相当于我们平时用的where，就是把两张表中同时满足a.id=b.id的数据找出来； left join是以左表（a）为参考对象，相当于做一个for循环，把a表的数据一条一条的读取出来，然后根据a.id=b.id的条件到b表中查找数据。 13.2 unio和unio all的区别? 如果我们需要将两个select语句的结果作为一个整体显示出来，我们就需要用到union或者union all关键字。 1select employee_id,job_id from employees union select employee_id,job_id from job_history union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。 13.3 unio 和 join的区别? 参考：https://www.jb51.net/article/30975.htm join是对两个表进行联合，相当于where，满足条件的行会被选出，其中列会被扩充！ 但unio是连接结果集，需要满足列个数相同，只会保存第一个表列个数，列个数不会被扩充！ 5.2 分布式数据库 0. 【字节】分布式数据库锁如何实现？ 什么时候用到分布式数据库？ 水平拆分 ：数据量大到单机数据库已存储不下时， 可以对数据进行拆分，化整为零，将数据均匀分布到多个数据库节点中。 读写分离：主要用在数据量并不大，单机数据库能够hold得住，但读请求很高的情况下。此时，可以配置多个只读数据库节点，来分担主节点的读请求。通过数据复制机制，在主节点和只读节点之间进行数据的实时同步，保证主从节点的数据一致性。 分布式数据库锁？ 直接锁表，代价比较大 加入排它锁，查询语句后面增加for update（这里我们希望使用行级锁，就要给method_name添加索引） Zookeeper实现分布式锁 1.请说说MySQL数据库的锁？ MySQL 中常见锁如下： 【按使用方式划分】 共享锁：不堵塞，多个用户可以同一时刻读取同一个资源，相互之间没有影响； 排它锁（写锁）：一个写操作阻塞其他的读锁和写锁，只允许一个用户进行写入，防止其他用户读取正在写入的资源。 【按锁粒度划分】 表锁：系统开销最小，会锁定整张表，不会出现死锁；但是由于粒度太大，因此造成锁的冲突几率大，并发性能低。MyISAM 使用表锁。 行锁：容易出现死锁，发生冲突概率低，并发性能高。InnoDB 支持行锁。 必须有索引才能实现，否则会自动锁全表，那么就不是行锁。 【按思想划分】 乐观锁 悲观锁 2.说说什么是锁升级？什么情况发生锁升级？ 区分一下sycronized锁升级。 锁升级是指将当前锁的粒度降低：行锁→页锁→表锁。 发生锁升级的情况： 当一条SQL语句对同一个对象上持有的锁数量超锁了阈值，默认这个阈值为5000，但是对于不同对象不会发生锁升级 锁资源占用的内存超过激活内存的百分之40 就会发生锁升级 2.1 为什么说innoDB 引擎不存在锁升级的问题 ？ 待补充。 2.2 什么时候触发行锁和表级锁？ mysql默认存储引擎都是innodb，默认是使用行锁 。 触发行级锁 ，行级锁锁的是索引记录 ，使用了索引所以就会触发行级锁。 触发表级锁，有以下三种情况 其实不管是读操作(select)还是写操作(update,delete,insert),只要涉及到带有筛选条件的语句，如果筛选条件中没有用到索引，就会触发全表扫描。 全表更新：事务需要更新大部分数据或全部数据，如果使用行级锁，会导致事务执行效率低，从而导致其他事务长时间等待锁和更多的锁冲突 多表级联：事务涉及多张表，比较复杂的关联查询，很可能造成死锁，这种情况若能一次性锁住事务涉及的表，从而避免死锁，减少数据库事务回滚所带来的开销 筛选条件中未用到索引： 全表扫描 用到索引，但区分度程度不高 ：innodb认为全表扫描比走索引效率更高导致索引失效，这个时候就要通过explain去查看下查询计划，看下查询语句是否真的用到了索引 2.3 行锁适合的场景？ A用户消费，service层先查询该用户的账户余额，若余额足够，则进行后续的扣款操作；这种情况查询的时候应该对该记录进行加锁。 1for update # 操作该记录时加上 否则，B用户在A用户查询后消费前先一步将A用户账号上的钱转走，而此时A用户已经进行了用户余额是否足够的判断，则可能会出现余额已经不足但却扣款成功的情况。 3.怎样尽量避免死锁的出现？ 设置获取锁的超时时间，至少能保证最差情况下，可以退出程序，不至于一直等待导致死锁； 设置按照同一顺序访问资源，类似于串行执行； 避免事务中的用户交叉； 保持事务简短并在一个批处理中； 使用低隔离级别。 4.解释一下悲观锁和乐观锁？ 悲观锁： 悲观锁是基于一种悲观的态度类来防止一切数据冲突。它是以一种预防的姿态 在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作。一般数据库本身锁的机制都是基于悲观锁的机制实现的。 特点： 完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁；但是造成性能消耗 实现 ： 12345678# 加读锁LOCK tables test_db READ # 释放锁UNLOCK TABLES# 加写锁LOCK tables test_db WRITE # 释放锁UNLOCK TABLES 乐观锁： 对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁，使得多个任务可并行对数据操作。但是使用一种验证机制来避免数据冲突 （一般通过加版本后对比来实现）。 特点： 并发类型的锁，本身不加锁但通过业务实现锁的功能 ，没有锁操作因此性能更高。 实现形式： （1）两个请求同时操作操作标Name字段，二者查询需检索的数据都是一样的： （2）请求1修改字段数据“zhangsan”→“lisi” ，并将版本号增加+1 ，验证版本号一直后提交 1update A set Name=lisi,version=version+1 where ID=#&#123;id&#125; and version=#&#123;version&#125; （3）请求2也想修改“zhangsan”→“liming” ，但是提交时由于 版本号不一致，无法提交成功 4.1 数据库乐观锁和悲观锁，如何实现？ 实现乐观锁 利用版本号，如MVCC； 时间戳：同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似。 也是在更新提交的时候，将当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。 实现悲观锁 直接加上读锁或者写锁，SELECT … FOR UPDATE 。 5.介绍一下分布式数据库全局ID唯一且自增，如何生成？ （或者问分库分表之后，id 主键如何处理？） 因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要⼀个全局唯⼀的 id来支持。 UUID：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。 ID自增量为分布式数据库个数，缺点是扩展性不好； snow flake算法：snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。 核心思想： 使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 不同ID），最后还有一个符号位，永远是0。 Leaf算法：分号段 8.介绍一下哈希算法？和一致性哈希算法？ 哈希算法 介绍： 哈希算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。 分布式应用中缺点： 在分布式的存储系统中，要将数据存储到具体的节点上。如果采用哈希算法：key%N（key是数据的key，N是机器节点数） 。出现机器加入或退出集群（N变了，映射值不一样了），所有的数据映射都无效了。 一致性哈希算法 介绍：解决普通哈希算法造成负载均衡时，在服务节点数量变动时出现哈希失效 问题 实现： 构建环：按照常用的hash算法来将对应的key哈希到一个具有2^32次方个节点的空间中（即0 ~ (2^32)-1）。 Note: 节点的个数可以自定义, hash环我们可以用TreeMap来实现, 因为treeMap是排序的，我们刚好可以利用上。 映射服务器节点： 将各个服务器使用Hash进行一个哈希，确定每台机器其在哈希环上的位置。 一般用服务器ip或唯一主机名进行哈希。 映射数据。 对于要存储的数据：ojectA、objectB、objectC、objectD ，首先通过特定哈希函数计算出hash值 ，散列到环上。然后从数据所在位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。 出现服务器变动。 如果此时NodeC宕机了，此时Object A、B、D不会受到影响，只有Object C会重新分配到Node D。避免了大量数据迁移，减小了服务器的的压力 。 9. （再理解）介绍一下MVVC？ MVCC（Multi-Version Concurrency Control）多版本并发控制，是 数据库控制并发访问的一种手段。 特别要注意MVCC只在读已提交(RC) 和可重复读（RR） 这两种事务隔离级别下才有效 是数据库引擎（InnoDB） 层面实现的，用来处理读写冲突的手段（不用加锁），提高访问性能 MVCC协议中，事务提交不会覆盖原数据，而是产生新版本数据，每个数据有多个历史版本，但同一时刻只有最新的版本有效； MVCC是在并发访问数据库时，通过对数据做多版本管理，避免【因为写锁的阻塞而造成读数据的并发阻塞】问题。可以让读取数据同时修改，【修改数据时同时可读取】。简单来说，就是不对数据库加上读写锁！ 9.1 MVCC 如何实现 ？ 参考：Innodb MVCC实现原理 总结性回答 MVCC是以一个多版本并发控制系统，它主要通过以下两个部分实现： 每行记录：记录最近操作该行记录的事务ID，和上一版本数据的指针（指向undo log） readview：每次读（写不可以） 可以获取一个readview，记录当前活跃的事务ID ，可以在写的过程进行读 写的时候并发读，通过比较当前行记录的事务ID和readview活跃的事务ID，来决定是否读取该行记录还是上一版本的数据。 MVCC实现的核心部分为： 事务版本号：每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。 表的隐藏列 ：每一行 有如下三个重要字段属性： 隐藏列 作用 DB_TRX_ID 记录操作该行事务的ID DB_ROLL_PTR 指向上一个版本的数据（在undo log）的指针 DB_ROW_ID 隐藏ID，当表没有合适的索引作为聚簇索引时，会用该ID创建聚簇索引 undo log ：每一行记录被修改之前的日志。 当事务被回滚时，可以用通过undo log日志对数据进行还原。 一个小例子：修改某行记录name从 “张三→李四” read view。在innodb 中每个SQL语句执行前都会得到一个read_view，保存了当前数据库系统中正处于活跃（没有提交）的事务的ID号。 根据事务的隔离性，这些事务ID列表不会被其它事务看到。 其相关重要属性如下： 属性 作用 trx_ids 当前系统：活跃（未提交）事务版本号集合 low_limit_id 当前系统：最大版本事务号+1 up_limit_id 当前系统：活跃的最小事务版本号 creator_trx_id 当前read view：事务版本号 具体原理可以描述如下： 举个例子，假设有一个user_info表，初始数据如下： 现在有事务A，B同时对id=1 这行数据进行操作，先开启事务A（未提交），此时执行事务B，最后返回什么结果呢？ 事务A（写），执行 update user_info set name =”李四” 获得事务编号：102 当前事务A的视图为：（写）不会获得read view！ 事务B（读），执行 select * fom user_info where id=1 获得事务B编号：103 当前事务B的视图为： trx_ids 当前活跃的事务：102,103 low_limit_id 当前最大事务id+1:104 up_limit_id 当前最小事务id：102 creator_trx_id 当前事务id：103 不同隔离级别下，read view的工作方式： 读未提交：不会获得read view的副本（等于没有并发控制所以会出现脏读） 读提交：每一次select都会获得一个read view的副本，所以会造成【不可重复读】 可重复读：同一个事务select只会获得一次read view副本（select的时候不允许修改），所以不会出现不可重复读。 事务A（写），开始执行update语句：（1）把原数据拷贝到undo log，（2）然后进行修改name字段：“张三→李四”，（3）并设置DB_TRX_ID 隐藏字段：99→102 （4）设置DB_ROLL_PTR隐藏字段：执行上个事务版本地址 此时，事务A还并未提交，依旧是处于活跃状态。 事务B（读），开始执行select语句，查询到是事务A修改后的语句 把数据和read view （视图）匹配： 保证（1）数据已提交，没有其他事物修改，否则去找上一版本的数据。 当前数据记录的事务id &lt; 事务B视图中最小活跃事务id : 说明数据，是在事务B的read view 创建前就存在，所以可以显示。 当前数据记录的事务id &gt; 事务B视图中最大活跃事务id ：说明数据，是在事务B的read view 创建后才存在，此时不应该显示。 事务B视图中最小活跃事务id&lt;= 当前数据记录的事务id &lt;= 事务B视图中最大活跃事务id ： 说明有其它事务在修改这行记录数据，但可能还没有提交。把id和事务B的read view的活跃事务集合trx_ids进行匹配： 如果数据记录的ID不存在trx_ids，说明已经提交了事务，可以显示 如果存在trx_ids，说明数据还没提交，此时事务B查询到数据不能显示（除非此时数据记录的事务id == 事务B的id，由于是自己的当然可以显示） 事务B（读），根据上述匹配规则，此时不能读，应该去undo log中找到上一版本数据。 此时事务B的id=103，数据记录的事务id=102 ：满足条件3，且此时trx_ids存在事务id=102，说明事务A（id=102）还没提交，因此不能显示。 故，最终查找的数据为： 可以看到，整个过程MVCC事务A【写】没有加锁，只是进行版本号控制 &amp; undo log，可以进行并发【读】。 9.2 MVCC 版本号如何变化的？更新的数据如何确定版本的？【幻读】又是怎么解决的呢？ 版本号变化 每条记录有三个隐藏列：（1）DB_TRX_ID （2）DB_ROLL_PTR （3）DB_ROW_ID 每一次新事务，update更新语句，都会将（1）拷贝数据到undo log（2）DB_ROLL_PTR指向上个数据的版本undo log（3）DB_TRX_ID修改为新事务的id 。 为什么MVCC可解决幻读 在RR（可重复读级别下）不会出现幻读。例如： 开启事务1，获得事务ID为1； 事务1执行查询，得到readview； 开始事务2； 执行insert； 提交事务2； 执行事务1的第二次查询 (因为这里是RR级别，所以不会再去获得readview，还是使用第一次获得的readview，所以当前read view 事务的ID不会更新，即不会加入插入事务2)； 最后得到的结果是，插入的数据不会显示，因为插入的数据事务ID &gt; readview里的最大活跃事务ID。 9.3 mvvc 和 for update的区别 是否加锁： mvvc不加锁，只通过多版本来进行并发控制；for update会加锁（即X/写锁）。 9.4 （快手）MVCC作用，如何实现RC，RR? 参考：https://zhuanlan.zhihu.com/p/73078137 作用如下： 最简单的描述，读写不阻塞，读的时候可以写 提高性能 实现RC，RR两个隔离级别： MVCC 读某一个数据时，根据隔离级别，事务选择要读取哪个版本的数据，过程中完全不需要加锁。 Read Committed ：一个事务读取数据时总是读这个数据最近一次被commit的版本 ，所以可以避免脏读（快手）； Repeatable Read ： 一个事务读取数据时总是读取当前【事务开始之前】最后一次被commit的版本（所以底层实现时需要比较当前事务和数据被commit的版本号），所以避免了幻读（快手）。 举个简单的例子： 一个事务A（txnId=100）修改了数据X，使得X=1，并且commit了 另外一个事务B（txnId=101）开始尝试读取X，但是还X=1。但B没有提交。 第三个事务C（txnId=102）修改了数据X，使得X=2。并且提交了 事务B又一次读取了X。这时 如果事务B是Read Committed。那么就读取X的最新commit的版本，也就是X=2 如果事务B是Repeatable Read。那么读取的就是当前事务（txnId=101）之前X的最新版本，也就是X被txnId=100提交的版本，即X=1。 注意，这里B不论是Read Committed，还是Repeatable Read，都不会被锁，都能立刻拿到结果。这也就是MVCC存在的意义。 5.3 索引相关 🛰 强烈建议对索引更深刻理解，先看完美团这篇技术文章：MySQL索引原理及慢查询优化 0. MySQL索引原理及慢查询优化 0.1 为什么要需要索引 答到：遍历磁盘开销太大这个关键。 数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分读入内存来计算 。 磁盘的成本大概是访问内存的十万倍左右 ， 每次去遍历磁盘找到数据再读入内存，是难以接受的。因此需要一种快速找到磁盘数据的方式，就像字典通过字母索引→快速定位单词。因此索引由此而出现。 0.2 局部性原理（磁盘IO一次读取大小） 在继续往下讲之前，先来讲讲磁盘读取局部性原理。 局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。 因此，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内。 每次IO读取的数据，分为下面情况： Linux：上以页为单位，一次一页（4K） 数据库：mysql（InnoDB引擎）一页（16K）; SQL Server/ Oracle，默认块，大小都是8KB 0.3 索引→B+树 相比二叉树，平衡树等，B+树 作为高度可控的多路搜索树 ，可以很好的满足要求。（详细选择原因，可以参考：5.3 索引相关–问答6） B+树基本结构 浅蓝色是一个磁盘块，数据项就是被组织索引那列的字段值。 如果是Innodb引擎，使用聚簇索引就是按照每张表的主键 构造索引，那么此时数据项就是主键值。 蓝色部分（如17,35）是数据项；黄色部分（如P1,P2,P3）是指针，指向下个磁盘块（页地址）。 1. 为什么B+树非叶子节点不存放数据？ IO次数取决于b+数的高度h，每个磁盘块大小也是一定（一页）的。如果数据项占的空间越小，一个磁盘块数据项的数量越多，树的高度越低，B+可以更高阶（指针占用先忽略）。 所以磁盘非叶子节点不保存数据，是为了保存更多的数据项和指针，这样一颗B+树叶子节点就能存储更多的数据。 2. 数据查找过程？ 以查找数据项=28 ，过程为例： （1） 先 加载（一般常驻内存） 根页面1（磁盘块1），因为17&lt;28&lt;35 所以使用P2指针 ， 找到磁盘块3（页面3）地址 （2）在 IO加载 磁盘块3，因为 26&lt;28&lt;30 ，因此根据此时的P2 指针，找到磁盘块8所在的地址 （3） IO加载 磁盘块8，因为此时是叶子节点，可以得到数据项=28对应的那行记录 。 仅仅最多3次磁盘IO就找到了数据，这提升是巨大的。 3. 高度为3的B+数可以存储多少数据？ 叶子节点一页存储的记录数 mysql一页16K，所以一页存储16K/1K = 16条 记录。（实际真实业务场景一条记录一般就是1K） 非叶子节点一页存储的指针数 由于数据项也要占用空间，其和指针只相差1，按成对算。 假设主键ID（数据项）为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节 。那么一共14字节。 所以一页可以存储：16K / 14B ≈ 1K 个指向页面的指针。 计算可以存储多少页 高度为3的B+树，第3层叶子节点存储真实数据页，前2层是存储数据项+指针。第二层指针==叶子节点存储的页面数。 第一层：根页面可以存储1K个指针，每个指针指向一个新的页面 第二层：存储 1K*1K = 1M ，约一百万个指针，指向一百万个叶子数据页面 所以一共存储：1M*16≈16M ，即千万级别的数据。 0.4 慢查询优化 （暂略） 1. MySQ索引的原理和数据结构能介绍一下吗？索引的缺点？ 索引原理： 本质是用来优化查询速度。用一个数据结构组织某一列的数据，然后如果你要根据那一列的数据查询的时候，就可以不用全表扫描，只要根据那个特定的数据结构快速去找到那一列的值。 数据结构： MySQL索引通过B+树来实现（按数据结构分也有hash索引、fulltext索引）。 索引缺点： （1）占用磁盘存储空间 （2）降低表更新速度，表发生变化，索引也要发生变化 2. MySQL 索引类型有哪些？ 按数据结构分类可分为：B+tree索引、Hash索引、Full-text索引。 按物理存储分类可分为：聚簇索引、二级索引（辅助索引）。 按字段特性分类可分为：主键索引、普通索引、前缀索引。 按字段个数分类可分为：单列索引、联合索引（复合索引、组合索引）。 主键索引：索引列中的值必须是唯一的，不允许有空值； 唯一索引：索引列中的值必须是唯一的，但是允许为空值； 普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值； 全文索引：只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引； 字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引； MyISAM和InnoDB中都可以使用全文索引。 前缀索引：在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定； 空间索引： MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。 MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。 2.1 什么是覆盖索引？ 我们在非聚簇索引一般只获得了，记录的key值（Innodb引擎），还需要回到聚簇索引中再次查询。 覆盖索引： 从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。 一个小例子。 以name和age两个字段建立联合索引，sql命令与建立后的索引树结构如下： 12ALTER TABLE student DROP INDEX I_name;ALTER TABLE student ADD INDEX I_name_age(name, age); 此时执行如下sql： 1SELECT age FROM student WHERE name = &#x27;小李&#x27;； 在非聚簇索引中包含了age信息，那么直接返回12，不需要再到聚簇索引中查询。 【重点】3.什么时候使用索引比较好？什么时候不要使用索引？ 3.1 什么时候用索引 特别的，主键自动建立唯一索引。 频繁作为查询条件的字段应该创建索引 ； 查询中与其他表关联的字段，外键关系建立索引； 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度（索引就是排序加快速查找）； 查询中统计或者分组字段。 3.2 什么时候不用索引 经常增删改的列不要建立索引（因为每次更新不单单是更新记录，还会更新索引，保存索引文件）； 表记录太少不要建立索引； （被CSIG问过）区分度低，数据重复且分布平均的字段不适合做索引； 例如性别字段，只有男女，不适合建立索引。 因为从索引中拿到的只是地址，要想真正访问到数据还是要对表进行一次IO； 假如你要从表的100万行数据中取几个数据，那么利用索引迅速定位，访问索引的这IO开销就非常值了； 但如果你是从100万行数据中取50万行数据，就比如性别字段，那你相对需要 访问50万次索引，再访问50万次表，加起来的开销并不会比直接对表进行一次完整扫描小。 text，image等类型不应该建立索引，这些列的数据量大； 多个单列索引并不是最佳选择 MySQL 只能使用一个索引，会从多个索引中选择一个限制最为严格的索引 ； 参加运算 或 作为函数参值等字段，不要建立索引，这会使得索引失效而全表扫描 。 4.主键与唯一索引有什么区别？ 主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键； 主键不允许为空值，唯一索引列允许空值； 一个表只能有一个主键，但是可以有多个唯一索引； 主键可以被其他表引用为外键，唯一索引列不可以； 主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本质差别。 5. b+树和b树有什么区别？ B树： 索引与数据存储在每个节点中（增加了IO次数）； 搜索过程有可能在非叶子节点结束（最好情况下O(1)O(1)O(1)）。 B+树： 所有数据按顺序存储在叶子节点中； 所有叶子节点被双向链连接； 搜索过程固定时间复杂度（O(log⁡n)O(\\log n)O(logn)）； （优点易忘）适合范围查找，降低磁盘IO次数。 6.为什么MySQL使用B+树作为索引？而不是平衡二叉树、红黑树、B树、或者Hash？ 不用平衡二叉树或者红黑树： 树的查询时间和树的结构有关，B+树是一颗多路搜索数，可以降低树的高度提高查询速度。 不用B树： （1）无法范围查询，而B+树所有叶子节点形成有序链表便于范围查询；（2）N阶B+数，B树，B+数可以存储n个关键字，而B树是n个。 不用Hash： （1）B+树允许分配加载节点，如果内存数据太大B+树更好（2）B+树更适合范围查询 用Hash需要把数据全部加载到内存中，如果数据量大，是一件很消耗内存的事，而采用B+树，是基于按照节点分段加载，由此减少内存消耗。 6.1 无限增加树的路数是不是可以有最优的查找效率？ 这样会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。 有序数组没法一次性加载进内存，这时候B+树的多路存储威力就出来了，可以每次加载B+树的一个结点，然后一步步往下找。 7. B+树怎么进行分裂、合并的？知道具体步骤吗？ 参考：https://www.cnblogs.com/nullzx/p/8729425.htm 8. MySQL聚簇索引和非聚簇索引的区别是什么？ 主要区别 聚簇索引 ： 找到索引就找到了需要的数据，那么这个索引就是聚簇索引; 所以Innodb主键就是聚簇索引，修改聚簇索引其实就是修改主键；但在Myisam下主键索引是非聚集索引。 InnoDB 会隐式定义一个主键来作为聚簇索引（但是这个主键如果更改代价较高，故建表时要考虑自增ID不能频繁update这点）。 非聚簇索引：索引的存储和数据的存储是分离的 , 找到了索引但没找到数据，需要根据索引上的值(主键/地址)再次回表查询，也叫做辅助索引。 MyISM使用的是非聚簇索引 ，下图叶节点的data域存放的是数据记录的地址 。 聚簇索引查找过程 首先澄清一个概念，聚簇索引和和辅助索引。 Innodb存储引擎的B+树分为，聚簇索引保存的是放着一整行的数据；辅助索引都引用主键作为data域。 例如，下图以Col3建立一个Innodb辅助索引 ： 对于MyISAM，主索引和辅助索引（Secondary key）在结构上没有任何区别。只是主索引要求key是唯一的，而辅助索引的key可以重复。 例如，下图以Col2建立一个MyISAM的辅助索引： 1Select * Where name=‘Alice’ 首先根据辅助索引 ，在叶子节点找到0X56对应主键值18 ；然后在聚簇索引，根据18 找到对应行数据。 8.1 看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，这不是多此一举吗？聚簇索引的优势在哪？ 重复访问同一页更快：由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘； B+树的每个节点的数量都是一个mysql分区页的大小(阿里面试) 。 辅助索引使用主键值作为指针： 辅助索引使用主键作为&quot;指针&quot;而不是使用地址值作为指针（MyISAM） ，减少了当出现【行移动】或者数据页分裂时（地址值变化）辅助索引的维护工作 。 8.2 为什么name,age这些字段不适合做索引？ 在InnoDB中每一个表都会有聚集索引，如果表定义了主键，则（默认）主键就是聚簇索引。 一个表只有一个聚集索引，其余为普通索引。所以name，age就是普通索引，也就是作为辅助索引。 在使用普通索引name查询时，会先加载普通索引： （1）通过普通索引查询到实际行的主键 （2）再使用主键通过聚集索引查询相应的行 （3）以此循环查询所有的行 若直接全量搜索聚集索引，则不需要在普通索引和聚集索引中来回切换。相比两种操作的总开销可能扫描全表效率更高。 9. MySQL联合索引如何使用？什么是最左匹配原则？ 参考：https://blog.csdn.net/Abysscarry/article/details/80792876 对多个字段同时建立的索引(有顺序，ABC，ACB是完全不同的两种联合索引。 1234567891011CREATE TABLE `test` ( `id` int(4) NOT NULL AUTO_INCREMENT, `a` varchar(10) NOT NULL, `b` varchar(10) NOT NULL, `c` varchar(10) NOT NULL, `d` varchar(10) NOT NULL, `e` varchar(10) NOT NULL, PRIMARY KEY (`id`), # 联合索引(a,b,c) UNIQUE KEY `idx_a_b_c` (`a`,`b`,`c`) USING BTREE ) ENGINE=I 以联合索引(a,b,c)为例： 建立这样的索引相当于建立了索引a、ab、abc三个索引。一个索引顶三个索引当然是好事，毕竟每多一个索引，都会增加写操作的开销和磁盘空间的开销。 a,c组合也可以但不是为他建立了索引，但实际上只用到了a的索引，c并没有用到！ 最左匹配原则 最左优先，在检索数据时从联合索引的最左边开始匹配，即是where条件必须有联合索引的第一个字段。 不包含第一个字段 不会走索引 1select * from test where b = &#x27;333&#x27; and c = &#x27;333&#x27;; where和索引顺序不一样 会走索引，和顺序无关。 where 后面列的顺序是被优化器优化了的，所以才会觉得无影响，你可以查看一下优化器优化后的语句，会帮你调整为满足最左前缀的顺序。 1select * from test where c = &#x27;333&#x27; and b = &#x27;333&#x27; and a = &#x27;333&#x27;; 9.1 联合索引的好处？ 10. （还要补充）介绍一下索引失效的原因？ 很不错的一篇文章：索引失效原理，终于有人讲明白了 结合这篇文章：https://juejin.cn/post/6844904073955639304 假设mysql 存在联合索引（a,b），显然也是一颗B+树: 不符合最左匹配失效 情况1 ：select * from testTable where b=2 联合索引是通过第一个索引a 来构建B+树，进行定位二分查找的，不能直接通过b 来进行二分查找。 情况2：like查询失效 12345where name like &quot;a%&quot; # 会有效，因为可以匹配到首字母where name like &quot;%a%&quot; # 首字母是任意匹配的，所以索引用不上where name like &quot;%a&quot; # 同上，不能根据尾字母来索引 范围查询失效 1select * from testTable where a&gt;1 and b=2 首先a字段在B+树上是有序的，所以可以用二分查找法定位到1，然后将所有大于1的数据取出来，a可以用到索引。 b有序的前提是a是确定的值，那么现在a的值是取大于1的，可能有10个大于1的a，也可能有一百个a。 大于1的a那部分的B+树里，b字段是无序的（开局一张图），所以b不能在无序的B+树里用二分查找来查询，b用不到索引。 多个单列索引 我们首先建立了三个单列索引：userid，mobile，billMonth。然后使用以下查询语句： 1EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE userid=&#x27;2222&#x27; AND mobile=&#x27;13281899972&#x27; AND billMonth=&#x27;2018-04&#x27; explain 结果分析，最终只有userid 这一个索引有效。 此处userid 、mobile 、billMonth这三个索引列都能用，只不过优化器判断使用userid这一个索引能最高效完成本次查询，故最终explain展示的key为userid。 特别的，如果改为 or 进行判断： 1EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE userid=&#x27;2222&#x27; OR mobile=&#x27;13281899972&#x27; 此时两个索引 userid &amp; mobile都用上了。 mysql 5.0 版本之前 使用or只会用到一个索引, 自从5.0版本开始 ，引入了index_merge索引合并优化！也就是说，我们现在可以利用上多个索引去优化or查询了。 或者索引加上了运算 1select * from t where c - 1 = 1000; 这种情况不会有效，应该是： 1select * from t where c = 1000 + 1; 又比如用了函数操作： 1select * from t where pow(c,2) = 1000; 11. 【⚠️ 新增】索引实战篇 参考：https://zhuanlan.zhihu.com/p/115778804 where a=xxx and b=xxx order by c ，如何建立索引？ 建立联合索引（a,b,c） ，因为这样的话无需做一次额外的排序操作。 因为建立联合索引时，根据最左匹配原则，先按a排序，再按b排序，最后按c 排序。根据联合索引检索到，a=xxx and b=xxx条件时，再去检索c本身已排序的。那么不用 order by c ，不用进行文件排序。 注意，建立联合索引 （a,b） , 则是走不到 sort的！ where a=xxx order by b,c ，如何建立索引？ 道理同上，建立（a,b,c） 。 where a &gt; 1 ORDER BY b，怎么建立索引？ 建立索引（a）即可，因为a是范围查询： 建立（a,b）的 话b也用不上，因为是a是范围查询； 建立（b,a）, b按索引排好序，a&gt;1可以用上？错误，因为先where筛选才会order by！ where a=1 and b=2 and c&gt;3 and d=4 ，如何建立索引？ 建立联合索引，(a,b,d,c) 即可。 但是对于建立(a,b,c,d) ，a,b,c三个字段能用到索引，而d就匹配不到，因为遇到了范围查询，在c&gt;3这个范围内，d不是有序的；但是c=3，这个范围内，d是有序的！ where a &gt; 1 and b = 2 and c &gt; 3，如何建立索引？ 建立（b,c）或者（b,a）即可，但至少有一个索引要失效（遇上范围查询）。 WHERE a IN (1,2,3) and b &gt; 1，怎么建立索引？ 还是对(a，b)建立索引，因为IN在这里可以视为等值引用，不会中止索引匹配，所以还是(a,b)！ 11.1 有个字段值可能正，可能负，查询该字段要绝对值，但计算会导致索引失效，怎么优化？ 拆成两列1列只存绝对值，另起一列tinyint来表示正负或者方向； 先查询到结果，然后再查询的结果上进行操作（取绝对值）？ 12. order by 怎么进行排序的？怎么优化？ 参考：https://segmentfault.com/a/1190000040357292 假设存在以下数据： 此时进行如下查询： 1select city, order_num, user_code from `order` where city=&#x27;广州&#x27; order by order_num limit 1000; 建立索引(city)：order by过程 1ALTER TABLE `order` ADD INDEX city_index ( `city` ); 用 explain 看看执行情况 注意到最后一个 extra 字段的结果是：Using filesort，表示需要排序。其实 MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。 完整执行过程 初始化 sort_buffer，放入 city、order_num、user_code 这三个字段； 从索引 city 找到第一个满足 city=’ 广州’条件的主键 id，也就是图中的 ID_3； 到主键 id 索引取出整行，取 city、order_num、user_code 三个字段的值，存入 sort_buffer 中； 从索引 city 取下一个记录的主键 id； 重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_X； 对 sort_buffer 中的数据按照字段 order_num 做快速排序； 其中，按 order_num 排序这个步骤，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size。 按照排序结果取前 1000 行返回给客户端。 优化1：使用rowid 上面的全字段排序其实会有很大的问题，你可能发现了。我们需要查询的字段都要放到 sort_buffer 中，如果查询的字段多了起来，内存占用升高，就会很容易打满 sort_buffer 。 sort_buffer 只存 order_num 和 id 字段。 初始化 sort_buffer，确定放入两个字段，即 order_num 和 id； 从索引 city 找到第一个满足 city=’ 广州’条件的主键 id，也就是图中的 ID_3； 回表，取 order_num、id 这两个字段，存入 sort_buffer 中； 从索引 city 取下一个记录的主键 id； 重复步骤 3、4 直到不满足 city=’ 广州’条件为止，也就是图中的 ID_X； 对 sort_buffer 中的数据按照字段 order_num 进行排序； 遍历排序结果，取前 1000 行，再次回表取出 city、order_num 和 user_code 三个字段返回给客户端。 优化2：建立联合索引 参见索引部分解释，不再赘述。 从索引 (city,order_num) 找到第一个满足 city=’ 广州’条件的主键 id； 回表，取 city、order_num、user_code 三个字段的值，作为结果集的一部分直接返回； 从索引 (city,order_num) 取下一个记录主键 id； 重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’ 广州’条件时循环结束。 5.3 事务相关 1.请介绍一下数据库事务？和事务特性（ACID）？ 数据库事务： 数据库事务指的是一组数据操作，事务内的操作要么就是全部成功，要么就是全部失败。 e.g. 假设一个网购付款的操作，用户付款后要涉及到订单状态更新、扣库存以及其他一系列动作，这就是一个事务，如果一切正常那就相安无事，一旦中间有某个环节异常，那整个事务就要回滚，总不能更新了订单状态但是不扣库存吧。 事务特性：（1） 原子性（Atomicity）：一个事务必须视为一个不可分割的最小工作单元，要么都成功要么都失败（2）一致性（Consistency）：数据库总能从一个一致性的状态转换到另一个一致性的状态（3）隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的（4）持久性（Durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中 1.1 四大特性得不到保障会出现什么情况？ 们以从A账户转账50元到B账户为例进行说明一下ACID这四大特性。 原子性 : 原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。即要么转账成功，要么转账失败，是不存在中间的状态。 如果无法保证原子性会怎么样？ 会出现数据不一致的情形，A账户减去50元，而B账户增加50元操作失败。系统将无故丢失50元~ 一致性 ：一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的。 那什么是合法的数据状态呢？这个状态是满足预定的约束就叫做合法的状态，再通俗一点，这状态是由你自己来定义的。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的。 如果无法保证一致性会怎么样？ 例一: A账户有200元，转账300元出去，此时A账户余额为-100元。 你自然就发现了此时数据是不一致的，为什么呢？因为你定义了一个状态，余额这列必须大于0。 例二：A账户200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。 你也知道此时数据是不一致的，为什么呢？因为你定义了一个状态，要求A+B的余额必须不变。 隔离性 ：隔离性是指多个事务并发执行的时候，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 如果无法保证隔离性会怎么样？ 假设A账户有200元，B账户0元。A账户往B账户转账两次，金额为50元，分别在两个事务中执行。 如果无法保证隔离性，A可能就会出现扣款两次的情形，而B只加款一次，凭空消失了50元，依然出现了数据不一致的情形！ 持久性 : 根据定义，持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 如果无法保证持久性会怎么样？ 在MySQL中，为了解决CPU和磁盘速度不一致问题，MySQL是将磁盘上的数据加载到内存，对内存进行操作，然后再回写磁盘。好，假设此时宕机了，在内存中修改的数据全部丢失了，持久性就无法保证。 设想一下，系统提示你转账成功。但是你发现金额没有发生任何改变，此时数据出现了不合法的数据状态，我们将这种状态认为是数据不一致的情形。 1.2 数据库如何保证四大特性（如何实现事务）？ 数据库事务的 ACID 四大特性是事务的基础，了解了 ACID 是如何实现的，我们也就清楚了事务的实现，接下来我们将依次介绍数据库是如何实现这四个特性的。 保证原子性 主要是利用Innodb的undo log。 undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。 例如 (1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据 (2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作 (3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操 undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。 保证一致性 数据库对于 ACID 中的一致性的定义是这样的：如果一个事务原子地在一个一致地数据库中独立运行，那么在它执行之后，数据库的状态一定是一致的。 它的第一层意思就是对于数据完整性的约束，包括主键约束、引用约束以及一些约束检查等等，在事务的执行的前后以及过程中不会违背对数据完整性的约束，所有对数据库写入的操作都应该是合法的，并不能产生不合法的数据状态。 第二层意思其实是指逻辑上的对于开发者的要求，我们要在代码中写出正确的事务逻辑，比如银行转账，事务中的逻辑不可能只扣钱或者只加钱，这是应用层面上对于数据库一致性的要求。 保证隔离性 在 SQL 标准中定义了四种数据库的事务的隔离级别：READ UNCOMMITED、READ COMMITED、REPEATABLE READ 和 SERIALIZABLE； 数据库对于隔离级别的实现就是使用并发控制机制对在同一时间执行的事务进行控制： 锁： MySQL 和常见数据库中的锁都分为两种，共享锁（Shared）和互斥锁（Exclusive），前者也叫读锁，后者叫写锁。 mvcc实现：实现RC和RR。 保证持久性 利用Innodb的redo log，为什么要使用redo log，请看下面： 正如之前说的，Mysql是把磁盘上的数据先加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失； 如果事务提交前直接把数据写入磁盘，只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。 redo log解决方案： 当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作； 当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)； 当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和binlog内容决定回滚数据还是提交数据。 1.3 binlog日志是做什么的？ 参考：https://www.cnblogs.com/kevingrace/p/5907254.html MySQL的二进制日志binlog可以说是MySQL最重要的日志，它记录了所有的DDL和DML语句（除了数据查询语句select），以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。 DDL ，即 Data Definition Language 数据库定义语言。 主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。 DML，即Data Manipulation Language 数据操纵语言。 主要的命令是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言。 binlog日志有两个最重要的使用场景： MySQL主从复制：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves来达到 master-slave数据一致的目的。 自然就是数据恢复了，通过使用mysqlbinlog工具来使恢复数据。 2.介绍一下（并发）事务不同隔离级别？对应可能出现的问题？ 参考：https://www.cnblogs.com/shan-kylin/p/9543294.html 下面排它锁和共享锁都是行锁，锁住一行。 Read uncommitted： 顾名思义，就是一个事务可以读取另一个未提交事务的数据。但这种情况会出现脏读： 因为写数据的时候添加一个X锁（排他锁，拿到锁的事务可以写，其它事务只能等待阻塞）；但读不受限制，读不加锁。 由于读不加锁，读的是可能是修改前（未提交）的数据，也就是脏读。 Read Committed ：写数据的时候加上X锁（排他锁），读数据的时候添加S锁（共享锁，拿到锁的事务可以查看但无法修改和删除，其它事务【只能加S锁】【不能加其它锁】如X锁）。解决脏读，但会导致出现不可重复读的问题。 初始x=100,； 事务A读x，加上S锁，读到x=100，立即释放S锁且未提交； 事务B修改x，加上X锁，修改x=50，提交 ； 事务A再次读取x，加上S锁，读取x=50，发现和第一次读取不一致，提交事务。 上述过程，事务A在提交前读取两次不一样的x值，为不可重复读。 Repeatable read ：MySQL 默认隔离界别 , 开始读取数据（事务开启）时，【S】锁不再立即释放，其它事务就不能加上【X】锁修改数据。解决了脏读、不可重复读，但是可能会出现幻读：- Mysql官方给出的幻读解释是：只要在一个事务中，第二次select（读）多出了row就算幻读。 现在做如下修改： 写：X锁保持不变 读：S锁，读完不再立即释放，而是在提交的时候再释放。 这样的话，保证事务A在提交前，读取的x是一致的。解决了不可重复读，但依旧可能出现幻读。例如，X锁不能阻止（表中其它记录）插入操作，因为只锁住了当前记录，是行级锁。 事务A加上X锁，更新了所有用户年龄从20→18； 过一会儿再读发现还有一个用户没修改，还是20岁？出现幻觉了吗？ 这是因为，其它事务B同时插入了一行新数据，年龄就是20岁。所以再读发现没修改。 Serializable： 序列化，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。耗费性能，一般不用。 2.1【猿辅导】 怎么解决幻读？ 解决幻读使用两种方式： 间隙锁 间隙锁（Gap Lock）：当我们用【范围条件】而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁； 举例： 假如user表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL： 1select * from user where user_id &gt; 99 for update; 是一个范围条件的检索，InnoDB不仅会对（1）符合条件的user_id值（100、101）的记录加锁，也会对（2）user_id大于101（这些记录并不存在）的“间隙”加锁。 如何解决幻读？ 产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”，导致下次读取产生幻读。如果锁住了间隙，自然也就没锁的问题了。 mvvc 在RR（可重复读级别下）不会出现幻读。例如： 开启事务1，获得事务ID为1。 事务1执行查询，得到readview。 开始事务2。 执行insert。 提交事务2。 执行事务1的第二次查询 (因为这里是RR级别，所以不会再去获得readview，还是使用第一次获得的readview，所以当前read view 事务的ID不会更新，即不会加入插入事务2) 最后得到的结果是，插入的数据不会被读取显示，因为插入的数据事务ID &gt; readview里的最大活跃事务ID。 5.4 MySQ优化 0. 分页查询慢的原因？如何优化？ 参考：https://juejin.cn/post/6844904141878214664 在偏移量非常大的时候，也就是翻页到很靠后的页面时，查询速度会变得越来越慢，例如： 1select * from t_order order by id limit 1000000000, 10; 这是因为，需要查询 100000000010 (100000000000 + 10) 条记录，然后只返回最后 10 条，并将前面的 100000000000 条记录抛弃，这样当翻页越靠后时，代价就变得越来越高。 优化方法： 最大id法 举例：查询第一页的时候是limit 400000,10 查询到的最后一条id是4000000，那么下一页的查询只需要查询id大于400000的10条数据即可。 语句： 1explain select * from user where id &gt; 4000000 limit 10; BETWEEN … AND 1select * from user where id BETWEEN 4000000 and 4000010 分表查询 mysql推荐一张表的存储不要超过500w数据，查询400w不到1秒对于一般的查询来说已经可以了，如果还要更快的话，我建议使用分表存储，分表又分两种情况，水平分表于垂直分表。 延迟关联（个人推荐） 1select * from table a,(select id from table limit 100000,20) b on a.id=b.id 1. SQL优化手段有哪些？ 查询语句中不要使用select 尽量减少子查询，使用关联查询（left join,right join,inner join）替代 减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代(在确认没有重复数据或者不用剔除重复数据时，union all会更好) 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 2.请问如何防止SQL被注入？ 什么是SQL注入？ 攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。 例如：用户登录，攻击者输入：用户名 = liangzone，密码 = ‘ or ‘1’=’1 ，那么拼接后的语句是： 1select * from user where name = ‘lianggzone’ and password = ‘’ or ‘1’=‘1’ 攻击者就可以查询出所有的用户表信息！ 如何防范SQL注入？ Web端：1）有效性检验； 2）限制字符串输入的长度 服务器端：1）不用拼接SQL字符串， 2）使用预编译的PrepareStatement， 3）有效性检验，4）过滤SQL需要的参数中的特殊字符，比如单引号、双引号。 3. MySQL 如何做到高并发解决方案？ 在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。 增加数据库索引，进而提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢） 主从读写分离分库，让主服务器负责写，从服务器负责读。 将数据库表进行拆分表，使得数据库的表尽可能小，提高查询的速度。 使用分布式架构，分散计算压力。 4. 大表如何进行优化？ 当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，⼀些常⻅的优化措施如下。 限定数据的范围：务必禁⽌不带任何限制数据范围条件的查询语句。⽐如：我们当⽤户在查询订单历史的时候，我们可以控制在⼀个⽉的范围内； 读/写分离：经典的数据库拆分⽅案，主库负责写，从库负责读； 垂直分区：根据数据库⾥⾯数据表的相关性进行拆分。 例如，⽤户表中既有⽤户的登录信息⼜有⽤户的基本信息，可以将⽤户表拆分成两个单独的表，甚⾄放到单独的库做分库。 简单来说垂直拆分是指数据表列的拆分，把⼀张列⽐较多的表拆分为多张表。 水平分区 : 保持数据表结构不变，通过某种策略存储数据分⽚。这样每⼀⽚数据分散到不同的表或者库中，达到了分布式的⽬的。 ⽔平拆分可以支撑⾮常大的数据量。 其它数据库结构方面优化： 范式优化： 比如消除冗余（节省空间。。） 反范式优化：比如适当加冗余等（减少join） 5. 数据库如何去重？ 参考：MySQL数据库行去重复和列去重复 5.1 行去重 存在行重复，则无法建立 唯一索引 等。 用distinct 得到我们要保留的数据也是可以的。 下面假设的是email字段重复。 查看我们的分组后 1select *,count(id) from demo_table group by email having count(id)&gt;1 order by id; 执行结果： 12345678910+----+------+--------------+-----------+| id | name | email | count(id) |+----+------+--------------+-----------+| 1 | u1 | u1@email.com | 4 || 2 | u2 | u2@email.com | 4 || 3 | u3 | u3@email.com | 3 || 4 | u4 | u4@email.com | 2 || 5 | u5 | u5@email.com | 2 |+----+------+--------------+-----------+5 rows in set (0.00 sec) 保留每个分组最小的id，表中其余都删除 在表中删除不符合要求的数据： 1delete from demo_table where id not in (select min(id) from demo_table group by email); 但是似乎有保护机制，无法直接删除： 1ERROR 1093 (HY000): You can&#x27;t specify target table &#x27;demo_table&#x27; for update in FROM clause 创建临时表再删除 12345678# 创建临时表保存每个分组中最小的那个idcreate table tmp_table as select min(id) from demo_table group by email;# 删除表中数据delete from demo_table where id not in (select * from tmp_table);# 删除临时表drop table tmp_table; 5.2 列重复 先找到重复字段的行 1select * from demo_table as a, demo_table as b where a.id=b.id and a.name=b.email; 执行结果： 12345678910+----+--------------+--------------+----+--------------+--------------+| id | name | email | id | name | email |+----+--------------+--------------+----+--------------+--------------+| 31 | 31@email.com | 31@email.com | 31 | 31@email.com | 31@email.com || 32 | 32@email.com | 32@email.com | 32 | 32@email.com | 32@email.com || 33 | 33@email.com | 33@email.com | 33 | 33@email.com | 33@email.com || 34 | 34@email.com | 34@email.com | 34 | 34@email.com | 34@email.com || 35 | 35@email.com | 35@email.com | 35 | 35@email.com | 35@email.com |+----+--------------+--------------+----+--------------+--------------+5 rows in set (0.00 sec) 重复记录的id都已经找出来了，删除就参考上述方式处理了。 6. select慢的原因？慢查询的优化策略？ 6.1 select 很慢的原因 参考：腾讯面试：一条SQL语句执行得很慢的原因有哪些? 如果是偶尔很慢 针对这种情况，这条SQL语句的书写本身是没什么问题的。可能是其它原因导致： 被加锁。 要执行的这条语句，刚好这条语句涉及到的表，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了；或者，表没有加锁，但要使用到的某个一行被加锁了 。 数据库在刷新脏页 ？ 看链接，不太明白流程。 如果是经常很慢 没用到索引 索引失效了 ： （1）联合索引不满足最左匹配（不包含第一个索引）； （2）like语句不满足最左匹配（不包含第一个索引） （3）或者索引加上了运算 1select * from t where c - 1 = 1000; 这种情况不会有效，应该是： 1select * from t where c = 1000 + 1; （4）或者函数操作用上索引 1select * from t where pow(c,2) = 1000; 数据库使用非聚簇索引 我们在进行查询操作的时候，例如： 1select * from t where 100 &lt; c and c &lt; 100000; 此时使用的非聚簇索引（辅助索引），只是存储了主键的key ，还是要再次通过聚簇索引去查找。效率可能不必全表扫描高。 7. select…for update用法？ 数据库-MySQL中for update的作用和用法 for update是一种行级锁，又叫排它锁。 一旦用户对某个行施加了行级加锁，则该用户可以查询也可以更新被加锁的数据行，其它用户只能查询但不能更新被加锁的数据行。 123456-- 开启事务begin;SELECT * FROM user WHERE id=3 FOR UPDATE;SELECT * FROM user WHERE id=3 and name=&#x27;Tom&#x27; FOR UPDATE;-- 提交事务commit; 8. 场景题：假如选择MySQL数据库，一天五万条增量，运维三年，有哪些优化手段？ 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率； 选择合适的表字段数据类型和存储引擎，适当的添加索引； MySQL库主从分库读写分离； 找规律分表，减少单表中的数据量提高查询速度； 添加缓存机制，比如Memcached，Apc等； 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE。","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://hwh.zone/tags/MySQL/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"数据库","permalink":"https://hwh.zone/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"校招笔记（四）_计算机基础_操作系统","slug":"校招笔记（四）_计算机基础_操作系统","date":"2021-11-26T12:55:27.544Z","updated":"2021-11-26T16:30:32.159Z","comments":true,"path":"2021/11/26/校招笔记（四）_计算机基础_操作系统/","link":"","permalink":"https://hwh.zone/2021/11/26/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 🚩 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 四、操场系统 4.1 操作系统基础 0. （百度安全一面） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？ 存储器：内存 控制器：南桥北桥 运算器：CPU 输入设备：键盘 输出设备：显示器、网卡 1. 什么是操作系统？ 操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基⽯； 操作系统本质上是运行在计算机上的软件程序 ； 操作系统为用户提供⼀个与系统交互的操作界面 ； 操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。 2. 什么是系统调用呢？ 能不能详细介绍⼀下？ 根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别： 用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。 系统态(kernel mode)：可以简单的理解系统态运行的进程或程序⼏乎可以访问计算机的任何资源，不受限制。 我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！ 这些系统调用按功能大致可分为如下⼏类： 设备管理。完成设备的请求或释放，以及设备启动等功能。 ⽂件管理。完成⽂件的读、写、创建及删除等功能。 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。 进程通信。完成进程之间的消息传递或信号传递等功能。 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。 3. CentOS 和 Linux的关系？ Linux意思较广广义的范围，多指是Linux内核。CentOS是RedHat的一个分支，RedHat是Linux的一个发行版本，RedHat与CentOS的区别在于，RedHat收费，CentOS免费。 4. 什么是分布式，优缺点？集群？ 分布式 根据业务需求进行拆分成N个子系统，多个子系统相互协作才能完成业务流程子系统之间通讯使用RPC远程通讯技术。 集群 同一个工程部署在多个不同的服务器上。 分布式优点 1.把模块拆分，使用接口通信，降低模块之间的耦合度。 2.把项目拆分成若干个子项目，不同的团队负责不同的子项目。 3.增加功能时只需要再增加一个子项目，调用其它系统的接口就可以。 4.可以灵活的进行分布式部署。 分布式缺点 1.系统之间交互需要使用远程通信，接口开发增加工作量。 2.各个模块有一些通用的业务逻辑无法共用。 5. 在Linux/windows栈空间的大小？ Linux环境下由操作系统决定，一般是8KB ， 通过ulimit命令查看以及修改 在Linux下通过如下命令可查看和设置栈的大小： 12$ ulimit -a # 显示当前栈的大小 （ulimit为系统命令，非编译器命令） $ ulimit -s 32768 # 设置当前栈的大小为32MCopy to clipboardErrorCopied Windows环境下由编译器决定，VC++6.0一般是1M \\ Windows平台下栈的大小是被记录在可执行文件中的（由编译器来设置)，即：windows下可以由编译器决定栈大小，而在Linux下是由系统环境变量来控制栈的大小的。 6. ASCII、Unicode和UTF-8编码的区别？ ASCII : ASCII 只有127个字符，表示英文字母的大小写、数字和一些符号 ； 常用中文需要两个字节，且不能和ASCII冲突，中国定制了GB2312编码格式。 Unicode： Unicode就是将不同语言统一到一套编码格式中，通常两个字节表示一个字符，而ASCII是一个字节表示一个字符 ； 如果你编译的文本是全英文的，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。 UTF-8 : 把Unicode编码转化为 “可变长编码” UTF-8编码，UTF-8编码将Unicode字符按数字大小编码为1-6个字节，英文字母被编码成1个字节，常用汉字被编码成2个字节。 6.1 三者区别和联系 在计算机内存中，统一使用Unicode编码 ； 当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码 举例说明： 例1 ：记事本编辑（内存）→保存（磁盘）。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。 例2：网络传输服务器→浏览器。 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。 7. 什么是并发和并行？同步和异步？ 并发和并行 并发： 是指宏观上在一段时间内能同时运行多个程序； 并行 ：则指同一时刻能运行多个指令。 同步和异步 同步：可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。 异步：执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 8. 什么是共享？ 共享定义： 系统中的资源可以被多个并发进程共同使用 ； 共享方式：互斥共享和同时共享： 互斥共享： 在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问 ，如：打印机。 4.2 进程和线程 1.请问64位和32位的区别？ 运行能力不同：64位可以一次性可以处理8个字节的数据量，而32位一次性只可以处理4个字节的数据量，因此64位比32位的运行能力提高了一倍。 内存寻址不同：64位最大寻址空间为2的64次方，理论值直接达到了16TB，而32位的最大寻址空间为2的32次方，为4GB，换而言之，就是说32位系统的处理器最大只支持到4G内存，而64位系统最大支持的内存高达亿位数。 运行软件不同：由于32位和64位CPU的指令集是不同的。所以需要区分32位和64位版本的软件。 为了保证兼容性，64位CPU上也能运行老的32位指令，但反过来32位系统不可以运行64位的软件。 2.介绍一下线程和进程的区别？ 根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小 包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程 内存分配：同一进程的线程共享本进程的【地址空间和资源】，而进程之间的地址空间和资源是相互独立的 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉，所以多进程要比多线程健壮。 线程没有独立的地址空间，如果崩溃，会发信号，如果没有错误处理的handler，OS一般直接杀死进程。 能否独立：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行 2.1 线程和协程之间的区别？ 进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序 ; 线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，和多个线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束； 协程是用户态的轻量级线程，也是线程内部调度的基本单位 。 协程和线程的区别如下（补充了和进程的区别，方便对比）。 进程 线程 协程 定义 资源分配和拥有的基本单位 程序执行的基本单位 用户态的轻量级线程，线程内部调度的基本单位 切换情况 进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置 保存和设置程序计数器、少量寄存器和栈的内容 先将寄存器上下文和栈保存，等切换回来的时候再进行恢复 切换者 操作系统 操作系统 用户 切换过程 用户态-&gt;内核态-&gt;用户态 用户态-&gt;内核态-&gt;用户态 用户态(没有陷入内核) 调用栈 内核栈 内核栈 用户栈 拥有资源 CPU资源、内存资源、文件资源和句柄等 程序计数器、寄存器、栈和状态字 拥有自己的寄存器上下文和栈 并发性 不同进程之间切换实现并发，各自占有CPU实现并行 一个进程内部的多个线程并发执行 同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理 系统开销 切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大 切换时只需保存和设置少量寄存器内容，因此开销很小 直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快 通信方面 进程间通信需要借助操作系统 线程间可以直接读写进程数据段(如全局变量)来进行通信 共享内存、消息队列 2.2 一个进程可以创建多少个线程，和什么有关？ 一个进程可用虚拟空间是（C++）2G，默认情况下，（假设）线程的栈的大小是1MB（Linux是8kb），则理论上最多只能创建2048个线程。如果要创建多于2048的话，必须修改编译器的设置。 2.3 进程之间的同步方式？（区分通信方式） 临界区。 对临界资源进行访问的那段代码称为临界区。 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。 同步和互斥。 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。 互斥：多个进程在同一时刻只有一个进程能进入临界区。 信号量。 常见的 P 和 V 操作。 特别的，如果信号量的取值只能为 0 或者 1，那么就成为了互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。 条件变量。 使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。 管程引入了条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。 123456789101112131415161718192021222324252627282930313233343536373839404142// 管程：解决生产者、消费者问题monitor ProducerConsumer condition full, empty; integer count := 0; condition c; procedure insert(item: integer); begin if count = N then wait(full); insert_item(item); count := count + 1; if count = 1 then signal(empty); end; function remove: integer; begin if count = 0 then wait(empty); remove = remove_item; count := count - 1; if count = N -1 then signal(full); end;end monitor;// 生产者客户端procedure producerbegin while true do begin item = produce_item; ProducerConsumer.insert(item); endend;// 消费者客户端procedure consumerbegin while true do begin item = ProducerConsumer.remove; consume_item(item); endend; 3.请问【进程】之间如何进行通信？ 可以分为如下两个方面： 本地进程之间的通信方式 远程进程之间的通信方式 1. 本地进程之间的通信方式（没有同步互斥！！） 无名管道 ：半双工通信方式，数据(消息)单向流动，只能是字节流格式的消息。 优点：简单方便 缺点：单向通信、只能用于具有亲缘关系（一般指父子）的进程之间、缓冲区有限 有名管道：半双工通信方式，数据也称为命名管道：是一种文件类型，以一种特殊设备文件形式存在于文件系统中。 优点：可以实现任意关系的进程间的通信（无法同步） 缺点： 长期存于系统中，使用不当容易出错、缓冲区有限 消息队列：消息队列是消息的链表,存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少,管道只能承载无格式字节流以及缓冲区大小受限等特点。 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题 缺点：信息的复制需要额外消耗CPU的时间，不适宜于信息量大或操作频繁的场合 共享内存 直接对内存存取，通信快，但是多个进程可以同时操作，需要用信号量进行同步。 信号量 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 优点：可以同步进程； 缺点：信号量有限 注解：P操作就是对S减一，V操作就是对S加一 同步：S = 0，进程A执行完进行V操作，进程B执行前执行P操作，这样B就可以等A执行完再执行； 互斥：S = 1，进程执行前进行P操作，执行后进行V操作。 2.远程进程之间的通信方式 首要解决的问题是如何唯一标识一个进程？本地上采用PID即可，但是网络中 TCP/IP五层网络模型中传输层的 “套接字：IP+端口” 套接字交互 优点：1）传输数据为字节级，传输数据可自定义，数据量小效率高；2）传输数据时间短，性能高；3) 适合于客户端和服务器端之间信息实时交互；4) 可以加密,数据安全性强 缺点：1) 需对传输的数据进行解析，转化成应用级的数据。 远程过程调用（RPC） 4. 请问【线程】间同步方式（通信方式）？ 【1. Linux下线程通知方式】 互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有⼀个，所以可以保证公共资源不会被多个线程同时访问。 ⽐如 Java 中的synchronized 关键词和各种 Lock锁 都是这种机制。 信号量(Semphares) ：它允许同⼀时刻多个线程访问同⼀资源，但是需要控制同⼀时刻访问此资源的最大线程数量 条件变量 : 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级 比如Wait/Notify 【2. Windows下线程通知方式】 全局变量：需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防编译器对此变量进行优化 ； CEvent对象：CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法； Message消息机制：常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。 5.什么时候用多线程 / 多进程？ 需要频繁创建销毁的优先用线程 ：创建和销毁的代价是很难承受的 ； 需要进行大量计算的优先使用线程 ：此时耗费很多CPU，切换频繁，用线程更轻量； 任务间相关性比较强的用多线程，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单； 考虑多进程： 扩展到多机分布的用多进程，多核分布的用多线程 ； 其它一般用多线程比较好 6.【线程】调度算法？ 在资源一定的情况下，调度算法需要在吞吐量（Throughput）、平均响应时间（延迟，Average Response Time）、公平性、调度引起的额外开销（overhead）等几个方面做权衡。 先进先出算法（FIFO，First-In-First-Out） 优点： 最少的任务切换开销（因为没有在任务执行过程中发生切换，故任务切换开销为0） 最大的吞吐量（因没有任务切换开销，在其他一定的情况下，吞吐量肯定是最大的） 最朴实的公平性（先来先做） 缺点： 平均响应时间高：耗时只需10毫秒的任务若恰巧在耗时1000毫秒的任务后到来，他则需要1010毫秒才能执行完成，绝大部分时间都花在等待被调度。 最短耗时任务优先算法 优先调度耗时短的任务，需要预先知道每个任务的耗时情况，这在实际情况中是不大现实的。 （优点）平均响应时间较低：这里有一点，因为将时间长的任务无限往后推移，实际计算的平均响应时间的任务都是执行较快的任务，统计出来的平均响应时间必然较低的。 （缺点）耗时长任务饥饿：耗时长的任务迟迟得不到调度，不公平，容易形成饥饿 。 （缺点）开销大：频繁的任务切换，调度的额外开销大。 时间片轮转算法 给队列中的每个任务一个时间片，第一个任务先执行，时间片到了之后，将此任务放到队列尾部，切换到下个任务执行，解决最短耗时任务优先算法中耗时长任务饥饿的问题 。 （特点）时间片设置问题： 算法介于FIFO和SJF之间，若时间片足够大，则退化到FIFO ；若分片足够小（假设不考虑任务切换的开销），则任务的完成时间顺序是以耗时从小到大排列。 （优点）公平调度：每个任务都能够得到公平的调度 （优点）不会饥饿：耗时短的任务即使落在耗时长的任务后面，也能够较快的得到调度执行 （缺点）开销大：任务切换引起的调度开销较大，需要多次切换任务上下文 （缺点）时间片不太好设置 最大最小公平算法 7.【进程】调度算法？ 先来先服务调度算法 短作业(进程)优先调度算法 时间片轮转法 多级反馈队列调度算法 优先权调度算法 8. CPU上下文切换？有什么类型？线程发生在什么地方？ 参考：https://zhuanlan.zhihu.com/p/52845869 什么是 CPU 上下文 ？ CPU 寄存器和程序计数器 就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前，必须的依赖环境。 CPU 寄存器 是 CPU 内置的容量小、但速度极快的内存。 什么是 CPU 上下文切换? 通常指以下过程： 前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来; 然后加载新任务的上下文到这些寄存器和程序计数器; 最后再跳转到程序计数器所指的新位置，运行新任务。 CPU 上下文切换的类型？ 根据任务的不同，可以分为以下三种类型 : 进程上下文切换 - 线程上下文切换 - 中断上下文切换 。 进程上下文切换 进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。 内核空间（Ring 0）具有最高权限，可以直接访问所有资源； 用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。 从用户态到内核态的转变，需要通过系统调用来完成，在这个过程中就发生了 CPU 上下文切换（两次，用户态-内核态-用户态））。 系统调用 : 查看文件时read()、wirte() 操作就发生了系统调用。 但是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。 而进程上下文切换 ，比系统调用时多了一步：在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来。 线程上下文调用 线程是调度的基本单位，而进程则是资源拥有的基本单位。 【面试高频】发生线程上下文切换的场景 前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。 前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据（栈、寄存器等)不共享的数据 中断上下文切换 9.如何杀死一个进程？进程终止的方式？ linux命令：kill -9 &lt;pid&gt; 接受能导致进程终止的信号：ctrl+c (^C)、SIGINT(SIGINT中断进程) main函数的自然返回，return 调用exit函数，属于c的函数库 3、调用_exit函数，属于系统调用 调用abort函数，异常程序终止，同时发送SIGABRT信号给调用进程 9.1 终端退出，终端运行的进程会怎么样？ 终端在退出时会发送SIGHUP给对应的bash进程， bash进程收到这个信号后首先将它发给session下面的进程 一个session就是一个shell终端会话窗口。 如果程序没有对SIGHUP信号做特殊处理，那么进程就会随着终端关闭而退出 9.2 怎么让进程后台运行？ 命令 + &amp; 即可，实际上，这样是将命令放入到一个作业队列中了 ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程 nohup + &amp;，将标准输出和标准错误缺省会被重定向到 nohup.out 文件中，忽略所有挂断（SIGHUP）信号 setsid + 命令，使其父进程编程init进程，不受HUP信号的影响 将命令+ &amp;放在()括号中，也可以是进程不受HUP信号的影响 10. 外中断和异常的区别？ 外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。 异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。 11. 什么是父进程、子进程、进程组、作业和会话？ 父进程： 已创建一个或多个子进程的进程 ； 子进程： 由fork创建的新进程被称为子进程（child process），函数被调用一次，但返回两次； fork之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系： （1）它们共享代码空间，（2）数据空间是互相独立的，但子进程数据空间中的内容是父进程的完整拷贝，（3）指令指针也完全相同，（4）子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同）。 除了：fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号pid 。 进程组： 进程组就是多个进程的集合，其中肯定有一个组长，其进程PID等于进程组的PGID ； 作业： shell分前后台来控制的不是进程而是作业（job）或者进程组（Process Group）。 一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，shell可以运行一个前台作业和任意多个后台作业，这称为作业控制。、 会话。 一个或多个进程组的集合，一个会话可以有一个控制终端。在xshell或者WinSCP中打开一个窗口就是新建一个会话。 12. 什么是守护进程、僵尸进程、孤儿进程？ 参考：Linux 之守护进程、僵死进程与孤儿进程 守护进程 在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。 举例：常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。 一个守护进程的父进程是init进程，也是一个孤儿进程 ，一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。 孤儿进程 一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 僵尸进程 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息（子进程必须等到父进程捕获到了子进程的退出状态才真正结束），那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。 11.1 如何避免僵尸进程？ 通过signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收； 如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN); 表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。 父进程调用wait/waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞； waitpid可以通过传递WNOHANG使父进程不阻塞立即返回。 如果父进程很忙可以用signal注册信号处理函数，在信号处理函数调用wait/waitpid等待子进程退出; 通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等待回收。 4.3 socket编程 暂略 4.4 内存管理 1.介绍一下操作系统的堆和栈？ 栈内存：栈内存首先是一片内存区域，存储的都是局部变量，栈内存的更新速度很快，因为局部变量的生命周期都很短。 局部变量：方法内的变量，for循环内部定义的也是局部变量等。 堆内存：存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象）。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。 1.1 什么时候会栈溢出？ 栈能使用的内存是有限的，一般是 1M~8M，这在编译时就已经决定了，程序运行期间不能再改变。 如果程序使用的栈内存超出最大值，就会发生栈溢出（Stack Overflow）错误，程序就崩溃了； 一般常见的情况，如递归过深 2. 介绍一下什么内存管理？常用的内存管理机制？ 内存管理 操作系统的内存管理主要负责内存的（1）分配与回收（malloc 函数：申请内存，free 函数：释放内存），（2）另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。 常用内存管理机制 简单分为连续分配管理方式和非连续分配管理方式这两种。连续分配管理方式是指为⼀个用户程序分配⼀个连续的内存空间，常见的如块式管理 。同样地，非连续分配管理方式允许⼀个程序使用的内存分在离散或者说不相邻的内存中，常见的如页式管理 和 段式管理。 块式管理 ： 远古时代的计算机操系统的内存管理方式。将内存分为⼏个固定大小的块，每个块中只包含⼀个进程。如果程序运行需要内存的话，操作系统就分配给它⼀块，如果程序运行只需 要很小的空间的话，分配的这块内存很大⼀部分⼏乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。 页式管理 ：把主存分为大小相等且固定的⼀页⼀页的形式，页较小，相对相⽐于块式管理的划分⼒度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。 段式管理 ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。段式管理把主存分为⼀段段的，每⼀段的空间⼜要⽐⼀页的空间小很多 。 但是，最重要的是段是有实际意义的，每个段定义了⼀组逻辑信息，例如，有主程段 MAIN、子程序段 X、数据段 D及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。 段页式管理机制 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲页，也就是说 段页式管理机制中段与段之间以及段的内部的都是离散的。 2.1 介绍一下逻辑地址和物理地址？ 我们编程⼀般只有可能和逻辑地址打交道，⽐如在 C 语⾔中，指针⾥面存储的数值就可以理解成为内存⾥的⼀个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。 物理地址指的是真实物理内存中地址，更具体⼀点来说就是内存地址寄存器中的地址。 2.2 操作系统在内存管理需要做什么？ 内存空间的分配与回收； 从逻辑上对内存空间进行扩充； 逻辑地址与物理地址的转换； 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。 3. 介绍一下快表和多级页表？ 在分页内存管理中，很重要的两点是： 虚拟地址到物理地址的转换要快。 解决虚拟地址空间大，页表也会很大的问题。 快表介绍 快表理解为⼀种特殊的高速缓冲存储器（Cache），其中的内容是页表的⼀部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。 但有时快表不命中要访问两次缓存，不过总体还是提高了性能。 多级页表介绍 引⼊多级页表的主要⽬的是为了 避免把全部页表⼀直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景。 4. 分页机制和分段机制的共同点和区别 ？ 共同点 ： 分页机制和分段机制都是为了提高内存利用率，较少内存碎片。 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。 区别 ： 页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。 分页仅仅是为了满⾜操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满⾜用户的需要。 5. 【待扩充】CPU 寻址了解吗?为什么需要虚拟地址空间? 现代处理器使用的是⼀种称为 虚拟寻址(Virtual Addressing) 的寻址⽅式。使用虚拟寻址，CPU 需要虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有⼀个被称为 内存管理单元（Memory Management Unit, MMU） 的硬件。 如果直接把物理地址暴露出来的话会带来严重问题，⽐如可能对操作系统造成伤害以及给同时运行多个程序造成困难。 6. 如果系统中具有快表后，那么地址的转换过程变成什么样了？ 简单来说：cup计算页号 → 快表查询是否有该页号 → 否则页表查询 计算页号和页偏移量。 CPU给出逻辑地址，由某个硬件算得页号、页内偏移量； 快表中查找内存块号。 将页号与快表中的所有页号进行比较，如果找到匹配的页号，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址； 页表中查找内存块号。 如果快表中查找不存在，访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。 7. 进程内存分配动态分区算法？ 首次适应法。 算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区； 实现方式：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分[表)，找到大小能满足要求的第-一个空闲分区。 优点： 综合性能最好，开销小。 最佳适应法。 算法思想：为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区； 实现方式： 空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 优点： 会有更多的大分区被保留下来，更能满足大进程需求 缺点： 产生很多太小的、难以利用的碎片，算法开销大 最坏适应法。 算法思想： 为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。 实现方式：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 优点： 可以减少难以利用的小碎片 缺点： 大分区容易被用完，不利于大进程，算法开销大 领近适应法。 算法思想： 首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。 实现方式：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始 ，查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 优点： 算法开销小 8. 什么是内存覆盖和内存交换？ 内存覆盖 思想： 把用户空间分成为一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。 特点：打破了必须将一个进程的全部信息装入内存后才能运行的限制 。 内存交换 思想： 内存空间紧张 时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存。 4.5 虚拟内存 0. 什么是虚拟技术 ？从时间和空间两方面来说。 虚拟技术把一个物理实体转换为多个逻辑实体 ： 时分复用技术 ： 如多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换 ； 空分复用技术： 物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。 1. 介绍一下局部性原理吧？ 局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装⼊部分程序到内存就开始运行。 局部性原理表现在以下两个⽅面： 时间局部性：如果程序中的某条指令⼀旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产⽣时间局部性的典型原因，是由于在程序中存在着大量的循环操作。 时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。 空间局部性：⼀旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在⼀段时间内所访问的地址，可能集中在⼀定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也⼀般是以向量、数组、表等形式簇聚存储的。 空间局部性通常是使用教大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。 虚拟内存技术实际上就是建⽴了 “内存⼀外存”的两级存储器的结构，利用局部性原理实现髙速缓存。 2.介绍一下，什么是虚拟内存？页式存储？ 虚拟内存 虚拟内存是一种存储机制，可为用户提供一个拥有很大主内存的错觉。通过将辅存的一部分作为主存来完成。在虚拟内存中，用户可以存储比可用主内存更大的进程。 每个进程创建加载的时候，会被分配一个大小为4G的连续的虚拟地址空间，仅仅是每个进程“认为”自己拥有4G的内存。等到进程真正运行的时候，需要某些数据并且数据不在物理内存中，才会触发缺页异常，进行磁盘数据拷贝到物理内存中 页式存储 大部分虚拟存储系统采用的是一种称为分页（paging）的技术。这种方式叫做虚拟页式存储管理。 物理内存空间划分为固定大小的内存块，称为物理页面，或者是页框（page frame） 虚拟地址空间也划分成大小相同的块，称为虚拟页面，或者简称页面（page） 页表：将虚拟页面映射为相应的物理页面。 3. 虚拟内存的技术实现 ？ 虚拟内存的实现需要建⽴在离散分配的内存管理⽅式的基础上。 虚拟内存的实现有以下三种⽅式： 请求分页存储管理 ：建⽴在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是⽬前最常用的⼀种实现虚拟存储器的⽅法。请求分页存储管理系统中，在作业开始运行之前，仅装⼊当前要执行的部分页即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调⼊到主存，同时操作系统也可以将暂时不用的页面置换到外存中。 请求分段存储管理：建⽴在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理⽅式就如同请求分页储存管理⽅式⼀样，在作业开始运行之前，仅装⼊当前要执行的部分段即可运行；在执行过程中，可使用请求调⼊中断动态装⼊要访问但⼜不在内存的程序段；当内存空间已满，而⼜需要装⼊新的段时，根据置换功能适当调出某个段，以便腾出空间而装⼊新的段。 请求段页式存储管理 4. 请你介绍一下页面置换算法？ 当发⽣缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择⼀个页面将其移出内存，以便为即将调⼊的页面让出空间。用来选择淘汰哪⼀页的规则叫做页面置换算法，我们可以把页 ⾯置换算法看成是淘汰页面的规则。 OPT （最佳页面置换算法）：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最⻓时间内不再被访问的页面,这样可以保证获得最低的缺页率。 但由于⼈们⽬前无法预知进程在内存下的若千页面中哪个是未来最⻓时间内不再被访问的，因⽽该算法无法实现。⼀般作为衡量其他置换算法的⽅法。 FIFO（First In First Out） （先进先出页面置换算法）: 总是淘汰最先进⼊内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。 LRU （Least Currently Used）（最近最久未使用页面置换算法）：LRU算法赋予每个页面⼀个访问字段，用来记录⼀个页面⾃上次被访问以来所经历的时间 T，当须淘汰⼀个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。 LFU （Least Frequently Used）（最少使用页面置换算法）: 该置换算法选择在前时期使用最少的页面作为淘汰页。 5.你怎么理解操作系统里的内存碎片，有什么解决办法？ 内存碎片分为：内部碎片和外部碎片。 内部碎片： 已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间； 内存泄漏：不再会被使用的对象的内存不能被回收 。 外部碎片： 还没有被分配出去（不属于任何进程），但由于太小了无法分配，给申请内存空间的新进程的内存空闲区域。 6. 什么是内存抖动？ 现象：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸； 原因： 程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够) ； 解决： 分配更多的物理块 4.6 并发和死锁 0. 介绍几种典型的锁？ 读写锁。 可以同时读，但写必须互斥，只允许一个写； 互斥锁。 一次只能一个线程拥有锁，其它只能等待； 条件变量： 互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定；而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足； 自旋锁。 如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。 1. 【重点】什么是线程死锁？什么情况下会发生死锁？解决死锁的策略有哪些？ 什么是死锁 死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。 发生死锁的条件 互斥：一个资源只能给一个进程使用； 占有并等待：进程持有资源并申请新资源，在申请到需要的资源之前，已有的资源不释放； 不可剥夺：进程申请到的资源在使用完之前，不可以被其他进程使用； 循环等待：各个进程的资源请求形成首尾连接循环等待。 解决方法：预防，避免，检测与恢复三种 预防：破坏死锁会发生的四个条件 破坏互斥：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的 破坏请求和保持：实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源； 破坏不剥夺条件 ：占用部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源； 破坏循环等待：资源分类标号，进行有序分配。 避免： 它不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配 安全序列：找到一种能让进程安全执行完的有序序列&#123;P1，P2，...，Pn&#125; 银行家算法：系统在为进程分配资源之前，首先计算此次资源分配的安全性，如果是安全的，则进行分配；如果这次分配会导致进入不安全状态，不进行分配。 恢复： 用资源分配图、进程等待图来协助这种检测出死锁，然后进行恢复。 系统重新启动，但代价很大 撤消参与死锁的全部或部分进程，剥夺资源 1.1 什么时候需要使用分布式锁？ 在单体应用的时候，如果多个线程要访问共享资源的时候，我们通常线程间加锁的机制，在某一个时刻，只有一个线程可以对这个资源进行操作，其他线程需要等待锁的释放，Java中也有一些处理锁的机制，比如synchronized。 而到了分布式的环境中，当某个资源可以被多个系统访问使用到的时候（例如，有多个客户端需要访问并操作同一个资源，还需要保持这个资源一致性的时候，就需要使用【分布式锁），为了保证大家访问这个数据是一致性的，那么就要求再同一个时刻，只能被一个系统使用，这时候线程之间的锁机制就无法起到作用了，因为分布式环境中，系统是会部署到不同的机器上面的，那么就需要【分布式锁】了。 2. （待补充）请你解释一下，通常系统CPU比较高是什么原因？ 首先查看是哪些进程的CPU占用率最高 3.说一下NIO，BIO，AIO区别? 参考：JAVaGuide 【BIO（同步阻塞）】 BIO：同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把 。 【NIO（同步非阻塞）】 NIO 本身是基于 事件驱动 的思想来实现的，其目的就是解决 BIO 的大并发问题： BIO 模型中，如果需要并发处理多个 I/O 请求，那就需要多线程来支持； IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。 【AIO（异步非阻塞）】 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型 。 AIO： 异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。 异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 0. 4. 【重点】介绍一下select，poll，epoll 原理？ 参考 select、poll、epoll的原理与区别 4.1 从阻塞I/O &amp; 非阻塞I/O说起 阻塞I/O 在linux中，默认情况下所有的socket都是阻塞的。 当用户进程调用了read()/recvfrom()等系统调用函数，它会进入内核空间中； 当这个网络I/O没有数据的时候，内核就要等待数据的到来，此时用户进程被阻塞； 当内核空间的数据准备好了，它就会将数据从内核空间中拷贝到用户空间； 用户进程才解除阻塞的的状态，重新运行读取数据。 非阻塞I/O linux下，可以通过设置socket使其变为非阻塞模式，这种情况下，当内核空间并无数据的时候，它会马上返回结果而不会阻塞。 当用户进程调用了read()/recvfrom()等系统调用函数，它会进入内核空间中； 如果内核空间中的数据还没有准备好，那么它并不会阻塞用户进程，而是立刻返回一个error； 对于应用进程来说，它发起一个read()操作后，并不需要等待，那么它可以再次调用read()/recvfrom()等函数； 当内核空间的数据准备好了，它就会将数据从内核空间中拷贝到用户空间； 用户进程才解除阻塞的的状态，重新运行读取数据。 多路复用I/O就是我们说的select，poll，epoll等操作，复用的好处就在于单个进程就可以同时处理多个网络连接的I/O，能实现这种功能的原理就是select、poll、epoll等函数会不断的轮询它们所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 4.2 select原理 更加深刻对比理解：Linux编程之select 1int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); select函数监视的文件socket描述符分3类，分别是writefds、readfds、和exceptfds； 调用后select函数会阻塞（不是线程），直到有描述符就绪（有数据 可read、可write、except、超时timeout），函数返回。 123456789101112131415&#123; select(socket); while(1) &#123; sockets = select(); // 还是要从内核拷贝到用户 for(socket in sockets) &#123; if(can_read(socket)) &#123; read(socket, buffer); process(buffer); &#125; &#125; &#125;&#125; 详细执行原理如下： 用户首先将需要进行IO操作的socket添加到select中，然后阻塞函数select（不是线程）等待系统调用返回； 当数据到达时，socket被激活，select函数返回，会唤醒其等待队列上睡眠的内核进程，即在socket可读写时唤醒，或者在超时后唤醒； 每次调用select查看fd，都需要把fd集合拷贝进行系统调用陷入内核态 。 返回select()函数的调用结果给用户进程，返回就绪socket描述符的数目，超时返回0，出错返回-1； 在select()函数返回后还是需要轮询去找到就绪的socket描述符的（将此前传入内核空间的fd_set拷贝到用户空间），此时用户进程才可以去操作socket； 进程调用read() / recvfrom() 读取数据 。 select优点： 从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。 那为什么还要使用select？ 使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的； 而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。 select缺点： 描述符数量：select支持的文件描述符数量太小了，默认是1024 ； 系统开销：每次调用select都需要把fd集合拷贝进行系统调用陷入内核态，这个开销在fd很多时会很大 ； 二次轮询：select需要二次查询拷贝所有文件描述fd_set进行遍历查看是否有描述符准备就绪。 4.3 poll原理 1234567int poll (struct pollfd *fds, unsigned int nfds, int timeout);struct pollfd &#123; int fd; /* file descriptor */ short events; /* requested events to watch */ short revents; /* returned events witnessed */&#125;; 不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd指针实现。 poll使用链表维护这些socket描述符，而select使用的是数组（位图）。 其他的都差不多和select()函数一样，poll()函数返回后，需要轮询pollfd来获取就绪的描述符，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。 poll缺点： 解决了selec第一个缺点（文件描述符数量太少），但是依旧存在后面两个缺点。 系统开销：每次调用poll都需要把fd集合拷贝进行系统调用陷入内核态，这个开销在fd很多时会很大 ； 二次轮询：poll需要二次查询拷贝所有文件描述fd_set进行遍历查看是否有描述符准备就绪。 4.3 epoll原理 1234567// epoll只有epoll_create()、epoll_ctl()、epoll_wait() 3个系统调用函数。int epoll_create(int size); int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); epoll_create 创建一个epoll文件描述符的epfd（或者称之为句柄）, epoll使用一个epfd文件描述符管理多个socket描述符。 当创建好epoll句柄后，它就是会占用一个fd值，必须调用close()关闭，否则可能导致fd被耗尽 。 epoll_ctl 该函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，以及删除事件。相关参数： 使用红黑树对监视的文件描述符进行：添加、修改、删除等。 epdf：由epoll_create()函数返回的epoll文件描述符（句柄）； op ： op是操作的选项，注册要监听的目标socket描述符fd到epoll句柄中 ；修改epoll句柄已经注册的fd的监听事件；从epoll句柄删除已经注册的socket描述符 ； fd：指定监听的socket描述符； event：事件 1234567891011typedef union epoll_data &#123; void *ptr; int fd; uint32_t u32; uint64_t u64;&#125; epoll_data_t;struct epoll_event &#123; uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */&#125;; epoll_wait() epoll_wait()函数的作用就是等待监听的事件的发生，类似于调用select()函数。 相关参数如下： 函数的返回值表示需要处理的事件数目，如返回0表示已超时。 events：用来从内核得到事件的集合。 maxevents ：告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的指定的size。 timeout：超时时间。 epoll高效运行过程 参考：彻底搞懂epoll高效运行的原理 执行epoll_create会在内核的高速cache区中建立一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。接着用户执行epoll_ctl 函数添加文件描述符会在红黑树上增加相应的结点。 select：创建3个文件描述符集并拷贝到内核中 ; poll：将传入的struct pollfd结构体数组拷贝到内核中进行监听。 调用epoll_wait 阻塞，等待可读事件； 内核在检测到满足条件的socket描述符会调用回调函数 ，回调函数将文件描述符放在就绪链表中 ； 而select/poll 都需要 ，遍历所有文件描述符fd_set 。 而执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，只需调用回调函数。 epoll_wait只用观察就绪链表中有无数据即可，最后将链表的数据返回给读写事件数组events &amp;返回就绪的数量，只用遍历events依次处理即可。 这里返回的文件描述符是通过mmap让内核和用户空间共享同一块内存实现传递的，减少了不必要的拷贝。 而select/poll 只返回socket就绪数目， 还需要将所有的文件描述符再次从内核→用户，遍历就绪的socket文件描述符。 4.4 select，poll，epoll 各自区别？ 不错的文章：https://www.codenong.com/cs105364662/ 相同点： select，poll，epoll 都是 IO 多路复用的机制（NIO？yes）； IO 多路复用的本质是通过一种机制，让单个进程可以监视多个描述符，当发现某个描述符就绪之后，能够通知程序进行相应的操作。 select，poll，epoll 都是同步 IO 。 不同点： IO 效率：（1）select 只知道有 IO 事件发生，却不知道是哪几个流，只能采取轮询所有流（ fd_set 集合）的方式，故其具有 O(n) 的无差别轮询复杂度，处理的流越多，无差别轮询时间就越长；（2）poll 与 select 并无区别，它的时间复杂度也是O(n)；（3）epoll 会将哪个流发生了怎样的 IO 事件通知我们（当描述符就绪时，系统注册的回调函数会被调用，将就绪描述符放到 readyList 里面），它是事件驱动的，其时间复杂度为 O(1)； 操作方式：select 和 poll 都是采取遍历的方式，而 epoll 则是采取了回调的方式； 底层实现：select 的底层实现为数组，poll 的底层实现为链表；而 epoll 的底层实现为红黑树； 最大连接数：select 的最大连接数为 1024 或 2048；而 poll 和 epoll 是无上限的； 对描述符的拷贝：select 和 poll 每次被调用时都会把描述符集合从用户态拷贝到内核态，而 epoll 在调用 epoll_ctl 时会拷贝进内核并保存，之后每次 epoll_wait 时不会拷贝； 性能：epoll 在绝大多数情况下性能远超 select 和 poll，但在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，因为 epoll 的通知机制需要很多函数回调 。 4.5 ET , LT 模式介绍？各自优缺点？ 参考：https://cloud.tencent.com/developer/article/1636224 边缘触发模式（Edge Trigger，ET），只有一个事件从无到有才会触发； 低电平 =&gt; 高电平 。 水平触发模式（Level Trigger，LT），一个事件只要有，就会一直触发。 低电平 =&gt; 高电平 ; 2. 处于高电平状态 举例说明 socket 的读事件 LT模式，只要 socket 上有未读完的数据，就会一直产生 EPOLLIN 事件； ET模式，socket 上每新来一次数据就会触发一次，如果上一次触发后，未将 socket 上的数据读完，也不会再触发，除非再新来一次数据。 对于 socket 写事件 LT模式，如果 socket 的 TCP 窗口一直不饱和，会一直触发 EPOLLOUT 事件； ET模式，只会触发一次，除非 TCP 窗口由不饱和变成饱和再一次变成不饱和，才会再次触发 EPOLLOUT 事件。 优缺点 使用 LT 模式，我们可以自由决定每次收取多少字节（对于普通 socket）或何时接收连接（对于侦听 socket），但是可能会导致多次触发； 使用 ET 模式，我们必须每次都要将数据收完（对于普通 socket）或必须理解调用 accept 接收连接（对于侦听socket），其优点是触发次数少。 5. 操作系统底层是怎么实现原子操作的？ 处理器使用基于对缓存加锁或总线加锁的方式，来实现多处理器之间的原子操作。 总线锁： 处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存； 总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据 缓存锁：相比总线锁，缓存锁即降低了锁的力度。核心机制是基于缓存一致性协议来实现的。 详细参考：JMM基础（总线锁、缓存锁、MESI缓存一致性协议、CPU 层面的内存屏障） 4.7 其它 1. 常见的磁盘调度算法？ 读写一个磁盘块的时间的影响因素有： 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上） 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上） 实际的数据传输时间 其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。 先来先服务。 按照磁盘请求的顺序进行调度。 优点：公平、简单； 缺点：未对寻道做任何优化，使平均寻道时间可能较长。 最短寻道优先。 优先调度与当前磁头所在磁道距离最近的磁道。 优点： 平均寻道时间比较低； 缺点：不公平，如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去。 电梯扫描算法。 电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。 优点： 性能较好，同时不会存在饥饿现象。 2. 服务器高并发的解决方案你知道多少？ 应用数据与静态资源分离：将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据； 客户端缓存 ：例如先生成静态页面，然后用ajax异步请求获取动态数据； 集群和分布式 ：使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度； 反向代理： 在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"操作系统","slug":"操作系统","permalink":"https://hwh.zone/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"校招笔记（三）_计算机基础_计算机网络","slug":"校招笔记（三）_计算机基础_计算机网络","date":"2021-11-26T12:53:16.543Z","updated":"2021-11-26T16:30:15.848Z","comments":true,"path":"2021/11/26/校招笔记（三）_计算机基础_计算机网络/","link":"","permalink":"https://hwh.zone/2021/11/26/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 🚩 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 三、计算机网络 3.1 ISO/OSI模型 和 TCP/IP 模型 1.请你简要介绍一下TCP/IP 五层协议 和 ISO/OSI七层协议？ 应用层：为用户的应用程序（如：电子邮件、文件传输和仿真终端）*提供网络服务； 表示层： 可以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取； 会话层： 通过运输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求； 运输层: 任务是为两台主机中进程之间的通信提供通用的*数据传输服务，传输的是报文段（tcp）/用户数据报（udp）； 复用：多个应用层进程可同时使用下面运输层的服务。 分用：运输层把收到的信息分别交付上面应用层中的相应进程。 网络层： 为主机间*提供通信服务。在发送数据时，网络层把运输层的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报 数据链路层（忘）： 两台主机通信，总是在一段一段的链路上传送的，这就需要需要专门的链路层的协议。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的*IP数据报组装成帧，在两个相邻结点间的链路上传送帧。每一帧包括数据和必要的控制信息。 物理层：主要作用是传入比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0），定义物理设备标准（例如网线的接口类型、光线的接口类型、各种传输介质的传输速率）。 2.请你简要介绍一下各层的协议？ 物理层：暂无 （快手）数据链路层：数据链路层主要是负责传输数据， PPP（点到点协议）：在点对点连接上传输多协议数据包提供了一个标准方法，PPP 最初设计是为两个对等节点之间的 IP 流量传输提供一种封装协议。这种链路提供全双工操作，并按照顺序传递数据包。 设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。 以太网（Ethernet)： CSMA/CD 协议： 冲突检测的载波监听多路访问技术(载波监听多点接入/碰撞检测)。 许多计算机以多点接入的方式连接在一根总线上，每个主机都必须不停地监听信道。发送前监听，如果忙则等待，如果空闲则发送。 若检测到信道有干扰信号，则表示产生了碰撞，于是就要停止发送数据，计算出退避等待时间，然后使用 CSMA 方法继续尝试发送。 网络层： 可参考 IP：网络协议，非常重要的中间层协议，TCP和UDP必须基于IP工作 ICMP：非常重要的中间层协议，用于在 IP主机、路由器 之间传递控制消息 IGMP：网络组消息协议，用来在IP主机和与其直接相邻的组播路由器之间建立、维护组播组成员 ARP：地址解析协议，建立IP→MAC地址映射表 RARP：反向地址解析协议，某个网络设备的MAC物理地址转换为IP地址 运输层:TCP(Transmission Control Protocol) 面向连接的，数据传输的单位是报文段，能够提供可靠的交付。 UDP(User Datagram Protocol) ：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付” 应用层：如支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议，DNS，POP3，SNMP，Telnet等等。 2.1 RARP 工作原理？ RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。 网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。 主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包； RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机； 主机收到RARP回应后，就使用得到的IP地址进行通讯。 3. 端口在哪一层？有效端口范围？ 端口在传输层。传输层以下的包封装过程： 数据报在传输层：加源端口号和目的端口号； 在网络层加上：源ip和目的ip ； 在数据链路层转化成：数据桢进行校验； 在物理层变成信号（电、光、等信号）发送出去。 UDP和TCP报头使用两个字节存放端口号，端口一共有一共有65535个。 知名端口号从0~1023，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口） ； 动态端口的范围是从1024~65535。 3.2 运输层 0. TCP报文头？UDP报文头？ 参考：IP、TCP、UDP报文头说明 TCP报文头 来源端口：向目标主机指明接入他的主机所使用的端口号 用于目标主机回应 目标端口：指明要连接的目标主机的端口号 从这也可以看书，端口占16bit，故范围是0~65535。 顺序号：数据包编号， 表明发送的数据包的顺序 。其值通常应该为上次发送包中的顺序号+1 ，若该数据包是整个TCP连接中的第一个包(SYN包) 则该值随意(通常随机) 确认号：通常该值是接受到的顺序号+1 ，若该数据包是整个TCP连接中的第一个数据包(SYN包) 则该值随意(通常为0) 首部长度：TCP头长度 。表明包好多少个32Bit 包括可选头(如果有) 值为TCP头大小除以4 ： 如：没有可选头TCP头为20字节 则该值为5 标志位： 紧急标志位(URG)：开启时表明此数据包处于紧急状态应该优先处理 确认标志位(ACK)：开启时表明确认号有效 否则忽略确认号 推送标志位(PSH)：开启时表明应该尽快交付给应用进程 而不必等到缓存区填满才推送 复位标志位(RST)：开启时表明TCP连接出现连接出现错误 数据包非法拒绝连接 同步标志位(SYN)：开启时表明一个连接的请求或者接受报文 终止标志位(FIN)：开启时表明释放一个连接 窗口大小：表示期望接受到的每个数据包字节数 校验和：该值为TCP报文头括数据部分中每16Bit的二进制反码求和 紧急指针：若指定该值 他应该是一个偏移量 该值加上顺序号表示紧急数据最后一个字节的顺序号 可选字段：包含最大载荷与窗口比例等信息 注：若使用该字段则长度必须为32Bit的倍数 不足则填充0 UDP报文 来源端口：向目标主机指明接入他的主机所使用的端口号 用于目标主机回应 目标端口：指明要连接的目标主机的端口号 数据包长度：UDP头和数据总长度字节数 检验和：该值为UDP报文头括数据部分中每16Bit的二进制反码求和 注：UDP检验和不是必须的 1. 请你说明一下，TCP协议的3次握手（进行连接）？ 参考：三次握手与四次挥手面试官想考我们什么？ TCP中，对确认ACK报文是不需要发送确认的 。 简略过程 ⚠️ SYN 和ACK报文是一起发的！！ 1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN©。此时客户端处于 SYN_Send 状态。 2、第二次握手：（⚠️ SYN+ACK是在一个包里发的！（字节一面） ）服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。 3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。 服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。 1.1 ISN （Initial Sequence Number）是固定的吗？ ISN作用 三次握手，其中一个重要功能是客户端和服务端交换 ISN，以便让对方知道接下来接收数据的时候如何按序列号组装数据。 ISN为什么不固定（还是不太理解） ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。 防止在网络中被延迟的分组在以后被重复传输，而导致某个连接的一端对它作错误的判断； 如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。 2.为什么要三次握手？ 1.用来确定服务端和客户端的发送能力是否正常； 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。 2.指定自己的初始化序列号，为后面的可靠传送做准备； 如果只有两次握手，那么客户端的起始序列号可以确认，服务端的起始序列号将得不到确认。 如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成。 2.1 三次握手可以携带数据吗？ 第一次、第二次握手不可以携带数据 ， 第三次可以携带数据： 对于第一次握手，不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。 如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，消耗服务器空间来接收数据； 对于第三次握手，客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，已经知道服务器的接收、发送能力正常，所以能携带数据。 3.请你说明一下，TCP协议的4次挥手（断开连接）？ 为什么不像三次握手一样执行三次即可？ 因为第二次和第三次对于被动方来说，意义是不一样的。 第二次是为了让主动方闭嘴（不再发挥手请求），自己该干嘛还是干嘛（但是自己可能还有数据美处理完）。 第三次是为了表示“我的活儿干完了，可以结束了”。 通常server接收到挥手的时候，手里还有活儿没做完。 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。 收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。 （1）客户端A发送一个FIN，报文中会指定一个序列号M，用来关闭客户A到服务器B的数据传送，此时客户端处于FIN_WAIT1状态； （2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号M+1。和SYN一样，一个FIN将占用一个序号，此时服务端处于 CLOSE_WAIT状态； （3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A和序列号N，此时服务端处于 LAST_ACK 的状态； （4）客户端A发回ACK报文确认，并将确认序号设置为收到序N+1，此时客户端处于 TIME_WAIT 状态，需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态；服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 3.1 为什么TCP四次挥手要基于全双工，不基于半双工呢？基于半双工可以改为三次挥手吗？ 半双工：同时只能有一端发送消息 ； 全双工：两端都可以随机接受/发送。 在四次挥手过程中，似乎C/S两端都是等待对方发送FIN/ACK，才会发送对应的ACK/FIN版本。同一时刻只有一方在发送消息，满足半双工。 但是，半双工模式效率会更低：比如C端（客户端）发送FIN报文请求关闭，但是S端（服务端）依旧可以同时发生数据 ，这个时候效率更高。 3.2（重点） 服务器出现大量close_wait的连接的原因是什么？有什么解决方法？ close_wait状态是在，TCP四次挥手的时候服务器收到FIN，但是没有发送自己的FIN时出现的。服务器出现大量close_wait状态的原因有两种： 服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法 服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收 处理方法： 停止应用程序 修改程序里的bug 4. 为什么要有TIME_WAIT 状态？为什么等待是2MSL？ 要确保服务器是否已经收到了客户端最后的ACK 报文，如果没有收到的话，服务器会重新发 FIN + ACK报文给客户端，客户端再次收到 FIN + ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。 确保之前连接的一些数据不在滞留在网络中：确保已经失效连接请求报文段不会再出现在本连接中，客户端发完最后一个ACK报文段后，再经过2MSL可以使得本连接中所有的报文段都从网络中消失。客户端就可以放心地释放TCP占用的资源、端口号，连接任何服务器。 如果客户端直接CLOSED，然后又再次向服务器发起一个新连接，有可能新、老连接的端口号一样的。假设新、老连接端口号一致，若老连接的一些数据仍滞留在网络中，这些滞留数据在新连接建立后才到达服务器，鉴于前后端口号一致，TCP协议就默认这些数据属于新连接，于是数据就这样乱成一锅粥了。 4.1 为什么是2MSL? MSL是报文在网络中最长生存时间，这是一个工程值(经验值)，不同的系统中可能不同 。 考虑最坏 情况，客户端A最后一次挥手发送给服务端B的ACK报文丢失了： ACK从最多经过1MSL会到达服务端，超过1MSL服务端会重发FIN 服务端重发的FIN最多经过1MSL到达A 所以为了确保，客户端能接收到服务端重发的FIN报文。 5. 【重点】请问TCP为什么要更可靠？哪种场景会有所应用？ 超时重传：当 TCP 发出⼀个报文段后，它启动⼀个定时器，等待⽬的端确认收到这个报⽂段。如果不能及时收到⼀个确认，将重发这个报⽂段； 数据排序：TCP有专门的序列号ISN字段，可提供数据re-order； 流量控制：滑动窗口和计时器的使用。TCP窗口中会指明双方能够发送接收的最大数据量； ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待对方确认。在收到确认后再发下⼀个分组。 拥塞控制：TCP的拥塞控制由4个核心算法组成。“慢启动”（Slow Start）、“拥塞避免”（Congestion avoidance）、“快重传 ”（Fast Retransmit）、“快恢复”（Fast Recovery）； 校验和： TCP 将保持它⾸部和数据的检验和。这是⼀个端到端的检验和，⽬的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报⽂段和不确认收到此报⽂段。 【应用场景】 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用 比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议 5.1 超时重传机制原理？ 基本原理：在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。 TCP中有四种计时器（Timer），分别为： 重传计时器：在滑动窗口协议中，接受窗口会在连续收到的包序列（连续ARQ）中的最后一个包向接收端发送一个ACK。当网络拥堵的时候，发送端的数据包和接收端的ACK包都有可能丢失。TCP为了保证数据可靠传输，就规定在重传的“时间片”到了以后，如果还没有收到对方的ACK，就重发此包，以避免陷入无限等待中。 坚持计时器：在滑动窗口协议中，当发送TCP收到窗口大小为0的确认ACK时，就坚持启动计时器。当坚持计时器期限到时，发送TCP就发送一个特殊的报文段，叫做探测报文。这个报文段只有一个字节的数据。他有一个序号，但他的序号永远不需要确认；甚至在计算机对其他部分的数据的确认时该序号也被忽略。探测报文段提醒接受TCP：确认已丢失，必须重传。 保活计时器：保活计时器使用在某些实现中，用来防止在两个TCP之间的连接出现长时间的空闲。假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远的处于打开状态。 通常设置为两小时。若服务器过了两小时还没有收到客户的信息，他就发送探测报文段。若发送了10个探测报文段（每一个像个75秒）还没有响应，就假定客户除了故障，因而就终止了该连接。 时间等待计时器：四次挥收后time waiter状态中使用。 5.2 介绍一下ARQ协议 ？ ⾃动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之⼀。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。 ARQ包括停⽌等待ARQ协议和连续ARQ协议。 停⽌等待ARQ协议。 停⽌等待协议是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待对方确认（回复ACK）。如果过了⼀段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下⼀个分组；在停⽌等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。 优点：简单 缺点：信道利用低，等待时间长 连续ARQ协议。连续 ARQ 协议可提高信道利用率。发送方维持⼀个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方⼀般采用累计确认，对按序到达的最后⼀个分组发送确认，表明到这个分组为⽌的所有分组都已经正确收到了。 优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。 缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 ⽐如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传⼀次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的N 个消息。 5.2 介绍一下连续ARQ协议滑动窗口和流量控制？ TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报⽂中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 5.3 介绍一下拥塞控制？ 为了进行拥塞控制，TCP 发送方要维持⼀个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让⾃⼰的发送窗口 == 取为拥塞窗口和接收方的接受窗口中较小的⼀个。 TCP的拥塞控制采用了四种算法： 慢开始： 慢开始算法的思路是当主机开始发送数据时，如果⽴即把大量数据字节注⼊到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测⼀下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过⼀个传播轮次RTT，cwnd加倍； 拥塞避免： 拥塞避免算法的思路是让拥塞窗⼝cwnd缓慢增大，即每经过⼀个往返时间RTT，就把发送放的cwnd加1； 快重传/快恢复： 区分快重传，连续ARQ中间丢失是Go back n。 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是⼀种拥塞控制算法，它能快速恢复丢失的数据包。如果接收机接收到⼀个【不按顺序】的数据段，它会⽴即给发送机发送⼀个重复确认（而不是等到自己发送数据时才捎带确认）。如果发送机接收到三个重复确认，它会假定确认指出的数据段丢失了，并⽴即重传这些丢失的数据段（而不必继续等待为该报文段设置的重传计时器的超时）。 5.4 如何区分流量控制和拥塞控制？ 流量控制属于通信双方协商，拥塞控制涉及通信链路全局； 流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。 6.如何提高客户端并发数？ 客户端建立的tcp数量受限于最大文件句柄数，一个连接就会建一个文件句柄，在linux 上默认是1024。 使用ulimit 可以修改最大进程数（最大为65535） 7.说说HTTP、TCP、Socket 的关系是什么？ TCP/IP 代表传输控制协议/网际协议，指的是一系列协议族； HTTP 本身就是一个协议，是从 Web 服务器和本地浏览器的超文本传送协议； Socket 是 TCP/IP 网络的 API ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。 8. 什么是半连接队列？泛洪攻击（DDos攻击的一种），以及解决策略 ？ 半连接队列 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。 已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。 泛洪攻击 在 TCP 的三次握手机制的第一步中，客户端会向服务器发送 SYN 报文段。 服务器接收到 SYN 报文段后会为该 TCP分配缓存和变量，如果攻击分子伪造大量不存在的IP地址，大量地往服务器发送 SYN 报文段，服务器的连接资源终将被耗尽，导致内存溢出无法继续服务。 当服务端接收到 SYN 后进入 SYN-RECV 状态，此时的连接称为半连接，同时会被服务端写入一个半连接队列。 想象一下，如果攻击者在短时间内不断的向服务端发送大量的 SYN 包而不响应，那么服务器的半连接队列很快会被写满，从而导致无法工作。 解决策略 设置验证机制：当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源 Id，目的 Id，端口号以及只有服务器自己知道的一个秘密函数生成一个 cookie，并把 cookie作为序列号响应 给客户端。 如果客户端是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段。接下来服务器会根据确认报文的源 Id，目的 Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1 等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源 。 防火墙过滤： 暂不了解具体 9.为什么DNS（域名解析）用UDP，而区域传送用TCP? DNS用UDP：客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。 区域传送用TCP： TCP协议可靠性好，TCP协议传输的内容大，而UDP最大只能传512字节。 10.说一下 TCP 粘包是怎么产生的？怎么解决粘包？ TCP粘包 TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。 客户端要发送原信息是A和B两个数据包，服务端接收到之后，可能出现如下情况： 正常情况：读取到了A和B两个数据包； 粘包：A和B两个数据包一起读取了； 拆包：读取了A数据包的一部分，A的另一部分和B数据包一起读取了。 TCP粘包原因 【发送方】TCP默认使用Nagle算法。客户端通过socket给服务端发送数据，为了传输更有效率，会将多次间隔较小的且数据量小的数据，通过nagle算法，合并成一个大的数据块，然后进行封包。这样做提高了效率，缺点就是你发送到服务端的数据，服务端不知道是不是完整的，不知道哪几小块数据拼起来才是原来的数据； 【接收方】来不及接收缓存区的包，导致多个包接收； TCP连接复用造成的粘包问题； 流量控制，拥塞控制也可能导致粘包。 解决粘包 解决问题的关键在于如何给每个数据包添加边界信息： Nagle算法问题导致的，需要结合应用场景适当关闭该算法； 发送端给每个数据包添加包 首部 ，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了； 数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开 ； 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。 11. TCP, UDP的区别？ UDP 在传送数据之前不需要先建立连接。远地主机在收到 UDP 报⽂后，不需要给出任何确认。虽然UDP 不提供可靠交付，但在某些情况下 UDP 确是⼀种最有效的⼯作方式（⼀般用于即时通信） ⽐如： QQ 语⾳、 QQ 视频 、直播等等 TCP 提供面向连接的服务。在传送数据之前必须先建⽴连接，数据传送结束后要释放连接。 TCP 不提供⼴播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握⼿来建⽴连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这⼀难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的⾸部增大很多，还要占用许多处理机资源。 TCP ⼀般用于⽂件传输、发送和接收邮件、远程登录等场景。 数据包： TCP是报文段，UDP是用户数据报。 应用场景 ： TCP用于一些需要可靠传输的场景； UDP则应用一些即时通信场景，不需要可靠传输的场景。 长度：UDP在DNS最长只能是512字节，TCP会更长。 3.3 网络层 1.请简单解释一下，ARP协议和ARP攻击? ARP协议：地址解析协议，建立IP/MAC地址映射表 ARP攻击： 2.什么是ICMP协议，它的作用是什么？ 用于在IP主机、路由器之间传递控制消息。 控制消息是指：网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。 3.请你讲一下路由器和交换机的区别？ 动态IP：路由器可以给你的局域网自动分配IP，虚拟拨号，就像一个交通警察，指挥着你的电脑该往哪走，你自己不用操心那么多了。交换机只是用来分配网络数据的。 路由器可以把一个IP分配给很多个主机使用，这些主机对外只表现出一个IP。交换机可以把很多主机连起来，这些主机对外各有各的IP。 寻址方式：路由器在网络层，路由器根据IP地址寻址，路由器可以处理TCP/IP协议，交换机不可以；交换机在中继层，交换机根据MAC地址寻址。 防火墙：路由器提供防火墙的服务，交换机不能提供该功能。集线器、交换机都是做端口扩展的，就是扩大局域网(通常都是以太网)的接入点，也就是能让局域网可以连进来更多的电脑。路由器是用来做网间连接，也就是用来连接不同的网络。 4.请解释ping命令过程？ 域名在DNS服务器查找IP地址； 通过Ping程序发送ICMP包； 同一网段的情况下，调用IP层的ARP协议请求广播（不同网段的情况下，交给路由器处理），查找目标主机的MAC地址； 目标主机ARP协议收到请求后，将本机MAC地址填充并发送ARP应答回到请求发送方； 请求发送方发送ICMP数据到目标主机； 目标主机响应ICMP包； 请求主机收到目标主机的ICMP响应包。 5. （补充介绍）介绍一下IPV6？一共多少位？ 源IP和目的IP地址都是，128（4*32）位（图中标识不清晰）！ 6. 介绍一下IP地址分类？C类哪些是保留地址？网络号全 0 全 1 ，主机号全 0 全1 分别什么含义？ IP地址分类 IP地址 == &#123;&lt;网络号&gt;，&lt;主机号&gt;&#125; A类： 第1位固定为0，网络号只有7位 。0（0000 0000）的IP地址是保留地址，意思是“本网络” ； 127（0111 1111）的IP地址也是保留地址，作为本地环回软件测试 。 特别的，主机号全1的是广播地址，它代表了网络全部的主机。 B类： 第1、2位固定为10，网络号有14位可以使用 。 B类地址网络号为128.0（1000 000 0000 0000）的IP地址是不指派的，所以可指派的网络号需要减一。 C类： 第1、2、3位固定为110，网络号有21位可以使用 。 （快手问）C类IP地址包含私有C类地址，范围从192.0.0.0 到223.255.255.255，其中私有C类地址范围从192.168.0.0 到192.168.255.255。 全0或者全1的含义 网络号全0：（1）如果主机号也为全0，那么此类ip地址可以当源端但不可以做目的端 （2）如果主机号不全为0，那么此类ip地址的使用和（1)相同，只是它代表的是网络上特定的主机 网络号全1：全1的网络号和任意的主机号组合当做回环地址来使用。 例如：127（0111 1111）的IP地址 主机号全0： 全为0，所得到的地址就是192.168.100.0，它是一个网络地址，代表的是一个网段； 主机号全1： 机号全1 代表的是广播地址，广播地址是不可以做源端的，但是可以做目的端。 3.4 应用层 1.请你谈谈DNS的寻址过程？ （1）检查浏览器缓存、检查本地hosts文件：是否有这个网址的映射，如果有，就调用这个IP地址映射，解析完成。 （2）如果没有，则查找本地DNS解析器缓存：是否有这个网址的映射，如果有，返回映射，解析完成。 本地dns服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动等。 （3）如果没有，则查找填写或分配的首选DNS服务器：称为本地DNS服务器。服务器接收到查询时： 如果要查询的域名包含在本地配置区域资源中，返回解析结果，查询结束，此解析具有权威性。 如果要查询的域名不由本地DNS服务器区域解析，但服务器缓存了此网址的映射关系，返回解析结果，查询结束，此解析不具有权威性。 （4）如果本地DNS服务器也失效： 如果未采用转发模式（迭代，从上至下）（1）本地DNS服务器就把请求发至13台根DNS，根DNS服务器收到请求后，会判断这个域名（如.com）是谁来授权管理，并返回一个负责该顶级域名服务器的IP，（2）本地DNS服务器收到顶级域名服务器IP信息后，继续向该顶级域名服务器IP发送请求，（3）该服务器如果无法解析，则会找到负责这个域名的下一级DNS服务器（如http://baidu.com）的IP给本地DNS服务器，循环往复直至查询到映射，（4）将解析结果返回本地DNS服务器，再由本地DNS服务器返回解析结果，查询完成。 如果采用转发模式（递归，从下至上）（1）则此DNS服务器就会把请求转发至上一级DNS服务器，（2）如果上一级DNS服务器不能解析，则继续向上请求，（3）最终将解析结果依次返回本地DNS服务器，本地DNS服务器再返回给客户机，查询完成。 1.1 怎么获取13台根服务器？ ping -R ? 抓包？ 1.2 解释一下DNS劫持和DNS污染？ 参考：什么是http劫持 ? 一、DNS劫持 DNS劫持某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，返回给用户一个错误的查询结果。 劫持过程 客户端发起域名请求到DNS解析服务器（一般是LocalDNS），但此时DNS解析服务器被攻击篡改； 被攻击篡改后的DNS解析服务器将请求转发给虚假服务器； DNS查询没有任何认证机制且基于UDP不可靠连接，因此很容易被篡改。 虚假服务器返回响应虚假信息给被攻击篡改后的DNS解析服务器（也可能直接不响应）； 解决办法 DNS劫持的本质是运营商的DNS解析服务器被攻击篡改 使用国外免费公用的DNS服务器解决。例如OpenDNS（208.67.222.222）或GoogleDNS（8.8.8.8） 直接使用ip进行访问 二、DNS污染 DNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。因为是不是劫持单个DNS服务器，而是监听所有的，所以个人比较难防范。 污染原理 通过对UDP端口53上的DNS查询进行入侵检测； 由于通常的DNS查询没有任何认证机制，而且DNS查询通常基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改。 一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。 解决办法 VPN代理或者域名远程解析的方法解决 通过修改Hosts，手动设置域名正确的IP地址 2. Forward和Redirect的区别？ 浏览器 URL 地址：Forward 是服务器内部的重定向，服务器内部请求某个 servlet，然后获取响应的内容，浏览器的 URL 地址不会变化；Redirect 是客户端请求服务器，然后服务器给客户端返回了一个302 状态码和新的 location，客户端重新发起 HTTP 请求，服务器给客户端响应 location 对应的 URL 地址，浏览器的 URL 地址发生了变化。 数据的共享：Forward 是服务器内部的重定向，request 在整个重定向过程中是不变的，request 中的信息在 servlet 间是共享的。Redirect 发起了两次 HTTP 请求分别使用不同的request。 请求的次数：Forward 只有一次请求；Redirect 有两次请求。 3.请你简单讲解一下，负载均衡反向代理模式的优点、缺点？ 联系实际：正反向代理、科学上网、VPN之间的关系 和翻墙基本原理（看他的其他文章补充） 【基本介绍】 反向代理（Reverse Proxy）：方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器； 优点： 网络络外部用户不能直接访问真实的服务器，具备额外的安全性 缺点： 反向代理是处于OSI参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反向代理服务器；限制了应用范围； 针对每一次代理，代理服务器就必须打开两个连接，一个对外，一个对内，因此在并发连接请求数量非常大的时候，代理服务器的负载也就非常大了，在最后代理服务器本身会成为服务的瓶颈。 反向代理负载均衡技术：是把将来自internet上的连接请求以反向代理的方式动态地转发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。 实现：apache mod_proxy、netscape proxy等，也可以在高速缓存器、负载均衡器等硬件设备上实现。 优点：可以将优化的 负载均衡策略和代理服务器的高速缓存技术结合在一起，提升静态网页的访问速度，提供有益的性能 缺点： 3.1 请解释下负载均衡的相关算法？ 不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。 给配置高、负载低的机器配置更高的权重，让其处理更多的请求； 给配置低、负载高的机器分配较低的权重，降低系统负载。 下面是几种比较相关的算法。 加权轮询算法 参考：加权轮询算法 基本定义 假设有 N 台实例 S = {S1, S2, …, Sn}，权重 W = {W1, W2, …, Wn} currentPos 表示当前选择的实例 ID，初始化为 -1； currentWeight 表示当前权重，初始值为 max(S)； max(S) 表示 N 台实例的最大权重值，gcd(S) 表示 N 台实例权重的最大公约数。 算法过程 从上一次调度实例起，遍历后面的每个实例； 若所有实例已被遍历过一次，则减小 currentWeight 为 currentWeight - gcd(S)，并从头开始遍历；若 currentWeight 小于等于 0，则重置为 max(S)； 直到 遍历的实例的权重 &gt;= currentWeight 时结束，此时实例为需调度的实例； 每次调度重复步骤 1、2、3； 算法实例 例如，上述 4 个服务，最大权重 max(S) 为 4，最大公约数 gcd(S) 为 1。其调度过程如下： 算法优缺点 优点： 相比 简单轮询 方式，通过权重进行分配，更加均匀 缺点：如下一个极端情况 服务实例 S = {a, b, c}，权重 W = {5, 1, 1}，使用加权轮询调度生成的实例序列为 {a, a, a, a, a, b, c}，那么就会存在连续 5 个请求都被调度到实例 a。 关于这点，可以采用 平滑加权轮询 调度算法 。 一致性哈希算法 负载均衡算法中的哈希算法，就是根据某个值生成一个哈希值，然后对应到某台服务器上去，即哈希环。 但是可能出现一种，哈希倾斜的情况：A负责的区域太大，B，C负责的小。这个时候采用虚拟节点去解决，这里不表。 3.2 DNS 负载均衡是什么策略？ 参考： 原理： 还是不太明白，DNS递归查询本身就是个负载均衡策略吧？多台服务器满足同一个查询服务？ 4.请说明一下http和https的区别？ https协议要申请证书到ca，需要一定经济成本； http是明文传输，https是加密的安全传输； （🚩*1）连接的端口不一样，http是80，https是443； http连接很简单，没有状态； https是ssl加密的传输，身份认证的网络协议，相对http明文传输比较安全。 4.1 讲一讲http的请求报文和响应报文？协议？ 请求报文和协议 一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。 请求行 ：由请求方法字段、URL字段和HTTP协议版本字段3个字段组成。 HTTP协议 : 的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。 请求头部： 请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔 。 请求头部通知服务器有关于客户端请求的信息。 User-Agent：产生请求的浏览器类型。 Accept：客户端可识别的内容类型列表。 Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。 请求数据 : 请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。 响应报文和协议 HTTP响应也由四个部分组成，分别是：状态行、响应头、空格、响应数据。 状态行 ： 状态行（status line）通过提供一个状态码来说明所请求的资源情况。如404等 4.2 一个TCP连接中多个HTTP请求发生可以【同时】一起发生吗？ HTTP/1.1单个 TCP 连接在同一时刻只能处理一个请求。意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠； Pipelining 技术 &amp; Multiplexing。 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行； 那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？ 维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求； 和服务器建立多个 TCP 连接。 5.请说明一下http1.0 和https1.1 区别？ 长连接 HTTP1.0默认使用短连接，每次HTTP请求都需要建立新的TCP连接，连接不能复用； HTTP1.1支持持久连接和请求的流水线处理（但不是并发！！），在一个TCP连接上可以传送多个HTTP请求和响应，减少建立和关闭TCP连接的消耗和延迟，提高效率 host字段 在HTTP1.0中为每台服务器绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname） HTTP1.1的请求消息和响应消息都应支持Host头域（补充：F12 抓包可以看到），且请求消息中如果没有Host头域，会报400 Bad Request错误 缓存处理 HTTP1.1则引入了更多的缓存控制策略 带宽优化及网络连接的使用 HTTP1.0中存在浪费带宽现象，例如：（1）客户端只需要某个对象的一部分，而服务器却将整个对象发送过来；(2) 下载大文件不支持断点续传功能，在发生断连后需要重新下载完整的包； HTTP1.1则在请求头中引入range头域，它允许只请求资源的某个部分(因此也支持断点重传)，即返回码是206； 新增一些错误通知状态码 如：409（Conflict）表示请求的资源与资源的当前状态发生冲突 。 6.请说明一下http1.0 和https2.0 区别？ 7.请讲一下浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程？ 在浏览器地址栏中输入URL； DNS域名解析，获得域名相对应的IP地址（详见：应用层DNS寻址过程）； 浏览器首先会从（1）本地浏览器缓存、hosts文件是否存在相应的域名、IP对应关系，如果有则向这个IP地址发送请求，如果没有则向（2）本地DNS解析器缓存中查找，如果都没有，（3）再去DNS服务器中找IP。 浏览器向服务器发起TCP连接，与浏览器建立TCP三次握手；然后 向服务器发送HTTP请求，请求数据包 HTTP请求是由三部分组成：请求行、请求报头和请求正文。 与服务器建立了连接后，就可以向服务器发起请求了。发送HTTP请求的过程就是构建HTTP请求报文，并通过TCP协议发送到服务器指定端口（HTTP协议80/8080，HTTPS协议443）。 服务端（由web服务器）处理收到的请求 服务器端收到请求后，由web服务器（准确来说应该是HTTP服务器）处理请求，诸如Apache、Ngnix、IIS 。 服务器返回相应结果（响应报文）至浏览器 HTTP响应报文也是由三部分组成：状态码、响应报头和响应报文。 状态码是由三位数组成，第一个数字定义了响应的类别： 1XX：指示信息，表示请求已接受，继续处理； 2XX：成功，表示请求已被成功接收、理解、接受； 3XX：重定向，要完成请求必须进行更进一步的操作； 4XX：客户端错误，请求有语法错误或无法实现； 5XX：服务器端错误，服务器未能实现合法的请求。 四次挥手关闭TCP连接 四次挥手，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。 浏览器解析渲染页面 浏览器在 收到HTML、CSS、JS文件后，就需要进行渲染。 （1）浏览器解析HTML文件构建DOM树，（2）然后解析CSS文件构建渲染树，（3）等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上 8.请解释一下SSL工作过程（Https传输过程）？ https是http的扩展，在传输层使用了安全协议：安全套接字层SSL(Secure Socket Layer)。 参考：https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html 公钥通常用于加密会话密钥、验证数字签名，或加密可以用相应的私钥解密的数据。公钥和私钥是通过一种算法得到的一个密钥对(即一个公钥和一个私钥)。 通过这种算法得到的密钥对能保证在世界范围内是唯一的。 使用这个密钥对的时候,如果用其中一个密钥加密一段数据，必须用另一个密钥解密。 SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。 所以基本过程是： （1） 客户端向服务器端索要并验证公钥。 （2） 双方协商生成&quot;对话密钥&quot;。 （3） 双方采用&quot;对话密钥&quot;进行加密通信。 协商加密算法。客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求； （1） 支持的协议版本，比如TLS 1.0版。 （2） 一个客户端生成的随机数，来生成&quot;对话密钥&quot;。 （3） 支持的加密方法，比如RSA公钥加密。 （4） 支持的压缩方法。 服务器回应。服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello； （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。 （2） 一个服务器生成的随机数，稍后用于生成&quot;对话密钥&quot;。 （3） 确认使用的加密方法，比如RSA公钥加密。 （4） 服务器证书。 客户端鉴别。客户端收到服务器回应以后，（1）首先验证服务器证书：如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。 （2）如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息： （1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。 （2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。 （3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。 会话秘钥计算。 服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的&quot;会话密钥&quot;（使用3个随机数生成更安全）； （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。 （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。 安全数据传输。双方用会话秘钥加密和解密之间传送的数据。 8.1 公钥如何保证不被篡改？说一说证书。 将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。 服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。 进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过（证书不可信浏览器会提示），就可以开始通信了。 8.2 公钥加密计算量太大，如何减少耗用的时间？ 每一次对话（session），客户端和服务器端都生成一个&quot;对话密钥&quot;（session key），用它来加密信息。由于对话密钥是对称加密，所以运算速度非常快，而服务器公钥只用于加密&quot;对话密钥&quot;本身，这样就减少了加密运算的消耗时间。 8.3 为什么有的时候刷新页面不需要重新建立 SSL 连接？ TCP 连接有的时候会被浏览器和服务端维持一段时间，TCP 不需要重新建立，SSL 自然也会用之前的。 9. 介绍一下常见的几种非对称加密算法？优缺点？ 非对称加密 非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。 常用非对称加密算法 RSA：由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的 DSA（Digital Signature Algorithm）：数字签名算法，是一种标准的 DSS（数字签名标准） ECC（Elliptic Curves Cryptography）：椭圆曲线加密 非对称加密优缺点 优点： 可以更安全地将公开密钥传输给通信发送方； 缺点： 运算速度慢。 10.公钥加密–私钥解密与公钥解密–私钥加密有什么区别? 主要是应用场景不同。 加解密：公钥加密，私钥解密 不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密 签名：私钥签名，公钥验签 是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证 https可以只有非对称加密吗? https验证证书阶段是非对称加密，但是在数据传输阶段是对称加密。https不可以只有非对称加密： 非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的； 在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。 11. HTTPS 为什么安全？为什么需要CA证书？只有认证机构可以生成证书吗？HTTPS 绝对安全吗？ 安全：因为 HTTPS 保证了传输安全，防止传输过程被监听、防止数据被窃取，可以确认网站的真实性； CA证书： HTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器，而 HTTPS 协议主要解决的便是网络传输的安全性问题，所以需要CA证书 证书生成： 如果需要浏览器不提示安全风险，那只能使用认证机构签发的证书。但浏览器通常只是提示安全风险，并不限制网站不能访问，所以从技术上谁都可以生成证书，只要有证书就可以完成网站的 HTTPS 传输。 不绝对安全： 不是绝对安全的，可以通过中间人攻击。 CA证书不是可以解决“中间人”吗？ 过程原理： 本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器 中间人服务器返回中间人自己的证书（但是这一步服务器不是会对服务器证书进行验证吗？） 客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输 中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密 中间人以客户端的请求内容再向官方网站发起请求 因为中间人与服务器的通信过程是合法的，官方网站通过建立的安全通道返回加密后的数据 中间人凭借与官方网站建立的对称加密算法对内容进行解密 中间人通过与客户端建立的对称加密算法对官方内容返回的数据进行加密传输 客户端通过与中间人建立的对称加密算法对返回结果数据进行解密 12. http应答码中的301/2/4、500、502、503、504状态码进行解释？ 200： 请求成功。 500： 500 (服务器内部错误) 服务器遇到错误，无法完成请求。 例如，服务器无法识别请求方法时可能会返回此代码。 501：服务器不支持请求的功能，无法完成请求 502： 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503： 由于超载或系统维护，服务器暂时的无法处理客户端的请求。 504(及时)：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 13.介绍一下http请求get、post等？ 重点区分一下get和post： get ：GET方法用于使用给定的URI从给定服务器中检索信息，即从指定资源中请求数据。 GET请求是可以缓存的，浏览器历史记录中查找到GET请求；长度有限制；不安全，url会暴露请求的参数 post：POST方法用于将数据发送到服务器以创建或更新资源 。 POST请求不会被缓存；长度无限制；更安全 特别的：GET产生一个TCP数据包;POST产生两个TCP数据包。 get：http header和body一并发送出去 ； post：浏览器先发送header，服务器响应100 continue，浏览器再发送body 。 ⚠️ post是不一定会发生两个的。 HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送； header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。 13.1 Get方法长度有限制是怎么回事？ HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器 / 服务器的原因。 服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制； 浏览器也会设置url有限。 13.2 POST 方法相比GET方法是绝对安全吗？ POST 比 GET 安全，因为数据在地址栏上不可见； POST不是绝对安全，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。 想要安全，只有使用HTTPS。 14. HTTP是不保存状态的协议,如何保存用户状态? Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太⼀样。 Cookie ⼀般用来保存用户信息 我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以⾃动帮你登录的⼀些基本信息给填了； ⼀般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了⼀个 Token 在 Cookie中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录⼀般要将 Token 重写)； 登录⼀次网站后访问网站其他页面不需要重新登录。 Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。 既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在Cookie 中附加⼀个 Session ID 来方式来跟踪。 15. cookie 、session的作用和区别？ Cookie 作用： 服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。 Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。 Session 作用： Session 代表着服务器和客户端一次会话的过程，Session 对象存储特定用户会话所需的属性及配置信息。 二者区别 作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端； 有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效； 安全性： Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些； 存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie； 存取类型的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。 15.1 Session的共享方式？（好未来问过） 参考：Session如何共享 问题描述 在集群环境中，假设客户端第一次访问服务A，服务A响应返回了一个sessionId并且存入了本地Cookie中。第二次不访问服务A了，转去访问服务B； 访问服务B的时候，会将sessionId加入到请求头中，而服务B因为通过sessionId没有找到相对应的数据，因此它就会创建一个新的sessionId并且响应返回给客户端 这样就造成了不能共享Session的问题。 解决方案 使用Cookie实现。 将系统用户的Session信息加密、序列化后，以Cookie的方式， 统一种植在根域名下（如：.host.com），利用浏览器访问该根域名下的所有二级域名站点时，会传递与之域名对应的所有Cookie内容的特性，从而实现用户的Cookie化Session在多服务间的共享访问。 数据库同步session。 每次将session数据存到数据库中。这个方案还是比较可行的。 缺点： Session的并发读写能力取决于MySQL数据库的性能，对数据库的压力大，同时需要自己实现Session淘汰逻辑，以便定时从数据表中更新、删除 Session记录，当并发过高时容易出现表锁。 使用token代替session。 就是Token方式替代了，但是还是没解决。 Spring-Sesion实现 。将原本需要由Web服务器创建会话的过程转交给Spring-Session进行创建。Spring-Session会将原本应该保存在Web服务器内存的Session存放到Redis中。然后Web服务器之间通过连接Redis来共享数据，达到Sesson共享的目的。 16. Cookie 和 Session有什么关联？（问过）token有什么作用，优点，（JWT）结构是什么？ 参考：一文彻底搞懂Cookie、Session、Token到底是什么 为什么需要session？ 既然浏览器已经通过Cookie实现了有状态这一需求，那么为什么又来了一个Session呢？ 如果将账户的一些重要信息都存入Cookie中的话，一旦被拦截，那么我们所有的账户信息都会丢失掉。所以就出现了Session，在一次会话中将重要信息保存在Session中，浏览器只记录SessionId一个SessionId对应一次会话请求。 session和cookie二者关联 以用户一次登录为例。 用户第一次请求服务器的时候，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；并将此 Session 的唯一标识信息 SessionID 返回给浏览器； 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名； 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端； 服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。 什么是Token？ Session是将要验证的信息存储在服务端，并以SessionId和数据进行对应，SessionId由客户端存储，在请求时将SessionId也带过去，因此实现了状态的对应。 但是，而Token是在服务端将用户信息经过Base64Url【编码，不是加密】过后传给在客户端，每次用户请求的时候都会带上这一段信息，因此服务端拿到此信息进行解密后就知道此用户是谁了。 这个方法叫做JWT(Json Web Token)。 一个例子理解：基于Token的身份验证流程，在服务端不需要存储用户的登录记录 。 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 Token在服务器端，可以保存在Redis缓存中。 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 Token的优点 无状态，可扩展和解耦： 使用 token 而不是 cookie 的最大优点应该就是无状态，后端不需要保持对 token 的记录，每个 token 都是独立的，包含了检查其有效性的所有数据，并通过申明传达了用户信息。 在 JWT 中存储数据 ： 当使用 cookie 进行验证时，你是将 session id 存储到 cookie 里，JWT 允许你存储任何类型的元数据，只要是合法的 JSON。 自包含：由于串包含了用户所需要的信息，避免了多次查询数据库。 JWT介绍 JWT有三部分组成：Header，Payload，Signature。 Header： 一个Json对象，描述JWT的元数据，通常是下面这样子的。 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, # 签名的算法为HS256 &quot;typ&quot;: &quot;JWT&quot; # Token类型为JWT&#125; Payload： 也是一个Json对象，用来存放实际需要传输的数据，也可以自己定义一些私有字段，如： 1234&#123; &quot;name&quot;: &quot;xiaoMing&quot;, &quot;age&quot;: 14&#125; Signature： 对前面的两部分的数据进行签名，防止数据篡改 。 首先需要定义一个秘钥，这个秘钥只有服务器才知道，不能泄露给用户，然后使用Header中指定的签名算法(默认情况是HMAC SHA256)。算出签名以后将Header、Payload、Signature三部分拼成一个字符串，每个部分用.分割开来，就可以返给用户了。 16.1 session和cookie应该如何去选择（适用场景）？ Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session； Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；考虑安全考虑session 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中，一般是cookie和session配合使用的。 17.说说HTTP、TCP、Socket 的关系是什么？ TCP/IP 代表传输控制协议/网际协议，指的是一系列协议族； HTTP 本身就是一个协议，是从 Web 服务器传输超文本到本地浏览器的传送协议； Socket 是 TCP/IP 网络的 API ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。 3.5 其它 1. 介绍一下CDN ？ CDN分发节点各个数据都一样吗？ CDN，即内容分发网络 解决静态网页加载 不同地区用户访问服务器速度不同，可以把静态网页放在不同地区的服务器，这样用户可以就近去连接，大大提升体验； 发展转换成，就近接入解决访问网络资源 如一个电信用户送请求，进入解析系统，会让用户连接到最近的边缘节点，然后请求数据； 如果边缘节点没有数据，则去访问源节点； 源节点也没有，就会去访问主干节点，去联通服务器中查找； 最后返回数据。 CDN分发节点各个数据不一样 不一样，就相当于DNS服务器缓存了些域名→ip数据，如果没有的话还要向上级查询，最终把源站数据拉下来。 2. 什么是CDN三级溯源？ CDN目的。CDN 系统设计的首要目标是尽量减少用户的访问响应时间 CDN实现思路。为达到这一目标，CDN 系统应该尽量将用户所需要的内容存放在距离用户最近的位置。也就是说，负责为用户提供内容服务的 Cache设备应部署在物理上的网络边缘位置，我们称这一层为 CDN边缘层 。 CDN系统架构。CDN 系统中负责全局性管理和控制的设备组成 中心层 ，中心层同时保存着最多的内容副本，当边缘层设备未命中时，会向中心层请求，如果在中心层仍未命中，则需要中心层向源站回源。","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"校招笔记（二）_计算机基础_Linux&Git","slug":"校招笔记（二）_计算机基础_Linux&Git","date":"2021-11-26T12:41:34.011Z","updated":"2021-11-26T16:28:35.081Z","comments":true,"path":"2021/11/26/校招笔记（二）_计算机基础_Linux&Git/","link":"","permalink":"https://hwh.zone/2021/11/26/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80_Linux&Git/","excerpt":"","text":"备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 🚩 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 二、Linux &amp; Git 2.1 Linux 2.1.1 常用命令 查看80端口状态？ 1netstat -ntulp | grep 80 -t : 指明显示TCP端口 -u : 指明显示UDP端口 -l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序) -p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序 -n : 不进行DNS轮询，显示IP(可以加速操作) 怎么查看指定端口是否开放？ 通过 netstat 命令，注意加上-a参数，看是否有0.0.0.0:22 在被监听。 通过lsof命令，如果没有任何显示，则端口没有被打开。 查看进程状态？怎么退出？怎么搜索进程？怎么查看某一个进程的内存和CPU使用情况？ 所有进程状态 12ps -aux # 内存中进程信息ps -l # 本次登陆所有的进程信息 退出进程： exit 搜索进程： ps -ef 1ps -ef | grep &lt;进程名&gt; -e相当于-a是全部列出，-f是显示UID等； 查看指定进程（如kalfa）CPU和内存占用 1ps -aux | grep java 1.3是CPU占用率，12.7是内存占用率，943100是物理内存使用量 还可以使用 top命令查看指定进程（PID）的内存和CPU使用率： 1top -p 2913 查看占用指定端口的进程 ？ 1lsof -i :8040 这一步只能获取进程名，还要ps 命令进一步获取进程id 如果要杀死相应进程： 1kill -9 &lt;进程id&gt; 任务管理器（cpu占用率、内存占用率、进程）？ 1top （总忘）还可以使用 top命令查看指定进程（PID）的内存和CPU使用率： 1top -p 内存使用情况 和 磁盘使用情况？ 1free -m # 内存使用情况 磁盘使用情况 1df -m -m : 以Mb为单位显示磁盘使用量和占用率 统计单词个数 1grep -o &lt;单词&gt; &lt;文件地址&gt; ｜ wc -l # -l表示统计行数 修改用户权限及常用参数？ 1chmod &lt;参数(可选)&gt; &lt;模式&gt; &lt;文件/文件夹&gt; 常用参数： -R ：递归的修改文件夹下所有子文件/文件夹的所属用户 【示例】如何修改 /test5/5.txt ，权限从rw-r--r-- —&gt; r--rwxrwx ？ 1234# 用户（U）权限[减去写]权限chmod u-w /test5/5.txt# 组（G）/其他用户（O）权限[加上写、执行]chmod go+wx /test5/5.txt 查看文件的命令有哪些？ 123456vi 文件名 #编辑方式查看，可修改cat 文件名 #显示全部文件内容more 文件名 #分页显示文件内容less 文件名 #与 more 相似，更好的是可以往前翻页tail 文件名 #仅查看尾部，还可以指定行数head 文件名 #仅查看头部,还可以指定行数 你平时怎么查看日志的？ Linux查看日志的命令有多种: tail、cat、tac、head、echo等，本文只介绍几种常用的方法。 tail（最常使用） 命令格式: tail[必要参数][选择参数][文件] 123tail -n 10 test.log 查询日志尾部最后10行的日志;tail -n +10 test.log 查询10行之后的所有日志;tail -fn 10 test.log 循环实时查看最后10行记录(最常用的) 一般还会配合着grep搜索用，例如 : 1tail -fn 1000 test.log | grep &#x27;关键字&#x27; 如果一次性查询的数据量太大,可以进行翻页查看，例如： 1tail -n 4700 aa.log |more -1000 可以进行多屏显示(ctrl + f 或者 空格键可以快捷键) 其它配合的命令 123456history # 所有的历史记录history | grep XXX # 历史记录中包含某些指令的记录history | more # 分页查看记录history -c # 清空所有的历史记录!! 重复执行上一个命令查询出来记录后选中 : !323 怎么让进程后台运行？ 命令后面加上**&amp;**即可，实际上，这样是将命令放入到一个作业队列中了； 通常配合nohup ，忽略发送给子命令的挂断SIGHUP信号（终端关闭）： 1nohup subcommand &amp; ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程； ctrl + c 是进程终止。 运行指令前面**+ setsid**，使其父进程编程init进程，不受SIGHUP信号的影响。 2.1.2 其它问题 1.请问/proc 目录有什么用？ Linux系统上的/proc目录是一种文件系统，即proc文件系统。 /proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件： 查看系统有关（1）硬件及当前（2）正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。 2. Linux的软/硬链接是什么？有什么区别？ 参考：“软链接”和“硬链接”的区别 什么是链接 ？ 文件在Linux上被分成两部分：用户数据 (user data) 与元数据 (metadata) 。 用户数据：即文件数据块，保留记录文件真实内容的地方 元数据： 是文件的附加属性，如创建大小、时间，所有信息等。其中inode号 ，是文件的唯一标识。 系统通过inode号快速找到文件，有一种方式可以快速寻找到数据元信息，那就是软/硬链接。 现在我们创建一个新文件myfile： 1234$ touch myfile &amp;&amp; echo &quot;This is a plain text file.&quot; &gt; myfile$ cat myfileThis is a plain text file. 来展示二者区别。 硬链接 建立 myfile 的一个硬链接 hard ，可以看到二者的inode 是一致的，也就是说指向了同一个物理区块。 硬链接inode ：指向文件的地址 &amp; 维护了一个引用计数，只要有文件还指向这个区块，它就不会从硬盘消失。 12345$ ln myfile hard # 建立硬链接hard$ ls -li25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 hard25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 myfile 操作硬链接更新文件，等价更新原文件 使用hard硬链接修改文件，发现原文件也被修改了。 12345$ echo &quot;New line&quot; &gt;&gt; hard$ cat myfileThis is a plain text file.New line 删除原文件，使用硬链接依旧可以显示 因为磁盘块还有硬链接在引用，所以不会消失。 12345$ rm myfile # 删除原文件$ cat hard # 硬链接依旧可以显示This is a plain text file.New line 软链接 建立一个soft软链接如下，可以看到二者的inode号是不一样的。 软连接的inode ：保存真实的文件的绝对路径地址，找到软链接，还要根据inode号找到真实文件路径。 12345$ ln -s myfile soft # 建立软连接soft$ ls -li25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 myfile25869216 lrwxr-xr-x 1 unixzii staff 6 7 8 17:47 soft -&gt; myfile 操作软链接更新文件，等价更新原文件 因为软链接就是相当个快捷方式，当然更新原文件。 删除原文件，使用软链接不会显示 因为软件inode指向的绝对地址，已经不存在文件了，所以当然不存在文件了。 1234$ rm myfile$ cat softcat: soft: No such file or directory 软硬连接区别总结 inode号不同。硬链接原文件/链接文件公用一个inode号，说明他们是同一个文件，而软链接原文件/链接文件拥有不同的inode号，表明他们是两个不同的文件； 链接数目不同。 软链接的链接数目不会增加；硬链接每多一个链接就会+1。 文件大小不同。硬链接文件显示的大小是跟原文件是一样 ；软链接显示的大小与原文件就不同了，BBB大小是95B，而BBBsoft是3B，因为BBB共有3个字符。 文件系统限制。 软链接没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。 建立软链接就是建立了一个新文件：当访问链接文件时，系统就会发现他是个链接文件，它读取链接文件找到真正要访问的文件。 3. 查询日志的top10 IP? 命令如下： 1cat log | cut -d &#x27; &#x27; -f 1 | sort | uniq -c | sort -nr | awk &#x27;&#123;print $0&#125;&#x27; | head -n 10 cat *.log ：将文本内容打印到屏幕 cut：截取指定IP那一列 sort ，按IP ASCII码排序：进行排序，默认是按照ascii码进行排序的 uniq -c ，统计重复的IP ：统计相邻的行的重复数量，结果是类似 3 127.13.13.13 ，前面的数字代码重复的行数 sort|uniq -c 统计重复的行数 sort -n，再次排序 ：是按照数值进行由小到大进行排序， -r是表示逆序，-t是指定分割符，-k是执行按照第几列进行排序 awk ，只显示IP：按照分割符将一行分割为多个列，第一列用1表示，第二列用​2表示，依次类推 awk -F&quot; &quot; '&#123;print $2&#125; ，表示用空格作为分隔符进行分割，打印出第2列 head -n ：表示取前n个 2.2 Git 讲git原理的的一篇不错文章 2.2.1 常问命令 1.什么是Git？是用什么语言编写的？ Git是一个 分布式 代码控制系统 ； Git使用 C 语言编写：使得 GIT 很快，C 语言减少运行时开销来做到这一点。 2.如何在Git中创建存储库？ 如果项目不存在，创建 然后运行 git init ，会在目录下创建一个 .git 目录 3.列举工作中常用的几个git命令？ git add : 增加文件 git commit -m ：提交文件 git status ：拉取远程分支 git push ：合并当前分支和主分支 git pull OR git fetch/git merge ：拉取远程分支 4.讲讲Git commit 基本参数？ 参考：https://www.cnblogs.com/qianqiannian/p/6005628.html git commit -m “message” ：简要说明这次提交的语句 git commit -a ：即使没有经过 git add ，也可以将所有 修改 或 删除 的文件提交到本地仓库，但新建的文件不会提交 git commit --amend ：追加提交，它可以在不增加一个新的commit-id 的情况下将新修改的代码追加到前一次的commit-id中， 5.在Git中，你如何还原已经 push 并公开的提交？ 删除或修复新提交中的错误文件，并将其覆盖推送到远程存储库： 1git commit -m &quot;commit message&quot; 创建一个新的提交，撤消在错误提交中所做的所有更改： 1git revert &lt;name of bad commit&gt; 6. git pull 和 git fetch 有什么区别？ git pull 取回远程主机某个分支的更新，再与本地的指定分支合并 （可能要解决冲突）。 git fetch 从远程获取最新版本到本地，不会自动合并 ，需要手动执行 git merge 7.什么是 git stash?你一般什么情况下会使用它？ 经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是git stash命令。储藏(stash)可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用 使用情况： 当前分支还没处理完，不能去commit提交，但是要去处理一个紧急开发项目，使用 git stash 处理完后git stash pop 继续处理工作 8.如果本次提交误操作，如何撤销？ 场景1:改乱了（包括删除等）工作区某个文件的内容（git add 之前）： 1git checkout -- &lt;file&gt; 丢弃之前所有的修改。 场景2:撤销提交到索引区的文件 （git add 之后）： 1git reset HEAD &lt;file&gt; 此时回到了场景1，然后再使用 git checkout 场景3： 撤销已经提交之后的文件（git commit之后）： 回退版本号。 12$ git reflog # 查看版本$ git reset --hard 3928 # 回退版本 场景4： 撤销已经push到远程分支之后的文件（git push之后） 创建一个新的提交，撤消在错误提交中所做的所有更改： 1git revert &lt;name of bad commit&gt; 删除或修复新提交中的错误文件，并将其覆盖推送到远程存储库： 1git commit -m &quot;commit message&quot; 9.使用过git merge和git rebase吗？它们之间有什么区别？ 都是用来合并分支的，但是： git merge &lt;当前分支要合并的分支&gt; ： 在当前分支合并&lt;指定要合并的分支&gt;，会自动在当前分支（下图为master）创建一个commit节点，保留了要合并的分支（下图为branch1）的提交记录 git rebase &lt;当前分支变基的基点分支&gt; ：相当将当前分支（下图为branch1）的分支节点（5,6） 依次提交到基点分支（master）的4节点之后，保留了更干净的历史记录，没有生成行的commit 节点","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://hwh.zone/tags/Git/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Linux","slug":"Linux","permalink":"https://hwh.zone/tags/Linux/"}]},{"title":"校招笔记（一）_Java_JVM","slug":"校招笔记（一）_Java_JVM","date":"2021-11-26T12:06:06.920Z","updated":"2021-11-26T16:38:16.721Z","comments":true,"path":"2021/11/26/校招笔记（一）_Java_JVM/","link":"","permalink":"https://hwh.zone/2021/11/26/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89_Java_JVM/","excerpt":"","text":"备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 🚩 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 1.6 JVM相关 1.6.1 常问问题 1. （被问过）JVM启动的基本配置参数有哪些？（或者说调优参数） 「堆栈内存相关」 -Xms： 设置初始堆的大小 -Xmx： 设置最大堆的大小 -Xmn ：设置年轻代大小，相当于同时配置-XX:NewSize和-XX:MaxNewSize为一样的值 -Xss： 每个线程的堆栈大小 -XX:NewSize 设置年轻代大小(for 1.3/1.4) -XX:MaxNewSize 年轻代最大值(for 1.3/1.4) -XX:NewRatio 年轻代与年老代的比值(除去持久代) -XX:SurvivorRatio Eden区与Survivor区的的比值 -XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。 -XX:MaxTenuringThreshold设定对象在Survivor复制的最大年龄阈值，超过阈值转移到老年代 「垃圾收集器相关」 -XX:+UseParallelGC：选择垃圾收集器为并行收集器。 -XX:ParallelGCThreads=20：配置并行收集器的线程数 -XX:+UseConcMarkSweepGC：设置年老代为并发收集。 -XX:CMSFullGCsBeforeCompaction=5 由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行5次GC以后对内存空间进行压缩、整理。 -XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片 「辅助信息相关」 -XX:+PrintGCDetails 打印GC详细信息 -XX:+HeapDumpOnOutOfMemoryError让JVM在发生内存溢出的时候自动生成内存快照,排查问题用 -XX:+DisableExplicitGC禁止系统System.gc()，防止手动误触发FGC造成问题. -XX:+PrintTLAB 查看TLAB空间的使用情况 2.说说堆和栈的区别？ 功能不同：栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象； 注：无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。 共享性不同：栈内存是线程私有的； 堆内存是所有线程共有的； 异常错误不同：如果栈内存或者堆内存不足，都会抛出异常但不同； 栈空间不足：java.lang.StackOverFlowError。 堆空间不足：java.lang.OutOfMemoryError； 空间大小：栈的空间大小远远小于堆的。 3.【重点】请问JVM运行时内存布局分布？ 哪些是线程共享的？ 从概念上大致分为 6 个（逻辑）区域，参考下图。注：Method Area 中还有一个常量池区，图中未明确标出。 总的来看，JVM 把内存划分为“栈(stack)”与“堆(heap)”两大类 线程私有的： 程序计数器：当同时进行的线程数超过CPU数或其内核数时，就要通过时间片轮询分派CPU的时间资源，不免发生线程切换。这时，每个线程就需要一个属于自己的计数器来记录下一条要运行的指令； 虚拟机栈： 每个java方法执行时都会创建一个桢栈来存储方法的： 变量表、操作数栈、动态链接方法、返回值、返回地址等信息； 栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法），“栈帧参考” ； 本地方法栈： 与虚拟机栈作用相似。但它不是为Java方法服务的，而是调用操作系统原生本地方法时，所需要的内存区域。 本地方法被执行的时候，在本地方法栈也会创建⼀个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。 线程共享的： 堆：GC 垃圾回收的主站场，用于存放类的实例对象及 数组实例等； 方法区： 线程共享的，用于存放被虚拟机加载的类的元数据信息： 如 常量、静态变量和 即时编译器编译后的代码； 运行时常量池：字符串，int -128~127 范围的值等，它是 方法区 中的一部分。 3.1 JVM 堆中又怎么分的？为什么要这么划分？为什么要取消永久代用元空间代替？ 参考：https://zhuanlan.zhihu.com/p/111809384 堆划分：堆又被划分为，新生代，老年代。新生代又被划分为eden和survivor区。 为什么划分新生代、老年代？ 因为有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率。 代替： 在java7版本前，堆和方法区连在了一起，但这并不能说堆和方法区是一起的，它们在逻辑上依旧是分开的。但在物理上来说，它们又是连续的一块内存。 也就是说，方法区和前面讲到的Eden和老年代是连续的。 永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。 在Java8中，元空间(Metaspace)登上舞台，方法区存在于元空间(Metaspace)。同时，元空间不再与堆连续，而且是存在于本地内存（Native memory）。本地内存（Native memory），也称为C-Heap，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。 元空间存在于本地内存，意味着只要本地内存足够，它不会出现像永久代中“java.lang.OutOfMemoryError: PermGen space”这种错误。看上图中的方法区，是不是“膨胀”了。 3.2 程序计数器存哪些东西？能为空吗？ 程序计数器是用于存放下一条指令所在单元的地址的地方。 如果正在执行的是Native方法，这个计数器值为空（Ubdifined）。 4. （新）说一下Java创建对象的过程？ 类加载检查： 虚拟机遇到⼀条 new 指令时，⾸先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 分配内存： 在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把⼀块确定大小的内存从 Java 堆中划分出来。 （重要）分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整⼜由所采用的垃圾收集器是否带有压缩整理功能决定。 初始化对象字段零值。 内存分配完成后，进行对象初始化操作。 例如给对象中（区分类加载过程，初始化类变量）所有的基本数据变量赋上初始化值， 当我们没有对它们进行赋值操作时就可以使用对象了。 设置对象头： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 执行init() &amp; 构造函数。然后执行对象内部生成的init方法，然后执行构造器方法（程序员设置的）。 内存地址赋给引用： 在虚拟机会将刚创建好对象的内存地址赋给引用对象。完成此操作后，便可以在程序中通过引用访问对象的实例数据。 4.1 什么是指针碰撞？空闲列表？TLAB? 三种虚拟机划分堆内存区域的方法，TLAB也可用来给堆内存分配空间。 指针碰撞 一般情况下，JVM的对象都放在堆内存中（发生逃逸分析除外）。当类加载检查通过后，Java虚拟机开始为新生对象分配内存。 如果Java堆中内存是绝对规整的，所有被使用过的的内存都被放到一边，空闲的内存放到另外一边，中间放着一个指针作为分界点的指示器，所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例，这种分配方式就是指针碰撞。 空闲列表 如果Java堆内存中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，不可以进行指针碰撞。 虚拟机必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表。 TLAB TLAB 是虚拟机在内存的eden 区划分出来的一块专用空间，是线程专属的。 在启用TLAB 的情况下，当线程被创建时，虚拟机会为每个线程分配一块TLAB 空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提高分配效率。 虚拟机通过 -XX:UseTLAB 设定它的。 4.2 JVM如何保证对象分配的线程安全问题？ 因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全： TLAB： 为每⼀个线程预先在Eden区分配⼀块⼉内存TLAB，JVM在给线程中的对象分配内存时，⾸先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用的CAS进行内存分配。 CAS+失败重试： CAS 是乐观锁的⼀种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为⽌。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。 5.描述一下对象分配【原则】？（区分前面new对象【过程】） JVM 中的堆可划分为两大部分，新生代和老年代，大小比例为1:2： 新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to 区 具体回收过程： 对象的正常流程：Eden 区 -&gt; Survivor 区 -&gt; 老年代。 新的对象优先在 Eden 区分配（大对象直接进入老年区，避免在Eden区及两个Survivor区之间发生大量的内存复制） ,当 Eden 区没有足够空间时，会发起一次Minor GC； Minor GC采用复制回收算法的改进版本回收Eden中对象： 先将Eden存活对象迁移到 to 区，然后清空Eden 最后交换to和from区域标签 每经过一次Minor GC （在交换区）后对象年龄加1，对象年龄达到15次后将会晋升到老年代； 对象提前晋升到老年代，动态年龄判定：如果在 Survivor 区中相同年龄所有对象大小总和大于 Survivor 区大小的一半， 年龄大于或等于该年龄的对象就可以直接进入老年代； 老年代空间不够时进行Full GC。 5.1 对象一定分配到堆上吗？ 参考：面试官：是不是所有的对象和数组都会在堆内存分配空间 小伙，来给我讲一下是不是所有的对象和数组都会在堆内存分配空间？ 并不是，这涉及到对象逃逸。请看下面的代码： StringBuffer对象，最终会被return，也就是会被该方法之外的给利用。 发生了对象逃逸。 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。 但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。 6.对象的访问定位有哪两种方式? 建⽴对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，⽬前主流的访问方式有：①使用句柄和 ②直接指针两种。 句柄： 如果使用句柄的话，那么Java堆中将会划分出⼀块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据（存放在方法区）各⾃的具体地址信息； 使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。 直接指针： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。 使用直接指针访问方式最大的好处就是速度快，它节省了⼀次指针定位的时间开销。 7.如何判断对象是否需要回收（死亡）？ 可达性分析：根据引用的关系构造引用链（有向图），在图中不可达的对象就是要被回收的； 引用计数：有地方引用该对象，计数器++，引用失效，计数器–，有循环引用的问题。 8. 如何判断一个常量是废弃变量？如何判断一个类是无用类？ 判断常量是废弃变量 运行时常量池主要回收的是废弃的常量。 假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量&quot;abc&quot; 就是废弃常量，如果这时发⽣内存回收的话而且有必要的话，“abc” 就会被系统清理出常量池。 判断类是无用类？ 虚拟机可以对满足下面3个条件的无用类进行回收，这⾥说的仅仅是“可以”，而并不是和对象⼀样不使用了就会必然被回收。 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例； 加载该类的 ClassLoader 已经被回收； 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 1.6.1 GC相关 不错的GC介绍文章：一文看懂 JVM 内存布局及 GC 原理 1.请介绍GC基本原理？有什么优点？GC可以马上回收内存吗？如何主动让虚拟机回收？ 当程序员创建对象时，GC就开始监控这个对象的地址、大小及使用情况 ，当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间 ： 基本原理： GC采用有向图的方式记录和管理堆(heap)中的所有对象 ，并确定对象是否“可达” GC优点：（1）使得程序员不用考虑内存管理 （2）Java中的对象不再有&quot;作用域&quot;的概念，只有对象的引用才有&quot;作用域&quot; （3）有效防止内存泄漏 马上回收： 程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。 主动回收： 手动执行System.gc() ，但是Java语言规范 并不保证 GC一定会执行。 1.1 本地java程序默认启动的是什么垃圾回收器？ cmd执行命令： 1java -XX:+PrintCommandLineFlags -version 输出：-XX：UseParallelGC。 2.什么是GC Root？可以作为GC Root的对象？ GC Root ： 判断对象是通过可达性分析，所以所有的可达性算法都会有起点 ，这就是 GC Root。 特点：当前时刻存活的对象！ 通过GC Root 找出所有活的对象，那么剩下所有的没有标记的对象就是需要回收的对象。 GC Root对象： （1）虚拟机栈中引用的对象；（2）方法区中的静态变量、常量对象；（3）本地方法引用的对象；（4）被synchronized修饰的对象等。 3.哪些内存区域需要GC? （无需）线程独享区域：PC Regiester、JVM Stack、Native Method Stack，其生命周期都与线程相同（即：与线程共生死），所以无需 GC; （需）线程共享的 Heap 区、Method Area 则是 GC 关注的重点对象。 4.什么时候会触发Full GC？ 调用 System.gc() ； 老年代空间不足； 通过Minor GC后进入老年代的平均大小大于老年代的可用内存； 如果发现统计之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC。 方法区空间不足。 JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space 。 为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。 5.什么时候触发 Minor GC ? 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？ 什么时候触发Minor GC ? 当Eden区不足时就会触发 Minor GC 。 minor gc运行频繁 产生了太多朝生夕灭的对象导致需要频繁minor gc 新生代空间设置太小 minor gc运行很慢 新生代空间设置过大； 对象引用链较长，进行可达性分析时间较长； 新生代survivor区设置的比较小，清理后剩余的对象不能装进去需要移动到老年代，造成移动开销； 内存分配担保失败，由minor gc转化为full gc； 采用的垃圾收集器效率较低，比如新生代使用serial收集器。 6.描述一下GC算法？ GC算法包含：引用计数法，标记清除，标记复制，标记压缩。 引用计数：对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用； 标记清除： 垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象；然后，在清除阶段，清除所有未被标记的对象，但会产生很多垃圾碎片 ； 标记复制： 将内存对半分，总是保留一块空着（上图中的右侧），将左侧存活的对象（浅灰色区域）复制到右侧。避免了内存碎片问题，但是内存浪费很严重，相当于只能使用 50%的内存； 标记压缩（标记整理）：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存（类似于 windows 的磁盘碎片整理），避免垃圾碎片。 6.1 新生代和老年代用哪些算法？stw问题会发生在新生代吗? 针对新生代，采用标记复制算法 参考：https://tech.meituan.com/2017/12/29/jvm-optimize.html 大多数对象在新生代中被创建，其中很多对象的生命周期很短。每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。 HotSpot实现的复制算法流程如下: 当Eden区满的时候,会触发第一次Minor gc，把还活着的对象拷贝到Survivor From区；当Eden区再次触发Minor gc的时候,会扫描Eden区和From区域，对两个区域进行垃圾回收,经过这次回收后还存活的对象,则直接复制到To区域,并将Eden和From区域清空。 当后续Eden又发生Minor gc的时候,会对Eden和To区域进行垃圾回收,存活的对象复制到From区域,并将Eden和To区域清空。 部分对象会在From和To区域中复制来复制去，如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15)，最终如果还是存活,就存入到老年代。 针对老年代对象存活率高的特点 在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。 老年代的垃圾回收（又称Major GC）通常使用标记-清理或标记-整理算法。整堆包括新生代和老年代的垃圾回收称为Full GC（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。 7.什么是Stop The World ? 什么是安全点？安全区域？ Stop The World 进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为「Stop The World」。也简称为STW。JVM在暂停的时候，需要选准一个时机。 由于JVM系统运行期间的复杂性，不可能做到随时暂停，因此引入了安全点的概念。 安全点 安全点，即程序（非GC先）执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。 安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，Java虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。只要不离开这个安全点，Java虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。 如何保证中断时所有线程都在安全点 抢先式中断（Preemptive Suspension） 抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机采用这种方式来暂停线程从而响应GC事件。 主动式中断（Voluntary Suspension） 主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 8. 常见的垃圾回收器有哪些（比如G1）？ Serial收集器。 Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是⼀个单线程收集器了。它的单线程 的意义不仅仅意味着它只会使用⼀条垃圾收集线程去完成垃圾收集⼯作，更重要的是它在进行垃圾收集⼯作的时候必须暂停其他所有的⼯作线程（ “Stop The World”），直到它收集结束。 ParNew收集器。 ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全⼀样。 新⽣代采用标记-复制算法，⽼年代采用标记-整理算法。 Parallel Scavenge收集器。 Parallel Scavenge 收集器类似于ParNew 收集器。 那么它有什么特别之处呢？ Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量。 如果对于收集器运作不太了解的话，⼿⼯优化存在的话可以选择把内存管理优化交给虚拟机去完成也是⼀个不错的选择。- 新⽣代采用标记-复制算法，⽼年代采用标记-整理算法。 （重点）CMS收集器。CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的。 CMS收集器仅作用于老年代的收集，基于 “标记-清除” 。 优点： 并发收集、低停顿。 缺点（快手）： CMS收集器对CPU资源非常敏感；CMS收集器无法处理浮动垃圾（Floating Garbage）。 （重点）G1收集器。 G1重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。区域划分的好处就是带来了停顿时间可预测的收集模型：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。 并行与并发：G1能充分利⽤CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核⼼）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。 分代收集：虽然G1可以不需要其他收集器配合就能独⽴管理整个GC堆，但是还是保留了分代的概念。 空间整合：与CMS的“标记–清除”算法不同，G1从整体来看是基于标记-整理算法实现的收集器；从局部上来看是基于标记-复制算法实现的。 可预测的停顿：这是G1相对于CMS的另⼀个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建⽴可预测的停顿时间模型，能让使用者明确指定在⼀个⻓度为M毫秒的时间片段内。 8.1 介绍一下CMS 和 G1 垃圾回收器原理？ 参考：弄明白CMS和G1，就靠这一篇了 CMS收集器 CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的。 CMS收集器仅作用于老年代的收集，是基于标记-清除算法的，它的运作过程分为4个步骤： 初始标记（CMS initial mark） : 需要STW，标记一下GC Roots能直接关联到的对象 ； 并发标记（CMS concurrent mark）：从GC Roots开始堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行； 重新标记（CMS remark）：需要STW ，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录 ； 并发清除（CMS concurrent sweep）： 清除对象。 G1收集器 在堆的结构设计时，G1打破了以往将收集范围固定在新生代或老年代的模式，G1将堆分成许多相同大小的区域单元，每个单元称为Region。Region是一块地址连续的内存空间，G1模块的组成如下图所示： 区域划分的好处就是带来了停顿时间可预测的收集模型：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。 和CMS挺像的。 初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。 并发标记（Concurrent Marking）：是从GC Roots开始堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。 最终标记（Final Marking）：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。 筛选回收（Live Data Counting and Evacuation）：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。 8.2 为什么CMS不用标记-压缩算法？ CMS主要关注低延迟，因而采用并发方式。 在并发清理垃圾时，如果采用压缩算法，这涉及到移动存活的对象。如果不进行停顿会很难处理，违背了CMS初衷，所以采用标记-清除算法。 9.什么是内存泄漏？ 广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄漏。 内存泄漏场景： 静态集合类、数组添加对象以后遗漏了对于他们的处理，例如HashMap和Vector； 各种连接，如数据库连接、网络连接、IO连接； 单例模式； 变量不合理的作用域。 1.6.2 类加载 1. 介绍一下类文件结构？ Class⽂件字节码结构组织示意图 。 魔数: 确定这个⽂件是否为⼀个能被虚拟机接收的 Class ⽂件。 Class ⽂件版本：Class ⽂件的版本号，保证编译正常执行。 常量池 ：常量池主要存放两大常量：字面量和符号引用。 访问标志：标志用于识别⼀些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。 当前类索引,⽗类索引 ：类索引用于确定这个类的全限定名，⽗类索引用于确定这个类的⽗类的全限定名，由于 Java 语⾔的单继承，所以⽗类索引只有⼀个，除了 java.lang.Object 之外，所有的 java 类都有⽗类，因此除了 java.lang.Object 外，所有 Java 类的⽗类索引 都不为 0。 接口索引集合：接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 implents (如果这个类本身是接口的话则是 extends ) 后的接口顺序从左到右排列在接口索引集合中。 字段表集合：描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。 方法表集合 ：类中的方法。 属性表集合： 在 Class ⽂件，字段表，方法表中都可以携带⾃⼰的属性表集合。 2. 什么是类加载器？请你解释一下java程序运行的过程？ 参考 ： 一个简单java程序的运行全过程 类加载器是一个用来加载类文件的类 。 我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存。主要分为以下3大步、5小步： 编译。 将编译的.java 文件编译为.class字节码文件，然后交给JVM运行； 加载 ：class字节码文件从各个来源通过类加载器装载入内存中 。 来源：包本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译 类加载器 ：一般包括启动类加载器，扩展类加载器，系统类加载器，以及用户的自定义类加载器 （代码加密防止反编译）。 链接： 分为，验证、准备、解析（”正-中-准-心“）三阶段 验证： 保证加载进来的字节流符合虚拟机规范； 文件格式的验证，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？ 元数据的验证，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？ 字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。 符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？ 准备：类变量（注意，不是实例变量 ）分配内存，并且赋予初值（虚拟机根据不同类型设定的初始值）； 这些变量所使用的内存都将在方法区中进行分配 ，进行零初始化： 即数字类型初始化为 0 ，boolean 初始化为 false，引用类型初始化为 null 等 解析：将常量池内的 符号引用 替换为 直接引用 的过程。 符号引用：即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。 直接引用：可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量。 🌾 实例： 调用方法hello()，方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。 初始化。 初始化就是执行类的 cinit()的过程。 ❔ 和准备阶段那个初始化看得我有点迷糊？ 在编译阶段，编译器收集所有的静态字段的赋值语句及静态代码块，并按 语句出现的顺序 拼接出一个类初始化方法 &lt;clinit&gt;()。此时，执行引擎会调用这个方法对静态字段进行代码中编写的初始化操作。 3.知道类的生命周期吗？ 在类加载的过程再加上： 使用。new出对象程序中使用 卸载。执行垃圾回收 4.请你介绍一下类加载器？ JVM预定义的三种类型类加载器： 启动类加载器（BootstrapClassLoader）：是一般用本地代码实现，负责将 &lt;Java_Runtime_Home&gt;/lib下面的类库加载到内存中； 标准扩展类加载器（ExtensionClassLoader）：&lt; Java_Runtime_Home &gt;/lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中； 系统类加载器（AppClassLoader）：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量或者系统属性java.class.path所指定的目录中加载类，是用户自定义加载器的默认父加载器。 5.请你介绍一下双亲委派机制？为什么要这么做？ 双亲委派机制。某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载； 为什么要这么做？防止内存中出现多份同样的字节码 。 比如两个类A和类B都要加载System类： 如果不用委托：而是自己加载自己的，那么类A就会加载一份System字节码，然后类B又会加载一份System字节码，这样内存中就出现了两份System字节码。 如果使用委托机制：会递归的向父类查找，也就是首选用Bootstrap尝试加载，如果找不到再向下。这里的System就能在Bootstrap中找到然后加载，如果此时类B也要加载System，也从Bootstrap开始，此时Bootstrap发现已经加载过了System那么直接返回内存中的System即可而不需要重新加载，这样内存中就只有一份System的字节码了。 5.1 如何自定义类加载器 ，如何打破双亲委派机制 ？ 自定义类加载器 &amp; 打破双亲委派机制 在实现自己的ClassLoader之前，我们先看一下JDK中的ClassLoader是怎么实现的： 1234567891011121314151617181920212223 1 protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) 2 throws ClassNotFoundException 3 &#123; 4 // First, check if the class has already been loaded 5 Class c = findLoadedClass(name); 6 if (c == null) &#123; 7 try &#123; 8 if (parent != null) &#123; 9 c = parent.loadClass(name, false);10 &#125; else &#123;11 c = findBootstrapClass0(name);12 &#125;13 &#125; catch (ClassNotFoundException e) &#123;14 // If still not found, then invoke findClass in order15 // to find the class.16 c = findClass(name);17 &#125;18 &#125;19 if (resolve) &#123;20 resolveClass(c);21 &#125;22 return c;23 &#125; 1、如果不想打破双亲委派模型，那么只需要重写findClass方法即可 （1）继承ClassLoader （2）重写findClass()方法 2、如果想打破双亲委派模型，那么就重写整个loadClass方法 （1）继承ClassLoader （2）重写findClass()方法6 （3）调用defineClass()方法 tomcat 为什么要违背双亲委托机制？ 双亲委托机制不能满足tomcat的业务需求； Webapp类加载器需要独立加载自身的class以及依赖的jar； 例如，webapp1依赖的spring版本为4.x，另一个webapp2依赖的spring版本为5.x. 如果使用双亲委托，那么spring的版本只能存在一个，没法满足这个需求。","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"JAVA","slug":"校招笔记/JAVA","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://hwh.zone/tags/JAVA/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"}]},{"title":"校招笔记（一）_Java_锁","slug":"校招笔记（一）_Java_锁","date":"2021-11-26T12:03:48.668Z","updated":"2021-11-26T16:32:30.207Z","comments":true,"path":"2021/11/26/校招笔记（一）_Java_锁/","link":"","permalink":"https://hwh.zone/2021/11/26/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89_Java_%E9%94%81/","excerpt":"","text":"备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 🚩 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 1.5 锁 【新增】 java常用的并发工具类？ 这篇不错：《今天面试了吗》- 并发编程之AQS同步工具类 JUC就是java.util.concurrent包，这个包俗称JUC，里面都是解决并发问题。 常用四大并发工具包（以下都是基于AQS实现的）： CountDownLatch： CyclicBarrier描述的是“允许一组线程相互等待，直到到达某个公共屏障点，才会进行后续任务”。 而CountDownLatch所描述的是“在完成一组正在其他线程中执行的操作之前，它允 一个或多个线程一直等待”。 在API中是这样描述的：用给定的计数初始CountDownLatch。由于调用了countDown方法，所以在当前计数到达零之前，await方法会一直受阻塞。之后，会释放所有等待的线程，await的所有后续调用都将立即返回。这种现象只出现一次（计数无法被重置。如果需要重置计数，请考虑使CyclicBarrier）。 CyclicBarrier：CyclicBarrier是一个同步辅助类。它允许一组线程互相等待，直到到达某个公共屏障点。在涉及一组固定大小的线程的程序里，这些线程必须不时的互相等待，此时CyclicBarrier 很有用。因为CyclicBarrier在释放等待线程后可以重用，因此成为循环的屏障。 使用**await()**方法，每个线程调用await()方法告诉CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。当所有线程都到达了屏障，结束阻塞，所有线程可继续执行后续逻辑。 Semaphore：信号量Semaphore是一个控制访问多个共享资源的计数器，和CountDownLatch一样，其本质上是一个“共享锁”。在API是这么介绍信号量的：一个计数信号量，从概念上讲，信号量维护了一个许可集。 ExChanger ：Exchanger是一个同步器，字面上就可以看出这个类的主要作用是交换数据。Exchanger有点类似CyclicBarrier，前面说到CyclicBarrier是一个栅栏，到达栅栏的 线程需要等待一定数量的线程到达后，才能通过栅栏。Exchanger可以看成是一个双向的栅栏。线程1到达栅栏后，会首先观察有没有其他线程已经到达栅栏，如果没有就会等待。如果已经有其他线程（比如线程2）到达了，就会以成对的方式交换各自携带的信息，因此Exchanger非常适合两个线程之间的数据交换。 1.5.1 synchronized 相关 1.1 [重点]说一说自己对于 synchronized 关键字的了解? synchronized 底层原理 ? 参考：Java面试常见问题：Monitor对象是什么？ 深入分析Synchronized原理(阿里面试题) 基本了解 synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock 来实现的； Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。 moniter介绍 Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用。 在HotSpot虚拟机中，Monitor是基于C++的ObjectMonitor类实现的，其主要成员包括： _owner：指向持有ObjectMonitor对象的线程 _WaitSet：存放处于wait状态的线程队列，即调用wait()方法的线程 EntryList：存放处于等待锁block状态的线程队列 _count：约为_WaitSet 和 _EntryList 的节点数之和 _cxq: 多个线程争抢锁，会先存入这个单向链表 _recursions: 记录重入次数 底层原理 synchronized 关键字底层原理属于 JVM 层面。 ① synchronized同步语句块的情况 1234567public class SynchronizedDemo &#123; public void method() &#123; synchronized (this) &#123; System.out.println(&quot;synchronized 代码块&quot;); &#125; &#125;&#125; 通过 JDK ⾃带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息： ⾸先切换到类的对应⽬录执行 javac SynchronizedDemo.java 命令⽣成编译后的 .class ⽂件，然后执行 javap -c -s-v -l SynchronizedDemo.class synchronized同步语句块的实现使用的是monitorenter和 monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。 当执行monitorenter 指令时，线程试图获取锁也就是获取 monitor的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1 ; monitor对象存在于每个Java对象的对象头中 synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因。 相应的在执行monitorexit 指令后，将锁计数器设为0，表明锁被释放； 如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外⼀个线程释放为⽌。 ② synchronized修饰方法的的情况 12345public class SynchronizedDemo2 &#123; public synchronized void method() &#123; System.out.println(&quot;synchronized 方法&quot;); &#125; &#125; synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是ACC_SYNCHRONIZED 标识，该标识指明了该方法是⼀个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问。 当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。 1.2 请你谈谈关于Synchronized和ReentrantLock？ 相似点 都是阻塞式同步：一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待； 线程阻塞和唤醒的代价是比较高的（操作系统需要在用户态与内核态之间来回切换，代价很高，不过可以通过对锁优化进行改善）。 都是可重入锁：是同一个线程可重复获得锁，每获得一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。 不同点 实现原理： Synchronized是java语言的关键字，是原生语法层面的互斥， JVM 层面；ReentrantLock是JDK 1.5后的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成； 是否避免死锁： synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；Lock不会主动适应 unLock() 释放，必须手动在finally释放；相⽐synchronized，ReentrantLock增加了⼀些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件） 线程等待可中断： Lock可以让等待锁的线程响应中断，线程可以中断去干别的事务；而synchronized却不行，使用synchronized时，等待的线程会一直等待下去； 公平锁： synchronized的锁是非公平锁，ReentrantLock默认情况下也是非公平锁，但可以通过带布尔值的构造函数要求使用公平锁； 选择性通知： synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。 Condition是JDK1.5之后才有的，它具有很好的灵活性，⽐如可以实现多路通知功能也就是在⼀个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使⽤notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，⽤ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有⼀个Condition实例，所有的线程都注册在它⼀个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。 1.3 synchronized锁住的是什么，在项目中遇到了吗？ synchronized本身并不是锁，锁本身是一个对象，synchronized最多相当于“加锁”操作，所以synchronized并不是锁住代码块。 （重点）Java中的每一个对象都可以作为锁，具体表示有三种形式： 面试中面试官经常会说：“单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁方式实现单例模式的原理呗！” 12345678910111213141516public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123;&#125; public synchronized static Singleton getUniqueInstance() &#123; //先判断对象是否已经实例过，没有实例化过才进⼊加锁代码 if (uniqueInstance WX null) &#123; //类对象加锁 synchronized (Singleton.class) &#123; if (uniqueInstance WX null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; uniqueInstance 采用 volatile 关键字修饰也是很有必要的， 1uniqueInstance = new Singleton(); 这段代码其实是分为三步执行： 为 uniqueInstance 分配内存空间 初始化 uniqueInstance 将 uniqueInstance 指向分配的内存地址 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致⼀个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回uniqueInstance，但此时 uniqueInstance 还未被初始化。 1.4 synchronized锁的优化机制了解吗？ 参考：死磕Synchronized底层实现 美团技术团队 synchronized本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括： 自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁； 锁的状态从低到高依次为：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁。 常见的锁： 无锁：无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。 锁到底存在哪里呢？答案就是对象头中。 对象头主要又包括了两部分数据：Mark Word（标记字段）、Class Point（类型指针）。 初始mark word 将是可偏向状态，此时的 是否偏向锁 为 0，表示当前没有任何一个线程持有该锁。 偏向锁：在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。 JDK1.6 中为了提高一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能，引入了偏向锁。在第一次获得锁时，会有一个 CAS 操作（见下）；之后该线程再获取锁，只会执行几个简单的命令，而不是开销相对较大的 CAS 命令。 CASE 1 : 线程第一次获得锁，如果未偏向，通过 CAS 指令： 插入线程ID : 向mark word插入线程ID 偏向锁标识：将 mark word 中的偏向锁标识从0→1 锁标志位：不修改！因为不变！ 如果操作成功：，则说明获得了偏向锁，以后当前线程等于owner就可以零成本的直接获得锁； 如果操作失败，说明有其它线程获取了锁： 如果偏向线程还存在：直接进行升级为轻量级锁； 如果偏向线程不存在：先修改锁标识为01→00 ，再升级为轻量级锁。 CASE 2 : 这是一次可重入，偏向线程是自己。 在当前线程栈中找到一个可用的 Lock Record ：并将其 obj 指向锁对象 &amp; Displaced Mark Word 置为null 轻量级锁：当发现多线程竞争时，偏向锁会升级为轻量级锁，一般来说，会在 safepoint（此时用户代码不会执行）中去查看偏向的线程是否还存活。 如果偏向的线程已经不存活或者不在同步块中，则将对象头的 mark word 改为无锁状态（unlocked），重新偏向新的线程； 如果存活且还在同步块中，原偏向的线程继续拥有锁，当前线程则走入到轻量级锁的加锁逻辑中； 轻量级锁的处理流程 ： 发现已经有偏向的线程了，则会先 撤 销偏向锁，然后升级为轻量锁 。通过CAS命令更新： 修改此前 当前线程栈帧Lock Record： （1）Displaced Mark Word 复制 mark word （此时无锁状态）中的现有内容 修改mark word ：mark word 指向当前线程栈帧Lock Record的 Displaced Mark Word的地址，见上图； 修改锁标志位： 01 → 00 上述CAS更新成功，则当前线程获得了对象的锁 ； 如果不成功： 检查Mark Word是否指向当前线程的栈帧的Lock Record ，是则是一次可重入 设置Lock Record第一部分（Displaced Mark Word）为null，起到了一个重入计数器的作用。然后结束。 如果不是则是进行自旋等待 当1.自旋超过一定的次数（默认10），或者2.一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。 重量级锁：内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。 Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁Monitor，称为内部锁或者Monitor锁。 Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。 如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。线程去获取重量级锁，其实就是就尝试获取对象的monitor锁。 即将 monitor锁的 Owner字段修改为当前线程ID 。 如果获取成功，此时线程获得了锁，CAS修改 ： 修改mark word ：然后将对象头mark word 改为指向该 monitor 的指针。 锁标志位：00 → 10 1.5 为什么说Synchronized是非公平锁，这样的优缺点是什么？ 并非是按照申请锁的时间前后给等待线程分配锁的，每当锁被释放后，任何一个线程都有机会竞争到锁。 优点：这样做的目的是为了提高执行性能； 缺点：是可能产生线程饥饿现象。 1.6 为什么说synchronized是一个悲观锁？乐观锁的实现原理又是什么？ 没看完，了解了下核心问题：https://www.cnblogs.com/jojop/p/14022029.html synchronized悲观锁 Synchronized显然是一个悲观锁，因为它的并发策略是悲观的： 不管是否会产生竞争，任何的数据都必须加锁。 synchronized原理 Synchronized是通过获取对象内部的一个叫做监视器锁（monitor）来实现的，每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权。 监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者； 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1； 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。 乐观锁实现原理：CAS 参考好文：一文彻底搞懂CAS实现原理 1.7 （CAS原理重点）什么是CAS？CAS的缺点？说说CAS源码实现？ 乐观锁的核心算法是CAS（Compared And Swap，比较并交换）： 关键逻辑： CAS，有几个重要的参数： （1）this，Unsafe 对象本身，需要通过这个类来获取 value 的内存偏移地址。 （2）valueOffset，value 变量的内存偏移地址。 （3）expect，期望更新的值。 （4）update，要更新的最新值。 如果原子变量中的 value 值等于 expect，则使用 update 值更新该值并返回 true，否则返回 false。 CAS特性： CAS具有原子性，它的原子性由CPU硬件指令实现保证。 【缺点1】ABA问题：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。 解决ABA： 在变量前面加上版本号，每次变量更新的时候变量的版本号都+1，即A-&gt;B-&gt;A就变成了1A-&gt;2B-&gt;3A 【缺点2】只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。 【缺点3】循环时间长开销大：对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。 CAS源码分析 参考：Java CAS 原理分析 CAS 全称是 compare and swap，是一种用于在多线程环境下实现同步功能的机制。 CAS 操作包含三个操作数 – 内存位置、预期数值和新值。CAS 的实现逻辑是将内存位置处的数值与预期数值想比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。 Java 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的，下面是具体分析。 背景介绍 在多核心时代下，多个核心通过同一条总线和内存以及其他硬件进行通信。 CPU 的多个核心同时对同一片内存进行操作，会导致错误。例如，递增指令inc dword ptr [...]，等价于DEST = DEST + 1。该指令包含三个操作读-&gt;改-&gt;写，涉及两次访存。 核心1,2从内存读取数据1，并写到各自寄存器中 核心1将寄存器中数据1→2 核心2将寄存器中数据1→2 然后都写回主存，此时为2 可以看到，由于核心2在核心1写入主存操作完成前进行读取，导致并不是我们期望的3 。 通过在递增inc 指令前添加 lock 前缀，可以让核心独占某个内存区域，由此可以避免上面问题。lock 前缀保证核心独占某片内存区域，有两种方式： 总线锁。总线被锁定后，其他核心就不能访问内存了，可能会导致其他核心短时内停止工作； 缓存锁。若某处内存数据被缓存在处理器缓存中，处理器发出的 LOCK# 信号不会锁定总线，而是锁定缓存对应的内存区域。其他处理器在这片内存区域锁定期间，无法对这片内存区域进行相关操作。（不是乐观机制都可以操作吗？不能写入内存？） 源码分析 我们分析，java.util.concurrent.atomic 包下的原子类 AtomicInteger 中的 compareAndSet 方法 。 AtomicInteger具体实现中，compareAndSet 实际上只是一个壳子，主要的逻辑封装在 Unsafe 的 compareAndSwapInt 方法中； compareAndSwapInt是一个native方法 1public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x); 123456789101112131415161718192021222324252627282930313233public class AtomicInteger extends Number implements java.io.Serializable &#123; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; // 计算变量 value 在类对象中的偏移 valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; public final boolean compareAndSet(int expect, int update) &#123; /* * compareAndSet 实际上只是一个壳子，主要的逻辑封装在 Unsafe的compareAndSwapInt 方法中 */ return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; // ......&#125;public final class Unsafe &#123; // compareAndSwapInt 是 native 类型的方法，继续往下看 public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); // ......&#125; 下面我们进入unsafe.cpp（compareAndSwapInt是native方法）具体实现中，看看调用： 12345678910111213141516171819202122232425// unsafe.cpp/* * 这个看起来好像不像一个函数，不过不用担心，不是重点。UNSAFE_ENTRY 和 UNSAFE_END 都是宏， * 在预编译期间会被替换成真正的代码。下面的 jboolean、jlong 和 jint 等是一些类型定义（typedef）： * */UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;); oop p = JNIHandles::resolve(obj); // 根据偏移量，计算 value 的地址。这里的 offset 就是 AtomaicInteger 中的 valueOffset jint* addr = (jint *) index_oop_from_field_offset_long(p, offset); // 调用 Atomic 中的函数 cmpxchg，该函数声明于 Atomic.hpp 中 return (jint)(Atomic::cmpxchg(x, addr, e)) == e;UNSAFE_END// atomic.cppunsigned Atomic::cmpxchg(unsigned int exchange_value, volatile unsigned int* dest, unsigned int compare_value) &#123; assert(sizeof(unsigned int) == sizeof(jint), &quot;more work to do&quot;); /* * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载 * 接下来分析 atomic_windows_x86.inline.hpp 中的 cmpxchg 函数实现 */ return (unsigned int)Atomic::cmpxchg((jint)exchange_value, (volatile jint*)dest, (jint)compare_value);&#125; 分析 Windows 平台下的 Atomic::cmpxchg 函数为例，看看具体实现。 123456789101112131415161718// atomic_windows_x86.inline.hpp#define LOCK_IF_MP(mp) __asm cmp mp, 0 \\ __asm je L0 \\ __asm _emit 0xF0 \\ __asm L0: inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) &#123; // 判断是否是多核 CPU int mp = os::is_MP(); __asm &#123; // 将参数值放入寄存器中 mov edx, dest // 注意: dest 是指针类型，这里是把内存地址存入 edx 寄存器中 mov ecx, exchange_value mov eax, compare_value LOCK_IF_MP(mp) // 核心比较写入操作 cmpxchg dword ptr [edx], ecx &#125;&#125; 其中LOCK_IF_MP实际内容如下： 12345678910111213141516171819202122232425 // LOCK_IF_MP cmp mp, 0 /* * 如果 mp = 0，表明是线程运行在单核 CPU 环境下。此时 je 会跳转到 L0 标记处， * 也就是越过 _emit 0xF0 指令，直接执行 cmpxchg 指令。也就是不在下面的 cmpxchg 指令前加 lock 前缀。 */ je L0 /* 0xF0 是 lock 前缀的机器码，这里没有使用 lock，而是直接使用了机器码的形式。*/ _emit 0xF0L0: /* * 比较并交换。简单解释一下下面这条指令，熟悉汇编的朋友可以略过下面的解释: * cmpxchg: 即“比较并交换”指令 * dword: 全称是 double word，在 x86/x64 体系中，一个 * word = 2 byte，dword = 4 byte = 32 bit * ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元 * [edx]: [...] 表示一个内存单元，edx 是寄存器，dest 指针值存放在 edx 中。 * 那么 [edx] 表示内存地址为 dest 的内存单元 * * 这一条指令的意思就是，将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值 * 进行对比，如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中。 */ cmpxchg dword ptr [edx], ecx &#125;&#125; 实际举例说明 AtomicInteger 类主要利用 CAS (compare and swap) + volatile 来保证原子操作。AtomicInteger 的主要方法都是通过调用Unsafe类方法去实现，如 compareAndSet 实际是调用AtomicInteger 的compareAndSwapInt方法。 下面以 getAndIncrement实现来说明。 getAndIncrement调用了 Unsafe的getAndAddInt方法，传递了（1）当前this对象，（2）value偏移量，用来计算得到value值（3）要加上的值，由于是递增所以是1 ⚠️ 为什么不传value的值，而是偏移量？ 传偏移量是为了计算value所在的内存地址，进而获取最新的value值。 getAndAddInt采用CAS方式进行更新，还需要进行当前期望值的计算 通过getIntVolatile获取到线程此时内存value值（期望值），也就是记录执行CAS前的内存最新value值； 然后开始执行Unsafe的 compareAndSwapInt ，主要是通过Atomic::cmpxchg 逻辑来实现 （1）将要dest（value内存地址），compareValue（期望值），exchange_value（要更新的值）写入寄存器中 （2）线程如果是运行多核CPU，上LOCK#锁，将dest内存区域锁住 ；否则不上LOCK#锁 （3）执行cmpxchg（比较并交换命令），如果dest的value值（执行CAS中的最新value值） == compareValue，则写入exchange_value ； （4）否则写入失败，通过不断自旋（循环）期望得到执行 1.8 请说明一下synchronized的可重入怎么实现？ 每个锁关联一个线程持有者对象和一个计数器。 当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁（即monitor对象）而调用相应方法。 当一个线程请求成功后，JVM对象头会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。 而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。 当线程退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁。 1.9 在synchronized偏向锁过程中，调用hashcode方法，markword会发生什么？ 第一次调用Hashcode：当对象的hashCode()方法（非用户自定义）第一次被调用时，JVM会生成对应的identity hash code值，并将该值存储到Mark Word中 。 后续如果该对象的hashCode()方法再次被调用则不会再通过JVM进行计算得到，而是直接从Mark Word中获取，保证唯一相同。 无锁状态：在无锁状态下，Mark Word中可以存储对象的identity hash code值 ； 偏向锁状态：需要计算其identity hash code的话，则它的偏向锁会被撤销（因为没有保存的位置），并且锁会膨胀为轻量级锁或者重量锁 ； 轻量锁状态：线程栈帧的Lock Recode可以记录存储Displaced Mark Word ，所以轻量级锁可以和identity hash code 共存 ； 重量级锁状态：ObjectMonitor类里有字段HashCode可以记录非加锁状态下的mark word，所以重量级锁也可以和identity hash code共存； 1.10 Synchronized 确定不可中断吗？如果一个线程访问Synchronized 代码，其它线程可以能否中断？比如使用Stop？是在中断前还是中断后获取锁？ 参考：https://blog.csdn.net/deel_feel/article/details/105771902 正确说法时：只有获取到锁之后才能中断，等待锁时不可中断。 1.5.2 Reetrantlock 相关 ReentrantLock意思为可重入锁 。 2.1 非公平锁和公平锁在reetrantlock里的实现过程是怎样的？ 美团技术文章-java-lock 公平锁：那么锁的 获取顺序 就应该符合请求的 绝对时间顺序，FIFO 非公平锁：只要CAS设置同步状态成功state，则表示当前线程获取了锁 但公平锁还需要判断当前节点是否有前驱节点，如果有，则表示有线程比当前线程更早请求获取锁，因此需要等待。 【源码分析】 基本结构 根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS，添加锁和释放锁的大部分操作实际上都是在Sync中实现的。 Sync有公平锁FairSync和非公平锁NonfairSync两个子类； ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。 公平和非公平锁区分 公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在CAS获取同步状态时，多了一个限制条件：hasQueuedPredecessors()。 该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。 2.2 ReentrantLock的实现原理？ ReentrantLock的实现基于队列同步（AbstractQueuedSynchronizer，后面简称AQS）。关于AQS的实现原理见下。 ReentrantLock的核心，是通过修改AQS中state的值来同步锁的状态。 2.3 希望等待一段时间锁没有获取，可以自动放弃用哪种锁？ Lock（ReentranLock） 但是基于AQS的源码哪里体现了？ 应该Lock锁的代码里自己的实现吧。 1.5.3 AQS 相关 3.1 什么是AQS请你简单介绍一下？ AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。 AQS是⼀个用来构建锁和同步器的框架，使⽤AQS能简单且高效地构造出应用⼴泛的大量的同步器。 例如：ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue等等皆是基于AQS的。当然，我们⾃⼰也能利⽤AQS非常轻松容易地构造出符合我们⾃⼰需求的同步器。 3.2 请介绍一下AQS原理？ 后续建议研读：从ReentrantLock的实现看AQS的原理及应用 先带着问题来进行看下面内容： Q：某个线程获取锁失败的后续流程是什么呢？ A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。 Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？ A：是CLH变体的FIFO双端队列。 Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？ A：可以详细看下2.3.1.3小节。 Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？ A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。 Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？ A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。 核心原理概览 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。 如果被请求的共享资源被占用，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是⽤CLH队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。 CLH(Craig,Landin,and Hagersten)队列是⼀个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成⼀个CLH锁队列的⼀个结点（Node）来实现锁的分配。 AQS使用⼀个int成员变量state来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队⼯作。AQS使⽤CAS对该同步状态进行原子操作实现对其值的修改。 1private volatile int state; //共享变量，使⽤volatile修饰保证线程可见性 状态信息通过protected类型的getState，setState，compareAndSetState进行操作 。 AQS 对资源的共享方式 AQS定义两种资源共享方式，可以通过修改state字段来实现多线程的独占（经典如ReentranLock）和共享模式。 Exclusive（独占）：只有⼀个线程能执行，如ReentrantLock。⼜可分为公平锁和非公平锁： 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的 Share（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。 AQS详细原理 最终参考：从源码角度彻底理解ReentrantLock(重入锁) 以下是基于ReentractLock语境下进行分析。 加锁过程：非公平锁 简单来说：新建线程→CAS尝试快速获取锁→tryAcquire()CAS修改state→addWaiter() 获取失败CAS尝试插入队尾入队→acquireQueued等待前驱线程唤醒继续CAS获取锁 加锁流程从lock.lock()开始 123public void lock() &#123; sync.lock();&#125; 进入该源码,正确找到sycn的实现类后可以看到真正有内容的入口方法： CAS尝试快速加锁，在ReentranLock只有state=0，才能更新成功（因为是非多线程共享资源） 获取锁失败执行acquire方法 12345678 // 加锁流程真正意义上的入口 final void lock() &#123; //以cas方式尝试将AQS中的state从0更新为1 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread());//获取锁成功则将当前线程标记为持有锁的线程,然后直接返回 else acquire(1);//获取锁失败则执行该方法&#125; acquire 在主要的逻辑都在if判断条件中,这里面有3个重要的方法tryAcquire()，addWaiter() 和 acquireQueued() 。 12345 public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; acquire流程1：tryAcquire() tryAcquire()在公平和非公平下获取的方式不一样，这里只说非公平实现。 如果state==0（未被其它线程持有），CAS尝试获取锁, 如果当前线程==持有锁的线程，可重入 ，state+1 否则 reture false获取锁失败，加入等待队列 123456789101112131415161718final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread();//获取当前线程实例 int c = getState();//获取state变量的值,即当前锁被重入的次数 if (c == 0) &#123; //state为0,说明当前锁未被任何线程持有 if (compareAndSetState(0, acquires)) &#123; //以cas方式获取锁 setExclusiveOwnerThread(current); //将当前线程标记为持有锁的线程 return true;//获取锁成功,非重入 &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; //当前线程就是持有锁的线程,说明该锁被重入了 int nextc = c + acquires;//计算state变量要更新的值 if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc);//非同步方式更新state值 return true; //获取锁成功,重入 &#125; return false; //走到这里说明尝试获取锁失败&#125; acquire流程2：addWaiter() 主要逻辑如下： 首先通过new Node()创建一个空结点； 如果队列不空**，以CAS方式让新节点插入到队尾; 如果队列为空，执行enq(node) 逻辑 1234567891011121314151617181920212223242526272829private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode);//首先创建一个新节点,并将当前线程实例封装在内部,mode这里为null // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node);//入队的逻辑这里都有 return node; &#125; private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail;//t指向当前队列的最后一个节点,队列为空则为null if (t == null) &#123; // Must initialize //队列为空 if (compareAndSetHead(new Node())) //构造新结点,CAS方式设置为队列首元素,当head==null时更新成功 tail = head;//尾指针指向首结点 &#125; else &#123; //队列不为空 node.prev = t; if (compareAndSetTail(t, node)) &#123; //CAS将尾指针指向当前结点,当t(原来的尾指针)==tail(当前真实的尾指针)时执行成功 t.next = node; //原尾结点的next指针指向当前结点 return t; &#125; &#125; &#125; &#125; acquire流程3：acquireQueued() 线程加入同步队列后，获取锁的流程是什么呢？ 简单来说，就是不断判断当前是否是老二，并尝试去获取锁。 SIGNAL ：意味着线程释放锁后会唤醒后面阻塞的线程。毕竟，只有确保能够被唤醒，当前线程才能放心的阻塞 123456789101112131415161718192021222324final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; //死循环,正常情况下线程只有获得锁才能跳出循环 for (;;) &#123; final Node p = node.predecessor();//获得当前线程所在结点的前驱结点 //第一个if分句 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); //将当前结点设置为队列头结点 p.next = null; // help GC failed = false; return interrupted;//正常情况下死循环唯一的出口 &#125; //第二个if分句 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; //判断是否要阻塞当前线程 parkAndCheckInterrupt()) //阻塞当前线程 interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; 解锁：非公平锁 加锁：公平锁 简单来说：新来线程→【必须】先CAS加入等待队列→等待前驱节点释放锁（state=0），如果是老二则获取锁。 公平锁加锁入口加锁从： 123finally void lock() &#123; acqiuire();&#125; 在之前非公平锁的逻辑中，线程有三次机会获取锁： 新创建时，CAS尝试修改state=1，去获取 可重入，当前获取锁线程为自己 前驱节点释放锁，自己作为老二被唤醒 而公平锁，只能按加入队列的先后次序 &amp; 可重入获得锁 ： 所有线程在获取锁前必须先加入同步队列 如果state=0，hasQueuedPredecessors判断当前是头节点，则获取锁 3.3 为什么基于FIFO的同步队列可以实现非公平锁？ 因为非公平锁，除了等前驱节点唤醒去获取锁 ，还有以下三种方式获取锁： 新创建时，CAS尝试修改state=1，去获取 公平锁：进来先执行hasQueuedPredecessors() , 看等待队列是否有有效节点，有的话不能获取锁！ 可重入，当前获取锁线程为自己 公平锁：也可以 同步队列等待，等待唤醒获取锁 公平锁：也可以 并且在锁释放时：是先释放锁（修改state=-1），再去唤醒后继节点 会导致新来的线程，可能在后继节点被唤醒前就获取了锁，这就不会公平 3.4 【易忘】为什么非公平锁性能好？ .线程不必加入等待队列就可以获得锁,不仅免去了构造结点并加入队列的繁琐操作 ，节省了线程阻塞、唤醒的开销（这涉及到上下文的切换）； 减少CAS竞争。如果线程必须要加入阻塞队列才能获取锁,那0将变得异常激烈,CAS操作虽然不会导致失败线程挂起,但不断失败重试导致的对CPU的浪费也不能忽视 3.4 AQS 有哪些组件，请简单介绍一下？介绍一下CountDownLatch的应用场景 ？ Semaphore(信号量)：Semaphore(信号量)可以指定多个线程同时访问某个资源； synchronized 和 ReentrantLock 都是⼀次只允许⼀个线程访问同时某个资源。 计数信号量具备两种操作动作，称为V（signal()）与P（wait()）（即部分参考书常称的“PV操作”）。V操作会增加信号标S的数值，P操作会减少它。 运行P（wait()），信号标S的值将被减少。企图进入临界区段的进程，需要先运行P（wait()）。当信号标S减为负值时，进程会被挡住，不能继续；当信号标S不为负值时，进程可以获准进入临界区段。 CountDownLatch （倒计时器）： CountDownLatch是⼀个同步⼯具类，用来协调多个线程之间的同步。这个⼯具通常用来控制线程等待，它可以让某⼀个线程等待直到倒计时结束，再开始执行。 CyclicBarrier(循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能⽐ CountDownLatch 更加复杂和强大。主要应用场景和CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让⼀组线程到达⼀个屏障（也可以叫同步点）时被阻塞，直到最后⼀个线程到达屏障时，屏障才会开⻔，所有被屏障拦截的线程才会继续⼲活。 CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调⽤**await()**方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。 CountDownLatch的应用场景 我们要读取处理6个⽂件，这6个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这6个⽂件的处理的结果进行统计整理。 为此我们定义了⼀个线程池和count为6的 CountDownLatch 对象 。使用线程池处理读取任务，每⼀个线程处理完之后就将count-1，调用 CountDownLatch 对象的 await() 方法，直到所有⽂件读取完之后，才会接着执行后面的逻辑。 123456789101112131415161718192021222324252627public class CountDownLatchExample1 &#123; // 处理⽂件的数量 private static final int threadCount = 6; public static void main(String[] args) throws InterruptedException &#123; // 创建⼀个具有固定线程数量的线程池对象（推荐使用构造方法创建） ExecutorService threadPool = Executors.newFixedThreadPool(10); final CountDownLatch countDownLatch = newCountDownLatch(threadCount); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadnum = i; threadPool.execute(() → &#123; try &#123; //处理⽂件的业务操作 ...... &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; //表示⼀个⽂件已经被完成 countDownLatch.countDown(); &#125; &#125;); &#125; countDownLatch.await(); threadPool.shutdown(); System.out.println(&quot;finish&quot;); &#125;&#125; 1.5.4 Volatile 关键字 4.0 JMM 是什么 ？ 缓存一致性协议MESI ? CPU内存屏障？JAVA内存屏障？ 参考：并发编程-（4）-JMM基础（总线锁、缓存锁、MESI缓存一致性协议、CPU 层面的内存屏障） JMM定义 全称Java Memory Model（java内存模型）是一系列的Java虚拟机平台对开发者提供的多线程环境下的内存可见性、是否可以重排序等问题的无关具体平台的统一的保证。 MESI 缓存一致性协议协议 缓存不一致问题 CPU处理速度，远大于I/O设备（磁盘），为了解决了处理器与内存的速度矛盾，引入了高速缓存。但是由此也带来了缓存不一致的问题。 每个线程都会缓存内存的数据在各自寄存器中，在不同 CPU 中运行的不同线程看到同一份内存的缓存值不一样就会存在缓存不一致的问题。 MESI协议内容 为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，最常见的就是 MESI 协议： MESI 表示缓存行的四种状态，分别是： 在 MESI 协议中，每个缓存的缓存控制器不仅知道自己的 读写操作，而且也监听(snoop)其它 Cache 的读写操作。 M(Modify) 表示共享数据只缓存在当前 CPU 缓存中， 并且是被修改状态，也就是缓存的数据和主内存中的数据不一致。 E(Exclusive) 表示缓存的独占状态，数据只缓存在当前 CPU 缓存中，并且没有被修改。 S(Shared) 表示数据可能被多个 CPU 缓存，并且各个缓存中的数据和主内存数据一致。 I(Invalid) 表示缓存已经失效。 对于 MESI 协议，从 CPU 读写角度来说会遵循以下原则： CPU 读请求：缓存处于 M、E、S 状态都可以被读取，I 状 态 CPU 只能从主存中读取数据； CPU 写请求：缓存处于 M、E 状态才可以被写。对于 S 状 态的写，需要将其他 CPU 中缓存行置为无效才可写。 Store Bufferes（存储缓存） CPU 缓存行的状态是通过消息传递来进行的，如果 CPU0 要对一个在缓存中共享的变量进行写入，首先发送一个失效的消息给到其他缓存了该数据的 CPU。并且要等到他们的确认回执。CPU0 在这段时间内都会处于阻塞状态。 为了避免阻塞带来的资源浪费。在 cpu 中引入 了 Store Bufferes（存储缓存） 和 Invalidate Queue（无效队列）。 CPU0 写入共享数据时，直接把数据写入到 store bufferes 中，同时发送 invalidate 消息，然后继续去处理其他指令； 收到其他所有 CPU 发送了 invalidate ACK消息时，再将 store bufferes 中的数据数据存储至 cache 中； 最后再从本地Cache同步到主内存。 CPU层面内存屏障 内存屏障就是将 Store Bufferes 中的指令写入到内存，从而使得其他访问同一共享内存的线程的可见性。 硬件层的内存屏障分为两种：Load Barrier （读屏障）和 Store Barrier（写屏障）及 Full Barrier（全屏障）是读屏障和写屏障的合集。 写屏障：强制把写缓冲区/高速缓存中的脏数据等写回主内存 读屏障：将缓冲区/高速缓存中相应的数据失效。 JAVA 内存屏障 java的内存屏障通常所谓的四种，LoadLoad（LL）, StoreStore（SS）, LoadStore（LS）, StoreLoad（SL)实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。 LoadLoad（LL）屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。 StoreStore（SS）屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。 LoadStore（LS）屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。 StoreLoad（SL）屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。 4.1 什么是HappenBefore原则？ 在 JMM 中，如果一个操作执行的结果需要对另一个操作【可见】，那么这两个操作必须要存在 happens-before 关系。这两个操作可以是同一个线程，也可以是不同的线程。 它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见 。 HappenBefore原则 as-if-serial 规则（程序顺序执行）：单个线程中的代码顺序不管怎么重排序，对于结果来说是不变的。 volatile 变量规则，对于 volatile 修饰的变量的写操作， 一定 happen-before 后续对于 volatile 变量的读操作; 监视器锁规则（monitor lock rule）：对一个监视器的解锁，happens-before于随后对这个监视器的加锁。 传递性规则：如果A happens-before B，且B happens-before C，那么A happens-before C。 start 规则：如果线程 A 执行操作 ThreadB.start(),那么线程 A 的 ThreadB.start()操作 happens-before 线程 B 中的任意操作。 join 规则：如果线程 A 执行操作 ThreadB.join()并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join()操作成功返回。 举例说明：什么是指令重排序？ 请看下面代码： 假设 线程A执行writer()方法之后，线程B执行reader()方法，那么线程B执行4的时候一定能看到线程A写入的值吗？ 12345678910111213141516class VolatileExample &#123; int a = 0; volatile boolean flag = false; public void writer() &#123; a = 1; //1 flag = true; //2 &#125; public void reader() &#123; if (flag) &#123; //3 int i = a; //4 ... &#125; &#125;&#125; 答案是肯定的。因为根据happens-before规则，我们可以得到如下关系： 根据程序顺序规则，1 happens-before 2；3 happens-before 4 根据volatile规则，2 happens-before 3； 根据传递性规则，1 happens-before 4 。 因此，综合运用程序顺序规则、volatile规则及传递性规则，我们可以得到1 happens-before 4，即线程B在执行4的时候一定能看到A写入的值。 4.2 Volatile 关键字原理 参考：https://www.cnblogs.com/paddix/p/5428507.html 。 此题考察的是volatile这个关键字。可以从volatile的作用和volatile的原理这三个方面来进行回答。volatile只能保证变量的可见性、有序性，但是不能保证原子性。 可见性实现原理 为了实现volatile可见性和happen-befor的语义。JVM底层是通过一个叫做“内存屏障（基于MESI）”的东西来完成（也实现了有序性 ？）。 线程本身并不直接与主内存进行数据的交互，而是通过线程的工作内存来完成相应的操作。这也是导致线程间数据不可见的本质原因。 使用MESI 协议，使得任意一个线程修改了 volatile 修饰的变量，其他线程可以马上识别到最新值。 最终目标：保证了缓存的一致性。 具体的话，下面是用内存屏障来实现的。 修改本地工作内存，强制刷回主内存； 强制让其他线程的工作内存失效过期； 其他线程重新从主内存加载最新值； 有序性实现原理 参考：https://blog.csdn.net/qq_42764468/article/details/106898608 从源代码到最终执行的指令，可能会经过三种重排序： 【指令】重排序，JMM 会要求编译器生成指令时，会插入内存屏障来禁止处理器重排序。 JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止：①特定类型的编译器重排序和②处理器重排序，为程序员提供一致的内存可见性保证。 编译器重排序，JMM 禁止了特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。 内存重排序：由于处理器会使用读/写缓冲区，出于性能的原因，内存会对读/写进行重排序 JVM 是使用内存屏障来禁止【指令】重排，从而达到：可见性 + 部分有序性效果。 lock前缀指令实际相当于一个内存屏障？ 下面不是可见性吗？？？ 对volatile变量的写操作与普通变量的主要区别有两点： 修改volatile变量前，会强制将修改后的值刷新的主内存中。 每个volatile写操作前插入StoreStore（SS）屏障 修改volatile变量后，会导致其他线程工作内存中对应的变量值失效，因此，再读取该变量值的时候就需要重新从读取主内存中的值。 在写操作后插入StoreLoad屏障； 对volatile变量的读操作类似： 在每个volatile读操作前插入LoadLoad（LL）屏障； 确保Load2及后续Load指令加载数据之前能访问到Load1加载的数据。 在读操作后插入LoadStore（LS屏障）。 确保Store2和后续Store指令执行前，可以访问到Load1加载的数据。 4.3 volatile为什么不能保证原子性？ 参考：为什么volatile能保证有序性不能保证原子性 对于i++这种复合操作，即使使用volatile关键字修饰也不能保证操作的原子性，可能会引发数据不一致问题。 12private volatile int i = 0;i++; 上述i++操作，其实分为三个操作： 线程读取i temp = i + 1 i = temp A,B两个线程多线程操作时： A线程读取i并执行了 temp = i + 1的操作， 此时的 i（0） 的值还没有变化 此时B也读入i并执行temp = i + 1操作，此时i（0）也没变化 ⚠️ 虽然有MESI协议，但是temp不保存变量i所在内存区域，是cpu内部的计算，不会被立马刷新内存！ 当A写入i = temp（1）时，由于可见性立马在主存被刷新了值 i=1 当B也写入i = temp时，此时A依旧是1，而不是2 4.4 并发编程的三个重要特性 ？ 原子性 : ⼀个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的⼲扰而中断，要么所有的操作都执行，要么都不执行。 synchronized 可以保证代码片段的原子性。 可见性 ：当⼀个变量对共享变量进行了修改，那么另外的线程都是⽴即可以看到修改后的最新值。 volatile 关键字可以保证共享变量的可见性。 有序性：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。 volatile 关键字可以禁⽌指令进行重排序优化。 4.5 说说 synchronized 关键字和 volatile 关键字的区别？ synchronized关键字和volatile关键字比较： volatile关键字是线程同步的轻量级实现，所以volatile性能肯定⽐synchronized关键字要好。 volatile关键字只能用于变量，而synchronized关键字可以修饰方法以及代码块。 synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引⼊的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多⼀些。 volatile关键字只能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发⽣阻塞 1.5.5 Atomic 原子类 5.1 什么是Atomic 原子类？ 所以，所谓原子类说简单点就是具有原子/原子操作特征的类。 在我们这⾥ Atomic 是指⼀个操作是不可中断的。即使是在多个线程⼀起执行的时候，⼀个操作⼀旦开始，就不会被其他线程⼲扰。 5.2 JUC 包中的原子类是哪4类? 5.3 Volatile 和 atomic 变量区别？ Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。 而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。 5.4 讲讲 AtomicInteger 的使用 ？ 1234567public final int get() //获取当前的值public final int getAndSet(int newValue)//获取当前的值，并设置新的值public final int getAndIncrement()//获取当前的值，并⾃增public final int getAndDecrement() //获取当前的值，并⾃减public final int getAndAdd(int delta) //获取当前的值，并加上预期的值boolean compareAndSet(int expect, int update) //如果输⼊的数值等于预期值，则以原子方式将该值设置为输⼊值（update）public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet设置之后可能导致其他线程在之后的⼀小段时间内还是可以读到旧的值。 使用示例： 123456789101112class AtomicIntegerTest &#123; // 基本类型也要是原子类 private AtomicInteger count = new AtomicInteger(); //使⽤AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。 public void increment() &#123; count.incrementAndGet(); &#125; public int getCount() &#123; return count.get(); &#125;&#125; 5.5（重点提问） AtomicInteger 原理？ AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。 我们以自增方法为例： getAndIncrement 123public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125; 可以看到，本质是在调用 unsafe中的 getAndAddInt unsafe中的compareAndSwapInt方法参数。 1compareAndSwapInt(Object o, long offset,int expected,int x); // x是准备更新的值 123456789101112131415public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125;// Unsafe中的方法public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; // getIntVolatile方法获取到期望值value后去调用compareAndSwapInt方法，失败则进行重试 do &#123; // var5是计算得到的期望值，获取此时内存的最新值（因为value是votilate修饰，修改总是被能及时看到） var5 = this.getIntVolatile(var1, var2); // 计算传入compareAndSwapInt的四个参数 // var1：传入的this对象；var2：value内存偏移值；var5：期望值，希望和【var2】一致； var5+var4：var5+var4（1），递增 &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 最终总结如下 AtomicInteger 类主要利用 CAS (compare and swap) + volatile 来保证原子操作。AtomicInteger 的主要方法都是通过调用Unsafe类方法去实现，如 compareAndSet 实际是调用AtomicInteger 的compareAndSwapInt方法。 下面以 getAndIncrement实现来说明。 getAndIncrement调用了 Unsafe的getAndAddInt方法，传递了（1）当前this对象，（2）value偏移量valueoffset，用来计算得到value值（3）要加上的值，由于是递增所以是1 ⚠️ 为什么不传value的值，而是偏移量？ 传偏移量是为了计算value所在的内存地址，进而获取最新的value值。 getAndAddInt采用CAS方式进行更新，还需要进行当前期望值的计算 通过getIntVolatile获取到线程此时内存value值（期望值），也就是记录执行CAS前的内存最新value值； 然后开始执行Unsafe的 compareAndSwapInt ，主要是通过Atomic::cmpxchg 逻辑来实现 （1）将要dest（value内存地址），compareValue（期望值），exchange_value（要更新的值）写入寄存器中 （2）线程如果是运行多核CPU，上LOCK#锁，将dest内存区域锁住 ；否则不上LOCK#锁 （3）执行cmpxchg（比较并交换命令），如果dest的value值（执行CAS中的最新value值） == compareValue，则写入exchange_value ； （4）否则写入失败，通过不断自旋（循环）期望得到执行","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"JAVA","slug":"校招笔记/JAVA","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://hwh.zone/tags/JAVA/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"}]},{"title":"校招笔记（一）_Java_多线程","slug":"校招笔记（一）_Java_多线程","date":"2021-11-26T12:01:58.657Z","updated":"2021-11-26T16:31:44.330Z","comments":true,"path":"2021/11/26/校招笔记（一）_Java_多线程/","link":"","permalink":"https://hwh.zone/2021/11/26/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89_Java_%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 🚩 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 1.4 多线程 0.三个线程，如何让他们按顺序打印A、B、C？如果是循环打印10次呢？依次打印1~100呢？交替打印奇偶10次呢？ 参考：https://zhuanlan.zhihu.com/p/370130458 0.1 synchronized + 条件变量 synchronized + 条件变量（循环打印1次） 思路如下： 新建三个线程1、2、3 ，分别负责打印A、B、C；同时，每个线程对应一个条件变量：num%3==当前线程条件变量? ； 把打印的代码用synchronized 加锁，每个线程拿到锁后，while循环判断是否满足当前线程的条件变量 ； 如果满足 ，便执行后续逻辑打印当前线程，之后notifyall()唤醒其它线程； 如果不满足，执行wait等待释放锁； 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.*;class Wait_Notify_ACB &#123; private int num; private static final Object LOCK = new Object(); private void printABC(int targetNum) &#123; // targetNum ： 每个线程应该满足的对应条件变量 synchronized (LOCK) &#123; while (num % 3 != targetNum) &#123; // while ：线程阻塞在wait(),再次被唤醒应该先检查下是否满足条件，因为这个时候未必轮到当前线程执行；用if会导致直接往下执行。 try &#123; LOCK.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; num++; System.out.print(Thread.currentThread().getName()); LOCK.notifyAll(); &#125; &#125; public static void main(String[] args) &#123; Wait_Notify_ACB wait_notify_acb = new Wait_Notify_ACB (); new Thread(() -&gt; &#123; wait_notify_acb.printABC(0); &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; wait_notify_acb.printABC(1); &#125;, &quot;B&quot;).start(); new Thread(() -&gt; &#123; wait_notify_acb.printABC(2); &#125;, &quot;C&quot;).start(); &#125;&#125; synchronized + 条件变量（循环打印10次） 打印10次，只需让三个线程，尝试去竞争10次锁即可。所以在synchronized前加上for循环即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.*;class Wait_Notify_ACB &#123; private int num; private static final Object LOCK = new Object(); private void printABC(int targetNum) &#123; // targetNum ： 每个线程应该满足的对应条件变量 for(int i = 0 ; i&lt;10 ;i++) &#123; synchronized (LOCK) &#123; while (num % 3 != targetNum) &#123; // while ：线程阻塞在wait(),再次被唤醒应该先检查下是否满足条件，因为这个时候未必轮到当前线程执行；用if会导致直接往下执行。 try &#123; LOCK.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; num++; System.out.print(Thread.currentThread().getName()); LOCK.notifyAll(); &#125; &#125; &#125; public static void main(String[] args) &#123; Wait_Notify_ACB wait_notify_acb = new Wait_Notify_ACB (); new Thread(() -&gt; &#123; wait_notify_acb.printABC(0); &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; wait_notify_acb.printABC(1); &#125;, &quot;B&quot;).start(); new Thread(() -&gt; &#123; wait_notify_acb.printABC(2); &#125;, &quot;C&quot;).start(); &#125;&#125; synchronized + 条件变量（打印1~100) 设置一个全局变量，synchronized 中加锁函数对num+1，保证只要每次只有一个线程能执行。 123456789101112131415161718192021222324252627282930313233343536373839404142class Wait_Notify_100 &#123;​ private int num; private static final Object LOCK = new Object(); private int maxnum = 10;​ private void printABC(int targetNum) &#123; while (true) &#123; synchronized (LOCK) &#123; while (num % 3 != targetNum) &#123; //想想这里为什么不能用if代替，想不起来可以看公众号上一篇文章 if(num &gt;= maxnum)&#123; break; &#125; try &#123; LOCK.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if(num &gt;= maxnum)&#123; break; &#125; num++; System.out.println(Thread.currentThread().getName() + &quot;: &quot; + num); LOCK.notifyAll(); &#125; &#125; &#125; public static void main(String[] args) &#123; Wait_Notify_100 wait_notify_100 = new Wait_Notify_100 (); new Thread(() -&gt; &#123; wait_notify_100.printABC(0); &#125;, &quot;thread1&quot;).start(); new Thread(() -&gt; &#123; wait_notify_100.printABC(1); &#125;, &quot;thread2&quot;).start(); new Thread(() -&gt; &#123; wait_notify_100.printABC(2); &#125;, &quot;thread3&quot;).start(); &#125; &#125; synchronized + 条件变量（奇偶打印10次） 12345678910111213141516171819202122232425262728293031class Wait_Notify_Odd_Even&#123; private Object monitor = new Object(); private volatile int count; Wait_Notify_Odd_Even(int initCount) &#123; this.count = initCount; &#125; private void printOddEven() &#123; synchronized (monitor) &#123; while (count &lt; 10) &#123; try // 这里不用while循环判断，是因为下次notifyAll的一定是奇数或偶数 &#123; System.out.print( Thread.currentThread().getName() + &quot;：&quot;); System.out.println(++count); monitor.notifyAll(); monitor.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //防止count=10后，while()循环不再执行，有子线程被阻塞未被唤醒，导致主线程不能退出 monitor.notifyAll(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Wait_Notify_Odd_Even waitNotifyOddEven = new Wait_Notify_Odd_Even(0); new Thread(waitNotifyOddEven::printOddEven, &quot;odd&quot;).start(); Thread.sleep(10); //为了保证线程odd先拿到锁 new Thread(waitNotifyOddEven::printOddEven, &quot;even&quot;).start(); &#125;&#125; 0.2 join join()方法**：在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行**。 基于这个原理，我们使得三个线程按顺序执行，然后循环多次即可。无论线程1、线程2、线程3哪个先执行，最后执行的顺序都是线程1——&gt;线程2——&gt;线程3。 代码如下： 1234567891011121314151617181920212223242526272829303132class Join_ABC &#123; public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 10; i++) &#123; Thread t1 = new Thread(new printABC(null),&quot;A&quot;); Thread t2 = new Thread(new printABC(t1),&quot;B&quot;); Thread t3 = new Thread(new printABC(t2),&quot;C&quot;); t1.start(); t2.start(); t3.start(); Thread.sleep(10); //这里是要保证只有t1、t2、t3为一组，进行执行才能保证t1-&gt;t2-&gt;t3的执行顺序。 &#125; &#125; static class printABC implements Runnable&#123; private Thread beforeThread; public printABC(Thread beforeThread) &#123; this.beforeThread = beforeThread; &#125; @Override public void run() &#123; if(beforeThread!=null) &#123; try &#123; beforeThread.join(); System.out.print(Thread.currentThread().getName()); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;else &#123; System.out.print(Thread.currentThread().getName()); &#125; &#125; &#125;&#125; 0.3 Lock 该方法很容易理解，不管哪个线程拿到锁，只有符合条件的才能打印。 123456789101112131415161718192021222324252627 class Lock_ABC &#123; private int num; // 当前状态值：保证三个线程之间交替打印 private Lock lock = new ReentrantLock(); private void printABC(int targetNum) &#123; for (int i = 0; i &lt; 10; ) &#123; lock.lock(); if (num % 3 == targetNum) &#123; num++; i++; System.out.print(Thread.currentThread().getName()); &#125; lock.unlock(); // 不符合要求直接释放锁，不会像sync一样阻塞在sync或wait处 &#125; &#125; public static void main(String[] args) &#123; Lock_ABC lockABC = new Lock_ABC(); new Thread(() -&gt; &#123; lockABC.printABC(0); &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; lockABC.printABC(1); &#125;, &quot;B&quot;).start(); new Thread(() -&gt; &#123; lockABC.printABC(2); &#125;, &quot;C&quot;).start(); &#125;&#125; 0.4 Semaphore Semaphore：用来控制同时访问某个特定资源的操作数量，或者同时执行某个制定操作的数量。Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。 一个线程要访问共享资源，先使用acquire()方法获得信号量，如果信号量的计数器值大于等于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。如果计数器值为0,线程进入休眠； 当某个线程使用完共享资源后，使用release()释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。 12345678910111213141516171819202122232425262728293031class SemaphoreABC &#123; private static Semaphore s1 = new Semaphore(1); //因为先执行线程A，所以这里设s1的计数器为1 private static Semaphore s2 = new Semaphore(0); private static Semaphore s3 = new Semaphore(0); private void printABC(Semaphore currentThread, Semaphore nextThread) &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; currentThread.acquire(); //阻塞当前线程，即信号量的计数器减1为0 System.out.print(Thread.currentThread().getName()); nextThread.release(); //唤醒下一个线程，即信号量的计数器加1 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; SemaphoreABC printer = new SemaphoreABC(); new Thread(() -&gt; &#123; printer.printABC(s1, s2); &#125;, &quot;A&quot;).start(); Thread.sleep(10); new Thread(() -&gt; &#123; printer.printABC(s2, s3); &#125;, &quot;B&quot;).start(); Thread.sleep(10); new Thread(() -&gt; &#123; printer.printABC(s3, s1); &#125;, &quot;C&quot;).start(); &#125;&#125; 1.4.1 线程基本 1. 什么是线程和进程？如何保证线程安全？ 1.1 什么是线程和进程？ 什么是进程？ 进程是程序的⼀次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行⼀个程序即是⼀个进程从创建，运行到消亡的过程。 如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe ⽂件的运行）。在Windows操作系统中，一个程序只对应一个进程，里面可以有一个或多个线程。 什么是线程？ 线程与进程相似，但线程是⼀个⽐进程更小的执行单位。⼀个进程在其执行的过程中可以产⽣多个线程。 与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有⾃⼰的程序计数器、虚拟机栈和本地方法栈 所以系统在产⽣⼀个线程，或是在各个线程之间作切换⼯作时，负担要⽐进程小得多，也正因为如此，线程也被称为轻量级进程。 ⼀个 Java 程序的运行是 main 线程和多个其他线程同时运行。 1.2 如何保证线程安全？ 原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现； 可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的； 有序性，是保证线程内串行语义，避免指令重排等。 1.3 为什么程序计数器、虚拟机栈和本地方法栈是线程私有的? 程序计数器为什么是私有 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪⼉了。 所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。 虚拟机栈和本地方法栈为什么私有 虚拟机栈： 每个 Java 方法在执行的同时会创建⼀个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直⾄执行完成的过程，就对应着⼀个栈帧在 Java 虚拟机栈中⼊栈和出栈的过程。 本地方法法栈： 和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合⼆为⼀。 所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。 2.创建线程的方式（非线程池）？ 哪种最好？ 一般有三种方式来进行创建： 继承Thread类：（1）定义Thread类的子类，并重写该类的run方法（2）创建Thread子类的实例对象 （3）调用对象start()方法 优点：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用this即可获取当前线程； 缺点：因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了。 实现Runnable接口：（1）定义runnable接口的实现类，并重写该接口的run()方法 （2）创建实现类的实例对象（3）调用线程对象的start()方法来启动该线程 通过Callable和Future创建线程：（1）创建Callable接口的实现类，并实现call()方法（2）创建Callable实现类的实例，并使用FutureTask类来包装Callable对象（3）使用FutureTask对象作为Thread对象的target创建并启动新线程（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值 其中 实现Runnalbe接口更好 ，使用实现Runnable接口的方式创建的线程可以处理同一资源，从而实现资源的共享。 3.如何停止一个正在运行的线程？ 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止； 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法； 使用interrupt方法中断线程。 12345678910111213141516171819202122232425262728293031class MyThread extends Thread&#123; volatile boolean stop = false; public void run() &#123; while (!stop) &#123; System.out.println(getName() + &quot; is running&quot;); try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;week up from blcok...&quot;); stop = true; // 在异常处理代码中修改共享变量的状态 &#125; &#125; System.out.println(getName() + &quot; is exiting...&quot;); &#125;&#125;class InterruptThreadDemo3&#123; public static void main(String[] args) throws InterruptedException &#123; MyThread m1 = new MyThread(); System.out.println(&quot;Starting thread...&quot;); m1.start(); Thread.sleep(3000); System.out.println(&quot;Interrupt thread...: &quot; + m1.getName()); m1.stop = true; // 设置共享变量为true m1.interrupt(); // 阻塞时退出阻塞状态 Thread.sleep(3000); // 主线程休眠3秒以便观察线程m1的中断情况 System.out.println(&quot;Stopping application...&quot;); &#125; &#125; 4.什么是Daemon线程？它有什么意义？ 所谓后台(daemon)线程，也叫守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。 意义：JVM的垃圾回收线程就是Daemon线程，Finalizer也是守护线程。 5.说说CyclicBarrier和CountDownLatch的区别？ 两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于： CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值**-1**而已，该线程继续运行； CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务 CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了 6.请你简要说明一下线程的基本状态以及状态之间的关系？ 新建状态：new语句创建的线程对象处于新建状态，仅被分配了内存； 等待状态： 当线程在new之后，并且在调用start方法前，线程处于等待状态 ; 就绪状态： 其他线程调用它的**start()**方法，该线程就进入就绪状态，只差等待cpu的使用权 ; 运行状态： 线程占用CPU，执行程序代码 ; 阻塞状态： 阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。阻塞状态分为三种： 等待阻塞: 运行的线程执行**wait()**方法，JVM会把该线程放入等待池中； 同步阻塞: 运行的线程在获取对象同步锁时，若该同步锁被别的线程占用，则JVM会把线程放入锁池中； 其他阻塞: 运行的线程执行Sleep()方法，或者发出I/O请求时，JVM会把线程设为阻塞状态。 死亡状态： 线程执行完run()方法中的代码，或者遇到了未捕获的异常，就会退出run()方法，结束生命周期 7. notify()和notifyAll()有什么区别？ notify可能会导致死锁（why？），而notifyAll则不会； 使用notifyall,可以唤醒 所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。 8. sleep()和wait() 有什么区别？ 继承的类：sleep()方法，我们首先要知道该方法是属于Thread类中的；而wait()方法，则是属于Object类中的； sleep() 是 Thread 类静态方法，可以使 当前 线程阻塞，并指定暂停时间，重点在于理解 当前。休眠时间期满后，该线程不一定会立即执行被CPU调度，只是到了就绪状态。 是否释放锁：sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁；当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池； 用处： Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行； 再次唤醒： wait() 方法被调用后，线程不会⾃动苏醒，需要别的线程调用同⼀个对象上的 notify() 或者notifyAll() 方法。sleep() 方法执行完成后，线程会⾃动苏醒。 8.1 Thread类中的yield方法有什么作用？ yield() 也是 Thread 类静态方法，使当前线程变为就绪状态 （sleep() 是阻塞），使得其他线程更多机会获取CPU。执行yield()的线程有可能在进入到暂停状态后马上又被执行。 8.2 java 中Wait、Sleep和Yield方法的区别？ https://www.jianshu.com/p/25e959037eed 9. volatile 是什么?可以保证有序性吗? 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存； 禁止进行指令重排序。 能保证有序性，因为禁止指令重排。 10. 为什么wait, notify 和 notifyAll这些方法不在thread类里面？ https://www.zhihu.com/question/321674476 明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。 简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。 11.为什么wait和notify方法要在同步块中调用？ wait()方法强制当前线程释放对象锁。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法； 在调用对象的notify()和notifyAll()方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。 12. （没细看）Java中interrupted 和 isInterruptedd方法的区别？ interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法。 1.4.2 线程池 1.请你解释一下什么是线程池（thread pool）？ 线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 除此之外： 提高性能，利用多线程压榨CPU算力； 提高线程的可管理性，限制线程数量并可以进行统一的分配、调优和监控。 1.1 请介绍一下使用线程池任务执行过程？ 核心参数：其中corePool是核心线程池（保活线程），maximumPool是总线程池（保活线程+工作线程），blockQueue 是等待任务队列，rejectedExecutionHandler是拒绝策略： 流程：corePoolSize→队列→maximumPool→拒绝策略 未达到corePoolSize时，核心线程池会开辟新线程运行任务（可以使用已有线程吗？），任务结束后线程不销毁； 达到corePoolSize，而任务队列未满时，新任务提交到等待队列，线程空闲时间超过keepAliveTime时被销毁； 任务队列也满了，但未超过最大线程数，新建工作线程执行任务； 超过最大线程数时，按拒绝策略处理，包括：抛出异常、使用调用者线程运行任务、丢弃新任务、丢弃队列头任务等。 1.2 线程池会回收核心线程吗？ 参考：线程池是怎么回收空闲线程的 会，可以通过allowCoreThreadTimeOut参数来进行设置。 先回忆一下整体线程池流程 excute方法 我们的任务放到线程池后，是从调用execute执行开始的。 核心是addWorker办法， 里面最最重要的就是初始化Worker同时启动thread。 Worker实现了Runnable接口，我们直接看它的run方法，看截图的③处标记，抽离出来一个runWorker方法： 也就是说：①处是一个while循环，getTask方法就是从线程池队列取任务，如果取不到任务就会执行 ​ ②一旦跳出while循环，即进入到processWorkExit方法，这就是回收Worker getTask方法 可以看到，①判断是否回收线程的条件，timed ，有两种情况要回收线程： wc&gt;corePoolSize ，当前线程数大于核心线程数 allowCoreThreadTimeOut，核心线程超时，所以核心线程是会被回收的 然后②处就是从任务队列取任务了，带了timeOut参数的poll方法超时 ，未能从任务队列获取任务即返回null，从而实现最终的线程回收。 不是processWorkExit处理吗，怎么在getTask处理，还是得好好看看。 2.请介绍一下什么是生产者消费者模式？ 生产者消费者问题是线程模型中的经典问题： 生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。 3.线程池的拒绝策略有哪些？ 主要有4种拒绝策略： AbortPolicy：直接丢弃任务，抛出异常，这是默认策略 CallerRunsPolicy：只用调用者所在的线程来处理任务 DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务 DiscardPolicy：直接丢弃任务，也不抛出异常 4.如何创建一个线程池（四大方法）？相关参数（七大参数）是什么? java通过Executors提供四大方法： newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程； newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待； newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行； newSingleThreadExecutor： 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 七大参数设置： corePoolSize：当使用了LinkedBlockingQueue = new LinkedBlockQueue的时候，队列长度默认无限长，会导致线程数量永远等于corePoolSize，任务激增时任务响应时间也激增； maximumPoolSize：线程池中线程个数，增加线程的公式：(任务数−queueCapacity)×(原线程数÷原任务数)(任务数-queueCapacity) \\times (原线程数 \\div 原任务数)(任务数−queueCapacity)×(原线程数÷原任务数)； keepAliveTime：线程最大（空闲）存活时间； rejectedExecutionHandler：线程被拒绝的解决方案，可以自己重写； workQueue ： 阻塞队列； unit：keepAliveTime的单位 ； threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程一般默认即可 5.线程池核心线程数corePoolSize怎么设置呢？ 分为CPU密集型和IO密集型来考虑： CPU密集型。这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。 比 CPU 核心数多出来的一个线程 ：是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。 IO密集型。这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 ： 核心线程数=CPU核心数量*2 6.（不熟悉）Java线程池中队列常用类型有哪些？ ArrayBlockingQueue ：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序； LinkedBlockingQueue :一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于 ArrayBlockingQueue ； SynchronousQueue : 一个不存储元素的阻塞队列； PriorityBlockingQueue： 一个具有优先级的无限阻塞队列，PriorityBlockingQueue 也是基于最小二叉堆实现。 7.有三个线程T1,T2,T3,如何保证顺序执行？ 因为在每个线程的run方法中用join()方法限定了三个线程的执行顺序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class JoinTest2&#123; // 1.现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行 public static void main(String[] args) &#123; final Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;t1&quot;); &#125; &#125;); final Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // t2线程内run方法最开始，引用t1.join，等待t1线程执行完 t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;t2&quot;); &#125; &#125;); Thread t3 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // t3线程内run方法最开始，引用t2.join，等待t2线程执行完 t2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;t3&quot;); &#125; &#125;); //这里三个线程的启动顺序可以任意，大家可以试下！ t3.start(); t2.start(); t1.start(); &#125;&#125; 1.4.3 多线程 1.请简述一下实现多线程同步的方法？ 为什么需要使用多线程？使用多线程会带来什么问题？ 同步方法：可以使用synchronized、lock、volatile和ThreadLocal来实现同步。 为什么需要使用多线程？ 减少上下文切换开销（共享进程的堆和方法区 ，注意，减少≠没有） 利用好多线程机制可以大大提高系统整体的并发能⼒以及性能 多核时代 ：多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算⼀个复杂的任务，我们只用⼀个线程的话，CPU 只会⼀个 CPU 核⼼被利用到，而创建多个线程就可以让多个 CPU 核⼼被利用到，这样就提高了 CPU 的利用率。 带来的问题？ 内存泄漏、上下⽂切换、死锁还有受限于硬件和软件的资源闲置问题。 2. 什么是线程安全？如何保证线程安全？ 好文：一文搞懂CAS 什么是线程安全？ 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 如何保证线程安全？ 使用 synchronized 关键字 。开销比较大 使用Lock 锁 。高并发场景下，使用 Lock 锁要比使用synchronized 关键字，在性能上得到极大的提高。因为 Lock 底层是通过 AQS + CAS 机制来实现的。 使用 Atomic 原子类 。使用 Lock 方式，一旦 unlock() 方法使用不规范，可能导致死锁。 Atomic 原子类，因为其底层基于 CAS 乐观锁来实现的，性能较高。 使用Volatile？不可行！ 因为无法保证原子性。 3.线程安全需要保证几个基本特征？ 原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。 可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将 线程本地状态反映到主内存上，volatile 就是负责保证可见性的。 有序性，是保证线程内串行语义，避免指令重排等。 4. 【待补充】如何在线程安全的情况下实现一个计数器？ 可以使用加锁，比如synchronized或者lock。也可以使用Concurrent包下的原子类。 5.多线程中的i++线程安全吗？请简述一下原因？ 不安全，因为i++不是原子性操作。i++分为读取i值，对i值加一，再赋值给i++，执行期中任何一步都是有可能被其他线程抢占的。 6.介绍一下ThreadLocal原理？ 一篇讲的不错的文章：https://www.cnblogs.com/wupeixuan/p/12638203.html 当多线程访问共享可变数据时，涉及到线程间同步的问题，并不是所有时候，都要用到共享数据，所以就需要线程封闭出场了。数据都被封闭在各自的线程之中，就不需要同步，这种通过将数据封闭在线程中而避免使用同步的技术称为线程封闭。 ThreadLocal 是 Java 里一种特殊变量，它是一个线程级别变量，每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞态条件被彻底消除了，在并发模式下是绝对安全的变量。 使用示例 在下面例子中，TreadLocal 做到多个线程对同一对象 set 操作，但是 get 获取的值还都是每个线程 set 的值，体现了线程的封闭。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ThreadLocalDemo &#123; /** * ThreadLocal变量，每个线程都有一个副本，互不干扰 */ public static final ThreadLocal&lt;String&gt; THREAD_LOCAL = new ThreadLocal&lt;&gt;(); public static void main(String[] args) throws Exception &#123; new ThreadLocalDemo().threadLocalTest(); &#125; public void threadLocalTest() throws Exception &#123; // 主线程设置值 THREAD_LOCAL.set(&quot;wupx&quot;); String v = THREAD_LOCAL.get(); System.out.println(&quot;Thread-0线程执行之前，&quot; + Thread.currentThread().getName() + &quot;线程取到的值：&quot; + v); new Thread(new Runnable() &#123; @Override public void run() &#123; String v = THREAD_LOCAL.get(); // 此时新建线程Thread-0取到的是null，意味着不同线程取到的值不同的 System.out.println(Thread.currentThread().getName() + &quot;线程取到的值：&quot; + v); // 设置 threadLocal THREAD_LOCAL.set(&quot;huxy&quot;); v = THREAD_LOCAL.get(); System.out.println(&quot;重新设置之后，&quot; + Thread.currentThread().getName() + &quot;线程取到的值为：&quot; + v); System.out.println(Thread.currentThread().getName() + &quot;线程执行结束&quot;); &#125; &#125;).start(); // 等待所有线程执行结束 Thread.sleep(3000L); v = THREAD_LOCAL.get(); System.out.println(&quot;Thread-0线程执行之后，&quot; + Thread.currentThread().getName() + &quot;线程取到的值：&quot; + v); &#125;&#125;/* 输出结果 */// 虽然Thread-0已经改变了值，但是main取到的值依旧是一样的。/*Thread-0线程执行之前，main线程取到的值：wupxThread-0线程取到的值：null重新设置之后Thread-0线程取到的值为：huxyThread-0线程执行结束Thread-0线程执行之后，main线程取到的值：wupx*/ ThreadLocal原理 ThreadLocal有一个静态内部类ThreadLocalMap，ThreadLocalMap又包含了一个Entry数组，Entry本身是一个弱引用，他的key是指向ThreadLocal的弱引用，Entry具备了保存key value键值对的能力。 ThreadLocalMap ThreadLocalMap 是 ThreadLocal 的静态内部类，当一个线程有多个 ThreadLocal 对象时时，需要一个容器来管理多 ThreadLocal，ThreadLocalMap 的作用就是管理线程中多个 ThreadLocal。 从源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构，底层是数组，有初始化大小，也有扩容阈值大小，数组的元素是 Entry，Entry 的 key 就是 ThreadLocal 的引用，value 是 ThreadLocal 的值。ThreadLocalMap 解决 hash 冲突的方式采用的是线性探测法，如果发生冲突会继续寻找下一个空的位置 1234567891011121314151617181920212223242526272829303132static class ThreadLocalMap &#123; /** * 键值对实体的存储结构 */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; // 当前线程关联的 value，这个 value 并没有用弱引用追踪 Object value; /** * 构造键值对 * * @param k k 作 key,作为 key 的 ThreadLocal 会被包装为一个弱引用 * @param v v 作 value */ Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; // 初始容量，必须为 2 的幂 private static final int INITIAL_CAPACITY = 16; // 存储 ThreadLocal 的键值对实体数组，长度必须为 2 的幂 private Entry[] table; // ThreadLocalMap 元素数量 private int size = 0; // 扩容的阈值，默认是数组大小的三分之二 private int threshold;&#125; Set方法 调用 ThreadLocal对象.set(value)，实际在调用当前线程的ThreadLocalMap对象.set(this,value) ，会把当前 threadLocal 对象作为 key，想要保存的对象作为 value，存入 map。 set 方法的流程主要是： 先获取到当前线程的引用 利用这个引用来获返回当前线程到 ThreadLocalMap 如果 map 为空，则去创建一个 ThreadLocalMap 如果 map 不为空，就利用 ThreadLocalMap 的 set (this当前对象，value) 添加键值对 12345678910111213141516171819202122232425/** * 为当前 ThreadLocal 对象关联 value 值 * * @param value 要存储在此线程的线程副本的值 */public void set(T value) &#123; // 返回当前ThreadLocal所在的线程 Thread t = Thread.currentThread(); // 返回当前线程持有的map ThreadLocalMap map = getMap(t); if (map != null) &#123; // 如果 ThreadLocalMap 不为空，则直接存储&lt;ThreadLocal, T&gt;键值对 // 此时this是ThreadLocal对象，这是在ThreadLocal类中 map.set(this, value); &#125; else &#123; // 否则，需要为当前线程初始化 ThreadLocalMap，并存储键值对 &lt;this, firstValue&gt; createMap(t, value); &#125;&#125;/** * 返回当前线程 thread 持有的 ThreadLocalMap对象 */ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; Get方法 调用ThreadLocal对象.get() 方式时，实际在调用ThreadLocalMap对象.getEntry(this) 方法。this是当前ThreadLocal对象。 get 方法的主要流程为： 先获取到当前线程的引用 获取当前线程内部的 ThreadLocalMap对象 如果 map 存在，则获取当前 ThreadLocal 对应的 value 值 如果 map 不存在或者找不到 value 值，则调用 setInitialValue() 进行初始化 1234567891011121314151617181920212223/** * 返回当前 ThreadLocal 对象关联的值 * * @return */public T get() &#123; // 返回当前 ThreadLocal 所在的线程 Thread t = Thread.currentThread(); // 从线程中拿到 ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) &#123; // 从 map 中拿到 entry ThreadLocalMap.Entry e = map.getEntry(this); // 如果不为空，读取当前 ThreadLocal 中保存的值 if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T) e.value; return result; &#125; &#125; // 若 map 为空，则对当前线程的 ThreadLocal 进行初始化，最后返回当前的 ThreadLocal 对象关联的初值，即 value return setInitialValue();&#125; resize 方法 当前线程的 ThreadLocalMap 中的 ThreadLocal 的个数超过容量阈值时，ThreadLocalMap 就要开始扩容了。 1// 略 7.为什么ThreadLocal造成内存泄漏？ ThreadLocalMap 是 ThreadLocal 的静态内部类，当一个线程有多 个ThreadLocal 时，需要一个容器来管理多个 ThreadLocal，ThreadLocalMap 的作用就是管理线程中多个 ThreadLocal。 源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构： 底层是数组Entry[] table，数组的元素是 Entry类：Entry 的两个属性， key 是 ThreadLocal类型的引用，value 是 ThreadLocal 的值。 原因：ThreadLocalMap的key为弱引用（有用但非必需，下一次GC会被回收），value为强引用（GC过程不会被回收），有可能造成key被GC，value没被GC，ThreadLocalMap中出现null为key的Entry，产生内存泄漏（软引用：有用但非必需，内存溢出之前被回收）； 解决： 调用set()、get()和remove()方法时，会自动清理掉key为null的记录，但使用ThreadLocal方法后手动remove()。 8.什么是多线程中的上下文切换？ 一个线程让出处理器使用权，就是“切出”；另外一个线程获取处理器使用权，就是“切入”。在这个切入切出的过程中，操作系统会保存和恢复相关的进度信息，这个进度信息就是我们常说的“上下文”，上下文中一般包含了寄存器的存储内容以及程序计数器存储的指令内容。 9.请问什么是死锁(deadlock)? 死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。 10. JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？ 最简单方法：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。 因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。或者通过破坏死锁的四个条件： 互斥 ： 不可能破坏。 破坏请求和保持条件：进程必须 等所有要请求的资源都空闲时才能申请资源， 这种方法会使资源浪费严重 。允许进程获取初期所需资源后，便开始运行，运行过程中再逐步释放自己占有的资源。 破坏不可抢占条件： 方法代价大，实现复杂。 破坏循坏等待条件 ：对各进程请求资源的顺序做一个规定，避免相互等待。这种方法对资源的利用率比前两种都高，但是前期要为设备指定序号，新设备加入会有一个问题，其次对用户编程也有限制。","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"JAVA","slug":"校招笔记/JAVA","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://hwh.zone/tags/JAVA/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"}]},{"title":"校招笔记（一）_Java_集合","slug":"校招笔记（一）_Java_集合","date":"2021-11-26T11:59:26.560Z","updated":"2021-11-26T16:31:59.177Z","comments":true,"path":"2021/11/26/校招笔记（一）_Java_集合/","link":"","permalink":"https://hwh.zone/2021/11/26/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89_Java_%E9%9B%86%E5%90%88/","excerpt":"","text":"备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 🚩 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 1.3 集合 1.3.1 集合类 1.请说明Java集合类框架的基本接口有哪些？ Collection：代表一组对象，每一个对象都是它的子元素。 Set：不包含重复元素的Collection。 List：有顺序的collection，并且可以包含重复元素。 Map：可以把键(key)映射到值(value)的对象，键不能重复。 2.（补充：举例说明）说说什么是fail-fast？ fail-fast 机制是 Java 集合（Collection）中的一种错误快速反馈机制。当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。 例如：当某一个线程 A 通过 iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了，那么线程 A 访问集合时，就会抛出 ConcurrentModifificationException 异常，产生 fail-fast 事件。这里的操作主要是指 add、remove 和 clear，对集合元素个数进行修改。 3.请说明List、Map、Set三个接口区分？ 重复元素：List以特定索引来存取元素，可以有重复元素；Map以键值对映射，不能有重复key；Set元素不能重复 继承collection： List、Set继承于collection；Map和前二者明显区分，不继承collection 实现方式： List是线性结构的容器 ，典型实现有ArrayList 、LinkedList、Vector； Map、Set都有 基于哈希存储和排序树 的两种实现版本，前者实现有 HashMap和Hashtable ，后者有HashSet 4.请讲讲你所知道的常用集合类以及主要方法？ 最常用的集合类是List 和 Map。 List：典型实现有ArrayList 、LinkedList、Vector ，大小可变，适合用于按数值索引元素类型； Map： 其中每个键映射到一个值，实现有 HashMap和Hashtable 。 1.3.2 Map &amp; Set 1.请你介绍一下map的分类和常见的情况？ java为数据结构中的映射定义了一个接口java.util.Map ， 它有四个实现类,分别是HashMap、 Hashtable、 LinkedHashMap、 和TreeMap. Hashmap ：根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度。 遍历：访问快，遍历时取得的数据随机 线程：不支持线程同步（但可以用Collections的synchronizedMap 实现同步） key和记录：HashMap允许键和值是null Hashtable ：和Hashmap类似，是其子类。但其： 线程： 支持线程同步，也导致写入比较慢（一个时候只能一个线程写入） key和记录：不允许记录的键或者值为空 ； LinkedHashMap ：HashMap的一个子类，保存了记录插入顺序： 遍历：遍历先得到的记录是先插入、一般情况比HashMap慢。 TreeMap ： 实现SortMap接口，默认是按键值的升序排序， 遍历：当用遍历TreeMap时，得到的记录是排过序的 线程：线程安全 一般情况下，我们用的最多的是HashMap, 在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列。 1.1 TreeMap的底层实现？ TreeMap实现了SotredMap接口，它是有序的集合。而且是一个红黑树结构，每个key-value都作为一个红黑树的节点。如果在调用TreeMap的构造函数时没有指定比较器，则根据key执行自然排序。这点会在接下来的代码中做说明，如果指定了比较器则按照比较器来进行排序。 自然排序：TreeMap的所有key必须实现Comparable接口，所有的key都是同一个类的对象 定制排序：创建TreeMap对象传入了一个Comparator对象，该对象负责对TreeMap中所有的key进行排序，采用定制排序不要求Map的key实现Comparable接口。等下面分析到比较方法的时候在分析这两种比较有何不同。 2.请问HashMap和Hashtable区别？ 共同点：都实现Map接口 不同点： 对Null key 和Null value的支持：HashMap允许键和值是null，而Hashtable不允许键或者值是null； 线程安全：Hashtable是同步的线程安全，而HashMap不是； 初始容量大小和每次扩充容量大小不同： （1）创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16，之后每次扩充，容量变为原来的2倍 ；（2）创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小，也就是说 HashMap 总是使用2的幂作为哈希表的大小； 底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表⻓度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有转换为红黑树这样的机制； 继承父类：HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。 3.请问Map接口实现：HashMap、Hashtable和ConcurrentHashMap区别？ 都是key-value存储形式。 底层数据结构：HashMap与ConcurrentHashMap底层数据结构相似（数组+链表+红黑树），Hashtable没有红黑树； 线程安全：Hashtable的synchronized修饰在方法，是对象级的加锁，同一时间只有一个线程能对数据进行操作；ConcurrentHashMap使用了修饰具体对象的synchronized（锁一个桶）和CAS机制，实现了更细粒度的锁； 地址计算： HashMap使用key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16)；- Hashtable使用(key.hashCode() &amp; 0x7fffffff) % tab.length() ConcurrentHashMap使用(key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16)) &amp; 0x7fffffff。 4.说一说红黑树特征？ 紧接上个问题，面试官很有可能会问红黑树。 每个节点是黑色是红色 根节点和叶子节点是黑色 红色节点不能相邻 从一个节点到子孙节点路径上相同数目的黑节点 5. hashmap的基本原理，扩容方式（rehash）？ 很棒的一篇文章：https://www.jianshu.com/p/dde9b12343c1 更棒的一篇文章：https://zhuanlan.zhihu.com/p/81587796 HashMap定义 HashMap继承了Map端口，实现了Serializable等接口。存储HashMap的是一个Entry[]数组，Entry是一个单向链表： 所以我们说HashMap实现的是一个数组+链表 。 1234public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;implements Map&lt;K,V&gt;, Cloneable, Serializable&#123; transient Entry&lt;K,V&gt;[] table; Entry类 Entry在HashMap中实现为一个静态内部类，封装了key和value，还有类型为Entry的next指向下一个Entry引用。 12345static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; 图解HashMap 根据前面所知，我们可以得到HashMap的实现如下（默认初始化容量为16）： put方法实现 输入的key根据hash(key) 计算出hash值 123456public V put(K key, V value) &#123; // 对key为null的处理 if (key == null) return putForNullKey(value); // 根据key算出hash值 int hash = hash(key); hash方法如下（JDK1.8版本） 下面这段代码也叫扰动函数 ，参考：JDK 源码中 HashMap 的 hash 方法原理是什么？ 混合原始哈希码的高位和低位，以此来加大低位的随机性 。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。 1234567static final int hash(Object key) &#123;int h;// key.hashCode()：返回散列值也就是hashcode// ^ ：按位异或// &gt;&gt;&gt;⽆符号右移，忽略符号位，空位都以0补⻬return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 相⽐于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差⼀点点，因为毕竟扰动了 4 次。 Object类HashCode实现 详细源码分析参考 ：Java Object.hashCode()返回的是对象内存地址？ JDK8 的默认hashCode的计算方法是通过和当前线程有关的一个随机数+三个确定值，运用Marsaglia’s xorshift scheme随机数算法得到的一个随机数 。 可以通过在JVM启动参数中添加-XX:hashCode=4，改变默认的hashCode计算方式： hashCode == 0 ：返回一个Park-Miller伪随机数生成器生成的随机数 ，OpenJdk 6 &amp;7的默认实现； hashCode == 1：此类方案将对象的内存地址，做移位运算后与一个随机数进行异或得到结果 ； hashCode == 2：此类方案返回固定的1； hashCode == 3：此类方案返回一个自增序列的当前值； hashCode == 4：此类方案返回当前对象的内存地址。 根据indexFor(hash, table.length) ，计算在table中下标 key.hashcode得到hash → 经过高低16异或扰动得到行hash → indexFor计算下标 indexFor() 实际就是hash值取余：hash%(table.lenght-1) 。但在具体实现中通过位运算实现： 123static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; 计算原理。 顺便说一下，这也正好解释了为什么HashMap的数组长度要取2的整次幂。因为这样（数组长度-1）正好相当于一个低位掩码。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。 1234 10100101 11000100 00100101&amp; 00000000 00000000 00001111 （16）------------------------------------------ 00000000 00000000 000000101 位运算要求length 一定是偶数。length-1则一定是奇数。 这样h &amp; (length-1)进行位运算出现的结果可奇可偶，不会一直是偶数，浪费奇数空间。而length为2的幂次，可以保证length一定是偶数，这也是扩容为什么要求一定是2的幂次。 遍历table中下标为i的Entry单向链表，找是否有相同的key已经在HashMap中，如果有，就替换value为最新的值；没有就直接插入。所以HashMap中只能存储唯一的key。 1234567891011int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 先判断hash值是否一样，如果一样，再判断key是否一样 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; 如果是第一次put上面for循环不会执行，而是addEntry方法直接把key和value封装成Entry，然后加入到table中的实现。 123modCount++;addEntry(hash, key, value, i);return null; 这涉及到HashMap的扩容机制。 扩容机制 当HashMap中存储的元素个数达到扩容的阀值 ，那如何进行扩容？ ⚠️ 在jdk1.8版本以后，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。 我们再来看看addEntry方法中的扩容相关代码： 扩容就是通过resize()方法创建一个长度为原来2倍的新table ； resize()方法内部通过遍历的方式，将老table的数据，重新计算hash并存储到新table的适当位置，最后使用新的table，并重新计HashMap的扩容阀值。 12345678910111213141516 void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; //初始化一个新的Entry数组 Entry[] newTable = new Entry[newCapacity]; //！！将数据转移到新的Entry数组里 transfer(newTable); //HashMap的table属性引用新的Entry数组 table = newTable; //修改阈值 threshold = (int)(newCapacity * loadFactor);13 &#125; transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里： 12345678910111213141516171819void transfer(Entry[] newTable) &#123; //src引用了旧的Entry数组 Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; //！！重新计算每个元素在数组中的位置 int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上元素 &#125; while (e != null); &#125; &#125; &#125; newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式 。下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。 get方法实现 用key的hash值算出key对应的Entry所在链表在在table的下标，然后遍历下标即可。 5.1 为什么HashMap默认链表长度超过8转为红黑树，而不是6、7或9？ 在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为 8 的时候，概率仅为 0.00000006。源码中注释如下： 123456789100: 0.606530661: 0.303265332: 0.075816333: 0.012636064: 0.001579525: 0.000157956: 0.000013167: 0.000000948: 0.00000006more: less than 1 in ten million 这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。 特别的，默认是链表长度达到 8 就转成红黑树，而当长度降到 6 就转换回去，这体现了时间和空间平衡的思想。长度较小时，使用链表空间占用少，时间也不会长（因为链表短）。 5.2 HashMap 多线程操作导致死循环问题？ 总结： HashMap之所以在并发下的扩容造成死循环，是因为，多个线程并发进行时，因为一个线程先期完成了扩容，将原的链表重新散列到自己的表中，并且链表变成了倒序，后一个线程再扩容时，又进行自己的散列，再次将倒序链表变为正序链表，于是形成了一个环形链表。 12345678910111213141516171819void transfer(Entry[] newTable) &#123; //src引用了旧的Entry数组 Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; //！！重新计算每个元素在数组中的位置 int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125; &#125; map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。 设置断点让线程1和线程2同时debug到transfer方法的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。 注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的新链表。 线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。 e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。 5.3 说说HashMap的put方法？ 根据key值计算在数组中的位置： 如果定位到的数组位置没有元素 就直接插入； 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 hash值&amp;equals对象相同就直接覆盖，不同就采用头插法插入元素。 123456789101112//table[i]的位置已经存在元素，遍历链表for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; //调用 equals 方法判断key是否相等，若相等，该key对应的键值对已经存在，用新的value取代旧的value if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; 5.4 说说HashMap的get方法？ 根据key值计算在数组中的位置： 遍历链表或者在红黑树，比较key来获取value 5.5 【百度】rehash扩容时机？在插入前还是插入后？ rehash过程在put函数中，其大致扩容时机如下： 计算hash，定位到桶；且遍历桶外挂链表，如果有相同key则覆盖； 123456789101112131415161718public V put(K key, V value) &#123; if (key == null) // 【百度】怎么处理key或value为NULL的情况？ return putForNullKey(value); int hash = hash(key);//计算键的hash值 int i = indexFor(hash, table.length);//通过hash值对应到桶位置 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;//顺序遍历桶外挂的单链表 Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;/ V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i);//遍历单链表完毕，没有找到与键相对的Entry，需新建一个Entry return null; &#125; 【如果没有找到相同key，说明要插入一个新entry】 ，执行addEntry，插入前先验证下是否扩容； 123456789101112131415void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);//将容量扩容为原来的2倍 hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length);//扩容后的，该hash值对应的新的桶位置 &#125; createEntry(hash, key, value, bucketIndex);//在指定的桶位置上，创建一个新的Entry &#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);//链表的头插法插入新建的Entry size++;//更新size &#125; 因此总结扩容时机如下： 在执行put时，如果遍历指定桶外挂链表没有找到相同key的节点时，说明需要新建一个entry，这个时候在插入前验证下是否要扩容。 5.6 hashmap在1.7版本之前为什么使用头插法？ 1.7版本之前采用头插法，1.8之后采用尾插法。 头插法会改变链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题；而尾插法，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题 。 既然有多线程并发问题，那为什么1.8之前还要使用头插法？ 局部性原理： 最近访问过的数据下次大概率会再次访问，把刚访问过的元素放在链表最前面可以直接被查询到，减少查找次数 不是为了适应多线程而设计： 只有在并发情况下，头插法才会出现链表成环的问题，多线程情况下，HashMap 本就非线程安全，这就相当于你在它的规则之外出了问题。 5.7 为什么 HashMap 的负载因子设置成 0.75，而不是 1 也不是 0.5？ 在 HashMap 中，临界值（threshold） = 负载因子（loadFactor） * 容量（capacity）。 那么如何能有效的避免哈希碰撞呢？ 我们先反向思维一下，你认为什么情况会导致 HashMap 的哈希碰撞比较多？ 无外乎两种情况： 容量太小。容量小，碰撞的概率就高了。狼多肉少，就会发生争抢。 hash 算法不够好。算法不合理，就可能都分到同一个或几个桶中。分配不均，也会发生争抢。 为了避免哈希碰撞，HashMap 需要在合适的时候进行扩容。那就是当其中的元素个数达到临界值的时候（等全满了再扩容，那么在此之前容量太少，导致碰撞的概率过高），而这个临界值前面说过和 loadFactor 有关，换句话说，设置一个合理的 loadFactor，可以有效的避免哈希冲突。 JVM中原话： 一般来说，默认的负载因子 (0.75) 在时间和空间成本之间提供了很好的权衡。更高的值减少了空间开销，但增加了查找成本(反映在 HashMap 类的大多数操作中，包括 get 和 put)。 另一方面，为了保证负载因子（loadFactor） * 容量（capacity）的结果是一个整数，这个值是 0.75(3/4) 比较合理，因为这个数和任何 2 的幂乘积结果都是整数。 5.8 Hashmap 怎么处理key和value为null的情况？ 6. Hashtable 源码分析 参考：Java集合之Hashtable源码解析 构造函数 和HashMap还是挺相似的，但是默认初始容量是11（HashMap是16）。 123456789101112131415161718192021222324252627282930313233private transient Entry&lt;?,?&gt;[] table;//数组 private transient int count;//键值对的数量 private int threshold;//阀值 private float loadFactor;//加载因子 private transient int modCount = 0;//修改次数 public Hashtable(int initialCapacity, float loadFactor) &#123;//下面的三个构造函数都是调用这个函数，来进行相关的初始化 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor); if (initialCapacity==0) initialCapacity = 1; this.loadFactor = loadFactor; table = new Entry[initialCapacity];//这里是与HashMap的区别之一，HashMap中table threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1); initHashSeedAsNeeded(initialCapacity); &#125; public Hashtable(int initialCapacity) &#123;//指定初始数组长度 this(initialCapacity, 0.75f); &#125; public Hashtable() &#123;//从这里可以看出容量的默认值为16，加载因子为0.75f. this(11, 0.75f); &#125; public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123; this(Math.max(2*t.size(), 11), 0.75f); putAll(t); &#125; put方法 和HashMap整体过程依旧很像，但有4点注意： put方法是加锁synchronized，所以线程安全 Hashtable计算hash值的hash(key)，不允许为null，所以会抛出异常 获取数组散列的下标 (hash &amp; 0x7FFFFFFF) % tab.length 和HashMap hash &amp; length-1 不同 (hash &amp; 0x7FFFFFFF) % tab.length 是（1）hash &amp; 0x7FFFFFFF 保证hash是正数 （2）然后取余 相比之下，HashMap是位运算进行了优化，更高效 Hashtable没有链表转红黑树的机制 12345678910111213141516171819202122232425262728public synchronized V put(K key, V value) &#123;//这里方法修饰符为synchronized,所以是线程安全的。 if (value == null) &#123; throw new NullPointerException();//value如果为Null,抛出异常 &#125; Entry tab[] = table; int hash = hash(key);//hash里面的代码是hashSeed^key.hashcode（）,null.hashCode（）会抛出异常，所以这就解释了Hashtable的key和value不能为null的原因。 int index = (hash &amp; 0x7FFFFFFF) % tab.length;//获取数组元素下标,先对hash值取正，然后取余。 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; V old = e.value; e.value = value; return old; &#125; &#125; modCount++;//修改次数。 if (count &gt;= threshold) &#123;//键值对的总数大于其阀值 rehash();//在rehash里进行扩容处理 tab = table; hash = hash(key); index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; Entry&lt;K,V&gt; e = tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++; return null; &#125; rehash方法（扩容） 和HashMap依旧很像，但是扩容每次是 old*2+1 。 get方法 也是相比Hashmap直接加了 synchronized 进行修饰，保证线程安全。 1234567891011public synchronized V get(Object key) &#123;//没有什么特殊性，就是加了一个synchronized，就是根据index来遍历索引处的单链表。 Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return e.value; &#125; &#125; return null; &#125; 6.1 （容易忘）HashMap 和 Hashtable 的区别 ？ 关于null，HashMap允许key和value都可以为null，而Hashtable则不接受key为null或value为null的键值对。 关于线程安全，HashMap是线程不安全的，Hashtable是线程安全的，因为Hashtable的许多操作函数都用synchronized修饰。 Hashtable与HashMap实现的接口不一致，但Hashtable继承Dictionary，而HashMap继承自AbstractMap，即父类不同 默认初始容量不同，扩容大小不同。HashMap的hash数组的默认大小是16，而且一定是2 的指数old*2；Hashtable中hash数组默认大小是11，增加的方式是old*2+1。 6.2 ConcurrentHashMap 和 Hashtable 的区别 ？ ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。 底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构⼀样，数组+链表/红黑⼆叉树。Hashtable 和 JDK1.8 之前的HashMap 的底层数据结构类似都是采用数组+链表/红黑树 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的； 实现线程安全的方式（重要）： ①在JDK1.7的时候ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提高并发访问率。到JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同⼀把锁，全表锁) :使用 synchronized 来保证线程安全，效率非常低下。当⼀个线程访问同步方法时，其他线程也访问同步方法，可能会进⼊阻塞或轮询状态，如使用 put 添加元素，另⼀个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。 7. ConcurrentHashMap线程安全的具体实现方式/底层具体实现 ？ 参考：https://www.cnblogs.com/huangjuncong/p/9478505.html javaGuide Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。 Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 Segment 数组 + HashEntry 数组 + 链表 进化成了 Node 数组 + 链表 / 红黑树，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。 JDK 1.7 实现 Java 7 中 ConcurrentHashMap 的存储结构如下图。 存储结构 ConcurrentHashMap 为了提高本身的并发能力，在内部采用了一个叫做 Segment 的结构，一个 Segment 其实就是一个类 HashTable 的结构，Segment 内部维护了一个链表数组。 两次Hash。ConcurrentHashMap 定位一个元素的过程需要进行两次Hash操作，第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部。 因此，这一种结构的带来的副作用是 Hash 的过程要比普通的 HashMap 要长，但是带来的好处是写操作的时候可以只对元素所在的 Segment 进行操作即可，不会影响到其他的 Segment。 1. ConcurrentHashMap的成员变量和构造函数 ConcurrentHashMap扩容： 元素数量增加导致ConrruentHashMap需要扩容，ConcurrentHashMap不会增加Segment的数量，而只会增加Segment中链表数组的容量大小。 需要对整个ConcurrentHashMap做rehash，而只需要对Segment里面的元素做一次rehash就可以了。 核心初始化函数逻辑如下： 2的指数是为了可以使用移位操作加快hash计算过程。 计算出Segment的数量ssize，是不大于concurrencyLevel的最大的2的指数 12345int ssize = 1;while (ssize &lt; concurrencyLevel) &#123; ++sshift; ssize &lt;&lt;= 1;&#125; 根据intialCapacity确定Segment的容量的大小，每一个Segment的容量大小也是2的指数 123456int c = initialCapacity / ssize;if (c * ssize &lt; initialCapacity) ++c; int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap &lt; c) cap &lt;&lt;= 1; 下面是完整代码： segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到 。默认是 32 - sshift = 28 segmentMask，默认是 ssize - 1 = 16 -1 = 15 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 默认初始容量static final int DEFAULT_INITIAL_CAPACITY = 16;// 默认加载因子static final float DEFAULT_LOAD_FACTOR = 0.75f;// 默认segment层级static final int DEFAULT_CONCURRENCY_LEVEL = 16;// 最大容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// segment最小容量static final int MIN_SEGMENT_TABLE_CAPACITY = 2;// 一个segment最大容量static final int MAX_SEGMENTS = 1 &lt;&lt; 16;// 锁之前重试次数static final int RETRIES_BEFORE_LOCK = 2;// 构造函数：无参public ConcurrentHashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);&#125;// 构造函数：指定初始容量public ConcurrentHashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);&#125;// 构造函数：指定初始容量，负载因子public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123; this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);&#125;// 构造函数：指定初始容量，负载因子，并发级别public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; // 找到两种大小的最匹配参数 int sshift = 0; // segment数组的长度是由concurrentLevel计算来的，segment数组的长度是2的N次方， // 默认concurrencyLevel = 16, 所以ssize在默认情况下也是16,此时 sshift = 4 // sshift相当于ssize从1向左移的次数 int ssize = 1; while (ssize &lt; concurrencyLevel) &#123; ++sshift; ssize &lt;&lt;= 1; &#125; // 段偏移量，默认值情况下此时segmentShift = 28 this.segmentShift = 32 - sshift; // 散列算法的掩码，默认值情况下segmentMask = 15 this.segmentMask = ssize - 1; if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; int c = initialCapacity / ssize; if (c * ssize &lt; initialCapacity) ++c; int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap &lt; c) cap &lt;&lt;= 1; // create segments and segments[0] Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])new HashEntry[cap]); // 创建ssize长度的Segment数组 Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize]; UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] this.segments = ss; &#125; 2.来查看具体代码定义，Segment的成员变量： Segment 继承于 ReentrantLock，不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理。 1234567static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; transient volatile int count; //Segment中元素的数量 transient int modCount; //对table的大小造成影响的操作的数量(比如put或者remove操作) transient int threshold; //阈值,Segment里面元素的数量超过这个值那么就会对Segment进行扩容 final float loadFactor; //负载因子,用于确定threshold transient volatile HashEntry&lt;K,V&gt;[] table; //链表数组,数组中的每一个元素代表了一个链表的头部&#125; 3. 继续查看HashEntry组成： 和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。 123456789101112131415161718192021 /** * ConcurrentHashMap列表Entry。注意，这不会作为用户可见的Map.Entry导出。 */static final class HashEntry&lt;K,V&gt; &#123; final int hash; final K key; volatile V value; volatile HashEntry&lt;K,V&gt; next; HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; // 设置具有volatile写语义的next字段。 final void setNext(HashEntry&lt;K,V&gt; n) &#123; UNSAFE.putOrderedObject(this, nextOffset, n); &#125; // 下面不太重要，略。 put() 方法实现 相比Hashtable，1.7版本concurrentHashmap的更加细粒度，只有定位到段，才会锁住。也就是段锁！ 而Hashtable直接锁住整个方法。 计算key的hash值 ; 根据hash值，segmentShift，segmentMask定位到哪个Segment； 如果指定位置的 Segment 为空，则初始化这个 Segment； 在对应的 Segment 中进行具体的 put。 1234567891011121314public V put(K key, V value) &#123; Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); int hash = hash(key); // hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算 // 其实也就是把高4位与segmentMask（1111）做与运算 int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment // 如果查找到的 Segment 为空，初始化 s = ensureSegment(j); return s.put(key, hash, value, false);&#125; Segment 中进行具体的 put的源码如下： 判断元素个数是否超过了阈值或者segment中数组的长度超过了MAXIMUM_CAPACITY，如果满足条件则rehash扩容！ 由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。 tryLock() 获取锁，获取不到使用scanAndLockForPut方法继续获取； 这里面的第一步中的 scanAndLockForPut 操作这里没有介绍，这个方法做的操作就是不断的自旋 tryLock() 获取锁。当自旋次数大于指定次数时，使用 lock() 阻塞获取锁。 计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry ； 遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待； 如果这个位置上的 HashEntry 不存在： 如果当前容量大于扩容阀值，小于最大容量，进行扩容。 直接头插法插入。 如果这个位置上的 HashEntry 存在： 判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致，一致则替换值 不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。 如果当前容量大于扩容阀值，小于最大容量，进行扩容。 直接链表头插法插入。 如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; // 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。 HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try &#123; HashEntry&lt;K,V&gt;[] tab = table; // 计算要put的数据位置 int index = (tab.length - 1) &amp; hash; // CAS 获取 index 坐标的值 HashEntry&lt;K,V&gt; first = entryAt(tab, index); for (HashEntry&lt;K,V&gt; e = first;;) &#123; if (e != null) &#123; // 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value K k; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; oldValue = e.value; if (!onlyIfAbsent) &#123; e.value = value; ++modCount; &#125; break; &#125; e = e.next; &#125; else &#123; // first 有值没说明 index 位置已经有值了，有冲突，链表头插法。 if (node != null) node.setNext(first); else node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; // 容量大于扩容阀值，小于最大容量，进行扩容 if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) rehash(node); else // index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头 setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; &#125; &#125; &#125; finally &#123; unlock(); &#125; return oldValue;&#125; 扩容 rehash rehash在put()内部被触发。 ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表头插法插入到指定位置。 1int idx = e.hash &amp; sizeMask; // 新位置计算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private void rehash(HashEntry&lt;K,V&gt; node) &#123; HashEntry&lt;K,V&gt;[] oldTable = table; // 老容量 int oldCapacity = oldTable.length; // 新容量，扩大两倍 int newCapacity = oldCapacity &lt;&lt; 1; // 新的扩容阀值 threshold = (int)(newCapacity * loadFactor); // 创建新的数组 HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity]; // 新的掩码，默认2扩容后是4，-1是3，二进制就是11。 int sizeMask = newCapacity - 1; for (int i = 0; i &lt; oldCapacity ; i++) &#123; // 遍历老数组 HashEntry&lt;K,V&gt; e = oldTable[i]; if (e != null) &#123; HashEntry&lt;K,V&gt; next = e.next; // 计算新的位置，新的位置只可能是不变或者是：老的位置+老的容量。 int idx = e.hash &amp; sizeMask; if (next == null) // Single node on list // 如果当前位置还不是链表，只是一个元素，直接赋值 newTable[idx] = e; else &#123; // Reuse consecutive sequence at same slot // 如果是链表了 HashEntry&lt;K,V&gt; lastRun = e; int lastIdx = idx; // 新的位置只可能是不变或者是：老的位置+老的容量。 // 遍历结束后，lastRun 后面的元素位置都是相同的 for (HashEntry&lt;K,V&gt; last = next; last != null; last = last.next) &#123; int k = last.hash &amp; sizeMask; if (k != lastIdx) &#123; lastIdx = k; lastRun = last; &#125; &#125; // ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。 newTable[lastIdx] = lastRun; // Clone remaining nodes for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123; // 遍历剩余元素，头插法到指定 k 位置。 V v = p.value; int h = p.hash; int k = h &amp; sizeMask; HashEntry&lt;K,V&gt; n = newTable[k]; newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n); &#125; &#125; &#125; &#125; // 头插法插入新的节点 int nodeIndex = node.hash &amp; sizeMask; // add the new node node.setNext(newTable[nodeIndex]); newTable[nodeIndex] = node; table = newTable;&#125; get方法 注意，Hashtable 会使用Synchronized进行修饰，所以不支持并发。但是ConcurrentHashmap 没有使用同步机制： 1.7版本 。使用unsafe方法（）等方式直接操作来保证并发处理的安全性，使用的是硬件的安全机制。 1.8版本。没有使用同步，也没有使用unsafe方式。所以是并发的。 到这里就很简单了，get 方法只需要两步即可。 计算得到segment的位置 u CAS方式获取segment数组对象 segment[u] 计算HashEntry数组的下标 i CAS方式获取HashEntry[i]，即数组首节点 12345678910111213141516171819public V get(Object key) &#123; Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead HashEntry&lt;K,V&gt;[] tab; int h = hash(key); long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; // 计算得到 key 的存放位置 if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; (tab = s.table) != null) &#123; for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) &#123; // 如果是链表，遍历查找到相同 key 的 value。 K k; if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) return e.value; &#125; &#125; return null;&#125; JDK 1.8 实现 1.8版本分析，建议参考：https://www.cnblogs.com/zerotomax/p/8687425.html 。 可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。当冲突链表达到一定长度时，链表会转换成红黑树。 和JDK1.8的HashMap是很相似 , 抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。 存储结构和属性 12345678910111213141516171819202122private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;private static final int DEFAULT_CAPACITY = 16; // hashmap也是16static final int TREEIFY_THRESHOLD = 8; // 超过8扩容static final int UNTREEIFY_THRESHOLD = 6;static final int MIN_TREEIFY_CAPACITY = 64; // 超过64红黑树static final int MOVED = -1; // 表示正在转移static final int TREEBIN = -2; // 表示已经转换成树static final int RESERVED = -3; // hash for transient reservationsstatic final int HASH_BITS = 0x7fffffff; // Node数组存储元素transient volatile Node&lt;K,V&gt;[] table;//默认没初始化的数组，用来保存元素private transient volatile Node&lt;K,V&gt;[] nextTable;//转移的时候用的数组/** * 用来控制表初始化和扩容的，默认值为0，当在初始化的时候指定了大小，这会将这个大小保存在sizeCtl中，大小为数组的0.75 * 当为负的时候，说明表正在初始化或扩张， * -1表示初始化 * -(1+n) n:表示活动的扩张线程 */private transient volatile int sizeCtl; 在ConcurrentHashMap中使用了unSafe方法，通过直接操作内存的方式来保证并发处理的安全性，使用的是硬件的安全机制。 123456789101112131415161718192021/* * 用来返回节点数组的指定位置的节点的原子操作 */ @SuppressWarnings(&quot;unchecked&quot;) static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123; return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE); &#125; /* * cas原子操作，在指定位置设定值 */ static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123; return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v); &#125; /* * 原子操作，在指定位置设定值 */ static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123; U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v); &#125; 初始化 1234567891011121314151617//空的构造public ConcurrentHashMapDebug() &#123; &#125;//如果在实例化对象的时候指定了容量，则初始化sizeCtlpublic ConcurrentHashMapDebug(int initialCapacity) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(); int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); this.sizeCtl = cap; &#125;//当出入一个Map的时候，先设定sizeCtl为默认容量，在添加元素public ConcurrentHashMapDebug(Map&lt;? extends K, ? extends V&gt; m) &#123; this.sizeCtl = DEFAULT_CAPACITY; putAll(m); &#125; put方法 123public V put(K key, V value) &#123; return putVal(key, value, false); &#125; 再来看putVal ： 可以发现相比HashTable直接对方法进行加锁synchronized / 1.7版本的ConcurrentHashMap 进入的开头尝试获取锁，1.8版本的ConcurrentHashMap 锁更加细粒度化。 只有：（1）table不为初始化 （2）定位到table位置i不存在元素（此时会用CAS方式进行添加）（3）数组也没有在进行扩张（MOVED=-1） 此时才会进行synchronized 添加元素（不会锁住rehash方法，最后才判断是否扩容）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* * 当添加一对键值对的时候，首先会去判断保存这些键值对的数组是不是初始化了， * 如果没有的话就初始化数组 * 然后通过计算hash值来确定放在数组的哪个位置 * 如果这个位置为空则直接添加，如果不为空的话，则取出这个节点来 * 如果取出来的节点的hash值是MOVED(-1)的话，则表示当前正在对这个数组进行扩容，复制到新的数组，则当前线程也去帮助复制 * 最后一种情况就是，如果这个节点，不为空，也不在扩容，则通过synchronized来加锁，进行添加操作 * 然后判断当前取出的节点位置存放的是链表还是树 * 如果是链表的话，则遍历整个链表，直到取出来的节点的key来个要放的key进行比较，如果key相等，并且key的hash值也相等的话， * 则说明是同一个key，则覆盖掉value，否则的话则添加到链表的末尾 * 如果是树的话，则调用putTreeVal方法把这个元素添加到树中去 * 最后在添加完成之后，会判断在该节点处共有多少个节点（注意是添加前的个数），如果达到8个以上了的话， * 则调用treeifyBin方法来尝试将处的链表转为树，或者扩容数组 */final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException();//K,V都不能为空，否则的话跑出异常 int hash = spread(key.hashCode()); //取得key的hash值 int binCount = 0; //用来计算在这个节点总共有多少个元素，用来控制扩容或者转移为树 for (Node&lt;K,V&gt;[] tab = table;;) &#123; // Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) tab = initTable(); //第一次put的时候table没有初始化，则初始化table else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; //通过哈希计算出一个表中的位置因为n是数组的长度，所以(n-1)&amp;hash肯定不会出现数组越界 if (casTabAt(tab, i, null, //如果这个位置没有元素的话，则通过cas的方式尝试添加，注意这个时候是没有加锁的 new Node&lt;K,V&gt;(hash, key, value, null))) //创建一个Node添加到数组中区，null表示的是下一个节点为空 break; // no lock when adding to empty bin &#125; /* * 如果检测到某个节点的hash值是MOVED，则表示正在进行数组扩张的数据复制阶段， * 则当前线程也会参与去复制，通过允许多线程复制的功能，一次来减少数组的复制所带来的性能损失 */ else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; /* * 如果在这个位置有元素的话，就采用synchronized的方式加锁， * 如果是链表的话(hash大于0)，就对这个链表的所有元素进行遍历， * 如果找到了key和key的hash值都一样的节点，则把它的值替换到 * 如果没找到的话，则添加在链表的最后面 * 否则，是树的话，则调用putTreeVal方法添加到树中去 * * 在添加完之后，会对该节点上关联的的数目进行判断， * 如果在8个以上的话，则会调用treeifyBin方法，来尝试转化为树，或者是扩容 */ V oldVal = null; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; //再次取出要存储的位置的元素，跟前面取出来的比较 if (fh &gt;= 0) &#123; //取出来的元素的hash值大于0，当转换为树之后，hash值为-2 binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; //遍历这个链表 K ek; if (e.hash == hash &amp;&amp; //要存的元素的hash，key跟要存储的位置的节点的相同的时候，替换掉该节点的value即可 ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) //当使用putIfAbsent的时候，只有在这个key没有设置值得时候才设置 e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; //如果不是同样的hash，同样的key的时候，则判断该节点的下一个节点是否为空， pred.next = new Node&lt;K,V&gt;(hash, key, //为空的话把这个要加入的节点设置为当前节点的下一个节点 value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123; //表示已经转化成红黑树类型了 Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, //调用putTreeVal方法，将该元素添加到树中去 value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) //当在同一个节点的数目达到8个的时候，则扩张数组或将给节点的数据转为tree treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); //计数，可能也会触发扩容 return null; &#125; 扩容transfer 扩容主要是通过transfer方法来进行的。 只有在往map中添加元素的时候，在某一个节点的数目已经超过了8个，调用treeifyBin() 触发数组的扩容/转换为数； 使用**addCount()**添加元素数组元素，会进行判断达到了sizeCtl的数量的时候，则会调用transfer方法来进行扩容 treeifyBin() 某一个节点的数目已经超过了8个，执行treeifyBin() 。 当需要扩容的时候，调用的时候tryPresize方法 （1）tryPresize方法并没有加锁，允许多个线程进入，如果数组正在扩张，则当前线程也去帮助扩容使用transfer方法 （2）transfer比较复杂还没有详细看，它里面使用的synchronized 进行单个节点处理扩容 （查看上面看transfer源码） 否则synchronized进行链表转换为树 1234567891011121314151617181920212223242526272829/* * 当数组长度小于64的时候，扩张数组长度一倍，否则的话把链表转为树 */ private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123; Node&lt;K,V&gt; b; int n, sc; if (tab != null) &#123; System.out.println(&quot;treeifyBin方\\t==&gt;数组长：&quot;+tab.length); if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) //MIN_TREEIFY_CAPACITY 64 tryPresize(n &lt;&lt; 1); // 数组扩容 else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123; synchronized (b) &#123; //使用synchronized同步器，将该节点出的链表转为树 if (tabAt(tab, index) == b) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; //hd：树的头(head) for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val, null, null); if ((p.prev = tl) == null) //把Node组成的链表，转化为TreeNode的链表，头结点任然放在相同的位置 hd = p; //设置head else tl.next = p; tl = p; &#125; setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));//把TreeNode的链表放入容器TreeBin中 &#125; &#125; &#125; &#125; &#125; addCount() addCount也主要是调用transfer，这里主要还是寄一下transfer的源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187/** * Moves and/or copies the nodes in each bin to new table. See * above for explanation. * 把数组中的节点复制到新的数组的相同位置，或者移动到扩张部分的相同位置 * 在这里首先会计算一个步长，表示一个线程处理的数组长度，用来控制对CPU的使用， * 每个CPU最少处理16个长度的数组元素,也就是说，如果一个数组的长度只有16，那只有一个线程会对其进行扩容的复制移动操作 * 扩容的时候会一直遍历，知道复制完所有节点，没处理一个节点的时候会在链表的头部设置一个fwd节点，这样其他线程就会跳过他， * 复制后在新数组中的链表不是绝对的反序的 */ private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123; int n = tab.length, stride; if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) //MIN_TRANSFER_STRIDE 用来控制不要占用太多CPU stride = MIN_TRANSFER_STRIDE; // subdivide range //MIN_TRANSFER_STRIDE=16 /* * 如果复制的目标nextTab为null的话，则初始化一个table两倍长的nextTab * 此时nextTable被设置值了(在初始情况下是为null的) * 因为如果有一个线程开始了表的扩张的时候，其他线程也会进来帮忙扩张， * 而只是第一个开始扩张的线程需要初始化下目标数组 */ if (nextTab == null) &#123; // initiating try &#123; @SuppressWarnings(&quot;unchecked&quot;) Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; nextTab = nt; &#125; catch (Throwable ex) &#123; // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; &#125; nextTable = nextTab; transferIndex = n; &#125; int nextn = nextTab.length; /* * 创建一个fwd节点，这个是用来控制并发的，当一个节点为空或已经被转移之后，就设置为fwd节点 * 这是一个空的标志节点 */ ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); boolean advance = true; //是否继续向前查找的标志位 boolean finishing = false; // to ensure sweep(清扫) before committing nextTab,在完成之前重新在扫描一遍数组，看看有没完成的没 for (int i = 0, bound = 0;;) &#123; Node&lt;K,V&gt; f; int fh; while (advance) &#123; int nextIndex, nextBound; if (--i &gt;= bound || finishing) &#123; advance = false; &#125; else if ((nextIndex = transferIndex) &lt;= 0) &#123; i = -1; advance = false; &#125; else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123; bound = nextBound; i = nextIndex - 1; advance = false; &#125; &#125; if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; int sc; if (finishing) &#123; //已经完成转移 nextTable = null; table = nextTab; sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); //设置sizeCtl为扩容后的0.75 return; &#125; if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123; if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) &#123; return; &#125; finishing = advance = true; i = n; // recheck before commit &#125; &#125; else if ((f = tabAt(tab, i)) == null) //数组中把null的元素设置为ForwardingNode节点(hash值为MOVED[-1]) advance = casTabAt(tab, i, null, fwd); else if ((fh = f.hash) == MOVED) advance = true; // already processed else &#123; synchronized (f) &#123; //加锁操作 if (tabAt(tab, i) == f) &#123; Node&lt;K,V&gt; ln, hn; if (fh &gt;= 0) &#123; //该节点的hash值大于等于0，说明是一个Node节点 /* * 因为n的值为数组的长度，且是power(2,x)的，所以，在&amp;操作的结果只可能是0或者n * 根据这个规则 * 0--&gt; 放在新表的相同位置 * n--&gt; 放在新表的（n+原来位置） */ int runBit = fh &amp; n; Node&lt;K,V&gt; lastRun = f; /* * lastRun 表示的是需要复制的最后一个节点 * 每当新节点的hash&amp;n -&gt; b 发生变化的时候，就把runBit设置为这个结果b * 这样for循环之后，runBit的值就是最后不变的hash&amp;n的值 * 而lastRun的值就是最后一次导致hash&amp;n 发生变化的节点(假设为p节点) * 为什么要这么做呢？因为p节点后面的节点的hash&amp;n 值跟p节点是一样的， * 所以在复制到新的table的时候，它肯定还是跟p节点在同一个位置 * 在复制完p节点之后，p节点的next节点还是指向它原来的节点，就不需要进行复制了，自己就被带过去了 * 这也就导致了一个问题就是复制后的链表的顺序并不一定是原来的倒序 */ for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123; int b = p.hash &amp; n; //n的值为扩张前的数组的长度 if (b != runBit) &#123; runBit = b; lastRun = p; &#125; &#125; if (runBit == 0) &#123; ln = lastRun; hn = null; &#125; else &#123; hn = lastRun; ln = null; &#125; /* * 构造两个链表，顺序大部分和原来是反的 * 分别放到原来的位置和新增加的长度的相同位置(i/n+i) */ for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123; int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) /* * 假设runBit的值为0， * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同为0的节点)设置到旧的table的第一个hash计算后为0的节点下一个节点 * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点 */ ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else /* * 假设runBit的值不为0， * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同不为0的节点)设置到旧的table的第一个hash计算后不为0的节点下一个节点 * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点 */ hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); &#125; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; &#125; else if (f instanceof TreeBin) &#123; //否则的话是一个树节点 TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt; (h, e.key, e.val, null, null); if ((h &amp; n) == 0) &#123; if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; &#125; else &#123; if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; &#125; &#125; /* * 在复制完树节点之后，判断该节点处构成的树还有几个节点， * 如果≤6个的话，就转回为一个链表 */ ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; &#125; &#125; &#125; &#125; &#125; &#125; get方法 get操作中，根本没有使用同步机制，也没有使用unsafe方法，所以读（get）操作是支持并发操作的。 123456789101112131415161718192021222324252627/* * 相比put方法，get就很单纯了，支持并发操作， * 当key为null的时候回抛出NullPointerException的异常 * get操作通过首先计算key的hash值来确定该元素放在数组的哪个位置 * 然后遍历该位置的所有节点 * 如果不存在的话返回null */ public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; int h = spread(key.hashCode()); if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; else if (eh &lt; 0) return (p = e.find(h, key)) != null ? p.val : null; while ((e = e.next) != null) &#123; if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null; &#125; 7.1 你知道 ConcurrentHashMap 的工作原理吗？ Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。 主要采用锁机制，在对某个Segment进行操作时，将该Segment锁定，不允许对其进行非查询操作 Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 Segment 数组 + HashEntry 数组 + 链表 进化成了 Node 数组 + 链表 / 红黑树，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。 CAS无锁算法，这种乐观操作在完成前进行判断，如果符合预期结果才给予执行 7.2 请问ConcurrentHashMap中变量使用final和volatile修饰有什么用呢？其中链表是final的next属性，那么发生删除某个元素，如何实现的？ ConcurrentHashMap被final修饰的变量，（部分）如下： 1234567891011121314// 默认初始容量static final int DEFAULT_INITIAL_CAPACITY = 16;// 默认加载因子static final float DEFAULT_LOAD_FACTOR = 0.75f;// 默认segment层级static final int DEFAULT_CONCURRENCY_LEVEL = 16;// 最大容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// segment最小容量static final int MIN_SEGMENT_TABLE_CAPACITY = 2;// 一个segment最大容量static final int MAX_SEGMENTS = 1 &lt;&lt; 16;// 锁之前重试次数static final int RETRIES_BEFORE_LOCK = 2; HashEntry中被volatile修饰的部分变量如下： 12345static final class HashEntry&lt;K,V&gt; &#123; final int hash; final K key; volatile V value; // 保证可见性 volatile HashEntry&lt;K,V&gt; next; 使用final。用来实现不变模式（immutable），他是多线程安全里最简单的一种保障方式。因为你拿他没有办法，想改变它也没有机会。不变模式主要通过final关键字来限定的。在JMM中final关键字还有特殊的语义。Final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让不可变形对象不需要同步就能自由地被访问和共享。 使用volatile。保证某个变量内存的改变对其他线程即时可见，在配合CAS可以实现不加锁对并发操作的支持。 7.3 HashTable与ConcurrentHashMap有什么区别，描述锁分段技术。 锁机制。 所有访问HashTable的线程都必须竞争同一把锁，效率更低；ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 底层数据结构。 1.8之后很相似，都是数组+链表/红黑树 ； 1.8之前，ConcurrentHashMap是Segement数组 + HashEntry数组 + 链表。 7.4 （阿里·淘特）ConcurrentHashMap1.8为什么不使用分段锁？ 先说分段锁的优点： 保证在操作不同段 map 的时候可以并发执行；操作同段 map 的时候，进行锁的竞争和等待。这相对于直接对整个map同步synchronized是有优势的。 但是分段锁也有一些不可忽视的缺点： 分成很多段时会比较浪费内存空间(不连续，碎片化)； 操作map时竞争同一个分段锁的概率非常小（段散列比较好的时候）时，分段锁反而会造成更新等操作的长时间等待； 当某个段很大时，分段锁的性能会下降。 综上考虑1.8不再使用分段锁。 7.5 为什么1.8中 get() 方法不加锁？ 因为链表每个节点的val和next都使用volatile修饰，保证了可见性。 7.6 为什么1.8不使用lock而是使用sync？ 因为sync加入锁升级机制（jdk1.6之后），已经优化的不错了； lock通过reentranclock实现，reentranlock是通过AQS实现，需要增加额外内存开销（CLH双向队列）。 7.7 ConcurrenthashMap使用的时候有可能出现不安全的情况？ 参考：https://blog.csdn.net/luzhensmart/article/details/108133560 查了一些资料后发现，原来ConcurrentHashMap的线程安全指的是，它的【每个方法】单独调用（即原子操作）都是线程安全的，但是代码总体的互斥性并不受控制。以上面的代码为例，最后一行中的： 1234567891011121314public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; this.addup(); &#125; &#125; private void addup() &#123; if (!map.containsKey(KEY)) &#123; map.put(KEY, 1); &#125; else &#123; map.put(KEY, map.get(KEY) + 1); &#125; &#125; 在上面一个线程内部进行了100次加法，但是其实加1在线程内部本身也并不是原子操作。 实际上并不是原子操作，它包含了三步： map.get 加1 map.put 是由于在上面的代码中，map本身是一个共享变量。当线程A执行map.get的时候，其它线程可能正在执行map.put，这样一来当线程A执行到map.put的时候，线程A的值就已经是脏数据了，然后脏数据覆盖了真值，导致线程不安全。 8. HashMap 和 HashSet区别 ？ 如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了clone() 、 writeObject() 、 readObject() 是 HashSet ⾃⼰不得不实现之外，其他方法都是直接调用 HashMap 中的方法。 HashMap HashSet 实现了Map接⼝ 实现Set接⼝ 存储键值对 仅存储对象 调⽤ put() 向map中添加元素 调⽤ add() ⽅法向Set中添加元素 HashMap使⽤键（Key）计算Hashcode：int hash = hash(key); HashSet使⽤成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()⽅法⽤来判断对象的相等性。 9. 说说HashSet的基本原理？ 底层结构 HashSet底层原理完全就是包装了一下HashMap ，只不过存储的时候value是默认存储了一个Object的静态常量，取的时候也是只返回key，所以看起来就像List一样。 初始化 123456789101112131415161718private transient HashMap&lt;E,Object&gt; map; public HashSet() &#123; map = new HashMap&lt;&gt;();&#125; public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity);&#125; public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor);&#125; public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125; add()方法 可以看到这三个方法都是直接调用的HashMap的实现。 1234567891011public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125; public boolean contains(Object o) &#123; return map.containsKey(o);&#125; add其实就是调用HashMap的put方法，那么如何保证唯一性？ 如果哈希值和key都一样，就会直接拿新值覆盖旧值，而HashSet就是利用这个特性来保证唯一性。 其实和HashMap就是一样的。 12if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; contains方法（Get()方法 ） hashset没有get方法，因为没有意义：不需要获取某个键值对应的value。 具体实现直接调用hashmap的containsKey()方法： 过程和hashmap的get方法过程差不多，返回为null则是不存在。 123public boolean contains(Object o) &#123; return map.containsKey(o);&#125; 9. 1 HashSet如何检查重复 ？ 把对象加⼊ HashSet 时，HashSet先计算对象的hashcode 值； 根据hashcode值计算出要加⼊的位置，同时也会与其他加⼊的对象的hashcode值作⽐教； 如果没有相符的hashcode，HashSet会假设对象没有重复出现； 如果发现有相同hashcode值的对象，这时会调用 equals() 方法来检查hashcode相等的对象是否真的相同，如果两者相同，HashSet就不会让加⼊操作成功。 9.2 【新】contains()方法在HashSet和ArrayList的实现区别？ Arraylist 因为底层是object数组，判断某个对象是否存在，其实是通过遍历来进行判断的。 123456789101112131415161718 public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;//#1 &#125;/* 返回指定元素在列表中第一次出现的索引，如果该列表不包含该元素，则返回-1。*/ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; Hashset Hashset是hash值 &amp;&amp; 遍历链表equals() 都相等，来判断的。 12if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; 10. comparable 和 Comparator的区别？ 参考：https://www.cnblogs.com/xujian2014/p/5215082.html Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。 例如Person类，实现Comparable接口，使得所有Person类对象可以按照各自年龄大小进行排序。 12345@Override public int compareTo(Person p) &#123; return this.age-p.getAge(); &#125; Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。 Person类没有实现Comparable接口，该如何比较大小呢？我们可以新建一个类，让其实现Comparator接口，从而构造一个“比较器&quot;。 12345@Override public int compare(Person o1, Person o2) &#123; return o1.getAge()-o2.getAge(); &#125; Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。。 11. 如何选用集合? 需要存储键值对： Map接口的集合 需要排序时选择TreeMap 不需要排序时就选择HashMap 需要保证线程安全就选⽤ConcurrentHashMap 只需要存储元素，实现collection接口的集合，又分为： 需要保证元素唯一–Set接口的集合 HashSet 不需要元素唯一–List接口结合 查找比较多：ArrayList 增删比较多：LinkedList 1.3.3 List 1.用过 ArrayList 吗？说一下它有什么特点？ 自动扩容： 当加入数据达到一定程度后，会实行自动扩容，即扩大数组大小 ； 底层实现：底层是使用数组实现，add(int,o)，添加到某个位置，那么可能会挪动大量的数组元素，并且可能会触发扩容机制； 线程不安全 2. ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？ 线程安全： Vector线程安全，ArrayList 不是； Vector耗时：Vector 类的所有方法都是同步的。可以由两个线程安全地访问⼀个Vector对象、但是⼀个线程访问Vector的话代码要在同步操作上耗费大量的时间。 3. Array &amp; ArrayList不同点? Array可以包含基本类型和对象类型，ArrayList只能包含对象类型 ； Array大小是固定的，ArrayList的大小是 动态变化 的 ； ArrayList提供了更多的方法和特性: addAll()，removeAll()，iterator()。 4. Arraylist 与 LinkedList 区别? 索引/插入：ArrayList按序号索引，索引快插入慢；LinkedList不是，索引慢，插入快； 内存方面： Arraylist 是线性连续存储， 内存利用更低；LinkedList 是链表，内存利用更高（将内存零散空间串联），但也更占有内存（每个节点存储了两个引用）； 线程安全： ArrayList 和 LinkedList 都是不同步的，也就是都不保证线程安全； 底层数据结构： Arraylist 底层使用的是 Object数组； LinkedList 底层使用的是双向链表 数据结构 ； JDK1.6之前为循环链表，JDK1.7取消了循环。 5. 【源码解读】说说ArrayList的扩容机制吧 ？为什么是扩容1.5倍？默认大小是多少。 逐源码分析扩容机制 先把回答写在下面： ArrayList/vector默认大小都是10，但vectot扩容是2倍。 1. 扩容机制： 使用无参构造函数创建的数组长度为0，当第一次add后数组长度为10 ； 如果继续add超过10后，也就是不满足minCapacity（最小需要容量） - elementData.length &gt; 0 会触发扩容机制。 将新容量更新为旧容量的1.5倍 ，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】。 最后检查设置的新容量是否大于最大容量MAX_ARRAY_SIZE ，进入hugeCapacity() : 如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8 。 2. 为什么是1.5倍？ 因为，int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)，所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同。 比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数。 ArrayList总览 ArrayList继承于AbstractList ，实现了List,RandomAccess,Cloneable,java.io.Serializable 这些接口。 1234public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; &#125; RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问； ArrayList 实现了Cloneable 接口 ，即覆盖了函数clone()，能被克隆； ArrayList 实现了 java.io.Serializable 接口，这意味着ArrayList支持序列化，能通过序列化去传输。 ArrayList 核心源码解读（先耐心看一遍） 直接点击上面链接 逐源码分析扩容机制 查看。 【重点】JDK8 扩容机制 解读 从构造函数说起 （JDK8）ArrayList 有三种方式来初始化 : 以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。 jdk8中的ArrayList的对象的创建类似于单例的懒汉式。JDK8的内存优化也值得我们在平时开发中学习。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 /** * 默认初始容量大小 */ private static final int DEFAULT_CAPACITY = 10; /** * 空数组（用于空实例）。 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //用于默认大小空实例的共享空数组实例。 //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 保存ArrayList数据的数组 */ transient Object[] elementData; // non-private to simplify nested class access /** * ArrayList 所包含的元素个数 */ private int size; /** /** * 带初始容量参数的构造函数。（用户自己指定容量） */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123;//初始容量大于0 //创建initialCapacity大小的数组 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123;//初始容量等于0 //创建空数组 this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123;//初始容量小于0，抛出异常 throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125; &#125; /** *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回 *如果指定的集合为null，throws NullPointerException。 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 再看add方法 这里以无参构造函数创建的 ArrayList 为例分析 。 JDK11 移除了 ensureCapacityInternal() 和 ensureExplicitCapacity() 方法 12345678910/** * 将指定的元素追加到此列表的末尾。 */ public boolean add(E e) &#123; //添加元素之前，先调用ensureCapacityInternal方法 ensureCapacityInternal(size + 1); // Increments modCount!! //这里看到ArrayList添加元素的实质就相当于为数组赋值 elementData[size++] = e; return true; &#125; 再看 ensureCapacityInternal() 方法 第2步（JDK7）可以看到 add 方法 首先调用了ensureCapacityInternal(size + 1) 。 当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。 然后开始调用 ensureExplicitCapacity() 方法 123456789//得到最小扩容量 private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 获取默认的容量和传入参数的较大值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; 调用 ensureCapacityInternal() 进入ensureExplicitCapacity()这个方法 123456789//判断是否需要扩容 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) //调用grow方法进行扩容，调用此方法代表已经开始扩容了 grow(minCapacity); &#125; 我们来仔细分析一下： 当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 ensureCapacityInternal() 方法 ，所以 minCapacity 此时为 10。此时，minCapacity - elementData.length &gt; 0成立，所以会进入 grow(minCapacity) 方法。 当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，minCapacity - elementData.length &gt; 0 不成立，所以不会进入 （执行）grow(minCapacity) 方法。 添加第 3、4···到第 9 个元素时，依然不会执行 grow 方法，数组容量都为 10。 直到添加第 10 个元素，minCapacity &lt; elementData.length不成立。进入 grow 方法进行扩容。 elementData.length（实际容量）&gt;= minCapacity（最小需要容量） , 执行 grow() int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数。 将新容量更新为旧容量的1.5倍 ，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】。 最后检查设置的新容量是否大于最大容量MAX_ARRAY_SIZE ，进入hugeCapacity() : 如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8 。 1234567891011121314151617181920212223/** * 要分配的最大数组大小 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * ArrayList扩容的核心方法grow。 */ private void grow(int minCapacity) &#123; // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; //将oldCapacity 右移一位，其效果相当于oldCapacity /2， //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍， int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】， if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE， //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); 设置完新容量 newCapacity ，进行Arrays.copyOf Arrays的copyOf()方法传回的数组是新的数组对象，改变传回数组中的元素值，不会影响原来的数组。 第二个自变量指定要建立的新数组长度，如果新数组的长度超过原数组的长度，则保留数组默认值，例如： 使用 Arrays.copyOf()方法主要是为了给原有数组扩容。 contains()方法 就是遍历数组看是否存在该元素。 123456789101112131415161718 public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;//#1 &#125;/* 返回指定元素在列表中第一次出现的索引，如果该列表不包含该元素，则返回-1。*/ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 5.1 多线程操作ArrayList会出现什么错误？ 从ArrayList的（1）添加元素（add/addAll）和（2）获取元素（get） 两个角度来说： 多线程添加元素 假设此时minCapacity（最小需要容量）= 10 ，此时数组容量是10。A,B两个线程各需要添加若干元素，同时 判断此时不需要扩容，后续可能就会发生数组越界。 多线程获取元素 一个线程正在修改某个元素，另外一个线程此时正在读，那么读到的就是修改前的元素，也就是脏数据。 5.2 arraylist可以存多少数据？ Integer.MAX_VALUE = 2147483647 。 arraylist底层是一个数组对象：Object[] arr = new Object[10]，数组的大小只能设置int类型。所以能存储2147483647 字节数据。 6. 说一下LinkedList底层原理？ 参考：Java集合系列之三：LinkedList底层原理 LinkedList实现了List接口和Deque接口的，底层的双端链表结构使它支持高效的插入和删除操作，也具有队列的特性，非线程安全的。 相比ArrayList要简单很多，主要是双向链表那些操作。 底层结构 核心属性、构造方法和Node定义如下。 123456789101112131415161718192021222324252627282930public class LinkedList&lt;E&gt;extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; transient int size = 0; //LinkedList中存放的元素个数 transient Node&lt;E&gt; first; //头节点 transient Node&lt;E&gt; last; //尾节点 //构造方法，创建一个空的列表 public LinkedList() &#123;&#125; //将一个指定的集合添加到LinkedList中，先完成初始化，在调用添加操作 public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125;// Node节点 private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; add() 方法 朴实无华的双向链表尾插法。获得当前最后一个节点最为当前节点的前置节点，同样把当前节点设置为前置节点的后置节点，然后把当前节点作为最后一个节点，因为只需要创建一个节点与前一个节点建立前后关系即可，时间复杂度是O(1)。 123456789101112131415161718192021public boolean add(E e) &#123; linkLast(e); return true;&#125; void linkLast(E e) &#123; // 获得当前最后一个节点作为前置节点，可能为空 final Node&lt;E&gt; l = last; // 初始化当前节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 把当前节点作为最后的节点 last = newNode; // 第一次添加设置为第一个节点 if (l == null) first = newNode; else // 把当前节点设置为前置节点的后置节点 l.next = newNode; size++; modCount++;&#125; add(int index,E e) 按索引插入元素，首先判断是不是第一个添加的元素，如果是的话，直接使用add()方法添加就可以了，如果不是则需要根据索引来遍历寻找链表上对应位置。 这里用了个小技巧，判断索引是在前半段还是在后半段，从短的那头开始遍历，找到之后，新建一个节点，建立新的前置节点和后置节点的关系。时间复杂度是O(n)，n为size/2。 get(int index)方法 get()方法是用的上面介绍过的node()方法，时间复杂度是O(n)，n为size/2。 12345678910111213141516171819202122232425262728 public E get(int index) &#123; // 判断数组越界 checkElementIndex(index); // 遍历寻找节点 return node(index).item; &#125;// 获得被插入索引上的元素Node&lt;E&gt; node(int index) &#123;// assert isElementIndex(index);// 如果索引是在链表的前半段if (index &lt; (size &gt;&gt; 1)) &#123; // 获得第一个节点 Node&lt;E&gt; x = first; // 往后找到插入索引位置上的节点 for (int i = 0; i &lt; index; i++) x = x.next; return x;&#125;// 如果索引是在链表的前半段else &#123; // 获得最后个节点 Node&lt;E&gt; x = last; // 往前找到插入索引位置上的节点 for (int i = size - 1; i &gt; index; i--) x = x.prev; return x;&#125; 1.3.4 迭代器 1.请简单说明一下什么是迭代器？ Iterator提供了统一遍历操作集合元素的统一接口, Collection接口实现Iterable接口。 每个集合都通过实现Iterable接口中iterator()方法返回Iterator接口的实例, 然后对集合的元素进行迭代操作； 在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出ConcurrentModificationException 异常. 但是可以通过Iterator接口中的remove()方法进行删除。 2.请你说说Iterator和ListIterator的区别？ 遍历类型：Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List； 遍历方向：Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向； 功能区别：ListIterator实现了Iterator接口，并包含其他的功能","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"JAVA","slug":"校招笔记/JAVA","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://hwh.zone/tags/JAVA/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"}]},{"title":"校招笔记（一）_Java_面对对象","slug":"校招笔记（一）_Java_面对对象","date":"2021-11-26T11:57:22.483Z","updated":"2021-11-26T16:32:14.207Z","comments":true,"path":"2021/11/26/校招笔记（一）_Java_面对对象/","link":"","permalink":"https://hwh.zone/2021/11/26/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89_Java_%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 🚩 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 1.2 面对对象 1.2.1 基本问题 1.介绍一下面对对象七大原则？三大特性？ 七大原则 单一职责原则： 就一个类来说，应该仅有一个引起它变化的原因。也就是说，一个类应该只有一个职责。 如果有多个职责，那么就相当于把这些指责耦合在起，一个职责的变化就可能削弱或抑制了这个类完成其他职责的能力，引起类的变化的原因就会有多个。所以在构造一个类时， 将类的不同职责分离至两个或多个类中(或者接口中)，确保引起该类变化的原因只有一个。 开闭原则(OCP)： 软件组成实体应该是可扩展的，但是不可修改。开放-封闭原则认为应该试图设计永远也不需要改变的模块。可以添加新代码来打展系统的行为，不能对已有的代码进行修改。 这个原则很好的实现了面向对象的封装性和可重用性。 李氏替换原则(LSP)： 子类应当可以替换父类并出现在父类能够出现的任何地方。 以圆和椭圆为例，圆是椭圆的一一个特殊子类。因此任何出现椭圆的地方，圆均可以出现。 依赖倒置原则(DIP)： 在进行业务设计时，与特定业务有关的依赖关系应该尽量依赖接口和抽象类，而不是依赖于具体类。具体类只负责相关业务的实现，修改具体类不影响与特定业务有关的依赖关系。 为此，在进行业务设计时，应尽量在接口或抽象类中定义业务方法的原型，并通过具体的实现类(子类)来实现该业务方法，业务方法内容的修改将不会影响到运行时业务方法的调用。 接口分离原则(ISP)： 采用多个与特定客户类有关的接口 比采用一个通用的涵盖多个业务方法的接口要好。 举例：如果拥有一个针对多个客户的类，为每一个客户创建特定业务接口，然后使该客户类继承多个特定业务接口将比直接加载客户所需所有方法有效。 组合重用原则 ：能用组合实现的地方，尽量用组合来实现，而不要使用继承来扩展功能。 097因为组合能更好地实现封装，比继承具有更大的灵活性和更稳定的结构。 迪米特原则 : 一个对象应该对于其他对象有最少的了解，这样做的好处就是可以有效地降低类之间的耦合要求。 三大特性 封装。封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果⼀个类没有提供给外界访问的方法，那么这个类也没有什么意义了。 继承。 继承是使用已存在的类的定义作为基础建⽴新类的技术，新类的定义可以增加新的数据或新的功能，也可以用⽗类的功能，但不能选择性地继承⽗类。通过使用继承我们能够非常方便地复用以前的代码。 子类拥有⽗类对象所有的属性和方法（包括私有属性和私有方法），但是⽗类中的私有属性和方法子类是无法访问，只是拥有。 子类可以拥有⾃⼰属性和方法，即子类可以对⽗类进行扩展。 子类可以用⾃⼰的方式实现⽗类的方法。 多态。（1）静态多态：重载 （2）动态多态：所谓多态就是指程序中定义的引用变量所指向的具体类型和&lt;通过该引用变量发出的方法调用在编程时并不确定，而是在【程序运行期间才确定】。即⼀个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。 在 Java 中有两种形式可以实现多态：继承（多个子类对同⼀方法的重写）和接口（实现接口并覆盖接口中同⼀方法）。 1.1 java多态的原理？【阿里&amp;待重写】 多态分两种：（1）【编译】时多态（静态多态）（2）运行时多态（动态多态）。 静态多态 重载（overload）就是编译时多态的一个例子，编译时多态在编译时就已经确定。 运行时运行的时候调用的是确定的方法。 动态多态 我们通常所说的多态指的都是运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时（链接过程）才能确定。 通常动态多态的实现方法： 子类继承父类（extends） 类实现接口（implements） 核心之处就在于对父类方法的改写或对接口方法的实现，以取得在运行时不同的执行效果。 多态运行的原理 详细建议查看：深入理解Java多态的实现原理 背景介绍 类加载 时会将类的元数据信息（类的方法代码、类变量、成员变量的定义等等）保存到方法区，方法区主要分为两部分： 常量池：Java 类引用的一些常量信息，比如类的符号引用信息 方法区其它部分： 保存方法表等 链接过程 类的多态就发生在 链接的解析 过程，将 符号引用替换为直接引用。 原理简述（子类方法继承） 参考：https://www.huaweicloud.com/articles/9b805c24ab31a65f5883c0dfeaf5a39b.html 2.请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？ 构造函数： 每一个类都有构造函数，程序员没有创建时，编译器会默认创建一个构造函数；对象被创建时，构造函数被调用； 构造函数重载： 和方法重载类似，一个类可以创建多个构造函数，每个构造函数都有唯一参数列表； 复制构造函数： Java不支持像C++中那样的复制构造函数。 3.请说明Java中的方法重写(Overriding)和方法重载(Overloading)是什么意思？构造函数能否被重写？ Overriding ： 方法重写是说子类重新定义了父类的方法，有相同的方法名，参数列表和返回类型 ； Overloading： 同一个类里面两个或者是多个方法同名 ，但 参数列表不同不同。 特别的重写要求返回类型一致，但重载不要求返回类型一致！ 构造函数不能被 override（重写）！但是可以 overload（重载）,所以你可以看到⼀个类中有多个构造函数的情况。 3.1 f（List&lt;String&gt; l） f（List&lt;Integer&gt; l）是重载么？ 不是重载。 静态类型一致，并不会因为泛型而改变。因为编译期间，会对泛型进行擦除。 4.介绍一下接口和抽象类的区别？ 设计层面 接口，是对类的行为进行约束，强制要求不同类实现相同行为 ； 抽象类，既 1.非抽象类实现代码复用 2.又同时有抽象方法使得被继承类各自实现。 方法实现 抽象类可以有非抽象方法，有方法体 ； 接口不能有。 抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。 构造函数 抽象类有；接口没有。 修饰符 抽象类除private 都有（抽象类目的是被继承，所以抽象方法是为被重写，不能私有）；接口默认public。 继承个数 [接口优] 抽象类只能被继承一次；接口可以有多个。 5. Java的四种引用？强软弱虚 ？ 强引用 ：强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方式： 12String str = new String(&quot;str&quot;);System.out.println(str); 软引用： 软引用在程序内存不足时，会被回收（“软”，没钱用了第一个被打劫），使用方式： 可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。 123// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，// 这里的软引用指的是指向new String(&quot;str&quot;)的引用，也就是SoftReference类中TSoftReference&lt;String&gt; wrf = new SoftReference&lt;String&gt;(new String(&quot;str&quot;)); 弱引用：是只要JVM垃圾回收器发现了弱引用，就会将之回收，使用方式： 可用场景： Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用。一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。 1WeakReference&lt;String&gt; wrf = new WeakReference&lt;String&gt;(str); 虚引用：无法通过虚引用来获取对一个对象的真实引用； 虚引用必须与ReferenceQueue一起使用，当GC准备回收一个对象，如果发现它还有虚引用，就会在回收之前，把这个虚引用加入到与之关联的ReferenceQueue中。 可用场景： 对象销毁前的一些操作，比如说资源释放等。 Object.finalize() 虽然也可以做这类动作，但是这个方式即不安全又低效。 12PhantomReference&lt;String&gt; prf = new PhantomReference&lt;String&gt;(new String(&quot;str&quot;),new ReferenceQueue&lt;&gt;()); 6. JAVA创建对象的机制？ new创建新对象 通过反射机制 采用clone机制 通过序列化机制 7.简述Java的对象结构？ Java对象由三个部分组成：对象头、实例数据、对齐填充。 对象头。 在JVM中，对象在内存中除了本身的数据外还会有个对象头，对于普通对象而言，其对象头中有两类信息：mark word和类型指针。 如果是数组对象，还有数组长度。 mark word(32位) 具体的内容包含对象的hashcode、分代年龄、轻量级锁指针、重量级锁指针、GC标记（分代年龄）、偏向锁线程ID、偏向锁时间戳。 当对象状态为偏向锁时，mark word存储的是偏向的线程ID；当状态为轻量级锁（lightweight locked）时，mark word存储的是指向线程栈中Lock Record的指针；当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针。 存储类型指针，也就是指向类的元数据的指针，通过这个指针才能确定对象是属于哪个类的实例； 数组长度：另外对于数组而言还会有一份记录数组长度的数据。 实例数据。 来存储对象真正的有效信息（包括父类继承下来的和自己定义的）； 对齐填充。JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）。 8. Object有哪些常用方法？ equals方法 hashCode方法 wait方法 notify方法 notifyAll方法 1.2.2 反射 1.请说明一下JAVA中反射的实现过程和作用分别是什么？ （快手）优缺点？ 定义 反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。 jdbc就是典型的反射 : 1Class.forName(&#x27;com.mysql.jdbc.Driver.class&#x27;);//加载MySQL的驱动类 实现和作用 JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。 实现： （1）代码会编译成一个.class文件 （2）类加载器加载进JVM的内存中，在方法区创建了Object类的Class对象 不是new出来的对象，而是类的类型对象，每个类都只有一个Class对象，作为方法区类的数据结构的接口。 我们便是通过这个class对象来进行反射获取类的信息。 作用： 反射机制指的是程序在运行时能够获取自身的信息。在JAVA中，只要给定类的名字，那么就可以通过反射机制来获取类的所有信息。 根据类名在运行时创建实例（类名可以从配置文件读取，不用new） 反射优缺点 优点：（1）对于任意一个类，都能够知道这个类的所有属性和方法；（2）对于任意一个对象，都能够调用它的任意一个方法 缺点： 性能降低 ： 反射包括了一些动态类型，所以JVM无法对这些代码进行优化 安全限制： 使用反射技术要求程序必须在一个没有安全限制的环境中运行 内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用 2. 解释一下JAVA代理模式？动态代理的原理？ 参考这个：JAVA面试50讲之9：动态代理的原理是什么？ 代理模式是给某一个对象提供一个代理，并由【代理对象】控制对【原对象】的引用(使用)。 优点：代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；可以灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务。 缺点：由于使用了代理模式，因此程序的性能没有直接调用性能高；使用代理模式提高了代码的复杂度。 根据代理模式又可以分为：静态代理和动态代理。 2.1 静态代理 静态代理：由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口、被代理类、代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。 代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。 一个班的同学（Student）要向老师交班费，但是都是通过班长（StudentProxy）把自己的钱转交给老师。这里，班长就是代理学生上交班费，班长就是学生的代理。 公共Person接口 1234/public interface Person &#123; //上交班费 void giveMoney(); &#125; Student实现Person接口 1234567891011public class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void giveMoney() &#123; System.out.println(name + &quot;上交班费50元&quot;); &#125;&#125; StudentsProxy实现Person接口 实现了Peson接口，同时持有一个Student对象，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为。 ⚠️ 自己实现的giveMoney，调用的是被代理的学生对象.giveMoney() 方法！ 123456789101112131415/public class StudentsProxy implements Person&#123; //被代理的学生 Student stu; public StudentsProxy(Person stu) &#123; // 只代理学生对象 if(stu.getClass() == Student.class) &#123; this.stu = (Student)stu; &#125; &#125; //代理上交班费，调用被【代理学生的上交班费】行为 public void giveMoney() &#123; stu.giveMoney(); &#125;&#125; 使用实例1 123456789101112public class StaticProxyTest &#123; public static void main(String[] args) &#123; //被代理的学生张三，他的班费上交有代理对象monitor（班长）完成 Person zhangsan = new Student(&quot;张三&quot;); //生成代理对象，并将张三传给代理对象 Person monitor = new StudentsProxy(zhangsan); //班长代理上交班费，实际上是调用被代理对象的giveMoney方法 monitor.giveMoney(); &#125;&#125; 使用实例2：扩充增强原对象方法 班长在帮张三上交班费之前，想要先反映一下张三最近学习有很大进步，通过代理模式很轻松就能办到 。 1234567891011121314151617public class StudentsProxy implements Person&#123; //被代理的学生 Student stu; public StudentsProxy(Person stu) &#123; // 只代理学生对象 if(stu.getClass() == Student.class) &#123; this.stu = (Student)stu; &#125; &#125; //代理上交班费，调用被代理学生的上交班费行为 public void giveMoney() &#123; System.out.println(&quot;张三最近学习有进步！&quot;); stu.giveMoney(); &#125;&#125; 2.2 动态代理 上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就已经编译完成 。 然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成“的 。 优点： 可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 比如说，想要在每个代理的方法前都加上一个处理方法： 12345678910111213 public void giveMoney() &#123; //调用被代理方法前加入处理方法 beforeMethod(); stu.giveMoney(); &#125;// 代理类其它方法public void giveHomework() &#123; //调用被代理方法前加入处理方法 beforeMethod(); stu.giveHomework(); &#125; 除了giveMonney还有很多其他的方法（giveHomework），那就需要写很多次beforeMethod方法，麻烦。 简单实现 12345 //创建一个与代理对象相关联的InvocationHandler InvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu);//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法 Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler); 公共Person接口 1234/public interface Person &#123; //上交班费 void giveMoney(); &#125; Student实现Person接口 12345678910111213141516public class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void giveMoney() &#123; try &#123; //假设数钱花了一秒时间 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(name + &quot;上交班费50元&quot;); &#125;&#125; 增加一个计算方法执行时间的检测方法： 12345678910111213public class MonitorUtil &#123; private static ThreadLocal&lt;Long&gt; tl = new ThreadLocal&lt;&gt;(); public static void start() &#123; tl.set(System.currentTimeMillis()); &#125; //结束时打印耗时 public static void finish(String methodName) &#123; long finishTime = System.currentTimeMillis(); System.out.println(methodName + &quot;方法耗时&quot; + (finishTime - tl.get()) + &quot;ms&quot;); &#125;&#125; StuInvocationHandler 实现 InvocationHandler接口 并没有像之前一样：用一个代理类 StudentsProxy实现公共Person接口，而是代理类StuInvocationHandler 实现InvocationHandler接口。 但二者都是持有被代理的对象Student引用。 InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。 通过反射，可以执行被代理对象Student的相应方法giveMoney()。 123456789101112131415161718192021222324public class StuInvocationHandler&lt;T&gt; implements InvocationHandler &#123; //invocationHandler持有的被代理对象 T target; public StuInvocationHandler(T target) &#123; this.target = target; &#125; /** * proxy:代表动态代理对象 * method：代表正在执行的方法 * args：代表调用目标方法时传入的实参 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;代理执行&quot; +method.getName() + &quot;方法&quot;); */ //代理过程中插入监测方法,计算该方法耗时 MonitorUtil.start(); // 原来的代理对象Student中的方法 Object result = method.invoke(target, args); MonitorUtil.finish(method.getName()); return result; &#125;&#125; 具体实例 123456789101112131415public class ProxyTest &#123; public static void main(String[] args) &#123; //创建一个实例对象，这个对象是被代理的对象 Person zhangsan = new Student(&quot;张三&quot;); //创建一个与代理对象相关联的InvocationHandler InvocationHandler stuHandler = new StuInvocationHandler&lt;Person&gt;(zhangsan); //创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法 Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)； //代理执行上交班费的方法 stuProxy.giveMoney(); &#125;&#125; 2.3 动态代理的原理 从 JVM 角度来说，动态代理是在运行时，通过反射动态生成类字节码，并加载到 JVM 中的。 3. 如何利用反射创建一个对象？ 过程如下。 1234567891011121314151617181920212223242526272829303132333435363738import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Test &#123; public static void main(String[] args) &#123; try &#123; //1. 得到Stu类的运行时Class描述符 //简单理解为你现在有了这个类，可以调用相应的方法进行实例化了 Class&lt;?&gt; stu = Class.forName(&quot;Stu&quot;); //2.从getDeclaredConstructor()的字面意思就能理解，得到所有声明的构造器 //这里得到的是所有声明的构造器，getConstructor()则只能得到被public修饰的构造器 Constructor&lt;?&gt; declaredConstructor = stu.getDeclaredConstructor(new Class[]&#123;String.class, int.class&#125;); //3. 使用newInstance()方法创建对象并传入参数 //简单的理解为Stu o = new Stu(&quot;zhangsan&quot;, 01) Stu o = (Stu) declaredConstructor.newInstance(new Object[]&#123;&quot;zhangsan&quot;, 01&#125;); //4.调用Stu这个类里面的方法 // getDeclaredMethod()方法能调用到所有声明的方法 Method method = stu.getDeclaredMethod(&quot;toString&quot;, new Class[]&#123;&#125;); //5. 简单的理解为o.toStirng() String invoke = (String)method.invoke(o, new Object[]&#123;&#125;); System.out.println(invoke); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"JAVA","slug":"校招笔记/JAVA","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://hwh.zone/tags/JAVA/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"}]},{"title":"校招笔记（一）_Java_Java入门","slug":"校招笔记（一）_Java_Java入门","date":"2021-11-26T11:53:12.060Z","updated":"2021-11-26T16:31:11.793Z","comments":true,"path":"2021/11/26/校招笔记（一）_Java_Java入门/","link":"","permalink":"https://hwh.zone/2021/11/26/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89_Java_Java%E5%85%A5%E9%97%A8/","excerpt":"","text":"备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 🚩 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 1.1 JAVA入门 1.1.1 JAVA基本 1.介绍一下JVM&amp;JRE&amp;JDK？ JAVA语言有什么特点？ JVM&amp;JRE&amp;JDK JVM: 即java虚拟机，针对不同操作系统，JVM把Java代码翻译成对应操作系统可以识别的内容，实现跨平台 ； JRE : JVM + 核心类库 = JRE ， 即Java运行时环境。只有JVM不能运行，它还需要核心类库，才能保证Java运行 ； JDK: JRE + java开发工具（编译器等) = JDK ，Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具。 Java语言特点 简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 可靠性； 安全性； 支持多线程（ C++ 语⾔没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语⾔却提供了多线程支持）； 2.什么是Java虚拟机？为什么Java被称为平台无关的编程语言？ java虚拟机，是执行字节码文件（.class）的虚拟机进程； 在 Java 中，JVM 可以理解的代码就叫做 字节码 （即扩展名为 .class 的⽂件），它不面向任 何特定的处理器，只面向虚拟机。 java源程序（.java）被编译器编译成字节码文件（.class）。然后字节码文件，将由java虚拟机，解释成机器码（不同平台的机器码不同）。 3. 请你谈谈Java中是如何支持正则表达式操作的？（补充实例） Java中的String类提供了支持正则表达式操作的方法，包括： matches()、replaceAll()、replaceFirst()、split() 此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，如： 123456789101112import java.util.regex.Matcher;import java.util.regex.Pattern;class RegExpTest &#123; public static void main(String[] args) &#123; String str = &quot;成都市(成华区)(武侯区)(高新区)&quot;; Pattern p = Pattern.compile(&quot;.*?(?=\\\\()&quot;); Matcher m = p.matcher(str); if(m.find()) &#123; System.out.println(m.group()); &#125; &#125;&#125; 实例示范（PCG问过） 参考：https://www.runoob.com/regexp/regexp-syntax.html 特殊字符 普通字符 实例示范 匹配邮箱 匹配电话号码 1234//匹配电话号码String phone = &quot;18637866964&quot;;String reg = &quot;^1[3,5,7,8,9]\\\\d&#123;9&#125;$&quot;;System.out.println(phone.matches(reg)); 匹配第一个出现的数字 下面好像是不对的。 123String phone = &quot;avss1sdp22&quot;;String reg = &quot;\\d?&quot;;System.out.println(phone.matches(reg)); 4.（补充例子）请你简单描述一下正则表达式及其用途。 在编写处理字符串的程序时，经常会有查找 符合某些复杂规则的字符串 的需要。 计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具； 绝大多数语言都提供了对正则表达式的支持。 5.&amp;和&amp;&amp;区分？ 共同点：都要求运算符左右两端的布尔值 都是true 整个表达式的值才是true 区别：&amp;&amp;之称为短路运算，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。 好处： e.g. ：右边判别式有如果有空指针NullPointerException异常判断风险，可以避免。 6.值传递和引用传递区分？ 值传递是该变量的一个副本， 改变副本不影响原变量； 引用传递是对象地址的副本，引用对象进行操作会同时改变原对象。 7.十进制与二进制？ 请你讲讲一个十进制的数在内存中是怎么存的？ 补码形式。 为什么会出现4.0-3.6=0.40000001这种现象？ 2进制的小数无法精确的表达10进制小数，计算机在 计算10进制小数的过程中要先转换为2进制进行计算 ，这个过程中出现了误差。 8.（重要）equals与==的区别 很清晰严谨的一篇文章：https://www.cnblogs.com/skywang12345/p/3324958.html == 基本类型：比较的是值是否相同； 引用类型：比较的是引用（对象地址）是否相同； equals 要看类是否覆盖equals()方法，将它分为两种情况： 若某个类没有覆盖equals()方法，当它的通过equals()比较两个对象时，实际上是比较两个对象（地址）是不是同一个对象。这时，等价于通过“==”去比较这两个对象； 我们可以覆盖类的equals()方法，来让equals()通过其它方式比较两个对象的内容（而不是地址）是否相等。 String 中的 equals 方法是被重写过的： 因为 object 的 equals 方法是⽐教的对象的内存地址 而 String 的 equals 方法（1）先比较对象地址是否相等 ，相同则ture，否则（2）再比较值是否相等 7.请解释hashCode()和equals()方法有什么联系？ 面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode方法？” 建议看文中例子理解：https://www.cnblogs.com/skywang12345/p/3324958.html hashCode()介绍 hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该 对象在哈希表中的索引位置。 我们仅在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。 其它情况下hashCode() 则根本没有任何作用，所以，不用理会hashCode()。 在这种情况下对象相等，hashcode值也会不相等。 为什么要有hashcode() hashCode() 的作用就是获取哈希码，也称为散列码；它实际上是返回⼀个 int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。 hashCode()在散列表中才有用，在其它情况下没用。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。 先判断hashcode，而不是直接遍历O(n)复杂度用equals()判断，减少判断时间。 如果hashcode一样，会调用equals()去比较。 HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加⼊操作成功。如果不同的话，就会重新散列到其他位置。 7.1 为什么重写了equals()一定要重写hashcode()方法？ 参考：为什么重写了equals()，还要重写hashCode()？ 在Hashmap / Hashset中，通过计算hash = hash(key.hashcode) 然后进行取余操作，快速定位到数组中。 因为map中是不允许重复key的，所以对内部get()/add()方法：对于散列到数组同一位置的对象来说，如果hash相等 &amp;&amp; equals()判断相等 ，是要进行覆盖的。 12//调用 equals 方法判断key是否相等，若相等，该key对应的键值对已经存在，用新的value取代旧的value if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; 如果我们只重写了equals方法：用来判断两个对象是否相等。但是依旧可能出现：两个相同对象equals相等，但hashcode不等，被散列到不同桶上，map中依旧出现了重复键值对！ 所以，需要重写hashcode方法，保证相同对象一定是散列到同一个位置（具有同样的hash值）。 7.2 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么？ 不一定正确，如果在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。 其它情况下可能会出现题目描述的情况。 8. 自动拆箱和装箱？ 8.1 介绍一下int&amp;Integer？ Java为了编程的方便还是引入了基本数据类型，但是 为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class） int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换： 1234567891011// e.g. public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; // false 两个引用没有引用同一对象 System.out.println(a == b); // true a自动拆箱成int类型再和c比较 System.out.println(a == c); &#125; Java 为每个原始类型提供了包装类型： （8种基本类型）原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 8.2 拆箱、装箱存在的意义？ 为什么要有装箱、拆箱，它们的作用是什么？ java 是 面对对象编程，而基本数据类型不是对象，所有才有封装类 引用基本数据类型进行操作。比如，下面打印出int型数据： 12int i = 1； System.out.println(i); // 自动装箱 其实，查看源码，实际经过以下几个过程： 将 i 自动装箱成封装类 Integer 然后调用 Integer中 toString() 方法，打印出字符串输出到控制台。 自动装箱和拆箱？ 自动装箱：就是自动将基本数据类型转换为包装器类型 自动拆箱：就是自动将包装器类型转换为基本数据类型 8.3 char和byte的区别 ， 能否强制转换？ 区别： Char是无符号型的，可以表示一个整数，不能表示负数，大小范围 是0—65535；而byte是有符号型的，可以表示-128—127 的数 char可以表中英文字符，byte不可以 强制转换： 可以，但是会出现精度丢失。 9. String &amp; StringBuffer&amp; StringBuilder 区别？为什么String不可变? 请解释String &amp; StringBuffer区别？ 共同点：它们可以储存和操作字符串，即包含多个字符的字符数据； 可否修改：String类提供了数值不可改变的字符，StringBuffer可以修改字符串，需要 字符数据要改变 时用。 典型地，你可以使用StringBuffers来动态构造字符数据。 请解释 StringBuilder&amp; StringBuffer 区别？ 共同点：AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共⽗类。都可以修改字符串，操作字符串方法丰富。 12345678910111213abstract class AbstractStringBuilder implements Appendable, CharSequence&#123; /** * The value is used for character storage. */ char[] value; /** * The count is the number of characters used. */ int count; AbstractStringBuilder(int capacity) &#123; value = new char[capacity]; &#125; 线程安全：单线程且操作大量字符串用StringBuilder,速度快，但线程不安全，可修改；在多线程且操作大量字符串用StringBuffer，线程安全，可修改。 StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 为什么String 不可变？ String 类中使用 final 关键字修饰字符数组来保存字符串， 所以 String 对象是不可变的。 1private final char value[] 10.说说深拷贝和浅拷贝？ 浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址； 因此，可能会出现出现浅拷贝时释放同一个内存的错误。 深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存。 11. 【新增】介绍一下JDK1.8的新特性？ JDK1.8新增了非常多的特性，如： Lambda表达式：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。 方法引用：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法：默认方法就是一个在接口里面有了一个实现的方法。 新工具：新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。 Stream API：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。 Date Time API：加强对日期与时间的处理。 Optional类：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。 Nashorn，JavaScript引擎：JDK1.8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。 12. 【新增】java一个程序能不能有多个main方法？一个类里呢？ 一个程序里，多个class都有main方法 可以，默认第一个为入口，其余为普通函数。 12345678class Class1 &#123; public static void main(String[] args) &#123; &#125;&#125;public class Class2 &#123; public static void main(String[] args) &#123; &#125;&#125; 一个类有多个main方法 可以，其余就相当是重载。但是具有以下sigature（签名）的主要方法将被视为app入口点： 1public static void main(String[] args) 1.1.2 关键字 1.请你讲讲Java里面的final关键字是怎么用的？ 修饰类：表示不能被继承，final类 成员变量 可以设为final；但final类所有方法 ，都被隐式指定为final方法； 修饰方法：防任何继承类修改它的含义 ； 在早期的Java实现版本中，会将final方法转为内嵌调用，效率会更高； 修饰变量、引用：基本类型的话一旦初始化不能修改；引用类型，不能指定其他对象 。 2. 【重点】请你谈谈关于Synchronized和lock ？ Synchronized：是一个关键字，修饰类、方法 或 代码块 ，保证在同一时刻最多只有一个线程执行该段代码； 作用范围： 修饰一个类/静态方法，作用的对象是这个类的所有对象。 修饰一个方法/代码块，作用的对象是调用这个方法/代码块的对象。 Lock：是一个接口，Lock能完成synchronized所实现的所有功能。 Lock接口是不能直接实例化的，需要靠它的实现类ReentrantLock来进行实例化。 区别： 锁释放：synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；Lock不会主动适应 unLock() 释放，必须手动在finally释放。； 线程等待： Lock可以让等待锁的线程可以响应中断，线程可以中断去干别的事务；而synchronized却不行，使用synchronized时，等待的线程会一直等待下去； 成功获取锁： 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 3. instanceof关键字的作用？ instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例。 123int i = 0;System.out.println(i instanceof Integer);//编译不通过 i必须是引用类型，不能是基本类型System.out.println(i instanceof Object);//编译不通过 12Integer integer = new Integer(1);System.out.println(integer instanceof Integer);//true 4. final有哪些用法? 被final修饰的类不可以被继承 ； 被final修饰的方法不可以被重写，而且JVM会尝试将其内联，以提高运行效率； 被final修饰的变量不可以被改变； 被final修饰的引用，那么表示引用不可变，引用指向的内容可变； 被final修饰的常量，在编译阶段会存入常量池中。 5. static都有哪些用法 ? 修饰静态变量和静态方法 ：都属于类的静态资源，类实例所共享 ； 修饰静态块：用于初始化操作。 12345public calss PreCache&#123; static&#123; //执行相关操作 &#125;&#125; 修饰静态包：在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用方法名。 12345678910import static java.lang.Math.*; public class Test &#123; public static void main(String[] args) &#123; //System.out.println(Math.sin(20));传统做法 System.out.println(sin(20)); &#125;&#125; 6. 谈一谈transient关键字？ 参考 : Java中的关键字 transient Java中序列化操作 Java中对象的序列化指的是将对象转换成以【字节序列】的形式来表示，这些字节序列包含了对象的数据和信息。 当然，序列化后的最终目的是为了反序列化，恢复成原先的Java对象，要不然序列化后干嘛呢，所以序列化后的字节序列都是可以恢复成Java对象的，这个过程就是反序列化。 一个序列化后的对象可以被写到数据库或文件中，也可用于网络传输，一般当我们使用缓存cache（内存空间不够有可能会本地存储到硬盘）或远程调用rpc（网络传输）的时候，经常需要让我们的实体类实现Serializable接口，目的就是为了让其可序列化。 关于transient关键字 Java中transient关键字的作用，向虚拟机表明: transient变量不是对象的持久状态的一部分。 简单地说，就是让某些被修饰的成员属性变量不被序列化，例如： 类中的字段值可以根据其它字段推导出来，如一个长方形类有三个属性：长度、宽度、面积（示例而已，一般不会这样设计），那么在序列化的时候，面积这个属性就没必要被序列化了； 其它，看具体业务需求吧，哪些字段不想被序列化； 7.1 HashMap中源码modCount为什么用tranisent修饰？ modCount主要用于判断HashMap是否被修改（像put、remove操作的时候，modCount都会自增）。 对于这种变量，一开始可以为任何值，0当然也是可以（new出来、反序列化出来、或者克隆clone出来的时候都是为0的），没必要持久化其值。 1.1.3 Java异常 1. Java常见异常和分类？ 常见分为两类，Error和Exception ： Error ：指程序无法恢复的异常情况，对于其所有类型，都不要求程序处理。 常见错误：Stackoverflow，outOfMemory Exception： 程序有可能恢复的错误，又分为IOException &amp; RuntimeException ，常见错误： IOException：FileNotFoundExcepetion RuntimeException : 空指针，参数不合法，类未找到等 2. OOM产生原因和分析？ OOM，全称“Out Of Memory”，翻译成中文就是“内存用完了”，来源于java.lang.OutOfMemoryError 。 java.lang.OutOfMemoryError: Java heap space （堆溢出） 产生原因 内存泄漏； 堆分配太小； 解决办法 内存泄漏要手动去释放内存，比如数据库连接池，单例模式 通过虚拟机参数-Xms,-Xmx等修改，对内存大小 java.lang.OutOfMemoryError: PermGen space （永久代（方法区）溢出） 产生原因 即方法区溢出了： 一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区 ； 过多的常量尤其是字符串也会导致方法区溢出。 解决办法 永久代的内存分配增大 ：-XX:PermSize和-XX:MaxPermSize java.lang.StackOverflowError ------&gt; 不会抛OOM error，但也是比较常见的Java内存溢出。 线程栈相关的内存异常有两个： StackOverflowError(方法调用层次太深，内存不够新建栈帧) OutOfMemoryError（线程太多，内存不够新建线程） java.lang.OutOfMemoryError: Metaspace Java中普通I/O采用输入/输出流方式实现，输入流InputStream（ 终端—&gt;直接内存-&gt;JVM），输出流（JVM-&gt;直接内存-&gt;终端），这一过程中有kenel与JVM之间的拷贝（很多次）。 为了使用直接内存，Java是有一块区域叫DirectBuffer，不是JavaHeap而是cHeap的一部分。 但由于直接内存没有被java虚机完全托管，若使用不当，也容易触发溢出，导致宕机。 3. try catch finally，try里有return，finally还执行么？ 执行，并且finally的执行早于try里面的return ： 不管有木有出现异常，finally块中代码都会执行； 当try和catch中有return时，finally仍然会执行； finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的。 4.说说你是怎么处理异常的？ try-catch-finally try 块负责监控可能出现异常的代码 catch 块负责捕获可能出现的异常，并进行处理 finally 块负责清理各种资源，不管是否出现异常都会执行 其中 try 块是必须的，catch 和 finally 至少存在一个标准异常处理流程 5. web网页卡怎么排查？cpu100%怎么排查？OOM怎么排查？ web网页卡顿 用户端：硬件配置低、资源不足；CPU 或者内存资源不足, 比如用户是否使用了 Chrome 这种 “吃内存大户” 的浏览器并且打开了很多网页? 网络分析：DNS 解析慢；未设置 CDN，如果没有设置 CDN, 在跨线路访问(比如用户是铁通, 但是服务器部署在联通, 这种情况就是跨线路), 地理位置相差很远 等情况 ；用户端的带宽不足或所处环境网络不佳； 服务端：服务端响应慢，性能比较差 。 cpu100% 参考：https://www.cnblogs.com/dennyzhangdd/p/11585971.html 执行top命令：查看所有进程占系统CPU的排序； 极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。 执行top -Hp 进程号命令：查看java进程下的所有线程占CPU的情况； 执行printf &quot;%x\\n 10命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，咱们需要把线程号转成16进制。 执行jstack 进程号 | grep 线程ID” 查找某进程下–&gt;线程ID(jstack堆栈信息中的nid)=0xa的线程状态。 代码中有大量消耗CPU的操作，导致CPU过高，系统运行缓慢： jstack，可直接定位到代码行。例如某些复杂算法，甚至算法BUG，无限循环递归等等。 如果有死锁，会直接提示关键字：deadlock。步骤4，会打印出业务死锁的位置。 执行jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一致统计）”，查看某进程GC持续变化情况，如果发现返回中FGC很大且一直增大–&gt;确认Full GC! 也可以使用“jmap -heap 进程ID”查看一下进程的堆内从是不是要溢出了，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。 jstat命令监控GC情况，可以看到Full GC次数非常多，并且次数在不断增加。 执行jmap -dump:format=b,file=filename 进程ID，导出某进程下内存heap输出到文件中。 OOM 参考：https://www.cnblogs.com/valjeanshaw/p/13130102.html 先通过内存映像工具对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。 1jmap -dump:format=b,file=$java_pid.hprof #java_pid为java进程ID 然后看具体是报什么错：很明显下面是堆溢出。 123456789java.lang.OutOfMemoryError: Java heap spaceDumping heap to oom.out ...Heap dump file created [3196858 bytes in 0.016 secs]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3332) at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124) at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:700) at java.lang.StringBuilder.append(StringBuilder.java:214) at jvm.OomDemo.main(OomDemo.java:13)","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"JAVA","slug":"校招笔记/JAVA","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://hwh.zone/tags/JAVA/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"}]},{"title":"校招笔记（零）_写在前面","slug":"校招笔记（零）_写在前面","date":"2021-11-26T10:26:04.423Z","updated":"2021-11-26T16:23:23.024Z","comments":true,"path":"2021/11/26/校招笔记（零）_写在前面/","link":"","permalink":"https://hwh.zone/2021/11/26/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E9%9B%B6%EF%BC%89_%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/","excerpt":"","text":"转眼就到了属于我的毕业季，还记得初来学校的期待和兴奋，却从“小师弟”眨眼变成了“老油条”。实习和秋招也算正式告一段落，对于我这种懒蛋，有幸拿到了腾讯、美团、Shoope SG等 后端开发岗 offer。找工作算是今年我经历的最重要事情之一，同时也想给师弟师妹提供一点帮助，便整理了这份 （互联网）校招笔记。 直入主题，互联网校招主要形式和考察内容如下： 考察形式 线上考察，视频面试（大部分公司）或电话面试（阿里等部分公司喜欢这种方式）。 考察内容 算法能力 俗称”刷题“，一般面试都是常见题，理论上刷完Leetcode-Top100，能做到烂熟于心（指现场秒背题或模板），大厂面试一般没有多大问题。 当然针对心仪公司，可以在面试前更加针对性地练习该公司的常出题，这一点上codeTop是一个不错的网站。 计算机基础 俗称“八股”，考察范围包含：计算机网络、Linux、数据库、操作系统、常见中间件&amp;框架、智力题等。可以看得到考察范围非常广，但是考察的题目非常固定。所以只要背熟常见题目问答便能不错地应对面试，这也是该部分内容被称为”八股文“的原因。 项目 &amp; 实习 项目顾名思义，就是实际做的开发项目（如果是算法岗则对应论文）。根据面试经验，一个好的开源项目是非常加分的。 实习通常是指大厂实习，在竞争这么激烈的情况下，如果没有实习，秋招想进入互联网大厂将会变得很困难。 根据以上内容，这份校招笔记争取尽量全面覆盖，整个目录安排如下： 备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 项目&amp;实习 主要是怎么准备项目，后续更新 算法还是后端 准备的时间节点 实习和秋招 一些有用的app &amp; 网站 制作简历 写在最后","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://hwh.zone/tags/JAVA/"},{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"目录","slug":"目录","permalink":"https://hwh.zone/tags/%E7%9B%AE%E5%BD%95/"}]},{"title":"前端基础（一）JavaScript基础笔记(上)","slug":"前端基础（一）JavaScript笔记（上）","date":"2021-11-25T12:37:58.119Z","updated":"2021-11-25T12:40:09.098Z","comments":true,"path":"2021/11/25/前端基础（一）JavaScript笔记（上）/","link":"","permalink":"https://hwh.zone/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"第一章：快速入门 1.1 hello javaScript! 我们编写一个简单 test.js 文件，里面有一行代码输出 “hello javaScript!” ： 1alert(&quot;hello javaScript!&quot;); 然后在准备好的 .html 文件head 标签内引入test.js 文件： 123456789&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;!--这里默认当前路径是index.html所在目录--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;test.js&quot;&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 注意区分引入 .js文件 和 css文件区别： .js文件 用一对 &lt;script&gt;&lt;/script&gt; 标签包围引用 ；.css 文件用 标签指向： 1&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;main.css&quot; &gt; .js文件 用 src 属性指向 ；.css 文件用 href 属性指向。 引入 js / css文件不成功？ 没有保存文件 默认 VSCode 不会自动保存文件，如果不自己 ctrl+s ，打开浏览器 F12 --&gt; Source 发现 mian.css文件为空。 可以设置自动保存文件，或者自己手动保存解决。 错用 href 属性 引用 js文件 见前。 1.2 安装 codeRunner 插件 我们肯定不希望，每次输出一些信息，都要打开浏览器去查看： 1alert(&quot;我想输出一些信息&quot;); 如果可以直接在 VSCoder 中就打印出信息多好啊！但是直接写在js 文件中，只能在浏览器控制台查看。 1console.log(&quot;我想输出一些信息&quot;); 如何直接打印信息？ JavaScript 可以直接打印：数组、对象、字符串、数值类型等 第一种方式只能在浏览器中查看，后来两种可以直接在VS中查看。 在浏览器控制台中 使用VS自带终端 我们可以用vs自带终端，如果已经安装好 node.js 便可以直接在VS中输出： 其实，这就实现相当于在 cmd 中执行这段代码。 利用 CodeRunner 插件 下载好 CodeRunner 插件，也可以直接运行 js 文件： CodeRunner 运行乱码/报错 Node.js 是否安装 CodeRunner 还是通过 Node.js 来运行 js 文件，如果没有安装自然出错。 特别的，安装 Node.js 会自动配置好环境变量，所以基本可以排除环境变量配置错误导致该问题。 终端是否能输出 首先在 cmd 尝试运行 js文件 ，如果能正确输出 ；但是在 VS终端中还是运行报错/乱码。可以排除是Node.js 相关配置问题。 如果cmd 中也无法运行，尝试重新配置 node.js 环境变量或者直接卸载重新安装。 尝试以管理员身份运行VSCoder 我出现的乱码/无法执行问题以管理员身份运行成功解决。 1、2 均无问题， 可以尝试以管理员身份运行 VSCoder 。也可以设置每次打开都是以管理员身份： 右键 VSCoder 图标 —&gt; 属性 --&gt; 兼容性 —&gt; 以管理员身份运行此程序 --&gt; 应用。 1.3 基本语法 1. 变量和注释 javsScript 注释有单行注释 &amp; 多行注释两种方式： 12// alert(&quot;我不想被执行&quot;); /* alert(&quot;我不想被执行&quot;); */ javsScript 是弱类型语言，所有变量都可用 var &lt;变量名&gt; 形式定义。 123456789101112131415// 1.javsScript不区分整数和浮点型，统称Numbervar num = 3.5; var num1 = 3; var num2 = 1.234*e3;// 2.字符串var str = &#x27;我是单引号包围字符串&#x27;; var str1 = &#x27;&#x27;我是双引号包围字符串&#x27;&#x27;;// 3.布尔类型var b = false;// 4.比较运算符var b1 = false == 0; var b2 = false === 0;var b3 = 2 &gt; 4? ; // ...// 5.常量const PI = 3.14; // const&amp;let修饰都是块级作用域（见后） 小心！== 、NaN、浮点数 不推荐==比较运算符 不推荐使用 == 运算符，这是 JavaScript 语言设计缺陷，会出现难以意料的错误，推荐使用 ===来替换。 判断浮点数相等 由于计算机不能精确表示浮点数，所以判断两个浮点数是否相等，比较它们差值是否小于某个足够小值： 1Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true 判断是否NaN 12var num = NaN;alert(num === NaN); // 输出false 为什么输出 false ？这是因为 NaN和所有其它值都判断不相等，包括它自己，唯一判断方法是： 1isNaN(NaN); // true 判断 null ： 变量 === null； 判断 Array：Array.isArray(arr); typeof 可以判断出 Number、Boolean、String、function &amp; undefined 类型，例如： 判断全局变量是否存在：typeof window.myVar === 'undefined' 判断局部变量是否存在：typeof myVar === 'undefined' 。 全局变量 我们知道，常规定义全局变量，把变量不定义在任何嵌套{}中即可。 事实上，变量定义可不用 var 关键字，此时定义的也是全局变量： 12345num = 3.5; str = &#x27;我是字符串&#x27;; b = false;console.log(&#x27;num = &#x27;+num + &#x27; , str = &#x27;+ str + &#x27;, b = &#x27;+b); 如何理解此时定义的是全局变量？请看下例： 123456789function f()&#123; // 不用var关键字声明函数内部变量 a = 1 ; for(i = 1 ; i &lt; 3 ; i++);&#125;f();console.log(a); // 可访问，输出：1console.log(i); // 可访问，输出：3 a、i 看似是函数内部局部变量，实际已是全局变量，可以访问。 类型转换 由于 JavaScript 没有那么复杂类型，比如数值类型之间转换（int --&gt; double …）。 常用的有如 Number 、 String 、Boolean、object类型之间转换 ： 123456789101112131415161718192021222324252627282930313233343536// 类型转换// 1.任何类型转换为String类型： String()转换 OR .toStringvar num = 123.45 , b = true ;// toString()console.log(num.toString()); // 输出：123.45console.log(b.toString()); // 输出：true// String()console.log(String(num)); // 输出：123.45console.log(String(b)); // 输出：true// 2.任意类型转换成Number类型：用Number() OR parseInt()、parseFloat()var str = &#x27;123.45&#x27; , b = true ;// Number()console.log(Number(str)); // 输出：123.45console.log(Number(b)); // 输出：1// parseInt()、parseFloat()// 转换不了boolean类型！console.log(parseFloat(str)); // 输出：123.45console.log(parseFloat(b)); // 输出：NaN// 3.任意类型转换为Boolean类型：用Boolean()// 注意：只有 0、&#x27;&#x27;转换为：false ；其余全部转换为ture// 以下都转换为tureconsole.log(Boolean(&#x27;false&#x27;)); // 也是ture！只有数字0、&#x27;&#x27;会转换为false！！console.log(Boolean(&#x27;123.45&#x27;)); console.log(Boolean(123.45)); // 以下都转换为falseconsole.log(Boolean(&#x27;&#x27;)); console.log(Boolean(0)); 特别的，具体的值也可以调用 .toString() 方法，转换为 Sting 类型。 123 // 注意1.toString()出错，两个.. OR (1).toString()1..toString(); // 1false.toString(); // false 2. 字符串 如何优雅表示字符串 除了前面介绍用 ’ ‘ 或者 “ ” 包围，还可以用最新ES6标准，反引号 `` 包围多行字符串。 ⚠️ 反引号是左上角 ESC 正下方对应键 ~ ，切换到英文状态下可以打出**`** 1234alert(`我是多行字符串酷不酷`) 1alert(`我是\\n多行字符串\\n酷不酷`) // 和上面写法等价 字符串拼接 除了常见用 + 号进行拼接，还可以用ES6新增的模板字符串进行拼接。 ⚠️ 模板字符一定要使用反引号 ` ，否则${…}当字符串输出了。 12345var name = &#x27;hwh&#x27;;var age = 20;// var message = &#x27;我是&#x27;+ name + &#x27;,今年&#x27;+ age+&#x27;岁啦！&#x27;;var message = `我是$&#123;name&#125;,今年$&#123;age&#125;岁啦！`; // 一定要使用反引号 `,否则$&#123;..&#125;当字符串输出alert(message); 常用字符串操作 获取字符串指定位置字符 直接把字符串当做数组进行索引即可： 12var s = &#x27;hello world&#x27;;alert(s[0]); // 输出：h 但是字符串是不可变的，不能对其某个字符索引赋值，不会有任何效果（但不报错）： 12s[0] = &#x27;l&#x27;;alert(s); // 还是输出：hello world 常用字符串方法 12345678910111213// 1.转换字符串大小写var s = &#x27;Hello&#x27;;var upper = s.toUpperCase(); // 返回&#x27;HELLO&#x27;var lower = s.toLowerCase(); // 返回&#x27;hello&#x27;并赋值给变量lower// 2.返回字符在字符串中位置var str = &quot;hello javaScript!&quot;;alert(str.indexOf(&#x27;java&#x27;)); // 输出6：j是第6个字符，从0计数。前面有6字符： hello + 空格 // 3.字符串截取var s = &#x27;hello, world&#x27;s.substring(0, 5); // 从索引0开始到5（不包括5），返回&#x27;hello&#x27;s.substring(7); // 从索引7开始到结束，返回&#x27;world&#x27; 3. 数组 定义一个简单数组，通常有 直接定义 &amp; new 两种方式： 12345var s = []; // var s = new Array();var s1 = [1,2];// var s1 = new Array(1,2); 奇妙数组 JavaScript 和其它语言数组有很多不同，这里一一说道。 数组不限制类型 下面是一个长度 = 6，包含多种类型的数组。 1var arr = [1, 2, 3.14, &#x27;Hello&#x27;, null, true]; 改变数组大小很简单 以往语言要扩展数组总是一件复杂的事，比如 java 用集合 ArrayList 来实现。 JavaScript 直接改变数组 length 属性即可： 12345var arr = [1, 2, 3];// 扩大数组arr.length = 6; // arr数组变为：[1, 2, 3, undefined, undefined, undefined]// 缩小数组arr.length = 1; // arr数组变为：[1] 可以越界赋值 很多编程语言是不允许越界赋值数组，但JavaScript 允许，它会自动扩大数组。 12var arr = [1, 2, 3];arr[6] = 6; // arr数组变为：[1, 2, 3, undefined, undefined, 6] 但是，这种做法不被推荐，尽量保证索引不会越界！ 常用数组操作 以下是常用数组操作的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var arr = [1,2,3,4,5,6];// 1.数组转为字符串var str = String(arr);console.log(str); // 输出：1,2,3,4,5,6// 2.indexOf：返回指定元素位置var i = arr.indexOf(1);console.log(i); // 输出：0// 3.slice：左开右闭截取元素, 对应String的substring()方法// 不指定第二个参数，会截取第一个参数位置以后所有元素var sub03 = arr.slice(0,3) var sub3 = arr.slice(0) console.log(sub03); // 输出：[ 1, 2, 3 ]console.log(sub3); // 输出：[ 1, 2, 3, 4, 5, 6 ]// 4.push 和 pop 尾部增减元素arr.push(&quot;hello&quot;,&quot;js&quot;);console.log(arr); // 输出：[ 1, 2, 3, 4, 5, 6, &#x27;hello&#x27;, &#x27;js&#x27; ]arr.pop() ; arr.pop();console.log(arr); // 输出：[ 1, 2, 3, 4, 5, 6 ]// 5.unshift 和 shift 头部增减元素arr.unshift(&quot;A&quot;,&quot;B&quot;);console.log(arr); // 输出：[ &#x27;A&#x27;, &#x27;B&#x27;, 1, 2, 3, 4, 5, 6 ]arr.shift(); arr.shift();console.log(arr); // 输出：[ 1, 2, 3, 4, 5, 6 ]// 6.反转和排序arr.reverse(); console.log(arr); // 输出：[ 6, 5, 4, 3, 2, 1 ]arr.sort(); console.log(arr); // 输出：[ 1, 2, 3, 4, 5, 6 ]// 7.splice：从指定位置删除若干元素，再从该位置添加若干元素var arr = [&quot;c#&quot;,&quot;c&quot;,&quot;c++&quot;,&quot;python&quot;,&quot;java&quot;,&quot;javascript&quot;];// 删除&amp;添加：从索引1开始删除2个元素，然后再从原索引位置添加两个元素var delElem = arr.splice(1,2,&quot;1&quot;,&quot;2&quot;); // 返回被删除的元素:[&quot;c&quot;,&quot;c++&quot;]console.log(arr); // 输出：[ &#x27;c#&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;python&#x27;, &#x27;java&#x27;, &#x27;javascript&#x27; ]// 只删除：不设定2个参数以上就行var delElem1 = arr.splice(1,2);console.log(arr); // 输出：[ &#x27;c#&#x27;, &#x27;python&#x27;, &#x27;java&#x27;, &#x27;javascript&#x27; ]// 只添加：设置第二个参数为0，即删除0个元素var delElem2 = arr.splice(1,0,&quot;c&quot;,&quot;c++&quot;);console.log(arr); // 输出：[ &#x27;c#&#x27;, &#x27;c&#x27;, &#x27;c++&#x27;, &#x27;python&#x27;, &#x27;java&#x27;, &#x27;javascript&#x27; ]// 8.concat：连接两个数组,但不改变原数组，只是返回一个新数组var arr1 = [1,2,3,4,5];var arr2 = arr1.concat(&quot;hwh&quot;,[&quot;上&quot;,&quot;山&quot;,&quot;打&quot;,&quot;老&quot;,&quot;虎&quot;]);console.log(arr2); // 输出：[ 1, 2, 3, 4, 5, &#x27;hwh&#x27;, &#x27;上&#x27;, &#x27;山&#x27;, &#x27;打&#x27;, &#x27;老&#x27;, &#x27;虎&#x27; ]// 9.join：将数组转为字符串，可指定连接字符var arr3 = arr1.join(&#x27;~&#x27;);console.log(arr3); // 输出：1~2~3~4~5 多维数组 多维数组：如果某个元素是多维数组，那么就可以形成多维数组。 123// 多维数组var darr = [[1, 2, 3], [400, 500, 600], &#x27;-&#x27;];console.log(darr[1][1]); // 输出：500 4. 对象 注意：在 JavaScript 中没有类这个概率，通过原型链来实现类作为模板概念，在后详述。下面都是具体对象！ 例如下面创建一个hwh对象，类似于 python 使用键值对定义 map 。 当然，还可以给对象增添方法（注意，此时不叫函数！），详见 第二章：函数 2.3节 123456var hwh = &#123; name:&quot;huangwanghui&quot;, school:&quot;chongqingU&quot;, &#x27;stu-num&#x27;: 123456 // 注意：最后一行代码不要加逗号，否则在低版本IE可能会报错&#125; 访问对象属性 访问对象属性有两种办法： 通过&lt;对象名.属性名&gt; 形式 12console.log(hwh.name); // 输出：huangwanghuiconsole.log(hwh.school); // 输出：chongqingU 特别的，访问不存在属性不会报错，但是会返回 undefined ： 1console.log(hwh.school); // 输出：undefined 通过&lt;对象名['属性名']&gt; 形式 理论上，所有访问对象属性都可通过该方式，特别以下两种情况只能使用&lt;对象名['属性名']&gt;这种方式。 属性名不是标准变量名 如 ‘stu-num’ 含变量定义非法字符 - ，所以要用 ’‘ 包围，只能通过 &lt;对象名['属性名']&gt; 访问该属性。 12console.log(hwh.stu-num); // 输出：NaNconsole.log(hwh[&#x27;stu-num&#x27;]); // 输出：123456 循环遍历属性时 在下面遍历对象属性，为什么都是输出 undefined？ 123456// 遍历属性for(var a in hwh)&#123; console.log(a); // 输出：name shcool &#x27;stu-num&#x27; console.log(hwh.a); // 输出：undefined undefined undefined&#125; 因为，此时 hwh.a 相当于访问的是hwh对象一个属性名为a的属性，这自然是不存在的。 正确做法使用对象名['属性名']便可正常输出： 1234for(var a in hwh)&#123; console.log(hwh[a]); // 输出：huangwanghui chongqingU 123456&#125; 给对象增删属性 给对象增减属性较为简单，增加属性类似于数组增加元素，删除属性要利用 delete 关键字。 123456// 增删属性hwh.age = 23;console.log(hwh.age); // 输出：23delete hwh.age;console.log(hwh.age); // 输出：undefined 判断对象是否拥有某属性 判断对象是否用于某属性也有两种办法。 利用 in 判断一个属性是否存在 12console.log(&#x27;name&#x27; in hwh);console.log(&#x27;age&#x27; in hwh); 但是这种方法有一个问题，in 判断属性不一定属于 hwh，还可能是 hwh 继承得到的。 比如原型链中，hwh 肯定会指向所有属性都指向的 Object， Object 含有一个toString 属性： 1console.log(&#x27;toString&#x27; in hwh); // 输出：true 利用hasOwnProperty()方法 这种方法可以不会判断继承得到的属性属于对象。 1console.log(&#x27;toString&#x27; in hwh); // 输出：false 5. 条件判断 &amp; 循环 条件判断 JavaScript 把null、undefined、0、NaN &amp; 空字符串''视为false，其他值一概视为true，因此下面代码条件判断的结果是true。 12345var s = &#x27;123&#x27;;if (s.length) // 条件计算结果为3&#123; // do something&#125; 循环 在 JavaScript 循环和 java 等高级语言循环没有太大区别。 特别的，在 JavaScript 中数组也被看作是对象，它的索引则被视为一个属性。然而遍历数组时，如果使用 for…in循环时，如给数组增加一个属性，将导致一个难以意料的结果。 这个问题可以用 for…of 循环解决，它还可以专用于遍历集合类型，详见 7. iterable 类型 。 12345678910111213141516171819202122232425262728293031323334var num = [1,2,3,4,5,&quot;上山打老虎&quot;];// 1.普通for循环for(var i = 0 ; i &lt; num.length; i++)&#123; console.log(num[i]); // 输出： 1 2 3 4 5 上山打老虎&#125;// 2.for..in 循环// 除了前面用来遍历对象属性，遍历数组也类似// for..in 循环的到时 String 而不是 Number，for循环呢？// 直接输出i是数组序号：0 1 2 3 4 5 ，可理解为把数组当对象，序号是它“属性名”for(var i in num)&#123; console.log(i); // 输出： 0 1 2 3 4 5 console.log(num[i]);&#125;// 3.while 循环var i = 0;while(i&lt;6)&#123; console.log(num[i]); i++;&#125;// 4.do...while 循环// 注意：do...while 循环至少会执行一次！var j = 0;do&#123; console.log(num[j]); j++;&#125;while(j&lt;6); 6. Map &amp; Set 在前面 JavaScript 中 4.对象 中&#123;&#125; 表达方式可以视作其它语言 Map 或 Dictionary 数据结构键值对表达方式。 BUT，JavaScript 中 对象中键只能是字符串 ，而在本讲 Map &amp; Set 将不局限于这点，还可以是 Number等类型。 MAP MAP 基本创建、增 == 改、删操作，和： 123456789101112131415161718// map// 1.创建：注意是([[..],[..],[..]])形式外侧还有一个[]var m = new Map([[1,&quot;hwh&quot;],[2,&#x27;liuting&#x27;],[3,&#x27;xiaoming&#x27;]]); // 2.增加(修改)键值对m.set(4,&#x27;xiaobai&#x27;); // 不存在该键4，则是创建新键值对m.set(4,&#x27;xiaohei&#x27;); // 存在键值4，那么是修改键4对应键值对// 3.删除键值对m.delete(4);// 4.判断是否存在键值var b = m.has(4);console.log(b); // 由于被删除所以是：false// 5.获取键值对var a = m.get(2);console.log(a); // 输出：liuting 注意，当map 键是String 类型一定要加引号（对象如果变量名符合规范可以不加），而且访问也要加引号： 123var m = new Map([[&#x27;a&#x27;,1],[&quot;b&quot;,2]]); // m.get(a); // 出错m.get(&#x27;a&#x27;); MAP 和对象有什么区别？ MAP 和对象都是利用 键值对 形式构造，但是也有以下区别： 删除、添加元素方式不同 访问形式不同：MAP通过get() 方法，对象通过 对象.属性名 或者 对象[属性名]形式 访问速度不同：MAP 拥有极快的访问速度 支持key类型不同：MAP支持多种类型作为key，对象只支持字符串String 类型 Set Set和Map类似，也是一组key的集合，但不存储value。 由于key不能重复，所以，在Set中，没有重复的key。如，创建时出现重复key，只会保留一个。 1234567891011// Set// 1.创建：出现重复键值被过滤var s = new Set([1,2,2,3]); // 实际集合中数据：&#123;1, 2, 3&#125;// 类似的：map也只会保存最后插入的重复键值var m = new Map([[&#x27;a&#x27;,1],[&#x27;a&#x27;,2],[&quot;b&quot;,2]]); // 实际集合中数据：&#123;[&#x27;a&#x27;,2],[&quot;b&quot;,2]&#125;// 2.增加s.add(4);// 3.删除s.delete(4); Set 和数组 Array 区别？ 删除、添加元素方法不同 Set 可以去重，而且可以 快速查找 ，但无法实现按下标查找等操作 7. 如何优雅遍历集合 for … in 遍历集合 遍历数组 Array 可以用下标循环，如何遍历集合类型如 Map &amp; Set 类型？能用 for … in 循环吗？ 我们尝试用 for…in 循环遍历集合： 12345678var m = new Map([[1,&quot;hwh&quot;],[2,&#x27;liuting&#x27;],[3,&#x27;xiaoming&#x27;]]); var s = new Set([1,2,3]); // for...in 遍历集合for(var i in s)&#123; console.log(i); // 什么都没输出&#125; 很不幸，什么都没输出。 事实上，Array、Map &amp; Set 都属于iterable 类型。对于 iterable 类型可以用 for…of 循环输出： 123456789// for...of 遍历集合for(var i of m)&#123; console.log(i); // 输出：[ 1, &#x27;hwh&#x27; ] [ 2, &#x27;liuting&#x27; ] [ 3, &#x27;xiaoming&#x27; ]&#125;for(var i of s)&#123; console.log(i); // 输出：1 2 3&#125; forEach() 遍历集合 遍历集合更加优雅安全的方式是通过 iterable内置的forEach() 方法，它接受一个函数，每次迭代自动回调该函数。 forEach() 是一个高级方法，接收一个函数，用来遍历数组。详见 2.4 高阶函数 – forEach() 1234567891011121314151617181920212223242526272829303132// forEach() 遍历集合var m = new Map([[1,&quot;hwh&quot;],[2,&#x27;liuting&#x27;],[3,&#x27;xiaoming&#x27;]]); var s = new Set([1,2,3]); var arr = [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;];// 遍历Mapm.forEach( function(value) &#123; console.log(value); // 输出：hwh liuting xiaoming &#125;); // 遍历Sets.forEach( function(element) &#123; console.log(element); // 输出：1 2 3 &#125;);// 遍历Arrayarr.forEach( function(element) &#123; console.log(element); // 输出：A B C &#125;);// 遍历对象：注意不能遍历对象！！ for … in 循环的弊端：数组长度不一致 我们已经知道 ，Array 都属于iterable 类型 ，但我们用 for … in 可以遍历输出Array 。 但是，我们在前也知道，数组也是对象，它的下标就是属性名。如果我们给一个数组增加属性名，然后遍历： 12345678var arr = [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;];// 类似对象一般，给数组增加属性arr.name = &#x27;alpha&#x27;;for(var i in arr)&#123; console.log(i); // 输出属性名：0 1 2 name&#125; 依次输出的是数组的属性名，好吧，这没什么不正常。 但是我们再尝试打印此时的数组大小： 1console.log(arr.length); // 输出：3 噢…不忍直视，数组长度竟然是3，而不是4！ 为什么说for… of 循环可以避免这个问题呢？ 因为for… of 循环只会遍历，集合内的元素，这种不正当通过 数组名.属性 赋值方式不会被输出： 12345for(var i of arr)&#123; console.log(i); // 输出元素而非属性名：A B C &#125;console.log(arr.length); // 输出：3 这样循环遍历数组元素个数 === 数组长度，保证了一致性。 而且，你应该还注意到一个细节，此时输出的是元素，而非是属性名。 第二章 ：函数 2.1 函数基本入门 函数定义 在 JavaScript 中，定义函数有两种方式：一种类似于其它高级语言，但没有返回值类型；一种匿名函数方式。 123456789101112// 函数定义// 1.第一种类似其它高级语言定义函数，但没有返回值类型，js也不需要定义类型function max(a,b)&#123; return a &gt; b ? a : b;&#125;// 2.第二种匿名函数，其实函数也是对象，把函数名max1视作指向该函数的变量var max1 = function(a,b)&#123; return a &gt; b ? a : b;&#125; 在 JavaScript 中，这两种方式是完全等价的，自然调用方式也是一致的： 123// 调用函数console.log(max(1,2)); // 输出：2console.log(max1(1,2)); // 输出：2 ⚠️ 不加()，直接调用函数不会报错，只会输出函数名： 1console.log(max); // [Function: max] 但是可以把函数作为变量传递给另外一个变量： 12var my_max = max;my_max(1,2); // 2 小心你的 return 语句 JavaScript 引擎 会在行末自动添加分号，这可能会导致使用 return 产生意料之外的错误： 1234567function max(a,b)&#123; return a &gt; b ? a : b;&#125;// 调用maxmax(1,2); // 输出：什么都没有输出 你会惊喜的发现，什么都没有输出！这是因为，由于自动添加分号，函数实际已经变成： 12345function max(a,b)&#123; return ; // 这里被添加了分号，函数执行到这结束了 a &gt; b ? a : b;&#125; 所以，细心的你一定会避过这个坑吧？ 奇妙的函数参数 传递参数个数任意？ 如果是第一次接触 JavaScript ，在上面定义max 函数我们可以惊讶的发现，可以传递不止两个参数！ 12// 多个参数调用console.log(max(1,2,&#x27;A&#x27;,&#x27;B&#x27;)); // 输出：2 而且它还计算出了正确结果！ 事实上，JavaScript 允许传递任意个参数，如果函数内部不使用多余的参数自然也就不会影响到结果。 那么传递参数比实际定义少呢？ 1console.log(max(1)); // 输出：undefined 怎么处理所有参数？ 在上面虽然我们调用 max() 函数输入了多余参数，但是我还是想把多余参数给输出来，该如何处理？ 在函数内部利用 arguments ，可以获取所有参数。 12345678910111213// argumentsfunction max(a,b)&#123; if(arguments.length &gt; 2) // 输出超过定义个数的参数 &#123; for(var i = 2 ; i &lt; arguments.length ; i++ ) console.log(arguments[i]); &#125; return a &gt; b ? a : b;&#125;// 调用maxmax(1,2,&quot;hhh不许笑！&quot;); // 输出：hhh不许笑！ 一般常用的也就是：arguments.length &amp; arguments[i] 用来获取参数长度和指定索引参数。 优雅的处理多余参数 上面虽然用arguments 获取到所有参数，然后输出多余参数，但是总感觉很变扭。 但是有没有一种方式，让我们直接处理多余参数 ，而不是要从索引 2 先排除前两个参数？ 可以使用 rest 来达到这个目的，多余参数会以数组形式 交给 rest 变量： 12345678910// rest// 函数定义的时候要以：...rest来标识[从哪里开始算是多余参数]function max(a,b,...rest)&#123; console.log(rest); // 会以[数组]形式输出 return a &gt; b ? a : b;&#125;// 调用maxmax(1,2,&quot;hhh不许笑！&quot;); // 输出：[ &#x27;hhh不许笑！&#x27; ] 2.2 变量作用域与解构赋值 1. 快速了解变量作用域 变量作用域块{}知识基本和其它语言没有太大区别，但是有几个 JavaScript 所特有特性。 变量提升 执行下面函数会报错吗？如果不会，那么输出什么？ 123456789&#x27;use strict&#x27;;function f()&#123; var x = 1; console.log( x + y); var y = 2;&#125;f(); 执行这段代码，我们发现：编译器没有报错，但是输出 NaN 。 这是因为javascript 有一个很奇怪的特性：它会自动提升 变量的声明 到函数顶端，但是又不会提升 变量的赋值。 在编译器眼里，它看到的代码是这样的： 12345678910&#x27;use strict&#x27;;function f()&#123; var x = 1; var y ; // 提升了定义 console.log( x + y); // 执行后也并没有报错 y = 2; // 没有提升赋值&#125;f(); 所以虽然可以使用变量 y 但是又不能使用它的值，所以输出：NaN 。 避免错误 😋 对于这种怪异特性，我们最好提前用 var 声明所有要使用的变量。 1234567function f()&#123; var x = 1, y = 2, z; // do something &#125; 😋 用 let 关键字来限定变量范围，申明一个块级作用域。 由于这种变量提升特性，导致变量实际作用域是函数内部，会使得for 等循环语块无法定义具有局部作用域变量： 1234567891011function f()&#123; console.log(i); // 不报错可以使用i，但是输出：undefined for(var i = 0 ; i &lt; 3 ; i++) &#123; // do something &#125; console.log(i); // 可以使用i值，输出：3&#125;f(); 我们可以通过 let 关键字来达到，限定 i 为局部变量： 1234567891011function f()&#123; console.log(i); // 会报错，不能使用局部变量i for(let i = 0 ; i &lt; 3 ; i++) &#123; // do something &#125; console.log(i); // 会报错，不能使用局部变量i&#125;f(); 2. 全局作用域 不在任何函数内定义的变量就具有全局作用域。 特别的，顶层函数也是全局变量。虽然乍看有点难以理解，但是回想它的匿名函数写法，便一目了然。 1234567891011121314&#x27;use strict&#x27;;// 全局作用域var author = &#x27;hwh&#x27;;var f2 = function()&#123; return &#x27;顶层函数也是全局变量&#x27;;&#125;// 全局变量任意嵌套块中都可以调用&#123; console.log(author); console.log(f2());&#125; window 对象 window 是javascript 默认全局对象 ，所有全局变量 都被绑定到 window 上作为一个属性。 1234567// window// 调用window对象：console.log 会报错，用alert打开网页可正常输出？&#123;// console.log(window.author); // 出错 alert(window.author); // 打开网页输出：hwh alert(window.f2()); // 打开网页输出：顶层函数也是全局变量&#125; 可以看到，全局变量可以作为它的属性一样被调用。事实上 alert() 也是一个全局变量。 下面尝试给 函数变量 alert 赋值一个新的函数，使得它不能执行 alert() 原本输出功能。 123456789101112&#x27;use strict&#x27;;window.alert(&#x27;调用window.alert()&#x27;);// 定义一个变量保存函数（函数也是变量）var old_alert = window.alert;// 给alert赋一个新函数:window.alert = function () &#123;&#125;// 尝试调用alert()alert(&#x27;我还能输出吗？&#x27;); // 打开网页发现这句话不会被输出 更好的定义全局变量 全局变量会绑定到对象window上，不同的 JavaScript 文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。 减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如： 1234567891011// 唯一的全局变量NOTE:var NOTE = &#123;&#125;; // 对象？// 其他变量:NOTE.author = &#x27;hwh&#x27;;NOTE.version = 1.0;// 其他函数:NOTE.f = function () &#123; return 1;&#125;; 3. 解析构值 什么是解析构值？简单来说，可以 同时对一组变量进行赋值。 1234// 解析构值// 注意：解析构值涉及多个变量赋值，两边都要用[]包围var x,y,z,rest;[x,y,z] = [1,2,3]; 还可以像前一样，用... 标识rest ，以数组形式接收指定位置之后所有赋值。 123// 1.解析赋值：...rest[x,y,z,...rest] = [1,2,3,4,5];console.log(rest); // 输出：[ 4, 5] 解构数组 除了上述基本特点，解构数组还有以下特点： 12// 解析数组 var x,y,z,rest; 允许待赋值变量个数 ≠ 右侧变量数 12345678// 1. 允许待赋值变量个数 ≠ 右侧变量数// 待赋值变量 &gt; 右侧，剩余未赋值变量赋undefined [x,y,z] = [1,2]; // 等价于：[x,y,z] = [1,2,undefined];console.log(&#x27;x=&#x27;+x+&#x27;,y=&#x27;+y+&#x27;,z =&#x27;+z); // 输出 ：x=1,y=2,z=undefined// 待赋值变量 &lt; 右侧，只会对应依次将待赋值变量赋值完毕[x,y,z] = [1,2,3,4,5]; // 等价于：[x,y,z] = [1,2,3]; console.log(&#x27;x=&#x27;+x+&#x27;,y=&#x27;+y+&#x27;,z =&#x27;+z); // 输出：x = 1,y = 2,z = 3 设置默认值 123// 2.可以设置默认值[x,y,z = 666] = [1,2];console.log(&#x27;x=&#x27;+x+&#x27;,y=&#x27;+y+&#x27;,z =&#x27;+z); // 输出：x=1,y=2,z=666 忽略某些值 1234// 3.忽略值var a,b;[a, ,b ] = [1,2,3];console.log(&#x27;a = &#x27;+ a + &#x27;,b = &#x27;+ b); // 输出：a = 1,b = 3 解构对象 前面都是解构数组，对象由一对对键值组成，和解构数组自然有些不同。 123// 对象解构赋值var o = &#123;x:&#x27;one&#x27; , y:&#x27;two&#x27;,z:&#x27;three&#x27;,a:&#x27;four&#x27;,b:&#x27;five&#x27;&#125;;var &#123;x,y,z,a,b&#125; = o; 特别的，如果不是对一个已存在对象解构，而是进行无声明赋值，赋值语句有所不同： 12345// 这种无声明赋值，要求赋值语句周围有 (...)var x,y,z;( &#123;x,y,...rest&#125; = &#123;x:&#x27;one&#x27; , y:&#x27;two&#x27;,3:&#x27;three&#x27;,4:&#x27;four&#x27;,5:&#x27;five&#x27;&#125; );console.log(x); // 输出：oneconsole.log(rest); // 输出：&#123; &#x27;3&#x27;: &#x27;three&#x27;, &#x27;4&#x27;: &#x27;four&#x27;, &#x27;5&#x27;: &#x27;five&#x27; &#125; 对象解构还有以下一些基本特点： 1var o = &#123;x:&#x27;one&#x27; , y:&#x27;two&#x27;,z:&#x27;three&#x27;,a:&#x27;four&#x27;,b:&#x27;five&#x27;&#125;; 允许待赋值变量个数 ≠ 右侧变量数 123// 1.待赋值变量 &lt; 右侧，按对应键值赋值完毕,[顺序不影响]var &#123;x,b,a&#125; = o;console.log(&#x27;x=&#x27;+x+&#x27;,y=&#x27;+y+&#x27;,z =&#x27;+z); // 输出：x=one ,a=four ,b=five 左右两侧键值要对应 123// 2.左右两侧键值要对应var &#123;x,Y,z,a,b&#125; = o; // 左侧Y和右侧键值y，不对应console.log(Y); // 无法解构成功，输出：undefined 给新变量提供默认值和参数 12345// 3.给新变量提供默认值和参数var &#123;x:xx = 10, y:yy = 5&#125; = &#123;x: 3&#125;;console.log(xx); // 3console.log(yy); // 5 解构嵌套对象和数组 解构嵌套对象和数组，具有的基本特点和上面是一致的。主要不同在于： 解构嵌套对象要保证层次一致；解构嵌套数组，不仅要保证层次一致还要保证位置一致。 嵌套数组 数组本身有嵌套，解构赋值要保证嵌套位置和层次一致。 123// 1.数组嵌套let [x,[y,z]] = [1,[2,3]];let [[y,z],x] = [1,[2,3]]; // 出错位置不一致 嵌套对象 对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，保证层次一致。 123456789101112131415var person = &#123; name: &#x27;hwh&#x27;, age: 23, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, address: &#123; city: &#x27;FUZHOU&#x27;, street: &#x27;No.1 Road&#x27;, zipcode: &#x27;341000&#x27; &#125;&#125;;// 只需保证层次一致：赋值时按键值赋值，顺序位置可以调换var &#123;name, address: &#123;city, zipcode&#125;&#125; = person; 注意，address 并不是变量名，尝试输出会报错。它只是为了city、zipcode获取对象属性： 123456// 测试输出 console.log(address); // 报错，address不是变量 console.log(person.address); // 输出： &#123; city: &#x27;FUZHOU&#x27;, street: &#x27;No.1 Road&#x27;, zipcode: &#x27;341000&#x27; &#125;// 输出：name:hwh,city:FUZHOU ,zipcode:341000console.log(&#x27;name:&#x27;+name+&#x27;,city:&#x27;+ city,&#x27;,zipcode:&#x27;+ zipcode); 使用场景 交换两个变量 123// 1.交换变量x yvar x=1, y=2;[x, y] = [y, x] 快速获取页面域名 &amp; 路径 12// 2.快速获取页面域名和路径var &#123;hostname:domain, pathname:path&#125; = location; 减化函数参数定义 如下面可以方便快速创建一个对象。 1234function myDate(&#123;year, mon, day, hour=0, min=0, sec=0&#125;) &#123; return new Date(year + &#x27;-&#x27; + month + &#x27;-&#x27; + day + &#x27; &#x27; + hour + &#x27;:&#x27; + minute + &#x27;:&#x27; + second);&#125; 如上面函数接收一个对象作为参数，而不是去定义6个参数： 1function myDate(year,mon,day,hour=0,min=0,sec=0) 在调用函数的时候，根据解析构值，形参对象给实参对象赋值 ： 1myDate(&#123;2019,07,19&#125;); 2.3 方法与this大坑 在一个对象中绑定函数，称为这个对象的方法。 123456789101112131415//方法var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:function() &#123; var nowYear = new Date().getFullYear(); return nowYear - this.birth; // 调用对象里属性，不用this会报错 &#125;&#125;console.log(hwh.age()); // 输出：23console.log(hwh.age); // 输出：[Function: age] 我们知道，this 关键字是用来指向当前对象。在JavaScript 没有类这个概念，this 在上述代码指向的是 hwh 这个对象。this.birth 因此可以拿到 hwh 的 birth 属性。 在这里，我们也看到 JavaScript 中 this 关键字和常用高级语言第一个不同点： 即使是在对象内部，调用对象属性也要 this.属性名 进行调用，否则会出错。 但是，由于js本身设计缺陷，this 在函数内部不一定指向当前对象，也可能指向全局对象 window 。 1. 小心使用你的 this 新变量指向方法 如果你尝试用一个新变量 my_age 指向函数内部方法 age() : 123456789101112131415var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:function() &#123; var nowYear = new Date().getFullYear(); return nowYear - this.birth; // 调用对象里属性，不用this会报错 &#125;&#125;// 新变量指向对象方法var my_age = hwh.age;console.log(my_age()); // 输出： NaN why？？为什么突然报错？ 这是因为，以 对象名.方法名() 调用 this 指向当前对象 ；但是 单独调用函数 ，this 指向全局对象 window ！ 多层函数内部用 this 喜欢重构的你，又闲得蛋疼，突发奇想，在age方法内部再定义一个函数来返回值： 1234567891011121314151617var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:function() &#123; function getAge() &#123; var nowYear = new Date().getFullYear(); return nowYear - this.birth; // 调用对象里属性，不用this会报错 &#125; return getAge(); &#125;&#125;console.log(hwh.age()); // 输出：NaN 又出错了！虽然 this 关键字在 对象age方法内部 指向当前对象，但在 age方法内函数内 指向全局对象 window ！ 聪明的你也许会想，既然在 age方法内部还是指向当前对象，那我可以捕获此时this ，再在方法内部函数使用： 12345678910111213141516171819var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:function() &#123; // 捕获this var that = this; function getAge() &#123; var nowYear = new Date().getFullYear(); return nowYear - this.birth; // 调用对象里属性，不用this会报错 &#125; return getAge(); &#125;&#125;console.log(hwh.age()); // 输出：23 更优雅解决this 错误指向：改写为箭头函数，详见：2.6 箭头函数 。 提醒不要犯错：strict 模式 上述两种情况，还可以在 strict 模式下让函数的this 指向 undefined ，而不是window ，这样编译器会抛出错误。 12345&#x27;use strict&#x27;;// 上面函数写法...console.log(hwh1.age()); //抛出错误： Cannot read property &#x27;birth&#x27; of undefined 2. apply 方法 在前面，我们可以用 strict 模式，使得this 指向 undefined 让编译器提醒我们不要让 this 错误指向。 但是，可以控制 this 正确指向我们所期望的吗？ 每个函数本身拥有的apply() 方法，可以做到这点。 123456789101112131415161718192021&#x27;use strict&#x27;;function getAge()&#123; var nowYear = new Date().getFullYear(); return nowYear - this.birth; &#125;var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:getAge&#125;// 让getAge() 中this从指向 undefined (严格模式下不是window） --&gt; hwh// 参数1：表示方法要指向的对象// 参数2：表示方法需要的参数，用数组封装好。这里[]表示为空getAge.apply(hwh,[]); console.log(hwh.age()); // 输出23 call 方法 call 方法和 apply 方法很类似，能达到相同效果，它们唯一区别是传递参数不同。 比如，调用 Math.max(3, 5, 4)，分别用 apply() 和 call() 实现如下： 12Math.max.apply(null, [3, 5, 4]); // 5Math.max.call(null, 3, 5, 4); // 5 可以看到，apply() 需要把参数封装好 Araay 数组再传入 ； call() 则需逐个传入参数。 新的问题 在 新变量指向方法 小节中，我们尝试用 apply 来改变新变量函数指向： 1234567891011121314151617var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:function() &#123; var nowYear = new Date().getFullYear(); return nowYear - this.birth; // 调用对象里属性，不用this会报错 &#125;&#125;// 新变量指向对象方法var my_age = hwh.age;my_age.apply(hwh,[]); // 改变this指向不成功？console.log(my_age()); // 输出： NaN 却发现，my_age 方法指向并没有被改变，还是输出 NaN ? 之所以不尝试，多层函数内部用 this 一节用apply 改变，是因为无法取里层函数名。而直接尝试在里层函数里使用函数名，那就变成递归了！ 1234567891011121314151617var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:function() &#123; function getAge() &#123; // 只能在这里可以取到getAge函数名，可是变成了递归 // getAge.apply(hwh,[]); // 报错：无限递归 var nowYear = new Date().getFullYear(); return nowYear - this.birth; // 调用对象里属性，不用this会报错 &#125; return getAge(); &#125;&#125; 装饰器 利用 apply()，我们还可以动态改变函数的行为。 JavaScript 的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。（ 覆写？？） 增加统计调用多少次方法 parseInt() ，在不改变原有功能基础上。 12345678910111213141516// 装饰器 // 下面代码在 VSCode + codeRunner报错：window is not defined// 在浏览器中控制台可正常输出var count = 0;var oldParseInt = parseInt;window.parseInt = function()&#123; count++; return oldParseInt.apply(null,arguments);&#125;parseInt(&#x27;10&#x27;); parseInt(&#x27;10&#x27;); parseInt(&#x27;10&#x27;);console.log(count); // 输出：3 但是下面方法也能调用原函数，无法说明装饰器作用？ 123456window.parseInt = function()&#123; count++; // return oldParseInt(null,arguments); // 报错：parseInt是函数变量，这里返回的是函数值 return oldParseInt; // 成功输出 ：函数之间的赋值&#125; 2.4 高阶函数 在 JavaScript 中 ，变量可以指向函数，函数参数能接收变量，那么自然可以把 函数当做另一个函数参数传递 。 高阶函数，简单来说就是把函数当参数，类似于C/C++中函数指针和C#中委托。 下面是四个基本四则运算函数： 1234567891011// 加function add(a,b)&#123; return a+b;&#125;// 除function div(a,b)&#123; return a/b;&#125;// 乘、减.. 我们可以把它们当做参数，实现一个函数就可以计算四种不同运算： 123456function myfuc(a,b,f)&#123; return f(a,b);&#125;var result = myfuc(1,3,div); // 0.3333333.. 映射：map / reduce map() 这里的map() 和前面集合map 不同，它是一个方法，表现对数组每个元素进行某种映射关系。 假设存在一个数组：arr = [x1,x2,x3…] ，和回调函数 f(x)。 arr.map() 把函数 f(x) 作为参数 ，会返回一个新数组 [f(x1), f(x2), f(x3) …] 12345678910// mapfunction pow(x)&#123; return x*x;&#125;var arr = [1,2,3,4,5];var newArr = arr.map(pow);console.log(newArr); // 输出：[ 1, 4, 9, 16, 25 ] ❔ 数组的元素会自动作为回调函数f(x) 第一个形参的实参进行赋值，如果f(x) 没有参数呢？或者不止一个参数呢？ 123456789function pow()&#123; return 1;&#125;var arr = [1,2,3,4,5];// 如果没有参数，每一次pow函数返回值 1 作为新数组元素var newArr = arr.map(pow);console.log(newArr); // 输出：[ 1, 1, 1, 1, 1 ] 事实上回调函数 f(x) 有三个参数，通常我们只使用第一个参数，表示 Array 某个元素： 123456789101112131415var arr = [1,2,3,4,5];var newArr = arr.map( function(element,index,self) &#123; console.log(element); // 依次打印: 1,2,3,4,5 console.log(index); // 依次打印: 0,1,2,3,4 console.log(self); // self就是变量arr,每次都打印arr:[ 1, 2, 3, 4, 5 ] return element*element; &#125;);console.log(newArr); // 输出：[ 1, 4, 9, 16, 25 ] 试分析：把parseInt函数作为参数，为什么得到意料之外的结果？ 1234var arr = [&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;];var newArr = arr.map(parseInt);console.log(newArr); // 输出：[ 1, NaN, NaN, NaN, NaN ] 🙂 查看MDN文档：MDN-Array.map() reduce() reduce() 和 map() 类似：传入的参数函数f 循环每次对数组前两个元素运算，运算结果r作为数组首元素插入头部。 假设存在一个数组：arr = [x1,x2,x3,x4…] ，和某个函数 f(x,y)。 arr.map() 把函数 f(x,y) 作为参数 ，会返回一个值：f(f(x1,x2),x3) 12345678910// reducefunction sum(x1,x2)&#123; return x1+x2; &#125;var arr = [1, 2, 3, 4, 5];var s = arr2.reduce(sum);console.log(s); // 输出：15 当然无论是 map / reduce 传递参数都可以用 lambada 表达式进行简化： 1234var arr2 = [1, 2, 3, 4, 5];var s = arr2.reduce((x1,x2) =&gt; x1+x2);console.log(s); // 输出：15 自定规则：filter / sort … 下列高级函数都有以下特点： 根据传递的回调函数 自定义某种判断规则 对数组每个元素进行判断，根据返回结果 ture / false 决定对元素进行不同操作 filter() filter也是常用高级函数，它用于把Array 某些元素过滤掉，然后返回剩下的元素。 具体过程：*filter()*把传入的回调函数依次作用于每个元素 ，回调函数返回值为 ture 则该元素保留，否则删除。 1234567891011var arr = [1, 2, 3, 4, 5];var arr1 = arr.filter( function(x) &#123; return x % 2 == 0; // 只返回偶数 &#125;);console.log(arr1); // 输出：[ 2, 4 ] 给定数组Array ，去除里面重复的元素。（没看太明白） 123456789101112131415&#x27;use strict&#x27;;var r, arr = [&#x27;apple&#x27;, &#x27;strawberry&#x27;, &#x27;banana&#x27;, &#x27;pear&#x27;, &#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;orange&#x27;];r = arr.filter( // 数组当前元素、数组当前元素索引、数组本身分别作为回调函数3形参的实参值 function (element, index, self) &#123; return self.indexOf(element) === index; // 这里没太明白 &#125;);console.log(r.toString()); // 输出：apple,strawberry,banana,pear,orange sort() JavaScript 中的 sort() 高级排序函数，无传递回调函数情况下，排序的操作顺序如下： 先将数组的所有元素转换成 String 字符串 sort() 根据每个字符串 首字符 ASCII值 来从小到大排序 所以看起来会有下面&quot;奇怪&quot;结果：10 排在 2 前面 1[10, 20, 1, 2].sort(); // [1, 10, 2, 20] 这是因为数组元素先转换成 String 类型，按 首字符 ASCII值 排序规则： ‘1’ &gt; ‘2’ ==&gt; ‘10’ &gt; ‘2’。 定义自己的排序规则 我们来定义数字从小到大排序规则回调函数，使得能正常输出我们期望的数字排序结果。 排序规则：类比冒泡排序，判断两个元素大小，决定是否交换位置？ 123456789101112var arr = [10, 20, 1, 2];arr1 = arr.sort( function(x,y) &#123; if(x&gt;y) return 1; else return -1; &#125;);console.log(arr1); // 输出：[ 1, 2, 10, 20 ] 对应，冒泡排序写法： 123456789101112131415161718192021function cmp(x,y)&#123; if(x&gt;y) return 1; else return -1;&#125;var s = [10, 20, 1, 2];for(let i = 0; i &lt; arr.length ; i++)&#123; for(j = arr.length -1 ; j -i &gt; 0; j--) &#123; // cmp作为排序规则，决定是否交换两个元素 if(cmp(s[j],s[j-1]) == -1) &#123; temp = s[j]; s[j] = s[j-1]; s[j-1] = temp; &#125; &#125; console.log(s[i]); // 依次输出：1 2 10 20&#125; 如果，要求从小到大输出呢？ 重新定义下 何为大 即可。 123456789101112var arr = [10, 20, 1, 2];arr1 = arr.sort( function(x,y) &#123; if(x&gt;y) return -1; // 改成返回 -1 else return 1; // 改成返回 1 &#125;);console.log(arr1); // 输出：[ 20, 10, 2, 1 ] 同理，对应冒泡排序改换cmp排序规则（交换if / else返回值）。已测试成功输出，这里不再赘述。 every() every() 自定回调函数判断规则，对所有数组元素进行判断，如果回调函数都 返回ture ，说明所有元素都满足判断条件，那么*every()* 返回 ture，否则返回false 。 给定一个包含指定字符串数组，判断字符串是否满足指定测试条件。 123456789var arr = [&#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;];var b = arr.every( function (s) &#123; return s.length &gt; 0; &#125;); console.log(b);// true, 因为每个元素都满足 s.length&gt;0 find() 同上自定 回调函数判断规则，对所有元素进行判断。如果回调函数返回 ture ，则找到第一个元素， find() 返回该元素；如果所有元素都遍历完毕，没有返回 ture ，则说明未找到元素，find() 返回 undefined。 123456789var arr = [&#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;];var tmp = arr.find( function (s) &#123; s.toLowerCase() === s; // 找到第一个全是小写字母的字符串 &#125;); console.log(tmp);// 输出：pear findIndex() 和 find() 类型，不同在于 findIndex() 找到元素返回该索引而非返回元素；如果没找到元素则返回 -1。 特别：forEach() 同前 forEach 循环，它可用来遍历 数组、集合 。只单纯传递数组元素等信息，具体对数组元素等进行什么操作由传递的回调函数决定。 利用forEach() 尝试遍历一个数组。 12var arr = [&#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;];arr.forEach(console.log); 由于回调函数默认有三个参数：element、index、self ，console.log 接收这三个实参依次打印它们信息： 123Apple 0 [ &#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27; ]pear 1 [ &#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27; ]orange 2 [ &#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27; ] forEach() 遍历一个数组，只打印出数组元素。 我们可以重写 console.log 方法，让它只接收一个参数。 123456789var arr = [&#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;];var old_console_log = console.log;console.log = function(element) // 重写&#123; old_console_log(element);&#125;arr.forEach(console.log); // 依次输出：Apple pear orange forEach() 还可以遍历集合，如 Set、Map 等。注：不能遍历对象！遍历对象直接for 循环就行。 12345var arr2 = new Set([1,2,3]); arr2.forEach( console.log // 依次输出：1 2 3); 2.5 闭包 什么是闭包？ 前面我们了解到，函数可以作为 参数，那么函数自然也可作为 返回值。 闭包，简单来说就是携带状态的函数，其返回值是一个也是函数，而且它的状态可以完全对外隐藏起来。 它的作用有： 可创建函数工厂、减少函数参数 实现携带状态的闭包，获取函数内部局部变量且变量一直在内存中 函数工厂 计算指定 x 值的 2次方 / 3次方。 也许聪明的你，很快想到利用系统自带 API 计算x 次方： 1234var x = 5; // x值任意Math.pow(x,2); // 25Math.pow(x,3); // 125 但是，如果计算指定 x 值的 2次方 / 3次方是 常用 的，你觉得没必要每次都指定参数 幂次 ，干脆直接自定义 pow2 / pow3 函数，只接收参数 x ： 123456789101112function pow2(x)&#123; return Math.pow(x,2);&#125;function pow3(x)&#123; return Math.pow(x,3);&#125;pow2(5);pow3(5); 但是，如果计算 x 值的 4次方 / 5次方也 常用 ，定义4个函数显然不太简洁。 这里，可以用闭包创建一个函数工厂，返回同类我们需要的函数： 12345678910111213function creat_pow(n) // 创建pow函数工程，参数为指定幂次&#123; return function(x) // 返回函数，参数为变量x &#123; return Math.pow(x,n); &#125;&#125;var pow2 = creat_pow(2); // 注意这里参数是：幂次，返回计算指定幂次函数var pow3 = creat_pow(3);pow2(5); // 25 注意这里参数是：变量x，即闭包里隐藏的局部变量x，计算它的指定幂次pow3(5); // 125 在这里我们还可以看到，闭包函数pow 隐藏一个状态：变量x ，即pow 内部返回的匿名函数局部变量参数x 。从而把一个多参数函数，变为单参数函数。 又有，利用闭包快速生成不同类似函数，给Web进行事件绑定。 参照：闭包的应用 – 应用于web开发 更深入理解 “闭包” 难道闭包只是为了返回函数进而创建函数工厂 OR 减少函数参数吗？怎么理解闭包是携带状态的函数？请看下例： 我们知道，函数内部的局部变量，在函数退出后便自动消亡： 12345678910111213function creat_counter(initial)&#123; var n = initial; return function() &#123; return n++; &#125;&#125;var c = creat_counter(0); // 返回的是函数，故带上()是为了执行然后返回函数console.log(c()); // 1console.log(c()); // 2console.log(c()); // 3 非常奇怪的是，为什么这里的局部变量 n 实现了递增呢？变量n 不是应该在执行：var c = creat_counter(0); 后就已经消亡了吗？ 其实：在返回的函数中，实现了一个闭包环境，该闭包携带了外部无法访问的局部变量x 。 这是由于 creat_counter 是内部匿名子函数的父函数，而creat_counter 被赋值给全局变量 c，因此其内部变量n 、匿名子函数都在内存中，没有被垃圾回收机制回收。 这样父函数内部，子函数外部的局部变量n，在 JavaScript 类似类的私有变量。我们还可以返回一个对象，看起来更像是 类对象调用方法。 实现类似class机制封装私有变量的一个简单计数器。 1234567891011121314151617function creat_counter(initial)&#123; var n = initial; // 看起来就是一个私有变量，外部无法访问 function increase() &#123; return n++; &#125; // 返回一个对象，里面有inc属性，这样调用起来像是对象调用方法。 // 注意 inc:f2() 错误，带()是执行函数 return &#123;inc:increase&#125;; &#125;var c = creat_counter(0); // 返回的是对象，带上()是为了执行函数后返回对象// 看起来像是对象调用方法c.inc(); // 1c.inc(); // 2c.inc(); // 3 小心！返回函数不立即执行 我们需要注意一个问题，闭包返回的 函数fun 并不会立即执行，而是直到调用 函数fun() 才会执行。 这样，在我们返回函数引用任何后续会发生的变量都会产生意料之外结果，比如循环变量： 12345678910function count() &#123; var arr = []; // 定义一个数组，用于压入三个函数 for (var i=1; i&lt;=3; i++) // 循环压入一个匿名函数计算当前i^2：用箭头函数简写 arr.push( () =&gt; &#123; return i * i &#125;); return arr;&#125;var results = count();var f1 = results[0]; var f2 = results[1]; var f3 = results[2]; 当我们尝试执行 f1()、 f2()、 f3() 会发现一个出人意料的结果： 123f1(); // 16f2(); // 16f3(); // 16 全都是16！这是因为，由于变量提升，循环局部变量 i 已经是函数内部全局变量了。 同时，arr.push() 压入函数时，函数并未立即执行。等到 return arr 时，此时引用的变量i 已经执行完3次循环后变为 4 了。 我们有两种解决办法： 循环内部变量用 let 关键字声明，这样等到 return arr 时，函数引用的变量是对应循环次数局部变量 i 。 12for (let i=1; i&lt;=3; i++) // let arr.push( () =&gt; &#123; return i * i &#125;); 再创建一个函数 立即执行，用该函数的参数绑定循环变量当前的值，参照：廖雪峰教程–闭包 123456789for (var i=1; i&lt;=3; i++) arr.push( ( function (n) &#123; return function () &#123; return n * n;&#125; &#125; )(i) // 当前i赋值给函数形参n立即执行 ); 为什么直接压入匿名函数，而是要内部再返回一个函数，否则会报错？ 123456789101112131415161718function count() &#123; var arr = []; // 定义一个数组，用于压入三个函数 for (var i=1; i&lt;=3; i++) arr.push( ( function (n) &#123; return n * n; // 直接返回出错？？ &#125; )(i) ); return arr;&#125;var results = count();var f1 = results[0];console.log(f1()); // 报错： f1 is not a function 这是因为表面看arr.push() 压入的是一个函数，但由于立即执行，实际上压入的是函数返回值！所以才必须设计压入函数返回值是一个函数。 2.6 箭头函数 箭头函数和 Lambda 表达式都用于简写匿名函数，其语法也基本相同：(parameters) =&gt; &#123; statements; &#125;。 同时在满足一定条件下，还可以进一步简写： 参数类型可选 ：不需要声明参数类型，编译器可以统一识别参数值； 只有一个参数 ： 参数 ()可选 主体{}只有一条语句 ：此时 return 关键字 &amp; {} ，可不写。注意 ！ 主体{} 不省略时，哪怕只有一条语句，函数有返回值return关键字不可省！ 主体{} 省略时，return 也必须省略！ 利用箭头函数，实现给指定数组排序。 1234567&#x27;use strict&#x27;var arr = [10, 20, 1, 2];// arr.sort( (x, y) =&gt; x &gt; y ? 1: -1;); // 错误：函数作为参数不要加分号！arr.sort( (x, y) =&gt; x &gt; y ? 1: -1 );console.log(arr); // [1, 2, 10, 20] ⚠️ 试着指出下列箭头函数为什么不对？ 1arr.sort( (x, y) =&gt; &#123; x &gt; y ? 1: -1; &#125;); // 错误写法 主体{}只有一条语句，不省略{}时，语句要有分号 &amp; return不可省！ 1arr.sort( (x, y) =&gt; &#123; return x &gt; y ? 1: -1; &#125;); // 正确写法 优雅的解决 this 错误指向 在前面，我们提到 JavaScript 一个设计错误，在嵌套函数内部 this 会指向全局对象window (严格模式下指向 undefined) 而非调用函数的对象！为此我们提出一种解决办法：在嵌套函数里捕获this。 12345678910111213141516171819var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:function() &#123; // 捕获this，此时this不在嵌套函数内部还是指向调用对象 var that = this; function getAge() &#123; var nowYear = new Date().getFullYear(); return nowYear - this.birth; // 调用对象里属性，不用this会报错 &#125; return getAge(); &#125;&#125;console.log(hwh.age()); // 输出：23 现在我们可以箭头函数更加优雅的解决this 指向错误问题。 1234567891011121314var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, age:function() &#123; // 无需捕获this，此时this也能正确指向调用方法的对象 var getAge = () =&gt; new Date().getFullYear() - this.birth; return getAge(); // 注意：返回不是函数，而是调用后函数值 &#125;&#125;console.log(hwh.age()); // 输出：23 我的理解是，此时已经不是在嵌套函数内部调用this ，而在外层函数内调用this，不会出现this 错误指向问题。 因为在外层函数使用this 是可以自动绑定到当前调用函数的对象，但直接在对象内部调用this 还是会出错。 试分析：为什么对象内部直接this 调用属性出错。 1234567891011var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, my_birth: this.birth, age:() =&gt; new Date().getFullYear() - this.birth&#125;console.log(hwh.my_birth); // undefinedconsole.log(hwh.age()); // NaN 比如调用 hwh.my_birth 相当于以下过程： 12hwh = new hwh(); hwh.my_birth = this.birth; // 此时this指向了全局对象！ hwh.age() 调用错误同理。那么如何解决这个问题？ 目前除了apply、call 改变 this 指向（没试过），可声明一个函数在里面this 调用可以绑定到正确对象。 1234567891011121314var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, my_birth: function() &#123; return this.birth; &#125;, age:function() &#123; return () =&gt; new Date().getFullYear() - this.birth; &#125;&#125;console.log(hwh.my_birth); // 1996console.log(hwh.age()); // 23 2.7 generator generator 即生成器，是ES6 新引入数据类型，看上去像一个函数，但可以返回多次。 123456789101112function* f(x)&#123; yield x + 1; yield x + 2; yield x + 3;&#125;var myGenerator = f(0);var x1 = myGenerator.next(); console.log(x1); // 输出：&#123; value: 1, done: false &#125;var x2 = myGenerator.next(); console.log(x2); // 输出：&#123; value: 2, done: false &#125;var x3 = myGenerator.next(); console.log(x3); // 输出：&#123; value: 3, done: false &#125;var x4 = myGenerator.next(); console.log(x4); // 输出：&#123; value: undefined, done: true &#125; 它多个返回值可以 记录函数不同时刻的执行状态，从语法上看和函数有以下几个区别： 基本定义：函数是function f(x) ，而生成器要多出一个* ，function* f(x) 返回值：generator 生成器可以有多个返回值，记录函数不同时刻状态 使用：直接调用 generator 不是返回值，而是返回 一个生成器对象 ，可调用它的 next() 函数来输出返回值。 生成器不同返回值以对象形式保存：{value : 当前返回值，done: 判断是否已经输出完毕} 我们还可以更简洁用 for…of 循环来遍历generator 输出： 123456// 下面在浏览器里如是输出：如果直接在VSCode打印，还会在第一行输出：// Object [Generator] &#123;&#125;for(var x of myGenerator)&#123; console.log(x); // 依次输出：1 2 3&#125; 那么，generator 这种可以返回多个值，记录不同时刻执行状态的&quot;函数&quot;有什么作用呢？请看下例： 试着编写一个以 0、1 开头的斐波那契数列：0 1 1 2 3 5 8 13 21 34 … 按照以前思路，我们若要返回该斐波那契数列，必须要用 数组保存多个值 ，且看更优雅的generator 如何做到： 1234567891011121314151617181920function* fib(x)&#123; var a = 0, b = 1, c = -1; yield a; // 返回 0 yield b; // 返回 1 while(c &lt; x) &#123; c = a + b; [a,b] = [b,c]; yield c; &#125;&#125;var myGenerator = fib(5);for(var x of myGenerator)&#123; console.log(x); // 依次输出：0 1 1 2 3 5&#125; generator 不用数组来保存每次循环计算的值，而是直接将当前计算值的值 yield 返回即可。 generator 简化 AJAX （待）","categories":[{"name":"前端","slug":"前端","permalink":"https://hwh.zone/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://hwh.zone/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hwh.zone/tags/JavaScript/"}]},{"title":"前端基础（一）JavaScript基础笔记(中)","slug":"前端基础（一）JavaScript笔记（中）","date":"2021-11-25T12:36:37.921Z","updated":"2021-11-25T12:44:11.448Z","comments":true,"path":"2021/11/25/前端基础（一）JavaScript笔记（中）/","link":"","permalink":"https://hwh.zone/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%AD%EF%BC%89/","excerpt":"","text":"第三章：标准对象 3.1 小城少年对象与坑 typeof 在 JavaScript 的世界里，一切都是对象，你喜欢但不喜欢你的姑娘也是。 typeof 操作符获取对象的类型，它总是返回一个 字符串。 1234567891011121314151617// 1.字符串、数值、布尔基本类型typeof 123; // &#x27;number&#x27;typeof true; // &#x27;boolean&#x27;typeof &#x27;str&#x27;; // &#x27;string&#x27;// 2.函数typeof Math.abs; // &#x27;function&#x27;// 3.预设特殊值typeof NaN; // &#x27;number&#x27;typeof undefined; // &#x27;undefined&#x27;typeof null; // &#x27;object&#x27;// 4.[] &#123;&#125; ?typeof []; // &#x27;object&#x27;typeof &#123;&#125;; // &#x27;object&#x27; 根据利用 tepeof 来判断一些变量。比如： 判读全局变量、局部变量是否存在。 判断全局变量是否存在：typeof window.myVar === 'undefined' 判断局部变量是否存在：typeof myVar === 'undefined' 。 判断是否 null、Array 。 我们从上也知道，typeof 无法判断出是否 null、Array (它们和 []、 {} 都是 object类型)，但可以： 判断 null ： 变量 === null； 判断 Array：Array.isArray(arr); 包装对象 和 java 类似，JavaScript 还提供了包装对象，比如 int 可封装转换为 integer 类型对象。 1234// 封装返回的是一个对象var n = new Number(123) ; console.log(n); // 输出：[Number: 123]var b = new Boolean(true); console.log(b); // 输出：[Boolean: true]var s = new String(&#x27;str&#x27;); console.log(s); // 输出：[String: &#x27;str&#x27;] 但是注意：包装对象看上去值和原来一样但是已经是 object 类型！ 12345678console.log(typeof n); // 输出：object console.log(typeof b); // 输出：objectconsole.log(typeof s); // 输出：object// 和此前不同！console.log(typeof 123); // 输出：numberconsole.log(typeof true); // 输出：booleanconsole.log(typeof &#x27;str&#x27;); // 输出：string 3.2 Date Date对象用来表示日期和时间，有以下三种创建其对象方式。 12345678910111213141516171819// 1.默认构造函数// 用now对象获取的时间始终是[当前最新]时间// 输出的是UTC时间，与本地时间相差8个小时var now = new Date(); console.log(now); // 输出：2019-07-23T08:25:35.884Z// 2.指定日期和时间构建// 默认参数 = 0var date = new Date(2019,6,23,16,20,30,123);console.log(date); // 输出：2019-07-23T16:20:30.123Z// 3.指定时间戳创建// 先将符合[ISO 8601格式]字符串---&gt;时间戳var timeStamp = Date.parse(&#x27;2019-07-23T16:20:30.123&#x27;);console.log(timeStamp); // 输出：1563870030123，这是一个时间戳// 转换为Date对象var date = new Date(timeStamp);console.log(date); // 输出：2019-07-23T16:20:30.123Z 常用的获取时间各种信息对象方法： 12345678910111213141516var now = new Date();now; // 2019-07-23T08:47:48.033Z// 对象方法now.getFullYear(); // 2019, 年份now.getMonth(); // 6, 月份，注意月份范围是0~11，6表示7月now.getDate(); // 23, 24号now.getDay(); // 2, 星期二now.getHours(); // 16, 24小时制now.getMinutes(); // 47, 分钟now.getSeconds(); // 48, 秒now.getMilliseconds(); // 033, 毫秒数now.getTime(); // 1563871956469, 时间戳// 静态方法console.log(Date.now()); // 输出：1563871956469 时区问题 我们看到上面输出的时间，并不是我们本地时间，而是UTC时间和本地相差8个小时，我们可以输出本地时间。 12345678910// 1.直接将当前时间转为本地时间console.log(now.toLocaleString()); // 输出：2019-7-23 5:10:21 PM// 2.获取时间戳，然后进行时区转换// 静态OR动态方法获取时间戳var timeStamp = Date.now(); // 或者 var timeStamp = new Date().getTime();// 直接用时间戳构建对象var date = new Date(timeStamp);console.log(date.toLocaleString()); // 输出：2019-7-23 5:10:21 PM 3.3 RegExp（待） RegExp 是专门用于正则解析的类，首先我们要对正则表达式熟悉。 正则表达式 3.4 JSON JSON 是 JavaScript Object Notation 的缩写，它是一种数据交换格式，实际上也是 JavaScript 的一个子集。 其支持的数据类型有： object：即JavaScript 的&#123; ... &#125;表示方式 (可嵌套) number、boolean、 string、null、array：和 JavaScript 中对应类型完全一致 json 数据可以是上面支持数据类型 任意一个或多个组合 ，而不是只能在object {…} 包含键值对形式 。 观察下面 json 格式数据{…}和 js 对象{…}有什么不同？ 1234567891011// 组合成json格式数据&#123; &quot;birth&quot;: 1996, &quot;gender&quot;: &quot;M&quot;, &quot;school&quot;: &quot;chongqingU&quot;, &quot;skills&quot;: [ &quot;3C&quot;, &quot;python&quot;, &quot;2j&quot; ]&#125; 只要是字符串，如键值必须用双引号 ‘’ ‘’ 而且 json 还规定字符集必须是 UTF-8，这样可以支持多语言了。 json 和 js 对象/数组/字符串（json支持）等 可以互相转换，这又称为序列化和反序列化。 序列化 将JavaScript 数据类型转换为 json 称之为序列化。如下面是一个对象： 12345678var hwh = &#123; birth: 1996, gender: &#x27;M&#x27;, school: &#x27;chongqingU&#x27;, skills: [&#x27;3C&#x27;,&#x27;python&#x27;,&#x27;2j&#x27;], age:function()&#123; return new Date().getFullYear() - this.birth; &#125;&#125; 在 JavaScript 内置了 json API，我们可以直接调用 JSON.stringify()来转换为 json 格式： 12345// @value：传递一个对象或者数组(?)// @replacer: 传递一个方法用来改变结果显示，或者传递数组筛选指定键值// @space : 传递空白字符等用来格式化结果，使得结果更易读JSON.stringify(hwh,null,&#x27; &#x27;); 尝试输出结果： 12345678910111213141516// 返回字符串var s = JSON.stringify(hwh,null,&#x27; &#x27;);console.log(typeof s); // 输出：string，说明转换后json格式数据是字符串console.log(s);// 序列化结果&#123; &quot;birth&quot;: 1996, &quot;gender&quot;: &quot;M&quot;, &quot;school&quot;: &quot;chongqingU&quot;, &quot;skills&quot;: [ &quot;3C&quot;, &quot;python&quot;, &quot;2j&quot; ]&#125; 特别的，允许的数据类型如果不属于json 支持类型，序列化时不会显示该类型，如 函数age键值对 没有显示。 当然，我们也可以转换其它json 支持的数据类型： 123console.log(JSON.stringify(&#x27;str&#x27;)); // 输出：&quot;str&quot;console.log(JSON.stringify(123)); // 输出：123console.log(JSON.stringify(true)); // 输出：true 进一步处理：传递函数 在前介绍，我们还可以通过第二个参数 @replacer 对键值对进行筛选、指定处理方法等。 筛选出JavaScript对象指定键值：birth、gender、school 对应键值对。 我们可以通过传递一个数组包含我们希望留下的键值，来达到目的。 123456789var s = JSON.stringify(hwh,[&#x27;birth&#x27;,&#x27;gender&#x27;,&#x27;school&#x27;],&#x27; &#x27;);console.log(s);// 序列化结果&#123; &quot;birth&quot;: 1996, &quot;gender&quot;: &quot;M&quot;, &quot;school&quot;: &quot;chongqingU&quot;&#125; 12345678// 数组好像不行？？var s = JSON.stringify([&#x27;hwh&#x27;,&#x27;lt&#x27;],[0],&#x27; &#x27;);// 序列化结果[ &quot;hwh&quot;, &quot;lt&quot;,] 将所有键值转换为大写。（为什么不能对键值 key 大写？只能修改属性？） 需要对键值对进行处理，可以传递一个函数，它会对所有键值对进行操作。 123456// 箭头函数// 必须判断是否是 string类型，因为如birth属性就是Number// 注意：typeof返回String类型字符串！// 为什么不能转换键值key为大写？var valueToUpper = (key,value) =&gt; typeof value === &#x27;string&#x27; ? value.toUpperCase():value; ⚠️ 传递的函数任何情况要有返回值！比如上面不打算对属性value 进行修改也要 return value 。 我们尝试输出结果： 12345678910111213var s = JSON.stringify(hwh,valueToUpper,&#x27; &#x27;);console.log(s);&#123; &quot;birth&quot;: 1996, &quot;gender&quot;: &quot;M&quot;, &quot;school&quot;: &quot;CHONGQINGU&quot;, &quot;skills&quot;: [ &quot;3C&quot;, &quot;PYTHON&quot;, &quot;2J&quot; ]&#125; 反序列化 我们也可以利用 JSON.parse() 将 json 格式字符串解析转换为 javaScript对象 。 123456789// 1.反序列化对象 JSON.parse(&#x27;&#123;&quot;name&quot;:&quot;hwh&quot;, &quot;age&quot;:23&#125;&#x27;); // Object &#123;name: &#x27;hwh&#x27;, age: 23&#125;// 2.反序列化数组JSON.parse(&#x27;[1,2,3,true]&#x27;); // [1, 2, 3, true]// 3.反序列化其它基本类型JSON.parse(&#x27;true&#x27;); // trueJSON.parse(&#x27;123.45&#x27;); // 123.45 ⚠️ 要解析的 json 数据一定要是字符串！ 1234567// 1.尝试解析对象？var hwh = &#123;&quot;name&quot;:&quot;hwh&quot;, &quot;age&quot;:23&#125;; // 这既不是对象（键值有&quot;&quot;），也不是字符串console.log(JSON.parse(hwh)); // 解析错误// 2.尝试解析数组？var arr = [1,2,3,true];console.log(JSON.parse(arr)); // 解析错误 进一步处理：传递函数 事实上JSON.parse() 有两个参数，还可传第二个函数参数 @reviver 对json 字符串进行处理： 把传递进来的json 字符串，键值name对应属性后加上“同学”。 123456789101112131415// 反序列化：json字符串转换为对象// JSON.parse(@text,@reviver)// @text：传递合法json字符串// @reviver：传递一个函数改变输出结果var json_hwh = &#x27;&#123;&quot;name&quot;:&quot;hwh&quot;, &quot;age&quot;:23&#125;&#x27;;var addSome = function(key,value)&#123; if(key === &quot;name&quot;) return value + &#x27;同学&#x27;; // 对value进行修改 else return value; // 易错：其它情况也一定要有返回值！否则最后解析为undefined的！&#125;var obj = JSON.parse(json_hwh,addSome); 尝试输出结果： 1234console.log(obj);// 反序列化结果&#123; name: &#x27;hwh同学&#x27;, age: 23 &#125; 第四章：面对对象编程 4.1 在 JS 世界面对对象 JavaScript 所有数据都可以看成对象，比如我们之前使用：Number、Array、string &amp; 基本的**{…} **定义的对象。 但这并没有真正发挥面对对象编程威力。 熟悉 java、C# 的你一定知道：类 &amp; 实例之间区别，就是模板与创建的实例对象。BUT ，在JavaScript 中并没有类和实例概念，在JavaScript 世界里是通过 原型（prototype） 等方式实现的。 1.创建对象 闲的蛋疼的你想创建一个hwh对象，他会唱 、跳、rap、喜欢打篮球，又懒得9点钟都不一定起床的你恰好看到你之前创建的一个student对象： 12345678910var student = &#123; name : &quot;小明&quot;, age: 18, school: &quot;chongqingU&quot;, sing: function () &#123; console.log(&quot;i am sing..&quot;); &#125;&#125; 可是hwh 不叫小明，也不是18岁啊！更重要的小明他居然不会跳、rap、🏀！ 熟悉原型链的你微微一笑，不慌不忙的创建了一个hwh 对象： 123456789101112131415161718var hwh = &#123; name: &quot;huangwanghui&quot;, age: 23, // 对象增加额外方法 jump: function() &#123; console.log(&quot;i am jump..&quot;); &#125;, rap: function() &#123; console.log(&quot;i am rap..&quot;); &#125;, play_basketball: function() &#123; console.log(&quot;i am playing basketball ..&quot;); &#125;&#125; 然后把hwh._proto_ 属性指向student，看上去好像继承了student： 1234567hwh.__proto__ = student; // 注意：proto左右各有两个_，不是一个！console.log(&quot;大家好，我是渣渣辉 :&quot; + hwh.name);hwh.sing(); // 唱：i am sing..hwh.jump(); // 跳：i am jump..hwh.rap(); // rap：i am rap..hwh.play_basketball(); // 打篮球：i am playing basketball .. 通过同名键值可以覆盖student原有键值，通过创建新键值对可以使得hwh 可以跳、rap、打篮球。 扩展了解 为什么这种方式看上去好像 “继承”了 student 属性？ 因为在JavaScript 中，实例对象hwh如果没有找到属性、方法它会自动在其 hwh._proto_ 对象属性中查找（_proto_ 是一个对象）。这个时候把对象student 赋值 hwh._proto_ ，那么就会自动查找对象 student 属性。 ⚠️ _proto_ 是每一个对象或函数都有的属性（默认指向 Object.prototype），但是函数还有 prototype 属性。 所以hwh._proto_ （也就是对象student ）中也有这个属性： 此时查找的原型链为： 如果是用后面介绍 构造函数创建hwh对象方式 ，其查找原型链为： Object.create()创建对象 通常在写 JavaScript 代码，不推荐 使用 对象名.__proto__ 方式改变对象原型。 我们应该用 Object.create(对象o) 创建一个基于对象o 原型新对象： 用Object.create() 方式创建基于原型student 的对象hwh ，相当 复制 了student对象。 1234567891011121314// 基于原型student创建对象hwhvar hwh = Object.create(student);// 对象修改属性hwh.name = &#x27;huangwanghui&#x27;;hwh.age = 23;// 对象增加方法hwh.jump = () =&gt; console.log(&quot;i am jump..&quot;);hwh.rap = () =&gt; console.log(&quot;i am rap..&quot;);hwh.play_basketball = () =&gt; console.log(&quot;i am playing basketball ..&quot;);// 测试调用console.log(hwh.name); // 输出：huangwanghuihwh.jump(); // 输出：i am jump.. 构造函数创建对象 前面我们介绍了两种基于student原型创建hwh 对象方式：其中 hwh.__proto___ = student 这种创建对象方式，我们不推荐修改实例hwh 的*_proto__* 属性。 而且我们知道，此前student 都是对象： 1234567891011// 原型对象studentvar student = &#123; name : &quot;小明&quot;, age: 18, school: &quot;chongqingU&quot;, sing: function () &#123; console.log(&quot;i am sing..&quot;); &#125;&#125; 我们把student 改写成一个函数： 1234567891011// 构造函数Studentfunction Student(name,age,school) // 构造函数首字母建议大写&#123; this.name = name; this.age = age, this.school = school, this.sing = function () // 必须全部用this引用函数内部变量 &#123; console.log(&quot;i am sing..&quot;); &#125;&#125; 函数内部看起来很像对象键值对形式只不过 键值:属性 变为：this.键值:属性，特别的 函数所有变量（“键值”）必须用this 引用 ，在函数内部（非strict 模式）this 指向全局对象window ；new 创建新对象后，会自动将 this 指向到新创建的对象。 这也就是构造函数，使用 new 它会返回一个实例对象： 实例对象 继承构造函数所有属性 实例对象 _proto_ 属性自动绑定为构造函数原型prototype 属性。 同样，自然我们也可以对对象进行增改： 1234567891011// new返回一个对象var hwh = new Student(&quot;hwh&quot;,23,&quot;chongqingU&quot;); // 对象增加额外方法hwh.jump = () =&gt; console.log(&quot;i am jump..&quot;);hwh.rap = () =&gt; console.log(&quot;i am rap..&quot;);hwh.play_basketball = () =&gt; console.log(&quot;i am playing basketball ..&quot;);// 测试输出hwh.sing(); // 输出：i am sing..hwh.jump(); // 输出：i am jump.. 同前，此时原型链查找顺序为： 对象student 原型对象prototype 会自动赋值给 hwh._proto_ （student.prototype 属性也是一个对象） 如果没有在实例hwh 中找到属性、方法就会自动在hwh._proto_ 中查找，等价于在 student.prototype 查找 对象student.prototype 又有个对象属性 student.prototype._proto_ 它被赋值为Object 原型Object.prototype 如果student.prototype 没有找到属性，就会接着在 student.prototype._proto_ 中查找（等价在原型Object.prototype 中查找） 最后还有还找到返回null 2. 初识原型链 当我们用对象名.xxx访问一个对象属性时，JavaScript 引擎查找顺序如下： 先在当前对象上查找该属性，如果没有找到； 在其原型对象上找，如果还没有找到； 一直上溯到 Object.prototype --&gt; null ； 上溯到null 说明未找到，返回 undefined 。 等等，这里原型链是什么？ 当我们创建一个 Array 对象： 1var arr = [1, 2, 3]; 数组 arr 它的原型链是： 1arr ----&gt; Array.prototype ----&gt; Object.prototype ----&gt; null 由于 Array.prototype 定义了 indexof() 、shift() 等方法，所以我们可以直接使用。 同理，创建一个函数 fun() 其原型链为： 1foo ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null 那么前面以构造函数创建的hwh对象原型链是？（参考 1.创建对象 — 构造函数创建对象 一节） 构造函数 创建的hwh对象其原型链： 1hwh ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null 或者用图表达： ⚠️ 这里 Array、Function、Student 都是构造函数，因此有prototype 属性 即函数原型（见下详述）。 ​ 注：每一个对象或函数都有*_proto_*属性（默认指向 Object.prototype），但只有函数才有 prototype 属性。 使用原型链基本原则 基本使用原型链原则： 原型链不应该过长，这会在查找对象属性花费过多时间。 构造函数名首字母应该为大写（像约定类名首字母大写）。 3.深入理解原型链 prototype &amp; _proto_ 在前我们知道构造函数也是可以拥有属性的，prototype 是只有函数才拥有的共有属性。属性prototype 又称为 函数原型，它是一个对象。 _proto_ 是所有对象、函数都有属性，它也是一个对象，指向生成它的构造函数原型prototype 属性。因为所有对象都派生自 Object 构造函数，所以默认指向原型object.prototype 属性。如果是通过构造函数创建的实例对象，则指向生成它的构造函数原型prototype 。 （而prototype 也是一个对象，所以不难理解它也有*_proto_*属性 ：prototype._proto_） 在函数原型上定义的方法、属性会被所有实例“继承”，（准确来说，构造函数new 出的实例才会继承构造函数所有属性，函数原型上定义的方法、属性只是可以通过原型链查找而被使用，看上去好像“继承”了）。 函数原型对象prototype主要包含的属性方法如下（prototype 是一个对象所以也有很多键值对属性）： 原型本身定义的 原型 属性、方法（只有通过 函数名.prototype.属性名 = 方法/属性 定义的才是原型方法、属性 ） constructor 属性：指向构造函数本身 _proto_ 属性：和原型链上级构造函数原型prototype属性等价 进一步理解函数原型对象？ 我们创建一个空构造函数 Student() ： 123456function Student() // 构造函数首字母建议大写&#123; this.name = &quot;hwh&quot;; // [注1]&#125;Student.prototype.shcool = &quot;chongqingU&quot;; // 给Student函数增加属性，这样可以增加到原型对象上Student.age = 23; // [注2] 试想一下，如果我们之前用对象来作为原型创建实例， 把函数Student()改为对象Student应该是： 1234567// [注1] 添加的属性name不属于函数原型方法属性，但可被创建的实例继承，是实例属性// [注2] 添加的属性age，既不属于函数原型方法属性，也不会被实例继承，只能自娱自乐Student &#123; school: &#x27;chongqingU&#x27;&#125; 这样我们便有了函数原型 Student.prototype 的一个初步雏形： 1234Student.prototype &#123; school: &#x27;chongqingU&#x27;&#125; 当然，实际的 Student.prototype 属性不会这么简单：它还拥有constructor属性指向构造函数本身 ；_proto_ 属性指向上一级构造函数原型prototype 。 我们尝试打印会出来类似下面结构： 123456789101112131415console.log(Student.prototype);&#123; shcool:&quot;chongqingU&quot; // 1.函数原型增加的原型属性：shcool constructor: ƒ doSomething(), // 2.constructor：指向Student本身 __proto__: &#123; // 3.__proto__：== object.prototype constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() &#125;&#125; 可以看到构造函数Student.prototype._proto_ 属性指向—&gt;上一级构造函数object.prototype 属性。 (_proto_ 属性默认指向Object 原型) 1Student.prototype.__proto__ === object.prototype; // ture t由上介绍我们也知道，用构造函数创建的实例*_proto_* 属性，会指向生成它的构造函数原型 prototype 属性。 利用构造函数Student 创建实例hwh 对象，打印出它的 _proto_ 属性。 12var hwh = new Student();console.log(hwh.__proto__); 下面打印出的实际就是原型 Student.prototype : 1234567&#123; shcool:&quot;chongqingU&quot; // 1.原型本身拥有的属性：shcool constructor: ƒ doSomething(), // 2.constructor：指向Student本身 __proto__: &#123; // 3.__proto__：== object.prototype // ... &#125;&#125; 总结一下，函数原型可看作是 构造函数的一个&quot;实例&quot; ，但是： 只有 函数名.prototype.属性 OR 函数名.prototype.方法 声明的属性/方法才是原型属性/方法 &quot;实例&quot;还自动拥有 constructor &amp; _proto_ 属性分别指向函数本身和下一级构造函数原型 原型链查找 好的聪明的你肯定想起来，我们前面写出的 Student 构造函数创建的 hwh 对象原型链： 和我们此前说过的原型链查找某属性规则： 1当前对象查找属性 ---&gt; 上一级原型查找 ---&gt; .... ---&gt; object原型查找 ---&gt; 还没找到则为null 用一张图概况整个过程应该是： 在对象 hwh 本身实例属性查找，未找到则在 hwh._proto_ 查找 hwh._proto__ 实际 ===上级原型Student.prototype ，在该原型中查找定义的原型属性、方法 未找到则在hwh._proto_.prototype._proto_ === Student.prototype._proto_ ===上级原型 Object.prototype，查找该原型中定义的属性、方法 还未找到则返回null 如果我们把构造函数Student 原型指向另外一个实例，那么原型链查找顺序如何变化？ 创建实例lt，它有属性name = “liuting” 。把Student.prototype指向lt后，分析原型链查找name过程。 123456function Student() &#123;&#125;var lt = new Student(); lt.name = &quot;liuting&quot;; 此时我们还可以看到：lt.__proto__ === Student.prototype 为ture ，指向生成它的构造函数原型。 而当把Student 原型指向lt 后： 1Student.prototype = lt; // Student原型指向lt lt.__proto__ === Student.prototype 为 false， lt._proto_ 还是保存原来未修改前的Student 函数原型**。 再用构造函Student数创建新对象hwh： 12var hwh = new Student();hwh.__proto__ === Student.prototype === lt; // ture 用一张图概括原型链变化应该是： 我们尝试输出 hwh.name，显然可以在原型链 实例lt 的 lt属性方法 找到 name 属性： 1console.log(hwh.name); // 输出:liuting 4.2 构造函数继承 我们定义一个构造函数 Student()： 12345function Student()&#123;&#125;var hwh = new Student(); 其原型链为： 1hwh ---&gt; Student.prototype ---&gt; Object.prototype ---&gt; null 现在我们又定义了个构造函数 People() : 1234function People()&#123; this.eat = () =&gt; console.log(&quot;i am eating&quot;);&#125; 我们希望Student 能继承 People ,从而可以使用 People 的 eat() 方法，并且把原型链修改为： 1hwh ---&gt; Student.prototype ---&gt; People.prototype ---&gt; Object.prototype ---&gt; null 那么该怎么办呢？ 1. 构造函数绑定 前面我们讲过apply方法：函数名.apply(对象名,[]) 。 可以将函数所有 绑定到this的属性 转而—&gt; 绑定到指定对象 上。（注：非严格模式下函数this 指向 undefined） 因此，我们可以将构造函数People 绑定到this的属性 —&gt; 绑定到构造函数Student 生成的对象上。 123456789function Student()&#123; // this指向Student构造函数创建的对象 // 将构造函数People绑定到this的属性(不是People所有属性) ---&gt; 绑定到Student对象上 People.apply(this,[]);&#125;var hwh = new Student();hwh.eat(); // 输出：i am eating 这样只是继承了Student 所有的属性，但是其原型链没有改变，还是： 1hwh ---&gt; Student.prototype ---&gt; Object.prototype ---&gt; null 之所以hwh 能调用 eat() 方法，是因为该方法已经绑定到 hwh 对象上。 2. prototype 模式 如果我们把 Student 原型指向 —&gt;一个 People 的实例，那么所有Student 实例都能“继承”People 属性、方法（准确来说，是通过原型链使得Student 实例对象hwh 可以使用构造函数People 的属性、方法）。 1234567Student.prototype = new People();// 良好习惯：修改了prototype要设置回prototype.constructorStudent.prototype.constructor = Student;var hwh = new Student();hwh.eat(); // 输出：i am eating 此时原型继承链为： 1hwh --&gt;Student.prototype == new People() --&gt;People.prototype --&gt;Object.prototype --&gt; null 用一张图表示为： 为什么有“良好习惯”？ 在上面我们修改了 Student.prototype 指向，立马有重新设置了 Student.prototype.constructor 指回Student 。 如果不这么做： 1234Student.prototype = new People();var hwh = new Student();hwh.eat(); // 输出：i am eating 不影响通过原型链使用People.eat() 方法，但我们尝试输出：hwh.constructor 1234567cosole.log(hwh.constructor);// 输出结果function People()&#123; this.eat = () =&gt; console.log(&quot;i am eating&quot;);&#125; 发现构造函数Student 生成的对象hwh.constructor 属性是指向构造函数People ！ 首先，我们要知道hwh 本身是没有constructor这个属性的。它是通过原型链查找到构造函数 People.prototype.constructor 属性的，自然它是指向构造函数 People 了： 但是对象hwh，是由构造函数Student() 生成的，我们在应该让hwh.constructor 指向生成它的构造函数Student()！ 所以就有了上面的 “良好习惯”： 1Student.prototype.constructor = Student; 但是，你可能会担心，这样People.prototype.constructor 不就被修改了吗？ 实际上，这样做只会在Student.prototype 也就是匿名对象 new People() +键值对：constructor : f Student() 看上去好像基本解决了原型链继承问题？但是由于要创建实例对象，开销较大。 3. 直接继承 prototype 通过直接把Student.prototype 原型属性直接指向 People.prototype 原型属性，来达到继承People 属性、方法。 通过这种方式，需要把People 的属性、方法绑定到原型对象People.prototype ： 1234function People()&#123;&#125;People.prototype.eat = () =&gt; console.log(&quot;i am eating&quot;); 好了，我们开始 “ 继承 ” People.prototype ： 123456Student.prototype = People.prototype;// 良好的习惯：每次修改函数原型，都应该设置回constructorStudent.prototype.constructor = Student;var hwh = new Student();hwh.eat(); // 输出：i am eating 看起来天衣无缝，而且这比第 2 种方法效率更高：不用创建 People 实例。 但这种方式的原型链为： 1hwh ---&gt; Student.prototype == People.prototype ---&gt; Object.prototype ---&gt; null 它没有体现 Student 和People之间原型继承关系，而且也隐藏了一个缺点。 继承 prototype 方式缺点 这种方式， Student.prototype 和 People.prototype 现在指向了 同一个对象 ，任何对 Student.prototype 修改都将反应在People.prototype 上。 我们在第二行修改了：Student.prototype.constructor = Student; ，会导致People.prototype.constructor 也被指向为构造函数 Student 。 123456People.prototype.constructor// 输出结果function Student()&#123;&#125; 我的疑问？ 为什么不可以直接设置 Student.prototype._proto_ 指向 People.prototype ？？？ 这种方式被很多博文都指出不应该提倡，原因影响性能？MDN-不推荐使用Object.prototype._proto_ 1234Student.prototype.__proto__ = People.prototype;var hwh = new Student();hwh.eat(); // 可以输出：i am eating 实现了原型链继承关系 同时因为没有修改Student.prototype ，不用设置 Student.prototype.constructor = Student 4. 利用空对象作为中介 一种基本完美的方法：既可体现原型链 Student 和People 继承关系，也不会导致constructor 之类问题。 由于第3种办法，会出现指向同一对象导致constructor 意料之外被修改问题，我们可以借用一个空函数作为中介。 123456789101112131415161718// 空函数F作为媒介function F()&#123;&#125;// 把F原型指向People原型F.prototype = People.prototype;// 此时Student.prototype原型指向空函数F实例对象Student.prototype = new F();// 良好习惯：每次修改函数原型，都应该设置回constructor// 由于此时Student.prototype 和 People.prototype不再指向同一对象// 此时修改constructor不会导致 People.prototype.constructor 被同步修改Student.prototype.constructor = Student; var hwh = new Student();hwh.eat(); // 输出：i am eating 噢，我的天！这是再变魔术吗？到底怎么一回事呢？ 1hwh ---&gt; Student.prototype == new F() ---&gt; F.prototype = People.prototype --&gt; Object.prototype ---&gt; null 5. 拷贝继承 这种方式比较暴力… 首先，把People 的属性、方法绑定到原型对象People.prototype ： 1234567function Student()&#123;&#125;function People()&#123;&#125;People.prototype.eat = () =&gt; console.log(&quot;i am eating&quot;); 接着实现将People 原型属性全部拷贝到 Student 原型属性上： 123456789// 遍历对象只需普通for循环// 遍历循环只能用&lt;对象名[&#x27;key&#x27;]&gt;方式，其中&#x27;&#x27;在[i]不用加，i已经是字符串for(var i in People.prototype)&#123; Student.prototype[i] = People.prototype[i];&#125;var hwh = new Student();hwh.eat(); // 输出：i am eating 可以看到，通过原型链 实例对象hwh 可以访问到构造函数Student.prototype.eat 属性方法。 4.3 class 继承 写的比较简单，需要时再补充。 初识 class 在ES6标准引入了 class 关键字，比原先JavaScript 基于原型链的对象模型更加简单。 现在有一个构造函数 Student 可用来new 出实例对象，它像下面这样： 123456function Student(name,age) &#123; this.name = name; this.age = age;&#125;Student.prototype.learn = function() &#123; console.log(&quot;i am learning..&quot;); &#125;; 把它改写成class ： 1234567891011121314151617181920class Student&#123; // 构造方法 // new生成实例对象时自动调用该方法，为所有类实例对象生成下列实例属性 constructor(name,age) &#123; this.name = name; this.age = age; &#125; // learn方法 learn() &#123; console.log(&quot;i am learning..&quot;); &#125;&#125;// 尝试调用var hwh = new Student(&#x27;hwh&#x27;,23);hwh.learn(); // 输出：i am learning.. 看起来比此前写法简单多了，但其实在JavaScript 类 class 本质还是函数： 1typeof Student; // function 另一方面，函数自然一定有原型属性prototype ： 当然，这个’'函数&quot;有点特殊，所有直接在类中定义的属性、方法会被直接绑定到函数原型上。 所以上面 class Student 等价这么写： 12345678910class Student&#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125;&#125;Student.prototype.learn = function() &#123; console.log(&quot;i am learning..&quot;); &#125;; 使用 class 实现继承 使用class 可以方便的实现继承，我想刚刚学完原型继承的你不会忘记被它支配的恐惧。 现在这有一个类 Girl_Student 继承 Student ，你可以这么写： 123456789101112131415161718class Girl_Student extends Student&#123; constructor(name,age,grade) &#123; // ES6规定必须调用父类构造函数一次 super(name,age); this.grade = grade; &#125; myGrade() &#123; console.log(&#x27;I am at grade: &#x27; + this.grade); &#125;&#125;var gs = new Girl_Student(&#x27;lt&#x27;,23,395);gs.myGrade(); // 调用自身方法：I am at grade 395gs.learn(); // 调用父类方法：i am learning..","categories":[{"name":"前端","slug":"前端","permalink":"https://hwh.zone/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://hwh.zone/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hwh.zone/tags/JavaScript/"}]},{"title":"前端基础（二）CSS基础笔记","slug":"前端基础（二）CSS笔记","date":"2021-11-25T10:45:45.161Z","updated":"2021-11-26T16:06:08.098Z","comments":true,"path":"2021/11/25/前端基础（二）CSS笔记/","link":"","permalink":"https://hwh.zone/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89CSS%E7%AC%94%E8%AE%B0/","excerpt":"","text":"第一部分：基本样式属性 文本样式 字体：font-family 指定设置元素的字体： 1234p&#123; font-family: &quot;Times New Roman&quot;, Times, serif;&#125; 逗号分隔表示为备选字体，当不浏览器不支持 “Times New Roman” 后会依次选择 Times、serif 字体。 如果字体不止为一个单词，要用 “ ” 包围，比如 “Times New Roman” 大小：font-size font-size 属性用于设置字体的大小，常用设置字体方式有三种： 关键字：small &lt; medium &lt; large &lt; xlarge 数值：像素值 px 、相对尺寸单位 em，特别的：1em = 16px 123456p &#123; font-size: small;// font-size: 16px;// font-size: 1em;&#125; 斜体：font-style font-style 通常用于指定斜体文本，常用属性值用关键字设置： 关键字：normal(正常文本)， italic（斜体） ，oblique(倾斜) 和 italic 效果类似 1234p&#123; font-style: italic;&#125; 粗细：font-weight font-weight 控制文本的粗细，可以设置关键字或者数值来指定： 关键字：normal (默认)，bold，bolder，和 lighter 数值：100（细）—&gt; 900（粗) ，特别的：normal == 400，700 == bold 大写：font-variant font-variant 属性可将字体转换 —&gt; 小型大写字母 ,可设属性有： 关键字：normal、small-caps（小型大写）、inherit ： 123456789101112&lt;html&gt;&lt;head&gt; &lt;style&gt; p.normal &#123; font-variant: normal;&#125; p.small &#123; font-variant: small-caps;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;normal&quot;&gt;设置为normal&lt;/p&gt; &lt;p class=&quot;small&quot;&gt;设置为small-caps&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 执行效果：可以看到原小写 small-caps 被转换为大写 SMALL-CAPS，但是字体较小 颜色：color color 可用于设置文本颜色，通常可用以下三种方法设置： 颜色关键字，如：red、blue、green 十六进制值，如：#0000FF(蓝色) RGB，如：rgb(255,0,0)(红色) 对齐：text-align 、vertical-align text-align 用于水平对齐，可设置属性为：left、center、rigth 。 vertical-align 用于垂直对齐，可设属性为： 文字在 表格单元 居中、上、下：top、middle、bottom ，不可用数值 字体能达到 不改变、下标、上标 ：baseline、sub、super ，可用数值 使得文字在表格居中、上、下。 123456789101112131415161718&lt;html&gt;&lt;head&gt; &lt;style&gt; td.top &#123; vertical-align: top;&#125; td.middle &#123; vertical-align: middle;&#125; td.bottom &#123; vertical-align: bottom;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;0&quot; style=&quot;height: 150px;&quot;&gt; &lt;tr&gt; &lt;td class=&quot;top&quot;&gt;Top&lt;/td&gt; &lt;td class=&quot;middle&quot;&gt;Middle&lt;/td&gt; &lt;td class=&quot;bottom&quot;&gt;Bottom&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; ⚠️ 但是特别的，如果 文字要在div区域到垂直居中效果 ，必须： 外部div标签 display 属性设置为内联表格：display: inline-table; 文字用 内部div标签 包围，同时将该内部div标签 display属性设置为表格单元：display: table-cell; html 代码： 123&lt;div class=&quot;div&quot;&gt; &lt;div class=&quot;paragraph&quot;&gt; w3cschool &lt;/div&gt;&lt;/div&gt; css 代码： 1234567891011.main &#123; height: 150px; width: 400px; background-color: LightSkyBlue; display: inline-table;&#125;.paragraph &#123; display: table-cell; vertical-align: middle;&#125; 最终可达到的效果： 使得某些文字在一段文字起到下标、上标效果。（注：也可直接使用 &lt;sub&gt;、 &lt;sup&gt; 标签达到效果） 12345678910111213141516&lt;html&gt;&lt;head&gt; &lt;style&gt; span.baseline &#123; vertical-align: baseline;&#125; span.sub &#123; vertical-align: sub; &#125; span.super &#123; vertical-align: super;&#125; span.pixel &#123; vertical-align: -10px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;This is a &lt;span class=&quot;baseline&quot;&gt;w3cschool&lt;/span&gt; example.&lt;/p&gt; &lt;p&gt;This is a &lt;span class=&quot;sub&quot;&gt;w3cschool&lt;/span&gt; example.&lt;/p&gt; &lt;p&gt;This is a &lt;span class=&quot;super&quot;&gt;w3cschool&lt;/span&gt; example.&lt;/p&gt; &lt;p&gt;This is a &lt;span class=&quot;pixel&quot;&gt;w3cschool&lt;/span&gt; example.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 下划： text-decoration text-decoration 指定文本如何装饰，如：增加下划线、上方水平线、删除线（也可用 &lt;s&gt; 标签实现）。 常用属性关键字有： none ： 默认值，这定义了一个正常的文本 inherit ： 从其父元素继承此属性 overline ：在文本上方绘制水平线 underline ： 在文本下方绘制水平线 line-through ： 在文本中绘制水平线（ 替换HTML标记） 比如给下面一段文字加上下划线： 12345678910&lt;html&gt;&lt;head&gt; &lt;style&gt; p.underline &#123; text-decoration: underline; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;underline&quot;&gt;w3cschool&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 效果图： 缩进：text-indent text-indent 属性指定在文本的第一行开始之前应该留下多少水平空间。 常用属性值以长度表示，其单位为：px、em、pt、cm 等。也可用 %、inherit(继承父元素缩进)。 ⚠️ 可使用负值，比如：text-indent: -40px 。 大写：text-transform text-transform 可以使得 文本字母 全部大写、小写、每个单词首字母大写，对应属性关键字为： uppercase：使得选中文本所有字母都大写 lowercase：使得选中文本所有字母都小写 capitalize ：使得选中文本每个单词首字母大写 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;style&gt; p.uppercase &#123; text-transform: uppercase;&#125; p.lowercase &#123; text-transform: lowercase;&#125; p.capitalize &#123; text-transform: capitalize;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;uppercase&quot;&gt; transforms all characters to uppercase.&lt;/p&gt;&lt;p class=&quot;lowercase&quot;&gt; transforms all characters to lowercase.&lt;/p&gt;&lt;p class=&quot;capitalize&quot;&gt; transforms the first character in each word to uppercase. &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 运行效果图： 间距：letter-spacing 、word-spacing letter-spacing 用于设置文本中字符之间的间距，常设属性方式： 关键字：normal(正常文本) 、inherit（继承父元素） 数值：px，pt，cm，mm 等测量单位定义字符额外空间，负值可以减少字符间距，更密集 。 word-spacing 指定文本中单词之间的空格，常设属性方式： 关键字：normal(正常文本) 、inherit（继承父元素） 数值：同前 盒模型 盒模型结构 属性工作顺序为顺时针：上 --&gt; 右 --&gt; 下 --&gt; 左 创建一个顶部10像素，底部15像素，右侧5像素，左侧10像素的 padding 。 1padding: 10px 5px 15px 10px; 盒模型宽高 高度 = height + ( padding-top + border-top + margin-top)+ (padding-bottom + border-bottom + margin-bottom) 宽度 = width + ( padding-left + border-left + margin-left )+ ( padding-right + border-right + margin-right ) 试问：下面盒模型的高度为多少？ 按照公式应该是：200 + (15 + 2 + 10 ) + (10 + 2 + 15) = 254px 边框：border border 属性可以自定义盒模型边框： 空格分隔分别表示：宽度 、边框样式 、颜色 。 1p &#123; border: 5px solid green; &#125; border-width、border-style、border-color border-width、border-style、border-color 属性可分别设置单独设置：宽度 、边框样式 、颜色 : 123456p&#123; border-style: solid; border-width: 2px; border-color: green;&#125; border-style 属性设置： 关键字：solid(实线)、dotted(虚线)、dashed(虚线)、double(双精度) 等 ⚠️ 还可为不同的边指定不同的边框：border-top-style，border-right-style … 宽高：width、height 元素的宽高属性一般设置： 数值：如指定高度 = 100px，height = 100px 百分比：如指定宽度占据整个屏幕宽，width = 100% 123456div &#123; border: 5px solid green; width: 100%; height: 90px;&#125; 最大、最小高宽 要设置元素的最小和最大高度或者宽度，可以使用以下属性： min-width ：元素的最小宽度 min-height ：元素的最小高度 max-width ：元素的最大宽度 max-height ：元素的最大高度 背景 背景色：background-color 前面我们可以使用属性 color 设置文本颜色；background-color 则可以设置元素指定背景颜色。常用属性值： 关键字：red、blue 等 十六进制：#fff、#000、#6e6e6e 等 RGB：rgb(255,255,255)、rgba(0,0,0,0.5) （rgba 可以实现透明背景色） 下面例子把：boby、h1、p 分配了不同的背景颜色。（字体颜色默认黑色） 12345678910111213141516171819202122&lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; body &#123; background-color:red; &#125; div &#123; background-color: #00ffff; &#125; p &#123; background-color:rgb(142,185,245); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;啊，我绿了！&lt;/div&gt; &lt;p&gt;啊，人生好蓝~&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 背景图：background-image background-image 用于设置背景图，设置属性值用相对/绝对路径指定： 指定路径：url(‘相对/绝对路径’) ⚠️ 如果要指定多个图片，以逗号分隔：background-image ： url(‘1.png’),url(‘2.png’); 特别的 background-image 不仅可以用于设置 整个页面，也可以设置 某个元素 背景图： 下面给元素设置一个背景图片。 1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; p &#123; height:100px; line-height: 100px; text-align: center; color: red; background-image:url(&quot;https://wpdotorg.files.wordpress.com/2008/11/boat.jpg&quot;) &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;我是p标签，我的颜色是红色，高度为100px，我的背景图是一艘小船。&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 重复：background-repeat background-repeat 指定如何重复背景图像，可设置属性值（关键字）： repeat：全区域重复 （即使不设置，背景图片默认全区域重复） repeat-x：沿x轴重复 repeat-y：沿y轴重复 no-repeat：不重复，只使用一次 herit：继承父元素的 background-repeat 属性值 滚动：background-attachment background-attachment 设置背景图片是 固定 的还是和 其余部分一起滚动 。可设置的参数（关键字）： scoll：默认值，背景图像会随着页面其余部分的滚动而移动 fixed：页面的其余部分滚动时，背景图像不会移动 inherit：从父元素继承 background-attachment 属性值 下面展示设置图片滚动的实例。 12345678910111213141516171819202122232425262728293031323334&lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; body &#123; background-image: url(&quot;https://wpdotorg.files.wordpress.com/2008/11/boat.jpg&quot;); background-repeat: no-repeat; background-attachment: scroll; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;div&gt;我是文本...&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 列表样式 项标记：list-style-type list-style-type 可用于设置列表每项标记，比如：· 、□ 、…，参数可用关键字设置： none,circle(空心原点), square(空心□), decimal(有序数字), disc(实心原点), lower-alpha(有序字母) ⚠️ 有序列表 除了默认数字decimal 作为标记，上面属性只能使用 lower-alpha 字母等有序标记 。 以下是为实例设置不同项目标记。 1234567891011121314151617181920212223242526272829&lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; ol.lower-alpha &#123; list-style-type: lower-alpha; &#125; ul.circle &#123; list-style-type: circle; &#125; ul.square &#123; list-style-type: square; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ol class=&quot;lower-alpha&quot;&gt; &lt;li&gt;w3cschool&lt;/li&gt; &lt;/ol&gt; &lt;ul class=&quot;circle&quot;&gt; &lt;li&gt;w3cschool&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;square&quot;&gt; &lt;li&gt;w3cschool&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 项标记-图像：list-style-image 、list-style-position 进一步我们还可以使用list-style-image 设置图像作为项标记，用 list-style-position 指定标记位置： list-style-position:inside：指定位置在内容流中❔ list-style-position:outside：默认值，指定位置不在内容流中❔ 设置项标记为指定图像，并设置在内容流中。 123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; ul &#123; list-style-image: url(&quot;https://www.w3cschool.cn/statics/images/favicon.ico&quot;); list-style-position: inside; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;w3cschool&lt;/li&gt; &lt;li&gt;w3cschool&lt;/li&gt; &lt;li&gt;w3cschool&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; list-style list-style 属性是设置 list-style-type*、list-style-image、*list-style-position 简写属性： 1234ul &#123; list-style: square outside none;&#125; 下方是未简化版本： 123456ul&#123; list-style-type: square; list-style-position: outside; list-style-image: none;&#125; 执行结果： 表格样式 属性 描述 boder 该属性可依次指定：边框大小、边框类型、边框颜色 border-collapse 是否把表格边框合并为单一的边框 border-spacing 分隔单元格边框的距离 width、height 设置表格宽高，可用px、em等，也可用百分比 % caption-side 表格标题的位置 empty-cells 是否显示表格中的空单元格 table-layout 显示单元、行和列的算法 更多设置： text-align 、vertical-align ：设置文本对齐方式，见前 padding ：设置表格中内容与边框的距离 边框 ：boder 可为表格、表格单元设置边框、以及颜色和粗细，比如存在以下表格： ⚠️这其实是盒模型边框 boder设置 ，因为表格table、表格单元th、td 其实也是元素，是盒模型结构。 12345678910111213141516171819202122&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;th&gt;Firstname&lt;/th&gt;&lt;th&gt;Lastname&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Bill&lt;/td&gt;&lt;td&gt;Gates&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Steven&lt;/td&gt;&lt;td&gt;Jobs&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 把整个表格、表格第一行单元、表格其它行单元设置为 ：1px粗、实框、蓝色。 1234table, th, td&#123; border: 1px solid blue;&#125; 注意：不能只选中 table 设置，这样只有表格最外层被设置蓝色边框。每个单元格也要被选中！ 给四边设置样式 在前面我们通过 border 属性来指定边框：颜色、样式、宽度，但是边框上下左右都是统一颜色样式等。 实际上，元素盒子模型中边框可分为上、右、下、左四个矩形区域。我们并且可通过下面属性分别指定： border-color：指定边框颜色，可依次按 上、右、下、左 顺序指定四边 border-style： 指定边框样式，可依次按 上、右、下、左 顺序指定四边 border-width：指定边框宽度，可依次按 上、右、下、左 顺序指定四边 试着分析写出下面图形CSS代码。 显然，背景颜色为白色，边框颜色都是黑色，边框样式也一致都为 solid ，而边框宽度明显下边宽度要和上、左、右不同需要单独设置。 12345678#yin-yang &#123; width: 96px; height: 48px; background: #eee; border-style: solid; border-width: 2px 2px 50px 2px;&#125; 进阶：尝试画出下面的阴阳图形。 首先我们只需将上例中正方形通过 border-radius 属性设置为圆形即可 ： 12345678910#yin-yang&#123; position: relative; width: 96px; height: 48px; background: #eee; border-style: solid; border-width: 2px 2px 50px 2px; border-radius: 100%;&#125; 然后我们再尝试生成下面小圆：内圆为白，外环为黑色。 123456789#yin-yang::before&#123; content: &quot;&quot;; position:absolute; background-color:#eee; width:12px; height:12px; border:18px solid black;&#125; 最后再把小圆下移到直径和大圆直径重合： 1234#yin-yang::before&#123; top:50%;&#125; 同理，再画出一个小圆：内圆为黑，外环为白色。 123456789101112#yin-yang::after&#123; content: &quot;&quot;; position:absolute; background-color:black; width:12px; height:12px; border:18px solid #eee; border-radius: 100%; top: 50%; left: 50%;&#125; 深入了解 border 属性：梯形 在上面你可能理解边框是由上下左右是个矩形组成。实际上它可通过border-top 、border-right 属性分为上下左右四个梯形区域，每个梯形区域由盒子 相邻 内容区域边 和 盒子最外边 组成。 请看下例：设置文本区域为长宽相等50px正方形，边界都厚度为50px 。 12345678910111213141516&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;div&#123; width: 50px; height: 50px; border: 50px solid red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如果我们分别修改边框上下左右颜色，便可以发现其实是由4个梯形组成： 123456789div&#123; width: 50px; height: 50px; border-top: 50px solid red; border-right: 50px solid yellow; border-bottom: 50px solid blue; border-left: 50px solid green;&#125; 进一步我们把文本内容区域高宽设置为0，那么四个边框矩形区域可变为三角形： 123456789div&#123; width: 0px; height: 0px; border-top: 50px solid red; border-right: 50px solid yellow; border-bottom: 50px solid blue; border-left: 50px solid green;&#125; 现在我们接着例举几个实例进一步理解border属性。 试分析：下面的右三角形是怎么画出的？ 过程其实很简单，首先在上面基础上，我们把上下两个三角形设为透明： 123456789div&#123; width: 0px; height: 0px; border-top: 50px solid transparent; border-right: 50px solid yellow; border-bottom: 50px solid transparent; border-left: 50px solid green;&#125; 然后删除掉border-bottom 属性，这样由于右侧三角形不存在，div 宽度自动减去原右三角形宽（厚）度，表现为保留原来的左半部分： 最终css 样式设置： 12345678div&#123; width: 0px; height: 0px; border-top: 50px solid transparent; border-bottom: 50px solid transparent; border-left: 50px solid green;&#125; 同理，试着实现下三角形。 12345678div&#123; width: 0px; height: 0px; border-top: 50px solid red; border-right: 50px solid transparent; border-left: 50px solid transparent;&#125; 折叠：border-collapse border-collapse 可将表格边框是否折叠成单一边框，可设置的属性（关键字）： seperate：默认值，折叠成单一表格，每个单元都有自己的完整边框（比如上面表格） collapse：不折叠，每个相邻单元边合并 设置每个相邻单元格边合并。 12345678table, th, td&#123; border: 1px solid blue;&#125;table&#123; border-collapse:collapse;&#125; 距离：border-spacing border-spacing 设置分隔单元格边框的距离： 设置格式：border-spacing ：水平单元格相邻距离 垂直单元格相邻距离 ⚠️ 只有在 border-collapse:seperate 设置分开才生效！ 设置表格：水平单元格相距10px，垂直单元格相距30px。 12345table&#123; border-collapse: separate; border-spacing:10px 30px ; &#125; 宽高：width、height width、height 可以设置table、th、td宽高： 基本长度单位：px，em… 百分比：如100%，表格可以占据整个宽度 表格宽度设置为 100%，同时将 th 元素的高度设置为 50px。 12345678910111213141516171819202122232425262728293031323334353637&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;table,td,th&#123; border:1px solid black; // 设置边框&#125;// 宽度==屏幕宽，水平单元格宽度 = 屏幕宽 / 水平单元格数// 但如果是选择单元格td、th来设置width:100%; 宽度并不会平分，而是第一个水平单元格占据尽可能多宽度table&#123; width:100%; &#125;th&#123; height:50px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;th&gt;Firstname&lt;/th&gt;&lt;th&gt;Lastname&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Bill&lt;/td&gt;&lt;td&gt;Gates&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Steven&lt;/td&gt;&lt;td&gt;Jobs&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 自动宽度：table-layout table-layout 可以当单元格宽度*未明确设置*时 （表宽度可指定），如果设置每列列宽： auto ： 当列或单元格宽度未明确设置时，列宽将与组成列的单元格中的内容量成比例 fixed ： 当列或单元格宽度未明确设置时，列宽将不受组成列的单元格中的内容数量的影响 123456789101112131415161718table&#123; border-collapse: separate; width: 100%; border: 1px solid gray;&#125; td &#123; border: 1px solid gray;&#125;table.auto &#123; table-layout: auto;&#125;table.fixed &#123; table-layout: fixed;&#125; 综合练习 请尝试实现下面表格样式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;#customers &#123; font-family:&quot;Trebuchet MS&quot;, Arial, Helvetica, sans-serif; width:100%; border-collapse:collapse; &#125;#customers td, #customers th &#123; font-size:1em; border:1px solid #98bf21; // 为什么不设置 #customers？没有效果，因为和单元格重叠 padding:3px 7px 2px 7px; // 设置文字离边框距离 &#125;#customers th &#123; font-size:1.1em; text-align:left; background-color:#A7C942; // 标题单元格背景设置为深绿 color:#ffffff; // 标题文字设置为白色，而不是默认黑色 &#125;// 设置奇数行默认背景色，含标题#customers tr:nth-child(2n+1) &#123; background-color:#EAF2D3; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table id=&quot;customers&quot;&gt;&lt;tr&gt;&lt;th&gt;Company&lt;/th&gt;&lt;th&gt;Contact&lt;/th&gt;&lt;th&gt;Country&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Apple&lt;/td&gt;&lt;td&gt;Steven Jobs&lt;/td&gt;&lt;td&gt;USA&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;alt&quot;&gt;&lt;td&gt;Baidu&lt;/td&gt;&lt;td&gt;Li YanHong&lt;/td&gt;&lt;td&gt;China&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Google&lt;/td&gt;&lt;td&gt;Larry Page&lt;/td&gt;&lt;td&gt;USA&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 链接样式 我们可以根据前面学的： 文本样式：设置链接文字样式，比如去除下划线 text-decoration:none; 盒模型：设置链接的边框、宽高等，比如 boder : 2px solid green 背景图：设置链接的背景图等 … 同时比较特殊的是：我们可以定义链接不同状态下样式： a:link ： 普通的、未被访问的链接 a:visited ： 用户已访问的链接 a:hover ： 鼠标指针位于链接的上方 a:active ： 链接被点击的时刻 综合练习 尝试实现如下样式的导航栏。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;/* 步骤1：设置基本导航栏div区域背景色、高宽*/#menu&#123; background-color: #34495e; // 直接设置区域背景色 width: 100%; height: 40px;&#125;/* 步骤2：设置表格，去除列表项标记等 Q1:为什么要设置：overflow: hidden？ 因为ul元素子元素li 为了可以在一行显示设置了向左浮动。 设置overflow: hidden可以让ul包含li，而不是不显示了。*/ul&#123; list-style-type:none; margin:0; padding-left: 60px; overflow: hidden; /*可以使用overflow:hidden;技术让父元素包含浮动子元素*/&#125;/*li标签默认是块，为了在一栏显示，设置为float浮动*/li&#123; float:left; &#125;/* 步骤3：设置链接基本样式。 Q1:为什么设置display: block？ 1.可以让a标签整个区域被点击（而不是只有文字）2.可以设置a标签宽度、高度 Q2:为什么设置line-height: 40px; ？ 为了让文字垂直居中。水平居中不能解决垂直居中，而vertical-align: middle不起作用。 当然，也可以尝试设置 padding来模拟居中。 */a:link,a:visited&#123; display: block; width: 130px; /* 设置a标签宽度 == div宽度，点击后整个区域都可以点击*/ height: 40px; /* 高度 = 行高，可使得文字居中。直接vertical-align: middle;只能是表格单元格内起作用 */ // vertical-align: middle; line-height: 40px; text-decoration: none; text-align: center; color: white;&#125;/*a:focus 可以保证点击后背景一直是红色，直到点了其它导航项目*/a:hover,a:focus&#123; background-color: red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&#x27;menu&#x27;&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;#home&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#news&quot;&gt;News&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#about&quot;&gt;About&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 定位与布局 内联与块：display 网页上的每个元素都是一个盒模型，每个元素默认为块 或者内联行为方式： 块元素：尽可能 占据最大宽度，独占一行、前后有 换行符 ，width、height 可设置 常用如：div、p、h1~h6、ol、ul、table、from 等 内联元素：占据内容宽度，不独占一行、 不强制换行 ，width、height 不可设置 常见如：span、a、img 等 display 属性可决定盒模型元素的 行为方式 ： display:block ：使得元素行为方式为块 display:inline ：使得元素行为方式为内联 display:inline-block ：使得元素行为方式为内联-块 ，在内联的基础上又可以设置框高 display:none ：隐藏 一个元素，不占用任何空间 (visibility:hidden 占用空间 ) ，好像它不存在一样。 显隐：visibility visibility 用来设置元素是显示还是隐藏的，可设关键字： visibility:visible ：元素可见 visibility:hidden ：元素不可见，但是它占据的空间还存在 ，依然会影响布局 定位：position position 允许我们定位一个元素，常见定位方式有： static：静态默认定位， 定位元素总是按照页面的正常流动进行定位，忽略left、rigth等设置位置！ fixed： 固定定位，即使窗口被滚动也不会移动，可设置垂直或水平位置，相对于浏览器窗口定位 relative：相对定位，可设置垂直或水平位置，相对于它自身的起点位置定位 absolute ：绝对定位，可设置垂直或水平位置，相对最近已定位祖先元素 或者最初包含块 设置后在 原文档流中被完全删除，原占据空间关闭，好像不存在一样 因为绝对定位的框与文档流无关，可覆盖页面上的其它元素，通过 z-index 属性来设置 设置垂直或水平位置，通过属性：top、bottom、left、right 来设置： 必须要先对 position属性进行初始化设置定位方式才能使用！ position:stactic 设置的元素，top、bottom、left、right 会被忽略！ 固定定位：fixed 实例：固定定位后，div-a 移动到相对浏览器窗口指定位置，原来位置被填充。 脱离文档流，原空间不保留，随滚动条改变位置 相对浏览器窗口（左上角）位置定位 相对定位：relative 实例：相对定位后，div-a 移动到相对自身在文档流的指定位置，原来位置保留。 不脱离文档流，原空间保留 相对自身起点（左上角）定位 绝对定位：absolute 实例：绝对定位后，div-a 移动到相对浏览器窗口（最近包含块）指定位置，原来位置被填充。 脱离文档流，原空间不保留，但不随滚动条改变位置 相对最近已定位祖先元素定位，如果没有则相对最初包含块定位 重叠：z-index 如果两个元素发生重叠，可以通过设置z-index 属性改变层叠次序。定位元素沿 z 轴的位置，z 轴定义为垂直延伸到显示区的轴： 默认z-index = 0， z-index 值越大，则沿着z 轴正轴越远，离用户越近 z-index 属性必须要在设置了position 才能生效。（除了不能设置position:static ） 试着改变下面重叠红、蓝方块次序，把蓝色方块显示在上面。 123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt; &lt;style&gt; .blue &#123; background-color: #8EC4D0; width: 60px; height: 60px; &#125; .red &#123; background-color: #FF4D4D; width: 60px; height: 60px; margin-top: -30px; margin-left: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;blue&quot;&gt;blue&lt;/div&gt; &lt;div class=&quot;red&quot;&gt;red&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，初始两个div方块按照 后到显示在前 ，所以红色方块显示在前。 我们可以设置 .blue 的 position 属性为 relative （fixed、absolute 也可以，但是由于脱离文档流红色方块会上移动不方便设置）；然后增大它的 z-index 为 1。 ⚠️ 不用设置红色方块 .red 的 position 属性?? 12345678.blue&#123; background-color: #8EC4D0; position: relative; width: 60px; height: 60px; z-index:1 &#125; 浮动：float 无论多么复杂的布局，基本出发点：如何在一行显示多个div元素 。这就用到了浮动，浮动只有两个关键字设置： left：左浮动 right：右浮动 设置为浮动的框，会脱离文档流向左或向右移动，它们的移动规则是： 多个元素浮动，从上至下依次向左、向右浮动 假设 div 元素A是浮动的，如果A元素上一个元素也浮动则紧跟其后（如果一行能放下）；如果A元素上一个元素不浮动（是标准流中元素），那么相对垂直位置不会改变（顶部和其底部同一条水平线，但可以对应左、右移动） 浮动元素总是飘浮在标准流之上（理解为z-index大） 比如，存在下图4个非浮动div 元素： 设置 div2 ：向右浮动，试分析结果？ 首先，div2 脱离标准流所以释放空间，下方div3、div4 向上移动。而div2 上一个块元素div1 不是浮动元素，所以相对div2 垂直位置不变（顶部和其底部同一条水平线，表现为不向上浮动），但是会向右浮动，故最后结果是： 设置div2、div3、div4：向右浮动，试分析结果？ div2、div3、div4 都脱离标准流，多个元素浮动，从上至下则div2先右浮动，由于div2 上一个元素div1 不浮动故保持相对垂直位置不变（表现为不上浮），整体只移动到右端。 然后div3 向上浮动，由于它的上一个元素div2 是浮动的，所以紧靠其后。div4同理，紧靠div3 后。 故最终结果是： 浮动与文字 首先我们观察网页：设置图片向左浮动后，生成的文字环绕图片。 123456789101112131415161718192021&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;img &#123; float:left;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3388481411,1093632805&amp;fm=26&amp;gp=0.jpg&quot; /&gt;&lt;p&gt;...余告之曰：其形也，翩若惊鸿，婉若游龙。荣曜秋菊，华茂春松。髣髴兮若轻云之蔽月，飘飖兮若流风之回雪。远而望之，皎若太阳升朝霞；迫而察之，灼若芙蕖出渌波。秾纤得中，修短合度。肩若削成，腰如约素。延颈秀项，皓质呈露。芳泽无加，铅华弗御。云髻峨峨，修眉联娟。丹唇外朗，皓齿内鲜。明眸善睐，靥辅承权。瓌姿艳逸，仪静体闲。柔情绰态，媚于语言。奇服旷世，骨像应图。披罗衣之璀粲兮，珥瑶碧之华琚。戴金翠之首饰，缀明珠以耀躯。践远游之文履，曳雾绡之轻裾。微幽兰之芳蔼兮，步踟蹰于山隅。于是忽焉纵体，以遨以嬉。左倚采旄，右荫桂旗。攘皓腕于神浒兮，采湍濑之玄芝。余情悦其淑美兮，心振荡而不怡。无良媒以接欢兮，托微波而通辞。愿诚素之先达，解玉佩而要之。嗟佳人之信修，羌习礼而明诗。抗琼珶以和予兮，指潜川而为期。执眷眷之款实兮，惧斯灵之我欺。感交甫之弃言兮，怅犹豫而狐疑。收和颜而静志兮，申礼防以自持。...&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; ❔ 令人困惑的是：图片设置浮动已经脱离文档流不应该释放了空间不再影响布局了，为什么文字还能环绕它呢？ 就像我们修改图片为绝对定位： 1234img &#123; position: absolute;&#125; 文字不再环绕，而是好像当图片不存在一样： 这也就是绝对定位和浮动的最大区别，虽然它们都脱离了文档流： 绝对定位不会影响布局好像它不存在一样；但浮动会影响布局，其它内容（包括元素？）会围绕它 。 清除浮动：clear 经过上面浮动学习：元素浮动之前在标准流中，是 竖向排列 的，而浮动之后可以理解为 横向排列。 而清除浮动可以 打破横向排列 ，但是 清除浮动只能在需要被影响的元素内使用 ，请看下例： 已知下列 div1、 div2 元素都是左浮动从而在一行显示，如何使 div2 移至下一行打破横向排列？ 如果我们增加CSS 样式，设置 div1 右边不允许有浮动元素： 1234.div1&#123; clear:right;&#125; 很不幸，这是不起作用的！我们希望div2 移动到下一行，那么被影响的是 div2，所以只能设置 div2 左边不允许存在浮动元素： 1234.div2&#123; clear:left;&#125; 这样就可以使得 div2 向下移动一行。 那么，下列 div1、 div2 元素都是右浮动，如何使得div2 移至 div1 下边呢？ 同上，被影响的是 div2 元素，那么不允许 div2 右边存在浮动元素即可： 1234.div2&#123; clear:right;&#125; 溢出：overflow 当父元素不设置高度时候，高度随内容增加自适应高度。但是当我们指定了父元素的高度，如何解决内容增加溢出问题呢？ 1234567891011121314151617&lt;html&gt;&lt;head&gt;&lt;style&gt; div &#123; width: 850px; height: 60px; background-color: LightBlue; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;none&quot;&gt; 苏子愀（qiǎo）然，正襟危坐，而问客曰：“何为其然也？”客曰：“‘月明星稀，乌鹊南飞’,此非曹孟德之诗乎？西望夏口，东望武昌。山川相缪(liáo)，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳(zhú)舻(lú)千里，旌(jīng)旗蔽空，酾(shi)酒临江，横槊(shuò)赋诗，固一世之雄也，而今安在哉?况吾与子渔樵(qiáo)于江渚(zhǔ)之上，侣鱼虾而友麋(mí)鹿,驾一叶之扁舟，举匏（páo）樽以相属（zhǔ）。寄蜉(fú)蝣(yóu)于天地，渺沧海之一粟(sù)。哀吾生之须臾(yú)，羡长江之无穷。挟（xié）飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。” &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们可以通过设置overflow 属性值（关键字）： visible：默认值，超出内容依旧可以显示但是会溢出框 scroll：阻止溢出框，超出部分可以拖动滚动条显示（无论是否溢出都显示滚动条） hidden：隐藏内容溢出部分，溢出部分不可见 auto：如果内容溢出自动出现滚动条阻止溢出 overflow：hidden &amp; 浮动 &amp; 崩塌 overflow：hidden 在前面我们介绍可以隐藏溢出内容，它还有以下功能： 清除浮动：解决由于父元素不设置高度，子元素都是浮动元素使得父元素高度为0的问题 解除坍缩：解决父、子元素非浮动元素，第一个子元素设置margin-top属性 ，等价父元素设置该属性问题 清除浮动 在前我们知道，父级元素 不设置高度时，高度随着内容增加自动适应。 但是当子元素此时设置了浮动float ，由于子元素已经脱离了文档流，父元素检测不到子元素高度，那么父元素高度 == 0。 子元素浮动依旧显示，只是父元素高度为0好似隐藏了 如果设置了父元素高度，子元素可以重新显示，超出部分溢出 比如下面黑色父级div包含了两个蓝、红子级div 。 1234567891011121314151617181920212223242526272829&lt;html&gt;&lt;head&gt;&lt;style&gt; .div &#123; background-color: black; &#125;.div1&#123; background-color: aqua; width: 100px; height: 100px;&#125;.div2&#123; background-color: red; width: 100px; height: 100px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;div&quot;&gt; &lt;div class=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如果我们把两个子级div 设置为浮动： 1234.div1,.div2&#123; float:left;&#125; 神奇的发现子级div1、div2 存在而黑色父级div 消失了！其实也就是高度变为0了。 我们有三种解决办法： 第一种：给父元素设置高度 = 100，使得父级元素不因为子元素都为浮动元素，高度自动=0 第二种：黑色父级div 设置 overflow：hidden ，使得父级元素可以包含浮动子元素 父级div 出现了，允许子元素为浮动元素：高度为子元素高度，宽度因为div 是块元素占据一行。 第三种：设置 父元素为浮动 float:left，注意这种方法会使得父元素不再有块 独占一行 的特性 乍看好像父级元素没有出现，但我们审查元素可发现div 父级标签：高度 = 子元素高度，宽度也因为设置浮动不再独占一行自动调整为子元素宽度。 特别的：如果我们设置父元素为浮动 float:right，而子元素都是左浮动，会以父元素为准： 避免崩塌 首先我们来认识什么是崩塌？依旧以最开始示例为例： 我们尝试给第一个子元素 div1 设置外边距上为50px： 1234.div1&#123; margin-top:50px;&#125; 我们期待得到的效果是： 但实际是： 就好像是给父级元素div 设置了：margin-top:50px 。要解决这个问题我们可以： 给父元素div 设置 overflow：hidden ，这样可以得到我们期待的效果 由上我们得知满足崩塌的条件： 父元素、子元素都不是浮动元素 第一个子元素设置了 margin-top属性 聪明的你也已经想到，如果子元素是浮动元素也可以完全避免崩塌（无论父元素是否浮动）。这里不详述。 第二部分：CSS3 基础样式 圆角：border-radius 我们知道在CSS世界里，万物皆为框，每个元素都可视作为框。通过 border-radius 属性可指定圆半径为R，把元素框 R*R正方形四角换成 ----&gt; 半径为 R的1/4圆形。 怎么理解 把元素框正方形四角换成1/4圆形 ？ 比如我们指定div 元素：宽 = 150px，高 = 100px ，圆半径为50px 。 可以看到，原 150px*100px 矩形，它对应四角 50px*50px 矩形区域被替换成半径 = 50px 的半圆。 ⚠️ 必须设置：圆半径 ≤ {1/2 宽，1/2 高} min ，如果超过则形成图形等价于：圆半径 = {1/2 宽，1/2 高}min 那么怎么生成圆形呢？ 显然，当框宽高相等恰为正方形，我们在把生成的四个1/4圆半径 = 1/2正方形边长。那么便可形成圆形。 1234567div&#123; width: 150px; height: 150px; background-color:aquamarine; border-radius: 75px;&#125; 进一步理解 在前面我们理解border-radius 属性为： 指定圆半径为R，把元素框 R*R正方形四角换成 ----&gt; 半径为 R的1/4圆形： 1border-radius: 50px; 实际应该为： 指定长、短半径为R1、R2，把元素框 R1*R2矩形四角换成 ----&gt; 长、短半径分别为 R1、R2的1/4椭圆形： 1border-radius: 50px / 40px; /* 只指定其中一个长度，则长短半径相等，也就是1/4圆 */ 甚至你还可以依次指定：左上 --&gt; 右上 --&gt; 右下 —&gt; 左下的1/4椭圆长短半径（顺时针） 1border-radius: 50px 40px 30px 20px / 40px 30px 20px 10px ; 尝试把指定div 元素：宽 = 150px，高 = 100px ，变为椭圆形 。 显然，只要把四角：长半径 = 1/2 宽，短半径 = 1/2 高的四个1/4椭圆形即可： 1234567div&#123; width: 150px; height: 100px; background-color:aquamarine; border-radius: 75px / 50px;&#125; 伪元素 ::before、::after 在前面我们有一个概念叫做 伪类 ，一种用来描述状态的关键字 ： 常用伪类：:hover、:link、:active、:target、:not()、:focus 等 而常用伪元素有： 常用伪元素：::first-letter、::first-line、::before、::after、::selection 等 其中伪元素 ::before、::after，特有content样式用来给内容元素 前、后 插入额外的元素 。 为什么称伪元素为 “伪” ？它有什么特点呢？ 无法审查：实际在DOM文档中没有生成这些元素，只是表面可见，审查元素没有生成 content ：特有content样式，用于添加内容，可以为空但不能省略！ 利用伪元素可以做出一些非常有意思的功能，比如各种图形、小图标等。 生成图形：菱形、六角星等 试分析：下面菱形生成代码。 123456789101112131415161718192021#test&#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 50px solid red; position: relative;&#125;#test:after &#123; content: &#x27;&#x27;; position: absolute; left: -50px; top: 50px; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 50px solid red; &#125; 生成上三角 123456789#test&#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 50px solid red; position: relative;&#125; 根据前面 border 属性设置我们可以这么生成上三角： 宽高设置为0后，上下左右四个边框角都设置为： 1border-x: 50px solid transparent; 然后 border-bottom 、 border-top颜色设置为红色，border-left、border-right 设置为透明： 最后删除掉border-top 属性设置，使得只保留下半部分，至此成功生成上三角： 最后设置的 position: relative 属性是为了方便接下来生成的伪元素进行绝对定位。 生成下三角 照猫画虎我们生成一个下三角： 12345678910#test:after &#123; content: &#x27;&#x27;; /* 为空，但不能省略*/ position: absolute; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 50px solid blue;&#125; 看到这我们对生成的下三角的初始位置不禁有些疑惑： 下三角伪元素是绝对定位：即相对于最近设置了position属性的祖先元素 ，如果没有则是包含它的框。 按照这个理论，#test 并不是 #test::after 的祖先元素为什么还相对它定位呢？ 这个不太清楚暂不提。 为什么 #test::after 绝对定位起点是*#test* 上中心点（红色三角形顶点）？不应该是左上角吗？ 第一：绝对定义不是相对于元素框的左上角，而是内容部分左上角。 第二：由于内容部分为0，所以内容左上角就是框中心点。 第三：又因为框上半部分没有，中心点上移，也就是现在红色三角形的顶点。 调整定位 最后我们调整一下生成的下三角形在上三角下方，即可生成一个菱形： 123456#test:after&#123; left: -50px; top: 50px; border-top: 50px solid red;&#125; 制作小图标 尝试制作做下面：列表左侧下三角下拉图标，注意大小。 123456789101112131415161718192021222324252627282930313233343536&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;div ul&#123; position: relative;&#125;#catalog ul::before&#123; content: &quot;&quot;; position: absolute; width: 0px; height: 0px; border-top: 8px solid red; border-right: 8px solid transparent; border-left: 8px solid transparent; left: 18px; top: 6px;&#125;div ul li&#123; text-indent: 12px; list-style-type: none;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;catalog&quot;&gt; &lt;ul&gt;我是下拉框 &lt;li&gt;我是下拉1&lt;/li&gt; &lt;li&gt;我是下拉2&lt;/li&gt; &lt;li&gt;我是下拉3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://hwh.zone/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://hwh.zone/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://hwh.zone/tags/CSS/"}]},{"title":"前端基础（一）JavaScript基础笔记（下）","slug":"前端基础（一）JavaScript笔记（下）","date":"2021-11-25T10:44:17.432Z","updated":"2021-11-25T12:47:50.024Z","comments":true,"path":"2021/11/25/前端基础（一）JavaScript笔记（下）/","link":"","permalink":"https://hwh.zone/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"第五章：浏览器 5.1 浏览器常用对象 window window 对象不但充当全局作用域，而且表示 浏览器窗口，常用属性如下： 属性名 作用 innerWidth 内宽度，不包含菜单栏、工具栏等占位元素 innerHeight 内高度，不包含菜单栏、工具栏等占位元素 screen screen 对象表示 屏幕 的信息，常用属性有： 属性名 作用 width 屏幕宽度，以像素为单位 height 屏幕高度，以像素为单位 colorDepth 颜色位数，如16 navigator navigator 对象表示 浏览器 信息，常用属性有： 属性名 作用 appName 浏览器名称 appVersion 浏览器版本 language 浏览器语言 platform 操作系统类型 userAgent 浏览器设定的 user-Agent 字符串 location location 对象表示 当前页面URL 信息，常用属性有： 以 http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP 为例。 属性名 作用 href 完整地址：上面全部蓝字域名 protocol 协议名： http host 域名： www.example.com port 端口： 8080 pathname 路径名： /path/index.html search 查询？：?a=1&amp;b=2 hash 哈希？：TOP 还可以利用对象方法： 方法名 实例 reload() location.reload(); // 重新加载当前界面 assign() location.assign(‘https://www.baidu.com’); // 当前界面打开百度，必须带有协议类型！ history 已不推荐使用，简单介绍常用方法： 方法名 实例 back() history.back() // 相当点击浏览器后退按钮 forward() history.forward() // 相当点击浏览器前进按钮 不推荐使用的一个实例场景。 如果我们在登陆成功调用 history.back() 试图回到登陆前界面，又要重新登陆了！ document document 对象是浏览器中 DOM树根节点 ，可利用它进行操作DOM、获取cookie等，常用属性如下： 属性名 实例 cookie document.cookie() // 获取 cookie 更多操作DOM，详见下节分解。 5.2 操作DOM 1.获取节点 getElementBy…() 获取节点 注：标签也可称为元素、节点。 方法名 作用 getElementById() 根据 标签ID属性 来获取节点 getElementByName() 根据 name属性 来获取节点 getElementByClassName() 根据 标签class属性 来获取节点 getElementByTagName() 根据 标签名 来获取节点，如div、img 一些简单操作实例。 123456789// 返回ID为&#x27;test&#x27;的节点：var test = document.getElementById(&#x27;test&#x27;);// 获取节点test下的所有直属[子节点]:var cs = test.children;// 获取节点test下第一个、最后一个[子节点]：var first = test.firstElementChild;var last = test.lastElementChild; CSS选择器获取节点 我们也可以利用 CSS选择器 selector 语法来获取节点： 方法名 作用 querySelector(selector) 获取满足条件的第一个节点 querySelectorAll(selector) 获取满足条件的所有节点 基本选择器用法： 选择器类型 用法 标签选择器：标签名 document.querySelector(“div”) // 获取第一个div标签节点 类选择器：.类名 document.querySelector(“.key”) // 获取第一个class = key节点 ID选择器：#ID名 document.querySelector(“#uid”) // 获取第一个ID = uid 节点 属性选择器：[属性=属性名] document.querySelector(“[type=text]”) // 获取第一个name =&quot; text&quot; 节点 层级选择器 我们还可以进行选择器组合筛选指定元素后代： 关系选择器组合 作用 A B 匹配A元素中的子元素B，B可以是A 任意级别后代 A &gt; B 匹配A元素中的下级子元素B，只能是 直系后代 A + B 匹配A元素中的任一下一个兄弟元素B（同级） B ~ E 匹配B元素后面的拥有共同父元素的兄弟元素E 过滤器 过滤器一般不单独使用，附加到选择器上更精确定位元素 ：&lt;选择器&gt;：&lt;元素状态关键字&gt; ⚠️ 在jQuery 中冒号： 和选择器前一定要有空格！ 12$(&#x27;#test-form:radio&#x27;); // 错误写法：无法选择表单中单选框$(&#x27;#test-form :radio&#x27;); // 正确写法，要有空格！ 指定选定元素处于何种状态时的CSS样式 。 指定a标签处于各种状态的样式 以 在CSS中修改不同状态a 标签颜色为例。 1234567891011// link-匹配当前元素连接a :link &#123;color: slategray;&#125;// visited-匹配已访问过的连接a :link &#123;color: #4b2f89;&#125;// active-匹配元素当中激活状态（鼠标悬停）的链接a :active &#123;color: blue;&#125; // hover-匹配元素当中未激活状态的链接a :hover &#123;color: blue;&#125; 匹配一组兄弟元素某元素 分类 实例 :first-child 匹配一组p标签第一个p标签：p:first-child :nth-child() 匹配一组p标签第一个p标签：p:nth-child(1) 匹配表格中的奇数行：tr:nth-child(2n+1) 匹配表格中的偶数行：tr:nth-child(2n) 更多：:nth-last-child(an + b)、:nth-of-type(an+b)、:last-of-type … 表单相关 分类 实例 :input 选择 表单 以下标签：&lt;input&gt;，&lt;textarea&gt;，&lt;select&gt;和&lt;button&gt; :enabled 选择 表单 可以正常输入的&lt;input&gt;、&lt;select&gt; ：$(‘#test-form :enabled’) :disabled 选择 表单 那些不能输入的 &lt;input&gt;、&lt;select&gt;：$(‘#test-form :disabled’) :file 选择文件： input : file === input[type=file] :checkbox 选择复选框：input : checkbox=== input[type=checkbox] :radio 选择单选框：input : radio === input[type=radio] :focus 选择当前输入焦点：例如把光标放到一个&lt;input&gt;上，$(‘input:focus’) 便可选中 :checked 选择当前勾上的单选框和复选框：$(‘input[type=radio]:checked’) 选择表单id = test-form 下所有 &lt;input&gt;，&lt;textarea&gt;，&lt;select&gt;和&lt;button&gt; 节点。 12// 无法用：document.querySelectorALL(&#x27;#test-form :input&#x27;) ？？$(&#x27;#test-form :input&#x27;); 其它更多 分类 实例 :empty 匹配没有子元素的元素 :target 用于匹配URI中的ID标识（即：锚点）部分 获取节点基本信息 1&lt;input type=&quot;text&quot; id=&#x27;user&#x27;&gt; 可以获取基本属性等信息，不存在的属性字符串类型返回空字符串 “” ，布尔类型默认返回 false： 123456789101112var u = document.querySelector(&#x27;#user&#x27;);// 获取存在的属性u.type; // &quot;text&quot;u.id; // &quot;user&quot;// 获取不存在的属性u.name; // &quot;&quot;u.checked; // false// 文本框值u.value ; // &quot;hwh&quot;，已经在文本框中输入hwh 2.更新DOM 更新DOM节点文本 我们常用以下属性对DOM节点文本内容进行修改： 属性名 用法 innerHTML 可以插入HTML标签 &amp; 字符串 innerText 只能插入字符串，插入HTML标签会解析成字符串 textContent 同上，但会返回所有文本包括隐藏文本 更新标签、字符串实例。 1&lt;div id=&quot;content&quot;&gt; test &lt;/div&gt; 1234567891011var c = document.getElementById(&#x27;content&#x27;);c.innerText; // 输出：&quot;test&quot;// 1.插入HTMLc.innerHTML = &#x27;&lt;p&gt; hello test!&lt;/p&gt;&#x27;; // 打开浏览器div标签内输出：hello test!// 2.插入字符串c.innerText = &#x27;&lt;p&gt; hello test!&lt;/p&gt;&#x27;; // 打开浏览器div标签内输出：&lt;p&gt; hello test!&lt;/p&gt;// 3.插入字符串c.textContent = &#x27;&lt;p&gt; hello test!&lt;/p&gt;&#x27;; // 打开浏览器div标签内输出：&lt;p&gt; hello test!&lt;/p&gt; 更新CSS样式 获取节点后，利用 style 属性进行样式设置。 属性名 用法 style DOM节点 style 属性对应所有的CSS，可直接获取OR设置。 进行简单CSS样式设置。 12345var c = document.getElementById(&#x27;content&#x27;);// 设置CSSc.style.color = &#x27;#ff0000&#x27;;c.style.fontSize = &#x27;1200px&#x27;; ⚠️ 注意 fontSize 等在javaScript 中是驼峰命名，而在CSS中是 font-size ！ 3.插入DOM 在前我们利用：c.innerHTML = '&lt;p&gt; hello test!&lt;/p&gt;'; 可以在&lt;div&gt; ... &lt;/div&gt;插入HTML标签，但是会替换掉里面所有DOM节点内容。 为此我们可以利用以下方法： 方法名 用法 appendChild(newElem) 添加子节点newElem 为当前父节点对象 最后一个子节点 insertBefore(newElem，ref) 添加子节点newElem 为当前父节点对象 另一个子节点ref前 下面为预设好的HTML结构： 123456&lt;ul id=&quot;programLanguage&quot;&gt; &lt;li id=&quot;C#&quot;&gt;C#&lt;/li&gt; &lt;li id=&quot;C&quot;&gt;C&lt;/li&gt; &lt;li id=&quot;python&quot;&gt;python&lt;/li&gt; &lt;li id=&quot;java&quot;&gt;java&lt;/li&gt; &lt;/ul&gt; 创建一个新节点：&lt;li id=&quot;javascript&quot;&gt;javascript&lt;/li&gt; 插入到列表末尾。 123456789var ul_pl = document.getElementById(&#x27;programLanguage&#x27;);// 创建一个新节点var li_js = document.createElement(&#x27;li&#x27;);li_js.id = &#x27;python&#x27;;li_js.innerText = &#x27;javaScript&#x27;;// 插入到末尾ul_pl.appendChild(li_js); 创建一个新节点：&lt;li id=&quot;C++&quot;&gt;C++&lt;/li&gt; 插入到列 python 前。 12345678910var ul_pl = document.getElementById(&#x27;programLanguage&#x27;);var li_py = document.getElementById(&#x27;python&#x27;);// 创建一个新节点var li_cpp = document.createElement(&#x27;li&#x27;);li_cpp.id = &#x27;C++&#x27;;li_cpp.innerText = &#x27;C++&#x27;;// 插入到末尾ul_pl.insertBefore(li_cpp,li_py); 4. 删除DOM 要删除一个节点，首先要获得该节点本身以及它的父节点，然后调用父节点的removeChild()把自己删掉： 删除指定列表第三个节点。 123456var ul_pl = document.getElementById(&#x27;programLanguage&#x27;);// 获取列表第三个子节点var li3 = ul_pl.children[2];// 调用该付节点删除该子节点ul_pl.removeChild(li3); ⚠️ 注意： DOM树中节点虽然被删除，但是还在内存中，可以随时被添加到别的位置 children属性 实时变化，删除后父节点.chidren返回的列表会对应减少 5.3 操作表单 常用表单元素 &lt;form&gt; 元素定义 HTML 表单，收集用户输入 ：&lt;form&gt;... 表单元素...&lt;/form&gt; 。以下是常用表单元素： 常用表单元素 表单元素 描述 &lt;input&gt; 最重要的表单元素，含有不同类型的 input 元素 、复选框、单选按钮、提交按钮等。 &lt;select&gt; 定义下拉列表： &lt;textarea&gt; 定义多行输入文本域： &lt;button&gt; 按钮：点击后出发onclick事件代码，输出Hello World! 不同类型的 input 元素 ：有复选框、单选按钮、提交按钮等： 常用input类型 类型 描述 text 文本输入：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; password 密码输入：&lt;input type=&quot;password&quot; name=&quot;psw&quot;&gt; submit 提交表单按钮：&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; radio 单选按钮： ○Male ○Female （多个单选按钮组合成 多选一 ，name要相同） checkbox 复选框：□ I have a bike □ I have a car button 和前表单元素button类似，但没有后面&lt;/button&gt;： number 输入数值，并可对其作出限制： date 包含日期的输入字段： color 颜色选择器会出现输入字段： 更多输入类型：time（时间选择器）、datetime &amp; datetime-local（日期选择器）、search（搜索字段类似文本字段）、tel &amp; url &amp; email （可自动验证是否是电话、网址、邮箱地址） 操作表单 操作值 对于 text、password、hidden以及select 等直接value 获取、设置值即可： 12345// &lt;input type=&quot;text&quot; name = &quot;username&quot;&gt;var input = document.getElementsByName(&#x27;username&#x27;);input.value; // 用户输入值input.value = &quot;hello!&quot;; // 设置值 对于 radio 、checkbox，如果获取 value 始终是预设值，不能获取用户输入选择值。 应该用节点 checked属性判断用户选中： 1234567891011121314/*&lt;form&gt;&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; id=&quot;b&quot; value=&quot;Bike&quot;&gt;I have a bike&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; id=&quot;c&quot; value=&quot;Car&quot;&gt;I have a car &lt;/form&gt; */var bike = document.getElementsById(&#x27;b&#x27;);if(bike.checked)&#123; // do something&#125; bike.checked = false; // 设置按钮未被选中 提交表单 HTML 表单用于收集用户输入，比如下例收集用户输入的账号、密码验证登陆： 提交表单一般有如下三种方法： 通过 按钮提交 通过 form 对象 submit() 方法提交 ajax 方式提交 type=“submit” 表单提交 12345&lt;form action=&quot;demo_form.asp&quot; id=&quot;demo_form&quot; style=&#x27;text-align: center&#x27; method=&quot;GET&quot;&gt; &lt;p&gt;用户：&lt;input type=&quot;text&quot; id=&#x27;user&#x27; name=&#x27;user&#x27;&gt; &lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; id=&#x27;pwd&#x27; name = &#x27;pwd&#x27;&gt;&lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;立即登陆&quot; style=&#x27;width:210px&#x27;&gt; &lt;/form&gt; action 属性：定义提交表单执行的动作，如果省略则会被置为当前页面。在这里提交的表单值会交给脚本代码 demo_form.asp 处理。 method 属性：定义提交方式为GET 或者 POST 点击 立即登陆 按钮后，会自动把表单值提交给脚本文件 demo_form.asp 处理 。 服务器接收到的提交内容为（GET 方式提交）： 1user=hwh&amp;pwd=123456 ⚠️ 只有设置 name 属性的表单值才会被提交，提交的值构造方式为：name1:value1&amp;name2:value2… submit() 方法提交 可以通过：点击button、点击链接 等方式触发事件，js 调用form DOM对象submit() 方法提交表单数据。 ⚠️ 不推荐这种方式，扰乱了原有浏览器提交表单。 12345&lt;form action=&quot;demo_form.asp&quot; id=&quot;demo_form&quot; style=&#x27;text-align: center&#x27; method=&quot;GET&quot;&gt; &lt;p&gt;用户：&lt;input type=&quot;text&quot; id=&#x27;user&#x27; name=&#x27;user&#x27;&gt; &lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; id=&#x27;pwd&#x27; name = &#x27;pwd&#x27;&gt;&lt;/p&gt; &lt;input type=&quot;button&quot; id=&#x27;btn&#x27; value=&quot;立即登陆&quot; onclick=&quot;submitForm()&quot; style=&#x27;width:210px&#x27;&gt; &lt;/form&gt; 和前面 type=“submit” 表单提交方式 对比，type=“submit” 被修改为 —&gt; type=“button” button 按钮设置了属性 onclick ，绑定click 事件执行 submitForm() 函数。 12345var form = document.getElementById(&quot;demo_form&quot;);function submitForm()&#123; form.submit();&#125; 也可用 jQuery 实现 ： 123456789var form = $(&quot;#demo_form&quot;);var button = $(&quot;#btn&quot;);button.click( function() &#123; form.submit(); &#125;); 服务器接收到的提交内容为（GET 方式提交）： 1user=hwh&amp;pwd=123456 ajax 提交 ajax 方式提交需要先理解 5.5 AJAX 一节。 html 代码部分： 12345&lt;form action=&quot;&quot; id=&quot;demo_form&quot; style=&#x27;text-align: center&#x27; method=&quot;GET&quot;&gt; &lt;p&gt;用户：&lt;input type=&quot;text&quot; id=&#x27;user&#x27; name=&#x27;user&#x27;&gt; &lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; id=&#x27;pwd&#x27; name = &#x27;pwd&#x27;&gt;&lt;/p&gt; &lt;input type=&quot;button&quot; id=&#x27;btn&#x27; value=&quot;立即登陆&quot; onclick=&quot;submitForm()&quot; style=&#x27;width:210px&#x27;&gt; &lt;/form&gt; 点击登陆按钮，发送 ajax 请求 js 代码部分： 1234567891011121314function submitForm()&#123; // 创建对象 var xmlhttp = new XMLHttpRequest(); // 绑定onreadystatechange事件处理服务器响应 xmlhttp.onreadystatechange = function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) alert(xmlhttp.responseText) &#125; // 发送请求 xmlhttp.open(&quot;GET&quot;,&quot;/demo_form.asp&quot;,true); xmlhttp.send();&#125; 🙂 也可用 jQuery 实现 ajax 请求： 12345678910111213141516function submitForm()&#123; var userName = $(&#x27;#user&#x27;).val(); var password = $(&#x27;#pwd&#x27;).val(); $.ajax ( &#123; type: &quot;Get&quot;, url: &quot;/demo_form.asp&quot;, username: userName, password:password, dataType : &quot;json&quot;, success: function(respMsg)&#123;&#125; &#125; );&#125; 更多提交方式 更多提交方式，参考：六种提交 form 表单方式 5.4 操作文件 用到再提。 5.5 AJAX 什么是 AJAX ? 传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。 如何不重新加载界面更新内容？ AJAX = 异步 JavaScript 和 XML，可以实现网页异步更新，这意味着不重新加载网页而进行更新。 AJAX 应用实例 当我们使用百度搜索，在输入框输入搜索内容时，通过AJAX和服务器进行请求返回一列推荐搜索结果。在这个过程中，并没有重新加载界面。 那么在前端和服务器后台都是具体怎么实现沟通呢？这里以一个推荐姓名实例demo为例。 PART1 ： 前端html 前端 html 实现见下： 123456789101112131415&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot;&gt; // ajax部分... &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;请在下面的输入框中键入字母（A - Z）：&lt;/h3&gt;&lt;form action=&quot;&quot;&gt; 姓氏：&lt;input type=&quot;text&quot; id=&quot;txt1&quot; onkeyup=&quot;showHint(this.value)&quot; /&gt;&lt;/form&gt;&lt;p&gt;建议：&lt;span id=&quot;txtHint&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; PART2 ：前端 js 实现 AJAX 123456789101112131415161718192021222324// ajax部分...function success(res) &#123; console.log(&quot;拿到服务器成功响应结果：&quot; + res); &#125;function fail(res) &#123; console.log(&quot;拿到服务器失败响应结果：&quot; + res);&#125;function showHint(str)&#123; // 创建对象 var xmlhttp = new XMLHttpRequest(); // 绑定onreadystatechange事件处理服务器响应 xmlhttp.onreadystatechange = function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; success(xmlhttp.responseText); &#125; else &#123; fail(xmlhttp.responseText); &#125; &#125; // 发送请求 xmlhttp.open(&quot;GET&quot;,&quot;/ajax/gethint.asp?q=&quot;+str,true); xmlhttp.send();&#125; 以下细分ajax 执行过程： 创建对象 现代浏览器使用 XMLHttpRequest 对象 用于在后台与服务器交换数据： 1var xmlhttp=new XMLHttpRequest(); 对于IE5、6不得不使用 ActiveXObject 对象： 1var xmlhttp=new XMLHttpRequest(); 发送请求 如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() &amp; send() 方法： 方法 描述 open(method,url,async) 规定：请求的类型、URL处理脚本文件 、是否异步处理请求 send(string) 将请求发送到服务器：string 参数仅用于 POST 请求 12xmlhttp.open(&quot;GET&quot;,&quot;/ajax/gethint.asp?q=&quot;+str,true);xmlhttp.send(); 请求方法为GET 类型，在以下情况推荐使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 url = /ajax/gethint.asp?q= str ：/ajax/gethint.asp 是处理脚本通常为 ASP/PHP 文件 ；?q=str 是请求的参数，GET 方式必须向URL 添加信息。 true ：表示开启异步，XMLHttpRequest 对象如果要用于 AJAX 的话必须设置为 true 。 服务器响应 如需获得来自服务器的响应，使用 XMLHttpRequest 对象的 responseText 、 responseXML 属性： 属性 描述 responseText 获得字符串形式的响应数据 responseXML 获得 XML 形式的响应数据 同时，通过脚本和服务器交互过程，我们需要根据连接状态来触发执行操作。我们可以使用XMLHttpRequest 对象的 onreadystatechange 事件： 属性 描述 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 同前 responseText 、 responseXML 也是XMLHttpRequest 对象属性： 属性 描述 readyState 存有 XMLHttpRequest 的状态：从 0 --&gt; 4 发生变化 status 200: “OK” 404: 未找到页面 对应实际代码为： 1234567891011xmlhttp.onreadystatechange = function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; success(xmlhttp.responseText); &#125; else &#123; fail(xmlhttp.responseText); &#125;&#125; PART3 ：服务器端*.ASP* 脚本 以下为 gethint.asp 文件，根据用户输入字母返回推荐的名字： 🙂 当然你也可以用 PHP 实现，这里从略。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;%response.expires=-1dim a(30)&#x27;用名字来填充数组a(1)=&quot;Anna&quot;a(2)=&quot;Brittany&quot;a(3)=&quot;Cinderella&quot;a(4)=&quot;Diana&quot;a(5)=&quot;Eva&quot;a(6)=&quot;Fiona&quot;a(7)=&quot;Gunda&quot;a(8)=&quot;Hege&quot;a(9)=&quot;Inga&quot;a(10)=&quot;Johanna&quot;a(11)=&quot;Kitty&quot;a(12)=&quot;Linda&quot;a(13)=&quot;Nina&quot;a(14)=&quot;Ophelia&quot;a(15)=&quot;Petunia&quot;a(16)=&quot;Amanda&quot;a(17)=&quot;Raquel&quot;a(18)=&quot;Cindy&quot;a(19)=&quot;Doris&quot;a(20)=&quot;Eve&quot;a(21)=&quot;Evita&quot;a(22)=&quot;Sunniva&quot;a(23)=&quot;Tove&quot;a(24)=&quot;Unni&quot;a(25)=&quot;Violet&quot;a(26)=&quot;Liza&quot;a(27)=&quot;Elizabeth&quot;a(28)=&quot;Ellen&quot;a(29)=&quot;Wenche&quot;a(30)=&quot;Vicky&quot;&#x27;获得来自 URL 的 q 参数q=ucase(request.querystring(&quot;q&quot;))&#x27;如果 q 大于 0，则查找数组中的所有提示if len(q)&gt;0 then hint=&quot;&quot; for i=1 to 30 if q=ucase(mid(a(i),1,len(q))) then if hint=&quot;&quot; then hint=a(i) else hint=hint &amp; &quot; , &quot; &amp; a(i) end if end if nextend if&#x27;如果未找到提示，则输出 &quot;no suggestion&quot;&#x27;否则输出正确的值if hint=&quot;&quot; then response.write(&quot;no suggestion&quot;)else response.write(hint)end if%&gt; jQuery &amp; ajax jQuery 提供了对JavaScript ajax 高度的封装API ，常用方法如下： 函数 描述 $.ajax({name:val, name:val,…}) 常用于其他jQuery Ajax方法不能完成的请求 $.post(url, data, func, dataType) POST方式执行Ajax请求，从服务器加载数据。 $.get(url, data, func, dataType) GET方式执行Ajax请求，从服务器加载数据。 $.getJSON(url, data, func) GET方式从服务器加载JSON格式数据。相较于$.get()不必再指定dataType $.load(url, data, func) POST方式将服务器加载的数据插入指定DOM中，data不存在则以GET方式 $.getScript(url, func) GET方式执行Ajax请求，从服务器加载并执行回传的JavaScript。 注：上述方法 func 都是指在方法完成后执行的回调（callback）函数 。 格式：func(data, status, xhr) 参数：data — 服务器返回数据；status — 响应状态 ；xhr – XMLHttpRequest对象。一般关注 data 即可。 $.ajax() .ajax()∗完整参数形式为：∗.ajax()* 完整参数形式为：*.ajax()∗完整参数形式为：∗.ajax({name:val, name:val,…}) ，其参数为一个对象 {} ，可选字段为： url：链接地址，字符串表示 data：需发送到服务器的数据，GET、POST都可以，格式为 {A: ‘…’, B: ‘…’} type：指定请求类型为：“POST” 或 “GET” timeout：请求超时时间 / 毫秒 cache：是否缓存请求结果，bool表示 contentType：内容类型，默认为 “application/x-www-form-urlencoded” dataType：服务器响应的数据类型，字符串表示 success：请求成功后，服务器回调的函数 error：请求失败后，服务器回调的函数 complete：请求完成后调用的函数，无论请求是成功还是失败，都会调用该函数；如果设置了success与error函数，则该函数在它们之后被调用 async：是否异步处理，bool表示，默认为true；设置该值为false后，JS不会向下执行，而是原地等待服务器返回数据，并完成相应的回调函数后，再向下执行 username：访问认证请求中携带的用户名，字符串表示 password：返回认证请求中携带的密码，字符串表示 下面通过 $.ajax() 方法请求服务器加载一个txt文本。 html代码部分： 123456789101112&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;myDiv&quot;&gt;&lt;h2&gt;通过 AJAX 改变文本&lt;/h2&gt;&lt;/div&gt;&lt;button id=&quot;b01&quot; type=&quot;button&quot;&gt;点我加载txt&lt;/button&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;// ajax实现部分...&lt;/script&gt;&lt;/html&gt; 1234567891011// ajax实现部分...$(&quot;#b01&quot;).click(function()&#123; htmlobj=$.ajax (&#123; url:&quot;/jquery/test1.txt&quot;, type:&quot;GET&quot;, async:false &#125;); $(&quot;#myDiv&quot;).html(htmlobj.responseText);&#125;); 点击后显示： 回调函数 也可使用回调函数，如果成功就显示： 1234567891011// ajax实现部分...$(&quot;#b01&quot;).click(function()&#123; htmlobj=$.ajax (&#123; url:&quot;/jquery/test1.txt&quot;, type:&quot;GET&quot;, async:false, success:function(data)&#123; $(&quot;#myDiv&quot;).html(data); &#125; &#125;); &#125;); 回调函数success有参数 data ，接收服务器返回数据，这里接收的是文本：test1.txt 。 也可以使用链式调用回调函数，类似前面 Promise ： 12345678910111213// ajax实现部分...$(&quot;#b01&quot;).click(function()&#123; htmlobj=$.ajax (&#123; url:&quot;/jquery/test1.txt&quot;, type:&quot;GET&quot;, async:false &#125;) .done(function(data)&#123; $(&quot;#myDiv&quot;).html(data); &#125;) .fail(function (xhr,status)&#123; $(&quot;#myDiv&quot;).html(&#x27;失败:&#x27;+xhr.status+&#x27;原因:&#x27;+ status);&#125;) .always(function () &#123; alert(&#x27;请求完成: 无论成功或失败都会调用&#x27;);&#125;);&#125;); $.get() 简单的 GET 请求功能以*.get()∗取代复杂∗.get()* 取代复杂 *.get()∗取代复杂∗.ajax()* ，请求成功时可调用回调函数。 其格式为：$.get(url, data, func, dataType) url：链接地址，字符串表示 data：需要发生到服务器的数据，以键值对形式 func(data, status, xhr)：回调函数，data — 服务器返回数据；status — 响应状态 ；xhr – XMLHttpRequest对象。一般关注 data 即可。 dataType：服务器返回数据的格式 以*$.get()* 实现上述点击按钮加载指定文本。 123456789// ajax实现部分...$(&quot;#b01&quot;).click(function()&#123; htmlobj=$.get(&quot;/jquery/test1.txt&quot; ,function(data,status) &#123; $(&quot;#myDiv&quot;).html(data); &#125;); &#125;); 回调函数function(data,status) 参数data、status 分别接收服务器返回的数据、状态。 点击后显示： ⚠️ 经过测试，似乎只能在回调函数里接收数据，像*$.ajax()* 一样用responseText 获取返回数据不成功： 123456// ajax实现部分...$(&quot;#b01&quot;).click(function()&#123; htmlobj=$.get(&quot;/jquery/test1.txt&quot;); $(&quot;#myDiv&quot;).html(htmlobj.responseText); // 点击按钮加载数据不成功？？！&#125;); $.post() 和 $.get() 类似，接收参数一致，除了请求方式变为了 post 方式。 其格式为：$.post(url, data, func, dataType) 向指定界面发送 HTTP POST 请求，并获得返回的结果 。 12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt;&lt;script src=&quot;/jquery/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body style=&quot;text-align: center&quot;&gt;&lt;p&gt; 姓名：&lt;input id=&#x27;user&#x27;&gt; &lt;/p&gt;&lt;p&gt; 城市：&lt;input id=&#x27;city&#x27;&gt; &lt;/p&gt;&lt;button&gt;发送 POST 请求，获取返回结果 &lt;/button&gt;&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;$(&quot;button&quot;).click(function()&#123; $.post(&quot;/example/jquery/demo_test_post.asp&quot;, &#123; name:$(&#x27;#user&#x27;).val(), city:$(&#x27;#city&#x27;).val() &#125;, function(data,status) &#123; $(&#x27;#myDiv&#x27;).html(&quot;数据：&quot; + data + &quot;&lt;br&gt;状态：&quot; + status); &#125;);&#125;);&lt;/script&gt;&lt;/html&gt; $.load() $.load() 如果数据存在则以 POST 方式（不存在则以 GET 方式）加载服务器返回的数据到 指定 DOM 节点中 。 其格式为：$(selector).load(URL,data,func)。 举个例子 依旧以上 $.post() 所举实例为例，加载服务器返回的结果到指定节点中。 123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt;&lt;script src=&quot;/jquery/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body style=&quot;text-align: center&quot;&gt;&lt;p&gt; 姓名：&lt;input id=&#x27;user&#x27;&gt; &lt;/p&gt;&lt;p&gt; 城市：&lt;input id=&#x27;city&#x27;&gt; &lt;/p&gt;&lt;button&gt;发送 POST 请求，获取返回结果 &lt;/button&gt;&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;$(&quot;button&quot;).click(function()&#123; $(&#x27;#myDiv&#x27;).load(&quot;/example/jquery/demo_test_post.asp&quot;, &#123; name:$(&#x27;#user&#x27;).val(), city:$(&#x27;#city&#x27;).val() &#125; );&#125;);&lt;/script&gt;&lt;/html&gt; 上面会将返回的结果自动加载到指定节点 #myDiv 中，当然你也可以使用回调函数来自定义加载： 1234567891011121314$(&quot;button&quot;).click(function()&#123; $(&#x27;#myDiv&#x27;).load(&quot;/example/jquery/demo_test_post.asp&quot;, &#123; name:$(&#x27;#user&#x27;).val(), city:$(&#x27;#city&#x27;).val() &#125;, function(data,status,xhr) &#123; $(&#x27;#myDiv&#x27;).html(&quot;数据：&quot; + data + &quot;&lt;br&gt;状态：&quot; + status); &#125; );&#125;); 回调函数参数意义同前，显示结果为： 再举个例子 也可直接加载url 指定资源，不用传递其它参数。 点击按钮后，指定节点直接加载 demo_test.txt 文件内容。 1234567891011121314151617&lt;html&gt;&lt;head&gt;&lt;script src=&quot;/jquery/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 id=&quot;test&quot;&gt;请点击下面的按钮，通过 jQuery AJAX 改变这段文本。&lt;/h3&gt;&lt;button id=&quot;btn1&quot; type=&quot;button&quot;&gt;获得外部的内容&lt;/button&gt;&lt;/body&gt;&lt;script&gt; $(&quot;#btn1&quot;).click(function() &#123; $(&#x27;#test&#x27;).load(&#x27;/example/jquery/demo_test.txt&#x27;); &#125;);&lt;/script&gt;&lt;/html&gt; 点击后显示： 5.6 Promise 初识 Promise 先不理会那些复杂的概念，我们来直观了解下 Promise 是什么： 很容易得知，Promise 原来是一个构造函数： 在自己身上有 all()、reject()、resolve() 等方法 在原型上有 then()、catch() 等方法，then() 返回一个 Promise 对象。 那么 new Promise() 出来的对象自然也拥有以上方法。 举个栗子 原生 JavaScript 执行异步 在 JavaScript 世界里，所有代码都是单线程执行。因此 JavaScript 所有网络操作、浏览器事件都必须异步执行。 也就是说，在某个时间点，会执行某个函数。然后根据函数状态执行不同的处理函数，也就是常说的回调函数。 如，生成一个0-2之间的随机数，如果小于1，则等待1s后返回成功，否则返回失败。 123456789101112131415161718192021function success(str)&#123; console.log(str); &#125;function fail(str) &#123; console.log(str); &#125;function test()&#123; var timeOut = Math.random() * 2; log(&#x27;set timeout to: &#x27; + timeOut + &#x27; seconds.&#x27;); setTimeout(function () &#123; if (timeOut &lt; 1) &#123; success(&#x27;成功：生成随机数小于1&#x27;); &#125; else &#123; fail(&#x27;失败：生成随机数大于1&#x27;); &#125; &#125;, 1000);&#125;test(); 本文中所有异步操作均以 setTimeout为例子，而不使用 ajax 。 可以看到，执行test() —&gt; 延迟1s后执行匿名判断函数 —&gt; 根据判断结果执行回调函数：success() 、fail() 。 Promise 执行异步 如果我们用 Promise 对象来执行可以达到相同效果： 123456789101112131415161718192021222324252627282930313233function test(resolve, reject) &#123; var timeOut = Math.random() * 2; setTimeout(function () &#123; if (timeOut &lt; 1) &#123; var date = &#x27;生成随机数小于1&#x27;; resolve(date); // 传递参数date给Promise对象.then方法内部匿名函数参数 &#125; else &#123; var date = &#x27;生成随机数大于1&#x27;; reject(date); // 传递参数date给Promise对象.catch方法内部匿名函数参数 &#125; &#125;, 1000);&#125;var p1 = new Promise(test);var p2 = p1.then( function (result) &#123; console.log(&#x27;成功：&#x27; + result); // 如果执行成功输出：&#x27;成功：生成随机数小于1&#x27; &#125;);var p3 = p2.catch( function (reason) &#123; console.log(&#x27;失败：&#x27; + reason); // 如果执行失败输出：&#x27;失败：生成随机数大于1&#x27; &#125;); 咋看之下首先方法 function test(…) 和之前没什么区别，只不过多了两个函数参数 resolve, reject ，替换了之前回调函数 success、fail 在接下来代码中位置，整体逻辑没有变化。 resolve, reject 可以分别将 Promise 状态置为：fullfiled、 rejected resolve, reject 还可将自身的接收的参数（本例为date） ，分别传给then、catch 方法（见下） 只不过在下面多了一层对 test() 的封装：创建一个 Promise 对象，传递一个函数作为参数，承诺一定执行。 1var p1 = new Promise(test); 紧接着根据此时 Promise 状态是fullfiled、 rejected 执行 then() 还是 catch() 方法。 比如，随机数&lt;1 —&gt; 执行resolve() —&gt; Promise 状态为fullfiled ----&gt; 执行 then() 方法： 1234567var p2 = p1.then( function (result) &#123; console.log(&#x27;成功：&#x27; + result); // 如果执行成功输出：&#x27;成功：生成随机数小于1&#x27; &#125;); then(func) 参数为一个函数，同时它也拿到了resolve(date) 的参数date ，赋值给了result （我是这么理解的的）。 所以如果执行会打印出： 同理，随机数&gt;1 —&gt; 执行reject() —&gt; Promise 状态为 rejected ----&gt; 执行 catch() 方法： 1234567var p3 = p2.catch( function (reason) &#123; console.log(&#x27;失败：&#x27; + reason); // 如果执行失败输出：&#x27;失败：生成随机数大于1&#x27; &#125;); Promise 对象可以串联起来，所以上述代码可以简化为： 12new Promise(test).then (function (result)&#123; console.log(&#x27;成功：&#x27; + result); &#125; .catch(function (reason)&#123; console.log(&#x27;失败：&#x27; + reason); &#125; 这就完了？ 看到这儿你可能不屑一顾，这么传的神乎其神的 Promise 就这点能耐？把原来好好的 test() 方法，整两个参数然后用 Promise 封装一下就没了？ 当然，看到这你也可能发现了 Promise 其中一个优点：执行代码和处理结果的代码清晰地分离 。 比如上面：执行代码 test() 只负责整体逻辑传递数据，而处理代码接收数据进行处理由then() 、 catch() 完成。 更大优点，是用 Promise 处理多个异步操作，请看下节。 更正确的使用Promise姿势：处理多异步 试想有多个异步任务函数，job1、job2、job3…： 执行job1，job1执行成功 —&gt; 执行job2，job2执行成功 —&gt; 执行job3，job3执行成功 —&gt; … 显然job1成了一个多层回调函数，job2执行完成后也有相应回调函数job3执行，job3有回调函数job4… 如果不使用 Promise 意味着我们要层层嵌套 job1、job2、job3…。这既不易读，也不灵活，而我们使用 Promise 后 可以将代码简写为： 1p.then(job1).then(job2).then(job3).then...; 分别实现异步函数job1_add1、job2_mul2、job3_div3 依次对数字0进行 *+1、2、/3： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 新建一个Promise对象var p = new Promise(function (resolve, reject) &#123; resolve(0); // 传递数据：数字0&#125;);// job1任务：将传过来的数字加1,这里传过来的数字是0function job1_add1(num)&#123; /* 为什么返回 Promise 对象？ 首先我们要知道，setTimeout共有四个参数，后面两个参数会传入回调函数（这里是resolve） 我们知道，resolve参数可以被then方法拿到，这样在接下来的then方法可以获取到传递的参数: p.then(job1_add1).then(job2_mul2).then(job3_div3) 你也可以直接传递数据而非Promise对象，后面then也可以接收到： return num+1; */ console.log(&#x27;计算：&#x27;+ num + &#x27; + 1&#x27;); return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, num + 1); &#125;);&#125;// job2任务：将传过来的数字×2，这里传过来的是0+1 = 1function job2_mul2(num)&#123; console.log(&#x27;计算：&#x27;+ num + &#x27; * 2&#x27;); return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, num * 2); &#125;);&#125;// job2任务：将传过来的数字÷3，这里传过来的是 (0+1)*2 = 2function job3_div3(num)&#123; console.log(&#x27;计算：&#x27;+ num + &#x27; / 3&#x27;); return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 400, num / 3); &#125;);&#125;// 执行多异步任务p.then(job1_add1).then(job2_mul2).then(job3_div3); 执行结果： 更多有关 Promise 除了前面提到 then、catch 方法，Promise 还提供了静态 方法 all、race 等。 all() 方法 Promise 的all(PromiesArr) 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。 由于可以在一个回调中处理所有返回数据，这样比如在打开网页，预先加载需要用到的所有资源如图片等，等全部加载完在执行回调。 依旧以上面异步函数job1_add1、job2_mul2、job3_div3 为例： 异步执行三个异步函数，分别将各自传递的参数值进行：+1、*2、/3。 12345Promise.all([job1_add1(1),job2_mul2(2),job3_div3(3)]) .then(function(results) &#123; console.log(results); &#125;); 三个异步操作都执行完毕后，all(PromiesArr) 会把它们返回的数据组成数组传给 then()，也就是上面results。 注意是传递 Promise 对象数组，而非函数，下面这种写法错误： 1Promise.all([job1_add1,job2_mul2,job3_div3]) 这是传递的参数是函数数组，而非Promise对象 数组。只有函数都执行后才是Promise对象数组（job1_add1、job2_mul2、job3_div3 返回Promise对象）。 所以，all() 不能实现前面三个异步操作结果交互依次进行：+1、*2、/3，因为传递的参数值被写死了，它们不存在嵌套关系，更何况论传值了。 最后执行的结果为： race() 方法 有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现： 123456789101112var p1 = new Promise(function (resolve, reject)&#123; setTimeout(resolve, 500, &#x27;P1&#x27;);&#125;);var p2 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, &#x27;P2&#x27;);&#125;);Promise.race([p1, p2]).then(function (result) &#123; console.log(result); // &#x27;P1&#x27;&#125;); 练习：将AJAX 异步执行函数转为 Promise 对象 在前我们举个ajax应用实例：根据用户输入字母，触发showHint 方法ajax 方式请求服务器返回推荐姓名。 其中 ajax 实现部分见下： 123456789101112131415161718192021222324// ajax部分...function success(res) &#123; console.log(&quot;拿到服务器成功响应结果：&quot; + res); &#125;function fail(res) &#123; console.log(&quot;拿到服务器失败响应结果：&quot; + res);&#125;function showHint(str)&#123; // 创建对象 var xmlhttp = new XMLHttpRequest(); // 绑定onreadystatechange事件处理服务器响应 xmlhttp.onreadystatechange = function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; success(xmlhttp.responseText); &#125; else &#123; fail(xmlhttp.status); &#125; &#125; // 发送请求 xmlhttp.open(&quot;GET&quot;,&quot;/ajax/gethint.asp?q=&quot;+str,true); xmlhttp.send();&#125; 现要求：将ajax 异步执行函数*showHint()*转换为 Promise 对象简化异步处理。 最开始，我用Promise 对象直接封装 showHint： 123456789101112131415161718192021222324function showHint(str) // 参数不对，应该为 function showHint(resolve, reject)&#123; // 创建对象 var xmlhttp = new XMLHttpRequest(); // 绑定onreadystatechange事件处理服务器响应 xmlhttp.onreadystatechange = function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; resolve(xmlhttp.responseText); &#125; else &#123; reject(xmlhttp.status); &#125; &#125; // 发送请求 xmlhttp.open(&quot;GET&quot;,&quot;/ajax/gethint.asp?q=&quot;+str,true); xmlhttp.send();&#125;var p = new Promise(showHint);p.then (function(res)&#123; console.log(&quot;拿到服务器成功响应结果：&quot; + res);&#125;) .catch(function(res)&#123; console.log(&quot;拿到服务器失败响应结果：&quot; + res);&#125;); 但是这样有一个问题：function showHint(str){…} 参数不对，应该为： 1234function showHint(resolve, reject)&#123; ....&#125; 否则无法在后面使用 resolve、reject 函数！但是这样又无法使用函数自带 str 参数，所以解决办法为：把函数showHint 内部需要判断执行不同回调函数的部分，包装成 Promise对象返回： 123456789101112131415161718192021222324var p;function showHint(str) // 参数不对，应该为 function showHint(resolve, reject)&#123; // 创建对象 var xmlhttp = new XMLHttpRequest(); // 绑定onreadystatechange事件处理服务器响应 p = new Promise( function(resolve,reject) &#123; xmlhttp.onreadystatechange = function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; resolve(xmlhttp.responseText); &#125; else &#123; reject(xmlhttp.responseText); &#125; &#125; &#125;); // 发送请求 xmlhttp.open(&quot;GET&quot;,&quot;/ajax/gethint.asp?q=&quot;+str,true); xmlhttp.send();&#125; 这样就可以使用resolve、reject 函数了，然后再让返回的Promise对象执行 then 、catch ： 12p.then (function(res)&#123; console.log(&quot;拿到服务器成功响应结果：&quot; + res);&#125;) .catch(function(res)&#123; console.log(&quot;拿到服务器失败响应结果：&quot; + res);&#125;); 第六章：jQuery 6.1 选择器 在前 5.2节 介绍了： 获取DOM 节点：getElementby…() 方法 OR CSS 层级选择器 操作DOM 节点 通过 innerText、innerHtml 属性修改节点文本 通过 style 属性修改CSS 样式 通过 appendChild() 、insertBefore() 、*removeChild()*方法插入、删除节点 jQuery 提供获取DOM 节点方法 本质是 CSS 层级选择器 语法，不再赘述。但是还特别提供 find()、filter()、map() 方法进行查找和过滤，详见下。 查找和过滤 123456&lt;ul id=&quot;programLanguage&quot;&gt; &lt;li id=&quot;C#&quot;&gt;C#&lt;/li&gt; &lt;li id=&quot;C&quot;&gt;C&lt;/li&gt; &lt;li id=&quot;python&quot;&gt;python&lt;/li&gt; &lt;li id=&quot;java&quot;&gt;java&lt;/li&gt; &lt;/ul&gt; find()、next()、prev()、parent() 在前面我们知道怎么获取一个节点，但是如果获取一个节点后，还想获取它的子、兄弟、父节点呢？ jQuery 为我们提供了 find()、next()、prev() 方法来做到这一点： 123456789101112// find()var C = $(&#x27;#programLanguage&#x27;).find(&#x27;#C&#x27;);C.text(); // 输出: C// parent()var pl = C.parent(); pl; // 节点：ul#programLanguage// next()、prev()C.next(); // 节点：li#pythonC.prev(); // 节点：li#C# first()、last() 如果我们获取到一个节点数组，对节点数组的操作和普通数组操作有什么不同吗？ 普通数组可以使用的API方法和jQuery 对象提供的API多有不同，不可混为一谈，以下是常用一些方法： 12345var lis = $(&#x27;#programLanguage li&#x27;);lis.first(); // 获取第一个节点，等价于：#programLanguage li:first-childlis.last(); // 获取最后一个节点，等价于：#programLanguage li:last-childlis.slice(0, 2); // 输出：[C#,C], 数组的slice()方法一致 更多方法以后用到再提。 filter()、map() filter()、map() 和我们前介绍的高阶函数类似。 通过 filter() 过滤出 ’C‘ 开头编程语言。 123456789101112131415161718192021// filter()过滤符合条件的原对象数组元素// 返回：数组 var lis = $(&#x27;#programLanguage li&#x27;);var firstIsC = lis.filter( /* 过滤条件；首字母为C 注意：此时是DOM节点对象不是jQuery对象 why? 直接箭头函数this绑定window */ // () =&gt; this.innerHTML.indexOf(&#x27;C&#x27;) === 0 function() &#123; return this.innerHTML.indexOf(&#x27;C&#x27;) === 0; &#125;);// 输出测试firstIsC ; // jQuery.fn.init(2) [li#C#, li#C, prevObject: jQuery.fn.init(4)] 通过 map() 遍历返回所有对象节点文本。 12345678910111213// map()// 遍历所有对象元素返回一个数组var lis = $(&#x27;#programLanguage li&#x27;);var texts = lis.map( function() &#123; return this.innerHTML; &#125;);// 输出测试texts; // [&quot;C#&quot;, &quot;C&quot;, &quot;python&quot;, &quot;java&quot;] 综合练习 123456789101112131415161718&lt;form id=&quot;test-form&quot; action=&quot;#0&quot; onsubmit=&quot;return false;&quot;&gt; &lt;p&gt;&lt;label&gt;Name: &lt;input name=&quot;name&quot;&gt;&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;Email: &lt;input name=&quot;email&quot;&gt;&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/label&gt;&lt;/p&gt; &lt;p&gt;Gender: &lt;label&gt;&lt;input name=&quot;gender&quot; type=&quot;radio&quot; value=&quot;m&quot; checked&gt; Male&lt;/label&gt; &lt;label&gt;&lt;input name=&quot;gender&quot; type=&quot;radio&quot; value=&quot;f&quot;&gt; Female&lt;/label&gt; &lt;/p&gt; &lt;p&gt;&lt;label&gt;City: &lt;select name=&quot;city&quot;&gt; &lt;option value=&quot;BJ&quot; selected&gt;Beijing&lt;/option&gt; &lt;option value=&quot;SH&quot;&gt;Shanghai&lt;/option&gt; &lt;option value=&quot;CD&quot;&gt;Chengdu&lt;/option&gt; &lt;option value=&quot;XM&quot;&gt;Xiamen&lt;/option&gt; &lt;/select&gt; &lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; 输入值后，用 jQuery 获取表单的 JSON 字符串，如：&#123;&quot;name&quot;:&quot;Michael&quot;,&quot;email&quot;:...&#125;。 12345678910111213141516171819202122232425var obj = &#123;&#125;;// 限定状态:input 可获取：&lt;input&gt;，&lt;textarea&gt;，&lt;select&gt;和&lt;button&gt; 元素$(&#x27;#test-form :input&#x27;).filter( function() &#123; // 过滤节点数组中：未选中的radio单选框节点和submit按钮节点 // this是DOM对象，获取节点属性type、checked等 var isNotChecked = this.type === &#x27;radio&#x27; &amp;&amp; !this.checked; if( isNotChecked || this.type === &#x27;submit&#x27;) return false; else return true; &#125;).map( function() &#123; // select元素可直接获取name属性和选中的值 return obj[this.name] = this.value; &#125;)json = JSON.stringify(obj,null,&#x27; &#x27;); 6.2 jQuery 操作 DOM 修改 Text &amp; HTML jQuery 对象提供了 text()、html() 方法来获取节点文本和HTML文本，例如以下HTML结构： 123456&lt;ul id=&quot;programLanguage&quot;&gt; &lt;li id=&quot;C#&quot;&gt;C#&lt;/li&gt; &lt;li id=&quot;C&quot;&gt;C&lt;/li&gt; &lt;li id=&quot;python&quot;&gt;python&lt;/li&gt; &lt;li id=&quot;java&quot;&gt;java&lt;/li&gt; &lt;/ul&gt; 分别获取文本和HTML： 12$(&#x27;#C&#x27;).html(); // C$(&#x27;#C&#x27;).text(); // C 设置文本 &amp; HTML，只需给text()、html() 方法传递参数即可： 1$(&#x27;#C&#x27;).text(&#x27;我是西语言&#x27;); // 我是西语言 特别巧妙的是，jQuery 可以给选中多个节点设置文本、CSS、属性等，具有 批量操作 特点： 123456// docment对象不具有 批量操作 特点document.getElementsByTagName(&#x27;li&#x27;).innerText = &#x27;test&#x27;; // 设置不成功，节点内容未被改变document.querySelectorAll(&#x27;li&#x27;).innerText = &#x27;test&#x27;; // 设置不成功，节点内容未被改变// jQuery对象具有 批量操作 特点$(&#x27;li&#x27;).text(&#x27;test&#x27;); // 设置成功，所有li节点文本被设置 &#x27;test&#x27; 修改CSS 同前，也可用 CSS() 方法获取、修改CSS样式，也具有 批量操作 特点，关于该特点以下不再赘述。 获取CSS样式： 1$(&#x27;li&#x27;).css(&#x27;color&#x27;); // &quot;rgb(0, 0, 0)&quot; 设置CSS样式： 1$(&#x27;li&#x27;).css(&#x27;color&#x27;,&#x27;red&#x27;); // 文本全变为红色 清除CSS样式： 1$(&#x27;li&#x27;).css(&#x27;color&#x27;,&#x27;&#x27;); // 等价把该属性设置为空即可 显示和隐藏DOM 隐藏DOM节点，注意DOM树结构没有被改变： 1$(&#x27;li&#x27;).hide(); // 对应CSS设置：display = none; 显示DOM节点： 1$(&#x27;li&#x27;).show(); // 对应CSS设置：display = inline; 或者 display = block; 修改DOM信息 节点宽高：width()、heigth() 获取宽高： 12$(&#x27;li&#x27;).width(); // 1860$(&#x27;li&#x27;).heigth(); // 21.5126 ⚠️ 经过测试，多个标签显示的是其中一个标签宽高？ 12$(&#x27;#C&#x27;).width(); // 1860$(&#x27;#C&#x27;).heigth(); // 21.5126 设置宽高： 12$(&#x27;#C&#x27;).width(400); $(&#x27;#C&#x27;).heigth(1800); 节点属性：attr() 、removeAttr() 获取属性，不存在返回 undefined： 123$(&#x27;#C&#x27;).attr(&#x27;id&#x27;); // C$(&#x27;li&#x27;).attr(&#x27;id&#x27;); // C#，多个节点返回第一个节点指定属性值$(&#x27;#C&#x27;).attr(&#x27;name&#x27;); // undefined，不存在返回undefined 设置属性，类似CSS() 方法： 1$(&#x27;#C&#x27;).attr(&#x27;name&#x27;,&#x27;iamC&#x27;); // &lt;li id=&quot;C&quot; name=&#x27;iamC&#x27;&gt;C&lt;/li&gt; 删除属性： 1$(&#x27;#C&#x27;).removeAttr(&#x27;name&#x27;); 特别的，关于一些属性只有出现和没出现两种情况判断，如： checked、selected 。 对于以下HTML结构： 1&lt;input id=&quot;test-radio&quot; type=&quot;radio&quot; name=&quot;test&quot; checked=&quot;checked&quot; value=&quot;1&quot;&gt; 如果使用attr() 获取 checked 属性： 1$(&#x27;#test-radio&#x27;).attr(&#x27;checked&#x27;); // &#x27;checked&#x27; 虽然正确返回了属性值，但是 checked 属性只有[被选中]、[未被选中]两种情况，用 true、false返回更好： 1$(&#x27;#test-radio&#x27;).is(&#x27;:checked&#x27;); // true,用is()方法判断更好 ⚠️ 不知道为什么有时候 attr 设置选中无效，建议使用 prop 方法： 12$(&#x27;#test_checkbox&#x27;).attr(&#x27;checked&#x27;,&#x27;checked&#x27;); // 选中无效？$(&#x27;#test_checkbox&#x27;).prop(&#x27;checked&#x27;,true); // 可选中 selected 等同理不再赘述。 修改DOM结构 添加节点 如果我们要在以下 ul 节点添加子节点 &lt;li id=&quot;python&quot;&gt;python&lt;/li&gt;： 1234&lt;ul id=&quot;programLanguage&quot;&gt; &lt;li id=&quot;C#&quot;&gt;C#&lt;/li&gt; &lt;li id=&quot;C&quot;&gt;C&lt;/li&gt;&lt;/ul&gt; jQuery 虽然提供了html() 方法，但是会修改 ul 节点所有节点。 为此我们可以利用以下方法： 方法名 用法 append(newElem) 添加子节点newElem 为当前父节点对象 最后一个子节点 prepend(newElem) 添加子节点newElem 为当前父节点对象 第一个子节点 如果是同级节点对象，还可以用： 方法名 用法 after(newElem) 添加子节点newElem 为当前节点对象 下一个兄弟子节点 before(newElem) 添加子节点newElem 为当前节点对象 前一个兄弟子节点 将 python 新节点添加为ul 列表最后一个新节点。 父节点对象方法： 12var pl = $(&#x27;#programLanguage&#x27;);pl.append(&#x27;&lt;li id=&quot;python&quot;&gt;python&lt;/li&gt;&#x27;); 同级节点对象方法： 12var last = $(&#x27;#programLanguage li:last-child&#x27;);last.after(&#x27;&lt;li id=&quot;python&quot;&gt;python&lt;/li&gt;&#x27;); 删除节点 方法名 用法 remove() 删除当前节点对象，可作用于多个节点对象。 删除所有列表项。 1$(&#x27;li&#x27;).remove(); // 所有&lt;li&gt;被删除 综合测试 对于以下html 结构：除了列出语言外，请再添加 Pascal、Lua 、Ruby，然后按字母顺序排序节点。 1234567&lt;div id=&quot;test-div&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123456789101112131415161718192021var language = [&#x27;Pascal&#x27;,&#x27;Lua&#x27;,&#x27;Ruby&#x27;];var ul = $(&#x27;#test-div ul&#x27;);for(var i = 0; i &lt; language.length; i++ )&#123; ul.append(&#x27;&lt;li&gt;&lt;span&gt;&#x27; + language[i] + &#x27;&lt;/span&gt;&lt;/li&gt;&#x27;);&#125;// 获取所有li标签排序var lis = ul.find(&#x27;li&#x27;);lis.sort( function(x,y) &#123; // 不是jQuery对象，而是DOM对象？不能用x.text() &gt; y.text() if(x.innerText &gt; y.innerText) return 1; else return -1; &#125;);// 添加已排序好的li标签ul.html(lis); 表单输入框值 对于表单元素，jQuery 统一用val() 方法获取 DOM 对象 value 属性，统一输入框取值和赋值问题： 方法名 用法 val() 无参数获取文本框值；有参数设置文本框值。 对于以下 html 结构： 1 尝试对以上不同 input 类型输入框值操作。 123456789// 获取输入框值$(&#x27;#test-input&#x27;).val(); // &#x27;test&#x27;$(&#x27;#test-select&#x27;).val(); // &#x27;BJ&#x27;$(&#x27;#test-textarea&#x27;).val(); // &#x27;Hello&#x27;// 设置输入框值$(&#x27;#test-input&#x27;).val(&#x27;abc@example.com&#x27;); // 文本框的内容已变为abc@example.com$(&#x27;#test-select&#x27;).val(&#x27;SH&#x27;); // 选择框已变为Shanghai$(&#x27;#test-textarea&#x27;).val(&#x27;Hi&#x27;); // 本区域已更新为&#x27;Hi&#x27; 对应docment 对象 value 属性： 1document.querySelector(&#x27;#test-input&#x27;).value = &#x27;abc@example.com&#x27;; 不要尝试用 attr() 方法 1&lt;p&gt;用户名：&lt;input type=&quot;text&quot; id=&#x27;user&#x27;&gt; &lt;/p&gt; attr() 方法是用来获取、设置属性，用于文本框会导致意想不到的错误： 1$(&#x27;#user&#x27;).attr(&#x27;value&#x27;,&#x27;hwh&#x27;); // 成功设置文本框值为:&#x27;hwh&#x27; 但是当我们重新修改文本框值为：‘lt’，再去尝试获取文本框值： 1$(&#x27;#user&#x27;).attr(&#x27;value&#x27;); // &#x27;hwh&#x27; 读取结果还是hwh！这是因为实际html结构已经是： 1&lt;p&gt;用户名：&lt;input type=&quot;text&quot; id=&#x27;user&#x27; value=&#x27;hwh&#x27;&gt; &lt;/p&gt; 每次读取都是value值， 修改文本框内容不会改变value属性 。 6.3 事件 类似C#事件，常用有鼠标事件、键盘事件、其他事件等。 鼠标事件 常用鼠标事件，参数为函数用于处理事件： 事件方法 解释 click(func) 鼠标单击时触发 dblclick(func) 鼠标双击时触发 mouseenter(func) 鼠标进入时触发 mouseleave(func) 鼠标离开时触发 mousemove(func) 鼠标内部移动时触发 hover(func) 鼠标进入和退出时触发，相当于 mouseenter()+ mouseleave() 。 存在以下html结构： 1234&lt;ul id=&quot;programLanguage&quot;&gt; &lt;li id=&quot;C#&quot;&gt;C#&lt;/li&gt; &lt;li id=&quot;C&quot;&gt;C&lt;/li&gt;&lt;/ul&gt; 绑定 click 事件，点击 &lt;li#C&gt; 时触发。 12345678var C = $(&#x27;#C&#x27;);C.click( function() &#123; alert(&#x27;hello C!&#x27;); &#125;) 有时候还会用到一种 on() 方法绑定事件： 事件方法 解释 on(evet,func) on() 绑定事件，传入事件名称 &amp; 事件处理函数 12345678var C = $(&#x27;#C&#x27;);C.on(&#x27;click&#x27;, function() &#123; alert(&#x27;hello C!&#x27;); &#125;) 事件参数 所有时间 都会传入Event 对象作为参数，可以获取更多信息。 绑定 mousemove 事件，当鼠标在 &lt;div#testMouseMoveDiv&gt; 区域移动可以获取到鼠标位置。 1234567$(&#x27;#testMouseMoveDiv&#x27;).mousemove( function (e) &#123; $(&#x27;#testMouseMoveSpan&#x27;).text(&#x27;pageX = &#x27; + e.pageX + &#x27;, pageY = &#x27; + e.pageY); &#125;); 键盘事件 键盘事件仅作用在当前焦点的DOM上，通常是&lt;input&gt;和&lt;textarea&gt;： 事件方法 解释 keydown(func) 键盘按下时触发 keyup(func) 键盘松开时触发 keypress(func) 按一次键后触发 有以下html 结构： 12&lt;p&gt;用户名：&lt;input type=&quot;text&quot; id=&#x27;user&#x27;&gt; &lt;/p&gt; &lt;label id=&quot;check&quot;&gt;&lt;/label&gt;&lt;p&gt;密码：&lt;input type=&quot;text&quot; id=&#x27;pwd&#x27;&gt;&lt;/p&gt; 当用户在 &lt;input#user&gt; 输入完毕，右侧 &lt;lable#check&gt; 显示是否已存在用户名。 1234567891011var user = $(&#x27;#user&#x27;);user.change( function() &#123; if(this.value === &#x27;hwh&#x27;) $(&#x27;#check&#x27;).text(&#x27;用户存在！&#x27;).css(&#x27;color&#x27;,&#x27;red&#x27;); else $(&#x27;#check&#x27;).text(&#x27;可以使用！&#x27;).css(&#x27;color&#x27;,&#x27;blue&#x27;); &#125;); 其他事件 事件方法 解释 change(func) 当&lt;input&gt;、&lt;select&gt;或&lt;textarea&gt;的内容改变时触发 focus(func) 当 DOM 获得焦点时触发 blur(func) 当 DOM 失去焦点时触发 submit(func) 当&lt;form&gt;提交时触发 ready(func) 当页面被载入并且 DOM 树完成初始化后触发 有以下html 结构： 12&lt;p&gt;用户名：&lt;input type=&quot;text&quot; id=&#x27;user&#x27;&gt; &lt;/p&gt; &lt;label id=&quot;check&quot;&gt;&lt;/label&gt;&lt;p&gt;密码：&lt;input type=&quot;text&quot; id=&#x27;pwd&#x27;&gt;&lt;/p&gt; change(func) 事件：当用户在 &lt;input#user&gt; 输入完毕，右侧 &lt;lable#check&gt; 显示是否已存在用户名。 1234567891011var user = $(&#x27;#user&#x27;);user.change( function() &#123; if(this.value === &#x27;hwh&#x27;) $(&#x27;#check&#x27;).text(&#x27;用户存在！&#x27;).css(&#x27;color&#x27;,&#x27;red&#x27;); else $(&#x27;#check&#x27;).text(&#x27;可以使用！&#x27;).css(&#x27;color&#x27;,&#x27;blue&#x27;); &#125;); change 事件当输入框失去焦点才会触发（移到别处了不再输入了） 最好把函数直接写在change 里面，否则不知道为什么触发不了？ 1user.change(changeUserName()); // 封装好的函数写入不成？ ready 事件作用于docment对象，当DOM节点都载入浏览器触发：试分析以下错误？ 123456789101112131415&lt;html&gt;&lt;head&gt; &lt;script&gt; // 代码有误: $(&#x27;#testForm).on(&#x27;submit&#x27;, function () &#123; alert(&#x27;submit!&#x27;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id=&quot;testForm&quot;&gt; ... &lt;/form&gt;&lt;/body&gt; 标签内js代码在前，DOM 节点还没加载完毕就操作 节点所以出错。我们可以： - 把 标签在后 - 或者，用 *docment* 对象 *read* 事件函数 保证DOM节点都加载完毕 再绑定*submit*事件 1234567 $(document).ready(function () &#123; $(&#x27;#testForm).on(&#x27;submit&#x27;, function () &#123; alert(&#x27;submit!&#x27;); &#125;);&#125;); 也可以像前一般简化不用on方法： 1234567 $(document).on(&#x27;ready&#x27;, function () &#123; $(&#x27;#testForm).submit(function () &#123; alert(&#x27;submit!&#x27;); &#125;);&#125;); 甚至*read* 事件还可以再简化： *$(document).on('ready', function ()...* ---> *$(function ()..* 1234$(function () &#123; console.log(&#x27;init A...&#x27;);&#125;); ### 事件触发条件 事件的触发总是由用户操作引发的，但是，比如用JavaScript代码去改动文本框的值，不会触发`change`事件： 12var input = $(&#x27;#test-input&#x27;);input.val(&#x27;change it!&#x27;); // 无法触发change事件 我们可以通过直接调用无参数 *change()* 方法手动触发事件： 123var input = $(&#x27;#test-input&#x27;);input.val(&#x27;change it!&#x27;);input.change(); // 触发change事件 #### 浏览器安全限制 在浏览器中，有些 *JavaScript* 代码只有在用户触发下才能执行。例如，`window.open()`函数： 12345// 无法弹出新窗口，将被浏览器屏蔽:$(function ()&#123; window.open(&#x27;/&#x27;);&#125;); 这些“敏感代码”只能由用户操作来触发。 ### 综合测试 有以下 *Form* 表单： 1234567891011121314&lt;form id=&quot;test-form&quot; action=&quot;test&quot;&gt; &lt;legend&gt;请选择想要学习的编程语言：&lt;/legend&gt; &lt;fieldset&gt; &lt;p&gt;&lt;label class=&quot;selectAll&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; &lt;span class=&quot;selectAll&quot;&gt;全选&lt;/span&gt; &lt;span class=&quot;deselectAll&quot;&gt;全不选&lt;/span&gt; &lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;lang&quot; value=&quot;python&quot;&gt; Python&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;lang&quot; value=&quot;ruby&quot;&gt; Ruby&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;lang&quot; value=&quot;haskell&quot;&gt; Haskell&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;lang&quot; value=&quot;scheme&quot;&gt; Scheme&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/p&gt; &lt;/fieldset&gt;&lt;/form&gt; > 要求完成： > > - 当用户勾上“全选”时，自动选中所有语言，并把“全选”变成“全不选” > - 当用户去掉“全不选”时，自动不选中所有语言，并把“全不选”变成“全选” 12345678910111213141516171819&#x27;use strict&#x27;;var form = $(&#x27;#test-form&#x27;), langs = form.find(&#x27;[name=lang]&#x27;), selectAll = form.find(&#x27;label.selectAll :checkbox&#x27;), selectAllLabel = form.find(&#x27;label.selectAll span.selectAll&#x27;), deselectAllLabel = form.find(&#x27;label.selectAll span.deselectAll&#x27;), invertSelect = form.find(&#x27;a.invertSelect&#x27;);// 重置初始化状态:form.find(&#x27;*&#x27;).show().off();form.find(&#x27;:checkbox&#x27;).prop(&#x27;checked&#x27;, false).off();deselectAllLabel.hide();// 拦截form提交事件:form.off().submit(function (e) &#123; e.preventDefault(); alert(form.serialize());&#125;); 接上，绑定事件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var isAllSelected = false;selectAll.click( function() &#123; if(!isAllSelected ) &#123; langs.each ( /* 不能用lambada表达式，应该下面this都未绑定正确？ 经过测试在function()&#123;...&#125; this绑定正确。 */ // () =&gt; this.checked = &#x27;checked&#x27; // () =&gt; $(this).prop(&#x27;checked&#x27;,true) function() &#123; /* attr无法成功设置属性 ：不起作用？ */ // $(this).attr(&#x27;checked&#x27;,&#x27;checked&#x27;) ; $(this).prop(&#x27;checked&#x27;,true); // 测试成功 &#125; ) deselectAllLabel.show(); selectAllLabel.hide(); selectAll.prop(&#x27;checked&#x27;,false); isAllSelected = true; &#125; else &#123; langs.each ( /* 不能用lambada表达式，应该下面this都未绑定正确？ 经过测试在function()&#123;...&#125; this绑定正确。 */ // () =&gt; this.checked = &#x27;checked&#x27; // () =&gt; $(this).prop(&#x27;checked&#x27;,true) function() &#123; /* attr无法成功设置属性 ：不起作用？ */ // $(this).attr(&#x27;checked&#x27;,&#x27;checked&#x27;) ; $(this).prop(&#x27;checked&#x27;,false); // 测试成功 &#125; ) deselectAllLabel.hide(); selectAllLabel.show(); isAllSelected = false; &#125; &#125;); 可以利用*jQuery* 批量操作特点，不用*each()*遍历: 1234567891011121314151617181920212223242526var isAllSelected = false; // 判断此时单选框是：全部勾选 OR 全不勾选selectAll.click( function() &#123; if(!isAllSelected ) &#123; // 全部勾选 langs.prop(&#x27;checked&#x27;,true); // 全选隐藏、全不选显示 deselectAllLabel.show(); selectAllLabel.hide(); selectAll.prop(&#x27;checked&#x27;,false); isAllSelected = true; &#125; else &#123; // 全部取消勾选 langs.prop(&#x27;checked&#x27;,false); // 全选显示，全不选隐藏 deselectAllLabel.hide(); selectAllLabel.show(); isAllSelected = false; &#125; &#125;); ## 6.4 动画 用 *JavaScript* 实现动画，比如实现淡出效果，让选中元素在1s内改变 *CSS* *opacity（透明度）* 属性值至0。 本质都是通过修改CSS属性，*jQuery* 封装了函数让这一切变得更加简单。 ### 逐渐显隐 无参数的 *show()、hide()* 方法直接显示、隐藏元素；有参数指定时间可以实现动画效果。 | 方法 | 描述 | | :------------------------: | :----------------------------------------------------------: | | *show(timeSeconds,func)* | 在指定 *timeSeconds* 显示全部，*func* 指定显示完成后指定的方法 | | *hide(timeSeconds,func)* | 在指定 *timeSeconds* 隐藏全部，*func* 指定显示完成后指定的方法 | | *toggle(timeSeconds,func)* | 根据当前状态，自动调用 *show()、hide()* 方法 | - *timeSeconds* 以毫秒为单位，同时可以用 *‘slow’、‘fast’* 等特殊字符串作为参数值。 - 显示过程是从左上角 ---> 展开铺满整个平面 ；隐藏则是从右下角 --> 隐藏整个平面。 > :slightly_smiling_face: 简单实例 123456var div = $(&#x27;#test-show-hide&#x27;);// 在1秒钟内逐渐消失div.hide(1000); // 在0.6秒钟内逐渐显示div.show(&#x27;slow&#x27;); 就像此前说过，上面显示是从左上展开，下面方法可以从垂直方法逐渐展开、收缩 ~ just like 拉窗帘。 | 方法 | 描述 | | :-----------------------------: | :--------------: | | *slideUp(timeSeconds,func)* | 拉窗帘般显示 | | *slideDown(timeSeconds,func)* | 拉窗帘般收起隐藏 | | *slideToggle(timeSeconds,func)* | 自动调用上面方法 | ### 淡入淡出 *fadeIn() 、fadeOut()* 可通过不断设置 *DOM* *CSS* *opacity* 属性来实现淡入淡出动画效果。 | 方法 | 描述 | | :----------------------------: | :--------------: | | *fadeIn(timeSeconds,func)* | 淡入显示 | | *fadeOut(timeSeconds,func)* | 淡出隐藏 | | *fadeToggle(timeSeconds,func)* | 自动调用上面方法 | 存在以下表格： ![1565600702619](https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565600702619.png) > 试完成以下代码，使得每次删除表中第一项可以淡出显示。 123456789&#x27;use strict&#x27;;function deleteFirstTR() &#123; var tr = $(&#x27;#test-table&gt;tbody&gt;tr:visible&#x27;).first(); // 在以下完成事件绑定...&#125;deleteFirstTR(); 完成的代码如下： 1tr.fadeOut(1000,() =&gt; tr.remove()); ### 自定义动画 对上面提供的动画效果不满意？尝试自定义动画吧。 | 方法 | 描述 | | :-----------------------------------: | :----------------------------------------------------------: | | *animate(cssStyle，timeSeconds,func)* | 在指定*timeSeconds* 达到预设*cssStyle* 值，最后执行 *func* 函数 | 现在我们来试试自定义实现上面淡出删除表格效果吧。 > 淡出删除表格。 12345678910&#x27;use strict&#x27;;function deleteFirstTR() &#123; var tr = $(&#x27;#test-table&gt;tbody&gt;tr:visible&#x27;).first(); // 在以下完成事件绑定... tr.animate(&#123; opacity:0 &#125;, 1000, () =&gt; tr.remove())&#125;deleteFirstTR(); ### 串行动画 如果有两个动画效果： 12345var div = $(&#x27;#test-animates&#x27;);// 放大div.animate( &#123; width: &#x27;256px&#x27;, height: &#x27;256px&#x27;&#125;, 2000);// 缩小div.animate( &#123; width: &#x27;128px&#x27;, height: &#x27;128px&#x27;&#125;, 2000); 希望实现放大 --> 缩小 连续动画效果，如果这样简单的连续执行两个动画： 1div.animate( &#123; width: &#x27;256px&#x27;, height: &#x27;256px&#x27;&#125;, 2000).animate( &#123; width: &#x27;128px&#x27;, height: &#x27;128px&#x27;&#125;, 2000); 是无法实现的，因为：*动画需要执行一段时间，所以jQuery必须不断返回新的Promise对象才能后续执行操作* 。 所以我们需要借助 *delay()* 方法实现暂停，给予时间返回新的 *Promise* 对象执行后续操作： 123div.animate( &#123; width: &#x27;256px&#x27;, height: &#x27;256px&#x27;&#125;, 2000) .delay(1000) .animate( &#123; width: &#x27;128px&#x27;, height: &#x27;128px&#x27;&#125;, 2000); ### 动画没有效果？ *jQuery* 动画的原理是逐渐改变 *CSS* 值，而有些情况是无法改变成功的。例如： - *slideUp()* 逐渐把*CSS*属性*height* --> 0，但是非*block* 属性值*DOM* 元素对它们设置 *height* 是不起作用的。 - *animate()* 设置 *background-color* 没有效果，因为 *jQuery* 没有实现。","categories":[{"name":"前端","slug":"前端","permalink":"https://hwh.zone/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://hwh.zone/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hwh.zone/tags/JavaScript/"}]},{"title":"Python 基础笔记","slug":"Python基础学习","date":"2021-11-25T10:40:15.008Z","updated":"2021-11-26T14:11:54.929Z","comments":true,"path":"2021/11/25/Python基础学习/","link":"","permalink":"https://hwh.zone/2021/11/25/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"第一章：函数基础 1.1 字符串 1.1.1 编码 字符串和比特 常见字符串和比特表示方法见下： 123456# 字符串表示的两种方法print(&#x27;i am string&#x27;); # i am stringprint(r&#x27;i am string&#x27;); # i am string# byte表示：前面加bprint(b&#x27;i am byte&#x27;); # b&#x27;i am byte&#x27; 注意到最后byte 字符串输出结果有些奇怪，不像字符串直接输出双引号的内容。 我们还可以将字符串 str 编码成 bytes： 方法 描述 encode(‘ascii’) 可将纯英文编码成 bytes，如果含中文编码会出错 encode(‘utf-8’) 可将含中文字符串编码成 bytes 123456# 字符串编码成bytestrTobyte = &#x27;hwh&#x27;.encode(&#x27;ascii&#x27;);print(strTobyte); # 输出：b&#x27;hwh&#x27;strTobyte = &#x27;黄旺辉&#x27;.encode(&#x27;utf-8&#x27;);print(strTobyte); # 输出：b&#x27;\\xe9\\xbb\\x84\\xe6\\x97\\xba\\xe8\\xbe\\x89&#x27; 当然我们也可以用*decode()*函数进行解码： 方法 描述 decode(‘uft-8’) 将bytes 变为 str 12a = b&#x27;\\xe9\\xbb\\x84\\xe6\\x97\\xba\\xe8\\xbe\\x89&#x27;.decode(&#x27;utf-8&#x27;);print(a); # 输出：黄旺辉 1.1.2 格式字符串 格式化字符串有两种方式：一种类C语言使用%占位符；一种利用 format 方法实现。 %占位符方式 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 还可指定长度、精度等： 指定长度：%2d —&gt; 表示整数占位2空格，不足补空格； %02d —&gt;同样表示正式占位2空格，但不足补0 指定精度：%.1f —&gt; 表示小数保留1为小数 以上为占位符方式，以下为举例： 12&gt;&gt;&gt; &#x27;%s 今年 %d 岁啦！&#x27;%(&#x27;黄旺辉&#x27;,23)&#x27;黄旺辉 今年 23 岁啦！&#x27; format() 格式化 在字符串方式format() 内部使用的占位符依次为：{0}、{1} … 12&gt;&gt;&gt; &#x27;&#123;0&#125; 今年 &#123;1&#125; 岁啦！&#x27;.format(&#x27;黄旺辉&#x27;,23)&#x27;黄旺辉 今年 23 岁啦！&#x27; 1.2 list &amp; tuple 1.2.1 列表：list list 类似我们此前接触的 C/C++/C# 数组，但是可以每个元素类型可以不同，比如： 1&gt;&gt;&gt; L = [&#x27;Apple&#x27;, 123, True]; 特别的当，当元素类型也为数组时就可以看做一个多维数组了： 1&gt;&gt;&gt; L = [[&#x27;C#&#x27;,C&#x27;,&#x27;C++&#x27;],[&#x27;JAVA&#x27;,&#x27;JAVASCRIPT&#x27;],[&#x27;PYTHON&#x27;,&#x27;PHP&#x27;]]; 此时获取 JAVASCRIPT ： 12&gt;&gt;&gt; L[1][-1]&#x27;JAVASCRIPT&#x27; 更多增删查改操作见下。 索引 索引从0开始，python 不但可以使用 自然数从正序 开始索引，还可以使用 负数从倒序 开始索引。 1234567891011&gt;&gt;&gt; classmates = [&#x27;hwh&#x27;,&#x27;lt&#x27;,&#x27;dxj&#x27;,&#x27;fs&#x27;]# 正序索引从0开始（正序第一个）&gt;&gt;&gt; classmates[0]&#x27;hwh&#x27;# 倒序索引从-1开始(倒序第一个)&gt;&gt;&gt; classmates[-1]&#x27;fs&#x27;&gt;&gt;&gt; classmates[-2]&#x27;dxj&#x27; ⚠️ 索引越界抛出IndexErro 错误！ 插入 给list 插入数据有两种方法： 方法 描述 append(data) 在list 表末尾 插入数据 insert(index,data) 在指定 位置 index 插入数据 1234567891011&gt;&gt;&gt; classmates = [&#x27;hwh&#x27;,&#x27;lt&#x27;,&#x27;dxj&#x27;,&#x27;fs&#x27;]# append()方法classmates.append(&#x27;lhy&#x27;)classmates[&#x27;hwh&#x27;, &#x27;lt&#x27;, &#x27;dxj&#x27;, &#x27;fs&#x27;, &#x27;lhy&#x27;]# insert()方法classmates.insert(0,&#x27;ljx&#x27;)classmates[&#x27;ljx&#x27;, &#x27;hwh&#x27;, &#x27;lt&#x27;, &#x27;dxj&#x27;, &#x27;fs&#x27;, &#x27;lhy&#x27;] 修改 要将元素A替换成别的元素B，直接赋值即可。 123&gt;&gt;&gt; classmates[-1] = &#x27;赖浩源&#x27;&gt;&gt;&gt; classmates[&#x27;ljx&#x27;, &#x27;hwh&#x27;, &#x27;lt&#x27;, &#x27;dxj&#x27;, &#x27;fs&#x27;, &#x27;赖浩源&#x27;] 删除 方法 描述 pop(index) 删除指定位置 index 元素，不带参数则删除末尾元素 ，返回值为被删除的元素 123456&gt;&gt;&gt; classmates.pop();&#x27;赖浩源&#x27;&gt;&gt;&gt; classmates.pop(0);&#x27;ljx&#x27;&gt;&gt;&gt; classmates[&#x27;hwh&#x27;, &#x27;lt&#x27;, &#x27;dxj&#x27;, &#x27;fs&#x27;] 1.2.2 不可变列表：tuple tuple 和 list 和相似，但是它里面元素不可以改变，可看做是一个常数列表 。它简单定义如下： 1234&gt;&gt;&gt; t = (); # 空列表&gt;&gt;&gt; t = (&#x27;Apple&#x27;, 123, True);&gt;&gt;&gt; t[-1];True 但是注意当只有一个元素时不能写做： 1&gt;&gt;&gt; t = (1); 这会和 python 数学公式中小括号产生歧义，此时定义的不是 tuple ，而是计算结果1这个数。为此我们需要加一个逗号消除歧义： 1&gt;&gt;&gt; t = (1,); 1.3 循环 1.3.1 for 循环 在其它语言循环遍历集合有两种方式： for、while 循环：根据元素下标遍历集合 foreach 循环：直接获取集合每个元素 python 只有：for、while 两种，但是python 中 for 循环其实更类似于其它语言foreach循环。 C++语言尝试遍历列表：L = ['hwh','lt','dxj','fs'] 。 遍历 0~length(L)-1 的下标索引来打印出数组 12for(int i = 0; i &lt; length(L); i++) print(L[i]); 利用 foreach 循环，获取列表每个元素打印数组 12foreach(int x in L) print(x); python 中遍历：L = ['hwh','lt','dxj','fs']。 根据 python for 循环基本类似 foreach 循环获取集合元素特性遍历 12for x in L: print(x); 巧妙达到用下标索引打印数组 在 python 中提供 rang(start,end) 函数，可生成 start~end-1 连续整数列表。从而根据下标索引打印数组： 12for i in range(0,len(L)): print(L[i]); 更多有关 range 函数 函数 描述 range(start,end) 生成指定从 start~end-1 连续整数列表 range(end) 生成指定从 0~end-1 连续整数列表 注意 range 生成的整数不包含最后一个指定参数整数。 尝试生成列表：[0,1,2,3] 。 12&gt;&gt;&gt; l = range(4);&gt;&gt;&gt; l = range(0,4); 1.3.2 while 循环 while 循环和以前接触相同同，不再赘述。 1.4 dict &amp; set 1.4.1 dict dict 即字典，在别的语言中又称为 map ，都是采用键值对(key-value)形式 ，查找速度极快。且有以下特点： dict 一个 key 只能对应一个 value ，重复对一个key 赋值会把前面值替换 简单增、删、查、改方式举例。 123456789101112131415161718192021&gt;&gt;&gt; dic = &#123;&#125;;# 增：给不存在键值赋值，即可增加一堆键值对&gt;&gt;&gt; dic[&#x27;shazi&#x27;] = &#x27;lt&#x27;;&gt;&gt;&gt; dic&#123;&#x27;shazi&#x27;: &#x27;lt&#x27;&#125;# 查：直接根据键值查找&gt;&gt;&gt; dic[&#x27;shazi&#x27;];&#x27;lt&#x27;# 改：给存在的键值赋新值，即可改&gt;&gt;&gt; dic[&#x27;shazi&#x27;] = &#x27;fs&#x27;;&gt;&gt;&gt; dic&#123;&#x27;shazi&#x27;: &#x27;fs&#x27;&#125;# 删：pop(key)方法即可删除&gt;&gt;&gt; dic.pop(&#x27;shazi&#x27;);&#x27;fs&#x27;&gt;&gt;&gt; dic&#123;&#125; 还可利用 *get(key,returnValue)*验证指定键值是否存在： 123# 判断键值是否存在：不存在指定返回-1（如果不指定返回None，但是在交互环境什么都不显示）&gt;&gt;&gt; dic.get(&#x27;shazi&#x27;,-1);-1 1.4.2 set set 和 dict 类似，是一组 key 集合 ，但不存储 value ，且： set 中 key 值不能重复 set 和 dict 都不是有序的 创建一个set ，需要 list 作为输入集合： 123&gt;&gt;&gt; s = set([1,2,3]);&gt;&gt;&gt; s&#123;1, 2, 3&#125; 简单 set 增、删、改、查如下。 1234567891011121314# 增：add方法，参数是字符串类型，带双引号&gt;&gt;&gt; s.add(&#x27;a&#x27;);&gt;&gt;&gt; s&#123;1, 2, 3, &#x27;a&#x27;&#125;# 删：remove方法，参数是字符串类型，带双引号&gt;&gt;&gt; s.remove(&#x27;a&#x27;)&gt;&gt;&gt; s&#123;1, 2, 3&#125;# 查：必须要先转换为list类型&gt;&gt;&gt; l = list(s);&gt;&gt;&gt; l[0];1 set 可以看做数学意义上无序、重复元素集合。因此还可以做交集、并集等操作。 123456&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2&#123;2, 3&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 4&#125; 1.5 函数 1.5.1 基本定义 下面展示了在 python 如何定义一个函数（注意冒号），且带默认参数。 123456# python 没有三目运算符def max(x,y = 5): if x &gt; y : return x; else: return y; 在上面除了必选参数、默认参数还有： 可变参数：定义为可变的参数的形参，接收的实参可以是多个（组成 tuple ） 关键字参数：定义为关键字的参数的形参，接收的实参可以是多个（组成 dict ） 命名关键字参数：通过分隔符 * 可限制关键字参数的名字 以上在下节1.5.2 会详细讲述，我们再来看一下 python 其它特性。 可变和不可变对象 什么是可变/不可变对象？ 简单来说：就是可变对象A充当函数实参 时，函数内部对形参 A进行修改，会同步改变A。 这是因为可变对象传递的是一个地址（引用传递），而不可变对象传递的是一份拷贝（值传递）！ 常见可变对象/不可变对象： 不可变对象：Number ,String , Tuple，bool 可变对象：List , Set , Dictionary 匿名函数 python 中匿名函数直接用 lambda 表达式表达，其语法格式为： lambda 参数列表 : 执行语句 执行语句只有一条，不用写 return ，返回值就是表达式结果。 筛选出所有奇数。 12&gt;&gt;&gt; L = list(filter(lambda n:n%2==1, range(1, 10)))[1, 3, 5, 7, 9] 1.5.2 返回值 return 返回多个值 在 python 函数中可以返回多个值，但实际它返回的是一个元组 tuple： 123def test(): return 1,2,3;print(test()); # (1, 2, 3) 这个时候利用解构赋值，可以接收函数返回值： 1x,y,z = test(); # x=1 y=2 z=3 返回函数 &amp; 闭包 参照：JavaScript 笔记 &amp; 阮一峰的闭包博客 。 🙂 什么是闭包？ 简单来说，就是一个函数，内部定义了一个函数并返回。 🙂 为什么要有闭包？ 读取函数内部变量 让变量值始终保存在内存中 下面开始详细介绍闭包两个作用。 读取函数变量值。 我们知道，根据作用域规则函数内部的变量、参数是无法被外部获取 的。 12345def test(a): b = 1;a; # 错误：无法读取b; # 错误：无法读取 但是，如果我在内部再定义一个子函数，返回变量、参数，最后再返回该子函数： 12345678def test(a): b = 1; def f(): return a,b; return f;f = test(0);a,b = f();print(a,b); # 输出：0 1 这样闭包便起到函数内、外部沟通的桥梁。 让变量始终保存在内存中。 1234567891011def test3(): x = 0; def f3(): nonlocal x; x += 1; return x ; # 直接 return x+=1 出错？ return f3;f3 = test3();print(f3()); # 输出：1print(f3()); # 输出：2print(f3()); # 输出：3 在内部子函数 f3() 对x进行修改，会屏蔽掉外部函数对 x 定义，这样内部函数 f3() 使用 x 会显示未定义。所以必须使用 nonlocal 关键字，让编译器知道这是前面已定义的 x。 为什么每次调用 f3() 输出的值都不一样？ 这是因为函数内部定义了子函数形成了闭包，函数的变量x都会保存在内存中，并没有消亡。 不要引用循环变量！ 子函数（返回函数）不要引用循环变量！这是因为返回函数不会立即执行，直到调用它才会执行。 123456789def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count() count() 函数尝试返回 i = 1,2,3 对应的不同函数。当我们尝试去执行它们： 123456&gt;&gt;&gt; f1()9&gt;&gt;&gt; f2()9&gt;&gt;&gt; f3()9 发现函数执行结果都是 9，这是因为返回的函数f1、f2、f3没有立即执行。而当执行它们是 i 都已经是9了。 1.5.3 函数参数 可变参数 试想如果一个函数接收参数不确定，比如计算用户输入的若干数字之和。当然我们可以用 列表接收多个参数： 1234567def sum(nums): sum = 0; for x in nums: sum += x; return sum;sum([1,2,3,4,5]); // 15 采用可变参数形式，来接收多个参数。 1234567def sum(nums): sum = 0; for x in nums: sum += x; return sum;sum(1,2,3,4,5); // 15 可见相比用列表接收参数，在调用时不用传递一个列表而是一个个传递参数即可，简洁明了。 如果定义了可变参数，又想传递一个列表呢？在调用时加上* 即可 。 12L = [1,2,3,4,5];print(sum(*L)); // 15 关键字参数 关键字参数类同可变参数，但它不同于可变参数接收多个参数组成 tuple 而是组成一个 dict 。 12345def person(name,age,**other): print(other);# 输出：&#123;&#x27;university&#x27;: &#x27;chongqingU&#x27;, &#x27;city&#x27;: &#x27;fuzhou&#x27;&#125;person(&#x27;hwh&#x27;, 20, university=&#x27;chongqingU&#x27;, city=&#x27;fuzhou&#x27;); 同样的它也解决 传递若干参数不用传递一个dict ，而是传递一个个 key:value 值就可以了 。 同前，如果已经定义了关键字参数，又想传递一个dict ，加上 ** 即可： 12dic = &#123;&#x27;university&#x27;: &#x27;chongqingU&#x27;, &#x27;city&#x27;: &#x27;fuzhou&#x27;&#125;;person(&#x27;hwh&#x27;, 20, **dic); ⚠️ other 获取的是 dic 一份拷贝，对 other 修改不会影响 dic 。 命名关键字参数 在上述关键字参数中，会将传递进来的若干 key:value 参数组成 dict 。但是，有时候我们希望传递的 key 为指定名字，且个数被限定 。 这个时，可以使用命名关键字，不同于关键字参数 **other ，命令关键字使用一个特殊分隔符 *： 1234def person(name,age,*,Uni,City): print(name,age,Uni,City);person(&#x27;hwh&#x27;,23,Uni = &#x27;chongQingU&#x27;,City = &#x27;fuzhou&#x27;); # hwh 23 chongQingU fuzhou 在以下情况，没有传递正确命名关键字参数会出错： 传递参数不带 key，只传 value 值 ，出错： 1person(&#x27;hwh&#x27;,23,&#x27;chongQingU&#x27;,&#x27;fuzhou&#x27;); # 出错 或者不是 key 值并不是限定的名字，出错： 1person(&#x27;hwh&#x27;,23,u=&#x27;chongQingU&#x27;,c=&#x27;fuzhou&#x27;); # 出错 或传递了多余参数，出错： 1person(&#x27;hwh&#x27;,23,Uni = &#x27;chongQingU&#x27;,City = &#x27;fuzhou&#x27;,height = 173); # 出错 关键字组合 必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是顺序： 必选参数 、 默认参数 、可变参数、命名关键字参数、关键字参数！ 1.6 基本类型转换 第二章：高级特性 2.1 切片 试想下有一数组和字符串，如何获取它们各自前三个元素？ 12L = [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;];S = &#x27;python.py&#x27;; 我们可以联想到 ：C# 中 substring() 进行 字符串 截取；JavaScript 中 slice() 方法，进行 数组、字符串 截取。 在 python 中提供了类似 JavaScript 中 slice() 方法 ，进行更加优雅的 列表（数组）、元组、字符串 截取。 12345678910111213# 1.截取数组# 第一个索引是0，还可以省略，L[:3]&gt;&gt;&gt; L[0:3] [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]# 2.截取字符串&gt;&gt;&gt; S[:3]&#x27;pyt&#x27;# 3.截取元组&gt;&gt;&gt; t = (1,2,3,4,5);&gt;&gt;&gt; t[:3](1, 2, 3) 第二个索引值一定要比第二个索引大！特别注意负数情况 第一个索引是0，可以省略；最后一个索引是列表长度，也可以省略 所以，下面获取的是整个列表。 12&gt;&gt;&gt; L[:]&gt;&gt;&gt; [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;] 2.1.1 切片更多技巧 索引使用负数 注意，第二个索引一定要比第一个索引大，换言之只能从数组头到尾方向切片！ 123&gt;&gt;&gt; L = [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;];&gt;&gt;&gt; L[-6:-2];[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;] 指定间隔取数 L[s:e:j] : 截取数组指定 [s:e] 范围， 然后每隔 j 个数取出数，返回一个新数组。 取出数组下标为奇数元素。 123&gt;&gt;&gt; L = [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;];&gt;&gt;&gt; L[1::2][&#x27;B&#x27;, &#x27;D&#x27;] 2.2 列表生成式 什么是列表生成式？简而言之，就是快速创建列表的表达式，类似 lambada 表达式生成函数。 生成式格式：[变量运算表达式 变量来源表达式 限制变量表达式 ] 最简单的利用 range(s,e) 来生成一个列表： 12&gt;&gt;&gt; list(range(1, 11))[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 利用列表生成式可写作： 12&gt;&gt;&gt; [x for x in range(1,11)][1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 变形1：在 1 - 11 中删选出为偶数的数字，且开平方作为为列表元素。 我们需要改变元素运算表达式开方，和增加限制变量表达式判断是否为偶数。 12&gt;&gt;&gt; [x*x for x in range(1,11) if x%2 == 0]; # 注意，判断条件是 == 号[4, 16, 36, 64, 100] 变形2：将字典 &#123;1:'one',2:'two',3:'three'&#125; 变为列表 ['1=one','3=three'] 。 利用 for 循环迭代字典获取 key、value，在元素运算表达式中拼接即可。 12&gt;&gt;&gt; [str(k)+&#x27;=&#x27;+v for k,v in &#123;1:&#x27;one&#x27;,2:&#x27;two&#x27;,3:&#x27;three&#x27;&#125;.items() if k!=2 ];[&#x27;1=one&#x27;, &#x27;3=three&#x27;] 前面都是 if 判断条件都限制遍历的集合，下例可以限制生成的值。 遍历['hwh','lt','fs'] ,如果是 'hwh'就对应生成列表对应元素数字1，否则生成0。 12&gt;&gt;&gt; [1 if name==&#x27;hwh&#x27; else 0 for name in [&#x27;hwh&#x27;,&#x27;lt&#x27;,&#x27;fs&#x27;] ][1 0 0] 2.3 生成器 在前面我们利用 列表生成式 可以快速生成列表。但是： 如果生成列表很大，如百万个元素，但后面很多元素当前不会用到，浪费空间存储又必须要保存怎么办呢？ 这个时候就可以利用生成器，只保存列表元素的推算算法，需要用到时可以不断推算出来。 创建一个 generator 和 列表生成式很像，只不过把 [] 变为了 () : 123&gt;&gt;&gt; g = (x * x for x in range(6))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 直接打印 g 是不会显示生成的列表，因为保存的是推算算法，我们可以利用 next() 函数 或者 直接 for 循环迭代： 1234567891011121314&gt;&gt;&gt; g = (x for x in range(6))&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)2# 注意：因为已经前面已经next获取到2了，下面是从3开始打印&gt;&gt;&gt; for x in g:... print(x);... 345 2.3.1 yield 返回：进一步理解生成器 观测下面有多个 yield 返回值函数： 1234567&gt;&gt;&gt; def g():... yield 1;... yiled 2;... yield 3;&gt;&gt;&gt; o = g();&gt;&gt;&gt; o&lt;generator object g at 0x000001B9C07059A8&gt; 可以看到，函数返回 的是一个 generator 对象，类似的可以通过 *next()*函数 或者 for 迭代 获取多个返回值。 12345678&gt;&gt;&gt; next(o)1&gt;&gt;&gt; next(o)2&gt;&gt;&gt; next(o)3&gt;&gt;&gt; next(o)Traceback (most recent call last): 在这里，我们基本就可以明白，生成器 (表达式) 本质是生成了一个有多个 yield 返回值的 generator 对象。 我们还可以将 斐波拉契数列 利用生成器依次打印出来。 常规定义的 fib() 函数如下： 1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print b # 打印生成的数字 a, b = b, a + b n = n + 1 return &#x27;done&#x27; 我们只需要将本该打印数字 print b ，变为返回 yeild b 即可。 1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b # 打印生成的数字 a, b = b, a + b n = n + 1 return &#x27;done&#x27; 然后利用函数返回 generator 对象打印出来： 123456789f = fib(5);next(f);1next(f);1next(f);2next(f);3 注意：generator 对象拿不到 return 语句的返回值。 2.4 for 迭代 什么是迭代？ 在其它语言也有类似的迭代器概念，换言之就是如何一种方式遍历各种类型数据结构集合。 python 中 for 循环是一种比其它语言 for 更高度抽象的概念，可直接作用于 for 循环迭代的数据类型有： 集合类型：如 list、tuple、dict、set、str等 generator 类型：包括 生成器 、带 yield 的 generator 函数 2.4.1 集合类型迭代 迭代 list &amp; tuple 12345&gt;&gt;&gt; for x in [1,2,3]:... print(x) &gt;&gt;&gt; for x in (1,2,3):... print(x) 试着分析下面列表迭代，元素类型为元组。 123456&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:... print(x, y)...1 12 43 9 这里同时引用了2个变量：因为列表的元素也是集合类型（元组），可以类似解析构值，将元组值赋值给 x、y。然后每一次循环都赋值一次，遍历所有元组打印。 ⚠️ 注意下面 key-value 字典不可以直接解析构值，要先利用 items() 方法变为元组，详情见下。 迭代 dict 12345678910111213# 迭代字典keyfor k in &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;: print(k); # 输出：a c b# 迭代字典value# 利用values()方法，将字典类型返回为values组成列表for k in &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;.values(): print(k); # 输出：1 2 3# 同时迭代字典 key，value# 利用items()方法for k,v in &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;.items(): print(k,v); # 输出：a 1 b 2 c 3 迭代字符串 12&gt;&gt;&gt; for c in &#x27;ABC&#x27;:... print(c) # 输出：A B C 2.4.2 生成器类型迭代 生成器类型迭代直接 for… in 循环打印即可，可参见 2.3 生成器 一节。 2.4.3 关于迭代更多 判断迭代对象 判断迭代对象利用 instance() 方法判断： 1234567&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance(&#x27;abc&#x27;, Iterable) # str是否可迭代True&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代True&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代False 把列表像字典一样迭代 Python 内置的enumerate(list)函数可以把一个 list 变成 索引-元素对 。 123456&gt;&gt;&gt; for i, value in enumerate([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]):... print(i, value) ...0 A1 B2 C 第三章：函数式编程 3.1 高阶函数 所谓高阶函数即指：函数也是变量，从而可作为另一个函数（高阶函数）参数。 在 JavaScript 中已经详细讲解了 map/reduce 、filter、sorted 等高阶函数 ，但是调用方法、返回值不同： 调用方法：JavaScript 中是数组对象方法， [1,2,3].map(func) ; python 中需要传递两个参数 map(func,[1,2,3]) 。 返回值：JavaScript 中直接返回一个列表；python 中返回一个是一个iterator 惰性序列 ，可以用 next() 逐个打印 、 for 循环 迭代打印 、 list() 方法直接转为列表 。 以下为简单示例。 3.1.1 高级函数示例 映射： map map 高级函数可以原列表元素x根据传递的函数 func 依依映射成新值 func(x)。 123456&gt;&gt;&gt; def f(x):... return x * x...&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81 r 是一个iterator 惰性序列 而非列表，需要 list() 转换为列表，当然也可用 next() 、for 循环迭代打印 事实上，第二个参数并不止可以是列表，还可以是其它可迭代对象集合，比如 str。 利用 map 将字符串 ’123456‘ 转换成数字列表集合 [1, 2, 3, 4, 5, 6] 。 1234567&gt;&gt;&gt; def char2num(s):... digits = &#123;&#x27;0&#x27;:0, &#x27;1&#x27;:1, &#x27;2&#x27;:2, &#x27;3&#x27;:3, &#x27;4&#x27;:4, &#x27;5&#x27;:5, &#x27;6&#x27;:6, &#x27;7&#x27;:7, &#x27;8&#x27;:8, &#x27;9&#x27;:9&#125;&gt;&gt;&gt; return digits[s]&gt;&gt;&gt; r = map(char2num,&#x27;123456&#x27;)&gt;&gt;&gt; list(r);[1, 2, 3, 4, 5, 6] 因为 str 也是可迭代对象，在map 函数迭代中中会依次把 str 每个字符当做一次迭代元素。 char2num 函数如果返回的是 return s ，那么最后结果是返回：['1', '2', '3', '4', '5', '6'] 。 由于实际上 char2num 函数是映射返回数字字符对应数字，所以最后结果是：[1, 2, 3, 4, 5, 6] 。 逐减：reduce 把序列[1, 3, 5, 7, 9]变换成整数13579。 123456&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def fn(x, y):... return x * 10 + y...&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])13579 结合上述两例，便可以将 字符串 转换为对应 数字。 12345678910&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def fn(x, y):... return x * 10 + y...&gt;&gt;&gt; def char2num(s):... digits = &#123;&#x27;0&#x27;:0, &#x27;1&#x27;:1, &#x27;2&#x27;:2, &#x27;3&#x27;:3, &#x27;4&#x27;:4, &#x27;5&#x27;:5, &#x27;6&#x27;:6, &#x27;7&#x27;:7, &#x27;8&#x27;:8, &#x27;9&#x27;:9&#125;... return digits[s]...&gt;&gt;&gt; reduce(fn, map(char2num, &#x27;13579&#x27;)) # map 返回的是一个可迭代对象13579 过滤：filter filter 把传入的函数作用于每个元素，返回值是ture 过滤，false 保留。 删除字符串中所有数字。 12345&gt;&gt;&gt; def isnum(x):... return 1 - (ord(x) &gt;= 48 and ord(x) &lt;= 57);&gt;&gt;&gt; r = filter(isnum, &#x27;A1B2C3&#x27;);&gt;&gt;&gt; list(r);[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;] ⚠️ python bool 运算常见操作误解！ python 中 &amp; | 是位运算，非位运算只能用 and 、or 替换 python 中取反 !b 非法，应该用 1-b 来达到取反效果 排序：sorted sorted(collection,key,reverse) 函数有三个参数： collection ： 可迭代集合数据类型都可 key：函数变量，指定集合元素进行映射，比如都取绝对值等，但只会改变排序结果不会改变集合元素 reverse ：指定是否反转 返回值：是一个列表（不同前高阶函数返回的是一个 genrator 对象）。 给指定字符列表 ['bob', 'about', 'Zoo', 'Credit'] 排序。 python会自动按首字母 ASCII 值给字符串数组排序，不用特定指定规则。 12&gt;&gt;&gt; sorted([&#x27;bob&#x27;, &#x27;about&#x27;, &#x27;Zoo&#x27;, &#x27;Credit&#x27;]);[&#x27;Credit&#x27;, &#x27;Zoo&#x27;, &#x27;about&#x27;, &#x27;bob&#x27;] 接上：将字符串全部变为小写，同时按降序排序。 12&gt;&gt;&gt; sorted([&#x27;bob&#x27;, &#x27;about&#x27;, &#x27;Zoo&#x27;, &#x27;Credit&#x27;],key=str.lower,reverse=True);[&#x27;Zoo&#x27;, &#x27;Credit&#x27;, &#x27;bob&#x27;, &#x27;about&#x27;] 3.2 装饰器 明月装饰了我的窗，我装饰了谁的梦？ 什么是装饰器？ 在不修改函数的前提下，在代码运行期间动态给函数增加功能，称之为装饰器（Decorator）。 比如，现在我们有一个函数 now ，希望每次调用它时都能打印调用信息，但又不改动函数： 12def now(): print(&#x27;2019-9-7&#x27;) 这个时候我们定义一个装饰器函数 log： 12345def log(func): def wrapper(*args, **kw): print(&quot;调用&quot; + func.__name__) return func(*args, **kw) # func是now的形参，但now没有参数啊，这里可以传任意参数？ return wrapper 装饰器本身是一个函数，内部也返回了一个函数 … … … 3.3 偏函数 偏函数是一个语法糖，可用来固定函数某个参数（设置默认值）。其调用方式： functools.partial(func,parameter=value): func，是要固定的函数；parameter=value 是要固定函数参数及值。 固定 int 函数第二个参数值为 2 ，返回函数 int2 使得可默认进行 二进制 --&gt; 十进制 转换。 1234&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2(&#x27;1000000&#x27;)64 3.3.1 关于偏函数参数 实际上偏函数参数是：functools.partial(func,*args,**kw)。 也就是说，下面二者是等价的： 1int2(&#x27;10010&#x27;) 12kw = &#123; &#x27;base&#x27;: 2 &#125;int(&#x27;10010&#x27;, **kw) 没太明白。 当传入： 1max2 = functools.partial(max, 10) 实际上会把10作为*args的一部分自动加到左边，也就是下面二者是等价的： 1max2(5, 6, 7) 12args = (10, 5, 6, 7)max(*args) 第四章：面向对象编程 4.1 python 面对对象快速入门 定义一个类，要求每次创建实例时类属性 count 自动加1，同时可打印成绩 123456789101112131415class Student: count = 0 def __init__(self, name, score): Student.count += 1 self.name = name self.score = score def print_score(self): print(&#x27;%s: %s&#x27; % (self.name, self.score)) if __name__ == &#x27;__main__&#x27;: stu = Student(&#x27;hwh&#x27;, 99) print(stu.count) # 输出：1 self ：在类中定义的函数必须要带有self ，它指向类创建的实例对象。 _init_ : _init_ 是一个特殊的函数用于创建实例时进行初始化。 类属性 count &amp; 实例属性 name、score：count是类属性它为所有创建的类实例共享 ；name、score 是实例属性，在创建实例的时候会根据传入的参数初始化。 4.2 面对对象进阶 4.2.1 访问限制 在前面我们定义实例属性，直接用 self.属性名 直接就可以绑定一个实例属性，在外部可以 读取、修改。 但是如果我们不希望进行修改呢？ 在属性名前加上 __ 可变为 私有变量，即 self.__属性名 即可，这样外部不能访问、不能修改 。 123456789101112131415161718class Student(object): def __init__(self, name, score): self.name = name self.__score = score def get_score(self): return self.__score def set_gender(self, score): if type(score) != str: print(&quot;error!&quot;) return -1 self.__score = score if __name__ == &#x27;__main__&#x27;: stu = Student(&#x27;hwh&#x27;, 99) # print(stu.__score) # 出错，不能访问 type 方法可以获取类型属性进行判断，类似的还有 instance 方法。instance 不但可以判断所有type 可判断的类型，还可以方便的判断 类型、实例 之间关系。 如果需要外部需要访问，可定义 get、set 方法。 注意！这不是修改私有变量 在前我们尝试打印出私有变量 __score 出错，但是我们尝试修改似乎成功了？ 12stu.__score = 88print(stu.__score) # 输出：88 其实不然，这和Student 类内部的 __score 不是同一个变量，我们尝试利用 get_score 打印出内部私有变量 __score : 1print(stu.get_gender()) # 输出：99 第五章：IO编程 5.1 增 open(filePath,type) 不仅可用于读写文件，还可在没有文件时创建一个新文件。 mkdir(filePath) 可创建一个目录。 12345# 创建目录 os.makedirs(&#x27;myDir&#x27;)# 创建文件with open(r&#x27;myDir\\myTxt&#x27;, &#x27;w&#x27;) as f: f.write(&#x27;hello world! \\n i \\n am \\n a \\n coder&#x27;) with open as ... 是 python 提供的文件读写操作简单写法，它等价于： 123456try: f = open(r&#x27;myDir\\myTxt&#x27;, &#x27;w&#x27;) f.write(&#x27;hello world! \\n i \\n am \\n a \\n coder&#x27;)finally: if f: f.close() windows 目录路径使用反斜杠\\，为了防止和文本其它字母转义，建议前面用 r 或者 双反斜杆 \\\\ 5.1.1 打开文件模式 模式 r r+ w w+ a a+ 读 + + + + 写 + + + + + 创建 + + + + 覆盖 + + 指针在开始 + + + + 指针在结尾 + + 5.2 删 1234# 删除目录 os.rmdir(&#x27;myDir&#x27;)# 删除文件os.remove(&#x27;test.py&#x27;) 5.3 查：读文件等 5.3.1 文件读 方法 描述 read(filePath) 一次读取所有内容 readline(filePath) 每次读取一行 readlines(filePath) 一次读取所有行，返回列表，每一个元素是一行内容 简单测试读取文本。 123with open(r&#x27;myDir\\myTxt&#x27;, &#x27;r&#x27;) as f: for line in f.readlines(): print(line.strip()) # 去除\\n，要不然会多打印换行 打印前两行。 123with open(r&#x27;myDir\\myTxt&#x27;, &#x27;r&#x27;) as f: for i in range(0,2): print(f.readline().strip()) # 去除\\n，要不然会多打印换行 二进制文件 &amp; 其它编码 如果读取的文件是二进制文件，比如图片、视频 等要用 rb 模式打开文件： 读取二进制文件。 123&gt;&gt;&gt; f = open(&#x27;/Users/michael/test.jpg&#x27;, &#x27;rb&#x27;)&gt;&gt;&gt; f.read()b&#x27;\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...&#x27; # 十六进制表示的字节 如果读取是非UTF-8编码文件，要指定按什么编码格式读取： 读取二进制且编码为gbk 文件。 123&gt;&gt;&gt; f = open(&#x27;/Users/michael/gbk.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;gbk&#x27;)&gt;&gt;&gt; f.read()&#x27;测试&#x27; 5.3.2 查看其它信息 123456# 获取当前文件操作路径os.getcwd()# 获取目录列表（重要）# 该方法获取的不包括文件路径，仅文件名os.listdir(&quot;./&quot;) 5.4 改：写文件等 5.4.1 写文件 写文件也是调用 open() 方法，传入标识符 'w'、’wb‘ 写文本或者二进制文件。 也是采用类似读文件 python 提供的一种简易写法，也可同读文件传入 encoding 参数转换编码。 12with open(&#x27;/Users/michael/test.txt&#x27;, &#x27;w&#x27;) as f: f.write(&#x27;Hello, world!&#x27;) 5.4.2 文件重命名等 12# 对文件重命名&gt;&gt;&gt; os.rename(&#x27;test.txt&#x27;, &#x27;test.py&#x27;) 5.5 序列化与反序列化 序列化：即指可以将把指定类型对象从 内存 —&gt; 磁盘 ； 反序列化：则可将保存在磁盘的对象从 磁盘 —&gt; 内存 。 5.5.1 pickle python 提供了 pickle 模块来进行任意对象的序列化和反序列化，但它序列化只能用于 python。 常用序列化、反序列化方法如下： 方法 描述 pickle.dump(obj, fp, [,protocol]) 将任意对象序列化 pickle.load(fp) 将保存在磁盘的bytes对象反序列化 pickle.dumps(obj, [,protocol]) 将obj 对象序列化为 string 形式，而不是存入文件中。 pickle.loads(string) 从string 中读出序列化前的 obj对象 以下做一个简单实例将 dict 字典类型序列化与反序列化进行io读写。 1234567891011# 序列化：保存在磁盘中d = &#123;&#x27;name&#x27;: &#x27;hwh&#x27;, &#x27;age&#x27;: &#x27;23&#x27;&#125;# 注意：创建一个写二进制文件file对象with open(&#x27;test.txt&#x27;, &#x27;wb&#x27;) as f: pickle.dump(d,f)# 反序列化：从磁盘中读取# 注意：创建一个读二进制文件file对象with open(&#x27;test.txt&#x27;, &#x27;rb&#x27;) as f: dic = pickle.load(f)print(dic) # 输出：&#123;&#x27;name&#x27;: &#x27;hwh&#x27;, &#x27;age&#x27;: &#x27;23&#x27;&#125; 但是 pickle 模块序列化只用于 python ，如何在不同编程语言传递对象？ 我们需要一种标准格式，比如 XML 、JSON ，json 是一种更好的选择。 5.5.2 JSON 因为要在不同语言中传递对象，首先要有一种把python对象 —&gt; 通用语(json) ，它们直接对应关系： JSON 类型 Python类型 {} dict [] list “string” str 1234.56 int 或 float true/false True/False null None 类似 pickle 模块，json 模块提供了序列化，反序列化方法： 方法 描述 json.dump(obj, fp…) 将任意对象序列化 json.load(fp) 将保存在磁盘的bytes对象反序列化 json.dumps(obj) 将obj 对象序列化为 string 形式，而不是存入文件中。 json.loads(string) 从string 中读出序列化前的 obj对象 改写上面 pickle 模块读写。 1234567891011# 序列化：保存在磁盘中d = &#123;&#x27;name&#x27;: &#x27;hwh&#x27;, &#x27;age&#x27;: &#x27;23&#x27;&#125;# 注意：和pickle模块不同这里是 w，不是二进制with open(&#x27;test.json&#x27;, &#x27;w&#x27;) as f: json.dump(d,f)# 反序列化：从磁盘中读取# 注意：这里是rwith open(&#x27;test.json&#x27;, &#x27;r&#x27;) as f: dic = json.load(f)print(dic) # 输出：&#123;&#x27;name&#x27;: &#x27;hwh&#x27;, &#x27;age&#x27;: &#x27;23&#x27;&#125; 不进行io读写，dumps() 序列化为 string，然后 loads() 反序列化读取。 12345678# 序列化d = &#123;&#x27;name&#x27;: &#x27;hwh&#x27;, &#x27;age&#x27;: &#x27;23&#x27;&#125;str = json.dumps(d)# 反序列化# 注意：这里是rdic = json.loads(str)print(dic) # 输出：&#123;&#x27;name&#x27;: &#x27;hwh&#x27;, &#x27;age&#x27;: &#x27;23&#x27;&#125; 自定义序列化规则 在 json 中用 &#123;&#125; 表示对象，对应 python 中 dict 。不过我们一般用 class 表示对象，但是 class 类对象不能直接序列化，需要自己定义序列化规则。 1234567891011121314class Student(object): def __init__(self, name, age, score): self.name = name self.age = age self.score = scoredef student2dict(std): return &#123;&#x27;name&#x27;:std.name, &#x27;age&#x27;:std.age, &#x27;score&#x27;:std.score&#125;s = Student(&#x27;hwh&#x27;, 20, 99)# 输出：&#123;&quot;name&quot;: &quot;hwh&quot;, &quot;age&quot;: 20, &quot;score&quot;: 99&#125;print(json.dumps(s, default=student2dict)) 因为通常class的实例都有一个__dict__属性，它就是一个dict，用来存储实例变量。 所以还可用 lambda 表达式直接简写： 1print(json.dumps(s, default=lambda obj: obj.__dict__))","categories":[{"name":"Python","slug":"Python","permalink":"https://hwh.zone/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hwh.zone/tags/Python/"}]},{"title":"数据库（一）MySQL基础笔记","slug":"数据库（一）MySQL基础笔记","date":"2021-11-25T10:37:31.105Z","updated":"2021-11-25T10:41:32.511Z","comments":true,"path":"2021/11/25/数据库（一）MySQL基础笔记/","link":"","permalink":"https://hwh.zone/2021/11/25/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89MySQL%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/","excerpt":"","text":"第一章 ：初识 MySQL 1.1 MySQL 概述 SQL &amp; 各大数据库 什么是 SQL? SQL 是 Structured Query Language （结构化查询语言）缩写 ，可用来对数据库进行：增、删、查、改 等操作。 SQL 大小写特点？ 关键字：SQL 语言关键字不区分大小写，在本笔记中总是大写 表名 &amp; 列名 ：有些数据库区分、有些不区分 ，在本笔记中总是小写 不同操作系统：同一个数据库可能在Linux上区分大小写，在Windows上不区分大小写。 SQL 和各大数据库之间的关系？ SQL 已经被ANSI组织定义为标准 ，如果我们使用标准 SQL 语言，理论上所有数据都可以支持。但是各大数据都在标准 SQL 上进行了扩展。 如果只使用标准 SQL 核心功能，那么所有数据库都可以执行，而对于各个数据库各自 方言（扩展功能），只能在各自数据库下执行。 关系模型 mysql 基于关系模型，对应其也就是一般我们常说的关系数据库。 什么是关系模型？ 关系模型把数据看作是一个二维表格，任何数据都可以通过*行号 +列号* 来唯一确定： ID 姓名 班级ID 性别 年龄 1 小明 201 M 9 2 小红 202 F 8 关系数据库 同前，基于关系模型数据库都可称为关系数据库，常用关系数据库可分为： 分类 举例 商用 Oracle、SQL Server、DB2 开源 MySQL，PostgreSQL 桌面 Access：适合桌面应用程序使用 嵌入式 Sqlite：适合手机应用和桌面程序 数据类型 对于每一个关系表，需要定义：每一列名字 &amp; 每一列数据类型，常用数据类型如下 名称 类型 说明 INT 整型 4字节整数类型，范围约 ±21亿 BIGINT 长整型 8字节整数类型，范围约 ±922亿亿 REAL 浮点型 4字节浮点数，范围约 ±-1038 DOUBLE 浮点型 8字节浮点数，范围约 ±10308 DECIMAL(M,N) 高精小数 由用户指定精度的小数，例如，DECIMAL(20,10) 表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字串 存储指定长度的字符串，例如，CHAR(100) 总是存储100个字符的字符串 VARCHAR(N) 变长字串 存储可变长度的字符串，例如，VARCHAR(100) 可以存储0~100个字符的字符串 BOOLEAN 布尔 存储 True 或者 False DATE 日期 存储日期，例如，2018-06-22 TIME 时间 存储时间，例如，12:20:59 DATETIME 日期 &amp; 时间 存储日期+时间，例如，2018-06-22 12:20:59 还有一些特殊类型：JSON 等。 1.2 安装 MySQL 安装参考：MySQL-mysql 8.0.11安装教程 1.2.1 下载 点击下载 ：MySQL-8.0.16-winx64.zip 下载地址 不用登陆，直接点击下面蓝字：No thanks,just start my download ，即浏览器开始下载。 1.2.2 解压 浏览器默认下载 zip 压缩包位置：C:\\Users\\86151\\Downloads\\mysql-8.0.16-winx64.zip，解压到你指定位置。 比如我解压到：D:\\软件\\mysql-8.0.16-winx64 1.2.3 配置环境变量 常规操作：搜索 高级系统设置 --&gt; 环境变量 --&gt; 系统变量 --&gt; 选中Path --&gt; 新建： 变量值：即解压后bin所在目录地址：D:\\软件\\mysql-8.0.16-winx64\\bin。 1.2.4 初始化 my.ini 由于解压目录并没有发现 my.ini 文件，所以要自行创建，创建位置：D:\\软件\\mysql-8.0.16-winx64\\my.ini 新建 .txt 文本文件，写入： ⚠️ 注意，下面 basedir &amp; datedir ，一定是你自己的 mysql 安装目录！ 1234567891011121314151617181920212223242526[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=D:\\软件\\mysql-8.0.16-winx64 # 切记此处一定要用双斜杠\\\\# 设置mysql数据库的数据的存放目录datadir=D:\\软件\\mysql-8.0.16-winx64\\\\Data # 此处同上# 允许最大连接数max_connections=200# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 然后重名为：my.ini 即可。 1.2.5 开始安装mysql 首先注意，安装 mysql 必须以管理员身份运行 cmd ，所以win10下：搜索cmd —&gt; 以管理员身份运行 然后依次进行以下操作： 切换到 bin 目录下 1C:\\Windows\\system32&gt; cd D:\\软件\\mysql-8.0.16-winx64\\bin 初始化数据库 出现错误，一般是 my.ini 目录没有配置好，见上。 1C:\\Windows\\system32&gt; mysqld --initialize --console 注意，上图生成了一个临时密码：I_?6&gt;&amp;l*_sw( ，记住它稍后会用到。 安装服务 使用 mysqld --install [服务名] ，服务名可不写，默认为 mysql 1C:\\Windows\\system32&gt; mysqld --install 然后，通过 net start mysql 启动服务： 出错：服务无法启动。后来发现 my.ini 文件的basedir &amp; datedir 没有成功保存修为自己的安装路径。 123C:\\Windows\\system32&gt; net start mysqlMySQL 服务正在启动 .MySQL 服务已经启动成功。 其余补充（以下命令不要执行）： 12net stop mysql # 停止mysql服务sc delete MySQL/mysqld -remove # 卸载mysql服务 更改密码 首先，进入到 mysql： 1C:\\Windows\\system32&gt; mysql -u root -p 会要求输入密码，密码就是上面生成的临时密码：I_?6&gt;&amp;l*_sw( 。 正确输入后会进入出现欢迎界面： 然后，键入语句修改密码为 123456： 1mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;; 第二章 ：关系模型 2.1 主键 记录与字段 在关系数据库中，一张表中的每一行数据被称为一条记录，一条记录就是由多个字段组成的 。 id class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 如上图共有 2 条记录，每条记录有 5个字段。 主键作用 主键用来区分不同记录，如上表 id 则可用来区分不同记录。 主键选取原则 主键不得轻易修改。 主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。 任何业务相关字段不用作主键。 如，身份证号也是一种业务场景，但是如果身份证号升位、变更，主键不得不修改，对业务产生巨大影响。 同理，还有：手机号、邮箱号等。 主键 id 两种类型 通常选取和业务完全无关字段，可命名为 id ，常见 id字段类型为： 自增整数类型 数据库会在插入数据时自动为每一条记录分配一个自增不重复整数，不用自己预先生成主键。 GUID类型 如：8f55d96b-8acc-4636-8cb8-76bf8abc2f57 是一个 GUID 标识符。 GUID 即 Globally Unique Identifier（全球唯一标识符），是微软使用的一个术语，由一个特定的算法，给某一个实体，如Word文档，创建一个唯一的标识，GUID值就是这个唯一的标识码。 联合主键 关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。 id_num id_type other columns 1 A … 2 A … 2 B … 如上表，id_num &amp; id_type 同时作为主键标识每一行数据（每一条记录），允许其中一个主键重复，只要不都重复即可。 2.2 外键 什么是外键？ 在一张表中，通过某个字段，可以把数据可另一张表联系起来，这种列称为外键。 如，在下列有两张构成 一对多 关系表中： ⚠️ 一对一、一对多、多对多：描述的是两个表之间的关系，单个表不存在这种描述！ 如：下两表，class 表中 每个 班级可以对应 student 表中 多 个学生，那么这就是一对多关系； 同理，如果存在一张 studentID 表，每个学号和 student 表 每个学生 一一对应，就是 一对一关系。 ​ student id name other columns… 1 小明 … 2 小红 … ​ class id name other columns… 1 一班 … 2 二班 … 如何在 student 表中，查到小明所属哪个班级呢？ 在 student 表中加入字段 class_id ，关联 class 表： ​ student id class_id name other columns… 1 1 小明 … 2 1 小红 … 如何通过编程实现外键呢？ 首先需要在表中增加一列 class_id ，然后添加外键约束： 1234ALTER TABLE student ADD CONSTRAINT fk_class_id -- 自定义约束名 FOREIGN KEY (class_id) -- 指定student表，外键字段REFERENCES class (id); -- 指定class表，关联外键字段 如果需要删除一个外键约束： 12ALTER TABLE studentDROP FOREIGN KEY fk_class_id; 前面介绍了：一对一、一对多，那么多对多关系如何实现？ 我们知道，上面 student 表 &amp; class 表 一对多关系是单向的，一个班级可以对应多个学生，反之不成立。 如果存在两个表，有双向一对多关系，如下面 teacher 表 &amp; class 表 ： ​ teacher id name 1 张老师 2 王老师 ​ class id name other columns… 1 一班 … 2 二班 … 在这两张表中，一个老师可以对应多个班级，一个班级对应多个老师，则是双向一对多关系。 要实现 多对多 ，则通过中间表关联这两个一对多关系即可： ​ 中间表 id teacher_id class_id 1 1 1 2 1 2 3 2 1 4 2 2 2.3 索引 索引的作用？ 索引注意有两个作用：一、加快查找记录速度 ；二、通过 唯一索引 保证某一列值具有唯一性。 加快索引 如下面存在一个 student 表 ： ​ student id class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 3 1 小军 M 88 我们可以加快 score 列的查询，为其创建索引： 12ALTER TABLE student ADD INDEX idx_score(score); 当然，可以同时为 score 列 &amp; name 列创建索引： 12ALTER TABLE studentADD INDEX idx_score_name(score,name); 那么是否创建索引一定可以加快索引速度呢？ 索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。 反之，如果记录的列存在大量相同的值，如 gender 列，大约一半记录值是M，另一半是F，对该列创建索引就没有意义，甚至会降低查询速度。 唯一索引 前面说到，一些和业务相关的信息如：身份证号、邮箱地址等，不适合作为主键。但是它们又有唯一性，如何保证它们不重复呢？ 这里，我们可以为其添加唯一索引，以保证 student 表 name 唯一性为例： 12ALTER TABLE studentADD UNIQUE INDEX uni_name(name); 有没有其它保持唯一性方法？ 我们还可以添加唯一性约束： 123ALTER TABLE studentADD CONSTRAINT uni_nameUNIQUE (name); 第三章 ： 增、删、改 2.0 登 首先，打开 cmd 切换到 mysql 安装的 bin 目录下进行登陆： 1234C:\\Users\\86151&gt;cd D:\\软件\\mysql-8.0.16-winx64\\binC:\\Users\\86151&gt;mysql -u root -pEnter password: ****** 输入密码后，进行基本 增、删、改 操作（ 查询数据 下一章）。 2.1 增 2.1.1 CREATE 创建 创建数据库 语法：CREATE TABLE &lt;数据库名&gt;; 1mysql&gt; CREATE DATABASE test; -- 注意有分号 我们可以用 SHOW DATEBASES 已存在的数据库： 创建数据表 创建 class 表 语法：CREATE TABLE &lt;表名&gt; (&lt;列名&gt; &lt;列类型&gt;); 1234567mysql&gt; USE test； -- 必须要先引用数据库testmysql&gt; CREATE TABLE class -&gt; ( -&gt; id INT, -- 自动增长C -&gt; name VARCHAR(10) NOT NULL, -&gt; PRIMARY KEY(id) -&gt; ); -- 命令要以分号结束 创建 student 表 12345678910mysql&gt; CREATE TABLE student -&gt; ( -&gt; id INT , -&gt; class_id INT, -&gt; name VARCHAR(10) NOT NULL, -&gt; gender VARCHAR(1), -&gt; score INT, -&gt; PRIMARY KEY(id) -&gt; );Query OK, 0 rows affected (0.14 sec) 设置 student 表外键 我们可以进一步，为 class_id 字段设置为外键： ⚠️ 解析错误：下面其实是一条语句，加 ，会出错！ ⚠️[3780]错误：student 表外键 class_id 与 class表中 id，NULL &amp; UNSIGNED 约束要一致！（为了方便删了这两个约束） 1234mysql&gt; ALTER TABLE student -&gt; ADD CONSTRAINT fk_class_id -&gt; FOREIGN KEY(class_id) -&gt; REFERENCES class(id); 查看表 语法：SHOW TABLES； 查看已经存在的数据表名 语法： DESCRIBE &lt;表名&gt; ; 查看表详细信息 2.1.2 ALTER + ADD ALTER 主要用于字段、约束方面。 增加字段 ALTER 命令 + ADD 子句 ：可用于增加字段（增加列） student 表增加一列，名为 xw 类型为 VARCHAR(1)；（还可增加默认值） 12ALTER TABLE student ADD xw VARCHAR(1); 增加索引 student 表 字段 score增加索引 12ALTER TABLE student ADD INDEX idx_score(score); 增加主键约束 给 test_stu 表新增字段 id，并设为主键。 12ALTER TABLE test_stuADD id INT NOT NULL AUTO_INCREMENT PRIMARY KEY; 1234insert into t_user( avatar, password, id, nickname, email, type, username) values (&#x27;https://unsplash.it/100/100?image=1005&#x27;,&#x27;96e79218965eb72c92a549dd5a330112&#x27;, &#x27;1&#x27;, &#x27;管理员&#x27;, &#x27;380141202@qq.com&#x27;, &#x27;1&#x27;, &#x27;hwh&#x27;); 2.1.3 INSERT 插入数据 下面插入表数据语法，是一条语句故没有， 123INSERT INTO &lt;表名&gt; ( &lt;字段1&gt;, &lt;字段2&gt;,...&lt;字段N&gt; ) VALUES ( value1, value2,...valueN ); ⚠️ 如果数据字符类似，必须加上单/双引号，如 ：“value” class表插入数据 123456mysql&gt; INSERT INTO class(id,name) -&gt; VALUES -&gt; (1,&quot;一班&quot;), -- 多行数据以 , 分隔 -&gt; (2,&quot;二班&quot;), -&gt; (3,&quot;三班&quot;), -&gt; (4,&quot;四班&quot;); student 表插入数据 由于代码较长，用 Notepad++ 写好代码保存 test.sql：SOURCE &lt;test.sql文件地址&gt; 执行。 12345678910111213141516-- 由于代码较长，下面是在Notepad++中编辑，而非命令行中INSERT INTO student(id,class_id,name,gender,score)VALUES (1,1,&quot;小明&quot;,&quot;M&quot;,90),(2,1,&quot;小红&quot;,&quot;F&quot;,95),(3,1,&quot;小军&quot;,&quot;M&quot;,95),(4,1,&quot;小米&quot;,&quot;F&quot;,73),(5,2,&quot;小白&quot;,&quot;F&quot;,81),(6,2,&quot;小兵&quot;,&quot;M&quot;,55),(7,2,&quot;小林&quot;,&quot;M&quot;,85),(8,3,&quot;小新&quot;,&quot;F&quot;,91),(9,3,&quot;小王&quot;,&quot;M&quot;,89),(10,3,&quot;小丽&quot;,&quot;F&quot;,88);-- 下面在cmd中执行，注意不要带 ；！！mysql&gt; source D:\\hwh\\uploadToGit\\code\\mysql\\test.sql 查看表中数据 实际就是查询数据 ：SELECT * FROM &lt;表名&gt;; 2.2 删 2.2.1 DROP 删除数据库 语法：DROP DATABASE &lt;数据库名&gt;; 1mysql&gt; DROP DATABASE hwh; 删除数据表 语法：DROP TABLE &lt;表名&gt;; 1mysql&gt; DROP TABLE temp_table; 2.2.2 DELETE 删除表中记录 为了测试是否删除，在 class 表中，增加一行记录：（5，“五班”） 语法：DELETE FROM &lt;表名&gt; WHERE &lt;条件&gt;； 1mysql&gt; DELETE FROM class WHERE id=5; 经过测试，记录被删除。 2.2.3 ALTER + DROP 删除字段、默认值 ALTER 命令 + DROP 子句 ：删除字段（列）、或者删除指定默认值 删除默认值： 1mysql&gt; ALTER TABLE student ALTER bust_size DROP DEFAULT; 删除字段（列）： 1mysql&gt; ALTER TABLE student DROP bust_size; 删除主/外键约束 语法： ALTER TABLE &lt;表名&gt; DROP FOREGIN/PRIMARY KEY &lt;外键名&gt;; 1ALTER TABALE test_stu DROP PRIMARY KEY ; --主键只有一个不用指定名字 删除索引 1 2.3 改 以下操作都基于 student 表： 2.3.1 UPDATE 语法：UPDATE &lt;表名&gt; SET &lt;字段1&gt; = &lt;新值1&gt; , ... WHERE &lt;条件1&gt; [AND | OR] &lt;条件2&gt;.. ⚠️ SET 设置多个值用 ，分隔； WHERE 设置多个条件用 AND 、OR 分隔； 更新某行记录字段值 修改 id = 10 记录，name 字段值。 123UPDATE student SET name=&#x27;刘婷&#x27;,score=89 WHERE id=10; 修改所有记录某字段值 所有人成绩 +1分。 123-- 不加 WHERE 限定，同时SET可用表达式UPDATE student SET score=score+1; 2.3.2 ALTER ALTER 命令主要是在我们，修改&lt;表名&gt; ；删除或增加 &lt;字段&gt;；修改&lt;字段类型&gt;、&lt;字段名&gt;。 和 UPDATE 区别？ ALTER 比 UPDATE 着眼于更宏观的字段上，而UPDATE 是修改记录某字段 具体值 ； ALTER 不仅可以更新，还可以进行 删除、增加操作； ALTER 还可用于修改 &lt;表名&gt;。 语法格式？ ALTER TABLE &lt;表名&gt; ADD/DROP/MODIFY/CHANGE/RENAME TO/ alter_tbl; 修改字段名、类型、默认值 ALTER 命令 + MODIFY 子句 ：可用于修改 字段类型、设置初始默认值 修改 xw 类型为 INT，初始默认值 B ; ⚠️ MODIFY 、CHANGE 只能在没有默认值设置初始默认值，不能修改默认值！ 12ALTER TABLE student MODIFY xw INT DEFAULT 2; ALTER 命令 + CHANGE 子句 ：可用于修改 字段名 &amp; 类型、设置初始默认值 修改 xw 名为 bust_size ，类型为 BIGINT ; 和 MODIFY 子句不同在于：CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;类型&gt; 12ALTER TABLE student CHANGE xw bust_size BIGINT; ALTER 命令 + SET子句 ：重新设置字段默认值 123ALTER TABLE student ALTER bust_size SET DEFAULT 1; -- 默认值2--&gt;1 修改表名 ALTER 命令 + RENAME TO 子句 ：修改表名 12ALTER TABLE student RENAME TO stu; 修改存储引擎 语法：ALTER TABLE &lt;表名&gt; &lt;旧引擎名&gt; = &lt;新引擎名&gt;; 第三章 ：查询数据 3.1 基本查询 SELECT * FROM &lt;表名&gt; 这是不带 WHERE 条件进行查询，查询显示：指定表所有数据。 1SELECT * FROM students; SELECT &lt;数学表达式&gt; SELECT 可用于数学计算，但那并不是强项，但可用于检测数据库了解是否有效。 1mysql&gt; SELECT 1+1; 3.2 条件查询 条件表达式 条件 举例1 举例2 说明 = score = 80 name = ‘abc’ 字符串需要用单引号括起来 &gt; score &gt; 80 name &gt; ‘abc’ 字符串比较：ASCII码；中文比较：根据数据库设置 &gt;= score &gt;= 80 name &gt;= ‘abc’ &lt; score &lt; 80 name &lt;= ‘abc’ &lt;= score &lt;= 80 name &lt;= ‘abc’ &lt;&gt; score &lt;&gt; 80 name &lt;&gt; ‘abc’ &lt;&gt; ：用于判断不相等，如举例1表示 score ≠ 80 LIKE name LIKE ‘ab%’ name LIKE ‘%bc%’ 判断相似：%表示任意字符。例如'ab%'将匹配 ‘ab’，‘abc’，‘abcd’ NOT、AND、OR NOT、AND、OR 可用于组成多条件查询，同时可配合 () 改变优先级。 SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt; 查询 student 表成绩80分以上男生，但不包含小兵。 123SELECT * FROM student WHERE NOT name=&#x27;小兵&#x27; AND score &gt; 80 AND gender=&#x27;M&#x27;; 其实，NOT 等价于 &lt;&gt; : 123SELECT * FROM studentWHERE name &lt;&gt; &#x27;小兵&#x27; AND score &gt; 80 AND gender = &#x27;M&#x27;; SELECT (列1，列2…) FROM &lt;表名&gt; WHERE &lt;条件&gt; 这种方式也称为 投影查询，结果集合只包含指定列，而非所有列。 查询 student 表成绩80分以上男生，但不包含小兵，结果只显示 id 、name 两列。 123 SELECT id,name FROM student WHERE name &lt;&gt; &#x27;小兵&#x27; AND score &gt; 80 AND gender = &#x27;M&#x27;; 3.2 查询进阶 3.2.1 排序 单条件查询 [单排序条件] 按一班成绩升序排列，并同时显示ta们：id、姓名、成绩。 1234SELECT id,name,scoreFROM student WHERE class_id = 1 ORDER BY score ; ⚠️ WHERE 要放在 ORDER BY 前，否则出错； 如果要降序：查询语句末加上 DESC 即可。 多条件查询 [多排序条件] 按一班成绩升序排列，成绩相同按性别降序，并同时显示ta们：id、姓名、成绩。 1234SELECT id,name,score FROM studentWHERE class_id = 1 ORDER BY score ,gender DESC ; 对于每个排序条件都要指定升序、降序：这里score默认升序、gender降序； gender值 是字符串，按ASCII 码规则进行排序。 3.2.2 分页 分页，解决 SELECT 查询时，数据量太多，指定显示 某页 数据。 其语法格式：&lt;SELECT查询&gt; LIMIT &lt;每页显示记录数&gt; OFFSET &lt;记录偏移量&gt; 查询实例 查询所有学生成绩降序排序，显示第二页数据，每页4条记录。 1234SELECT id,class_id,name,scoreFROM studentORDER BY score DESCLIMIT 4 OFFSET 4 ; -- (2-1)*4 = 4：0-3为第一页4条记录，第4条记录即是第二页第一条记录 显示第n页数据：LIMIT OFFSET * size 查询结果 3.2.3 多表查询 多表查询：返回的是笛卡尔乘积，即一张有n记录表 &amp; 一张m记录表 —&gt; 查询结果 m*n 记录表。 查询实例 查询 student 表、class 表，显示笛卡尔乘积结果。 12SELECT *FROM student s, class c; 查询 student 表、class 表，1班男生成绩降序排序。 1234SELECT s.id &#x27;学号&#x27;, c.id &#x27;班级号&#x27;,s.name &#x27;名字&#x27;,s.score &#x27;成绩&#x27;FROM student s, class cWHERE s.gender = &#x27;M&#x27; AND c.id = 1ORDER BY s.score DESC; student 表 &amp; class 表分别使用了别名 s 和 c ；查询结果列名也可以使用别名； 这样查询表，其实是在它们的 笛卡尔乘积表中查询。 查询结果 笛卡尔乘积查询结果1 查询结果2 123456789+--------+-----------+--------+--------+| 学号 | 班级号 | 名字 | 成绩 |+--------+-----------+--------+--------+| 3 | 1 | 小军 | 96 || 1 | 1 | 小明 | 91 || 9 | 1 | 小王 | 90 || 7 | 1 | 小林 | 86 || 6 | 1 | 小兵 | 56 |+--------+-----------+--------+--------+ 3.2.4 连接查询 查询 student 表中，显示学生信息[id、姓名、班级名、成绩]，要包含班级名称。 这题难点在于，班级名(name)在 class 表中， student 表中只有 class_id 。 如果用上面多表查询 要生成笛卡尔积表效率太低，所以我们使用连接查询。 内连接 内连接中，没有主表，只分为左右表。 原理：用从左表中取出每一条记录，去与右表中所有记录匹配，满足ON &lt;连接条件&gt; 被保留。 没有 ON &lt;连接条件&gt; ，将会生成成笛卡尔积表。 查询实例 1234SELECT s.id,s.name,c.name,s.scoreFROM student sINNER JOIN class cON s.class_id = c.id; INNER JOIN class c ：使得可以 SELECT 使用 class 表中name ; 将左表记录N_i 与 右表记录 M_j 比较，如果字段 s.class_id = c.id ，那么记录N_i 保留。 也就是说，比较次数 = 左表记录数 * 右表记录数，这比直接生成笛卡尔表查询高效。 查询结果 1234567891011121314+----+--------+--------+-------+| id | name | name | score |+----+--------+--------+-------+| 1 | 小明 | 一班 | 91 || 2 | 小红 | 一班 | 96 || 3 | 小军 | 一班 | 96 || 4 | 小米 | 一班 | 74 || 5 | 小白 | 二班 | 82 || 6 | 小兵 | 二班 | 56 || 7 | 小林 | 二班 | 86 || 8 | 小新 | 三班 | 92 || 9 | 小王 | 三班 | 90 || 10 | 刘婷 | 三班 | 90 |+----+--------+--------+-------+ 左外连接 左外连接中，左表为主表。 原理：以左表为主表，从里面取每一条记录和右表进行连接，分两种情况 满足ON &lt;条件&gt; 能匹配：保留该记录； 不满足ON &lt;条件&gt; 能匹配：保留该记录，但是其它字段置为NULL。 右外连接 右外连接中，右表为主表。 原理：同上。 查询实例 1234SELECT s.id,s.name,c.name,s.scoreFROM student sRIGHT OUTER JOIN class cON s.class_id = c.id; 把右表当主表去匹配左表：满足ON条件，正确保存；不满足，其余字段置为 NULL 。 查询结果 123456789101112131415+------+--------+--------+-------+| id | name | name | score |+------+--------+--------+-------+| 1 | 小明 | 一班 | 91 || 2 | 小红 | 一班 | 96 || 3 | 小军 | 一班 | 96 || 4 | 小米 | 一班 | 74 || 5 | 小白 | 二班 | 82 || 6 | 小兵 | 二班 | 56 || 7 | 小林 | 二班 | 86 || 8 | 小新 | 三班 | 92 || 9 | 小王 | 三班 | 90 || 10 | 刘婷 | 三班 | 90 || NULL | NULL | 四班 | NULL |+------+--------+--------+-------+ 3.2.5 子查询 子查询分类 子查询按对返回结果集调用方法，可分为： WHERE 子查询：把内层查询结果当做外层 查询条件； FROM 子查询：把内层查询结果当做外层 查询集合； EXISTS 子查询：把外层查询结果拿到内层，看内层查询是否成立。 IN 、ANY、SOME、ALL 最典型的当 WHRER 子查询结果，不是标量（一行一列），而是一个集合（多行多列）。 此时，不能使用：= &gt; &lt; &gt;= &lt;= &lt;&gt; 这些比较标量操作符；而用IN、ANY（SOME）、ALL 操作符。 IN：判断查询的表达式是否在子查询列表中，返回满足in列表中的满足条件的记录。 ANY：ANY关键字必须在一个比较操作符后面，表示与子查询返回任何值比较为 TRUE ，则返回 TRUE ； ALL：ALL关键字必须在一个比较操作符后面，表示与子查询返回所有值比较为 TRUE ，则返回 TRUE 。 子查询实例 查询实例1 获取所有比刘婷成绩好的男同学，学号、姓名、成绩。 12345678SELECT id,name,scoreFROM studentWHERE score &gt; ( SELECT score FROM student WHERE name = &#x27;刘婷&#x27; -- 这里没有 ;); 查询比刘婷成绩好的同学为父查询·····；由于刘婷成绩未知，所以还需要一个子查询查询刘婷成绩。 WHERE 子查询字段 == 父查询字段！（都只有 score） 查询实例2 新建一个 test_stu 表查询：test.sql 找出语文和数学都及格的同学名字。 12345678SELECT name FROM test_stuWHERE score &gt;= 60 AND project = &#x27;语文&#x27; AND name IN( SELECT name FROM test_stu WHERE score &gt;= 60 AND project = &#x27;数学&#x27;); 很明显要子查询，要查出语文成绩及格同学，可做父查询条件之一 ；然后把子查询查询数学结果做父查询条件之二。 一开始想用 FROM 子查询 限制查询集合，似乎并不太好用。 查询结果2 123456+--------+| name |+--------+| 张三 || 赵六 |+--------+ 3.2.6 聚合 ： 分组 &amp; 简单函数 函数只能在 SELECT 中使用？？ 聚合 &amp; 简单函数 聚合配合函数：用来统计表中信息，如总人数、平均分、最高分等。 聚合 &amp; count() 统计 student 表学生总人数。 1SELECT COUNT(*) stu_num FROM student; count(*) : 参数 * 代表统计所有列； stu_num : 是设置的别名。 12345+---------+| stu_num |+---------+| 10 |+---------+ 聚合 &amp; SUM()、AVG() 注意，SUM()、AVG() 用来计算一列总和/平均值，必须要是 数值类型 ( count() 是统计列，和类型无关) 。 统计女生总分，和平均分。 123SELECT SUM(score),AVG(score) FROM studentWHERE gender = &#x27;F&#x27;; SELECT name ,SUM(s.score),AVG(s.score) 不行，每个女生都有总分/平均分? 12345+------------+------------+| SUM(score) | AVG(score) |+------------+------------+| 434 | 86.8000 |+------------+------------+ 聚合 &amp; MIN() 、MAX() MAX()和MIN()不限于数值类型,如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。 统计学生中最高分，并同时显示姓名、班级、分数。 该题难点在于，由于还是显示班级，需要连接 class 表。 ON 条件：还想同时 MAX() 找出最高分，不太可行，用来给 student 表增加一列 c.name就行。 WHERE 条件：然后给新连接表找出最高分。 123456789SELECT s.name,c.name,s.scoreFROM student sINNER JOIN class cON s.class_id = c.idWHERE s.score &gt;= ALL ( SELECT score FROM student); 进一步优化：利用 MAX() 函数 123456789SELECT s.name,c.name,s.scoreFROM student sINNER JOIN class cON s.class_id = c.idWHERE s.score = -- 尝试 WHERE s.score = MAX(score) 出错，只能在SELECT中使用？( SELECT MAX(score) FROM student); 聚合 &amp; 分组 单条件分组 在前面，我们利用 coutn(*) 函数，可以很快统计出学生总数，但是如果要分别统计出男/女生数呢？难道，分别用 WHERE 条件限制一下再统计吗？ 如果，表可以分为两男、女两组，函数分别会分别统计两组信息再显示多好呀！ 分别统计出男/女平均分、学生总数。 123SELECT gender,AVG(score),COUNT(*)FROM studentGROUP BY gender; 这也就相当于：表分为男女两组，函数会分别计算两次 。 我们可以 SELECT gender ，但是下列语句会出错： 1SELECT class_id,gender,AVG(score),COUNT(*) -- 第一句SELECT增加class_id 因为，按性别分组，每个性别都要若干学生，自然对应多个班级 class_id ,试问如何显示？ 123456+--------+------------+----------+| gender | AVG(score) | COUNT(*) |+--------+------------+----------+| M | 83.8000 | 5 || F | 86.8000 | 5 |+--------+------------+----------+ 多条件分组 在 单条件分组 我们说到，下面写法是错误的： 123SELECT class_id,gender,AVG(score),COUNT(*) -- 第一句SELECT增加class_idFROM studentGROUP BY gender; 原因是：按 gender 分组只能分为 M/F 两组，显示只有两行统计结果，而每一行M/F都包括多个class_id ，没法显示，也不合逻辑。现在思考一个问题： 查询每个班级的男/女生平均分？ 123SELECT class_id,gender,AVG(score)FROM studentGROUP BY gender,class_id; 为什么这里又可以显示了？其实整个逻辑如下： 先按 class_id 分为 3 组，然后每组又按 gender 分为 2 组，所以总共是 6 组可以显示出来。 12345678910+----------+--------+------------+| class_id | gender | AVG(score) |+----------+--------+------------+| 1 | M | 93.5000 || 1 | F | 85.0000 || 2 | F | 82.0000 || 2 | M | 71.0000 || 3 | F | 91.0000 || 3 | M | 90.0000 |+----------+--------+------------+ 第四章：事务 4.1 事务简介 简单来说，事务就是让多个操作要么全部执行，要么全不执行，保证数据统一性。 比如，A向B进行转账必须保证，A 、B账户一方增，一方必须减。 1234-- 第一步：将id=1的A账户余额减去100UPDATE accounts SET balance = balance - 100 WHERE id = 1;-- 第二步：将id=2的B账户余额加上100UPDATE accounts SET balance = balance + 100 WHERE id = 2; 显然，这两条语句必须全部执行，但上面语句无法保证，这就需要开启事务。 隐式事务 对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为隐式事务。 显示事务 手动把多条事务作为一个事务执行，使用 BEGIN &lt;多条SQL语句操作&gt; COMMIT 形式。比如上面转账： 1234BEGIN; -- 分号UPDATE accounts SET balance = balance - 100 WHERE id = 1;UPDATE accounts SET balance = balance + 100 WHERE id = 2;COMMIT; -- 分号 COMMIT &amp; ROLLBACK 上面最终选择提交更新，如果写完SQL语句但又不想提交更新呢？可以用 ROLLBACK 撤销操作： 1234BEGIN; -- 分号UPDATE accounts SET balance = balance - 100 WHERE id = 1;UPDATE accounts SET balance = balance + 100 WHERE id = 2;ROLLBACK; -- 分号 4.2 隔离级别 概况：避免多个并发执行事务，对 同一条记录 进行操作，带来的数据不一致问题。 SQL 标准定义4种隔离级别，不同程度 的避免出现数据不一致情况。 同时，在MySQL中，使用 innoDB 默认隔离级别是 Repeatable Read 。 Isolation Level 脏读 不可重复读 幻读 隔离级别 概括 Read Uncommitted Yes Yes Yes 最低 脏读：两次读，中间撤 Read Committed - Yes Yes 较低 不可重读：两次读，中间更 Repeatable Read - - Yes 较高 幻读：两次读，中间插 Serializable - - - 最高 Read Uncommitted 根据上表，我们知道，Read Uncommitted 可能出现脏读。 什么是脏读？最终读取到已不在表中数据。 多并发下，事务A进行了更新操作，在事务B进行连续两次读过程中，发生撤回更新操作，导致读取无效C。 两次读，中间撤 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; 2 BEGIN; BEGIN; 3 UPDATE student SET score= 65 WHERE id = 1; 4 SELECT * FROM student WHERE id = 1; 5 ROLLBACK; 6 SELECT * FROM student WHERE id = 1; 7 COMMIT; 时刻3：事务A，更新 student 表设置分数为65； 时刻4：事务B，读到刚刚更新的分数65； 时刻5：事务A取消更新分数操作，导致上一个分数实际不是正确分数； 时刻6：验证性操作，再次读取数据发现分数和时刻4读取的不一致。 Read Committed 根据上表，我们知道，Read committed 可能出现不可重复读。 什么是不可重复读？两次连续读取的数据不一致，但最终读取的数据在表中。 在多并发下，事务B在进行两次读过程中，事务A恰好更新了数据，导致两次读取数据不一致。 两次读，中间更 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL READ COMMITTED; SET TRANSACTION ISOLATION LEVEL READ COMMITTED; 2 BEGIN; BEGIN; 3 SELECT * FROM studentWHERE id = 1; 4 UPDATE student SET score= 65 WHERE id = 1; 5 COMMIT; 6 SELECT * FROM student WHERE id = 1; 7 COMMIT; ❔ Read Committed下为什么不会出现脏读呢？ 💭 我的理解是，Read Committed 下只能读取到已经 COMMIT 更新的数据，不能读取未 COMMIT 操作数据。 ​ 脏读是未 COMMIT 前更新操作然后撤回又读取导致，所以也就不会出现脏读。 Repeatable Read 根据上表，我们知道，Repeatable Read 可能出现幻读。 什么是幻读？连续两次读，第一次不存在，但可以更新，更新后再次读取竟然又存在。 两次读，中间插 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; 2 BEGIN; BEGIN; 3 SELECT * FROM student WHERE id = 99; 4 INSERT INTO student (id, name) VALUES (99, ‘Bob’); 5 COMMIT; 6 SELECT * FROM student WHERE id = 99; 7 UPDATE student SET name = ‘Alice’ WHERE id = 99; 8 SELECT * FROM student WHERE id = 99; 9 COMMIT; 第6时刻：⚠️ 此时没有出现不可重复读，第6时刻读取到 id = 99 数据还是空。 第7时刻：但是发现可以更新数据，而且此时再去读取 id = 99 数据发现成功了！！AMAZING! ❔ 如果第 4 步是 UPDATE 操作 ，会出现不可重复读吗？ 💭 我猜测不会，因为 INSERT 操作也是更新，但是第6时刻读取数据为空？ 🕵 Repeatable Read 在同一个事务内的查询与事务开始时刻一致，在B事务过程中不会读到期间A中更新值。 Serializable Serializable是最严格的隔离级别，但是效率最低，一般不会设置。 在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。 第五章 ：存储过程和触发器","categories":[{"name":"数据库","slug":"数据库","permalink":"https://hwh.zone/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"https://hwh.zone/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://hwh.zone/tags/MySQL/"}]},{"title":"机器学习（一）吴恩达笔记","slug":"机器学习（一）吴恩达笔记","date":"2021-11-25T10:34:24.303Z","updated":"2021-11-26T16:09:01.059Z","comments":true,"path":"2021/11/25/机器学习（一）吴恩达笔记/","link":"","permalink":"https://hwh.zone/2021/11/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%B4%E6%81%A9%E8%BE%BE%E7%AC%94%E8%AE%B0/","excerpt":"","text":"吴恩达的机器学习最重要的还是课后的lab实验，后期会继续上传。这里先简单上传听课的笔记，略粗糙。 一 、绪论 1.1 监督学习 1.2 无监督学习 只把数据交给算法，自动给事物分群。 （BC都是无监督学习） 二、单变量线性回归 2.1 模型描述 卖房子 卖房子预测，既是一个监督学习模型，也是一个回归模型。 基本常识 符号 m：训练集 x &amp; y ：分别表示输入/输出变量 监督学习流程 2.2 代价函数 平方误差代价函数 简化版平方代价函数 改变参数 简化平代函数 ，改变一个参数θ1图像 平代函数，改变两个参数θ、θ1图像 用等高线图来表示（J(θ0,θ1)相同即等高） 2.3 梯度下降算法 — 自动寻找最小J(代价)算法 问题描述 如何最快下山？ 不同下山点会得到不同下山路径，即局部最优解。 梯度算法介绍 一定要同时更新，右边算法错误在于θ0更新值被用于 temp1，应该用旧值。 梯度下降算法寻找最小代价过程 如果斜率 == (d(J(θ))/dθ)θ &gt; 0 ，那么当前θ - α*斜率，就是使得θ减小，逼近函数底端 如果斜率 == (d(J(θ))/dθ)θ &gt; 0 ，那么当前θ - α*斜率，就是使得θ增大，逼近函数底端 学习速率α 学习速率大小影响 学习速率太小：逼近过程太慢 学习速度太大：可能会越过最低点（最小代价），甚至无法收敛 梯度下降算法特点 如果已经在局部最低点 此时，斜率为0，θ不会被更新，达到局部最优。 自动减小θ变化程度 原因是因为，越逼近最低点，斜率会自动变小，α*斜率变小—&gt; θ变化程度降低。、 总结 基本方程了解 推导成偏微分项过程 对θ0求导，结果如框1 对θ1求导，结果如框2 梯度下降过程 根据公式 θj=θj−α∗∂∂θ∗J(θ0,θ1)\\theta_j = \\theta_j - \\alpha*\\frac{\\partial}{\\partial_\\theta}*J(\\theta_0,\\theta_1) θj​=θj​−α∗∂θ​∂​∗J(θ0​,θ1​) 不断减少 θ值，梯度下降使之达到局部最优。 不断拟合hθ，使得贴近数据，达到预测 三 、多变量线性回归 3.1 多功能 多变量预测房价 预测函数改进 写出矩阵表达形式 3.2 多元梯度下降法 为什么假设的函数 h(θ)是一个线性形式？ 通过大概预测数据分布 关键是让 最小代价函数 J会最小，拟合原数据。假设成线性形式方便推导，计算。 多元梯度下降计算最小代价 多元更新θ规则 对θ更新的理解1 ​ 每一次更新θj都是，要利用到所有的数据集，计算出此时θj数据集所有不同特征{x1,x2,x3…xn}偏导数平均值，决定下一次θj的偏移值。 12345678910#开始迭代while True: cnt=cnt+1 diff = [0,0] #梯度下降 for i in range(m): diff[0]+=h(x_train[i])-y[i] diff[1]+=(h(x_train[i])-y[i])*x_train[i] theta0=theta0-alpha/m*diff[0] theta1=theta1-alpha/m*diff[1] 3.3 多元梯度实用技巧 代价函数J是一个类似这种图形（多元更复杂）： 特征缩放：使得特征规模在一个相近范围 如果数据集{x1,x2,x3…xn}中特征xi过大，可能会使得J(θ)变得狭长，收敛慢、且震荡等： 为什么会变这样？ 改变{x1,x2,x3…xn}不会使得θ发生变化? 更好的确定特征缩放范围 xi=X−umax−minx_i = \\frac{X - u}{max - min} xi​=max−minX−u​ 选择学习速率α 观测是否收敛方法 画出收敛过程图形（老师推荐） 设置某个限差 不推荐，因为一般难以判断。 不收敛举例 α过大 可能导致的情况：越过最低点，来回走；不断重复某个相似形状。 已经证明：只要α够小，代价函数J一定会减小。 α过小 一定收敛，但是过程太慢。 取α技巧（经验） 从一个较小合适值如0.001，每次是前一次3倍左右递增测试。 3.4 特征表达式和多项式回归 根据已知数据得出更好的特征 如，已知房子的长、宽特征，其实根据长*宽 这个新特征更好预测。 多元拟合举例（单一特征） 如下图房价是一个类似二次函数，那么可以选择多项式来拟合。 为了更加精确，还可以增加开平方等（后面房价变化平缓） 3.5 正规方程解法 方法1：求出偏微分置零—非线性 这种方法，根据公式令所有的偏微分方程 == 0 ，然后解出 θ0，θ1…θn。 方法2：公式解出—-线性 简单来说就是求解：（不对，应该参考：正规方程推导过程） Y=X∗θY = X*θ Y=X∗θ step1:XTY=XTX∗θstep1:X^TY = X^TX*θ step1:XTY=XTX∗θ step2:（XTX)−1XTY=θstep2:（X^TX)^{-1}X^TY = θ step2:（XTX)−1XTY=θ 可是一般也不会是线性解啊？θ有n个，数据集有很多个如m，就X为m*（n+1） m &gt;&gt; n，不一定有解啊？ step1:y=θ0+θ1∗x1+θ2∗x2....θn∗xnstep1: y = \\theta_0 + \\theta_1*x_1+ \\theta_2*x_2.... \\theta_n*x_n step1:y=θ0​+θ1​∗x1​+θ2​∗x2​....θn​∗xn​ 两种方法对比 如果正规方程，XTX不可逆（奇异矩阵） 一般不可逆情况很少。 使用pinv求逆而非inv（即使不可逆也可求出） 改变特征值/正则化删除多余特征 四、Octave/ Matalab使用 4.1 基本操作 改变提示符号 1octave:1&gt; PS1(&#x27;&gt;&gt; &#x27;) % 将octave：&lt;num&gt; &gt; &lt;命令&gt; 提示变成 &gt;&gt; &lt;命令&gt; HELP 帮助 查看函数定义等 1&gt;&gt; help PS1 常规运算 123456789101112&gt;&gt; 1+2 % 加ans = 3 &gt;&gt; 1-2 % 减ans = -1&gt;&gt; 1*2 % 乘ans = 2&gt;&gt; 1/2 % 除ans = 0.50000&gt;&gt; 1^2 % 幂ans = 1&gt;&gt; 1%2 % 取余ans = 1 布尔运算 12345678&gt;&gt; 1 == 2 # equalans = 0&gt;&gt; 1 ~= 2 # ...?ans = 1&gt;&gt; 1 &amp;&amp; 0 # ANDans = 0&gt;&gt; 1 || 0 # ORans = 1 矩阵运算 加减 A + 1 , A - 1 : 矩阵每一个数字都加减 1 12345678910&gt;&gt; A = [1 2 3 ; 4 5 6 ; 7 8 9;];&gt;&gt; B = [1 2 3 ; 4 5 6 ; 7 8 9;];&gt;&gt; A + 1ans = 2 3 4 5 6 7 8 9 10 乘除 A*B &amp; *A .B : 前者常规矩阵相乘，后者是用对应A(i,j) * B(i,j) 类似的还有：1 ./ A , A .^2 , .都是表示对矩阵每个元素的操作 12345678910111213&gt;&gt; A * Bans = 30 36 42 66 81 96 102 126 150&gt;&gt; A .*Bans = 1 4 9 16 25 36 49 64 81 函数 A '、pinv(A)abs(A)、log(A)、exp(A)、max(A) &amp; ceil(A)、floor(A) 向上、下取整 123456789101112&gt;&gt; A = [1 2 3 ; 4 5 6 ; 7 8 9;]A = 1 2 3 4 5 6 7 8 9&gt;&gt; A&#x27;ans = 1 4 7 2 5 8 3 6 9 sum(A)、prod(a) 、max(A)：返回每行元素和、乘积、最大值，以行向量表示。 max(A,B)：比较A 和 B 对应位置元素，求最大，组成新矩阵 max(A,[],1)、max(A,[],2)：分别获取每一列、行最大值 sum(A,1)、sum(A,2)：分别获取每一列、行和 12345678910111213141516171819202122232425&gt;&gt; sum(A) % 默认获取的是每一列的最大值ans = 12 15 18&gt;&gt; prod(A)ans = 28 80 162 &gt;&gt; [r,c]= max(A) % r 是每列最大数字 ； c是每列最大数字索引r = 7 8 9c = 3 3 3 &gt;&gt; max(A,[],2) % 返回每行最大ans = 3 6 9 find(A &lt; 3) ：返回矩阵所有小于3的元素，为一个列向量 12345&gt;&gt; find(A &lt; 3)ans = 1 4 布尔 A &lt; 3 、 A &gt; 3 : 相对矩阵每个元素都和3进行bool运算，返回0 或者1 123456&gt;&gt; A &lt; 3ans = 1 1 0 0 0 0 0 0 0 补充 A(😃 ：将A所有元素组成一个列向量。配合 max(A)就可以求矩阵A的最大值 1234567891011121314B = 1 4 7 2 5 8 3 6 9&gt;&gt; max(B) % max 默认求每列的最大值ans = 9 变量相关操作 定义变量 123&gt;&gt; a = pi % 变量会自动打印a = 3.1416&gt;&gt; a = pi; % 让变量不打印 display 打印变量 1234&gt;&gt; a = pi;&gt;&gt; display(a) a = 3.1416&gt;&gt; display(sprintf(&#x27;%0.2f&#x27;,a)) % 以C语言格式打印出来 format 打印变量 1234567&gt;&gt; format long &gt;&gt; aa = 3.141592653589793&gt;&gt; format short&gt;&gt; aa = 3.1416 clear清除变量 12clear a % 清除a变量clear % 清除所有变量 who,whos显示所有变量信息 12345678910111213141516&gt;&gt; whoVariables in the current scope:A a ans data &gt;&gt; whos % whos更加详细Variables in the current scope: Attr Name Size Bytes Class ==== ==== ==== ===== ===== A 15x15 1800 double a 1x1 8 double ans 1x14 14 char data 3x3 72 doubleTotal is 249 elements using 1894 bytes 向量和矩阵 常规生成矩阵 123456789101112131415&gt;&gt; A = [1 2; 3 4 ; 5 6] % 以；分隔矩阵行 ，以空格分隔每一行元素A = 1 2 3 4 5 6&gt;&gt; A = [1 2; % 另一种输入矩阵方法&gt; 3 4;&gt; 5 6]A = 1 2 3 4 5 6 快捷生成矩阵 ::指定起始和结束生成一个行向量 12345678&gt;&gt; A = 1:0.2:2 % 同时指定步长为 0.2A = 1.0000 1.2000 1.4000 1.6000 1.8000 2.0000&gt;&gt; A = 1 : 5 % 不指定步长（默认为1）A = 1 2 3 4 5 直接复制某矩阵指定多少元素，生成行向量，从上至下，从左至右开始算 1234567891011&gt;&gt; w = rand(3,3)w = 0.920009 0.424680 0.795883 0.890070 0.048942 0.592416 0.748348 0.784034 0.366445 &gt;&gt; v = w(1:3) % 1:3 表示第1 到 第3 个元素赋值给v行向量（第一列）v = 0.92001 0.89007 0.74835 用ones、zeros、magic函数指定行列，生成元素为1、0矩阵 或者幻方方阵 123456789101112131415161718&gt;&gt; ones(2,2)ans = 1 1 1 1&gt;&gt; 2*ones(2,2) % 还可以指定倍数ans = 2 2 2 2 &gt;&gt; magic(3) % 每行、列、对角 相加相等ans = 8 1 6 3 5 7 4 9 2 rand、randn生成随机矩阵（randn生成的矩阵符合高斯分布） 1234567891011&gt;&gt; rand(2,2)ans = 0.84394 0.39302 0.33943 0.18478&gt;&gt; randn(2,2)ans = -0.32139 0.19817 0.62788 0.42349 eye 生成单位矩阵 12345678&gt;&gt; eye(3)ans =Diagonal Matrix 1 0 0 0 1 0 0 0 1 图形显示矩阵 12&gt;&gt; A = rand(15,15);&gt;&gt; hist(A) 矩阵数据索引 A(i,j) 显示矩阵A，i行j列元素 12345678&gt;&gt; A = [1 2 3 ; 4 5 6; 7 8 9]A = 1 2 3 4 5 6 7 8 9&gt;&gt; A(2,2)ans = 5 A(i,:) 获取矩阵A，第i行所有元素 1234&gt;&gt; A(2,:)ans = 4 5 6 A(:,j) 获取矩阵A，第j列所有元素 123456&gt;&gt; A(:,2)ans = 2 5 8 A([i,j]😅 获取矩阵A，第i行和第j行元素 12345&gt;&gt; A([1,3],:)ans = 1 2 3 7 8 9 修改矩阵 A(:,j) = [column vector ] ： 修改矩阵第j列为新列向量 A(i,:) = [column vector ] ： 修改矩阵第i行为新行向量 12345678910111213&gt;&gt; A(:,2) = [8 ; 8 ; 8]A = 1 8 3 4 8 6 7 8 9&gt;&gt; A(2,:) = [7 7 7]A = 1 8 3 7 7 7 7 8 9 组合矩阵 [A,B] &amp; [A B] : 将矩阵B作为矩阵A的扩展列，形成新矩阵 12345678910111213&gt;&gt; A = [1 1 1]A = 1 1 1&gt;&gt; B = [2 2 2]B = 2 2 2&gt;&gt; [A,B]ans = 1 1 1 2 2 2 [A;B] : 将矩阵B作为矩阵A的扩展行，形成新矩阵，注意是分号； 12345&gt;&gt; [A;B]ans = 1 1 1 2 2 2 矩阵量度 size 返回矩阵大小 1234&gt;&gt; size(A)ans = 15 15 length 返回行长 12&gt;&gt; length(A)ans = 15 4.2 移动数据 路径相关 pwd ：当前路径 ； cd 切换目录 ； ls 显示当前目录文件 load 加载文件 12345678load data.datload(&#x27;data.dat&#x27;)&gt;&gt; data % 特别注意不要输入:后缀名！！！data = 1 2 3 4 5 6 7 8 9 save 存储数据 12345678data = 1 2 3 4 5 6 7 8 9&gt;&gt; v = data(1:3)&gt;&gt; save v.dat v 4.3 数据绘制 设置横轴坐标 &amp; 函数（中间数字为什么不能改变成 0.1？？） 123&gt;&gt; t = [0:0.01:2*pi];&gt;&gt; y1 = sin(t); &gt;&gt; y2 = cos(t); 绘制图形 123&gt;&gt; plot(t,y1)hold on; % 保持正弦图形在基础上再绘制余弦函数&gt;&gt; plot(t,y2) 添加信息 1234&gt;&gt; xlabel(&#x27;time&#x27;); % 增加x坐标轴标签&gt;&gt; ylabel(&#x27;value&#x27;); % 增加y坐标轴标签&gt;&gt; legend(&#x27;sin&#x27;,&#x27;cos&#x27;); % 用显示两条线代表什么函数&gt;&gt; title(&#x27;simple plot&#x27;) % 增加这幅图的标题 保存图片 cd &lt;保存路径&gt; ；&lt;保存图片名&gt; 1&gt;&gt; cd &#x27;C:\\Users\\Administrator\\Desktop&#x27;;print -dpng &#x27;myPlot.png&#x27; 同时显示两张图片 12&gt;&gt; figure(1);plot(t,y1);&gt;&gt; figure(2);plot(t,y2); 显示框分隔成两块 12345&gt;&gt; subplot(1,2,1); % 把界面分成1x2，选中第一个格子&gt;&gt; plot(t,y1); &gt;&gt; subplot(1,2,2); % 选中第二个格子&gt;&gt; plot(t,y2);&gt;&gt; axis([0.5 1 -1 1]) % 修改第二幅图的横坐标为[0.5,1],纵坐标为[-1,1] 绘制矩阵图像 矩阵中一个元素代表着一个色块， 123456789&gt;&gt; A = magic(3)A = 8 1 6 3 5 7 4 9 2&gt;&gt; imagesc(A) % 生成不同色块矩阵&gt;&gt; imagesc(A),colorbar,colormap pink; % 色块的颜色深浅由元素的数值决定。&gt;&gt; close % 关闭所有打开的绘制图像框 4.4 控制语句 for、while… for、while循环 for : 变量i会自＋1 while：i不会自加，需要自己设置初始值 12345678910111213141516171819&gt;&gt; rang = [1:3]rang = 1 2 3 &gt;&gt; for i = rang % 等价于 ： for i = [1:10]&gt; disp(i);&gt; end 1 2 3&gt;&gt; i = 0&gt;&gt; while i &lt; 3&gt; disp(i);&gt; i = i+1; % 加；，使得i不会输出&gt; end; 0 1 2 if 注意 if也要有end配合 12345678910&gt;&gt; i = 0 ;&gt;&gt; while true&gt; i = i+1;&gt; disp(i)&gt; if i == 3&gt; break;&gt; else if&gt; disp(&#x27;continue&#x27;)&gt; end&gt; end 调用自定义函数 定义一个后缀名为.m文件：square.m，写入函数： 12function y = square(x) % 函数头，函数名最好和文件名相同y = x^2; % 函数主体 在octave中CIL中调用 123&gt;&gt; cd C:\\Users\\86151\\Desktop % 先切换到文件所在目录&gt;&gt; square(10)ans = 100 也可返回多个值： 1234567function [a,b] = squareAndCube(x) a = x^2; b = y^3;&gt;&gt; % 在octave中调用 squareAndCube.m 中 squareAndCube函数&gt;&gt; [a,b] = squareAndCube(10)a = 100b = 1000 计算代价函数实例 4.5 矢量 矩阵化两数相乘求和 更复杂的举例 五、Logistic回归 5.1 分类 线性回归预测分类问题 例如预测，肿瘤是否良性问题。 我们将大于0.5的预测函数h肿瘤，预测为良性；小于0.5预测为恶性。 但是如果增加一个数据集，预测函数把原本属于恶性肿瘤预测为良性。 另外一个问题，预测函数h(x)值可以超过[0,1]范围。 5.2 假设陈述 Sigmoid函数 &amp; Logistic 函数 Sigmoid函数：g(z)=11+e−zSigmoid 函数：g(z) = \\frac{1}{1+e^{-z}} Sigmoid函数：g(z)=1+e−z1​ Logistic函数:hθ(x)=g(θTx)Logistic 函数 :h_\\theta(x) = g(\\theta^Tx) Logistic函数:hθ​(x)=g(θTx) 预测病人有 70% 概率患有恶性肿瘤。 5.3 决策界限 再理解Logistic 函数 当 z &gt; 0 时，g（z）&gt; 0.5 -----&gt; θ’ &gt; 0 时，g（θ’）&gt; 0.5。 那么如果设置 阀值 = 0.5，只需判断 θ’ &gt; 0 ? 便可分类了。 举例（一） 如果设定阀值= 0.5，按照前推论，预测 y = 1只需 ： θ0+θ1x1+θ2x2&gt;0\\theta_0+\\theta_1x_1+\\theta_2x_2 &gt; 0 θ0​+θ1​x1​+θ2​x2​&gt;0 不妨假设，θ0 = 0 ，θ1 = θ2 = 1。那么便是推得： x1+x2≥3,y=1;x1+x2&lt;3,y=0x_1 + x_2 ≥ 3 , y = 1 ; x_1 + x_2 &lt; 3 , y = 0 x1​+x2​≥3,y=1;x1​+x2​&lt;3,y=0 由此可以得到决策边界函数，如下图红色直线所示： x1+x2=3x_1 + x_2 = 3 x1​+x2​=3 举例（二） 基本推导过程同上，可以得到决策边界函数： x12+x22=1x_1^2+x_2^2 = 1 x12​+x22​=1 可能还有有更复杂的图形和参数： 5.4 代价函数 向量化 Logistic函数 选择新的代价函数 为什么要构造新的代价函数？ 线性回归代价函数的实际意义就是平方误差。而逻辑回归却不是，它的预测函数hθ(x)hθ(x)是非线性的。如果类比地使用线性回归的代价函数于逻辑回归，那J(θ)J(θ)很有可能就是非凸函数，即存在很多局部最优解，但不一定是全局最优解。我们希望构造一个凸函数，也就是一个碗型函数做为逻辑回归的代价函数。 原文链接：https://blog.csdn.net/ljp1919/article/details/79120761 原先总体代价函数： 将 左边 1/2(h_θ(x) - y)^2 替换成新的代价函数（不是总体代价函数！！）： 对于新代价函数理解： 在 y = 1 ，即数据集实际分类为1，Cost图像如下： 如果预测函数h(θ) = 0 ，即分类到0，和实际 1偏差，则代价 --&gt;无穷，惩罚这个函数？ 相反，如果预测结果h(θ) = 1，那么代价为—&gt;0，符合实际数据集 = 1。 同理，y = 0 时，实际分类为0，代价函数Cost图像如下： 但是，和前面代价函数相比怎么更新θ？？ 5.5 简化代价函数与梯度下降 简化代价 &amp; 回归函数 将先前代价函数写成一项： 那么新的总体代价函数是： 梯度下降 总体流程 不断调整θ，使得代价函数（总体）最小，最后得出回归预测函数。 详细过程 更新θ，和前类似，关键在于计算导数。（没推导出求导怎么出来的） 其中 θTx 为线性时，h(x) = g(θ0 + θ2x1+θ3x3…+θnxn)为： hθ(x)=11+e−θTxh_\\theta(x) = \\frac{1}{1+e^{-\\theta^Tx}} hθ​(x)=1+e−θTx1​ 5.6 高级优化 梯度算法简介 octave中调用梯度下降算法 写好代价函数算法 注意这里好像没有数据集，实际上这就是单纯求这个代价函数的最小值。 然后把θ迭代，直至收敛。 实际自己编写的 COSTFunction.m函数 调用梯度下降算法 5.7 多元分类：一对多 问题 我们知道用Logistic 函数对类型进行二维分类，那么如何进行多元分类呢？ 解决 采用“一对余”方法，简单来说。就是先n元分类变成2元分类，区分出一个。 然后循环上述，直至区分出所有。 六、正则化 6.1 过拟合问题 什么是过拟合 无论是之前的，线性回归和逻辑回归都有出现过度拟合。 线性回归过拟合 如下图所示，图三虽然千方百计很好的拟合了数据，保留了更多特征x3、x4…但是很显然它并不能得到一条很好的预测函数。 逻辑回归过拟合 如何解决过拟合 减少特征 减少特征分为人工或者模型选择算法来达到目的。但是减少特征会使得我们无视一些本该有用的特征变量。（比如房子是否明亮对预测价格也是有影响的） 正则化 保留所有特征，但是减少它们的量级。 6.2 代价函数 正则化举例 引子 依旧是图二，虽然保留更多特征，但是图形过于浮夸，并不是一个好的预测函数。我们可以通过正则化，减少特征 x3、x4的影响。 正则化 减少特征 x3、x4的影响，可以通过减少θ3、θ4来实现： 在我们使得代价函数越来越小的过程中，θ3、θ4则会趋于0。使得预测函数好像不存在θ3^3、θ4^4这两项一样，–预测函数越简单越不会出现过度拟合–。 正则化标准过程 确定特征 &amp; 参数 写出代价函数 加入正则新项 正则新项用来惩罚θ参数，注意一般不对θ0进入惩罚。 正则化不当后果 惩罚过大 使得参数 θ 都趋于0，那么预测函数会趋近于一条水平直线。 6.3 线性回归正则化 流程 列出代价函数正则表达式 进行梯度下降 根据以前的梯度下降公式可以得出： 加上正则化进行的变形梯度下降公式： 相比之前，每次更新都对θj*(1 - α*λ/m)，而 (1 - α*λ/m) 是一个比 1小一点的数，则相比未正则化前加快向0的方向趋近？？ 采用正规方程来解决(所有特征x都是一次，线性回归) 根据之前正规方程解出θ，推导过程： θ=(XTX)−1XTy\\theta = (X^TX)^{-1}X^Ty θ=(XTX)−1XTy 如果使用正则化则应该是： 注意：只要λ&gt;0，上式（）中一定可逆。 6.4 Logistic 回归正则化 流程 列出代价函数正则表达式 梯度下降算法 octave实现 写出costFunction函数 七、神经网络学习 7.1 非线性假设 ​ 在前面我们进行都是线性假设，如 ： h = θ0 + θ1x1 + θ2x2 ，而不会出现 x1x2、x1^2*x2…之类。 多项特征处理 两项特征时logistic回归 注意下面只有两个特征x1、x2，但是是非线性，进行回归分类。 多个特征时 举例识别汽车 流程 给每个样本集输入学习算法得出分类器 给一辆汽车标记两个像素位置pixel1、pixel2，并记录它们像素强度坐标 然后再记录另一辆汽车相同像素位置的？？？像素强度坐标 重复以上得出更多左边对它们进行分类 但是，一张50*50图片都有2500个像素点位置，对应2500个像素强度。如果还要包含所有的二次项特征约有300万个。 让分类器去判断一个新样本是否是汽车 7.2 神经元与大脑 略 7.3 模型展示 模型展示1 神经元 神经元模型 神经网络 具体解释 各个出现参数含义 ai^j ,第j 层“激活的神经元”用来计算前一层（j-1）输入x1、x2、x3的值； θ^j，用来控制从第j 到 j +1层的映射权重。 计算流程 ​ 第二层活动神经元ai^2 ，计算从第一层到第二层的映射，同时θ^1来控制映射权重。 ​ 然后第三层，计算最终结果： 在上面这个式中，非常类似于逻辑回归： Logistic函数:hθ(x)=g(θTx)Logistic 函数 :h_\\theta(x) = g(\\theta^Tx) Logistic函数:hθ​(x)=g(θTx) ​ 只不过，它不是直接利用x1、x2、x3特征作为输入，而是先利用第二层“神经元”进行计算。得出a0（多添加的basic单元）、a1、a2、a3。 总结 ​ 第j层有sj个单元，第j+1层有sj+1个单元，那么控制从j层到j+1层映射权重θj的个数应该是，第j+1层单元数 * （第j层单元数 + 1），即： sj+1∗（sj+1）,第j层会补一个x0s_{j+1} * （s_j + 1）,第j层会补一个x_0 sj+1​∗（sj​+1）,第j层会补一个x0​ 模型展示2 向量化神经网络公示 更复杂的神经网络举例 7.4 例子和直觉理解 直觉理解1 神经元函数计算 AND 如下图所示，有两个特征x1、x2只可能是 0 或者 1，同时给它们赋予权重 θ: -30、+20、+20（-30给增加的basic单元）。 那么对应的h(x)，为： hθ(x)=g(−30+20x1+20x2)h_\\theta(x)=g(-30+20x_1+20x_2) hθ​(x)=g(−30+20x1​+20x2​) 对应函数图形为： 那么输入x1、x2得出的特征值是 计算结果恰为 x1 &amp; x2，实现了神经网络逻辑AND运算。 神经网络计算OR 基本同上过程： 神经网络计算NOT 由于权重θ1 = - 20 ，当 x1 = 0 时， h = 1，趋近1 ； 反之 x2 = 1 ，h = 0 ，达到取反的效果。 ​ 进一步还可以得到，计算 NOT x_1 AND NOT x_2。 ​ 只有当 x1 = x2 = 0，h = 1。那么只需 对应权重θ1 、θ2 为一个较大负数，θ0 为一个整数，只要 x1、x2有一个不为0，那么结果必为0。 直觉理解2 组合成更复杂的神经网络计算 x1 XNOR x2 基本神经网络逻辑计算 组合计算x1 XNOR x2 ​ x1 XNOR x2，即 x1、x2相同才会为1。而它们直接基本组合很难计算出来，抓住相同二字，我们可以联想用AND。在此之前一层： x1 = x2 = 0，要经过计算得出为1，显然要用NOT x_1 AND NOT x_2 x1 = x2 = 1，要经过计算得出为1，显然要用 AND 即可 故有如下组合： 其他更复杂计算（手迹判别） 7.5 多元分类----以识别汽车、人、摩托举例 ​ 上节看到的识别手迹数字，就是一个多元分类问题（识别数字 0~9）。神经元网络实现多元分类，本质就是一对多法的扩展。 举例 ​ 简而言之，就是给出特征 x = {x1、x2、x3…}(如前面给出两个像素点像素强度x1、x2)，然后经过多层神经网络，输出预测最后的结果分类（一个4维向量）。 给出数据集 如下图，给出多个图形，每个图形都是一组（x^(i)，y^(i)），其中 x^(i) ：对应图像输入的特征，为一个n维向量 y^(i)：对应输出结果，用一个4维向量分别表示 行人、汽车、摩托车、货车。 训练 ？？？？？？？？下一章节分解。 预测结果 用上面训练好的神经网络来进行预测： 八 、神经网络的反向传播算法 8.1 代价函数 神经网络中字母记法 L : 代表神经网络层数，如下图为 L = 4 ; S_l ：代表第 l 层的单元数，如下图S_L = 4 （最后一层，同时也可记为 K = 4）。 K：一般记录为最后一层输出单元数 x^(i) 、y^(i) ：是向量，y^(i)表示第 i个数据集的输出，由于有4个输出单元所以4维。 如 第2个数据集，第一个输出单元是人，y^(i) = (1 0 0 0)T 代价函数 Logistic 回归代价函数 Logistic代价函数 ：∑m组数据（h(x)预测代价偏差） * 1/m ，然后正则化。 神经网络代价函数 代价函数理解 ​ ∑m组数据（K个输出单元h(x)预测代价偏差和） * 1/m ，然后正则化。 ​ 也就是说对于每组数组，最后都有四个输出单元，四个预测结果(车、人、摩托车…)，对实际预测偏差代价求和。然后再对m数据产生的代价求和。 正则化项理解 在神经网络中，控制从第j 层到 第 j+1 层权重θ数是 sj+1∗（sj+1）,第j层会补一个x0s_{j+1} * （s_j + 1）,第j层会补一个x_0 sj+1​∗（sj​+1）,第j层会补一个x0​ 不考虑，第j层 basic θ0 ，那么应该是： sj+1∗sjs_{j+1} * s_j sj+1​∗sj​ 所以不含输出层所有网络层的θ（取平方）累加便应该是 ∑l=1L−1∑i=1s1∑j=1sl+1(θjil)2\\sum_{l=1}^{L-1}\\sum_{i=1}^{s_1}\\sum_{j=1}^{s_l+1}(\\theta_{ji}^l)^2 l=1∑L−1​i=1∑s1​​j=1∑sl​+1​(θjil​)2 8.2 反向传播算法 梯度下降计算流程 而现在的关键就是，如何计算偏导项，这利用到前向传播 &amp; 反向传播算法。 向量化前向传播算法流程 下图给定一个训练例子(x,y)，进行前向传播得出h(x)预测结果（4输出单元结果）过程 那么至此，可以计算出各层的激活单元输出值 a^(4)。 向量反向传播算法 根据前向传播计算出的各单元激活值a^(4) ，可以进一步计算出反向传播。 计算输出层各激活单元单元激活值（预测值） 和 真实值误差 aj(4)a_j^{(4)}aj(4)​ 是最后一层单元输出值，也就是预测值；yjy_jyj​ 是实际的真实值，它们相减便是第4层第j个输出单元误差 接着，我们可以利用下图公式计算其余各层单元误差（此时误差是向量，代表第L层所有单元误差向量，而不是某个具体单元） 不用计算第一层误差，第一层是实际输入 其中： g′(z(i))=a(i)∗(1−a(i))g&#x27;(z^{(i)}) = a^{(i)} * (1-a^{(i)})g′(z(i))=a(i)∗(1−a(i)) 流程汇总 给定数据初始化 其中每个激活单元都有对应误差： Δij(l):表示第i组数据，第l层，第j个激活单元\\Delta_{ij}^{(l)}:表示第i组数据，第l层，第j个激活单元 Δij(l)​:表示第i组数据，第l层，第j个激活单元 计算所有数据神经网络误差和 在这个循环中 ： Δij(l):第一次循环：是第一次神经网络所有单元误差值；第二次循：第一次循环误差和+第二次循环误差和；以此类推。\\Delta_{ij}^{(l)}:第一次循环：是第一次神经网络所有单元误差值；\\\\ 第二次循：第一次循环误差和 + 第二次循环误差和；\\\\以此类推。 Δij(l)​:第一次循环：是第一次神经网络所有单元误差值；第二次循：第一次循环误差和+第二次循环误差和；以此类推。 上面 j 没有变化？？ 计算偏导项（跳出上诉循环后） 注意：第0个激活单元，不用加标准化项 经过数学证明可以得出，代价函数偏导项如下： 8.3 理解反向传播 前向传播 注意如何计算出z，又进一步计算出a ​ 反向传播 把最大似然函数，当做代价函数？和逻辑回归差不多，勉强可以理解。 误差 = 代价函数对 zj(l)z_j^{(l)}zj(l)​ 导数？ 演示反向传播如何进行 δ2(2)\\delta_2^{(2)}δ2(2)​ 的计算。 δ2(2)\\delta_2^{(2)}δ2(2)​ 根据箭头可知，第三层有两个箭头指向它，需要计算出 δ1(3)\\delta_1^{(3)}δ1(3)​ 、δ2(3)\\delta_2^{(3)}δ2(3)​ ，而 δ1(3)\\delta_1^{(3)}δ1(3)​ 、δ2(3)\\delta_2^{(3)}δ2(3)​ 需要先计算第四层误差。 首先计算出第四层误差： δ1(4)=y(i)−a1(4)\\delta_1^{(4)} = y^{(i)} - a_1^{(4)}δ1(4)​=y(i)−a1(4)​ 根据前一层单元误差 = 下一层对应单元（有箭头）* 权重 可计算出第三层单元误差： δ1(3)=θ11(3)δ1(4)\\delta_1^{(3)} = \\theta_{11}^{(3)} \\delta_1^{(4)}δ1(3)​=θ11(3)​δ1(4)​ δ2(3)=θ12(3)δ1(4)\\delta_2^{(3)} = \\theta_{12}^{(3)} \\delta_1^{(4)}δ2(3)​=θ12(3)​δ1(4)​ 则对应第二层单元误差： δ2(2)=θ12(2)δ1(3)+θ22(2)δ2(3)\\delta_2^{(2)} = \\theta_{12}^{(2)} \\delta_1^{(3)} + \\theta_{22}^{(2)} \\delta_2^{(3)}δ2(2)​=θ12(2)​δ1(3)​+θ22(2)​δ2(3)​ 但是前面不还是有后面那项吗？？？？ 8.4 展开参数 向量化 θ为什么有三个?? 8.5 梯度检测 8.6 随机初始化 8.7 组合 8.8 无人驾驶举例 九、应用机器学习的建议 9.1 评估假设 一部分数据（70%）用来训练模型，一部分数据（30%）用来测试验证。而验证通过计算误差方式来衡量数据集是否准确。常用方法有： 计算测试数据集代价函数 统计误差分类 9.2 模型选择 对于一个模型如何选择拟合函数？ 恰当的做法是把一个数据集分为：训练集(60%)、交叉验证集(20%)、测试集(20%)。 ⚠️ 注意这里定义的都是 误差 ，真正的代价函数 JθJ_\\thetaJθ​ 是可能会有正则项的！ 具体的训练过程为： 训练模型 选择不同的模型（预测函数）hθ1(x)h_{\\theta_1}{(x)}hθ1​​(x)、hθ2(x)h_{\\theta_2}{(x)}hθ2​​(x) …hθi(x)h_{\\theta_i}{(x)}hθi​​(x)，用 训练集 训练出对应的参数θ1\\theta_1θ1​ 、θ2\\theta_2θ2​ …θi\\theta_iθi​ 选择模型 利用 交叉验证集 计算不同模型下的误差 Jcv(θ1)J_{cv}(\\theta_1)Jcv​(θ1​)、 Jcv(θ2)J_{cv}(\\theta_2)Jcv​(θ2​)… Jcv(θi)J_{cv}(\\theta_i)Jcv​(θi​) ，选择误差最小对应的模型。 验证模型 最后利用 测试集 来对我们选择的模型进行最终验证。 9.3 诊断偏差和方差 如何判断我们的模型出现了高偏差或者高方差？ 出现高偏差（欠拟合） 此时训练误差和交叉验证误差都很大（误差都大说明模型不够好）。 出现高方差（过拟合） 训练误差很小，而交叉验证误差很大。说明在新的数据拟合差，只在训练数据集集合好，则属于过拟合情况。 9.4 正则化偏差、方差 在前我们知道选择模型可能会出现高偏差、方差问题： 高偏差：接近直线，不能很好拟合数据 高方差：复杂曲线，多项式过度拟合数据，而没有很好的泛化能力 因此我们可以通过正则化参数使得拟合函数在简单直线和复杂曲线中变化，以下图例可以直观说明： 通过改变参数 λ\\lambdaλ 来修正参数 θ1、θ2...θn\\theta_1 、\\theta_2 ...\\theta_nθ1​、θ2​...θn​ —&gt; 修正偏差和高方差。 9.4.1 如何选择正则参数 一般以 步长=0.02步长 = 0.02步长=0.02 递增来选择 λ\\lambdaλ 进行炼丹 ： 通过选择合适的 λ\\lambdaλ ，我们找到使得交叉验证误差 JcvJ_{cv}Jcv​ 最小的λ\\lambdaλ（红色曲线最低点） 9.5 学习曲线 对于一个给定数据集，我们选择模型假设函数对其进行训练。可以通过学习曲线来帮助我们直观选择参数。 出现高偏差 也就是出现欠拟合，如下图： 此时无论是 训练误差Jcv(θ)J_{cv}{(\\theta)}Jcv​(θ)、交叉验证误差 Jtrain(θ)J_{train}{(\\theta)}Jtrain​(θ) 都很大，这是由于我们选择的模型不当。 出现高偏差无论 用再多的数据集也无法降低误差 。 因此我们需要选择更复杂的多项式函数模型来拟合。 出现高方差 这是因此选择的模型过于复杂出现欠拟合。 此时 训练误差Jcv(θ)J_{cv}{(\\theta)}Jcv​(θ) 较小、交叉验证误差 Jtrain(θ)J_{train}{(\\theta)}Jtrain​(θ) 较大。但是可以通过增加数据集来减少Jtrain(θ)J_{train}{(\\theta)}Jtrain​(θ) 。 9.6 总结：算法效果不好？ 如果我们通过一个模型如下，进行训练： 首先通过画出 Jcv(θ)J_{cv}{(\\theta)}Jcv​(θ) 、 Jtrain(θ)J_{train}{(\\theta)}Jtrain​(θ) 图像，来判断我们的算法出现什么问题。 🎯 我们最终目标都是使Jtrain(θ)J_{train}{(\\theta)}Jtrain​(θ) 误差最小。 出现高偏差 增加更多特征：如 x3、x4 etc.x_3、x_4 \\ etc.x3​、x4​ etc. 增加多项特征：如 x12、x22、x1x2x_1^2、x_2^2、x_1x_2x12​、x22​、x1​x2​ 减少正则化参数λ\\lambdaλ ：使得拟合函数更加复杂 出现高方差 获取更多数据：更多数据可以有效降低误差 Jtrain(θ)J_{train}{(\\theta)}Jtrain​(θ) 减少更多特征：可避免过拟合 增加正则化参数 λ\\lambdaλ ：可降低 θ\\thetaθ ，使得拟合曲线简单一点。 9.6.1 关于神经网络 choose：小与大？ 小型神经网络一般不容易出现过拟合，大型神经网络容易出现过拟合，但可以使用正则化参数来解决。 所以一般可以选择大神经网络更好。 choose：隐藏层个数？ 一般选择1 个是比较合理的选项。 也可尝试多个，这样就需要根据 Jcv(θ)J_{cv}{(\\theta)}Jcv​(θ) 、 Jtrain(θ)J_{train}{(\\theta)}Jtrain​(θ) 等误差来判断，多少隐藏层个数是最好的选择。 十、机器学习系统设计 10.1 误差分析 10.1.1 建议措施 以下是一个邮件分类具体实例提高机器学习分类正确率。 先有一个邮件分类系统，它对500个 CVCVCV 验证集进行了 100 次 错误分类。我们人工检查这100个错误： 我们人工分类这是什么类型邮件，然后检查是什么原因（特征）导致分类错误: 类型：这 100封错误分类邮件，有四种类型 分类错误原因：邮件故意拼写错误、不寻常的邮件路径等 使用数值分析，来决定是否做某些优化。 比如，下面是否应该将 discount / discounted / discounting 等视作为一个单词？ 又如，是否应该忽略首字母大小写，mom / Mom 视作一个单词？ 我们应该尝试去进行优化前后 数值分析错误率对比，如果优化后分类错误更低那么就进行优化，反之则取消。 10.2 不对称性分类的误差评估 假设我们预测：癌症（y=1）,非癌症（y≠1）。我们可以画出类似下面的四方格子： 我们由此可以得出两个评估模型的数字概率： 查准率 ： 在这个模型中，查准率=预测正确为癌症数(y=1)所有预测为癌症数(y=1)查准率 = \\frac{预测正确为癌症数(y=1)}{所有预测为癌症数(y=1)}查准率=所有预测为癌症数(y=1)预测正确为癌症数(y=1)​ 召回率： 在这个模型中，召回率=预测正确为癌症数(y=1)实际为癌症数(y=1)召回率 = \\frac{预测正确为癌症数(y=1)}{实际为癌症数(y=1)}召回率=实际为癌症数(y=1)预测正确为癌症数(y=1)​ 查准率高说明 False pos 低False \\ \\ pos \\ 低False pos 低 (错误预测为癌症数低) ；召回率高说明False neg 低False \\ \\ neg \\ 低False neg 低 （错误预测为非癌症数低） 10.3 精确度和召回率的权衡 依旧以之前那个预测癌症为例。我们知道预测函数 0≤hθ(x)≤10 ≤ h_\\theta{(x)} ≤ 10≤hθ​(x)≤1 ，且通常我们当 hθ(x)&gt;0.5h_\\theta{(x)} &gt; 0.5hθ​(x)&gt;0.5，预测 y =1，即是癌症。 提高查准率：谨慎告诉病人得了癌症。 告诉病人得了癌症是一件需要谨慎判断的事情，所以我们可以通过提高 thresholdthresholdthreshold ，比如 hθ(x)&gt;0.99h_\\theta{(x)} &gt; 0.99hθ​(x)&gt;0.99 时才判断为1告诉病人得了癌症。 但是这样做会导致：查准率(正确预测为癌症数提高)得到提高，而召回率下降？(判断正确为癌症数下降)。 提高召回率：需要有可能患癌症病人及时得到治疗。 同上，此时只要降低 thresholdthresholdthreshold ，比如 hθ(x)&gt;0.01h_\\theta{(x)} &gt; 0.01hθ​(x)&gt;0.01 即判断病人或有癌症。 同样的，这样做会导致：查准率降低，而召回率提高？(判断正确为癌症数上升，实际为癌症数不变)。 10.3.1 如何综合评价算法查准率/召回率？ 对于下面三个不同算法，有三个不同查准率/召回率，选择哪个算法？ 如果不是希望：查准率/召回率 某个值更高，我们可以综合评价算法。但是，取平均值不是一个好的做法。我们采用一种叫做 F ScoreF\\ ScoreF Score 综合评价算法。 F ScoreF\\ ScoreF Score 越大则算法越好，比如极端情况：召回率=查准率=1召回率=查准率 = 1召回率=查准率=1 ， F Scoremax=1F\\ Score_{max} = 1F Scoremax​=1 10.4 机器学习数据 最成功的的不是那些拥有最好的算法的人，而是那些拥有最多数据的。 降低偏差：使用带有众多参数的算法来降低偏差，比如拥有复杂隐藏层的神经网络。 降低方差：使用大数据集来降低方差，使得测试集误差也会相应很小。 二者结合，机器学习，千秋万代，一统江湖。 十一、支持向量机(SVM) 11.1 优化目标 我们对此前的 logistic 回归代价进行一些修改。 yi=1时，代价函数=−log11+e(−θTx)y_i = 1 时，代价函数 = - log\\frac{1}{1+e^{(-\\theta^Tx)}}yi​=1时，代价函数=−log1+e(−θTx)1​ ：如左图，我们想要此时 z=θTx&gt;&gt;0z = \\theta^Tx &gt;&gt; 0z=θTx&gt;&gt;0 ，如果满足则代价越小，不满足则代价则越大。 而支持向量机代价函数 cost1(z)cost_1(z)cost1​(z) 则是一条折线，逼近于原本代价函数： z&gt;1时z &gt;1 时z&gt;1时：此时代价为0，换言之z&gt;1−&gt;hθ(x)始终=1−&gt;代价函数=−log11+e(−θTx)=0z &gt;1 -&gt; h_\\theta (x) 始终= 1 -&gt; 代价函数 = - log\\frac{1}{1+e^{(-\\theta^Tx)}} = 0z&gt;1−&gt;hθ​(x)始终=1−&gt;代价函数=−log1+e(−θTx)1​=0 z&lt;1z &lt; 1z&lt;1 时：此时代价函数近似原本 logistics 回归代价函数 yi=−1时，代价函数=−log(1−11+e(−θTx))y_i = -1 时，代价函数 = - log(1-\\frac{1}{1+e^{(-\\theta^Tx)}})yi​=−1时，代价函数=−log(1−1+e(−θTx)1​) ：如右图，其余类似上，不再赘述。 因此我们可以得到最终支持向量机的代价函数： SVM 代价函数是CA+BCA+BCA+B 形式，而不是 logistics 代价函数 A+λBA + \\lambda BA+λB 形式。这是因为我们更关注与第一项AAA 的优化而不是第二项。 假设函数是否有误？ 应该是 θTx≥1，hθ(x)=1;θTx≤−1，hθ(x)=0\\theta^Tx ≥ 1 ，h_\\theta(x) = 1 ; \\theta^Tx ≤ -1 ，h_\\theta(x) = 0θTx≥1，hθ​(x)=1;θTx≤−1，hθ​(x)=0 ？？ 11.2 直观上对大间隔的理解 再次回顾下此前支持向量机代价函数 JSVMJ_{SVM}JSVM​： 11.2.1 SVM：线性最大分隔 对于一个样本我们有多种进行分隔直线进行分类，就像下面这种： 显然，黑色直线具有直观上最好的分类效果，因为它离正负样本都拥有 最大间距 。 进一步直观理解 SVM 中正则化系数CCC 的作用：防止过拟合。 下面这张图展示不同情况下 CCC 可能导致的情况。 当 CCC 过大 时：此时分隔直线是上面红色直线，显然它发生了过拟合。类似于 logistics 回归 λ\\lambdaλ 过小 时，导致过拟合情况。 当CCC 不是很大时：此时分隔直线显然具有更好的泛化能力，不会发生过拟合。 11.3 大间隔分类数学原理 引子：对于两个向量 u=[u1u2]u = \\begin{bmatrix} u_1\\\\u_2 \\end{bmatrix}u=[u1​u2​​] 与 v=[v1v2]v= \\begin{bmatrix} v_1\\\\v_2 \\end{bmatrix}v=[v1​v2​​] ，uTvu^TvuTv 的几何意义怎么理解？ 直接给结论：uTvu^TvuTv = u1v1+u2v2u_1v_1 + u_2v_2u1​v1​+u2​v2​ = P⋅∣∣u∣∣P·||u||P⋅∣∣u∣∣ = v在u上的投影距离∗u的长度v 在u上的投影距离*u的长度v在u上的投影距离∗u的长度 注意：PPP 是有方向的，而范数 ∣∣u∣∣||u||∣∣u∣∣ 是没有方向只有距离。 11.3.1 数学分析 🎯 我们的目标是最小代价函数。 根据上面公式可知，等价为 min 12∑j=1nθj2min \\ \\frac{1}{2} \\sum_{j=1}^{n}\\theta_j^2min 21​∑j=1n​θj2​ （因为第一项可控？）： 在根据 引子数学公式引子数学公式引子数学公式 我们可以进一步表达如下： 直观观测SVM如何确定最大间隔。 绿色直线为决策直线 y=θTxy = \\theta^Txy=θTx，蓝色直线为 θ\\thetaθ 向量，且它们互相垂直 ? 令 θ0=0\\theta_0 = 0θ0​=0 可以保证决策直线一定经过原点。 图1：为什么SVM可以决策直线不好？ 我们要使得 min 12∑j=1nθj2==min∣∣θ∣∣2min \\ \\frac{1}{2} \\sum_{j=1}^{n}\\theta_j^2 == min|| \\theta||^2min 21​∑j=1n​θj2​==min∣∣θ∣∣2 ，同时还要满足条件： {p(i)⋅∣∣θ∣∣≥1，正样本p(i)⋅∣∣θ∣∣≤−1，负样本\\begin{cases} p^{(i)}·||\\theta|| ≥1 &amp;，正样本\\\\ p^{(i)}·||\\theta|| ≤-1 &amp;，负样本\\\\ \\end{cases} {p(i)⋅∣∣θ∣∣≥1p(i)⋅∣∣θ∣∣≤−1​，正样本，负样本​ 可以看到恰好使得等式成立的支持向量 x(1)、x(2)x^{(1)}、x^{(2)}x(1)、x(2) 在向量 θ\\thetaθ 上的投影p(1)、p(2)p^{(1)}、p^{(2)}p(1)、p(2) 都很小。 而我们又要满足上述条件，那么自然 ∣∣θ∣∣||\\theta||∣∣θ∣∣ 就要很大，这与我们的目标不符合，所以可判断决策直线不好。 图2：为什么SVM可以决策直线好？ 同上，此时支持向量在 θ\\thetaθ 向量上的投影 p(1)、p(2)p^{(1)}、p^{(2)}p(1)、p(2) 最大 —&gt; 那么 ∣∣θ∣∣min||\\theta||_{min}∣∣θ∣∣min​ 。 11.4 核函数 11.4.1 核函数（上） 如何进行复杂非线性分类？ 在此前我们进行复杂非线性分类，是增加更多特征 x1x2、x12、x22...x_1x_2、x_1^2、x_2^2...x1​x2​、x12​、x22​... 进行非线性分类： 决策边界是： θTX=θ0+θ1x1+θ2x2+θ3x1x2...\\theta^TX = \\theta_0+\\theta_1x_1 +\\theta_2x_2+\\theta_3x_1x_2...θTX=θ0​+θ1​x1​+θ2​x2​+θ3​x1​x2​... ，预测函数为 h(θTx)h(\\theta^Tx)h(θTx) 。 而现在我们可以利用相似度函数 fff 来产生更多特征，将上面特征 x1、x2、x1x2、x12、x22...x_1、x_2、x_1x_2、x_1^2、x_2^2...x1​、x2​、x1​x2​、x12​、x22​... 替换为 f1、f2、f3、f4..f_1、f_2、f_3、f_4..f1​、f2​、f3​、f4​.. 。 θTf=θ0+θ1f1+θ2f2+θ3f3...其中：fi=similarity(x,l(i))=exp(−∣∣x−l(i)∣∣22σ2)\\theta^Tf = \\theta_0+\\theta_1f_1 +\\theta_2f_2+\\theta_3f_3...\\\\ 其中： f_i = similarity(x,l^{(i)}) = exp(-\\frac{||x-l^{(i)}||^2}{2\\sigma^2}) θTf=θ0​+θ1​f1​+θ2​f2​+θ3​f3​...其中：fi​=similarity(x,l(i))=exp(−2σ2∣∣x−l(i)∣∣2​) l(i)l^{(i)}l(i) 即标记。 进一步理解相似度函数 l(i)、σl^{(i)} 、\\sigmal(i)、σ 作用。 l(i)l^{(i)}l(i) 会标记对应产生的不同特征 f1、f2...f_1、f_2 ...f1​、f2​... ，它可用来描述和特征 xxx 的偏离： 当 l(i)接近xl^{(i)} 接近 xl(i)接近x ，fff 输出为 111 ， 当 l(i)远离xl^{(i)} 远离 xl(i)远离x ，fff 输出为 000 。 σ\\sigmaσ 可用来控制当 x远离l(i)x 远离 l^{(i)}x远离l(i) 时，函数 fff 趋于0下降的速率。 初始 l(1)=[35]l^{(1)} = \\begin{bmatrix} 3\\\\ 5 \\end{bmatrix}l(1)=[35​] 当 x=[35]x = \\begin{bmatrix} 3\\\\ 5 \\end{bmatrix}x=[35​] ，此时函数值 = 1 (顶峰处)。如果 σ\\sigmaσ 较大，可以看出当 x偏离l(1)x 偏离 l^{(1)}x偏离l(1) 越多，则此时函数值趋于0会相比较其它图更快。 一张图进行总结如下： 一个实际计算实例。 11.4.1 核函数（下） 如何获取标记 l(1)、l(2)、l(3)...l^{(1)}、l^{(2)}、l^{(3)}...l(1)、l(2)、l(3)... ？ 初始选择 l(1)=x(1)、l(2)=x(2)、l(3)=x(3)...l^{(1)} = x^{(1)}、l^{(2)} = x^{(2)}、l^{(3)} = x^{(3)}...l(1)=x(1)、l(2)=x(2)、l(3)=x(3)... ？然后怎么更新 l(i)l^{(i)}l(i) ? θTf=θ0+θ1f1+θ2f2+θ3f3...+θmfm...其中：fi=similarity(x,l(i))=exp(−∣∣x−x(i)∣∣22σ2)\\theta^Tf = \\theta_0+\\theta_1f_1 +\\theta_2f_2+\\theta_3f_3...+\\theta_mf_m...\\\\ 其中： f_i = similarity(x,l^{(i)}) = exp(-\\frac{||x-x^{(i)}||^2}{2\\sigma^2}) θTf=θ0​+θ1​f1​+θ2​f2​+θ3​f3​...+θm​fm​...其中：fi​=similarity(x,l(i))=exp(−2σ2∣∣x−x(i)∣∣2​) 有多个样本就有多个核函数 fif_ifi​？ 核函数版代价函数。 11.5 使用SVM 我们可以使用成熟的库来实现SVM算法的应用。 那么，大量细节实现被隐藏了，我们仅需要选择参数 CCC 和 核函数fi核函数f_i核函数fi​。 线性核函数，实际没有应用到核函数，但我们保持这么一个称呼以便统一。 11.5.1 多分类 依旧是一对多，分类KKK个类别，训练 KKK 个线性 SVMsSVMsSVMs 。 给定一组特征(X,Y)(X,Y)(X,Y) ，K组训练权重θ\\thetaθ ， θ(i)TX{\\theta^{(i)}}^TXθ(i)TX对应概率最大则分类为 iii。 11.5.3 logistics 回归 &amp; SVM 以下列举了对于特征 nnn 与样本数 mmm 不同情况下，如何选择 logistics 回归 OR SVM 进行分类。 十二、无监督学习 12.1 K-means 算法","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://hwh.zone/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"吴恩达","slug":"吴恩达","permalink":"https://hwh.zone/tags/%E5%90%B4%E6%81%A9%E8%BE%BE/"},{"name":"机器学习","slug":"机器学习","permalink":"https://hwh.zone/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"深度学习","slug":"深度学习","permalink":"https://hwh.zone/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"Java基础笔记","slug":"JAVA基础笔记","date":"2021-11-25T10:32:06.260Z","updated":"2021-11-26T16:12:13.917Z","comments":true,"path":"2021/11/25/JAVA基础笔记/","link":"","permalink":"https://hwh.zone/2021/11/25/JAVA%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/","excerpt":"","text":"第一章：初识java 1.0 快捷键 Alt + \\ : 查看本来所有方法，变量 Ctrl+Alt ： 跳出虚拟机 1.1 JDK安装与配置 JDK下载 下载地址：官网JDK下载 下载完毕后： 下载是exe文件，安装 到 D:/JDK 文件夹下（没有自己新建JDK文件夹） 下载是压缩包，解压到相应 D:/JDK 文件夹下即可。 配置环境变量（win10） 首先打开 系统属性—&gt;高级----&gt;环境变量： 如上图所示，新建一个系统变量JAVA_HOME: 接着选择编辑PATH变量： 选择新建一个%JAVA_HOME%\\bin ，并移动到最上方： %JAVA_HOME% : 表示引入的 前一个 系统变量 JAVA_HOME 路径 记得依次点击确定保存，关闭环境变量设置。 验证是否成功 win + r ---&gt; cmd ----&gt; java -version 查看，显示版本号则按照成功： 1.2 IDE : intelliJ IDEA 下载 &amp; 安装 官网地址：官网下载IDEA 傻瓜似安装，注意安装过程选择64位。 注册激活 第一次打开IDEA时会要求你注册激活，选择输入激活代码，博客激活码地址： 激活地址，第二个可用 1.3 第一个项目:HELLOJAVA 创建项目 选择 File–&gt;New–&gt;Project ,SDK 选择 安装 JDK 所在目录（同上）： 下一步选择 Project 所在文件夹： ⚠️ 先创建一个文件夹用来保存项目，该步不会自动创建一个Projiect对应文件夹！ 第一个 JAVA 文件 为了方便管理，可以先创建一个 Package（类似 C# 命令空间）。 右键选择 src---&gt; new ---&gt; package ，比如新建 package 名为：HELLOJAVA； 右键选中 HELLOJAVA 包，HELLOJAVA--&gt; new --&gt; class ，新建类名为 hello： 编辑hello.java 1234567public class hello //选择创建class，会自动创建同名类名&#123; public static void main(String[] args) //里面参数不能少 &#123; System.out.println(&quot;Hello JAVA&quot;); &#125;&#125; 配置 这个时候直接运行是运行不了的，还要设置一些东西，点击下图按钮添加配置信息： 选择模板 &amp; 主函数位置： 运行 选择 hello.java文件，右键选择 run “hello.main()” 即可。 第二章 ：JAVA基本知识 2.1 面对对象 实战 设计一个Hero 类对象VN，有一些属性；有加血函数等。 在Hero类中 12345678910111213public class Hero&#123; //设计一些属性 String name; //String 第一个S是大写 int HP; int moveSpeed; //函数：加血 void addHP(int blood) &#123; HP += blood; System.out.println(&quot;加血!&quot;); &#125;&#125; 在Hello类中 1234567891011121314151617public class hello&#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello JAVA&quot;); // 调用item类，实例出一个对象 Hero i = new Hero(); i.name = &quot;vn&quot;; i.HP = 2000; i.addHP(200); &#125;&#125;/* 输出结果： Hello JAVA 加血!*/ 总结 java 面对对象和 C# 目前有以下区别： java 每次 new --&gt; class ，在这个新类中只能写一个类，有多个类会报错 System.out.println 还不太熟，官方文档语焉不详的，待摸索怎么读官方文档。 2.2 变量 变量类型 整型 int（4种） 类型 缺省值 长度 范围 byte 0 8 -128 ~ 127 short 0 16 -32768 ~ 32767 int 0 32 -2147483648 ~ 2147483647 long 0 65 -9223372036854775808 ~ 9223372036854775807 即使声明 long 类型，也要以 L或者l结尾，否则是int类型 12long val = 1234567890; // 报错，被当成int类型超出范围long val = 1234567890L; // 正确 int 类型 也可以表示 4种进制 1234int decVal = 26; //默认int型int hexVal = 0x1a; //16进制int oxVal = 032; //8进制int binVal = 0b11010; //2进制 字符型 char 可以用char 类型表示一些转义字符： 1234567//以下是转义字符char tab = &#x27;\\t&#x27;; // 制表符char carriageReturn = &#x27;\\r&#x27;; // 回车char newLine = &#x27;\\n&#x27;; // 换行char doubleQuote = &#x27;\\&quot;&#x27;; // 双引号char singleQuote = &#x27;\\&#x27;&#x27;; // 单引号char backslash = &#x27;\\\\&#x27;; // 反斜杠 浮点型 float、double float 类型表示浮点数（整数时不报错）时要加f ： 12float f = 123.456; //报错，一定要加ffloat f1 = 123.456f; // 正确 double 类型表示浮点数不用加： 12double d = 123.456; //正确double d1 = 1.23456e2 // 科学技术法 = 1.23456 * 10^2 2020-12-30 总结： 在java中，long、float（double不用）类型，变量值还要+前/后缀对应，才能正确定义。 布尔型 boolean 1boolean b1 = true; 字符串 String String 类型其实并不是基本类型 , 而是 lmmutable 类型 ；而且一旦创建不能别改变。 这里一旦创建不能被改变，不能改变内容但是可以改变引用指向，比如下面： 12String str = &quot;hello&quot;;str = &quot;hello world&quot;; //改变成功，改变了引用 实际上又成功改变了，因为改变了str 原来指向“hello” —&gt; 转为指向 “hello world” 类型转换 低精度向高精度转换 这种转换是不需要强制转换的，默认转换就可以。 高精度向低精度转换 和以前学的无太大区别，注意以下几点： short &amp; char 转换 虽然二者位数相同但是还是要强制转换 123char c = &#x27;A&#x27;;short s = 80;c = (char) s; // 强制转换 int 以下数据相加 在 java 世界里，如果精度 &lt; int 进行 数值运算会被自动提升到int类型 123short a = 1;short b = 2;System.out.println(getType(a+b)); // int类型 也就是说下面必须要强制转换 : 1short c = (short)(a + b); // ※ ※ ※ 注意理解 ※ ※ ※ 变量修饰 final 当一个变量被 final 修饰的时候，该变量只有一次赋值的机会。 12final int i = 1;i = 5 // 出错，i已经被赋值过来 特别的注意，当 final 修饰参数时： 1234567public class HelloWorld&#123; public void method1(final int j) &#123; j = 5; //这个能否执行？ &#125;&#125; 此时是不能执行的，因为调用方法是 实参赋值给形参，j = 5 不能再赋值了。 2.3 输入、输出 输出 Println 字符串直接可以**+**连接，涉及到复杂一般还是 format ： 1System.out.println(&quot;hello&quot;+&quot; world &quot;); // 输出：hello world format %s ：表示字符串 %n：表示换行符 %d：表示整数 %8d，（默认）右对齐，占8长度 ；%-8d，左对齐，8长度；%08d，长度8不够补0。 12System.out.format(&quot;%08d，%n&quot;,123); // 输出 00000123System.out.format(&quot;%08d&quot;,123.45); // 出错，不能是浮点数 %f：表示浮点数 %.2f，表示保留两位小数。 1System.out.format(&quot;%.1f&quot;,123.456); // 四舍五入，保留一位小数：123.5 输入 输入一般是用 Scanner类 来捕捉用户输入。 基本使用 12345678910111213141516import java.util.Scanner; // 1. 引用Scanner类public class hello&#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); // 2. 实例化 Scanner对象 System.out.println(&quot;请输入一个整数&quot;); int a = s.nextInt(); // 读入整数 System.out.println(&quot;输入整数为 ：&quot; + a); System.out.println(&quot;请输入一行字符串&quot;); String str1 = s.nextLine(); // 3.读取回车键 String str1 = s.nextLine(); //读入字符串 System.out.println(&quot;输入字符串为 ：&quot; + str1); &#125;&#125; 读入输入数据首先需要引用 Scanner类 ，且实例化 整数、浮点数、字符串…都有对应 nextInt() 、nextFloat() 、nextLine() 等方法 特别注意 nextLine() 方法，前面有如 ：nextInt()读入数据 + 回车 ， 会读入回车~ 2.4 控制流程 switch switch 可以使用 byte,short,int,char,String,enum 2.5 数组 声明 &amp; 创建 一维数组 12345678910// 1.声明一个引用int a[]; int[] a;// 2.分配空间a = new int[5];// 3.分配空间 &amp; 赋值a = new int[5]&#123;1,2,3,4,5&#125;;a = new int[]&#123;1,2,3,4,5&#125;; // 省略：(1) [数组大小]a = &#123;1,2,3,4,5&#125;; // 省略：(1) [数组大小] (2) new 分配符 二维数组 12345678910// 1.声明一个引用int[][] a;// 2.分配空间int[][] a = new int[2][3];int[][] a = new int[2][]; // 虽然一维数组长度被省略，但是要访问必须指定一维数组长度// 3.分配空间 &amp; 赋值int[][] a = new int[][]&#123; &#123;1,2,4&#125;, &#123;4,5&#125;, &#123;6,7,8,9&#125;&#125;;int[][] a = &#123; &#123;1,2,4&#125;, &#123;4,5&#125;, &#123;6,7,8,9&#125;&#125;; // 省略：(1) [][] (2) new 分配符 增强型for循环 举例 循环打印数组内容。 12345int[] arr = &#123;1,2,3&#125;;for(int item : arr) // 类比C#：foreach(int item in arr)&#123; System.out.println(item);&#125; 输出 1234//输出 1 2 3 常用数组操作 复制 用 Arrays 类 实现： 首先注意，需要引用：import java.util.Arrays; 1234567891011121314/* 复制数组 : Arrays.copyOfRange(int[] original, int from, int to) - original : 被复制的数组 - from：复制起始位置 - to： 复制结束位置*/int[] srcArr = &#123;1,2,3,4,5&#125;;int[] destArr ; // 下面复制：自动给目标数组分配空间destArr = Arrays.copyOfRange(srcArr, 0, arr.length); for (int item : b)&#123; System.out.print(item + &quot;&quot;);&#125; 合并 以下利用系统方法 复制实现合并两个数组： 123456789101112131415161718/* 复制数组 : System.arraycopy(src, srcPos, dest, destPos, length) - src : 被复制的数组 - srcPos：被复制数组起始位置 - dest：目标数组 - destPos：复制到目标数组的起始位置 - length ：复制的长度*/int[] arr1 = &#123;1,2,3,4,5&#125;;int[] arr2 = &#123;6,7,8&#125;;int[] arr3 = new int[arr1.length + arr2.length];System.arraycopy(arr1, 0, arr3,0 ,arr1.length); // 必须新数组长度容下前2个数组System.arraycopy(arr2, 0, arr3,arr1.length ,arr2.length);for (int item : arr3)&#123; System.out.print(item + &quot;&quot;); // 最终输出： 1 2 3 4 5 6 7 8&#125; 转换成字符串 12345678/* 转字符串 :Arrays.toString(src); - src : 被转换的数组*/int[] srcArr = &#123;1,2,3,4,5&#125;;String content = Arrays.toString(srcArr);System.out.println(content); // 输出：[1, 2, 3, 4, 5] 排序 123456789/* 排序 : Arrays.sort(src); - src : 被排序的数组 返回值 : 无返回值！*/ int[] srcArr = &#123;1,2,3,4,5&#125;; Arrays.sort(srcArr); // 无返回值 System.out.println(Arrays.toString(srcArr)); // 输出：[1, 2, 3, 4, 5] 二分查找（必须先sort排序！） 12345678910/* 查找 : Arrays.binarySearch(src,elem); - src : 被搜索的数组 - elem : 被搜索的元素 返回值 : 被搜索元素的位置*/ int[] srcArr = &#123;1,2,3,4,5&#125;; Arrays.sort(srcArr); // 无返回值 System.out.println(Arrays.binarySearch(srcArr, 3)); // 输出：2（从0计数） 判断是否相同 System.out.println(Arrays.equals(a, b)); 填充 使用指定元素值，填充数组。 123int a[] = new int[3];Arrays.fill(a, 6); System.out.println(Arrays.toString(a)); // 输出：[6,6,6] 第三章：类和对象 3.1 基本概念 引用 区分 引用 与 = ? 12int h = 5; // 此时 = 表示赋值 ，h 是变量Hero h1 = new Hero(); // 此时 = 表示指向，h1 是引用 一个对象，有多个引用 12Hero h1 = new Hero();Hero h2 = h1; //h2指向h1所指向的对象 一个引用，有多个对象 下面 两次 new Hero() 产生了两个对象 12Hero garen = new Hero(); // garen 指向Hero对象1garen = new Hero(); // garen 指向Hero对象2 但是，同一时间只能指向同一个对象，所以对象1没有引用指向。 继承 使用 extends 关键字来实现继承： 123456789101112// 物品类public class Item&#123; String name; String price;&#125;// 草鞋类public class shone extends Item &#123; int speed;&#125; 参数 this参数 this 代表当前对象。 类函数参数 和 属性重名，this.属性名 访问属性 构造方法中调用另一个构造方法 ，this(参数) 传参（引用类型传参） 尝试写出下面程序输出结果。 12345678910111213141516171819202122232425/* 写出下面输出结果 */public class Hero &#123; String name; //姓名 float hp; //血量 public Hero(String name,float hp) &#123; this.name = name; this.hp = hp; &#125; //复活 public void revive(Hero h) &#123; h = new Hero(&quot;提莫&quot;,383); &#125; public static void main(String[] args) &#123; Hero teemo = new Hero(&quot;提莫&quot;,383); teemo.hp = teemo.hp - 400; // 受到400伤害，挂了 teemo.revive(teemo); // 复活 System.out.println(teemo.hp); &#125; &#125; 输出结果： -17 , 即原来死去teemo血量 虽然是传递引用，但是在 revive 方法中，此时 hp = 383 ; 退出方法后，h 指向的临时对象被销毁。 执行revive方法前，引用teemo指向 死去teemo对象 ； 执行revive方法时，引用teemo 复制一份给形参 h ，teemo 和 h 都是指向同一个对象；但是，形参引用h 又new了份新内存，现在它指向的是新Hero对象(无名) 。 参考这篇文章：对象传参 执行revive方法后，引用h 指向对象被销毁，引用teemo 始终指向死去teemo对象。 访问修饰符 似乎没有说，对象访问权限？ 下图，是类中属性、方法被修饰后各种情况访问权限。绿色表示可以访问；红色表示不可以。 静态方法和属性 静态属性static 什么时候使用？ 如果一个属性，每个英雄都不一样，比如name，这样的属性就应该设计为对象属性，因为它是跟着对象走的，每个对象的name都是不同的。 如果一个属性，所有的英雄都共享，都是一样的，那么就应该设计为类属性 = 静态属性。 静态方法static 什么时候使用？ 如果方法里访问了对象属性，那么这个方法，就必须设计为对象方法； 如果一个方法，没有调用任何对象属性，那么就可以考虑设计为类方法。 比如取随机数 ：Math.random() 其它特性 静态方法不能调用非静态方法、成员 ；反之却可以。 实例成员变量是属于某个对象的，而静态方法在执行时，并不一定存在对象。所以，不允许，静态方法调用实例成员变量。 对象属性初始化 初始化方法 注：静态属性初始化，除了第三种：不能在构造函数（*非静态函数不能调用静态属性？*可以！见前。）初始化，其余都可以！ 1234567891011121314public class Hero &#123; // 1.声明属性时 public String name = &quot;first&quot;; // 2.初始化块时 &#123; name = &quot;second&quot;; &#125; // 3.构造函数时 public Hero() &#123; name = &quot;third&quot;; &#125; &#125; 初始化顺序 那么问题来了，上述代码 name 最终被初始化 ？ 初始化属性： 静态变量 --&gt; 静态初始化块 --&gt; 变量 --&gt; 初始化块 --&gt; 构造器 所以，答案是 ： third。 3.2 单例模式 2020-12-23 总结： 单例模式应用场景 &amp; 特点 【场景】 例1：回收站。在windows桌面上打开了一个回收站，当我们试图再次打开一个新的回收站时，Windows系统并不会为你弹出一个新的回收站窗口。也就是说，在整个系统运行的过程中，系统只维护一个回收站的实例。这就是一个典型的单例模式运用。 例2：网站计数器。 网站的计数器，一般采用单例模式实现。如果存在多个计数器，每一个用户访问都刷新计数器值，计数值难以同步。 例3：程序日志。 web开发中读取配置文件都适合使用单例模式，如HttpApplication 就是单例的典型应用。 【特点】 优点：实现了对唯一实例访问的可控；对于一些需要频繁创建和销毁的对象来说可以提高系统的性能。 缺点： 不适用于变化频繁的对象； 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出； 如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失。 单例模式三元素 构造方法私有化 静态属性指向实例 public static的 getInstance方法，返回第二步的静态属性 饿汉单例模式 饿汉式 ：是立即加载的方式，无论是否会用到这个对象，都会加载 举例 ：数据库连接，构造立即初始化，启动时感觉会卡顿。 1234567891011121314public class GiantDragon &#123; // 1.私有化构造方法：类外无法 new 进行实例化 private GiantDragon()&#123;&#125; // 2.静态属性指向实例 private static GiantDragon instance = new GiantDragon(); // 3.每次获取实例都是 2. 中实例，实现单例 public static GiantDragon getInstance() &#123; return instance; &#125;&#125; 懒汉单例模式 饿汉式 ：非立即加载的方式，使用时才会加载。 举例 ：业务上有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式。 12345678910111213/* 部分代码略。同饿汉单例模式 ，不过将 2. &amp; 3.中进行一些改变 */ // 2.静态属性指向实例 ： 但不new！ private static GiantDragon instance = null; // 3.同前：不存在才创建一次，防止创建出不同对象。 public static GiantDragon getInstance() &#123; if(instance == null) instance = new GiantDragon(); else return instance; &#125; 3.3 枚举类型 枚举创建 enum是特殊class，enum声明定义的类型就是一个类。 e.g. 单独写一个颜色枚举类Color.java。 123456789101112131415161718enum Color &#123; RED(255, 0, 0), BLUE(0, 0, 255), BLACK(0, 0, 0), YELLOW(255, 255, 0); // rgb三属性 private int redValue; // 自定义数据域，private为了封装。 private int greenValue; private int blueValue; // 构造枚举值，比如RED(255,0,0) private Color(int r, int g, int b) &#123; this.redValue = r; this.greenValue = g; this.blueValue = b; &#125;&#125; 枚举 + switch 可以更好限定范围 &amp; 指定各种类型。 123456// 枚举调用：类名.枚举颜色，创建对象Color color = Color.RED; // 不用写后面参数switch (color) // switch 判断是引用（或变量），switch (Season s) 是错误写法&#123; // case break 判断代码&#125; 枚举常用方法 ordinal 返回枚举值在枚举类种的顺序。这个顺序根据枚举值声明的顺序而定。 12Color.RED.ordinal(); //返回结果：0Color.BLUE.ordinal(); //返回结果：1 compareTo Enum中的compareTo返回的是两个枚举值的顺序之差。当然，前提是两个枚举值必须属于同一个枚举类，否则会抛出ClassCastException()异常。 1Color.RED.compareTo(Color.BLUE); //返回结果 -1 [静态]values 静态方法，返回一个包含全部枚举值的数组。 12345Color[] colors=Color.values();for(Color c:colors)&#123; System.out.print(c+&quot;,&quot;); &#125; //返回结果：RED,BLUE,BLACK YELLOW,GREEN, toString 返回枚举常量的名称。 12Color c=Color.RED;System.out.println(c);//返回结果: RED valueOf 这个方法和toString方法是相对应的，返回带指定名称的指定枚举类型的枚举常量。 1Color.valueOf(&quot;BLUE&quot;); //返回结果: Color.BLUE equals 比较两个枚举类对象的引用。 12345//JDK源代码： public final boolean equals(Object other)&#123; return this==other; &#125; 第四章：接口与继承 4.1 接口 JAVA中使用接口，需要创建一个 new --&gt; class —&gt; 下拉选择 Interface —&gt; IAD.java 下面实现一个 AD英雄 implements AD接口。 在 IAD.java 中： 1234public interface IAD&#123; void ADAttack(); // 接口不能有体:&#123;&#125;&#125; 在 ADHero.java 中 12345678public class ADHero extends Hero implements IAD&#123; @Override // 加上这句IDE自动显示可以继承的方法；但没有这句也可自己写方法覆写。 public void ADAttack() &#123; System.out.println(&quot;输出了物理伤害！&quot;); &#125;&#125; 4.2 对象转换 基本概念 引用类型 &amp; 对象类型 通常，引用类型 和 对象类型 是一致的，如： 1ADHero ad = new ADHero(); 引用ad 指向了new出的新对象，它们类型都是 ADHero。 如果 引用类型 ≠ 对象类型：则是下述的类型转换问题。 向上转型 / 向下转型 “向上”、“向下”：是一种继承的概念，父类在子类上 ；类在继承的接口上。 向上转型：则指 子类转父类 ；类转为继承的接口。（可行） 向上转型 苹果手机 继承 手机，把苹果手机当做普通手机使用； 怡宝纯净水 继承 饮品， 把怡宝纯净水当做饮品来使用。 总结：特殊可转一般，子转父、子转接口。 子类转父类 下面 把物理英雄转普通英雄，显然是可行的： 123Hero h; // 不new！ADHero ad = new ADHero();h = ad; // 【注意】：h指向的是ADHero对象，但只能使用 Hero 类方法属性！ 子类转父接口 12ADHero ad = new ADHero();AD adi = ad; 向下转型（强制） 父类转子类，有的时候行，有的时候不行，所以必须进行强制转换。 父类转子类 下面，这种情况向下转型可行：因为第三行子类转父类，h指向ADHero对象（但只能使用 Hero 类方法属性）。 1234Hero h = new Hero();ADHero ad = new ADHero();h = ad; // 父类（基类）引用h 指向--&gt; ADHero对象ad = (ADHero) h; 所以上面代码表现的好像是，父类转子类成功，其实是 ADHero转换为ADHero。 父接口转子类 1234ADHero ad = new ADHero();AD Iad = ad; // 引用Iad指向 ADHero对象ADHero adHero = (ADHero) Iad; // ADHero 转 ADHero ，可行ADAPHero adapHero = (ADAPHero) Iad; // 不可行，ADHero 不能转 ADAPHero 没有继承关系转换 一定失败，不多言。 instanceof 123456ADHero ad = new ADHero();Hero h1 = ad;//判断引用h1指向的对象，是否是ADHero类型System.out.println(h1 instanceof ADHero); // 输出：true//判断引用h1指向的对象，是否是Hero的子类型System.out.println(h1 instanceof Hero); // 输出：true 4.3 重写 &amp; 隐藏 &amp; 重载 重写 重写：是不改变父类的方法名字和参数个数和类型，简单点说就是实现跟父类不一样的功能。 关键字：继承、不同类，和父类方法只有方法体不一样。 隐藏 隐藏：是有一个跟父类一样的静态方法，调用的时候就直接用子类的静态方法了。 关键字：继承、不同类，和父类方法只有方法体不一样、静态。 重载 重载：是方法重载,方法签名完全一致,参数类型和个数不同,JVM就可以识别并调用重载方法。 关键字：同类、和同类同名方法参数类型、个数、方法体都不同。 4.4 多态 多态一般分为：操作符多态；类多态，由类型向上转换 + 重写/重载 实现； 操作符多态 概念 如：+ 既可以表示 数字相加 也可表示 字符串连接 等，由运算符重载实现。 12int a = 3 + 5;int str = &quot;hello&quot; + &quot;world&quot;; 运算符重载 类多态 类多态一般需满足两个条件： 父类（接口）指向 子类对象 因为所谓类多态，就是可以用 基/父类 指向子类 调用方法有重写 同前，父类虽然在1. 指向子类对象，但只可以使用父类方法、属性；如果想调用子类方法，那么在父类和子类都声明同名方法，这样父类.方法()—&gt; 执行 —&gt; 子类.方法()。 类多态作业1：重写 实现多态 分别有以下两个类： MagicPortion类，*effec()*使用后回蓝； LifePortion 类，*effec()*使用后回血； Hero类对象 VN，VN调用本身方法 userItem(参数) 即可实现回血、回蓝等物品使用。 实现父类接口 Item 要实现多态，我们在外面使用一个父类引用指向不同子类对象，再用其调用子类方法。 这样，不必为不同子类对象生成不同对应引用，比如可使得函数参数统一等（见后）。 1234public interface Item&#123; void effect();&#125; 实现 MagicPortion、LifePortion 类 MagicPortion类，*effec()*使用后回蓝： 1234567public class MagicPortion implements Item&#123; public void effect() &#123; System.out.println(&quot;使用蓝瓶回蓝100！&quot;); &#125;&#125; LifePortion 类，*effec()*使用后回血： 1234567public class LifePortion implements Item&#123; public void effect() &#123; System.out.println(&quot;使用血瓶回血100！&quot;); &#125;&#125; Hero类表现多态 要表现多态，让父类指向子类对象，同时可以执行子类同名（重写）方法 1234567public class Hero&#123; void useItem(Item i) //父类接口Item做参数，可以接收不同子类对象 &#123; i.effect(); &#125;&#125; 这样，统一了函数参数，一个方法（不必重载）就可以实现各种物品使用。 123456// 在主函数main()中Hero VN = new Hero();Item i1 = new MagicPortion();Item i2 = new LifePortion();VN.useItem(i1); // 输出：使用蓝瓶回蓝100！VN.useItem(i2); // 输出：使用血瓶回血100！ 类多态作业2：隐藏static无法体现多态 如果将 Item 类改为以下： 1234567public class Item // 1.接口--&gt;类，隐藏只支持类&#123; static void effect() // 2.+static，关键字 &#123; System.out.println(&quot;物品产生一些效果&quot;); // 3.添加方法体 &#125;&#125; 然后在 MagicPortion &amp; LifePortion 类 effect() 也加上static关键字实现同名隐藏： 1public static void effect() 这个时候主函数输出： 1234// 在主函数main()中Hero VN = new Hero();Item i1 = new MagicPortion();VN.useItem(i1); // 输出：物品产生一些效果 原因如下： 隐藏 对方法都加上了static关键字，无法在 Item i1 = new MagicPortion(); ，实现引用 i1动态绑定 静态方法，也就无法实现多态！ 4.5 super &amp; final 利用super调用父类属性、方法 1234567public class ADHero extends Hero implements AD&#123; //在某个方法中 super.moveSpeed; // 1.调用父类属性 super.useItem(i); // 2.调用父类方法userItem super(); // 3.调用父类无参构造函数 &#125; final 修饰 修饰类：类无法被继承 如，可用自定义类 someString 继承系统类 String ，结果如何？ 不能继承，因为 系统类 String ，是被 final 关键字修饰的。 修饰方法：方法不能被重写 修饰变量：只能被赋值1次 如，可利用这点，设置一个常量。 1public static final int pi = 3.14; 修饰引用：只有1次指向引用的机会 4.6 抽象类 基本概念 类带有 abstract 关键字修饰就是抽象类； 含有抽象方法必须是抽象类； 123456public abstract class Hero&#123; // 抽象方法attack：[1] abstract修饰 [2] 无方法体 // Hero的子类会被要求实现attack方法 public abstract void attack();&#125; 抽象类不能被实例化，专门用来继承的。 抽象类 和 接口区别 默认方法实现 抽象类可以有非抽象方法，有方法体 ； 接口不能有。 抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。 再精辟点总结： 抽象类，既 1.非抽象类实现代码复用 2.又同时有抽象方法使得被继承类各自实现。 接口，是对类的行为进行约束，强制要求不同类实现相同行为。 构造函数 抽象类有；接口没有。 修饰符 抽象类除private 都有（抽象类目的是被继承，抽象方法是为被重写）；接口only public。 继承个数 [接口优] 抽象类只能被继承一次；接口可以有多个。 4.7 内部类 暂时不知道什么时候用得到，先不展开：讲解内部类链接 非静态内部类 静态内部类 匿名类 本地类 4.8 默认方法 默认方法是指 ：接口的抽象方法，加上 default 关键字，可以有方法体。 1234567public interface Mortal &#123; public void die(); default public void revive() &#123; System.out.println(&quot;本英雄复活了&quot;); &#125;&#125; 这样做的好处： 假设没有默认方法这种机制，那么如果要为Mortal增加一个新的方法revive,那么所有实现了Mortal接口的类，都需要做改动实现 revive。 但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法 4.9 UML图 类图解释 接口图解释 继承关系解释 实线：表示继承类，如下图 Spider 类继承 Animal 类； 虚线：表示继承接口，如下图 Cat类 继承 Pet 接口。 第五章：数字 和 字符串 5.1 拆箱、装箱 关于拆箱、装箱基本概念 所有的基本类型，都有对应的类类型 ，又称为封装类，也是数值与包类型转换。 下面是所有数值 基本类型，对应的类型型，它们又都是抽象类 Number 的子类。 如：基本类型 int --&gt; 对应封装类 Integer ； short --&gt; 对应封装类 Short … 装箱 装箱，即将 基本类型自动 转换成封装类型，自动又是通过**=** 号实现。 先看一个非装箱，自己调用构造方法实现 基本类型–&gt; 封装类型： 123// 非装箱转换成封装类 int i = 1; Integer it = new Integer(i); 如果 用 = 号 实现自动上述过程，则称为装箱： 123// = 自动装箱 int i = 1; Integer it = i; // = 自动实现类型转换，无需new 拆箱 和装箱类似，即将 封装类型自动 转换成 基本类型，自动又是通过**=** 号实现。 非拆箱，自己调用构造函数实现： 123// 非拆箱实现转换成基本类型 Integer it = new Integer(0); int i = it.intValue(); 拆箱实现： 123// = 自动拆箱 Integer it = new Integer(0); int i = it; // = 自动实现类型转换 拆箱、装箱之惑 存在的意义？ 为什么要有装箱、拆箱，它们的作用是什么？ java 是 面对对象编程，而基本数据类型不是对象，所有才有封装类 引用基本数据类型。 比如，下面打印出int型数据： 12int i = 0；System.out.println(i); 其实，查看源码，实际经过以下几个过程： 将 i 自动装箱成封装类 Integer 然后调用 Integer中 toString() 方法，打印出字符串输出到控制台。 5.2 类型转换 数值类型之间 位数低—&gt;高 低—&gt;高：byte,char(1) --&gt; short(2)–&gt; int(4) --&gt; long(8) --&gt; float(8) --&gt; double(16) 强制转换 如果是低位向高位转换，则自动转换；反之，则需要 () 强制转换。 123byte b = 1;short s = b; // 可，自动转换。b = (byte)s; // 强制 表达式类型提升 如果，数值类型参与运算，操作符两端类型要一致，有以下几个原则： byte、short和char 自动提升int型； 操作数含long型，则整个表达式类型提升为long型； 操作数含 float / double 型，则整个表达式提升为 float /double型表示； long、float、double，同时出现，提升优先：double &gt; float &gt; long 。 数值类型 &amp; char 基本规则和数值类型直接按位数，是否强制转换很相似，但有一点不同： char &amp; byte &amp; short 之间, 除了 byte 转换成 short 都是强制转换； 12345byte b = 0; char c = 1; short s = 2;s = (short) c; // 虽然short位数4，但是还是要强制转换c = (char) b;b = (byte) c; 数值类型 &amp; String 数值类型 &lt;— String String 转为 数值类型，一般有如下三种方法： 123456789101112 String str = &quot;12345&quot;;// 方法1：数值类型对应封装类.parse方法 int a1 = Integer.parseInt(str);// 方法2：手动装箱 --&gt; 手动拆箱// 等价自动拆箱：int a2 = Integer.valueOf(str); Integer it2 = Integer.valueOf(str); int a2 = it2.intValue(); // 可以更简单=自动拆箱：int a2 = it2;// 方法3：手动装箱 --&gt; = 自动拆箱 int a3 = new Integer(str); String &lt;— 数值类型 1234567 int i = 12345;// 方法1：数值类型对应封装类.toString方法 String str1 = Integer.toString(i);// 方法2：先装箱再拆箱：手动装箱--&gt; = 自动拆箱 String str2 = String.valueOf(i); int[] &amp; String int[] 转换 string 12345import java.util.*；// 1.调用Arrays类方法int[] arr = new&#123;1,2,3&#125;;string s = Arrays.toString(arr) String &amp; char &amp; char[] String转换为char 1234// String 和 char 之间转换String str = &quot;123&quot;; char c = str.charAt(0); // 转换成字符char[] c1 = str.toCharArray(); // 转换成字符数组 char 转换成 String 1234567char c1 = &#x27;1&#x27;; String str1 ;// 方法1：利用每种基本类型对应封装类都有的.toString方法str1 = Character.toString(c1);// 方法2：valueOf装箱 --&gt; =自动拆箱str1 = String.valueOf(c1); char[] 转换为string 1234567// 1.直接在构造String时建立。 char data[] = &#123;&#x27;s&#x27;, &#x27;g&#x27;, &#x27;k&#x27;&#125;; String str = new String(data);// 2.String有方法可以直接转换。 char[] cha = &#123;&#x27;s&#x27;,&#x27;g&#x27;,&#x27;h&#x27;&#125;; String n = String.valueOf(cha); String &amp; byte[] String转换为byte[] 和转换成 char 类似，可以调用对象本身的方法。 12String str = &quot;123&quot;; byte[] bytes = str.getBytes(); byte[] 转换成 String 也同 char 转 String 类似，利用装箱拆箱。 12byte[] bs = new byte[]&#123;1,2,3&#125;;String s = new String(bytes); 引用类型之间 123456public class Person &#123;&#125;public class Student extends Person &#123;&#125;// 主函数中Person p = new Person();Student s = new Student(); 向上转换，父类引用 &lt;— 子类引用，可转。 1p = s； // 子转父 其实，本质 p指向了 Student对象，虽然只能使用Person方法，等价这种写法： 1p = new Student(); // Student对象无名引用，转换成父类 Person 向下转换，子类引用 &lt;— 父类引用，抛出异常。 1s = (Student)p; // 抛出异常 如果无继承关系引用转换，编译错误！ 5.3 数学方法 123456789101112// 1.四舍五入Math.round(5.5); // 6// 2.随机数Math.random(); // [0-1) 之间随机数Math.random()*10; // [0-10) 之间随机数// 3.开方Math.sqrt(9)// 4.次方Math.pow(2,4)// 5.常数Math.PI // πMath.E // 自然常数 5.4 Sting 常用方法 单字符串操作 1String str = &quot;hello java!&quot;; 常用方法见下： 12345678910111213141516171819// 1.返回字符str.charAT(0); // 返回str第一个字符// 2.返回字符数组str.toCharArray(); // 3.截取字符串str.substring(3); // 从第3个字符开始截取str.substring(3,5); // [3,5):截取第3--&gt;第5字符，不含第5// 4.分隔字符串str.split(&quot;,&quot;); // 5.去除首尾空格str.trim(); // 6.大小写str.toLowerCase()str.toUpperCase()// 7.定位str.indexOf(&#x27;l&#x27;); // 返回l第一次出现位置：2str.lastIndexOf(&#x27;l&#x27;); // 返回l最后一次出现位置：3// 8.包含str.contains(&quot;java&quot;); // 返回：ture 多字符串操作 比较 12String str1 = &quot;the light&quot;;String str2 = new String(str1); 常用操作方法： 12345// 1.是否同一对象 System.out.println( str1 == str2); //虽然，内容相同但不是同一对象// 2.是否内容相同 System.out.println(str1.equals(str2)); //返回 ：ture System.out.println(str1.equalsIgnoreCase(str3)); // 忽略大小写，比较 以特定字符结束/开始 12String str1 = &quot;the light&quot;;String str2 = &quot;ht&quot;; 使用举例： 1234// 1.判断以特定字符开始System.out.println(str1.startsWith(str2)); // 返回false// 2.判断以特定字符结束System.out.println(str1.endsWith(str2)); // 返回ture 5.5 StringBuffer类 比String基本类型，能更好操作字符串：追加、删除、插入、反转等，而且性能佳！ 为什么StringBuffer可以变长？ 和String 和 StringBuffer 内部都维护了一个字符数组，但是StringBuffer 还有冗余长度。 声明 1StringBuffer sb = new StringBuffer(&quot;hello java!&quot;); 常用操作 123456789101112// 1.追加sb.append(&quot;啊，我死了！&quot;);System.out.println(sb); // hello java!啊，我死了！// 2.删除sb.delete(5,10);System.out.println(sb); // hello!啊，我死了！// 3.插入sb.insert(5, &quot;!&quot;);System.out.println(sb); // hello!!啊，我死了！// 4.反转sb.reverse(); //反转System.out.println(sb); // ！了死我，啊!!olleh 常用属性 12sb.length(); //内容长度：13sb.capacity(); //总容量：27（有冗余） 第六章：日期 6.1 Date类 什么是时间原点？ 时间原点是：1970/1/1 8:0:0 。所有的日期，以此为基准，每过一毫秒，就+1。 如何引进日期类库？ 1import java.util.Date; 创建 1234567// 1.不带参数，当前时间Date d = new Date();System.out.println(d); // 输出：Sat Jun 29 22:11:23 CST 2019// 2.带参数(整数)，时间：原点+整数/1000(秒)Date d1 = new Date(1000);System.out.println(d1); // 输出：Thu Jan 01 08:00:01 CST 1970 常用方法 12// 1.getTime:获取 当前时间 - 原点 毫秒数System.out.println(d.getTime()); 6.2 SimpelDateFormat 类 SimpelDateFormat 类 用来格式化日期输出。 如何引用？ 1import java.text.SimpleDateFormat; 格式Date对象 ⚠️注意，下面格式模式 MM 、HH 必须大写，否则出错！ 1234567Date d = new Date();// 1.创建SimpleDateFormat对象，并指定格式模式SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;);// 2.利用format方法，格式Date对象，并返回String类型String str = sdf.format(d); // 返回String类型// 3.输出测试System.out.println(str); // 输出：2019/06/29 22:53:00 格式String对象 ⚠️注意，parse方法，必须在一对 try catch 块中，否则编译错误。 123456789101112131415String str = &quot;2019/01/01 00:00:00&quot;;Date d = new Date();// 1.创建SimpleDateFormat对象，并指定格式模式SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;);// 2.parse方法，格式String对象，并返回Date类型try &#123; d = sdf.parse(str);&#125;catch (ParseException e)&#123; e.printStackTrace();&#125;// 3.输出测试System.out.println(d); // 输出测试：Tue Jan 01 00:00:00 CST 2019 6.3 Calendar类 Calendar 类 和 Date类相比，更容易进行“翻日历“，进行月份/天等修改。 如何引用？ 1import java.util.Calendar; 创建对象 ⚠️ 只能利用Calendar.getInstance() 获取单例，new需要重写函数。 1Calendar c = Calendar.getInstance(); 常用方法 123456789101112131415161718192021// 1.getTime(),返回Date类型对象Calendar c = Calendar.getInstance();Date d = c.getTime()；System.out.println(c.getTime()); // 输出：Sat Jun 29 23:08:53 CST 2019// 2.setTime(Date d),设置时间，无返回Date d1 = new Date(0);c.setTime(d1);System.out.println(c.getTime()); // 输出：Thu Jan 01 08:00:00 CST 1970// 3.add，在原日期(2019/6/29)上增加 年/月/日c.add(c.YEAR, 3); // 3年后c.add(c.MONTH, -1); // 前1个月c.add(c.DATE, 1); // 后1天System.out.println(c.getTime()); // 输出：Sun May 30 23:29:06 CST 2022// 4.set，可分别设置年月日，区分setTimec.add(c.YEAR, 2019); c.add(c.MONTH, 9); c.add(c.DATE, 1); System.out.println(c.getTime()); // 输出：Tue Oct 01 23:34:55 CST 2019 第七章：异常 7.1 异常分类 异常分为，Error &amp; Exception，它们都是 Throwable 子类； Exception，又分为运行时异常、可查异常。 7.2 异常处理 try cacth 尝试打开 LOL，抛出异常： 1234567891011121314151617import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;// 主函数中：File f= new File(&quot;d:/LOL.exe&quot;);try&#123; System.out.println(&quot;试图打开 d:/LOL.exe&quot;); new FileInputStream(f); // (1) 执行到这出现异常 ---&gt; 执行catch块 System.out.println(&quot;成功打开&quot;); &#125; catch(FileNotFoundException e) // (2) 出现异常开始处理 &#123; System.out.println(&quot;d:/LOL.exe不存在&quot;); System.out.println(e.toString()); &#125; 改进：如果不知道抛出异常类型？ 可以用父类 Exception，甚至Throwable 进行catch 处理。 123456// 利用父类进行catch(只修改catch块)catch(Exception e)&#123; System.out.println(&quot;d:/LOL.exe不存在&quot;); System.out.println(e.toString());&#125; 改进：如果有多个错误？ 可用多个 catch 块进行处理。 123try&#123; // 程序代码 &#125;catch(异常类型1 异常的变量名1) &#123; // 处理程序 &#125;catch(异常类型2 异常的变量名2) &#123; // 处理程序 &#125; try cacth finally 有时候希望，无论是否出现异常，都希望有段代码被执行，也就是finally块。 但是有下面几个结合return 情况，值得深思：java异常捕获 throw try cacth 理解不深，待实际操作补充。同时可见下：[自定义异常] 7.3 自定义异常 对 throws 作用理解不深，待补充。 自定义异常类 1234567class myException extends Exception // 继承Exception类&#123; public myException() &#123; System.out.println(&quot;flag = 0，发生异常！&quot;); &#125;&#125; 捕获异常 在 try中抛出异常，然后catch接住异常进行出现(不处理会编译错误)。 123456789101112// 主函数中int flag = 0; try &#123; if (flag == 0) throw new myException(&quot;flag == 0 &quot;); &#125; catch (myException e) &#123; // 处理异常代码 System.out.println(&quot;catch中捕获到异常！&quot; ); &#125; 第八章 ： IO流 8.1 文件对象 创建对象 1234import java.io.File;// 以当前项目路径(相对路径)创建对象 File f = new File(&quot;test.txt&quot;); 对象常用方法 1234567891011121314151617181920212223242526272829303132// 1.重命名文件 -- 不会改变f的name属性File f1 = new File(&quot;hwh.txt&quot;);f.renameTo(f1); // f.getName() 还是test.txt// 2.创建文件 -- 存在不会重新创建File f2 = new File(&quot;lt.txt&quot;);try&#123; f2.createNewFile(); // 创建了lt.txt文件 &#125;catch (IOException e) // 必须处理异常&#123; System.out.println(e.toString());&#125;// 3.创建文件夹:不会覆盖File f3 = new File(&quot;son&quot;);f3.mkdir(); // 创建了 son 文件夹 // 4.返回目录下文件 &amp; 文件夹// 以String数组返回String[] str = f3.list();System.out.println(str[0]); // 输出目录下第一个文件名字// 以File数组返回File[] fs = f.listFiles();// 5.其它方法f.exists(); // 判断文件是否存在f.isDirectory(); // 判断是文件夹f.isFile(); // 判断是文件f.length(); // 文件长度f.delete(); // 删除文件 8.2 文件流 当需要对文件进行 读取/写入 时，要建立文件 输出/输入 流。 ⚠️ 字符流可以一个字符一个字符也可以一行一行读取 ；字节流不可以。 字节流 字符流 按行读取 × 一次读取 √ 读取中文 √ 更方便 √ 字节流读写 以 字节（ASCII） 形式读取和写入数据：InputStream字节输入流 ；OutputStream字节输出流 。 都是 抽象 类，不提供具体实现，可用子类 FileInputStream &amp; FileOutStream 对文件进行读写。 [读]文件输入流：不用 try catch 捕获异常会报错 1234567891011121314151617181920212223242526import java.io.File;import java.io.FileInputStream;try&#123; // 1.创建文件对象 File f = new File(&quot;lt.txt&quot;); // lt.txt 内容：lt // 2.创建输入流对象 FileInputStream fis = new FileInputStream(f); // 3.文件读出数据 byte[] all =new byte[(int) f.length()]; fis.read(all); // 打印读取到byte数组文件内容 // 直接打印打印出的 ASCII码，强制转换成char字符 for (byte b : all) System.out.print((char)b); // 输出： lt // 4.流关闭 fis.close(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; [写]文件输出流：最后查看 hwh.txt 内容被写入 hwh 12345678910111213141516171819202122import java.io.File;import java.io.FileOutputStream;try&#123; // 1.创建文件对象 File f = new File(&quot;hwh.txt&quot;); // hwh.txt 内容为空 // 2.创建输入流对象 FileOutputStream fos = new FileOutputStream(f); // 3.数据写入文件 byte[] all = new byte[]&#123;104,119,104&#125;; // ASCII 104——&gt;h ; ASCII 119——&gt;w fos.write(all); // 4.流关闭 fos.close(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; 字符流读写 以 字符 对文件进行读写，Reader 字符输入流；Writer 字符输出流 ，同前都为 抽象类 。 用子类，FileReader &amp; FileWriter、对文件进行字符读写。 [读] FileReader : 注意是用字符数组 char[] 进行读写，而不是 String 12345678910111213141516171819202122232425import java.io.FileReader;try&#123; // 1.创建文件对象 File f = new File(&quot;lt.txt&quot;); // 2.创建字符流对象 FileReader fr = new FileReader(f); // 3.读取流对象内容 // String str = null; // 错误，应该是char[]数组 char cArr[] = new char[(int)f.length()]; fr.read(cArr); // 打印读取到char数组文件内容 for (char c : cArr) System.out.print(c); // 输出： lt // 4.流关闭 fr.close();&#125;catch (Exception e)&#123; System.out.println(e);&#125; [写] FileWriter ：同上注意char[]数组。最好 hwh.txt 文件内容为： hwh is a pig 12345678910111213141516171819202122import java.io.FileWriter;try&#123; // 1.创建文件对象 File f = new File(&quot;hwh.txt&quot;); // 2.创建输入流对象 FileWriter fw = new FileWriter(f); // 3.读取流对象内容 String str = &quot;hwh is a pig&quot;; char cArr[] = str.toCharArray() ; fw.write(cArr); // 4.流关闭 fw.close();&#125;catch (Exception e)&#123; System.out.println(e);&#125; 缓存流读写 缓冲流是字符流的子类 ，用于解决：字符流 &amp; 字节流 每读写1字节要IO操作。 [读]BufferedReader 12345678910111213141516171819202122232425262728293031323334import java.io.BufferedReader;try&#123; // 1.创建文件对象 // hwh.txt内容(空格表示换行)：黄 旺辉 不喜欢西瓜 File f = new File(&quot;hwh.txt&quot;); // 2.创建字符流对象 FileReader fr = new FileReader(f); // 3.创建缓存流：必须建立在一个存在流之上 BufferedReader br = new BufferedReader(fr); // 4.读取流对象内容:一次一行 // 输出：黄 旺辉 不喜欢西瓜 while(true) &#123; //一次读取一行，返回Sting类型 // 比前面；设置好char[] 、byte[] ,然后f.read()有所不同 // 比后面：不用考虑中文 char[] 、byte[] 转换成Sting类型 String line = br.readLine(); if(line == null) break; System.out.println(line); &#125; // 5.流关闭 br.close();&#125;catch (Exception e)&#123; System.out.println(e);&#125; [写] PrintWriter ，基本同上差不多步骤，简略说明下 12345import java.io.PrintWriter;// ...基本同上// 写操作，pw是PrintWriter对象，调用println方法读写即可。pw.println(&quot;刘婷是傻子&quot;); 数据流&amp;对象流 数据流 &amp; 对象流 都是字节流子类，建立数据流 &amp; 字符流必须要在一个存在的字节流之上。 数据流：主要可以进行格式化 顺序 读写，有 FileInputStream 、FileOutputStream 1234567891011121314151617181920212223242526272829303132333435import java.io.DataInputStream;import java.io.DataOutputStream;try&#123; // 1.创建文件对象 File f = new File(&quot;hwh.txt&quot;); // 2.创建字节流对象 FileOutputStream fos = new FileOutputStream(f); FileInputStream fis = new FileInputStream(f); // 3.创建数据流：必须建立在一个[字节流]之上 DataOutputStream dos = new DataOutputStream(fos); DataInputStream dis = new DataInputStream(fis); // 4.数据流顺序写 dos.writeBoolean(true); dos.writeInt(1); dos.writeUTF(&quot;yes&quot;); // 5.数据流顺序读 boolean b = dis.readBoolean(); int i = dis.readInt(); String s = dis.readUTF(); // 输出：顺序读到：bool:true ; int：1；String：yes System.out.format(&quot;顺序读到：bool:%b ; int：%d；String：%s &quot;,b,i,s); // 6.流关闭 dos.close(); dis.close();&#125;catch (Exception e)&#123; System.out.println(e);&#125; 对象流：指的是可以直接把一个对象以流的形式传输给其他的介质，比如硬盘 。暂时不详写用 到再说吧：对象流 1234import java.io.ObjectInputStream;import java.io.ObjectOutputStream;// 主函数中 8.3 中文读写问题 常用编码格式 IS0-8859-1、ASCII ：数字 &amp; 西欧字母 ，IS0-8859-1包含 ASCII，1字节。 GBK、GB2312、BIG5：中文简繁；中文 ；繁体中文，2字节 。 Unicode ：统一码，万国码，字母、数字、中文都为4 字节编码。 UTF-8：对 Uincode 进行的一种减肥子编码 ，字母、数字：1字节 ；中文：3 字节。 特别的 ANSI ：表示本地编码，中文OS则选用 GBK、英文 IS0。 中文编码读写 写 在记事本等中直接写中文：采用本地编码 ANSI保存。 在 java中写中文：执行后都会变为 Unicode（UTF-8?），然后字符流、字节流读写？ 读 读：字节流 &amp; 字符流读文本中中文，字符流比较麻烦略。 将字节流数组转换成 Sting 和对应字符编码。 1234567891011121314151617181920212223242526272829303132333435363738394041try&#123; // 1.创建文件对象 File f = new File(&quot;hwh.txt&quot;); // hwh.txt内容：黄 // 2.创建输入流对象 FileInputStream fis = new FileInputStream(f); // 3.读取流对象内容 byte[] all = new byte[(int)f.length()]; fis.read(all); // [测试] 直接输出 byte数组 for(byte b : all) &#123; /* byte 1字节，直接打印对应二进制整数：-23 -69 -124(uft-8编码中文3字节) 为了打印出16进制，先转换成int --&gt; 再调用toHexString方法 */ System.out.println(b); int i = b; /* 类型转换，输出：ffffffe9、ffffffbb、ffffff84 对应-23 -69 -124 补码：e9、bb、84(int4字节，byte1字节，补码前3字节添1不看) */ System.out.println(Integer.toHexString(i)); &#125; // 4.类型转换：把字节数组转换成 Sting UTF-8编码 // 类型转换第一种：new String装箱，= 自动拆箱 // 第二种转换：调用对象类型都有的.toString方法：all.toString() String str = new String(all,&quot;UTF-8&quot;); System.out.println(str); // 输出：黄 // 5.流关闭 fis.close();&#125;catch (Exception e)&#123; System.out.println(e);&#125; 第九章：集合框架 常用集合框架有： ArrayList、LinkedList、HashMap、HashSet 等。 Tips： System.out.println(集合类型对象)：可以直接装箱成String类型，然后拆箱输出，如[1,2,3]。 9.1 ArrayList ArrayList 是实现了 List 接口子类。相比常规数组，容量会自动增长，是一个动态数组（非链表）。 声明 123import java.util.ArrayList;ArrayList array = new ArrayList(); 常用方法 12345678910111213141516171819202122232425262728293031323334// 1. add -- 未泛型指定可添加不同类型对象Hero VN = new Hero();array.add(VN); // Hero类型对象array.add(&quot;pentaKill&quot;); // Sting类型对象// 2.contains：判断对象是否存在System.out.println(&quot;VN对象是否存在：&quot; + array.contains(VN));// 3.get ：获取指定位置对象 -- 从0计数System.out.println(&quot;第1个位置对象：&quot; + array.get(0));// 4.indexof：判断对象所处位置System.out.println(&quot;VN所处位置：&quot; + array.indexOf(VN));// 5.remove：可根据位置或者对象名删除array.remove(VN);array.remove(1);// 6.set: 只能替换指定位置对象,不能设置新元素System.out.println(&quot;替换第1个位置对象：&quot; + array.set(1, 5));// 7.size：获取数组已存元素个数（大小）System.out.println(&quot;替换第1个位置对象：&quot; + array.size());// 8.addAll:添加另外一个容器所有对象ArrayList array1 = new ArrayList();array.addAll(array1);// 9.toArray :ArrayList对象转换为数组// 加了toSting无变化，因为返回Objiect数组System.out.println(&quot;转换为数组：&quot; + array.toArray().toString()); // 10.clear：清空 9.2 LinkedList LinkedList &amp; ArrayList 都实现了 List接口，都有 add 、remove 、contains 等方法。 但同时，LinkedList 还实现了 Queue（队列） 、Deque（双向队列）接口。 声明 1234567// LinkList// 普通声明LinkedList l = new LinkedList();// 多态：声明双端队列Deque d = new LinkedList();// 多态：声明队列Queue q = new LinkedList(); 常用方法 Deque 暂未补充。 12345678910111213/* 1. LinkList 在头部、尾部进行操作 */// [查看]链表头尾元素l.getFirst(); l.getLast();// [删除]链表头尾元素l.removeFirst(); l.removeLast();/* 2. Queue 在头部、尾部进行操作 */// [添加]队列尾元素 -- q.add?用List接口方法一样吗？q.offer(1); q.offer(2);// [查看]链表头尾元素q.peek();// [取出]链表头尾元素，取出后会被删除q.poll(); 9.3 HashMap HashMap 可理解为一个字典，键值不能重复，不同键元素可重复（相同）。 声明 123import java.util.HashMap;HashMap dic = new HashMap(); // 也可泛型指定 Key ：Value 类型 常用方法 未详细列出，详细需查看：HashMap官方文档。 12345// 常用方法// 1.put -- 插入数据dic.put(1, &quot;啊我是1&quot;); dic.put(2, &quot;啊我竟然是2&quot;); dic.put(3, &quot;啊哈哈哈我是3&quot;);// 2.get -- 获取数据System.out.println(dic.get(2)); // 输出：啊我竟然是2 9.4 HashSet HashSet 没有键值，只保存元素。且不提供 get(index) 方法读取指定位置元素，遍历可利用迭代器。 类似的还有：LinkedHashSet &amp; TreeSet ，暂略。 声明 123import java.util.HashSet; HashSet hs = new HashSet(); 常用方法 123456789101112// 常用方法// 1.add -- 插入数据hs.add(1); hs.add(true); hs.add(&quot;一&quot;);// 2.可直接打印所有数据，不是按添加顺序System.out.println(hs); // 输出：[一, 1, true]// 3.[迭代遍历] 由于未提供get方法，不能普通for循环，但可以迭代器遍历for(Iterator it = hs.iterator();it.hasNext();)&#123; System.out.println(it.next()); // 输出：一 1 true&#125; 9.5 Collections类 Collections 类是专门用于处理集合类型的工具类，包含一系列诸如：排序、反转、混淆、交换 等方法。 类似于：Arrays 是数组的工具类。但是，只能处理实现了 List 接口类。Collections 类官方文档 基本使用 1234567891011121314import java.util.Collections;LinkedList&lt;Integer&gt; ll = new LinkedList&lt;Integer&gt;(); // [注]：不是int类型ll.add(1) ; ll.add(2) ; ll.add(3) ; ll.add(4) ; ll.add(5) ;// 常用方法：更多查看官方文档// 1.混淆Collections.shuffle(ll); // 2.排序Collections.sort(ll); System.out.println(ll); // 输出：[1, 2, 3, 4, 5]// 3.反转Collections.reverse(ll);// 4.交换Collections.swap(ll,0,4); 比较器：Comparable Comparable 是一个接口，通过覆写实现它的 compare 方法，来比较非数值类型的 sort 排序等。 如下，实现了通过比较 Hero类 HP属性来实现排序。 在Hero类中 也可在 Hero类中在覆写 compareTo方法，这样自带比较信息，而不用在主函数覆写Comparator 接口的 compare方法。 ⚠️ 在 Hero类中覆写了 toSting方法，这样打印Hero对象不显示：Hero@十六进制地址形式。 1234567891011121314151617181920public class Hero&#123; // 属性 String name; int HP; // 方法：构造函数 Hero(String name ,int hp) &#123; this.name = name; this.HP = hp; &#125; // 方法：类中覆写函数toString @Override public String toString() &#123; return &quot;英雄名：&quot; + name + &quot; 血量：&quot; + HP; &#125;&#125; 在主函数中 Q : System.out.println(ll); 如何实现打印出集合？ A: 首先，打印 ll 会将集合每个Hero对象装箱成Sting，然后调用 .toString()方法进行拆箱； ​ 由于Hero类中覆写了 .toString()方法，此时返回的不是默认Hero@十六进制地址形式 。 ​ 最后结合所有对象.toString() ,转换成String类型[…,…,…,…]打印出来。 123456789101112131415161718192021222324252627282930import java.util.Comparator;// 1.准备好一个集合类型 LinkList，插入十个Hero类型对象并设置不同随机hpLinkedList&lt;Hero&gt; heros = new LinkedList&lt;&gt;();for(int i = 0 ; i &lt; 10 ; i++)&#123; String name = &quot;hero&quot;+i; int hp = (int)(Math.random()* 1000); heros.add(new Hero(name,hp)); // 带int参数构造函数&#125;System.out.println(heros);// 2.[匿名类]覆写比较器compare方法（比较规则）Comparator&lt;Hero&gt; comparable = new Comparator&lt;Hero&gt;() &#123;@Overridepublic int compare(Hero h1,Hero h2)&#123; if(h1.HP &gt; h2.HP) return 1; else return -1; // 注意，别写0 &#125;&#125;;// 3.工具栏Collections进行排序Collections.sort(heros,comparable);// 4.直接打印输出查看System.out.println(heros); 9.x 迭代器初使用 根据学习C++经验，迭代器要和这些集合类型如 ArrayList 结合才能用。 声明一个集合 123456import java.util.Iterator;import java.util.List;// 利用 List接口多态实现 List array = new ArrayList();array.add(12345); array.add(&quot;上山打老虎&quot;); array.add(new Hero()); 普通for循环遍历集合 12for (int i = 0; i &lt; array.size();i++) System.out.println(array.get(i)); 迭代for循环遍历 123456// hasNext - 判断当前是否有下一个元素，有返回true// next - 返回当前元素类型。for (Iterator it = array.iterator();it.hasNext();)&#123; System.out.println(it.next());&#125; 第十章：泛型 10.1 泛型分类及作用 泛型集合 通过，泛型集合指定集合接受类型，如只能接受 Hero对象及其子类 如下，声明了一个非泛型对象数组集合，可添加不同对象，但也许我们只想添加Hero对象。 1234ArrayList heros = new ArrayList();heros.add(new Hero());heros.add(new Item());// 此时泛型还可以添加无关的 Item对象 通过泛型指定只能添加 Hero对象及其子类： 12345ArrayList&lt;Hero&gt; heros = new ArrayList&lt;Hero&gt;();heros.add(new Hero()); heros.add(new ADHero()); // 子类也可以添加heros.add(new Item()); // 编译错误 泛型方法 &amp; 泛型类 &amp; 泛型接口 这些泛型，可以接受不同参数实现代码精简。 12345678910111213141516171819202122232425262728293031323334// 泛型类，类中定义了非泛型方法&amp;泛型方法。public class Demo&lt;T&gt; &#123; // 1.[非泛型方法] 因为用的是类定义泛型 public void test(T a) &#123; System.out.println(a); &#125; // 2.[泛型方法] 这才是泛型方法，&lt;T&gt;声明在返回类型前 public &lt;T&gt; void test1(T a) &#123; System.out.println(a); &#125; // 3.[静态方法 &amp; 编译错误]下面编译错误，静态类不能用类定义的泛型 public static void test2(T a) &#123; System.out.println(a); &#125; // 4.[静态泛型方法] 用自己定义的泛型就不会出错 public static &lt;T&gt; void test2(T a) &#123; System.out.println(a); &#125;&#125;// 泛型接口类似泛型类声明interface InterDemo&lt;T&gt;&#123; // do something&#125; 泛型转型 暂时记住结论。 我们知道，子类是可以转换成父类（多态），但是子类泛型和父类泛型不能互转！ 10.2 泛型通配符 通配符作用 &lt; ? extends 类型名&gt; ：只能取 类型名、object，不能插入； &lt;?&gt; : 只能取object ，不能插入； &lt; ? super 类型名&gt; ： 只能取object ，能插入满足通配符匹配所有类型的子类。 &lt; ? extends 类型名&gt; 12345678910111213// 1. 因为不能插入，所以先定义一个&lt;APHero&gt;泛型集合插入一些数据ArrayList&lt;APHero&gt; apHeroList = new ArrayList&lt;APHero&gt;();apHeroList.add(new APHero());// 2.定义&lt;? extends&gt;泛型集合：指向上面泛型集合 ArrayList&lt;? extends Hero&gt; heroList = apHeroList;// 3.测试// [取，可行] 因为&lt;? extends&gt;代表保存的都是 Hero及其子类，取出来都可以转换成Hero类型Hero h = herolist.get(0);// [插，不可] 因为&lt;? extends&gt;可以是Hero及其子类，但只能确定为其中一个。// 比如， &lt;? extends&gt;已经代表是&lt;Hero&gt;,根据泛型集合限定插入类型，此时插入APHero类型会失败。heroList.add(new ADHero()); //编译错误 &lt;?&gt; 基本同*&lt; ? extends 类型名&gt;* ，由于少了 extends ，代表可以是指向任意泛型对象，而非某类及其子类。 但是，取数据也对应只能是 Object 类型。 1234567// ...同前// 3.测试// [取，可行]只能为object类型Object o = generalList.get(0);// [插，不可]generalList.add(new Item()); generalList.add(new Hero()); // 编译错误 &lt; ? super 对象名&gt; 和*&lt; ? extends 对象名&gt;* 对象名不同，*&lt; ? super 对象名&gt;*代表可指向 对象名及父类。 如：&lt; ? super Hero&gt; ，代表可指向 Hero及其父类Object 。所以： 可插入：Hero &amp; 子类ADHero等（父类泛型可以插入子类对象） 不可取：无法将父类泛型转换成子类（向下转换），但是不可以像*&lt;?&gt;取出来是Object*类型吗？可行 12345678910// 1.定义&lt;? super&gt;泛型ArrayList&lt;? super Hero&gt; heroList = new ArrayList&lt;Hero&gt;();// 2.测试// [取，不可] 无法向下转换，父类转换成子类Hero h = heroList.get(0); // 不可，编译错误Object O = heroList.get(0); // 可行// [插，可行]heroList.add(new Hero()); heroList.add(new ADHero()); // 子类可插入 通配符取出、插入总结 取出 无论是何种通配符，取出是只要满足 向上转换 规则即可。 如：&lt;? extends Hero&gt; ,是 Hero及子类，只要转换的对象类型是通配符匹配所有类型的父类（或同级），即可插入。 显然，Hero 是*&lt;? extends Hero&gt;所有类型父类，所以可以取出转换成Hero*： 123ArrayList&lt;? extends Hero&gt; heroList = new ArrayList&lt;Hero&gt;();Hero h = heroList.get(0); // 可行 但是， & ，Hero不满足通配符所代表的所有类型类型父类，所以出错； 以此推论，向上转换成Object则行。 1234ArrayList&lt;? super Hero&gt; heroList = new ArrayList&lt;Hero&gt;();Hero h = heroList.get(0); // 编译错误Object O = heroList.get(0); // 可行 插入 插入即&quot;向下插入&quot;，插入对象是通配符匹配所有类型的子类（或同级）。 如：* & * ,它们的子类是不确定的，所以不能插入。 而：&lt;? extends Hero&gt; ，ADHero、Hero 显然满足符合该通配符匹配的所有类型子类（同级），故可以插入。 第十一章：Lambda 11.1 匿名类 使用时机 在new创建：一个类对象 、 一个接口子类对象、一个抽象类子类对象时。 12345类|接口 名字 = new 类|接口()&#123; @override 重写方法;&#125;； 如，下面 new Runnable接口实现了一个匿名类： 123456789// Runnable是一个接口Runnable x = new Runnable()&#123; @Override public void run() &#123; System.out.println(this.getClass()); &#125; &#125;; 我们知道，接口是不能被实例化的，上述代码实际是这么一个实现过程： {}相当于一个继承了Runnable接口 BUT 匿名的类实现了Runnable接口方法； 该匿名类则可以通过多态 转换成父类接口Runnable类型。 总结 在实际开发中，我们可以看到有方法，用抽象类、接口作参数实现多态。 而我们实际需要的是一个子类对象，如果该方法仅仅调用1 次，用匿名类简化格式，不必特地实现一个类继承该接口、抽象类。 11.2 Lambda 基本用法 Lambda 语法 在 java中，其表达式格式语法一般是：(parameters) -&gt; &#123; statements; &#125; 。 在满足一定条件下，还可以进一步简写： 参数类型可选 ：不需要声明参数类型，编译器可以统一识别参数值； 只有一个参数 ： 参数 ()可选 主体{}只有一条语句 ：此时 return 关键字 &amp; {} ，可不写。注意 ！ 主体{} 不省略时，哪怕只有一条语句，函数有返回值return关键字不可省！ 主体{} 省略时，return 也必须省略！ 以下是一些简单示例： 1234567891011121314// 1. 不需要参数,返回值为 5 () -&gt; 5 // 2. 接收一个参数(数字类型),返回其2倍的值 x -&gt; 2 * x // 3. 接受2个参数(数字),并返回他们的差值 (x, y) -&gt; x – y // 4. 接收2个int型整数,返回他们的和 (int x, int y) -&gt; x + y // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void) (String s) -&gt; System.out.print(s) Lambda 用于简化匿名类 在 9.5 Collections类 一节，我们用 Collections.sort(heros，Comparator) 静态方法去比较 Hero 的HP属性，进而按HP大小打印heros数组中各Hero对象信息。 我们用到匿名类覆写实现了 Comparator 接口： 123456789101112131415// 2.[匿名类]覆写比较器compare方法（比较规则）Comparator&lt;Hero&gt; comparable = new Comparator&lt;Hero&gt;() &#123;@Overridepublic int compare(Hero h1,Hero h2)&#123; if(h1.HP &gt; h2.HP) return 1; else return -1; // 注意，别写0 &#125;&#125;;Collections.sort(heros,comparable);System.out.println(heros); 这里可以将匿名类简写为： 1Comparator&lt;Hero&gt; comparable = (Hero h1,Hero h2) -&gt; &#123; return h1.HP &gt; h2.HP ? 1:0;&#125;; 还可以进一步简化： 12345// 1.去掉参数类型 // 2.去掉&#123;&#125;(只有一条语句) // 3.去掉return（只有一条语句 + 没有&#123;&#125;）Comparator&lt;Hero&gt; comparable = (h1,h2) -&gt; h1.HP &gt; h2.HP ? 1:0; Lambda 用于把方法作参数 在上面我们通过匿名类 或者 lambda简化，最终创建了Comparator对象comparable，然后调用方法： 12Comparator&lt;Hero&gt; comparable = (h1,h2) -&gt; h1.HP &gt; h2.HP ? 1:0;Collections.sort(heros,comparable); 我们可以更进一步，直接传递 lambda 表达式作为参数： 1Collections.sort(heros,(h1,h2) -&gt; h1.HP &gt; h2.HP ? 1:0); 最终上面代码被成功简化成一行。 当然还有其它匿名方法例子，实现遍历输出： 1public void forEach(@NotNull java.util.function.Consumer&lt;? super E&gt; action) 123456// 创建一个集合ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();array.add(4);array.add(5);array.add(3);array.add(1);// forEach方法参数有一个Cosumer接口，通过lambda表达式创建一个继承Cosumer接口匿名对象array.forEach(n -&gt; System.out.println(n)); 11.3 Lambda 聚合操作 在上面我们介绍了，如果方法参数是一个接口或者抽象类等，可利用Lambda 表达式作为方法参数。表达式创建一个继承该接口 |抽象类的匿名类，这种方法也叫做匿名方法。 我们可以用同时使用多个匿名方法，实现聚合操作。 实例介绍 1234567891011121314// 创建一个Hero类型集合，准备多个对象指定HPArrayList&lt;Hero&gt; heros = new ArrayList&lt;Hero&gt;();for(int i = 0 ; i &lt; 10 ; i++)&#123; String name = &quot;hero&quot;+i; int hp = (int)(Math.random()* 1000); heros.add(new Hero(name,hp)); // 带int参数构造函数&#125;// heros对象有多个方法，进行聚合操作heros .stream() .sorted((h1,h2) -&gt; h1.HP &gt; h2.HP ? 1:-1) // 比较器接口 .forEach(n -&gt; System.out.println(n)); // Cosumer接口 更多操作 实例参考，具体待用到补充：聚合操作 以 源为 List 为例： 中间操作方法 filter ：匹配 distinct： 去除重复(根据equals判断) sorted ：自然排序 sorted(Comparator) ：指定排序 limit ：保留 skip ：忽略 结束操作方法 forEach()：遍历每个元素 toArray() ：转换为数组 min(Comparator) ： 取最小的元素 max(Comparator)： 取最大的元素 count()： 总数 findFirst()：第一个元素 第十二章：多线程 12.0 基本知识 线程与进程介绍 什么是进程？ 打开任务管理管理器，可以看到很多【正在运行】的应用程序，这就是对应进程。 正在运行的应用程序； 系统分配和调用资源的基本单位 线程？单线程与多线程？ 线程：是进程的单个顺序控制流，是执行的最小单位（执行路径） 单线程：e.g. 记事本程序 一个进程如果只有一条执行路径，则为单线程 多线程：e.g. 扫雷程序：计时、玩家扫雷 一个进程如果有多条执行路径，则为多线程程序 子线程设置名字 &amp; 源码分析 MyThread.java 123456789101112131415161718package com.itheima_01;public class MyThread extends Thread &#123; // 必须要定义这个 public MyThread() &#123;&#125; // 调用父类（Thread）构造函数（一个参数的方法） // 调用顺序看下截图 public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; for(int i=0; i&lt;100; i++) &#123; System.out.println(getName()+&quot;:&quot;+i); &#125; &#125;&#125; MyThreadDemo.java 12345678910111213141516171819202122package com.itheima_01;/* 方式1：继承Thread类 1:定义一个类MyThread继承Thread类 2:在MyThread类中重写run()方法 3:创建MyThread类的对象 4:启动线程 */public class MyThreadDemo &#123; public static void main(String[] args) &#123; MyThread my1 = new MyThread(); MyThread my2 = new MyThread(); my1.setName(&quot;11&quot;);// my1.run();// my2.run(); //void start​() 导致此线程开始执行; Java虚拟机调用此线程的run方法 my1.start(); my2.start(); &#125;&#125; 获取Main方法进程名 不能使用Thread对象方法：getName()，因为没继承Thread 应该用Thread静态方法，Thread.currentThread 获取当前执行对象, 再调用getName() 1String mainTreadName = Thread.currentThread.getName() 线程调度 线程主要有两种调度【模型】： 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些 Java使用的是抢占式调度模型 ，具有随机性。 随机性 ：因为CPU在某个时刻只能执行一条命令，线程只有得到CPU时间片（使用权），才可以执行。而抢占式调度模型多线程执行具有随机性，谁抢到CPU是不确定的。 线程优先级： 通过设置线程优先级，可以让某个线程得到CPU的概率变大。（但不意味着是绝对优先，只是概率增大） 方法名 说明 final int getPriority() 返回此线程的优先级 final void setPriority(int newPriority) 更改此线程的优先级 线程默认优先级是5；线程优先级的范围1-10 线程生命周期 📓 面试重点！ 变为阻塞 ：是由 运行 状态进入的， 且是被sleep() 一些阻塞式方法导致的 变为就绪： 可能是 新建 状态获得资源，也可能是 运行 状态进入 12.1 多线程快速入门 不使用多线程 下面有一个 Hero 类，实现了attack 方法，用于模拟游戏人物进行攻击： 123456789101112131415161718192021222324252627package LOL;public class Hero&#123; String name; int HP; Hero(String name ,int hp) &#123; this.name = name; this.HP = hp; &#125; // 函数：攻击 public void attack(Hero h,int damage) &#123; h.HP -= damage; System.out.format(&quot;[%s]正在攻击[%s],[%s]血量为:[%d]..\\n&quot;, name,h.name,h.name,h.HP); if (h.isDead()) &#123; System.out.println(h.name + &quot;--已经挂了！\\n&quot;); &#125; &#125; // 函数：判断是否死亡 public boolean isDead() &#123; return 0 &gt;= HP ? true :false; &#125;&#125; 我们在主函数中，实例化游戏人物VN，garren 各自分别攻击 teemo、bh ： 12345678910111213141516171819package LOL;public class hello&#123; public static void main(String[] args) &#123; Hero VN = new Hero(&quot;VN&quot;,2500); Hero teemo = new Hero(&quot;teemo&quot;,3000); Hero gareen = new Hero(&quot;gareen&quot;,5000); Hero bh = new Hero(&quot;bh&quot;,2800); // 英雄开始攻击 while (!teemo.isDead()) VN.attack(teemo,100); while (!bh.isDead()) gareen.attack(bh,100); &#125;&#125; 因为都在主函数中的主线程中，显然应该先是VN 攻击，然后garren 进行攻击，这样一种串行方式。 但是实际游戏中，VN 和 garren 是可以同时进行攻击的，如何实现呢？ 多线程实现并行攻击 根据上面思考，我们应该分别把 VN攻击teemo 和 garren攻击bh 放在不同线程中并行执行。 一般来说，实现多线程我们有三种方式： 继承 Thread 类 实现 Runnable 接口 匿名类的方式 1. 继承 Thread 类 通过继承Thread 类，然后覆写run() 方法，在run() 方法写上需要并发的操作 。这样，在实例化对象后，执行对象方法 start() 启动后便会分配线程来执行 run() 中操作。 1234567891011121314151617181920212223package 多线程;import LOL.Hero;public class KillThread extends Thread&#123; private Hero h1; private Hero h2; public KillThread(Hero h1,Hero h2) &#123; this.h1 = h1; this.h2 = h2; &#125; // 覆写父类Thread中run()方法 @Override public void run() &#123; while (!h2.isDead()) // 模拟不断攻击敌方英雄 h1.attack(h2,100); &#125;&#125; 然后在主函数，实例化 KillThread 对象，执行start() 方法来创建线程，然后执行方法run() 中操作。 显然，下面KillThread 对象kh1、kh2，分别创建了两个线程执行 VN攻击Teemo，garren攻击bh。 📓 创建两个线程，代码排版中是串行的，但是实际执行是并行的。 12345678910111213141516171819package LOL;public class hello&#123; public static void main(String[] args) &#123; Hero VN = new Hero(&quot;VN&quot;,2500); Hero teemo = new Hero(&quot;teemo&quot;,3000); Hero gareen = new Hero(&quot;gareen&quot;,5000); Hero bh = new Hero(&quot;bh&quot;,2800); // 如果执行 kt1.run()、kt2.run() 不会创建新线程,相当于串行操作 KillThread kt1 = new KillThread(VN, teemo); kt1.start(); KillThread kt2 = new KillThread(gareen, bh); kt2.start(); &#125;&#125; 根据下面部分输出截图，可以发现 VN攻击Teemo，garren攻击bh 可以并行执行： 2. 实现 Runnable 接口 通过 实现 Runnable 接口 和 继承 Thread 类来实现多线程，大同小异。 相比继承Thread类，实现Runnable接口的好处： 避免了Java单继承的局限性 适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想 唯一需注意的是，Runnable 接口 虽然要求实现 run() 方法，但是： 直接调用*run()*方法，并不会启动一个新的线程。[面试]需要借助线程对象 start()方法，才会启动一个新的线程。 下面创建一个 Battle 类，实现Runnable 接口，可以看到：除了没有继承 Thread 类，其余都一模一样。 1234567891011121314151617181920212223package 多线程;import LOL.Hero;public class Battle implements Runnable // 以下和继承Thread方式代码一样&#123; private Hero h1; private Hero h2; public KillThread(Hero h1,Hero h2) &#123; this.h1 = h1; this.h2 = h2; &#125; // 覆写父类Thread中run()方法 @Override public void run() &#123; while (!h2.isDead()) // 模拟不断攻击敌方英雄 h1.attack(h2,100); &#125;&#125; 在主函数需要借助 Thread 对象 *start()*方法，启动一个新线程，这也是和直接继承 Thread 类不同地方： 123456789101112131415161718package LOL;public class hello&#123; public static void main(String[] args) &#123; Hero VN = new Hero(&quot;VN&quot;,2500); Hero teemo = new Hero(&quot;teemo&quot;,3000); Hero gareen = new Hero(&quot;gareen&quot;,5000); Hero bh = new Hero(&quot;bh&quot;,2800); Battle battle1 = new Battle(gareen,teemo); new Thread(battle1).start(); // 把Battle对象当做Thread构造函数参数传递进去 Battle battle2 = new Battle(bh,leesin); new Thread(battle2).start(); &#125;&#125; 3. 匿名类 在 2.实现 Runnable 接口 中，我们难免会想到通过匿名类方式来实现，因为它满足： 通过继承接口/类方式实现一个类(Battle) 该类对象仅被调用一次 当然，在 3.继承 Thread 类 中也满足上述条件，可以通过匿名类实例KillThread 对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package LOL;public class hello&#123; public static void main(String[] args) &#123; Hero VN = new Hero(&quot;VN&quot;,2500); Hero teemo = new Hero(&quot;teemo&quot;,3000); Hero gareen = new Hero(&quot;gareen&quot;,5000); Hero bh = new Hero(&quot;bh&quot;,2800); /* // 匿名类生成本来的KillThread对象 Thread t1= new Thread()&#123; public void run() &#123; while(!teemo.isDead()) gareen.attackHero(teemo); &#125; &#125;; */ // 匿名类实现生成Battlel类对象 Runnable battle1 = new Runnable() &#123; @Override public void run() &#123; while (!teemo.isDead()) VN.attack(teemo,100); &#125; &#125;; // 注意要有 ; 分号 new Thread(battle1).start(); Runnable battle2 = new Runnable() &#123; @Override public void run() &#123; while (!bh.isDead()) gareen.attack(bh,100); &#125; &#125;; new Thread(battle2).start(); &#125;&#125; 当然，我们还可以更进一步，使用 lambada 表达式： 12345678910111213141516171819package LOL;public class hello&#123; public static void main(String[] args) &#123; Hero VN = new Hero(&quot;VN&quot;,2500); Hero teemo = new Hero(&quot;teemo&quot;,3000); Hero gareen = new Hero(&quot;gareen&quot;,5000); Hero bh = new Hero(&quot;bh&quot;,2800); // 更进一步：通过lambada表达式 Runnable battle1 = () -&gt; &#123;while (!teemo.isDead()) VN.attack(teemo,100);&#125;; new Thread(battle1).start(); Runnable battle2 = () -&gt; &#123;while (!bh.isDead()) gareen.attack(bh,100);&#125;; new Thread(battle2).start(); &#125;&#125; 12.2 多线程常用方法 sleep() 方法 sleep() 是 Thread 类静态方法，可以使 当前 线程阻塞，并指定暂停时间，重点在于理解 当前： 下面是14.1中 3.匿名类 在主函数实现多线程代码，删减了 garren 攻击 bh 创建线程部分。 1234567891011121314151617181920212223242526272829package LOL;public class hello&#123; public static void main(String[] args) throws InterruptedException &#123; Hero VN = new Hero(&quot;VN&quot;,2500); Hero teemo = new Hero(&quot;teemo&quot;,3000); Hero gareen = new Hero(&quot;gareen&quot;,5000); Hero bh = new Hero(&quot;bh&quot;,2800); // [1]暂停1s Thread.sleep(1000); // sleep要处理异常，为了方便直接在主函数throw // 匿名类实现 Runnable battle1 = new Runnable() &#123; @Override public void run() &#123; // [2]暂停2s Thread.sleep(2000); while (!teemo.isDead()) VN.attack(teemo,100); &#125; &#125;; new Thread(battle1).start(); &#125;&#125; 可以看到上面有两个位置发生暂停： [1]暂停1s：显然当前线程是主线程，所以会使得主线程暂停1s； [2]暂停2s：执行完 new Thread(battle1).start(); 启动新线程1，新线程1会执行 run() 方法。那么当前线程就是线程1，线程1被暂停2s。 yield() 方法 yield() 也是 Thread 类静态方法，使当前线程变为就绪状态 （sleep() 是阻塞），使得其他线程更多机会获取CPU。 但不能指定暂停时间，因为线程重新到就绪状态 后，执行yield()的线程有可能在进入就绪状态 马上又被执行。 1234567891011121314151617181920212223242526272829package LOL;public class hello&#123; public static void main(String[] args) throws InterruptedException &#123; Hero VN = new Hero(&quot;VN&quot;,2500); Hero teemo = new Hero(&quot;teemo&quot;,3000); Hero gareen = new Hero(&quot;gareen&quot;,5000); Hero bh = new Hero(&quot;bh&quot;,2800); // [1]主线程从运行--&gt;就绪 Thread.yield(); // 实际测试没有效果，后面代码还是执行主函数代码，主线程立马又被调度了 // 匿名类实现 Runnable battle1 = new Runnable() &#123; @Override public void run() &#123; while (!teemo.isDead()) VN.attack(teemo,100); // [2]VN攻击teemo线程从运行--&gt;就绪 Thread.yield(); // 让出CPU调度 &#125; &#125;; new Thread(battle1).start(); &#125;&#125; join() 方法 slepp()、yield()都是Thread类静态方法，但jion() 是Thread类实例对象方法。 一种特殊的wait，当前 运行线程调用另一个线程的join方法。 当前线程进入阻塞状态直到join的线程运行结束 ，等待该线程终止。 注意该方法也需要捕捉异常。- ⚠️ 此时有其它子线程，也必须等到调用jion() 的线程先执行完毕。 ​ 123456789101112131415161718192021222324252627282930313233343536/* void join()：等待这个线程死亡 */public class ThreadJoinDemo &#123; public static void main(String[] args) &#123; ThreadJoin tj1 = new ThreadJoin(); ThreadJoin tj2 = new ThreadJoin(); ThreadJoin tj3 = new ThreadJoin(); tj1.setName(&quot;康熙&quot;); tj2.setName(&quot;四阿哥&quot;); tj3.setName(&quot;八阿哥&quot;); // 1.启动主线程后，三个线程抢占执行，谁都可能执行 tj1.start(); tj2.start(); tj3.start(); // 2.主线程继续往下执行， // 遇到设置康熙线程jion后，主线程和另外两个阿哥线程 // 【都阻塞】，等待康熙线程执行完 try &#123; tj1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;public class ThreadJoin extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(getName() + &quot;:&quot; + i); &#125; &#125;&#125; setPriority() 方法 setPriority() 用于设置优先级，优先级的高的线程更高几率获得 CPU 调度。有以下几个需要知道知识点： 线程优先级表示 线程优先级表示用整数：1~10，也可以用java 内置的三种 INT 型常量表示： 最低优先级 1：Thread.MIN_PRIORITY 普通优先级 5：Thread.MAX_PRIORITY 最高优先级10：Thread.NORM_PRIORITY 默认线程优先级 Java默认的线程优先级是 父线程的优先级，而非普通优先级 Thread.NORM_PRIORITY 。 详细参考 操作系统 一书，这里以一个简单实例说明。 123456789101112131415161718192021222324252627282930313233343536373839404142package LOL;public class hello&#123; public static void main(String[] args) throws InterruptedException &#123; Hero VN = new Hero(&quot;VN&quot;,2500); Hero teemo = new Hero(&quot;teemo&quot;,3000); Hero gareen = new Hero(&quot;gareen&quot;,5000); Hero bh = new Hero(&quot;bh&quot;,2800); Thread t1 = new Thread()&#123; @Override public void run() &#123; while (!teemo.isDead()) VN.attack(teemo,100); &#125; &#125;; Thread t2 = new Thread()&#123; @Override public void run() &#123; while (!bh.isDead()) gareen.attack(bh,100); &#125; &#125;; // 获取线程优先级 System.out.format(&quot;t1优先级%d，t2优先级%d\\n&quot; ,t1.getPriority(),t2.getPriority()); // 重新设置线程优先级 t1.setPriority(Thread.MAX_PRIORITY); t2.setPriority(Thread.MIN_PRIORITY); // 获取优先级 System.out.format(&quot;t1优先级%d，t2优先级%d\\n&quot; ,t1.getPriority(),t2.getPriority()); // 启动线程 t1.start(); t2.start(); &#125;&#125; setDaemon() 方法 setDaemon() 用于设置守护线程。什么是守护线程？ 简单理解，一个 进程 中用于守护其它线程的线程，如果其它线程结束，只剩下守护线程，那么进程 结束。 守护线程通常会被用来做：日志、性能统计等工作。 12// t1线程被设为当前进程的守护线程 t1.setDaemon(true); 创建一个破解线程用穷举法匹配指定的某密码；创建一个日志守护线程，打印用过哪些密码匹配。 🔑 由于日志线程是守护线程，那么破解线程匹配成功结束，守护线程日志也就结束了； 🔑 设置一个公共容器 LinkList 答案查看：多线程常用方法 设置三个线程：“关羽”、“张飞”、“刘备” 。“刘备”为当前线程（也是主线程），“关羽”和“张飞”为守护线程。 下面示例中，“刘备”线程挂了后，“关羽”、“张飞” 也马上停止了（但还是挣扎了会）。 12.3 多线程同步 多线程同步问题，指多线程同时修改一个数据时，导致数据不一致等。解决多线程问题，通常通过： volatile关键字 ：可保证可见性； synchronized关键字 ：是一个同步锁，保证原子性和可见性； Lock 接口：保证原子性和可见性，详情暂略。 在解释 volatile &amp; synchronized 同步锁前，先了解一些并发编程基本概念。 思考下面售票案例：为什么控制台会：1. 输出相同票、2.出现负数票？ 主函数类 12345678910111213141516public class SellTicketDemo &#123; public static void main(String[] args) &#123; //创建SellTicket类的对象 SellTicket st = new SellTicket(); //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称 Thread t1 = new Thread(st,&quot;窗口1&quot;); Thread t2 = new Thread(st,&quot;窗口2&quot;); Thread t3 = new Thread(st,&quot;窗口3&quot;); //启动线程 t1.start(); t2.start(); t3.start(); &#125;&#125; SellTicket 线程类 123456789101112131415public class SellTicket implements Runnable &#123; private int tickets = 100; //在SellTicket类中重写run()方法实现卖票，代码步骤如下 @Override public void run() &#123; while (true) &#123; if (tickets &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot;张票&quot;); tickets--; &#125; &#125; &#125;&#125; 解释 相同票：打印出售票、 tickets-- 两条语句共享tickets变量，导致没有及时更新tickets变量 出现负数票： if (tickets &gt; 0) 语句判断和 tickets--共享tickets变量 ，没有及时更新tickets变量 1.如何解决多线程 安全问题出现的条件 是多线程环境 有共享数据 有多条语句操作（包含，读、写等）共享数据 为什么一定要求是一个线程有多条语句操作共享数据？ 如果两个线程，各只有一条语句操作数据，虽然线程执行具有随机性，但是无论哪个线程执行自己那条语句（是原子性语句）时，其它线程即使此刻抢占到CPU，修改了共享变量。但由于前一个线程不再会执行共享数据相关操作，因此实际是不影响的。 ⚠️ 区分多线程中线程来源同一个类和不同类情况。 两个线程来自同一个线程类两个对象 ，该类有多条语句修改共享类变量的操作 ；锁住类的共享操作数据语句保证同一时候只有一个线程对共享变量进行修改 【消费生产问题】两个线程来自不同线程类，但各有一条或多条语句对共享变量进行修改 ；使用P、V操作保证同一时候只有一个线程对共享变量进行修改。参考 ：7.生产者消费者 小节实例 JAVA中使用 wait()、notifyAll() 来实现，但是和PV操作逻辑是不一样的。 如何解决多线程安全？ 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可 Java提供了同步代码块的方式来解决 1234synchronized(任意对象) &#123; // 多条语句操作共享数据的代码&#125; synchronized同步方式优缺点？ 好处：解决了多线程的数据安全问题 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率 尝试synchronized解决售票问题 为什么下面这种方式，执行还是一样的问题？ 因为每次创建线程对象，锁对象new Object 也是重新创建的，三个线程对象三把锁，所以锁不住 因此，我们要定义一个公共的锁对象： 2.原子性、可见性、有序性 原子性 即一个或多个操作，要么全部执行，要么全部不执行，类似于数据库事务概念。 在 java 中，基本数据类型的变量的读取和赋值操作是原子性操作，其余不是，例如： 【面试高频】判断：下面语句1~4，都是原子性操作吗？（即是否每条语句包含的操作要么都完成/要么都不完成） 1234x = 10; // 语句1y = x; // 语句2x++; // 语句3x = x + 1; // 语句4 其实，除了第一条语句，其余都不是原子性操作。 x = 10：线程执行该语句将10写入内存； y = x：读取x值 --&gt; 然后将10写入内存，进行了两次操作； x++ ：读取x值 --&gt; 进行+1操作 --&gt; 写入新值，进行了三次操作； x = x + 1：同x++，三次操作。 所以，只有x=10这种简单赋值操作是原子性语句。在 java中提供了 synchronized 关键字 和Lock 接口来实现。 可见性 对于可见性，Java 提供了volatile 关键字来保证可见性，当然synchronized 关键字 和Lock 接口也可以保证。 可见性，即指一个共享变量被volatile 修饰时，它会保证修改的值会立即被更新到主存。当有其他线程需要读取时，它会去内存中读取新值。 有序性 在Java内存模型中，允许编译器和处理器对指令进行重排序。但是重排序过程不会影响到 单线程 程序的执行，却会影响到 多线程 并发执行的正确性。 在java 中，也是通过 volatile关键字来保证一定的“有序性&quot;。 12345678910//线程1:context = loadContext(); //语句1 context初始化操作inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;System.out.println(context); 由于指令重新排序，可能导致语句2先于语句1执行。即相当于inited = ture被执行 ， context = loadContext() 未被执行。然后线程2 错误判读已经初始化完毕 ，执行System.out.println(context); 打印出context 。 通过加上volatile 关键字对 inited 变量进行修饰，可以避免这种情况。 因为，程序执行到volatile修饰变量读/写操作时，保证在其前面的操作肯定已经完成，后面操作未执行。 1volatile inited = true; 3.volatile 关键字 volatile 关键字主要有两个作用：使被修饰变量具有可见性 &amp; 禁止指令重排保证可见性。 保证可见性，见前。这里结合实例保证被修饰变量具有可见性。 设计一个线程1不断学狗叫，一个线程2过1秒结束这令人窒息的操作。 12345678910111213141516171819202122232425262728293031323334353637383940// 线程类，有一个学狗叫操作import 多线程.test_Thread;public class test_Thread extends Thread&#123; public volatile boolean flag = true; @Override public void run() &#123; while (flag) System.out.println(&quot;我在学狗叫：汪汪汪~&quot;); &#125;&#125;// 主函数中public class test&#123; public static void main(String[] args) throws InterruptedException &#123; test_Thread t1 = new test_Thread(); Thread t2 = new Thread()&#123; // 匿名类方式生成一个线程1s后结束t1线程 @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; t1.flag =false; // 把flag设置为flase，由于可见性，将结束线程t1中while循环 &#125; &#125;; t1.start(); t2.start(); &#125;&#125; 实际输出：过了大概1s，线程1停止了学狗叫。 4.synchronized关键字 volatile 关键字可以保证可见性，但是不能保证原子性，会导致多线程出现脏数据等问题。例如下面例子： 1. 一个DEMO ⚠️ java 函数不能改变int类型实参，也不能加上ref 关键字改变！所以出此下策：把数组当做参数传递，组第一个元素是我们想通过函数改变的值。数组是引用类型，可以改变里面的值。 1234567891011121314151617181920212223242526272829303132333435363738// 线程类IncreaseThreadpublic class IncreaseThread extends Thread&#123; private int[] num; public IncreaseThread(int[] num) &#123; this.num = num; &#125; // 函数使得num值被修改 @Override public void run() &#123; num[0]++; &#125;&#125;// 主函数中import 多线程.IncreaseThread;public class test&#123; public static void main(String[] args) throws InterruptedException &#123; int[] num = new int[]&#123;0&#125;; Thread addThreads[] = new Thread[100000]; for (int i = 0 ; i &lt; 100000 ; i++) &#123; IncreaseThread ih = new IncreaseThread(num); ih.start(); addThreads[i] = ih; &#125; // 所有增加子线程都加入主线程中，保证子线程都【先】执行完 // *如果线程已经执行完，不会在执行吧？是 // *如果没有这行代码，子线程也会在主线程执行完继续执行 for (Thread t : addThreads) t.join(); System.out.println(num[0]); // 输出有时候是：999995 / 99996 .. &#125;&#125; 2. 分析结果 我们看到输出结果并非为100000，这是为什么？ 因为 num[0]++; 并非是原子性语句，它由三个操作：取num[0]值 --&gt; +1 操作 --&gt; 写入 num[0] 三个操作组成。 在多线程这将导致一个问题，例如恰好某时刻 num[0] = 100，存在线程A、B： 线程A，取出*num[0]*值 = 100，准备进行+1操作 线程B，恰好也取出*num[0]*值 = 100 线程A，执行num[0]++ 操作，num[0] = 101 线程B，也执行 num[0]++ 操作，所以 num[0] = 101没有被改变 所以线程A、B写入值都是101，没有正确顺序执行++操作。 这就是为什么每次运行结果都是 &lt;100000。 3. synchronized 同步锁 我们可以用synchronized 关键字保证同一时刻只有一个线程获取锁，然后执行同步代码。 【面试】synchronized只能修饰：类、方法或代码块，不能修饰变量。 在 IncreaseThread 类中给 run() 函数加上同步锁： 12345@Overridepublic synchronized void run()&#123; num[0]++;&#125; 保证了 num[0]++ 操作同一时刻只有一个线程可以执行。经过多次测试输出结果 == 100000。 ⚠️ 直接给 run() 加锁也许并不是一个好做法，这会使得里面所有需要并行操作都加锁。因为这里只有 num[0]++ 这一条语句故这样写。更好的做法是，单独设计一个函数包含++操作，然后给这个函数加锁，在run()中调用。 4. 匿名类使用同步锁 匿名类下就没法用synchronized关键字限定一个函数，然后run() 执行这个函数（当然你可以限定 run() …） 我们可以首先定义一个object 常量： 1final Object someObject = new Object(); 然后在匿名类中，synchronized (someObject)&#123; // 包含要原子性执行的语句 &#125;，下面是示例。 暂时不明白synchronized (someObject) 设置不同参数有何作用？ 123456789101112131415161718192021222324252627282930public class test&#123; public static void main(String[] args) throws InterruptedException &#123; int[] num = new int[]&#123;0&#125;; Thread addThreads[] = new Thread[100000]; final Object someObject = new Object(); for (int i = 0 ; i &lt; 100000 ; i++) &#123; Thread ih = new Thread() &#123; @Override public void run() // 不推荐：synchronized限定run() &#123; // synchronized体&#123;&#125;代码被独占 synchronized (someObject) &#123; num[0]++; &#125; &#125; &#125;; ih.start(); addThreads[i] = ih; &#125; // 所有增加子线程都加入主线程中，保证子线程都执行完 for (Thread t : addThreads) t.join(); System.out.println(num[0]); // 多次测试输出是：100000 &#125;&#125; 5. synchronized 同步方法 同步对象方法 给上述卖票代码加个else语句：偶数执行if，奇数执行else。esle语句存在一个方法，给它加上锁。 但是synchronized 关键字直接加到方法上会出问题： 同步对象方法的默认锁是this （默认且不能指认），而前述if语句的是的锁是obj ，两把锁是不一样的！ 因此要把锁改为this 1234567891011121314151617181920212223242526272829303132333435363738public class SellTicket implements Runnable &#123; private int tickets = 100; private Object obj = new Object(); private int x = 0; @Override public void run() &#123; while (true) &#123; if (x % 2 == 0) &#123; // synchronized (obj) &#123; // 应该改为this synchronized (this) &#123; if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot;张票&quot;); tickets--; &#125; &#125; else &#123; sellTicket(); &#125; x++; &#125; &#125;// private synchronized void sellTicket() &#123;// if (tickets &gt; 0) &#123;// try &#123;// Thread.sleep(100);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot;张票&quot;);// tickets--;// &#125;// &#125; 同步静态方法 同步静态方法默认锁是当前类 ，因此不能用对象方法的锁this 可以采用反射：&lt;类名&gt;.class 获取当前类的字节码 5.常见线程安全的类 共同点 不同点 HashMap &amp; Hashtable（安全） 都实现了Map接口，按键值对保存数据。 1.HashMap可以存null，Hashtable不可以。2. Hashtable是线程安全类，put()方法用synchronized 关键字修饰。 StringBuffer（安全） &amp;StringBuilder 操作字符串，可以进行字符串拼接等操作。 1.StringBuilder 是线程安全类，比如 public synchronized StringBuilder append(int i) 方法，用了synchronized关键字 ArrayList &amp; Vector（安全） 都是可扩展动态数组 1.同上查看源码得知，Vector 是线程安全类。 把非线程安全集合转为线程安全 借助工具类 Collections 中静态方法 Collections.synchronizedList() 可以进行非安全集合到安全转换。 注意：StringBuffer 不属于集合范畴，不能转换。 1234567ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt; ();// 错误写法：返回是list无法转换为 Arraylist//ArrayList&lt;Integer&gt; list2 = Collections.synchronizedList(list1);List&lt;Integer&gt; list2 = Collections.synchronizedList(list1);HashMap&lt;Integer,String&gt; map1 = new HashMap&lt;&gt; ();Map&lt;Integer,String&gt; map2 = Collections.synchronizedMap(map1); 6.Lock锁 创建Lock锁 123456789101112131415161718192021222324252627mport java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class SellTicket implements Runnable &#123; private int tickets = 100; private Lock lock = new ReentrantLock(); @Override public void run() &#123; while (true) &#123; try &#123; lock.lock(); // 加锁 if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot;张票&quot;); tickets--; &#125; &#125; finally &#123; lock.unlock(); // Lock要手动释放锁 &#125; &#125; &#125;&#125; 7.生产者消费者 生产者消费者问题 生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。 常用方法 案例分析 生产者消费者案例中包含的类： 奶箱类(Box)：存储一个共享成员变量mike，表示第x瓶奶，提供存储牛奶put()和获取牛奶get()的操作 生产者类(Producer)：实现Runnable接口，重写run()方法，调用存储牛奶put()的操作，循环放30瓶 消费者类(Customer)：实现Runnable接口，重写run()方法，调用获取牛奶get()的操作，死循环不断获取 测试类(BoxDemo)：里面有main方法，main方法中的代码步骤如下: 创建奶箱对象，这是共享数据区域 创建消费者创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作对象 把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作 创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递 启动线程 为什么Object.wait(),Object.notify(),Object.notifyAll()必须在同步块synchronized中执行呢? ⚠️ 重点看下面P、V逻辑和wait()、notify() 逻辑区分。 在Java中，我们使用wait()和nofify()或notifyAll()来实现线程间通信。一个线程在测试条件不满足后进入等待状态; 在经典的生产者-消费者问题中，生产者线程因缓存区满而等待，消费者线程在消费了缓存区的一个元素后通知生产者线程。 调用notify()和notifyAll()方法来通知一个或多个线程一个条件已经改变了。一旦通知线程退出同步方法或同步块，所有等待的线程会争抢它们等待对象上的对象锁。 获取锁的线程会从等待状态返回并继续执行。 下面只用synchronized关键字锁住put和get操作，由于消费者while(true)一直消费会导致控制台最后一直输出： 123456...用户拿到第30瓶奶用户拿到第30瓶奶用户拿到第30瓶奶用户拿到第30瓶奶用户拿到第30瓶奶 必须要设置进程间通信，只用生产者put() 了一瓶奶，才能允许消费者取get() 牛奶 。 12345678910111213141516171819public class BoxDemo &#123; public static void main(String[] args) &#123; //创建奶箱对象，这是共享数据区域 Box b = new Box(); //创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作 Producer p = new Producer(b); //创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作 Customer c = new Customer(b); //创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递 Thread t1 = new Thread(p); Thread t2 = new Thread(c); //启动线程 t1.start(); t2.start(); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115public class Box &#123; //定义一个成员变量，表示第x瓶奶 private int milk; //定义一个成员变量，表示奶箱的状态 private boolean state = false; //提供存储牛奶和获取牛奶的操作 public synchronized void put(int milk) &#123; //如果有牛奶，等待消费 */ if(state) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果没有牛奶，就生产牛奶 this.milk = milk; System.out.println(&quot;送奶工将第&quot; + this.milk + &quot;瓶奶放入奶箱&quot;); //生产完毕之后，修改奶箱状态 state = true; //唤醒其他等待的线程 notifyAll(); &#125; public synchronized void get() &#123; //如果没有牛奶，等待生产 if(!state) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果有牛奶，就消费牛奶 System.out.println(&quot;用户拿到第&quot; + this.milk + &quot;瓶奶&quot;); //消费完毕之后，修改奶箱状态 state = false; //唤醒其他等待的线程 notifyAll(); &#125;&#125;public class Box &#123; //定义一个成员变量，表示第x瓶奶 private int milk; //定义一个成员变量，表示奶箱的状态 private boolean state = false; //提供存储牛奶和获取牛奶的操作 public synchronized void put(int milk) &#123; //如果有牛奶，等待消费 if(state) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果没有牛奶，就生产牛奶 this.milk = milk; System.out.println(&quot;送奶工将第&quot; + this.milk + &quot;瓶奶放入奶箱&quot;); //生产完毕之后，修改奶箱状态 state = true; //唤醒其他等待的线程 notifyAll(); &#125; public synchronized void get() &#123; //如果没有牛奶，等待生产 if(!state) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果有牛奶，就消费牛奶 System.out.println(&quot;用户拿到第&quot; + this.milk + &quot;瓶奶&quot;); //消费完毕之后，修改奶箱状态 state = false; //唤醒其他等待的线程 notifyAll(); &#125;&#125;public class Producer implements Runnable &#123; private Box b; public Producer(Box b) &#123; this.b = b; &#125; @Override public void run() &#123; for(int i=1; i&lt;=30; i++) &#123; b.put(i); &#125; &#125;&#125; 12.4 线程交互 生成者、消费者问题：p = synchronized ，占有；v = this.wait 释放。 Sleep()方法 Wait()方法 sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会; wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问； sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁 wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。 在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。 wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。 ❔ 试着解释下面分别用 sleep(2000) 和 wait(2000)的输出结果： 123456789101112131415161718192021222324252627282930313233343536373839public class ThreadTest implements Runnable &#123; int number = 10; public void firstMethod() throws Exception &#123; synchronized (this) &#123; number += 100; // 执行到这number=110 System.out.println(number); &#125; &#125; public void secondMethod() throws Exception &#123; // synchronized 保证原子性，代码只能被全部执行或不执行 synchronized (this) &#123; /** * (休息2S,阻塞线程) * 以验证当前线程对象的机锁被占用时, 是否被可以访问其他同步代码块 */ Thread.sleep(2000); // 输出 2100 //this.wait(2000); // 输出 110 number *= 200; &#125; &#125; @Override public void run() &#123; try &#123; firstMethod(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws Exception &#123; ThreadTest threadTest = new ThreadTest(); Thread thread = new Thread(threadTest); thread.start(); // 执行firstMethod() threadTest.secondMethod(); &#125;&#125; 12.5 线程池快速入门 创建一个线程池 下面表示创建一个：拥有线程个数为10、最多可增长至15，允许线程空闲60s后被回收，线程池。 123456import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;// 主函数中ThreadPoolExecutor threadPool= new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); ThreadPoolExecutor 类用于实现线程池，其创建多线程的构造函数原型如下： ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, RejectedExecutionHandler handler) corePoolSize ：表示线程池最低拥有的线程数 maximumPoolSize ：表示线程池最多可增长到线程数 keepAliveTime &amp; unit：表示线程空闲后的存活时间，超过后会被回收，最终保持池中10个线程 workQueue ：存放任务的阻塞队列 handler：当队列和最大线程池都满了之后的饱和策略 执行任务 通过 ThreadPoolExecutor 对象 execute() 方法执行任务，接受的参数为 Runnable 类型。 public void execute( Runnable command ) 1234567threadPool.execute(new Runnable()&#123; @Override public void run() &#123; System.out.println(&quot;执行任务&quot;); &#125;&#125;; DEMO : 遍历搜寻文件夹 🎉 对指定文件夹进行遍历搜寻，如果找到文件含有“黄旺辉”字样，就分配一个线程对该文件进行处理。 1234567891011121314151617181920212223242526272829303132333435363738import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.io.File;public class test&#123; public static void main(String[] args) throws InterruptedException &#123; // 1.创建线程池 ThreadPoolExecutor threadPool= new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); // 2.搜寻指定文件 t.searchFile(&quot;D:/hwh/uploadToGit/本科&quot;,threadPool); &#125; // 函数：搜寻指定文件 public void searchFile(String root, ThreadPoolExecutor threadPool) &#123; File f = new File(root); // 每个文件/文件夹都一定会被遍历到：所以可以在这里判断是否是文件 if (f.getName().contains(&quot;黄旺辉&quot;)) // 找到满足条件文件开始分配任务 &#123; // 设定任务 Runnable task = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;子线程在对指定文件执行任务：&quot; + f.getName()); &#125; &#125;; // 分配线程执行任务 threadPool.execute(task); return; &#125; //递归搜寻 for(File file : f.listFiles()) searchFile(file.getAbsolutePath(),threadPool); &#125;&#125; 第十三章：网络编程 13.1 基本知识 服务器和客户端通信 上图表示，服务器IP：192.168.1.100 ，客户端IP：192.168.1.189，它们分别通过各自的端口 8080、1087 和对方进行通信。 如何获取本机IP地址？ 通过java自带API 获取本机IP可以通过java自带的API，引用类：java.net.InetAddress 1234567891011121314import java.net.InetAddress;import java.net.UnknownHostException;try&#123; // 调用getLocalHost()，必须处理异常UnknownHostException InetAddress host = InetAddress.getLocalHost(); String ip = host.getHostAddress(); System.out.println(&quot;本机IP地址是：&quot; + ip);&#125;catch (UnknownHostException e)&#123; System.out.println(e.getMessage());&#125; cmd命令：ipconfig 1C:\\Users\\86151&gt; ipconfig ping 命令 通过java自带API 直接复制粘贴，需要时再看。 123456789101112131415161718192021222324import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader; public class TestSocket &#123; public static void main(String[] args) throws IOException &#123; Process p = Runtime.getRuntime().exec(&quot;ping &quot; + &quot;192.168.2.106&quot;); // 缓存流，建立在字符流之上 // InputStreamReader类继承字符流类Reader，可使得字节流向字符流转换 // 注意加上 &quot;gbk&quot;，否则执行的命令乱码 Reader reader = new InputStreamReader(p.getInputStream(),&quot;gbk&quot;); BufferedReader br = new BufferedReader(reader); String line = null; StringBuilder sb = new StringBuilder(); while ((line = br.readLine()) != null) &#123; if (line.length() != 0) sb.append(line + &quot;\\r\\n&quot;); &#125; System.out.println(&quot;本次指令返回的消息是：&quot;); System.out.println(sb.toString()); &#125;&#125; 通过cmd命令ping ping某个IP地址，这个IP是网关地址 1C:\\Users\\86151&gt; ping 192.168.0.1 ping一个主机名，如果能返回说明：DNS解析正确，且本机或本网和外部连接正确 1C:\\Users\\86151&gt; ping baidu.com 13.2 实战测试网络连通 观察本地网络设置是否正确： ipconfig /all 检测本地TCP/IP 协议：Ping 127.0.0.1 IP地址由两个部分组成，即网络地址和主机地址 ，（IPV4）长4个字节，32位。根据网络地址占的字节数不同，分为A、B、C三类及特殊地址D、E。全0和全1的都保留不用。 A类：第1个字节为网络号，后3个字节为主机号。最前面为“0”，所以地址网络号取值于1~126之间 。而保留的127（01111111）+ 0.0.1 就是 本地回送地址 ，一般用于测试。 本机回送地址（Loopback Address），即主机IP堆栈内部的IP地址，主要用于（1）网络软件测试 以及（2）本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回，不进行任何网络传输。 有返回接收则配置正确。 检查本地IP地址是否有误：ping 本机IP 参考：好文：ping到底做了什么？ 有返回接收则配置正确，否则要重新配置下。 检查硬件问题 &amp; 本机与本地网络连接是否正常（非局域网可忽略）：ping 本机网关IP 网关和路由器区别？ 网关设备：一个大概念，不具体特指一类产品，只要 连接两个不同的网络的设备都可以叫网关； 路由器：一般特指能够 实现路由寻找和转发的 特定类产品，路由器很显然能够实现网关的功能。 默认网关：不是一个产品而是一个网络层的概念，PC本身不具备路由寻址能力，所以PC要把所有的IP包发送到一个 默认的中转地址 上面进行转发，也就是默认网关。 可以在路由器、三层交换机上，可以在防火墙上，可以在服务器上，所以和物理的设备无关。 检查本网或本机与外部连接是否正常： Ping 远程IP地址 有些 IP是ping不通的，因为有防火墙或者其它设置，这里百度找了个能ping通的。 在5. 基础上检查DNS解析：ping 域名 如果可以ping通，则说明域名解析可正常运行。 13.3 网络编程通信实战 ​ 在13.1中介绍了服务器和客户端通过各自端口进行简单通信。本节通过实战编程，实现服务端和客户端简单交流对话。 如何编程实现通信？ ​ 通过套接字：{ IP地址，端口号 } ，Java 有封装好类 ServerSocket &amp; Socket ，进而通过套接字输入、输出流 实现通信。 服务端通过 ServerSocket 对象 ss打开端口； 客户端创建套接字 Socket 对象 socket 连接到服务端，并通过 套接字建立 输出流 进行数据传输； 服务端通过 ServerSocket 对象 ss.accept() 方法，返回 Socket 对象（客户端的？），通过 输入流 读数据； 服务端进行回应，并关闭服务。 编程实现 客户端 - Client 1234567891011121314151617181920212223242526272829303132333435363738package QQ;import java.io.IOException;import java.net.Socket;import java.io.OutputStream;public class Client&#123; Socket socket; /** * 构造函数：套接字初始化连接的主机和端口 * @param host 指定连接的主机 * @param post 指定连接的端口 */ public Client(String host,int post) throws IOException &#123; socket = new Socket(host,post); &#125; /** * 客户端发送指定消息 * @param clientMsg 要发送的消息内容 */ public void msg(String clientMsg) throws IOException &#123; // 1.建立[套接字字节输出流]对象发生消息 OutputStream os = socket.getOutputStream(); // 2.客户端发消息 // 注意String类型 --&gt; byte[] os.write(clientMsg.getBytes()); // 3.注意：客户端套接字必须要关闭，才开始连接服务端 socket.close(); &#125;&#125; Q1 : 为什么设计每个方法 t hrows IOException ？ A1: 因为创建套接字对象socket | 调用对象方法 ，都要处理 IOException 异常，每个方法写 try catch 太麻 烦，不如先抛出异常，在主函数中统一处理。 Q2 : 为什么msg() 方法发送完消息立马关闭套接字 socket.close() ，而不是等服务器接收了再关闭 ？ A1: 事实上，只有先关闭套接字socket.close() ，客户端才会开始连接服务端！ 服务端 - Server ⚠️ ServerSocket 对象 ss.accept() 方法，必须客户端建立连接之后，否则会一直阻塞！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package QQ;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.io.InputStream;public class Server&#123; ServerSocket ss; Socket socket; /** * 打开端口，建立套接字对象监听端口 * @param post 要打开的服务端端口 */ public Server(int post) throws IOException &#123; ss = new ServerSocket(post); &#125; /** * 关闭套接字连接 */ public void close() throws IOException &#123; ss.close(); socket.close(); &#125; /** * 服务端对客户发来的消息进行回应 */ public void response() throws IOException &#123; // 1.注意：客户端必须已经连接，否则会一直阻塞 socket = ss.accept(); // 2.建立[套接字字节输入流]，读取客户端发过来的消息 InputStream is = socket.getInputStream(); byte[] all = is.readAllBytes(); // 3.类型转换: 将byte[] ---&gt; String String clientMsg = new String(all); // 4.回应客户端 System.out.println(&quot;服务端回复-小白兔回道：&quot; + reMsg(clientMsg)); &#125; public String reMsg(String clientMsg) &#123; if(clientMsg.contains(&quot;你好&quot;)) &#123; return &quot;你好！我是小白兔。&quot;; &#125; else if (clientMsg.contains(&quot;沙雕&quot;)) &#123; return &quot;你才是沙雕！你全家都是沙雕！&quot;; &#125; else if (clientMsg.contains(&quot;你叫什么&quot;)) &#123; return &quot;my name is dad&quot;; &#125; else if (clientMsg.contains(&quot;我好烦呀~&quot;)) &#123; return &quot;放下得自在。&quot;; &#125; return &quot;风太大，没听清！&quot;; &#125;&#125; 主函数串联 123456789101112131415161718192021try&#123; // 服务端打开端口 Server server = new Server(8886); // 客户端连接端口 Client client = new Client(&quot;127.0.0.1&quot;,8886); Scanner s = new Scanner(System.in); System.out.print(&quot;客户端-大灰狼说道：&quot;); String clientMsg = s.nextLine(); // 客户端通过套接字输出流发生消息 client.msg(clientMsg); // 服务端通过套接字输入流进行回应 server.response(); server.close();&#125;catch (IOException e)&#123; System.out.println(e.getMessage());&#125; 第十四章：JDBC 14.1 JDBC 快速入门 什么是 JDBC？ JDBC 即 Java DataBase Connection ，是JAVA 的一个 API 通过 JAVA 访问数据库。 其一般执行流程如下： 连接数据源，如数据库 进行增删查改指令 处理响应并返回结果 下载 JDBC 官网下载驱动包 下载地址：Download Connector/J 选择：Platform Independent —&gt; mysql-connector-java-8.0.16.zip ，然后下载： 坑：下面还有一个下载MySQL Installer ，是下载 mysql 全家桶 ！ 解压 解压之后会在下载目录出现：mysql-connector-java-8.0.16 文件夹，里面有我们要的 jar 包： 引用包 在工程目录下新建一个文件夹：lib ，然后将 mysql-connector-java-8.0.16.jar 包复制到该目录下。 在IDEA中，右键选择该jar 包 --&gt; Add as Library ，即可添加成功。 更好的添加包方法点击：IDEA导入包两种方法 简单 DEMO mysqlDB 类 在 mysqlDB 类中主要有三个函数，负责执行操作数据库对应三个流程： mysqlDB() 连接数据库 🔈 最新 SQL 驱动： 1.加载驱动程序 这步可以省略。 123456789public mysqlDB(String url,String user,String passwd) throws Exception&#123; this.URL = url; this.USER = user; this.PASSWD = passwd; // 1.加载驱动程序 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 2.获取数据库连接 conn = DriverManager.getConnection(url,user,passwd); System.out.println(&quot;成功连接数据库！&quot;);&#125; crudDB() 增删查改 crudBOY 表演时刻：执行指定 sql 语句。 1234567public ResultSet crudDB(String sql) throws Exception&#123; // 3.操作数据库 Statement s = conn.createStatement(); ResultSet rs = s.executeQuery(sql); return rs;&#125; exit() 退出 Statement 对象应该也关闭，这里没。 1234public void exit() throws Exception&#123; conn.close();&#125; 主函数中 在主函数中串接所有流程，和数据库进行 Connection 连接需提供 url ： url = “jdbc:mysql://&lt;地址&gt;:&lt;端口&gt;/&lt;数据库名&gt;?serverTimezone=UTC” &lt;地址&gt;：这里选择本机地址，127.0.0.1 / localhost &lt;端口&gt;：mysql 专用端口，3360 &lt;数据库名&gt;：预先准备好的数据库，test ⚠️?serverTimezone=UTC ：新版驱动器出现的问题，要指定 time zone value 。 123456789101112131415161718192021222324252627282930import JDBC_demo.mysqlDB;import java.sql.ResultSet;public class hello&#123; public static void main(String[] args) &#123; try &#123; final String url = &quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;; final String user = &quot;root&quot;; final String passwd = &quot;123456&quot;; String sql = &quot;SELECT * FROM student WHERE gender = &#x27;F&#x27;;&quot;; // 连接数据库--执行sql语句 mysqlDB mdb = new mysqlDB(url, user, passwd); ResultSet rs = mdb.crudDB(sql); // 读取指定列名数据 while(rs.next()) &#123; System.out.println(rs.getString(&quot;name&quot;) + rs.getInt(&quot;score&quot;)); &#125; mdb.exit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; mysqlDB 类完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package JDBC_demo;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;public class mysqlDB&#123; final String URL ; final String USER ; final String PASSWD ; Connection conn; /** * 构造函数：进行初始化和数据库连接 * @param url jdbc:mysql://127.0.0.1:3306/&lt;数据库名&gt; * @param user mysql账号 * @param passwd mysql密码 */ public mysqlDB(String url,String user,String passwd) throws Exception &#123; this.URL = url; this.USER = user; this.PASSWD = passwd; // 1.加载驱动程序 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 2.获取数据库连接 conn = DriverManager.getConnection(url,user,passwd); System.out.println(&quot;成功连接数据库！&quot;); &#125; /** * 执行增删查改 * @param sql 要执行的sql语句 */ public ResultSet crudDB(String sql) throws Exception &#123; // 3.操作数据库 Statement s = conn.createStatement(); ResultSet rs = s.executeQuery(sql); return rs; &#125; public void exit() throws Exception &#123; conn.close(); &#125;&#125; 14.2 查询技巧 ​ 因为，增、删、改并不需要处理返回的数据，比较简单就是执行sql 语句即可。但是查询较为复杂，这里来通过几个查询实例，来进一步熟悉 JDBC API。 验证用户登陆 student 表中没有设置密码字段，所以下面只验证了名字，简单表达意思。 123456789101112131415161718192021222324252627282930import JDBC_demo.mysqlDB;import java.sql.ResultSet;public class hello&#123; public static void main(String[] args) &#123; try &#123; final String url = &quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;; final String user = &quot;root&quot;; final String passwd = &quot;123456&quot;; String sql = &quot;SELECT * FROM student WHERE name = &#x27;&#x27;&quot; + &quot;刘婷&#x27;&quot;; // 连接数据库--执行sql语句 mysqlDB mdb = new mysqlDB(url, user, passwd); ResultSet rs = mdb.crudDB(sql); // 进行判断 if(rs.next()) // re.next() 返回的是bool类型，没有找到数据返回false System.out.println(&quot;账号密码正确&quot;); else System.out.println(&quot;账号密码错误&quot;); mdb.exit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 拼接字符串有个坑，要注意给字符串类型&quot;刘婷&quot;加上单/双引号： 1String sql = &quot;SELECT * FROM student WHERE name = &#x27;&#x27;&quot; + &quot;刘婷&#x27;&quot;; 获取总数 123456789101112131415161718192021222324252627282930import JDBC_demo.mysqlDB;import java.sql.ResultSet;public class hello&#123; public static void main(String[] args) &#123; try &#123; final String url = &quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;; final String user = &quot;root&quot;; final String passwd = &quot;123456&quot;; String sql = &quot;SELECT count(*) FROM student WHERE gender = &#x27;F&#x27;&quot;; // 连接数据库--执行sql语句 mysqlDB mdb = new mysqlDB(url, user, passwd); ResultSet rs = mdb.crudDB(sql); // 进行判断 rs.next(); // 读取下一行数据，这里是第一行 int girl_num = rs.getInt(1); // 获取第一列第一行数据 System.out.println(&quot;女生总数为：&quot; + girl_num ); mdb.exit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; rs.next() : 读取下一行数据，如果下一行数据不存在返回 false ； 输出结果： 12成功连接数据库！女生总数为：5 14.3 再谈 Statement &amp; eceute() 预编译 Statement Statement 弊端 在前面，我们知道 Statement 对象主要用于执行 sql 语句： 1234567public ResultSet crudDB(String sql) throws Exception&#123; // 3.操作数据库 Statement s = conn.createStatement(); ResultSet rs = s.executeQuery(sql); return rs;&#125; 但是，有以下几个弊端： 只能执行完整sql 语句，不能对 sql 语句进行模板化修改； 易遭受 sql 注入攻击，比如在前面我们拼接查询，是否存在用户sql 语句： 1String sql = &quot;SELECT * FROM student WHERE name = &quot; + name; // name 由用户输入 如果用户输入‘刘婷’ OR 1=1 ,而非 刘婷 ，那么拼接语句为： 1SELECT * FROM student WHERE name = &#x27;刘婷&#x27; OR 1=1; 如果用户表有100万条数据，那么显然会耗光内存，让数据库负载过高。 PreparedStatement PreparedStatement 和 Statement 都是用来执行 sql 语句。不同是PreparedStatement 可以通过 ？ 来预留sql 语句编辑位置，而非直接拼接。 下面展示重新封装crubDB() 方法为 *identityUser()*验证用户(同前只验证姓名)： 12345678910import java.sql.PreparedStatement; // 注意要引用PreparedStatement public ResultSet identityUser(String sql, String userName) throws Exception&#123; // 3.操作数据库 PreparedStatement ps = conn.prepareStatement(sql); ps.setString(1, userName); ResultSet rs = ps.executeQuery(); return rs;&#125; 在主函数中，调用如下： 12345678910111213141516171819202122232425262728import JDBC_demo.mysqlDB;import java.sql.ResultSet;public class hello&#123; public static void main(String[] args) &#123; final String url = &quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;; final String user = &quot;root&quot;; final String passwd = &quot;123456&quot;; String sql = &quot;SELECT * FROM student WHERE name = ?&quot;; // 连接数据库--执行sql语句 mysqlDB mdb = new mysqlDB(url, user, passwd); ResultSet rs = mdb.identityUser(sql,&quot;刘婷&quot;); // 进行判断 if(rs.next()) // re.next() 返回的是bool类型，没有找到数据返回false System.out.println(&quot;正在登陆...&quot;); else System.out.println(&quot;用户不存在！&quot;); mdb.exit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 注意，sql语句 不用给 ？ 代表的字符串类似加上单/双引号，会出错： 1String sql = &quot;SELECT * FROM student WHERE name = &#x27;?&#x27;&quot;; // 错误写法 因为，ps.setString(1, userName); 方法会自动设置好。 三种不同eceute 执行 sql 语句，通常头三种方法：eceute() &amp; executeUpdate() &amp; executeQuery() ，它们都是 Statement 对象方法，主要有以下区别。 返回值不同 eceute() 用来执行 sql 语句： 12Statement s = conn.createStatement();boolean rs = s.execute(sql); // 返回bool类型，判断执行是否成功 executeUpdate() &amp; executeQuery() 相似，但是三者返回值不同： 1int number = s.executeUpdate(sql); // 返回int类型，有多少语句被影响 1ResultSet rs = s.executeQuery(sql); // 返回ResultSet类型，可以查询返回数据 是否支持查询语句 executeUpdate() 可以进行 增、删、改： 123s.executeUpdate(sqlInsert); // 执行INSERT插入数据s.executeUpdate(sqlDelete); // 执行DELETE删除数据s.executeUpdate(sqlUpdate); // 执行UPDATE更新数据 但是不能查询表： 1s.executeUpdate(sqlSelect); // 出错：执行SELECT查询数据 executeQuery() 一般用于查询语句 ，进行其它更新操作会报错： java.sql.SQLException: Can not issue data manipulation statements with executeQuery(). execute() 没有限制可以进行：增、删、改、查 。 14.4 特殊操作 &amp; 事务 特殊操作 未展开讲，用到可查询：特殊操作 这里的特殊操作包括两种： 获取自增长id：如果表中id为AUTO_INCREMENT，无论是*execute()还是executeUpdate()*都不会返回自增长id。 获取表元数据：诸如，数据库服务器版本，驱动版本，都有哪些数据库等等 事务 为什么要使用事务，不在赘述，同 MySQL笔记，这里主要展示 JDBC 如何使用事务。 ⚠️ 支持事务前提：当前MySQL服务器本身要支持INNODB, 同时表类型为 INNODB 。 支持事务 在当发现无法执行事务时，再进行以下修改。 设置表类型为 INNODB 1ALTER TABLE teble_name ENGINE = innodb; 设置服务器支持 INNODB mysql 从 5.5 版本已将 innoDB 作为默认存储引擎。 点击查看： 开启MYSQL INNODB的办法 事务实例 在事务中的多个操作，要么都成功，要么都失败。 在 JDBC 中，主要是取消excute() 等之后 自动 提交，改为 手动 提交所有操作。 12345678910111213141516171819202122232425262728293031import JDBC_demo.mysqlDB;import java.sql.ResultSet;public class hello&#123; public static void main(String[] args) &#123; final String url = &quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;; final String user = &quot;root&quot;; final String passwd = &quot;123456&quot;; String sql = &quot;UPDATE student SET score = score + ? WHERE name = ?&quot;; // 连接数据库 mysqlDB mdb = new mysqlDB(url, user, passwd); PreparedStatement ps = mdb.conn.prepareStatement(sql); // 事务：刘婷+10分，小白-10分 mdb.conn.setAutoCommit(false); // 取消自动提交 ps.setInt(1, 10);ps.setString(2, &quot;刘婷&quot;); ps.executeUpdate(); // 看下面错误解析 ps.setInt(1, -10);ps.setString(2, &quot;小白&quot;); ps.executeUpdate(); mdb.conn.commit(); // 手动提交 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; ⚠️ 调试半小时犯的2个错误，有关： ps.executeUpdate(); 用ps.executeQuery() ，提示 ：Cannot issue data manipulation statements with executeQuery() 原因：executeQuery() 适用于 SELECT ，用户更新等操作会报错。 添加参数sql：ps.executeQuery(sql) ，在前面创建 PreparedStatement 对象已给参数 sql ，再添参数会出现解析错误。 14.5 数据库线程池(待)","categories":[{"name":"Java","slug":"Java","permalink":"https://hwh.zone/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://hwh.zone/categories/Java/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hwh.zone/tags/Java/"}]},{"title":"Git基础笔记","slug":"Git基础","date":"2021-11-25T09:17:16.561Z","updated":"2021-11-26T16:13:36.694Z","comments":true,"path":"2021/11/25/Git基础/","link":"","permalink":"https://hwh.zone/2021/11/25/Git%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一、Git 简介 1.1 安装 安装地址 官网下载：Git官网下载 设置用户信息 主要是设置 ： 名字 &amp; Email 地址。 12$ git config --global user.name &quot;hwh&quot;$ git config --global user.email &quot;380141202@qq.com&quot; git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 1.2 创建版本库 创建仓库 ​ windows可以直接在桌面创建一个名为：&quot;Git&quot;文件夹，下有“test”子文件夹，子文件夹含有一个名为“readme.md”文件。 ​ 然后切换到其目录下（这里切换的是&quot;Git&quot;文件夹，而非“test”子文件夹） 123$ cd Git/$ pwd/c/Users/86151/Desktop/Git 初步提交过程 初始化仓库 12$ git initInitialized empty Git repository in /Users/michael/learngit/.git/ 修改仓库文件 将“test”子文件夹，下readme.md文件，增加内容。 添加文件到仓库 注意：可以同时 一次添加多个文件到仓库！ 1$ git add test/readme.md 提交文件 可以增加m参数：添加修改信息 1$ git commit -m &#x27;第一次文件改动&#x27; 二、时光机穿梭 2.0 更多控制修改提交 概览 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff &lt;filepath&gt;可以查看修改内容。 实操 再次修改文件 可以先清除原文件，再增添readme.md文档内容 ： 123“i am huitailang , here is my first test word .“ “这是我第二次修改这个文件” 使用 git status，查看状态发现readme.md文件已被修改但未提交（no changes） 1$ git status 查看具体修改了什么内容 git diff &lt;filepath&gt;查看文件具体修改， 1$ git diff test/readme.md 添加仓库 1$ git add test/readme.md 同时可用 git status，查看此时状态会显示，readme.md将要被提交修改。 提交仓库 1$ git commit -m &quot;这是我第二次修改&quot; ​ 再用 git status，查看仓库当前状态，显示没有需要提交的修改，而且工作目录是干净的（working tree clean）。 2.1 版本回退 概览 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本 实操 N次修改文件 先多修改几次文件提交，得到多个版本。 版本回退 查看版本历史 git log 查看当前版本和之前的历史，git relog 查看所有版本历史 1$ git log # 可以加上 --pretty=oneline 参数使显示更简洁 回退版本 git reset --hard &lt;指定版本&gt;：可用于回到指定版本，&lt;指定版本&gt;方式： HEAD ^ HEAD ^ 回到上个版本；HEAD ^ ^ 回到上上 个版本，依此类推。 1$ git reset --hard HEAD^^ # 回到上上个版本 HEAD~&lt;数字&gt; 回到前&lt;数字&gt;版本。如HEAD~100，回到前100个版本。 : commit ID 不用打全，一般打前面几个字符即可。如，如果回退第2版本，git log，只能看到第2版本及之前的版本信息。那么可用 git reflog查看所有版本ID，然后指定ID，回到第4版本。 1$ git reflog 12$ git reset --hard 3928d # 再次回到第四次修改版本HEAD is now at 3928d9f 第四次修改 2.2 工作区和暂存区 概览 理解工作区和暂存区的区别，暂存区是版本库的一个子集 比较文件有三个不同命令 git diff git diff --cached git diff --HEAD 工作区 工作区就是我们能看到的目录，如我前面创建的Git文件夹就是一个工作区 版本库 &amp; 暂存区 工作区有一个隐藏目录.git，不属于工作区而是Git版本库，版本库包含 Git自动创建的分支master&amp;指向master的指针HEAD stage（或叫index）暂存区 暂存区工作 git add 这一步实际上就是把文件修改（已存在被修改 OR 新文件）添加到暂存区，可以add多个文件，一次被提交。 git commit 把暂存区的所有内容提交到当前分支。 但是注意，git commit 后暂存区文件不会消失，始终是上一次git add之后文件！ git diff &amp;git diff --cached &amp;git diff HEAD git diff 比较的是工作区文件和暂存区文件区别。 git diff --cached 比较的是暂存区文件和仓库分支文件区别。 git diff --HEAD 比较的是工作区文件和仓库分支最新版本区别。 暂存区：就是 .git / index 这个文件，git add 会把工作区修改的文件添加到暂存区，即使 git commit 后也不会空，始终保存最近一次 git add后的内容。 仓库分支：始终保存上次git commit 内容。 2.3 管理修改 概览 git管理的是修改，而非文件 实操 新建一个文件 readme1.txt，然后依次： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit ​ 用git diff HEAD test/readme1.txt 比较工作区和版本分支，会发现第二次修改没有被提交，说明git只把git add后暂存区内容提交了，而不管理文件。 如果要把第二次修改也提交了，需要进行以下操作： 第一次修改 -&gt; git add -&gt; 第二次修改-&gt; git add -&gt; git commit 2.4 撤销修改 概览 场景1：改乱了工作区某个文件的内容，想直接丢弃工作区的修改时 用命令git checkout -- file。 场景2：不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改 第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1 第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交 参考版本回退一节，不过前提是没有推送到远程库。 实操 场景1 不小心在文件里增加了一句话： 刘婷是傻子 用 git checkout命令撤回工作区修改，有两种情况 readme.txt修改但未被放到暂存区，撤销修改就回到和版本库一样状态； readme.txt修改且添加到暂存区后，撤销修改就回到添加到暂存区后的状态。 ⚠️ 总之，就是让文件回到最近一次git commit或git add时的状态。 🕵所以，也可用于恢复误删的文件（撤销工作区删除操作） 1git checkout -- test/readme.md 场景2 不小心在文件里增加了一句话，而且已经git add提交到暂存区 刘婷是傻子哈哈哈 命令git reset 不仅可以回退版本 而且可以把暂存区的修改撤销。 ⚠️之所以不直接 git checkout 是因为此时会用暂存区内容覆盖工作区，显然不行。 1git reset HEAD test/readme.md # HEAD表示最新版本 然后此时再用git checkout ，暂存区内容覆盖工作区 1git checkout -- test/readme.md 再次查看文件发现，‘’刘婷是傻子哈哈哈‘’ 的胡话已经被没了，暂存区也没了。 场景3 又说胡话，不但 git add 且git commit（暂存区和版本库HEAD都是修改后版本） 刘婷是傻子哈哈哈哈哈哈 这个时候只有回退版本了 1$ git reflog # 查看版本号 12$ git reset --hard 3928HEAD is now at 3928d9f 第四次修改 2.5 删除文件 rm 删除 原理 rm 删除文件，只相当于删除了 工作区文件，如果要恢复文件撤销工作区修改即可。 1rm test/readme.md 恢复 用git checkout -- &lt;file&gt;，它会用最新版本库文件（如果已经git add 用最新暂存区内容，见前）覆盖工作区文件，则相当于撤销工作区修改 1git checkout -- test/readme.md git rm 删除 原理 git rm 删除文件，不但相当于删除工作区文件 &amp; 而且git add添加到暂存区。 所以此时直接git checkout 是用暂存区内容覆盖 工作区，显然是没用的。 恢复 先恢复暂存区 1git reset HEAD test/readme.md # HEAD表示最新版本 再用暂存区覆盖工作区 1git checkout -- test/readme.md 彻底删除 如前所述，git rm 已经删除了 ①工作区文件 ② 添加到暂存区，那么此时只需要 1git commit --m &#x27;彻底删除&#x27; # 将③版本库内容也修改 那么文件就会从工作区、暂存区、版本库全部删除。 彻底删除恢复 如果已经commit，那么只能git reset回退版本 12$ git reset --hard 3928HEAD is now at 3928d9f 第四次修改 三、远程仓库 3.1 添加远程库上传本地文件 以下操作基于默认你 创建好 github 账号 &amp; 创建好一个仓库 设置好本地ssh -key 而且已经同时在github网页服务端账号设置里添加 ssh -key 添加用户信息 12$ git config --global user.name &quot;hwh&quot;$ git config --global user.email &quot;380141202@qq.com&quot; 初始化本地仓库 如果本地仓库从未被初始化才需要，初始化会创建一个隐藏的 .git 文件管理版本。 cd切换 + git init cd命令切换到后本地仓库； git init 初始化本地仓库，会为你创建一个 .git文件，已经初始化不用。 手动 bash ⚠️ 很奇怪的是，这样 git add . --&gt; git commit --&gt; git push后，会把整个父文件夹推送上去。 比如：地址 TEST 文件夹下有 README.md ，推送后github上显示的 TEST文件夹，而不是我想的README.md文件。 右击本地仓库，选择Git Bash here 把本地仓库添加到版本库 12$ git add . # add . 提交所有新建、修改文件$ git commit -m &#x27;第一次添加本地仓库到版本库&#x27; 本地仓库关联远程库 git remote add &lt;远程库名设置&gt; &lt;远程仓库地址&gt; 显然这里把远程仓库地址设置为 origin。 1$ git remote add origin git@github.com:huangwanghuiYY/gitTest.git 推送到远程库 下面代码表示：将本地master分支推送到远程仓库origin。 1$ git push -u origin master # 第一次推送带 -u 参数 -u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。 1$ git push origin master 3.2 从远程库克隆 ​ 当我们想多人协作时会用到克隆。比如有一个不错的开源项目，你可以克隆到本地仓库进行修改等。 确定要克隆的仓库 比如我的XSurvey项目。 git clone 进行克隆 克隆会在当前文件夹创建克隆的仓库，克隆仓库以XSuery为名，下含项目文件。 1$ git clone git@github.com:huangwanghuiYY/XSurvey.git 四、分支管理 4.1 创建和合并分支 这一节，涉及大量图形，廖雪峰教程 讲的很好，这里尽量精简记录心得。 概述 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 实操记录 主分支 ​ master分支也是一条时间线，每次提交 master 分支都会向前移动一步，随着不断提交 master分支也就越长。 ⚠️下图有两个指针：HEAD &amp; master ，HEAD严格来说不是指向提交。HEAD指向master，master指向最新分支。 新分支创建切换 创建新分支 1234$ git branch dev1 # 新建分支$ git branch # 查看分支 dev1* master # * 表示当前所在的分支（master） ​ 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master指向的提交。 切换到当前分支 1$ git checkout -b dev1 如果checkout 加上 -b参数，表示 创建 &amp; 切换两个操作 1$ git checkout dev1 切换到当前分支，其实把head指向master所指向的提交。 ⚠️这张图，还表示dev分支还执行了一次提交。 合并分支 12$ git checkout master # 先切回master分支（即HEAD指向master）$ git merge dev1 # 表示当前分支（master）合并 dev1分支 根据上图我们可以看到： ​ dev分支向前走了一步，dev指向了当前最新提交，而master指针依然指向上次提交。 ​ 如果要合并，那么直接让master指向dev指向的当前提交 。相当于，master也提交过一次。 删除分支 12$ git branch -d devDeleted branch dev (was b17d20e). ​ 删除分支，等价于删除创建分支后的提交记录（上图红色线），但由于master指向了最新提交，等价复制dev1的提交记录（蓝色线）。 ​ 4.2 解决同时修改冲突 产生冲突原因 在master分支上 在当前master分支上，创建一个新分支 dev2 同时master分支上，对README.md文件增加一句话 i said master ⚠️ 然后，git add --&gt; git commit 在dev2分支上 checkout切回master分支上，对README.md文件增加一句话 i said dev2 ⚠️ 然后，git add --&gt; git commit 合并 12$ git checkout master$ git merge dev2 显示，README.md文件同时被修改，发生冲突（也可用 git status 查看） vim 查看文件显示具体冲突： 1$ vim README.md #当前HEAD指向master，所以下图显示HEAD 解决冲突 Ⓜ️此时两个README.md已经是一个文件了，文件内容就是上图vim查看的所有内容 。 我们再命令行端口也可以看到，提示我们在 master|MERGING 合并中。 ​ 我们打开文件，修改文件内容为：（第一句话有误，此时实在master分支上，不用在意） 这是的dev分支，我增加了一句话 修改冲突，这里变成这样。其实不修改直接提交也解决冲突，只是没解决同时修改。 然后再提交，发现冲突已经解决： 12$ git add README.md $ git commit -m &#x27;解决冲突&#x27; 4.3 分支管理策略 – 禁用Fast forward 概览 通常，合并分支时，如果可能，Git会用Fast forward模式，则直接把 master 的指针直接指向了 dev 分支的最新提交，这样两个分支的最新提交的 commit id 就是一样的。但这种模式下，删除分支后，会丢掉分支信息。 加上--no-ff参数，强制禁用Fast forward模式，使用普通模式。Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 实操 默认已经创建好分支 dev3，且修该了文，进行了一次commit。 然后下面都是在 master分支上尝试合并操作 切回master 1$ git checkout master 合并分支 –no–ff ： 普通模式合并。 -m ：由于本次合并dev要创建一个新的commit，所以加上-m参数，添加描述。 1$ git merge --no-ff -m &quot;merge with no-ff&quot; dev 查看历史 123456$ git log --graph --pretty=oneline --abbrev-commit* e1e9c68 (HEAD -&gt; master) merge with no-ff|\\ | * f52c633 (dev) add merge|/ * cf810e4 conflict fixed Fast forward模式 &amp; 普通模式 对比 FF模式不用--no-ff，实际上只是将master的指针update成dev分支而已。用的还是dev的commit ID。 普通模式用，则是重新commit一次，有了新的commit ID，保留了分支版本记录。 Fast forward模式 普通模式 4.4 BUG分支—git stash 概览 ​ 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； ​ 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 实操（应用场景） master 上面发布的是A的1.0版本 dev 上开发的是A的2.0版本 ，刚刚新建了test文件 &amp;修改README.md： 这里是dev分支。 这时，用户反映 1.0版本存在漏洞，有人利用这个漏洞开外挂 需要从dev切换到master去填这个漏洞，正常必须先提交dev目前的工作，才能切换。 如果不commit切换分支： 1$ git checkout master 发现当前工作目录，是dev分支工作目录！ 解释1 一个本地的git repo只有一个工作区和暂存区，但是有多个分支的提交区，而我们的checkout只是将HEAD指针从一个分支切换到另一个分支。 所以： 切换后工作区内容是branch的工作内容 经过测试，如果切回dev分支，进行add --&gt; commit 再切回master就回到 master工作区。 而dev的工作还未完成，不想提交，所以先把dev的工作stash一下，然后切换到master： 先git add test ⚠️ 为什么要先add test文件？ test文件是新建，还未被git管理！让git add追踪test文件，否则即使 git stash ，test文件也依然会出现在master工作目录中！ 1$ git add test git stash 然后切换 12$ git stash$ git checkout master 恢复dev工作目录 简单恢复： 1$ git stash pop # 恢复的同时把stash内容也删了 有多个因此目录，可以配合下面目录恢复： 123$ git stash list stash@&#123;0&#125;: WIP on dev: f52c633 add merge$ git stash apply stash@&#123;0&#125; # 恢复不会删除stash内容 在master建立分支issue101并切换。 在issue101上修复漏洞。 修复后，在master上合并issue101 。 切回dev，恢复原本工作，继续工作。 4.5 删除分支 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。 4.6 多人协作 查看分支 1$ git remote -v # 带-v参数查看更加详细 push 推送分支 git push &lt;远程库名&gt; &lt;要推送分支名&gt; ​ 推送本地主分支master到 origin master，相当用本地master版本覆盖远程origin master版本。 ⚠️ git push 只能用户该项目属于自己的情况，因为要输入账号密码！参与他人开源： 成为该开源项目贡献者（由项目作者设置） fork 该项目 ----&gt; clone到本地----&gt; 修改 ----&gt; 发起 pull requset —&gt; 讨论 &amp; 等待合并 还有其他更多情况，如产生冲突等，查看：pro git 中文# 对项目做出贡献 1$ git push origin master 推送其他分支到远程库 ，也可以查看。 1$ git push origin dev clone 克隆分支工作 多人协作时，大家都会往远程库master和dev分支上推送各自的修改。 克隆主分支 ⚠️ 克隆只能克隆master分支！！ 现在，模拟你的小伙伴，在另一台电脑（注意要把SSH Key添加到GitHub）克隆： 1$ git clone git@github.com:michaelliao/Python-100-Days 克隆远程dev分支开发 由于只能克隆master分支，而又要在远程dev分支开发，那么： 1$ git checkout -b dev origin/dev 之后就可进行修改 —&gt; 提交 ：git push了 git pull 一种应用情况：A、B都克隆了项目，在远程分支dev上进行开发（分别在本地也克隆dev分支） A修改了文件 README，并进行了push提交 。 你也修改了README，进行提交修改，会出错，原因是 ⚠️远程分支比你的本地更新！ 只有先 pull 最新分支你的分支合并 —&gt; 解决冲突—&gt;提交 git pull命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并，它的完整格式稍稍有点复杂。 在默认模式下，git pull是git fetch后跟git merge FETCH_HEAD的缩写。 git pull == git fetch+ git merge （默认是检索头部合并到当前分支） ⚠️ 使用–rebase，它运行git rebase而不是git merge。 1$ git pull&lt;可选参数&gt; &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 示例 比如，要取回origin主机的next分支，与本地的master分支合并： 1$ git pull origin next:master 省略当前分支名 如果远程分支(next)要与当前分支合并，则冒号后面的部分可以省略。上面命令可以简写为： 1$ git pull origin next 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再执行git merge。 12$ git fetch origin$ git merge origin/next 省略远程分支名 某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。 Git也允许手动建立追踪关系，指定master分支追踪origin/next分支： 1$ git branch --set-upstream master origin/next 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。 1$ git pull origin 上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”(remote-tracking branch)进行合并。 省略远程主机名 如果当前分支只有一个追踪分支，连远程主机名都可以省略。 1$ git pull git fetch和git pull的区别 git fetch：相当于是从远程获取最新版本到本地，不会自动合并。 123$ git fetch origin master$ git log -p master..origin/master$ git merge origin/master 以上命令的含义： 首先从远程的origin的master主分支下载最新的版本到origin/master分支上 然后比较本地的master分支和origin/master分支的差别 最后进行合并 上述过程其实可以用以下更清晰的方式来进行： 123$ git fetch origin master:tmp$ git diff tmp $ git merge tmp git pull：相当于是从远程获取最新版本并merge到本地 1git pull origin maste 五、标签管理 5.1 创建标签 5.2 操作标签 六、使用Github 6.1 简单上传 设置用户信息 12$ git config --global user.name &quot;hwh&quot;$ git config --global user.email &quot;380141202@qq.com&quot; git init 初始化仓库 1$ git init 本地创建ssh key 1$ ssh-keygen -t rsa -C &quot;380141202@qq.com&quot; # 后面会要求设置密码可不设置 然后会在：C:\\Users\\80651\\.ssh 生成ssh key 文件，其下有一个公钥 id_rsa.pub，记事本打开复制。 打开github设置 打开github 在个人设置中添加**2.**中ssh key。 可用 ssh -T查看是否成功 1$ ssh -T git@github.com 对文件一些操作 比如，这里以增加一个README文件，然后git commit 提交到版本库。 12$ git add README # 也可add . 提交所有新建、修改文件$ git commit -m &#x27;增加readme&#x27; push 上传到版本库 1$ git push origin master Q : git push 出现错误 ‘’ error: failed to push some refs to git‘’ A : 一般是因为github中的README.md文件不在本地代码目录中 添加 -f 参数强制覆盖 1git push -f origin master 通过如下命令进行github与本地代码合并: 12$ git pull --rebase origin master # 先和本地代码合并$ git push # 然后再上传 6.2 参与开源项目 可参考：GitHub的Pull Request 是指什么意思 七、自定义Git 服务器端安装Git 1$ yum install git 创建用户 &amp; 组 管理仓库目录 12$ groupadd git$ useradd git -g git # -g 参数表示把用户gituser主组设置为 git 创建目录 我们先创建一个目录gitrepo用来管理其下仓库，一般习惯在 /var下创建。 12$ cd /var$ mkdir gitrepo 给其设置好用户 &amp; 组，便于管理 1$ chown -R gituser:git gitrepo # 把目录gitrepo 设置用户gituser &amp; 组 git ls -l 查看是否设置成功： 创建仓库 创建hwhComputer2Backup.git仓库，并初始化用来上传电脑备份。 12$ cd gitrepo # 注意先切换到git下$ git init --bare hwhComputer2Backup.git 创建证书 在本地电脑上 执行以下命令创建ssh 公钥。会在：C:\\Users\\80651\\\\.ssh 生成ssh key 文件，其下有一个公钥 id_rsa.pub。 1$ ssh-keygen -t rsa -C &quot;380141202@qq.com&quot; # 后面会要求设置密码可不设置 切回服务端 裸机需创建/home/git/.ssh/authorized_keys文件。 123$ cd gitrepo/$ mkdir .ssh$ touch .ssh/authorized_keys 然后把本地电脑上公钥复制导入，一行一个（？） 1$ vim .ssh/authorized_keys 再次修改权限 创建的子目录 用户 &amp; 组 默认是 root root ⚠️由于.ssh &amp; 仓库 hwhComputer2Backup.git 都不属于 gituser ，所有还需设置权限。否则进行 push pull 操作 没有足够权限。 12$ cd /var$ chown -R gituser:git gitrepo 本地上传文件 添加用户信息 12$ git config --global user.name &quot;hwh&quot;$ git config --global user.email &quot;380141202@qq.com&quot; 初始化本地仓库 12$ cd D:/hwh/uploadToGit$ git init 把本地仓库添加到版本库 错误：c#程序练习 does not have a commit checked out 解决：是因为 c#程序练习 这个文件夹已经被初始化，查看隐藏文件可以发现 .git文件删除其即可。 12$ git add . # add . 提交所有新建、修改文件$ git commit -m &#x27;第一次备份文件&#x27; 本地仓库关联远程库 移除当前远程连接： 1git remote remove origin git remote add origin &lt;服务端用户名&gt;@&lt;远程库名地址&gt;:&lt;远程仓库地址&gt; ⚠️&lt;服务端用户名&gt; : 是在服务端的用户！ 1$ git remote add origin gituser@129.28.154.240:/var/gitrepo/hwhComputer2Backup.git 推送到远程库 似乎由于 ssh key 设置不对，git push 要输入用户 gituser 的密码 123456？ 1$ git push -u origin master # 第一次推送带 -u 参数 等待上传服务器(速度有点慢)： 八、debug 记录 ERROR：由于存在 &gt;100M 文件，提交后报错，不允许提交超过100M 文件，进行如下操作： 压缩并删除&gt;100M文件 将相应文件加入 .gitignore 再次commit --&gt; push 依旧报相同错误。 解决办法如下，参考：Fixing the “GH001… 删除文件 建议可以先回退最近的commit 分支 利用以下命令删除所有在仓库中 &gt;100M 的文件： 1git filter-branch -f --index-filter &#x27;git rm --cached --ignore-unmatch &lt;大于100M文件URL&gt;&#x27; 例如，我的例子： 1git filter-branch -f --index-filter &#x27;git rm --cached --ignore-unmatch Experiment/Ex4_CustomerForecast/src/train.csv&#x27; 再次提交 为了保险，可以先： 1git rm -r --cached ./ # 本地代码不会被删除 接下来正常：git add --&gt; git commit --&gt; git push 即可","categories":[{"name":"Git","slug":"Git","permalink":"https://hwh.zone/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://hwh.zone/tags/Git/"}]},{"title":"深度学习基础（三）OpenCV","slug":"深度学习基础（三）OpenCV","date":"2021-11-25T09:08:54.544Z","updated":"2021-11-26T09:21:48.182Z","comments":true,"path":"2021/11/25/深度学习基础（三）OpenCV/","link":"","permalink":"https://hwh.zone/2021/11/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89OpenCV/","excerpt":"","text":"一、初识OpenCV 使用以下命令可以一键安装 OpenCV ： 1conda install -c menpo opencv 1.1 环境搭建 简单测试是否搭建成功OpenCV： 1234567891011import cv2 as cv# 1.测试打开图片src = cv.imread(&quot;C:/Users/86151/Pictures/1571142354306.png&quot;)# 打开一个名为“test”的窗口（不知道有什么用？）cv.namedWindow(&quot;test&quot;,cv.WINDOW_AUTOSIZE) # 打开指定路径图片cv.imshow(&quot;111&quot;,src)cv.waitKey(0) # 等待用户输入关闭图片，这里好像任意键关闭cv.destroyAllWindows()print(&quot;hello opencv!&quot;) 1.2 图像加载和保存 1.2.1 图片：读取+基本属性 显示图片同时打印一些基本信息。 123456789101112131415# 2.读取图片：中文路径好像会报错imageSrc = r&quot;C:/Users/86151/Pictures/1571142354306.png&quot;image = cv.imread(imageSrc)# 显示图片和基本信息cv.imshow(&quot;hwh&quot;,image)cv.waitKey(0)print(type(image)) # &lt;class &#x27;numpy.ndarray&#x27;&gt;print(image.shape) # (278, 1068, 3),依次对应：宽、高、通道数print(image.size) # 890712 = 278*1068*3print(image.dtype) # uint8,每个像素基本单元？# 保存图片cv.imwrite(&quot;D:/result.png&quot;,image) 图片使用 cv.imread 读取后三位 numpy 数组，例如 image[0,0,0] 索引第一个像素值。 栗子1：将图片RGB三通道进行拆分、合并分别展示。 首先我们可以利用 cv.split() 将图片进行分隔： 12345678910image = cv.imread(r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;)# cv.split：将图片分割为BGR三通道b,g,r = cv.split(image)cv.imshow(&#x27;r&#x27;,r)cv.imshow(&#x27;g&#x27;,g)cv.imshow(&#x27;b&#x27;,b)# cv.merge：合并成RGB（不是BGR）图像rgb = cv.merge([r,g,b])cv.imshow(&#x27;rgb&#x27;,rgb) 其它：numpy创建图片 12345# 创建一张三通道黑色图片：255*255*3image = np.zeros((255,255,3),np.uint8) # 每个像素值都占一个字节（0-255）cv.imshow(&#x27;black&#x27;,image)cv.waitKey(0) 1.2.2 视频：读取 123456789101112# 3.视频# VideoCapture：指定视频路径，不指定（参数=0）则是打开自带摄像头capture = cv.VideoCapture(0)while(1): ret,frame = capture.read() # cv.flip: 使图像镜像颠倒，恢复正常 frame = cv.flip(frame,1) cv.imshow(&quot;video&quot;,frame) # cv.waitKey:每处理一帧都等待50ms，同时当按下ESC(ASCII=27)退出 c = cv.waitKey(50) if c==27: break; 1.3 色彩空间 该部分主要参考：图像色彩空间总结 1.3.1 色彩空间初识 图像通道 从数学方式理解，一张图片是一个数值矩阵。如果有n 个通道，则指按*不同方式* 可分解成 n 个同大小、不同数值矩阵之和。 如下三通道RGB ，可将原始彩色图片 —&gt; 分解成 RGB 三通道： RGB 三个分量 R、G、B取值大小在 [0,255] 之间。 常用色彩空间有：BGR、RGB、GRAY、RGB、HSV、YUV 等 1.3.2 色彩空间转换 简单使用如下代码可以进行不同色彩空间的转换： 123456789101112# 4.色彩空间转换image = cv.imread(r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;)cv.imshow(&quot;standingCat&quot;,image)# 转换为GRAYgray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)cv.imshow(&quot;gray&quot;,gray)# 转换为RGBRGB = cv.cvtColor(image,cv.COLOR_BGR2RGB)cv.imshow(&quot;RGB&quot;,RGB)cv.waitKey(0) HSV空间颜色三通道范围 栗子 1：将视频中红色转换为 --&gt;白色突出显示，其余颜色都是黑色便于跟踪。 在图像处理中，通常不会直接对RGB图像做处理，因为RGB和人类视觉相差较远。故下面代码将每一帧都转换到 HSV 色彩空间。 1234567891011121314151617181920212223242526# 5.视频色彩空间转换capture = cv.VideoCapture(&quot;D:/hwh/uploadToGit/code/python/5_learn_pytorch/src/video1.mp4&quot;)while(True): ret,frame = capture.read() if ret == False: # 判断视频流是否读取完毕 break # 转换到hsv色彩空间，返回hsv帧 hsv = cv.cvtColor(frame,cv.COLOR_BGR2HSV) # 设置黑色像素三通道值阀值范围 # 将hsv帧转换为二值化mask帧 lower_hsv = np.array([0,43 ,46]) # 设置红色最低三通道值（在hsv色彩空间） upper_hsv = np.array([10,255,255]) # 设置红色最高三通道值（在hsv色彩空间） mask = cv.inRange(hsv,lowerb=lower_hsv,upperb=upper_hsv) # 显示原始视频 cv.namedWindow(&quot;testVideo&quot;,0) # 第二参数不明 cv.resizeWindow(&quot;testVideo&quot;,900,600) # 设置窗口大小 cv.imshow(&quot;testVideo&quot;,frame) # 显示当前读取的帧 # 显示mask二值化视频 cv.namedWindow(&quot;mask&quot;, 0) cv.resizeWindow(&quot;mask&quot;, 900, 600) cv.imshow(&quot;mask&quot;,mask) c = cv.waitKey(20) if c == 27: break 1.4 像素运算 1.4.1 基本加减乘除 试分析，下面两张图片进行加减乘除得到的结果。 定义基本代码： 加减操作： 1234# 图片相加add_image = cv.add(src1,src2);# 图片相减substract_image = cv.substract(src1,src2); 图片相加：黑色=0，白色=255。所以src1黑色背景相加对src2没影响，而src1白色字体和src2相加会超过255被截断依旧显示Linux白色字体。 图片相减：背景是黑色？因为src1背景黑色-src2 &lt; 0，依旧取0故结果为黑色 ； 字体五颜六色？因为src中Linux字体是白色=255，减去src2值，变成其它颜色了。 乘法操作： 图片相乘：背景黑色？因为src1黑色=0 * 第二张图对应部分 == 0 ，还是显示黑色 ； 字体是白色周围又五颜六色？ 这是因为 src1中Linux字体周围有反锯齿，周围边缘有平滑有模糊，它周围像素值并不为0，和src2相乘后，所以最终像素值并不为0而相乘值变大了就容易显示出其它颜色。 14.2 MASK（掩膜） MASK掩膜，即图和掩膜按位与进行运算，筛选出感兴趣的区域。 由于mask和原图像素值 ∈[0,255]∈[0,255]∈[0,255] ，所以定义逻辑与如下： mask和原图对应点像素值都 &gt;0&gt;0&gt;0 ，则为真，输出*原图像素像素值* 其中一个等于0，则为假，输出对于*点像素值为0* 这样定义mask意义在于： 对于自己敢兴趣的区域，mask=0，则按位与必为0（显示为黑色） 自己不感兴趣的区域设置 mask&gt;0 ,则依旧输出为原图像素像素值 举个简单的例子：更多参考 mask只能是二维矩阵，与原图 shape[:2] 相同（shape[:2] 是 1*3 矩阵，当其是一维矩阵 [:2] 索引的是前两个数字，而非前两行！） 1.4.3 逻辑操作 12345678image1 = cv.imread(r&quot;C:\\Users\\86151\\Pictures\\test1.jpg&quot;)image2 = cv.imread(r&quot;C:\\Users\\86151\\Pictures\\test2.jpg&quot;)# 逻辑与dst1 = cv.bitwise_and(image1,image2)# 逻辑或dst2 = cv.bitwise_or(image1,image2)# 取反 dst3 = cv.bitwise_not(image1) 上图是逻辑与结果 栗子1：inRang+mask 实例：结合上节利用将图像掩膜mask，突出显示某些指定颜色变化为白色（其余为黑色）。 我们可以通过 bitwise_and ，使得突出显示的颜色为原来颜色，而非白色。 12345678910111213141516171819202122232425262728capture = cv.VideoCapture(&quot;D:/hwh/uploadToGit/code/python/5_learn_pytorch/src/video1.mp4&quot;)while(True): ret,frame = capture.read() if ret == False: # 视频流读取完毕 break hsv = cv.cvtColor(frame,cv.COLOR_BGR2HSV) lower_hsv = np.array([0,43 ,46]) upper_hsv = np.array([10,255,255]) # 在这里mask∈&#123;0,255&#125;，只有两个数字 mask = # 前面两个参数原图进行相加（逻辑与不变？），然后通过掩膜mask按位与实现输出原图像素值？ dst = cv.bitwise_and(frame,frame,mask=mask) # 显示原始视频1 cv.namedWindow(&quot;testVideo&quot;,0) cv.resizeWindow(&quot;testVideo&quot;,600,400) cv.imshow(&quot;testVideo&quot;,frame) # 显示mask二值化视频2 cv.namedWindow(&quot;mask&quot;, 0) cv.resizeWindow(&quot;mask&quot;, 600, 400) cv.imshow(&quot;mask&quot;,mask) # 显示逻辑与操作视频3 cv.namedWindow(&quot;dst&quot;, 0) cv.resizeWindow(&quot;dst&quot;, 600, 400) cv.imshow(&quot;dst&quot;,dst) c = cv.waitKey(20) if c == 27: break 实际上原图 &amp; mask输出非黑部分和 原图区别还是挺大的啊？ 1.4.4 其它：对比度addWeight等 有点类是add，也是进行图像叠加不过会设置各种权重和参数。按下公式计算结果图： alpha ： src1 矩阵元素权重 ； beta ： src2 矩阵权重；gamma 最后各元素再相加值。 举例：可通过 addWeighted 调整图片的亮度、对比度等 生成一张纯0矩阵 blank ，那beta有什么用？乘上一个零矩阵不变？ 此时 alpha 即可是认为是对比度（等比增大元素像素值，黑色还是黑，别的会等比变大），gamma 可调节亮度（值越大越白–&gt;越亮） 12345678910111213# 7.addWeight 调整对比度image = cv.imread(r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;)# 创建一张和原图等大纯黑图h,w,c = image.shapeblank = np.zeros([h,w,c],dtype=image.dtype)# 增加对比度dst = cv.addWeighted(image,1.2,blank,1-1.2,10)# 显示图片cv.imshow(&#x27;image&#x27;,image)cv.imshow(&#x27;dst&#x27;,dst)cv.waitKey(0) 其它操作。 12345# 打印出图片三个通道像素均值m1 = cv.mean(src1)# 打印出图片三个通道像素均值和方差m1,dev1 = cv.meanStdDev(m1) 1.5 绘图与鼠标事件 该部分主要参照于：openCV-Python 中文教程 1.5.1 绘图 以下为简单实例，绘制矩形、多边形、圆、椭圆、添加文字等 12345678910111213141516171819202122232425262728293031image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)# 1.画线# 参数依次意义：原图，起始点坐标，终点坐标，线颜色，线厚度cv.line(image,(0,0),(250,250),(255,0,0),5)# 2.画矩形# 参数依次意义：原图，左上角坐标，右下角坐标，边颜色，边厚度cv.rectangle(image,(50,50),(250,250),(255,255,0),1)# 3.画圆# 参数依次意义：原图，圆心坐标，半径，边颜色，边厚度# 指定边厚度=-1，则圆会向内填充cv.circle(image,(250,250),20,(0,0,255),-1)# 4.画椭圆# 参数依次意义：原图，圆心坐标，(长轴，短轴)，旋转角度，椭圆弧起始角，椭圆弧终止角，颜色cv.ellipse(image,(250,250),(100,50),30,70,360,255,1)# 5.画多边形# 参数依次意义：原图，多边形各点坐标，是否闭合，边颜色# 指定多边形各点左边，[必须是int32]pts=np.array([[100,50],[200,300],[400,200],[500,100]],np.int32)cv.polylines(image,[pts],True,(46.46,46))# 6.添加文字# 参数依次意义：原图，绘制位置，字体类型，大小，颜色，粗细，类型font = cv.FONT_HERSHEY_SCRIPT_SIMPLEXcv.putText(image,&#x27;HELLO OPENCV!&#x27;,(100,200),font,2,(0,0,255),cv.LINE_4)cv.imshow(&#x27;result&#x27;,image)cv.waitKey(0) 1.5.2 鼠标事件 利用鼠标事件，实现对图片指定区域裁剪。 123456789101112131415161718192021222324252627282930# 9.鼠标事件# 1.创建回调函数：draw_circle(event,x,y,flags,param)# 2.绑定回调函数&amp;窗口：setMouseCallback(&#x27;window&#x27;,draw_circle)def draw_circle(event,x,y,flags,param): global ix,iy,drawing,mode # 触发左键按下事件：EVENT_LBUTTONDOWN if event == cv.EVENT_LBUTTONDOWN: ix,iy = x,y # 获取左键按下初始坐标 elif event == cv.EVENT_LBUTTONUP: cv.rectangle(image,(ix,iy),(x,y),(0,0,255),1) cv.imshow(&#x27;crop&#x27;,image[iy:y,ix:x]) # 未解决：用鼠标移动+拖拽事件来判断，会每次移动画一个矩形，最后出现很多矩形 # 已画的矩形又无法清除 # 触发鼠标移动 &amp; 左键拖拽事件 # elif event==cv.EVENT_MOUSEMOVE and flags==cv.EVENT_FLAG_LBUTTON: # if drawing == True: # elif event==cv.EVENT_LBUTTONUP: # drawing = Falseimage = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.namedWindow(&#x27;img&#x27;)cv.setMouseCallback(&#x27;img&#x27;,draw_circle)while(1): # 放在循环里，一直显示？ cv.imshow(&#x27;img&#x27;, image) k = cv.waitKey(1) if k == ord(&#x27;q&#x27;): break 二、进击！openCV！ 2.1 ROI与泛洪填充 简单来说：获取感兴趣区域ROI对它进行指定方式填充。 例子：截取指定区域，转换为GRAY图像并覆盖原图相同区域 123456789101112131415161718192021222324252627282930# ROI与填充# 该例子分为三个部分：# 1.实现指定图片对其进行部分截图# 2.将截图部分转换为灰色，并覆盖原图相同区域def crop_trans_Img(event,x,y,flags,param): global x0,y0,x1,y1 # 触发左键按下事件：EVENT_LBUTTONDOWN if event == cv.EVENT_LBUTTONDOWN: x0,y0 = x,y # 获取左键按下时初始坐标 # 触发左键抬起事件：EVENT_LBUTTONUP，裁剪指定区域图片并转换为灰度图 elif event == cv.EVENT_LBUTTONUP: x1,y1 = x, y # 指定裁剪区域 cv.rectangle(image,(x0,y0),(x1,y1),(0,0,255),1) # 获取裁决区域图 crop = image[y0:y1,x0:x1] # 裁剪区域转换为灰度图Gray gray_crop = cv.cvtColor(crop,cv.COLOR_BGR2GRAY) # 将[灰度图--&gt; BGR图] --&gt; 覆盖原图指定区域 image[y0:y1, x0:x1] = cv.cvtColor(gray_crop,cv.COLOR_GRAY2BGR)image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.namedWindow(&#x27;img&#x27;)cv.setMouseCallback(&#x27;img&#x27;,crop_trans_Img) # img窗口绑定回调函数while(1): cv.imshow(&#x27;img&#x27;, image) k = cv.waitKey(1) if k == ord(&#x27;q&#x27;): break 2.1.1 FloodFill：泛洪填充 定义，floodFill(image,mask,seePoint,newVal,rect,loDiff,upDiff,scalar,flags) : mask：必须宽高比原图大2像素；对不想填充区域设置为非零值，则不被填充（为原像素值） 即mask &gt; 0 区域依旧表现为原图像素值；mask = 0 ，则会被指定填充（前面讲mask=0，值=0，即黑色，和这有点不同的） loDiff、upDiff：定义指定视为连通可被填充像素值范围（彩色还要设置三通道这种低、高Diff） flags：填充方法选择，一般彩色图片选择cv.FLOODFILL_FIXED_RANGE ；还有可以选择cv.FLOODFILL_FIXED_MASK_ONLY 好像是只填充mask=0区域？？？？ 利用mask，实现对指定区域进行泛洪填充。 1234567891011image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)copyImg = image.copy()h,w = copyImg.shape[:2]# 设置mask，对于想感兴趣的区域设置0mask = np.ones([h+2,w+2],np.uint8)mask[100:800,200:700] = 0# 进行泛洪填充cv.floodFill(copyImg,mask,(250,250),(0,255,255),(20,20,20),(100,100,100),cv.FLOODFILL_FIXED_RANGE)cv.imshow(&#x27;flood&#x27;,copyImg)cv.waitKey(0) 2.2 模糊操作 2.2.1 均值模糊、中值模糊 均值模糊 作用：对随机噪声有很好去噪效果 实现：通过指定size=(h,w)size=(h,w)size=(h,w)的全1卷积核，计算新像素值 = (h,w)范围像素线性加权h∗w\\frac{(h,w)范围像素线性加权}{h*w}h∗w(h,w)范围像素线性加权​ API：blur(src,dst,ksize,anchor=Point(-1,-1), borderType=BORDER_DEFAULT ) 中值模糊 作用：对椒盐噪声有很好去噪效果 实现：指定长宽相同size=(h,h)size=(h,h)size=(h,h)卷积核， 在对图像进行卷积过程中，将卷积核区域内像素值从小–&gt;大排序，取中值像素作为整个区域像素值。 API : medianBlur( src,dst,ksize ) 实例1：调用openCV的API来实现均值模糊，中值模糊。 注：实际上好像下面都没有指定参数 dst 啊？ 12345678910image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;orign&#x27;,image)# 均值模糊avgBlurImg = cv.blur(image,(5,5))cv.imshow(&#x27;avgBlur&#x27;,avgBlurImg)# 中值模糊medianBlurImg = cv.medianBlur(image,5) # 必须是方阵，只指定一个数字即可cv.imshow(&#x27;medianBlur&#x27;,medianBlurImg)cv.waitKey(0) 实例2：自定义卷积核实现均值滤波。 12345# 自定义卷积核实现均值滤波kernel = np.ones([5,5],np.float32)/25autoAvgImg = cv.filter2D(image,-1,kernel=kernel)cv.imshow(&#x27;aotuAvgImg&#x27;,autoAvgImg)cv.waitKey(0) 效果和调用API 一样。 2.2.2 高斯模糊 和前均值模糊一样，也是进行卷积。只不过高斯模糊的卷积核附和高斯分布而已。 高斯分布（又为正态分布）： 高斯模糊 作用：对高斯噪声有较好处理效果 API : GaussianBlur(src,ksize,sigmaX,dst,sigmaY,borderType: Any = None) 实例1：简单调用接口实现对图片的高斯模糊。 123456789# 13.高斯模糊image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# GaussianBlur:调用高斯模糊# x标准差=sigmax=15，卷积核大小设置为0则会根据sigmax自动计算GaussianImg = cv.GaussianBlur(image,(0,0),15)cv.imshow(&#x27;guassian image&#x27;,GaussianImg)cv.waitKey(0) 实例2：利用高斯模糊对高斯噪声进行处理。 可发现高斯噪声对高斯模糊产生结果没什么影响。 12345678910111213141516171819202122232425262728# 14.高斯模糊对高斯噪声进行处理image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# 给图片加上高斯噪声h,w,c = image.shapefor row in range(h): for col in range(w): # 生成高斯随机噪声像素值 # loc:概率分布的均值；scale：概率分布标准差；size：输出的shape，默认输出一个 # 例如正态分布（μ=0,σ=1 ） == random.normal(loc=0, scale=1, size) s = np.random.normal(loc=0,scale=20,size=3) # 获取BGR三个通道对应像素值 b = image[row,col,0] g = image[row,col,1] r = image[row,col,2] # 给每个像素点加上高斯噪声生成的像素值 image[row, col, 0] = (b + s[0]) % 255 image[row, col, 1] = (g + s[1]) % 255 image[row, col, 2] = (r + s[2]) % 255cv.imshow(&#x27;Guassian noise&#x27;,image)# 高斯模糊对高斯噪声图片进行处理GaussianImg = cv.GaussianBlur(image,(0,0),15)cv.imshow(&#x27;GaussianImg&#x27;,GaussianImg)cv.waitKey(0) 2.2.3 EPF模糊：高斯双边、均值偏移 EPF，即边缘保留滤波。常用有基于高斯双边和均值偏移。 我们知道，在前 高斯模糊 只考虑了空间分布，而没有像素之间差异问题： 如果像素差异很大，说明实现显著特征，我们应该将它进行平滑吗？ 显然是不应该的，而且往往在 图像边缘 出现像素差异变大。在openCV中提供了：高斯双边、均值漂移 来实现边缘保留。 高斯双边模糊 高斯双边美颜效果杠杠的。 上述是高斯双边模糊原理图（没太明白） API : cv.bilateralFilter(src, d, sigmaColor, sigmaSpace[, dst[, borderType]]) d : 滤波器大小，d&gt;5d&gt;5d&gt;5 执行效率低，一般取d=5d=5d=5； d≤0d≤0d≤0 时由 sigmaSpace确定且成正比 sigmaColor ：值越大，交界处即边缘越模糊 sigmaSpace ：值越大，即颜色平均的地方越模糊 一个简单测试：利用高斯双边模糊把刘欣变得更美美的。 12345678910# 15.高斯双边模糊image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\testlx.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# d=0,由sigamColor确定；sigamColor=100 ；sigamSpace=15# 好像又略过了dst参数啊？？lx_beautiful = cv.bilateralFilter(image,0,100,15)cv.imshow(&quot;lx_beautiful&quot;,lx_beautiful)cv.waitKey(0) 均值飘移模糊 也能保留边缘，但是更类似于卡通效果。 均值飘移模糊： 原理：又是什么色彩聚类平滑滤波，结合泛洪填充可以进行图像分割？ API : pyrMeanShiftFiltering(src, sp, sr[, dst[, maxLevel[, termcrit]]]) sp、sr ： 值越大，则图像色彩平滑效果越好，但耗时也越多。 简单测试：均值漂移把刘欣变得… 12345678# 15.均值漂移模糊image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\testlx.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)lx_beautiful = cv.pyrMeanShiftFiltering(image,10,50)cv.imshow(&quot;lx_beautiful&quot;,lx_beautiful)cv.waitKey(0) 2.3 图像直方图 图像直方图： 意义：直方图是图像 像素强度 分布的图形表达方式，统计每一个强度值所具有的像素个数。 例如下列灰度直方图： xxx 轴代表灰度值（0-255） ； yyy 轴代表同一个灰度值点的数目。 彩色图像如何设置直方图？ 三个通道值还是∈[0,255]∈[0,255]∈[0,255] ,那么分别统计各个不同通道相同像素值就好了。 常用一些术语： range：每个特征空间的取值范围，例如 range=[0,255] bin：直条或组距，表示每个特征子空间的段的数目 下面图像14位是什么意思，为什么会有 2142^{14}214 不同像素值，不是只会 ∈[0,255]∈[0,255]∈[0,255] ? 这里指得应该是图像大小=14，然后灰度图会有 14∗1414*1414∗14 个像素点。 2.3.1 实例：直方图初应用 下面我们分别介绍两个API 来计算图像 直方图 和 直方折线图 ： matplotlib::plt.hist() 计算直方图 x ：数组，必须是(n,)数组，所以图像要用 image.ravel() 函数进行降维 bins ：指定bin个数 range ： 显示的区间 cv.calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate]]) 返回的是一个数组(histSize,1)，统计了指定 histSize 的像素强度统计个数。 实例1：利用matplotlib::plt.hist()绘制出图像不同像素强度统计数直方图 123456789# 16.直方图image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# 绘制直方图# image.ravel()将原图640*640*3维度降为一维 2288000=640*640*3# 注意这里是256不是255plt.hist(image.ravel(),256,[0,256])plt.show()cv.waitKey(0) 实例2：利用 cv.calcHist() 统计指定图像和通道的各个像素强度个数。 1234567891011# 17.绘制直方折线图？image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)color = (&#x27;blue&#x27;,&#x27;green&#x27;,&#x27;red&#x27;) # 三个通道各个像素统计折线不同颜色for i,color in enumerate(color): hist =cv.calcHist([image],[i],None,[256],[0,256]) plt.plot(hist,color=color) plt.xlim([0,256])plt.show() 2.3.3 直方图应用 直方图均衡化 直方图均衡化：利用图像直方图 对比度进行调整 的方法。可参考这篇文章 原理：待补充 API ： 直方图均衡化 ： cv.equalizeHist(src[, dst]) 局部直方图均衡化： cv2.createCLAHA(clipLimit=8.0, titleGridSize=(8, 8)) clipLimit ：颜色对比度的阈值 titleGridSize ：进行像素均衡化的网格大小，即在多少网格下进行直方图的均衡化操作 实例1：通过直方图均衡化提升图像质量。 123456789101112# 18.直方图均衡化image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)# 将原图转换为灰度图gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)cv.imshow(&#x27;origin_gay&#x27;,gray)# 直方图均衡化只能是灰度图，如果是彩色图？不能？dst = cv.equalizeHist(gray)cv.imshow(&#x27;equalHistImg&#x27;,dst)cv.waitKey(0) 实例2：局部图直方图均衡化，解决全局的均衡化整体亮度提升使得局部图像的细节变得模糊。 好像这张图不能体现局部直方图均衡化可以保留更多细节？下面这张图最右侧局部均衡化显然保存的人脸更多细节： 1234567891011121314# 19.局部直方图均衡化image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)# 将原图转换为灰度图gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)# 显示全局均衡化图像cv.imshow(&#x27;hist&#x27;,cv.equalizeHist(gray))# 实例化自适应直方图均衡化系数clahe = cv.createCLAHE(5.0,(8,8))dst = clahe.apply(gray)cv.imshow(&#x27;clahe&#x27;,dst)cv.waitKey(0) 直方图比较 手动创建图像直方图方法 create_rgb_hist 没有太明白？ 直方图反向投影 该小节例子使用的范围归一化到[0,255]，而不是一值归一化。可查看 OpenCV中矩阵的归一化 作用：用于图像分割或查找图像中感兴趣的对象 归一化: 计算反向直方图： 实例1：计算二维直方图并显示。 1234567891011# 20.显示hsv二维直方图image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# 计算直方图反向投影先转换到hsv色彩空间(?)hsv = cv.cvtColor(image,cv.COLOR_BGR2HSV)# hsv，因为亮度(v)很容易受到外界影响，所以我们认为颜色本质是hsv，h∈[0,180],v∈[0,256]hist = cv.calcHist([hsv],[0,1],None,[180,256],[0,180,0,256])cv.imshow(&#x27;hist2D&#x27;,hist)cv.waitKey(0) 实例2：提取刘欣头发为感兴趣区域，进行反向直方图投影。 ⚠️ 经过测试感兴趣区域应该是一类颜色，而不应该是整个脸什么的？ 123456789101112131415161718192021222324# 21.直方图反向投影# 读取roi图像并转换到hsv色彩空间roi = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\testlx_roi2.jpg&quot;)roi_hsv = cv.cvtColor(roi,cv.COLOR_BGR2HSV)cv.imshow(&#x27;roi&#x27;,roi)# 读取目标图像并转换到hsv色彩空间target = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\testlx.jpg&quot;)target_hsv = cv.cvtColor(target,cv.COLOR_BGR2HSV)cv.imshow(&#x27;target&#x27;,target)# 计算roi图像直方图并[范围]归一化到[0,255]# roi_hist.shape=(180,256)# 如果想效果更好，可以把bin不那么细化，即bin数目调整少点：[180,256] --&gt; [32,64]roi_hist = cv.calcHist([roi_hsv],[0,1],None,[180,256],[0,180,0,256]) # 归一化范围至0-256，cv.NORM_MINMAX常用的线性平移缩放归一化cv.normalize(roi_hist,roi_hist,0,256,cv.NORM_MINMAX)# 计算反向直方图投影dst = cv.calcBackProject([target_hsv],[0,1],roi_hist,[0,180,0,256],1)cv.imshow(&#x27;dst&#x27;,dst)cv.waitKey(0) 2.4 模板匹配 模板匹配即给定模板（template）在目标（target）中进行搜索匹配，画出锚框。 匹配：matchTemplate 原理：利用模板在目标图像匹配（卷积），返回所有匹配结果矩阵A 对于TM_SQDIFF 方法，结果矩阵A 中*最小值位置* 对应最佳匹配时模板图像*左上角* 位置 对于TM_CCORR or TM_CCOEFF 方法，A 中*最大值位置* 对应最佳匹配模板图像*左上角* 位置 原型：cv.matchTemplate(image, templ, method[, result[, mask]]) 例1：给定模板图像猫脸，在目标图像猫中画出对应模板图像位置红框。 12345678910111213141516171819202122232425262728# 22.模板匹配# 读取模板图像（猫脸）template = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat_roi.jpg&quot;)cv.imshow(&#x27;template&#x27;,template)th,tw = template.shape[:2] # shape=(h,w,c)# 读取目标图像（猫）target = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)# 模板匹配的三种方法methods = [cv.TM_SQDIFF_NORMED,cv.TM_CCOEFF_NORMED,cv.TM_CCORR_NORMED]tl = [0,0]for md in methods: # 采用指定方法md,进行模板匹配 result = cv.matchTemplate(target,template,md) # minMaxLoc：返回矩阵中最小值、最大值、最小值位置，最大值位置 minVal,maxVal,minLoc,maxLoc = cv.minMaxLoc(result) if md == cv.TM_SQDIFF_NORMED: tl = minLoc else: tl = maxLoc # 注意右下角 = （左上角x+宽，左上角y+高） cv.rectangle(target,tl,(tl[0]+tw,tl[1]+th),(0,0,255),2) cv.imshow(str(md),target)cv.waitKey(0) 2.5 图像二值化 什么是图像的二值化？该部分主要参考 : 图像二值化 一幅图像包括目标物体、背景还有噪声，要想*从多值的数字图像中直接提取出目标物体*，通过设定一个阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。这是研究灰度变换的最特殊的方法，称为图像的二值化（Binarization）。 例如：将图像上的像素点的灰度值设置为0或255，整个图像呈现出明显的只有黑和白的视觉效果。 1 hsv二值化： inRange 在之前我们还接触过 inRange 将图像进行二值化 ： 在 hsv 色彩空间中，对于指定 hmin−hmax、smin−smax、vmin−vmaxh_{min}-h_{max} 、s_{min}-s_{max} 、v_{min}-v_{max}hmin​−hmax​、smin​−smax​、vmin​−vmax​ 范围内像素值设置为白色其余为黑色。 这是针对在 hsv 色彩空间，而下面 threshold 是指对 单通道灰度图 进行二值化。 2 gray二值化：threshold 相关API : cv2.threshold(img, threshold, maxval,type) threshold : 是设定的阈值 maxval: 当灰度值大于（或小于）阈值时将该灰度值赋成的值 type : 当前二值化的方式（保持原样指的是保持原图像像素值） threshold 方法针对 单通道灰度图 ，彩色图要先转换为灰度图。 1234567891011121314151617181920212223242526272829303132# 23.图像二值化：thresholdimage = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)image_gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)cv.imshow(&#x27;origin_gray&#x27;,image_gray)# 进行二值化# THRESH_BINARY: 大于阈值=127，被置为255，小于阈值=127，被置为0# 这里maxVal=255，是大于阈值被设置的值，而不是默认就设置为255！ret1,binary1 = cv.threshold(image_gray,127,255,type=cv.THRESH_BINARY)cv.imshow(&#x27;THRESH_BINARY&#x27;,binary1)# THRESH_BINARY_INV: 和THRESH_BINARY设置相反ret2,binary2 = cv.threshold(image_gray,127,255,type=cv.THRESH_BINARY_INV)cv.imshow(&#x27;THRESH_BINARY_INV&#x27;,binary2)# THRESH_TRUNC：大于阈值部分被置为threshold，小于部分保持原样（原图像素值）# 这里及下面maxVal（0）设置不起作用，大于阈值为原图像值ret3,binary3 = cv.threshold(image_gray,127,0,type=cv.THRESH_TRUNC )cv.imshow(&#x27;THRESH_TRUNC&#x27;,binary3)# THRESH_TOZERO：小于阈值部分被置为0，大于部分保持不变（原图像素值）ret4,binary4 = cv.threshold(image_gray,127,0,type=cv.THRESH_TOZERO )cv.imshow(&#x27;THRESH_TOZERO&#x27;,binary4)# THRESH_TOZERO_INV ：大于阈值部分被置为0，小于部分保持不变 （原图像素值）ret5,binary5 = cv.threshold(image_gray,127,0,type=cv.THRESH_TOZERO_INV )cv.imshow(&#x27;THRESH_TOZERO_INV&#x27;,binary5)# [重要] cv.THRESH_OTSU：是最大间差法，按图像灰度特性将图像分为前景和背景两部分cv.waitKey(0) 3 gray二值化：adaptiveThreshold 该部分主要参考：自适应化阈值操作 自适应阈值，则是根据像素的 邻域块的像素值分布来确定该像素位置上的二值化阈值 ： 每个像素位置处的二值化阈值不是固定不变的，而是由其周围邻域像素的分布来决定的 亮度较高图像区域二值化阈值通常较高，而亮度低的图像区域的二值化阈值则会相适应变小 不同亮度、对比度、纹理的局部图像区域将会拥有相对应的局部二值化阈值 每一个像素计算阈值过程： 首先该像素点周围 B*B 区域内像素加权平均（对应方法有平均值法、高斯平均两种方法） 最后减去一个常数C，得到该像素点的阈值 相关API : cv.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst]) maxValue ：阈值？ adaptiveType : 指自适应的阈值 求平均值方法，同上有两种可选 ADAPTIVE_THRESH_MEAN_C ：先求出领域块中的均值，再减去常数C ADAPTIVE_THRESH_GAUSSIAN_C：局部邻域块的高斯加权和，最后减去常数C thresholdType ：阈值类型，有两种可选：THRESH_BINARY 或THRESH_BINARY_INV ？ 同前，THRESH_BINARY 大于阈值置为阈值，小于阈值置为0；THRESH_BINARY_INV 相反。 blockSize： 指定的领域块区域大小，通常为3、5、7 C : 上面说的常数C 实例：可以看到自适应阈值化很好的保留了 边缘信息 。 123456789101112# 24.自适应阈值：adaptiveThresholdimage = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)image_gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)cv.imshow(&#x27;origin_gray&#x27;,image_gray)# 自适应阈值# 不知道为什么设置C=10,blockSize=5(区域大小为5*5=25)adaptive_binary = cv.adaptiveThreshold(image_gray,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,25,10)cv.imshow(&#x27;adaptive_binary&#x27;,adaptive_binary)cv.waitKey(0) 4 超大图像二值化 该部分主要参考：超大图像二值化和空白过滤 处理超大图像的思路其实就是分块思想： 将图像分成一个个小块 对每个小块进行 threshold 、adaptiveThreshold 二值化操作，获取二值化图像 将原图（灰度图像）对应区域覆盖为上述的二值化图像 分别使用全局阈值/局部阈值对分块图像进行处理比较。 左侧全局阈值处理，导致每个分块之间的图像差距较大，出现分块边界 现象。 右侧局部阈值处理，就没有明显的分块现象 12345678910111213141516171819# 25.超大图像二值化def big_image_binary(image): print(image.shape) #(4208, 2368, 3) cw,ch = 256,256 h,w = image.shape[:2] #要二值化图像，要先进行灰度化处理 gray = cv.cvtColor(image,cv.COLOR_RGB2GRAY) for row in range(0,h,ch): for col in range(0,w,cw): roi = gray[row:row+ch,col:col+cw] #获取分块 # 全局阈值 # ret,binary = cv.threshold(roi,0,255,cv.THRESH_BINARY|cv.THRESH_OTSU) # 局部阈值 binary = cv.adaptiveThreshold(roi,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,127,20) gray[row:row + ch, col:col + cw] = binary #分块覆盖 print(np.std(binary),np.mean(binary)) cv.imwrite(&quot;binary2.jpg&quot;,gray) 空白区域过滤 简单来说就是我们认为该区域是空白图像，不进行二值化（但可全变为黑或者白）。 123456789101112131415161718192021# 空白区域过滤def big_image_binary(image): print(image.shape) #(4208, 2368, 3) cw,ch = 128,128 h,w = image.shape[:2] gray = cv.cvtColor(image,cv.COLOR_RGB2GRAY) # 要二值化图像，要先进行灰度化处理 for row in range(0,h,ch): for col in range(0,w,cw): roi = gray[row:row+ch,col:col+cw] # 获取分块 # 通过获取分块区域的方差和平均值来判断是否是空白区域 dev = np.std(roi) avg = np.mean(roi) if dev &lt; 15 and avg &gt; 200: # 满足条件，接近空白区域，让他变黑 gray[row:row + ch, col:col + cw] = 0 #全部都赋值为0 else: ret,binary = cv.threshold(roi,0,255,cv.THRESH_BINARY|cv.THRESH_OTSU) gray[row:row + ch, col:col + cw] = binary print(np.std(binary), np.mean(binary)) cv.imwrite(&quot;binary.jpg&quot;,gray 2.6 图像缩放 如果要进行对图像进行 放大或缩小 通常有以下几种方法（在openCV中提供）： ⚠️ 以下方法都可以进行 放大或缩小 （具体怎么实现缩小图像，还待理解） INTER_NEAREST ：最近邻插值法 INTER_LINEAR ： 双线性插值法（默认） INTER_AREA ： 基于局部像素的重采样，缩小图像通常选择 INTER_CUBIC ： 基于4x4像素邻域的3次插值法 INTER_LANCZOS4 ： 基于8x8像素邻域的Lanczos插值 在 openCV 中可使用以下API实现对图像缩放： 简单粗暴的 resize 函数 ：实现效率最高 cv::pyrUP 、cv::pyrDown ：对图像进行上采样、下采样，常用于图像金字塔中，下详 2.6.1 缩放：resize 函数原型： 实例：演示如何使用 resize 函数对图像进行缩放。 123456789101112# 26.resize# image.shape = (640, 640, 3)image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)print(image.shape)cv.imshow(&#x27;origin&#x27;,image)# resize到 512*512,采用双线性插值# 彩色图虽然有三通道，但是只需指定长、宽就行resize_image = cv.resize(image,(512,512),interpolation=cv.INTER_LINEAR)cv.imshow(&#x27;resize_image&#x27;,resize_image)cv.waitKey(0) 2.6.2 图像金字塔：pyrUP 、pyrDown 图像金字塔是一系列图像的集合，所有图像来源于同一张原始图像，通过梯次向下采样获得。 通常有两种类型的图像金字塔 ： 高斯金字塔(Gaussian pyramid)：用来向下采样 拉普拉斯金字塔(Laplacian pyramid)：用来从金字塔底层图像重建上层未采样图像，可以对图像进行最大程度的还原. 高斯金字塔 高斯金字塔用于下采样过程可描述如下： 对图像进行高斯内核卷积，其中高斯内核= ❔​ 这一步卷积不会缩小图像尺寸吗？ 将所有偶数行、列去除，这样得到的图形长、宽是原图12\\frac{1}{2}21​ 。 在openCV中提供了pyrDown 函数来实现下采样： 实例：使用高斯金字塔来缩放图像。 123456789101112131415# 27.高斯金字塔image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)# resize到 512*512image = cv.resize(image,(512,512),interpolation=cv.INTER_AREA)cv.imshow(&#x27;origin&#x27;,image)level = 3pyramid_imgs = []for i in range(level): dst = cv.pyrDown(image) pyramid_imgs.append(dst) image = dst cv.imshow(&#x27;L&#x27;+str(i),dst)cv.waitKey(0) 拉普拉斯金字塔 拉普拉斯金字塔中使用了上采样，其上采样过程如下： 将图像在每个方向上扩大为原来的两倍，新增的行和列以0填充 使用先前同样的内核(乘以4)与放大后的图像卷积，或得”新增像素”的近似值 ⚠️ 同上疑问，卷积这一步不会改变图像大小吗？那就不是放大2倍了？ 在openCV中提供了pyrUp 函数来实现上采样： 拉普拉斯金字塔图像可不仅仅通过对图像向上采样就得到，具体操作如下： 通过高斯金字塔得到一系列不同层级(0-L)图像G 先对最高层级图像G[L] --&gt; 上采样(pyrUp)得到EP[L-1] --&gt; G[L-1] - EP[L-1] == 拉普拉斯图L[L-1] 对次高层图像G[L-1] --&gt; 上采样(pyrUp)得到EP[L-2] --&gt; G[L-2] - EP[L-2] == 拉普拉斯图像L[L-2] 重复步骤 2-3 ，直至高斯金字塔最低层（原图第一次下采样图） 显然，根据上述步骤，拉普拉斯金字塔是通过 源图下采样对应层级 - 上采样相应层级 获取。保留的残差，为图像还原做准备（🙂 此处复原不是很清楚 ）。 实例：获取拉普拉斯金字塔图像。 12345678910111213# 28.拉普拉斯金字塔# 下面 pyramid_imgs 表示高斯金字塔下采样获得图像集合for i in range(level-1,-1,-1): # 左闭右开从[2,-1)，递减选择步伐=-1 if i != 0: expand = cv.pyrUp(pyramid_imgs[i], dstsize=pyramid_imgs[i - 1].shape[:2]) lpls = cv.subtract(pyramid_imgs[i - 1], expand) else: # 此时已经放大至原图大小 expand = cv.pyrUp(pyramid_imgs[i], dstsize=image.shape[:2]) lpls = cv.subtract(image, expand) cv.imshow(&#x27;lpls&#x27;+str(i),lpls)cv.waitKey(0) 2.7 图像梯度 该部分主要参考清晰易懂的：图像梯度的基本原理 我们知道用 均值滤波器 等 ，可以降低图像噪声，但是会使得图像变得模糊 。 Q1 : 那么模糊图像和清晰图像又是怎么区分定义的呢？ 图像模糊：因为图像轮廓不明显，换言之，轮廓边缘灰度变化不强烈 ，层次感不强。 自然我们可以通过使得 轮廓灰度变得强烈 —&gt; 联系到 图像梯度 。 那么梯度又是如何增强图像清晰度呢？ 首先我们了解下如何计算图像的梯度。 我们知道图像是一个离散二维函数，那么其 x、yx、yx、y 方向梯度可定义如下： 显然这就相当于 梯度 = 2个相邻像素之间差值 考虑下面这张图：左部分是图像某个X方向像素变化值，右侧部分是该像素X方向梯度值。 将 原图X方向像素值+该X方向梯度=新图X方向像素值原图X方向像素值 + 该X方向梯度 = 新图X方向像素值原图X方向像素值+该X方向梯度=新图X方向像素值 。 这样：将有梯度值的相邻像素的灰度值变大了；而没有灰度值变换的像素值不变。 特别的，我们还可以将 x和yx和yx和y方向结合来计算新图像素值。计算公式如下： 一般使用拟合公式，简化计算： M(x,y)M(x,y)M(x,y) 即认为是梯度变化值，原图像像素加上该值便可获得最终新图像素值。 2.7.1 图像求导：Sobel、Scharr、Lapacian OpenCV提供三种不同梯度滤波器（高通滤波器）：Sobel，Scharr和 Lapacian ： Sobel、Scharr ：用于求图像一阶导或二阶导 Lapacian ：求图像二阶导，对 Sobel 的部分优化 Sobel &amp; Scharr 感觉就是定义卷积核，然后进行卷积。但是不知道为什么这样可以求导。 Sobel 算子 ：高斯平滑和微分操作的结合体，因此抗噪声能力很好 ddepth：指图像深度，目标图像深度必须 &gt;= 原图像深度。-1 表示和原图像深度一致。 dx、dy：表示求导的方向，0 表示这个方向不进行求导，1 表示有。 ksize：卷积核大小，当 ksize=-1 ，会使用 3*3 Scharr卷积核。它的效果比Sobel好 Scharr 算子： 以Scharr 算子为例：实现计算图像指定方向的梯度。 12345678910111213141516171819202122232425# 29.图像求导：Sobel、Scharr、Lapacian# 演示Scharr算子求导梯度，Sobel同理image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# Scharr算子对图像求导# 为什么使用CV_32F？# 因为Scharr算子求导后会有负值&amp;大于255值。而原图是unit8位，即8位无符号数。# 所以scharr建立图像位置不够，需要使用32F有符号数据类型。grad_x = cv.Scharr(image,cv.CV_32F,1,0)grad_y = cv.Scharr(image,cv.CV_32F,0,1)# 经过处理后，别用convertScaleAbs()函数将其转回原来的uint8形式。# 否则将无法显示图像，而只是一副灰色的窗口。# dst = cv2.convertScaleAbs(src[, dst[, alpha[, beta]]])# 可选参数alpha是伸缩系数，beta是加到结果上的一个值。结果返回uint8类型的图片grad_x = cv.convertScaleAbs(grad_x)grad_y = cv.convertScaleAbs(grad_y)cv.imshow(&#x27;gradx&#x27;,grad_x)cv.imshow(&#x27;grady&#x27;,grad_y)cv.waitKey(0) ⚠️ 上面图不适合演示增加图像清晰度，可看下面这张图： 梯度图是x、yx、yx、y 方向分别计算然后绝对值相加： Laplacian 算子 作用 对噪声敏感，会产生双边效果。不能检测出边的方向。通常不直接用边检测。一般用来检测一个像素是在边的亮的一边还是暗的一边利用零跨越，确定边的位置。 原理 图像中的边缘区域，像素值会发生“跳跃”，对这些像素求导，在其*一阶导数极值处就是边缘* 。 API 实例：利用 Laplacian 检测图像的边。 12345678910# Lapacianimage = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)dst = cv.Laplacian(image,cv.CV_32F,ksize=3)dst = cv.convertScaleAbs(dst)cv.imshow(&#x27;Lapacian&#x27;,dst)cv.waitKey(0) 2.7.2 Canny边缘提取 该部分主要参考：边缘检测之Canny 作用：提取图像边缘 流程：详细流程算法实现参考上述文章链接 使用高斯滤波器，以平滑图像，滤除噪声 计算图像中每个像素点的梯度强度和方向 应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应 应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘 通过抑制孤立的弱边缘最终完成边缘检测 API threshold1、threshold2即对应阈值T低、T高T_低、T_高T低​、T高​： 像素值&gt;T高像素值&gt;T_高像素值&gt;T高​ : 被认为是边缘像素，保留 T低&lt;像素值&lt;T高T_低&lt;像素值&lt;T_高T低​&lt;像素值&lt;T高​ : 当该像素和高于上限的像素点连接才保留 像素值&lt;T低像素值&lt;T_低像素值&lt;T低​ : 不认为是边缘像素，舍弃 一般设置 T高/T低=3:1T_高/T_低 = 3:1T高​/T低​=3:1 或者 T高/T低=2:1T_高/T_低 = 2:1T高​/T低​=2:1 实例：利用Canny函数进行边缘检测。 123456789# 30.canny边缘检测image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\standingCat.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# canny边缘检测，可以使用这种不用提供gradx、grady的APIedge_detect = cv.Canny(image,50,150)cv.imshow(&#x27;edge detect&#x27;,edge_detect)cv.waitKey(0) 2.8 直线、圆、轮廓检测 2.8.1 直线检测：霍夫变换 给定一副图像（一般是二值图像，像素值对检测直线没有作用）如何检测是否存在直线？ 一种很直观的想法：任选一对点，决定一条线，然后测试所有其他点是否接近这条线，从而得出接近这条特殊线的所有点的子集。 但是这种方法比较复杂，我们通常使用的 霍夫变换 。 在了解霍夫变换，我们先来了解什么是 对偶性 。 对偶性 我所理解的对偶性：将直角坐标系的 点 对应 参数空间的 直线。 在直角空间x−yx-yx−y，过点A(x0,y0)A(x_0,y_0)A(x0​,y0​) 所有直线确定一簇直线，都满足方程：y0=k∗x0+by_0=k*x_0+by0​=k∗x0​+b 。 如果转换参数空间 k−bk-bk−b ，那么过点A(x0,y0)A(x_0,y_0)A(x0​,y0​) 所有 直线就可以描述为 一条 直线：b=−kx0+y0b=-kx_0+y_0b=−kx0​+y0​: 在参数空间k−bk-bk−b ，斜率是点 AAA 横坐标 −x0-x_0−x0​ , 截距是点AAA 纵坐标 y0y_0y0​ 那么如果在直角坐标系存在多个点在同一直线l1(斜率=k1,截距=b1)l_1(斜率=k_1,截距=b_1)l1​(斜率=k1​,截距=b1​)上，也就是说：它们在参数空间k−bk-bk−b 必然会交于一点 (k1,b1)(k_1,b_1)(k1​,b1​) 。 如果有n个点在一条直线上，那么在参数空间就会存在对应交于n个点，那么在参数空间相交直线最多的点(k,b)(k,b)(k,b) , 就是我们在 x−yx-yx−y 直角坐标对应直线斜率和截距的解 。 霍夫变化&amp;参数空间选择 上述参数空间是选择直角坐标系空间 k−bk-bk−b , 但是这样会带来一个问题：无法检测垂直直线 因此我们考虑将参数空间转换到极坐标系 r−θr-\\thetar−θ : ⚠️ 为什么映射到极坐标是曲线？ 为什么给定恒等式 xcosθ+ysinθ=pxcos\\theta+ysin\\theta=pxcosθ+ysinθ=p 进行变换？ 同前，在极坐标系相交最多的点(θ，p)(\\theta，p)(θ，p) ，便可转换到直角坐标系求解对应斜率和截距。 理论上，一个点会对应无数条直线，在参数空间 p−θp-\\thetap−θ 自然也是连续的。但事实上，我们会规定直线的数量，将 θ\\thetaθ 离散化为等间距离散值，相应ppp 也离散为等间距离散值。 这样，参数空间就是一个等大小*网格* 。当参数空间有直线相交于这个点，则网格累加器+1： HoughLines() 霍夫变换，利用openCV检测图像具体流程可总结如下： 彩色图像-&gt;灰度图 去噪（高斯核） 边缘提取（canny、sobel） ⚠️ Canny方法中包含计算梯度，非最大信号抑制和双阈值输出 二值化（判断此处是否为边缘点，就看灰度值==255） 映射到霍夫空间 取局部极大值，设定阈值，过滤干扰直线 绘制直线、标定角点 下面代码没有进行第三步二值化，是因为 canny自带二值化吗？ 对的 rho：生成极坐标像素扫描步长（离散化） theta：生成极坐标时扫描角度步长（离散化） threshold：只有足够交点的极坐标才被认为是直线 实例：利用openCV &amp; 霍夫变换来检测图像直线。 为什么检测直线图像上面总是出现这些不正常直线？ 12345678910111213141516171819202122232425262728293031323334353637383940# 31.霍夫变换image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\building.jpg&quot;)# 0.高斯滤波（效果也不好，最好取消这步了）# image = cv.GaussianBlur(image,(3,3),0)cv.imshow(&#x27;origin&#x27;,image)# 1.转换为灰度图gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)# 2.边缘检测canny# 分别设定阈值像素为50、150，sobel算子大小=3edges = cv.Canny(gray,50,150,apertureSize=3)# 3.霍夫变换# 生成极坐标扫描步长=1，角度=1°，至少有200个交点才认为是直线lines = cv.HoughLines(edges,1,np.pi/180,200)# 4.画出直线for line in lines: r,theta = line[0] # 极坐标p、θ # 计算直线两端点 # 为什么是这么计算也不清楚？ cos = np.cos(theta) sin = np.sin(theta) x0 = r*cos y0 = r*sin # 计算直线最大点(x1,y1) x1 = int(x0 + 1000 * (-sin)) y1 = int(x0 + 1000 * (cos)) # 计算直线最小点(x2,y2) x2 = int(x0 - 1000 * (-sin)) y2 = int(x0 - 1000 * (cos)) # 画出直线 cv.line(image,(x1,y1),(x2,y2),(0,0,255),2)cv.imshow(&#x27;detect line&#x27;,image)cv.waitKey(0) HoughLinesP() 霍夫概率变换是霍夫变换的加强版： 原理：暂略，待补 API：效果和API接口都比霍夫变换要好很多 实例：利用openCV &amp; 霍夫变换来检测图像直线。 123456789101112131415161718192021# 32.霍夫概率变换image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\building.jpg&quot;)# 0.进行高斯模糊（实测效果变好）# ksize和sigma可以互相计算，故指定sigmaX=0image = cv.GaussianBlur(image,(3,3),0)cv.imshow(&#x27;origin&#x27;,image)# 1.转换为灰度图gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)# 2.边缘检测cannyedges = cv.Canny(gray,50,150,apertureSize=3)# 3.霍夫概率变换lines = cv.HoughLinesP(edges,1,np.pi/180,200,minLineLength=50,maxLineGap=10)for line in lines: x1,y1,x2,y2 = line[0] cv.line(image, (x1, y1), (x2, y2), (0, 0, 255), 2)cv.imshow(&#x27;detect line&#x27;,image)cv.waitKey(0) 2.8.2 圆检测：霍夫变换 在前，若干点在同一直线上，则它们必有一条直线y=kx+by=k x+by=kx+b 经过它们。为了解算出k、bk、bk、b 我们将这 若干点 变换到极坐标参数空间k−bk-bk−b 得到对应 若干曲线 , 这些曲线若存在交点A(ka,ba)A(k_a,b_a)A(ka​,ba​) 则说明存在一条直线 y=kax+bay=k_a x+b_ay=ka​x+ba​ 使得它们在同一直线上。 那如何确定几个点是在同一圆上？ 在 x−yx-yx−y 坐标系，圆表达式可写作：(x−a)2+(y−b)2=r(x-a)^2+(y-b)^2 = r(x−a)2+(y−b)2=r 。 同样将其映射到参数空间 r−a−br-a-br−a−b 中。 ⚠️ 上有三个参数rabrabrab，在OpenCV中可通过设定rrr 范围，循环遍历rrr 值，则只在二维空间a−ba-ba−b 寻找圆心(a,b)(a,b)(a,b) 即可。 那么，在二维空间a−ba-ba−b , 圆(x−a)2+(y−b)2=r(x-a)^2+(y-b)^2 = r(x−a)2+(y−b)2=r 被映射成什么样子？ 显然也是个圆，此时圆心是 (x,y)(x,y)(x,y) , rrr 已知 ：(a−x)2+(b−y)2=r(a-x)^2+(b-y)^2 = r(a−x)2+(b−y)2=r 。 假设在 x−yx-yx−y 坐标系存在三个点 a(x1,y1)、b(x2,y2)、a(x2,y2)a(x_1,y_1)、b(x_2,y_2)、a(x_2,y_2)a(x1​,y1​)、b(x2​,y2​)、a(x2​,y2​) 。显然它们任意一个点，由于圆心(a,b)(a,b)(a,b) 不确定，在x−yx-yx−y 坐标系可以画出无数个圆。 三个点映射到 a−ba-ba−b 二维空间，则为确定的一个圆，圆心分别为a(x1,y1)、b(x2,y2)、a(x2,y2)a(x_1,y_1)、b(x_2,y_2)、a(x_2,y_2)a(x1​,y1​)、b(x2​,y2​)、a(x2​,y2​) 如果它们在同一个圆上，那么必然存在一个圆，圆心为(a1,b1)(a_1,b_1)(a1​,b1​) 半径为rrr ，都经过这三个点。换言之，在参数空间这三个点对应的圆必然会交于一个点(a1,b1)(a_1,b_1)(a1​,b1​) 。由于在假设半径rrr 值情况遍历搜寻，那么此时半径已知。至此，圆就被确定下来了。 当然，上述过程三个点在参数空间对应的圆交于一个点，就确定一个点还是太少了。实际可以指定更多点交于一个点才认为确实存在圆。 HoughCircles() 下面是基本API用法。 method : 检测圆方法，例如霍夫梯度法：CV_HOUGH_GRADIENT dp：检测圆心的累加器图像的分辨率于输入图像之比的倒数。dp= 1时，累加器和输入图像具有相同的分辨率。如果dp=2，累加器便有输入图像一半那么大的宽度和高度 minDist：圆的圆心之间的最小距离。参数如果太小，多个相邻的圆可能被错误地检测成了一个重合的圆。反之，参数设置太大的话，某些圆就不能被检测出来了。 param1：默认值100。是第三个参数method设置的检测方法的对应的参数，对于霍夫梯度法CV_HOUGH_GRADIENT，它表示传递给canny边缘检测算子的高阈值，低阈值为高阈值的一半。 param2：默认值100。同上，对于霍夫梯度法CV_HOUGH_GRADIENT，它表示检测阶段圆心的累加器阈值。它越小的话，就可以检测到更多根本不存在的圆，而它越大的话，能通过检测的圆就更加接近完美的圆形了。 minRadius、maxRadius ： 表示设置圆半径的最小值和最大值。 实例：使用HoughCircles() 检测图像中存在的圆形。 123456789101112131415161718192021# 33.霍夫变换圆检测image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\circles.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# 霍夫变换易受噪声影响，先进行均值漂移滤波减少噪声dst = cv.pyrMeanShiftFiltering(image,10,100)# 转换为灰度图gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)# 霍夫变换圆检测# param1、param2调参很重要。最开始param1=50，效果很差，canny的高阈值设置太低circles = cv.HoughCircles(gray,cv.HOUGH_GRADIENT,1,20,param1=100,param2=30,minRadius=0,maxRadius=0)# 画圆[注意维度问题]# circles.shape=（1,3,3）,第一个维度不明。第二个维度是圆个数，第三个维度对应圆三个参数for i in circles[0,:]: cv.circle(image,(i[0],i[1]),i[2],(0,0,255),2)cv.imshow(&#x27;circles&#x27;,image)cv.waitKey(0) 2.8.3 轮廓检测 原理 待补充 findContours 原理不懂，API看得也稀里糊涂的。参数意义可以参考 ：轮廓发现 整个API操作步骤可以总结如下： 对图像进行高斯滤波，减少噪声 转换为二值图像：threshold 或者 canny 边缘提取都可 通过二值图像寻找轮廓：findContours 描绘轮廓：drawContours 实例1：寻找图像轮廓（通过threshold获取二值图像） 1234567891011121314151617181920212223242526272829# 34.轮廓发现（通过threshold获取二值图像）image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\circles.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# 0.高斯滤波图像减少噪声GaussianImg = cv.GaussianBlur(image,(3,3),0)# 1.转换为灰度图像grayImg = cv.cvtColor(GaussianImg,cv.COLOR_BGR2GRAY)# 2.threshold 获取二值图像# 如果选择二值方式是 cv.THRESH_BINARY，由于原图像素&gt;0,结果就是二值化图全白色# cv.THRESH_OTSU：是最大间差法，按图像灰度特性将图像分为前景和背景两部分ret,binaryImg = cv.threshold(grayImg,0,255,cv.THRESH_BINARY|cv.THRESH_OTSU)cv.imshow(&#x27;binaryImg&#x27;,binaryImg)# 3.findContours 轮廓提取# cv.RETR_EXTERNAL 获取外部轮廓 ； cv.CHAIN_APPROX_SIMPLE cloneImage,contours,heriachy= cv.findContours(binaryImg,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)# 4. drawContours 绘出轮廓for i,contour in enumerate(contours): # 注意第二个参数是传递所有轮廓！ cv.drawContours(image,contours,i,(0,0,255),-1) print(i)cv.imshow(&#x27;detect contours&#x27;,image)cv.waitKey(0) 实例2：寻找图像轮廓（通过canny获取二值图像） 123456789101112131415161718192021222324# 35.轮廓发现（通过canny获取二值图像）image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\circles.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# 0.高斯滤波图像减少噪声GaussianImg = cv.GaussianBlur(image,(3,3),0)# 1.转换为灰度图像grayImg = cv.cvtColor(GaussianImg,cv.COLOR_BGR2GRAY)# 2.canny 获取二值图像binaryImg = cv.Canny(grayImg,50,150)cv.imshow(&#x27;binaryImg&#x27;,binaryImg)# 3.findContours 轮廓提取cloneImage,contours,heriachy= cv.findContours(binaryImg,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)# 4. drawContours 绘出轮廓for i,contour in enumerate(contours): cv.drawContours(image,contours,i,(0,0,255),-1)cv.imshow(&#x27;detect contours&#x27;,image)cv.waitKey(0) 2.9 对象测量 这部分对象测量主要包含两个部分： 基于前2.8 节 发现轮廓 后对轮廓进行 计算弧长和面积 对发现的轮廓进行多边形拟合 2.9.1 面积&amp;多边形拟合… 原理 待补充 API cv.contourArea(contour) ：获取每个轮廓面积 cv.boundingRect(contour) ：获取轮廓的外接矩形 cv.moments(contour) ：求取轮廓的几何距 cv.arcLength(contour,True) ：求取轮廓的周长，指定闭合 过程总结 获取灰度图像：cvtColor 二值化图像：threshold 或 canny 发现轮廓：findContours 计算面积 / 周长/多边形拟合 等 实例：获取图像面积、绘出外接矩形框、根据几何距计算轮廓中心（不明白原理） 12345678910111213141516171819202122232425262728293031323334353637383940414243# 36.对象测量# 计算面积、绘出外接矩形、根据几何距计算轮廓中心（不明白）image = cv.imread(r&quot;C:\\\\Users\\\\86151\\\\Pictures\\\\circles.jpg&quot;)cv.imshow(&#x27;origin&#x27;,image)# 1.转换为灰度图像grayImg = cv.cvtColor(image,cv.COLOR_BGR2GRAY)# 2.threshold 获取二值图像ret,binaryImg = cv.threshold(grayImg,0,255,cv.THRESH_OTSU)cv.imshow(&#x27;binaryImg&#x27;,binaryImg)# 3.发现轮廓cloneImage,contours,heriachy= cv.findContours(binaryImg,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)# 4.计算轮廓面积、外接矩形、求中心点# debug：在二值图像化没反应？for i,contour in enumerate(contours): # 计算轮廓面积 area = cv.contourArea(contour) # print(area) # 绘制外接矩形 x,y,w,h = cv.boundingRect(contour) cv.rectangle(image,(x,y),(x+w,y+h),(0,0,255),1) # 根据几何距获取中心点并绘制 m = cv.moments(contour) # 获取几何距 if m[&#x27;m00&#x27;] == 0: # 有可能出现 m[&#x27;m00&#x27;] == 0 continue else: cx = m[&#x27;m10&#x27;] / m[&#x27;m00&#x27;] # 中心x cy = m[&#x27;m01&#x27;] / m[&#x27;m00&#x27;] # 中心y cv.circle(image,(np.int(cx),np.int(cy)),1,(0,255,0),-1) # 拟合多边形 # 4是与阈值的间隔大小，越小越易找出，True是是否找闭合图像 # 返回拟合曲线 approxCurve = cv.approxPolyDP(contour, 4, True) # 如果拟合曲线的边数大于4则绘出（三角形、四边形等&lt;=4就不会绘出） if approxCurve.shape[0] &gt; 4: cv.drawContours(image, contours, i, (255, 0, 0), 2) cv.imshow(&#x27;draw&#x27;,image)cv.waitKey(0) 2.10 图像形态学","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://hwh.zone/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"OpenCV","slug":"深度学习/OpenCV","permalink":"https://hwh.zone/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/OpenCV/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://hwh.zone/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://hwh.zone/tags/OpenCV/"}]},{"title":"深度学习基础（二）Pytorch","slug":"深度学习基础（二）Pytorch","date":"2021-11-25T09:00:17.449Z","updated":"2021-11-26T09:46:36.496Z","comments":true,"path":"2021/11/25/深度学习基础（二）Pytorch/","link":"","permalink":"https://hwh.zone/2021/11/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89Pytorch/","excerpt":"","text":"PTboy：PyTorch 一、快速入门 本笔记主要参考：pytorch中文教程 、pytorch开源书籍中文教程 1.1 安装 进入 PyTorch官网 我们可以看到需要安装的软件和版本： Package：包管理软件，可以用 pip ，为了方便我们使用 Conda CUDA : 显卡加速软件，GPU 跑一定要下载，CPU 不用。我们显卡是 GTX 1650 ，GPU 勉强可以跑得动，故下载。 下面依次详细记录安装 Conda &amp; CUDA 。 1.1.1 安装 AnaConda 安装参考 ： Anaconda详细安装及使用教程 官网下载： AnaConda最新版本 。太慢了，选择 : 腾讯软件下载AnaConda 。 下载完毕后开始安装，一直下一步就好 ，有两个地方需要说明： 安装路径：安装路径需要英文懒得折腾，直接默认安装路径了 环境变量：在安装过程中可以勾选自动添加环境变量，记得勾选 如果安装成功，且环境变量配置成功，在 cmd 输入 conda -V 可以看到如下版本信息： Conda 使用初体验 以下操作都是命令行，在 cmd 环境中进行。 创建虚拟环境： 更新所有包：conda upgrade --all 创建虚拟环境：conda create --name ptboy python=3.7 切换环境 &amp; 查看已创建环境：activate ptboy &amp; conda env list 切换/退出 python 解释器：python 、exit() 包管理 ： 安装 / 卸载 包 ： conda install 要安装的包名 、conda remove 要卸载的包名 和 pycharm 连接： 下面略有不对，可参考这篇文章：Anaconda与pycharm连接 File --&gt; Settings --&gt; Project:你的项目名 ---&gt; Project Interpreter ，然后 Add ： 设置虚拟环境python解释器： 1.1.2 安装 CUDA &amp; cuDNN 安装 CUDA 🙂 狗日的fuck 中国移动网卡，浪费我一天时间检查网络，原来是你这🐶 东西限我速！ 首先我们去官网下载 CUDA ：CUDA 10.1 下载 点击右下角 Download[2.5GB] 下载即可。 下载完毕后，解压默认会提取到临时目录，不用修改（临时目录会自动删除） 一直下一步 --&gt; 自定义安装 ，勾选以下： ⚠️ 一般安装出错都是由于 Visual Studio Intergration ，所以去除掉，实际我也用不到 VS 环境。 如果需要VS环境，可参考这篇文章：CUDA安装失败原因解决 。 下一步，使用默认安装位置，不折腾了： 一直下一步安装，很快便会显示安装完成了。 接着便是最重要容易出错的 环境变量配置了 ： ⚠️ 下面都是默认安装路径，如果需要自定义安装注意修改环境变量路径名。 高级系统设置 --&gt; 环境变量 --&gt; 系统变量，添加以下几个环境变量： CUDA_SDK_PATH = C:\\ProgramData\\NVIDIA Corporation\\CUDA Samples\\v10.1 CUDA_LIB_PATH = %CUDA_PATH%\\lib\\x64 CUDA_BIN_PATH = %CUDA_PATH%\\bin CUDA_SDK_BIN_PATH = %CUDA_SDK_PATH%\\bin\\win64 CUDA_SDK_LIB_PATH = %CUDA_SDK_PATH%\\common\\lib\\x64 高级系统设置 --&gt; 环境变量 --&gt; 系统变量 --&gt; PATH , 添加： C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\lib\\x64 C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\bin C:\\ProgramData\\NVIDIA Corporation\\CUDA Samples\\v10.1\\common\\lib\\x64 C:\\ProgramData\\NVIDIA Corporation\\CUDA Samples\\v10.1\\bin\\win64 在cmd 键入 nvcc -V 来查看是否正确安装： 安装 cuDNN 我们继续开始安装 cuDNN ，下载cuDNN 地址：cuDNN 7.6.4 下载 ⚠️ 下载前要先注册会员，选择 QQ登陆马上就注册好了？ 点击上述红框位置下载即可，解压文件复制下图所示3个文件： 然后找到 CUDA 安装目录（我之前是默认），复制替换对应下面三个文件： 整体测试安装 切换到目录(默认) ：C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\extras\\demo_suite 可以看到上述两个程序：bandwidthTest.exe 、deviceQuery.exe 两个测试程序。 在 cmd 中运行这两个测试程序： 出现以上信息则证明安装成功。 第一次安装出错：原因是驱动版本跟不上 CUDA 版本。 解决办法如下，下载 NVIDIA GeForce Experience ：腾讯下载 NVIDIA GeForce Experience 。 打开软件更新驱动，下载 GeForce Game Ready Driver： 安装，会提示你更新驱动，直接更新就好。再次运行便会发现可以正常运行测试信息了。 1.1.3 安装 pytorch 进入官网，我们可以看到安装命令： 1conda install pytorch torchvision torchaudio cudatoolkit=10.2 -c pytorch 尝试替换源加快速度。 参数 -c pytorch 指的是 pytorh 官方仓库，由于速度太慢我们换成清华源： 12345conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/conda config --set show_channel_urls yes ⚠️ 一开始好像没有引用 pytorch 清华源（第三个），一直官方安装不成功。 再执行安装命令即可快速安装了： 1conda install pytorch torchvision cudatoolkit=10.1 最后切换到 python 解释器，输入 import torch ，不报错则安装成功了： 12(ptboy) C:\\Users\\86151&gt;python&gt;&gt;&gt; import pytorch 补充 一开始由于安装太慢尝试各种办法，删除了 .condarc文件(everything进行搜索) 默认通道 default （最后一行）。最终文件内容如下： 12345channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/show_channel_urls: true 1.1.4 安装使用 jupyter 该部分主要参考于 ：Jupyter Notebook介绍、安装及使用教程 快速启动 安装 进入到 cmd 界面进行安装。我最开始想在指定环境 activate ot下安装，显示缺少依赖。 我想后面还可以设置引用环境为 ot ，就不管了。 1conda install jupyter 启动 启动后界面那一堆文件，其实是我们家目录中的文件。 在 cmd 窗口输入下面命令，会自动在浏览器打开 jupyter。 ⚠️ 不要关闭 cmd 否则在 Jupyter 中也无法继续操作！ 1jupyter notebook 如果想换个浏览器打开，可以查看到 cmd 中有 token 值： 输入 http://localhost:8080 在键入上述token 即可！ 也可以使用 jupyter notebook list 查看token 值。 启动配置 指定端口启动： 1jupyter notebook --port &lt;port_number&gt; 启动但不打开服务器： 1jupyter notebook --no-browser 设置文件保存路径 仅说如何在 windows 设置，linux 参照最开始提到的教程。 默认保存文档是在家目录，我们可以修改想要保存文件的目录。首先查询配置文件地址： 1jupyter notebook --generate-config 编辑该配置文件：找到 c.NotebookApp.notebook_dir 取消注释配置自己想保存的路径 实际测试最好用 \\\\ , 成功后再启动就能看见一个清爽的界面 基本使用 主界面 &amp; 笔记本页面简介 根据上图我们创建一个.ipynb 文件，编辑上面测试代码 &amp; md文字 进行输出。 ESC 进入命令模式 ： a 在当前cell创建一个cell b 在当前cell之后创建一个cell m 进入 markdown 模式（单元格前面 In[] 没了） y 进入 code （单元格前面 In[] 又出现了） l 显示 cell 中总行数 dd 删除当前cell 扩展功能 扩展功能1 ： 关联 Jupyter Notebook和 conda 环境。 安装 nb_conda 1conda install nb_conda ⚠️ 出现报以下错误 摸不着头脑，我主要做了以下事就可以了： conda clean -- packages (好像没软用) 修改了下文件 .condarc 去除清华源换成别的源（？？） 愉快查看环境 此时在 jupyter 会增加一列 Conda 我们可以查看Conda 拥有的环境变量。 ⚠️ 但是此时不能直接点击切换环境，如 ot 查看环境又他娘报错： 解决报错： 切换 conda 环境 如果想要指定 conda 指定环境，经过测试要先在cmd 激活指定环境： 1activeta ot 然后再启动 Jupyter ，即发现此时 conda 环境以及切换到 ot ： 扩展2：在 jupyter 使用 markdowm ⚠️ 一开始报各种错误，又是 conda.exe 不存在 / 产生冲突。解决如下： 卸载 Anaconda 有些冲动了，感觉可以不卸载。 新建环境 base0 ⚠️ 最开始安装 3.7 版本，后面安装扩展显示报错产生冲突。 1conda create --name base0 --python=3.5 接下来以下命令都能正常执行了。 经过测试实际可行的安装扩展插件方法： 用 pip 安装扩展 1pip install conda-forge jupyter_contrib_nbextensions 解决安装的相关依赖 执行 1. 命令会显示要先安装 lxml 之类，为了速度先直接用conda 安装： 1conda install lxml 安装扩展 1pip install conda-forge jupyter_contrib_nbextensions 这样就可以快速安装好扩展了。 但是打开扩展可能出现下面问题： 尝试执行下面命令即可解决： 1jupyter contrib nbextensions install --sys-prefix --skip-running-check 安装扩展 1conda install -c conda-forge jupyter_contrib_nbextensions 开始使用 markdown 点击导航栏多出来的 Nbextensions 类目，勾选 Tableof Contents ⑵ 。 然后便可以在 Jupyter 中使用 markdown 了 ： 补充使用 加载各种 加载指定网址源码 1%load URL 加载本地 python 文件 1%load Python文件的绝对路径 🙂 其实你不想加载 python 文件再运行，也可直接运行文件。 1%run Python文件的绝对路径 使用 shell 命令 1!shell命令 !pwd : 获取当前笔记本所在绝对路径位置 也可在 jupyter 打开终端 ， new —&gt; Terminal 。 快捷键 按esc键进入命令模式，此时不能操作单元格 按enter或return键进入编辑模式，可编辑单元格 1.2 张量 1.2.1 生成张量 以下都需引入如下包。 12from __future__ import print_functionimport torch 库函数生成 类似于 numpy 库函数生成ndarray，但有时候 numpy 传入有时是triple，而 pytorch 传入基本都是 int 12345678# empty ： 没有初始化的张量（元素随机）torch.empty(5, 3)# rand：随机初始化张量torch.rand(5, 3)# zeros：生成全零张量torch.zeros(5, 3, dtype=torch.long) # 同时还指定元素类似为 long 直接构造 12x = torch.tensor([5.5, 3])print(x)Copy 输出： 1tensor([5.5000, 3.0000]) 根据已有张量构造 123456X = torch.zeros(3,3)print(X)# 根据X实例方法 new_ones 生成全0张量，大小也可改变（那不等于直接库函数创建？）X1 = X.new_ones(2,2,dtype=torch.double)print(X1) 输出： 12345tensor([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]])tensor([[1., 1.], [1., 1.]], dtype=torch.float64) 1.2.2 常用张量方法 形状相关 123456789101112# 1.查看形状X.size() # 输出：torch.Size([3, 3])# 2.改变形状 &gt;&gt;&gt; x = torch.randn(4, 4)torch.Size([4, 4])&gt;&gt;&gt; y = x.view(16)torch.Size([16])&gt;&gt;&gt; z = x.view(-1, 8) # 参数为-1，指的是这个维度根据：元素个数/其它维度 ，自动计算出来torch.Size([2, 8]) 索引操作 类似 numpy 进行各种索引操作。 12345&gt;&gt;&gt; x = torch.rand(3,3)&gt;&gt;&gt; xtensor([[0.3667, 0.7708, 0.9581], [0.0958, 0.6113, 0.3566], [0.6013, 0.0894, 0.2580]]) 切片索引： 123# 索引第2列&gt;&gt;&gt; x[:,1]tensor([0.7708, 0.6113, 0.0894]) 不想写了…今天是 2019 / 11 / 12 16:58 ，我是青青草原带灰狼哈哈 numpy数组 ⇄ Torch 张量 ndarray 数组每个元素之间是空格 ，Tensor 是 逗号 。 torch 张量 → numpy 数组 ： 1234# numpy()a = torch.ones(5) # 张量 : tensor([1., 1., 1., 1., 1.])b = a.numpy() # ndarray :[1. 1. 1. 1. 1.] torch 张量 ← numpy 数组 ： 1234# torch.form_numpy()a = np.ones(5) # ndarray：[1. 1. 1. 1. 1.]b = torch.from_numpy(a) # 张量： tensor([1., 1., 1., 1., 1.]) 1.2.3 张量运算 加减乘除 仅以加法为例，更多上百种运算参考：这里 1234567891011# 1.直接相加y = torch.rand(5, 3)print(x + y)# 2.库函数 torch.addtorch.add(x, y)# 3.张量实例本身函数（in-place）y.add_(x) # adds x to y# 其它in-place操作x.copy_(y) # 复制y到x 1.3 自动求导 pytorch 在所有神经网络的核心是 autograd 包，而autograd 包核心类是 torch.Tensor 。 如何进行自动求导 ： 给希望追踪对它进行求导的张量x，设置属性 requires_grad = True 当完成计算后，通过调用 backward(gradient) 方法，自动计算所有的梯度（自动累加到 grad 属性） 调用 backward() 方法需要指定一个参数gradient，该参数匹配张量形状 ？ 特别的，如果此时张量是标量，可不传入参数，等价此时 gradient = torch.tensor(1) 。 通过被追踪的张量 x 属性值 grad ，即 x.grad 便可求出它的梯度 如果不希望跟踪历史记录 ： 将代码块包装在 with torch.no_grad()： 中 1.3.1 关于 Function Function 是自动求导另外一个非常重要的*类* 。Tensor类 和 Function类互相连接并生成一个非循环图，它表示和存储了完整的计算历史。 每个张量都有一个.grad_fn属性，这个属性引用了一个创建了Tensor的Function （没太明白 ？） 1.3.2 向量求导（没太整明白） 已知 y⃗=f(x⃗)\\vec y = f(\\vec x)y​=f(x) ， 其中 y⃗\\vec yy​ 和 x⃗\\vec xx 都是向量，那么 y⃗\\vec yy​ 对 x⃗\\vec xx 的梯度形式应该是？ 在数学上，∂y⃗∂x⃗\\frac{\\partial \\vec y}{\\partial \\vec x}∂x∂y​​ 应该是一个雅可比矩阵，可记为 JJJ : J=[∂y⃗1∂x⃗1 ... ∂y⃗m∂x⃗1...∂y⃗1∂x⃗n ... ∂y⃗m∂x⃗n]J = \\begin{bmatrix} \\frac{\\partial \\vec y_1}{\\partial \\vec x_1} \\ ... \\ \\frac{\\partial \\vec y_m}{\\partial \\vec x_1} \\\\ ... \\\\ \\frac{\\partial \\vec y_1}{\\partial \\vec x_n} \\ ... \\ \\frac{\\partial \\vec y_m}{\\partial \\vec x_n} \\end{bmatrix} J=⎣⎡​∂x1​∂y​1​​ ... ∂x1​∂y​m​​...∂xn​∂y​1​​ ... ∂xn​∂y​m​​​⎦⎤​ 已知 l=g(y⃗)l=g(\\vec y)l=g(y​) 其中 lll 为标量 ，那么 ∂l∂y⃗\\frac{\\partial l }{\\partial \\vec y}∂y​∂l​ 梯度vvv 形式应该是？ v=[∂l∂y1 ... ∂l∂ym]Tv = \\begin{bmatrix} \\frac{\\partial l }{\\partial y_1} \\ ... \\ \\frac{\\partial l }{\\partial y_m} \\end{bmatrix} ^T v=[∂y1​∂l​ ... ∂ym​∂l​​]T 根据上述，我们已知 J=∂y⃗∂x⃗J = \\frac{\\partial \\vec y}{\\partial \\vec x}J=∂x∂y​​ ， v=∂l∂y⃗v =\\frac{\\partial l }{\\partial \\vec y}v=∂y​∂l​ , 那么 ∂l∂x⃗\\frac{\\partial l }{\\partial \\vec x}∂x∂l​ ? 根据链式法则： ∂l∂x⃗\\frac{\\partial l }{\\partial \\vec x}∂x∂l​ = ∂l∂y⃗⋅∂y⃗∂x⃗\\frac{\\partial l }{\\partial \\vec y} · \\frac{\\partial \\vec y}{\\partial \\vec x}∂y​∂l​⋅∂x∂y​​ ∂l∂x⃗=∂l∂y⃗⋅∂y⃗∂x⃗=J⋅v=[∂y⃗1∂x⃗1 ... ∂y⃗m∂x⃗1...∂y⃗1∂x⃗n ... ∂y⃗m∂x⃗n][∂l∂y1...∂l∂ym]=[∂l∂x1...∂l∂xm]\\frac{\\partial l }{\\partial \\vec x} = \\frac{\\partial l }{\\partial \\vec y} · \\frac{\\partial \\vec y}{\\partial \\vec x} = J·v = \\begin{bmatrix} \\frac{\\partial \\vec y_1}{\\partial \\vec x_1} \\ ... \\ \\frac{\\partial \\vec y_m}{\\partial \\vec x_1} \\\\ ... \\\\ \\frac{\\partial \\vec y_1}{\\partial \\vec x_n} \\ ... \\ \\frac{\\partial \\vec y_m}{\\partial \\vec x_n} \\end{bmatrix} \\begin{bmatrix} \\frac{\\partial l }{\\partial y_1} \\\\ ... \\\\ \\frac{\\partial l }{\\partial y_m} \\end{bmatrix} = \\begin{bmatrix} \\frac{\\partial l }{\\partial x_1} \\\\ ... \\\\ \\frac{\\partial l }{\\partial x_m} \\end{bmatrix} ∂x∂l​=∂y​∂l​⋅∂x∂y​​=J⋅v=⎣⎡​∂x1​∂y​1​​ ... ∂x1​∂y​m​​...∂xn​∂y​1​​ ... ∂xn​∂y​m​​​⎦⎤​⎣⎡​∂y1​∂l​...∂ym​∂l​​⎦⎤​=⎣⎡​∂x1​∂l​...∂xm​∂l​​⎦⎤​ 1.3.3 举个栗子 1import torch 栗子1 以下过程可表示为 ：out=14∑izi=14∑i3(xi+2)2out = \\frac{1}{4} \\sum_i z_i = \\frac{1}{4} \\sum_i 3(x_i+2)^2out=41​∑i​zi​=41​∑i​3(xi​+2)2 1234x = torch.ones(2,2,requires_grad=True) # 追踪张量xy = x + 2z = y * y * 3out = z.mean() out 调用方法 backward 进行反向传播，因为 out 是标量，所以可不用传参数： cvb n 1out.backward() 由于 x 设置了 requires_grad = True ，其梯度会被自动累加，我们可计算其梯度为： 12345x.grad# 输出# tensor([[4.5000, 4.5000],# [4.5000, 4.5000]]) Q : 没明白，根据 1.3.2 节，此时输出不该是一个 4*1 大小张量吗？ A: 非也，因为此时x 是 2*2 大小，而 1.3.2 节 x 是 m*1 大小 栗子2 以下过程可表示为： y=(x∗2)2∗y.data.normy = (x*2)^{2*y.data.norm}y=(x∗2)2∗y.data.norm 12345678910x = torch.randn(3, requires_grad=True)y = x * 2while y.data.norm() &lt; 1000: y = y * 2print(y)# 输出y# tensor([-920.6895, -115.7301, -867.6995], grad_fn=&lt;MulBackward&gt;) 显然，此时 yyy 是一个向量，那么此时调用 backward 进行反向传播需传递参数 gradient ： 依然不太明白此时 gradient 参数意义？ 大小和 x 保持一致，那么其中的列表值是什么意思呢？ 经过请教大师兄，解释如下： gradient 参数表示学习速率 α\\alphaα ，当 α=1\\alpha = 1α=1 时 x.grad = 512 ；α=0.1\\alpha = 0.1α=0.1 ,那么 x.grad = 51.2。 控制当前梯度变化速率，而且可对于每个不同样本 xix_ixi​ 进行控制。 123456gradients = torch.tensor([0.1, 1.0, 0.0001], dtype=torch.float)y.backward(gradients)print(x.grad)# tensor([ 51.2000, 512.0000, 0.0512]) 1.4 神经网络 我的神经网络都是没有好好训练啊，做笔记还在胡思乱写，现在反向传播还来得及吗？ 14.1 快速入门 定义网络 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import torchimport torch.nn as nnimport torch.nn.functional as Fclass Net(nn.Module): def __init__(self): super(Net, self).__init__() # class torch.nn.Conv1d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True) # 输入图像channels：1；输出channels：6；kernel = 5x5，方阵可只写一个数字5 self.conv1 = nn.Conv2d(1, 6, 5) self.conv2 = nn.Conv2d(6, 16, 5) # class torch.nn.Linear(in_features, out_features, bias=True) # in_features ： 输入样本的大小 # out_features： 输出样本的大小 # nn.Linear 传入相连两个layer各自大小，返回一个函数fc(x),可用来计算前向传播下一层layer值 self.fc1 = nn.Linear(16 * 5 * 5, 120) self.fc2 = nn.Linear(120, 84) self.fc3 = nn.Linear(84, 10) def forward(self, x): # torch.nn.functional.max_pool2d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False) # input：输入的张量。在这里激活函数为relu，会将神经元输入值映射到新值（输出值） x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2)) x = F.max_pool2d(F.relu(self.conv2(x)), 2) x = x.view(-1, self.num_flat_features(x)) # 和全连接层相连先平铺 x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = self.fc3(x) return x def num_flat_features(self, x): &quot;&quot;&quot; 平铺卷积层图像特征向量： 因为输入图片size = (1,1,32,32),表示输入1张大小为1@32*32的特征图 显然第一个参数1，指图片个数，也就是一次批处理的数量 &quot;&quot;&quot; size = x.size()[1:] # 除去批处理维度的其他所有维度，[1,16,5,5] --&gt; [16,5,5] num_features = 1 for s in size: num_features *= s return num_featuresnet = Net() 现在让我们进行前向传播和反向传播、更新权重等。下一节将会以实际例子来统合下面方法。 前向传播 12input = torch.randn(1, 1, 32, 32) # 随机输入一张图像out = net(input) # 前向传播 输出： 12tensor([[ 0.0399, -0.0856, 0.0668, 0.0915, 0.0453, -0.0680, -0.1024, 0.0493, -0.1043, -0.1267]], grad_fn=&lt;AddmmBackward&gt;) 损失函数 一个损失函数接受一对 (output, target) 作为输入，nn 包多个不同损失函数。 例如：均方误差损失函数MSE，nn.MSELoss() 123456output = net(input)target = torch.randn(10) # 本例子中使用模拟数据target = target.view(1, -1) # 使目标值与数据值形状一致,size=(1,10)criterion = nn.MSELoss()loss = criterion(output, target) # tensor(1.0263, grad_fn=&lt;MseLossBackward&gt;) 反向传播 Q : 传入一个随机梯度进行反向传播？ 有了 loss 函数我们便可以进行反向传播。 12net.zero_grad() # 清除所有参数的梯度缓存loss.backward(torch.randn(1, 10)) # 传入一个随机梯度进行反向传播？ 同时我们还可以查看反向传播后 conv1 层 bias 梯度： 12&gt;&gt;&gt; net.conv1.bias.gradtensor([ 0.0084, 0.0019, -0.0179, -0.0212, 0.0067, -0.0096]) 1.4.2 举个栗子：训练分类器 这部分主要参考：基于PyTorch的CIFAR10小记 训练一个图像分类器可按照以下顺序进行： 使用torchvision加载和归一化 CIFAR10 训练集和测试集 定义一个卷积神经网络 定义损失函数 在训练集上训练网络 在测试集上测试网络 1 加载数据 该部分主要参考于 ： 基于PyTorch的CIFAR10小记 测试数据集使用 CIFAR10，直接用torchvision 太慢，我们使用 链接 来进行下载。 下载完毕后，导入包和一些基本参数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import torchimport torchvisionimport torchvision.transforms as transformsimport matplotlib.pyplot as pltimport numpy as np# 参数设置EPOCHS = 20BATCH_SIZE = 512# 0.创建一个转换器，将torchvision数据集的输出范围[0,1]转换为归一化范围的张量[-1,1]# 为什么需要转换？transform = transforms.Compose\\([ transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])# 1.创建训练集trainset = torchvision.datasets.CIFAR10\\( root=&#x27;./data&#x27;, # 存放的目录 train=True, # 是否训练集 download=True, # 是否需要下载 transform=transform # 是否进行转换)# 2.创建测试集testset = torchvision.datasets.CIFAR10\\( root=&#x27;./data&#x27;, train=False, download=True, transform=transform)# 3.创建训练/测试加载器# shuffle -- 是否打乱顺序trainloader = torch.utils.data.DataLoader(trainset, batch_size=BATCH_SIZE, shuffle=True )testloader = torch.utils.data.DataLoader (testset, batch_size=BATCH_SIZE, shuffle=True )# 4.设置类别标签classes = (&#x27;plane&#x27;, &#x27;car&#x27;, &#x27;bird&#x27;, &#x27;cat&#x27;, &#x27;deer&#x27;, &#x27;dog&#x27;, &#x27;frog&#x27;, &#x27;horse&#x27;, &#x27;ship&#x27;, &#x27;truck&#x27;) 上面一些代码进行解释： 转换器 1transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))]) ToTensor(): 将一个取值是 [0,255]的PI.Image（或者 shape=(H,W,C) 的ndarray） —&gt; 取值是[0,1,0]的torch.FloadTensor（同时 shape=(C,H,W)） Normalize(mean, std) ： 给定均值 mean、std，会将Tensor正则化，即：Normalized_image=(image-mean)/std transforms.Compose([ transforms.CenterCrop(10),transforms.ToTensor() ]) 将多个 transform 组合起来使用，比如上面是进行了 中心裁剪 + ToTensor 2 定义网络 该网络定义在文件: CNN1.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import torchLR = 0.005 # 学习率class Net(torch.nn.Module): # 定义网络结构：3个卷积层 + 1个全连接层 def __init__(self): super(Net, self).__init__() # 3个卷积层 # 定义该卷积层依次经过： 3*3卷积核 --&gt; ReLU激活函数 --&gt; 池化层下采样 self.conv1 = torch.nn.Sequential\\ (# Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1) torch.nn.Conv2d(3, 16, 3, padding=1), # 3@32*32 -&gt; 16@32*32 torch.nn.ReLU(), # 第一个参数是卷积核大小2*2，第二个参数是stride torch.nn.MaxPool2d(2, 2) # 16*32*32 -&gt; 16*16*16 ) self.conv2 = torch.nn.Sequential\\ ( torch.nn.Conv2d(16, 32, 3, padding=1), # 16*16*16 -&gt; 32*16*16 torch.nn.ReLU(), torch.nn.MaxPool2d(2, 2) # 32*16*16 -&gt; 32*8*8 ) self.conv3 = torch.nn.Sequential\\ ( torch.nn.Conv2d(32, 64, 3, padding=1), # 32*8*8 -&gt; 64*8*8 torch.nn.ReLU(), torch.nn.MaxPool2d(2, 2) # 64*8*8 -&gt; 64*4*4 ) # 1个全连接层（2个？） self.fc1 = torch.nn.Sequential\\ ( # class torch.nn.Linear(in_features, out_features, bias=True) torch.nn.Linear(64*4*4, 32), torch.nn.ReLU(), # torch.nn.Dropout() ) self.fc2 = torch.nn.Linear(32, 10) # 前向传播 def forward(self, x): x = self.conv1(x) x = self.conv2(x) x = self.conv3(x) x = x.view(-1, 64*4*4) # 和全连接层相连先扁平化 x = self.fc1(x) x = self.fc2(x) return xnet = Net()net.cuda()# 损失函数：使用交叉熵criterion = torch.nn.CrossEntropyLoss() # 权重更新规则：使用Adam下降（optim.SGD,随机梯度下降）optimizer = torch.optim.Adam(net.parameters(), lr=LR) 3 训练函数 &amp; 测试函数 1234567891011121314151617181920212223242526272829# 5.训练函数def train(model, criterion, optimizer, trainloader, epochs=5, interval=50): print(&#x27;----- Train Start -----&#x27;) for epoch in range(epochs): running_loss = 0.0 # 遍历数据迭代器：获取数据信息 for step, (x,y) in enumerate(trainloader): # 获取输入 # [易错] 使用GPU训练，数据也需要设置cuda inputs, labels = x.cuda(),y.cuda() # 下面其实就是梯度下降过程，参考：https://www.zhihu.com/question/305638940 # 权重清零 optimizer.zero_grad() # 一次bacth计算出的梯度g(loss对weigth导数）用于 # 更新权重 w = w - α*g 后，下次g要清零重新计算 # 计算loss反向传播 output = model(inputs) # 期望输出值 loss = criterion(output, labels) # 该次代价 loss.backward() # 反向传播 optimizer.step() # 更新权重 # 输出每log_interval=50次批次平均loss # loss是张量：tensor(2.3109, device=&#x27;cuda:0&#x27;, grad_fn=&lt;NllLossBackward&gt;) running_loss += loss.item() if step % log_interval == (log_interval - 1): print(&#x27;[%d, %5d] loss: %.4f&#x27; %(epoch+1, step+1, running_loss/ interval)) running_loss = 0.0 print(&#x27;----- Train Finished -----&#x27;) 现在我们来开始设置测试函数： 1234567891011121314151617181920212223242526272829303132333435# 6.测试函数def test(model, testloader): print(&#x27;------ Test Start -----&#x27;) correct = 0 total = 0 with torch.no_grad(): for test_x, test_y in testloader: # 批处理数量，batch_size = 512: 一次输入512张图片 # images.shape = torch.Size([512,3,32,32]) lable.shape = torch.Size([512]) images, labels = test_x.cuda(), test_y.cuda() # output.shape = torch.Size([512,10]) output = model(images) # predicted.shape = torch.Size([512]) # torch.max : 返回每行最大值，如果[指定维度] 还会返回对应最大值索引 # output.data : 获取张量数据，返回还是一个张量？ _, predicted = torch.max(output.data, 1) # size() 方法：获取大小，返回一个张量如：torch.Size([3, 4]) # sum() 方法：求张量所有元素和，返回一个张量如：tensor(3.2860) # item() 方法：把[1]个元素大小的张量，转换为 python数值类型 total += labels.size(0) correct += (predicted == labels).sum().item() accuracy = 100 * correct / total print(&#x27;Accuracy of the network is: %.4f %%&#x27; % accuracy) return accuracyif __name__ == &#x27;__main__&#x27;: # train(CNN1.net, CNN1.criterion, CNN1.optimizer, trainloader, epochs=EPOCHS) test(CNN1.net, testloader) 最后测试准确率为：71.3% 左右。 4 规范代码结构 该部分主要参考： PyTorch实战指南 定义文件结构如下： 1234567891011121314151617├── checkpoints/├── data/│ ├── __init__.py│ ├── dataset.py│ └── get_data.sh├── models/│ ├── __init__.py│ ├── AlexNet.py│ ├── BasicModule.py│ └── ResNet34.py└── utils/│ ├── __init__.py│ └── visualize.py├── config.py├── main.py├── requirements.txt├── README.md 二、常用函数 归一：BatchNorm2d 中文文档解释 pytorch 中文文档 ：class torch.nn.BatchNorm2d 知乎问答：BN为什么效果好? ⚠️ 参数 num_features : 实际只传的是通道数！ 实例补充 参考：Pytorch中的Batch Normalization操作 假设存在4 个 batch ，每个特征图大小为：3*2*2 ，即通道数为 3 ，长宽为 2*2 。那么归一化如下： 每个batch ，从相同通道（比如第一个R通道）取出特征图其大小为 2*2 上述一共有 4 个 2*2 的特征图，对这16 个元素进行归一化操作 重复 1 2 两次 （一共3个通道），则对剩余两个通道的16*2 个元素也进行了归一化","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://hwh.zone/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Pytorch","slug":"深度学习/Pytorch","permalink":"https://hwh.zone/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Pytorch/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://hwh.zone/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Pytorch","slug":"Pytorch","permalink":"https://hwh.zone/tags/Pytorch/"}]},{"title":"深度学习基础（一）Numpy","slug":"深度学习基础（一）Numpy","date":"2021-11-25T08:55:19.914Z","updated":"2021-11-26T09:12:27.588Z","comments":true,"path":"2021/11/25/深度学习基础（一）Numpy/","link":"","permalink":"https://hwh.zone/2021/11/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89Numpy/","excerpt":"","text":"矩阵，数组？Numpy 一、 常用方法 0 初次使用 安装：pip install numpy 引用：import numpy as np 1 创建数组：np.arange、np.ones… 基本方式 基本创建数组的办法，注意以下创建的都是 一维数组 (5,) ： 123456a = np.array([0, 1, 2, 3, 4]) # &gt;&gt;&gt;[0 1 2 3 4]b = np.array((0, 1, 2, 3, 4)) # &gt;&gt;&gt;[0 1 2 3 4]c = np.arange(5) # &gt;&gt;&gt;[0 1 2 3 4]d = np.linspace(0, 2*np.pi, 5) # 将[0,2π]等分为5份print(d) # &gt;&gt;&gt;[ 0. 1.57079633 3.14159265 4.71238898 6.28318531] 为了创建 多维数组 我们可以使用 reshape() 来改变数组维度： 12345678910&gt;&gt;&gt; np.arange(12).reshape((3,4)) # 2D:传入的是一个元组array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) &gt;&gt;&gt; np.arange(12).reshape((2,2,3)) # 3D:传入的是一个元组array([[[ 0, 1, 2], [ 3, 4, 5]], [[ 6, 7, 8], [ 9, 10, 11]]]) 当然你也可以选择传入多维列表： 123456&gt;&gt;&gt; A = np.array([[2,1,-2],[3,0,1],[1,1,-1]])&gt;&gt;&gt; A = np.array([[2,1,-2],[3,0,1],[1,1,-1]])&gt;&gt;&gt; Aarray([[ 2, 1, -2], [ 3, 0, 1], [ 1, 1, -1]]) 库函数生成 最后可以使用基本库函数 zeros、ones、eyes、empty、full、random来创建。 12345678910111213141516171819202122232425262728293031# 1D 创建一维可以直接传递一个数字&gt;&gt;&gt; np.zeros(6)array([0., 0., 0., 0., 0., 0.])&gt;&gt;&gt; np.ones(6)array([1., 1., 1., 1., 1., 1.])&gt;&gt;&gt; np.full(6,3)array([3, 3, 3, 3, 3, 3])# 2D 除了 eyes方法，其余都传递一个元组&gt;&gt;&gt; np.zeros((2,3))array([[0., 0., 0.], [0., 0., 0.]])&gt;&gt;&gt; np.empty((2,3)) # 不是空矩阵，而是内容随机array([[0., 0., 0.], [0., 0., 0.]])&gt;&gt;&gt; np.full((2,3),6)array([[6, 6, 6], [6, 6, 6]]) &gt;&gt;&gt; np.eye(3,3) # 对角矩阵：传递不是元组，而是两个数字array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]])&gt;&gt;&gt; np.random.random((2,3)) # 随机填充[0,1]之间的一个数值array([[0.91453011, 0.06663476, 0.18352908], [0.19449024, 0.06442752, 0.64491859]]) ​ 2 索引：切片、列表索引、布尔屏蔽 基本索引 索引一个数字类似于 python 多维列表 12345678&gt;&gt;&gt; a = np.array([[11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25], [26, 27, 28 ,29, 30], [31, 32, 33, 34, 35]]) &gt;&gt;&gt; a[2,4] 25 切片索引 1234567891011121314151617# 索引第2列&gt;&gt;&gt; a[:, 1] [12 17 22 27 32]# 索引第1列，指定开始选中数值&gt;&gt;&gt; a[1:4, 0] [16 21 26]# 索引第0行，指定开始选中数值&gt;&gt;&gt; a[0, 1:4] [12 13 14]# 每隔2行，每隔2列进行索引&gt;&gt;&gt; a[::2,::2] [[11 13 15] [21 23 25] [31 33 35]] 列表索引 依旧使用上面矩阵，我们可以指定一个列表来索引指定位置元素： 12345678910&gt;&gt;&gt; a = np.array([[11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25], [26, 27, 28 ,29, 30], [31, 32, 33, 34, 35]])&gt;&gt;&gt; L = [0,2,4]&gt;&gt;&gt; a[L] # 索引第 1、3、5行array([[11, 12, 13, 14, 15], [21, 22, 23, 24, 25], [31, 32, 33, 34, 35]]) 布尔屏蔽 布尔屏蔽是一个有用的功能，它允许我们根据我们指定的条件检索数组中的元素。 12345678910# 布尔屏蔽import matplotlib.pyplot as plta = np.linspace(0, 2 * np.pi, 50)b = np.sin(a)plt.plot(a,b)# 画出值大于0，且小于π/2的所有绿色点mask = (b &gt;= 0) &amp; (a &lt;= np.pi / 2)plt.plot(a[mask], b[mask], &#x27;go&#x27;)plt.show() 3 插入：np.c_ 、np.r_ 还有其它插入方式暂时不表，下面都仅限于插入 2D 数组，更高维暂未尝试。 按列插入：np.c_ 按列插入则要求，被插入的数组和原数组 行相同 。 123456789101112131415161718&gt;&gt;&gt; aarray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])# 1D 数组，但是第一维度相同（虽然看起来是行向量？）&gt;&gt;&gt; c0 = np.zeros((3,))&gt;&gt;&gt; np.c_[c0,a]array([[ 0., 0., 1., 2., 3.], [ 0., 4., 5., 6., 7.], [ 0., 8., 9., 10., 11.]])# 2D 数组，第一维度相同&gt;&gt;&gt; c1 = np.ones((3,1))&gt;&gt;&gt; np.c_[c1,a]array([[ 1., 0., 1., 2., 3.], [ 1., 4., 5., 6., 7.], [ 1., 8., 9., 10., 11.]]) 按行插入：np.r_ 123456789101112&gt;&gt;&gt; aarray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])# 按行插入：第2维度相等&gt;&gt;&gt; r0 = np.zeros((1,4))&gt;&gt;&gt; np.r_[r0,a]array([[ 0., 0., 0., 0.], [ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.]]) 二、Numpy 进阶 2.1 广播 以下整理自：numpy中的广播机制 什么是广播？ 当两个数组的形状并不相同的时候，我们可以通过扩展数组的方法来实现相加、相减、相乘等操作。 广播的条件是什么？ 数组维度 不同，后缘维度的轴长相符 数组维度 相同，其中有个轴为1 2.1.1 维度不同进行广播 (4,3) 是 2D，(3,) 是 1D，但是它们后缘维度相同，因此可以扩展 (3,4,2) 是 3D，(4,2) 是 1D，但是它们后缘维度相同 同理，还有 （4,2,3）和（2,3）是兼容的，（4,2,3）还和（3）是兼容的。 2.1.2 维度相同进行广播 虽然维度相同，但有一个为1，也可以进行广播。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://hwh.zone/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Numpy","slug":"深度学习/Numpy","permalink":"https://hwh.zone/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Numpy/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://hwh.zone/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Numpy","slug":"Numpy","permalink":"https://hwh.zone/tags/Numpy/"}]},{"title":"校招笔记（九）_计算机基础_相关补充","slug":"校招笔记（九）_计算机基础_相关补充","date":"2021-11-25T08:29:59.274Z","updated":"2021-11-26T16:33:50.370Z","comments":true,"path":"2021/11/25/校招笔记（九）_计算机基础_相关补充/","link":"","permalink":"https://hwh.zone/2021/11/25/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80_%E7%9B%B8%E5%85%B3%E8%A1%A5%E5%85%85/","excerpt":"","text":"备注 算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop 计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新 校招笔记（一）__Java_面对对象 校招笔记（一）__Java_集合 校招笔记（一）__Java_多线程 校招笔记（一）__Java_锁 校招笔记（一）__Java_JVM 计算机基础(下)（“八股”） 校招笔记（二）__计算机基础_Linux&amp;Git 校招笔记（三）__计算机基础_计算机网络 校招笔记（四）__计算机基础_操作系统 校招笔记（五）__计算机基础_MySQL 校招笔记（六）__计算机基础_Redis 校招笔记（七）__计算机基础_数据结构 校招笔记（八）__计算机基础_场景&amp;智力题 校招笔记（九）__计算机基础_相关补充 🚩 项目&amp;实习 主要是怎么准备项目，后续更新 九、相关补充 9.1 （要扩充）设计模式 没有足够实际代码经验，只好先写这些应付下面试。 1.说说什么是单例模式 ?手写一个？ 单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。 手写单例模式 参考：https://www.runoob.com/design-pattern/singleton-pattern.html 记忆：“2private + 1public ” 饿汉式 线程安全 ， 但：类加载时就初始化，浪费内存。 1234567891011121314151617public class SingleObject &#123; // 创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); // *让构造函数为 private，这样该类就不会被实例化 private SingleObject()&#123;&#125; // 获取唯一可用的对象 public static SingleObject getInstance()&#123; return instance; &#125; public void showMessage()&#123; System.out.println(&quot;Hello World!&quot;); &#125; &#125; 懒汉式（不加锁） 只有真正调用获取实例对象时，才会创建一次。 1234567891011121314public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; // 调用时才判断 if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 懒汉式（加锁） 线程安全，但加锁性能不够高 123456789101112public class Singleton&#123; private static Singleton instance; private Singleton ()&#123;&#125; // 就是多了个synchronized关键字 public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 双检锁式 懒汉式（加锁）虽然可以保证只创建一个单例，但其性能不高，因为每次访问整个方法都加锁。 因此出现双检索式，在instance=new DoubleCheckSingleton(); 进行加锁 ， return instance;不加锁！ 为什么要进行两次检查instance==null？ 第一层检查作用 主要为了提高性能。如果没有第一层，上来就要加锁比较耗费性能 第二层检查作用 解决多线程并发问题。假设是第一次开始执行getInstance方法： A，B两个线程，此时instance==null ，A，B都通过了第一层检查。 假设A先拿到锁，往下执行创建一个实例，然后释放了锁； 此时B也拿到了锁，如果没有第二层检查，B会进行重新new一个实例，违背单例模式！ 12345678910111213141516171819202122232425262728public class DoubleCheckSingleton&#123; // volitale 关键字修饰，避免指令重排，因为初始化操作是不原子化的 ： // (1) 给DoubleCheckSingleton类的实例instance分配内存 // (2) 调用实例instance的构造函数来初始化成员变量 // (3) 将instance指向分配的内存地址 // 在多线程中，A可能是 1→3→2的顺序，执行到1→3，此时另外一个线程看到instance不为null（因为前面线程执行了3）就直接返回实例。而此时并没有被分配内存故可能出现问题。 private volatile static DoubleCheckSingleton instance; // 私有的构造方法 private DoubleCheckSingleton() &#123;&#125; public static DoubleCheckSingleton getInstance()&#123; if(instance==null)&#123; //第一层检查，是否存在实例 synchronized (DoubleCheckSingleton.class)&#123; if(instance==null)&#123; //第二层检查，防止出现另外一个线程阻塞在synchronized，获得锁后重复创建实例 instance=new DoubleCheckSingleton(); &#125; &#125; &#125; return instance; &#125; &#125; 2.说说你对代理模式的理解？ 代理模式是给某一个对象提供一个代理，并由代理对象控制对原对象的引用。 优点：代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；可以灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务。 缺点：由于使用了代理模式，因此程序的性能没有直接调用性能高；使用代理模式提高了代码的复杂度。 3.说说简单工厂模式？ 简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 比如，一台咖啡机就可以理解为一个工厂模式，你只需要按下想喝的咖啡品类的按钮（摩卡或拿铁），它就会给你生产一杯相应的咖啡，你不需要管它内部的具体实现，只要告诉它你的需求即可； 【优点】工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品； 【缺点】 不易拓展，一旦添加新的产品类型，就不得不修改工厂的创建逻辑； 产品类型较多时，工厂的创建逻辑可能过于复杂，一旦出错可能造成所有产品的创建失败，不利于系统的维护。 4.说说抽象工厂模式？ 抽象工厂模式是在简单工厂的基础上将未来可能需要修改的代码抽象出来，通过继承的方式让子类去做决定。 【简单工厂模式缺点】以上面的咖啡工厂为例，某天我的口味突然变了，不想喝咖啡了想喝啤酒，这个时候如果直接修改简单工厂里面的代码，这种做法不但不够优雅，也不符合软件设计的“开闭原则”，因为每次新增品类都要修改原来的代码。 【抽象工厂】抽象工厂里只声明方法，具体的实现交给子类（子工厂）去实现，这个时候再有新增品类的需求，只需要新创建代码即可。如，创建一个啤酒工厂而不是咖啡工厂。 5.装饰器模式是什么？ 不够深入。 装饰器模式是指动态地给一个对象增加一些额外的功能，同时又不改变其结构。 9.2 分布式问题【校招必问】 非常系统的总结文档：分布式相关：第一页 CAP 理论指的是什么：C（Consistency）是数据一致性、A（Availability）是服务可用性、P（Partition tolerance）是分区容错性。 问题引入 现在有一个分布式系统 A，它有一个副本 A1，在正常情况下，客户端 Client 写数据到系统 A，然后数据从 A 节点同步到 A1 节点，再返回给 Client 成功状态。 但由于网络是不可靠的，节点 A 和 A1 的网络随时会因为中断而出现分区。所谓网络分区就是由于网络不通导致节点 A 和 A1 被隔离在不同的网络子集中，此时节点 A 的数据就不能及时同步到节点 A1 中了。 9.1.1 在CAP基础上讲讲BASE？举实例说说？ BASE 理论，它是 CAP 理论的延伸。BASE 是 Basically Available（基本可用）、Soft State（软状态）和 Eventually Consistent（最终一致性）三个单词的简写，作用是保证系统的可用性，然后通过最终一致性来代替强一致性，它是目前分布式系统设计中最具指导意义的经验总结。 其实是做了“可用性”方面的妥协，比如： 电商网站在双十一大促等访问压力较大的时候，关闭商品排行榜等次要功能的展示，从而保证商品交易主流程的可用性，这也是我们常说的服务降级； 为了错开双十一高峰期，电商网站会将预售商品的支付时间延后十到二十分钟，这就是流量削峰； 在你抢购商品的时候，往往会在队列中等待处理，这也是常用的延迟队列。 软状态和最终一致性指的是允许系统中的数据存在中间状态，这同样是为了系统可用性而牺牲一段时间窗内的数据一致性，从而保证最终的数据一致性的做法。 9.1.2 亿级商品分布式存储问题？ 1.如何设计一个支持海量商品存储的高扩展性架构？ 从这一点出发会考察你Hash（哈希）分片的具体实现原理。 以商品 ID 作为关键字进行分片，系统会通过一个 Hash 函数计算商品 ID 的 Hash 值，然后取模，就能得到对应的分片； 2.在做分库分表时，基于 Hash 取模和一致性 Hash 的数据分片是如何实现的？ 解决 Hash 分片的缺点，既保证数据均匀分布，又保证扩展性 ，最终采用一致性 Hash ：它是指将存储节点和数据都映射到一个首尾相连的哈希环上。 具体见前，一致性哈希相关算法描述 3.在电商大促时期，如何对热点商品数据做存储策略 ？ 问题 一致性 Hash 提升了稳定性，使节点的加入和退出不会造成大规模的数据迁移，但本质上 Hash 分片是一种静态的分片方式，必须要提前设定分片的最大规模，而且无法避免单一热点问题， 某一数据被海量并发请求后，不论如何进行 Hash，数据也只能存在一个节点上，这势必会带来热点请求问题。 解决 做 Range（范围）分片。 与 Hash 分片不同的是，Range 分片能结合业务逻辑规则，例如，我们用 “Category（商品类目）” 作为关键字进行动态分片时，不是以统一的商品一级类目为标准，而是可以按照一、二、三级类目进行灵活分片。例如，对于京东强势的 3C 品类，可以按照 3C 的三级品类设置分片；对于弱势品类，可以先按照一级品类进行分片，这样会让分片间的数据更加平衡。 4.强一致性和最终一致性的数据共识算法是如何实现的？ 9.1.3 海量并发，分布式事务一致性问题？ 什么是分布式事务问题？ 一次大的操作由多个小操作组成，这些小的操作分布在不同的服务器上，分布式事务需要保证这些小操作要么全部成功，要么全部失败。 举一个实例： 京东旅行系统，拆分成多个子系统，如商品系统、促销系统、订单系统。用户下单时，订单系统生成订单，商品系统扣减库存，促销系统扣减优惠券，只有当三个系统的事务都提交之后，才认为此次下单成功，否则失败。 解决方案 有两阶段提交协议（Two-Phase Commit，2PC）、3PC 、TCC 和基于消息队列的实现方式。 错误回答：方案很多，可以选择 2PC ，2PC 实现的流程是… 错误原因： 因为在实际工作中，很少采用前几种方案（互联网中落地方案代价大），基本都是基于 MQ 的可靠消息投递的方式来实现。 正确回答：先介绍目前主流实现分布式系统事务一致性的方案（也就是基于 MQ 的可靠消息投递的机制）然后回答出可实现方案和关键知识点。另外，为了和面试官进一步交流，你可以提出 2PC 或 TCC （这是一种交流方案）。 回答一、基于 MQ 的可靠消息投递方案 什么是MQ 核心的五个概念： Queue: 真正存储数据的地方 Exchange: 接收请求，转存数据 Bind: 收到请求后存储到哪里 消息生产者:发送数据的应用 消息消费者: 取出数据处理的应用 场景实例 订单系统（1）完成订单后，（2）购物车系统减购物车中的商品。 订单系统在消息队列上开启一个事务（没有创建订单）； 订单系统给消息服务器发送一个“半消息”； 这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的。 半消息发送成功后，订单系统就可以执行本地事务了，在订单库中创建一条订单记录，并提交订单库的数据库事务。 然后根据本地事务的执行结果决定提交或者回滚事务消息。 如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。 购物系统消费这条拿到的订单系统消息（确认了订单系统事务执行完毕），这样就可以继续下一步购物操作 9.1.4 分布式锁问题 06 分布式系统中，如何回答锁的实现原理？ 分布式锁是解决协调分布式系统之间，同步访问共享资源的一种方式。详细来讲：在分布式环境下，多个系统在同时操作共享资源（如写数据）时，发起操作的系统通常会通过一种方式去协调其他系统，然后获取访问权限，得到访问权限后才可以写入数据，其他系统必须等待权限释放。 基于redis的分布式锁 使用setnx命令加锁 12345678public static void wrongGetLock1(Jedis jedis, String lockKey, String requestId, int expireTime) &#123; // 第一步：加锁 Long result = jedis.setnx(lockKey, requestId); if (result == 1) &#123; // 第二步：设置过期时间 jedis.expire(lockKey, expireTime); &#125;&#125; setnx命令，意思就是 set if not exist，如果lockKey不存在，把key存入Redis，保存成功后如果result返回1，表示设置成功，如果非1，表示失败，别的线程已经设置过了。 expire()，设置过期时间，防止死锁，假设，如果一个锁set后，一直不删掉，那这个锁相当于一直存在，产生死锁。 解决setnx与expire不是一个原子操作 加锁总共分两步，第一步jedis.setnx，第二步jedis.expire设置过期时间，setnx与expire不是一个原子操作，如果程序执行完第一步后异常了，第二步jedis.expire(lockKey, expireTime)没有得到执行，相当于这个锁没有过期时间，有产生死锁的可能。 解决方案为：一步操作 123456789101112131415161718192021222324252627282930313233public class RedisLockDemo &#123; private static final String SET_IF_NOT_EXIST = &quot;NX&quot;; private static final String SET_WITH_EXPIRE_TIME = &quot;PX&quot;; /** * 获取分布式锁 * @param jedis Redis客户端 * @param lockKey 锁 * @param requestId 请求标识 * @param expireTime 超期时间 * @return 是否获取功 */ public static boolean getLock(Jedis jedis, String lockKey, String requestId, int expireTime) &#123; // 两步合二为一，一行代码加锁并设置 + 过期时间。 if (1 == jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime)) &#123; return true;//加锁成功 &#125; return false;//加锁失败 &#125; // 解锁：对应del删除key即可 public static void unLock(Jedis jedis, String lockKey, String requestId) &#123; // 第一步： 使用 requestId 判断加锁与解锁是不是同一个客户端 if (requestId.equals(jedis.get(lockKey))) &#123; // 第二步： 若在此时，这把锁突然不是这个客户端的，则会误解锁 jedis.del(lockKey); &#125; &#125;&#125; ​ 基于Zoopkeeper的分布式锁 sync，lock也只能保证你当前机器线程安全，这样分布式访问还是有问题。 建议参考：https://www.cnblogs.com/aobing/p/12650036.html 一个机器接收到了请求之后，先获取 zookeeper 上的一把分布式锁（zk会创建一个 znode），执行操作；然后另外一个机器也尝试去创建那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等待，等第一个机器执行完了方可拿到锁。 下面是创建临时顺序节点的情况： 客户端调用create()方法创建名为“/dlm-locks/lockname/lock-”的临时顺序节点。 客户端调用getChildren(“lockname”)方法来获取所有已经创建的子节点。 客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，就是看自己创建的序列号是否排第一，如果是第一，那么就认为这个客户端获得了锁，在它前面没有别的客户端拿到锁。 如果创建的节点不是所有节点中需要最小的，那么则监视比自己创建节点的序列号小的最大的节点，进入等待。直到下次监视的子节点变更的时候，再进行子节点的获取，判断是否获取锁。 基于关系型数据库 MySQL 实现分布式锁 参考：https://juejin.cn/post/6844904137172189198 利用 Mysql 的锁表，创建一张表，设置一个 UNIQUE KEY（如，利用主键ID的唯一性） 这个 KEY 就是要锁的 KEY，所以同一个 KEY 在mysql表里只能插入一次了。 这样对锁的竞争就交给了数据库，处理同一个 KEY 数据库保证了只有一个节点能插入成功，其他节点都会插入失败。 定义加锁、解锁代码如下： 123456789def lock ： exec sql: ins ert into lockedtable (xxx) values (xxx) if result == true : return true else : return falsedef def unlock ： # 解锁就是删除 exec sql: delete from lockedOrder where order_id=&#x27;order_id&#x27; 9.3 其它问题 1. 【字节-懂车帝】什么是跨域？ 参考：https://www.jianshu.com/p/f049ac7e2220 跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。 同源策略限制了一下行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 JS 对象无法获取 Ajax请求发送不出去 具体的一些实例： 非跨域 1http://www.yyy.cn/index.html 调用 http://www.xxxyyy.cn/server.php 非跨域 跨域：主域不同 1http://www.xxxyyy.cn/index.html 调用 http://www.xxx.cn/server.php 跨域：子域名不同 1http://abc.xxxyyy.cn/index.html 调用 http://def.xxx.cn/server.php 跨域：端口不同 1http://www.xxx.cn:**8080**/index.html 调用 http://www.xxx.cn/server.php 跨域：协议不同 1**https**://www.xxx.cn/index.html 调用 **http**://www.xxx.cn/server.php","categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"分布式","slug":"分布式","permalink":"https://hwh.zone/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hwh.zone/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"数据库（二）Redis基础","slug":"数据库（二）Redis基础学习","date":"2021-11-25T08:09:21.817Z","updated":"2021-11-25T10:42:42.423Z","comments":true,"path":"2021/11/25/数据库（二）Redis基础学习/","link":"","permalink":"https://hwh.zone/2021/11/25/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89Redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、Redis 1.1概述 redis是一款高性能的NOSQL系列的非关系型数据库 。 NoSQL(NoSQL = Not Only SQL) : “不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。为了解决大规模数据集合多重数据、高性能查询数据带来的挑战，尤其是大数据应用难题。 由缓存到redis解释。 缓存思想 直接操作数据库通常是很费时的，我们可以把在内存开辟一块区域作为缓存，存储经常访问的数据。 缓存具体实现 缓存的实现有多种，比如开辟一块内存空间使用map集合。但是： map是运行到JVM中，只能固定分配一些内存，比较小 map集合如果涉及分布式，没法部署 redis 整台机器内存都可以被redis数据库分配 可以部署分布式 NOSQL和关系型 各自优势对比 NOSQL 关系型 【性能】：NOSQL是基于键值对的，（1）不需要经过SQL层的解析，所以性能非常高（2）NOSQL数据库将数据存储于缓存之中，而不是硬盘，查询快 【复杂查询】：复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询 【存储格式】：NOSQL的存储格式是key,value形式，可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型 【安全性&amp;事务】：事务支持使得对于安全性能很高的数据访问要求得以实现 【扩展性】：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难；NOSQL基于键值对，数据之间没有关联关系，所以非常容易水平扩展 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系： 关系数据库： 所有数据存储的位置 NoSQL： 备份（缓存）关系数据库的（常用？）数据 redis的应用场景 缓存（最重要） 聊天室的在线好友列表 任务队列。（秒杀、抢购、12306等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒 分布式集群架构中的session分离 下载&amp;安装 下载 下载地址：https://github.com/tporadowski/redis/releases/ 启动 解压后分别启动： 启动服务端：redis-server.exe （不要关闭！！） 启动服务端：redis-cli.exe 安装完成开始愉快使用了。 1.2 数据结构 基本操作 redis存储的是：&lt;key,value&gt;格式的数据，其中key都是字符串，value有5种不同的数据结构 : 字符串类型： string 1234567891011# 1.存储 : set &lt;key&gt; &lt;value&gt;127.0.0.1:6379&gt; set username zhangsan ok# 2.获取: get &lt;key&gt; 127.0.0.1:6379&gt; get username &quot;zhangsan&quot;# 3.删除 127.0.0.1:6379&gt; del username (integer) 1 哈希类型 hash ： map格式 1234567891011121314# 1.存储：hset &lt;key&gt; &lt;field&gt; &lt;value&gt;127.0.0.1:6379&gt; hset myhash username lisi(integer) 1# 2.获取: hget &lt;key&gt; &lt;field&gt;127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot;127.0.0.1:6379&gt; hgetall myhash # 获取所有键值对1) &quot;username&quot; 2) &quot;lisi&quot;# 3.删除: hdel &lt;key&gt; &lt;field&gt;127.0.0.1:6379&gt; hdel myhash username (integer) 1 列表类型 list ： linkedlist格式。支持重复元素 其实更相当一个队列。 12345678910111213141516171819# 1.存储 # lpush &lt;key&gt; &lt;value1&gt;: 将元素加入列表头部# rpush &lt;key&gt; &lt;value1&gt;: 将元素加入列表尾部127.0.0.1:6379&gt; lpush myList a(integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c(integer) 3# 2.获取 ：lrange &lt;key&gt; &lt;start&gt; &lt;end&gt; 范围获取127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot;# 3.删除：# lpop key： 删除列表最左边的元素，并将元素返回 # rpop key： 删除列表最右边的元素，并将元素返回 集合类型 set ： 不允许重复元素 1234567891011121314# 1. 存储：sadd &lt;key&gt; &lt;value1&gt; &lt;value2&gt; ...127.0.0.1:6379&gt; sadd myset a b(integer) 2 127.0.0.1:6379&gt; sadd myset a(integer) 0 # 没有更新成功！# 2. 获取所有元素：smembers &lt;key&gt;127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 2) &quot;b&quot; # 3. 删除：srem &lt;key&gt; &lt;value&gt; 127.0.0.1:6379&gt; srem myset a (integer) 1 有序集合类型 zset：不允许重复元素，且元素有顺序 每个元素都会关联一个double类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。 12345678910111213141516171819202122232425# 1.存储：zadd &lt;key&gt; &lt;score&gt; &lt;value&gt; 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 # 2. 获取：zrange &lt;key&gt; &lt;start&gt; &lt;end&gt; &lt;withscores&gt;（有序）127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;zhangsan&quot;2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot;6) &quot;500&quot;# 3.删除：zrem &lt;key&gt; &lt;value&gt; 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 通用命令 **keys *** : 查询所有的键 如果不知道自己以前存储的键，可以用这个命令获取： **type ** ： 获取键对应的value的类型 但是如果想知道，“myset”对应是什么类型呢？ **del **：删除指定的key value 区分具体数据结构，如hashmap ，删除某个数据。del &lt;key&gt; 直接将存储的hashmap都删了。 1.3 持久化 redis是一个内存数据库，当redis服务器重启 / 电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 RDB（默认） 在一定间隔时间中，检测key的变化情况，然后持久化数据 。 编辑redis.windwos.conf文件 123456# after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changedsave 60 10000 （测试）设置每10s检测一下，如果至少有5个key发生改变就保存 12# after 60 sec if at least 10000 keys changedsave 10 5 然后我们修改set 类型myset集合键name 5次： 关闭服务器，和客户端。但是可以看见在redis目录下生成了dump.rdb 文件： 再次启动服务器和客户端，发生name 依旧在： AOF 日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据。 编辑redis.windwos.conf文件 首先开启AOF : 将下面修改为 appendonly yes 修改AOF模式 默认是 appendfsync everysec （每秒进行记录） appendfsync always ： 每次操作都持久化 appendfsync no ： 不进行持久化，此时redis==相当大map集合 （测试）重启服务端、客户端 首先可以发现，多了个appendonly .aof 文件 随意保存一些数据，重启数据库可以发现数据依旧存在。 1.4 Jedis快速入门 Jedis是 一款java操作redis数据库的工具。 快速实践： 123456//1. 获取连接 Jedis jedis = new Jedis(&quot;localhost&quot;,6379); //2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //3. 关闭连接 jedis.close(); Jedis操作 下面是API相关调用，先不学了。 1.5 连接池 介绍 工具栏 1.6 案例分析 先从sql数据库查询，然后可使用redis缓存一些不经常发生变化的数据 。 环境搭建 查询数据库 redis缓存优化","categories":[{"name":"数据库","slug":"数据库","permalink":"https://hwh.zone/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"数据库/Redis","permalink":"https://hwh.zone/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://hwh.zone/tags/Redis/"}]}],"categories":[{"name":"校招笔记","slug":"校招笔记","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"校招笔记/计算机基础","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"JAVA","slug":"校招笔记/JAVA","permalink":"https://hwh.zone/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/"},{"name":"前端","slug":"前端","permalink":"https://hwh.zone/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://hwh.zone/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://hwh.zone/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"Python","slug":"Python","permalink":"https://hwh.zone/categories/Python/"},{"name":"数据库","slug":"数据库","permalink":"https://hwh.zone/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"https://hwh.zone/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"},{"name":"深度学习","slug":"深度学习","permalink":"https://hwh.zone/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"https://hwh.zone/categories/Java/"},{"name":"Java基础","slug":"Java/Java基础","permalink":"https://hwh.zone/categories/Java/Java%E5%9F%BA%E7%A1%80/"},{"name":"Git","slug":"Git","permalink":"https://hwh.zone/categories/Git/"},{"name":"OpenCV","slug":"深度学习/OpenCV","permalink":"https://hwh.zone/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/OpenCV/"},{"name":"Pytorch","slug":"深度学习/Pytorch","permalink":"https://hwh.zone/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Pytorch/"},{"name":"Numpy","slug":"深度学习/Numpy","permalink":"https://hwh.zone/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Numpy/"},{"name":"Redis","slug":"数据库/Redis","permalink":"https://hwh.zone/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"}],"tags":[{"name":"校招","slug":"校招","permalink":"https://hwh.zone/tags/%E6%A0%A1%E6%8B%9B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"场景题","slug":"场景题","permalink":"https://hwh.zone/tags/%E5%9C%BA%E6%99%AF%E9%A2%98/"},{"name":"智力题","slug":"智力题","permalink":"https://hwh.zone/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/"},{"name":"数据结构","slug":"数据结构","permalink":"https://hwh.zone/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Redis","slug":"Redis","permalink":"https://hwh.zone/tags/Redis/"},{"name":"数据库","slug":"数据库","permalink":"https://hwh.zone/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"https://hwh.zone/tags/MySQL/"},{"name":"操作系统","slug":"操作系统","permalink":"https://hwh.zone/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://hwh.zone/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Git","slug":"Git","permalink":"https://hwh.zone/tags/Git/"},{"name":"Linux","slug":"Linux","permalink":"https://hwh.zone/tags/Linux/"},{"name":"JAVA","slug":"JAVA","permalink":"https://hwh.zone/tags/JAVA/"},{"name":"目录","slug":"目录","permalink":"https://hwh.zone/tags/%E7%9B%AE%E5%BD%95/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://hwh.zone/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"https://hwh.zone/tags/CSS/"},{"name":"Python","slug":"Python","permalink":"https://hwh.zone/tags/Python/"},{"name":"吴恩达","slug":"吴恩达","permalink":"https://hwh.zone/tags/%E5%90%B4%E6%81%A9%E8%BE%BE/"},{"name":"机器学习","slug":"机器学习","permalink":"https://hwh.zone/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"深度学习","slug":"深度学习","permalink":"https://hwh.zone/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"https://hwh.zone/tags/Java/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://hwh.zone/tags/OpenCV/"},{"name":"Pytorch","slug":"Pytorch","permalink":"https://hwh.zone/tags/Pytorch/"},{"name":"Numpy","slug":"Numpy","permalink":"https://hwh.zone/tags/Numpy/"},{"name":"分布式","slug":"分布式","permalink":"https://hwh.zone/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hwh.zone/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}