<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++从零开始（开源）：一文读懂muduo</title>
      <link href="/p/37224/"/>
      <url>/p/37224/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，工作快一年，终于又开始更新了…🥗</p></blockquote><div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div><p>在学校接触C++比较少，主要是用Java 、Python较多。入职腾讯前，为了恶补下C++网络相关基础，读了一些经典的<u>demo级</u> 开源库，如 <a href="https://github.com/EZLippi/Tinyhttpd">Tinyhttpd</a> 、<a href="https://github.com/zyearn/zaver">Zavar</a> 等。入职后大多数时候在业务屎山上玩耍，内部也有封装好的网络框架，但一直对网络通信底层挺感兴趣。</p><p>疫情过后，所在的业务收缩（千万PCU–&gt;百万PCU），并发数下降了一个量级。也算有了难得的时间，来静下来心来读一些<u>工业级</u>别的开源库。经过调研，锁定在<a href="https://github.com/S1mpleBug/muduo_cpp11">muduo-cpp11</a> 、<a href="">brpc</a> 两个项目，先花了一周先读完了相对简单的muduo，写篇文章给自己总结回顾，也给后来者一份全面清晰地参考吧。</p><h1>一、Muduo整体架构</h1><blockquote><p>注意，<a href="https://github.com/chenshuo/muduo">muduo</a> 源码@<em>chenshuo</em>基于boost，本文代码引用@<em>S1mpleBug</em>基于C++11改写的<a href="https://github.com/S1mpleBug/muduo_cpp11">muduo-cpp11</a>。</p></blockquote><h2 id="1-1-从EchoServer说起">1.1 从EchoServer说起</h2><h3 id="1-1-1-快速开始">1.1.1 快速开始</h3><p>下好源码后，我们编译一下项目中EchoServer示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/S1mpleBug/muduo_cpp11</span><br><span class="line">cd muduo_cpp11/example/ &amp; make</span><br></pre></td></tr></table></figure><p>一个简单“复读机”服务器便诞生了：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230227171908955.png" alt="image-20230227171908955"></p><h3 id="1-1-2-“复读机“服务器业务层实现">1.1.2 “复读机“服务器业务层实现</h3><p>muduo的接口使用相当方便和精简：</p><ol><li><p><strong>首先定义一个EchoServer类</strong></p><p>该类主要有如下功能：</p><ul><li>封装了TcpServer类对象<code>server_</code>，在muduo中，TcpServer是整个框架逻辑层面的入口；</li><li>用户注册自定义的事件（新客户端连接、客户端消息响应）回调函数，也即是业务层面逻辑处理。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mymuduo/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mymuduo/Logger.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EchoServer</span>(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;addr, <span class="keyword">const</span> std::string &amp;name)</span><br><span class="line">        : <span class="built_in">server_</span>(loop, addr, name) <span class="comment">// TcpServer server_; TcpServer对象初始化</span></span><br><span class="line">        , <span class="built_in">loop_</span>(loop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册回调函数</span></span><br><span class="line">        server_.<span class="built_in">setConnectionCallback</span>( <span class="comment">// onConnection，打印下连接的客户端ip+port</span></span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">        </span><br><span class="line">        server_.<span class="built_in">setMessageCallback</span>( <span class="comment">// onMessage：将客户端发来的信息原样返回send</span></span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onMessage, </span><br><span class="line">                        <span class="keyword">this</span>, </span><br><span class="line">                        std::placeholders::_1,</span><br><span class="line">                        std::placeholders::_2,</span><br><span class="line">                        std::placeholders::_3));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置合适的subloop线程数量</span></span><br><span class="line">        server_.<span class="built_in">setThreadNum</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        server_.<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 连接建立或断开的回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (conn-&gt;<span class="built_in">connected</span>())</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Connection UP : %s&quot;</span>, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Connection DOWN : %s&quot;</span>, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可读写事件回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp time)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string msg = buf-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(<span class="string">&quot;muduo: &quot;</span> + msg);</span><br><span class="line">        <span class="comment">// conn-&gt;shutdown();   // 关闭写端 底层响应EPOLLHUP =&gt; 执行closeCallback_</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventLoop *loop_;</span><br><span class="line">    TcpServer server_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>启动服务器</strong></p><p>EchoServer对象start()，main loop开启事件循环loop()。整个服务器便顺利启动了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.用户自定义的loop作为main loop</span></span><br><span class="line">    EventLoop loop;</span><br><span class="line">    <span class="comment">// 2. 对socket编程中的sockaddr_in进行封装</span></span><br><span class="line">    <span class="function">InetAddress <span class="title">addr</span><span class="params">(<span class="number">8002</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 3.EchoServer初始化</span></span><br><span class="line">    <span class="function">EchoServer <span class="title">server</span><span class="params">(&amp;loop, addr, <span class="string">&quot;EchoServer&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 4.启动服务器server</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">// 5.开启main loop事件循环：epoll_wait等待listenfd的accpet连接事件</span></span><br><span class="line">    loop.<span class="built_in">loop</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>即使你目前对上述出现<code>loop</code> 、<code>事件循环</code> 等概念还一无所知。但足够简洁的API接口，做业务层的开发，却已经可以实现一个自己的高性能“复读机”服务器了！</p><h2 id="1-2-整体架构：Multi-Reactor">1.2 整体架构：Multi-Reactor</h2><h3 id="1-2-1-高并发之网络IO模型">1.2.1 高并发之网络IO模型</h3><p>高并发即我们所说的 C10K（一个 server 服务 1w 个 client）, C10M（一个 server 服务 1M 个 client） 。这节将主要循序渐近地，介绍如何设计出一个高并发网络 IO 框架：</p><ul><li>传统同步阻塞 IO 模型的缺陷</li><li>针对传统同步阻塞 IO 模型缺陷的改进</li><li>IO 多路复用</li><li>Reactor模型</li></ul><h4 id="传统同步阻塞-IO-模型的缺陷">传统同步阻塞 IO 模型的缺陷</h4><p>在该小节我们重点关注以下两点：</p><ol><li>传统同步阻塞 IO 模型有哪些缺陷？</li><li>传统同步阻塞IO 模型阻塞点有哪些？</li></ol><p>先重温下客户端和服务端的基于TCP的通信流程：</p><table><thead><tr><th>客户端和服务端TCP通信流程</th><th>伪代码</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/90dbe13651eaa48fb760dd13f9d6c1ad.png" alt="img"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230309160413142.png" alt="image-20230309160413142"></td></tr></tbody></table><ol><li><p><strong>服务端</strong>：server 调用<code>socket()</code>创建<u>监听 socket</u> 后，执行<code> bind()</code> 绑定 IP 和端口，然后调用<code> listen()</code> 监听，代表 server 已经准备好接收请求了，listen 的主要作用其实是初始化半连接和全连接队列大小；</p></li><li><p><strong>客户端</strong>：server 准备好后，client 也创建 socket ，然后执行 <code>connect()</code> 向 server 发起连接请求，<strong>这一步会被阻塞</strong>，需要等待三次握手完成：</p><ul><li><p>第一次握手完成，服务端会创建 <u>连接socke</u>t，将其放入半连接队列中；</p><blockquote><p><strong>连接socket与监听socket区分</strong>？</p><ul><li>监听socket，即服务端调用<code>socket()</code>返回的<u>监听 socket</u> ，负责特定客户端和服务器的等待连接、建立连接，不负责数据传输；</li><li>连接 socket，即accept后返回的连接 socket， 负责在连接完成后与指定客户端完成一对一的数据传输。</li></ul><p>二者各司其职。</p></blockquote></li><li><p>第三次握手完成，系统会把 <u>连接socket</u> 从半连接队列摘下放入全连接队列中，然后 accept 会将其从全连接队列中摘下，之后此 <u>连接socket</u>就可以与客户端 socket 正常通信了，默认情况下如果全连接队列里没有 <u>连接socket</u>，则 accept 会<strong>阻塞等待</strong>三次握手完成。</p></li></ul></li><li><p><strong>read/业务处理/write</strong>，该过程也往往发生<strong>阻塞</strong>，比如：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/79ec7119fc5ed790a4a3ea3472094821.png" alt="img"></p><ul><li>read/write需要等待内核缓冲区数据就绪/有空间可写等；</li><li>业务处理过程也往往会发生阻塞。</li></ul></li></ol><p>开头的问题也就很好回答了，对于传统同步阻塞 IO：</p><ul><li><strong>阻塞点</strong>：传统的socket通信会阻塞在connect，accept，read/write 这几个操作上。</li><li><strong>缺陷点</strong>：性能低下，如单进程/线程，只要 server 阻塞，就不能处理其他 client 。</li></ul><h4 id="针对同步阻塞IO模型缺陷的改进">针对同步阻塞IO模型缺陷的改进</h4><p>针对上面的阻塞点，我们可以做如下进行改进。</p><h5 id="多进程-线程：避免read-业务处理-write阻塞">多进程/线程：避免read/业务处理/write阻塞</h5><p>如果 server 是单进程/线程，<strong>read/业务处理/write阻塞会导致 server无法再处理其他client请求了，能不能把read/业务处理/write交给<u>子</u>进程/线程处理</strong>？这样一定程度上可提高服务器并发。</p><blockquote><p>一般是使用多线程，因为<u>多进程</u>相对<u>多进程</u>负担更大：</p><ol><li><p>要考虑“<u>子进程善后</u>”：当「子进程」退出时，实际上内核里还会保留该进程的一些信息，也是会占用内存的，如果不做好“回收”工作，就会变成<strong>僵尸进程</strong>，慢慢耗尽我们的系统资源；因此，父进程要在子进程退出后回收资源，分别是调用 <code>wait()</code> 和 <code>waitpid()</code> 函数。</p></li><li><p>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源；</p></li><li><p>进程创建/开销大。</p></li></ol></blockquote><ul><li><p><strong>父进程/线程负责 accept(listenfd)等待客户端新连接</strong>， 有新连接fork一个子进程/创建一个线程，把accept返回的connfd 交给子进程/线程处理；</p><blockquote><p>父进程中accept依旧会阻塞等待连接就绪。</p></blockquote></li><li><p><strong>子进程/线程负责read(connfd)/write(connfd)等待connfd读写</strong>，这样就算：子进程/线程read/业务处理/write阻塞了，但不影响父进程/线程处理其它client连接。</p></li></ul><table><thead><tr><th>多进程IO</th><th>伪代码</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/d837739b1ef65399bbd4fdfb53aff34f.png" alt="img"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230310111604769.png" alt="image-20230310111604769"></td></tr></tbody></table><h5 id="有关线程池"><strong>有关线程池</strong></h5><p>不过无论是多进程还是多线程，创建、销毁的开销其实并不小。因此我们还会往往用<u>进程池</u>or<u>线程池</u>进行管理。</p><blockquote><p>需要注意的是，这个队列是全局的，每个线程都会操作，为了避免多线程竞争，线程在操作这个队列前要加锁。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="img"></p><h5 id="非阻塞IO：一个线程处理多个fd">非阻塞IO：一个线程处理多个fd</h5><p>对于同步多线程阻塞模型，<strong>为了线程io（read/业务处理/wirte）阻塞不影响处理下一个连接</strong>，只能在处理io事件时就单开一个线程，提高服务的吞吐。而如果上万个连接<strong>同时</strong>到来，服务器资源很容易遇到瓶颈。</p><p>想象一下，如果有1w个客户端<strong>同时</strong>发生连接，：</p><ol><li><p>主进程开始处理client1：主进程阻塞等待connect/accept就绪，连接建立==&gt;返回连接socket connfd1给子进程1处理==&gt;子进程1开始处理read/业务处理/wirte；</p></li><li><p>主进程开始处理client2：…</p><p>…</p></li><li><p>主进程开始处理clientN：…</p></li></ol><p>不难发现，过多的阻塞等待浪费了服务器性能：</p><ol><li>对于主进程：大量时间浪费在<strong>等待connect/accept就绪</strong>，<u>这个等待过程可以先处理其它事情</u>；</li><li>对于子进程：大量时间浪费在等待<strong>read阻塞到可读/业务处理完成/write阻塞上</strong>，等待read/write就绪过程，也可以处理其它事情。</li></ol><p>我们可以设置为非阻塞：</p><ol><li><p>对于<strong>进程的阻塞操作（connect，accept，read/write），改为非阻塞</strong>：</p><ul><li><p>如果相应的事件未准备好，就立马返回 EWOULDBLOCK 或 EAGAIN 错误，不阻塞进程；</p></li><li><p>使用 fcntl 可以可以将 socket 设置为非阻塞 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connfd = <span class="built_in">accept</span>(listenfd);</span><br><span class="line"><span class="built_in">fcntl</span>(connfd, F_SETFL, O_NONBLOCK);</span><br><span class="line"><span class="comment">// 此时 connfd 变为非阻塞，如果数据未就绪，read 会立即返回</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">read</span>(connfd, buffer) != SUCCESS; </span><br></pre></td></tr></table></figure></li></ul></li><li><p>对于<strong>业务处理阻塞</strong> ，可以新开一个线程去处理，不影响主流程。</p></li></ol><p>如此，减少大量不必要的等待，服务器的性能得到进一步榨干。<strong>更妙的是，线程不再阻塞没有就绪就立即返回，使得N个新连接必须要开N个线程去处理（避免read/业务处理/write阻塞主线程处理其它连接），一个线程就可以处理多个连接</strong>。</p><p>两种实现：</p><ul><li><p><strong>一个线程不断轮询所有描述符</strong>：</p><ol><li>遍历listenfd &amp; connfd ；</li><li>如果是listenfd ，accept是否有返回connfd，是通知用户程序处理，<strong>不是也不阻塞立即返回</strong>；</li><li>如果是connfd，read/write 是否就绪，是则通知用户程序处理，<strong>不是也不阻塞立即返回</strong> ；</li><li>重复以上。</li></ol></li><li><p><strong>基于I/O多路复用</strong>，向内核注册后，一个进程可以监视多个描述符fd，且一旦某个描述符就绪（连接就绪/读就绪/写就绪），内核通知用户程序进行相应的处理新连接/读/写操作。</p></li></ul><p>但是，<strong>第一种同步非阻塞IO模型实现基于<u>循环+非阻塞</u>，即用户需要不断循环调用read/write</strong>，如read：尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型。</p><p><strong>第二种I/O多路复用，避免同步非阻塞IO模型中不断轮询和大量系统调用</strong>。直接向<u>内核注册</u>，不需要设置非阻塞（但I/O多路复用往往是结合非阻塞），基于<u>事件通知机制</u>通知用户程序。</p><h4 id="IO多路复用：select-poll-epoll">IO多路复用：select/poll/epoll</h4><p>目前支持I/O多路复用的系统调用有<code>select，pselect，poll，epoll。</code>与多进程和多线程技术相比，<strong>I/O多路复用技术的最大优势是可以一个进程/线程就可以监听多个客户端fd，而不必每个都要专门开个进程/线程去处理IO读写事件</strong> 。</p><p>在以前的<a href="https://hwh.zone/p/15646/">个人博客</a>，详细分析过，这里不详细描述。仅简单放下select/poll/epoll伪代码比对：</p><ul><li><code>select</code>： ①每次一个fd可读需遍历所有；③描述符有上限 ；③ 大量描述符数组被整体复制于用户态和内核态的地址空间；④ ；</li><li><code>poll</code> ：①每次一个fd可读需遍历所有；② 描述符<strong>无</strong>上限  ；③大量描述符数组被整体复制于用户态和内核态的地址空间；</li><li><code>epoll</code>：①只需遍历<u>就绪</u>的fd； ②描述符无上限； ③有mmap映射高效缓冲区，没有大量描述符从用户态和内核态直接的复制。</li></ul><table><thead><tr><th>select</th><th>poll</th><th>epoll</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230308175037297.png" alt="image-20230308175037297"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230308175104079.png" alt="image-20230308175104079"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230308175637979.png" alt="image-20230308175637979"></td></tr></tbody></table><h4 id="Reactor模式：继续优化多路IO">Reactor模式：继续优化多路IO</h4><p><strong>我们已经知道 IO 多路程复用是用一个进程来管理多个 socket 的， 那么是否还有优化的空间呢</strong>？</p><p>以最简单的select为例：</p><ol><li>调用 select 来监听连接，读写事件；</li><li>收到事件后判断是否是监听 listenfd 上的连接事件，是的话调用 accept() ；</li><li>否则判断是否是已连接 connfd 上的读写事件，是的话调用 read()/write() 。</li></ol><table><thead><tr><th>select流程图</th><th>select伪代码</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/c4d09a898fc645b18150aafc591ad2c6.png" alt="img"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230308175037297.png" alt="image-20230308175037297"></td></tr></tbody></table><p>上面的写法没啥问题，但是逻辑过于耦合，如果：</p><ol><li>select单独一个子逻辑，负责监听；</li><li>listenfd上的连接事件，单独拆分一个子逻辑；</li><li>connfd 上的读写事件，单独拆分一个子逻辑。</li></ol><p>这样会不会更好？</p><h5 id="单进程-线程-单Reactor模式">单进程/线程&amp;单Reactor模式</h5><p>为了提高扩展性&amp;避免耦合性，我们将IO多路复用模型再拆分为三个模块：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/805350f4232fb586d4d0257c5d215c9c.png" alt="img"></p><ol><li><strong>Reactor</strong>， 对象首先调用 select 来<u>监听</u> listenfd/connfd事件，收到事件后会通过 dispatch 分发；</li><li><strong>Acceptor</strong>，如果是连接建立事件，则由 Acceptor 处理，Acceptor 通过调用 <u>accept 接收连接</u>，并且会<u>创建一个 Handler</u> 来处理后续的读写等事件；</li><li><strong>Handler</strong>，如果不是连接建立事件，则 Reactor 会调用连接对应的 Handler 进行响应，handler 会<u>完成 read/业务处理/write 的完整业务处理流程</u>。</li></ol><p>以上这些操作其实和之前的 IO 多路复用一样，所有的操作还是在<strong>一个进程/线程</strong>进行，只不过进行更细分拆解。</p><p>但是：</p><ul><li>单进程/线程也没有充分利用多核优势；</li><li>业务处理耗时较长，那么进程/线程就会被阻塞。</li></ul><p>那么改成多进程/线程，会不会更好？</p><h5 id="多进程-线程-单Reactor模式">多进程/线程&amp;单Reactor模式</h5><p>于是人们又提出了 单 Reactor 多线程模型：</p><ol><li><p>主进程依旧负责处理：Reactor（监听 listenfd/connfd）、Accpetor（accpet连接&amp;创建Handle处理）、Handle（处理read/write，业务逻辑不再处理）；</p></li><li><p>每个Handler的业务处理，改为分配一个线程处理。</p></li></ol><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/dde30dc52e79109ee75cc30967e4bd41.png" alt="img"></p><p>但依然有如下两个瓶颈点：</p><ol><li><p><strong>子线程处理好业务数据后需要将其传回 handler进行发送处理</strong>，这涉及到共享数据的互斥和保护机制；</p><p>Handler能不能在一个线程全部处理read/业务逻辑/write，避免跨进程/线程通信？</p><blockquote><p>事实上，zaver就是这么做的，参考之前画的流程图：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/http-main.png" alt="http-main"></p><p>不过这里的主要瓶颈我认为是第二点。</p></blockquote></li><li><p><strong>主进程单个Reactor负责监听所有fd（listenfd &amp; clientfd）io事件</strong>，在客户端瞬时大并发，会出现性能瓶颈。</p><p><strong>其它Reator分担一些事件监听如io事件等，那该多好</strong>？这也是主要瓶颈所在。</p></li></ol><h5 id="多进程-线程-多Reactor模式">多进程/线程&amp;多Reactor模式</h5><p>基于以上逻辑考虑，多进程/线程&amp;多Reactor模式诞生了：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/a31ef38616720ac9c5d7e0719ee57714.png" alt="img"></p><p>工作原理如下：</p><ol><li><strong>主进程负责处理：Mian-Reactor（只监听listenfd）、Accpetor（accpet连接&amp;创建Handle处理）</strong>，接收connfd后会将其传给 subReactor；</li><li><strong>子进程负责处理：Sub-Reactor（只监听connfd的io读写事件）</strong>，将其连接加入连接队列中来监控；</li><li><strong>Handler，一起处理read/业务逻辑/write，每个Handler一个线程</strong>。</li></ol><p>以上介绍的只是标准的 Reactor 模型，但实际上生产上应用的 Reactor 不一定完全遵照这些标准。</p><p>一起看看muduo怎么做的！</p><h3 id="1-2-2-Muduo与Reactor模式">1.2.2 Muduo与Reactor模式</h3><p>Muduo采用的便是<strong>多线程&amp;多Reactor模式</strong>。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230310203312893.png" alt="image-20230310203312893"></p><ul><li>主进程中，Main-Reactor负责<u>监听</u>listenfd，等待连接事件；Accpetor负责<u>accpet连接</u>返回connfd（注意在muduo，dispatch逻辑实际也在Accpetor中：用于分配一个Sub-Reactor&amp;绑定/注册返回connfd）。</li><li>子进程中（1~N），每个子进程运行一个Sub-Reactor，负责<u>监听</u>已注册的connfd等待io读写事件。</li></ul><p>在muduo中，每个Main-Reactor/Sub-Reactor抽象为EventLoop对象，且运行在一个线程中。这也是<code>one loop per thread</code>的由来。</p><p>仅仅通过上图，也能发现muduo不少特别之处：</p><ol><li><strong>每个Sub-Reactor都会负责监听一部分connfd的io事件</strong>，提高了服务器处理连接能力；</li><li>Sub-Reactor和Main-Reactor通信，是<strong>通过更高效eventfd</strong>，而不是像Main-Reactor使用socket listen()和客户端通信；</li><li><strong>Sub-Reactor不仅要①处理其负责的connfds的io事件；②还要处理回调队列中的事件</strong>。</li></ol><p>上面的Reactor/Accpetor/…概念，又是在muduo代码中怎么抽象实现？一起看看！</p><h2 id="1-3-Muduo核心类">1.3 Muduo核心类</h2><p>Muduo核心类的结构如下：</p><blockquote><p><strong>为什么要继承NonCopyable基类</strong>？</p><ul><li><p>好处：强制只能以指针的方式使用， 不能以拷贝类的方式来使用， 避免反复拷贝内存空间消耗。</p></li><li><p>具体实现：这个类将拷贝和赋值构造函数给delete掉，提供了一个<strong>不可拷贝</strong>的基类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NonCopyable</span>(<span class="keyword">const</span> NonCopyable &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">NonCopyable &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> NonCopyable &amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/classnoncopyable__inherit__graph%E7%9A%84%E5%89%AF%E6%9C%AC2.png" alt="classnoncopyable__inherit__graph的副本2"></p><h3 id="1-3-1-Reactor：Poller、EventLoop、EventLoopThread、TcpConnection、Channel">1.3.1 Reactor：Poller、EventLoop、EventLoopThread、TcpConnection、Channel</h3><h4 id="Poller类-EPollPoller类">Poller类 &amp; EPollPoller类</h4><p>Poller类底层封装<u>epoll</u> &amp; <u>poll</u>，它还会被EPollPoller继承，EPollPoller是<u>epoll</u>的封装类。整体实现比较简单。</p><p>其中：</p><ul><li>updateChannel()、removeChannel() ，等函数是封装<code>EPOLL_CTL_ADD</code> 、<code>EPOLL_CTL_DEL</code> ；</li><li>Poller，构造函数owerLoop标识了当前Poller对象所属Loop；析构函数，默认；</li><li>EollPoller构造函数，执行Poller构造函数，创建epollfd；析构函数关闭epollfd。</li></ul><table><thead><tr><th>Poller &amp; EPollPoller成员及继承关系</th><th>EPollPoller构造函数&amp;析构函数</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/classEPollPoller__inherit__graph.png" alt="classEPollPoller__inherit__graph"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230302174034339.png" alt="image-20230302174034339"></td></tr></tbody></table><h4 id="EventLoop类">EventLoop类</h4><p>EventLoop类进一步封装了Poller类，通过调用Poller::poll()进行I/O复用，返回活跃事件列表，<strong>然后遍历该列表，依次调用每一个活跃Channel的</strong>事件处理函数handleEvent()，而handleEvent其实就是根据事件响应类型（EPOLLIN、EPOLLOUT等），最终调用TcpConnection注册过来的回调函数。</p><table><thead><tr><th>EventLoop类成员</th><th>EventLoop类构造函数&amp;析构函数</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230310202213519.png" alt="image-20230310202213519"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230310202407788.png" alt="image-20230310202407788"></td></tr></tbody></table><p>作为muduo的核心类，EventLoop类值得分析的地方很多。 <u>本文将在2.1部分，串讲整个流程加深理解</u>。</p><h5 id="从构造函数看：wakeupFd设计与tie初识">从构造函数看：<code>wakeupFd</code>设计与<code>tie</code>初识</h5><p><strong>这里，我们先来看看<code>wakeupFd</code>设计</strong>。</p><p>想想这么一种情况：<strong>Sub-Reactor（EventLoop）开启事件循环后，阻塞在epoll；此时如果有新连接clientfd待注册，Main-Reactor（Accpetor）如何通知Sub-Reactor</strong>？</p><p>这个时候便需要<code>wakeupFd</code>“唤醒”。聪明的你想到：<strong>Accpetor绑定的listenfd是通过<code>listen()</code>来监听客户端请求，Sub EventLoop也可以通过<code>listen()</code>来监听Main-Reactor请求</strong>？</p><blockquote><p>⚠️ 回忆<code>listen()</code>：</p><ul><li><code>listen()</code> 只是让套接字进入监听状态，并没有真正接收客户端请求，listen() 后面的代码会继续执行，直到遇到 accept()；</li><li><code>accept() </code>返回一个新fd来和客户端通信，会阻塞程序执行（后面代码不能被执行），直到有新的请求到来。</li></ul></blockquote><p>但在muduo中，使用的是更高效的<code>eventfd</code>。注意到上表右侧EventLoop<u>构造函数</u>：</p><blockquote><p><strong>eventfd是linux的一个系统调用</strong>，为事件通知创建文件描述符，eventfd()创建一个“eventfd对象”，这个对象能被用户空间应用用作一个<strong>事件等待/响应机制</strong>，靠内核去响应用户空间应用事。</p></blockquote><ol><li><p><strong>首先，创建wakeFd &amp; wakeupChannel</strong>:</p><p>不同于常规使用socket跨线程通信，muduo使用eventfd（事件驱动更快，8字节缓存区也更省）。wakeupChannel_随后对eventfd进行封装。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wakeupFd_</span>(<span class="built_in">createEventfd</span>()) </span><br><span class="line"><span class="built_in">wakeupChannel_</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(<span class="keyword">this</span>, wakeupFd_))</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createEventfd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> evtfd = ::<span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (evtfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;eventfd error:%d\n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> evtfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>随后wakeupChannel_设置Read回调事件<code>EventLoop::handleRead</code></strong>：</p><blockquote><p>注意区分后面会提到的：<code>Acceptor::handleRead</code>函数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wakeupChannel_-&gt;<span class="built_in">setReadCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;EventLoop::handleRead, <span class="keyword">this</span>)); </span><br></pre></td></tr></table></figure><p>很简单，<code>EventLoop::handleRead(this)</code> 只是有写事件（Main-Reactor为了唤醒往<code>wakeupFd_</code> 写）时，读出数据，基本啥也没干。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::handleRead</span><span class="params">()</span> <span class="comment">// 删除read判错逻辑</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> n = <span class="built_in">read</span>(wakeupFd_, &amp;one, <span class="built_in"><span class="keyword">sizeof</span></span>(one));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Sub-Reactor（EventLopp）注册wakeFd事件开始监听</strong>：</p><p><code>Channel::enableReading()</code> 核心逻辑是，注册fd事件到当前调用Channel所绑定的EventLoop的epoll上。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230302153343007.png" alt="image-20230302153343007"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wakeupChannel_-&gt;<span class="built_in">enableReading</span>();</span><br></pre></td></tr></table></figure></li></ol><p>这样Main-Reactor需要唤醒Sub-Reactor时：</p><ol><li><p>将新连接建立的回调事件（<em><strong>TcpConnection::connectEstablished</strong></em>,），压入Sub-Reactor的<u>回调队列</u> ；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*in TcpServer.cc*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> InetAddress &amp;peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// .... 省略</span></span><br><span class="line">  ioLoop-&gt;EventLoop::<span class="built_in">runInLoop</span></span><br><span class="line">  (std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只需简单<code>wakeup()</code> , Sub-Reactor便不再阻塞在epoll；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来唤醒loop所在线程 向wakeupFd_写一个数据 wakeupChannel就发生读事件 当前loop线程就会被唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span><span class="comment">// 删除write判错逻辑</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> n = <span class="built_in">write</span>(wakeupFd_, &amp;one, <span class="built_in"><span class="keyword">sizeof</span></span>(one));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>随后Sub-Reactor被唤醒，遍历处理队列中的回调事件。</p></li></ol><p><strong><code>TcpConnection::connectEstablished</code> 做了什么</strong>？</p><p>不难分析中，当新连接到来时，我们至少需要它可以完成以下工作：</p><ul><li>我们需要新连接的clientfd注册到Sub-Reactor，进行后续监听；</li><li>我们需要执行用户自定义的连接回调；</li><li>…</li></ul><p>其实现便呼吁而出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接建立</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setState</span>(kConnected);</span><br><span class="line">    <span class="comment">// 1.解决TcpConnection对象已经不存在了，还能感知到Poller的通知并调用Channel的回调方法的问题</span></span><br><span class="line">    <span class="comment">// shared_from_this()==指向对象this指针的有效shared_ptr</span></span><br><span class="line">    channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    <span class="comment">// 2.向poller注册channel的EPOLLIN读事件</span></span><br><span class="line">    channel_-&gt;<span class="built_in">enableReading</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.新连接建立：执行用户自定义的回调</span></span><br><span class="line">    <span class="comment">// TcpConnection::connectionCallback==EchoServer::onConnection</span></span><br><span class="line">    <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这里出现了一个奇怪的东西：<strong><code>tie</code> 这是什么？</strong></p><p>简单来说，<code>tie</code>避免了这么一种情况：</p><ul><li>Channel所属的TcpConnection对象（简称<code>T</code>）已经不存在，但Channel还在处理clientfd回调事件&amp;调用Channel的回调方法；</li><li>而且Channel回调方法里又往往调用了<code>T</code>的方法成员，如<code>send()</code>等处理数据收发；</li><li>最后，调用不存在的对象<code>T</code>导致程序崩溃。</li></ul><p>在后面的<u>EventLoop::loop()</u>介绍中，我们还会详细解释分析<code>tie</code>调用流程。</p><h5 id="析构函数">析构函数</h5><p>EventLoop析构函数负责：</p><ul><li>①epoll上移除wakeupChannel_相关事件；</li><li>②移除从epoll上把wakeupChannel_所管理的fd；</li><li>③调用系统函数关闭fd。</li></ul><h5 id="loop-函数">loop() 函数</h5><p><code>loop() </code> 函数用来开启事件循环，说人话便是：</p><ol><li>启动底层epoll_wait监听感兴趣事件 ；</li><li>感兴趣事件处理，如：①for循环处理可读、可写、错误等事件；②doPendingFunctors函数处理回调队列中的事件。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启事件循环</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    looping_ = <span class="literal">true</span>;</span><br><span class="line">    quit_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;EventLoop %p start looping\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!quit_)</span><br><span class="line">    &#123;</span><br><span class="line">        activeChannels_.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// 1. 底层实际还是调用epoll_wait监听</span></span><br><span class="line">        pollRetureTime_ = poller_-&gt;<span class="built_in">poll</span>(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">        <span class="comment">// 2. 处理事件1：遍历处理响应的EPOLLIN、EPOLLOUT等事件</span></span><br><span class="line">        <span class="keyword">for</span> (Channel *channel : activeChannels_)</span><br><span class="line">        &#123;    </span><br><span class="line">            channel-&gt;<span class="built_in">handleEvent</span>(pollRetureTime_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 处理事件2：遍历执行回调队列中的回调事件（函数）</span></span><br><span class="line">        <span class="comment">// 如前述提到的，新连接到来，Main-Reactor将回调事件</span></span><br><span class="line">        <span class="comment">// TcpConnection::connectEstablished加入Sub-Reactor的回调队列</span></span><br><span class="line">        <span class="built_in">doPendingFunctors</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;EventLoop %p stop looping.\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    looping_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有两个地方值得注意：</p><ol><li><code>Channel::handleEvent</code> 实现逻辑，特别是其中<code>tie</code>相关逻辑；</li><li><code>EventLoop::doPendingFunctors()</code>实现逻辑，特别是其中的<u>线程同步加锁逻辑</u>。</li></ol><h6 id="Channel-handleEvent实现"><strong><code>Channel::handleEvent</code>实现</strong></h6><p><code>Channel::handleEventWithGuard</code> 作用：当epoll返回可读、可写、错误等事件，去调用TcpConnetion类给Channel设置的回调函数进行处理。</p><p>这里又出现了那个奇怪的<code>tie</code> ？</p><table><thead><tr><th>Channel::handleEvent</th><th>Channel::handleEventWithGuard</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230302213126042.png" alt="image-20230302213126042"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com//image-20230302213317905.png" alt="image-20230302213317905"></td></tr></tbody></table><h6 id="tie深入理解"><code>tie</code>深入理解</h6><p>前面简单提到：</p><blockquote><p><code>tie</code>避免了这么一种情况：</p><ul><li>Channel所属的TcpConnection对象（简称<code>T</code>）已经不存在，但Channel还在处理clientfd回调事件&amp;调用Channel的回调方法；</li><li>而且Channel回调方法里又往往调用了<code>T</code>的方法成员，如<code>send()</code>等处理数据收发；</li><li>最后，调用不存在的对象<code>T</code>导致程序崩溃。</li></ul></blockquote><p>所以，我们需要<code>tie</code>：保证<strong>先让Channel回调函数先把数据发送完，再释放TcpConnection对象的资源</strong>。</p><p>整个过程复盘如下：</p><ol><li><p>如前提到，Main-Reactor需要唤醒Sub-Reactor时，首先会将新连接回调事件（<em><strong>TcpConnection::connectEstablished</strong></em>,），压入Sub-Reactor的<u>回调队列</u> ；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*in TcpServer.cc*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> InetAddress &amp;peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// .... 省略</span></span><br><span class="line">  ioLoop-&gt;EventLoop::<span class="built_in">runInLoop</span></span><br><span class="line">  (std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*in TcpConnection.cc*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setState</span>(kConnected);</span><br><span class="line">    <span class="comment">// 1.解决TcpConnection对象已经不存在了，还能感知到Poller的通知并调用Channel的回调方法的问题</span></span><br><span class="line">    channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    <span class="comment">// 2.向poller注册channel的EPOLLIN读事件</span></span><br><span class="line">    channel_-&gt;<span class="built_in">enableReading</span>(); </span><br><span class="line">    <span class="comment">// 3.新连接建立：执行用户自定义的回调</span></span><br><span class="line">    <span class="comment">// TcpConnection::connectionCallback==EchoServer::onConnection</span></span><br><span class="line">    <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时是在<code>TcpConnection</code>对象<code>T</code>中，<code>shared_from_this()</code> 返回的是shared_ptr指针指向<code>T</code>。</p><p><code>Channel::tie</code>使用<strong>weak_ptr</strong> 即<code>tie_</code>绑定了<code>T</code> ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;<span class="keyword">void</span>&gt; tie_; </span><br><span class="line"><span class="comment">/*****  Channel.cc   ******/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::tie</span><span class="params">(<span class="keyword">const</span> shared_ptr&lt;<span class="keyword">void</span>&gt;&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tie_ = obj;</span><br><span class="line">    tied_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样，如果epoll监听事件触发，执行<code>Channel::HandlerEvent</code> ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tied_)&#123;</span><br><span class="line">        shared_ptr&lt;<span class="keyword">void</span>&gt; guard = tie_.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (guard)</span><br><span class="line">            <span class="built_in">HandleEventWithGuard</span>(receiveTime);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先判断一下当前Channel是否生命绑定了一个TcpConnection对象（貌似是一定成立的？） ；</p></li><li><p>然后重头戏，使用<code>tie_.lock()</code> 将<code>tie_</code>这个weak_ptr提升→shared_ptr ，该shared_ptr执行TcpConnection对象；</p><blockquote><p>参考<a href="https://blog.csdn.net/qq_38410730/article/details/105903979">here</a>：weak_ptr不改变shared_ptr实例的引用计数，可能存在weak_ptr指向的对象被释放掉这种情况，<strong>如何判断weak_ptr指向对象是否存在呢</strong>？C++中提供了lock<code>()</code>来实现该功能。</p><p>如果对象存在，lock()函数返回一个指向共享对象的shared_ptr(引用计数会增1)，否则返回一个空shared_ptr。</p></blockquote></li><li><p>如果<code>guard</code> 不为null，则说明共享的TcpConnection对象还存在，可以放心地继续往下执行<code>Channel::handleEventWithGuard</code> ；否则不做处理。</p></li></ul></li></ol><p>至此，<code>tie</code>的作用便已了然于胸：保证在Channel对象执行回调时，TcpConnection对象一定存在。</p><h6 id="doPendingFunctors-：结合runInLoop-理解回调队列中的多线程同步">doPendingFunctors() ：结合runInLoop()理解回调队列中的多线程同步</h6><p>如前提到，在事件循环loop()中，epoll被触发时，需执行两类事件：</p><ol><li>处理事件1：遍历处理响应的EPOLLIN、EPOLLOUT等事件，这类事件处理<u>基本是用户自定义业务回调函数</u>处理；</li><li>处理事件2：遍历执行回调队列中的回调事件（函数），如框架中预定义的TcpConnection::shutdownInLoop、TcpConnection::connectEstablished() 等。</li></ol><p>第2类事件处理，便在doPendingFunctors()中实现。其中的多线程设计难点，要结合runInLoop()函数理解：</p><table><thead><tr><th>EventLoop::runInLoop()</th><th>EventLoop::doPendingFunctors()</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230303163927004.png" alt="image-20230303163927004"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230303163516830.png" alt="image-20230303163516830"></td></tr></tbody></table><ul><li><p><strong>runInLoop(cb)函数功能：负责唤醒调用其所属EventLoop对象所在的线程，并执行回调事件cb</strong>。</p><ul><li><p><strong>如果TA≠TB</strong>，触发新事件时，某个EventLoop对象EA（所属线程TA），唤醒（不再阻塞在epoll）&amp;调用另外某个EventLoop对象EB（所属线程TB）的函数<code>runInLoop(cb)</code>，将回调cb加入到回调队列<code>pendingFunctors_</code>；</p><p>比如，新连接到来时，main loop（所属线程TA）调用sub loop（所属线程TB）<code>runInLoop(TcpConnection::connectEstablished)</code>。</p></li><li><p><strong>如果TA=TB</strong>，则立即执行回调事件<code>cb()</code>，走到这里说明线程没有处理其它事（比如正在处理回调队列），因此直接执行即可。</p></li></ul></li><li><p><strong>doPendingFunctors()函数功能</strong>：在某个EventLoop对象，例如为上述EB，处理回调队列<code>pendingFunctors_</code>中的函数 。</p></li></ul><p><strong>当TA≠TB，存在两个多线程同步问题</strong>：</p><ol><li><p><strong>线程TA，如何保证将回调事件注册EventLoop对象 EB上时，去唤醒TB执行？EB属于线程TB</strong>；</p></li><li><p><strong>EventLoop对象EB所属线程TB已经被唤醒，且正在处理<code>pendingFunctors_</code> ；此时TA又要将新回调<code>cb</code>加入<code>pendingFunctors_</code> ，该如何用锁优雅处理<code>pendingFunctors_</code>的多线程竞争</strong>？</p><ul><li>不过这里有个疑问：<u>这里是典型1消费者N生产者模型，即有多个生产线程可能往<code>pendingFunctors_</code>加入cb回调，当前EventLoop对象所在线程消费执行cb回调。虽然<code>pendingFunctors_</code>会被多个线程改变状态，但是生产者线程之间各自加入自己回调不需要状态同步，各自加入回调即可；消费者遍历<code>pendingFunctors_</code>回调队列时，虽然队列状态不一定准确，比如判断已经遍历到队尾时但恰好又有新cb加入，等待下次再处理即可</u>？</li></ul><p>我猜测原因应该是<u>pendingFunctors_是Vector类型，而Vector是线程非安全的，所以其实还是需要状态同步</u>。</p><ul><li>例如，<strong>多个</strong>生产者线程之间向pendingFunctors_.emplace_back(cb)加入回调<u>其实是需要状态同步</u>的。因为pendingFunctors_是vector数组，vector数组插入非线程安全，且存在<u>自动扩容</u>机制。比如线程a插入触发扩容数组的内存重新分配，线程b又恰好插入，可能会引起意料之外的内存错误。</li><li>又如，<strong>单个</strong>消费者线程消费cb，erase后虽然vector不会<u>自动缩容</u>，但是考虑线程安全还是加锁？<strong>高手看不透啊</strong>。</li></ul></li></ol><blockquote><p>对于问题1：<strong>线程TA，如何保证将回调事件注册EventLoop对象 EB上时，去唤醒TB执行</strong>？</p></blockquote><p>muduo给出的答案是：</p><ol><li>EventLoop对象只运行在一个Thread上，并在对象初始化时使用<code>threadId_</code>字段记录该Thread的pid；</li><li>在注册回调时，通过<code>isInLoopThread()</code> 函数比较调用EB线程的pid 和 <code>threadId_</code>字段，如果一样则直接执行；</li><li>如果不一样，调用EB的wakeup()，唤醒其属Thread TB即可。</li></ol><blockquote><p>对于问题2：<strong>如何优雅用锁处理<code>pendingFunctors_</code>的多线程竞争</strong>？</p></blockquote><p>设置互斥锁<code>mutex_</code>来处理，暂时忘记muduo，下面看似更简单一点实现有什么问题？</p><table><thead><tr><th>EventLoop::queueInLoop() : 基本无改动</th><th>EventLoop::doPendingFunctors()：第一次实现</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230303203552875.png" alt="image-20230303203552875"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230303211319508.png" alt="image-20230303211319508"></td></tr></tbody></table><ul><li><p><strong>锁范围增大，性能降低</strong>：只有等回调队列函数全部执行完才释放锁，在此期间<u>queueInLoop将不可用</u>；</p></li><li><p><strong>死锁风险</strong>：<code>doPendingFunctors</code>拿到锁—&gt;<code>queueInLoop</code>等待<code>doPendingFunctors</code>释放锁—&gt; <code>doPendingFunctors</code>执行的回调恰好也要执行<code>queueInLoop</code> —&gt; <code>doPendingFunctors</code>等待<code>queueInLoop</code>执行 —&gt;死锁。</p></li></ul><p>聪明的你想到：如<strong>前述，我们加锁主要是考虑Vector类型回调队列多线程操作（插入、删除等）安全；但消费线程（EventLoop对象）执行<code>cb()</code>时，里面的回调函数完全是可以独立执行的。如果将队列中回调函数放到临时队列，遍历临时队列执行回调就可以释放锁了（队列相关操作完成）。不但缩小锁范围了，同时还避免了死锁</strong>！</p><p>因此，我们写出第2版代码：</p><table><thead><tr><th>EventLoop::queueInLoop() : 基本无改动</th><th>EventLoop::doPendingFunctors()：修改锁范围</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230303203552875.png" alt="image-20230303203552875"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230303220711006.png" alt="image-20230303220711006"></td></tr></tbody></table><p>不过我们依旧可以做一个小改进：</p><ul><li>使用callingPendingFunctors_记录（右栏）EventLoop对象所在线程T<u>是否已经遍历执行完</u>回调队列中的函数；</li><li>如果EventLoop对象所在线程在执行回调，新回调cb加入<u>应该要随着队列中的回调一起执行完</u>（属于时间段的事件），这样当<code>callingPendingFunctors_=true</code>，唤醒EventLoop对象所在线程， 让执行完<code>doPendingFunctors</code>进入到下一次<code>poller_-&gt;poll()</code>也不阻塞，会再依次执行<code>doPendingFunctors</code>处理新cb。</li></ul><p>最后muduo代码实现为：</p><blockquote><p>这里还有个小疑问：</p><ul><li>为什么这个callingPendingFunctors_变量没有用原子？外面有线程会来读这个变量，内部本身的io线程会修改这个变量，感觉需要保证这个变量的原子性？</li></ul></blockquote><table><thead><tr><th>EventLoop::queueInLoop()</th><th>EventLoop::doPendingFunctors()：增加执行状态字段</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230303224111361.png" alt="image-20230303224111361"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230303224204945.png" alt="image-20230303224204945"></td></tr></tbody></table><h4 id="EventLoopThread类">EventLoopThread类</h4><p>都说EventLoop是<code>one loop per thread</code>，其秘密便藏在EventLoopThread类中。</p><p><strong>先来看看EventLoopThread类主要职能</strong>：</p><ol><li>负责管理<strong>一个</strong>线程；</li><li><strong>一个</strong>线程对应创建<strong>一个</strong>EventLoop对象，且调用<code>EventLoop::loop()</code>。</li></ol><table><thead><tr><th>EventLoopThread类成员</th><th>EventLoopThread类构造&amp;析构函数</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230306152734033.png" alt="image-20230306152734033"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230306150450754.png" alt="image-20230306150450754"></td></tr></tbody></table><p>EventLoopThread函数很少，我们重点关注：构造&amp;析构函数、<code>startLoop()</code>、<code>threadFunc()</code> 函数。</p><h5 id="构造函数-析构函数">构造函数 &amp; 析构函数</h5><ul><li><p>构造函数：可以看到，<code>thread_</code>绑定了<code>EventLoopThread::threadFunc</code>  函数；</p></li><li><p><strong>析构函数</strong>：如果<code>loop_</code>不为null，说明线程绑定的EventLoopThread对象<code>loop_</code>还未析构，线程<code>thread_</code>也未退出：</p><ol><li><p>首先退出事件循环，loop_-&gt;quit()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::quit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置quit_=true使得loop()函数：while(!quit_)&#123; epoll_wait()..&#125; ，退出事件while循环</span></span><br><span class="line">    quit_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 但是还可能出现：在其它EventLoop对象中，调用了当前EventLoop对象quit()</span></span><br><span class="line">    <span class="comment">// 比如：在subloop(worker)中调用mainloop(IO)的quit时，需要唤醒mainloop(IO)执行完loop()函数。</span></span><br><span class="line">    <span class="comment">// p.s. 不太理解这种情况，而且搜了全量代码，也只有在析构才会调用quit()？</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isInLoopThread</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wakeup</span>(); <span class="comment">// 当前EventLoop对象被唤醒，由于quit_ = true当前对象loop退出。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线程退出：thread_.join()</p><p>保证线程执行完，然后退出。</p></li></ol></li></ul><h5 id="startLoop-threadFunc">startLoop() &amp; threadFunc()</h5><p>startLoop()用来创建sub loop并启动事件循环loop()。</p><p>startLoop()比较难理解的是其<u>锁逻辑</u>，这里首先需要明白：<strong>为什么loop_要上锁</strong>？</p><ol><li>在main线程中（主逻辑）启动线程池TcpServer::start()函数时，<strong>线程池EventThreadPool会创建N个EventLoopThread对象</strong>；所以，EventLoopThread::startLoop()是在<u>main线程中</u>被调用的，<strong>但main线程不负责具体的 sub loop（loop_）创建，会wait其它线程将sub loop创建完成</strong>。</li><li>EventLoopThread::startLoop()还会启动<u>一个io线程</u>（绑定了<code>threadFunc</code>函数），<strong>io线程会执行<code>threadFunc</code>去创建sub loop（loop_），通知main线程</strong>。</li></ol><p>可知，<code>loop_</code>对上述两个线程都是可见的，需要上锁。</p><table><thead><tr><th>startLoop()</th><th>threadFunc()</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230306165147863.png" alt="image-20230306165147863"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230306164520082.png" alt="image-20230306164520082"></td></tr></tbody></table><p>给<code>loop_</code> 上锁代码，是经典的：条件变量+while{wait}+notify逻辑：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230306173226883.png" alt="image-20230306173226883"></p><ul><li>main线程，while循环+条件变量等待解锁；</li><li>io 线程，创建完成EventLoop对象后，使用notify唤醒main线程；</li><li>main线程返回创建好的EventLoop对象。</li></ul><h4 id="TcpConnection类">TcpConnection类</h4><p>如前所述，TcpConnection类职能如下：</p><blockquote><p>…</p><ol start="3"><li>Sub-Reactor 向其底层封装的epoll注册clientfd ；</li><li>同时，对于每个新连接，其实是通过分配一个TcpConnection类对象处理：<ol><li><p><strong>new一个Channle对象封装clientfd</strong>，并<strong>向Channle注册回调事件</strong>（可读、可写、可关闭、错误处理）；</p></li><li><p>封装底层InputBuffer和OutputBuffer，用来进行<strong>数据收发</strong>。</p></li></ol></li></ol></blockquote><p>不难发现，<strong>TcpConnection用于sub loop中处理新连接，对connfd封装以及数据收发</strong>。</p><ul><li>注，TcpConnection类析构函数为空，因此这里省略。</li></ul><table><thead><tr><th>TcpConnection类</th><th>TcpConnection类构造函数</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230310205447731.png" alt="image-20230310205447731"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230302172836862.png" alt="image-20230302172836862"></td></tr></tbody></table><h5 id="TcpConnection对象上游调用链">TcpConnection对象上游调用链</h5><p>在前面我们说过：对于每个新连接，Accpetor分配新连接给sub loop时，会创建一个新TcpConnection对象。</p><p>那么在muduo代码中，<strong>TcpConnection对象生成的<u>具体</u>时机（调用链</strong>）？</p><ul><li><p><strong>生成时机</strong>：main loop 有新连接 —&gt;<code>Acceptor::handleRead</code> （Acceptor初始化时注册该回调）—&gt; <code>TcpServer::newConnection</code>：</p></li><li><p><strong>核心代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. accepChannel_上listenfd可读（epoll返回）--&gt;执行readCallback_--&gt;即Acceptor::handleRead()</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. Acceptor::handleRead()处理新连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InetAddress peerAddr;</span><br><span class="line">    <span class="comment">// 调用accpet4返回client_fd（connfd)&amp;相应地址(peerAddr)</span></span><br><span class="line">    <span class="keyword">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(&amp;peerAddr);</span><br><span class="line">    <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (NewConnectionCallback_)</span><br><span class="line">       <span class="comment">// 绑定为：TcpServer::newConnection</span></span><br><span class="line">            <span class="built_in">NewConnectionCallback_</span>(connfd, peerAddr); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ::<span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. TcpServer::newConnection：轮询找到subLoop 唤醒并分发当前的新客户端的Channel</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> InetAddress &amp;peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 3.1 轮询算法 选择一个subLoop 来管理connfd对应的channel</span></span><br><span class="line">    EventLoop *ioLoop = threadPool_-&gt;<span class="built_in">getNextLoop</span>();</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 3.2 创建TcpConnection对象！</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            sockfd,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            peerAddr))</span></span>;</span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line">    <span class="comment">// 3.3 TcpServer 设置回调给=&gt; TcpConnection的</span></span><br><span class="line">    conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setCloseCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line"><span class="comment">// 3.4 io loop（sub loop）执行回调connectEstablished</span></span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="构造函数：muduo中的回调注册链">构造函数：muduo中的回调注册链</h5><p>注意到，<code>TcpConnection</code>在构造函数体内还给其绑定的<code>channel_</code>注册了四个<u>读</u>、<u>写</u>、<u>关闭</u>、<u>错误</u>回调。那handleRead、handleWrite、handleClose、handleError又是什么时候被注册？</p><p>一图看明白muduo中<u>Channel类关键回调注册链</u>：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230310233710151.png" alt="image-20230310233710151"></p><p><code>TcpServer</code> 还没正式介绍过，其<strong>主要封装了Accpetor &amp; EventThreadPool ，是提供给用户的接口类</strong>。如:</p><ul><li>启动服务器<code>start()</code> 方法，启动线程池&amp;创建线程&amp;main loop开启事件循环；</li><li>上述给用户注册自定义回调的<code>TcpServer::setConnectionCallback</code> 、<code>TcpServer::setMessageCallback</code> 等方法。</li></ul><h5 id="谈谈数据收发">谈谈数据收发</h5><p>前面提到TcpConnection第二个职能：封装底层<code>InputBuffer</code>和<code>OutputBuffer</code>，用来进行<strong>数据收发</strong>。</p><p>所谓<code>InputBuffer</code>和<code>OutputBuffer</code>都是<code>Buff</code>类对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据缓冲区</span></span><br><span class="line">Buffer inputBuffer_;    <span class="comment">// 接收数据的缓冲区</span></span><br><span class="line">Buffer outputBuffer_;   <span class="comment">// 发送数据的缓冲区，用户向outputBuffer_发</span></span><br></pre></td></tr></table></figure><p>下一节我们进行具体介绍。</p><h4 id="Buff类">Buff类</h4><p>Buffer类封装了一个vector数组，以及向这个缓冲区数组读、写数据等一系列控制方法。</p><h5 id="Buff类底层数据结构">Buff类底层数据结构</h5><p>Buff类底层数据结构是个vector数组<code>buffer_</code>，结合两个读<code>writerIndex_</code>、写<code>readerIndex_</code>索引：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">char</span>&gt; buffer_;</span><br><span class="line"><span class="keyword">size_t</span> readerIndex_; <span class="comment">// 数据开始读起始位置</span></span><br><span class="line"><span class="keyword">size_t</span> writerIndex_; <span class="comment">// 数据开始写起始位置</span></span><br></pre></td></tr></table></figure><h5 id="Buff类关键函数">Buff类关键函数</h5><p>关键函数：</p><ul><li><code>append(const char* data, size_t len)</code>，将data数据添加到缓冲区中；</li><li><code>retrieveAllString()</code>，获取缓冲区所有数据，并以string返回；</li><li><code>ensureWritableByts(size_t len)</code>，当你打算向缓冲区写入长度为len的数据之前，先调用这个函数，这个函数会检查你的缓冲区可写空间能不能装下长度为len的数据，如果不能，<strong>就动态扩容</strong>。</li></ul><p>下面两个方法主要是封装了调用了上面几个方法：</p><ul><li><code>ssize_t Buffer::readFd(int fd, int* saveErrno)</code>：客户端发来数据，readFd从该TCP接收缓冲区中将数据读出来==&gt;Buffer中；操作过程参考上图。</li><li><code>ssize_t Buffer::writeFd(int fd, int* saveErrno)</code>：服务端要向这条TCP连接发送数据，通过该方法将Buffer中的数据拷贝==&gt;到TCP发送缓冲区outputBuffer_中；操作过程参考上图。</li></ul><p>Buff类这里浅浅提下，其核心设计精髓要结合<code>TcpConnection::send</code> &amp; <code>TcpConnection::handRead</code> 一起理解。在2.3、2.4复盘有详细分析。</p><h4 id="Channel类">Channel类</h4><p>Channel类主要是对描述符<code>fd</code>和感兴趣的事件<code>events</code>封装，一个Channel只属于一个EventLoop。</p><blockquote><p><strong>为啥Channel_类析构函数为空？似乎将所封装的fd移除注册的事件 &amp; 移除channelMap比较好</strong>？</p><p>这部分代码放到EventLoop 和 Accpetor析构函数，可能是因为：①一个Channel属于一个EventLoop；②Channel的析构动作由其所属的Reactor负责比较好？保证先析构Channel？</p></blockquote><table><thead><tr><th>Channel类成员</th><th>Channel类构造函数</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/classChannel__inherit__graph.png" alt="classChannel__inherit__graph"></td><td><img src="https:/blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230307151436660.png" alt="image-20230307151436660"></td></tr></tbody></table><p>理解Channel类，关键在于理解：</p><ol><li>Channel类回调函数是如何被注册的？什么时候执行？第1个问题再TcpConnection类中已介绍。</li><li><code>tie_</code> &amp; <code>tied</code> 字段作用？第2个问题在EventLoop类中也已介绍。</li></ol><p>因此，这里不再赘述。</p><h3 id="1-3-2-Main-Reactor：Acceptor、EventThreadPool">1.3.2 Main Reactor：Acceptor、EventThreadPool</h3><h4 id="Acceptor类">Acceptor类</h4><p>在前面，我们已大致清楚Acceptor职能：</p><ol><li>封装listenfd：初始化时会创建<code>acceptChannel_</code>封装listenfd；</li><li>处理&amp;分配新连接：通过<code>acceptChannel_</code>的<u>读</u>回调（具体是<code>Acceptor::handleRead</code>函数）。</li></ol><p>显然，Acceptor最重要的就是<code>Acceptor::handleRead</code> 方法。</p><h5 id="构造函数和析构函数">构造函数和析构函数</h5><table><thead><tr><th>Acceptor类成员</th><th>Acceptor类构造&amp;析构函数</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230307115631615.png" alt="image-20230307115631615"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230307120146153.png" alt="image-20230307120146153"></td></tr></tbody></table><ul><li><p><strong>构造函数</strong></p><p>主要就做了两件事：</p><ol><li>创建listenfd–&gt;bind() --&gt; acceptChannel封装listenfd；</li><li><strong>设置了acceptChannel的<u>读</u>回调 <code>Acceptor::handleRead</code></strong>  。</li></ol></li><li><p><strong>析构函数</strong></p><p>类似Sub-Reactor（sub loop）会将其绑定的<code>wakeupChannel_</code>：</p><ol><li>感兴趣的事件移除；</li><li>从chanenlMap上移除。</li></ol><p>Accpetor其绑定的<code>acceptChanne_</code>也做了上述处理。</p></li></ul><h5 id="Acceptor-handleRead-函数"><code>Acceptor::handleRead</code>  函数</h5><p><code>handleRead</code>进行处理&amp;分配新连接，具体来说：</p><table><thead><tr><th>Acceptor::handleRead</th><th>TcpServer::newConnection</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230307154319197.png" alt="image-20230307154319197"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230307154740008.png" alt="image-20230307154740008"></td></tr></tbody></table><ol><li><p>接受新连接；</p></li><li><p>轮询算法选择一个sub loop；</p></li><li><p>new TcpConnection对象绑定该sub loop；</p></li><li><p>设置TcpConnection的连接、读、写、关闭回调；</p></li><li><p>sub loop执行<u><em><strong>connectEstablished</strong></em></u>回调：①设置<code>tie</code> （深入理解可以参考）②<code>acceptChanne_</code>绑定的listenfd开始listen() ③执行用户自定义连接回调。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setState</span>(kConnected);</span><br><span class="line">    <span class="comment">// 1.防止当channel被手动remove掉 channel还在执行回调操作</span></span><br><span class="line">    <span class="comment">// shared_from_this()==指向对象this指针的有效shared_ptr</span></span><br><span class="line">    channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    <span class="comment">// 2.向poller注册channel的EPOLLIN读事件</span></span><br><span class="line">    channel_-&gt;<span class="built_in">enableReading</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.新连接建立：执行用户自定义的回调</span></span><br><span class="line">    <span class="comment">// TcpConnection::connectionCallback==EchoServer::onConnection</span></span><br><span class="line">    <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>至此，Accpetor核心功能便已经分析完成。</p><h4 id="EventThreadPool类">EventThreadPool类</h4><p>在前面EventThread类介绍中，我们曾简单提过EventThreadPool的职能：</p><blockquote><p>线程池EventThreadPool会创建N个EventLoopThread对象 。</p></blockquote><p>更具体点，EventThreadPool类：</p><ol><li>负责在<code>构造函数</code>，初始化main loop、线程数等字段；</li><li>负责在<code>start()</code>函数，创建N个EventLoopThread对象==&gt;N个EventLoopThread对象对应<u>启动</u>N个<code>thread_</code>==&gt;N个<code>thread_</code>创建对应创建N个EventLoop对象并开启事件循环loop()；</li><li>负责在<code>getNextLoop()</code>实现sub loop的分发（具体调用是在Accpetor）；</li><li>…</li></ol><p>需要重点关注的便是 <code>start()</code>创建线程池对象逻辑 。</p><h5 id="构造函数-析构函数-2">构造函数&amp;析构函数</h5><table><thead><tr><th>EventLoopThreadPool类成员</th><th>EventLoopThreadPool类构造&amp;析构函数</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230306152031494.png" alt="image-20230306152031494"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230307161953501.png" alt="image-20230307161953501"></td></tr></tbody></table><h5 id="start-函数"><code>start()</code> 函数</h5><p>主要流程：</p><ol><li>循环创建N个EventLoopThread对象，保存在<code>threads_</code>，对于这N个对象；</li><li>每个EventLoopThread对象执行<code>startLoop()</code>，并启动底层的<code>thread_</code>线程；</li><li><code>thread_</code>线程， <strong>创建EventLoop对象并启动loop()事件循环</strong> 。</li></ol><p>可见，每个EventLoopThread对象（底层是<code>thread_</code>线程）都会创建一个EventLoop对象。也即是<code> one loop per thread</code>的秘密所在。</p><blockquote><p><code>startLoop()</code>&amp;<code>threadFunc()</code>，在EventLoopThread已详细分析，这里不再赘述。</p></blockquote><table><thead><tr><th>EventThreadPool::start()&amp;startLoop()</th><th>EventLoopThread::threadFunc()</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230307171136801.png" alt="image-20230307171136801"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230306165147863.png" alt="image-20230306165147863"></td></tr><tr><td></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230306164520082.png" alt="image-20230306164520082"></td></tr></tbody></table><p>Muduo的“各个”核心类至此便介绍完成，我们再来“整体”串联整个muduo代码。</p><h1>二、 从三个半事件处理再看Muduo</h1><p>muduo作者chengshuo说过，TCP网络编程最本质的是处理三个半事件：</p><ol><li><strong>连接建立</strong>：包括服务器端被动接受连接（accept）和客户端主动发起连接（connect），TCP连接一旦建立，客户端和服务端就是平等的，可以各自收发数据；</li><li><strong>消息到达</strong>：即文件描述符可读，这是最为重要的一个事件，对它的处理方式决定了网络编程的风格（阻塞还是非阻塞，如何处理分包，应用层的缓冲如何设计等等）；</li><li><strong>消息发送完毕（半个</strong>）：对于低流量的服务，可不必关心这个事件；另外，这里的“发送完毕”是指数据写入操作系统缓冲区（内核缓冲区），将由TCP协议栈负责数据的发送与重传，<u>不代表对方已经接收到数据</u>；</li><li><strong>连接断开</strong>：包括主动断开（close、shutdown）和被动断开（read()返回0）。</li></ol><p>结合muduo代码，我们来深刻的全面理解。</p><h2 id="2-1-连接建立">2.1 连接建立</h2><h3 id="2-1-1-问题引入">2.1.1 问题引入</h3><p><strong>对于Muduo这么一个基于Multi-Reator模型的网络库，连接的建立（或者说创建一个服务器）是如何完成的</strong>？</p><p>在前面tcpserver.cc示例，其实已经做了非常好的示例。但这仅仅是业务层面的调用，底层又是如何完成的？</p><p>其实前面的核心类分析，基本已经揭晓了答案。现在我们将各个“子图块”完整“拼接”起来。</p><h3 id="2-2-2-从“复读机服务器”再看连接建立">2.2.2 从“复读机服务器”再看连接建立</h3><h4 id="EchoServer-TcpServer作用">EchoServer&amp;TcpServer作用</h4><p>EchoServer&amp;TcpServer在tcpserver.cc被使用，这里先简单介绍：</p><ul><li><p><strong>EchoServer</strong>，是用户自定义的类，主要是<strong>封装了TcpServer对象<code>server_</code> &amp; 自定义连接、可读事件回调</strong>；</p></li><li><p><strong>TcpServer</strong>，如前介绍，它主要<strong>封装了Accpetor &amp; EventThreadPool ，是提供给用户的接口类</strong>。如:</p><ul><li>启动服务器<code>start()</code> 方法，启动线程池&amp;创建线程&amp;main loop开启事件循环；</li><li>上述给用户注册自定义回调的<code>TcpServer::setConnectionCallback</code> 、<code>TcpServer::setMessageCallback</code> 等方法。</li></ul><table><thead><tr><th>TcpServer类成员</th><th>TcpServer构造函数</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230307191431104.png" alt="image-20230307191431104"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230307191524707.png" alt="image-20230307191524707"></td></tr></tbody></table></li></ul><h4 id="连接建立流程">连接建立流程</h4><p>回忆一下tcpserver.cc主要逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.用户自定义的loop作为main loop</span></span><br><span class="line">    EventLoop loop;</span><br><span class="line">    <span class="comment">// 2. 对socket编程中的sockaddr_in进行封装</span></span><br><span class="line">    <span class="function">InetAddress <span class="title">addr</span><span class="params">(<span class="number">8002</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 3.EchoServer初始化</span></span><br><span class="line">    <span class="function">EchoServer <span class="title">server</span><span class="params">(&amp;loop, addr, <span class="string">&quot;EchoServer&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 4.启动服务器server</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">// 5.开启main loop事件循环：epoll_wait等待listenfd的accpet连接事件</span></span><br><span class="line">    loop.<span class="built_in">loop</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>用户自定义main loop</strong>，用于和后面Accpetor对象绑定；</p></li><li><p><strong>封装要监听的ip&amp;port</strong>，使用InetAddress封装；</p></li><li><p><strong>EchoServer初始化</strong>，主要完成：</p><ul><li><p>loop_字段绑定前面创建的main loop；</p></li><li><p><strong>TcpServer对象server_初始化</strong>，参考上图TcpServer构造函数：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230307193308123.png" alt="image-20230307193308123"></p><ul><li>loop_字段EchoServer传过来的main loop；</li><li><strong>Acceptor对象accpetor_初始化</strong>；</li><li><strong>EventThreadPool对象threadpoll_初始化</strong>；</li><li><strong>设置accpetor_新连接时的回调函数（即<code>TcpServer::newConnnection</code>，是<code>Accepetor::handleRead</code>函数核心逻辑</strong>）。</li></ul></li></ul></li><li><p><strong>启动服务器server</strong>，真正调用的是<code>TcpServer::start()</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (started_++ == <span class="number">0</span>)    <span class="comment">// 防止一个TcpServer对象被start多次</span></span><br><span class="line">    &#123;</span><br><span class="line">        threadPool_-&gt;<span class="built_in">start</span>(threadInitCallback_);    <span class="comment">// 启动底层的loop线程池</span></span><br><span class="line">        <span class="comment">// main_loop 执行Acceptor::listen</span></span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::listen, acceptor_.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>线程池启动</strong>，即前所述的EventThreadPool::start()函数 ：</p><ol><li>循环创建N个EventLoopThread对象，保存在<code>threads_</code>，对于这N个对象：</li><li>每个EventLoopThread对象执行startLoop()，并启动底层的<code>thread_</code>线程；</li><li><code>thread_</code>线程， <strong>创建sub loop并启动loop()事件循环，监听clientfd的io事件</strong> 。</li></ol><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230307194100456.png" alt="image-20230307194100456"></p></li><li><p><strong>main loop的listenfd开始<code>listen() </code>&amp; 注册到epoll</strong>，listenfd开启listen() ，并在<em>enableReading()</em> 函数中将listenfd的io事件注册到epoll。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::listen, acceptor_.<span class="built_in">get</span>()));</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listenning_ = <span class="literal">true</span>;</span><br><span class="line">    acceptSocket_.<span class="built_in">listen</span>();         <span class="comment">// listen</span></span><br><span class="line">    acceptChannel_.<span class="built_in">enableReading</span>(); <span class="comment">// acceptChannel_绑定fd并注册至mian loop的底层epoll</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>main loop启动事件循环</strong>，epoll_wait<strong>监听listenfd的accpet连接事件</strong> 。</p></li></ol><h2 id="2-2-连接断开">2.2 连接断开</h2><h3 id="2-2-1-问题引入">2.2.1 问题引入</h3><p>在处理连接断开，我们必然要面对这么两个灵魂发问：</p><ul><li><strong>如果是被动关闭连接：服务端如何感知，应该处理哪些逻辑</strong>？</li><li><strong>如果是主动关闭连接：如何保证对方已经收到全部数据</strong>？<strong>直接close(fd)肯定是不行的</strong>。因为应用层往往有缓冲（这在非阻塞网络编程中是必需的），我们需要保证先发送完缓冲区中的数据，然后再断开连接。</li></ul><h3 id="2-2-2-被动关闭连接">2.2.2 被动关闭连接</h3><h4 id="如何感知？"><strong>如何感知</strong>？</h4><p>在muduo中：</p><ul><li>服务端<code>TcpConnection::handleRead()</code>中，内部调用了Linux的函数<code>readv()</code>；</li><li>当<code>readv()</code>返回0的时候，服务端就知道客户端断开连接了。</li></ul><h4 id="如何处理？">如何处理？</h4><p>当<code>readv()</code>返回0 ，会紧接着调用<code>TcpConnection::handleClose()</code>，一图明白后续调用链：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/v2-f50b4f7e23b79110f453146163cb000c_r.jpg" alt="img"></p><ol><li><strong>将TcpConnection的channel_从Poller取消监听</strong>，因为一个TcpConnection对应一个Channel，连接关闭了首要是将channel_从Sub-EventLoop的epoll取消监听；</li><li><strong>执行用户自定义的connectCallback_回调</strong>；</li><li><strong>在TcpServer::connections_移除当前TcpConnection对象</strong>，由于<code>connections_</code>（一个unordered_map，负责保存<code>&lt;KEY:connName,VALUE:TcpConnection&gt;</code> 的映射）在TcpServer中定义（主线程），所以这里会跳转到main loop去执行；</li><li><strong>最后将TcpConnection::channel_从底层Poller::chanenlMap移除</strong>，chanenlMap保存<code>&lt;KEY:sockfd,VALUE:Channel&gt;</code> 映射。</li></ol><h3 id="2-2-3-主动关闭连接">2.2.3 主动关闭连接</h3><h4 id="如何实现优雅关闭？">如何实现优雅关闭？</h4><p>在“复读机”服务器示例中，“复读”完可以主动调用<code>shutdown()</code> 关闭连接。这是一种“优雅关闭”，保证主动关闭时正在发生的数据可以全部发生完：</p><ol><li><p><strong>如果要主动关闭连接，先关本地“写”端</strong></p><p>这样muduo会发送 TCP FIN 分节，对方会读到 0 字节。<strong>注意此时muduo不是调用<code>close(fd)</code>，所以不是完全关闭</strong>。</p></li><li><p><strong>等对方关闭之后，再关本地“读”端</strong></p><ul><li>一般来说，对方通常会关闭连接，这样 muduo 会read到 0 字节，然后 muduo 调用<code>TcpConnection::handleClose()</code>取消监听&amp;移除<code>channel_</code>&amp;<code>connections_</code>移除当前TcpConnection对象，不再接收客户端数据，即关闭了“读端”；</li><li><strong>不过这种做法有风险</strong>：万一对方故意不不关，那么 muduo 的连接就一直半开着，消耗系统资源。</li></ul></li></ol><p>完整的代码实现：</p><table><thead><tr><th>用户自定义回调</th><th>shutdown()实现</th></tr></thead><tbody><tr><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230310222330841.png" alt="image-20230310222330841"></td><td><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20230310222254290.png" alt="image-20230310222254290"></td></tr></tbody></table><p>但是，截止目前依旧疑云重重：</p><h5 id="什么时候muduo才会真正的close-fd-关闭连接？"><strong>什么时候muduo才会真正的close(fd)关闭连接</strong>？</h5><p>答案是：<strong>在 TcpConnection 对象析构的时候</strong>。TcpConnection 不再持有一个 Socket 对象（<code>sockfd_</code>），Socket 是一个 RAII handler，它的析构函数会 <code>close(sockfd_)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpConnection</span> :</span> noncopyable, <span class="keyword">public</span> std::enable_shared_from_this&lt;TcpConnection&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::unique_ptr&lt;Socket&gt; socket_;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Socket::~<span class="built_in">Socket</span>()</span><br><span class="line">&#123;</span><br><span class="line">    ::<span class="built_in">close</span>(sockfd_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="那什么时候会触发TcpConnection-对象析构？"><strong>那什么时候会触发TcpConnection 对象析构</strong>？</h5><p>我们知道，每个TcpConnection 对象引用计数至少为2，有新连接时执行<code>TcpServer::newConnection</code>：</p><ol><li>创建TcpConnection 对象指针<code>conn</code>时， 该<code>conn</code> 持有对象；</li><li><code>TcpServer::connections_</code> 持有所有TcpConnection 对象。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> InetAddress &amp;peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// conn持有</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            sockfd,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            peerAddr))</span></span>;</span><br><span class="line">    <span class="comment">// connections_持有</span></span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键在于让<code>connections_</code> 释放持有的TcpConnection 对象，从而触发TcpConnection 对象析构==&gt; Socket 对象对象析构。</p><h5 id="connections-在什么时候会释放持有的TcpConnection-对象？"><strong><code>connections_</code> 在什么时候会释放持有的TcpConnection 对象</strong>？</h5><p>答案是在触发<code>TcpServer::removeConnection</code> 时。<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com//image-20230310233220594.png" alt="image-20230310233220594"></p><p>而removeConnection函数：</p><ol><li><code>shutdown()</code>  ，关闭写端，底层响应EPOLLHUP，会触发<code>TcpConnection::handleClose()</code>，进而触发removeConnection函数。</li><li>read到0，也会触发<code>TcpConnection::handleClose()</code>函数。</li></ol><p>如果 TcpConnection 的引用计数降到零，它就会析构了。</p><p>当<u>服务器主动关闭</u>时，调用<code>TcpServer::~TcpServer()</code>析构函数，也会<strong>析构所有TcpConnection对象</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TcpServer::~<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//connections类型为std::unordered_map&lt;std::string, TcpConnectionPtr&gt;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;item : connections_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(item.second)</span></span>;</span><br><span class="line">        <span class="comment">// 释放掉TcpServer中（item.second）保存的该TcpConnectino对象的智能指针</span></span><br><span class="line">        <span class="comment">// 此时，只剩下conn还持有这个TcpConnection对象，因此当前TcpConnection对象还不会被析构</span></span><br><span class="line">        item.second.<span class="built_in">reset</span>(); </span><br><span class="line">        conn-&gt;<span class="built_in">getLoop</span>()-&gt;<span class="built_in">runInLoop</span>(<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TcpConnection::connectDestroyed</code> 即将所管理的channel_在chanenlMap移除。</p><h5 id="疑问">疑问</h5><blockquote><p><strong>为什么这里不执行<code>disableAll()</code> ? 不先取消事件监听</strong>？</p><p>观察到，相比<code>~Accpetor()</code>析构<code>wakeupChannel_ </code>还是前面<code>被动关闭连接</code>析构<code>channel_</code> 还会先执行<code>disableAll()</code>，将channel_从sub EventLoop的epoll取消监听。</p></blockquote><h4 id="如何保证主动关闭时正在发生的数据可以全部发生完？">如何保证主动关闭时正在发生的数据可以全部发生完？</h4><p>我们需要<code>tie</code>：保证<strong>先让Channel回调函数先把数据发送完，再释放TcpConnection对象的资源</strong>。</p><p>参考前：1.3.1其中小节—<code>tie</code>深入理解。</p><h2 id="2-3-消息到达">2.3 消息到达</h2><h3 id="2-3-1-问题引入">2.3.1 问题引入</h3><h4 id="为什么要应用层接收缓冲区？">为什么要应用层接收缓冲区？</h4><p>消息到达是最重要的事件，对它的处理决定了网络编程的风格：①是阻塞还是非阻塞；②分包的处理；③应用层的缓冲如何设计等等。</p><p><strong>在非阻塞网络编程中，为什么要使用应用层接收缓冲区</strong>？</p><p>假如一次读到的数据不够<u>一个完整的数据包</u>，也就是<strong>需要分包去区分一个个消息</strong>：已经读到的数据应该先暂存在某个地方，等剩余的数据收到之后再一并处理；</p><blockquote><p>常见的分包方法有：</p><ol><li>固定长度；</li><li>特殊的结尾符，比如字符串的\0，或者回车换行等；</li><li>固定的消息头中指定后续的消息的长度，然后跟上一个消息体内容；</li><li>使用协议本身的格式，比如json格式头尾配对（XML也一样）。</li></ol></blockquote><p>但是：<strong>从系统内核中调用的时候，在应用层需要有足够大的缓冲区，最好能一次将系统recv到的缓冲区给读空，但这可能是不行的；每次针对每个连接一次都分配较大的缓冲区，又会浪费严重</strong>。</p><p>该如何处理？</p><h3 id="2-3-2-muduo是如何做的？TcpConnection-handleRead">2.3.2 muduo是如何做的？TcpConnection::handleRead</h3><p>TcpConnection::handleRead的核心函数便是Buffer::readFd。</p><blockquote><p><code>Buffer</code>已经是老熟人了：</p><ul><li><strong>底层数据结构</strong>：使用的是<code>vector::buffer_</code>，可以动态增长 ；</li><li><strong>核心函数</strong>：<code>Buffer_.readFd(channel_-&gt;fd(), &amp;saveErrno)</code> 。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(), &amp;savedErrno);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) <span class="comment">// 有数据到达</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 已建立连接的用户有可读事件发生了 调用用户传入的回调操作onMessage shared_from_this就是获取了TcpConnection的智能指针</span></span><br><span class="line">        <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="comment">// 客户端断开</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">handleClose</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 出错了</span></span><br><span class="line">    &#123;</span><br><span class="line">        errno = savedErrno;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleRead&quot;</span>);</span><br><span class="line">        <span class="built_in">handleError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>readFd关键设计</strong>：</p><ol><li>设计两个缓冲区vec[2]，vec[1]<strong>指向Buffer底层的<code>buffer_</code></strong>，vec[2]预分<strong>64K临时空间<code>extrabuf</code></strong>；</li><li>readv的时候，如果第一个缓冲区&lt;=64k就使用两个缓冲区，否则就只使用第一个缓冲区（一般不会超过64K，tcp buffer如果确实要设置大的缓存区，需要调整系统参数），<strong>这样一次读取就足以将socket中的缓存区读空</strong>；</li><li>开始readv，将socket上数据读到两个缓冲区；</li><li>如果第一个缓冲区已满，<code>buffer_</code> 扩容，将第二个缓冲区数据append到第一个缓冲区；</li></ol><p>这样：既①保证一次就可以读完socket ；②也避免预申请过大的<code>buffer_</code>。</p><p>具体实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从fd上读取数据，Poller工作在LT模式</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Buffer::readFd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> *saveErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 栈额外空间，用于从套接字往出读时，当buffer_暂时不够用时暂存数据，待buffer_重新分配足够空间后，在把数据交换给buffer_。</span></span><br><span class="line">    <span class="keyword">char</span> extrabuf[<span class="number">65536</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 栈上内存空间 65536/1024 = 64KB</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    struct iovec &#123;</span></span><br><span class="line"><span class="comment">        ptr_t iov_base; // iov_base指向的缓冲区存放的是readv所接收的数据或是writev将要发送的数据</span></span><br><span class="line"><span class="comment">        size_t iov_len; // iov_len在各种情况下分别确定了接收的最大长度以及实际写入的长度</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用iovec分配两个连续的缓冲区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">vec</span>[2];</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> writable = <span class="built_in">writableBytes</span>(); <span class="comment">// 这是Buffer底层缓冲区剩余的可写空间大小 不一定能完全存储从fd读出的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一块缓冲区，指向可写空间</span></span><br><span class="line">    vec[<span class="number">0</span>].iov_base = <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = writable;</span><br><span class="line">    <span class="comment">// 第二块缓冲区，指向栈空间</span></span><br><span class="line">    vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="built_in"><span class="keyword">sizeof</span></span>(extrabuf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里之所以说最多128k-1字节，是因为若writable为64k-1，那么需要两个缓冲区 第一个64k-1 第二个64k 所以做多128k-1</span></span><br><span class="line">    <span class="comment">// 如果第一个缓冲区&gt;=64k 那就只采用一个缓冲区 而不使用栈空间extrabuf[65536]的内容</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> iovcnt = (writable &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(extrabuf)) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ssize_t</span> n = ::<span class="built_in">readv</span>(fd, vec, iovcnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= writable) <span class="comment">// Buffer的可写缓冲区已经够存储读出来的数据了</span></span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// extrabuf里面也写入了n-writable长度的数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ = buffer_.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">append</span>(extrabuf, n - writable); <span class="comment">// 对buffer_扩容 并将extrabuf存储的另一部分数据追加至buffer_</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-消息发送">2.4 消息发送</h2><h3 id="2-4-1-问题引入">2.4.1 问题引入</h3><h4 id="为什么要应用层发送缓冲区？">为什么要应用层发送缓冲区？</h4><ul><li><strong>TCP发送缓冲区空间不足</strong>：TCP发送缓冲区会出现不足；</li><li><strong>应用层接收慢</strong>：发送数据时，应用层写的快而内核发送数据慢，需要把待发送数据写入缓冲区。</li></ul><h4 id="TCP发送缓冲区不足如何处理">TCP发送缓冲区不足如何处理?</h4><p>假设应用程序需要发送40kB 数据，但是操作系统的 TCP 发送缓冲区只有 25kB 剩余空间，那么剩下的 15kB数据怎么办？</p><ul><li><p><strong>如果等待 OS 缓冲区可用，会阻塞当前线程</strong>，所以我们需要一个发送缓冲区。</p></li><li><p><strong>但是，如果应用程序随后又要发送 50kB 数据，不能立刻尝试 write() ，这样有可能打乱数据的顺序</strong>。如果发送缓冲区不为空，应该先write到发送缓冲区。</p><p>这也是muduo的做法。</p></li></ul><h3 id="2-4-2-muduo是如何做的：TcpConnetion-send">2.4.2 muduo是如何做的：TcpConnetion::send</h3><p>在muduo中，当用户调用了<code>TcpConnetion::send(buf)</code>函数时：</p><ul><li><strong>如果发送缓冲区没有待发送数据</strong>：<ul><li><strong>如果TCP发送缓冲区能一次性容纳buf</strong>，调用用户自定义的<code>writeCompleteCallback_</code> 来移除该TcpConnection在事件监听器上的可写事件（因为大多数时候是没有数据需要发送的，频繁触发可写事件但又没有数据可写）；</li><li><strong>如果TCP发送缓冲区不能一次性容纳buf</strong>，判断一下errno是不是SIGPIPE RESET等致命错误。</li></ul></li><li><strong>如果发送缓冲区没有待发送数据 &amp;&amp; 非致命错误</strong>：<ul><li>判断是否是高水位，执行回调<code>highWaterMarkCallback_</code> ；</li><li>不直接write，先将数据append到发送缓冲区（如果缓冲区不足会执行<code>makeSpace</code>扩容）；</li><li>注册当前<code>channel_</code>的写事件，通知epoll监听处理。</li></ul></li></ul><p>完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送数据 应用写的快 而内核发送数据慢 需要把待发送数据写入缓冲区，而且设置了水位回调</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwrote = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> remaining = len;</span><br><span class="line">    <span class="keyword">bool</span> faultError = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state_ == kDisconnected) <span class="comment">// 之前调用过该connection的shutdown 不能再进行发送了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;disconnected, give up writing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示channel_第一次开始写数据或者缓冲区没有待发送数据</span></span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>() &amp;&amp; outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nwrote = ::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(), data, len);</span><br><span class="line">        <span class="keyword">if</span> (nwrote &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            remaining = len - nwrote;</span><br><span class="line">            <span class="keyword">if</span> (remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 既然在这里数据全部发送完成，就不用再给channel设置epollout事件了</span></span><br><span class="line">                loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                    std::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// nwrote &lt; 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            nwrote = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK) <span class="comment">// EWOULDBLOCK表示非阻塞情况下没有数据后的正常返回 等同于EAGAIN</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::sendInLoop&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (errno == EPIPE || errno == ECONNRESET) <span class="comment">// SIGPIPE RESET</span></span><br><span class="line">                &#123;</span><br><span class="line">                    faultError = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 说明当前这一次write并没有把数据全部发送出去 剩余的数据需要保存到缓冲区当中</span></span><br><span class="line"><span class="comment">     * 然后给channel注册EPOLLOUT事件，Poller发现tcp的发送缓冲区有空间后会通知</span></span><br><span class="line"><span class="comment">     * 相应的sock-&gt;channel，调用channel对应注册的writeCallback_回调方法，</span></span><br><span class="line"><span class="comment">     * channel的writeCallback_实际上就是TcpConnection设置的handleWrite回调，</span></span><br><span class="line"><span class="comment">     * 把发送缓冲区outputBuffer_的内容全部发送完成</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 目前发送缓冲区剩余的待发送的数据的长度</span></span><br><span class="line">        <span class="keyword">size_t</span> oldLen = outputBuffer_.<span class="built_in">readableBytes</span>();</span><br><span class="line">        <span class="keyword">if</span> (oldLen + remaining &gt;= highWaterMark_ &amp;&amp; oldLen &lt; highWaterMark_ &amp;&amp; highWaterMarkCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                std::<span class="built_in">bind</span>(highWaterMarkCallback_, <span class="built_in">shared_from_this</span>(), oldLen + remaining));</span><br><span class="line">        &#125;</span><br><span class="line">        outputBuffer_.<span class="built_in">append</span>((<span class="keyword">char</span> *)data + nwrote, remaining);</span><br><span class="line">        <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            channel_-&gt;<span class="built_in">enableWriting</span>(); <span class="comment">// 这里一定要注册channel的写事件 否则poller不会给channel通知epollout</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-其它：LT与ET">2.5  其它：LT与ET</h2><p>细心的读者已经注意到，Muduo使用的是LT（Lever Trigger，边缘触发，默认模式）而非是ET（Edge Trigger，边缘触发）。</p><ul><li>为什么muduo使用ET？不是说ET更快吗？</li><li>LT什么时候关注 EPOLLOUT 事件？会造成 busy-loop吗？muduo是怎么做的？</li><li>如果使用ET，如何防止漏读造成的饥饿？</li></ul><h3 id="2-5-1-LT与ET介绍">2.5.1 LT与ET介绍</h3><p>要讲明白这个问题，我们先来复习LT与ET基本概念和触发条件。</p><h4 id="LT与ET触发条件">LT与ET触发条件</h4><p>LT与ET两种模式本质区别：</p><ul><li>对于水平触发模式LT，一个事件只要有就会一直触发；</li><li>对于边缘触发模式ET，只有一个事件从无到有才会触发。</li></ul><p>具体到读、写事件：</p><table><thead><tr><th></th><th>读事件触发条件</th><th>写事件触发条件</th></tr></thead><tbody><tr><td>LT</td><td>socket有数据（就一直触发）</td><td>socket可写（就一直触发）</td></tr><tr><td>ET</td><td>socket有<strong>新</strong>数据到来</td><td>socket不可写 =&gt; socket可写</td></tr></tbody></table><p>这决定LT、ET在编程上对于读、写事件的不同处理。</p><h4 id="LT与ET编程">LT与ET编程</h4><p>对于一个非阻塞 socket：</p><table><thead><tr><th></th><th>读事件处理</th><th>写事件处理</th></tr></thead><tbody><tr><td>LT</td><td>根据业务自行决定recv多少数据，尽量多读点防止<strong>busy-loop</strong></td><td><strong>必须</strong>：不需要写事件EPOLLOUT一定要及时移除，避免<strong>busy-loop</strong></td></tr><tr><td>ET</td><td><strong>必须</strong>：循环recv到错误码<code>EWOULDBLOCK</code>/<code>EAGAIN</code>，<strong>防止漏读</strong></td><td>根据业务自行决定下次是否触发</td></tr></tbody></table><p>所在，对于LT模式，最要紧的就是防止busy-loop：</p><ol><li><strong>对于可读事件busy-loop</strong>：muduo有接收缓冲区+recv(2)策略，能保证数据能被尽量一次读完；</li><li><strong>对于可写事件busy-loop</strong>：在muduo的<code>TcpConnetion::send(buf)</code>函数时，<strong>如果能一次发送完</strong>，会马上调用<code>writeCompleteCallback_</code> 回调函数，<strong>移除可写事件监听</strong>；如果不能发完，可以先放到发送缓冲区。</li></ol><h3 id="2-5-2-muduo为什么使用ET？">2.5.2 muduo为什么使用ET？</h3><p>muduo使用是LT而非ET，主要原因：</p><ol><li>LT读的时候只需要一次系统调用，而ET必须循环read到EAGAIN错误逻辑处理更复杂；</li><li>muduo有应用层缓冲区，对于可读/可写事件的busy-loop，可以进行很好的避免。</li></ol><p>而且：<strong>ET不一定比LT快</strong> 。</p><p>ET模式下用户要自行进行 read/write 循环处理，这其中<u>增加的read/write系统调用</u>和<u>减少的epoll 系统调用</u>相比，综合收益其实不大。为了降低处理逻辑复杂度，常用的事件处理库大部分都选择了LT 模式（如 libevent、boost::asio、muduo等）。</p><h1>三、总结与展望</h1><h3 id="3-1-本文总结">3.1 本文总结</h3><p>本文主要介绍了以下内容：</p><ol><li><p>高并发IO网络模型介绍，从最简单的单线程网络IO模型==&gt;Reactor模式==&gt;Muduo网络框架介绍；</p></li><li><p>Muduo各个核心类的介绍，尤其是对<code>loop()</code> 、<code>tie</code>等重难点进行了介绍；</p></li><li><p>结合muduo源码，来分析“三个半事件”的每个事件的关键处理，如：muduo连接建立全流程、被动关闭如何感知/处理、主动优雅关闭、消息到达使用缓冲区+recv(2)处理分包、消息发送使用缓冲区处理应用层接收慢或TCP发送缓冲区不足等；</p></li><li><p>muduo为何使用LT等。</p></li></ol><p>总的来说尽量考虑了整体联系和细节丰满。</p><h3 id="3-2-未来展望">3.2 未来展望</h3><p>本文陆陆续续在半个月落笔完成，中间修修改改多次。在成文的过程中，也学习、巩固到不少网络编程知识。对于网络编程入门来说，muduo的确是个不错的参考。</p><p>但限于自身水平，自己对muduo中一些设计细节还是存在些疑问。比如，muduo代码大量使用了智能指针和RAII管理对象的生命周期，但对于TcpConnection/Eventloop/Socket/…各个对象在连接关闭/整个服务器关闭/…等各种情况核心设计处理理念，目前依旧存在些疑惑。这个，留到后面再来补全吧！</p><p>最后，如果本文能给学习网络编程or研究muduo库的同学带来帮助，那就再好不过了。欢迎在下留言交流。</p><h1>四、更新记录</h1><div class="timeline"><div class="timenode"><div class="meta"><p><p>2023-03-11：更新</p></p></div><div class="body"><ol><li>修正一些排版bug；</li><li>更新1.2节传统IO性能改进相关描述。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2023-03-10：第一次更新</p></p></div><div class="body"><ol><li>第一次更新上传。</li></ol></div></div></div><h1>五、参考文献</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">陈硕.《Linux多线程服务端编程》<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">万字长文梳理Muduo库核心代码及优秀编程细节思想剖析：https://zhuanlan.zhihu.com/p/495016351<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Muduo 源码分析：https://youjiali1995.github.io/network/muduo/<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">IO - Netty的模型：https://www.cnblogs.com/hlkawa/p/15303013.html<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">【muduo】net篇---TcpConnection：https://blog.csdn.net/daaikuaichuan/article/details/87822822<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">高并发之网络IO模型  https://www.cnblogs.com/xiekun/p/16593204.html<a href="#fnref:6" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 教程 </tag>
            
            <tag> muduo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++从零开始（十二）：Linux系统编程入门</title>
      <link href="/p/45495/"/>
      <url>/p/45495/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，毕业论文初稿写完三个月过去，终于又开始更新了…🥗</p></blockquote><div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div><p>Linux系统编程作为《C++从零开始》三部曲之一，自有其极其重要的地位。</p><p>如果将Linux比作为一台性能出众的跑车，我们一定不会只满足于驾驶它上下班，只会挂挡、踩油门和控制方向之类的基本操作。我们想要更加了解它，挖掘更多的潜能。</p><p>学习系统编程便是让你做到这一点。</p><p>Linux系统内容纷繁复杂，在学习过程中<a href="https://m.douban.com/book/subject/25809330/">《Linux系统编程手册》</a>使我受益良多。在本部曲中，我将尽量用简洁的语言进行总结和扩展。</p><p>好了，轻松一点，让我们先从Linux的前身——UNIX历史说起吧。</p><h1>UNIX历史</h1><h2 id="UNIX和C简史">UNIX和C简史</h2><ol><li><strong>1969年</strong>，<u>bell实验室</u>（隶属AT&amp;T电话公司），<u>Ken Thompson</u>，开发出了<strong>首个 UNIX 系统</strong>。<ul><li>UNIX 是MULTICS（多信息及计算服务，Multiplexed Information and Computing Service）一词的双关语。</li></ul></li><li><strong>1970年</strong>，<u>AT&amp;T 的工程师</u>，在Digital PDP-11 小型机以汇编语言重写了UNIX。</li><li><strong>1971年</strong>，Thompson 在 bell 实验室的同事，<u>Dennis Ritchie</u>设计<strong>实现了C语言</strong>。<ul><li>C 语言由于其高效、灵活、功能丰富、表达力强和较好的可移植性等特点，迅速风靡起来。</li></ul></li><li><strong>1973 年</strong>，UNIX 已经被移植到了 PDP-11 小型机上，并以 <strong>C 语言对UNIX进行了重写</strong>。</li><li><strong>1977年</strong>，因为法律禁止 AT&amp;T销售 UNIX，AT&amp;T公司<strong>允许高校使用UNIX</strong>，极大促进了UNIX的发展。第七版 UNIX 发布的重要意义还在于，从该版本起，UNIX 分裂为了两大分支：BSD 和 System V。</li><li><strong>1979年</strong>，伯克利发布首个完整的，属于自己 <strong>UNIX 发布版 3BSD</strong>（伯克利软件发布，Berkeley Software Distribution）诞生。<ul><li>在此期间，随着 AT&amp;T 不再对电信市场形成垄断，该公司被获准销售 UNIX。这也就催生出了另一种 UNIX 的变种—System V，日后，它也成为了某些商业 UNIX 实现的基石。</li></ul></li><li><strong>1983 年</strong>，加州大学伯克利分校的计算机系统研究组（Computer Systems Research Group）<strong>发布了 4.2BSD</strong>。<ul><li><u>该版本的发布意义深远</u>，因为其包含了完整的 TCP/IP 实现，其中包括套接字应用编程接口（API）以及各种网络工具。</li></ul></li></ol><h2 id="Linux简史">Linux简史</h2><p>在当时UNIX时代，计算机软件的消费者不但无权阅读自己所购软件的源码，而且还不能复制、更改及重新发行所购软件。Stallman认为，这只会造成程序员之间勾心斗角、敝帚自珍的局面，无法实现工作协同和成果共享。</p><ol><li><strong>1984年</strong>，MIT 的程序员<u>Richard Stallman</u>，<strong>发起了 GNU 项目</strong>（“GNU’s not UNIX”的递归缩写形式）。<ul><li>GNU 项目由此制定了 <strong>GNU GPL协议</strong>：以 GPL 许可协议发布的软件不但必须开放源码，而且应能在 GPL 条款的约束下自由对其进行重新发布。可以不受限制的修改以 GPL 许可协议发布的软件，但任何经修改后发布的软件仍需遵守 GPL 条款；</li><li>GNU 项目还开发出了<strong>Emacs 文本编辑器</strong>、<strong>GCC</strong>、<strong>bash shell</strong> 以及 <strong>glibc</strong>（GNU C 语言库），<u>只要再拥有一个能够有效运作的内核，就能使 GNU 项目开发出的UNIX 系统“功德圆满”</u>。</li></ul></li><li><strong>1991</strong> 年，<u>Linus Torvalds</u>，<strong>开发出UNIX内核</strong>“雏形”，可以编译并运行各种 GNU 程序。<ul><li>为了传承 UNIX 历史悠久的光荣传统，总以字母“X”结尾，人们最终将这一内核命名为 Linux。</li></ul></li></ol><p>应 Torvalds 之邀，许多其他程序员也加入到了改进内核的行列中。随着时光的流逝，在一干程序员的不懈努力下，Linux 逐渐发展壮大，并被移植到了多种硬件架构之上。</p><h2 id="标准化过程">标准化过程</h2><p>20 世纪 80 年代末，UNIX 和 C 语言的实现“百花齐放”，所引发的可移植性问题迫使人们开展针对以上两者的标准化工作。</p><p>C 语言和 UNIX 系统的标准化进程也显得愈发重要。</p><h3 id="C标准">C标准</h3><p>C 语言标准独立于任何操作系统，换言之，C 语言并不依附于 UNIX 系统。</p><ol><li><strong>1989 年</strong>，美国国家标准委员会ANSI的<strong>C 语言标准（C89标准）获批</strong>。<ul><li>这份标准在定义 C 语言语法和语义的同时，还对标准 C 语言库操作进行了描述，这包括 stdio 函数、字符串处理函数、数学函数、各种头文件等等。</li></ul></li><li><strong>随之于 1990 年</strong>，<strong>C89标准被国际标准化组织ISO采纳</strong>；</li><li><strong>1999年</strong>，<u>ISO</u> 对 C 语言标准的修订版，<strong>C99标准正式被批准</strong>。<ul><li>对 C 语言及其标准库的一系列修改，诸如，增加了 long long 和布尔数据类型、C++风格的注释（//）、受限指针以及可变长数组等。</li></ul></li></ol><h3 id="操作系统接口">操作系统接口</h3><ol><li><strong>1989年</strong>，操作系统标准化的“第一次吃螃蟹”便催生出了 <strong>POSIX.1</strong>。<ul><li>术语“POSIX（可移植操作系统 Portable Operating System Interface 的缩写）”；</li><li>符合 POSIX.1 标准的操作系统应向程序提供调用各项服务的 API，POSIX.1 文档对此作了规范。凡是提供了上述 API 的操作系统都可被认定为符合 POSIX.1 标准。</li></ul></li><li><strong>1988 年和 1990 年</strong>，IEEE 和 ISO 先后将 POSIX.1 采纳为标准。</li><li><strong>2001 年</strong>，<strong>POSIX 1003.1-2001 标准颁布</strong>，取代了 SUSv2、POSIX.1、POSIX.2 以及大批的早期 POSIX 标准。</li><li><strong>2008 年</strong>，人们继续完成对POSIX标准和 SUS 规范的修订，于是，合二为一的<br>POSIX 1003.1-2008 和 SUSv4 标准浮出水面。</li></ol><p>对Linux发展历史有了简单了解后，我们再来了解Linux系统编程的一些基本概念吧。</p><h1>一、基本概念</h1><p>在本章中，主要将介绍Linux&amp;系统编程的基本概念，以期更好地理解后续章节。</p><h2 id="1-1-Linux基本概念">1.1 Linux基本概念</h2><h3 id="1-1-1-操作系统与内核">1.1.1 操作系统与内核</h3><p>操场系统与内核表现为包含关系。</p><ul><li><strong>操作系统</strong>，指完整的软件包，这包括用来<u>管理计算机资源（即CPU、RAM和设备）的核心层软件</u>，以及<u>附带的所有标准软件工具</u>，诸如命令行解释器、图形用户界面、文本编辑器等；</li><li><strong>内核</strong>，则特指管理资源的核心层软件。</li></ul><h4 id="内核有什么用？">内核有什么用？</h4><p>内核所提供的核心层软件，一般执行以下主要任务：</p><ul><li><p><strong>进程调度，即用于控制进程对CPU使用</strong>。</p><p>CPU在一时间段只能执行一个任务，而Linux属于抢占式多任务操作系统，这意味着多个进程（一个运行中的程序我们称之为“进程”）可同时驻留在内存。<u>分配CPU何时给哪些进程使用，以及每个进程能使用多长时间</u>，都需要内核进行进程调度。</p></li><li><p><strong>进程通信，用于多进程之间进行通信</strong>。</p></li><li><p><strong>内存管理，而物理内存（RAM）仍然属于有限资源，内核必须以公平、高效地方式在进程间共享这一资源</strong>。</p><p>Linux通常采用<u>虚拟内存管理机制</u>，它有以下好处：</p><ul><li>内存隔离，进程与进程之间&amp;进程与内核之间隔离。因此一个进程无法读取其它进程或内核的内容。</li><li>只需将进程一部分保存在内存中。不但降低了每个进程对内存的需求量，而且还能在 RAM 中同时加载更多的进程</li></ul></li><li><p><strong>文件系统</strong>，内核在磁盘之上提供了文件系统。</p></li><li><p><strong>IO设备访问</strong>，如键盘、打印机等。</p></li><li><p><strong>网络连接</strong>，内核以用户进程的名义收发网络消息（数据包）。</p></li><li><p><strong>提供系统调用应用编程接口</strong>（API）：进程可利用内核入口点（也称为系统调用）请求内核去执行各种任务。</p></li></ul><p>以上内容每一部分都将后续扩展开来分析探讨。</p><h4 id="内核态和用户态">内核态和用户态</h4><p><strong>CPU 可在用户态和核心态两种不同状态运行，对应地将虚拟内存区域划分（标记）为用户空间部分或内核空间部分</strong>。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/k.jpg" alt="k"></p><ul><li><strong>用户态</strong>，CPU 只能访问被标记为用户空间的内存，无法执行不利于系统运行的操作。</li><li><strong>核心态</strong>，CPU 既能访问用户空间内存，也能访问内核空间内存，也能执行一些核心操作如：执行宕机（halt）指令去关闭系统，访问内存管理硬件等。</li></ul><p>这样做保证了系统的安全和效率。</p><h3 id="1-1-2-shell">1.1.2 shell</h3><p><strong>shell 也称之为命令解释器</strong>，主要用于读取用户输入的命令，并执行相应的程序以响应命令。</p><p>纵观 UNIX 历史，出现过以下几种重要的 shell（按时间顺序）：</p><ol><li><strong>Bourne shell (sh</strong>)，历史最为悠久，由<u>Steve Boume</u>编写。Bourne shell 包含了在其他 shell 中常见的许多特性，I/O 重定向、管道、文件名生成（通配符）、变量、环境变量处理、命令替换、后台命令执行等。</li><li><strong>C shell（csh</strong>），由 <u>Bill Joy</u>编写而成，控制语法与C语言有很多相似之处而因此得名。C shell 与 Bourne shell 并不兼容，且包含一些极为实用的特性，如命令历史记录，命令编辑等。</li><li><strong>Korn shell（ksh</strong>），由<u>David Korn</u> 编写，不但兼容了sh还吸收了csh相关特性。</li><li><strong>Bourne again shell（bash</strong>），这款 shell 是 <u>GNU 项目</u>对 <strong>Bourne shell 的重新实现</strong>，提供了与 C shell 和 Korn shel 所类似的交互式特性。</li></ol><p>不过，<strong>设计 shell 的目的不仅仅是用于人机交互，对 shell 脚本（包含 shell 命令的文本文件）进行解释也是其用途之一</strong>。为实现这一目的，每款 shell 都内置有许多通常与编程语言相关的功能，其中包括变量、循环和条件语句、I/O 命令以及函数等。</p><h3 id="1-1-3-用户和组">1.1.3 用户和组</h3><p><strong>系统会对每个用户的身份做唯一标识，用户可隶属于多个组</strong>。</p><h4 id="用户">用户</h4><p>系统的每个用户都拥有唯一的登录名（用户名）和与之相对应的整数型用户ID（UID）。</p><p>在系统文件<code>/etc/passwd</code> 显示了更具体的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp cpp-learn]<span class="comment"># cat /etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>以上7个字段分别对应：<strong>用户名</strong>:<strong>口令</strong>:<strong>用户标识号</strong>:<strong>组标识号</strong>:<strong>注释性描述</strong>:<strong>主目录</strong>:<strong>登录Shell</strong> 。下面对其中部分字段进行解释：</p><ul><li><p><strong>口令</strong>，一些系统中，存放着加密后的用户口令字，但这存在安全隐患。因此，在Linux使用了shadow技术，使用<code>x</code>或<code>*</code>进行替代，而把真正的加密后的用户口令字存放到<code>/etc/shadow</code>文件中。</p></li><li><p><strong>用户标志号</strong>，即UID，为一个整数，范围为0~65535。0是超级用户root的标识号，1-99由系统保留，作为管理账号，普通用户的标识号从100开始。</p></li><li><p><strong>组标志号</strong>，即GID，记录用户所属的用户组，对应着/etc/group文件中的一条记录。</p></li><li><p><strong>注释性描述</strong>，记录着用户的一些个人情况，但并没有什么实际的用途。</p></li><li><p><strong>主目录</strong>，用户在登录到系统之后所处的目录，各用户对自己的主目录有完整的读（r）、写（w）、执行（x）权限。</p></li><li><p><strong>登陆shell</strong>，用户登录到系统后运行的命令解释器，即shell。</p></li></ul><p>在<code>/etc/passwd</code>我们也注意到，除了我们熟知的root账户，还有一些其它系统账户：bin（拥有可执行的用户命令文件）、sys（拥有系统文件）、adm（拥有帐户文件）。</p><h4 id="组">组</h4><p><strong>出于管理目的，比如为了控制对文件和其他资源的访问</strong>，将多个用户分组是非常实用的做法。</p><p>每个用户组都对应着系统组文件<code>/etc/group</code> 中的一行记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp cpp-learn]<span class="comment"># cat /etc/group</span></span><br><span class="line">root:x:0:</span><br><span class="line">bin:x:1:</span><br><span class="line">daemon:x:2:</span><br><span class="line">sys:x:3:</span><br></pre></td></tr></table></figure><p>以上4个字段分别对应， <strong>组名:口令:组标识号:组内用户列表</strong>。</p><ul><li>其中组内用户列表，是属于这个组的所有用户的列表，不同用户之间用逗号<code>,</code>分隔。</li></ul><h3 id="1-1-4-目录与文件">1.1.4 目录与文件</h3><h4 id="目录">目录</h4><p>Linux目录具有以下特点：</p><ul><li><p><strong>单根目录结构</strong>，Linux内核维护一套单根目录结构，存放系统所有文件。这和我们熟知Windows系统不同，它的每个磁盘（如C盘）都有各自的目录层级。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220506131811917.png" alt="image-20220506131811917"></p></li><li><p><strong>绝对路径与相对路径</strong>。</p><ul><li><strong>绝对路径以<code>/</code>开始</strong>，如上图中<code>/etc/passwd</code> ；</li><li><strong>相对路径不以<code>/</code>开始</strong>，如上图中，在usr目录下，<code>include/sys/types.h</code> 、<code>../home/mtk/.bashrc</code> 分别可引用文件types.h和.bashrc。</li></ul></li></ul><h4 id="文件">文件</h4><p>Linux文件主要值得关注以下三点：</p><ul><li><p><strong>文件类型</strong>，在Linux文件系统内，“<strong>一切皆为文件</strong>”。这意味着文件类型不仅包含<u>普通文本文件</u>，还包含：设<u>备、管道、套接字、目录、符号链接</u>等。</p></li><li><p><strong>文件名</strong>，文件名最长可达 255 个字符。文件名可以包含除<code>/</code>和空<br>字符（<code>\0</code>）外的所有字符。</p><blockquote><p>此外，还应避免以连字符<code>-</code>作为文件名的起始字符，因为一旦在 shell 命令中使用这种文件名，会被误认为命令行选项开关。</p></blockquote></li><li><p><strong>文件IO模型</strong>，<strong>UNIX 系统 I/O 模型最为显著的特性之一是其 I/O 通用性概念</strong>。</p><p>也就是说，同一套系统调用（open()、read()、write()、close()等）所执行的 I/O 操作，可施之于所有文件类型，包括设备文件。</p><p><strong>另外，值得注意的是，UNIX系统本质只提供<u>字节流文件</u>，因此没有“文件结束符”的概念</strong>。UNIX系统read()如何判断文件结束？读取文件时如无数据返回，便会认定抵达文件末尾。</p></li></ul><h3 id="1-1-5-进程">1.1.5 进程</h3><p><strong>进程是正在执行的程序实例</strong>。</p><p>执行程序时，内核会将程序代码载入虚拟内存，为程序变量分配空间，建立内核记账（bookkeeping）数据结构，以记录与进程有关的各种信息（比如，进程 ID、用户 ID、组 ID 以及终止状态等）。</p><h4 id="进程内存布局">进程内存布局</h4><p>下图展示了一个虚拟进程（程序）内存空间<u>运行时</u>分布布局。高地址的1GB（Windows默认2GB）空间分配给内核，也称为<strong>内核空间</strong>；剩下的3GB分给用户，也称<strong>用户空间</strong>（程序使用的）。</p><p><strong>一个进程本质是由代码段、数据段、堆、栈四部分组成的</strong> 。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/5e8d39d19a216fd03392d36081e70b7e.jpg" alt="你确定你理解内存分配吗？" style="zoom:80%;" /><p>作为程序员，我们更关注的是用户空间中的内容，也就是：</p><ul><li><p><strong>栈（Stack</strong>）：存储代码中调用函数、定义<u><strong>局部</strong>变量</u>(但不包含static修饰的变量)、保存的上下文等；</p><ul><li><p><strong>特点</strong>：存放的数据从<strong>栈顶（低地址</strong>）压入，也是从<strong>栈顶（低地址</strong>）弹出，所以有人说栈是<strong>向下生长</strong>的。函数退出时，所有数据会自动释放内存（出栈）。</p><img src="https://pic1.zhimg.com/v2-4a47248b485bc764430e802f87ee950c_b.webp" alt="img" style="zoom:67%;" /></li></ul></li><li><p><strong>文件映射区域 ：</strong> 栈和堆中间那个空白区域。动态库、共享内存等映射物理空间的内存，一般是 <code>mmap</code> 函数所分配的虚拟地址空间。</p></li><li><p><strong>堆（Heap</strong>）：存储那些生存期<u>与函数调用无关的数据</u>，如动态分配的内存。堆（动态）分配的接口通常有malloc()、calloc()、realloc()、new等。</p><ul><li><strong>特点</strong>：相对于栈，堆是<strong>向上生长</strong>的；堆空间需要主动释放，否则会依然存在。</li></ul></li><li><p><strong>数据段（.data</strong>）：保存<strong>全局</strong>变量、<strong>常量</strong>、<strong>静态变量</strong>的内容的一块内存区域。</p></li><li><p><strong>代码段（.text &amp; .init</strong>）： <code>.text</code> 用于存放整个程序中的代码， <code>.init</code> 用于存放系统中用来初始化启动你的程序的一段代码 。</p></li></ul><h4 id="进程创建、执行及终止">进程创建、执行及终止</h4><ul><li><p><strong>进程创建调用fork()函数，新创建进程被称为子进程</strong>。正如“fork”所暗示的，</p><ul><li>子进程会<u>复制父进程数据段、堆、栈等的副本并可以进行修改</u>；</li><li><u>代码段</u>在内存被标记为只读，则由父、子进程共享。</li></ul></li><li><p><strong>进程执行往往指的是，1）执行父进程共享代码其它函数，或2）调用execve()去加载执行全新程序</strong>。</p><ul><li>execve()会销毁所有代码段、数据段及堆栈内容，并根据新段创建新段进行替换；</li><li>以execve()为基础，C语言库提供以“exec”打头的相关函数。</li></ul></li><li><p><strong>进程终止往往可通过，1）调用_exit()函数，或2）向进程传递信号杀死</strong>。</p><p>根据惯例，终止状态为 0 表示进程“功成身退”，非 0 则表示有错误发生。</p></li></ul><h4 id="特殊进程">特殊进程</h4><h5 id="init进程">init进程</h5><p>系统引导时，内核会创建一个名为 init 的特殊进程，其主要任务是<u>创建并监控</u>系统运行所需的一系列进程。</p><ul><li><strong>1生万物</strong>，init 进程的进程号总为 1，且总是以超级用户权限运行，系统的所有进程不是由 init（使用 frok()）“亲自”创建，就是由其后代进程创建。</li><li><strong>与日同辉</strong>，谁（哪怕是超级用户）都不能“杀死”init 进程，只有关闭系统才能终止该进程。</li></ul><h5 id="守护进程">守护进程</h5><p>守护进程指的是具有特殊用途的进程，系统创建和处理此类进程的方式与其他进程相同，但以下特征是其所独有的：</p><ul><li><strong>长生不老</strong>，守护进程通常在系统引导时启动，直至系统关闭前，会一直“健在”。</li><li><strong>后台运行</strong>，且无控制终端供其读取或写入数据。</li></ul><p>守护进程中的例子有 <strong>syslogd</strong>（在系统日志中记录消息）和 <strong>httpd</strong>（利用 HTTP 分发 Web 页面）。</p><h4 id="环境列表">环境列表</h4><p>每个进程都有一份环境列表，即在进程用户空间内存中维护的一组环境变量。这份列表的每一元素都由一个名称及其相关值组成。</p><blockquote><p>由 fork()创建的新进程，也会继承父进程的环境副本。</p></blockquote><p>在大多数shell中，我们使用export命令进行创建环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp cpp-learn]<span class="comment"># export myval=&#x27;hello unix&#x27;</span></span><br><span class="line">[root@roy-cpp cpp-learn]<span class="comment"># echo $myval</span></span><br><span class="line">hello unix</span><br></pre></td></tr></table></figure><p>我们还可以打印已预定义的环境变量：</p><ul><li>PATH，用户输入命令后，shell搜索的目录列表；</li><li>HOME，用户登陆目录的路径名。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp cpp-learn]# echo $PATH </span><br><span class="line">/root/.vscode-server/bin/f80445acd5a3dadef24aa209168452a3d97cc326/bin/remote-cli:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line">[root@roy-cpp cpp-learn]# echo $HOME</span><br><span class="line">/root</span><br></pre></td></tr></table></figure><p>这些预定义的变量也很好地可以直接被shell脚本和程序进行访问。</p><h4 id="进程通信">进程通信</h4><p>Linux 系统上运行有多个进程，有些进程必须相互合作以达成预期目的，因此彼此间需要通信和同步机制。</p><ul><li><u>读写磁盘文件中的信息</u>，来进程间通信是一种容易被接受且简单可行的办法。</li></ul><p>但这种方法既慢又缺乏灵活性。因此，像所有现代 UNIX 实现那样，Linux 也提供了丰富的进程间通信（IPC）机制，如下所示。</p><ul><li><strong>信号（signal</strong>），用来表示事件的发生。</li><li><strong>管道（亦即 shell 用户所熟悉的“|”操作符）和 FIFO</strong>，用于在进程间传递数据。</li><li><strong>套接字</strong>，供同一台主机或是联网的不同主机上所运行的进程之间传递数据。</li><li><strong>消息队列</strong>，用于在进程间交换消息（数据包）。</li><li><strong>信号量（semaphore</strong>），用来同步进程动作。</li><li><strong>共享内存</strong>，允许两个及两个以上进程共享一块内存。当某进程改变了共享内存的内容时，其他所有进程会立即了解到这一变化。</li></ul><h3 id="1-1-6-内存映射">1.1.6 内存映射</h3><p><strong>内存映射（Memory-mapped，mmap）</strong>，即将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和应用程序进程虚拟地址空间中一段虚拟地址的映射关系。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/v2-3a06854cd2f7cba1da033b4a931d01e8_720w.jpg" alt="img"></p><p><strong>特别的，由某一进程所映射的内存可以与其他进程的映射共享</strong>。</p><p>有两种方式可以做到这一点：</p><ol><li>两个进程都针对某一文件的相同部分加以映射；</li><li>由 fork()创建的子进程自父进程处继承映射。</li></ol><p><strong>但这也由此引发了一个问题：某个进程对共享页面内容的改动一定会为其他进程所见吗</strong>？</p><p>其实这取决于创建映射时所传入的标志参数。</p><ul><li>若传入标志为私有，则某进程对映射内容的修改对于其他进程是不可见的，<u>而且这些改动也不会真地落实到文件上</u>；</li><li>若传入标志为共享，对映射内容的修改就会为其他进程所见，<u>并且这些修改也会造成对文件的改动</u>。</li></ul><p>内存映射用途很多，如文件 I/O（即映射内存 I/O）以及进程间通信（通过共享映射）。在后续我们还会更深入的探讨。</p><h3 id="1-1-7-信号">1.1.7 信号</h3><p>尽管1.5.5将信号视为 IPC 的方法之一，但其在其他方面的广泛应用则更为普遍。<br><strong>人们往往将信号称为“软件中断”。进程收到信号，就意味着某一事件或异常情况的发生</strong>。</p><p>信号的类型很多，每一种分别标识不同的事件或情况。采用不同的<u>整数</u>来标识各种信号类型，并以 <code>SIGxxxx</code> 形式的符号名加以定义。</p><ul><li><p><strong>信号发送</strong>，内核、其他进程（只要具有相应的权限）或进程自身均可向进程发送信号。</p><p>发生下列情况之一时，内核可向进程发送信号：</p><ul><li>用户键入中断字符（通常为 Control-C）。</li><li>进程的子进程之一已经终止。</li><li>由进程设定的定时器（告警时钟）已经到期。</li><li>进程尝试访问无效的内存地址。</li></ul><p>在 shell 中，可使用 <code>kill</code> 命令向进程发送信号。在程序内部，系统调用 kill()可提供相同的功能。</p></li><li><p><strong>信号回复</strong>，收到信号时，进程会根据信号采取如下动作之一：</p><ul><li>忽略信号。</li><li>被信号“杀死”。</li><li>先挂起，之后再被专用信号唤醒。</li></ul><p>就大多数信号类型而言，程序可选择不采取默认的信号动作，而是<u>忽略信号或者建立自己的信号处理器</u>。信号处理器是由程序员定义的函数，会在进程收到信号时自动调用，根据信号的产生条件执行相应动作。</p></li></ul><h3 id="1-1-8-线程">1.1.8 线程</h3><p>在现代 UNIX 实现中，每个进程都可执行多个线程。</p><p><strong>什么是线程</strong>？</p><p>线程是操作系统能够进行运算调度的最小单位，被包含在进程之中，是进程中的实际运作单位。</p><ul><li>每个线程都会<strong>执行相同的程序代码，共享同一数据区域和堆</strong>；</li><li>每个线程都<strong>拥有属于自己的栈</strong>，用来装载本地变量和函数调用链接信息。</li></ul><p><strong>为什么需要线程</strong>？</p><p>线程的主要优点：</p><ul><li>协同线程之间的数据共享（通过全局变量）更为容易、自然；</li><li>多线程创建、销毁等开销小；</li><li>CPU利用率高，如果一个子任务阻塞，程序可以将CPU调度到另外一个子任务进行工作。<u>这样CPU还是保留在本程序中</u>，而不是被调度到别的进程去。这样，提高了本程序所获得的CPU时间和利用率。</li></ul><p><strong>线程之间如何通信</strong>？</p><ul><li>利用前述进程之间的通信方式（<strong>IPC</strong>）；</li><li><strong>利用共享的全局变量进行通信</strong>，借助于线程 API 所提供的条件变量和互斥机制，进程所属的线程之间得以相互通信并同步行为。</li></ul><h3 id="1-1-9-会话、控制终端和控制进程">1.1.9 会话、控制终端和控制进程</h3><p>会话、控制终端和控制进程之间概念和关系如下。</p><h4 id="会话">会话</h4><p><strong>会话是一个或多个进程组的集合</strong>，会话中的所有进程都具有相同的会话标识符。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/session.jpg" alt="会话"></p><p><strong>会话与shell的关系</strong>？</p><p>使用会话最多的是支持任务控制的 shell，由 shell 创建的所有进程组与 shell 自身隶属于同一会话，<u>shell 是此会话的会话首进程</u>。</p><h4 id="控制终端">控制终端</h4><p>当一个终端与一个会话相关联后，那么这个终端就称为该会话的<strong>控制终端</strong>，建立与控制终端连接的会话首进程（一般是shell）被称为<strong>控制进程</strong>(controlling process)。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/session2.jpg" alt="会话"></p><p><strong>控制终端关闭时，会话中各个进程的变化</strong>？</p><p>简单来说，shell进程和前台所有进程会退出，后台无终端输出进程退出。</p><ol><li>首先会发一个挂断信号SIGHUP给<u>会话首进程</u>（一般为shell），即shell进程退出。</li><li>当会话首进程shell退出时，挂断信号（SIGHUP）还会继续发送给<u>前台进程组</u>和<u>后台有终端输出的</u>所有进程。</li></ol><p>若进程未对挂断信号（SIGHUP）进行处理时，所有收到该信号的进程将被终止。</p><p><strong>如何让进程在终端关闭时，不受其影响进行执行</strong>？</p><p>根据前述，若想进程在终端关闭时不受影响：</p><ol><li>如果该进程无终端输出，让该进程成为后台进程；</li><li>如果该进程有终端输出，还忽略SIGHUP信号；</li><li>让程序对挂断信号SIGHUP进行处理。</li></ol><p>针对1、2我们可以使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup &lt;<span class="built_in">command</span>&gt; &amp;</span><br></pre></td></tr></table></figure><ul><li>nohub，忽略所有挂断（SIGHUP）信号；</li><li>&amp;，程序进程进入后台运行。</li></ul><p>实例：<code>nohub python run.py &amp;</code> 。</p><p>针对3，我们还可以让程序自动具备防退出功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="comment">// 处理程序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_hup</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;received signup\n&quot;</span>);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pid = %d\n&quot;</span>,getpid());</span><br><span class="line">  <span class="comment">// 注册挂断信号(SIGHUP)的处理程序</span></span><br><span class="line">  <span class="comment">// 这样一来，我们的程序就不会因收到挂断信号而退出了</span></span><br><span class="line">  signal(SIGHUP, sig_hup);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123; </span><br><span class="line">    count++;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="1-10-proc目录">1.10 /proc目录</h3><p>Linux系统上的/proc目录是一种文件系统，即proc文件系统。 /proc是一种伪文件系统（也即虚拟文件系统），存储的是<strong>当前内核运行状态</strong>的一系列特殊文件，用户可以通过这些文件：</p><ul><li><strong>查看系统有关（1）硬件及当前（2）正在运行进程的信息</strong>；</li><li><strong>更改其中某些文件来改变内核的运行状态</strong>。</li></ul><p>例如，查看磁盘信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp proc]<span class="comment"># cat /proc/devices </span></span><br><span class="line">Character devices:</span><br><span class="line">  1 mem</span><br><span class="line">  4 /dev/vc/0</span><br><span class="line">  4 tty</span><br><span class="line">  4 ttyS</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="1-2-系统编程基本概念">1.2 系统编程基本概念</h2><p><strong>什么是系统编程</strong>？</p><p>系统编程，是指<u>进程（或者说程序</u>）以API形式，去<u>调用系统内核</u>提供的一系列服务如：</p><ul><li>创建进程</li><li>执行IO</li><li>进程通信</li><li>…</li></ul><p>等来完成程序编写。</p><p>可以看到前述核心过程是<strong>调用系统内核服务</strong>，也就是我们常说的<u>系统调用</u>。</p><h3 id="1-2-1-系统调用">1.2.1 系统调用</h3><p>在深入系统调用的运作方式之前，请务必牢记以下几点：</p><ul><li><strong>检测返回状态</strong>，无论何时，只要执行了系统调用或者库函数，检查调用的返回状态以确定调用是否成功，这是一条编程铁律。</li><li><strong>核心态切换</strong>，系统调用将处理器从用户态切换到核心态，以便 CPU 访问受到保护的内核内存。</li><li><strong>每个系统调用由数字标识</strong>，系统调用的组成是固定的，每个系统调用都由一个唯一的数字来标识。</li><li><strong>每个系统调用都有对应参数</strong>。</li></ul><p>现在我们来以具体的硬件平台x86-32为例，来分析系统调用发生时的步骤：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220509221824529.png" alt="image-20220509221824529"></p><ol><li><p><strong>调用外壳函数</strong>，应用程序通过设置相应的参数来调用 C 语言函数库中的外壳函数，然后发起系统调用；</p></li><li><p><strong>参数传入寄存器</strong>，内核希望将这些函数参数置入特定寄存器，因此，外壳函数会将上述参数复制到寄存器；</p></li><li><p><strong>系统调用编号传入寄存器<code>%eax</code></strong>，由于所有系统调用进入内核的方式相同，内核需区分每个系统调用，为此，外壳函数会将系统调用编号复制到一个特殊的 CPU 寄存器（%eax）中；</p></li><li><p><strong>执行中断</strong>，外壳函数执行中断机器指令（int 0x80）→<u>处理器从用户态切换到核心态</u>→执行系统中断 0x80；</p></li><li><p><strong>响应中断</strong>，保存寄存器值→审核系统编号有效性→<u>查询服务列表sys_call_table→执行系统调用→返回状态参数给sys_call</u>()；</p><ul><li>关于sys_call_table，在 Linux/x86-32 上，execve()的系统调用号为 11(__NR_execve)。因此，在 sys_call_table 向量中，条目 11 包含了该<br>系统调用的服务例程 sys_execve()的<strong>地址</strong>。</li></ul></li><li><p><strong>结束中断</strong>，内核栈中恢复各寄存器值→系统调用返回值置于栈中→<u>处理器切回用户态</u>。</p></li><li><p><strong>返回值错误处理</strong>，若系统调用服务例程的返回值表明调用有误，外壳函数会使用该值来设置全局变量 errno。</p></li></ol><h3 id="1-2-2-C语言函数库glibc">1.2.2  C语言函数库glibc</h3><p>GNU C 语言函数库[glibc](<a href="http://www">http://www</a>.<br><a href="http://gnu.org/software/libc/">gnu.org/software/libc/</a>)，是 Linux 上最常用的实现。</p><p>查看一下我们机器上的glibc版本吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp TLPI]<span class="comment"># /lib64/libc.so.6 </span></span><br><span class="line">GNU C Library (GNU libc) stable release version 2.17, by Roland McGrath et al.</span><br></pre></td></tr></table></figure><p>动态库<code>libc.so.6</code> 可视为可执行文件，输出当前glibc版本，一般位于目录/lib64/libc.so.6 或 /lib/libc.so.6 下。</p><h3 id="1-2-3-处理返回的错误">1.2.3 处理返回的错误</h3><p><strong>不检查状态值，少敲几行代码听起来的确诱人，但实际却得不偿失</strong>。</p><p>每个<u>系统调用</u>和<u>库函数</u>都会返回某类状态值，要了解调用是否成功，必须坚持对状态值进行检查。</p><p>这能节约我们大把的程序调试时间。</p><h4 id="处理系统调用错误">处理系统调用错误</h4><p>绝大部分系统检查调用错误信息步骤：</p><ol><li>先检查系统调用返回值是否错误（为-1），如果错误转2；</li><li>继续检查 errno号，来确定具体错误。</li></ol><p>下面举一个例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cnt = <span class="built_in">read</span>(fd,buf1,len);</span><br><span class="line"><span class="keyword">if</span>(cnt == <span class="number">-1</span>)  <span class="comment">// 检查返回值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(errno == EINTR)  <span class="comment">// 检查errno号</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;read was interrupted by a signal.&quot;</span> ;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查errno号也可以直接替换使用<code>perror(char* str)</code> 函数，其会打印我们输入字符串<code>str</code> + 当前error对应的错误信息。</p><p>以下是一个更完整的例子展示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span>    <span class="comment">/* For O_RDWR */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>   <span class="comment">/* For open(), creat() */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  <span class="comment">/* For strlen()*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span>  <span class="comment">/* For setw() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">20</span>] = <span class="string">&quot;./test/1.txt&quot;</span>;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(filename,O_RDWR|O_EXCL|O_TRUNC,S_IRWXG);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;open the file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)  <span class="comment">// 判断文件是否成功打开</span></span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;file open error.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;writ data to the file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;please input: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">getline</span>(buf,<span class="number">100</span>); </span><br><span class="line">    len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    cnt = <span class="built_in">write</span>(fd,buf,len);</span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;file write error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);   <span class="comment">// 关闭文件   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">100</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;read file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    fd = <span class="built_in">open</span>(filename,O_RDONLY);  <span class="comment">// 再次打开文件</span></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) <span class="comment">// 判断文件是否打开成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;file open error.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="built_in">read</span>(fd,buf1,len);</span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;file read error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; buf1;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp TLPI]<span class="comment"># g++ -g  chap3.cpp  -o chap3.out  </span></span><br><span class="line">[root@roy-cpp TLPI]<span class="comment"># ./chap3.out </span></span><br><span class="line">open the file.</span><br><span class="line">writ data to the file.</span><br><span class="line">please input: </span><br><span class="line">hello roy</span><br><span class="line"><span class="built_in">read</span> file.</span><br><span class="line">hello roy</span><br></pre></td></tr></table></figure><h4 id="处理库函数调用错误">处理库函数调用错误</h4><p>库函数调用和系统调用错误有些不同。</p><ul><li>和系统调用一致：返回值为-1，配合error号进行检查；</li><li>出错返回值不一定为-1，如<code>fopen</code>出错返回NULL指针，配合error进行检查；</li><li>部分库函数根本不使用error。</li></ul><p>在本章，主要介绍了Linux发展历史，以及Linux&amp;系统编程的基本概念。在下一章，我将主要介绍文件I/O相关知识。</p><h1>更新记录</h1><div class="timeline"><div class="timenode"><div class="meta"><p><p>2022-06-16 ：更新笔记</p></p></div><div class="body"><ol><li>第一次更新</li></ol></div></div></div><h1>参考文献</h1><p>[1] linux的控制终端： <a href="http://shareinto.github.io/2016/11/17/linux-terminal/">http://shareinto.github.io/2016/11/17/linux-terminal/</a></p><p>[2] 黑马程序员教程：<a href="https://book.itheima.net/course/223/">https://book.itheima.net/course/223/</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 系统编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++从零开始（十一）：C++进阶（下）STL</title>
      <link href="/p/17467/"/>
      <url>/p/17467/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，开始更新中…</p></blockquote><div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div><h1>九、STL</h1><p>STL 即“标准模板库”（ “Standard Template Library”） 的缩写， 是C++标准库的一部分，使用时不用单独安装，直接引入头文件即可。</p><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>  <span class="comment">// 引入vector</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span>   <span class="comment">// 引入array</span></span></span><br></pre></td></tr></table></figure><p>STL发展历史重要时刻一览：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/Ko9ammy.png" alt="Ko9ammy"></p><ul><li>1987年：贝尔实验室Stepanov 进行C++泛型软件库的研究；</li><li>1992年：Alex Stepanov 正式提出 <a href="https://en.wikipedia.org/wiki/Standard_Template_Library">STL（Standard Template Library）</a>；</li><li>1994年：STL 正式纳入 C++ 标准化进程之中，随者 C++ 标准的改进，STL 也不断做着相应演化；</li><li>1998年：ANSI/ISO C++ 标准正式定案，STL 正式成为C++ 标准库不可或缺的重要组成部分。</li></ul><p>STL 几乎所有的代码都采用了<u>模板类</u>和<u>模版函数</u>的方式，由此提供了很好的代码重用机会。</p><p>STL从广义上讲分为三类：</p><ul><li><p><strong>container（容器</strong>），使得我们可以直接使用不同的数据结构，如vector（底层是数组）、list（底层是链表）、map（底层是红黑树）等来组织数据。这为我们高效组织不同数据，提供了极大的方便。</p></li><li><p><strong>algorithm（算法</strong>），则方便了我们对<u>容器（或数组）中的数据</u>进行各种骚操作，如排序（sort）、查找（find）、合并（merge）等。STL算法提供了现成的接口（函数），可以快速实现上述操作。而且一般来说，STL的实现远比我们自身实现的算法要高效，尽量避免自己造轮子，直接使用STL中的接口函数更好。</p></li><li><p><strong>iterator（迭代器</strong>），提供了遍历<u>不同容器（或数组）的元素</u>时的统一访问方式。这得益于STL为每种容器类设计了一个内嵌的<strong>iterator类</strong>，不同的容器都有自己专属的<code>iterator</code>，因此访问不同容器中的数据可统一使用<code>container&lt;type&gt;::iterator</code>方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;    <span class="comment">// vector</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator t = v.<span class="built_in">begin</span>();  <span class="comment">// iterator</span></span><br><span class="line"></span><br><span class="line">array&lt;<span class="keyword">int</span>,5&gt; arr &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">// array</span></span><br><span class="line">array&lt;<span class="keyword">int</span>,5&gt;::iterator t = arr.<span class="built_in">begin</span>(); <span class="comment">// iterator</span></span><br></pre></td></tr></table></figure><p>普通数组名也可视为一个指向首元素的迭代器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line">*(arr++);    <span class="comment">// 2, arr作为迭代器</span></span><br></pre></td></tr></table></figure><p>更妙的是，迭代器使得容器和算法的实现<u>可以分开</u>，必要时又可作为“粘合剂”将二者联系起来。</p></li></ul><p>现在我们按：迭代器、容器、算法的顺序依次对STL进行详细介绍。</p><h2 id="9-1-迭代器">9.1 迭代器</h2><p>正如前述，迭代器用于遍历容器（或数组）中存储的元素。</p><h3 id="9-1-1-认识迭代器">9.1.1 认识迭代器</h3><h4 id="容器迭代器：iterator">容器迭代器：iterator</h4><p>STL 标准库为每一种标准容器定义了迭代器，我们可以按照下面方式进行访问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;容器类名&gt;::iterator </span><br></pre></td></tr></table></figure><p>就像：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator;</span><br><span class="line">array&lt;<span class="keyword">int</span>,5&gt;::iterator;</span><br></pre></td></tr></table></figure><p>这里的类成员<code>&lt;容器类名&gt;::iterator </code>对于不同容器，返回的是不同功能的迭代器。</p><table><thead><tr><th style="text-align:center">容器</th><th style="text-align:center">底层数据结构</th><th style="text-align:center">迭代器类型</th></tr></thead><tbody><tr><td style="text-align:center">array</td><td style="text-align:center">数组</td><td style="text-align:center">随机访问迭代器</td></tr><tr><td style="text-align:center">vector</td><td style="text-align:center">数组</td><td style="text-align:center">随机访问迭代器</td></tr><tr><td style="text-align:center">deque</td><td style="text-align:center">数组</td><td style="text-align:center">随机访问迭代器</td></tr><tr><td style="text-align:center">list</td><td style="text-align:center">双链表</td><td style="text-align:center">双向迭代器</td></tr><tr><td style="text-align:center">set / multiset / map / multimap</td><td style="text-align:center">红黑树</td><td style="text-align:center">双向迭代器</td></tr><tr><td style="text-align:center">forward_list</td><td style="text-align:center">单链表</td><td style="text-align:center">正向迭代器</td></tr><tr><td style="text-align:center">unordered_map / unordered_set / …</td><td style="text-align:center">哈希表</td><td style="text-align:center">正向迭代器</td></tr><tr><td style="text-align:center">stack / queue</td><td style="text-align:center">对基础容器list、deque等进行封装</td><td style="text-align:center">不支持迭代器</td></tr></tbody></table><p>上述三种迭代器解释如下：</p><blockquote><p>以下<code>p</code>、<code>q</code>代表对应的迭代器。</p></blockquote><ul><li><p><strong>输入、输出迭代器</strong>：比较特殊，它们不是把容器（或数组）当做操作对象，而是把输入流/输出流作为操作对象。</p><ul><li>输入迭代器：<u>只读</u>，一次传递 ，为输入迭代器预定义实现只有<code>istream_iterator</code>和<code>istreambuf_iterator</code>，用于从一个输入流中读取数据。其支持的操作符有 *<strong>p,++p,p++,p!=q,p == q</strong> ；</li><li>输出迭代器：<u>只写</u>，一次传递 ，为输出迭代器的预定义实现只有<code>ostream_iterator</code>和<code>ostreambuf_iterator</code>，用于向一个输出流写数据。支持的操作符和输入迭代器一致。</li></ul></li><li><p><strong>正向迭代器</strong>：结合了输入、输出迭代器几乎所有的功能，支持正向遍历、取值、赋值及相关比较操作。</p><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">p++ 或 ++p</td><td style="text-align:center">返回p<strong>后一个</strong>元素的迭代器</td></tr><tr><td style="text-align:center">*p</td><td style="text-align:center">获取迭代器所指向元素的值</td></tr><tr><td style="text-align:center">p = p+1</td><td style="text-align:center">赋值操作</td></tr><tr><td style="text-align:center">p == p+1</td><td style="text-align:center">比较操作</td></tr><tr><td style="text-align:center">p != p+1</td><td style="text-align:center">比较操作</td></tr></tbody></table></li><li><p><strong>双向迭代器</strong>：具有<u>正向</u>迭代器的全部功能，除此之外还可以向后移动，即<code>--p</code>或<code>p--</code> 。</p><table><thead><tr><th style="text-align:center">额外操作（相比正向迭代器）</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">p-- 或 --p</td><td style="text-align:center">返回p前一个元素的迭代器</td></tr></tbody></table></li><li><p><strong>随机访问迭代器</strong>：具有双向迭代器的全部功能，除此之外还可以随机遍历容器元素（显然，指针就是这么一个迭代器）。</p><table><thead><tr><th style="text-align:center">额外操作（相比双向迭代器）</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">p+=i</td><td style="text-align:center">p 往后移动 i 个元素</td></tr><tr><td style="text-align:center">p-=i</td><td style="text-align:center">p 往前移动 i 个元素</td></tr><tr><td style="text-align:center">p+i</td><td style="text-align:center">返回 p 后面第 i 个元素的迭代器</td></tr><tr><td style="text-align:center">p-i</td><td style="text-align:center">返回 p 前面第 i 个元素的迭代器</td></tr><tr><td style="text-align:center">p[i]</td><td style="text-align:center">返回 p 后面第 i 个元素的引用</td></tr></tbody></table><p>此外，两个随机访问迭代器 p1、p2 ：</p><ul><li>可以用 &lt;、&gt;、&lt;=、&gt;= 运算符进行比较；</li><li>表达式 p2-p1 也是有定义的，返回区间[p1,p2]的元素个数。</li></ul></li></ul><p>再思考不同容器对应的迭代器就很好理解了：</p><ul><li>底层数据结构是数组的（array/vector/deque），具体随机访问的特性，自然最适合随机迭代器；</li><li>底层数据结构是双链表和红黑树的（list/set/map），无法随机访问，但可以前、后方向遍历，所以使用双向迭代器；</li><li>底层数据结构是单链表、哈希表的（forward_list/unordered_map / unordered_set），无法随机访问也无法正向遍历，最后只能使用正向迭代器。</li></ul><p>stack / queue 为了维持特殊的数据访问规则“先进后出” / “先进先出”，不允许前/后/随机迭代器在这里使用，否则会破坏规则。</p><h4 id="容器其它迭代器">容器其它迭代器</h4><p>每个容器类除了成员<code>iterator</code>还可能有其它的迭代器：</p><table><thead><tr><th style="text-align:center">迭代器</th><th style="text-align:center">使用格式</th></tr></thead><tbody><tr><td style="text-align:center">默认迭代器</td><td style="text-align:center"><code>&lt;容器类名&gt;::iterator</code></td></tr><tr><td style="text-align:center">常量正向迭代器</td><td style="text-align:center"><code>&lt;容器类名&gt;::const_iterator</code></td></tr><tr><td style="text-align:center">反向迭代器</td><td style="text-align:center"><code>&lt;容器类名&gt;::reverse_iterator</code></td></tr><tr><td style="text-align:center">常量反向迭代器</td><td style="text-align:center"><code>&lt;容器类名&gt;::const_reverse_iterator</code></td></tr></tbody></table><p>这些迭代器是对类成员<code>iterator</code>的进一步限制。</p><ul><li><p><strong>常量正向/反向迭代器</strong>：保留<code>iterator</code>的基本特性，但常量迭代器无法修改其指向的元素；</p></li><li><p><strong>反向迭代器</strong>：保留<code>iterator</code>的基本特性，但<code>iterator</code>进行 ++ 操作时，迭代器会指向容器中的<strong>后一个</strong>元素；而反向迭代器进行 ++ 操作时，迭代器会指向容器中的<strong>前一个元</strong>素。</p><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">p++ 或 ++p</td><td style="text-align:center">返回p<strong>前一个</strong>元素的迭代器</td></tr></tbody></table></li></ul><p>不过以上 4 种定义迭代器，并不是每个容器都全部拥有。</p><ul><li>部分容器同时支持以上 4 种方式，比如 array、deque、vector；</li><li>而有些容器只支持部分，例如 forward_list 容器只支持正向迭代器，不支持反向迭代器。</li></ul><p>以vector为例演示vector类中四种迭代器成员的使用。</p><p>同前，vector的<code>iterator</code>是随机迭代器，<u>常量迭代器和反向迭代器只是对<code>iterator</code>的进一步限制，但也具有随机迭代器的基本特性</u>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// vector默认的是随机迭代器</span></span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;随机迭代器遍历：&quot;</span>;</span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>(); </span><br><span class="line">   iter[<span class="number">1</span>] = <span class="number">20</span>;  <span class="comment">// 随机迭代器特性[]</span></span><br><span class="line">   <span class="keyword">for</span>(; iter != vec.<span class="built_in">end</span>() ; iter++)</span><br><span class="line">         std::cout &lt;&lt; *(iter) &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 20 3 4 5</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 常量迭代器</span></span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;\n常量迭代器遍历：&quot;</span>;</span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt;::const_iterator c_iter = vec.<span class="built_in">cbegin</span>(); </span><br><span class="line">   <span class="comment">// c_iter[1] = 20;  // error，只读</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注意，rbegin()/crbegin() 返回的是尾元素迭代器</span></span><br><span class="line">   <span class="comment">// 反向迭代器</span></span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;\n反向迭代器遍历：&quot;</span>;</span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt;::reverse_iterator r_iter = vec.<span class="built_in">rbegin</span>(); </span><br><span class="line">   <span class="keyword">for</span>(; r_iter != vec.<span class="built_in">rend</span>() ; r_iter++)</span><br><span class="line">         std::cout &lt;&lt; *(r_iter) &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 5 4 3 20 1</span></span><br><span class="line">         </span><br><span class="line">   <span class="comment">// 常量反向迭代器</span></span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;\n常量反向迭代器遍历：&quot;</span>;</span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt;::const_reverse_iterator cr_iter = vec.<span class="built_in">crbegin</span>(); </span><br><span class="line">   <span class="comment">// c_iter[1] = 20;  // error，只读</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">随机迭代器遍历：1 20 3 4 5 </span><br><span class="line">反向迭代器遍历：5 4 3 20 1 </span><br></pre></td></tr></table></figure><p>实际编码中，可用<code>auto</code>关键字减少定义迭代器类型时的书写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = vec.<span class="built_in">begin</span>(); </span><br></pre></td></tr></table></figure><p>下文我们会默认采用这种书写方式。更多迭代器的使用示例会穿插在后文中。</p><h3 id="9-1-2-迭代器和指针？">9.1.2  迭代器和指针？</h3><p>迭代器和指针表现得和指针极为类似，以至于我们会产生疑惑：<strong>迭代器是什么？它就是指针吗</strong>？</p><p>先说结论，迭代器不是指针，它只是指针的一层封装，在STL中实现为一个模板类。</p><p><strong>为什么要进行这种封装</strong>？</p><p>这样可统一不同容器的指针操作。比如，array/list/…底层都是利用指针算术运算查找元素，但具体的行为不同，采用iterator可把底层指针操作抽象出来，根据容器不同的底层数据结构来实现不同的++、–等指针操作。</p><p>源码简单观察迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;   </span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>F12查看<code>vector&lt;int&gt;::iterator</code>定义：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216103721767.png" alt="image-20220216103721767"></p><ul><li><code>iterator</code>定义在模板类vector中，是<code> __gnu_cxx::__normal_iterator&lt;pointer, vector&gt;</code> 的别名，注意到模板参数<code>pointer</code>；</li><li><code>__normal_iterator</code>是linux中STL自定义的迭代器模板，而<code>pointer</code>是普通指针类型别名，这里是<code>int*</code> 。</li></ul><p>继续进入<code>__normal_iterator</code>类中：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216105723634.png" alt="image-20220216105723634"></p><ul><li><code>_M_current</code> 类型为<code>_Iterator</code> ，即为<code>pointer</code>（这里是<code>int*</code>），它是一个指针，指向底层数组首元素 。</li></ul><p>类中还有迭代器的各种操作，以<code>++</code>操作为例：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216111955068.png" alt="image-20220216111955068"></p><p>可见迭代器确实只是对指针进行了一层封装，本质还是通过指针实现了各种操作。</p><h2 id="9-2-容器">9.2 容器</h2><p>STL中的容器也是模板类，本质是封装了不同的基本数据结构（数组、链表等）的模板类。STL提供三种标准容器，分别是：</p><ul><li>序列容器</li><li>排序容器</li><li>哈希容器</li></ul><p>这三种容器主要特点如下。</p><table><thead><tr><th style="text-align:center">容器种类</th><th style="text-align:center">包含的具体容器</th><th>底层数据结构</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">序列容器</td><td style="text-align:center">vector 向量容器、list 列表容器以及 deque 双端队列容器</td><td>数组或链表</td><td style="text-align:center">序列容器中的元素以<strong>线性方式</strong>存储，但元素不是排好序的</td></tr><tr><td style="text-align:center">排序容器</td><td style="text-align:center">set 集合容器、multiset 多重集合容器、map 映射容器以及 multimap 多重映射容器</td><td>红黑树</td><td style="text-align:center">排序容器中的元素，以<strong>键值对形式</strong>存储，默认是按键值排序好的</td></tr><tr><td style="text-align:center">哈希容器</td><td style="text-align:center">unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射</td><td>哈希表</td><td style="text-align:center">哈希容器中元素同样以<strong>键值对方式</strong>存储，但元素是未排序的，元素的位置由哈希函数确定</td></tr></tbody></table><p>下面开始具体介绍。</p><h3 id="9-2-1-序列式容器">9.2.1 序列式容器</h3><p>本节主要探讨以下容器：</p><table><thead><tr><th style="text-align:center">容器</th><th style="text-align:center">底层数据结构</th><th style="text-align:center">特点</th><th style="text-align:center">迭代器类型</th></tr></thead><tbody><tr><td style="text-align:center">array</td><td style="text-align:center">数组</td><td style="text-align:center"><strong>大小固定、无法修改</strong></td><td style="text-align:center">随机迭代器</td></tr><tr><td style="text-align:center">vector</td><td style="text-align:center">数组</td><td style="text-align:center">大小可变、只能<u>尾部</u>插入/删除</td><td style="text-align:center">随机迭代器</td></tr><tr><td style="text-align:center">deque</td><td style="text-align:center">数组</td><td style="text-align:center">大小可变、双向队列，头尾可高效插入/删除</td><td style="text-align:center">随机迭代器</td></tr><tr><td style="text-align:center">list</td><td style="text-align:center">双链表</td><td style="text-align:center">大小可变，双链表，头尾可高效插入/删除</td><td style="text-align:center">双向迭代器</td></tr><tr><td style="text-align:center">forward_list</td><td style="text-align:center">单链表</td><td style="text-align:center">大小可变，单链表，仅可在<u>头部</u>插入/删除</td><td style="text-align:center">前向迭代器</td></tr></tbody></table><p>它们最主要的区别，由底层数据结构决定。</p><h4 id="array">array</h4><p>array 容器底层数据结构是普通的<u>静态</u>数组，所以array大小是固定的，无法动态扩展。</p><p>array 容器以类模板的形式定义在 <code>&lt;array&gt;</code> 头文件，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, std::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array</span></span></span><br></pre></td></tr></table></figure><p>这里实际是使用模板结构体<code>struct</code>，但在C++中和<code>class</code>差别不大，可以视为类模板。</p><p>在 <code>array&lt;_Tp,_Nm&gt;</code> 模板中：</p><ul><li><code>_Tp</code>，用于指明容器中元素数据类型；</li><li><code>_Nm</code>，用于指明容器的大小。</li></ul><p>一个简单使用实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="keyword">int</span>, 5&gt; arr &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">auto</span> first = arr.<span class="built_in">cbegin</span>();</span><br><span class="line">    <span class="keyword">auto</span> last = arr.<span class="built_in">cend</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != last)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216180536128.png" alt="image-20220216180536128"></p><h5 id="底层实现">底层实现</h5><p>本节主要探讨以下问题：</p><ul><li>array底层数据结构？</li><li>array迭代器结构？</li></ul><p><strong>我们前面说过array底层是一个容量大小固定的数组，它具体是什么样呢</strong>？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="keyword">int</span>, 5&gt; arr&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br></pre></td></tr></table></figure><p>F12查看<code>array</code>定义：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216181435428.png" alt="image-20220216181435428"></p><p>注意到上面红框处的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _GLIBCXX_STD_C::__array_traits&lt;_Tp, _Nm&gt; _AT_Type;</span><br><span class="line"><span class="keyword">typename</span> _AT_Type::_Type    _M_elems; <span class="comment">// typename说明_AT_Type::_Type是一个类型</span></span><br></pre></td></tr></table></figure><p>成员 <code>_M_elems</code>便是底层数组。要分析出<code>_M_elems</code>类型，首先要知道<code>_AT_Type::_Type</code>是什么意思。</p><ul><li><p>注意到第一行代码，<code>_AT_Type</code>是<code>__array_traits&lt;_Tp, _Nm&gt;</code>的别名，查看<code>__array_traits</code>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, std::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">array_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> _Tp _Type[_Nm]; <span class="comment">// _Type是一个静态数组</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">constexpr</span> _Tp&amp;</span><br><span class="line">   _S_ref(<span class="keyword">const</span> _Type&amp; <span class="keyword">__t</span>, std::<span class="keyword">size_t</span> __n) <span class="keyword">noexcept</span></span><br><span class="line">   &#123; <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;_Tp&amp;&gt;(<span class="keyword">__t</span>[__n]); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以：<code>_AT_Type</code>就是一个array萃取类，而<code>_Type</code>是它的成员，也就是一个静态数组，类型为<code>_Tp[_Nm]</code>。</p></li></ul><p>回到<code>_M_elems</code>相关定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> _AT_Type::_Type    _M_elems;</span><br></pre></td></tr></table></figure><p><code>_M_elems</code>真正面貌便呼之欲出，在这个例子中<code>_Tp</code>为<code>int</code>，<code>_Nm</code>为<code>5</code> ，所以上述等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[<span class="number">5</span>] _M_elems;</span><br></pre></td></tr></table></figure><p><strong>每个容器都会有对应的迭代器，array的迭代器是什么</strong>？</p><p>说出来你有点惊讶，array的迭代器就简单实现为指针。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220217191114160.png" alt="image-20220217191114160"></p><ul><li><code>iterator</code> 即为<code>_Tp *</code> ；</li><li><code>const_iterator</code> 即为<code>const _Tp *</code> 。</li></ul><p>所以你会发现即使array的<code>iterator</code> 没有实现<code>operator++</code>函数 ，依旧可以这么使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="keyword">int</span>,3&gt; arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iter = arr.<span class="built_in">begin</span>();  <span class="comment">// 等价于 int* iter = arr.begin(); </span></span><br><span class="line">iter++; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>因为此时就是对一个<code>int*</code>指针进行<code>++</code>操作。</p><p>array让我们可以灵活定义各种类型的数组，保证了安全性又几乎不损失效率。如果想使用静态数组（固定数组），array首选推荐使用。</p><h5 id="成员函数">成员函数</h5><p>array具有众多的成员函数，方便我们对array进行各种操作。</p><p>我们先一睹为快。</p><ul><li><p><strong>迭代器相关</strong></p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">begin()</td><td style="text-align:center">返回指向容器中第一个元素的正向迭代器</td></tr><tr><td style="text-align:center">end()</td><td style="text-align:center">返回指向容器最后一个元素之后一个位置的正向迭代器</td></tr><tr><td style="text-align:center">rbegin()</td><td style="text-align:center">返回指向最后一个元素的反向迭代器</td></tr><tr><td style="text-align:center">rend()</td><td style="text-align:center">返回指向第一个元素之前一个位置的反向迭代器</td></tr><tr><td style="text-align:center">cbegin()</td><td style="text-align:center">和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td></tr><tr><td style="text-align:center">cend()</td><td style="text-align:center">和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td></tr><tr><td style="text-align:center">crbegin()</td><td style="text-align:center">和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td></tr><tr><td style="text-align:center">crend()</td><td style="text-align:center">和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td></tr></tbody></table><ul><li>注意，如果是 <em>const</em> 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素；</li><li>begin() 和 end() 为C++11新增，操作对象还可以是数组。</li></ul></li></ul><p>包含使用的一些小例子</p><ul><li><p><strong>主要成员函数</strong></p><p>标粗部分是常用的函数。</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><strong>size</strong>()</td><td style="text-align:center"><strong>返回容器中当前元素的数量</strong>，其值始终等于初始化 array 类的第二个模板参数 N</td></tr><tr><td style="text-align:center">max_size()</td><td style="text-align:center">返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N</td></tr><tr><td style="text-align:center"><strong>empty</strong>()</td><td style="text-align:center"><strong>判断容器是否为空</strong>，和通过 <code>size()==0</code> 的判断条件功能相同，但其效率可能更快</td></tr><tr><td style="text-align:center"><strong>at(n</strong>)</td><td style="text-align:center"><strong>返回容器中 n 位置处元素的引用，作用类似[]</strong>，但该函数还会检查 n 是否有效，无效会抛出 <em>out_of_range</em> 异常</td></tr><tr><td style="text-align:center">front()</td><td style="text-align:center">返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器</td></tr><tr><td style="text-align:center">back()</td><td style="text-align:center">返回容器中最后一个元素的直接引用，该函数同样不适用于空的 array 容器</td></tr><tr><td style="text-align:center"><strong>data</strong>()</td><td style="text-align:center"><strong>返回一个指向容器首个元素的指针</strong>，利用该指针可实现复制容器中所有元素等类似功能</td></tr><tr><td style="text-align:center"><strong>fill(val</strong>)</td><td style="text-align:center"><strong>将 val 这个值赋值给容器中的每个元素</strong></td></tr><tr><td style="text-align:center">array1.swap(array2)</td><td style="text-align:center">交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td></tr></tbody></table></li></ul><p>由于这些函数都比较简单，所以就不举例说明啦。</p><h4 id="vector">vector</h4><p>vector基本是平时最常用的容器之一，和 array 容器类似，底层数据结构都是数组，只不过array是静态数组大小固定，而vector底层是一个动态数组。</p><p>最让人欣慰的是，vector会<u>动态扩展（但不会收缩</u>）所占用的内存空间，即自动扩容，我们无需操心数组增长问题。</p><p>vector容器以类模板的形式定义在 <code>&lt;vector&gt;</code> 头文件，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, </span><br><span class="line"> <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">class vector : <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;</span><br></pre></td></tr></table></figure><p>在 <code>vector&lt;_Tp,_Alloc&gt;</code> 模板中：</p><ul><li><code>_Tp</code> ，用于指明容器中元素数据类型；</li><li><code>_Alloc</code> ，内存分配器，默认采用二级配置器，一般不用我们关心。</li></ul><p>简单使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// vector&lt;int,std::allocator&lt;int&gt;&gt; vec &#123;1,2,3,4,5,6&#125;; // 模板参数完整使用</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="string">&quot;7&quot;</span>); <span class="comment">// 继续插入数据，vector自动扩容，程序员无需关心</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = vec.<span class="built_in">begin</span>(); i &lt; vec.<span class="built_in">end</span>(); i++) </span><br><span class="line">&#123;</span><br><span class="line">        std::cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，相比array，vector可以很方便的使用<code>push_back</code>等方法插入新数据。</p><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h5 id="底层实现-2">底层实现</h5><p>在本节我们主要探讨以下问题：</p><ul><li>vector底层数据结构？</li><li>vector底层迭代器如何实现？</li><li>vector底层是如何进行初始化的？</li><li>vector底层自动扩容机制过程和原理？</li></ul><p><strong>我们先了解下vector类继承结构及核心成员</strong>。</p><p>注意到，vector 继承了 <code>_Vector_base</code> ，<code>_Vector_base</code>专门负责vector的内存管理。</p><p><code>_Vector_base</code>核心是内部类<code>_Vector_impl</code> ，它继承了<code>_Tp_alloc_type</code>  获得内存分配释放的功能。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216195801843.png" alt="image-20220216195801843"></p><p><code>_Vector_impl</code>核心成员：</p><ul><li><p><code>M_start</code>，<code>_M_finish</code>，<code>_M_end_of_storage</code> ：所有关于地址，容量大小等操作都需要用到这三个指针。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216195950418.png" alt="image-20220216195950418"></p><ul><li>_M_start ，代表起始位置的指针</li><li>_M_finish ，代表已存储的元素的末尾位置</li><li>_M_end_of_storage， 代表整个vector空间的结束位置</li></ul></li><li><p><code>_M_allocate</code>和<code>_M_deallocate</code>：分别分配和释放vector所用内存，vector只需要负责元素构造和析构。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216200341073.png" alt="image-20220216200341073"></p><ul><li><code>_M_allocate</code>，最终通过malloc实现内存分配；</li><li><code>_M_deallocate</code>，通过free实现内存释放。</li></ul></li></ul><p>了解了vector类大致结构，再来依次回答节前的问题：</p><ul><li><p><strong>vector底层数据结构</strong>？</p><p>vector底层是一个动态数组，初始化时会让指针<code>_M_start</code> （<code>_Tp*</code>类型）会指向分配内存。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216195950418.png" alt="image-20220216195950418"></p></li><li><p><strong>vector迭代器如何实现</strong>？</p><p>同前<u>9.1.2节</u>，在vector类中可找到<code>iterator</code>相关定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __gnu_cxx::__normal_iterator&lt;pointer, vector&gt; iterator;</span><br></pre></td></tr></table></figure><p>进入<code>__normal_iterator</code>类中：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216105723634.png" alt="image-20220216105723634"></p><ul><li>主要成员<code>_M_current</code> 类型为<code>_Iterator</code> ，即为<code>pointer</code>（这里是<code>int*</code>），它是一个指针，指向底层数组首元素 。</li></ul><p>类中还封装迭代器的各种操作，以<code>++</code>操作为例：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216111955068.png" alt="image-20220216111955068"></p></li><li><p><strong>vector是如何进行初始化的</strong>？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; vec &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>vector类在构造时分配初始数组内存。vector类支持多种构造函数，如普通构造函数、移动构造函数、拷贝构造函数等。</p><p>以普通构造函数为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  @brief  初始化为n个__value值，如果没指定就使用该类型默认值</span></span><br><span class="line"><span class="comment">  *  @param  __n  The number of elements to initially create.</span></span><br><span class="line"><span class="comment">  *  @param  __a  An allocator.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type __n, <span class="keyword">const</span> value_type&amp; __value = value_type(),<span class="keyword">const</span> allocator_type&amp; __a = allocator_type())</span></span></span><br><span class="line"><span class="function"> : _Base(__n, __a)</span></span><br><span class="line"><span class="function"> &#123;</span> </span><br><span class="line">  _M_fill_initialize(__n, __value); <span class="comment">// 初始化所有元素为__value</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>核心是调用了基类构造函数<code>_Base(__n, __a)</code> ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _Vector_base&lt;_Tp, _Alloc&gt; _Base;</span><br></pre></td></tr></table></figure><p>在<code>_Vector_base</code> 查到其定义：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216204720395.png" alt="image-20220216204720395"></p><p>关键函数<code>_Vector_base::_M_create_storage</code>实现为：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216204940950.png" alt="image-20220216204940950"></p><ul><li><code>_M_allocate</code> 最终就是通过<code>_M_impl.allocate</code>实现；</li><li><code>_M_impl.allocate</code> 最终通过malloc实现内存分配。</li></ul><p>综上所述，vector通过构造函数初始化，最终调用malloc分配了底层数组内存空间。</p></li><li><p><strong>vector自动扩容机制实现的过程和原理</strong>？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(<span class="string">&quot;7&quot;</span>); <span class="comment">// 继续插入数据，vector自动扩容，程序员无需关心</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="string">&quot;9&quot;</span>);</span><br></pre></td></tr></table></figure><p>如下所示，左图代表扩容前的存储结构，右图是扩容后的存储结构。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/20200620015208205.png" alt="img"></p><p>扩容条件：</p><ul><li>size()函数返回的是<u>已用空间</u>大小，capacity()返回的是<u>总空间</u>大小，capacity()-size()则是剩余的可用空间大小；</li><li><u>当size()和capacity()相等</u>，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。</li></ul><p>扩容过程：</p><ol><li>重新分配一块<u>两倍</u>于原来大小的内存空间；</li><li>将原来的存储空间的元素，依次拷贝到新的<code>2*capacity</code>大小的存储空间之中。</li></ol></li></ul><h5 id="成员函数-2">成员函数</h5><p>vector具有众多的成员函数，方便我们对vector进行各种操作。</p><p>我们先一睹为快。</p><ul><li><p><strong>迭代器相关</strong></p><p>同array。</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">begin()</td><td style="text-align:center">返回指向容器中第一个元素的正向迭代器</td></tr><tr><td style="text-align:center">end()</td><td style="text-align:center">返回指向容器最后一个元素之后一个位置的正向迭代器</td></tr><tr><td style="text-align:center">rbegin()</td><td style="text-align:center">返回指向最后一个元素的反向迭代器</td></tr><tr><td style="text-align:center">rend()</td><td style="text-align:center">返回指向第一个元素之前一个位置的反向迭代器</td></tr><tr><td style="text-align:center">cbegin()</td><td style="text-align:center">和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td></tr><tr><td style="text-align:center">cend()</td><td style="text-align:center">和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td></tr><tr><td style="text-align:center">crbegin()</td><td style="text-align:center">和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td></tr><tr><td style="text-align:center">crend()</td><td style="text-align:center">和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td></tr></tbody></table><ul><li>注意，如果是 <em>const</em> 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素；</li><li>begin() 和 end() 为C++11新增，操作对象还可以是数组。</li></ul></li><li><p><strong>主要成员函数</strong></p><p>标粗部分是常用的函数。</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><strong>size</strong>()</td><td style="text-align:center"><strong>返回容器中当前元素的数量</strong></td></tr><tr><td style="text-align:center"><strong>capacity</strong>()</td><td style="text-align:center">返回当前容量</td></tr><tr><td style="text-align:center"><strong>reserve</strong>()</td><td style="text-align:center">增加容器的容量</td></tr><tr><td style="text-align:center">max_size()</td><td style="text-align:center">返回容器可容纳元素的最大数量</td></tr><tr><td style="text-align:center"><strong>empty</strong>()</td><td style="text-align:center"><strong>判断容器是否为空</strong>，和通过 <code>size()==0</code> 的判断条件功能相同，但其效率可能更快</td></tr><tr><td style="text-align:center"><strong>at(n</strong>)</td><td style="text-align:center"><strong>返回容器中 n 位置处元素的引用，作用类似[]</strong>，但该函数还会检查 n 是否有效，如果不是会抛出 <em>out_of_range</em> 异常</td></tr><tr><td style="text-align:center">front()</td><td style="text-align:center">返回容器中第一个元素的直接引用</td></tr><tr><td style="text-align:center">back()</td><td style="text-align:center">返回容器中最后一个元素的直接引用</td></tr><tr><td style="text-align:center"><strong>data</strong>()</td><td style="text-align:center"><strong>返回一个指向容器首个元素的指针</strong>，利用该指针可实现复制容器中所有元素等类似功能</td></tr><tr><td style="text-align:center"><strong>swap</strong>()</td><td style="text-align:center">交换两个容器的所有元素</td></tr></tbody></table><p>相比array独有的方法（可以尾部插入、删除元素等）：</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><strong>push_back</strong>()</td><td style="text-align:center">在容器的尾部添加一个元素</td></tr><tr><td style="text-align:center"><strong>pop_back</strong>()</td><td style="text-align:center">移出容器尾部的元素</td></tr><tr><td style="text-align:center"><strong>emplace_back</strong>()</td><td style="text-align:center">在容器的尾部添加一个元素</td></tr><tr><td style="text-align:center"><strong>erase</strong>()</td><td style="text-align:center">移出一个元素或一段元素，返回指向删除元素的下一个元素的迭代器</td></tr><tr><td style="text-align:center"><strong>clear</strong>()</td><td style="text-align:center">移出所有的元素，容器大小变为 0</td></tr></tbody></table></li></ul><blockquote><p>关于删除vector空间释放有些小问题。</p></blockquote><p><strong>clear</strong>()、<strong>erase</strong>()方法均不会释放<u>vector</u>所占用的内存空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    std::cout&lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;     <span class="comment">// 5</span></span><br><span class="line">    std::cout&lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>()+<span class="number">1</span>);</span><br><span class="line">    std::cout&lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;     <span class="comment">// 4</span></span><br><span class="line">    std::cout&lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 5 , capacity未改变</span></span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">clear</span>();</span><br><span class="line">    std::cout&lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;     <span class="comment">// 0</span></span><br><span class="line">    std::cout&lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 5 , capacity未改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因为vector内存占用空间只增不减</strong>：</p><ul><li>分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个；</li><li>所有内存空间，在<u>vector对象析构</u>时才能被系统回收。</li></ul><p>换句话说，<strong>clear</strong>()、<strong>erase</strong>()方法只是减少了vector的<code>size</code>大小，没有改变<code>capacity</code>。</p><p>我们可以借助<code>swap</code>方法彻底删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;().<span class="built_in">swap</span>(vec); <span class="comment">// swap</span></span><br><span class="line">    </span><br><span class="line">    std::cout&lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;     <span class="comment">// 0</span></span><br><span class="line">    std::cout&lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 0，彻底删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector&lt;int&gt;()</code>使用默认构造函数建立临时vector对象，再在该临时对象上调用swap成员；</li><li><code>swap</code>调用之后原来vector占用的空间就等于一个默认构造的对象的大小，而临时对象就具有原来对象<code>vec</code>的大小；</li><li>临时对象随即被析构，其占用的空间（原来<code>vec</code>的空间）也被释放。</li></ul><p>另一方面，会动态增长和<u>缩小</u>的容器，如<code>deque</code>，便没有上面烦扰：<strong>clear</strong>()、<strong>erase</strong>()方法删除元素后，其内存也随之缩减。</p><p>下节我们一起来认识下吧。</p><h4 id="deque">deque</h4><p>vector 可以在尾部快速添加和移除元素，虽然<u>理论上</u>也可以在头部进行操作，但因为其底层是一个<u>一维动态数组</u>，因此无论是添加和移除元素都涉及到<u>数组所有元素</u>的移动，效率都奇差，<strong>因此STL相关头部操作的方法<code>vector::push_front()</code>都没有提供</strong>。</p><p><strong>deque （双端队列）用于弥补 vector 的不足，在首尾两端都可以快速添加和删除，STL会提供头、尾插入、删除方法（vector头部操作效率低，STL只提供了尾部插入、删除相关方法</strong>），其直观形式表现如下：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/179596b3b6ad50d526ea30ce5a096f1b" alt="img"></p><p>不过这种“整体连续”是一种假象，deque底层实际实现为一个<u>二维动态数组</u> 。正式介绍其底层实现前，我们按老规矩先介绍容器上层封装和基本使用。</p><p>deque容器以类模板的形式定义在 <code>&lt;deque&gt;</code> 头文件，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, </span><br><span class="line">     <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">class deque : <span class="keyword">protected</span> _Deque_base&lt;_Tp, _Alloc&gt;</span><br></pre></td></tr></table></figure><p>在 <code>deque&lt;_Tp,_Alloc&gt;</code> 模板中：</p><ul><li><code>_Tp</code>，用于指明容器中元素数据类型；</li><li><code>_Alloc</code>，内存分配器，默认采用二级配置器，一般不用我们关心。</li></ul><p>简单使用实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;size = &quot;</span> &lt;&lt; d.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">    <span class="comment">// deque没有`capacity`()函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> first = d.<span class="built_in">begin</span>(); first != d.<span class="built_in">end</span>(); first++)</span><br><span class="line">    std::cout&lt;&lt;*first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; d &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d);  <span class="comment">// size = 5 : 0 1 2 3 4</span></span><br><span class="line">    </span><br><span class="line">    d.<span class="built_in">pop_back</span>();</span><br><span class="line">    d.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">printDeque</span>(d); <span class="comment">// size = 3 : 1 2 3  </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="底层实现-3">底层实现</h5><p>本节我们主要探讨以下问题：</p><ul><li>deque底层数据结构及实现？</li><li>deque底层迭代器如何定义？</li><li>deque什么时候进行扩容？如何扩容？</li><li>deque底层如何插入、删除一个数据？</li></ul><p><strong>我们先了解下deque类继承结构及核心成员（类似vector继承结构</strong>）。</p><p>注意到，deque继承了 <code>_Deque_base</code> ，<code>_Deque_base</code>专门负责vector的内存管理。</p><p><code>_Deque_base</code>核心是内部类<code>_Deque_impl</code> ，它继承了<code>_Tp_alloc_type</code>  获得内存分配释放的功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Deque_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      ...</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc::<span class="keyword">template</span> rebind&lt;_Tp&gt;::other  _Tp_alloc_type;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">Deque_impl</span>:</span> <span class="keyword">public</span> _Tp_alloc_type</span><br><span class="line">  &#123;</span><br><span class="line">      _Tp** _M_map;   <span class="comment">// map数组，其中的每个元素都是一个指针（节点），指向一块缓冲区</span></span><br><span class="line">      <span class="keyword">size_t</span> _M_map_size;</span><br><span class="line">      iterator _M_start;</span><br><span class="line">      iterator _M_finish;</span><br></pre></td></tr></table></figure><p><code>_Deque_impl</code>核心成员：</p><ul><li><p><code>_M_map</code>：二维动态数组map；</p></li><li><p><code>_M_start</code>，<code>_M_finish</code>：迭代器，start 迭代器记录着 map 数组中首个连续空间的信息，finish 迭代器记录着 map 数组中最后一个连续空间的信息。</p><p>deque的<code>begin()</code> 和 <code>end()</code> 方法就是通过他们实现的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _M_start; &#125;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _M_finish; &#125;</span><br></pre></td></tr></table></figure></li></ul><p>好了，现在我们可以依次回答节前的问题。</p><p><strong>我们先探讨第一个问题：deque底层数据结构及实现</strong>？</p><p>deque 容器用二维动态数组（数组名假设为 map）存储着各个连续空间的<u>首地址</u> ，每个连续空间是等长的内存缓存区域（下图中的strat和finish对应上面的<code>_M_start</code>和<code>_M_finish</code>）。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220217160103198.png" alt="image-20220217160103198"></p><p>所以第一个问题答案总结如下：deque底层数据结构就是一个二维数组<code>_Tp**</code> ，由<code>_Deque_impl</code>类负责相关内存分配。</p><p>最后补充一点deque类中<code>_Map_pointer</code>介绍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">class deque : <span class="keyword">protected</span> _Deque_base&lt;_Tp, _Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Deque_base&lt;_Tp, _Alloc&gt;           _Base;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base::_Tp_alloc_type _Tp_alloc_type;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> _Tp_alloc_type::pointer           pointer;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">      <span class="comment">// _Map_pointer，一个二级指针，指向二维数组map</span></span><br><span class="line">      <span class="keyword">typedef</span> pointer*                           _Map_pointer;</span><br></pre></td></tr></table></figure><p><code>_Map_pointer</code>是一个二维指针<u>类型</u>。</p><blockquote><p><code>_Map_pointer</code>其实就是<code>_Tp**</code>：</p><p>容易知道，<code>_Map_pointer</code> 是<code>_Deque_base&lt;_Tp, _Alloc&gt;::_Tp_alloc_type::pointer*</code> 别名；</p><ul><li><p>查看<code>_Tp_alloc_type</code>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Deque_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// _Alloc是模板参数设置的分配器，_Tp是模板参数的类型</span></span><br><span class="line">    <span class="comment">// _Tp_alloc_type是空间配置器的类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc::<span class="keyword">template</span> rebind&lt;_Tp&gt;::other  _Tp_alloc_type;</span><br></pre></td></tr></table></figure><p><code>_Tp_alloc_type</code> 就是<code>other</code>的别名，经过一番艰难的求知，在<a href="https://cloud.tencent.com/developer/article/1831752">三张图带你弄懂STL中内存分配器</a> 中确定：<code>other</code>类型其实是<code>allocator&lt;_Tp1&gt;</code>这个类型，如果我们传参为<code>int</code> 那就是<code>allocator&lt;int&gt;</code> 。</p></li><li><p>查看<code>pointer</code>定义：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220217151742421.png" alt="image-20220217151742421"></p></li></ul><p>所以，最终<code>pointer*</code> 等价于<code>__Tp**</code> ，如果我们传入的类型为<code>int</code>，那就是<code>int**</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pointer*   _Map_pointer;</span><br></pre></td></tr></table></figure></blockquote><p><strong>继续第二个问题：deque迭代器如何定义</strong>？</p><p>前面我们说过，<code>_M_start</code>，<code>_M_finish</code>都是<code>iterator</code>类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;</span><br></pre></td></tr></table></figure><p>查看<code>_Deque_iterator</code>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Ref, <span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Deque_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;</span><br><span class="line">      ...</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">typedef</span> _Tp**                           _Map_pointer;</span><br><span class="line">      <span class="keyword">typedef</span> _Deque_iterator                 _Self;</span><br><span class="line"></span><br><span class="line">      _Tp* _M_cur;   <span class="comment">// 可以看成是原生指针，表示当前的元素位置</span></span><br><span class="line">      _Tp* _M_first; <span class="comment">// 缓冲区开始处，可看成是第二维第一个元素的位置  </span></span><br><span class="line">      _Tp* _M_last;  <span class="comment">// 缓冲区末端的下一个位置，第二维的最后元素的下一个位置  </span></span><br><span class="line">      _Map_pointer _M_node; <span class="comment">// _M_node指向第一维  </span></span><br></pre></td></tr></table></figure><p>相比deque的迭代器底层实现 ，<code>vector</code>中的迭代器就底层封装了一个光溜溜的<code>_M_current</code>指针， 简单了很多：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220217181847136.png" alt="image-20220217181847136"></p><p><strong>第三个问题：deque什么时候进行扩容？如何扩容</strong>？</p><p>放一张图：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/2-19121316430U40.gif" alt="deque容器的底层实现"></p><p>deque何时及如何扩容一目了然：</p><ul><li>扩容时机：map数组已满；</li><li>扩容方式：再申请一块更大的连续空间供 map 数组使用，将原有数据（很多指针）拷贝到新的 map 数组中，然后释放旧map数组的空间（不释放map数组中的指针指向的空间）。</li></ul><p><strong>最后一个问题：deque底层如何插入、删除一个数据</strong>？</p><p>如果是插入操作，需分三种情况讨论：在容器的尾部插入、在容器的首部插入、在容器的指定位置前插入元素。这里仅以<u>在容器的尾部插入</u>为例分析。</p><ul><li><p>在容器的尾部插入</p><p>此时，<code>cur</code>指向的是含有实际值的下一个位置，<code>last</code>表示最后一个实际值的下一个位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(<span class="keyword">const</span> T&amp; t)</span><br></pre></td></tr></table></figure><ol><li>找到<code>finish</code>绑定的缓冲区，如果缓存区还有空闲位置（<code>start.cur!=start.last</code>），则在<code>cur</code>位置插入元素，并更新<code>cur++</code> ，否则转2；</li><li>没有空闲位置可以插入元素，则在<code>finish.node</code>（这是第一维）的后一个位置申请一个缓冲区（如果map满了，触发扩容），并将<code>finish</code>绑定到该新缓冲区，重复1中步骤插入元素。</li></ol></li></ul><p>删除操作类似，同样需要分三种情况：在容器的尾部删除、在容器的首部删除、在容器的指定位置前删除元素。这里仅以<u>在容器的尾部删除</u>为例分析。</p><ul><li><p>在容器的尾部删除</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pop_back</span>()</span><br></pre></td></tr></table></figure><ol><li><p>找到<code>finish</code>绑定的缓冲区，如果finish所绑定的缓冲区上有1个或多个元素，将最后一个有效元素析构即可destroy(–finish.cur)，否则转2；</p></li><li><p>finish所绑定的缓冲区为空，即<code>finish.cur==finish.first</code>：</p><ul><li><p>先将该空缓冲区的空间释放掉deallocate_node(finish.first)；</p></li><li><p>再将finish绑定到上一个map结点和缓冲区；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">finish.<span class="built_in">set_node</span>(finish.node<span class="number">-1</span>);</span><br><span class="line">finish.cur=finish.last<span class="number">-1</span>;</span><br></pre></td></tr></table></figure></li><li><p>最后将最后一个元素析（也是当前要删除的元素）构destroy(finish.cur)。</p></li></ul></li></ol><p><strong>从这里也可以看出，相比vector，deque确实会动态释放内存，不会只增不减</strong>。</p></li></ul><h5 id="成员函数-3">成员函数</h5><p>deque具有众多的成员函数，方便我们对deque进行各种操作。</p><p>我们先一睹为快。</p><ul><li><p><strong>迭代器相关</strong></p><p>同array，vector。</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">begin()</td><td style="text-align:center">返回指向容器中第一个元素的正向迭代器</td></tr><tr><td style="text-align:center">end()</td><td style="text-align:center">返回指向容器最后一个元素之后一个位置的正向迭代器</td></tr><tr><td style="text-align:center">rbegin()</td><td style="text-align:center">返回指向最后一个元素的反向迭代器</td></tr><tr><td style="text-align:center">rend()</td><td style="text-align:center">返回指向第一个元素之前一个位置的反向迭代器</td></tr><tr><td style="text-align:center">cbegin()</td><td style="text-align:center">和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td></tr><tr><td style="text-align:center">cend()</td><td style="text-align:center">和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td></tr><tr><td style="text-align:center">crbegin()</td><td style="text-align:center">和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td></tr><tr><td style="text-align:center">crend()</td><td style="text-align:center">和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td></tr></tbody></table><ul><li>注意，如果是 <em>const</em> 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素；</li><li>begin() 和 end() 为C++11新增，操作对象还可以是数组。</li></ul></li><li><p><strong>主要成员函数</strong></p><p>标粗部分是常用的函数。</p><ul><li>头、尾操作效率均高，所以会都提供<strong>push_front</strong>()  、<strong>push_front</strong>()等头、尾部等插入、删除方法。</li></ul><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><strong>size</strong>()</td><td style="text-align:center"><strong>返回容器中当前元素的数量</strong></td></tr><tr><td style="text-align:center"><s>capacity</s></td><td style="text-align:center"><s>deque没有该方法，vector有</s></td></tr><tr><td style="text-align:center"><s>reserve</s>()</td><td style="text-align:center"><s>deque没有该方法，vector有</s></td></tr><tr><td style="text-align:center">max_size()</td><td style="text-align:center">返回容器可容纳元素的最大数量</td></tr><tr><td style="text-align:center"><strong>empty</strong>()</td><td style="text-align:center"><strong>判断容器是否为空</strong>，和通过 <code>size()==0</code> 的判断条件功能相同，但其效率可能更快</td></tr><tr><td style="text-align:center"><strong>at(n</strong>)</td><td style="text-align:center"><strong>返回容器中 n 位置处元素的引用，作用类似[]</strong>，但该函数还会检查 n 是否有效，如果不是会抛出 <em>out_of_range</em> 异常</td></tr><tr><td style="text-align:center">front()</td><td style="text-align:center">返回容器中第一个元素的直接引用</td></tr><tr><td style="text-align:center">back()</td><td style="text-align:center">返回容器中最后一个元素的直接引用</td></tr><tr><td style="text-align:center"><s>data</s>()</td><td style="text-align:center"><s>deque没有该方法，vector有</s></td></tr><tr><td style="text-align:center"><strong>swap</strong>()</td><td style="text-align:center">交换两个容器的所有元素</td></tr></tbody></table><p>相比array独有的方法（可以<u>头、尾</u>部插入、删除元素等）：</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><strong>push_back</strong>()</td><td style="text-align:center">在容器的尾部添加一个元素</td></tr><tr><td style="text-align:center"><strong>emplace_back</strong>()</td><td style="text-align:center">在容器的尾部添加一个元素</td></tr><tr><td style="text-align:center"><strong>push_front</strong>()</td><td style="text-align:center">在容器的头部添加一个元素</td></tr><tr><td style="text-align:center"><strong>emplace_front</strong>()</td><td style="text-align:center">在容器头部生成一个元素</td></tr><tr><td style="text-align:center"><strong>erase</strong>()</td><td style="text-align:center">移出一个元素或一段元素，返回指向删除元素的下一个元素的迭代器</td></tr><tr><td style="text-align:center"><strong>clear</strong>()</td><td style="text-align:center">移出所有的元素，容器大小变为 0</td></tr><tr><td style="text-align:center"><strong>pop_back</strong>()</td><td style="text-align:center">移出容器尾部的元素</td></tr><tr><td style="text-align:center"><strong>pop_front</strong>()</td><td style="text-align:center">移除容器头部的元素</td></tr></tbody></table></li></ul><p>这些方法都比较简单，不过多介绍。</p><h4 id="list">list</h4><p>list容器的底层是用双向链表实现的，甚至一些 STL 版本中（比如 SGI STL），list 容器的底层实现使用的是双向循环链表。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/2-19121Q62J3329.gif" alt="img"></p><ul><li>a）双向链表，b）循环链表</li></ul><p><u>双链表</u>相比数组有很多好处：</p><ul><li><strong>插入和删除操作效率高（但查找效率低），头、尾插入/删除操作也是，所以STL会都提供了<code>push_front()</code>、<code>push_back()</code>等头、尾部操作方法</strong>；</li><li>扩展方便；</li><li>内存空间不要求连续，可充分利用空间；</li><li>…</li></ul><p>这些也是list所具有的优点。另外一个好处可能现在有点难以理解（后文会解释）：</p><ul><li>在vector中如果进行<u>插入</u>和<u>删除</u><u>操作</u>会导致<u>后续迭代器会失效</u>，而在List中：<u>插入</u>不会导致迭代器失效；删除也只会使得当前迭代器失效，后续迭代器不会失效。</li></ul><p>list容器以类模板的形式定义在 <code>&lt;list&gt;</code> 头文件，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp,</span><br><span class="line"> <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">class list : <span class="keyword">protected</span> _List_base&lt;_Tp, _Alloc&gt;</span><br></pre></td></tr></table></figure><p>在 <code>list&lt;_Tp,_Alloc&gt;</code> 模板中：</p><ul><li><code>_Tp</code>，用于指明容器中元素数据类型；</li><li><code>_Alloc</code>，内存分配器，默认采用二级配置器，一般不用我们关心。</li></ul><p>简单使用实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;size = &quot;</span> &lt;&lt; l.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">    <span class="comment">// list没有`capacity`()函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> first = l.<span class="built_in">begin</span>(); first != l.<span class="built_in">end</span>(); first++)</span><br><span class="line">    std::cout&lt;&lt;*first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="keyword">int</span>&gt; l &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    l.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    l.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printList</span>(l);  <span class="comment">// size = 5 : 0 1 2 3 4</span></span><br><span class="line">    </span><br><span class="line">    l.<span class="built_in">pop_back</span>();</span><br><span class="line">    l.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">printList</span>(l);  <span class="comment">// size = 3 : 1 2 3  </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>list</code>不止是链表还是双向链表，所以我们头、尾都是可以插入/删除的。</p><h5 id="底层实现-4">底层实现</h5><p>本节我们主要探讨以下问题：</p><ul><li>list底层数据结构及实现？</li><li>list底层迭代器如何定义？</li><li>list底层如何插入、删除一个数据？</li></ul><p><strong>我们先了解下list类继承结构及核心成员（类似vector、deque继承结构</strong>）。</p><p>注意到，list继承了 <code>_List_base</code> ，<code>_List_base</code>专门负责list的内存管理。</p><p><code>_List_base</code>核心是内部类<code>_List_impl</code> ，它继承了<code>_Tp_alloc_type</code>  获得内存分配释放的功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">List_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc::<span class="keyword">template</span> rebind&lt;_List_node&lt;_Tp&gt; &gt;::other</span><br><span class="line">        _Node_alloc_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc::<span class="keyword">template</span> rebind&lt;_Tp&gt;::other _Tp_alloc_type;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">List_impl</span>:</span> <span class="keyword">public</span> _Node_alloc_type</span><br><span class="line">    &#123;</span><br><span class="line">__detail::_List_node_base _M_node;  <span class="comment">// 头结点，不存储数据</span></span><br><span class="line"></span><br><span class="line">        _List_impl(): _Node_alloc_type(), _M_node()</span><br><span class="line">        &#123; &#125;</span><br><span class="line"></span><br><span class="line">    _List_impl(<span class="keyword">const</span> _Node_alloc_type&amp; __a): _Node_alloc_type(__a), _M_node()</span><br><span class="line">    &#123; &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;; <span class="comment">// _List_impl</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>_List_impl</code>核心成员：</p><ul><li><p><code>_M_node</code>：list头结点，不存储数据</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220217204035277.png" alt="image-20220217204035277"></p></li></ul><p>好了，现在我们可以依次回答节前的问题。</p><p><strong>第一个问题：list底层数据结构及实现</strong>？</p><p>list底层是链表，头结点为<code>_M_node</code>。头节点是<code>_List_node_base</code>类型，不存储数据。</p><p>但数据结点是<code>_List_node</code> 类型，存储数据。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220217204337102.png" alt="image-20220217204337102"></p><p>借助<code>_M_node</code>可以实现，list中几乎所有的成员函数。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220217212702954.png" alt="image-20220217212702954"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220217212735184.png" alt="image-20220217212735184"></p><p><strong>第二个问题：list底层迭代器如何定义</strong>？</p><p>在list类中，找到<code>iterator</code>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _List_iterator&lt;_Tp&gt;             iterator;</span><br></pre></td></tr></table></figure><p>其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 定义一堆别名</span></span><br><span class="line">    <span class="keyword">typedef</span> _List_iterator&lt;_Tp&gt;                _Self;</span><br><span class="line">    <span class="keyword">typedef</span> _List_node&lt;_Tp&gt;                    _Node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                          difference_type;</span><br><span class="line">    <span class="comment">// list为一个双向链表，迭代器必须具备前移、后移的能力，所以提供了bidirectional iterator</span></span><br><span class="line">    <span class="keyword">typedef</span> std::bidirectional_iterator_tag    iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                                value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp*                               pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp;                               reference;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 构造函数1：实例化头结点_M_node指针</span></span><br><span class="line">    _List_iterator(): _M_node() &#123; &#125;   </span><br><span class="line">    <span class="comment">// 构造函数2：给定值实例化</span></span><br><span class="line">     <span class="keyword">explicit</span> _List_iterator(__detail::_List_node_base* __x): _M_node(__x) &#123; &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>继续看看具体<code>_List_iterator</code>相关函数。</p><ul><li><p><code>operator++</code> 的后置自增，将当前 <code>_M_node</code> 移动到 <code>_M_node-&gt;_M_next</code> 所在的位置，并返回移动之后的迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _Self 是_List_iterator&lt;_Tp&gt; 一个类型别名</span></span><br><span class="line">_Self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">     _M_node = _M_node-&gt;_M_next;</span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>operator--</code>大同小异。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_Self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">_M_node = _M_node-&gt;_M_prev;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>最后一个问题：list底层如何插入、删除一个数据</strong>？</p><p>大致应该就是链表的插入、删除相关操作。这里有机会再补上吧。</p><h5 id="成员函数-4">成员函数</h5><p>list具有众多的成员函数，方便我们对list进行各种操作。</p><p>我们先一睹为快。</p><ul><li><p><strong>迭代器相关</strong></p><p>同array、vector，deque。</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">begin()</td><td style="text-align:center">返回指向容器中第一个元素的正向迭代器</td></tr><tr><td style="text-align:center">end()</td><td style="text-align:center">返回指向容器最后一个元素之后一个位置的正向迭代器</td></tr><tr><td style="text-align:center">rbegin()</td><td style="text-align:center">返回指向最后一个元素的反向迭代器</td></tr><tr><td style="text-align:center">rend()</td><td style="text-align:center">返回指向第一个元素之前一个位置的反向迭代器</td></tr><tr><td style="text-align:center">cbegin()</td><td style="text-align:center">和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td></tr><tr><td style="text-align:center">cend()</td><td style="text-align:center">和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td></tr><tr><td style="text-align:center">crbegin()</td><td style="text-align:center">和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td></tr><tr><td style="text-align:center">crend()</td><td style="text-align:center">和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td></tr></tbody></table><ul><li>注意，如果是 <em>const</em> 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素；</li><li>begin() 和 end() 为C++11新增，操作对象还可以是数组。</li></ul></li><li><p><strong>主要成员函数</strong></p><p>标粗部分是常用的函数。</p><ul><li><p>list底层是双链表，只有双向迭代器没有随机迭代器，一些随机迭代器才支持的方法，比如<code>at(n)</code>、<code>[n]</code>都是不支持的；</p></li><li><p>头、尾操作效率均高，所以会提供<strong>push_front</strong>()  、<strong>push_back</strong>()等头、尾部等插入、删除方法。</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><s>size</s>()</td><td style="text-align:center"><s>list没有，vector、deque有</s></td></tr><tr><td style="text-align:center"><s>capacity</s></td><td style="text-align:center"><s>list、deque没有该方法，vector有</s></td></tr><tr><td style="text-align:center"><s>reserve</s>()</td><td style="text-align:center"><s>list、deque没有该方法，vector有</s></td></tr><tr><td style="text-align:center">max_size()</td><td style="text-align:center">返回容器可容纳元素的最大数量</td></tr><tr><td style="text-align:center"><strong>empty</strong>()</td><td style="text-align:center"><strong>判断容器是否为空</strong>，和通过 <code>size()==0</code> 的判断条件功能相同，但其效率可能更快</td></tr><tr><td style="text-align:center"><s>at(n</s>)</td><td style="text-align:center"><s>不支持</s></td></tr><tr><td style="text-align:center">front()</td><td style="text-align:center">返回容器中第一个元素的直接引用</td></tr><tr><td style="text-align:center">back()</td><td style="text-align:center">返回容器中最后一个元素的直接引用</td></tr><tr><td style="text-align:center"><s>data</s>()</td><td style="text-align:center"><s>list、deque没有该方法，vector有</s></td></tr><tr><td style="text-align:center"><strong>swap</strong>()</td><td style="text-align:center">交换两个容器的所有元素</td></tr></tbody></table></li></ul><p>相比array独有的方法（可以<u>头、尾</u>部插入、删除元素等）：</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><strong>push_back</strong>()</td><td style="text-align:center">在容器的尾部添加一个元素</td></tr><tr><td style="text-align:center"><strong>emplace_back</strong>()</td><td style="text-align:center">在容器的尾部添加一个元素</td></tr><tr><td style="text-align:center"><strong>push_front</strong>()</td><td style="text-align:center">在容器的头部添加一个元素</td></tr><tr><td style="text-align:center"><strong>emplace_front</strong>()</td><td style="text-align:center">在容器头部生成一个元素</td></tr><tr><td style="text-align:center"><strong>erase</strong>()</td><td style="text-align:center">移出一个元素或一段元素，返回指向删除元素的下一个元素的迭代器</td></tr><tr><td style="text-align:center"><strong>clear</strong>()</td><td style="text-align:center">移出所有的元素，容器大小变为 0</td></tr><tr><td style="text-align:center"><strong>pop_back</strong>()</td><td style="text-align:center">移出容器尾部的元素</td></tr><tr><td style="text-align:center"><strong>pop_front</strong>()</td><td style="text-align:center">移除容器头部的元素</td></tr></tbody></table><p>相比deque新增（链表的一些操作方法）：</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">splice()</td><td style="text-align:center">将一个 list 容器中的元素插入到另一个容器的指定位置</td></tr><tr><td style="text-align:center">remove(val)</td><td style="text-align:center">删除容器中所有等于 val 的元素</td></tr><tr><td style="text-align:center">remove_if()</td><td style="text-align:center">删除容器中满足条件的元素</td></tr><tr><td style="text-align:center"><strong>unique</strong>()</td><td style="text-align:center">删除容器中相邻的重复元素，只保留一个</td></tr><tr><td style="text-align:center"><strong>merge</strong>()</td><td style="text-align:center">合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的</td></tr><tr><td style="text-align:center">sort()</td><td style="text-align:center">通过更改容器中元素的位置，将它们进行排序</td></tr><tr><td style="text-align:center"><strong>reverse</strong>()</td><td style="text-align:center">反转容器中元素的顺序</td></tr></tbody></table></li></ul><p>新增的函数有点意思，合适的时候进行补充。</p><h5 id="迭代器失效">迭代器失效</h5><p>分析“迭代器失效”这个问题前，我们先回忆一下各个容器的底层数据结构：</p><table><thead><tr><th style="text-align:center">容器</th><th style="text-align:center">底层数据结构</th><th style="text-align:center">对应的迭代器类型</th></tr></thead><tbody><tr><td style="text-align:center">array、vector、deque</td><td style="text-align:center">数组</td><td style="text-align:center">随机访问迭代器</td></tr><tr><td style="text-align:center">list、forward_list</td><td style="text-align:center">链表</td><td style="text-align:center">双向迭代器</td></tr><tr><td style="text-align:center">set / multiset / map / multimap</td><td style="text-align:center">红黑树</td><td style="text-align:center">双向迭代器</td></tr><tr><td style="text-align:center">stack / queue</td><td style="text-align:center">list 和 deque 实现，封闭头部</td><td style="text-align:center">不支持迭代器</td></tr></tbody></table><p>好了，让我们正式开始吧。</p><p>看下面这段看似无害的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">erase</span>(it);  <span class="comment">// 迭代器失效</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时却发生了错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><p><strong>这段代码对于list、vector、deque等容器都会出错（array例外，它没有<code>erase</code>()方法），究其原因就是出现迭代器失效</strong>。</p><ol><li>迭代器<code>it</code> 初始化指向了第一个元素，判断条件成立进入循环体；</li><li>执行<code>vec.erase(it</code>)，<code>it</code>被删除；</li><li>执行<code>it++</code>出错，<code>it</code>已失效无法递增。</li></ol><p>得益于<code>erase</code>方法的返回值是下一个有效的 <code>iterator</code>，解决办法也很简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); )</span><br><span class="line">    &#123;</span><br><span class="line">        it = vec.<span class="built_in">erase</span>(it);  <span class="comment">// 迭代器失效</span></span><br><span class="line">        <span class="comment">// it++;  // it已经是下一个迭代器了不用++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者：</p><blockquote><p>⚠️ 关联容器：map、set、multimap、multiset等可以使用两种方式，但list、vector、deque无法使用下面这种方式，否则会出错（为啥？）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; map1;</span><br><span class="line">    map1.<span class="built_in">emplace</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    map1.<span class="built_in">emplace</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=map1.<span class="built_in">begin</span>(); it != map1.<span class="built_in">end</span>(); )</span><br><span class="line">    &#123;</span><br><span class="line">        map1.<span class="built_in">erase</span>(it++);  <span class="comment">// 迭代器失效</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>it++</code>会复制一个<code>it</code>副本传递给<code>erase()</code> 函数；</li><li><code>it</code>执行<code>++</code>操作；</li><li>最后再执行<code>erase()</code>将 复制的<code>it</code>副本删除，它和<code>it</code>指向同一元素，所以最后<code>it</code>还是失效了。</li></ol><p><strong>迭代器失效总结如下</strong>：</p><ul><li>如果底层数据结构是一维数组的（vector）<ul><li>插入操作：插入位置及之后的迭代器都失效，因为插入位置后的所有元素都需要移动；如果还触发了扩容，则所有迭代器都失效；</li><li>删除操作：删除位置及之后的迭代器都失效，因为删除位置之后的元素都需移动；</li></ul></li><li>如果底层数据结构是二维数组的（deque）<ul><li>插入操作：首部或者尾部插入不会使迭代器失效，因为不影响其它元素位置，中间插入会使得所有迭代器失效，因为所有元素都被影响要移动；</li><li>删除操作：部或尾部删除元素只会使得被删除位置的迭代器失效，中间删除会使得所有迭代器失效，原因同上。</li></ul></li><li>如果底层数据结构是链表的（list、forward_list）<ul><li>插入操作：节点无需移动，所有迭代器有效；</li><li>删除操作：节点无需移动，仅删除的节点迭代器失效。</li></ul></li><li>如果底层数据结构是红黑树的（set / multiset / map / multimap）<ul><li>插入操作：不影响其它节点，所有迭代器有效；</li><li>删除操作：不影响其它节点，仅删除的节点迭代器失效。</li></ul></li></ul><h4 id="forward-list">forward_list</h4><p>forward_list底层实现和list一样，都是链表，但是forward_list使用的是单链表，而list是双链表。</p><p>单链表相比双链表灵活性<u>差了</u>很多：</p><ul><li><u>尾部</u>插入、删除操作效率低；</li><li>只能前向遍历，不能反向遍历（因此forward_list只有前向迭代器，而且不会具有 rbegin()、rend() 之类的成员函数）；</li><li>…</li></ul><p><u>但是单链表空间利用利用率更高</u>（node不用保存前向指针），而且遵循<a href="https://zh.wikipedia.org/zh-hans/%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80">奥卡姆剃刀</a>原则：“若无必要，勿增实体”——在诸多可以满足需求的结构中，选择影响范围最小的。</p><p>所以只要是 list 容器和 forward_list 容器都能实现的操作，应优先选择 forward_list 容器。</p><p>forward_list 容器以类模板的形式定义在 <code>&lt;forward_list &gt;</code> 头文件，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, </span><br><span class="line"> <span class="keyword">typename</span> _Alloc = allocator&lt;_Tp&gt; &gt;</span><br><span class="line">class forward_list : <span class="keyword">private</span> _Fwd_list_base&lt;_Tp, _Alloc&gt;</span><br></pre></td></tr></table></figure><p>在 <code>forward_list&lt;_Tp,_Alloc&gt;</code> 模板中：</p><ul><li><code>_Tp</code>，用于指明容器中元素数据类型；</li><li><code>_Alloc</code>，内存分配器，默认采用二级配置器，一般不用我们关心。</li></ul><p>简单使用实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> forward_list&lt;<span class="keyword">int</span>&gt;&amp; fl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// forward_list 没有size()方法</span></span><br><span class="line">    <span class="comment">// 用distance方法实现</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;size = &quot;</span> &lt;&lt; std::<span class="built_in">distance</span>(std::<span class="built_in">begin</span>(fl), std::<span class="built_in">end</span>(fl)) &lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">    <span class="comment">// forward_list 没有capacity()函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> first = fl.<span class="built_in">begin</span>(); first != fl.<span class="built_in">end</span>(); first++)</span><br><span class="line">    std::cout&lt;&lt;*first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">forward_list&lt;<span class="keyword">int</span>&gt; fl &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">// fl.emplace_front(4);  // 底层是单链表，不支持尾部相关操作的函数/迭代器</span></span><br><span class="line">    fl.<span class="built_in">emplace_front</span>(<span class="number">0</span>); <span class="comment">// 头部插入，尾部不行</span></span><br><span class="line">    <span class="built_in">printList</span>(fl);    <span class="comment">// size = 4 : 0 1 2 3 </span></span><br><span class="line">    </span><br><span class="line">    fl.<span class="built_in">pop_front</span>();   <span class="comment">// 头部删除</span></span><br><span class="line">    <span class="built_in">printList</span>(fl);    <span class="comment">// size = 3 : 1 2 3  </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到：</p><ul><li>forward_list只能头部进行了插入等操作，不能在尾部；</li><li>forward_list没有size方法，只能用distance方法实现。</li></ul><h5 id="底层实现-5">底层实现</h5><p>本节我们主要探讨以下问题：</p><ul><li>forward_list底层数据结构及实现？</li><li>forward_list底层迭代器如何定义？</li><li>forward_list底层如何插入、删除一个数据？</li></ul><p>forward_list底层实现和list极为相似，这里直接给出关键答案。</p><ul><li><p><strong>forward_list底层数据结构及实现</strong>？</p><p>forward_list底层是但链表，头结点为<code>_M_head</code>。头节点是<code>_Fwd_list_node_base</code>类型，不存储数据。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220218115621414.png" alt="image-20220218115621414"></p></li><li><p><strong>forward_list底层迭代器如何定义</strong>？</p><p>没啥好说的，和list差不多。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220218115822591.png" alt="image-20220218115822591"></p></li><li><p><strong>forward_list底层如何插入、删除一个数据</strong>？</p><p>就是单链表相关的操作，有头结点操作比较统一。</p></li></ul><h5 id="成员函数-5">成员函数</h5><p>forward_list具有众多的成员函数，方便我们对forward_list进行各种操作。</p><p>我们先一睹为快。</p><ul><li><p><strong>迭代器相关</strong></p><p>和array、vector、deque，list不同，forward_list没有尾部相关迭代器函数。</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">begin()</td><td style="text-align:center">返回指向容器中第一个元素的正向迭代器</td></tr><tr><td style="text-align:center">end()</td><td style="text-align:center">返回指向容器最后一个元素之后一个位置的正向迭代器</td></tr><tr><td style="text-align:center">cbegin()</td><td style="text-align:center">和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td></tr><tr><td style="text-align:center">cend()</td><td style="text-align:center">和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td></tr></tbody></table><ul><li>注意，如果是 <em>const</em> 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素；</li><li>begin() 和 end() 为C++11新增，操作对象还可以是数组。</li></ul></li><li><p><strong>主要成员函数</strong></p><p>标粗部分是常用的函数。</p><ul><li>list、forward_list底层是链表，没有随机迭代器，一些随机迭代器才支持的方法，比如at(n)都是不支持的；</li><li>forward_list底层是单链表，只有头部操作效率高，<u>所以尾部操作相关的方法<code>push_back()</code>等STL不提供</u>；</li></ul><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><s>size</s>()</td><td style="text-align:center">forward_list不支持，可用<code>std::distance()</code> 方法间接实现</td></tr><tr><td style="text-align:center"><s>capacity</s></td><td style="text-align:center"><s>forward_list、list、deque没有该方法，vector有</s></td></tr><tr><td style="text-align:center"><s>reserve</s>()</td><td style="text-align:center"><s>forward_list、list、deque没有该方法，vector有</s></td></tr><tr><td style="text-align:center">max_size()</td><td style="text-align:center">返回容器可容纳元素的最大数量</td></tr><tr><td style="text-align:center"><strong>empty</strong>()</td><td style="text-align:center"><strong>判断容器是否为空</strong>，和通过 <code>size()==0</code> 的判断条件功能相同，但其效率可能更快</td></tr><tr><td style="text-align:center"><s>at(n</s>)</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">front()</td><td style="text-align:center">返回容器中第一个元素的直接引用</td></tr><tr><td style="text-align:center"><s>data</s>()</td><td style="text-align:center"><s>forward_list、list、deque没有该方法，vector有</s></td></tr><tr><td style="text-align:center"><strong>swap</strong>()</td><td style="text-align:center">交换两个容器的所有元素</td></tr></tbody></table><p>相比array独有的方法（可以<u>头部</u>插入、删除元素等）：</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><strong>push_front</strong>()</td><td style="text-align:center">在容器的头部添加一个元素</td></tr></tbody></table></li></ul><p>| <strong>emplace_front</strong>() |                    在容器头部生成一个元素                    |<br>|     <strong>erase</strong>()     | 移出一个元素或一段元素，返回指向删除元素的下一个元素的迭代器 |<br>|     <strong>clear</strong>()     |                移出所有的元素，容器大小变为 0                |<br>|   <strong>pop_front</strong>()   |                      移除容器头部的元素                      |</p><p>相比deque新增（链表相关方法）：</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">splice()</td><td style="text-align:center">将一个 forward_list容器中的元素插入到另一个容器的指定位置</td></tr><tr><td style="text-align:center">remove(val)</td><td style="text-align:center">删除容器中所有等于 val 的元素</td></tr><tr><td style="text-align:center">remove_if()</td><td style="text-align:center">删除容器中满足条件的元素</td></tr><tr><td style="text-align:center"><strong>unique</strong>()</td><td style="text-align:center">删除容器中相邻的重复元素，只保留一个</td></tr><tr><td style="text-align:center"><strong>merge</strong>()</td><td style="text-align:center">合并两个事先已排好序的 forward_list容器，并且合并之后的 forward_list容器依然是有序的</td></tr><tr><td style="text-align:center">sort()</td><td style="text-align:center">通过更改容器中元素的位置，将它们进行排序</td></tr><tr><td style="text-align:center"><strong>reverse</strong>()</td><td style="text-align:center">反转容器中元素的顺序</td></tr></tbody></table><h3 id="9-2-2-关联式容器">9.2.2 关联式容器</h3><p>序列式容器元素是顺序存储的，而“关联式容器”是以键值对方式存储的，顾名思义每个元素都会和一个“键”相关联的。这种特性简单解释来说，就是查找到“键”就可以查找到相关元素。</p><p><strong>在底层实现中，关联容器的“键值对”采用红黑树来存储</strong>，这使得可以很方便地实现排序，所以关联式容器的元素都会<u>按照键值的大小做升序排序</u>。</p><p>本节主要探讨以下容器：</p><blockquote><p>除此之外，C++ 11 还新增了 4 种哈希容器，即 unordered_map、unordered_multimap 以及 unordered_set、unordered_multiset。严格来说，它们也属于关联式容器，但由于哈希容器底层采用的是哈希表，而不是红黑树，放在下节<u>9.2.3</u>讲解。</p></blockquote><table><thead><tr><th style="text-align:center">容器</th><th style="text-align:center">底层数据结构</th><th style="text-align:center">特点</th><th style="text-align:center">迭代器类型</th></tr></thead><tbody><tr><td style="text-align:center">map</td><td style="text-align:center">红黑树，下同</td><td style="text-align:center">键必须唯一，会根据键大小默认升序排序</td><td style="text-align:center">双向迭代器，下同</td></tr><tr><td style="text-align:center">multimap</td><td style="text-align:center"></td><td style="text-align:center">基本同map，但multimap 键可重复</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">set</td><td style="text-align:center"></td><td style="text-align:center">键和值完全相同，键依旧唯一，默认升序</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">multiset</td><td style="text-align:center"></td><td style="text-align:center">基本同set，但multiset 键可重复</td><td style="text-align:center"></td></tr></tbody></table><h4 id="pair">pair</h4><p>我们知道，关联式容器存储的是“键值对”形式的数据，即<code>&lt;key,value&gt;</code>形式。</p><p>C++STL专门提供了pair类模板，用来封装“键值对”这种形式的数据。</p><p>它被定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="keyword">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      _T1 first;</span><br><span class="line">      _T2 second;</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure><p>使用起来也很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    pair&lt;<span class="keyword">int</span>,string&gt; kv1&#123;<span class="number">1</span>,<span class="string">&quot;一&quot;</span>&#125;;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,string&gt; kv2&#123;<span class="number">2</span>,<span class="string">&quot;二&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改  </span></span><br><span class="line">    kv1.first = <span class="number">-1</span>;</span><br><span class="line">    kv1.second =<span class="string">&quot;负一&quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较:键值对完全相关返回true，否则false</span></span><br><span class="line">    <span class="keyword">bool</span> is_equal = kv1 == kv2 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// swap交换键值对</span></span><br><span class="line">    kv1.<span class="built_in">swap</span>(kv2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你还可以使用<code>make_pair</code> 来创建<code>pair</code>对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>,string&gt; kv3&#123;<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&quot;三&quot;</span>)&#125;;</span><br></pre></td></tr></table></figure><p>后面我们会大量用到这种方式创建<code>pair</code>对象。</p><h4 id="map">map</h4><p>作为关联式容器的一种，map用 <code>pair</code> 类模板创建键值对，底层结构是红黑树而且还会根据各键值对的键的大小，进行升序排序。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220218142932775.png" alt="image-20220218142932775"></p><p>map容器以类模板形式定义在 <code>&lt;map&gt;</code> 头文件，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Key, </span><br><span class="line">  <span class="keyword">typename</span> _Tp, </span><br><span class="line">          <span class="keyword">typename</span> _Compare = std::less&lt;_Key&gt;,</span><br><span class="line">          <span class="keyword">typename</span> _Alloc = std::allocator&lt;std::pair&lt;<span class="keyword">const</span> _Key, _Tp&gt; &gt; &gt;</span><br><span class="line">class map</span><br></pre></td></tr></table></figure><p>在 <code>map&lt;_Key,_Tp,_Compare,_Alloc&gt;</code> 模板中：</p><ul><li><code>_Key</code>，指定键的类型；</li><li><code>_Tp</code>，指定值的类型；</li><li><code>_Compare</code>：指定排序顺序，默认选用升序<code>std::less&lt;_Key&gt;</code>，也可以选用<code>std::greater&lt;_Key&gt;</code> 或者自定义排序规则；</li><li><code>_Alloc</code>，默认选用二级内存分配器。</li></ul><p><strong>特别的，关联式容器（如map）的键值key都是不能修改的，只能通过：先手动删除键值对，再插入，这种间接的方式修改</strong>。</p><blockquote><p>假设关联容器允许修改键值的，因为其底层是红黑树：</p><ol><li>首先需要删除该键，然后调节平衡</li><li>再插入修改后的键值，再调节平衡</li></ol><p>如此一来，严重破坏了红黑树的结构，导致iterator失效，不知道应该指向之前的位置，还是指向改变后的位置。所以STL中将关联式容器的迭代器设置成const，不允许修改迭代器的值。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> map1 = std::map&lt;<span class="keyword">int</span>,std::string&gt; &#123; std::<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="string">&quot;一&quot;</span>),std::<span class="built_in">make_pair</span>(<span class="number">2</span>,<span class="string">&quot;二&quot;</span>)&#125;;</span><br><span class="line"></span><br><span class="line">map1.<span class="built_in">find</span>(<span class="string">&quot;two&quot;</span>)-&gt;first  = <span class="number">0</span>; <span class="comment">// error，不允许修改</span></span><br></pre></td></tr></table></figure><p>一个简单使用实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span>   </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="keyword">const</span> map&lt;<span class="keyword">int</span>,string&gt;&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;size = &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">    <span class="comment">// 打印键值对</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = m.<span class="built_in">begin</span>(); iter != m.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;&lt;key=&quot;</span>&lt;&lt; iter-&gt;first &lt;&lt;<span class="string">&quot;, value=&quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot;&gt; &quot;</span>; </span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make_pair</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>,std::string&gt; map1 &#123; std::<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="string">&quot;一&quot;</span>),std::<span class="built_in">make_pair</span>(<span class="number">2</span>,<span class="string">&quot;二&quot;</span>)&#125;;</span><br><span class="line">    map1[<span class="number">1</span>]; <span class="comment">// &quot;一&quot;</span></span><br><span class="line">    map1[<span class="number">2</span>]; <span class="comment">// &quot;二&quot;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    map1.<span class="built_in">emplace</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="string">&quot;零&quot;</span>));</span><br><span class="line">    map1.<span class="built_in">emplace</span>(std::<span class="built_in">make_pair</span>(<span class="number">4</span>,<span class="string">&quot;四&quot;</span>));</span><br><span class="line">    <span class="built_in">printMap</span>(map1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    map1.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">    map1.<span class="built_in">erase</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printMap</span>(map1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，map初始化还可以简化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>,std::string&gt; map1 &#123; &#123;<span class="number">1</span>,<span class="string">&quot;一&quot;</span>&#125;,&#123;<span class="number">2</span>,<span class="string">&quot;二&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>输出（注意打印出来的顺序按key升序打印的）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">size = 4 : &lt;key=0, value=零&gt; &lt;key=1, value=一&gt; &lt;key=2, value=二&gt; &lt;key=4, value=四&gt; </span><br><span class="line">size = 3 : &lt;key=0, value=零&gt; &lt;key=1, value=一&gt; &lt;key=2, value=二&gt; </span><br></pre></td></tr></table></figure><h5 id="成员函数-6">成员函数</h5><p>map具有众多的成员函数，方便我们对map进行各种操作。</p><p>我们先一睹为快。</p><ul><li><p><strong>迭代器相关</strong></p><p>同array、vector，deque、list。</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">begin()</td><td style="text-align:center">返回指向容器中第一个元素的正向迭代器</td></tr><tr><td style="text-align:center">end()</td><td style="text-align:center">返回指向容器最后一个元素之后一个位置的正向迭代器</td></tr><tr><td style="text-align:center">rbegin()</td><td style="text-align:center">返回指向最后一个元素的反向迭代器</td></tr><tr><td style="text-align:center">rend()</td><td style="text-align:center">返回指向第一个元素之前一个位置的反向迭代器</td></tr><tr><td style="text-align:center">cbegin()</td><td style="text-align:center">和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td></tr><tr><td style="text-align:center">cend()</td><td style="text-align:center">和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td></tr><tr><td style="text-align:center">crbegin()</td><td style="text-align:center">和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td></tr><tr><td style="text-align:center">crend()</td><td style="text-align:center">和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td></tr></tbody></table><ul><li>注意，如果是 <em>const</em> 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素；</li><li>begin() 和 end() 为C++11新增，操作对象还可以是数组。</li></ul></li><li><p><strong>主要成员函数</strong></p><p>标粗部分是常用的函数。</p><ul><li>关联容器虽然底层也是双向迭代器，不是随机迭代器，一些随机迭代器才支持的方法，<strong>比如<code>at(n)</code>、<code>[n]</code>是不支持的，但支持按键值查找<code>at(key)</code>、<code>[key]</code>方法</strong>；</li><li><strong>关联容器不能在指定位置上删除、插入元素</strong>，所以STL没有提供<code>push_back()</code>、<code>push_front()</code>之类头尾操作方法，而是使用<code>emplace()</code> 或<code>insert()</code>。</li></ul><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><strong>empty</strong>()</td><td style="text-align:center">若容器为空，则返回 true；否则 false</td></tr><tr><td style="text-align:center"><strong>size</strong>()</td><td style="text-align:center">返回当前 map 容器中存有键值对的个数</td></tr><tr><td style="text-align:center">max_size()</td><td style="text-align:center">返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同</td></tr><tr><td style="text-align:center"><strong>operator</strong>[key]</td><td style="text-align:center">map容器重载了 [] 运算符，获取指定键的值，<strong>查找失败添加新的键值对</strong></td></tr><tr><td style="text-align:center"><strong>at</strong>(key)</td><td style="text-align:center">找到 map 容器中 key 键对应的值，<strong>查找失败引发 out_of_range 异常</strong></td></tr><tr><td style="text-align:center"><strong>insert</strong>()</td><td style="text-align:center">向 map 容器中插入键值对，<strong>如果key重复会覆盖</strong></td></tr><tr><td style="text-align:center"><strong>erase</strong>()</td><td style="text-align:center">删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对</td></tr><tr><td style="text-align:center"><strong>swap</strong>()</td><td style="text-align:center">交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td></tr><tr><td style="text-align:center">clear()</td><td style="text-align:center">清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0</td></tr><tr><td style="text-align:center"><strong>emplace</strong>()</td><td style="text-align:center">基本同insert，但相比insert效率更高</td></tr><tr><td style="text-align:center">count(key)</td><td style="text-align:center">在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。</td></tr></tbody></table><p>相比序列容器，关联容器独有的一些函数：</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><strong>find</strong>(key)</td><td style="text-align:center">在 map 容器中查找键为 key 的键值对，<strong>找到返回对应迭代器（和at、[]不同，不是返回value</strong>），如果没找到返回和 end() 方法一样的迭代器</td></tr><tr><td style="text-align:center">lower_bound(key)</td><td style="text-align:center">返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器，如果没找到返回和 end() 方法一样的迭代器</td></tr><tr><td style="text-align:center">upper_bound(key)</td><td style="text-align:center">类似上，不过返回的是第一个大于 key的（不包含等于）</td></tr></tbody></table></li></ul><p>简单对比下<code>operator[key]</code> 和<code>at(key)</code> 这两种查询key的方式。</p><p>注意到，<code>operator[key]</code> 如果没查找到key，还会直接给map插入当前未查找到的key。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 空map</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>,std::string&gt; map1 &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// at(key)</span></span><br><span class="line">    <span class="comment">// map1.at(1); // error程序终止，抛出异常</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [key]</span></span><br><span class="line">    map1[<span class="number">1</span>];</span><br><span class="line">    std::cout&lt;&lt; map1.<span class="built_in">begin</span>()-&gt;first &lt;&lt;<span class="string">&quot;,&quot;</span> &lt;&lt; map1.<span class="built_in">begin</span>()-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器自动初始化了value：如果是基本数据类型，则值为 0；如果是 string 类型，其值为 “”，即空字符串。</p><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">1,&quot;&quot;</span><br></pre></td></tr></table></figure><h5 id="底层实现-6">底层实现</h5><p>本节我们主要探讨以下问题：</p><ul><li>map底层数据结构及实现？</li><li>map底层迭代器如何定义？</li><li>map底层如何插入、删除一个数据？</li></ul><p>本节只做简单分析。</p><p><strong>map底层数据结构及实现</strong>？</p><p>前面我们说过，map底层是红黑树，可以在map代码中验证：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Compare = std::less&lt;_Key&gt;,</span><br><span class="line"><span class="keyword">typename</span> _Alloc = std::allocator&lt;std::pair&lt;<span class="keyword">const</span> _Key, _Tp&gt; &gt; &gt;</span><br><span class="line">class map</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Key    key_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp     mapped_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;<span class="keyword">const</span> _Key, _Tp&gt;     value_type;</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc::<span class="keyword">template</span> rebind&lt;value_type&gt;::other _Pair_alloc_type;</span><br><span class="line">    <span class="comment">// 红黑树模板类</span></span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree&lt;key_type, value_type, _Select1st&lt;value_type&gt;, key_compare, _Pair_alloc_type&gt; _Rep_type;  </span><br><span class="line">   <span class="comment">/// The actual tree structure.</span></span><br><span class="line">   _Rep_type _M_t; <span class="comment">// map底层的红黑树 </span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>具体展开就是对红黑树的分析了，大致了解到这就行。</p><p><strong>map底层迭代器如何定义</strong>？</p><p>map中迭代器使用的是红黑中的迭代器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Rep_type::iterator   iterator;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> _<span class="title">Rb_tree_color</span> &#123;</span> _S_red = <span class="literal">false</span>, _S_black = <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Rb_tree_node_base</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree_node_base* _Base_ptr;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> _Rb_tree_node_base* _Const_Base_ptr;</span><br><span class="line"></span><br><span class="line">    _Rb_tree_color_M_color;</span><br><span class="line">    _Base_ptr_M_parent;  <span class="comment">// 父指针</span></span><br><span class="line">    _Base_ptr_M_left;    <span class="comment">// 左指针</span></span><br><span class="line">    _Base_ptr_M_right;   <span class="comment">// 右指针</span></span><br></pre></td></tr></table></figure><p><strong>map底层如何插入、删除一个数据</strong>？</p><p>主要是红黑树相关删除、插入操作。</p><h4 id="multimap">multimap</h4><p>multimap 容器具有和 map 极为相似的特性：</p><ul><li>multimap 容器的类模板也定义在<code>&lt;map&gt;</code>头文件；</li><li>也按键值对方式存储数据，底层也是红黑树结构；</li><li>会根据键值升序排序元素；</li><li>成员函数大部分相同；</li><li>键值无法修改；</li><li>…</li></ul><p>主要的不同体现在：</p><ul><li>multimap 可以同时<u>存储多个键相同的键值对</u>；</li><li>multimap 除了<code>find(key)</code>，不能使用<code>at(key)</code> 或 <code>operator[key]</code> 等<u>直接按key获取value的方式</u>（很好理解，multimap会存在多个重复的键）。</li></ul><p>multimap 也定义在 <code>&lt;map&gt;</code> 头文件，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Key, </span><br><span class="line">  <span class="keyword">typename</span> _Tp, </span><br><span class="line">  <span class="keyword">typename</span> _Compare = std::less&lt;_Key&gt;,</span><br><span class="line">  <span class="keyword">typename</span> _Alloc = std::allocator&lt;std::pair&lt;<span class="keyword">const</span> _Key, _Tp&gt; &gt; &gt;</span><br><span class="line">class multimap </span><br></pre></td></tr></table></figure><p>在 <code>multimap &lt;_Key,_Tp,_Compare,_Alloc&gt;</code> 模板中：</p><ul><li><code>_Key</code>，指定键的类型；</li><li><code>_Tp</code>，指定值的类型；</li><li><code>_Compare</code>：指定排序顺序，默认选用升序<code>std::less&lt;_Key&gt;</code>，也可以选用<code>std::greater&lt;_Key&gt;</code> 或者自定义排序规则；</li><li><code>_Alloc</code>，默认选用二级内存分配器。</li></ul><p>一个简单使用实例（使用起来和map很相似）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span>   </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMMap</span><span class="params">(<span class="keyword">const</span> multimap&lt;<span class="keyword">int</span>,string&gt;&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;size = &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">    <span class="comment">// 打印键值对</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = m.<span class="built_in">begin</span>(); iter != m.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;&lt;key=&quot;</span>&lt;&lt; iter-&gt;first &lt;&lt;<span class="string">&quot;, value=&quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot;&gt; &quot;</span>; </span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make_pair</span></span><br><span class="line">    multimap&lt;<span class="keyword">int</span>,std::string&gt; mmap1 &#123; std::<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="string">&quot;一&quot;</span>),std::<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="string">&quot;壹&quot;</span>)&#125;; <span class="comment">// 键值相同，都是1</span></span><br><span class="line">    <span class="comment">// map1[1] = &quot;one&quot;; // error，无法修改键值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    mmap1.<span class="built_in">emplace</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="string">&quot;零&quot;</span>));</span><br><span class="line">    mmap1.<span class="built_in">emplace</span>(std::<span class="built_in">make_pair</span>(<span class="number">4</span>,<span class="string">&quot;四&quot;</span>));</span><br><span class="line">    <span class="built_in">printMMap</span>(mmap1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    mmap1.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">    mmap1.<span class="built_in">erase</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printMMap</span>(mmap1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出（自动排序）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">size = 4 : &lt;key=0, value=零&gt; &lt;key=1, value=一&gt; &lt;key=1, value=壹&gt; &lt;key=4, value=四&gt; </span><br><span class="line">size = 3 : &lt;key=0, value=零&gt; &lt;key=1, value=一&gt; &lt;key=1, value=壹&gt; </span><br></pre></td></tr></table></figure><p><strong>关于成员函数</strong></p><p>multimap的成员函数，除了不能使用<code>at(key)</code>、<code>operator[key]</code> ，基本和map一致，故不单列了。</p><h4 id="set">set</h4><p>map和set都是以红黑树作为底层数据结构，所以外部表现的也极为相似：</p><ul><li>不允许出现键值重复；</li><li>所有的元素都会被自动排序；</li><li>不能通过迭代器来改变set的值，因为set的值就是键（关联容器的键值不允许修改）；</li><li>成员函数极为类似；</li><li>…</li></ul><p>主要区别在于：</p><ul><li><strong>set容器存储的键值对（key-value）的key、value完全相同。在底层实现上，map底层区别也主要是修改红黑树存储的key、value保存一致</strong>；</li><li>set容器除了<code>find(key)</code>，不能使用<code>at(key)</code> 或 <code>operator[key]</code>获取value ，虽然在底层实现上set的key等于value，<u>但是不允许获取value</u>。</li></ul><p>对于第一个区别，我们查看set容器底层实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Compare = std::less&lt;_Key&gt;,</span><br><span class="line"><span class="keyword">typename</span> _Alloc = std::allocator&lt;_Key&gt; &gt;</span><br><span class="line">class set</span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">typedef</span> _Key     key_type;  </span><br><span class="line">      <span class="keyword">typedef</span> _Key     value_type; <span class="comment">// 和key_type一样</span></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc::<span class="keyword">template</span> rebind&lt;_Key&gt;::other _Key_alloc_type;</span><br><span class="line">      <span class="comment">// 和map几乎一致</span></span><br><span class="line">      <span class="comment">// 唯一区别在于红黑树类模板参数key_type和value_type其实是一样的</span></span><br><span class="line">      <span class="comment">// 初始化时它们的值也一样</span></span><br><span class="line">      <span class="keyword">typedef</span> _Rb_tree&lt;key_type, value_type, _Identity&lt;value_type&gt;,</span><br><span class="line">       key_compare, _Key_alloc_type&gt; _Rep_type;</span><br><span class="line">     _Rep_type _M_t;  <span class="comment">// Red-black tree representing set.</span></span><br></pre></td></tr></table></figure><p>可以看到，底层实现上key、value的类型、值都会被设置为一样。set 容器类模板的定义中，也仅提供第 1 个参数（<code>_Key</code>）用于设定存储数据的类型。</p><p>set 容器以类模板形式定义在 <code>&lt;set&gt;</code> 头文件，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, </span><br><span class="line"> <span class="keyword">typename</span> _Compare = std::less&lt;_Key&gt;,</span><br><span class="line">         <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Key&gt; &gt;loc = std::allocator&lt;std::pair&lt;<span class="keyword">const</span> _Key, _Tp&gt; &gt; &gt;</span><br><span class="line">class set</span><br></pre></td></tr></table></figure><p>在 <code>set&lt;_Key,_Compare,_Alloc&gt;</code> 模板中：</p><ul><li><code>_Key</code>，指定键的类型；</li><li><code>_Compare</code>：指定排序顺序，默认选用升序<code>std::less&lt;_Key&gt;</code>，也可以选用<code>std::greater&lt;_Key&gt;</code> 或者自定义排序规则；</li><li><code>_Alloc</code>，默认选用二级内存分配器。</li></ul><p>一个简单使用实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span>   </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(<span class="keyword">const</span> set&lt;<span class="keyword">int</span>&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;size = &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">    <span class="comment">// 打印set键值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = s.<span class="built_in">begin</span>(); iter != s.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;key=&quot;</span>&lt;&lt;*iter&lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//  iter-&gt;first set不允许使用</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; set1 &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;; <span class="comment">// 键值不能相同</span></span><br><span class="line">    <span class="comment">// set1[1];  // error，不能使用[key]或at(key)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    set1.<span class="built_in">emplace</span>(<span class="number">0</span>);</span><br><span class="line">    set1.<span class="built_in">emplace</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printSet</span>(set1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    set1.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">    set1.<span class="built_in">erase</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printSet</span>(set1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">size = 5 : key=0 key=1 key=2 key=3 key=4 </span><br><span class="line">size = 3 : key=0 key=1 key=2 </span><br></pre></td></tr></table></figure><p><strong>关于成员函数</strong></p><p>set、multimap的成员函数，除了不能使用<code>at(key)</code>、<code>operator[key]</code> ，基本和map一致（底层实现上就非常相似），故不单列了。</p><h4 id="multiset">multiset</h4><p>multiset和map的主要区别在于：</p><ul><li><p><strong>multiset可以存储相同的键值</strong>；</p></li><li><p>multiset键值对相同；</p></li><li><p>除了map/unordered_map，multiset和set、multimap一样，也不能使用<code>at(key)</code> 或 <code>operator[key]</code>，但可以使用<code>find(key)</code> 。</p></li></ul><p>multiset 也定义在 <code>&lt;set&gt;</code> 头文件，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Key,</span><br><span class="line">  <span class="keyword">typename</span> _Compare = std::less&lt;_Key&gt;,</span><br><span class="line">  <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Key&gt; &gt;</span><br><span class="line">class multiset</span><br></pre></td></tr></table></figure><p>在 <code>multiset&lt;_Key,_Compare,_Alloc&gt;</code> 模板中：</p><ul><li><code>_Key</code>，指定键的类型；</li><li><code>_Compare</code>：指定排序顺序，默认选用升序<code>std::less&lt;_Key&gt;</code>，也可以选用<code>std::greater&lt;_Key&gt;</code> 或者自定义排序规则；</li><li><code>_Alloc</code>，默认选用二级内存分配器。</li></ul><p>一个简单使用实例（使用起来和set很相似）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span>   </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMSet</span><span class="params">(<span class="keyword">const</span> multiset&lt;<span class="keyword">int</span>&gt;&amp; ms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;size = &quot;</span> &lt;&lt; ms.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = ms.<span class="built_in">begin</span>(); iter != ms.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;key=&quot;</span>&lt;&lt;*iter&lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//  iter-&gt;first ，set、multiset不允许使用</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make_pair</span></span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; mset1 &#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;; <span class="comment">// 存在键值相同</span></span><br><span class="line">    <span class="comment">// mset1[1];  // error，不能使用[key]或at(key)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    mset1.<span class="built_in">emplace</span>(<span class="number">0</span>);</span><br><span class="line">    mset1.<span class="built_in">emplace</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printMSet</span>(mset1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    mset1.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">    mset1.<span class="built_in">erase</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printMSet</span>(mset1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出（自动排序）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">size = 6 : key=0 key=1 key=1 key=2 key=3 key=4 </span><br><span class="line">size = 4 : key=0 key=1 key=1 key=2 </span><br></pre></td></tr></table></figure><p><strong>关于成员函数</strong></p><p>multimap、set、multiset的成员函数，除了不能使用<code>at(key)</code>、<code>operator[key]</code> ，基本和map一致（底层实现上就非常相似），故不单列了。</p><h3 id="9-2-3-无序关联式容器">9.2.3 无序关联式容器</h3><p>本节主要介绍以下容器：</p><table><thead><tr><th style="text-align:center">容器</th><th style="text-align:center">底层数据结构</th><th style="text-align:center">特点</th><th style="text-align:center">迭代器类型</th></tr></thead><tbody><tr><td style="text-align:center">unordered_map</td><td style="text-align:center">哈希表，下同</td><td style="text-align:center">键必须唯一，会根据键大小默认升序排序</td><td style="text-align:center"><u>前向</u>迭代器，下同</td></tr><tr><td style="text-align:center">unordered_multimap</td><td style="text-align:center"></td><td style="text-align:center">基本同前，但unordered_multimap键可重复</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">unordered_set</td><td style="text-align:center"></td><td style="text-align:center">键和值完全相同，键依旧唯一，默认升序</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">unordered_multiset</td><td style="text-align:center"></td><td style="text-align:center">基本同前，但unordered_multiset键可重复</td><td style="text-align:center"></td></tr></tbody></table><p>正如名字“unordered”所暗示的，这些关联式容器是无序的，它们<u>不会</u>像之前的map/set/multimap/multiset/等关联容器一样，自动按键值大小对存储的键值对进行排序。</p><p><strong>为什么无序关联容器不会自动排序了</strong>？</p><p>这是因为“unordered”版本的关联式容器底层数据结构采用的是<u>哈希表</u> 而不是<u>红黑树</u> ，哈希表结构不适合插入元素时进行排序。</p><p>哈希表（Hash table）是根据关键码值(Key value)而直接进行访问的数据结构。</p><p>例如， <code>std::unordered_map</code>在内存中的哈希表形式结构：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/unordered_map_layout.png" alt="Jean Guegant's Blog – Making a STL-compatible hash map from scratch - Part  1 - Beating std::unordered_map"></p><p>直观上来看：</p><ul><li>哈希表是一个buckets数组（C++中使用vector实现）；</li><li>每个bucket是一个指针，指向它外挂的键值对链表（有时候我们用“bucket”指代外挂的链表）。</li></ul><p>在哈希表查找指定key的value大致过程如下：</p><blockquote><p>以 <code>std::unordered_map</code> 中 <code>[key]</code> 或 <code>at(key)</code> 查找过程为例。</p></blockquote><ol><li>使用hash(key)函数进行哈希映射，得到一个key对应的哈希值；</li><li>将哈希值和桶数量<code>n</code> 做<code>哈希值 % n</code>运算，元素结果即bucket的编号（下标），由此定位到具体的bucket上；</li><li>遍历查找定位的bucket外挂的键值对链表，如果找到key返回对应<u>value</u>（<code>find(key)</code>方法返回对应迭代器），如果没找到抛出异常（<code>find(key)</code>方法返回迭代器<code>unordered_map::end()</code>）。</li></ol><p><strong>为什么要重新设计哈希表作为底层结构</strong>？</p><p>这涉及到红黑树和哈希表的数据结构特性：</p><ul><li>查找、修改效率上：哈希表更快（哈希映射查找），常数级别O(1)，但哈希碰撞严重最坏O(n)；红黑树更慢（二叉树二分查找），但稳定O(logn)级别；</li><li>插入、删除效率上：哈希表更快，常数级别O(1)，红黑树更慢，但稳定O(logn)。</li></ul><p>所以，选择哈希表作为底层结构的无序容器，增删查改效率通常是更好的。<u>一般建议选择无序关联容器，除非你真的需要key有序</u>。</p><h4 id="unordered-map">unordered_map</h4><p>unordered_map 容器和 map 容器一样：</p><ul><li>以键值对（pair类型）的形式存储数据；</li><li>存储的各个键值对的键互不相同且不允许被修改。</li></ul><p>但由于 unordered_map 容器底层采用的是哈希表存储结构，该结构本身不具有对数据的排序功能，所以此容器内部不会自行对存储的键值对进行排序。</p><p>unordered_map 容器以类模板形式定义在 <code>&lt;unordered_map&gt;</code> 头文件，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">Tp</span>,</span></span><br><span class="line"><span class="class">     <span class="keyword">class</span> _<span class="title">Hash</span> =</span> hash&lt;_Key&gt;,</span><br><span class="line">     <span class="class"><span class="keyword">class</span> _<span class="title">Pred</span> =</span> std::equal_to&lt;_Key&gt;,</span><br><span class="line">     <span class="class"><span class="keyword">class</span> _<span class="title">Alloc</span> =</span> std::allocator&lt;std::pair&lt;<span class="keyword">const</span> _Key, _Tp&gt; &gt; &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unordered_map</span> :</span> __check_copy_constructible&lt;_Alloc&gt;</span><br></pre></td></tr></table></figure><p>在 <code>unordered_map&lt;_Key,_Tp,_Hash,_Pred,_Alloc&gt;</code> 模板中：</p><ul><li><code>_Key</code>，指定键的类型；</li><li><code>_Tp</code>，指定值的类型；</li><li><code>_Hash</code>：指定要使用的哈希函数，默认选用<code>hash&lt;_Key&gt;</code>，不过默认哈希函数只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类；</li><li><code>_Pred</code>：unordered_map不允许键值相等，而判断是否相等的规则，就由此参数指定；</li><li><code>_Alloc</code>，默认选用二级内存分配器。</li></ul><p>使用简单举例。</p><p>和map的提供的上层函数接口基本一致，如<code>emplace()</code> 插入元素等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printUMap</span><span class="params">(<span class="keyword">const</span> unordered_map&lt;<span class="keyword">int</span>,string&gt;&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;size = &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">    <span class="comment">// 打印键值对</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = m.<span class="built_in">begin</span>(); iter != m.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;&lt;key=&quot;</span>&lt;&lt; iter-&gt;first &lt;&lt;<span class="string">&quot;, value=&quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot;&gt; &quot;</span>; </span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,std::string&gt; umap1 &#123; &#123;<span class="number">1</span>,<span class="string">&quot;一&quot;</span>&#125;,&#123;<span class="number">2</span>,<span class="string">&quot;二&quot;</span>&#125;&#125;;</span><br><span class="line">    umap1[<span class="number">1</span>]; <span class="comment">// &quot;一&quot;</span></span><br><span class="line">    umap1[<span class="number">2</span>]; <span class="comment">// &quot;二&quot;</span></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    umap1.<span class="built_in">emplace</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="string">&quot;零&quot;</span>));</span><br><span class="line">    umap1.<span class="built_in">emplace</span>(std::<span class="built_in">make_pair</span>(<span class="number">4</span>,<span class="string">&quot;四&quot;</span>));</span><br><span class="line">    <span class="built_in">printUMap</span>(umap1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    umap1.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">    umap1.<span class="built_in">erase</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printUMap</span>(umap1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出（未排序）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">size = <span class="number">4</span> : &lt;key=<span class="number">4</span>, value=四&gt; &lt;key=<span class="number">0</span>, value=零&gt; &lt;key=<span class="number">2</span>, value=二&gt; &lt;key=<span class="number">1</span>, value=一&gt; </span><br><span class="line">size = <span class="number">3</span> : &lt;key=<span class="number">0</span>, value=零&gt; &lt;key=<span class="number">2</span>, value=二&gt; &lt;key=<span class="number">1</span>, value=一&gt; </span><br></pre></td></tr></table></figure><h5 id="成员函数-7">成员函数</h5><p>unordered_map 既可以看做是关联式容器，更属于自成一脉的无序容器。所以其成员函数可分为：</p><ul><li>迭代器相关</li><li>基本方法</li><li>无序容器独有方法</li></ul><p>我们先一睹为快。</p><ul><li><p><strong>迭代器相关</strong></p><p>无序容器只有前向迭代器，尾部操作相关迭代器和函数都没有。</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">begin()</td><td style="text-align:center">返回指向容器中第一个元素的正向迭代器</td></tr><tr><td style="text-align:center">end()</td><td style="text-align:center">返回指向容器最后一个元素之后一个位置的正向迭代器</td></tr><tr><td style="text-align:center">cbegin()</td><td style="text-align:center">和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td></tr><tr><td style="text-align:center">cend()</td><td style="text-align:center">和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td></tr></tbody></table><ul><li>注意，如果是 <em>const</em> 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素；</li><li>begin() 和 end() 为C++11新增，操作对象还可以是数组。</li></ul></li><li><p><strong>基本方法（基本同map</strong>）</p><p>标粗部分是常用的函数。</p><ul><li>无序关联容器虽然底层不是随机迭代器，一些随机迭代器才支持的方法，<strong>比如<code>at(n)</code>、<code>[n]</code>是不支持的，但支持按键值查找<code>at(key)</code>、<code>[key]</code>方法</strong>；</li><li><strong>关联容器不能在指定位置上删除、插入元素</strong>，所以STL没有提供<code>push_back()</code>、<code>push_front()</code>之类头尾操作方法，而是使用<code>emplace()</code> 或<code>insert()</code>。</li></ul><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><strong>empty</strong>()</td><td style="text-align:center">若容器为空，则返回 true；否则 false</td></tr><tr><td style="text-align:center"><strong>size</strong>()</td><td style="text-align:center">返回当前 unordered_map容器中存有<strong>键值对的个数</strong></td></tr><tr><td style="text-align:center">max_size()</td><td style="text-align:center">返回 unordered_map容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同</td></tr><tr><td style="text-align:center"><strong>operator</strong>[key]</td><td style="text-align:center">map容器重载了 [] 运算符，获取指定键的值，<strong>查找失败添加新的键值对</strong></td></tr><tr><td style="text-align:center"><strong>at</strong>(key)</td><td style="text-align:center">找到 map 容器中 key 键对应的值，<strong>查找失败引发 out_of_range 异常</strong></td></tr><tr><td style="text-align:center"><strong>insert</strong>()</td><td style="text-align:center">向 map 容器中插入键值对，<strong>如果key重复会覆盖</strong></td></tr><tr><td style="text-align:center"><strong>erase</strong>()</td><td style="text-align:center">删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对</td></tr><tr><td style="text-align:center"><strong>swap</strong>()</td><td style="text-align:center">交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td></tr><tr><td style="text-align:center">clear()</td><td style="text-align:center">清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0</td></tr><tr><td style="text-align:center"><strong>emplace</strong>()</td><td style="text-align:center">基本同insert，但相比insert效率更高</td></tr><tr><td style="text-align:center">count(key)</td><td style="text-align:center">在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。</td></tr></tbody></table></li><li><p><strong>无序容器独有方法</strong></p><p>相比序列容器、有序容器，无序容器独有的一些<u>哈希表相关</u>方法：</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">bucket_count()</td><td style="text-align:center">返回当前桶数量（一个线性链表代表一个桶）</td></tr><tr><td style="text-align:center">max_bucket_count()</td><td style="text-align:center">返回最多可以使用多少桶</td></tr><tr><td style="text-align:center"><strong>bucket_size</strong>(n)</td><td style="text-align:center">返回第 n 个桶中存储键值对的数量</td></tr><tr><td style="text-align:center">bucket(key)</td><td style="text-align:center">返回以 key为键的键值对所在桶的编号</td></tr><tr><td style="text-align:center"><strong>load_factor</strong>()</td><td style="text-align:center">返回 unordered_map 容器中当前的负载因子，即负载因子 = 容器存储的总键值对 / 桶数 ， load_factor() = size() / bucket_count()</td></tr><tr><td style="text-align:center">max_load_factor()</td><td style="text-align:center">返回或者设置当前 unordered_map 容器的负载因子</td></tr><tr><td style="text-align:center"><strong>rehash</strong>(n)</td><td style="text-align:center">将当前容器底层使用桶的数量设置为 n</td></tr><tr><td style="text-align:center"><strong>reserve</strong>()</td><td style="text-align:center">将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个键值对（不超过最大负载因子）所需的数量，并重新整理容器</td></tr><tr><td style="text-align:center">hash_function()</td><td style="text-align:center">返回当前容器使用的哈希函数对象</td></tr></tbody></table></li></ul><p>对于无序容器的独有方法进行测试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printUmapInfo</span><span class="params">(<span class="keyword">const</span> unordered_map&lt;string, string&gt;&amp; umap)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap 初始桶数: &quot;</span> &lt;&lt; umap.<span class="built_in">bucket_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap 最大可使用桶数: &quot;</span> &lt;&lt; umap.<span class="built_in">max_bucket_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap 当前存在的键值对: &quot;</span> &lt;&lt; umap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap 初始负载因子: &quot;</span> &lt;&lt; umap.<span class="built_in">load_factor</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap 最大负载因子: &quot;</span> &lt;&lt; umap.<span class="built_in">max_load_factor</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;—————————————————————————————————————&quot;</span>  &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建空 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 umap 使用最适合存储 9 个键值对的桶数</span></span><br><span class="line">    umap.<span class="built_in">reserve</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">printUmapInfo</span>(umap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 umap 容器添加 3 个键值对</span></span><br><span class="line">    umap[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;royhuang&quot;</span>;</span><br><span class="line">    umap[<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;25&quot;</span>;</span><br><span class="line">    umap[<span class="string">&quot;university&quot;</span>] = <span class="string">&quot;chongqingU&quot;</span>;</span><br><span class="line">    <span class="built_in">printUmapInfo</span>(umap);</span><br><span class="line">    <span class="comment">// 调用 bucket() 获取指定键值对位于桶的编号</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;“age”存储在第：&quot;</span> &lt;&lt; umap.<span class="built_in">bucket</span>(<span class="string">&quot;age&quot;</span>) &lt;&lt;<span class="string">&quot;个桶&quot;</span>&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自行计算某键值对位于哪个桶</span></span><br><span class="line">    <span class="keyword">auto</span> fn = umap.<span class="built_in">hash_function</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hash(age)%n，计算“age”存储在第：&quot;</span> &lt;&lt; <span class="built_in">fn</span>(<span class="string">&quot;age&quot;</span>) % (umap.<span class="built_in">bucket_count</span>())  &lt;&lt;<span class="string">&quot;个桶&quot;</span>&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">umap 初始桶数: 11</span><br><span class="line">umap 最大可使用桶数: 576460752303423487</span><br><span class="line">umap 当前存在的键值对: 0</span><br><span class="line">umap 初始负载因子: 0</span><br><span class="line">umap 最大负载因子: 1</span><br><span class="line">—————————————————————————————————————</span><br><span class="line">umap 初始桶数: 11</span><br><span class="line">umap 最大可使用桶数: 576460752303423487</span><br><span class="line">umap 当前存在的键值对: 3</span><br><span class="line">umap 初始负载因子: 0.272727</span><br><span class="line">umap 最大负载因子: 1</span><br><span class="line">—————————————————————————————————————</span><br><span class="line">“age”存储在第：5个桶</span><br><span class="line"><span class="meta">hash(age)%</span><span class="bash">n，计算“age”存储在第：5个桶</span></span><br></pre></td></tr></table></figure><h5 id="底层实现-7">底层实现</h5><p>unordered_map底层实现主要就是哈希表：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220219131831129.png" alt="image-20220219131831129"></p><p>具体逻辑暂略。</p><h4 id="unordered-multimap">unordered_multimap</h4><p>回忆map和multimap的区别：</p><blockquote><p>map和multimap主要的不同体现在：</p><ul><li>multimap 可以同时<u>存储多个键相同的键值对</u>；</li><li>multimap 除了<code>find(key)</code>，不能使用<code>at(key)</code> 或 <code>operator[key]</code> 等<u>直接按key获取value的方式</u>（很好理解，multimap会存在多个重复的键）。</li></ul><p>multimap 也定义在 <code>&lt;map&gt;</code> 头文件，…</p></blockquote><p>unordered_map和unordered_multimap的<u>区别同上</u>：</p><ul><li><p>unordered_multimap可以同时<u>存储多个键相同的键值对</u>；</p></li><li><p>unordered_multimap除了<code>find(key)</code>，不能使用<code>at(key)</code> 或 <code>operator[key]</code> 等<u>直接按key获取value的方式</u> 。</p></li></ul><p>unordered_multimap也定义在 <code>&lt;unordered_map&gt;</code> 头文件中，使用起来基本和unordered_map没差，不再重复介绍了。</p><h4 id="unordered-set">unordered_set</h4><p>回忆set和map的区别：</p><blockquote><p>主要区别在于：</p><ul><li><strong>set容器存储的键值对（key-value）的key、value完全相同。在底层实现上，map底层区别也主要是修改红黑树存储的key、value保存一致</strong> ;</li><li>set容器除了<code>find(key)</code>，不能使用<code>at(key)</code> 或 <code>operator[key]</code>获取value ，虽然在底层实现上set的key等于value，<u>但是不允许获取value</u>。</li></ul></blockquote><p>unordered_set和unordered_map的区别同上。</p><h4 id="unordered-multiset">unordered_multiset</h4><p>回忆multiset和map的区别：</p><blockquote><p>multiset和map的主要区别在于：</p><ul><li><p><strong>multiset可以存储相同的键值</strong>；</p></li><li><p>multiset键值对相同；</p></li><li><p>除了map/unordered_map，multiset和set、multimap一样，也不能使用<code>at(key)</code> 或 <code>operator[key]</code>，但可以使用<code>find(key)</code> 。</p></li></ul></blockquote><p>unordered_map和unordered_multiset的区别同上。</p><h3 id="9-2-4-容器适配器">9.2.4 容器适配器</h3><p>本节主要介绍以下容器：</p><table><thead><tr><th style="text-align:center">容器</th><th style="text-align:center">底层数据结构</th><th style="text-align:center">特点</th><th style="text-align:center">迭代器类型</th></tr></thead><tbody><tr><td style="text-align:center">stack</td><td style="text-align:center">（默认）deque</td><td style="text-align:center">元素“先进后出”</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">queue</td><td style="text-align:center">（默认）deque</td><td style="text-align:center">元素“先进先出”</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">priority_queue</td><td style="text-align:center">（默认）vector</td><td style="text-align:center">元素“先进优先级高先出”</td><td style="text-align:center">无</td></tr></tbody></table><p>或许你和第一次接触“容器适配器”这个名词的我，都会感到纳闷：这词听起来有些古怪，它是什么意思呢？它也是容器吗？</p><p><strong>“容器适配器”是什么意思</strong>？</p><p>在栈（stack）这种数据结构中，必须要满足“先进后出”这种特性。而我们之前的容器，如deque、list都无法满足这种特性。</p><p>但我们可以，比如对<u>基础容器</u>deque，进行一层封装：禁止头部进出只允许尾部进出，这样就<u>适配了栈“先进后出”的特性</u>。这种通过，<strong>封装某个序列式容器，并重新组合该容器中包含的成员函数来实现“需要的特性”的容器（必要时也可以自创新函数），就称为容器适配器</strong>。</p><p>所以，容器适配器自然也是容器。特别的，STL中的容器适配器，基础容器并不是固定的，还允许我们选择满足条件的基础容器。采用的底层基础容器不同，其执行效率也不尽相同，一般来说使用默认的就行。</p><h4 id="stack">stack</h4><p>stack 栈适配器是一种单端开口的容器，该容器模拟的就是栈存储结构，<u>只能在栈顶插入、删除</u>。</p><p>下图展示了stack的简单使用。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220219135504605.png" alt="image-20220219135504605"></p><p>stack 容器以类模板的形式定义在 <code>&lt;stack&gt;</code> 头文件，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Sequence = deque&lt;_Tp&gt; &gt;</span><br><span class="line">class stack</span><br></pre></td></tr></table></figure><p>在 <code>stack&lt;_Tp,_Sequence&gt;</code> 模板中：</p><ul><li><code>_Tp</code>，用于指明容器中元素数据类型；</li><li><code>_Sequence</code>，指定底层使用的基础容器。</li></ul><p>简单使用实例。</p><p>在这个例子中，我们没有使用默认的deque作为基础容器，而是使用list。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构建 stack 容器适配器</span></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; values&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">// 基础容器list</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>, list&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">my_stack</span>(values);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看 my_stack 存储元素的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of my_stack: &quot;</span> &lt;&lt; my_stack.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    my_stack.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of my_stack: &quot;</span> &lt;&lt; my_stack.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 my_stack 中存储的元素依次弹栈，直到其为空</span></span><br><span class="line">    <span class="keyword">while</span> (!my_stack.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; my_stack.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">        my_stack.<span class="built_in">pop</span>();  <span class="comment">// 将栈顶元素弹栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="底层实现-8">底层实现</h5><p>stack底层就是封装了基础容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Sequence = deque&lt;_Tp&gt; &gt;</span><br><span class="line">class stack</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//  See queue::c for notes on this name.</span></span><br><span class="line">    _Sequence c;  <span class="comment">// 底层基础容器，模板参数指定</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>查看经典的<code>stack::push()</code>、<code>stack::pop()</code> 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(<span class="keyword">const</span> value_type&amp; __x)  <span class="comment">// 引用</span></span><br><span class="line">&#123; </span><br><span class="line">c.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(__x));  <span class="comment">// 就是基础容器的push_back方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">push</span>(value_type&amp;&amp; __x)  <span class="comment">// 右值引用</span></span><br><span class="line">&#123; </span><br><span class="line">c.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(__x)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">__glibcxx_requires_nonempty();</span><br><span class="line">c.<span class="built_in">pop_back</span>();  <span class="comment">// 基础容器的pop_back方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实主要还是借助基础容器的成员和方法实现。</p><h5 id="成员函数-8">成员函数</h5><p>相比其它序列或关联式容器，stack 是一类存储机制简单、<u>提供成员函数较少</u>的容器。</p><ul><li>特别的，容器适配器都没有迭代器，所以遍历元素：只能不断移除元素，去访问下一个元素。</li></ul><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">empty()</td><td style="text-align:center">当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false</td></tr><tr><td style="text-align:center"><strong>size</strong>()</td><td style="text-align:center">返回 stack 栈中存储元素的个数</td></tr><tr><td style="text-align:center">top()</td><td style="text-align:center">返回一个栈顶元素的引用，类型为 T&amp;，<strong>如果栈为空，程序会报错</strong>。</td></tr><tr><td style="text-align:center"><strong>push(const T&amp; val</strong>)</td><td style="text-align:center">先复制 val，再将 val 副本压入栈顶，这是通过调用底层容器的 push_back() 函数完成的</td></tr><tr><td style="text-align:center"><strong>push(T&amp;&amp; obj</strong>)</td><td style="text-align:center">以移动元素的方式将其压入栈顶，这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。</td></tr><tr><td style="text-align:center"><strong>pop</strong>()</td><td style="text-align:center">弹出栈顶元素</td></tr><tr><td style="text-align:center">emplace(arg…)</td><td style="text-align:center">arg… 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素</td></tr><tr><td style="text-align:center">swap(stack<T> &amp; other_stack)</td><td style="text-align:center">将两个 stack 适配器中的元素进行互换，需要注意的是，进行互换的 2 个 stack 适配器中存储的<u>元素类型以及底层采用的基础容器类型，都必须相同</u></td></tr></tbody></table><h4 id="queue">queue</h4><p>和 stack 栈容器适配器不同，queue 容器适配器有 2 个开口，一个开口（尾部）专门用来加入元素，另一个开头（头部）专门用来移除元素。</p><p>这种存储结构最大的特点是，最先进入 queue 的元素，也可以最先从 queue 中出来，即“先进先出”。</p><p>下图展示了queue这种结构。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220219145411589.png" alt="image-20220219145411589"></p><p>stack 容器以类模板的形式定义在 <code>&lt;stack&gt;</code> 头文件，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Sequence = deque&lt;_Tp&gt; &gt;</span><br><span class="line">class stack</span><br></pre></td></tr></table></figure><p>在 <code>stack&lt;_Tp,_Sequence&gt;</code> 模板中：</p><ul><li><code>_Tp</code>，用于指明容器中元素数据类型；</li><li><code>_Sequence</code>，指定底层使用的基础容器。</li></ul><p>简单使用实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构建 stack 容器适配器</span></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; values&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">// 基础容器list</span></span><br><span class="line">    queue&lt;<span class="keyword">int</span>, list&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">my_queue</span>(values);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看 my_stack 存储元素的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of my_queue: &quot;</span> &lt;&lt; my_queue.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    my_queue.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of my_queue: &quot;</span> &lt;&lt; my_queue.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 my_stack 中存储的元素依次弹栈，直到其为空</span></span><br><span class="line">    <span class="keyword">while</span> (!my_queue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; my_queue.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//将栈顶元素弹栈</span></span><br><span class="line">        my_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">size of my_queue: 3</span><br><span class="line">size of my_queue: 4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h5 id="底层实现-9">底层实现</h5><p>同stack，queue底层就是封装了基础容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Sequence = deque&lt;_Tp&gt; &gt;</span><br><span class="line">class queue</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//  See queue::c for notes on this name.</span></span><br><span class="line">    _Sequence c;  <span class="comment">// 底层基础容器，模板参数指定</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>queue::push</code>、<code>queue::pop</code>方法实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(<span class="keyword">const</span> value_type&amp; __x)  <span class="comment">// 引用</span></span><br><span class="line">&#123; </span><br><span class="line">c.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(__x));  <span class="comment">// 就是基础容器的push_back方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">push</span>(value_type&amp;&amp; __x)  <span class="comment">// 右值引用</span></span><br><span class="line">&#123; </span><br><span class="line">c.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(__x)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">__glibcxx_requires_nonempty();</span><br><span class="line">c.<span class="built_in">pop_front</span>();  <span class="comment">// 基础容器的pop_front方法，stack这里是pop_back，所以是尾部弹出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="成员函数-9">成员函数</h5><p>queue 容器适配器拥有stack 成员函数基本所有函数（除了<code>top()</code>、<code>emplace()</code>）。</p><ul><li>特别的，容器适配器都没有迭代器，所以遍历元素：只能不断移除元素，去访问下一个元素。</li></ul><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">empty()</td><td style="text-align:center">当 queue中没有元素时，该成员函数返回 true；反之，返回 false</td></tr><tr><td style="text-align:center"><strong>size</strong>()</td><td style="text-align:center">返回 queue中存储元素的个数</td></tr><tr><td style="text-align:center"><s>top</s>()</td><td style="text-align:center"><s>queue没有</s></td></tr><tr><td style="text-align:center"><strong>push(const T&amp; val</strong>)</td><td style="text-align:center">先复制 val，再将 val 副本压入队尾，这是通过调用底层容器的 push_back() 函数完成的</td></tr><tr><td style="text-align:center"><strong>push(T&amp;&amp; obj</strong>)</td><td style="text-align:center">以移动元素的方式将其压入队尾，这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。</td></tr><tr><td style="text-align:center"><strong>pop</strong>()</td><td style="text-align:center">弹出队头（第一个）元素</td></tr><tr><td style="text-align:center"><s>emplace(arg</s>…)</td><td style="text-align:center"><s>queue没有</s></td></tr><tr><td style="text-align:center">swap(queue<T> &amp; other_stack)</td><td style="text-align:center">将两个 queue适配器中的元素进行互换，需要注意的是，进行互换的 2 个 queue适配器中存储的<u>元素类型以及底层采用的基础容器类型，都必须相同</u></td></tr></tbody></table><p>queue 独有的函数：</p><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">front()</td><td style="text-align:center">返回 queue 中第一个元素的引用</td></tr><tr><td style="text-align:center">back()</td><td style="text-align:center">返回 queue 中最后一个元素的引用</td></tr></tbody></table><h4 id="priority-queue">priority_queue</h4><p>priority_queue 容器适配器中元素的进出，遵循“先进优先级高的先出”原则。</p><p><strong>那priority_queue 中元素优先级是如何评定</strong>？</p><p>每个 priority_queue 容器适配器在创建时，都制定了一种“排序规则”。根据此规则，该容器适配器中存储的元素就有了优先级高低之分。</p><p>比如这种“排序规则”，可以是：元素值从大到小或从小到大。</p><p>priority_queue中元素进出和queue有些不同：</p><ul><li>进：不直接插到队尾，找到优先级最高的元素，并将其移动到队列的队头；</li><li>出：直接移出队头，然后找到当前优先级最高的元素，并将其移动到队头。</li></ul><p>优先队列可以使用<u>数组</u>、<u>二叉搜索树</u>、<u>链表</u>和<u>堆</u>数据结构来实现。但是，最好的选择是堆数据结构，因为它有助于相对更快、更有效地实现优先级队列。</p><p>priority_queue容器以类模板的形式定义在 <code>&lt;queue&gt;</code> 头文件，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, </span><br><span class="line">  <span class="keyword">typename</span> _Sequence = vector&lt;_Tp&gt;,</span><br><span class="line">      <span class="keyword">typename</span> _Compare  = less&lt;typename_Sequence::value_type&gt; &gt;</span><br><span class="line">class priority_queue</span><br></pre></td></tr></table></figure><p>在 <code>priority_queue&lt;_Tp,_Sequence,_Compare&gt;</code> 模板中：</p><ul><li><code>_Tp</code>，用于指明容器中元素数据类型；</li><li><code>_Sequence</code>，指定底层使用的基础容器；</li><li><code>_Compare</code> ，指定排序规则。</li></ul><p>简单使用例子。</p><p>注意priority_queue的初始化有些不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构建 stack 容器适配器</span></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; values&#123; <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;  <span class="comment">// 此时是无序的list</span></span><br><span class="line">    <span class="comment">// priority_queue&lt;int, deque&lt;int&gt;&gt; my_priority_queue(values); // error,不能使用这种方式初始化</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, deque&lt;<span class="keyword">int</span>&gt;&gt; my_priority_queue&#123;values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>()&#125; ; <span class="comment">// 初始化指定两个迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看 my_priority_queue 存储元素的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of my_priority_queue: &quot;</span> &lt;&lt; my_priority_queue.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    my_priority_queue.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of my_priority_queue: &quot;</span> &lt;&lt; my_priority_queue.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 my_stack 中存储的元素依次弹栈，直到其为空</span></span><br><span class="line">    <span class="keyword">while</span> (!my_priority_queue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; my_priority_queue.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 输出有序</span></span><br><span class="line">        <span class="comment">// 队头元素（最高优先级出栈）</span></span><br><span class="line">        my_priority_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出（有序）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">size of my_priority_queue: 3</span><br><span class="line">size of my_priority_queue: 4</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h5 id="成员函数-10">成员函数</h5><p>priority_queue 拥有的成员函数和tack更像（基本一致）：</p><ul><li><p>有<code>top()</code> 方法，没有queue独有的<code>front()</code> 或<code>back()</code> 方法；</p></li><li><p>特别的，容器适配器都没有迭代器，所以遍历元素：只能不断移除元素，去访问下一个元素。</p></li></ul><table><thead><tr><th style="text-align:center">成员函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">empty()</td><td style="text-align:center">当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false</td></tr><tr><td style="text-align:center"><strong>size</strong>()</td><td style="text-align:center">返回 stack 栈中存储元素的个数</td></tr><tr><td style="text-align:center">top()</td><td style="text-align:center">返回一个栈顶元素的引用，类型为 T&amp;，<strong>如果栈为空，程序会报错</strong>。</td></tr><tr><td style="text-align:center"><strong>push(const T&amp; val</strong>)</td><td style="text-align:center">先复制 val，再将 val 副本压入栈顶，这是通过调用底层容器的 push_back() 函数完成的</td></tr><tr><td style="text-align:center"><strong>push(T&amp;&amp; obj</strong>)</td><td style="text-align:center">以移动元素的方式将其压入栈顶，这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。</td></tr><tr><td style="text-align:center"><strong>pop</strong>()</td><td style="text-align:center">弹出栈顶元素</td></tr><tr><td style="text-align:center">emplace(arg…)</td><td style="text-align:center">arg… 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素</td></tr><tr><td style="text-align:center">swap(stack<T> &amp; other_stack)</td><td style="text-align:center">将两个 stack 适配器中的元素进行互换，需要注意的是，进行互换的 2 个 stack 适配器中存储的<u>元素类型以及底层采用的基础容器类型，都必须相同</u></td></tr></tbody></table><h3 id="9-2-5-容器最佳实践">9.2.5 容器最佳实践</h3><p>在本节我们从<u>基本使用</u>、<u>底层实现</u>、<u>常用函数</u>等方面介绍了众多容器，它们可分为：</p><ol><li>序列式容器：array、vector、deque、list 和 forward_list；</li><li>关联式容器：map、multimap、set 和 multiset；</li><li>无序关联式容器：unordered_map、unordered_multimap、unordered_set 和 unordered_multiset；</li><li>容器适配器：stack、queue 和 priority_queue。</li></ol><p><strong>这么多容器，实际编码该选择哪一个呢</strong>？</p><p>回忆各个数据结构的特点。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">特点</th><th style="text-align:center">对应容器</th><th style="text-align:center">对应迭代器</th></tr></thead><tbody><tr><td style="text-align:center"><strong>数组</strong></td><td style="text-align:center">查找效率高且可随机查找、（除尾部）插入删除效率低</td><td style="text-align:center">array/vector/deque</td><td style="text-align:center">随机迭代器</td></tr><tr><td style="text-align:center"><strong>链表</strong></td><td style="text-align:center">空间利用率高，插入删除效率高，查找较数组低</td><td style="text-align:center">list/forwar_list</td><td style="text-align:center">双向或前向迭代器</td></tr><tr><td style="text-align:center"><strong>红黑树</strong></td><td style="text-align:center">在STL中存储键值对，增删查改效率均高，还会排序</td><td style="text-align:center">map/set/…</td><td style="text-align:center">双向迭代器</td></tr><tr><td style="text-align:center"><strong>哈希表</strong></td><td style="text-align:center">在STL中存储键值对，不会排序，但比红黑树效率更高</td><td style="text-align:center">unordered_map/ unordered_set/…</td><td style="text-align:center">前向迭代器</td></tr></tbody></table><p>首先，一般来说除非需要键值有序，在无序关联式容器/关联式容器中，优先考虑无序关联式容器。现在，我们再从<u>时间效率角度</u> 出发考虑各种容器的选择：</p><ul><li><strong>如果查找元素效率要求高</strong> ：选择unordered_map/unordered_set或array/vector/deque<ul><li><strong>如果数据可按键值对存储</strong>：选择unordered_map/unordered_set，O(1)常数级别查找键值；</li><li><strong>如果只能顺序存储</strong> ：选择array/vector/deque<ul><li><strong>如果存储的是静态数据</strong>：选array；</li><li><strong>如果存储的是动态数据</strong>：只在尾部增、删选vector；头、尾均需要增、删选deque。</li></ul></li></ul></li><li><strong>如果插入、删除效率要求高</strong>：<ul><li><strong>如果插入、删除位置有要求</strong> ：list/forwar_list<ul><li><strong>如果只在头部插入、删除数据</strong>：选forwar_list；</li><li><strong>如果头、尾均需插入、删除数据</strong>：选list。</li></ul></li><li><strong>如果插入、删除位置没要求</strong>：选择unordered_map/unordered_set，O(lgn)级别复杂度。</li></ul></li></ul><p>至于stack、queue 和 priority_queue则一般是在你需要：“先进后出”、“先进先出”或“按优先级别出队”，这种特殊情况才考虑。</p><h2 id="9-3-算法">9.3 算法</h2><p>STL提供了许多算法，供我们来对容器（或数组）中数据进行操作，通常可分两类：</p><ul><li>会改变它们所应用的序列的算法</li><li>不改变它们所应用的序列的算法</li></ul><p>可通过引入于<code>&lt;algorithm&gt;</code>头文件来使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><p>不过在本文中，主要还是按算法功能来进行介绍。而且本文不会对各种算法进行具体介绍，通常只是<u>对常用算法进行简单概况</u>。</p><p><strong>为什么不详细介绍各类算法</strong>？</p><p>主要原因如下：</p><ul><li>本文已经足够长（~3W字），每个算法详细介绍的话，篇幅长度难以估计把控；</li><li>一般情况下我们只需对大致函数功能有所了解就行，实际编码可查看具体的API接口，再深入理解即可。</li></ul><p>另外，作者在实际工作中如果对一些算法有“踩坑和理解”，还会补充到本文中。</p><h3 id="9-3-1-sort">9.3.1 sort</h3><p>C++ STL 标准库提供很多实用的排序函数，通过调用它们，我们可以很轻松地实现对<u>普通数组或者容器</u>中指定范围内的元素进行排序。</p><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center"><strong>sort (first, last)</strong></td><td style="text-align:center">对容器或普通数组中 <strong>[first, last)</strong> 范围内的元素进行排序，<strong>默认进行升序排序</strong></td></tr><tr><td style="text-align:center"><strong>stable_sort (first, last)</strong></td><td style="text-align:center">和 sort() 函数功能相似，不同之处在于，对于 [first, last) 范围内值相同的元素，该函数不会改变它们的相对位置</td></tr><tr><td style="text-align:center">partial_sort (first, middle, last)</td><td style="text-align:center">从 [first,last) 范围内，筛选出 muddle-first 个最小的元素并排序存放在 [first，middle) 区间中</td></tr><tr><td style="text-align:center">partial_sort_copy (first, last, result_first, result_last)</td><td style="text-align:center">从 [first, last) 范围内筛选出 result_last-result_first 个元素排序并存储到 [result_first, result_last) 指定的范围中</td></tr><tr><td style="text-align:center"><strong>is_sorted</strong> (first, last)</td><td style="text-align:center">检测 [first, last) 范围内是否已经排好序，默认检测是否按升序排序</td></tr><tr><td style="text-align:center">is_sorted_until (first, last)</td><td style="text-align:center">和 is_sorted() 函数功能类似，唯一的区别在于，如果 [first, last) 范围的元素没有排好序，则该函数会返回一个指向首个不遵循排序规则的元素的迭代器</td></tr></tbody></table><h3 id="9-3-2-merge">9.3.2 merge</h3><p>有些场景中，我们需要将 2 个<u>有序序列</u>合并为 1 个有序序列，这时就可以借助 merge() 实现。</p><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center"><strong>merge (first1, last1,  first2, last2,  result</strong>)</td><td style="text-align:center">first1、last1、first2 以及 last2 都为输入迭代器，[first1, last1) 和 [first2, last2) 各用来指定一个有序序列；result 为输出迭代器，指定存储位置</td></tr><tr><td style="text-align:center"><strong>merge (first1, last1,  first2, last2,                  result,  comp</strong>)</td><td style="text-align:center">同上，不过多了comp 用于自定义排序规则</td></tr></tbody></table><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span>    <span class="comment">// std::merge</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// first 和 second 数组中各存有 1 个有序序列</span></span><br><span class="line">    <span class="keyword">int</span> first[] = &#123; <span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> second[] = &#123; <span class="number">7</span>,<span class="number">17</span>,<span class="number">27</span>,<span class="number">37</span>,<span class="number">47</span>,<span class="number">57</span> &#125;;</span><br><span class="line">    <span class="comment">// 用于存储新的有序序列</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">myvector</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 将 [first,first+5) 和 [second,second+6) 合并为 1 个有序序列，并存储到 myvector 容器中</span></span><br><span class="line">    <span class="built_in">merge</span>(first, first + <span class="number">5</span>, second, second + <span class="number">6</span>, myvector.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-3-find">9.3.3 find</h3><p>find() 函数本质上是一个模板函数，用于在指定范围内查找和<strong>目标元素值相等的第一个元素</strong>。</p><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center"><strong>find(first, last,  const T&amp; val</strong>)</td><td style="text-align:center">该函数会返回一个输入迭代器，first 和 last 为输入迭代器，[first, last) 用于指定该函数的查找范围；val 为要查找的目标元素。</td></tr></tbody></table><p>其它的“find”函数：</p><ul><li><strong>find_if() 或 find_not_if</strong>()， 和find唯一不同的是，前者需要明确指定要查找的元素的值，而后者则允许自定义查找规则；</li><li><strong>find_end() 或 search</strong>()，用于在序列 A 中查找序列 B， 最后一次或第一次出现的位置；</li><li><strong>find_first_of</strong>()：在 A 序列中查找和 B 序列中，<strong>和B中任意元素相匹配的第一个元素</strong>。</li></ul><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span>    <span class="comment">// std::find</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// find() 函数作用于普通数组</span></span><br><span class="line">    <span class="keyword">char</span> stl[] =<span class="string">&quot;royhuang&quot;</span>;</span><br><span class="line">    <span class="comment">// 调用 find() 查找第一个字符 &#x27;r&#x27;</span></span><br><span class="line">    <span class="keyword">char</span> * p = <span class="built_in">find</span>(stl, stl + <span class="built_in">strlen</span>(stl), <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">    <span class="comment">// 判断是否查找成功</span></span><br><span class="line">    <span class="keyword">if</span> (p != stl + <span class="built_in">strlen</span>(stl)) </span><br><span class="line">        cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// find() 函数作用于容器</span></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; myvector&#123; <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span> &#125;;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    it = <span class="built_in">find</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查找成功：&quot;</span> &lt;&lt; *it;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-4-reverse">9.3.4 reverse</h3><p>reverse函数可以反转一个容器中的元素。</p><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center"><strong>reverse(_first, last</strong>)</td><td style="text-align:center">reverse函数反转的范围是[first,last)，不包括last指向的元素</td></tr></tbody></table><p>简单实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>      </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; myvector &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    std::<span class="built_in">reverse</span>(myvector.<span class="built_in">begin</span>(),myvector.<span class="built_in">end</span>());    <span class="comment">// 5 4 3 2 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-5-copy-n">9.3.5 copy_n</h3><p>copy_n() 算法，可以从源容器复制指定个数的元素到目标容器中。</p><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center"><strong>copy_n(source_first, size, target_start</strong>)</td><td style="text-align:center">source_first 是指向源容器的起始位置的迭代器，size是要复制的元素总数， target_start是目标容器的开始迭代器</td></tr></tbody></table><p>简单实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 复制arr中5个元素到v1中</span></span><br><span class="line">    <span class="built_in">copy_n</span>(arr, <span class="number">5</span>, v1.<span class="built_in">begin</span>());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-6-fill和fill-n">9.3.6 fill和fill_n</h3><p>fill() 和 fill_n() 算法提供了一种为元素序列填入指定值的简单方式，fill() 会填充整个序列； fill_n() 则以给定的迭代器为起始位置，<u>为指定个数</u>的元素设置值。</p><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center"><strong>fill(first, last, value</strong>)</td><td style="text-align:center">给容器在位置[first,last)，填充指定值value</td></tr><tr><td style="text-align:center"><strong>fill_n(first, 10, value</strong>)</td><td style="text-align:center">从指定位置first开始，填充n个value</td></tr></tbody></table><h2 id="9-4-总结">9.4 总结</h2><p>本文是《C++从零开始之C++篇》最后一篇博客，因此除了STL总结部分，还特意补充了《C++篇》的总结。</p><h3 id="9-4-1-STL总结">9.4.1  STL总结</h3><p>在这篇博客中，作者主要从：STL迭代器、STL容器、STL算法对STL进行了全面介绍，其中STL容器是重点阐述内容。</p><ul><li>迭代器：本质是指针的一层封装，具体实现为模板类，每个容器都有自己的迭代器类。迭代器主要功能是，提供了统一访问各种容器的方式，同时也使得算法和容器得于解耦，必要时可以作为“粘合剂”将二者联系起来。</li><li>容器：容器用来组织存储数据，具体实现也是模板类，本质是对数组、链表、红黑树、哈希表等基本数据结构的封装。最后作者还对实践中各种容器的选择，进行了简单总结。</li><li>算法：STL中提供了大量的算法供我们使用，具体实现是模板函数。理论上如果能使用STL中算法就尽量使用，本文主要对：sort、merge、find、reverse、copy_n、fill等<u>常用算法</u>进行了简略介绍。</li></ul><p>不过在本文成型中，也发现了一些不足：</p><ul><li>博文过长~3W字，放在一篇文章中显得过长，不利于阅读；</li><li>作者水平有限，对STL底层分析及STL算法等尚缺乏相关知识或经验，写作中难免部分描述不清。</li></ul><p>针对上述问题或未发现的一些问题，后期作者会尽量进行完善，并将更新记录同步在文后。</p><h3 id="9-4-2-C-总结">9.4.2  C++总结</h3><p>在重庆今天这个让人有点昏昏欲睡的下午，STL篇终于完结，不禁舒了一口气，长达2.7w的总结既是《C++篇》最后一篇博客，也应该是目前我写的最长的一篇博客。</p><p>也终于可以回过神来，做一个小结。</p><p>时间回到~3个月前，大约是11.20号，也就是9月结束找工作痛快玩了2个月后，我感到空虚过于无所事事，开始折腾起了自己的网站。在个人网站总结完自己实习和秋招笔记后，也萌发了学习C++的想法——主要是想到自己在腾讯实习从Java转到C++的痛苦经历，就还是在工作前提前学习一遍C++吧（菜是原罪）。</p><p>于是便有了<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 这个系列。</p><p>这是我第一次尝试写框架这么大的系列文章（光C++篇已经~13W+字），整个系列完成估计至少有40W字。当然字数多少并不重要，在这个过程中学习到很多，比如明确了一个很重要的原则：“<strong>写的文章不是给自己看的笔记，而是给别人看的博客”</strong>。秉着这个原则，每篇博客写完，我都会代入一个“旁观者”视角，自己读几遍，看逻辑是否清晰、文章是否有错误等。所以，每篇博客甚至整个系列其实一直在完善中。但限于自己的水平，错误和描述不清晰的地方依旧不少，比如每次我自己重读时依旧能发现（好消息是越来越少了）。</p><p>whatever，相信不断进步&amp;完善，总能达到满意的效果。</p><p><a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 接下来将主要专注于Linux/C++开发方面的知识，所以接下来的内容分为两大篇章：</p><ul><li>《C++从零开始之Linux/C++系统编程》</li><li>《C++从零开始之网络编程》</li></ul><p>和《C++从零开始之C++》互为《C++从零开始》的三部曲。</p><p>敬请期待！</p><h1>更新记录</h1><div class="timeline"><div class="timenode"><div class="meta"><p><p>2022-02-19：更新笔记</p></p></div><div class="body"><ol><li>第一次更新</li></ol></div></div></div><h1>参考资料</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">嗨课网-STL教程：https://haicoder.net/stl/stl-data-structure.html<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">迭代器（iterator）和指针（pointer）区别在哪？https://www.zhihu.com/question/54047747<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">STL 源码剖析：https://www.kancloud.cn/digest/stl-sources/<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++ STL: 容器vector源码分析：https://blog.csdn.net/Z_Stand/article/details/106866871<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">stl源码分析之vector：https://www.cnblogs.com/coderkian/p/3888429.html<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://favtutor.com/blogs/priority-queue-cpp">Priority Queue - Insertion, Deletion and Implementation in C++</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 教程 </tag>
            
            <tag> STL </tag>
            
            <tag> C++进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++从零开始（十）：C++进阶（上）模板</title>
      <link href="/p/51012/"/>
      <url>/p/51012/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，开始更新中…</p></blockquote><div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div><h2 id="八、模板">八、模板</h2><p>模板（Template）是C++中的泛型编程的基础。</p><p>就像类是一种模板，可以创建不同的对象。模板（Template），也可以创建不同的“对象”，只不过这个“对象”是<u>函数或类</u>。</p><p>类为同一类型的不同对象，提供了一份“通用的代码”。而产生所需的不同对象，只需实例化类生成对象时通过：</p><ol><li><p>分配内存：为不同对象分配不同内存，这决定了它们物理意义上的不同；</p></li><li><p>构造函数初始化：调用指定构造函数和参数进行初始化，可以让对象产生值意义上的不同。</p></li></ol><p>模板类似，<strong>根据类模板/函数模板可以实例化出不同的类/函数</strong>。这些类之间或函数之间的差异性，是在实例化时：</p><ol><li>编译器会为每个实例出来的类/函数分配不同空间；</li><li>另一方面，是实例化时我们可以指定<strong>不同的数据类型</strong>。</li></ol><p><strong>模板最大的好处便体现在第2点，让我们编写的类或函数<u>和数据类型无关</u>，从而实现了通用编程</strong>。</p><p>本文主要探讨以下内容：</p><ul><li>函数模板、类模板的应用场景及基本使用；</li><li>模板参数；</li><li>模板特化应用场景及使用，包含全特化和偏特化。</li></ul><h3 id="8-1-模板初识">8.1 模板初识</h3><h4 id="8-1-1-函数模板">8.1.1 函数模板</h4><p>我们可能实现过这么一个<code>mySwap</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(<span class="keyword">int</span>&amp;a , <span class="keyword">int</span>&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a =  b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这虽然简单到都不需要进行注释，但是如果哪一天我们希望交换的数类型是<code>long</code> 、<code>char</code>、<code>std::string</code> 等，这肯定就让你发愁了。</p><p>总不然定义茫茫多的、仅仅<u>数据类型不同</u>的函数吧？还好你知道函数模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template允许我们的函数不再受限于数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a =  b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> a1 = <span class="number">0</span>, b1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> a2 = <span class="number">0</span>, b2 = <span class="number">1</span>; </span><br><span class="line">    </span><br><span class="line">    mySwap&lt;<span class="keyword">int</span>&gt;(a,b);    <span class="comment">// （1）实例化模板指定数据类型</span></span><br><span class="line">    </span><br><span class="line">    mySwap&lt;<span class="keyword">int</span>&gt;(a1,b1);  <span class="comment">// （2）</span></span><br><span class="line">    </span><br><span class="line">    mySwap&lt;<span class="keyword">long</span>&gt;(a2,b2); <span class="comment">// （3）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为你的机智点赞。现在我们探讨一点高深的问题：</p><ul><li>函数模板实例化生成的“对象”在哪里？（1）、（2）两处会分别声明两个对象吗？</li><li>我可以将模板的声明（.h）和定义（.cpp）分开吗？</li></ul><h5 id="函数对象生成">函数对象生成</h5><p>模板实例化生成的函数，由编译器在编译阶段完成。（1）、（2）两处只会生成一个具体函数：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220210222030037.png" alt="image-20220210222030037"></p><p>注意到上图红框（1）、（2）处，都是执行函数模板生成的同一个函数。</p><h5 id="函数模板的声明和定义无法分开">函数模板的声明和定义无法分开</h5><p>模板的声明和定义不可以分开，如果你尝试这么做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swap.h</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T&amp; t1, T&amp; t2)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a =  b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;swap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    mySwap&lt;<span class="keyword">int</span>&gt;(a,b);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时会发生错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# g++ -std=c++11 test.cpp swap.cpp -o test.out</span><br><span class="line">/tmp/ccrmjFSC.o: In function `main&#x27;:</span><br><span class="line">test.cpp:(.text+0x25): undefined reference to `void mySwap&lt;int&gt;(int&amp;, int&amp;)&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>上述显示<u>链接时</u>找不到函数 <code>mySwap&lt;int&gt;(int&amp;, int&amp;)</code>的定义。</p><p>理一理整个编译过程：</p><ol><li><p>预编译：源文件<code>test.cpp</code>、 <code>swap.cpp</code>进行头文件替换等；</p></li><li><p>编译：<code>test.cpp</code>、 <code>swap.cpp</code> 分别单独编译生成可执行文件<code>test.o </code>、<code>swap.o</code>。</p><ul><li><p><code>test.cpp</code> 编译到 <code>mySwap&lt;int&gt;(a,b)</code> 发现一个函数调用，不过没关系，先在函数位置生成符号标记为未定义，在链接时再寻找这个函数；</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220210233031798.png" alt="image-20220210233031798"></p></li><li><p><code>swap.cpp</code> 进行编译，期望<code>swap.o</code> 生成我们所需的函数符号，但是很意外，没有任何符号被生成。</p></li></ul><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220210230529700.png" alt="image-20220210230529700"></p></li><li><p>所以汇编完成后，链接时无法找到<code>mySwap</code>任何相关定义，链接报错。</p></li></ol><p><strong>为什么<code>swap.o</code> 没有生成具体函数</strong>？</p><p>这是因为模板分两次编译：</p><ul><li>第一次编译发生在<code> swap.cpp</code>中（实例化前），仅对模板进行一些语法检查等，不生成具体函数，所以<code> swap.o</code> 符号表没有生成任何符号；</li><li>第二次编译是在<code>test.cpp</code>中（实例化时），编译到调用代码<code>mySwap&lt;int&gt;(a,b)</code>时，才会去编译<code> swap.cpp</code>中模板<code>mySwap</code>生成具体函数，<u>因为这个时候编译器才知道需要的类型是<code>int</code>，知道生成什么参数类型的函数</u>。</li></ul><p>但是<code>test.cpp</code> 的头文件 <code> swap.h</code> 仅包含函数模板<code>mySwap</code> 的声明，无法得知其定义，所以编译器无法根据其生成具体函数。</p><p>最终导致链接时发生错误。</p><p><strong>解决办法也很简单，模板的定义和声明都放在头文件中即可，这样生成函数对象的时候就可以看到函数模板完整定义</strong>。</p><p>试一试。</p><p>注意到我们还在<code>swap.h</code> 设置了宏开关，避免模板定义出现在头文件中时，而<code>swap.h</code>被多个文件引用，导致<code>mySwap</code> 出现重复定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swap.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> mySwap_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mySwap_H</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span>  <span class="comment">// 定义和声明在一块儿</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a =  b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;swap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    mySwap&lt;<span class="keyword">int</span>&gt;(a,b);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次编译一切正常：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220210234622994.png" alt="image-20220210234622994"></p><p>这个解决方案同样适合类模板。</p><p>什么是类模板？奥我们还没开始讲呢，看官老爷请看下文。</p><h4 id="8-1-2-类模板">8.1.2 类模板</h4><h5 id="认识类模板">认识类模板</h5><p>类模板同样使得我们编写的类<u>不用再和数据类型相关</u>，更加通用。</p><p>下面这个模板类<code>StaticArray</code>，允许我们创建不同成员数据类型的静态数组类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> size&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_array[size]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T* <span class="title">getArray</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_array; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_array[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单使用一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StaticArray&lt;<span class="keyword">int</span>, <span class="number">4</span>&gt; myArray1&#123;&#125;;</span><br><span class="line">StaticArray&lt;<span class="keyword">long</span>, <span class="number">10</span>&gt; myArray2&#123;&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉还不错。</p><p>也许你注意到，我们进行模板定义时好像有点“奇怪”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> size&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticArray</span></span></span><br></pre></td></tr></table></figure><p>这里还使用了参数 <code>int</code> ， C++称之为“非模板类型参数”，而不是只使用“模板类型参数”，即<code>typename</code> 。</p><h5 id="模板参数">模板参数</h5><p>“模板类型参数” ，是一个占位符类型，用于替代作为参数传入的类型。</p><p>“非模板类型参数”，则是预定义的类型，它允许以下类型：</p><ul><li>整数类型（浮点类型在C++20起开始支持）</li><li>枚举类型</li><li>指向类对象/函数/类成员函数的指针/引用</li><li><code>std::nullptr_t</code></li></ul><p>回顾我们之前的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaticArray&lt;<span class="keyword">int</span>, <span class="number">4</span>&gt; myArray1&#123;&#125;;</span><br></pre></td></tr></table></figure><p>实例化类模板<code>StaticArray</code> 时，编译器会将 <code>T</code>替换为<code>int</code>，<code>size</code> 替换为 <code>4</code> 。此时，<code>int</code> 是一个类型参数，而 <code>4</code> 是一个非类型参数。</p><p>最终<code>m_array</code>是 <code>int[4]</code> 类型。</p><p>最后注意，非模板类型参数只能用<u>表达式</u> 初始化，<u>非表达式</u> 是不被允许的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">4</span>;</span><br><span class="line">StaticArray&lt;<span class="keyword">int</span>, x&gt; myArray1&#123;&#125;;  <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="8-2-模板特化">8.2 模板特化</h3><p>模板使得我们不用再担心仅仅因为数据类型不同，而去定义多个极为类相似的函数或类。</p><p>因为我们的类模板/函数模板，可以处理不同数据类型。<u>也就是对于不同数据类型，我们都可以使用同一套模板代码</u>。</p><p>这会带来另一个问题：<strong>同一套代码，对特定的数据类型也许并不能很好地处理</strong>。</p><p>这就依旧需要我们针对特定数据类型，准备特定模板。</p><p>之前的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> size&gt; <span class="comment">// 类模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_array[size]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T* <span class="title">getArray</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_array; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_array[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i&#123; <span class="number">0</span> &#125;; i &lt; size; ++i)</span><br><span class="line">            std::cout &lt;&lt; m_array[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在有一个成员函数<code>print</code>期望可以打印<code>StaticArray</code> 的不同数据类型成员<code>m_array</code>。</p><p>注意，这个函数为数组<code>m_array</code> 每个元素都设置了空格 <code>' '</code> 。</p><p>这看起来没什么毛病：</p><ul><li><p>对于非字符类型，在每个数组元素之间放置一个空格是有意义的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure></li><li><p>但对于字符类型数组，<code>char</code>数组 ，你肯定不想打印出来的结果是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h e l l o  w o r l d !</span><br></pre></td></tr></table></figure></li></ul><p>所以我们希望函数模板（成员函数<code>print</code>此时也是模板，作为类模板的成员），针对特定的数据类型<code>char</code>，能进行特别处理。</p><p>这就是模板特化的思想， 模板特化具体又分为模板全特化和偏特化：</p><ul><li>全特化就是限定死模板实现的模板类型参数；</li><li>偏特化就是如果这个模板有多个类型参数，那么只限定其中的一部分。</li></ul><h4 id="8-2-1-函数模板特化">8.2.1 函数模板特化</h4><h5 id="函数模板特化初识">函数模板特化初识</h5><blockquote><p>先从普通函数模板特化说起，再谈论成员函数模板特化。</p></blockquote><p>函数模板有两个重要的概念：</p><ul><li><p>对于函数模板，只有全特化，不能偏特化；</p></li><li><p>编译器优先匹配：全特化&gt;偏特化&gt;函数模板。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* tmp.cpp */</span> </span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T1 a , T2 b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> fun&lt;<span class="keyword">int</span> ,<span class="keyword">char</span>&gt;(<span class="keyword">int</span> a, <span class="keyword">char</span> b) <span class="comment">// 声明时&lt;&gt;指定参数类型</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数不存在偏特化：下面的代码是错误的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;typename T1&gt;</span></span><br><span class="line"><span class="comment">void fun&lt;T1,char&gt;( T1 a , char b)  // 偏特化，error</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">2</span>);  <span class="comment">// 匹配模板函数，使用时&lt;&gt;指定参数类型</span></span><br><span class="line">    fun&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt;(<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">// 匹配全特化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到：</p><ul><li>全特化通过尖括号<code>&lt;int,char&gt;</code>，对模板两个类型参数都进行了限制，T1、T2分别限定为 int 、char；</li><li>偏特化<code>&lt;T1,char&gt;</code>，只对T2进行了限制为char，T1没有限制（部分限制）。</li></ul><p><strong>为什么函数模板不允许偏特化</strong>？</p><p>函数可以进行重载，函数模板也不例外，也可以进行重载。</p><p>但因为函数重载就可以实现偏特化，所以偏特化没有必要。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* tmp.cpp */</span> </span><br><span class="line"><span class="comment">// 函数模板1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T1 a , T2 b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 函数不存在偏特化：下面的代码是错误的</span></span><br><span class="line"><span class="comment">template&lt;typename T1&gt;</span></span><br><span class="line"><span class="comment">void fun&lt;T1,char&gt;( T1 a , char b);  // 偏特化，error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板2，重载了模板1</span></span><br><span class="line"><span class="comment">// 实现了偏特化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T1 a , <span class="keyword">char</span> b)</span></span>; <span class="comment">// 不是偏特化，注意没有&lt;&gt;</span></span><br></pre></td></tr></table></figure><p>到目前为止，函数模板的偏特化还没有得到C++标准的支持，不排除它在将来会被纳入标准的可能。</p><p>函数模板重载可以实现偏特化，那也应该能实现全特化吧？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数模板1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T1 a , T2 b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.全特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> fun&lt;<span class="keyword">int</span> ,<span class="keyword">char</span>&gt;(<span class="keyword">int</span> a, <span class="keyword">char</span> b); <span class="comment">// &lt;&gt;指定参数类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.模板2，重载了函数模板1</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p>1、2两处代码被视为是等价的，<strong>全特化就是模板1的重载</strong>。</p><p>那为啥全特化被允许使用？不明白，有机会厘清一下。</p><p><strong>不过请注意，全特化的函数模板已经不能称之为模板</strong>。</p><p>全特化接管了编译器的工作，实例化出了函数。查看<code>tmp.cpp</code>的符号表，也发现确实已有符号生成：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220211115932016.png" alt="image-20220211115932016"></p><p>而模板（及偏特化）只有在编译到调用代码时才会进行实例化，生成具体函数符号。</p><h5 id="成员函数模板全特化">成员函数模板全特化</h5><p>继续前面的例子，我们采用函数模板全特化解决。注意，此时<code>print</code>是成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> size&gt; <span class="comment">// 类模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_array[size]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T* <span class="title">getArray</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_array; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_array[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i&#123; <span class="number">0</span> &#125;; i &lt; size; ++i)</span><br><span class="line">            std::cout &lt;&lt; m_array[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// 成员函数模板全特化</span></span><br><span class="line"><span class="keyword">void</span> StaticArray&lt;<span class="keyword">char</span>, <span class="number">13</span>&gt;::<span class="built_in">print</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; <span class="number">13</span>; ++count)</span><br><span class="line">std::cout &lt;&lt; m_array[count];  <span class="comment">// 去除了字符之间的空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，<code>template &lt;&gt;</code> 模板参数已为空，代码26行处<code>StaticArray&lt;char, 13&gt;</code>将原本参数<code>T</code> 被替换为<code>char</code> ，<code>size</code> 被替换为<code>13</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StaticArray&lt;<span class="keyword">char</span>, <span class="number">13</span>&gt; char13&#123;&#125;;</span><br><span class="line">    std::<span class="built_in">strcpy</span>(char13.<span class="built_in">getArray</span>(), <span class="string">&quot;Hello world!&quot;</span>);  <span class="comment">// 数组不能作为左值，用strcpy复制</span></span><br><span class="line">    char13.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次编译输出正常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure><p>但这个全特化例子，对模板所有类型的参数都限定死了，包括<code>size</code>。所以，我们只能处理特定长度为<code>13</code>的字符串。</p><p>虽然我们很想使用偏特化，只对<code>T</code>进行限制为<code>char</code> ，对<code>size</code> 不进行限制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> size&gt; <span class="comment">// 函数模板偏特化？error</span></span><br><span class="line"><span class="keyword">void</span> StaticArray&lt;<span class="keyword">char</span>, size&gt;::<span class="built_in">print</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; <span class="number">13</span>; ++count)</span><br><span class="line">std::cout &lt;&lt; m_array[count]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++不允许呀！那就试试函数重载吧。</p><p>但是成员函数<code>print()</code>根本没办法重载，因为它没有任何参数来对<code>T</code> 进行限制。除非它是一个普通函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> size&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(StaticArray&lt;T, size&gt;&amp; array)</span> <span class="comment">// 非成员函数，有一个StaticArray类型参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; size; ++count)</span><br><span class="line">std::cout &lt;&lt; array[count] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> size&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(StaticArray&lt;<span class="keyword">char</span>, size&gt;&amp; array)</span> <span class="comment">// 函数重载，此时ok</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; size; ++count)</span><br><span class="line">std::cout &lt;&lt; array[count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不过我们可以迂回一点：函数模板不能偏特化，不代表类模板不能偏特化（类没有重载，不会受到限制）。我们可以偏特化出一个类模板，专门让成员函数<code>print</code>处理不同长度的<code>char</code> 类型数据</strong>。</p><p>这就是类模板的偏特化。</p><h4 id="8-2-2-类模板特化">8.2.2 类模板特化</h4><h5 id="类模板全、偏特化">类模板全、偏特化</h5><p>我们使用类模板偏特化，让成员函数<code>print</code> 可以处理不同长度的<code>char</code>类型数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template &lt;typename T, int size&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> size&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticArray</span>&lt;</span><span class="keyword">char</span>,size&gt; <span class="comment">// 类模板偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> m_array[size]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">getArray</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_array; &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_array[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i&#123; <span class="number">0</span> &#125;; i &lt; size; ++i)</span><br><span class="line">            std::cout &lt;&lt; m_array[i];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>试一试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StaticArray&lt;<span class="keyword">char</span>, <span class="number">7</span>&gt; char7&#123;&#125;;  <span class="comment">// 长度为7</span></span><br><span class="line">    std::<span class="built_in">strcpy</span>(char7.<span class="built_in">getArray</span>(), <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    StaticArray&lt;<span class="keyword">char</span>, <span class="number">13</span>&gt; char13&#123;&#125;; <span class="comment">// 长度为13</span></span><br><span class="line">    std::<span class="built_in">strcpy</span>(char13.<span class="built_in">getArray</span>(), <span class="string">&quot;Hello world!&quot;</span>);  </span><br><span class="line">    </span><br><span class="line">    char7.<span class="built_in">print</span>();  <span class="comment">// ok</span></span><br><span class="line">    char13.<span class="built_in">print</span>(); <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220211140112484.png" alt="image-20220211140112484"></p><p>类模板全特化使用类似，这里仅做一个简单对比：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> size&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticArray</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> size&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticArray</span>&lt;</span><span class="keyword">char</span>,size&gt;;  <span class="comment">// 尖括号指定参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticArray</span>&lt;</span><span class="keyword">char</span>,<span class="number">14</span>&gt;;   <span class="comment">// 尖括号指定参数</span></span><br></pre></td></tr></table></figure><h5 id="指针偏特化">指针偏特化</h5><p>先观察下面这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类模板1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板1的全特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span>&lt;</span><span class="keyword">char</span>*&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板2，模板1的偏特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span>&lt;</span>T*&gt;;</span><br></pre></td></tr></table></figure><p>或许让你有点惊讶，类模板2依旧被视为是类模板1的偏特化版本。<u>即使我们没有准确地指定底层类型，只是告诉编译器它用于指针类型</u>。</p><p>下面是具体实例应用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板1：只适合存储（单个）非指针类型成员</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Storage</span>(T value): m_value &#123; value &#125; <span class="comment">// 只能初始化非指针成员（单个），值复制方式</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Storage</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板2：模板1的偏特化版本，可以存储（单个）指针类型成员</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span>&lt;</span>T*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Storage</span>(T* value): m_value &#123; <span class="keyword">new</span> T &#123; *value &#125; &#125; <span class="comment">// 适合初始化（单个）指针成员，new分配</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Storage</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板1的全特化版本：适合存储char*指针数组</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span>&lt;</span><span class="keyword">char</span>*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Storage</span>(<span class="keyword">char</span>* value)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span> length &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">while</span> (value[length] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">++length;</span><br><span class="line">        ++length;</span><br><span class="line">        m_value = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; length; ++count)</span><br><span class="line">m_value[count] = value[count];</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Storage</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Storage&lt;<span class="keyword">int</span>&gt; my_int &#123; <span class="number">5</span> &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> x &#123; <span class="number">7</span> &#125;;</span><br><span class="line"><span class="function">Storage&lt;<span class="keyword">int</span>*&gt; <span class="title">my_int_ptr</span><span class="params">(&amp;x)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *name &#123; <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">40</span>]&#123; <span class="string">&quot;royhuang&quot;</span> &#125; &#125;;</span><br><span class="line">    <span class="function">Storage&lt; <span class="keyword">char</span>*&gt; <span class="title">my_name</span><span class="params">(name)</span></span>;</span><br><span class="line">    <span class="keyword">delete</span>[] name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板相关介绍over，下章我们开始介绍C++标准库STL。</p><h2 id="更新记录">更新记录</h2><div class="timeline"><div class="timenode"><div class="meta"><p><p>2022-02-11 ：更新笔记</p></p></div><div class="body"><ol><li>第一次更新</li></ol></div></div></div><h2 id="参考资料">参考资料</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kejiang.co/2021/10/18/c-%E6%A8%A1%E6%9D%BF%E5%81%8F%E7%89%B9%E5%8C%96%E4%B8%8E%E5%85%A8%E7%89%B9%E5%8C%96/">C++ 模板偏特化与全特化 – 珂酱 (kejiang.co)</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++模板template用法总结：https://blog.csdn.net/qq_35637562/article/details/55194097<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 教程 </tag>
            
            <tag> C++基础 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++从零开始（九）：面对对象（下）继承和虚函数</title>
      <link href="/p/60158/"/>
      <url>/p/60158/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，开始更新中…</p></blockquote><div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div><h2 id="七、继承和虚函数">七、继承和虚函数</h2><h3 id="7-1-继承">7.1 继承</h3><p>面对对象三大特性：封装、继承、多态，继承在面对对象中的重要性不言而喻。</p><p>本章主要探讨的问题：</p><ul><li>为什么需要继承？</li><li>继承的访问权限和成员访问权限的区别？</li><li>继承的派生类出现和基类同样（函数签名、返回类型一致）的函数，会发生什么？</li><li>派生类对象构造时，是如何进行构造的？</li><li>多重继承优缺点及菱形问题。</li></ul><h4 id="7-1-1-为什么需要继承？">7.1.1 为什么需要继承？</h4><p>想象这么一个问题：如果存在一些简单、基本的对象，如何来创建一个新对象？</p><p>通常我们使用对象组合和对象继承两种方式。</p><ul><li><p><strong>对象组合</strong>。这符合我们最直观的认知，适合新对象与基本对象之间存在<code>has-a</code> 关系。</p><p>例如，一个房间有一张桌子和凳子。我们创建一个<code>ClassRoom</code>类，然后组合<code>table</code> 和 <code>chair</code>构成<code>ClassRoom</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassRoom</span> // 教室</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Table _table; <span class="comment">// 桌子</span></span><br><span class="line">    Chair _chair; <span class="comment">// 椅子</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">ClassRoom</span>(Table table,Chair chair):_table(table),_chair(chair)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>对象继承</strong>，也是本节的重点。与对象组合通过组合其他对象来创建新对象不同，继承直接获取其他对象的属性和行为，然后进行扩展来创建新对象。</p><p>下面的<code>ClassRoom</code> 便继承了<code>Room</code> ，获取了<code>Room</code>的<code>price</code> 、<code>area</code> 属性，然后再进行扩展。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> _price;</span><br><span class="line">    <span class="keyword">double</span> _area;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">Room</span>(<span class="keyword">double</span> price,<span class="keyword">double</span> area):_price(price),_area(area)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassRoom</span>:</span> <span class="keyword">public</span> Room</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Table _table; <span class="comment">// 桌子</span></span><br><span class="line">    Chair _chair; <span class="comment">// 椅子</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">ClassRoom</span>(Table table,Chair chair,<span class="keyword">double</span> price,<span class="keyword">double</span> area):</span><br><span class="line">    _table(table),_chair(chair),<span class="built_in">Room</span>(price,area)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>上例的例子很好地展示了继承的作用：<strong>派生类通过继承来重用被继承类（基类），然后派生类可以添加、修改或隐藏相关功能来进行扩展</strong>。</p><p>这使得继承：</p><ul><li>提高了代码的复用性、维护性</li><li>类与类之间产生了联系，这是多态的前提</li></ul><p>不过另一方面，继承有违开发原则“高内聚、低耦合”，因为继承会增加类的耦合性（类与类之间关系变得紧密）。</p><p>whatever，善用继承是熟练运用OOP（Object Oriented Programming，OOP）思想的重要体现。</p><p>上面的例子也带来一些思考：</p><ul><li><p>继承访问权限是什么？和之前的类成员访问权限有什么不同吗？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassRoom</span>:</span> <span class="keyword">public</span> Room</span><br></pre></td></tr></table></figure></li><li><p>派生类怎么添加、修改或隐藏基类相关功能？</p></li><li><p>派生类实例化时，构造函数、析构函数的顺序有什么讲究吗？为什么存在这么一个顺序？</p></li><li><p>很多语言如Java是不允许多重继承的，而C++为什么要允许多重继承，多重继承会带来什么问题吗？</p></li></ul><p>带着问题来和我一起认识一下吧。</p><h4 id="7-1-2-继承相关概念">7.1.2 继承相关概念</h4><h5 id="继承权限和访问符">继承权限和访问符</h5><p>先从类成员访问符说起，类成员访问控制符实现了类的封装。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _public &#123;&#125;;    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> _protected &#123;&#125;; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _private &#123;&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>回顾一下private、public访问符：</p><ul><li>private：私有成员，该成员仅在类内可以被访问，在类体外（包括派生类）是隐藏状态；</li><li>public：公有成员，该成员在类内、类外也都可以被访问，是类对外提供的可访问接口。</li></ul><p>在继承中，我们引入了第三种访问修饰符：</p><ul><li>protected：保护成员，和私有成员类似，不过在<u>派生类</u>可以被访问。</li></ul><p>回到我们本小节的重点：继承权限的访问符。</p><p><strong>派生类隐式包含了基类的副本。不同继承权限的访问符，本质就是修改<u>基类副本</u>的<u>公有成员</u>、<u>保护成员</u>，在<u>派生类中</u>的访问权限（<u>私有成员</u>不受影响</strong>）。</p><p>核心概念强调：</p><ul><li>派生类并非是修改了原有类（基类）成员的访问权限，而是修改派生类持有基类的副本原本的访问权限；</li><li>继承方式对私有成员无影响。</li></ul><p>不同继承权限的基类副本访问权限修改规则：</p><ul><li>public继承：所有基类成员副本都保持原有权限；</li><li>private继承：所有基类成员副本被修改为private；</li><li>protected继承：所有基类成员副本被修改为protected；</li></ul><p>public继承是使用最常用继承方式，其次是private继承，protected继承基本不使用。</p><p>我们来实际验证下上述结论（protected继承不举例，因为基本不用）。</p><p><strong>public继承</strong>。</p><p>注意到，派生类中的基类副本成员访问权限和基类一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_public &#123;&#125;;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_protected &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_private &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pub</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pub</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_public = <span class="number">1</span>;    <span class="comment">// okay</span></span><br><span class="line">        m_protected = <span class="number">2</span>; <span class="comment">// okay</span></span><br><span class="line">        <span class="comment">// m_private = 3;   // not okay</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base;</span><br><span class="line">    base.m_public = <span class="number">1</span>;    <span class="comment">// okay</span></span><br><span class="line">    base.m_protected = <span class="number">2</span>; <span class="comment">// not okay</span></span><br><span class="line">    base.m_private = <span class="number">3</span>;   <span class="comment">// not okay</span></span><br><span class="line">    <span class="comment">// 在派生类中和基类成员访问权限一致</span></span><br><span class="line">    Pub pub;</span><br><span class="line">    pub.m_public = <span class="number">1</span>;     <span class="comment">// okay</span></span><br><span class="line">    pub.m_protected = <span class="number">2</span>;  <span class="comment">// not okay</span></span><br><span class="line">    pub.m_private = <span class="number">3</span>;    <span class="comment">// not okay</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>private继承</strong>。</p><p>注意到，派生类中的基类副本成员的访问权限都被修改为private。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_public &#123;&#125;;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_protected &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_private &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pri</span>:</span> <span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pub</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// m_public = 1;    // not okay</span></span><br><span class="line">        <span class="comment">// 此时访问的基类成员，访问权限按基类成员来</span></span><br><span class="line">        m_protected = <span class="number">2</span>;    <span class="comment">// okay</span></span><br><span class="line">        <span class="comment">// m_private = 3;   // not okay</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base;</span><br><span class="line">    base.m_public = <span class="number">1</span>;    <span class="comment">// okay</span></span><br><span class="line">    <span class="comment">// 基类m_protected访问权限依旧是protected，类外无法访问</span></span><br><span class="line">    base.m_protected = <span class="number">2</span>; <span class="comment">// not okay</span></span><br><span class="line">    base.m_private = <span class="number">3</span>;   <span class="comment">// not okay</span></span><br><span class="line">    <span class="comment">// 派生类中的基本副本所有成员的访问权限为private</span></span><br><span class="line">    Pub pub;</span><br><span class="line">    pub.m_public = <span class="number">1</span>;     <span class="comment">// not okay</span></span><br><span class="line">    pub.m_protected = <span class="number">2</span>;  <span class="comment">// not okay，派生类中的m_protected已经是private权限，无法访问</span></span><br><span class="line">    pub.m_private = <span class="number">3</span>;    <span class="comment">// not okay</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="using修改访问权限">using修改访问权限</h5><p>通过继承权限设置，虽然可以修改派生类基类副本原本的访问权限，但也有局限性：</p><ul><li>不能修改基类副本单个成员访问权限，只能全部修改；</li><li>无法修改private成员权限（比如为private→public）。</li></ul><p>using弥补了这个缺陷。</p><p>例如，我们可以只将基类某个公共成员设为私有（通常用来隐藏基类中某个功能）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_value &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">using</span> Base::m_value; <span class="comment">// 类外访问的派生类基类副本成员m_value，并修改为private，无法访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Derived</span>(<span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">m_value = value; <span class="comment">// 这个时候访问的是基类成员m_value（public修饰，不是派生类的基类副本），所以还可以访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived derived &#123; <span class="number">7</span> &#125;;</span><br><span class="line">std::cout &lt;&lt; derived.m_value; <span class="comment">// error，无法访问</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自然，也可以将私有设为公有（不过这破坏了类的封装性，慎用）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> value): m_value &#123; value &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; std::cout &lt;&lt; m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 此时初始化基类成员m_value，只能通过调用基类构造函数这种方式，因为它是private，无法直接访问</span></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="keyword">int</span> value): Base &#123; value &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">using</span> Base::printValue;  <span class="comment">// 派生类基本副本成员m_value访问权限修改为public</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived &#123; <span class="number">7</span> &#125;;</span><br><span class="line">    derived.<span class="built_in">printValue</span>(); <span class="comment">// 7，ok</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="函数重写">函数重写</h5><p>前面我们提到过继承的好处：“派生类通过继承来重用被继承类（基类），然后可以通过添加、修改或隐藏相关功能可以进一步扩展” 。</p><p><strong>这里的：<u>添加、修改或隐藏相关功能</u>，是如何做到的</strong>？</p><p>答案是通过函数重写。</p><p>理解这个问题，首先要明白派生类对象是如何调用一个函数的（不考虑虚函数）：</p><ol><li>编译器首先查看该成员是否存在派生类中，如果不存在转2；</li><li>沿着继承链往上走，查看是存在任何父类定义中，如果不存在转3；</li><li>不存在该函数，调用失败。</li></ol><p>函数重写便是利用这个调用顺序：<strong>在派生类中定义一个和基类<u>完全一致</u>（不止同名，而且函数签名、返回类型完全一致）的函数，在函数体对原有功能进行修改，达到添加、修改、隐藏相关功能。因为编译器首先调用的会是派生类中的函数</strong>。</p><p>看一个实例吧。</p><p>下面派生类中对基类的<code>print</code> 实现了隐藏，你永远无法通过派生类访问到基类的<code>print</code>方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Derived &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived derived;</span><br><span class="line">derived.<span class="built_in">print</span>(); <span class="comment">// calls derived::print()</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived</span><br></pre></td></tr></table></figure><p>完全隐藏基类的方法也许并不是你所需要的，但你还可以对基类的<code>print</code>添加功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        Base::<span class="built_in">print</span>();  <span class="comment">// 范围运算符调用基类print函数</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Derived &quot;</span>; <span class="comment">// 添加打印输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base</span><br><span class="line">Derived</span><br></pre></td></tr></table></figure><p><strong>同时，我们应该注意到函数重载和函数重写的异同</strong>。</p><ul><li>函数重写分别位于基类、派生类，而函数重载位于同一类中。</li><li>函数重写的函数签名完全一致（不止同名），而函数重载仅仅是同名，函数签名并不同。</li><li>函数重写是运行时多态的一种体现（一个方法在不同的子类中表现出不同的行为），为了能对基类的功能实现修改、隐藏等而生，而函数重载是为了解决命名空间污染问题而生。</li></ul><h4 id="7-1-3-派生类构造函数">7.1.3 派生类构造函数</h4><p>我们知道派生类继承至基类，那派生类进行实例化时：</p><ul><li><p>基类部分由谁负责初始化？是基类构造函数吗？</p></li><li><p>派生类构造函数只负责初始化派生类扩展部分吗？</p></li><li><p>基类和派生类构造函数执行顺序是怎么样的？</p></li></ul><h5 id="构造顺序">构造顺序</h5><p>上述答案分别是：</p><ul><li>基类部分初始化由基类构造函数负责；</li><li>派生类构造函数只负责派生类扩展部分初始化；</li><li>C++ 分阶段构造派生类，从最基类（在继承树的顶部）开始，到最子类（在继承树的底部）结束。</li></ul><p>验证一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;A\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;B\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;C\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;D\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;构造 A: \n&quot;</span>;</span><br><span class="line">    A a;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;构造 B: \n&quot;</span>;</span><br><span class="line">    B b;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;构造 C: \n&quot;</span>;</span><br><span class="line">    C c;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;构造 D: \n&quot;</span>;</span><br><span class="line">    D d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">构造 A：</span><br><span class="line">A</span><br><span class="line">构造 B：</span><br><span class="line">A </span><br><span class="line">B</span><br><span class="line">构造 C：</span><br><span class="line">A </span><br><span class="line">B </span><br><span class="line">C</span><br><span class="line">构造 D：</span><br><span class="line">A </span><br><span class="line">B </span><br><span class="line">C </span><br><span class="line">D</span><br></pre></td></tr></table></figure><p>可以看到，</p><ul><li>C++ 总是首先构造“第一个”或“最基”类，然后它按顺序遍历继承树并构造每个派生类；</li><li>基类构造函数和派生类构造各自负责相应的部分。</li></ul><p>顺便一提，析构函数执行顺序恰恰和构造函数相反。</p><p><strong>为什么要按这种构造顺序</strong>？</p><p>子类继承了父类，了解父类的一切，且经常需使用父类的成员或函数，但父类对子类一无所知。为了安全，首先实例化父类可以确保父类成员在被派生类使用前，就已经准备好了。</p><p>另一方面，迄今为止，派生类实例化时的基类构造函数都是<u>隐式</u>调用的。</p><ul><li>如果我们想<u>在派生类初始化基类成员</u>，该如何实现？</li><li>能不能直接<u>显式</u>调用基类构造函数初始化？</li></ul><h5 id="初始化基类成员">初始化基类成员</h5><p>为了方便说明，先将基类成员<code>m_id</code> 声明为public，试想如何在派生类中对其初始化？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> id=<span class="number">0</span>) : m_id&#123; id &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;In base, m_id = &quot;</span> &lt;&lt; id &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>既然<code>m_id</code>已被声明为public，容易想到两种初始化方式：</p><ul><li>派生类构造函数成员列表<u>初始化</u>；</li><li>派生类构造函数体内<u>赋值</u>。</li></ul><p>但第一种方式不被C++允许，因为第一种成员列表方式会导致<code>m_id</code> 在基类和派生类初始化两次，而初始化只能有一次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_cost &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// error，不被允许</span></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="keyword">double</span> cost, <span class="keyword">int</span> id): m_id&#123; id &#125;,m_cost&#123; cost &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;In Derived, m_cost = &quot;</span> &lt;&lt; m_cost &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cost; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二种方式是允许的，因为这是重新赋值，不是初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_cost &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="keyword">double</span> cost, <span class="keyword">int</span> id): m_cost&#123; cost &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    m_id&#123; id &#125;;  <span class="comment">// ok</span></span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;In Derived, m_cost = &quot;</span> &lt;&lt; m_cost &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cost; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但这有两个问题：</p><ul><li>不够优雅，是重新赋值，而不是直接初始化；</li><li>如果<code>m_id</code> 是private/const/引用，这种方式也无法使用。</li></ul><p><strong>如果可以在派生类直接调用基类构造函数初始化，那该多好呀</strong>！</p><p>现在我们在派生类的构造函数成员列表中，显示调用了基类构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 私有</span></span><br><span class="line">    <span class="keyword">int</span> m_id &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> id=<span class="number">0</span>) : m_id&#123; id &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;In base, m_id = &quot;</span> &lt;&lt; id &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_cost &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 直接调用基类构造函数Base&#123; id &#125;初始化</span></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="keyword">double</span> cost, <span class="keyword">int</span> id): Base&#123; id &#125;,m_cost&#123; cost &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;In Derived, m_cost = &quot;</span> &lt;&lt; m_cost &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cost; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d&#123;<span class="number">2.33</span>,<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In base, m_id = 1</span><br><span class="line">In Derived, m_cost = 2.33</span><br></pre></td></tr></table></figure><p>以上完美解决了初始化基类成员的需求，但注意：</p><ul><li><p><u>基类构造函数<code>Base&#123; id &#125;</code>只被执行了一次</u>，依旧是从继承链顶部往下构造，派生类只是指定了基类构造函数的参数；</p></li><li><p>成员列表的基类构造函数<code>Base&#123; id &#125;</code> 的顺序无关紧要，无论如何，基类构造函数总是率先执行的：</p><ol><li>首先执行基类构造函数（根据派生类中指定的参数）；</li><li>然后执行派生类构造函数<u>成员列表</u>初始化；</li><li>最后执行派生类构造<u>函数体内代码</u>。</li></ol></li></ul><h4 id="7-1-4-多重继承">7.1.4 多重继承</h4><h5 id="多重继承优缺点">多重继承优缺点</h5><p>在前面我们提到：</p><blockquote><p>很多语言如Java是不允许多重继承的，C++为什么要允许多重继承，多重继承会带来什么问题吗？</p></blockquote><p>这是个很有意思的问题，我们来说说多重继承的优缺点。</p><p>多重继承的优点很明显：<strong>简单，清晰，更有利于复用。</strong></p><p>但它的缺点同样明显：</p><ol><li><p><strong>二义性</strong>。如果两个基类（B、C）具有同名的方法（do()），在派生类中必须指定此方法来源于哪个基类。如下图：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220205112328276.png" alt="image-20220205112328276"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D d&#123;&#125;;</span><br><span class="line">d.<span class="built_in"><span class="keyword">do</span></span>();    <span class="comment">// error</span></span><br><span class="line">d.B::<span class="built_in"><span class="keyword">do</span></span>(); <span class="comment">// ::范围限定，ok</span></span><br></pre></td></tr></table></figure></li><li><p><strong>菱形继承</strong>。但如果是<u>菱形继承</u>，不但会带来二义性问题，还会使得派生类中具有重复拷贝的问题。</p><p>如下图：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220205112707264.png" alt="image-20220205112707264"></p><p>派生类D中拷贝了<u>两份</u>A的副本！另一方面这也加重了二义性问题，因为<code>a</code> 也存在了二义性问题，虽然它只在A中被定义了<u>一次</u>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D d&#123;&#125;;</span><br><span class="line">d.<span class="built_in">a</span>();     <span class="comment">// error</span></span><br><span class="line">d.B::<span class="built_in">a</span>();  <span class="comment">// ::范围限定，ok</span></span><br></pre></td></tr></table></figure><p>范围限定虽然能解决，但终究不是好方法，不够优雅，重复数据拷贝的问题也依旧存在。</p></li></ol><p>这也是为什么C#和Java中不支持类多继承，而是使用类单继承和接口多继承设计替代类多继承。</p><p>既然C++选择了多重继承，我们来看看二义性和重复拷贝的问题如何解决：</p><ul><li>二义性：可通过范围限定符<code>::</code> 消除二义性；</li><li>重复拷贝：存在菱形继承中，通常使用虚继承来解决。</li></ul><h5 id="虚继承">虚继承</h5><p>类通过虚继承可以指出<u>它希望共享的虚基类</u>，对于虚基类，无论在派生层次中被继承多少次，都<u>只存在一份</u>共享的基类子对象。</p><p>在上例中，我们可以让类B、C都虚继承A，这样A在D中只会有一次拷贝。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220205114829756.png" alt="image-20220205114829756"></p><p>实际编码验证：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D d&#123;&#125;;</span><br><span class="line">    d.a;  <span class="comment">// ok，避免了重复拷贝，也间接消除了A中成员的二义性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B、C、D共享了同一份A的副本。</p><p>注意，虚继承只是避免了重复拷贝的问题，并没有消除二义性，B、C中<code>doSomething</code> 依旧存在二义性问题。</p><p>我们熟悉的<code>istream</code>和<code>ostream</code> 也是虚继承于<code>ios</code> ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> ios &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> ios &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iostream</span> :</span> <span class="keyword">public</span> istream, <span class="keyword">public</span> ostream &#123;...&#125;;</span><br></pre></td></tr></table></figure><p>最后我们再来探讨下，虚继承和非虚继承方式的<u>构造函数执行顺序</u>：</p><ul><li>非虚继承，构造函数执行顺序：A→B→<strong>A</strong>→C→D；</li><li>虚继承，构造函数执行顺序：A→B→C→D。</li></ul><p>可见非虚继承中，A被初始化了两次，虚继承中A确实只被初始化了一次。</p><p>析构函数执行顺序恰相反：</p><ul><li>非虚继承，析构函数执行顺序：D→C→<strong>A</strong>→B→A；</li><li>虚继承，析构函数执行顺序：D→C→B→A。</li></ul><h5 id="最佳实践">最佳实践</h5><p>事实证明，大多数可以使用多重继承解决的问题，也可以使用单继承来解决。</p><p><strong>另一方面，很多现代编程语言，如 Java 和 C#，将类限制为普通类的单继承，只允许接口类的多继承</strong>。</p><p>所以，我们应该尽量避免在C++中使用多重继承，除非：</p><ul><li>这个时候多继承是最好的选择；</li><li>被多继承的类是设计良好的<u>接口类</u>。</li></ul><h3 id="7-2-虚函数">7.2 虚函数</h3><p>首先回忆下C++的多态性行为表现：对象在不同上下文环境会表现出不同的特性。</p><p>这有点抽象，我们具体一点。</p><p>C++支持两种多态：</p><ul><li>编译时多态（静态多态）：通过重载函数实现，函数地址早绑定，编译期间就可以确定函数的链接地址；</li><li>运行时多态（动态多态）：通过虚函数实现，函数地址晚绑定，运行期间根据虚表来确定函数链接地址。</li></ul><p>重载的同名函数，在函数签名不同（不同的上下文环境），会调用不同的函数（表现不同的行为）。</p><p><strong>虚函数的作用便体现在C++的动态多态性上，可以根据调用函数的对象的类型（不同的上下文环境），会执行不同的虚函数（表现不同的行为）。</strong></p><p>其大致实现过程如下：</p><ol><li>首先，在基类的函数前加上<u>virtual</u>关键字，也就是虚函数，同时在派生类中<u>重写</u>该函数；</li><li>然后，声明基类类型的指针（或引用），该指针（或引用）会指向派生类对象；</li><li>最后，使用基类指针（或引用）调用该虚函数，<u>如果指向对象类型是派生类，就调用派生类的函数；如果指向对象类型是基类，就调用基类的函数</u> 。</li></ol><p>这便通过虚函数实现了C++动态多态性，下面我们开始具体探讨：</p><ul><li>基类指针/引用指向派生类对象，会发生什么？</li><li>虚函数是什么？虚函数实现多态的原理？</li><li>析构函数、构造函数和虚函数之间的一些问题？</li><li>基类指针/引用↔和派生类指针/引用之间的转换是安全的吗？（上行转换和下行转换）</li><li>对象切片引发的一些编码问题。</li></ul><h4 id="7-2-1-指向派生类对象的基类指针和引用">7.2.1 指向派生类对象的基类指针和引用</h4><h5 id="认识基类指针和引用">认识基类指针和引用</h5><p>我们了解到，派生类由两部分组成：</p><ul><li>继承的基类部分；</li><li>自身扩展的部分。</li></ul><p>好了，愉快地接受这个设定后。下面<u>类实例内存布局</u>就很容易接受了：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220209134126964.png" alt="image-20220209134126964"></p><p>注意，派生类Derived实例化后内存布局：<strong>先</strong>拷贝基类部分，<strong>再</strong>扩展了自身部分，所以基类部分在<strong>前</strong>。</p><p>现在有一个很有意思的问题：</p><p><strong>理论上，派生类对象是包含基类部分的，那基类指针或引用能指向派生类对象吗？如果能，基类指针能使用派生类扩展部分的成员吗</strong>？</p><p>答案分别是：能，不能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基类指针和引用都可以指向派生类</span></span><br><span class="line">    Base&amp; rBase =  derived ;</span><br><span class="line">    Base* pBase =  &amp;derived;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基类指针只能调用基类的方法（基类引用同理）</span></span><br><span class="line">    pBase-&gt;<span class="built_in">getName</span>();  <span class="comment">// base，调用的是基类方法</span></span><br><span class="line">    pBase-&gt;<span class="built_in">getValue</span>(); <span class="comment">// 5</span></span><br><span class="line">    <span class="comment">//pBase-&gt;getValueDoubled();  // error，不能调用派生类的方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>另一方面，你可能会说这个例子很傻：“当我能使用派生对象时，为什么要使用指向派生对象基类的指针或引用</strong>？”</p><p>这涉及到多态的“接口重用原则”：不论传递过来的究竟是类的哪个对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。</p><p>我们举例说明。</p><h5 id="为什么需要基类指针和引用？">为什么需要基类指针和引用？</h5><p>假设有多个派生类：Derived、Derived1、Derived2…等都派生于Base。现在外部有一个函数<code>printName</code>要求打印它们的名字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">(Derived* pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout&lt;&lt;pd-&gt;<span class="built_in">getName</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个函数只能打印Derived的名字，Derived1等不能打印，因为Derived和Derived1等是不同类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="built_in">printName</span>(d); <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">Derived1 d1;</span><br><span class="line"><span class="built_in">printName</span>(d1); <span class="comment">// error，Derived类型不匹配Derived1</span></span><br></pre></td></tr></table></figure><p>所以，为了Derived1、Derived2…DerivedN，都能被打印，我们不得不再定义<code>N</code>个基本一样的<code>printName</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">(Derived1* pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout&lt;&lt;pd-&gt;<span class="built_in">getName</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">(Derived2* pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout&lt;&lt;pd-&gt;<span class="built_in">getName</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这肯定会让你有点无奈，幸运的是，我们知道基类指针（或引用）可以接受派生类对象。于是一切便不用这么麻烦：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">(Base* pBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout&lt;&lt;pBase-&gt;<span class="built_in">getName</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line">Derived1 d1;</span><br><span class="line">Derived2 d2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printName</span>(d);   <span class="comment">// ok, 打印：Base</span></span><br><span class="line"><span class="built_in">printName</span>(d1);  <span class="comment">// ok, 打印：Base</span></span><br><span class="line"><span class="built_in">printName</span>(d2);  <span class="comment">// ok, 打印：Base</span></span><br></pre></td></tr></table></figure><p>但细心的你也注意到，打印全都是基类的名：即调用的是基类的<code>getName</code>函数，而不是派生类的<code>getName</code> 函数。显然，此时并没有体现类的动态多态性，因为<code>getName</code>函数的链接地址在<u>编译时</u>便确定了，链接的是基类的<code>getName</code>函数地址。</p><p>这也就是<strong>早绑定</strong>，如下图。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220207005934363.png" alt="image-20220207005934363"></p><p>↑可以看到，编译之后，<code>getName</code> 在汇编代码中已被替换为符号： <code>_ZNK4Base7getNameB5cxx11Ev</code> ，对应调用地址为<code>400c02</code>。</p><p>但如果<code>getName</code>是虚函数一切开始变得不一样。</p><p>如果基类的<code>getName</code>函数被声明为虚函数，其地址便会在<u>运行时</u>绑定为调用的派生类对象的<code>getName</code>函数地址。进而实现下面效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printName</span>(d);   <span class="comment">// ok, 打印：Derived</span></span><br><span class="line"><span class="built_in">printName</span>(d1);  <span class="comment">// ok, 打印：Derived1</span></span><br><span class="line"><span class="built_in">printName</span>(d2);  <span class="comment">// ok, 打印：Derived2</span></span><br></pre></td></tr></table></figure><p>我们将从类实例化内存布局变化角度进行剖析。</p><h4 id="7-2-2-虚函数和多态">7.2.2 虚函数和多态</h4><h5 id="虚函数实现多态">虚函数实现多态</h5><p>继续前面的例子，我们看看虚函数如何实现多态吧。</p><p>为了方便描述，这里只展示了派生类Derived、Derived1，注意<strong>派生类的签名、返回类型要和基类完全一致</strong>！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> value): m_value&#123; value &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 基类getName函数被声明为虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Base&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="keyword">int</span> value): Base&#123; value &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 派生类getName函数的virtual可省略</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Derived&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValueDoubled</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_value * <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived1</span>(<span class="keyword">int</span> value): Base&#123; value &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 派生类getName函数的virtual可省略</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Derived1&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValueDoubled</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_value * <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">(Base* pBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout&lt;&lt;pBase-&gt;<span class="built_in">getName</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    Derived1 derived1&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printName</span>(&amp;derived);   <span class="comment">// Derived，调用的是派生类方法Derived::getName</span></span><br><span class="line">    <span class="built_in">printName</span>(&amp;derived1);  <span class="comment">// Derived1，调用的是派生类方法Derived1::getName</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base* pBase =  &amp;derived;</span><br><span class="line">pBase-&gt;<span class="built_in">getName</span>();  <span class="comment">// Derived，同上</span></span><br><span class="line">pBase =  &amp;derived1;</span><br><span class="line">pBase-&gt;<span class="built_in">getName</span>();  <span class="comment">// Derived1</span></span><br></pre></td></tr></table></figure><p>和前面非虚函数<code>getName</code>编译器早在编译期绑定了基类函数地址不同，虚函数采用<strong>晚绑定</strong>（动态绑定）：编译器检查到基类的<code>getName</code>函数是虚函数，不会早早绑定函数<code>getName</code>到特定入口地址。</p><p>下图说明了这个不同。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220207011513361.png" alt="image-20220207011513361"></p><p>↑此时<code>getName</code> 函数的地址是通过寄存器<code>rax</code>的值确定的，<code>rax</code> 存放的便是派生类的<strong>虚表</strong>中<code>getName</code> 函数地址，也就是所谓的晚绑定。</p><h5 id="早绑定和晚绑定">早绑定和晚绑定</h5><p>本节对早绑定和晚绑定进行更全面的总结。</p><p>编译程序时，编译器会将 C++ 程序中的每条语句转换为一行或多行机器语言，遇到函数则是转换为一个可用地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 对应代码：add(1,2) </span><br><span class="line"># 转换为地址0x400937</span><br><span class="line">call   400937 &lt;_Z3addii&gt; </span><br></pre></td></tr></table></figure><p>但在编译期间，我们不一定能确定要调用哪个函数，必须要在运行时才能确定。由此区分出了早绑定和晚绑定：</p><ul><li><strong>早绑定</strong>：在编译器期间就可以<u>直接确定的调用函数</u>，会将其转换为一个调用地址，这就是早绑定；</li><li><strong>晚绑定</strong>：在编译期间<u>不可以直接确定的调用函数</u>，运行期间才转换为具体调用的地址，便是晚绑定。</li></ul><p>下面这个例子：我们通过函数指针根据操作符指向相应运算函数，但操作符是在运行期间由用户确定的。</p><p>晚绑定一般通过函数指针实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op;  <span class="comment">// 操作符由用户确定</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter an operation (0=add, 1=subtract, 2=multiply): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; op;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// （1）晚绑定</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*pFcn1)(<span class="keyword">int</span>, <span class="keyword">int</span>) = add;</span><br><span class="line">    <span class="comment">// （2）晚绑定</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*pFcn2)(<span class="keyword">int</span>, <span class="keyword">int</span>) = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (op)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: pFcn2 = add; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: pFcn2 = subtract; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: pFcn2 = multiply; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// （3）早绑定调用</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// （4）晚绑定调用</span></span><br><span class="line">    <span class="built_in">pFcn1</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// （5）晚绑定调用</span></span><br><span class="line">    <span class="built_in">pFcn2</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，（1）、（2）都是晚绑定。</p><p>对于（1），编译器同样无法在编译期间确定，函数指针<code>pFcn1</code>指向的是哪个函数。因为函数指针：</p><ol><li>需要先读取<code>pFcn1</code> 保存的函数地址</li><li>才能再跳转到相应函数</li></ol><p>显然，“读”这个操作在编译期间是无法完成的，所以<code>pFcn1</code> 无法确定指向哪个函数。</p><p>最后，我们再来直观对比下早绑定和晚绑定调用（3）、（4）、（5）时的不同。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220207120431838.png" alt="image-20220207120431838"></p><ul><li>早绑定（①处）：因为<code>add(1,2)</code>函数可直接被调用，所以在编译期间就被替换为函数入口地址<code>_Z3addii</code>（0x400877）；</li><li>晚绑定（②处）：<code>PFcn1</code>无法被直接调用，先将指针<code>PFcn1</code> 保存的函数地址（<u>地址-16(%rbp)中的值，这个值是运行时计算的</u>）存入寄存器<code>rax</code> 中，最后才根据寄存器保存的函数地址进行调用。</li><li>晚绑定（③处）：同②。</li></ul><p>有了这些概念，我们可以开始探讨<u>虚函数动态绑定实现的过程和原理</u>，这不可避免涉及到虚表。</p><h5 id="虚表">虚表</h5><p>为了实现虚函数，C++ 使用了一种特殊形式的后期绑定，称为虚表（vtable）。</p><p><strong>每个使用虚函数的类（或派生自使用虚函数的类）都有自己的虚表</strong>：</p><ul><li><strong>虚表是编译器期间设置的静态一维数组</strong>，数组每一个条目都是一个函数指针，它指向该类的虚函数；</li><li><strong>每个类还有个隐藏指针<code>*__vptr</code> ，<u>它可以被继承</u></strong>：<ul><li>在<u>创建类实例时</u>，对象的虚表会被创建，<code>*__vptr</code> 会被<u>类构造函数</u>初始化指向该类的虚表（准确来说是在构造函数体进入前初始化的，也就是成员列表中）；</li><li>相比<code>*this</code> 指针，<code>*__vptr</code>是一个真正的指针，它使得每个类的对象都增加了一个指针的大小（4字节或8字节）。</li></ul></li><li><strong>虚表和虚表指针是在构造函数中进行创建和初始化的</strong>。</li></ul><p>看一个简单的例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function3</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 d1; </span><br><span class="line">    Base* dPtr = &amp;d1;</span><br><span class="line">    dPtr-&gt;<span class="built_in">function1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<u>7.2.1</u> 节我们知道，理论上基类指针<code>dPtr</code>只能“看到”派生类对象<code>d1</code>的基类部分。但这里却成功调用了<code>d1</code> 的成员虚函数<code>function1</code> 。</p><p>下图类实例布局形象地说明了原因：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220209143710226.png" alt="image-20220209143710226"></p><ol><li>创建派生类D1的实例<code>d1</code> 时，先构造了基类Base对象部分，然后用基类构造函数进行初始化，这个过程设置了基类对象的虚指针和虚表；</li><li>然后构造派生类扩展部分，派生类构造函数进行初始化：<ul><li>原来继承的基类虚表，修改<code>base::function1</code> → 为 <code>Derived::function1</code> ；</li><li>增加派生类自己的虚函数<code>Derived::function3</code> ；</li><li>完成其它初始化工作。</li></ul></li><li>实例<code>d1</code> 构建完成（内存布局如上图）。</li></ol><p>现在我们再来解释下面这行代码发生了什么：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dPtr-&gt;<span class="built_in">function1</span>();</span><br></pre></td></tr></table></figure><ol><li>编译器识别出<code>function1</code> 是虚函数，开始分析此时调用对象，来确定使用哪个类对象的虚指针，进而确定虚表来找到相应虚函数指针地址；</li><li>指针<code>dPtr</code>比较特殊，它是基类的指针（引用同理），但指向的是派生类对象<code>d1</code>——<strong>这种情况，是根据指向派生类对象确定</strong>；</li><li>所以，最终根据<code>dPtr-&gt;d1.*__vptr</code> 来查找对象<code>d1</code>的虚表（上图的D1对象虚表），从而调用了<code>D1::function1</code> 。</li></ol><p>调用function2类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dPtr-&gt;<span class="built_in">function2</span>();</span><br></pre></td></tr></table></figure><ol><li>编译器识别出<code>function2</code> 是虚函数 ，同时确定了当前调用对象是<code>d1</code> ;</li><li>根据<code>d1</code>虚指针查找<code>d1</code> 的虚表，进而找到<code>function2</code>函数指针，不过这个指针保存的是<code>Base</code> 虚表的<code>function2</code>函数地址；</li><li>最终调用了<code>Base::function2</code> 。</li></ol><p>从汇编角度来验证上述过程（精简了些代码，不影响阅读）：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220207232953703.png" alt="image-20220207232953703"></p><p>注意右侧红框处的汇编代码：1.确定对象类型→2.根据虚指针找到虚表→3.根据虚表和偏移计算虚函数指针地址→4.根据虚函数指针获取虚函数调用地址→5.调用函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 1.-8(%rbp)是堆上d1内存首地址，存入寄存器rax中</span><br><span class="line">movq    -8(%rbp), %rax </span><br><span class="line"># 2.获取d1首地址保存的值，存在寄存器rax中。因为d1内存首地址，即是虚指针地址，所以获取了虚指针保存的内容，即虚表首地址放入寄存区rax中</span><br><span class="line">movq    (%rax), %rax  </span><br><span class="line"># 3.虚表首地址+偏移8个字节表示function2函数指针，然后存入寄存器rax中</span><br><span class="line">addq    $8, %rax </span><br><span class="line"># 4.获取函数指针保存的值，即function2的函数地址，最终保存在rax中</span><br><span class="line">movq    (%rax), %rax </span><br><span class="line">movq    -8(%rbp), %rdx</span><br><span class="line">movq    %rdx, %rdi</span><br><span class="line"># 5.调用function2</span><br><span class="line">call    *%rax </span><br></pre></td></tr></table></figure><h5 id="虚函数性能问题">虚函数性能问题</h5><p>迄今为止，我们介绍了三种函数调用方式：</p><ul><li>早绑定方式：直接调用；</li><li>晚绑定方式：函数指针与虚函数。</li></ul><p>其中，直接调用方式只需1次就可以找到调用的函数；函数指针需要两次：读取函数指针保存的函数地址→调用函数；而虚函数需要三次：读取虚指针<code>*__vptr</code> 找到虚表→读取虚表中要调用的虚函数指针保存的函数地址→调用函数。</p><p>显然这带来了额外的<u>时间开销</u>。</p><p><strong>另外，任何使用虚函数的<u>类对象</u>都有一个 虚指针<code>*__vptr</code></strong> ，所以创建对象也需要多余内存存储该指针，这还带来额外<u>空间开销</u>。</p><p>所以，虚函数虽好但不要过度哦。</p><h4 id="7-2-3-虚函数二三事">7.2.3  虚函数二三事</h4><h5 id="override、final及协变类型">override、final及协变类型</h5><p>本节我们将主要介绍override、final及协变返回类型：</p><ul><li>override：在派生类函数标记该函数重写了基类的虚函数，以避免重写时派生类函数的返回类型、函数签名和基类虚函数不一致的书写错误；</li><li>final：显式标记某个函数不希望不重写，如果被重写编译器会报错；</li><li>协变返回类型：基类函数返回类型是基类的指针（或引用），派生类返回<u>重写函数</u>的返回类型可以是派生类的指针（或引用），此时依旧视为重写。</li></ul><p><strong>先从override说起</strong>。</p><p>我们知道，派生类虚函数只有在其<u>签名和返回类型完全匹配时</u>才被视为重写。</p><p>一不留神可能就会出错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125; <span class="comment">// 非常函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125; <span class="comment">// 常函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以，为了能让编译器帮我们自动检查，我们可以考虑在派生类B中，使用override关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125; <span class="comment">// error，编译器报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时程序产生了编译错误。</p><p>使用override说明符没有产生性能损失，所以在派生类中的重写函数请尽量使用override说明符。</p><p><strong>final说明符比较简单仅仅希望某个函数不会被重写</strong>。</p><p>和override说明符在同一位置使用（函数体前），二者也可以同时存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// okay, 此时getName函数被final修饰</span></span><br><span class="line"><span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>  :</span> <span class="keyword">public</span> B </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// error，无法重写B中的getName函数</span></span><br><span class="line"><span class="function">std::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>final也可以修饰类表示无法继承。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">final</span>  // 其它类无法继承<span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最后是协变返回类型</strong>。</p><p>如果基类返回类型是基类的指针或引用，那么派生类重写函数的返回类型可以是<u>派生类的引用或指针</u>。此时依旧视为重写。</p><p>不过，下面这个例子藏了点玄机。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 返回类型是：base*</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Base* <span class="title">getThis</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;调用 Base::getThis()\n&quot;</span>; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printType</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 返回类型是Derived*，依旧视为是基类getThis的重写</span></span><br><span class="line"><span class="function">Derived* <span class="title">getThis</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;调用 Derived::getThis()\n&quot;</span>;  <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printType</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived d&#123;&#125;;</span><br><span class="line">Base* b&#123; &amp;d &#125;;</span><br><span class="line">    <span class="comment">// 输出会是什么呢？</span></span><br><span class="line">b-&gt;<span class="built_in">getThis</span>()-&gt;<span class="built_in">printType</span>(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用 Derived::getThis()</span><br><span class="line">Base</span><br></pre></td></tr></table></figure><p>结果分析：</p><ol><li><p><code>b-&gt;getThis()</code>，因为<code>getThis</code> 是虚函数，所以<code>getThis</code> 在运行时才会被确定，<code>b</code>是<code>d</code>的指针，查找对象<code>d</code>虚表最终调用输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用 Derived::getThis()</span><br></pre></td></tr></table></figure></li><li><p><code>b-&gt;getThis()</code> 虽然返回了<code>Derived*</code> ，但因为C++是静态语言，而<code>printType</code> 又未声明为虚函数，所以<code>printType</code>调用对象类型其实在编译时就已经确定为<code>Base</code> 。</p><p>所以最终<code>Derived*</code>只能向上转型为<code>Base*</code> ，调用<code>Base::printType</code>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base</span><br></pre></td></tr></table></figure></li></ol><h5 id="析构、构造函数与虚函数">析构、构造函数与虚函数</h5><p>析构、构造函数与虚函数之间需记住以下两点：</p><ol><li>不要在构造函数或析构函数中调用虚函数；</li><li>析构函数可声明为虚函数，构造函数不能声明为虚函数。</li></ol><p><strong>我们先来讨论第一点：不要从构造函数或析构函数调用虚函数</strong>。</p><p>要解释这一点，我们需要回忆两个知识点：</p><ul><li>每个类对象虚指针指向当前类虚表，<u>虚指针根据当前调用的对象确定</u>；</li><li>创建派生类对象时，先调用基类部分构造函数，再调用派生类构造函数；销毁派生类对象时，析构函数执行顺序和构造函数恰相反。</li></ul><p>设想下，我们从<u>基类</u>的构造函数调用虚函数会发生什么？</p><ol><li>创建派生类对象，开始调用基类构造函数；</li><li>进入基类构造函数调用虚函数，<strong>即：this-&gt;虚函数()，当前this对象是基类对象而不是派生类对象</strong> ，所以最终使用的是基类对象虚指针，在基类的虚表中调用了基类的虚函数版本而不是派生类中的；</li><li>最后再调用派生类构造函数。</li></ol><p>类似的错误存在析构函数中：</p><ol><li>销毁对象，开始调用派生类析构函数；</li><li>派生类部分被销毁，接着调用基类析构函数；</li><li>进入基类析构函数调用虚函数，同样的，<strong>此时对象是基类对象而不是派生类对象</strong>，所以虚函数始终解析为该函数的基类版本。</li></ol><p><strong>我们再来讨论第二点：析构函数可声明为虚函数，构造函数不能声明为虚函数</strong>。</p><p>析构函数声明为虚函数，特别是明确要作为基类中的析构函数，可以避免派生类内存没有被释放产生内存泄漏。这样释放基类内存时，<u>会执行派生类析构函数，而派生类析构函数执行后还会调用基类析构函数</u>，确保了内存被析构完全。</p><p>下面这个例子帮助理解：</p><p>注意，基类指针<code>base</code> 指向了new动态分配在<u>堆上</u>的派生类对象内存，所以只能我们显式delete管理堆内存释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Base</span>() <span class="comment">// 非虚函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用 ~Base()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="keyword">int</span> length): m_array&#123; <span class="keyword">new</span> <span class="keyword">int</span>[length] &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用 ~Derived()\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] m_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *base = <span class="keyword">new</span> Derived&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 释放base指向的内存</span></span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用 ~Base()</span><br></pre></td></tr></table></figure><p>因为<code>base</code>指向的是<u>堆上</u>的派生类对象，所以这个对象离开作用域也不会自动释放，只能我们使用delete显式删除。</p><p>但此时只有基类部分执行了析构函数，派生类析构函数没有执行，导致<code>m_array</code> 持有的内存发生泄漏。</p><p>为了解决这个问题，需要<strong>将基类的析构函数声明为虚函数</strong>。修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Base</span>() <span class="comment">// 虚函数</span></span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;调用 ~Base()\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次执行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用 ~Derived()</span><br><span class="line">调用 ~Base()</span><br></pre></td></tr></table></figure><p>这样，派生类的析构函数执行完还会执行基类的析构函数（反之不行）。</p><p><strong>不过，构造函数不能声明为虚函数</strong>。</p><p>很好理解，因为这破坏了构造函数执行顺序：先基类构造函数→再派生类构造函数。</p><p>当基类构造被声明为虚函数时：先派生类构造函数ok，但<u>基类构造函数永远等不到执行</u>，派生类构造函数并没有义务调用基类构造函数。</p><p>综上所述：</p><ul><li>永远不要从构造函数或析构函数调用虚函数；</li><li>当前类如果打算作为基类，请将析构函数声明为virtual（如果不打算作为基类，析构函数不用声明为virtual，<u>但类最好标记为final</u>）；</li><li>永远不要把构造函数声明为virtual。</li></ul><h5 id="纯虚函数、抽象基类与接口类">纯虚函数、抽象基类与接口类</h5><p>迄今为止，我们编写的虚函数都有函数体。C++允许我们创建一种特殊的函数，纯虚函数，它没有实体由派生类实现具体定义。</p><p>由此还引申出其它几个概念：</p><ul><li>抽象基类：具有纯虚函数的类便是抽象基类；</li><li>接口类：没有成员变量，只有纯虚函数的类。</li></ul><p>要创建一个纯虚函数，只需为函数赋值0即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:  <span class="comment">// 保护成员</span></span><br><span class="line">    <span class="built_in">Animal</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数，=0</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们声明了一个<code>Animal</code> <u>只作为基类</u>，因此：</p><ul><li><code>Animal</code>  构造函数被声明为<code>protected</code> ，避免其被外部被实例化；但是不要声明为<code>private</code> ，否则派生类无法实例化。</li><li>内部我们声明了纯虚函数<code>speak()</code> ，因为我们只希望它在派生类中被实现，基类实现没有意义。</li></ul><p>此时<code>Animal</code> 因为包含纯虚函数，所以也被称为<u>抽象基类</u>。抽象基类不能被实例化，所以这里的<code>Animal</code> 构造函数，直接声明public也可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:  <span class="comment">// 保护成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 纯虚函数，=0</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>纯虚函数还有几个特质：</p><ul><li><p>纯虚函数必须被派生类实现（重写）；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cow</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cow</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// const char* speak() const override &#123; return &quot;咪&quot;; &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cow cow&#123;&#125;;</span><br><span class="line">    std::cout &lt;&lt; cow.<span class="built_in">speak</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// error，派生类Cow没有实现纯虚函数speak()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>纯虚函数可以有函数体，不过只能在类外实现（不常用）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:  <span class="comment">// 保护成员</span></span><br><span class="line">    <span class="built_in">Animal</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数，=0</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Animal::speak</span><span class="params">()</span> <span class="keyword">const</span>  <span class="comment">// 只能类外实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;？？？&quot;</span>; <span class="comment">// &quot;？？？&quot;是字符串常量，在常量区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最后值得一提的是，抽象类仍然具有虚表。</p><h5 id="虚基类">虚基类</h5><p><u>7.1.4节</u>中多重继承导致的“菱形问题”，我们最终解决方案是通过虚继承解决：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220205114829756.png" alt="image-20220205114829756"></p><p>此时A被称为<u>虚基类</u>。</p><ul><li><p>虚基类对象，在继承树中被所有对象共享，也就是只会构造一次；</p></li><li><p>派生虚基类最多的类，负责创建虚基类；</p><p>在上图中，B、C都只派生了一次虚基类A，而D派生了两次，所以由D负责构建虚基类A（调用虚基类的构造函数一次）。</p></li></ul><h4 id="7-2-4-动态转换与对象切片">7.2.4 动态转换与对象切片</h4><h5 id="上行转换和下行转换">上行转换和下行转换</h5><p>基本概念：</p><ul><li>上行转换：派生类<u>指针或引用</u>转换为→基类<u>指针或引用</u>，C++可以隐式地进行，这种转换是安全的；</li><li>下行转换：基类<u>指针或引用</u>转换为→派生类<u>指针或引用</u> ，这种转换是不安全的，最好通过<strong>dynamic_cast</strong> 或 <strong>static_cast</strong> 显式完成。</li></ul><p><strong>下行转换既然是不安全的，为什么还要存在</strong>？</p><p>我们经常会有这种需求：虽然只有基类指针，但还是想根据基类指针访问派生类相关的信息。</p><p>在这之前，我们已经有了解决方案：在基类声明和派生类函数一致的虚函数。但虚函数并非万灵药，因为:</p><ul><li>这给基类带来了额外的负担，不得不在基类重复声明了一个虚函数。</li></ul><p>考虑下面这个例子，说明了上述问题。</p><p>使用基类指针访问派生类getName方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 不得不额外在基类声明一个虚函数，以便可解析到派生类中</span></span><br><span class="line">    <span class="comment">// 实际上它什么也没做</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> std::string <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">std::string m_name&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Derived</span>(<span class="keyword">const</span> std::string&amp; name): m_name&#123;name&#125;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> std::string <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Base* <span class="title">getObject</span><span class="params">(<span class="keyword">bool</span> returnDerived)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (returnDerived)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Derived&#123; <span class="string">&quot;Derived&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Base&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* b&#123; <span class="built_in">getObject</span>(<span class="literal">true</span>) &#125;;</span><br><span class="line">    std::cout &lt;&lt; b-&gt;<span class="built_in">getName</span>()&lt;&lt;std::endl; <span class="comment">// Derived</span></span><br><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然最终成功访问到派生类的getName方法，但是不得不在基类额外定义一个虚函数：即使它对基类是毫无作用的。</p><p>另一方面，考察这行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base* b&#123; <span class="built_in">getObject</span>(<span class="literal">true</span>) &#125;;</span><br></pre></td></tr></table></figure><ol><li><code>getObject(true)</code> 返回的是Derived类型指针；</li><li>然后上行转换为Base指针，。</li></ol><p>也就是说Base指针<code>b</code> 保存了Derived对象的内存地址，只不过只能访问基类部分。但也天生<u>具备了访问Derived对象的“潜质”</u>，Derived对象的其它部分依旧存在。</p><p>我们可以利用<strong>dynamic_cast</strong>强制转换发掘这种潜力：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时基类的虚函数getName已被删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* b&#123; <span class="built_in">getObject</span>(<span class="literal">true</span>) &#125;;</span><br><span class="line">    Derived* d&#123; <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(b) &#125;; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d) <span class="comment">// 确保转换成功</span></span><br><span class="line">std::cout &lt;&lt; d-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived</span><br></pre></td></tr></table></figure><p>最后强调一下<strong>dynamic_cast 失败</strong>时的处理：</p><ul><li>dynamic_cast失败返回NULL（如果是引用，返回 <code>std::bad_cast</code> 异常），（最佳实践）请编码时务必进行判断，确保你的下行转换成功；</li><li>static_cast 失败也不返回NULL，因此不建议使用static_cast，它过于粗暴不够安全。</li></ul><h5 id="下行转换还是虚函数？">下行转换还是虚函数？</h5><p>一般来说，使用虚函数<u>应该</u>优于向下转换。但是，有时向下转换是更好的选择：</p><ul><li>当不能修改基类添加虚函数时（例如，基类是标准库的一部分）；</li><li>当需要访问特定于派生类的东西时（例如，仅存在于派生类中的函数）；</li><li>向基类添加虚函数没有意义时（例如，基类函数体没有实现的必要）。</li></ul><p><strong>不过能使用下行转换是建立在：你使用的基类指针或引用是否具有转换下行转换的潜质——指向的是派生类对象</strong>？</p><p>如果不具有的话，比如指向的是一个基类对象，强行转换会出错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* b&#123; <span class="built_in">getObject</span>(<span class="literal">false</span>) &#125;;</span><br><span class="line">    std::cout &lt;&lt;<span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(b)-&gt;<span class="built_in">getName</span>()&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><h5 id="对象切片">对象切片</h5><p>在此之前，我们都是利用基类的<u>指针</u>或<u>引用</u> 指向了一个派生类对象，大概类似下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    Base&amp; ref&#123; derived &#125;;  <span class="comment">// 引用</span></span><br><span class="line">    Base* ptr&#123; &amp;derived &#125;; <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>ref</code>、<code>ptr</code> 虽然只能“看到”derived的Base部分，但<u>derived其它部分依旧是存在的</u>。</p><p>如果不用指针或引用指向呢？就像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    Base base &#123; derived &#125;; <span class="comment">// 非指针或引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面<code>base</code> 复制了Derived 对象的 Base 部分，而 Derived 对象<u>其它部分已被丢弃，不再存在</u> ，这就是<strong>对象切片</strong>。</p><p><strong>对象切片很容易导致一些意料之外的问题，比如函数参数<u>值传递</u>时</strong>。</p><blockquote><p>假设此时Base有一个虚函数getName，它的作用是打印出“Base”；派生类getName进行了重写，不过它打印的是“Derived”。</p></blockquote><p>函数<code>printName</code>接受一个Base类型参数，是值传递方式，它主要任务是调用getName函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">(<span class="keyword">const</span> Base base)</span> <span class="comment">// 不是引用或指针传递</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base.<span class="built_in">getName</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">printName</span>(d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base</span><br></pre></td></tr></table></figure><p>因为发生了对象切片，即使getName是虚函数也不会调用Derived::getName，而是调用基类版本Base::getName（这也是为什么我们建议函数的类类型参数尽量声明为引用或指针）。</p><p>最后，我们再举一个例子来说明对象切片带来编码问题：使用vector实现多态时，发生了对象切片。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;Base&gt; v&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base b&#123;&#125;; </span><br><span class="line">Derived d&#123;&#125;;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(b); </span><br><span class="line">v.<span class="built_in">push_back</span>(d); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* element : v)</span><br><span class="line">std::cout &lt;&lt; element-&gt;<span class="built_in">getName</span>()  &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base</span><br><span class="line">Base</span><br></pre></td></tr></table></figure><p>与前面的示例类似，因为 <code>std::vector</code> 被声明为 <code>Base</code> 类型的向量，所以当将 <code>d</code>添加到向量时，<code>d</code>被切片了。</p><ul><li><p>而且，尝试使用引用传参也不起作用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Base&amp;&gt; v&#123;&#125;;</span><br></pre></td></tr></table></figure><p>会发生编译错误，因为<code>std::vector</code>的元素必须是可分配的，而引用不能重新分配（仅能初始化）。</p></li><li><p>最终解决方案是声明为指针传参：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Base*&gt; v&#123;&#125;;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;b); </span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;d); </span><br></pre></td></tr></table></figure><p>重新编译，输出正常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base</span><br><span class="line">Derived</span><br></pre></td></tr></table></figure></li></ul><p>综上所述：尽管 C++ 支持通过对象切片将派生对象分配给基类对象，但这是个让人感到头疼的行为。</p><ul><li>所以，请尽量避免使用切片；</li><li>确保函数参数是引用（或指针）。</li></ul><p>下章我们开始介绍模板相关知识。</p><h2 id="更新记录">更新记录</h2><div class="timeline"><div class="timenode"><div class="meta"><p><p>2022-02-09 ：更新笔记</p></p></div><div class="body"><ol><li>第一次更新</li></ol></div></div></div><h2 id="参考资料">参考资料</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://stackoverflow.com/questions/36162714/what-is-the-difference-between-is-a-relationship-and-has-a-relationship-in">What is the difference between &quot;IS -A&quot; relationship and &quot;HAS-A&quot; relationship in Java?</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">【C++基础之二十一】菱形继承和虚继承：https://blog.csdn.net/jackystudio/article/details/17877219<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">多重继承的优缺点：https://blog.csdn.net/woodforestbao/article/details/4500406<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++ 多态 ：https://zhuanlan.zhihu.com/p/37340242<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++基类的析构函数为何要声明为虚函数 ：https://zhuanlan.zhihu.com/p/148290103<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++类对象的内存结构 ：https://blog.csdn.net/MOU_IT/article/details/89045103<a href="#fnref:6" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
          <category> C++面对对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 教程 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 虚函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++从零开始（八）：面对对象（中）运算符重载</title>
      <link href="/p/43924/"/>
      <url>/p/43924/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，开始更新中…</p></blockquote><div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div><h2 id="六、运算符重载">六、运算符重载</h2><p>在前面我们接触过函数重载，让我们可以使用多个同名函数，只要它们有唯一的函数签名（由函数参数类型、个数、函数名组成）可以让编译器区分即可。</p><p><strong>在C++中，运算符被视为函数，自然也可以进行重载</strong>。</p><p>认识下运算符这个特殊的函数。</p><p>运算符<code>operator+</code> 作为函数，接收了两个<code>int</code>类型参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x &#123; <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> y &#123; <span class="number">3</span> &#125;;</span><br><span class="line">x+y;   </span><br></pre></td></tr></table></figure><p>重载函数<code>operator+</code> ，又接收了两个<code>double</code> 类型参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x &#123; <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">double</span> y &#123; <span class="number">3</span> &#125;;</span><br><span class="line">x+y; </span><br></pre></td></tr></table></figure><p>这都是C++为我们内置实现了<code>operator+</code> 重载，用于C++基本类型之间运算。</p><p><strong>我们也可以自定义重载自己的运算符函数</strong>。</p><p>虽然C++ 中几乎所有的运算符我们都可以进行重载，但要注意以下规则：</p><ul><li>重载运算符中的至少一个操作数必须是用户定义的类型，比如重载<code>operator+</code> 函数，一个参数是<code>int</code>，一个是<code>double</code> 是不行的；</li><li>无法更改运算符支持的操作数数量，优先级也被保留。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">myInt</span>(<span class="keyword">int</span> a):<span class="built_in">i</span>(a)&#123; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 重载操作符形式</span></span><br><span class="line">myInt <span class="keyword">operator</span>+(myInt&amp; i1,myInt&amp; i2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">myInt</span>(i1.<span class="built_in">getValue</span>()+i2.<span class="built_in">getValue</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function">myInt <span class="title">add</span><span class="params">(myInt&amp; i1,myInt&amp; i2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">myInt</span>(i1.<span class="built_in">getValue</span>()+i2.<span class="built_in">getValue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>普通函数也可以实现重载运算符所需的功能，重载运算符有什么好处</strong>？</p><p>重载运算符可以让程序表达更直观：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myInt i1&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    myInt i2&#123;<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    myInt i3 = i1+i2;      <span class="comment">// i3.getValue()=3，更直观</span></span><br><span class="line">    myInt i4 = <span class="built_in">add</span>(i1,i2); <span class="comment">// i3.getValue()=3 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>如果重载运算符并不能让你的程序更清晰，请谨慎使用</u>。</p><p>本章主要介绍：</p><ul><li>重载运算符的友元/普通/成员三种方式。</li><li>特殊重载，如重载()、=介绍。</li></ul><h3 id="6-1-重载运算符的三种方式">6.1 重载运算符的三种方式</h3><p>重载运算符有三种不同的方式：</p><ul><li>友元函数方式</li><li>普通函数方式</li><li>成员函数方式</li></ul><p>按照顺序我们依次来看下。</p><h4 id="6-1-1-友元函数">6.1.1 友元函数</h4><h5 id="重载友元初识">重载友元初识</h5><p>下面展示了重载<code>operator+</code> ，其余操作符<code>-</code> 、<code>/</code> 、<code>*</code> 等类似。</p><p>注意到函数<code>operator+</code> 是类<code>MinMax</code> 的友元函数，这样就可以使用<code>MinMax</code>的私有成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cents</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_cents&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cents</span>(<span class="keyword">int</span> cents): m_cents&#123; cents &#125;&#123;&#125;</span><br><span class="line">  <span class="comment">// 类中声明友元函数原型</span></span><br><span class="line">  <span class="keyword">friend</span> Cents <span class="keyword">operator</span>+(<span class="keyword">const</span> Cents&amp; c1, <span class="keyword">const</span> Cents&amp; c2)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数定义</span></span><br><span class="line">Cents <span class="keyword">operator</span>+(<span class="keyword">const</span> Cents&amp; c1, <span class="keyword">const</span> Cents&amp; c2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; c1.m_cents + c2.m_cents &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Cents cents1&#123; <span class="number">6</span> &#125;;</span><br><span class="line">  Cents cents2&#123; <span class="number">8</span> &#125;;</span><br><span class="line">  Cents centsSum =  cents1 + cents2 ;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;I have &quot;</span> &lt;&lt; centsSum.<span class="built_in">getCents</span>() &lt;&lt; <span class="string">&quot; cents.\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I have 14 cents.</span><br></pre></td></tr></table></figure><h5 id="更多例子：重载I-O运算符">更多例子：重载I/O运算符</h5><p>下面是一个同时使用重载的 <code>operator&lt;&lt;</code> 和 <code>operator&gt;&gt;</code> 的示例 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_x&#123;&#125;;</span><br><span class="line">    <span class="keyword">double</span> m_y&#123;&#125;;</span><br><span class="line">    <span class="keyword">double</span> m_z&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">double</span> x=<span class="number">0.0</span>, <span class="keyword">double</span> y=<span class="number">0.0</span>, <span class="keyword">double</span> z=<span class="number">0.0</span>): m_x&#123;x&#125;, m_y&#123;y&#125;, m_z&#123;z&#125;&#123;&#125;</span><br><span class="line">    <span class="comment">// 类型友元函数声明</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; out, <span class="keyword">const</span> Point&amp; point);</span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt; (std::istream&amp; in, Point&amp; point);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; out, <span class="keyword">const</span> Point&amp; point)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;Point(&quot;</span> &lt;&lt; point.m_x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; point.m_y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; point.m_z &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    <span class="comment">// 返回std::ostream对象out，这样就可以形成链式使用</span></span><br><span class="line">    <span class="comment">// 像这样：out&lt;&lt;point1&lt;&lt;&quot; &quot; &lt;&lt; point2</span></span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 和前有点不一样，重载的参数类型不同</span></span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt; (std::istream&amp; in, Point&amp; point)</span><br><span class="line">&#123;</span><br><span class="line">    in &gt;&gt; point.m_x;</span><br><span class="line">    in &gt;&gt; point.m_y;</span><br><span class="line">    in &gt;&gt; point.m_z;</span><br><span class="line">    <span class="comment">// 同前返回std::istream对象in，形成链式</span></span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a point: &quot;</span>;</span><br><span class="line">    Point point1;</span><br><span class="line">    Point point2;</span><br><span class="line">    <span class="comment">// 链式输入</span></span><br><span class="line">    std::cin &gt;&gt; point1 &gt;&gt; point2;</span><br><span class="line">    <span class="comment">// 链式输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; point1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; point2&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">Enter a point: 1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">You entered: Point(1, 2, 3) Point(4, 5, 6)</span><br></pre></td></tr></table></figure><h4 id="6-1-2-普通函数">6.1.2 普通函数</h4><p>使用友元函数虽然很方便，但也一定程度的破坏了类的封装性。因此我们建议尽量将重载运算符实现为普通函数。</p><p>下面是一个小例子。</p><p>注意到普通函数和实现为友元函数极为类似，除了友元函数需要在类中先声明函数原型 <code>friend Cents operator+(const Cents&amp;,const Cents&amp;)</code> ，其余没有区别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cents</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_cents&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cents</span>(<span class="keyword">int</span> cents): m_cents&#123; cents &#125;&#123;&#125;</span><br><span class="line">  <span class="comment">// 访问私有成员的接口函数</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getCents</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cents; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 普通函数，非友元</span></span><br><span class="line">Cents <span class="keyword">operator</span>+(<span class="keyword">const</span> Cents&amp; c1, <span class="keyword">const</span> Cents&amp; c2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> Cents&#123; c1.<span class="built_in">getCents</span>() + c2.<span class="built_in">getCents</span>() &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Cents cents1&#123; <span class="number">6</span> &#125;;</span><br><span class="line">  Cents cents2&#123; <span class="number">8</span> &#125;;</span><br><span class="line">  Cents centsSum =  cents1 + cents2 ; <span class="comment">// ok </span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-3-成员函数">6.1.3 成员函数</h4><h5 id="重载成员初识">重载成员初识</h5><p>成员重载运算符和友元重载运算符很类似，但是也有些不同：</p><ul><li>重载的运算符被定义为成员而不是友元（例如，是<code>Cents::operator+</code> 而不是<code>operator+</code> ）；</li><li>左边的类类型参数<code>const Cents&amp;</code>被移除了，变成了隐含的 <code>*this</code> 对象。</li></ul><p>看代码说话。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cents</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_cents &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cents</span>(<span class="keyword">int</span> cents): m_cents &#123; cents &#125; &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// friend Cents operator+(const Cents &amp;cents, int value);</span></span><br><span class="line">    <span class="comment">// 对比普通函数声明：</span></span><br><span class="line">    <span class="comment">// 1. 少了friend声明，本来就是成员函数可以访问私有成员没必要</span></span><br><span class="line">    <span class="comment">// 2. 左参数被省略，隐含为*this对象</span></span><br><span class="line">    Cents <span class="keyword">operator</span>+ (<span class="keyword">int</span> value);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCents</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cents; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比普通函数多了Cents::（成员函数），多了左参数</span></span><br><span class="line">Cents Cents::<span class="keyword">operator</span>+ (<span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// m_cents被视为this-&gt;m_cents</span></span><br><span class="line">    <span class="keyword">return</span> Cents &#123; m_cents + value &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cents cents1 &#123; <span class="number">6</span> &#125;;</span><br><span class="line">Cents cents2 &#123; cents1 + <span class="number">2</span> &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;I have &quot;</span> &lt;&lt; cents2.<span class="built_in">getCents</span>() &lt;&lt; <span class="string">&quot; cents.\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I have 8 cents.</span><br></pre></td></tr></table></figure><h5 id="重载一元函数">重载一元函数</h5><p>正 (+)、负 (-) 和逻辑非 (!) 运算符都是一元运算符，这意味着它们只对一个操作数进行操作，也就是只对应用它们的对象进行操作，所以通常一元运算符重载被实现为成员函数。</p><p>下面是个简单的例子，注意负运算符和减号运算符之间没有混淆，因为它们具有不同数量的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cents</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_cents &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cents</span>(<span class="keyword">int</span> cents): <span class="built_in">m_cents</span>(cents) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重载-负运算符，成员函数方式</span></span><br><span class="line">    Cents <span class="keyword">operator</span>-() <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCents</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cents; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义处</span></span><br><span class="line">Cents Cents::<span class="keyword">operator</span>-() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> -m_cents; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Cents nickle&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A nickle of debt is worth &quot;</span> &lt;&lt; (-nickle).<span class="built_in">getCents</span>() &lt;&lt; <span class="string">&quot; cents\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-4-最佳实现：使用什么方式重载">6.1.4 最佳实现：使用什么方式重载</h4><p>下面是一些经验法则：</p><ul><li><p>普通函数或友元函数优先考虑普通函数，可避免封装性被破坏。</p></li><li><p><strong>使用成员函数</strong>：</p><ul><li><p>在处理修改左操作数的二元运算符（例如 operator+=）时，通常首选成员函数版本，因为最右边的操作数成为一个显式参数，不会混淆谁（左参数）被修改；</p><p>但是左参数类型必须要是当前类类型，如operator&lt;&lt;，它具有 ostream 类型的左操作数，此时按普通函数方式重载最好。</p></li><li><p>一元运算符通常也作为成员函数重载，此时成员版本没有参数。</p></li></ul></li><li><p><strong>使用普通函数</strong>：</p><ul><li>在处理不修改左操作数的二元运算符（例如 operator+）时，普通或友元函数版本具有“对称”的额外好处，因为所有操作数都成为显式参数。</li></ul></li></ul><h3 id="6-2-重载-运算符">6.2 重载()运算符</h3><p>到目前为止我们接触的运算符，参数类型虽然可以设置，但参数类型是固定的。</p><p><strong>而重载括号运算符 <code>operator()</code>  ，允许我们改变它的参数类型和数量</strong>。</p><p>这有什么用？</p><p><code>operator()</code> 一大用处是用来实现函子（函数对象）。相比普通函数，</p><ul><li>函子可以<u>将任意数量的数据存储在成员变量</u>，而不用在形参中定义避免了可能的值传递开销；</li><li>函子可以<u>保存结果和状态</u>，提高代码灵活性；</li><li>函数指针不能内联，函子可以，效率更高（没验证过）。</li></ul><h4 id="6-2-1-实现函子">6.2.1 实现函子</h4><p>请看下例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accumulator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_counter&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> i)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCounter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_counter;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 1.函子数据成员m_counter保存在类中，而不是形参中定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accumulator::operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (m_counter += i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Accumulator acc&#123;&#125;;</span><br><span class="line">    <span class="comment">// 函子就像函数一样使用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">acc</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">//  10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">acc</span>(<span class="number">20</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">//  30</span></span><br><span class="line">    <span class="comment">// 2.函子保存了结果状态</span></span><br><span class="line">    acc.<span class="built_in">getCounter</span>(); <span class="comment">// 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函子更多的是应用在关联容器和STL，其中许多算法都是可以用函数或函数对象自定义比较器的</strong>。</p><p>请看下例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGreater</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (a &gt; b);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myLesser</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &lt; b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> std::array&lt;<span class="keyword">int</span>,<span class="number">6</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>,6&gt; arr = &#123; <span class="number">13</span>, <span class="number">90</span>, <span class="number">99</span>, <span class="number">5</span>, <span class="number">40</span>, <span class="number">80</span> &#125;;</span><br><span class="line">    <span class="comment">// std::sort第三个指针接受一个函数指针</span></span><br><span class="line">    <span class="comment">// 普通函数，此时myLesser是函数地址</span></span><br><span class="line">    std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), myLesser);</span><br><span class="line">    <span class="built_in">print</span>(arr);</span><br><span class="line">    <span class="comment">// 函子，此时MyGreater()也是函数地址，不要()迷惑</span></span><br><span class="line">    std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">MyGreater</span>());</span><br><span class="line">    <span class="built_in">print</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp <span class="built_in">test</span>]<span class="comment"># g++ -std=c++11 test.cpp -o test.out</span></span><br><span class="line">[root@roy-cpp <span class="built_in">test</span>]<span class="comment"># ./test.out </span></span><br><span class="line">5 13 40 80 90 99 </span><br><span class="line">99 90 80 40 13 5 </span><br></pre></td></tr></table></figure><h3 id="6-3-重载-运算符">6.3 重载=运算符</h3><h4 id="6-3-1-区分复制构造函数">6.3.1 区分复制构造函数</h4><p>复制构造函数和赋值运算符的用途几乎相同——<u>都是将一个对象复制到另一个对象</u>。</p><p>但它们最核心的区别在于作用的时机不同：</p><ul><li>复制构造函数：只要对象在<u>声明时</u>用了另一个对象（可能是编译器创建的匿名对象）进行初始化，就会触发复制构造函数，也就是进行复制<u>初始化</u>。</li><li>赋值运算符：不是在对象声明时，而是一个已存在的对象被另一个对象重新<u>赋值时</u> ，就会触发赋值运算符函数。</li></ul><p>我们通过例子来理解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">int</span> m_year&#123;&#125;;</span><br><span class="line">     <span class="keyword">int</span> m_month&#123;&#125;;</span><br><span class="line">     <span class="keyword">int</span> m_day&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">Date</span>() = <span class="keyword">default</span>;</span><br><span class="line">     <span class="built_in">Date</span>(<span class="keyword">int</span> day,<span class="keyword">int</span> month=<span class="number">1</span>,<span class="keyword">int</span> year=<span class="number">2022</span>) </span><br><span class="line">     &#123;</span><br><span class="line">         std::cout&lt;&lt; <span class="string">&quot;构造函数被调用&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">         m_year=year;m_month=month;m_day=day;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="built_in">Date</span>(Date <span class="keyword">const</span>&amp; tmp): <span class="built_in">m_year</span>(tmp.m_year),<span class="built_in">m_month</span>(tmp.m_month),<span class="built_in">m_day</span>(tmp.m_day)</span><br><span class="line">     &#123;</span><br><span class="line">         std::cout&lt;&lt; <span class="string">&quot;复制构造函数被调用&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">     &#125;</span><br><span class="line">     Date&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Date&amp; date)</span><br><span class="line">     &#123;</span><br><span class="line">         std::cout&lt;&lt; <span class="string">&quot;oprator=被调用&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">         m_year=date.m_year; m_month=date.m_year; m_day=date.m_year;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主函数中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">// 都是复制初始化</span></span><br><span class="line"> Date date1 = <span class="number">25</span>;       <span class="comment">// 1</span></span><br><span class="line">Date date2 = Date&#123;<span class="number">25</span>&#125;; <span class="comment">// 2</span></span><br><span class="line">Date date3 = date2;    <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1、2在对象date1、date2<u>声明时</u>用匿名对象进行初始化（编译器要使得<code>=</code> 左右操作类型一致，分别在<code>=</code>右侧创建了Date匿名对象，然后调用复制构造函数来初始化date1、date2）。</li><li>3处date3也是<u>声明</u>时使用了其它对象（date2）进行初始化，所以也会调用复制构造函数。</li></ul><p>但是1、2处会被编译器优化使用普通构造函数初始化，所以最后输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">构造函数被调用</span><br><span class="line">构造函数被调用</span><br><span class="line">复制构造函数被调用</span><br></pre></td></tr></table></figure><p>我们再来看看调用赋值运算符<code>=</code> 的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Date date1 = <span class="number">25</span>;       <span class="comment">// 1</span></span><br><span class="line">Date date2 = Date&#123;<span class="number">25</span>&#125;; <span class="comment">// 2</span></span><br><span class="line">date2 = <span class="number">31</span>;            <span class="comment">// 3</span></span><br><span class="line">date2 = date1;         <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造函数被调用</span><br><span class="line">构造函数被调用</span><br><span class="line">oprator=被调用</span><br><span class="line">oprator=被调用</span><br></pre></td></tr></table></figure><p>也就是3、4处都是调用了赋值运算符<code>=</code> 进行赋值（不是初始化）：</p><ul><li>3处，date2不是声明时进行<u>初始化</u>，而是使用编译器生成的匿名对象进行<u>重新赋值</u> ；</li><li>4处，同理，date2不是声明时进行<u>初始化</u> ，使用date1进行<u>重新赋值</u> 。</li></ul><p>它们都符合前文所述：“而是一个已存在的对象被另一个对象重新<u>赋值时</u> ，就会触发赋值运算符函数” 。</p><h2 id="更新记录">更新记录</h2><div class="timeline"><div class="timenode"><div class="meta"><p><p>2022-01-29 ：更新笔记</p></p></div><div class="body"><ol><li>第一次更新</li></ol></div></div></div><h2 id="参考资料">参考资料</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++STL中的函数对象 ：https://blog.csdn.net/CV_Jason/article/details/83899253<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
          <category> C++面对对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 教程 </tag>
            
            <tag> C++基础 </tag>
            
            <tag> 运算符重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++从零开始（七）：面对对象（上）快速入门</title>
      <link href="/p/17506/"/>
      <url>/p/17506/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，开始更新中…</p></blockquote><div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div><h2 id="五、面对对象入门">五、面对对象入门</h2><p>C++和C一大主要区别，便是引入了入面对对象。</p><p>为什么需要引入面对对象？它有什么好处？</p><h3 id="5-1-为什么需要面对对象？">5.1 为什么需要面对对象？</h3><h4 id="5-1-1-从面向过程说起">5.1.1 从面向过程说起</h4><p>在传统编程中，<u>数据和处理该数据的函数是单独的实体</u>，它们组合在一起以产生所需的结果。</p><p>也就是面向过程通常做法。</p><p>但是由于面向过程的这种分离，传统编程通常不能提供非常直观的现实表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">goToHome</span>(you);</span><br></pre></td></tr></table></figure><p>在这个例子中，行为主体<code>you</code> 和行为<code>goToHome</code> 被分隔了：<code>you</code>  被当做单独的数据实体，行为<code>goToHome</code> 被当做单独的函数实体。</p><p>面对对象则提供了更直观的表示能力。</p><p>因为面对对象<u>将对象（行为主体）、属性和行为封装到独立、可重置的类中。</u> 而这些属性和行为往往也被认为是密不可分的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you.<span class="built_in">goToHome</span>();</span><br></pre></td></tr></table></figure><p>显然，这让对象（<code>you</code>）是谁，以及正在调用什么行为（<code>goToHome</code>）更清楚了。我们不再专注于编写函数，而是专注于定义<u>行为集的对象</u>。</p><p>这，也就是面对对象。</p><p>得益于这种专注于对象的行为，面对对象带来以下几个好处：</p><ul><li>代码模块化</li><li>更容易理解、直观</li><li>可重用性高</li></ul><p>现在我们来举一个更具体的例子进行对比：分别使用面向过程和面向对象的方式，打印年/月/日到屏幕上。</p><ul><li><p>面对过程</p><p>按照面对过程的思想，<code>Date</code>当做独立变量组织了“年/月/日”，“打印”则当做独立行为（函数）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> year &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> month &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> day &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> DateStruct&amp; date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; date.year &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; date.month &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; date.day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date today &#123; <span class="number">2022</span>, <span class="number">1</span>, <span class="number">24</span> &#125;;</span><br><span class="line">    today.day = <span class="number">25</span>; </span><br><span class="line">    <span class="built_in">print</span>(today);  <span class="comment">// 2022/1/25</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>面向对象</p><p>面向对象则将<code>Date</code>视作行为主体（对象），“年/月/日”被当做其成员变量，“打印”则是其成员函数。此时明确了行为主体对象<code>Date</code>，建立了“年/月/日”和行为“打印”的关联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>  // <span class="keyword">class</span>关键字</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _year &#123;&#125;;  <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">int</span> _month &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> _day &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span>  <span class="comment">// 成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_year &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; m_month &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; m_day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date today &#123; <span class="number">2022</span>, <span class="number">1</span>, <span class="number">24</span> &#125;;</span><br><span class="line">    today._day = <span class="number">25</span>; </span><br><span class="line">    <span class="comment">// 主体对象.行为() </span></span><br><span class="line">    today.<span class="built_in">print</span>();  <span class="comment">// 2022/1/25</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>相信你对面对对象有了更深刻的理解，现在来更系统地了解面对对象基本组成吧。</p><h4 id="5-1-2-面对对象组成">5.1.2 面对对象组成</h4><h5 id="成员组成">成员组成</h5><p>其实，前面我们已经展示了面对对象最基本的组成：<u>成员变量</u>和<u>成员函数</u>。</p><p>面对对象还可以有<u>成员类型</u> 、<u>嵌套类型</u>。</p><ul><li><p><strong>成员类型</strong></p><p>成员类型规定这个类基本数据类型，这样我们只需更新类型别名，而不必替换基本类型。</p><p>这样说有点难以理解，举个例子：<code>vector</code>类规定的类型<code>size_type</code> 。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220125171853448.png" alt="image-20220125171853448"></p><p><code>size_t</code> 归根究底就是类型<code>long unsigned int</code> 别名</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220125172016902.png" alt="image-20220125172016902"></p><p>也就是说下面两种写法是等价的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt;::size_type x;  <span class="comment">// 等价：unsigned long int x </span></span><br><span class="line">std::cout&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(x).<span class="built_in">name</span>()&lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// m，表示unsigned long (int)</span></span><br></pre></td></tr></table></figure><p><code>stl_vector.h</code> 变量基本都是使用的这种类型别名声明，比如我们熟悉的<code>size()</code> 方法声明：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220125172456097.png" alt="image-20220125172456097"></p><p><strong>回到前面：这样做有什么好处</strong>？</p><p>当我们想修改vector使用的基本类型，只需要将修改类型别名就行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #define __SIZE_TYPE__ long unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SIZE_TYPE__ int  <span class="comment">// 现在vector基本类型被你声明为int</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>嵌套类型</strong></p><p>这个很好理解，只要：类类型、结构体类型、枚举类型在类中声明，就可以称其为嵌套类型。</p><p>以枚举类型嵌套为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 此时枚举类型声明在类Fruit中</span></span><br><span class="line">    <span class="comment">// 所以枚举类型此时是个嵌套类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FruitType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">apple,</span><br><span class="line">banana,</span><br><span class="line">cherry</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">FruitType m_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Fruit</span>(FruitType type) :m_type &#123; type &#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="function">FruitType <span class="title">getType</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_type;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意枚举类型不限制作用范围</span></span><br><span class="line">Fruit apple &#123; Fruit::apple &#125;; <span class="comment">// 调用构造函数Fruit(FruitType type)</span></span><br><span class="line">    apple.<span class="built_in">getType</span>() ; <span class="comment">// FruitType::apple</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="访问控制符">访问控制符</h5><p><u>类成员访问控制符实现了类的封装</u>，C++访问符包括：</p><ul><li>pprivate：私有成员，该成员仅在类内可以被访问，在类体外（包括派生类）是隐藏状态；</li><li>public：公有成员，该成员在类内、类外也都可以被访问，是类对外提供的可访问接口。</li></ul><p>在继承中，我们引入了第三种修饰符：</p><ul><li><p>protected：保护成员，和私有成员类似，不过在<u>派生类</u>可以被访问。</p><blockquote><p>最佳实践：从降低类的耦合性来说，优先考虑private而不是protect。</p></blockquote></li></ul><p><code>Base</code> 类中三种成员访问权限也可以用下图形象表示：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220208003805697.png" alt="image-20220208003805697"></p><p>具体实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_public &#123;&#125;; </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_protected &#123;&#125;; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_private &#123;&#125;; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_public = <span class="number">1</span>;    <span class="comment">// ok</span></span><br><span class="line">        m_protected = <span class="number">2</span>; <span class="comment">// ok</span></span><br><span class="line">        m_private = <span class="number">3</span>;   <span class="comment">// error，派生类访问私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base;</span><br><span class="line">    base.m_public = <span class="number">1</span>;    <span class="comment">// ok</span></span><br><span class="line">    base.m_protected = <span class="number">2</span>; <span class="comment">// error，类外访问保护成员</span></span><br><span class="line">    base.m_private = <span class="number">3</span>;   <span class="comment">// error，类外访问私有成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个例子，进一步说明protected访问说明符作用。</p><blockquote><p>涉及到<u>7.1</u> 继承一些知识：</p><ul><li>派生类由两个部分组成：继承的基类副本部分，派生类自身扩展的部分。</li><li>派生类实例化时，必须先调用基类构造函数初始化基类副本部分，再调用派生类构造函数初始化派生类部分。</li></ul></blockquote><p>假设我们有一个基类A，我们希望它：</p><ol><li><p>A不能被实例化；</p></li><li><p>但能被继承，派生类类可以实例化。</p></li></ol><p>为了满足第一点，我们想到可以将A的构造函数声明为private。</p><p>但这样就无法满足第二点：派生类无法实例化，因为派生类无法调用基类副本的私有构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b ; <span class="comment">// error: ‘A::A()’ is private</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候需要将A的构造函数声明为protected：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">A</span>()&#123;&#125;</span><br></pre></td></tr></table></figure><p>这样派生类就可以调用基类的构造函数进行初始化基类副本了。</p><p><strong>最佳实践：类成员变量是私有的，类成员函数是公开的</strong>。</p><p>为什么这么建议？</p><ul><li><p>对于普通人而言，遥控器就是一个简单的包括若干的按钮界面，用户只关心按钮按下的效果，但不关心具体是如何和电视通信。类似的，踩下油门踏板也不需要关心内燃机如何使得车轮转动。</p></li><li><p>这其实就是<u>接口分离</u>的思想：降低对象复杂性，使得我们在不了解对象如何工作的前提下，可以去使用对象。</p></li></ul><h5 id="三大特性之封装">三大特性之封装</h5><p><strong>结构分离思想也就是面对对象三大特性：封装，的重要组成部分</strong>。</p><p><strong>怎么实现封装</strong>？</p><p>在 C++ 中，我们通过<u>访问说明符实现封装</u>。类的所有成员变量都是私有的（隐藏实现细节），大多数成员函数都是公开的（向用户公开接口）。</p><p>封装具体有什么好处？</p><ul><li>降低对象复杂性，同前；</li><li>保护数据，类中定义的成员变量都是全局变量，意味着它可以被类任何对象修改，这很危险。使用private修饰避免了这一点，访问数据只能公共接口函数；</li><li>更容易调试，因为每个人都只能通过同一个公共函数修改某个值，这样值不正确时很容易进行debug；</li><li>更容易修改，…</li></ul><p>另外两大特性将会在后面章节介绍：</p><ul><li>继承：让某种类型（派生类）对象获得另一个类型对象（基类）的属性和方法。</li><li>多态：C++ 多态指相同对象收到不同消息，或不同对象收到相同消息时，产生不同的实现动作。</li></ul><h5 id="类和结构体这么像？">类和结构体这么像？</h5><p>看到这你不禁想吐槽，你说类这些功能：</p><ul><li>嵌套、变量、函数</li></ul><p>结构体都支持啊？甚至你还知道更多：</p><ul><li>结构体支持继承、多态…</li></ul><p>是的，在C++中类和结构体除了<u>默认访问符</u>外太像了，以至于很多开发人员认为这是个错误的设计。</p><p>确实，这的确有点不合理。根据前人经验——</p><p><strong>最佳实践：将 struct 用于纯数据结构，对同时具有数据和函数的对象使用 class</strong>。</p><p>也就是说，建议struct声明为POD(Plain Old Data)类型进行使用。</p><p><a href="https://zhuanlan.zhihu.com/p/45545035">什么是POD类型？</a></p><p>如果struct/class/enum等，只定义了常规数据类型(不含有自定义数据类型)，不使用封包或者其它面对对象特征，那么就是POD类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myDate</span>   // <span class="title">POD</span>类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-2-构造函数及初始化">5.2 构造函数及初始化</h3><p>当一个类/结构体的所有成员都是公共成员时，我们可以直接<u>列表初始化</u>类/结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x ;</span><br><span class="line">    <span class="keyword">int</span> m_y ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo1 &#123; <span class="number">1</span>, <span class="number">2</span> &#125;; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是前面我们也强调过，成员变量一般声明为private。</p><p><strong>此时如何初始化private修饰的成员变量</strong>？</p><ul><li><p>如果私有成员变量仅仅是需要零值初始化，在类成员变量使用列表初始化<code>&#123;&#125;</code>即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x&#123;&#125; ;  <span class="comment">// 声明时列表初始化</span></span><br><span class="line">    <span class="keyword">int</span> m_y&#123;&#125; ;  <span class="comment">// 声明时列表初始化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>如果私有成员变量需要指定值，<strong>使用构造函数可以指定初始化类的成员变量</strong>。</p></li></ul><p>构造函数有特定命名规则：</p><ul><li>和类同名</li><li>没有返回类型</li></ul><p>从默认构造函数开始吧。</p><h4 id="5-2-1-默认构造函数、初始化及类分配">5.2.1 默认构造函数、初始化及类分配</h4><h5 id="默认构造函数">默认构造函数</h5><p>不带参数（或所有参数都具有默认值）的构造函数称为<strong>默认构造函数</strong>。</p><blockquote><p>【注】没有一个构造函数被显式声明时，编译器会隐式声明一个默认构造函数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> m_denominator &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Fraction</span>() <span class="comment">// 默认构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_numerator = <span class="number">0</span>;</span><br><span class="line">        m_denominator = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Fraction frac&#123;&#125;; <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>Fraction frac&#123;&#125;</code>时，会创建类<code>Fraction</code>的实例 <code>frac</code>，然后调用默认构造函数初始化对象<code>frac</code>。</p><p>有时候你也会看到下面初始化方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fraction frac;</span><br><span class="line"><span class="function">Fraction <span class="title">frac</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这二者有什么不同吗？</p><h5 id="列表初始化和直接初始化">列表初始化和直接初始化</h5><p><code>Fraction frac&#123;&#125;</code> 通常称为列表初始化，而 <code>Fraction frac / Fraction frac()</code> 被称为直接初始化。</p><p>它们都会在执行时调用相关构造函数，但是<code>&#123;&#125;</code> 方式还<u>可能</u>会使得编译器调用构造函数之前，<u>对成员变量进行零值初始化</u>。</p><p>验证一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator ;  <span class="comment">// 去除&#123;&#125;</span></span><br><span class="line">    <span class="keyword">int</span> m_denominator ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Fraction</span>()  <span class="comment">// 不做任何事</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// m_numerator = 0;  </span></span><br><span class="line">        <span class="comment">// m_denominator = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Fraction frac1&#123;&#125;; <span class="comment">// 列表初始化</span></span><br><span class="line">    Fraction frac2;   <span class="comment">// 直接初始化</span></span><br><span class="line">    std::cout&lt;&lt;frac1.m_numerator&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;frac2.m_numerator&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">2082139952</span><br></pre></td></tr></table></figure><p>可见列表初始化方式确实对成员变量进行了<u>零值初始化</u>，而进行直接初始化存的是垃圾值（这一点我们在<u>1.2.4</u>节也总结对比过，此时成员变量值都是<u>默认初始化</u>的垃圾值）。</p><h5 id="类静态分配和动态分配">类静态分配和动态分配</h5><p>在这之前我们见到类的对象都是静态分配的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fraction frac2;</span><br><span class="line">Fraction frac1&#123;&#125;; </span><br></pre></td></tr></table></figure><p>编译器静态建立一个类对象，在<u>栈空间</u>中分配内存，<u>所以该对象内存不需要我们管理</u>，编译器负责释放。</p><p>我们还可以进行动态分配（new方式）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fraction* pfrac = <span class="keyword">new</span> Fraction&#123;&#125;;</span><br></pre></td></tr></table></figure><p>此时编译器动态建立一个类对象，在<u>堆空间</u>上分配内存，需要我们使用delete显式删除管理内存。</p><p><strong>类如何实现只能静态分配或只能动态分配对象</strong> ？</p><ul><li>只能静态分配：把new、delete运算符重载为private；</li><li>只能动态分配：把构造设为private/protected属性，类静态函数分配对象。</li></ul><p>下面是实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能静态分配，禁用new（声明为private）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> t)</span></span>&#123;&#125;     <span class="comment">// 注意函数的第一个参数和返回值都是固定的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>&#123;&#125;  <span class="comment">// 重载了new就需要重载delete</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能动态分配（外部无法使用构造函数，也就无法实例化，只能通过内部函数动态分配内存返回）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> B* <span class="title">create</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">B</span>();&#125; <span class="comment">// 静态函数，因为不能创建对象</span></span><br><span class="line">    ~<span class="built_in">B</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a; <span class="comment">// 静态分配</span></span><br><span class="line">    B* b = B::<span class="built_in">create</span>(); <span class="comment">// 动态分配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-转换构造函数">5.2.2 转换构造函数</h4><p>C++ 会将任何构造函数视为隐式转换运算符，在<u>4.X.1 用户自定义隐式转换</u>有过详细介绍。</p><p>简单回忆一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 1.转换构造函数</span></span><br><span class="line">        <span class="built_in">dog</span>(string name) &#123;m_name = name;&#125; </span><br><span class="line">        <span class="comment">// 2.类型转换重载</span></span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> m_name;&#125; </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      string dogname = <span class="string">&quot;dog&quot;</span>;</span><br><span class="line">      <span class="comment">// 1.转换构造函数</span></span><br><span class="line">      dog d = dogname; <span class="comment">// ok</span></span><br><span class="line">      <span class="comment">// 2.类型转换重载</span></span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;my name is &quot;</span> &lt;&lt; <span class="built_in">string</span>(d) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体过程涉及到复制初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dog d = dogname; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><ol><li>表达式从右到左，构造函数<code>dog(string)</code>作为转换构造函数 ，编译器先创建<code>dog</code>临时匿名对象，使得<code>=</code>两边操作类型一致；</li><li>然后<code>dog(string)</code> 初始化匿名对象；</li></ol><p>至此，完成了<code>string</code>类型隐式转换为<code>dog</code> 。接下来是复制初始化相关过程：</p><ol><li>编译器创建对象<code>d</code> ；</li><li>调用复制构造函数，用匿名对象成员值复制初始化对象<code>d</code> 。</li></ol><p>初始化相关工作细节&amp;原理请看下文。</p><h4 id="5-2-3-再谈初始化🌟">5.2.3 再谈初始化🌟</h4><p>回顾一下三种初始化方式。</p><p>下面是列表初始化<code>&#123;&#125;</code> 初始化（可能会对非静态成员进行零值初始化）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> m_month&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> m_day&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Date</span>(<span class="keyword">int</span> day,<span class="keyword">int</span> month=<span class="number">1</span>,,<span class="keyword">int</span> month=<span class="number">1</span><span class="keyword">int</span> year=<span class="number">2022</span>) <span class="comment">// 带参数的构造函数，存在默认值</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_year=year;m_month=month;m_day=day;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date date&#123;<span class="number">25</span>&#125;; <span class="comment">// 列表初始化，调用带参构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用直接初始化方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">date</span><span class="params">(<span class="number">25</span>)</span></span>; <span class="comment">// 直接初始化</span></span><br></pre></td></tr></table></figure><p>甚至你还可以使用<u>复制初始化</u>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date date1 = <span class="number">25</span>;   <span class="comment">// 1，还进行了隐式转换，等价于Date date1 =Date(25)</span></span><br><span class="line">Date date2 = <span class="built_in">Date</span>(<span class="number">25</span>); <span class="comment">// 2</span></span><br><span class="line">Date date3 = Date&#123;<span class="number">25</span>&#125;; <span class="comment">// 3</span></span><br><span class="line">Date date4 = date3;    <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><strong><code>=</code> 左侧是被初始化的对象，因为<code>=</code>左右两侧操作类型要相等，所以<code>=</code> 右侧会先生成一个（匿名）对象，对左侧对象成员进行（复制）初始化</strong>。</p><p>但是，我们建议避免使用类进行复制初始化，因为一般效率较低且不安全。</p><p>为什么会这样？复制初始化是怎么工作的？</p><h5 id="复制初始化">复制初始化</h5><blockquote><p>参考：<a href="https://sqrt-1.me/?p=241">C++的直接初始化与复制初始化</a></p></blockquote><p>先说说直接初始化是如何工作的：</p><p><strong>注意，构造函数没有创建对象，只进行初始化。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">date</span><span class="params">(<span class="number">25</span>)</span></span>; <span class="comment">// 直接初始化</span></span><br></pre></td></tr></table></figure><ol><li>编译器创建一个对象<code>date</code> ；</li><li>初始化static<u>静态成员</u>；</li><li>最后调用匹配的构造函数 <code>Date(int day,int year=2022,int month=1)</code>初始化<code>date</code>的<u>非静态成员</u>。</li></ol><p>列表初始化类似，只是在调用构造函数前，<u>可能还会对非静态成员进行零值初始化</u>。</p><p>对于复制初始化，还涉及到编译器为我们隐式声明的复制构造函数。</p><p>一个空类默认会添加以下函数，包括复制构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缺省构造函数</span></span><br><span class="line"><span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">~<span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// 赋值运算函数</span></span><br><span class="line">Date&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Date&amp;);</span><br><span class="line"><span class="comment">// 复制构造函数 （copy constructor）</span></span><br><span class="line"><span class="built_in">Date</span>(Date <span class="keyword">const</span>&amp; tmp);</span><br></pre></td></tr></table></figure><p>其中复制构造函数完整定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员列表方式，下节介绍</span></span><br><span class="line"><span class="built_in">Date</span>(Date <span class="keyword">const</span>&amp; tmp):<span class="built_in">m_year</span>(tmp.m_year),<span class="built_in">m_month</span>(tmp.m_month),<span class="built_in">m_day</span>(tmp.m_day) </span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>回到复制初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="built_in">Date</span>(<span class="number">25</span>); <span class="comment">// 复制初始化</span></span><br></pre></td></tr></table></figure><ol><li><p>为了<code>=</code>两侧操作类型一致，<u>编译器首先创建一个匿名对象</u>，为方便记为<code>tmp</code>；</p><blockquote><p>注：<code>Date(25)</code> 是一种匿名对象初始化方式，它隐藏了对象的名字，等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">tmp</span><span class="params">(<span class="number">25</span>)</span></span>; <span class="comment">// 匿名对象假设为tmp</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>执行<code>Date(25)</code>，（匿名对象中的）构造函数 <code>Date(int day,int year=2022,int month=1)</code> <u>初始化临时对象</u>；</p></li><li><p>编译器创建一个对象<code>date</code> ；</p></li><li><p>最后编译器再调用（对象<code>date</code>中）<u>拷贝构造函数</u>，将临时匿名对象<code>tmp</code>作为拷贝构造函数参数 ，<code>date</code> 每个成员值复制临时匿名对象成员。</p></li></ol><p><strong>只要对象在<u>声明时</u>用了另一个对象（可能是编译器创建的匿名对象）进行初始化，就会触发复制构造函数，也就是复制<u>初始化</u>。</strong></p><p><strong>另一方面，我们不要执着于表象，=不重要：复制初始化核心在于调用复制构造函数，而不是调用普通构造函数初始化</strong>。</p><p>下面这种方式虽然没有<code>=</code> ，看起来像直接初始化。但<code>Date date5</code> <u>声明</u>时使用了对象<code>date1</code> 进行初始化，所以依旧是复制初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">date5</span><span class="params">(date1)</span></span>;   <span class="comment">// 复制初始化</span></span><br></pre></td></tr></table></figure><p>显然，这种“复制”效率可想而言是低下的，因为它还可能会创建临时匿名对象。</p><blockquote><p>不过标准规定，为了提高效率，允许编译器在合适的地方进行优化，<u>跳过创建临时匿名对象</u>这一步，直接调用构造函数构造要创建的对象。</p><p>下面4个复制初始化哪些会执行复制构造函数？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">int</span> m_year&#123;&#125;;</span><br><span class="line">     <span class="keyword">int</span> m_month&#123;&#125;;</span><br><span class="line">     <span class="keyword">int</span> m_day&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">Date</span>() = <span class="keyword">default</span>;</span><br><span class="line">     <span class="built_in">Date</span>(<span class="keyword">int</span> day,<span class="keyword">int</span> month=<span class="number">1</span>,<span class="keyword">int</span> year=<span class="number">2022</span>) </span><br><span class="line">     &#123;</span><br><span class="line">         m_year=year;m_month=month;m_day=day;</span><br><span class="line">         std::cout&lt;&lt; <span class="string">&quot;构造函数被调用&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="built_in">Date</span>(Date <span class="keyword">const</span>&amp; tmp): <span class="built_in">m_year</span>(tmp.m_year),<span class="built_in">m_month</span>(tmp.m_month),<span class="built_in">m_day</span>(tmp.m_day)</span><br><span class="line">     &#123;</span><br><span class="line">         std::cout&lt;&lt; <span class="string">&quot;复制构造函数被调用&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">// 都是复制初始化</span></span><br><span class="line"> Date date1 = <span class="number">25</span>;       <span class="comment">// 1 </span></span><br><span class="line">Date date2 = <span class="built_in">Date</span>(<span class="number">25</span>); <span class="comment">// 2</span></span><br><span class="line">Date date3 = Date&#123;<span class="number">25</span>&#125;; <span class="comment">// 3</span></span><br><span class="line">Date date4 = date3;    <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果可能会让你有些惊讶：除了方式<code>4</code> ，其余都没用调用复制构造函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# g++ -std=c++11 test.cpp -o test.out</span><br><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">构造函数被调用</span><br><span class="line">构造函数被调用</span><br><span class="line">构造函数被调用</span><br><span class="line">复制构造函数被调用</span><br></pre></td></tr></table></figure><p>也就是除了方式<code>4</code> ，编译器都进行了优化（1、2、3生成了匿名对象，编译器可以跳过）。所以方式1、2、3等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">date1</span><span class="params">(<span class="number">25</span>)</span></span>;</span><br><span class="line"><span class="function">Date <span class="title">date2</span><span class="params">(<span class="number">25</span>)</span></span>;</span><br><span class="line"><span class="function">Date <span class="title">date3</span><span class="params">(<span class="number">25</span>)</span></span>;</span><br></pre></td></tr></table></figure></blockquote><p><strong>不仅如此，复制初始化效率低的同时还并不安全</strong>。</p><p>因为这种拷贝方式是<u>浅拷贝</u>，如果存在指针也只是复制其值，不会复制其指向的区域。</p><h5 id="深拷贝和浅拷贝">深拷贝和浅拷贝</h5><p>浅拷贝会带来什么问题？</p><p>浅拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现double free。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *p&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span>()&#123;p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">4</span>);&#125;</span><br><span class="line">        ~<span class="built_in">Test</span>()&#123;<span class="keyword">delete</span> p;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Test ob1;</span><br><span class="line">   Test ob2 = ob1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行出错：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220126000908921.png" alt="image-20220126000908921"></p><p>给各位看官分析下原因：</p><ol><li><p><code>Test ob1</code>构造类对象ob1，这是调用了<u>构造函数</u>，为ob1.p分配了内存空间；</p></li><li><p><code>Test ob2 = ob1</code>，调用复制构造函数构造类对象ob2 = ob1;</p></li><li><p>main()函数执行完毕，全局函数的运行周期结束，系统回收内存（析构函数除了显示delete执行，对象离开作用范围会自动执行）：</p><ul><li>先调用ob1的析构函数，将ob1.p指向的内存释放；</li><li>再调用ob2的析构函数，将ob2.p指向的内存释放。</li></ul></li><li><p>但是由于ob2.p的内存已经在上一步被释放，所以造成了double free。</p></li></ol><p>解决这个问题也很简单：</p><ul><li><p><strong>禁止使用<u>拷贝构造函数</u></strong>：</p><p>使用delete关键字禁止（推荐）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11新特性delete</span></span><br><span class="line"><span class="built_in">Test</span>(Test &amp;ob) = <span class="keyword">delete</span>; </span><br></pre></td></tr></table></figure><p>或声明为private：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:  <span class="comment">// 尝试调用私有成员函数会出错</span></span><br><span class="line"><span class="built_in">Test</span>(Test &amp;ob)&#123;...&#125;; </span><br></pre></td></tr></table></figure><p>让使用者无法使用<u>默认</u>构造函数。</p></li><li><p><strong>深拷贝</strong>：</p><p>自己显示声明复制构造函数，对成员变量实现深拷贝（复制指针内存区域值）。</p><p>深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *p&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]();</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Test</span>()&#123;<span class="keyword">delete</span> p;&#125;</span><br><span class="line">        <span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; other) <span class="comment">// 实现深拷贝</span></span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">if</span>(p) <span class="comment">// p不空</span></span><br><span class="line">             <span class="keyword">delete</span> p;</span><br><span class="line">            <span class="keyword">if</span>(other.p)  <span class="comment">// other.p不空</span></span><br><span class="line">            &#123;</span><br><span class="line">                p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">4</span> ; i++)</span><br><span class="line">                p[i] = other.p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="成员初始化列表">成员初始化列表</h5><p><strong>怎么初始化类私有成员</strong>？</p><p>看过前面文章的你肯定脱口而出：构造函数呀！</p><p>还有吗？对了，还有列表初始化。就像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year&#123; <span class="number">1900</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_month&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_day&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>但如果私有成员被const修饰呢</strong>？</p><p>列表初始化依旧可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_year&#123; <span class="number">1900</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_month&#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_day&#123; <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure><p>但是如果用户想使用构造函数初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带参数的构造函数，存在默认值</span></span><br><span class="line"><span class="built_in">Date</span>(<span class="keyword">int</span> day,<span class="keyword">int</span> year,<span class="keyword">int</span> month) </span><br><span class="line">    &#123;m_year=year;m_month=month;m_day=day;&#125;;</span><br></pre></td></tr></table></figure><p>出错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int Date::m_year</span><br><span class="line">expression must be a modifiable lvalue</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_year&#123; <span class="number">1900</span> &#125;;</span><br><span class="line">m_year = year;  <span class="comment">// 常量不能修改，出错</span></span><br></pre></td></tr></table></figure><p>这种情况就需要用到<u>成员初始化列表</u>。</p><p><strong>成员初始化列表可以让用户初始化私有变量，包括常量</strong>。</p><p>成员初始化列表在构造函数后接<code>:</code> 进行初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_year&#123; <span class="number">1900</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_month&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_day&#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Date</span>(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day ):<span class="built_in">m_year</span>(year),<span class="built_in">m_month</span>(month),<span class="built_in">m_day</span>(day) <span class="comment">// 带参数的构造函数，存在默认值</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printDay</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       std::cout&lt;&lt;m_day&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date d&#123;<span class="number">2022</span>,<span class="number">1</span>,<span class="number">26</span>&#125;;</span><br><span class="line">    d.<span class="built_in">printDay</span>();  <span class="comment">// 26，确实重新初始化了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>成员初始化还可以初始化数组成员</strong>。</p><p>在 C++11之前，只能通过成员初始化列表将数组成员归零：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_array[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Something</span>(): m_array &#123;&#125; <span class="comment">// 只归零</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在还可以赋值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_array[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Something</span>(): m_array &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; <span class="comment">//  对数组进行赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后注意，初始化列表中的变量是<u>按照类声明顺序进行初始化，而不是列表指定的顺序</u>。</p><h5 id="成员列表初始化更快？">成员列表初始化更快？</h5><p>准确来说：</p><ul><li>对于内置数据类型，复合类型（指针，引用）,成员初始化列表和构造函数体内进行性能没有什么差别；</li><li>对于用户自定义类型（类类型），成员列表初始化会快很多。</li></ul><p>这是因为对于用户自定义类型，使用成员列表初始化<u>会少使用一次构造函数</u>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备好classA</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classA</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">classA</span>() &#123; cout &lt;&lt; <span class="string">&quot;classA()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">classA</span>(<span class="keyword">const</span> classA&amp; a) &#123; cout &lt;&lt; <span class="string">&quot;copy classA()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">classA</span>() &#123; cout &lt;&lt; <span class="string">&quot;~classA()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="comment">// 重载赋值运算符</span></span><br><span class="line">    classA&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> classA&amp; a) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator= in classA&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>理解这个问题需要一点前置知识：</p><ol><li><p>什么时候会使用复制构造函数？<u>声明</u>一个对象时用另外一个<u>已存在</u>的对象进行<u>初始化</u>时，会调用复制构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">A b = <span class="built_in">A</span>();  <span class="comment">// 编译器生成匿名，然后调用复制构造函数初始b（不过编译器会优化）</span></span><br><span class="line">A b = a;    <span class="comment">// 已存在的对象a调用复制构造函数初始化b</span></span><br></pre></td></tr></table></figure></li><li><p>什么时候会使用赋值运算符？</p><blockquote><p>重载<code>=</code>赋值运算符在下章介绍。</p></blockquote><p>当一个<u>已存在</u>的对象用另外一个<u>已存在</u>的对象进行<u>赋值</u>时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">A b;</span><br><span class="line">b = a; <span class="comment">// a,b之前就已存在，此时a调用赋值运算符函数对b进行赋值</span></span><br></pre></td></tr></table></figure></li><li><p>类对象成员初始化动作<u>早于构造函数体执行前</u>，和<u>成员列表同时发生</u>。</p></li></ol><p>有了这些基础知识，我们来分析为什么成员列表初始化更快。</p><ul><li><p>成员列表初始化方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">classC</span>(<span class="keyword">const</span> classA&amp; a) : <span class="built_in">mA</span>(a) &#123;&#125;  <span class="comment">// 对mA进行成员列表初始化</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    classA mA;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    classA class_a;</span><br><span class="line">    <span class="function">classC <span class="title">c</span><span class="params">(class_a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classA()</span><br><span class="line">copy classA()</span><br><span class="line">~classA()</span><br><span class="line">~classA()</span><br></pre></td></tr></table></figure><p>代码11、12行处等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classA class_a;  <span class="comment">// 输出：classA()，执行构造函数，初始化对象class_a</span></span><br><span class="line">classA mA = a; <span class="comment">// 输出：copy classA()，也是调用复制构造函数方式</span></span><br></pre></td></tr></table></figure><p>可以看到，类实例化给对象分配内存时（比如<code>mA</code>）：</p><ol><li>同时执行成员列表初始化对<code>mA</code>J进行初始化，即<code>classA mA = a</code> ；</li><li>再执行构造函数<u>体</u>。</li></ol></li><li><p>构造函数<u>体</u>初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">classC</span>(<span class="keyword">const</span> classA&amp; a) </span><br><span class="line">    &#123;</span><br><span class="line">       mA = a;  <span class="comment">// 函数体内初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    classA mA;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    classA class_a;</span><br><span class="line">    <span class="function">classC <span class="title">c</span><span class="params">(class_a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">classA()</span><br><span class="line">classA()</span><br><span class="line">operator= in classA</span><br><span class="line">~classA()</span><br><span class="line">~classA()</span><br></pre></td></tr></table></figure><p>上述代码14、15行处等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classA class_a;  <span class="comment">// 输出：classA()，执行构造函数，初始化对象class_a</span></span><br><span class="line">classA mA;       <span class="comment">// 输出：classA()，执行构造函数，初始化对象mA</span></span><br><span class="line">mA = a;          <span class="comment">// 输出：operator= in classA，一个已存在的对象初始化另外一个已存在的对象，使用赋值初始化</span></span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li>由于类成员分配内存早于构造函数<u>体</u>执行，先执行<code>classA mA</code>，调用<u>默认构造函数</u>对<code>mA</code>进行默认初始化 ；</li><li>再执行构造函数<u>体</u> ，也就是<code>mA = a</code>，这个时候是用<u>赋值=函数</u>进行重新赋值；</li></ul><p>而成员列表初始化方式，在类成员分配内存时时同时使用<u>复制构造函数</u>进行初始化。</p></li></ul><p>所以相比之下，成员列表初始化少调用了一次构造函数对类对象成员（<code>mA</code>）进行初始化，成员列表初始化效率更高。</p><h5 id="最佳实践：初始化选择">最佳实践：初始化选择</h5><p>迄今为止我们接触了好几种初始化方式：</p><p>类实例方式：</p><ol><li>列表初始化</li><li>直接初始化</li><li>复制初始化</li><li><code>std::move</code></li></ol><p>类声明初始化位置：</p><ol><li>成员初始化列表初始化</li><li>普通构造函数体内初始化</li></ol><p><strong>怎么进行选择</strong>？</p><p>类声明初始化位置：</p><ul><li><p><u>类类型成员、常量成员、引用成员</u>优先考虑<u>成员初始化列表</u>。因为成员初始化列表不在函数体内，效率更高；</p><p>（补充其它情况：当调用一个基类的构造函数，而构造函数拥有一组参数时；当调用一个成员类的构造函数，而它拥有一组参数。）</p></li><li><p>如果类成员还需要在调<u>用构造函数前</u>就提供默认值，成员声明时使用<code>&#123;&#125;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m_year&#123; <span class="number">1900</span> &#125;;</span><br></pre></td></tr></table></figure></li><li><p>最后考虑普通构造函数。</p></li></ul><p>类实例方式：</p><ul><li>优先考虑<u>列表初始化</u>。因为列表初始化还可能会进行零值初始化，更安全，但效率相比直接初始化更低点。</li><li>如果是临时对象初始化场景，使用<code>std::move</code>移动构造函数初始化。</li><li>慎重使用复制初始化。因为这种方式还会创建临时对象，效率比较低，而且不安全（浅拷贝）——一般是<u>需要显式声明复制构造函数实现对象复制时（深拷贝）才使用</u>。</li></ul><h4 id="5-2-4-移动构造函数">5.2.4 移动构造函数</h4><h5 id="什么是移动构造函数？">什么是移动构造函数？</h5><blockquote><p>C++11之前，对象的拷贝控制由三个函数决定：拷贝构造函数（Copy Constructor）、拷贝赋值运算符（Copy Assignment operator）和析构函数（Destructor）。</p><p>C++11新增加了两个函数：移动构造函数（Move Constructor）和移动赋值运算符（Move Assignment operator）。</p></blockquote><p>在前面我们介绍了两种方法来避免指针浅拷贝造成double free的问题。</p><p><strong>在这里我们介绍第三种方法：被复制的对象的指针成员置为NULL</strong>：</p><p>指针的浅拷贝之所以危险，究其本质是因为被析构函数释放了两次。例如上述指针<code>p</code> 的空间就被释放了两次，导致double free。</p><p><strong>如果被复制的对象不再被使用，我们可以在复制构造函数进行浅拷贝后将指针成员置为NULL，析构时判断指针被置为NULL就不被释放。这样就可以避免double free</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *p &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span>()&#123; p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">4</span>); &#125;</span><br><span class="line">        <span class="built_in">Test</span>(Test&amp; other) </span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">if</span>(p)  </span><br><span class="line">               <span class="keyword">delete</span> p;</span><br><span class="line">            p = other.p;        <span class="comment">// 浅拷贝</span></span><br><span class="line">            other.p = <span class="literal">nullptr</span>;  <span class="comment">// 浅拷贝后将拷贝对象指针成员置为NULL</span></span><br><span class="line">        &#125; </span><br><span class="line">        ~<span class="built_in">Test</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p) <span class="comment">// p不空，析构函数进行判断</span></span><br><span class="line">            &#123;       </span><br><span class="line">                <span class="keyword">delete</span> p;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Test ob1;</span><br><span class="line">   Test ob2 = ob1; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一方面，<strong>这里<code>ob2</code> 直接使用了<code>ob1</code> 的空间（ob2.p指向的是ob1.p原来的空间），不就大大地降低内存分配成本吗</strong>？</p><p>这也就是移动构造函数的初衷：</p><ul><li>对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以<u>将其包含的指针成员指向的内存资源直接移给新对象所有</u>，无需再新拷贝一份，这大大提高了初始化的执行效率。</li></ul><p>上面的拷贝构造函数已经可以称为是移动构造函数。</p><p>但这种方式也有局限性：</p><ol><li>仅限于一个对象被复制后不再被使用的场景，比如这里<code>ob1</code>，因为<code>ob1.p</code>指向内存已经被置为NULL，也就是说<strong>我们希望接受的引用对象是一个右值（右值在表达式中产生，运算结束后立即消失，有着“阅后即焚”的特性</strong>）。</li><li>但构造函数参数无法声明为<code>const Test&amp; other</code> ，虽然可以接受右值引用了（非const引用必须用左值初始化），但<code>other.p = nullptr</code>  修改会编译出错。</li></ol><p>有没有办法，<strong>让移动构造函数参数能接受右值引用，又能进行修改，最好是只接受右值引用</strong>？</p><p>这个时候右值引用和<code>std::move</code> 便派上了用处。</p><h5 id="右值引用和std-move">右值引用和<code>std::move</code></h5><p>请看下例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *p&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span>()&#123;p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">4</span>);&#125;</span><br><span class="line">        <span class="built_in">Test</span>(Test&amp; other) </span><br><span class="line">        &#123;    </span><br><span class="line">            cout&lt;&lt; <span class="string">&quot;复制构造函数（浅拷贝）&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(p)</span><br><span class="line">                <span class="keyword">delete</span> p;</span><br><span class="line">            p = other.p;         <span class="comment">// 浅拷贝</span></span><br><span class="line">            other.p = <span class="literal">nullptr</span>;   <span class="comment">// 置为null</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">Test</span>(Test&amp;&amp; other) <span class="comment">// 使用右值引用</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt; <span class="string">&quot;移动构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(p)</span><br><span class="line">                <span class="keyword">delete</span> p;</span><br><span class="line">            p = other.p;         <span class="comment">// 浅拷贝</span></span><br><span class="line">            other.p = <span class="literal">nullptr</span>;   <span class="comment">// 置为null</span></span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Test</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p) <span class="comment">// p不空</span></span><br><span class="line">            &#123;       </span><br><span class="line">                <span class="keyword">delete</span> p;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Test ob1;</span><br><span class="line">   Test ob2 = std::<span class="built_in">move</span>(ob1); <span class="comment">// 构造函数参数接受右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">移动构造函数</span><br></pre></td></tr></table></figure><p>可以看到移动构造函数和我们之前实现的复制构造函数（浅拷贝）基本一致。除了：</p><ol><li><p>声明时，<code>Test(Test&amp;&amp; other)</code> 的<code>&amp;&amp;</code> ，<code>&amp;&amp;</code> 表示<u>右值引用</u>，表示参数只接收右值；</p><p>在本例中，如果你尝试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Test ob1;</span><br><span class="line">   Test ob2 = ob1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">复制构造函数（浅拷贝）</span><br></pre></td></tr></table></figure><p>因为<code>ob1</code> 是右值，不会执行移动构造函数。</p><p>其它例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; pb = a;  <span class="comment">// error，只能接受右值，a是左值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; pc = <span class="number">2</span>;  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></li><li><p>使用时，<code>Test ob2 = std::move(ob1)</code> 的<code>std::move</code> ，<code>std::move</code>表示将一个左值转换为右值。</p><p>这里是将<code>ob1</code> 转换为右值。上个例子中也可以进行转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; pb = std::<span class="built_in">move</span>(a);  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p><code>std::move</code> 实际只是个类型转换器，实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 显示类型转换，类型T转换为type</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是<code>std::move</code>  可以理解为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; pb = std::<span class="built_in">move</span>(a);</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; pb = (<span class="keyword">int</span>&amp;&amp;)a;</span><br></pre></td></tr></table></figure><p><strong><code>std::move</code>  单独出现没有意义，它只将左值对象转换为右值，表明这个原本的左值对象不会再被需要或使用。它本身不会对对象做任何事，具体的移动工作由外面以右值为形参的重载函数进行</strong>。</p><p>一句话总结：<code>std::move</code> 只进行了移动前的准备工作（返回一个右值），配合重载了右值为形参的函数对对象进行移动。</p><p>在上面的例子中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Test ob1;</span><br><span class="line">   Test ob2 = std::<span class="built_in">move</span>(ob1); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>std::move(ob1)</code> 将对象<code>ob1</code> 转换为右值或者说将亡值，为转移对象<code>ob1</code>所有权做准备；</p></li><li><p>然后匹配了重载了右值引用的移动构造函数，由移动构造函数完成“移动”这个动作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = other.p;         <span class="comment">// 浅拷贝</span></span><br><span class="line">other.p = <span class="literal">nullptr</span>;   <span class="comment">// 置为null</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>更深刻理解<code>std::move</code> 除了返回一个右值，没有对对象进行其它操作</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp;&amp; p_a = std::<span class="built_in">move</span>(a);</span><br><span class="line">    a++;  <span class="comment">// a照常使用</span></span><br><span class="line">    std::cout&lt;&lt;a&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::move</code>没有修改<code>a</code> 本身，只是提示这是个可移动的对象，需要自己调用有右值的重载函数，才会进行移动（函数内部实现了“移动”这个动作）。</p></li></ol><p>总的来说移动构造函数有以下好处：</p><ul><li>充分利用临时对象内存，避免了空间浪费；</li></ul><p>但一切都建立在使用临时对象进行初始化这个场景下。</p><p><strong><code>std::move(ob1)</code>还可以扩展到其它以右值引用为形参移动语义函数中，最常见是在STL中，STL类大都支持移动语义函数</strong>。</p><p>例如，<code>std::vector</code>方法定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><p>显然<code>void push_back (value_type&amp;&amp; val);</code> 可以接受移动语义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;royhuang&quot;</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; vec;</span><br><span class="line">     </span><br><span class="line">    vec.<span class="built_in">push_back</span>(str1); <span class="comment">// 传统方法，copy</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str1)); <span class="comment">// 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，这种做法减少了开辟内存开销。</p><p><code>emplace_back</code>类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vec.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(str1)); <span class="comment">// emplace_back效果相同，str1会失去原有值</span></span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="string">&quot;axcsddcas&quot;</span>);     <span class="comment">// 当然可以直接接右值</span></span><br></pre></td></tr></table></figure><p>再次强调，移动语义函数也是建立在被拷贝对象再拷贝后就不再被需要的场景下，比如这里的<code>str1</code>视为“将亡值”。</p><h4 id="5-2-5-委托构造函数">5.2.5 委托构造函数</h4><p>构造函数重载时，允许一个构造函数调用其它构造函数，这个过程称为<strong>委托构造函数</strong> 。</p><p>为什么要这么设计？</p><p><strong>因为C++中不能在构造函数中调用其它构造函数，也就是不能进行构造函数嵌套</strong> 。</p><p>下面便是一个错误的示范，猜猜输出结果是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>()&#123; Point&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;&#125;;  <span class="comment">// 调用其它构造函数</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y): <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123;  &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt;endl; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point p1&#123;&#125;;</span><br><span class="line">    p1.<span class="built_in">show</span>();      <span class="comment">// 是 x=0，y=0吗？</span></span><br><span class="line">    Point p2&#123;<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">// 是 x=2，y=3吗？</span></span><br><span class="line">    p2.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果可能会让你有点意外：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = -1847177920, y = 32765</span><br><span class="line">x = 2, y = 3</span><br></pre></td></tr></table></figure><p>好家伙<code>x = -1847177920, y = 32765</code>是什么鬼？Point{0, 0}没有初始化p1吗？</p><p>回到案发现场：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point p1;</span><br></pre></td></tr></table></figure><p>我们知道在C++中定义一个对象：</p><ol><li>要先分配内存（此时，非静态成员还未初始化）；</li><li>再调用构造函数（初始化非静态成员）。</li></ol><p>对于<code>Point p1</code> ：</p><ol><li>编译器给对象<code>p1</code> 分配了内存；</li><li>调用构造函数<code>Point()</code> 初始化，进入函数体开始执行构造函数<code>Point(int,int)</code> ；</li><li><u>执行构造函数<code>Point(int,int)</code>时，编译器又创建了临时匿名对象</u>；</li><li>此时再调用<code>Point(int,int)</code> 初始化匿名对象非静态成员x=0，y=0，而不是对象<code>p1</code>；</li><li>所以最终对象<code>p1</code> 的x、y没有被初始化为{0,0}。</li></ol><p>也就是构造函数发生嵌套时，不会初始化当前对象而是初始化新生成的匿名对象。</p><p><strong>整个过程比较难理解的是第3点：为什么执行构造函数，编译器创建了临时对象，构造函数不是不会创建对象吗</strong>？</p><p>构造函数虽然不创建对象，但是在构造函数<u>执行前</u>，编译器会分配一个匿名对象空间，构造函数确实只是负责将其初始化了。</p><p>是的，C++就是这么魔鬼。</p><p><strong>不过，C++大魔王大慈大悲允许你使用委托构造函数方式进行构造函数嵌套</strong>。</p><p>赶紧带着感恩的心瞧一下吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(): Point&#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#123;&#125;;  <span class="comment">// 委托构造方式</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y): <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123;  &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt;endl; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>偷偷再告诉你两种不太优雅的方式做到类似构造函数嵌套的效果</strong>。</p><ul><li><p>把构造函数中的公共部分抽取出来定义一个成员函数(最好修饰为private)，然后在每个需要这个代码的构造函数中调用该函数即可。</p></li><li><p>使用placement new。因为placement new不会重新分配内存，其定义也证明了这一点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> *__cdecl <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span> *_P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (_P);  <span class="comment">// 没有分配新的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样调用构造函数<code>Point(int,int)</code> 时不会创建临时对象，而是依旧在对象<code>p1</code>内存中执行初始化操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Point</span>()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">new</span> (<span class="keyword">this</span>)Point&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">Point p1;</span><br><span class="line">p1.<span class="built_in">show</span>(); <span class="comment">// x=0，y=0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-3-析构函数">5.3 析构函数</h3><h4 id="什么是析构函数？">什么是析构函数？</h4><p><strong>析构函数</strong>是另一种特殊的类成员函数，在该类的对象被销毁时执行，帮助类清理对象。</p><p>和构造函数一样，析构函数没有参数、返回类型，与类同名。</p><p><strong>析构函数什么时候执行</strong>？</p><ul><li><p>当一个栈上分配的对象正常超出范围，注意区分堆上分配的对象不会自动释放，需要手动；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class Test</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tets t1;   <span class="comment">// 此时t1在栈上，超出作用范围会自动释放</span></span><br><span class="line">Test* t2 = <span class="keyword">new</span> Test&#123;&#125;; <span class="comment">// 此时t2指向的对象分配在堆上</span></span><br></pre></td></tr></table></figure></li><li><p>delete 关键字显式删除动态分配的对象。</p></li></ul><p><strong>类一定需要析构函数吗</strong>？</p><ul><li>如果只是包含普通成员变量的值，不需要析构函数；</li><li>如果是类对象持有动态内存、文件或数据库句柄，需要析构函数。</li></ul><p>例如，下面<u>数组</u>指针<code>m_array</code> 需要显示定义析构函数进行清理，否则会发生内存泄漏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span>* m_array&#123;&#125;;  <span class="comment">// m_array持有动态内存</span></span><br><span class="line"><span class="keyword">int</span> m_length&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">IntArray</span>(<span class="keyword">int</span> length) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(length &gt; <span class="number">0</span>);</span><br><span class="line">m_array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">static_cast</span>&lt;std::<span class="keyword">size_t</span>&gt;(length)]&#123;&#125;;</span><br><span class="line">m_length = length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">IntArray</span>() <span class="comment">// 析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~IntArray&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span>[] m_array;  <span class="comment">// 清理m_array持有的动态内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123; m_array[index] = value; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123; <span class="keyword">return</span> m_array[index]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IntArray arr &#123;<span class="number">10</span>&#125;;  <span class="comment">// 直接初始化，arr分配在栈上</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; arr.<span class="built_in">getLength</span>(); ++count)</span><br><span class="line">arr.<span class="built_in">setValue</span>(count, count+<span class="number">1</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The value of element 5 is: &quot;</span> &lt;&lt; arr.<span class="built_in">getValue</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 析构函数~IntArray执行</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The value of element 5 is:  6</span><br><span class="line">~IntArray</span><br></pre></td></tr></table></figure><h4 id="RAII">RAII</h4><p>RAII（资源获取即初始化）是一种编程技术，其中资源使用与具有自动生命周期的对象（例如非动态分配的对象）的生命周期相关联。在 C++ 中，RAII 是通过具有构造函数和析构函数的类来实现的。</p><p><strong>RAII 的主要优点是它有助于防止资源泄漏</strong>（例如内存未被释放），因为所有资源持有对象都会自动清理。</p><ul><li>资源（内存、文件或数据库句柄等）在<u>对象的构造函数中获取</u>，在对象处于活动状态时使用该资源。</li><li>当对象被销毁时，资源在<u>析构函数中被释放</u>。</li></ul><p>前例中的<code>m_array</code>持有的动态内存就是RAII一个很好的例子——在构造函数中分配，在析构函数中释放。</p><p>在标准库中，<code>std::string</code> 和 <code>std::vector</code>同样遵循RAII——动态内存在初始化时获取，并在销毁时自动清理。</p><h3 id="5-4-友元函数和友元类">5.4 友元函数和友元类</h3><p>我们一直努力尽量宣扬类数据保密（private）的好处。</p><p><strong>但是，如果有类A和类B联系的非常紧密，类B对象确实需要用到类A对象的私有成员，这怎么办</strong>？</p><p>（这种情况通常发生于重载运算符时，此时两个类通常联系得很紧密，其它情况确实不常见。）</p><ul><li>将类A的私有成员公开（public）？显然不行，这样别的类对象也可以访问A的私有成员；</li><li>在类A专门设置接口函数获取私有成员值？也不行，道理同上。</li></ul><p>如果能指定<u>只能</u>类B访问类A的私有成员该多好啊！</p><h4 id="5-4-1-友元函数">5.4.1 友元函数</h4><p><strong>友元函数就做了这么一件事：指定某个普通函数或某个类的成员函数为本类的友元函数，由此可以使用本类的私有成员</strong>。</p><p>虽然这破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。但在某些场景下确实很有用。</p><p>举例说明普通函数/成员函数作为友元函数。</p><h5 id="普通函数作为友元函数">普通函数作为友元函数</h5><p>注意：友元函数虽然声明在类中，但并不属于当前类成员。</p><p>下面这个例子展示了，在类<code>Accumulator</code> 把函数<code>reset</code> 作为友元函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accumulator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部函数reset作为友元函数</span></span><br><span class="line">    <span class="comment">// 友元函数声明在类外，Accumulator对象作为参数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(Accumulator&amp; accumulator)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数reset定义在类外</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(Accumulator&amp; accumulator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 现在reset可以使用类Accumulator对象的私有成员</span></span><br><span class="line">    accumulator.m_value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Accumulator acc;</span><br><span class="line">    <span class="built_in">reset</span>(acc); <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意，我们必须将 Accumulator 对象acc传递给 reset()</strong>。</p><p>因为友元函数reset() <u>不是类的成员</u>，没有 <code>*this</code> 指针，也没有可供使用的 Accumulator 对象，因此必须给定一个。</p><p><strong>一个函数还可以同时是多个类的友元函数，但是每个类中都要声明这个函数</strong>。</p><p>下面外部函数<code>printWeather</code> 同时是类<code>Humidity</code> 和 <code>Temperature</code> 的友元函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Humidity</span>;</span>  <span class="comment">// 前向声明，否则代码14行处无法找到定义</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temperature</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_temp &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Temperature</span>(<span class="keyword">int</span> temp=<span class="number">0</span>): m_temp &#123; temp &#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">// 声明1：是类Temperature的友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printWeather</span><span class="params">(<span class="keyword">const</span> Temperature&amp; temperature, <span class="keyword">const</span> Humidity&amp; humidity)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Humidity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_humidity &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Humidity</span>(<span class="keyword">int</span> humidity=<span class="number">0</span>): m_humidity &#123; humidity &#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">// 声明2：是类Humidity的友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printWeather</span><span class="params">(<span class="keyword">const</span> Temperature&amp; temperature, <span class="keyword">const</span> Humidity&amp; humidity)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数printWeather</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printWeather</span><span class="params">(<span class="keyword">const</span> Temperature&amp; temperature, <span class="keyword">const</span> Humidity&amp; humidity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The temperature is &quot;</span> &lt;&lt; temperature.m_temp &lt;&lt;</span><br><span class="line">       <span class="string">&quot; and the humidity is &quot;</span> &lt;&lt; humidity.m_humidity &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Humidity <span class="title">hum</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Temperature <span class="title">temp</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printWeather</span>(temp, hum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="成员函数作为友元函数">成员函数作为友元函数</h5><p>与使普通函数成为朋友类似，也可以让类成员函数作为友元函数。</p><p>下面是一个实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Humidity</span>;</span>  <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temperature</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_temp &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Temperature</span>(<span class="keyword">int</span> temp=<span class="number">0</span>): m_temp &#123; temp &#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">// 这里不需要Humidity完整定义，前面前向声明就可以。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printHumidity</span><span class="params">(<span class="keyword">const</span> Humidity&amp; Humidity)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;The Humidity is &quot;</span> &lt;&lt; Humidity.m_humidity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Humidity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_humidity &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Humidity</span>(<span class="keyword">int</span> humidity=<span class="number">0</span>): m_humidity &#123; humidity &#125;&#123;&#125;</span><br><span class="line">    <span class="comment">// Humidity的友元函数是Temperature类中的printHumidity函数</span></span><br><span class="line">    <span class="comment">// 注意，类Temperature一定要在前，因为编译器需要友元函数类Temperature完整定义</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> Temperature:: <span class="built_in">printHumidity</span> (<span class="keyword">const</span> Humidity&amp; Humidity);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-4-2-友元类">5.4.2 友元类</h4><p>也可以让整个类成为另一个类的朋友，这样友元类的所有成员都可以访问类的私有成员。</p><p>一个简单实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_nValue &#123;&#125;;</span><br><span class="line">    <span class="keyword">double</span> m_dValue &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Storage</span>(<span class="keyword">int</span> nValue, <span class="keyword">double</span> dValue): m_nValue &#123; nValue &#125;, m_dValue &#123; dValue &#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">// Display是本类（Storage）的友元类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Display</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Display</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_displayIntFirst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Display</span>(<span class="keyword">bool</span> displayIntFirst): m_displayIntFirst &#123; displayIntFirst &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayItem</span><span class="params">(<span class="keyword">const</span> Storage&amp; storage)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Display可以使用Storage的私有成员</span></span><br><span class="line">        <span class="keyword">if</span> (m_displayIntFirst)</span><br><span class="line">            std::cout &lt;&lt; storage.m_nValue &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; storage.m_dValue &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            std::cout &lt;&lt; storage.m_dValue &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; storage.m_nValue &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Storage <span class="title">storage</span><span class="params">(<span class="number">5</span>, <span class="number">6.7</span>)</span></span>;</span><br><span class="line">    <span class="function">Display <span class="title">display</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    display.<span class="built_in">displayItem</span>(storage); <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-隐藏的this指针">5.5 隐藏的this指针</h3><h4 id="5-5-1-快速回忆">5.5.1 快速回忆</h4><p>在<u>2.1.4</u>节，我们说过，<strong>每个类都有个隐藏的<code>this</code>指针</strong>。</p><p>快速回忆下：</p><ul><li>编译器隐式为每个数据成员加上<code>this</code> 指针；</li><li>编译器隐式为每个函数显示加上了第一个参数<code>Simple* const this</code> 。</li></ul><p>为方便理解，下面代码<u>注释</u>显示指示了<code>this</code>指针的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Simple</span>(<span class="keyword">int</span> id): m_id&#123; id &#125;</span><br><span class="line">    <span class="comment">// Simple(Simple* const this,int id): this-&gt;m_id&#123; id &#125; </span></span><br><span class="line">    &#123;      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; m_id = id; &#125;</span><br><span class="line">    <span class="comment">//  void setID(Simple* const this,int id) &#123; this-&gt;m_id = id; &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Simple simple&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    simple.<span class="built_in">setID</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// simple.setID(&amp;simple,2);</span></span><br><span class="line">    std::cout &lt;&lt; simple.<span class="built_in">getID</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码22行处，也可以知道：<strong><code>this</code>指针就是指向当前对象</strong><code>simple</code> 。</p><p>大部分时候，我们都可以假装不知道this指针的存在，但在链接成员时this指针表现得很有用。</p><h4 id="5-5-2-this指针链接成员函数">5.5.2 this指针链接成员函数</h4><p>思考一下：经常使用的<code>std::cout</code>是如何实现连续打印多个字符串？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello &quot;</span> &lt;&lt; <span class="string">&quot;World&quot;</span>;</span><br></pre></td></tr></table></figure><p>此时，std::cout 是一个对象，而 operator&lt;&lt; 是对该对象进行操作的成员函数：</p><ul><li>operator&lt;&lt; 打印第一个字符串&quot;Hello &quot;，然后返回当前对象，也就是<code>*this</code>；</li><li>std::cout 对象 <code>*this</code> 调用operator&lt;&lt; 打印第二个字符串&quot;World&quot;。</li></ul><p>举一个更具体的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Calc&amp; <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value += value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function">Calc&amp; <span class="title">sub</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value -= value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function">Calc&amp; <span class="title">mul</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value *= value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calc calc&#123;&#125;;</span><br><span class="line">    calc.<span class="built_in">add</span>(<span class="number">5</span>).<span class="built_in">sub</span>(<span class="number">3</span>).<span class="built_in">mul</span>(<span class="number">4</span>);   <span class="comment">// 函数链接起来了</span></span><br><span class="line">    std::cout &lt;&lt; calc.<span class="built_in">getValue</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法在<u>类重载运算符</u>时最常使用，下章一起来学习下吧。</p><h2 id="更新记录">更新记录</h2><div class="timeline"><div class="timenode"><div class="meta"><p><p>2022-02-02：更新笔记</p></p></div><div class="body"><ol><li>修改std::move相关描述</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2022-01-29：更新笔记</p></p></div><div class="body"><ol><li>修改成员列表初始化相关描述</li><li>增加移动构造函数相关描述</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2022-01-28：更新笔记</p></p></div><div class="body"><ol><li>修改复制初始化相关描述</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2022-01-27：更新笔记</p></p></div><div class="body"><ol><li>第一次更新</li></ol></div></div></div><h2 id="参考资料">参考资料</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++构造函数的理解 : https://www.cnblogs.com/downey-blog/p/10470782.html<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">禁止拷贝构造，禁止bug：https://zhuanlan.zhihu.com/p/266353611<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">为什么使用初始化列表会快一些？https://segmentfault.com/a/1190000039294789<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++11右值引用和移动构造函数详解 ：https://zhuanlan.zhihu.com/p/365412262<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++中的std::move函数到底是做什么的？https://www.zhihu.com/question/467449795<a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
          <category> C++面对对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 教程 </tag>
            
            <tag> 快速入门 </tag>
            
            <tag> 面对对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++从零开始（六）：务实基础（下）复合类型及转换</title>
      <link href="/p/6587/"/>
      <url>/p/6587/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，开始更新中…</p></blockquote><div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div><h2 id="四、复合类型及转换">四、复合类型及转换</h2><p><strong>什么是复合类型？这听起来好像是有点新奇的概念</strong>。</p><p><u>从基本数据类型（比如<code>int</code>、<code>char</code>）或其他复合数据类型构造出来</u>的数据类型，就称为复合类型。</p><p>在前面我们已经接触过所谓的复合类型：</p><ul><li><p>数组（<code>std::string</code>、<code>std::array</code> 等）、指针类型（函数指针或者说函数，指向对象的指针等）、引用类型。</p></li><li><p>举个例子，下面函数<code>func</code> 类型是<code>void()(int, double)</code> ，它由基本类型组成，使其成为复合类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>本章主要介绍的复合类型是结构体（注意结构体大小计算）和枚举（注意枚举作用范围问题），以及各种类型之间的转换：</p><ul><li>用户隐式转换及发生的情况；</li><li>用户四种显示转换，包含C风格和C++风格；</li><li>t特别补充，string类型和其它类型之间的转换。</li></ul><h3 id="4-1-结构体">4.1 结构体</h3><h4 id="4-1-1-从C谈起">4.1.1 从C谈起</h4><p>在C语言中定义一个典型结构体<code>struct</code>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> gender[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;; <span class="comment">// *这里有个分号，易遗漏</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 2.声明&amp;初始化，结合&#123;&#125;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">People</span> <span class="title">people</span> =</span> &#123;<span class="string">&quot;royhuang&quot;</span>,<span class="string">&quot;male&quot;</span>,<span class="number">25</span>&#125;; </span><br><span class="line">    <span class="comment">// 3.访问，C/C++中结构体成员默认都是public可以直接访问</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;your name: %s \n&quot;</span>,people.name); <span class="comment">// royhuang</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时还是新手C玩家的我，很难说出<code>struct</code>到底带来什么好处。只能隐隐约约感觉到，<code>struct</code>组合<u>多个</u>且有<u>逻辑关联</u>的数据<u>增强了程序逻辑性和可读性</u>。</p><p><strong>那么<code>struct</code> 除了组织有逻辑关联的数据提高代码可读性和一致性，在实际编码中还有其它应用吗</strong>？</p><p>在第三章函数，我们提到过：结构体还可用于<u>函数传递多个参数</u>或者<u>函数返回多个值</u>。</p><ul><li><p><strong>传递多个参数</strong></p><p>传递一个结构体作为参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPeople</span><span class="params">(<span class="keyword">const</span> struct People&amp; people)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;your name: %s \n&quot;</span>,people.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;your gender: %s \n&quot;</span>,people.gender);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;your age: %d \n&quot;</span>,people.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">People</span> <span class="title">people</span> =</span> &#123;<span class="string">&quot;royhuang&quot;</span>,<span class="string">&quot;male&quot;</span>,<span class="number">25</span>&#125;;</span><br><span class="line">    <span class="built_in">printPeople</span>(people);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这相比传递多个参数要清爽很多（且不易出错）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPeople</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* gender, <span class="keyword">const</span> <span class="keyword">int</span> age)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>返回多个值</strong></p><p>函数只能返回一个参数，除了使用元组，结构体是不二的选择：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct People&amp; <span class="title">cleanPeople</span><span class="params">(People&amp; people)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    people.name=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    people.gender=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    people.age=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> people;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-1-2-C-中struct">4.1.2 C++中struct</h4><p>C++中struct兼容了C，在此基础上还进行了扩展：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">C</th><th style="text-align:center">C++</th></tr></thead><tbody><tr><td style="text-align:center">成员</td><td style="text-align:center">只有数据</td><td style="text-align:center">数据，函数等都可以</td></tr><tr><td style="text-align:center">访问权限</td><td style="text-align:center">public</td><td style="text-align:center">默认public，有private</td></tr><tr><td style="text-align:center">是否可以继承</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr></tbody></table><ol><li><p>在C中结构体声明必须带上<code>struct</code> 关键字，而C++中可以直接使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> <span class="title">people1</span>;</span> <span class="comment">// C</span></span><br><span class="line">People people1; <span class="comment">// C++</span></span><br></pre></td></tr></table></figure></li><li><p>C++中，struct增加了private访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了兼容C）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> gender[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">People</span>(<span class="keyword">const</span> <span class="keyword">char</span>* peole_name,<span class="keyword">const</span> <span class="keyword">char</span>* peole_gender,<span class="keyword">int</span> peole_age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(name,peole_name,<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(gender,peole_gender,<span class="number">5</span>);</span><br><span class="line">        age = peole_age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printPeople</span><span class="params">(<span class="keyword">const</span> People&amp; people)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;your name:&quot;</span> &lt;&lt;people.name&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;your gender: &quot;</span>&lt;&lt;people.gender&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;your age: &quot;</span>&lt;&lt;people.age&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有变量</span></span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="keyword">char</span> girl_friend[<span class="number">10</span>];</span><br><span class="line">&#125;; <span class="comment">// 分号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    People people = &#123;<span class="string">&quot;royhuang&quot;</span>,<span class="string">&quot;male&quot;</span>,<span class="number">25</span>&#125;;</span><br><span class="line">    people.<span class="built_in">printPeople</span>(people);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以继承，实现了多态。</p></li></ol><p>显然，C++中struct和class区别已经不大。</p><h4 id="4-1-3-结构体大小和比较">4.1.3 结构体大小和比较</h4><blockquote><p>参考：<a href="https://blog.csdn.net/liuweiyuxiang/article/details/85997084">c++中的sizeof()运算符</a>、<a href="https://caohuilong.github.io/2019/03/12/C-%E4%B8%ADsizeof%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/">C/C++中 sizeof 的用法总结</a></p></blockquote><p><strong>从基本数据类型说起</strong>。</p><p>对于short、int、long简单内置数据类型，可采用<code>sizeof</code> 关键字计算大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;  </span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>); <span class="comment">// 值为4  </span></span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(i);   <span class="comment">// 值为4，等价于sizeof(int)  </span></span><br><span class="line"><span class="keyword">sizeof</span> i;    <span class="comment">// 值为4  </span></span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(<span class="number">2</span>);   <span class="comment">// 值为4，等价于sizeof(int)，因为2的类型为int  </span></span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(<span class="number">2</span> + <span class="number">3.14</span>); <span class="comment">// 值为8，等价于sizeof(double)，因为此表达式的结果的类型为double  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ary[<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * <span class="number">10</span>]; <span class="comment">// OK，编译无误</span></span><br></pre></td></tr></table></figure><blockquote><p>题外话：<strong>sizeof和strlen的区别</strong>？</p><ul><li><strong>运算符与函数</strong>：sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</li><li><strong>参数类型</strong>：sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；<u>strlen的参数只能是字符指针且结尾是’\0’的字符串</u>。</li><li><strong>值确定时机</strong>：sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in"><span class="keyword">sizeof</span></span>(str); <span class="comment">// 取的是指针str的长度，是8</span></span><br><span class="line">      <span class="built_in">strlen</span>(str); <span class="comment">// 取的是这个字符串的长度，不包含结尾的 \0。大小是4</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></blockquote><p>注意，<strong>基本数据类型的内存大小是和系统相关的</strong>，所以在不同的系统下取值可能不同。比如，</p><ul><li><code>long</code> 类型与指针类型在 32 位机器上只占 4 字节，在 64 位机器上占 8 字节；</li><li><code>int</code>在32位/64位都占4字节。</li></ul><p>本节均假设<strong>按64位机器考虑</strong>。</p><h5 id="sizeof-计算结构体大小">sizeof 计算结构体大小</h5><p>结构体的sizeof为了提高存取效率，涉及到字节<strong>对齐</strong>问题。</p><p>其对齐规则如下:</p><ol><li><strong>顺序存储</strong>：分配内存的顺序是按照声明的顺序进行<strong>顺序存储</strong>；</li><li><strong>偏移量</strong>：每个变量相对于起始位置的偏移量，必须是<strong>该变量类型大小的整数倍</strong>，不是整数倍空出内存，直到偏移量是整数倍为止；</li><li><strong>整体大小</strong>：最后整个结构体的大小必须是，<strong>变量类型最大值的整数倍</strong>。</li></ol><p>以下实例说明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(A) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：24，而不是1+8+4=13。这是因为 ：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211223175820728.png" alt="image-20211223175820728"></p><ol><li>char a 的偏移量为 0，占用 1Byte；</li><li>double b 指的下一个可用的地址的偏移量为 1，不是 sizeof(double)=8 的整数倍，需要补足 7Byte 才能是偏移量为 8；</li><li>int c 指的下一个可用的地址的偏移量为 16，是 sizeof(int)=4 的整数倍，满足 int 的对齐方式；</li><li>结构体大小必须是最大成员大小的整数倍，（即结构中占用最大空间的类型所占用的字节数 sizeof(double)=8）的倍数，所以最后还需填充4byte。</li></ol><p><strong>嵌套结构体和unio共用体对齐规则又有所不同</strong>。</p><ul><li><p><strong>嵌套结构体</strong></p><p>对于嵌套的结构体，需要将其展开。对嵌套结构体求 sizeof 时，上述原则变为：</p><ol><li>展开后的结构体的第一个成员的<strong>偏移量</strong>应当是被展开的结构体中<strong>最大</strong>（非嵌套不要求最大）的成员的整数倍。</li><li>结构体大小必须是<strong>最大成员大小的整数倍</strong>，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">    &#125; ss;</span><br><span class="line">    <span class="keyword">short</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(B) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码输出：16。分析过程同前，这里只给出图示。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211223180812242.png" alt="image-20211223180812242"></p></li><li><p><strong>Unio共用体</strong></p><p>union 中变量共用内存，原则如下：</p><ol><li>内存大小应以最长的为准；</li><li>满足上述条件下，还应是最长成员的整数倍大小。</li></ol><p>例如，下面例子输出共用体大小为：<strong>24</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];  <span class="comment">// 数组大小=成员*长度=5*4=20</span></span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 最后输出补足4byte，满足是double(8字节)整数倍</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(C) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别的，请思考：</p><ul><li><strong>将共用体内的 int a[5] 修改成 int a[6] 后，结果仍然不变；但如果将 int a[5] 修改成 int a[7]，结果就变成 32</strong>？</li></ul><p>你可在评论区写下你的见解。</p></li></ul><h5 id="扩展：sizeof计算类对象大小">扩展：sizeof计算类对象大小</h5><p>关于类占用的内存空间，有以下几点需要注意：</p><ol><li><p><strong>虚函数</strong>：编译器需要为类构建虚函数表，类<strong>中需要存储一个指针</strong>指向这个虚函数表的首地址。</p><p><strong>注意不管有几个虚函数，都只建立一张表</strong>，所有的虚函数地址都存在这张表里，类中只需要一个指针指向虚函数表首地址即可。</p></li><li><p><strong>静态成员</strong>：被类所有实例所共享的，它<strong>不计入</strong>sizeof计算的空间。</p></li><li><p><strong>普通函数或静态函数</strong>：都存储在栈中，不计入sizeof计算的空间。</p></li><li><p><strong>类成员</strong>：采用字节对齐的方式分配空间；</p></li></ol><p>以下为实例说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 虚函数：需要一个指针指向虚函数表</span></span><br><span class="line">        <span class="comment">// 32位系统指针大小为 4Byte，64位系统指针大小为 8Byte</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funa</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funb</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 普通函数或静态函数或静态成员：不计入</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fund</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> si; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// char占1字节</span></span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="comment">// int首先要偏移3字节，是sizeof(int)整数倍</span></span><br><span class="line">        <span class="comment">// int本身占4字节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 最后总大小为：指针大小+1+3+4 = 12 OR 16</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(D) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上输出为：12（32位系统）或者16（64位系统）。具体占用请查看代码中注释。</p><p><strong>类成员对齐方式和结构体有所不同</strong>，未尽细节将在未来补充。</p><h5 id="空类-结构体大小">空类/结构体大小</h5><blockquote><p>思考源自于：<a href="https://www.zhihu.com/question/266041176">空类的大小为什么是1？</a></p></blockquote><p>经过实践，无论是空类还是空结构体，其大小<strong>均为1而不是0</strong>。</p><p>看了一下比较信服的解答是：</p><ul><li><p>如果长度是0，那么把他塞给一个指针，指针指到哪里呢？不考虑指针，这个类自己存在哪里呢？如果我一下子申明100万个实例，都不占用内存吗？</p></li><li><p>c++ 中规定<strong>不同的对象必须拥有不同的地址</strong>，如果为0会导致两个空类的地址一样。</p><blockquote><p>但是为啥空类一定要有不同的地址来去区分不同的对象？</p></blockquote></li></ul><h5 id="结构体比较">结构体比较</h5><p>C++结构体直接进行比较会出错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="keyword">char</span>* c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;h&#x27;</span>&#125;&#125;;</span><br><span class="line">    A b&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;h&#x27;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;equal&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;not equal&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# g++ -std=c++11 test.cpp -o test.out</span><br><span class="line">test.cpp: In function ‘int main()’:</span><br><span class="line">test.cpp:21:9: error: no match for ‘operator==’ (operand types are ‘A’ and ‘A’)</span><br><span class="line">     if(a==b)</span><br></pre></td></tr></table></figure><p>有两种办法解决这个问题：</p><ol><li><p>结构体 <code>a</code> 和 <code>b</code> 每个元素逐个比较，指针比较它们的地址。</p></li><li><p>自己重载操作符<code>==</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="keyword">char</span>* c;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> A&amp; other) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> a_is_equal = (a==other.a);</span><br><span class="line">        <span class="keyword">bool</span> b_is_equal = (b==other.b);</span><br><span class="line">        <span class="keyword">bool</span> c_is_equal = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">3</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i] != other.c[i])</span><br><span class="line">            &#123;</span><br><span class="line">                c_is_equal =<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a_is_equal &amp;&amp; b_is_equal &amp;&amp; c_is_equal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;h&#x27;</span>&#125;&#125;;</span><br><span class="line">    A b&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;h&#x27;</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;equal&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;not equal&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">equal</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-1-4-扩展阅读：为什么C-还保留struct？">4.1.4 扩展阅读：为什么C++还保留struct？</h4><p>在C++中，除了默认访问控制符、模板参数，struct和class基本完全一致，struct存在的意义是什么，全用class不好吗？</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">struct</th><th style="text-align:center">class</th></tr></thead><tbody><tr><td style="text-align:center">继承默认权限</td><td style="text-align:center">struct默认是public</td><td style="text-align:center">class默认是private</td></tr><tr><td style="text-align:center">模板参数</td><td style="text-align:center">不可以</td><td style="text-align:center">可以</td></tr></tbody></table><p>这里面的原因主要是：</p><ol><li><strong>历史包袱</strong>。给 C 语言程序开发人员有一个归属感；</li><li><strong>兼容</strong> 。让 C++ 编译器兼容以前用 C 语言开发出来的项目，比如系统库<code>stdlib.h</code> 等。</li></ol><h3 id="4-2-枚举">4.2 枚举</h3><h4 id="4-2-1-枚举初识">4.2.1 枚举初识</h4><p>和结构体类似，枚举也是组织了<u>有逻辑关系的数据</u>，不过枚举：</p><ul><li>数据只能是同类型（我们定义的枚举类型）；</li><li>相比struct/class，枚举enum更像是一种弱组织类型，如果你有一组相关的常量最好使用枚举。</li></ul><p>举个例子吧，用枚举组合三元色（常量）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>  // 最佳实践：首字母大写</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    red,</span><br><span class="line">    blue,</span><br><span class="line">    green,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Color paint = red;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比用0、1、2分别定义三元色，代码可读性提高了很多。</p><h5 id="枚举是整数符号常量">枚举是整数符号常量</h5><p><strong>枚举到底什么</strong>？</p><p>好吧，标题已经出卖了答案：<strong>枚举其实就是整数符号常量（默认是int</strong>）。</p><p>和<code>char</code> 情况有点类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><p>char 实际上存储的是一个 1 字节的整数值，即字符<code>'A'</code>被转换为整数值（在本例中为<code>65</code>）并存储。</p><p>只不过打印<code>cout</code>类对<code>&lt;&lt;</code>进行了重载，直接打印<code>c</code> 出来的是<code>'A'</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout&lt;&lt;c;  <span class="comment">// A</span></span><br></pre></td></tr></table></figure><p>回到枚举<code>enum</code> ：</p><ul><li>枚举会自动分配一个整数值。默认情况下，第一个枚举器被分配整数值<code>0</code>，每个后续枚举器的值都比前一个<code>+1</code>；</li><li>我们也可以自定义枚举值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    cat = <span class="number">-3</span>,</span><br><span class="line">    dog,         <span class="comment">// -2</span></span><br><span class="line">    pig,         <span class="comment">// -1</span></span><br><span class="line">    horse = <span class="number">5</span>,</span><br><span class="line">    giraffe,     <span class="comment">// 6</span></span><br><span class="line">    chicken      <span class="comment">// 7</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal animal = dog;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你的宠物是：&quot;</span> &lt;&lt; animal;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你的宠物是：-2</span><br></pre></td></tr></table></figure><p><strong>好吧你的宠物是<code>-2</code>，编译器隐式将枚举转换为了整数（并没有像char一样打印字符，std::cout没有对枚举类型Animal进行重载</strong>）。</p><p>不过，编译器不会将整数隐式转换为枚举数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="number">-2</span>;  <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>需要显式转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">static_cast</span>&lt;Animal&gt;(<span class="number">-2</span>);</span><br></pre></td></tr></table></figure><p>上面我们验证了enum的主要用法和特性，但可以更完美一点优雅打印枚举数吗，就像char一样？</p><h5 id="优雅打印枚举数">优雅打印枚举数</h5><p>怎么优雅打印枚举数？</p><p>C++中并没有提供相关函数。这只有我们自己来实现，<code>if-else</code>或<code>switch</code> 逐个判断是最容易想到的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> std::string <span class="title">printAnimal</span><span class="params">(Animal animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (animal)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> cat:   <span class="keyword">return</span> <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> dog:   <span class="keyword">return</span> <span class="string">&quot;dog&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> pig:   <span class="keyword">return</span> <span class="string">&quot;pig&quot;</span>;</span><br><span class="line">        <span class="comment">// 省略其它的判断</span></span><br><span class="line">        <span class="keyword">default</span>:    <span class="keyword">return</span> <span class="string">&quot;???&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这需要显式调用<code>printAnimal</code> 方法，看起来有点笨拙。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = dog;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;你的宠物是：&quot;</span> &lt;&lt; <span class="built_in">printAnimal</span>(animal);</span><br></pre></td></tr></table></figure><p><strong>直接重载<code>std::cout</code> 类运算符<code>&lt;&lt;</code>是更好的做法</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, Animal animal)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (animal)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> cat:   <span class="keyword">return</span> <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> dog:   <span class="keyword">return</span> <span class="string">&quot;dog&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> pig:   <span class="keyword">return</span> <span class="string">&quot;pig&quot;</span>;</span><br><span class="line">        <span class="comment">// 省略其它的判断</span></span><br><span class="line">        <span class="keyword">default</span>:    <span class="keyword">return</span> <span class="string">&quot;???&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以打印字符串看起来聪明了很多：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = dog;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;你的宠物是：&quot;</span> &lt;&lt; animal;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你的宠物是：dog</span><br></pre></td></tr></table></figure><h5 id="认识枚举作用域">认识枚举作用域</h5><p><strong>枚举内部数据和枚举具有同样的作用范围，也就是枚举对内部数据作用范围无限制</strong>。</p><p>回到最开始的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    red,</span><br><span class="line">    green,</span><br><span class="line">    blue, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 直接就使用了red</span></span><br><span class="line">    <span class="comment">// 也可以通过前缀Color::red</span></span><br><span class="line">    Color paint = red;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>red</code> 和 <code>enum Color</code> 作用域是一致的，都是全局类型。</p><p>这种设置，调用起来很方便，但是<strong>在两个不同枚举类定义相同的数据，会使得命令空间污染，导致编译错误</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    red,</span><br><span class="line">    green,</span><br><span class="line">    blue, <span class="comment">// blue 表示颜色</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Feeling</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    happy,</span><br><span class="line">    tired,</span><br><span class="line">    blue, <span class="comment">// blue表示心情</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果你再尝试调用，编译无法通过，两个<code>blue</code> 冲突：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color paint = blue; <span class="comment">//  error: redeclaration of ‘blue’</span></span><br></pre></td></tr></table></figure><p>虽然可以通过显式指定前缀避免错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color paint = Color::blue; </span><br></pre></td></tr></table></figure><p>但终归是埋下了隐患。</p><p><strong>更好的做法是使用命名空间<code>namespace</code> 限定范围，这样我们可以在不同枚举类定义相同的数据</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> color</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        red,</span><br><span class="line">        green,</span><br><span class="line">        blue,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> feeling</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Feeling</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        happy,</span><br><span class="line">        tired,</span><br><span class="line">        blue, </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 现在必须加上作用域区域的名称</span></span><br><span class="line">    color::Color paint  =  color::blue ;</span><br><span class="line">    feeling::Feeling me = feeling::blue ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="最佳实践">最佳实践</h5><p>使用枚举请显式指明枚举类型，比如<code>color::blue</code> 而非直接使用<code>blue</code>。</p><h4 id="4-2-2-范围枚举">4.2.2 范围枚举</h4><h5 id="为什么需要范围枚举？">为什么需要范围枚举？</h5><p>非范围枚举看起来很好，但会带来一些问题：</p><ul><li><strong>隐式转换的危害</strong>。非范围枚举会隐式地将枚举类型转换为整数类型，这有时候会造成一些意料之外的错误（比如不同枚举类型进行比较，下举例说明）；</li><li><strong>非强制要求前缀</strong>。这显然和我们刚刚提到的枚举最佳实践不符。</li></ul><p><strong>范围枚举</strong>的特性很好地解决了上述问题：</p><ul><li>范围枚举是<strong>强类型的</strong>（不会隐式转换为整数）和<strong>强作用域的</strong>（必须指定前缀）；</li><li>其余和非范围枚举没什么区别。</li></ul><h5 id="范围枚举初识">范围枚举初识</h5><p>范围枚举通过<code>enum class</code> 声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     red, </span><br><span class="line">     blue,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    banana, </span><br><span class="line">    apple,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先认识下范围枚举的<u>强作用域</u>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color c = red;  <span class="comment">// error，identifier &quot;red&quot; is undefined</span></span><br></pre></td></tr></table></figure><p>必须显式指定作用范围，契合了最佳实践：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color c = Color::red; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>再来认识范围枚举的<u>强类型</u>（不会隐式转换）。</p><ol><li><p>无法直接打印</p><p>因为范围枚举不会隐式转换为<code>int</code> ，<code>std::cout</code> 无法直接打印。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; Fruit::banana;</span><br></pre></td></tr></table></figure><p>除非你显式进行转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(Fruit::banana);</span><br></pre></td></tr></table></figure></li><li><p>不能直接比较两个不同枚举类型</p><p>下面代码编译能通过吗？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Color color = Color::red ; </span><br><span class="line">    Fruit fruit = Fruit::banana ; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (color == fruit) </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;color和fruit相等\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;color和fruit不相等\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是无范围枚举上述代码不会编译出错，甚至会打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color和fruit相等</span><br></pre></td></tr></table></figure><p>因为<code>red</code>和<code>banana</code> 都被隐式转换为<code>int</code>类型，值都为<code>0</code> 。</p><p>但如果是范围枚举，上述代码会直接报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile error: the compiler doesn&#x27;t know how to compare different types Color and Fruit</span><br></pre></td></tr></table></figure><p>范围枚举不会转换任何可以与另一种类型进行比较的类型。</p><p>不过，<strong>比较同一类型是ok的</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Color::red == Color::blue) <span class="comment">// ok </span></span><br></pre></td></tr></table></figure></li></ol><h5 id="最佳实践-2">最佳实践</h5><p>请尽量使用范围枚举，它更安全。</p><p>虽然在实际编码我们还是可能会使用非范围枚举，因为非范围枚举隐式转换可避免大量手动<code>static_casting</code> 。但是，只是偶尔的需要<code>static_casting</code> 便不能构成拒接范围枚举的理由。</p><h3 id="4-X-类型转换🌟">4.X 类型转换🌟</h3><p><strong>什么是类型转换</strong>？</p><p>将值从一种数据类型转换为另一种数据类型的过程，称为类型转换。</p><p><strong>C++的类型有几种</strong>？</p><p>C++的类型转换分为两种，一种为隐式转换，另一种为显式转换：</p><ul><li><strong>隐式转换</strong>：编译器<u>自动</u>进行的类型转换，就是隐式转换；</li><li><strong>显式转换</strong>：程序员<u>显式</u>使用<code>_cast</code> 类型转换符进行类型转换，就是显式转换。</li></ul><p><strong>C++ 中的绝大多数类型转换都是隐式类型转换</strong>。</p><p>所以，我们先来接触隐式类型转换吧。</p><h4 id="4-X-1-隐式转换">4.X.1 隐式转换</h4><p>隐式转换可以分为两个部分，<u>标准转换</u>和<u>用户自定义转换</u>，我们来看看它们是什么。</p><h5 id="标准转换">标准转换</h5><p>标准转换就是编译器里内置的一些类型转换规则：</p><ul><li>数值提升</li><li>数值转换</li><li>算术转换</li><li>数组退化成指针、函数转换成函数指针</li><li>数据类型指针到void指针的转换、nullptr_t到数据类型指针的转换</li><li>特定语境下要求的转换，比如if里要求bool类型的值、枚举类型转换为整型</li><li>…</li></ul><p>可以看到，这些转换基本针对<u>基本数据类型</u>、<u>指针</u>、或<u>数组</u>这种内置的聚合类型的。</p><p>先从第一个数值提升说起吧。</p><ul><li><p><strong>数值提升</strong></p><p><strong>数值提升是什么</strong>？</p><p>顾名思义，数值提升就是将更小的数据类型（比如<code>char</code>） 转换为更大的数据类型（通常是<code>int</code>或者<code>double</code>）。显然这种提升是<u>安全</u>的，它不会丢失精度。</p><p>数值提升也分为两个子类别：浮点提升和整数提升。</p><ul><li><p><strong>浮点提升</strong></p><p>浮点提升规则很简单，就是<code>float</code> 可以隐式提升为<code>double</code> 。一个例子就能明白：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDouble</span><span class="params">(<span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printDouble</span>(<span class="number">4.0f</span>); <span class="comment">// 4.0f是float被隐式提升double</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>整型提升</strong></p></li></ul><blockquote><p><code>char</code>、<code>bool</code>、<code>short</code> 、<code>int</code>、<code>long</code> 都是整型。</p></blockquote><p>整型提升说白了，就是比<code>int</code> 小的数据类型，尽量往<code>int</code> 或 <code>unsigned int</code>上靠。它的规则大致总结如下：</p><ol><li>无符号或者有符号char、short 优先隐式转换为int，如果int不够容纳，则转换为 unsigned int；</li><li>bool也转换为int，false变成0，true变成1。</li></ol><p>举一个小例子。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInt</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> s =  <span class="number">3</span> ;  <span class="comment">// short</span></span><br><span class="line">    <span class="built_in">printInt</span>(s);    </span><br><span class="line">    <span class="built_in">printInt</span>(<span class="string">&#x27;a&#x27;</span>);  <span class="comment">// char</span></span><br><span class="line">    <span class="built_in">printInt</span>(<span class="literal">true</span>); <span class="comment">// bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数值之间的转换就结束了</strong>？</p><p>看到这儿或许你会说作者是不是遗漏了，<code>int→float</code> 之类的整型提升介绍呢？</p><p>其实，<code>int→float</code> 、还有宽类型→窄类型的转换都被归类为<u>数值转换</u>。当然这只是学术上的区别，你不必太过纠结这点。</p></li><li><p><strong>数值转换</strong></p><p><strong>什么是数值转换</strong>？</p><p>数值提升未提到的转换，都是数值转换。</p><p>回答这么敷衍？好吧，我具体一点。</p><p>数值转换可分为以下五种规则：</p><ol><li><p>整型可转换为任何其它整型（不包括整型提升）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s = <span class="number">3</span>; </span><br><span class="line">  <span class="keyword">long</span> l = <span class="number">3</span>; </span><br><span class="line">  <span class="keyword">char</span> ch = s; </span><br></pre></td></tr></table></figure></li><li><p>浮点类型转换为任何其他浮点类型（不包括浮点提升）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">3.0</span>; </span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">double</span> ld = <span class="number">3.0</span>;</span><br></pre></td></tr></table></figure></li><li><p>整数类型转换为任何浮点类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>将浮点类型转换为任何整数类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">3.5</span>;</span><br></pre></td></tr></table></figure></li><li><p>将整数类型或浮点类型转换为 bool</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b1 = <span class="number">3.0</span>;</span><br></pre></td></tr></table></figure></li></ol><p>可以看到：<strong><u>数值转换</u>和<u>数值提升</u>的规则综合起来就是一句话：C++中基本任意整型之间都可以进行隐式转换</strong>。</p><p><strong>但数值转换会带来一些危险</strong>。</p><p>由于数值转换可以将：宽类型→窄类型、浮点类型→整数类型，这会导致精度丢失。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浮点类型→整数类型</span></span><br><span class="line">  <span class="keyword">float</span> a = <span class="number">1.5</span>;</span><br><span class="line">  <span class="keyword">int</span> b = a ;  <span class="comment">// a = 1.0 , 小数部分丢失</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 宽类型→窄类型</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1000000</span>;</span><br><span class="line">  <span class="keyword">char</span> d = a; <span class="comment">// d = 64（&#x27;@&#x27;） , a被截断</span></span><br></pre></td></tr></table></figure><p>另一点比较隐蔽，<u>隐式转换总是转换为右值</u>（显式转换也是）。</p><p>听起来好像没什么毛病，但是和引用结合起来就坏事了，我们知道引用只能用左值初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">long</span> &amp;b = a; <span class="comment">// error，无法使用右值初始化引用</span></span><br><span class="line">  <span class="keyword">long</span> &amp;b = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span>&gt;(a); <span class="comment">// error,显式转换也是右值</span></span><br></pre></td></tr></table></figure><p>解决办法也很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.和引用类型保持一致</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">long</span> tmp = a;</span><br><span class="line">  <span class="keyword">long</span> &amp;b = tmp; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2.使用const修饰，这样可以接受右值初始化</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">long</span> &amp;b = a; </span><br></pre></td></tr></table></figure><p>扩展到函数也是一样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">long</span>&amp; value)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">func</span>(a);</span><br></pre></td></tr></table></figure><p><strong>这也是为什么很多教程说尽量用const修饰引用：这样可以使得函数参数可以隐满足式转换规则</strong>。</p></li><li><p><strong>算术转换</strong></p><p>算术转换就是当操作数不是同一类型时，会隐式转换为同一类型进行再进行操作。</p><p>算术转换优先级列表：</p><ul><li>long double  &gt; double &gt; float &gt; unsigned long long &gt; long long &gt; long &gt; unsigned int &gt; int</li></ul><p>注意到最低优先级是int。</p><p>算术转换只有两条规则：</p><ul><li>如果至少有一个操作数的类型在优先级列表中，则将具有较低优先级的操作数转换为具有较高优先级的操作数的类型；</li><li>否则（两个操作数的类型都不在列表中），两个操作数都进行类型提升。</li></ul><p>一个简单例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">3.5</span>;</span><br><span class="line"><span class="built_in"><span class="keyword">typeid</span></span>(i + d).<span class="built_in">name</span>(); <span class="comment">// 最终类型为d，double优先级更高，所以i提升为double </span></span><br></pre></td></tr></table></figure></li><li><p><strong>指针相关转换</strong></p><p>这些我们之前其实都基本见过：</p><ul><li>数组退化成指针、函数转换成函数指针</li><li>数据类型指针到void指针的转换、nullptr_t到数据类型指针的转换</li><li>…</li></ul><p>举个小例子加深下印象就好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* i = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>();</span><br><span class="line"><span class="keyword">void</span>* ptr = i;  <span class="comment">// 所以之前说void类型接受任何类型的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* pc = <span class="number">0</span>;   <span class="comment">// int 转换为 Null 指针再转换为char*指针</span></span><br><span class="line"><span class="keyword">char</span>* pc = <span class="literal">nullptr</span>;        <span class="comment">// nullptr转换为char*指针</span></span><br><span class="line">dog* pd = <span class="keyword">new</span> <span class="built_in">yellowdog</span>(); <span class="comment">// 指针类型转换，子类 yellowdog 指针转换为父类 dog 指针</span></span><br></pre></td></tr></table></figure></li><li><p><strong>特殊语境下转换</strong></p><p>以if为例，if接受bool类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">3</span>)  <span class="comment">// 3转换为bool类型，这里是true(非0值都转换为true)</span></span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;fine&quot;</span>&lt;&lt;std::endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bool也是整型，其实也就是前面说别的，C++中整型几乎都可以进行隐式转换。</p></li></ul><h5 id="别踩坑：char和int的转换？">别踩坑：char和int的转换？</h5><p>前面我们说到，char和int可以隐式转换。但这可能会带来一些意外的错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> a = c;   <span class="comment">// a=49</span></span><br></pre></td></tr></table></figure><p>此时是将<code>c</code> 的ASCII码<code>49</code>（数字的ASCII码从<code>48</code>开始，即<code>'0'</code>开始） 赋值给变量<code>a</code>。</p><p>如果需要获取<code>c</code>存储值<code>'1'</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1 = c<span class="number">-48</span>;  <span class="comment">// 方法1</span></span><br><span class="line"><span class="keyword">int</span> a2 = c-<span class="string">&#x27;0&#x27;</span>; <span class="comment">// 方法2</span></span><br></pre></td></tr></table></figure><h5 id="用户自定义转换🌟">用户自定义转换🌟</h5><blockquote><p>这部分内容有点超前，适合有一定面对对象基础的同学。</p></blockquote><p><strong>怎么进行用户定义转换</strong>？</p><p>用户自定义的隐式转换是隐式转换的重头戏，一般指两方面内容:</p><ol><li><p><strong>转换构造函数</strong>，利用接受<u>单个参数</u> 或 <u>第一个参数其余参数都提供了默认值</u> 的构造函数，将<u>其他类型对象→转换为本对象</u>。</p><blockquote><p>C++ 会将任何构造函数视为隐式转换运算符。</p></blockquote></li><li><p><strong>类型转换重载</strong>， <u>重载指定类型</u>，将<u>本类的对象→转换为指定类型对象</u>。</p></li></ol><p>两者合起来可以构成一个双向转换关系，下面我们看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 1.转换构造函数</span></span><br><span class="line">        <span class="built_in">dog</span>(string name) &#123;m_name = name;&#125; </span><br><span class="line">        <span class="comment">// 2.类型转换重载</span></span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> m_name;&#125; </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">s2dog</span><span class="params">(cosnt dog&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// nothing;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      string dogname = <span class="string">&quot;dog&quot;</span>;</span><br><span class="line">      <span class="comment">// 1.转换构造函数</span></span><br><span class="line">      dog d = dogname; <span class="comment">// ok</span></span><br><span class="line">      <span class="built_in">s2dog</span>(<span class="string">&quot;dog&quot;</span>);    <span class="comment">// ok</span></span><br><span class="line">      <span class="comment">// 2.类型转换</span></span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;my name is &quot;</span> &lt;&lt; <span class="built_in">string</span>(d) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my name is dog</span><br></pre></td></tr></table></figure><p>第一种隐式转换方式看起来有点让人费解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dog d = dogname;</span><br></pre></td></tr></table></figure><p>它也没有重载 <code>=</code> ，怎么就<code>string</code>→<code>dog</code>转换了？</p><p>这是因为<code>dog(string name) &#123;m_name = name;&#125;</code> 有两层含义，除了构造函数外，它还可以作为隐式转换函数，将 <code>string</code> 对象转换为 <code>dog</code> 对象。</p><p>具体过程还涉及到复制初始化（<u>5.2.2</u>节详解）：</p><ol><li>表达式从右到左，构造函数<code>dog(string)</code>作为转换构造函数 ，编译器先创建<code>dog</code>临时匿名对象，使得<code>=</code>两边操作类型一致；</li><li>然后构造函数<code>dog(string)</code> ，初始化匿名对象；</li><li>编译器创建对象<code>d</code> ；</li><li>调用复制构造函数，匿名对象作为复制构造函数参数，初始化对象<code>d</code> 。</li></ol><p><strong>用户自定义转换有什么危险</strong>？</p><p>隐式转换总是或多或少有点危险，用户自定义隐式转换也不例外。</p><ul><li>比如，我们只是想声明一个构造函数，但是会自动被识别为转换构造函数——将<code>string</code> →<code>dog</code>也许并不是我们的本意 。</li><li>通常编码需避免双向隐式转换，我们开头的例子是不好的编程实践。</li></ul><p>如果不想构造函数进行隐式转换，可以用 <code> explicit</code> 进行声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">dog</span><span class="params">(string)</span> </span>&#123;m_name = name;&#125;</span><br></pre></td></tr></table></figure><p>此时进行隐式转换会出错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string dogname = <span class="string">&quot;dog&quot;</span>;  <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>只能进行显示转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string dogname = <span class="keyword">static_cast</span>&lt;dog&gt;(<span class="string">&quot;dog&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>用户自定义转换有什么好处</strong>？</p><p>隐式转换并不是一无是处，它仍然有存在的意义。</p><p>下面声明一个<code>Rational</code> 有理数类，处理数字类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> den;</span><br><span class="line">    <span class="comment">// 1.构造函数隐式转换</span></span><br><span class="line"><span class="built_in">Rational</span>(<span class="keyword">int</span> numerator = <span class="number">0</span>, <span class="keyword">int</span> denominator = <span class="number">1</span>)</span><br><span class="line">: <span class="built_in">num</span>(numberator), <span class="built_in">den</span>(denominator) &#123;&#125;</span><br><span class="line">    <span class="comment">// 2.重载运算符*</span></span><br><span class="line">    Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.num*rhs.num, lhs.den*rhs.den);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rational r1 = <span class="number">23</span>;</span><br><span class="line">    Rational r2 = r1 * <span class="number">2</span>;</span><br><span class="line">    Rational r3 = <span class="number">3</span> * r1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面代码定义了一个有理数类 <code>Rational</code>，它的构造函数接受 2 个默认参数，分别代表分子和分母，给该构造函数传递一个参数时，<code>Rational</code> 具有隐式转换的特性，所以我们可以直接将数字赋值给 <code>Rational</code> 对象，如：<code>Rational r1 = 23;</code> 。</li><li>为了避免双向转换，这里并没有定义将 <code>Rational</code> 转换为 <code>int</code> 的转换函数，而当我们想实现 <code>Rational</code> 对象和 <code>int</code> 之间自由的算术运算时，我们需要定义全局的操作符重载，如上面的 <code>operator*</code> 定义了有理数的乘法云算符。</li></ul><h5 id="最佳实践-3">最佳实践</h5><p>类型转换是危险的操作，使用更长的操作符（后文将提到的显式转换）提醒同事和将来的自己注意安全。</p><h4 id="4-X-2-显式转换">4.X.2 显式转换</h4><p>显式转换主要有两个作用：</p><ol><li>完成C++隐式转换无法完成的工作，比如范围枚举中将<code>eunm</code> 类型→<code>int</code> ；</li><li>尽可能的替代隐式转换，在程序显式的声明这是个转换操作——这很专业。</li></ol><p>C++/C总是难以分开的，先从C中显式转换说起吧。</p><h5 id="C风格显式转换">C风格显式转换</h5><p>在标准 C 编程中，转换是通过 <code>()</code> 运算符完成的，类型的名称要转换的值放在括号内。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">1.5</span>;</span><br><span class="line"><span class="keyword">int</span> y = (<span class="keyword">double</span>)x;</span><br></pre></td></tr></table></figure><p>C风格的转换格式看起来很简单，但其实有不少缺点：</p><ol><li><u>转换太过随意，可以在任意类型之间转换</u>。可以把一个指向const对象的指针转换成指向非const对象的指针，把一个指向基类对象的指针转换成一个派生类对象的指针。这些转换之间的差距是非常巨大的，但是传统的C语言风格的类型转换没有区分这些。</li><li><u>C风格的转换没有统一的关键字和标示符</u>。对于大型系统，做代码排查时容易遗漏和忽略。</li></ol><p>为此，C++ 引入了<code>_cast</code>强制转换运算符。</p><h5 id="C-显式转换">C++显式转换</h5><p>C++转换风格完美的解决了C风格两个问题：</p><ol><li>对类型转换做了细分，提供了四种不同类型转换，以支持不同需求的转换；</li><li>类型转换有了统一的标示符，利于代码排查和审查。</li></ol><p>四种不同类型的转换分别是：</p><ul><li><p><code>static_cast</code>，命名上理解是静态类型转换，如int转换→char，转换失败不返回NULL。</p></li><li><p><code>dynamic_cast</code>，命名上理解是动态类型转换，如子类和父类之间的多态类型转换，转换失败返回<u>NULL</u>。</p><blockquote><p>⚠️ 所以上行转换（子类→父类）这种安全转换用static_cast是可以的，但是下行转换（父类→子类）这种不安全的转换使用dynamic_cast，失败会返回NULL，会运行时检查。</p></blockquote></li><li><p><code>const_cast</code>，去除const属性，如常量指针/引用转换→非常量指针/引用。</p></li><li><p><code>reinterpret_cast</code>，仅仅重新解释类型，没有进行二进制的转换。</p></li></ul><h5 id="static-cast">static_cast</h5><p><strong>什么时候使用static_cast</strong>？</p><ul><li><strong>基本数据类型之间的转换</strong>，如把int转换为char，带来安全性问题由程序员来保证；</li><li><strong>把空指针转换成目标类型的空指针</strong>；</li><li><strong>把任何类型的表达式转为void类型</strong>；</li><li>（不推荐）类层次结构中<u>基类和派生类之间指针或引用</u>的转换：上行转换（子类→父类）是安全的；下行转换（父类→子类）由于没有动态类型检查，所以是不安全的。</li></ul><p><strong>隐式转换都建议使用static_cast进行标明和替换</strong>。</p><p>例如，下面隐式转换都可替换为显式的static_cast转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(n); <span class="comment">// 基本类型转换</span></span><br><span class="line"><span class="keyword">int</span> *pn = &amp;n;</span><br><span class="line"><span class="keyword">double</span> *d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span> *&gt;(&amp;n) <span class="comment">// 无关类型指针转换，编译错误，应该使用reinterpret_cast</span></span><br><span class="line"><span class="keyword">void</span> *p = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> *&gt;(pn); <span class="comment">// 任意类型转换成void类型</span></span><br></pre></td></tr></table></figure><h5 id="dynamic-cast">dynamic_cast</h5><p><strong>什么时候使用dynamic_cast</strong>？</p><p>只有在<u>派生类之间</u>转换时才使用dynamic_cast，<u>type-id必须是类指针，类引用或者<code>void*</code></u>。</p><ul><li><strong>使用时基类必须要有虚函数</strong>，因为dynamic_cast是运行时类型检查，需要运行时类型信息，而这个信息是存储在类的虚函数表中，只有一个类定义了虚函数才会有虚函数表（如果一个类没有虚函数，那么一般意义上，这个类的设计者也不想它成为一个基类）。</li></ul><p><strong>和static_cast对比有什么区别</strong>？</p><ul><li>下行转换，dynamic_cast是安全的（当类型失败时，转换过来的是<u>空指针</u>），而static_cast是不安全的（当类型不一致时，<u>转换过来的是错误意义的指针</u>，可能造成踩内存、非法访问等各种问题）。</li><li>dynamic_cast还可以进行交叉转换。</li></ul><p>一个简单示例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">int</span> m_iNum;</span><br><span class="line">      <span class="comment">// 基类必须有虚函数，保持多态性才能使用dynamic_cast</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span>:</span> <span class="keyword">public</span> BaseClass </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">char</span> *m_szName[<span class="number">100</span>];</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">　　</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BaseClass* pb = <span class="keyword">new</span> <span class="built_in">DerivedClass</span>();</span><br><span class="line">    <span class="comment">// 子类-&gt;父类，静态类型转换，正确但不推荐</span></span><br><span class="line">    DerivedClass *pd1 = <span class="keyword">static_cast</span>&lt;DerivedClass*&gt;(pb);</span><br><span class="line">    <span class="comment">// 子类-&gt;父类，动态类型转换，正确</span></span><br><span class="line">    DerivedClass *pd2 = <span class="keyword">dynamic_cast</span>&lt;DerivedClass*&gt;(pb);</span><br><span class="line"></span><br><span class="line">    BaseClass* pb2 = <span class="keyword">new</span> <span class="built_in">BaseClass</span>();</span><br><span class="line">    <span class="comment">// 父类-&gt;子类，静态类型转换，危险！访问子类m_szName成员越界</span></span><br><span class="line">    DerivedClass *pd21 = <span class="keyword">static_cast</span>&lt;DerivedClass*&gt;(pb2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类-&gt;子类，动态类型转换，安全的。结果是NULL</span></span><br><span class="line">    DerivedClass *pd22 = <span class="keyword">dynamic_cast</span>&lt;DerivedClass*&gt;(pb2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="const-cast">const_cast</h5><p>cosnt_cast是四种类型转换符中唯一可以对常量进行操作的转换符，<u>用来去除常量性</u>，程序员对这个操作负责。</p><ul><li>常量指针转换为非常量指针，并且仍然指向原来的对象</li><li>常量引用被转换为非常量引用，并且仍然指向原来的对象</li></ul><p>注意转换类型只能是指针或引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SA</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">　　<span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> SA ra;</span><br><span class="line">    ra.i = <span class="number">10</span>; <span class="comment">// error，直接修改const类型</span></span><br><span class="line">    SA &amp;rb = <span class="keyword">const_cast</span>&lt;SA&amp;&gt;(ra);</span><br><span class="line">    rb.i = <span class="number">10</span>; <span class="comment">// ok，去除了常量性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="reinterpret-cast">reinterpret_cast</h5><p><strong>非常危险的操作符，谨慎使用</strong>。</p><ul><li>reinterpret_cast可以在指针和引用里进行肆无忌惮的转换；</li><li>reinterpret_cast可以将整型转换为指针，也可以把指针转换为数组；</li><li>reinterpret_cast是从底层对数据进行重新解释，依赖具体的平台，可移植性差。</li></ul><p>一般用来不同类型的指针或引用之间转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>* p_a = &amp;a;</span><br><span class="line"><span class="keyword">bool</span>* p_c = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">bool</span>*&gt;(p_a);</span><br><span class="line">std::cout &lt;&lt; *p_c&lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h5 id="最佳实践-4">最佳实践</h5><ul><li><p><strong>什么时候使用显式转换</strong>？</p><p>在所有需要转换的地方都应该尽量使用显式转换。</p></li><li><p><strong>四种显式转换该怎么选择</strong>？</p><p>⚠️ 除了static_cast可用于非指针、引用类型，<strong>其它转换符都必须是指针或引用</strong>。</p><ul><li>static_cast：基本类型转换、类下行转换、空指针和其它指针的转换；</li><li>reinterpret_cast：不同类型的指针类型转换；</li><li>const_cast：将常量指针/引用转换为非常量指针/引用；</li><li>daynamic_cast：多态类之间的类型转换。</li></ul></li></ul><h4 id="4-X-3-类型转换补充：string">4.X.3 类型转换补充：string</h4><p>这里主要总结下<u>上面没提到，平时又经常用到的</u>转换：</p><ol><li>string和char等基本类型的转换；</li><li>string和char[]之间转换；</li><li>string和其它类型数组（比如int[]）之间的转换。</li></ol><p>1和2在<u>1.8.3</u> &amp; <u>1.8.4</u> 节都已介绍过，为了完整性这里再次进行简单总结。</p><h5 id="string↔基本类型">string↔基本类型</h5><blockquote><p>string不是内置类型，使用static_cast是不行的，比如int↔string。</p></blockquote><p>string↔基本类型有两种方式：</p><ol><li>使用输入、输出流作为媒介实现；</li><li>使用C++11<code>std::string</code>内置的相关函数实现。</li></ol><p>为了通用性，我们先介绍 <code>std::istringstream</code>和<code>std::ostringstream</code>  作为媒介如何实现转换。</p><ul><li><code>std::istringstream</code> ，即输入流：构造函数<u>接受数据的输入</u>，然后使用<code>&gt;&gt;</code> 提取流中数据；</li><li><code>std::ostringstream</code> ，即输出流：使用<code>&lt;&lt;</code> 接受数据的输入，使用成员方法如<code>str()</code> 提取流中数据。</li></ul><p>下面是具体实例。</p><ul><li><p><strong>string→基本类型</strong></p><p>基本思路：用string对象初始化<u>输入</u>流 → 输入流写入<code>&gt;&gt;</code>其它类型中（string此时会被自动转换）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    std::string str = <span class="string">&quot;233&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function">std::istringstream <span class="title">iStream</span><span class="params">(str)</span></span>;</span><br><span class="line">    iStream&gt;&gt;a;   <span class="comment">// 输出流自动转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>string←基本类型</strong></p><p>基本思路：用<code>&lt;&lt;</code>初始化<u>输出</u>流 → 输出流对象调用<code>str()</code>方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">233</span>;</span><br><span class="line">std::ostringstream oStream;</span><br><span class="line">oStream&lt;&lt;b;</span><br><span class="line">oStream.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure></li></ul><p><strong>好消息，C++11给广大程序员带来了福音，提供了大量已经定义好的方法</strong>。</p><blockquote><p>更多介绍，可参考：<a href="https://blog.csdn.net/lmb1612977696/article/details/78273629">c++ string和其他类型互转</a></p></blockquote><p>但注意，char↔string的转换方法未实现，我们可使用以下方式实现转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">std::string str = c;  <span class="comment">// char → string</span></span><br><span class="line"></span><br><span class="line">c = str[<span class="number">0</span>];  <span class="comment">// string → char</span></span><br></pre></td></tr></table></figure><p>下面对常用的转换方法进行介绍。</p><ul><li><p><strong>string→基本类型</strong></p><p>常用方法原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string→int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi</span><span class="params">( <span class="keyword">const</span> std::string&amp; str, std::<span class="keyword">size_t</span>* pos = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span> )</span></span>;</span><br><span class="line"><span class="comment">// string→long</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">stol</span><span class="params">( <span class="keyword">const</span> std::string&amp; str, std::<span class="keyword">size_t</span>* pos = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span> )</span></span>;</span><br><span class="line"><span class="comment">// string→float</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">stof</span><span class="params">( <span class="keyword">const</span> std::string&amp; str, std::<span class="keyword">size_t</span>* pos = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>使用实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::string str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">   <span class="keyword">int</span> a = std::<span class="built_in">stoi</span>(str);</span><br><span class="line">   <span class="keyword">int</span> <span class="keyword">float</span> = std::<span class="built_in">stof</span>(str);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>string←基本类型</strong></p><p>常用方法原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数重载</span></span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">( <span class="keyword">int</span> value )</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">( <span class="keyword">long</span> value )</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">( <span class="keyword">float</span> value )</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">( <span class="keyword">double</span> value )</span></span>;</span><br></pre></td></tr></table></figure><p>使用实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">   std::string str1 = std::<span class="built_in">to_string</span>(a);</span><br><span class="line">   <span class="keyword">float</span> b = <span class="number">1.2</span>;</span><br><span class="line">   std::string str1 = std::<span class="built_in">to_string</span>(b);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="string↔char">string↔char[]</h5><p>string和char[]数组之间的转换比较简单，因为string内置了相关方法。</p><ul><li><p><strong>char[]← string</strong></p><p>如果是字符串常量，C++可以隐式转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c_arr[] = <span class="string">&quot;royhuang&quot;</span>;  <span class="comment">// &quot;royhuang&quot;是string类型的字符串常量，可以隐式转换</span></span><br><span class="line">  <span class="keyword">char</span>* p_c_arr = <span class="string">&quot;royhuang&quot;</span>; <span class="comment">// 这里没发生隐式转换，但p_c_arr指向了字符串常量</span></span><br></pre></td></tr></table></figure><p>对于非字符串常量，<code>std::string</code>同样提供了<code>c_str()</code> 和 <code>data()</code> 等方法，不过要注意：</p><ul><li>返回类型只能是<code>const char*</code> ，也就是必须为常量，且是指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;royhuang&quot;</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* c_arr1 = str.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* c_arr2 = str.<span class="built_in">data</span>();</span><br><span class="line"><span class="comment">// const char c_arr3[] = str.data();  // 非法</span></span><br></pre></td></tr></table></figure></li><li><p><strong>char[] → string</strong></p><p>string构造函数接受字符串数组：<code>string::string(const char* szCString)</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c_arr[] = <span class="string">&quot;royhuang&quot;</span>;  </span><br><span class="line"></span><br><span class="line">std::string str&#123; c_arr &#125;;  <span class="comment">// 构造函数</span></span><br></pre></td></tr></table></figure></li></ul><p>但是如果涉及到字符串分隔符，就比较麻烦点，参考下文处理。</p><h5 id="string→其它类型数组">string→其它类型数组</h5><p><strong>如果是分割每一个字符为数组元素，可以转换为：string→char[]→其它类型数组</strong>。</p><p>下面展示了：string→int[] ，这里使用了容器vector。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; i_arr;</span><br><span class="line">    i_arr.<span class="built_in">reserve</span>(<span class="number">10</span>); <span class="comment">// tips：预先分配一些空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.先转换为char数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* c_arr = str3.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">// 2.char数组再转换为其它类型数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c:str3)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意是c-&#x27;0&#x27;，不是static_cast&lt;int&gt;(c)</span></span><br><span class="line">        <span class="comment">// c-&#x27;0&#x27;算术类型提升为int</span></span><br><span class="line">        i_arr.<span class="built_in">push_back</span>(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>string←其它类型数组，没啥意义一般很少需要</strong>。</p><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">45</span>,<span class="number">45</span>,<span class="number">67</span>,<span class="number">144</span>&#125;;</span><br></pre></td></tr></table></figure><p>转换为<code>454567144</code> 有啥用呢？一般不需要这么做。更多的反而是怎么将一个int类型转换string。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">string str = std::<span class="built_in">to_string</span>(i);</span><br></pre></td></tr></table></figure><p><strong>其实上面介绍都是很特殊的string→数组情况：分割每一个字符为数组元素。但往往我们需要处理的是如何按指定规则分割<u>子串</u>为数组元素</strong>：</p><p>比如，如何将：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;12,45,56&quot;</span> ;</span><br></pre></td></tr></table></figure><p>转换为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">12</span>,<span class="number">45</span>,<span class="number">56</span>&#125;;</span><br></pre></td></tr></table></figure><p>最常见的便是<u>按指定分隔符来分割字符串</u>为新数组元素。</p><h5 id="string指定分割→数组">string指定分割→数组</h5><p>对于指定分隔符来分割字符串，再转换为数组。一般而言有如下思路：</p><ol><li>通过string成员函数：find+substr函数；</li><li>通过C语言中分割函数：strtok函数；</li><li>通过stringstream实现。</li></ol><p>这里主要介绍第1、第3两种方式，完整的介绍可参考：<a href="https://www.cnblogs.com/wikiwen/p/10229604.html">C++字符串分割方法总结</a> 。</p><ul><li>find函数原型： <code>size_t find (const string&amp; str, size_t pos = 0) const;</code>；</li><li>substr函数原型： <code>string substr (size_t pos = 0, size_t len = npos) const;</code> 。</li></ul><p><strong>以string→int[]为例</strong> 。</p><ul><li><p>通过find+substr函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strSplit</span><span class="params">(<span class="keyword">const</span> std::string src_str, vector&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">const</span> <span class="keyword">char</span> pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    std::string str = src_str;</span><br><span class="line">    str += std::<span class="built_in">string</span>(pattern);   <span class="comment">// 方便处理最后一个字符串</span></span><br><span class="line">    <span class="keyword">size_t</span>  pre_pos = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">size_t</span>  pos = str.<span class="built_in">find</span>(pattern);</span><br><span class="line">    <span class="keyword">while</span> (pos != str.npos) <span class="comment">// 如果没找到分隔符则终止</span></span><br><span class="line">    &#123;</span><br><span class="line">        string temp = str.<span class="built_in">substr</span>(pre_pos,pos);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(std::<span class="built_in">stoi</span>(temp));</span><br><span class="line">        <span class="comment">// 保留剩下的字符串作为新串</span></span><br><span class="line">        str = str.<span class="built_in">substr</span>(pos+<span class="number">1</span>,str.<span class="built_in">length</span>());</span><br><span class="line">        <span class="comment">// 查找新字符串第一个分隔符的位置</span></span><br><span class="line">        pos = str.<span class="built_in">find</span>(pattern); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">      std::string str = <span class="string">&quot;12,45,56&quot;</span> ;</span><br><span class="line">      std::vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">strSplit</span>(str,vec,<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过stringstream</p><p>这种方式更为简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strSplit</span><span class="params">(<span class="keyword">const</span> std::string src_str, vector&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">const</span> <span class="keyword">char</span> pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::stringstream <span class="title">input_ss</span><span class="params">(src_str)</span></span>;</span><br><span class="line">    std::string sub_str&#123;&#125;;  <span class="comment">// sub_str接受返回的子串</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(input_ss, sub_str, pattern)) <span class="comment">// getline分割字符串</span></span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(std::<span class="built_in">stoi</span>(sub_str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">      std::string str = <span class="string">&quot;12,45,56&quot;</span> ;</span><br><span class="line">      std::vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">strSplit</span>(str,vec,<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="leetcode实战">leetcode实战</h5><p>以经典题型为例，将下面转换为多维数组，第一行输入的是长度。</p><blockquote><p>3</p><p>11  12  13</p><p>14  15   16</p><p>17   18  19</p></blockquote><p>完整实现代码如下：可见关键是如何实现分割字符串的函数（面试时这种常用函数最好直接背下）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strSplit</span><span class="params">(<span class="keyword">const</span> std::string src_str, vector&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">const</span> <span class="keyword">char</span> pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::stringstream <span class="title">input_ss</span><span class="params">(src_str)</span></span>;</span><br><span class="line">    std::string sub_str&#123;&#125;; <span class="comment">// sub_str接受返回的子串 </span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(input_ss, sub_str, pattern)) <span class="comment">// getline分割字符串</span></span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(std::<span class="built_in">stoi</span>(sub_str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// std::getline(std::cin,N); // getline不能接受类型int的参数，所以这里不使用</span></span><br><span class="line">    std::cin&gt;&gt;N;</span><br><span class="line">    std::cin.<span class="built_in">ignore</span>(); <span class="comment">// 但是cin要处理换行符，getline不需要处理这个问题 </span></span><br><span class="line">    </span><br><span class="line">    std::vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vec ; <span class="comment">// vector比内置数组好用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string input_str; <span class="comment">// 读取一行字符串</span></span><br><span class="line">        std::<span class="built_in">getline</span>(cin,input_str);    </span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; vec_tmp ;  </span><br><span class="line">        <span class="built_in">strSplit</span>(input_str,vec_tmp,<span class="string">&#x27;,&#x27;</span>); <span class="comment">// 分割该行字符串</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(vec_tmp);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="最佳实践-5">最佳实践</h5><p>不涉及到数组：</p><ul><li><p><strong>如果是基本类型之间的互转</strong>，隐式转换虽然也可以实现，但最好使用<code>static_cast</code>显式转换；</p><p>不过需要注意char↔int之间的转换，也许你并不需要char类型的ASCII值。</p></li><li><p><strong>如果是指针、引用、多态、常量转非常量之间的转换</strong>，请使用显示转换；</p></li><li><p><strong>如果string和基本类型转换</strong>，使用<code>std::string</code> 内置的函数库效率最高。</p></li></ul><p>涉及到数组：</p><ul><li><strong>如果是string↔char[]，不涉及到分割子串</strong>，使用<code>std::string</code> 内置函数可以很方便进行转换；</li><li><strong>如果是string→其它类型数组（单向，反向没多大意义），不涉及到分割子串</strong> ，按string→char[]→其它类型数组转换即可；</li><li><strong>如果是string→其它类型数组（单向），涉及到分割子串</strong> ：<ul><li>先借助find和substr函数切割出子串数组（string[]）；</li><li>再将每个子串转换为其它类型（内置函数实现，如stoi）。</li></ul></li></ul><p>最后，请尽量避免使用隐式转换。</p><h2 id="更新记录">更新记录</h2><div class="timeline"><div class="timenode"><div class="meta"><p><p>2022-01-22 ：更新笔记</p></p></div><div class="body"><ol><li>第一次更新</li></ol></div></div></div><h2 id="参考资料">参考资料</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++中已经有面向对象的概念，那struct还有啥存在的意图：https://www.zhihu.com/question/23174488<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++中四种强制类型转换区别详解：https://blog.csdn.net/chen134225/article/details/81305049<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">没有学不会的C++：用户自定义的隐式类型转换 ：https://juejin.cn/post/6844903798100459533<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 教程 </tag>
            
            <tag> C++基础 </tag>
            
            <tag> 结构体 </tag>
            
            <tag> 枚举 </tag>
            
            <tag> 类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++从零开始（三）：务实基础（上）快速入门</title>
      <link href="/p/26224/"/>
      <url>/p/26224/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，开始更新中…</p></blockquote><div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div><h2 id="一、快速开始">一、快速开始</h2><h3 id="1-1-认识C">1.1 认识C++</h3><h4 id="1-1-1-为什么需要C">1.1.1 为什么需要C++</h4><p>前有Java后有Python、Go、Rust，C++作为一个“老古董”似乎有点格格不入了？</p><p>其实不然，C 和 C++ 的底层设计理念可以概括为“信任程序员”——这既美妙又危险。但也正是C++ 允许程序员高度自由地做他们想做的事，因此，<strong>在需要高性能和精确控制内存和其他资源的情况下表现出色</strong> 。</p><p>例如，下面是C++擅长的一些领域，它们对性能要求通常极其苛刻：</p><ul><li>视频游戏</li><li>实时系统（例如用于运输、制造等……）</li><li>高性能金融应用（例如高频交易）</li><li>图形应用和模拟</li><li>生产力/办公应用</li><li>嵌入式软件</li><li>音视频处理</li><li>人工智能和神经网络</li></ul><p>如果你想更了解计算机的本质，也对这些领域感兴趣，C/C++应该是你不二的选择。</p><h4 id="1-1-2-C-组成">1.1.2 C++组成</h4><p>标准的C++由两个重要部分组成：</p><ul><li><strong>核心语言</strong>，提供了所有构件块，包括变量、数据类型和常量等等。</li><li><strong>C++ 标准库</strong>，提供了大量的函数，用于操作文件、字符串等，包含<strong>标准模板库</strong>（STL），提供了大量的方法，用于操作数据结构等。</li></ul><p>C++ 标准库简单来说就是提供一些预定的库及函数，方便我们编写代码。整体可以分为两部分：</p><ol><li><strong>标准函数库</strong>： 这个库是由通用的、独立的、<u>不属于任何类的函数</u>组成的，函数库继承自 C 语言。<ul><li>输入/输出 I/O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数</li></ul></li><li><strong>面向对象类库</strong>： 这个库是类及其相关函数的集合。<ul><li>标准的 C++ I/O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库</li></ul></li></ol><p>同时，为了编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译， C++ 采用<strong>ISO标准</strong>。</p><p>ISO标准发展历史一览如下：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/00001_01.png" alt="Modern C++ 中的多线程| Busyboxs"></p><h4 id="1-1-3-第一个C-程序">1.1.3 第一个C++程序</h4><p>🖱 从梦开始的地方，写一个经典<code>hello.cpp</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* main() 是程序开始执行的地方 */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span>&lt;&lt;endl; <span class="comment">// 输出 Hello World</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保<code>g++</code>程序可被识别（加入到环境变量中），在包含源文件 <code>hello.cpp</code> 的目录中，编译并执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ hello.cpp</span><br><span class="line">$ ./a.out</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p><code>g++</code>编译代码的方式将在本文大量使用，在前文：<a href="https://hwh.zone/p/2834/">g++/Makefile/CMake快速入门</a> ，我们也仔细介绍过。如果还不太了解，可以一读。</p><p>在上述程序中还使用了C++的<strong>注释</strong>：</p><ul><li>单行注释：<code>// 注释内容</code></li><li>多行注释：<code>/* 注释内容 */</code></li></ul><p>特别的，在 <code>/* */</code> 注释内部，<code>//</code> 字符没有特殊的含义；在 <code>//</code> 注释内，<code>/* */</code> 也没有特殊的含义。</p><h3 id="1-2-变量">1.2 变量</h3><p>“变量”一词来源于数学，是计算机表示能储存计算结果或能表示值的抽象概念，但这种说法不够深刻。</p><p>应该从CPU角度理解，<u>变量</u>就是某块内存区域<u>地址别名</u>，这块内存区域保存变量的值。下面举一个实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>对应汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl    $0, -12(%rbp)</span><br><span class="line">movl    $1, -12(%rbp)</span><br></pre></td></tr></table></figure><ol><li>当CPU执行<code>int x = 0</code>，会在内存（这里是栈）腾出一块区域（<code>-12(%rbp)</code>）用来存储变量<code>x</code>；然后<code>x</code>所代表的内存区域（<code>-12(%rbp)</code>）被存入0。</li><li>继续执行<code>x=1</code>，1被存入变量<code>x</code>所代表的内存区域。</li></ol><p>可以看到，变量的存在使得我们：<strong>不用记住为分配<code>x</code>的内存地址是什么，我们通过变量名<code>x</code>就可以使用分配的内存区域</strong>。<strong>因为使用<code>x</code>时，编译器会将变量<code>x</code>隐式自动翻译成对应的内存地址，同时进行间接寻址</strong>（可以理解为使用<code>x</code>等价于<code>*x</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;   <span class="comment">// 编译器眼里：int* x = -12(%rbp); *x = 0;</span></span><br><span class="line">x = <span class="number">1</span>;       <span class="comment">// 编译器眼里： *x = 1;</span></span><br></pre></td></tr></table></figure><p>说完深层次的概念，我们来了解变量基本的一些定义&amp;使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a simple example*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> c, ch;  <span class="comment">// char类型变量c,ch</span></span><br><span class="line"><span class="keyword">int</span> months;   <span class="comment">// int类型变量months</span></span><br><span class="line"><span class="comment">/* main() 是程序开始执行的地方 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  empoly_salary = <span class="number">20000</span>; <span class="comment">// int类型变量empoly_salary</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到组成变量的基本三要素：<strong>名称、类型及值</strong>。</p><ol><li><p><strong>名称</strong>：变量的名称可以由<strong>字母、数字和下划线字符</strong>组成。</p></li><li><p><strong>类型</strong>：用于<strong>指定变量存储的大小和布局</strong>。在C++中有<u>基本类型</u>和其它的如<u>枚举</u>等类型。</p><ul><li><p><strong>基本类型</strong>：C++ 七种基本数据类型如下。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">关键字</th></tr></thead><tbody><tr><td style="text-align:center">布尔型</td><td style="text-align:center">bool</td></tr><tr><td style="text-align:center">字符型</td><td style="text-align:center">char</td></tr><tr><td style="text-align:center">整型</td><td style="text-align:center">int</td></tr><tr><td style="text-align:center">浮点型</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">双浮点型</td><td style="text-align:center">double</td></tr><tr><td style="text-align:center">无类型</td><td style="text-align:center">void</td></tr><tr><td style="text-align:center">宽字符型</td><td style="text-align:center">wchar_t</td></tr></tbody></table></li><li><p><strong>其它类型</strong></p><p>C++ 也允许定义各种其他类型的变量，比如<strong>枚举、指针、数组、引用、数据结构、类</strong>等。这是我们后续笔记会继续提到的知识点。</p></li></ul></li></ol><p>在上面我们提到了变量三要素：<strong>名称</strong>、<strong>值</strong>和<strong>类型</strong>。由此可以引发几个小问题：</p><ul><li><p>C++变量名称有什么<strong>命令规则</strong>或规律吗？</p></li><li><p>C++<strong>不同的位置（如，main函数体内、外</strong>）定义的变量有什么区别吗？</p></li><li><p><strong>C++的变量存储有上限吗</strong>？比如int类型的变量最多可以存储多大的数据？</p></li><li><p>实际写代码中，变量不一定立马给它赋值（初始化），<strong>变量的初始化值会是什么呢</strong>？为什么常说变量不初始化是一个不好的行为？</p></li></ul><h4 id="1-2-1-标识符和命令规则">1.2.1 标识符和命令规则</h4><p>C++ 标识符是用来<strong>标识变量、函数、类、模块</strong>，或任何其他用户自定义项目的名称。一个标识符<strong>以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字</strong>（0-9）。</p><p>C++ 标识符内不允许出现标点字符，比如 @、&amp; 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，<strong>Manpower</strong> 和 <strong>manpower</strong> 是两个不同的标识符。</p><p>下面列出几个有效的标识符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mohd       zara    abc   move_name  a_123</span><br><span class="line">myname50   _temp   j     a23b9      retVal</span><br></pre></td></tr></table></figure><h4 id="1-2-2-局部变量和全局变量">1.2.2 局部变量和全局变量</h4><p>一般来说有三个地方可以声明变量：</p><ul><li><strong>函数或一个代码块内部</strong>，称为局部变量；</li><li><strong>函数参数中</strong>，称为形式参数；</li><li><strong>所有函数外部</strong>，称为全局变量。</li></ul><p>在之前的例子中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a simple example*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数体外，全局变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> c, ch; </span><br><span class="line"><span class="keyword">int</span> months;        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  empoly_salary = <span class="number">20000</span>;  <span class="comment">// main函数体内，局部变量</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>【<strong>扩展思考</strong>】特别的，如果<strong>局部变量和全局变量的名称相同</strong>，调用时以谁的值为准？</p><ul><li>答案：以局部变量值为准，请看下例。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数体外，全局变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> c, ch; </span><br><span class="line"><span class="keyword">int</span> months;        </span><br><span class="line"><span class="keyword">int</span> empoly_salary = <span class="number">24000</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  empoly_salary = <span class="number">20000</span>;  <span class="comment">// main函数体内，局部变量</span></span><br><span class="line">   cout&lt;&lt; empoly_salary&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码输出值：20000。<strong>局部变量的值会覆盖全局变量的值</strong>。</p></li><li><p>【<strong>深入总结</strong>】<strong>全局变量和局部变量的区别和总结</strong></p><ul><li><p><strong>声明位置不同</strong>：局部变量声明在函数或代码块内部；全局变量声明在所有函数的外部。</p></li><li><p><strong>生命周期不同</strong>：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</p></li><li><p><strong>使用方式不同</strong>：通过声明后全局变量在程序的各个部分都可以用到，<strong>分配在全局数据段并且在程序开始运行的时候被加载</strong>；局部变量分配在堆栈区，只能在局部使用。</p></li></ul></li></ul><h4 id="1-2-3-变量类型">1.2.3 变量类型</h4><h5 id="七种基本类型">七种基本类型</h5><p>在前面我们提到：</p><ul><li><p>变量其实只不过是程序可操作的存储区的名称，类型决定了变量存储的大小和布局。</p></li><li><p>C++有七种基本类型</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">关键字</th></tr></thead><tbody><tr><td style="text-align:center">布尔型</td><td style="text-align:center">bool</td></tr><tr><td style="text-align:center">字符型</td><td style="text-align:center">char</td></tr><tr><td style="text-align:center">整型</td><td style="text-align:center">int</td></tr><tr><td style="text-align:center">浮点型</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">双浮点型</td><td style="text-align:center">double</td></tr><tr><td style="text-align:center">无类型</td><td style="text-align:center">void</td></tr><tr><td style="text-align:center">宽字符型</td><td style="text-align:center">wchar_t</td></tr></tbody></table></li></ul><p>这些基本类型可以使用一个或多个类型修饰符进行修饰：</p><ul><li>signed、unsigned、short、long</li></ul><p>例如， wchar_t 是这样来的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">wchar_t</span>;</span><br></pre></td></tr></table></figure><p>所以 wchar_t 实际上和 short int 一样。</p><p>每种类型需占用不同的字节数，存储上下限如下所示：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">描述</th><th style="text-align:center">取值范围</th><th style="text-align:center">字节数</th></tr></thead><tbody><tr><td style="text-align:center"><strong>int</strong></td><td style="text-align:center">整型，表示整数</td><td style="text-align:center">-2^-31^ ~ 2^31^-1</td><td style="text-align:center"><strong>4</strong></td></tr><tr><td style="text-align:center">unsigned int</td><td style="text-align:center">无符号整型，表示整数</td><td style="text-align:center">0 ~ 2^32^-1</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">bool</td><td style="text-align:center">布尔类型</td><td style="text-align:center">true或false</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">字符类型，是<strong>整型</strong></td><td style="text-align:center">-128~127</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">unsigned char</td><td style="text-align:center">无符号字符类型，是<strong>整型</strong></td><td style="text-align:center">0~255</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>float</strong></td><td style="text-align:center">单精度浮点值，表示实数</td><td style="text-align:center">3.4×10^-38^ ~ 3.4×10^38^</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center"><strong>double</strong></td><td style="text-align:center">双精度浮点值，表示实数</td><td style="text-align:center">1.7×10^-308^ ~ 1.7×10^308^</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center"><strong>long</strong></td><td style="text-align:center">长整型</td><td style="text-align:center">-2^-31^ ~ 2×10^31^-1</td><td style="text-align:center"><strong>4</strong></td></tr><tr><td style="text-align:center">unsigned long</td><td style="text-align:center">无符号长整型</td><td style="text-align:center">0 ~ 2^32^-1</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">unsigned long long</td><td style="text-align:center">无符号长整型，64位</td><td style="text-align:center">0 ~ 2×10^64^-1</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center"><strong>short</strong></td><td style="text-align:center">短整型</td><td style="text-align:center">-2^-15^ ~ 2^15^-1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">unsigned short</td><td style="text-align:center">无符号短整型</td><td style="text-align:center">0 ~ 2^16^-1</td><td style="text-align:center">2</td></tr></tbody></table><h5 id="如何比较浮点变量？">如何比较浮点变量？</h5><p>这是一个很有意思的小问题，它涉及到计算机一些底层表示。</p><p><strong>永远不要使用<code>==</code> 比较两个浮点变量，因为计算机不能精确表示非2的指数幂小数</strong>。</p><p>你或许表示疑问：直接<code>==</code>比较不可以吗？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">2.33</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">2.33</span>;</span><br><span class="line"><span class="keyword">if</span>( a == b)</span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;不相等&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;相等&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相等</span><br></pre></td></tr></table></figure><p>— 这没毛病啊老铁？</p><p>不，老铁问题大的很勒！</p><p>下面比较便出现了意料之外的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">2.33</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">2.34</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((b-a) == <span class="number">0.01</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;相等&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;不相等&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不相等</span><br></pre></td></tr></table></figure><p>这是因为<code>b</code> 、<code>a</code> 在底层二进制中不能精确表示，只能<u>无限趋近</u>。实际存储中，计算机<u>只会截断保留一定长度的二进制数，并不能精确表示浮点数</u> 。</p><p>以IEEE 754标准为例，单精度（总32位）尾数保留23位，其余指数8位，符号位1位（<a href="https://tooltt.com/ieee/">在线转换地址</a>）。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220117161858469.png" alt="image-20220117161858469"></p><p>在浮点运算中，计算机也是使用二进制进行计算：</p><ul><li><p>最开始<code>a=b=2.33</code> ，判断<code>a=b</code> 是否相等：计算机通过对比每一个<code>bit</code> ，因为<code>b</code> 和<code>a</code> 底层二进制表示相等，所以直接比较两个相等浮点数不会出错；</p></li><li><p>但是如果是<code>a-b</code> ，浮点数参与了运算：因此操作数<code>b</code> 和<code>a</code> 本来就是不精确的二进制表示，计算出来的二进制结果自然无法精确表示的<code>0.01</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00111100001000111101011100001010 # 32位，0.01对应二进制表示</span><br></pre></td></tr></table></figure></li></ul><p>所以参与了运算的浮点数<code>b-a</code> 再和<code>0.01</code> 比较出错。</p><p><strong>但也并不是所有的浮点数都不能精确表示，2的整数冥的浮点数便可以精确表示</strong>。</p><p><code>IEEE 754</code>存储标准如下。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1949091-20200502090534549-1343111747.png" alt="IEEE 754 浮点数的表示方法- 莫哈德- 博客园"></p><p>根据标准，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.5</mn><mo>=</mo><mn>1.0</mn><mo>∗</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">0.5=1.0*2^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.5</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1.0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ，显然<code>0.5</code> 可以被精确表示。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220117163244930.png" alt="image-20220117163244930"></p><h4 id="1-2-4-变量初始化🌟">1.2.4 变量初始化🌟</h4><p>初始化是指<strong>声明变量但没有定义它（没有指定初值</strong>）时，编译器进行的<strong>默认初始化</strong>（赋值）操作。</p><p>先讲讲上述概念中出现的新名词，“声明”和“定义”。</p><h5 id="声明和定义的区别？">声明和定义的区别？</h5><p>说清楚这个问题，要分变量和函数两个方面讨论。</p><blockquote><p>声明可以多次，定义只能有一次。</p></blockquote><p><strong>如果是变量</strong>。</p><ul><li><p><strong>声明（一般在<code>.h</code>文件中</strong>）：仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a ;     <span class="comment">// 仅声明，别处定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b = <span class="number">10</span>; <span class="comment">// 声明，同时进行定义，为变量b分配了空间且存储了值10</span></span><br></pre></td></tr></table></figure><p>⚠️ 注意如果不是<code>extern</code>关键字修饰的变量，C++中的变量<u>声明时编译器会自动定义（默认初始化）</u>。</p><p>下面进行举例说明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*other.h*/</span></span><br><span class="line"><span class="keyword">int</span> a; <span class="comment">//  声明+定义（存储值0）</span></span><br></pre></td></tr></table></figure><p>如果有多个<code>.cpp</code> 文件<code>include “other.h”</code> ，<u>会重复定义多次<code>a</code></u>（定义只能有一次）。</p><ul><li><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;other.h&quot;</span>  <span class="comment">// 引入头文件other.h，变量a被定义一次,</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;   </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>other.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;other.h&quot;</span> <span class="comment">// 引入头文件other.h，变量a被定义一次</span></span></span><br></pre></td></tr></table></figure></li></ul><p>尝试编译出错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# g++  -std=c++11 main.cpp other.cpp -o  main.out</span><br><span class="line">  /tmp/cc2DsgGi.o:(.data+0x0): multiple definition of `a&#x27;</span><br><span class="line">/tmp/ccDlbvUg.o:(.data+0x0): first defined here</span><br></pre></td></tr></table></figure><blockquote><p>更糟糕的是，此时采用<code>ifndef</code>防止预编译重复定义没有用，更多<code>ifndef</code> 解释参考：<a href="http://c.biancheng.net/view/7636.html">C++防止头文件被重复引入的3种方法</a> 。</p><p>因为此时<code>main.cpp</code> 、<code>other.cpp</code> 是分别编译的，<code>main.cpp</code> 中的<code>define OTHER_H</code> 对<code>other.cpp</code> 不起作用。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*other.h*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OTHER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OTHER_H</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br></pre></td></tr></table></figure><p>为了避免这种问题，为了避免这种问题我们只有将头文件中变量声明为extern：</p>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a; </span><br></pre></td></tr></table></figure><p>再次编译正常：</p>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]<span class="meta"># g++  -std=c++11 main.cpp other.cpp -o  main.out</span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code> 和 <code>other.cpp</code> 都是拥有<code>a</code>的声明，声明可以多次。</p></blockquote></li><li><p><strong>定义（一般在<code>.cpp</code>文件中</strong>）：要在定义的地方为其<u>分配存储空间</u>，相同变量可以在多处声明（外部变量extern），但只能在一处定义。</p></li></ul>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a; <span class="comment">// 声明也是定义，编译器默认初始化</span></span><br></pre></td></tr></table></figure><p><strong>如果是函数</strong>。</p><ul><li><p><strong>声明（一般在<code>.h</code>文件中</strong>）：把函数的位置、参数和返回类型等信息告诉编译器；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><p>函数定义不会被默认初始化，故无需extern。</p></li><li><p><strong>定义（一般在<code>.cpp</code>文件中</strong>）：在源文件中实现具体函数，<u>并为其分配内存</u>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="最佳实践：头文件里应该放什么？">最佳实践：头文件里应该放什么？</h5><blockquote><p>参考：<a href="https://github.com/chenshuo/muduo/blob/master/muduo">muduo</a> 中做法。</p></blockquote><p>在头文件<code>test.h</code>中：</p><ul><li><p><strong>全局变量</strong>：注意用extern关键字修饰，只声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure></li><li><p><strong>函数</strong>：只声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><p>如果是内联函数可直接定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内联函数会被直接替换，不用担心重复定义的问题。</p></li><li><p><strong>结构体</strong>：声明+定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isOK;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于结构体已经被定义，如果有多个<code>.cpp</code> 文件 include了<code>test.h</code> 容易出现重复定义。这也是为什么开源文件中往往在<code>.h</code> 文件中使用<a href="http://c.biancheng.net/view/7636.html">#ifndef</a> 避免头文件被重复引入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> XXX_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XXX_H</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isOK;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>类</strong>：类声明+定义，内部成员只声明。</p><p>同上，需注意使用<a href="http://c.biancheng.net/view/7636.html">#ifndef</a> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>普通成员函数（普通构造函数或析构函数、访问函数等）建议在类中（头文件）定义；重要的成员函数应在与类同名的 .cpp 文件中定义。</p></li><li><p><strong>其它</strong>：define宏定义。</p></li></ul><p>在源文件<code>test.cpp</code>中：</p><p>实现<code>test.h</code>相关定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;  <span class="comment">// 定义变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>  <span class="comment">// 定义函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体成员</span></span><br><span class="line"><span class="comment">// 不用，直接使用即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类成员（往往是重要的类成员函数）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyClass::get_value</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认初始化">默认初始化</h5><p>变量值声明时的初始化值不仅和<strong>变量的类型</strong>有关系，也和<strong>变量声明的位置</strong>有关系：</p><ul><li><p><strong>对于内置类型变量</strong>（如 <code>int</code> ，<code>double</code>，<code>bool</code>等）</p><ul><li>函数体之<strong>外</strong>的变量：会进行&quot;零值初始化&quot; ；</li><li>函数体之<strong>内</strong>的变量：此时该变量是<strong>未定义值</strong>，在一些IDE中如VS2017使用会报错；在一些编译器中如VSCode2020可以被使用，<strong>部分会被初始化，部分指向内存中“野值”</strong>；</li><li><strong>静态变量</strong>（包括局部静态变量）：进行&quot;零值初始化&quot;。</li></ul></li><li><p><strong>对于类成员变量（Class</strong>）：</p><ul><li><p><strong>原生类型</strong>：int类型或者指针类型等，他们<strong>不会被初始化</strong>。但是，他们会使用类实例内存地址中任何已经存在的<strong>野值</strong>作为自己的值；</p><ul><li><strong>对象类型</strong>：如string类型，<strong>默认构造器</strong>会被调用初始化为空串<code>&quot;&quot;</code>；</li></ul></li><li><p><strong>引用类型</strong>：无法通过编译。</p></li></ul></li></ul><p>对于以上描述我们进行实例验证。</p><blockquote><p>【实例】不同情况初始化验证。</p></blockquote><p>我们先给出各种情况下总结，具有验证请查看下方代码。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">int/float/double</th><th style="text-align:center">bool</th><th style="text-align:center">string/char</th><th style="text-align:center">指针</th><th style="text-align:center">引用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>局部变量</strong></td><td style="text-align:center">野值</td><td style="text-align:center">0</td><td style="text-align:center"><code>&quot;&quot;</code>，<code>''</code></td><td style="text-align:center">野值</td><td style="text-align:center">出错</td></tr><tr><td style="text-align:center"><strong>全局变量/静态变量</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center"><code>&quot;&quot;</code>，<code>''</code></td><td style="text-align:center">0</td><td style="text-align:center">出错</td></tr><tr><td style="text-align:center"><strong>类成员</strong></td><td style="text-align:center">野值</td><td style="text-align:center">野值</td><td style="text-align:center"><code>&quot;&quot;</code>，野值</td><td style="text-align:center"><code>&quot;&quot;</code>/野值</td><td style="text-align:center">出错</td></tr></tbody></table><p>以下是实际代码验证。</p><div class="tabs" id="markdown"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#markdown-1">函数体外变量</button></li><li class="tab"><button type="button" data-href="#markdown-2">函数体内变量</button></li><li class="tab"><button type="button" data-href="#markdown-3">静态变量</button></li><li class="tab"><button type="button" data-href="#markdown-4">类成员变量</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="markdown-1"><ul><li><p>函数体外变量</p><p>可以看到，函数体外的所有变量（全局变量）都已经被<strong>零值初始化</strong>：整数/浮点类型/指针初始化为0；字符串类型被初始化空串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.数值类型</span></span><br><span class="line"><span class="keyword">int</span> num;  <span class="comment">// 0       </span></span><br><span class="line"><span class="keyword">float</span> f;  <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">double</span> d; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.bool 类型</span></span><br><span class="line"><span class="keyword">bool</span> b;   <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.字符串类型</span></span><br><span class="line">string str;  <span class="comment">// &quot;&quot; </span></span><br><span class="line"><span class="keyword">char</span> c;      <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.指针: 零值</span></span><br><span class="line"><span class="comment">// 旧版本C++, 0 成为指示无效内存位置值</span></span><br><span class="line">string *str_ptr; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">int</span> *ptr;        <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.引用：出错</span></span><br><span class="line">string &amp;str_ref; <span class="comment">//  error: not initialized</span></span><br><span class="line"><span class="keyword">int</span> &amp;int_ref;    <span class="comment">// error: not initialized</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 打印测试代码略</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-2"><ul><li><p>函数体内变量</p><p>VSCode（g++ 4.6+）中给<strong>部分局部变量进行了“初始化”</strong>，直接使用并未报错。但是，<strong>浮点类型和指针的值都指向了野值</strong>。</p><p>函数体内变量变量不初始化，是个危险且错误的编程行为，使得代码很难调试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.数值类型</span></span><br><span class="line">    <span class="keyword">int</span> num;  <span class="comment">// 野值：9.88131e-324     </span></span><br><span class="line">    <span class="keyword">float</span> f;  <span class="comment">// 野值：5.88128e-39</span></span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">// 野值：2.07385e-317</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.bool 类型</span></span><br><span class="line">    <span class="keyword">bool</span> b;   <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// 3.字符串类型</span></span><br><span class="line">    string str;  <span class="comment">// &quot;&quot; </span></span><br><span class="line">    <span class="keyword">char</span> c;      <span class="comment">// &#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.指针: 零值</span></span><br><span class="line">    <span class="comment">// 指针指向内存中随机地址值，这非常危险</span></span><br><span class="line">    string *str_ptr; <span class="comment">// 0x400a10</span></span><br><span class="line">    <span class="keyword">int</span> *ptr;        <span class="comment">// 0x400be0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.引用：出错</span></span><br><span class="line">    string &amp;str_ref; <span class="comment">//  error: not initialized</span></span><br><span class="line">    <span class="keyword">int</span> &amp;int_ref;    <span class="comment">//  error: not initialized</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打印测试代码略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-3"><ul><li><p>静态变量</p><p>特别的，静态变量不论是<strong>局部静态变量还是全局静态变量都会进行零值初始化</strong>。初始化规则同全局变量。</p><blockquote><p>❓ 局部静态变量，每次进入函数都会被初始化吗？</p></blockquote><p>静态局部变量和全局变量一样，数据都存放在全局区域，所以<strong>在主程序main执行之前</strong>，编译器已经为其分配好了内存，即<strong>只会被初始化一次</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_calls</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 主程序执行就已被初始化</span></span><br><span class="line">    <span class="comment">// 后续进入函数不会再执行初始化变为0</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ctr;     <span class="comment">// 默认初始化为 0</span></span><br><span class="line">    <span class="keyword">return</span> ++ctr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段程序将输出从 1 到 10 的数字。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">count_calls</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-4"><ul><li><p>类成员变量</p><p>可以看到，类成员变量值如果不给定初始化：<strong>基本类型变量指向野值；引用类型会非法警告</strong>。</p><p>但是，<strong>对象类型</strong>string会被“零值初始化”（<code>空串</code>）。这是因为string类型的默认构造函数被调用，而string的默认构造会将string类型值初始化为<code>空串</code>。</p><p>显然，类成员变量最好在使用前进行初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 1.数值类型</span></span><br><span class="line">    <span class="keyword">int</span> num;   <span class="comment">// 野值：1760379232    </span></span><br><span class="line">    <span class="keyword">float</span>  f;  <span class="comment">// 野值：4.59149e-41</span></span><br><span class="line">    <span class="keyword">double</span> d;  <span class="comment">// 野值：4.59149e-41</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.bool 类型</span></span><br><span class="line">    <span class="keyword">bool</span> b ;   <span class="comment">// 野值：2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.字符串类型</span></span><br><span class="line">    string str;  <span class="comment">// &quot;&quot; 空,对象类型，会调用string构造函数初始化，所以是&quot;&quot;</span></span><br><span class="line">    <span class="keyword">char</span> c;      <span class="comment">// 野值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.指针</span></span><br><span class="line">    <span class="comment">// 指针指向内存中随机地址值，这非常危险</span></span><br><span class="line">    string *str_ptr; <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">int</span> *ptr;        <span class="comment">// 0x400d00</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.引用：出错</span></span><br><span class="line">    string &amp;str_ref; <span class="comment">// not initialized</span></span><br><span class="line">    <span class="keyword">int</span> &amp;int_ref;    <span class="comment">// not initialized</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// 默认构造函数：不做任何操作</span></span><br><span class="line">    <span class="built_in">test</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test t;</span><br><span class="line">    <span class="comment">// 打印测试代码略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-3-关键字">1.3 关键字</h3><p>在前面的例子，多次见到的<strong>extern关键字</strong>是什么意思呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> c, ch;</span><br></pre></td></tr></table></figure><p>在这之前，我们先简单介绍一下什么是关键字，有个整体的概念和了解。</p><p>关键字是<strong>预定义的</strong>单词，对编译器具有特殊的含义。例如，前面我们看到的<code>int</code>、<code>float</code>等基本变量类型也是关键字的一部分。</p><p>下表列出了 C++ 中的关键字。这些关键字不能作为常量名、变量名或其他标识符名称。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/C-Tutorial-Edureka-Keywords-of-C-Program.png" alt="C++ Tutorial | Learn C++ | C++ Programming Language | Edureka"></p><p>本节主要介绍存储类相关关键字。</p><p>存储类定义 C++ 程序中<strong>变量/函数的范围（可见性）和生命周期</strong>，这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p><ul><li>extern</li><li>static</li><li>mutable</li><li>thread_local (C++11)</li></ul><p>特别的，从 C++ 11 开始，auto 关键字不再是 存储类说明符，但auto是c++11中非常优雅的关键字。为了更好的说明它的作用，在<u>3.X节</u>中会正式提到它。</p><h4 id="1-3-1-extern关键字">1.3.1 extern关键字</h4><blockquote><p><code>extern</code>顾名思义，外面的、外来的。</p></blockquote><p>extern 可以置于变量或者函数前，扩展变量/函数的定义域：</p><ol><li>第一种情况，首先将声明的变量/函数作用域，从声明扩展到本文件结束；如果依旧未找到定义转情况二。</li><li>第二种情况，声明变量/函数定义在其它文件中，<u>在链接时</u>会在<u>其它文件</u>寻找其定义（这样在<u>编译时</u>，本文件未找定义也不报错）。</li></ol><p>分别举两个例子说明两种情况。</p><h5 id="第一种情况，变量在本文件定义">第一种情况，变量在本文件定义</h5><blockquote><p>【例1】变量声明后不想立即初始化，在调用后才会进行初始化。如何在调用时就获取正确的值？</p></blockquote><p>使用 <code>extern</code> 关键字对变量<code>c</code>, <code>ch</code> 作“外部变量声明”，使<strong>作用域扩展到从声明开始到本文件结束</strong> ，这样编译器就会<u>在本文件其它区域寻找其定义</u>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 作用域扩展到文件结尾</span></span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">char</span> c, ch;  </span><br><span class="line">   cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;ch&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正定义的地方</span></span><br><span class="line"><span class="keyword">char</span> c=<span class="string">&#x27;h&#x27;</span>, ch=<span class="string">&#x27;H&#x27;</span>;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# g++  -std=c++11 main.cpp other.cpp -o  main.out</span><br><span class="line">[root@roy-cpp test]# ./main.out </span><br><span class="line">h</span><br><span class="line">H</span><br></pre></td></tr></table></figure><p>而如果没有使用extern关键字，输出为空（默认初始化的值）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>如果本文件没找到定义，extern还会去其它文件中寻找定义。</p><h5 id="第二种情况，变量在其它文件定义">第二种情况，变量在其它文件定义</h5><p><strong><code>c, ch</code>是在别的文件中声明</strong></p><blockquote><p>【例2】变量<code>c</code>, <code>ch</code> 是在<u>别的.cpp文件</u>中声明的，但又需要在 main 函数中调用它们（<u>引入头文件中也没有它们的定义</u>）。</p></blockquote><p>使用extern关键字声明即可解决，这样编译阶段不会出错，链接时会去寻找它们的定义（如果extern修饰函数/类等效果等同前向声明，3.1.1节）。</p><ul><li><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明外部变量，头文件中也没有c,ch的定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> c, ch;     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;ch&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>other.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c=<span class="string">&#x27;h&#x27;</span>, ch=<span class="string">&#x27;H&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><p>没使用extern关键字声明编译会出错，使用后编译正常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 main.cpp other.cpp -o main.out</span><br><span class="line">./main.out</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h</span><br><span class="line">H</span><br></pre></td></tr></table></figure><p>不过这个做法有点刻意，根据我们之前的最佳实践，声明和定义最好分开。变量<code>c</code>, <code>ch</code> 应该声明在<u>.h文件</u>中。</p><p><strong>此时<code>extern</code>关键字的作用是告诉编译器， <code>other.h</code> 变量<code>a</code>定义在别处/文件中</strong>。</p><ul><li><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;other.h&quot;</span>  <span class="comment">// 引入头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;ch&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>other.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> c, ch; <span class="comment">// 只声明</span></span><br></pre></td></tr></table></figure></li><li><p>other.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c=<span class="string">&#x27;h&#x27;</span>, ch=<span class="string">&#x27;H&#x27;</span>;  <span class="comment">// 实际定义</span></span><br></pre></td></tr></table></figure></li></ul><p>编译正常：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]<span class="meta"># g++  -std=c++11 main.cpp other.cpp -o  main.out</span></span><br><span class="line"> h</span><br><span class="line"> H</span><br></pre></td></tr></table></figure><h5 id="最佳实践：什么时候使用extern和头文件">最佳实践：什么时候使用extern和头文件</h5><p><strong>引入头文件就可以使用在其它文件的变量/函数/类，为什么还需要extern</strong>？</p><ol><li><p><strong>extern将声明、定义分离</strong>。extern可以用于头文件把全局变量的声明和定义分离，避免重复定义；</p></li><li><p><strong>只需要使用个别其它文件的变量/函数等</strong>。有时候我们只想使用头文件定义的个别变量/函数，但是这样不得不引入<u>头文件所有的相关变量/函数等声明</u>。在大项目编译中，过度使用头文件会让编译速度显著变慢。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220121152903021.png" alt="image-20220121152903021"></p><p>这里我们<u>没有include “other.h”</u> , 因为我们只需要它的<code>Max</code> 函数，使用extern关键字即可。</p></li><li><p><strong>C++和C代码混编时</strong>。 下节说明。</p></li></ol><h5 id="extern-“C”">extern “C”</h5><p>extern关键字还可用于extern “C”，使得C和C++混编不会出错，它有两层含义：</p><ol><li><strong>声明的变量是extern的</strong>，它只是在这里声明，定义在别的地方；</li><li><strong>声明的变量按C方式进行编译</strong>。</li></ol><p>第2点是本节的核心内容。</p><blockquote><p>⚠️ 以下情况仅在用gcc编译代码时出现，g++编译不会出错（节末解释）。</p></blockquote><p>准备三个文件：a.c、a.h、main.cpp ，在<strong>main.cpp</strong>中调用<strong>a.c</strong>中的函数<code>printHello</code> 。</p><p>尝试gcc编译：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220121172211779.png" alt="image-20220121172211779"></p><p>很不幸报错了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.cpp:(.text+<span class="number">0x5</span>): undefined reference to `<span class="built_in">printHello</span>()&#x27;</span><br></pre></td></tr></table></figure><p>链接过程中找不到符号 <code>printHello</code> ，为什么会这样？</p><p><strong>这是因为<code>gcc</code> 对 cpp和c代码变量的符号处理不同导致的</strong>。</p><p>我们知道从代码到可执行程序需要经过，预编译→编译→汇编→链接，其中编译和链接大致如下：</p><ul><li>编译：代码展开、语法检查，还包括<u>将变量转成符号</u>；</li><li>链接：将未定义的符号，<u>解析重定位到其定义实现的地方</u>。</li></ul><p>查看<code>a.o</code>链接前的符号表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test1]# gcc -c a.c -o a.o</span><br><span class="line">[root@roy-cpp test1]# nm a.o</span><br><span class="line">0000000000000000 T printHello</span><br><span class="line">                 U puts</span><br></pre></td></tr></table></figure><p><code>a.c</code> 编译后的符号名（<code>printHello</code>）和代码中的定义一样。</p><p>再查看<code>main.o</code>链接前的符号表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test1]# nm main.o</span><br><span class="line">0000000000000000 T main</span><br><span class="line">                 U _Z10printHellov</span><br></pre></td></tr></table></figure><p><code>main.cpp</code> 编译后<code>printHello</code>符号名变为<code>_Z10printHellov</code> ，这是什么鬼？</p><blockquote><p>对于C++代码：如果是数据变量并且没有嵌套，符号名也是本身；如果变量名有嵌套（在名称空间或类里）或者是函数名，符号名就会按如下规则来处理。</p><ol><li>符号以_Z开始；</li><li>如果有嵌套，后面紧跟N，然后是名称空间、类、函数的名字，名字前的数字是长度，以E结尾；</li><li>如果没嵌套，则直接是名字长度后面跟着名字；</li><li>最后是参数列表，<code>v</code> 表示<code>void</code>。</li></ol></blockquote><p>因为<code>main.cpp</code> 的符号<code>_Z10printHellov</code> 是未定义的，它需要解析重定位到定义的地方，也是<code>a.o</code> 中。但显然符号<code>_Z10printHellov</code> 和  <code>printHello</code> 不同，因此链接时在<code>a.o</code>找不到相关符号导致报错，无法正确重定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.cpp:(.text+0x5): undefined reference to `printHello()&#x27;</span><br></pre></td></tr></table></figure><p><strong>这个时候extern “C” 就派上用场了：在C++文件指定代码/头文件按C的方式进行编译</strong>。</p><p>将<code>a.h</code> 修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次查看<code>main.o</code> 符号表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test1]# gcc -c main.cpp -o main.o</span><br><span class="line">[root@roy-cpp test1]# nm main.o</span><br><span class="line">0000000000000000 T main</span><br><span class="line">                 U printHello</span><br></pre></td></tr></table></figure><p>一切正常。整个过程详细变化如下：</p><ol><li><p><code>gcc</code> 根据<code>main.cpp</code> 文件名后缀识别为cpp文件；</p></li><li><p>预编译：将<code>main.cpp</code> 中 <code>\#include &quot;a.h&quot;</code> 展开，因为cpp文件都会存在宏定义<code>__cplusplus</code>，所以<code>#ifdef __cplusplus</code> 成立。最终展开为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译：编译到 extern “C”{…} 中的变量<code>printHello</code> 按C方式编译成符号<code>printHello</code> 。</p></li></ol><p>再次尝试编译也确实正常输出了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test1]# gcc  main.cpp a.c -o main.out</span><br><span class="line">[root@roy-cpp test1]# ./main.out </span><br><span class="line">hello C ! </span><br></pre></td></tr></table></figure><p><strong>但是g++编译不使用extern “C”汇编C和C++代码也不会出错 ，因为g++将c或cpp代码都按cpp方式编译</strong>。</p><p>下面是测试。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220121175557825.png" alt="image-20220121175557825"></p><p>查看此时<code>a.c</code>编译后的<code>a.o</code> 符号表（cpp风格）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test1]<span class="comment"># g++ -c a.c -o a.o</span></span><br><span class="line">[root@roy-cpp test1]<span class="comment"># nm a.o</span></span><br><span class="line">                 U puts</span><br><span class="line">0000000000000000 T _Z10printHellov</span><br></pre></td></tr></table></figure><h4 id="1-3-2-static关键字">1.3.2  static关键字</h4><p>static关键字常于各种面试题、书籍中，<strong>为什么需要static关键字？为什么它如此重要</strong>？</p><p>我们从面向过程和面向角度两个角度分析。</p><h5 id="面向过程角度">面向过程角度</h5><p><strong>一、作用域隐藏。当一个工程有多个文件的时候，用static修饰的函数或变量只能够在本文件中可见，文件外不可见</strong>。</p><blockquote><p><strong>对比全局变量/函数</strong>：全局变量/函数访问具有全局性，<u>其它文件</u>通过<strong>extern关键字或引用头文件</strong>，是可以使用<u>本文件</u>中定义的全局变量/函数。</p></blockquote><p>但有时我们并不希望这样，因为这暴露了我们不想暴露的变量/函数，这个时候static可以更好的限定作用范围。</p><p>由此还引申另外一个好处：不同的人编写不同的函数时，<strong>不用担心是否会与其它文件中的函数同名</strong>，因为同名也没有关系（限定作用范围在本文件内）。</p><p>下面我们通过两个小例子来理解。</p><p><strong>例子1：静态变量</strong></p><p>可以看到，静态static变量即使被extern关键字修饰，依旧不能被其它文件引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*other.cpp*/</span></span><br><span class="line"><span class="keyword">int</span> global_var = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*main.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> global_var;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> staic_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 编译正确，other.cpp中的global_var被正确打印输出</span></span><br><span class="line">    cout&lt;&lt;global_var&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译错误，undefined reference to `staic_var&#x27;</span></span><br><span class="line">    cout&lt;&lt;staic_var&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子2：静态函数</strong></p><p>将静态函数<code>static_func</code> 定义在<code>other.h</code> （实现在<code>other.cpp</code>），无法通过编译：<em>undefined reference to static_func</em>()。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*other.h*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">static_func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">global_func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*other.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">static_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;i am static_func in other.cpp&quot;</span>&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">global_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;i am global_func in other.cpp&quot;</span>&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*main.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;other.h&quot;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 出错：undefined reference to &#x27;static_func()&#x27;</span></span><br><span class="line">    <span class="built_in">global_func</span>();</span><br><span class="line">    <span class="built_in">static_func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试编译出错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 main.cpp other.cpp -o main.out</span><br></pre></td></tr></table></figure><p><strong>但如果我们不使用头文件，<code>static_func</code>可以被成功使用</strong>？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*other.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">static_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;i am static_func in other.cpp&quot;</span>&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">global_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;i am global_func in other.cpp&quot;</span>&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*main.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;other.cpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 均被正确执行了</span></span><br><span class="line">      <span class="built_in">global_func</span>();</span><br><span class="line">    <span class="built_in">static_func</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220121001648635.png" alt="image-20220121001648635"></p><p>这是因为此时<code>static_func</code> 已经被视为在同一个文件中。</p><p>注意到：</p><ol><li><p>头文件 <code>#include &quot;other.cpp&quot;</code> ，预编译时直接替换为 <code>other.cpp</code> 中内容， 相当直接在<code>main.cpp</code> <u>定义</u>了<code>static_func</code> 。同一个文件中调用静态函数<code>static_func</code>自然是可以的。</p><p>预编译后的文件如下所示。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220121002134540.png" alt="image-20220121002134540"></p><p>而之前生成的预编译文件是不会包含静态函数的定义（只有头文件<code>other.h</code>中的静态函数声明），所以实际定义还是在别的文件（<code>other.cpp</code>）中，因此调用时会出错。</p></li><li><p>所以我们在g++编译时都不用把<code>other.cpp</code>作为源文件（预编译时已经替换了）。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220121002353063.png" alt="image-20220121002353063"></p></li></ol><p><strong>二、全局生命周期。用static修饰的变量或函数生命周期是全局的（即使是局部静态变量），存储在静态数据区（全局数据区）。 即在main函数执行前就会被初始化</strong>。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/memory.png" alt="memory" style="zoom:67%;" /><p>我们举两个实例，来更好的理解“全局生命周期”这个概念。</p><ul><li><p>例1，在<code>normal_add</code>函数中定义了局部变量<code>count</code> ，每次函数退出，count也随之销毁。所以每次打印的都是进入函数初始化后的值+1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i ;    <span class="comment">// 全局访问性，全局生命周期 </span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">normal_add</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// 局部访问性，局部访问周期</span></span><br><span class="line">      <span class="keyword">return</span> ++count;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">3</span> ; j++)</span><br><span class="line">        cout&lt;&lt; <span class="built_in">normal_add</span>()&lt;&lt;endl;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211224205831812.png" alt="image-20211224205831812"></p></li><li><p>例2，在<code>static_add</code> 中定义了局部静态变量<code>count</code> 。<strong>它只会被初始化一次（内存只被分配一次，见下例解释），随着函数退出也不销毁</strong>，保持最新的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i ;    <span class="comment">// 全局访问性，全局生命周期 </span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">static_add</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// 局部访问性，局部访问周期</span></span><br><span class="line">      <span class="keyword">return</span> ++count;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     <span class="comment">// 虽然多次（3次）进入了函数static_add</span></span><br><span class="line">     <span class="comment">// 但count只在第一次进入函数被初始化了一次</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">3</span> ; j++)</span><br><span class="line">        cout&lt;&lt; <span class="built_in">static_add</span>()&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211224205850147.png" alt="image-20211224205850147"></p></li></ul><p><strong>三、初始化零值</strong>。</p><p>static修饰的（局部/全局）变量和全局变量一样，不显示定义时会进行零值初始化。</p><h5 id="面向对象角度">面向对象角度</h5><p><strong>一、类只拷贝一份。类中static修饰的静态数据成员或静态成员函数是属于类的，所有对象只有一份拷贝，因此它的值可以被所有对象更新，在类未实例化就可以使用</strong>。</p><p>特别的， <strong>static类对象必须要在类外进行初始化</strong>，因为static修饰的变量先于对象存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> test::i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> test::j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.类未实例化就可以被使用</span></span><br><span class="line">    <span class="comment">// 2.static 像普通类成员可以被修饰为private</span></span><br><span class="line">    <span class="comment">// test::i = 1;  // 访问错误，私有静态变量</span></span><br><span class="line">    test::j = <span class="number">1</span>;     <span class="comment">// 访问正确，公有静态变量</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 3.所有对象只有一份拷贝，更新的同一块存储区域</span></span><br><span class="line">    <span class="comment">//   但如果是普通类数据成员，下面输出都是1。</span></span><br><span class="line">    test a, b ,c ;</span><br><span class="line">    cout&lt;&lt;++a.j&lt;&lt;endl ;   <span class="comment">// 2</span></span><br><span class="line">    cout&lt;&lt;++b.j&lt;&lt;endl ;   <span class="comment">// 3</span></span><br><span class="line">    cout&lt;&lt;++c.j&lt;&lt;endl ;   <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种特性可以很好的实现类多个对象的变量共享。</p><p>在后面面对对象笔记中，有机会我们还会更深入探讨下static的用法，比如与虚函数的关系。</p><p>最后，总结下全局变量和静态变量。</p><p><strong>全局变量/函数和static变量/函数的区别</strong>？</p><ol><li><strong>存储方式</strong>。全局变量/函数和static变量/函数都是静态存储方式，存储在全局数据区。</li><li><strong>作用域</strong>。全局变量/函数是可见性全局性，其它文件中可通过extern关键字/引用头文件，来进行使用，但静态变量/函数只能在本类使用。</li><li><strong>初始化</strong>。staic变量/函数只被初始化一次，但全局变量则不然可以被初始化多次。</li><li><strong>面对对象</strong>。类静态成员、函数只被拷贝一份，为全对象共享。</li></ol><h3 id="1-4-常量">1.4 常量</h3><p>在前面我们认识的“变量”，即意为“变化可被修改的值”，灵活性强。</p><p>在C++中还存在“常量”，即“不希望被修改的值”，定义以后无法被修改。</p><p>如何定义一个常量？</p><h4 id="1-4-1-定义常量">1.4.1 定义常量</h4><blockquote><p>🖋 把常量定义为大写字母形式，是非常好的编程实践。</p></blockquote><p>在 C++ 中，有两种简单的定义常量的方式：</p><ul><li><p>使用 <strong>#define</strong> 预处理器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME value</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <strong>const</strong> 关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> type  NAME = value;</span><br></pre></td></tr></table></figure></li></ul><p>以下是更多的实例（以const关键字定义为例）。请注意不同数据类型常量定义的区别。</p><h4 id="1-4-2-常量类型">1.4.2 常量类型</h4><ul><li><p><strong>整数常量</strong></p><p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</p><p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> VALUE = <span class="number">123</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> VALUE = <span class="number">123L</span>;   <span class="comment">// 自动转换为long类型</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> VALUE = <span class="number">123u</span>;   <span class="comment">// 自动转换为unsiged int类型</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> VALUE = <span class="number">0x123</span>;  <span class="comment">// 16进制</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> VALUE = <span class="number">0123</span>;   <span class="comment">// 8进制</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>浮点常量</strong></p><p>浮点常量由整数部分、小数点、小数部分和指数部分组成。</p><p>以下仅给出关键代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> VALUE = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> VALUE = <span class="number">314159e-5</span>;  <span class="comment">// 使用科学计数法</span></span><br></pre></td></tr></table></figure></li><li><p><strong>布尔常量</strong></p><p>布尔常量共有两个，即<strong>true和false</strong>。</p><p>以下仅给出关键代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> VALUE = <span class="literal">true</span>;   </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> VALUE = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>我们不应把 true 的值看成 1，把 false 的值看成 0。即如下定义通常不建议进行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不建议的做法</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> VALUE = <span class="number">1</span>;   </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> VALUE = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>字符常量</strong></p><p>字符常量是<strong>括在单引号中</strong>。</p><p>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\t’），或一个通用的字符（例如 ‘\u02C0’）。</p><p>以下给出关键代码进行示例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> VALUE = <span class="string">&#x27;X&#x27;</span>;        <span class="comment">// 普通字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> VALUE = <span class="string">&#x27;\n&#x27;</span>;       <span class="comment">// 转义字符，即换行符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> VALUE = <span class="string">&#x27;\u02C0&#x27;</span>;   <span class="comment">// 通用字符，打印输出</span></span><br></pre></td></tr></table></figure></li><li><p><strong>字符串常量</strong></p><p>字符串字面值或常量是括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string VALUE = <span class="string">&quot;\n&quot;</span>;       <span class="comment">// 转义字符，即换行符</span></span><br><span class="line"><span class="keyword">const</span> string VALUE = <span class="string">&quot;\u02C0&quot;</span>;   <span class="comment">// 通用字符，打印输出</span></span><br><span class="line"><span class="keyword">const</span> string VALUE = <span class="string">&quot;hello world&quot;</span>;   </span><br></pre></td></tr></table></figure></li></ul><h4 id="1-4-3-const-和constexpr">1.4.3 const 和constexpr</h4><p>C++11 引入了一个关键字<strong>常量表达式<code>constexpr</code>，它确保变量必须在<u>编译时</u>被初始化，而<code>const</code>修饰的变量可以在<u>编译时</u>或<u>运行时</u>被初始化</strong>。</p><p>换句话说，<code>constexpr</code> 语义才是真正意义上的常量，运行时不能初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> j = i + <span class="number">1</span>; <span class="comment">// ok，const修饰的值在运行时被初始化</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> j = i + <span class="number">1</span>; <span class="comment">// error，运行时无法初始化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码编译出错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp <span class="built_in">test</span>]<span class="comment"># g++ -std=c++11 test.cpp -o test.out</span></span><br><span class="line">test.cpp: In <span class="keyword">function</span> ‘int main()’:</span><br><span class="line">test.cpp:1817:25: error: the value of ‘i’ is not usable <span class="keyword">in</span> a constant expression</span><br><span class="line">     constexpr int j = i+1;</span><br></pre></td></tr></table></figure><p><strong><code>constexpr</code>有什么好处</strong>？</p><p><code>constexpr</code> 可以显示地告诉编译器<u>表示式是确定值且可以被优化</u>，<code>const</code> 修饰的编译器只能<u>隐式跟踪是运行时常量还是编译时常量</u>。</p><p>比如上述代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 修改为常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = i + <span class="number">1</span>; <span class="comment">// ok，const修饰的值在运行时被初始化</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> j = i + <span class="number">1</span>; <span class="comment">// ok，在编译时这行代码被优化</span></span><br></pre></td></tr></table></figure><p>由于<code>i</code>也是常量，表达式<code>int j = i + 1</code>显然也一定会是常量。我们由此可以显示声明为<code>constexpr</code>，这样表达式会被编译器大胆地在编译期进行优化，提高编译速度。</p><p><u>在对性能要求苛刻的高并发场景</u>，<code>constexpr</code>是个不错的选择。</p><h4 id="1-4-4-define-const-函数-🌟">1.4.4 define &amp; const &amp; 函数 🌟</h4><p><strong>define宏定义和const的区别</strong>？</p><ul><li><strong>文本替换</strong>：define是在编译的<strong>预处理</strong>阶段起作用，属于文本插入替换；而const是在<strong>编译、运行</strong>的时候起作用；</li><li><strong>类型检查</strong>：define只做替换，不做类型检查和计算，也不求解，容易产生错误；const常量有数据类型，编译器可以对其进行类型安全检查；</li><li><strong>内存占用</strong>：define只是将宏名称进行替换，在内存中会产生多分<strong>相同的备份</strong>。const在程序运行中<strong>只有一份备份</strong>，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表；</li><li><strong>空间分配</strong>：宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。</li></ul><p><strong>define宏定义和函数的区别</strong>？</p><ul><li><p><strong>文本替换</strong>：define是在编译的<strong>预处理</strong>阶段起作用，属于文本插入替换；函数调用在运行时需要跳转到具体调用函数；</p></li><li><p><strong>类型检查</strong>：define只做替换，不做类型检查和计算，也不求解，容易产生错误；函数参数具有类型，需要检查类型；</p></li><li><p><strong>其它</strong>：函数有返回值，在最后不用加分号。</p></li></ul><h3 id="1-5-运算符">1.5 运算符</h3><p>运算符是一种告诉编译器<strong>执行特定的数学或逻辑操作</strong>的符号。</p><p>除了常见的：<strong>算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符</strong>外，我们先来看看其它的一些重要运算符。</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">描述</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><code>sizeof</code></td><td style="text-align:center">sizeof 运算符一个对象或类型所占的内存字节数。</td><td style="text-align:center">重要，4.1.3节给出具体示例</td></tr><tr><td style="text-align:center"><code>Condition ? X : Y</code></td><td style="text-align:center">条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>.</code>、  <code>-&gt;</code></td><td style="text-align:center">成员运算符用于引用类、结构和共用体的成员。</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>Cast</code></td><td style="text-align:center">强制转换运算符把一种数据类型转换为另一种数据类型。</td><td style="text-align:center">4.X节详述</td></tr><tr><td style="text-align:center"><code>&amp;</code></td><td style="text-align:center">取地址运算符 <code>&amp;</code> ，可获取变量的地址。例如 ，<code>int var =3; int *ptr=&amp;var</code>，获取变量<code>var</code>的地址。</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>*</code></td><td style="text-align:center">间接寻址运算符 <code>*</code>， 获取指定地址的变量的值。例如，<code>int val = *ptr</code> ,此时var=3。</td><td style="text-align:center"></td></tr></tbody></table><h4 id="1-5-1-运算符汇总">1.5.1 运算符汇总</h4><blockquote><p>该小节详细列出各类运算符，仅为查表用。读者可略过。</p></blockquote><p>非特别说明，下例中假设变量 A 的值为 10，变量 B 的值为 20。</p><div class="tabs" id="markdown"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#markdown-1">算术运算符</button></li><li class="tab"><button type="button" data-href="#markdown-2">关系运算符</button></li><li class="tab"><button type="button" data-href="#markdown-3">逻辑运算符</button></li><li class="tab"><button type="button" data-href="#markdown-4">位运算符</button></li><li class="tab"><button type="button" data-href="#markdown-5">赋值运算符</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="markdown-1"><ul><li><p><strong>算术运算符</strong></p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">描述</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">把两个操作数相加</td><td style="text-align:center">A + B 将得到 30</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">从第一个操作数中减去第二个操作数</td><td style="text-align:center">A - B 将得到 -10</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">把两个操作数相乘</td><td style="text-align:center">A * B 将得到 200</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">分子除以分母</td><td style="text-align:center">B / A 将得到 2</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">取模运算符，整除后的余数</td><td style="text-align:center">B % A 将得到 0</td></tr><tr><td style="text-align:center">++</td><td style="text-align:center">自增运算符，整数值增加 1</td><td style="text-align:center">A++ 将得到 11</td></tr><tr><td style="text-align:center">–</td><td style="text-align:center">自减运算符，整数值减少 1</td><td style="text-align:center">A-- 将得到 9</td></tr></tbody></table></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-2"><ul><li><p><strong>关系运算符</strong></p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">描述</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center">==</td><td style="text-align:center">检查两个操作数的值是否相等，如果相等则条件为真。</td><td style="text-align:center">(A == B) 不为真。</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">检查两个操作数的值是否相等，如果不相等则条件为真。</td><td style="text-align:center">(A != B) 为真。</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td><td style="text-align:center">(A &gt; B) 不为真。</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td><td style="text-align:center">(A &lt; B) 为真。</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td><td style="text-align:center">(A &gt;= B) 不为真。</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td><td style="text-align:center">(A &lt;= B) 为真。</td></tr></tbody></table></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-3"><ul><li><p><strong>逻辑运算符</strong></p><p>假设变量 A 的值为 1，变量 B 的值为 0。</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">描述</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td><td style="text-align:center">(A &amp;&amp; B) 为假。</td></tr><tr><td style="text-align:center">||</td><td style="text-align:center">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td><td style="text-align:center">(A || B) 为真。</td></tr><tr><td style="text-align:center">!</td><td style="text-align:center">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td><td style="text-align:center">!(A &amp;&amp; B) 为真。</td></tr></tbody></table></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-4"><ul><li><p><strong>位运算符</strong></p><table><thead><tr><th style="text-align:center">p</th><th style="text-align:center">q</th><th style="text-align:center">p &amp; q</th><th style="text-align:center">p | q</th><th style="text-align:center">p ^ q</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-5"><ul><li><p><strong>赋值运算符</strong></p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">描述</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:center">简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td style="text-align:center">C = A + B 将把 A + B 的值赋给 C</td></tr><tr><td style="text-align:center">+=</td><td style="text-align:center">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td style="text-align:center">C += A 相当于 C = C + A</td></tr><tr><td style="text-align:center">-=</td><td style="text-align:center">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td style="text-align:center">C -= A 相当于 C = C - A</td></tr><tr><td style="text-align:center">*=</td><td style="text-align:center">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td style="text-align:center">C *= A 相当于 C = C * A</td></tr><tr><td style="text-align:center">/=</td><td style="text-align:center">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td style="text-align:center">C /= A 相当于 C = C / A</td></tr><tr><td style="text-align:center">%=</td><td style="text-align:center">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td><td style="text-align:center">C %= A 相当于 C = C % A</td></tr><tr><td style="text-align:center">&lt;&lt;=</td><td style="text-align:center">左移且赋值运算符</td><td style="text-align:center">C &lt;&lt;= 2 等同于  C = C &lt;&lt; 2</td></tr><tr><td style="text-align:center">&gt;&gt;=</td><td style="text-align:center">右移且赋值运算符</td><td style="text-align:center">C &gt;&gt;= 2 等同于  C = C &gt;&gt; 2</td></tr><tr><td style="text-align:center">&amp;=</td><td style="text-align:center">按位与且赋值运算符</td><td style="text-align:center">C &amp;= 2 等同于  C = C &amp; 2</td></tr><tr><td style="text-align:center">^=</td><td style="text-align:center">按位异或且赋值运算符</td><td style="text-align:center">C ^= 2 等同于  C = C ^ 2</td></tr><tr><td style="text-align:center">|=</td><td style="text-align:center">按位或且赋值运算符</td><td style="text-align:center">C |= 2 等同于  C = C | 2</td></tr></tbody></table></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="1-5-2-运算符优先级">1.5.2 运算符优先级</h4><p>不同运算符在编译时优先级是不同的。</p><ul><li>例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。</li></ul><p>列出所有优先级比较，供需要时查表所用。读者不应过分关注下面细节。</p><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">运算符</th><th style="text-align:center">结合性</th></tr></thead><tbody><tr><td style="text-align:center">后缀</td><td style="text-align:center">() [] -&gt; .  ++   - -</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">一元</td><td style="text-align:center">+  -   !  ~  ++  - -   (type)*  &amp;  sizeof</td><td style="text-align:center">从右到左</td></tr><tr><td style="text-align:center">乘除</td><td style="text-align:center">*  /  %</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">加减</td><td style="text-align:center">+  -</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">移位</td><td style="text-align:center">&lt;&lt; &gt;&gt;</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">关系</td><td style="text-align:center">&lt; &lt;=  &gt; &gt;=</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">相等</td><td style="text-align:center">==  !=</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">位与 AND</td><td style="text-align:center">&amp;</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">位异或 XOR</td><td style="text-align:center">^</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">位或 OR</td><td style="text-align:center">|</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">逻辑与 AND</td><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">逻辑或 OR</td><td style="text-align:center">||</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">条件</td><td style="text-align:center">?:</td><td style="text-align:center">从右到左</td></tr><tr><td style="text-align:center">赋值</td><td style="text-align:center">=  +=  -=  *=  /=  %=&gt;&gt;=  &lt;&lt;=  &amp;=  ^=   |=</td><td style="text-align:center">从右到左</td></tr><tr><td style="text-align:center">逗号</td><td style="text-align:center">,</td><td style="text-align:center">从左到右</td></tr></tbody></table><h3 id="1-6-循环">1.6 循环</h3><p>循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式：</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1472440363761312.png" alt="img" style="zoom: 80%;" /><h4 id="1-6-1-快速入门">1.6.1 快速入门</h4><p>C++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。</p><table><thead><tr><th style="text-align:center">循环类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://www.w3cschool.cn/cpp/cpp-while-loop.html">while 循环</a></td><td style="text-align:center">当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td></tr><tr><td style="text-align:center"><a href="https://www.w3cschool.cn/cpp/cpp-for-loop.html">for 循环</a></td><td style="text-align:center">多次执行一个语句序列，简化管理循环变量的代码。</td></tr><tr><td style="text-align:center"><a href="https://www.w3cschool.cn/cpp/cpp-do-while-loop.html">do…while 循环</a></td><td style="text-align:center">除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td></tr><tr><td style="text-align:center"><a href="https://www.w3cschool.cn/cpp/cpp-nested-loops.html">嵌套循环</a></td><td style="text-align:center">可以在 while、for 或 do…while 循环内使用一个或多个循环。</td></tr></tbody></table><p><strong>循环控制语句</strong>更改执行的正常序列。</p><table><thead><tr><th style="text-align:center">控制语句</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://www.w3cschool.cn/cpp/cpp-break-statement.html">break 语句</a></td><td style="text-align:center">终止 <strong>loop</strong> 或 <strong>switch</strong> 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。</td></tr><tr><td style="text-align:center"><a href="https://www.w3cschool.cn/cpp/cpp-continue-statement.html">continue 语句</a></td><td style="text-align:center">引起循环跳过主体的剩余部分，立即重新开始测试条件。</td></tr><tr><td style="text-align:center"><a href="https://www.w3cschool.cn/cpp/cpp-goto-statement.html">goto 语句</a></td><td style="text-align:center">将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td></tr></tbody></table><h4 id="1-6-2-循环判断">1.6.2 循环判断</h4><p>C++ 编程语言提供了以下类型的判断语句。</p><table><thead><tr><th style="text-align:center">语句</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">if 语句</td><td style="text-align:center">一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。</td></tr><tr><td style="text-align:center">if…else 语句</td><td style="text-align:center">一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。</td></tr><tr><td style="text-align:center">嵌套 if 语句</td><td style="text-align:center">您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。</td></tr><tr><td style="text-align:center">switch 语句</td><td style="text-align:center">一个 switch 语句允许测试一个变量等于多个值时的情况。</td></tr><tr><td style="text-align:center">嵌套 switch 语句</td><td style="text-align:center">您可以在一个 switch 语句内使用另一个 switch  语句。</td></tr></tbody></table><h4 id="1-6-3-运算符">1.6.3 ?: 运算符</h4><p>条件运算符在实际编码中，用来替代 <strong>if…else</strong> 语句。因为很多时候可以简化代码，用的比较多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exp1 ? Exp2 : Exp3;</span><br></pre></td></tr></table></figure><h4 id="1-6-4-无限循环">1.6.4 无限循环</h4><p>如果条件<strong>永远不为假或不存在时</strong>，则循环将变成无限循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This loop will run forever.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按 Ctrl + C 键可以终止一个无限循环。</p><h3 id="1-7-数组">1.7 数组</h3><p><strong>存储一个由相同类型元素构成的顺序集合，称之为数组</strong>。</p><h4 id="1-7-1-静态数组">1.7.1 静态数组</h4><p>静态数组<strong>声明且未初始化时必须确定数组大小</strong>，否则会报错。</p><ul><li>初始化：可以使用列表<code>&#123;...&#125;</code> 快速赋值，不可使用<code>new int[]&#123;...&#125;</code>赋值（这是指针分配空间的方式）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 静态数组</span></span><br><span class="line">    <span class="comment">// 一维</span></span><br><span class="line">    <span class="comment">// 【声明】</span></span><br><span class="line">    <span class="keyword">int</span> array1[LEN] ;  <span class="comment">// 未初始化，指定大小=3</span></span><br><span class="line">    <span class="comment">// 【赋值】</span></span><br><span class="line">    <span class="keyword">int</span> array2[]  = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">// 已初始化，编译器可推断大小=3</span></span><br><span class="line">    <span class="comment">// int array2[]  = new int[]&#123;1,2,3&#125;; // 出错，这是动态数组赋值的方式</span></span><br><span class="line">    <span class="keyword">int</span> array3[LEN]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;   <span class="comment">// C++11支持不用=号进行赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二维</span></span><br><span class="line">    <span class="comment">// 【声明】</span></span><br><span class="line">    <span class="keyword">int</span> array4[LEN][LEN];</span><br><span class="line">    <span class="comment">// 【赋值】</span></span><br><span class="line">    array4[LEN][LEN] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-7-2-动态数组">1.7.2 动态数组</h4><p>声明静态数组很简单，但很多时候我们更希望申请一个动态数组（比如声明时并不确定数组的内容）。</p><p>动态数组可以<strong>声明时不指定大小</strong> ，但是使用前一定要<strong>分配空间（可不初始化，会默认初始化）</strong>。</p><ul><li><p>初始化：可使用<code>new int[]&#123;...&#125;</code>赋值，不可以使用列表<code>&#123;...&#125;</code> 快速赋值</p></li><li><p>删除：注意是使用<code>delete[]</code> ，不是<code>delete</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.一维 </span></span><br><span class="line">    <span class="comment">// 【声明】</span></span><br><span class="line">    <span class="keyword">int</span>* array1;       <span class="comment">// 动态数组可不声明大小</span></span><br><span class="line">    <span class="comment">// array1[1] = 2;  // 编译出错，分配空间前就使用</span></span><br><span class="line">    <span class="keyword">int</span>* array2 = <span class="keyword">new</span> <span class="keyword">int</span>[LEN];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 【赋值】</span></span><br><span class="line">    <span class="comment">// C++11支持快速为动态数组赋值</span></span><br><span class="line">    <span class="comment">// 而不是C风格那样傻乎乎for循环挨个赋值</span></span><br><span class="line">    <span class="keyword">int</span>* array3 = <span class="keyword">new</span> <span class="keyword">int</span>[LEN]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">// 但下列这种静态数组赋值方式是错误的</span></span><br><span class="line">    <span class="comment">// int* array3 = &#123;1,2,3&#125;; //  编译出错，requires one element in initialize</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 【释放】</span></span><br><span class="line">    <span class="keyword">delete</span>[] array3;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.二维</span></span><br><span class="line">    <span class="comment">// 【声明】</span></span><br><span class="line">    <span class="keyword">int</span>** array4;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 【赋值】</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 不能用下面初始化方法</span></span><br><span class="line"><span class="comment">    int** array5 = new int[LEN] &#123;&#123;1,2,3&#125;,</span></span><br><span class="line"><span class="comment">                                &#123;4,5,6&#125;,</span></span><br><span class="line"><span class="comment">                                 &#123;7,8,9&#125;&#125;; ; </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>** array5 = <span class="keyword">new</span> <span class="keyword">int</span>*[LEN] &#123;  <span class="keyword">new</span> <span class="keyword">int</span>[LEN]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="keyword">int</span>[LEN]&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="keyword">int</span>[LEN]&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="keyword">int</span>** array5 = <span class="keyword">new</span> <span class="keyword">int</span>*[LEN];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN; i++)</span><br><span class="line">        array5[i] = <span class="keyword">new</span> <span class="keyword">int</span>[LEN]&#123;(i+<span class="number">1</span>)*<span class="number">1</span>,(i+<span class="number">2</span>)*<span class="number">1</span>,(i+<span class="number">3</span>)*<span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 【释放】</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LEN; i++)</span><br><span class="line">         <span class="keyword">delete</span>[] array5[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-7-3-数组默认初始化">1.7.3 数组默认初始化</h4><blockquote><p>在前面，我们了解到了局部变量/全局变量/静态变量/类成员的默认初始化值。数组的默认初始化值会什么呢？</p></blockquote><p>经过实验，数组默认初始化规则，<u>基本等同局部变量/全局变量/静态变量/类成员的规则</u>。<strong>只不过数组是以集合形式出现的</strong>。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">int/float/double</th><th style="text-align:center">bool</th><th style="text-align:center">string/char</th><th style="text-align:center">指针</th><th style="text-align:center">引用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>局部变量</strong></td><td style="text-align:center">野值</td><td style="text-align:center">0</td><td style="text-align:center"><code>&quot;&quot;</code>，<code>''</code></td><td style="text-align:center">野值</td><td style="text-align:center">出错</td></tr><tr><td style="text-align:center"><strong>全局变量/静态变量</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center"><code>&quot;&quot;</code>，<code>''</code></td><td style="text-align:center">0</td><td style="text-align:center">出错</td></tr><tr><td style="text-align:center"><strong>类成员</strong></td><td style="text-align:center">野值</td><td style="text-align:center">野值</td><td style="text-align:center"><code>&quot;&quot;</code>，野值</td><td style="text-align:center"><code>&quot;&quot;</code>/野值</td><td style="text-align:center">出错</td></tr><tr><td style="text-align:center"><strong>局部数组（其它同）</strong></td><td style="text-align:center">野值</td><td style="text-align:center">野值</td><td style="text-align:center"><code>&quot;&quot;</code>，<code>''</code></td><td style="text-align:center">野值</td><td style="text-align:center">出错</td></tr></tbody></table><p>但是很多时候我们希望给（局部）数组进行初始化（比如0值）。如果数组很长，你肯定不希望逐个进行初始化化，虽然可以用循环但看起来也不那么聪明的样子。</p><p>让我们看看初始化数组的技巧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 快速0值初始化，其它类型同理，如flaot/double/bool</span></span><br><span class="line">    <span class="comment">// 1.静态数组：&#123;0&#125;</span></span><br><span class="line">    <span class="keyword">int</span> array1[LEN] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 0,0,0</span></span><br><span class="line">    <span class="keyword">int</span> array2[LEN] = &#123;<span class="number">1</span>&#125;;  <span class="comment">// 1,0,0，如果第一个数字不是0，则只有其它是0</span></span><br><span class="line">    <span class="comment">// 2.动态数组</span></span><br><span class="line">    <span class="keyword">int</span>* array3 = <span class="keyword">new</span> <span class="keyword">int</span>[LEN]();  <span class="comment">// 0,0,0,记得指定长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.更通用的做法: std::fill()</span></span><br><span class="line">    <span class="comment">// 分别指定：数组起始地址，地址终地址，要填充的值</span></span><br><span class="line">    <span class="built_in">fill</span>(array1,array1+LEN,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-7-4-数组不是指针">1.7.4 数组不是指针</h4><p><u>在前面数组和动态数组（指针方式）不同初始化方式（指针需要new分配</u>），你也应该隐隐约约感受到指针和数组是两个不同的东西。虽然很多时候数组会退化为指针使用，但将数组视为指针这是不对的。</p><p><strong>比如，静态数组一旦初始化是不能重新赋值的，但是动态数组可以</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr1[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> arr3[<span class="number">3</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">arr1 = arr3; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; </span><br><span class="line">arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>那么，<strong>数组和指针究竟有哪些不同？它什么时候退化为指针？怎么去更深层次的理解</strong>？</p><p>这些东西不适合放在这里详细讲解，因为你还不具备很多相关知识。请参考：<u>2.1.3#指针和数组</u>。</p><h4 id="1-7-5-数组小结🌟">1.7.5 数组小结🌟</h4><p>下面我们总结一下数组常用声明、初始化方式。</p><p>【注1】仅以一维数组为例。</p><p>【注2】动态数组记得使用<code>delete[]</code>释放空间。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">声明</th><th style="text-align:center">显示初始化</th><th style="text-align:center">快速初始化</th></tr></thead><tbody><tr><td style="text-align:center">静态数组</td><td style="text-align:center">int arr[LEN];</td><td style="text-align:center"><strong>int arr[LEN]={…}</strong>;<br>int arr[]={…};<br>int arr[]{…};</td><td style="text-align:center">int arr[LEN]={0};<br>fill(arr,arr+LEN,0);</td></tr><tr><td style="text-align:center">动态数组</td><td style="text-align:center">int* arr;<br>int* arr = new int[LEN];</td><td style="text-align:center"><em><em>int</em> arr = new int[LEN]{…}</em>*</td><td style="text-align:center">int* arr = new int[LEN]();<br>fill(arr,arr+LEN,0);</td></tr></tbody></table><h3 id="1-8-字符串">1.8 字符串</h3><h4 id="1-8-1-C风格字符串">1.8.1 C风格字符串</h4><p>在C中我们使用字符串其实是字符数组。</p><table><thead><tr><th>用字符数组存放</th><th>用字符指针管理串</th></tr></thead><tbody><tr><td>char str1[ ]=“royhuang”;</td><td>char *str2=“hwh”;</td></tr></tbody></table><ul><li><p><strong>char字符数组</strong></p><p>定义一个C 风格的字符串：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> my_name[] = <span class="string">&quot;royhuang&quot;</span> ;</span><br></pre></td></tr></table></figure><p>猜猜<code>my_name</code>的长度？8？不，是9。因为C风格的字符串还会自动在末尾添加一个终止符，即：<code>royhuang\0</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(my_name)/<span class="keyword">sizeof</span>(my_name[<span class="number">0</span>]); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p><code>strlen</code> 可以忽略空字符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(my_name); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p><strong>C风格字符数组，无法二次重新赋值，但数组存储的内容可以被修改</strong>。</p><p>下面举例说明。</p><p>数组不能重新赋值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_name = <span class="string">&quot;hwh&quot;</span>;  <span class="comment">// error，无法被修改</span></span><br></pre></td></tr></table></figure><p>数组存储的内容可以被修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_name[<span class="number">0</span>]=<span class="string">&#x27;z&#x27;</span></span><br><span class="line">cout&lt;&lt;my_name;  <span class="comment">// zoyhuang</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指针数组</strong></p><p>定义一个指针数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* my_name = <span class="string">&quot;royhuang&quot;</span> ;</span><br></pre></td></tr></table></figure><p>如果你对指针有所了解，一定会纳闷：<strong>指针都没给它分配指向的空间，怎么就可以存入char数组</strong>？</p><p>下面才符合我们之前对动态数组的认知：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C风格动态数组</span></span><br><span class="line"><span class="comment">// malloc分配空间</span></span><br><span class="line"><span class="keyword">char</span>* my_name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="comment">// for赋值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span> ; i++) <span class="comment">// for循环赋值</span></span><br><span class="line">&#123;</span><br><span class="line">    my_name[i]=<span class="string">&#x27;&#x27;; </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string">// C++风格</span></span><br><span class="line"><span class="string">// new分配空间，还可以同时初始化</span></span><br><span class="line"><span class="string">char* my_name = new char[10]&#123;&quot;royhuang&quot;&#125;;</span></span><br><span class="line"><span class="string">*/</span></span><br></pre></td></tr></table></figure><p>这一切都要感谢编译器的“幕后工作”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* my_name = <span class="string">&quot;royhuang&quot;</span> ;  <span class="comment">// 发生了什么？</span></span><br></pre></td></tr></table></figure><p>等价于：</p><ol><li><p>编译器首先在常量区分配一个字符数组（可以看做是匿名数组），这里假设为<code>tmp_my_name</code> ；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* tmp_my_name[] = <span class="string">&quot;royhuang\0&quot;</span>;</span><br></pre></td></tr></table></figure><p>题外话，正因为&quot;royhuang\0&quot;保存在常量区（只读），所以<u>上述方式分配的动态数组无法修改</u>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_name[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span>; <span class="comment">// 错误，尝试修改常量区的值</span></span><br></pre></td></tr></table></figure></li><li><p>然后将<code>tmp_my_name</code> 拷贝给<code>my_name</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_name 并没有分配空间</span></span><br><span class="line"><span class="comment">// 只是保存了数组（首元素）地址</span></span><br><span class="line">my_name = tmp_my_name;</span><br></pre></td></tr></table></figure><p>题外话，正因为<code>my_name</code> 只是保存了数组地址（本质是指针，而不是数组），<u>所以动态数组可以重新改变指向</u>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_name = <span class="string">&quot;hwh&quot;</span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>常用方法</strong></p><p>C++提供了<code>cstring.h</code> 供我们操作C字符串（不适用<code>std::string</code>！），这里给出一些常用方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> source[]=<span class="string">&quot;royhuang&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><ul><li><p><strong>复制字符串</strong></p><p>下面这种方式容易造成溢出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(dest, source); <span class="comment">// 溢出 &gt; 5</span></span><br></pre></td></tr></table></figure><p>c中建议使用<code>strncpy</code>，C++11则首选<code>strcpy_s</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保编译器支持此函数，需要先define</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __STDC_WANT_LIB_EXT1__ 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// linux下strcpy_s无法使用，使用strncpy</span></span><br><span class="line"><span class="comment">// strncpy(dest, source, 5);</span></span><br><span class="line"><span class="built_in">strcpy_s</span>(dest, <span class="number">5</span>, source); </span><br><span class="line">cout&lt;&lt;dest&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">royhu</span><br></pre></td></tr></table></figure></li><li><p><strong>长度和容量</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>] = <span class="string">&quot;royhuang&quot;</span>;</span><br><span class="line"><span class="built_in">strlen</span>(name) ; <span class="comment">// 7，不包含终止符</span></span><br><span class="line"><span class="built_in">size</span>(name);    <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></li><li><p><strong>其它有用的方法</strong></p><ul><li><strong>strcmp</strong>() ：比较两个字符串（如果相等则返回 0 ）；</li><li><strong>strncmp</strong>() ： 比较两个字符串到特定数量的字符（如果相等则返回 0）；</li><li><strong>strcat</strong>() ： 将一个字符串附加到另一个（危险）；</li><li><strong>strncat</strong>() ：将一个字符串附加到另一个字符串（带缓冲区长度检查）。</li></ul></li></ul></li><li><p><strong>最佳实践</strong></p><p>C风格的字符串通常使用麻烦：合并字符串不方便、<code>char*</code>需管理内存分配、不自动增长需考虑越界的问题等。</p><p>因此在C++中最佳字符串实践：</p><ol><li>不建议使用C风格的字符串，请尽量使用<code>std::string</code>；</li><li>如果一定要使用，请使用有固定缓冲区大小的 C 样式字符串。</li></ol><p>认识下<code>std::string</code> 究竟有何般魔力吧。</p></li></ul><h4 id="1-8-2-string初识">1.8.2 string初识</h4><h5 id="std-string-是什么？"><code>std::string</code> 是什么？</h5><p>C++ 支持两种不同类型的字符串：<code>std::string</code>（作为标准库的一部分）和 C 风格的字符串（从 C 语言继承而来）。</p><p><code>std::string</code> 是使用 C 风格的字符串实现的，参考：<a href="https://zhuanlan.zhihu.com/p/157169295">C++ string 源码实现对比</a> 。</p><p>可以看到 string 其实就是 <code>basic_string&lt;char&gt;</code>，通过 <code>basic_string</code> 可以构造出不同字符类型的字符串类型。比如 <code>wstring</code> 就是 <code>basic_string&lt;wchar_t&gt;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="keyword">char</span>&gt;    string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="keyword">char</span>, char_traits&lt;<span class="keyword">char</span>&gt;, allocator&lt;<span class="keyword">char</span>&gt; &gt; string; </span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="keyword">wchar_t</span>, char_traits&lt;<span class="keyword">wchar_t</span>&gt; allocator&lt;<span class="keyword">wchar_t</span>&gt; &gt; wstring; </span><br></pre></td></tr></table></figure><p><strong>也就是说<code>std::string</code>是一个对象，不是数组</strong>。</p><p>在c++中可以通过 <code>#include &lt;string&gt;</code> 引入字符串<code>std::string</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// string my_name &#123;&#125;; // 空串</span></span><br><span class="line">    string my_name = <span class="string">&quot;royhuang&quot;</span>;</span><br><span class="line">    cout&lt;&lt;my_name&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227223041128.png" alt="image-20211227223041128"></p><h5 id="std-string-好在哪里？"><code>std::string</code> 好在哪里？</h5><p>回忆我们提到的C风格字符串缺点：</p><blockquote><p>C风格的字符串通常使用麻烦：合并字符串不方便、<code>char*</code>需管理内存分配、不自动增长需考虑越界的问题等。</p></blockquote><p><code>std::string</code> 则不存在这些问题：</p><ol><li><p><strong>合并字符串方便</strong>：string内置<code>append</code>方法和重载了<code>+</code>操作符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;royhuang&quot;</span>;</span><br><span class="line">s1.<span class="built_in">append</span>(<span class="string">&quot;cqu&quot;</span>); <span class="comment">//  royhuangcqu</span></span><br><span class="line">s1 = s1+<span class="string">&quot;1996&quot;</span>;   <span class="comment">//  royhuangcqu1996</span></span><br></pre></td></tr></table></figure></li><li><p><strong>无需管理内存</strong> 。使用<code>char*</code> 需要显示使用<code>delete[]</code> 删除内存，string会自动管理。</p></li><li><p><strong>自动动态增长</strong>。同上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.<span class="built_in">append</span>(<span class="string">&quot;cqu&quot;</span>);  <span class="comment">// 字符串长度自动增长</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="1-8-3-string转换为C风格">1.8.3 string转换为C风格</h4><p>实际编码中，总有或多或少的原因，我们要将string转换为C风格字符串（C风格字符串如何转换为string在<u>下一节：string常用方法</u>介绍）。</p><p>了解一下吧。</p><ol><li><p><code>c_str()</code> 方法</p><p>原型：<code>const char* string::c_str () const</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string sSource&#123; <span class="string">&quot;abcdefg&quot;</span> &#125;;</span><br><span class="line">sSource.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure></li><li><p><code>data()</code> 方法</p><p>原型：<code>const char* string::data () const</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string sSource&#123; <span class="string">&quot;abcdefg&quot;</span> &#125;;</span><br><span class="line">sSource.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure></li><li><p><code>copy()</code> 方法</p><p>原型：<code>size_type string::copy(char *szBuf, size_type nLength, size_type nIndex = 0) const</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string sSource&#123; <span class="string">&quot;sphinx of black quartz, judge my vow&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> szBuf[<span class="number">20</span>];</span><br><span class="line">sSource.<span class="built_in">copy</span>(szBuf, <span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">black</span><br></pre></td></tr></table></figure></li></ol><p>继续看看string更多的用法吧。</p><h4 id="1-8-4-string常用方法">1.8.4 string常用方法</h4><p>字符串是编程中经常要处理的，这里列出常用的方法供熟悉和查阅。</p><p>为了尽量简洁，下面仅给出关键性代码。</p><div class="tabs" id="markdown"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#markdown-1">构造初始化</button></li><li class="tab"><button type="button" data-href="#markdown-2">访问</button></li><li class="tab"><button type="button" data-href="#markdown-3">容量大小</button></li><li class="tab"><button type="button" data-href="#markdown-4">基本修改</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="markdown-1"><p><strong>注意初始化string的只能是常量（const）类型</strong>。</p><p>当然你可能见过最简单的方法，使用操作符<code>=</code> 来初始化字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="built_in">string</span>(<span class="string">&quot;royhuang&quot;</span>);</span><br></pre></td></tr></table></figure><p>当然，你还可以用C风格的字符串，也就是<strong>C风格字符串如何转换为string</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;royhuang&quot;</span>;  <span class="comment">// 字符串</span></span><br><span class="line">string str = <span class="string">&#x27;5&#x27;</span>;  <span class="comment">// 字符</span></span><br></pre></td></tr></table></figure><p>这里<code>=</code> 是重载过后的运算符。现在我们来了解一下：如何通过构造函数进行初始化。</p><ul><li><p><code>string()</code> 方法</p><p>原型：string::string()。创建一个空字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空串，默认初始化</span></span><br><span class="line">string sSource;  </span><br></pre></td></tr></table></figure></li><li><p><strong>string::string(const string&amp; strString)</strong></p><p>此构造函数创建一个新字符串作为 strString 的副本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定字符串值初始化</span></span><br><span class="line">string sSource&#123; <span class="string">&quot;my string&quot;</span> &#125;; </span><br><span class="line">string sNewSource&#123; sSource &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特别的，还接受char* szCString 类型作为参数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *szSource&#123; <span class="string">&quot;my string&quot;</span> &#125;;</span><br><span class="line">string sNewSource&#123; szSource &#125;;</span><br></pre></td></tr></table></figure></li><li><p><em><em>string::string(const char</em> szCString)</em>*</p><p>使用<u>常量</u><strong>C风格字符串初始化</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *szSource&#123; <span class="string">&quot;my string&quot;</span> &#125;;</span><br><span class="line">string sOutput&#123; szSource &#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>string::string(const string&amp; strString, size_type unIndex, size_type unLength)</strong></p><p>创建一个新字符串，最多包含 strString 中的 unLength 字符，从索引 unIndex 开始。如果遇到 NULL，即使未达到 unLength，字符串复制也会结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 截取指定长度初始化</span></span><br><span class="line">string sSource&#123; <span class="string">&quot;my string&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">string sOutput&#123; sSource, <span class="number">3</span> &#125;;</span><br><span class="line">std::cout &lt;&lt; sOutput&lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">sOutput2</span><span class="params">(sSource, <span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; sOutput2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// stri</span></span><br></pre></td></tr></table></figure></li><li><p><strong>想用非字符串类型初始化</strong>？</p><p>如果你尝试用非字符类型串初始化，比如数字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string sFour&#123; <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure><p>会报错：<code>无法将参数 1 从“int”转换为“std::basic_string”</code>  。也就是说试图将int转换为string失败了。</p><blockquote><p>有什么好办法吗？好办法就是我们先将非string类型，比如上文int类型，转换为string。</p></blockquote><p>好吧，果然是经典废话大师。具体来说我们是使用<code>std::ostringstream</code> 类来转换为string类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">ToString</span><span class="params">(T tX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化--&gt;读入--&gt;调用str方法</span></span><br><span class="line">    ostringstream oStream;</span><br><span class="line">    oStream &lt;&lt; tX;  <span class="comment">// tX加入到流中</span></span><br><span class="line">    <span class="keyword">return</span> oStream.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string sFour&#123; <span class="built_in">ToString</span>(<span class="number">4</span>) &#125;;</span><br><span class="line">    string sSixPointSeven&#123; <span class="built_in">ToString</span>(<span class="number">6.7</span>) &#125;;</span><br><span class="line">    string sA&#123; <span class="built_in">ToString</span>(<span class="string">&#x27;A&#x27;</span>) &#125;;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; sFour &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; sSixPointSeven &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 6.7</span></span><br><span class="line">    cout &lt;&lt; sA &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，知道你一定求知若渴：那string类型怎么转换为其它类型呢？类似的，我们使用std::istringstream。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">FromString</span><span class="params">(<span class="keyword">const</span> std::string&amp; sString, T &amp;tX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化--&gt;写入--&gt;调用str方法</span></span><br><span class="line">    <span class="function">istringstream <span class="title">iStream</span><span class="params">(sString)</span></span>;</span><br><span class="line">    <span class="comment">// 将流中数据写入到tX中</span></span><br><span class="line">    <span class="keyword">return</span> !(iStream &gt;&gt; tX).<span class="built_in">fail</span>(); <span class="comment">// extract value into tX, return success or not</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> dX;</span><br><span class="line">    <span class="built_in">FromString</span>(<span class="string">&quot;3.4&quot;</span>, dX)</span><br><span class="line">    <span class="built_in">FromString</span>(<span class="string">&quot;ABC&quot;</span>, dX)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-2"><ul><li><p><strong>重载符号[]</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string sSource&#123; <span class="string">&quot;abc&quot;</span> &#125;;</span><br><span class="line">sSource[<span class="number">2</span>] = <span class="string">&#x27;D&#x27;</span>; <span class="comment">// abD</span></span><br></pre></td></tr></table></figure></li><li><p><strong>at() 方法</strong></p><p>相比性能较慢，因为它会对传入的参数<code>index</code>进行异常检查。但是相对的，如果你不确定传入的<code>index</code>是否有效：</p><p>just use it.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string sSource&#123; <span class="string">&quot;abc&quot;</span> &#125;;</span><br><span class="line">sSource.<span class="built_in">at</span>(<span class="number">2</span>) = <span class="string">&#x27;D&#x27;</span>; <span class="comment">// abD</span></span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-3"><ul><li><p><strong>size_type string::length() const</strong> 和 <strong>size_type string::size() const</strong></p><p>两个函数都可以返回字符串中的当前<strong>字符数</strong>，不包括空终止符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string source&#123; <span class="string">&quot;012345678&quot;</span> &#125;;</span><br><span class="line">source.<span class="built_in">length</span>() <span class="comment">// 9 </span></span><br><span class="line">source.<span class="built_in">size</span>()   <span class="comment">// 9</span></span><br></pre></td></tr></table></figure></li><li><p><strong>bool string::empty() const</strong></p><p>如果字符串没有字符则返回真，否则返回假。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source.<span class="built_in">empty</span>()  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><strong>size_type string::capacity() const</strong></p><p>注意，length()方法返回的是实际存储的字符数量，但是capacity()方法返回的编译器给string类型初始化分配的容量大小。</p><p>编译器一般会为用户提供了一些缓冲空间，所以一般<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>a</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo>&gt;</mo><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">capacity()&gt;length()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s &#123; <span class="string">&quot;012345678&quot;</span> &#125;;</span><br><span class="line">s.<span class="built_in">length</span>() ;   <span class="comment">// 9</span></span><br><span class="line">s.<span class="built_in">capacity</span>() ; <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p><strong>为什么要这么做</strong>？</p><p>考虑这么一种情况，你初始化了一个字符串<code>str</code>，length()=8。如果你在后面还继续串联构造更大字符串，这个时候<strong>每串联一次编译器就要重新分配<code>str</code>大小</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span> <span class="comment">// for rand() and srand()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span> <span class="comment">// for time()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str&#123;&#125;; <span class="comment">// length 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; <span class="number">16</span>; ++count)</span><br><span class="line">        str += <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当串联的次数过多时，显然这会对性能造成较大的影响。所以更更聪明的做法，<strong>除了系统默认分配更大的容量，还可以自定义提前reserve分配更大的容量</strong>。</p></li><li><p><strong>void string::reserve(size_type unSize)</strong></p><p>提前分配更大的容量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="built_in">reserve</span>(<span class="number">16</span>);</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-4"><p>定义公共代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">sStr1</span><span class="params">(<span class="string">&quot;red&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">sStr2</span><span class="params">(<span class="string">&quot;blue&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>交换两个字符串</strong></p><p>void swap (string &amp;str1, string &amp;str2)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(sStr1, sStr2);</span><br></pre></td></tr></table></figure></li><li><p><strong>追加字符串</strong></p><p>string&amp; string::operator+= (const string&amp; str)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sStr1 += sStr2 ; <span class="comment">// 新字符串：redblue</span></span><br></pre></td></tr></table></figure><p>或者使用append()方法，效果一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sStr1.<span class="built_in">append</span>(sStr2)</span><br></pre></td></tr></table></figure><p><strong>特别对于C风格字符串</strong>，如下。</p><ol><li><p><code>+=/append</code> 方式</p><p>要求都是<strong>常量</strong>！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">sString</span><span class="params">(<span class="string">&quot;one&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// &quot; two&quot;、&quot; three&quot;都是C风格字符串</span></span><br><span class="line">sString += <span class="string">&quot; two&quot;</span>;</span><br><span class="line">sString.<span class="built_in">append</span>(<span class="string">&quot; three&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>push_back</code> ，仅限<u>字符</u></p><p><strong>不要求是常量</strong>，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">sString</span><span class="params">(<span class="string">&quot;one&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">sString += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">sString.<span class="built_in">push_back</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">cout &lt;&lt; sString &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one 2</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>插入字符串</strong></p><p>string&amp; string::insert (size_type index, const string&amp; str)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sStr1.<span class="built_in">insert</span>(<span class="number">2</span>,sStr2); <span class="comment">// reblued</span></span><br></pre></td></tr></table></figure><p>当然也可以插入C风格字符串，但是只能是<strong>常量</strong>字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sStr1.<span class="built_in">insert</span>(<span class="number">2</span>,<span class="string">&quot;hwh&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><!-- tab 比较、子串、搜索--><ul><li><p><strong>比较</strong></p><p>常用方法如下。</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">==, !=</td><td style="text-align:center">比较两个字符串是否相等/不相等（返回 bool）</td></tr><tr><td style="text-align:center">&lt;, &lt;=, &gt; &gt;=</td><td style="text-align:center">比较两个字符串是否小于/大于彼此（返回 bool）</td></tr><tr><td style="text-align:center">compare()</td><td style="text-align:center">比较两个字符串是否相等/不相等（返回 -1、0 或 1）</td></tr></tbody></table></li><li><p><strong>子串</strong></p><p>见下。</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:center">子串相加</td></tr><tr><td style="text-align:center">substr()</td><td style="text-align:center">获取子串</td></tr></tbody></table></li><li><p><strong>搜索</strong></p><p>大致如下。</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">find()</td><td style="text-align:center">查找第一个<u>字符/子串</u></td></tr><tr><td style="text-align:center">find_first_of()</td><td style="text-align:center">查找指定搜索<u>字符</u>的第一次出现位置的索引</td></tr><tr><td style="text-align:center">find_last_of()</td><td style="text-align:center">查找指定搜索<u>字符</u>的最后一次出现位置的索引</td></tr></tbody></table></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="1-8-5-输入输出流">1.8.5 输入输出流</h4><p>在本笔记中，“流（stream）”一词会被大量提到。不可避免的，我们先来了解下其基本概念。</p><ul><li><p><strong>什么是流</strong>？</p><p>抽象地说，<strong>流只是一个可以顺序访问的字节序列</strong>。随着时间的推移，流可能会产生或消耗无限量的数据。</p><p>以我们通常处理的输入流和输出流为例。</p><ul><li><strong>输入流：保存来自数据生成器（例如键盘、文件或网络）的输入</strong>。例如，保存用户当前键盘的输入。</li><li><strong>输出流：用于保存特定数据使用者的输出，例如监视器、文件或打印机</strong>。将数据写入输出设备时，该设备可能尚未准备好接受该数据——例如，当程序将数据写入其输出流时，打印机可能仍在预热。数据将位于输出流中，直到打印机开始使用它。</li></ul></li><li><p><strong>C++中的输入、输出流</strong></p><ul><li><strong>istream类是与输入流处理时的主类</strong>。对于输入流，<strong>提取运算符</strong> (&gt;&gt;)用于从流中<u>删除</u>值。</li><li><strong>ostream类是与输出流处理时的主类</strong>。对于输出流，<strong>插入运算符</strong> (&lt;&lt;)用于将值<u>加入</u>流中。</li></ul><p>当然，C++已经预定义好四个标准流对象，我们可以直接使用它们：</p><ol><li><strong>cin</strong> ：标准输入流对象（通常是键盘）；</li><li><strong>cout</strong> ：标准输出流对象（通常是监视器）；</li><li><strong>cerr</strong> ：标准错误输出流对象（通常是监视器），提供<strong>无缓冲输出</strong>；</li><li><strong>clog</strong> ：标准错误输出流对象（通常是监视器），提供<strong>缓冲输出</strong>。</li></ol><p>无缓冲输出通常被立即处理，而缓冲输出通常作为块存储和写出。因为 clog 不经常使用，所以经常从标准流列表中省略它。</p></li></ul><div class="tabs" id="markdown"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#markdown-1">istream</button></li><li class="tab"><button type="button" data-href="#markdown-2">ostream</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="markdown-1"><ul><li><p><strong>istream最佳实践</strong></p><ul><li><p>（C风格）<strong>使用setw避免缓存区溢出</strong></p><p>使用提取运算符<code>&gt;&gt;</code>从输入流中读取信息，第一个常见问题便是要避免缓冲区溢出。<strong>尤其是在C风格的字符串中</strong>，这应该成为你的肌肉反应。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>]; </span><br><span class="line">cin&gt;&gt;buf;  <span class="comment">// 输入：12345678910</span></span><br></pre></td></tr></table></figure><ul><li><strong>流程</strong>：上例中，输入流中存在：12345678910，<strong>cin每次读取一个字符串放入buf中，遇到空格、制表符、换行符才会终止</strong>。</li></ul><p>但由于你的小调皮，输入了超过10个字符。因为这超过了缓存预定大小（10），很不幸发生了Segmentation fault。</p><p>正确的做法应该是，我们要<strong>限制从流中读取的最大字符数</strong>（小于10），然后再放入buf中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">cin&gt;&gt;<span class="built_in">setw</span>(<span class="number">10</span>)&gt;&gt;buf;</span><br><span class="line">cout&lt;&lt;buf;</span><br></pre></td></tr></table></figure><p>现在程序只读取流中的前 <strong>9</strong> 个字符（为终止符留出空间）。任何剩余的字符都将留在流中，等待下一次提取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123456789</span><br></pre></td></tr></table></figure></li><li><p>（C风格）<strong>使用getline读取整行</strong></p><p>如前提到，<strong>cin如果遇到：空格、制表符、换行符，就会自动停止提取</strong>。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">cin&gt;&gt;<span class="built_in">setw</span>(<span class="number">20</span>)&gt;&gt;buf; <span class="comment">// 输入：i am royhuang</span></span><br><span class="line">cout&lt;&lt;buf;</span><br></pre></td></tr></table></figure><p>输出结果却不如意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i</span><br></pre></td></tr></table></figure><p>当然，聪明的你想到直接用循环读取字符：遇到空格、制表符等开始下一个循环，直至遇到<code>\n</code> 才结束循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt;buf[i++]);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i am royhuang</span><br></pre></td></tr></table></figure><p>但上面的方式存在两个问题：1）循环不够优雅；2）没有限制输入字符最大长度。</p><p>为此，你说可以使用get方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">cin.<span class="built_in">get</span>(buf,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>看上去一切都很美好。但是这里忽略了一个问题，<strong>换行符<code>\n</code>还在流中</strong>。</p><p>请看下例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">  cin.<span class="built_in">get</span>(buf,<span class="number">20</span>);</span><br><span class="line">  cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">char</span> company[<span class="number">10</span>];</span><br><span class="line">  cin.<span class="built_in">get</span>(company,<span class="number">10</span>);</span><br><span class="line">cout&lt;&lt;company&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>company还未来得及输入，便结束：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211229165225112.png" alt="image-20211229165225112"></p><p><strong>使用getline可读入换行符</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">  cin.<span class="built_in">getline</span>(buf,<span class="number">20</span>);  <span class="comment">// \n 也并读入</span></span><br><span class="line">  cout&lt;&lt;buf&lt;&lt;endl;  </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">char</span> company[<span class="number">10</span>];</span><br><span class="line">  cin.<span class="built_in">get</span>(company,<span class="number">10</span>);</span><br><span class="line">cout&lt;&lt;company&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>一切正常了。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211229165358871.png" alt="image-20211229165358871"></p></li></ul></li><li><p>（string）<strong>std::string+cin</strong></p><p>和前面C风格字符串读取大同小异，不过C++中使用的是标准库中<code>std::get</code>和<code>std::getline</code> 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">// 虽然uni初始化为空串，但是赋值后超过长度（length）会自动增长容量（capacity）</span></span><br><span class="line">    string name&#123;&#125;;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;input your name: &quot;</span>;</span><br><span class="line">    cin&gt;&gt;name;</span><br><span class="line">    </span><br><span class="line">    string uni&#123;&#125;;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;input your university: &quot;</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin,uni);</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;your university is: &quot;</span>&lt;&lt;uni&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现前述类似读入<code>\n</code>问题：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227224535931.png" alt="image-20211227224535931"></p><p>我们输入<code>royhuang</code>并按下回车时，等于输入了<code>royhuang\n</code> ：<code>royhuang</code> 被正确赋值给<code>name</code> ，但是<code>\n</code> 留在了缓冲区等待下一次<code>cin</code>读取。下一次的<code>cin</code>还没等我们再次输入，便发现了缓冲区<code>\n</code>就完成此次读取了。</p><p>我们有两个办法解决这个问题：</p><ol><li>提前读入<code>\n</code>：第6行<code>cin&gt;&gt;name;</code> 替换—&gt;<code>getline(cin,name);</code> ；</li><li>忽略<code>\n</code>：第13行<code> getline(cin,uni);</code>—&gt;<code>getline(cin&gt;&gt;ws,uni);</code>，<code>ws</code> 表示忽略前面的空白字符。</li></ol><p>好了，世界又好起来了。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227225611265.png" alt="image-20211227225611265"></p></li><li><p><strong>其它有用的istream函数</strong></p><ul><li><strong>ignore</strong>()丢弃流中的第一个字符。</li><li><strong>ignore(int nCount</strong>)丢弃前 nCount 个字符。</li><li><strong>peek(</strong>)允许您从流中读取字符，而无需将其从流中删除。</li><li><strong>unget(</strong>)将读回的最后一个字符返回到流中，以便下次调用时可以再次读取。</li><li><strong>putback(char ch</strong>)允许您将您选择的字符放回流中以供下一次调用读取。</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-2"><p>这个小节主要如何 iostream 输出类 (ostream) 格式化输出内容。</p><ul><li><p><strong>前缀正数+</strong></p><p>std::ios::showpos：如果设置，则用 + 前缀正数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; showpos &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211229172847173.png" alt="image-20211229172847173"></p></li><li><p><strong>bool标识</strong></p><p>std::ios::boolalpha：如果设置，布尔值打印“真”或“假”。如果未设置，布尔值打印 0 或 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; boolalpha &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211229172619002.png" alt="image-20211229172619002"></p></li><li><p><strong>科学计数法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; uppercase &lt;&lt; <span class="number">12345678.9</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211229173207449.png" alt="image-20211229173207449"></p></li><li><p><strong>10/2/8/进制</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; hex &lt;&lt; <span class="number">11</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; dec &lt;&lt; <span class="number">11</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; oct &lt;&lt; <span class="number">11</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211229173531290.png" alt="image-20211229173531290"></p></li><li><p><strong>设置宽度、填充字符、对齐方式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; left &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; right &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; internal &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-12345 </span><br><span class="line">    -12345 </span><br><span class="line">-12345 </span><br><span class="line">    -12345 </span><br><span class="line">- 12345</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="更新记录">更新记录</h2><div class="timeline"><div class="timenode"><div class="meta"><p><p>2021-12-25 ：更新笔记</p></p></div><div class="body"><ol><li>第一次更新</li></ol></div></div></div><h2 id="参考资料">参考资料</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">c++中的变量初始化：https://www.dyxmq.cn/program/code/c-cpp/cpp-variable-default-init.html<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">cpp类初始化：https://aiden-dong.gitee.io/2020/01/08/cpp%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++ 教程：https://cloud.tencent.com/edu/learning/course-1844-21266<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C语言extern关键词：http://c.biancheng.net/cpp/html/448.html<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++ 中的static关键字使用场景：https://cloud.tencent.com/developer/article/1695037<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++ 循环：https://www.w3cschool.cn/cpp/cpp-loops.html<a href="#fnref:6" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 教程 </tag>
            
            <tag> 快速入门 </tag>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++从零开始（四）：务实基础（中）指针和引用</title>
      <link href="/p/24237/"/>
      <url>/p/24237/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，开始更新中…</p></blockquote><div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div><h2 id="二、指针-引用">二、指针&amp;引用</h2><p>第一次学C++，指针和引用令当时还是初学者的我感到非常的困惑：</p><ul><li>普通变量就可以代表一块内存区域，我们可以直接使用原始变量，为什么还需要指针？</li><li>指针解决了普通变量的不足，为什么又引入引用的概念？</li><li>引用本质是什么？为什么操作引用等价操作变量本体？</li></ul><p>希望曾经的我，现在的你可以在本章找到答案。</p><h3 id="2-1-指针">2.1 指针</h3><h4 id="2-1-1-为什么需要指针">2.1.1 为什么需要指针</h4><h5 id="重新审视变量">重新审视变量</h5><p><u>变量</u>可以理解为某块内存区域<u>地址别名</u>，这块内存区域保存变量的值。</p><p>下面举一个实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>对应汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl    $0, -12(%rbp)</span><br><span class="line">movl    $1, -12(%rbp)</span><br></pre></td></tr></table></figure><ol><li>当CPU执行<code>int x = 0</code>，会在内存（这里是栈）腾出一块区域（<code>-12(%rbp)</code>）用来存储变量<code>x</code>；然后0被存入<code>x</code>所代表的内存区域（<code>-12(%rbp)</code>）。</li><li>继续执行<code>x=1</code>，1被存入变量<code>x</code>所代表的内存区域。</li></ol><p>可以看到，变量的存在使得我们：不用记住为分配<code>x</code>的内存地址是什么，我们通过变量名<code>x</code>就可以使用分配的内存区域。<strong>因为使用<code>x</code>时，编译器会将变量<code>x</code>隐式自动翻译成对应的内存地址，同时进行间接寻址</strong>（可以理解为使用<code>x</code>等价于<code>*x</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;   <span class="comment">// 编译器眼里：int* x = -12(%rbp); *x = 0;</span></span><br><span class="line">x = <span class="number">1</span>;       <span class="comment">// 编译器眼里： *x = 1;</span></span><br></pre></td></tr></table></figure><p>既然有好用又好记的变量<code>x</code>就可以，为什么还要画蛇添足般地显示使用<u>指针变量</u>，去存储内存地址，再来操作变量<code>x</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个指针变量，它存入x的地址</span></span><br><span class="line"><span class="keyword">int</span>* p_x = &amp;x;</span><br><span class="line"><span class="comment">// 使用间接操作符*，访问p_x存储的内存区域</span></span><br><span class="line">*p_x = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>对应的汇编代码也变得臃肿起来，因为还多了空间去存储指针<code>p_x</code>（即使没有汇编相关基础也建议阅读一遍）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># -12(%rbp)地址赋值给寄存器rax，也就是变量x的地址</span><br><span class="line">leaq    -12(%rbp), %rax </span><br><span class="line"># cpu腾出一块内存区域（对应地址-8(%rbp)）给指针p_x，</span><br><span class="line"># 并把变量x的地址赋值给p_x</span><br><span class="line">movq    %rax, -8(%rbp)</span><br><span class="line"># p_x的值存储到寄存器rax中</span><br><span class="line">movq    -8(%rbp), %rax</span><br><span class="line"># 将立即数10存储到变量x代表的内存区域中</span><br><span class="line">movl    $10, (%rax)</span><br></pre></td></tr></table></figure><p>现在我们来说说C++中指针的好处。</p><h5 id="指针的好处">指针的好处</h5><p>事实证明，指针在许多情况下都很有用（上面的例子当然是使用变量更好）：</p><ul><li><strong>遍历数组</strong>。指针可以很方便的遍历数组，因为数组是使用指针实现的；</li><li><strong>动态分配内存</strong>。在C++中只能使用指针来动态分配内存；</li><li><strong>函数作为参数时</strong>。可以用来将一个函数作为参数传递给另一个函数，即函数指针；</li><li><strong>实现多态性</strong>。它们可用于实现多态性，在面对对象中会详细介绍；</li><li><strong>指向另一个结构/类</strong>。在一些更高级的数据结构中很有用，例如链表和树。</li></ul><p>但另一个事实是，除了在C++中，指针的使用并非那么必要。其它的高级语言中，很多已经摒弃了指针（如.NET或Java）：</p><ul><li><strong>遍历数组</strong>：传统的for循环、迭代器都可以替代；</li><li><strong>动态分配内存</strong>：很多高级语言如Java不用指针即可动态分配内存（new方式）；</li><li><strong>函数作为参数</strong>：在java中可以通过使用接口实例等方式间接实现；</li><li><strong>实现多态性</strong>：java无需指针即可实现；</li><li><strong>指向另外一个结构类</strong> ：java等直接使用<strong>引用</strong>即可。</li></ul><h5 id="最佳实践">最佳实践</h5><p>根据多位C++大师的建议，<u>实际编码尽量不要使用指针</u>，替代使用<u>引用</u>或者<u>标准库</u>是种更好的方式。</p><p>但种种原因，作为一个C++程序员，很多情况还是避免不了去接触和使用。因此，我们还是很有必要深层次了解指针的用法和原理。</p><h4 id="2-1-2-指针简介">2.1.2 指针简介</h4><h5 id="指针初识">指针初识</h5><p><strong>声明</strong>指针使用<code>*</code>，这个时候<code>*</code>不是间接操作符，它只是指针语法的一部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* p_a; <span class="comment">// p_a也是变量，不过是指针变量，存储的是一个地址（a的），下面简称为指针</span></span><br></pre></td></tr></table></figure><p>这里有两个注意事项：</p><ul><li>指针变量在声明时如果没被初始化，默认初始化规则和普通变量一样，可能包含垃圾值（比如局部指针变量）；</li><li><code>p_a</code>被称为“整数指针”，实际含义应该是“指向整数的指针”。</li></ul><blockquote><p>👀 眼保健操环节。</p></blockquote><p>区分以下指针类型？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p[<span class="number">10</span>]</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">10</span>]</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure><p>指针和数组<code>[]</code> 结合一般才要注意区分，其余情况大多是表示指针。</p><ol><li><code>int *p[10]</code> ，强调数组概念，此时<code>p</code>表示数组，每个元素都是<code>int*</code> 类型；</li><li><code>int (*p)[10]</code> ，用<code>()</code> 圈住<code>*p</code> ，强调指针概念，此时指针<code>p</code> 指向一个<code>int</code> 类型数组，等价于 <code>int *p = new int(10*sizeof(int));</code> ；</li><li><code>int *p(int)</code> ，这是函数声明本质还是指针，指针<code>p</code> 存储的函数的地址，后面的<code>(int)</code> 表示是个<u>函数</u>。</li></ol><p>特别的还有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><ol start="4"><li>同前，用<code>()</code> 圈住<code>*p</code> ，更强调指针概念，后面的<code>(int)</code> 表示是个<u>函数</u>。</li></ol><p><strong>赋值</strong>是使用地址运算符<code>&amp;</code>：</p><p>从下也可以看到，<strong>指针和普通变量在cpu眼中无多大区别，只不过指针用来存储地址</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p_a = &amp;a;   <span class="comment">// &amp;a获取了变量a的地址。</span></span><br></pre></td></tr></table></figure><p><code>&amp;p_a</code>可获取指针<code>p_a</code>的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;p_a&lt;&lt;endl;  <span class="comment">// a的地址，0x7ffc4f78721c</span></span><br><span class="line">cout&lt;&lt;&amp;p_a&lt;&lt;endl; <span class="comment">// 指针p_a的地址，0x7ffe903aae20</span></span><br></pre></td></tr></table></figure><p>地址运算符需要注意以下几点：</p><ul><li><p>地址运算符 (&amp;) 返回<strong>不是变量的地址</strong>，而是一个包含<strong>变量地址的指针</strong> ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(&amp;a).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *</span><br></pre></td></tr></table></figure></li><li><p><strong>指针只能使用左值进行赋值</strong></p><p>什么是左（l）值和右（r）值？可参考下一小节：<u>l值和r值</u>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* b = a; <span class="comment">// 合法，变量a是左值</span></span><br><span class="line"><span class="keyword">int</span>* b = <span class="number">1</span>; <span class="comment">// 非法，文字1是右值</span></span><br><span class="line"><span class="keyword">int</span>* b = a+<span class="number">1</span>; <span class="comment">// 非法，表达式a+1也是右值</span></span><br></pre></td></tr></table></figure></li></ul><p>变量可以修改存储其它的值，指针也可以指向其他的内存区域（存取它的地址）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">11</span>; </span><br><span class="line">p_a  = &amp;b;</span><br></pre></td></tr></table></figure><p><strong>使用</strong>指针是通过间接操作符<code>*</code> ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt; *p_a &lt;&lt;endl ; <span class="comment">// 10, 读取值</span></span><br><span class="line">*p_a = <span class="number">11</span>;  <span class="comment">// 修改</span></span><br></pre></td></tr></table></figure><p><strong>指针大小</strong>取决于编译可执行文件的体系结构——32 位可执行文件使用 32 位内存地址——因此，32 位机器上的指针是 32 位（4 字节）。对于 64 位可执行文件，指针将是 64 位（8 字节）。</p><p>它和指向的对象大小无关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* p_a = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> b = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span>* p_b = &amp;b;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(p_a)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(p_b)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>在作者64位机器上输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h5 id="l值和r值">l值和r值</h5><p>什么是左值（l值）？</p><p><strong>左值是具有地址（在内存中）的值</strong>。例如：</p><ul><li>变量是一种左值（读作 ell-value），因为所有变量都有地址；</li></ul><p>当我们进行赋值时，<strong>赋值运算符=的左侧必须是左值，但=右侧可以是左值也可以是右值</strong>。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;  <span class="comment">// 正确，变量a可作为左值</span></span><br><span class="line"><span class="keyword">int</span> b = a;  <span class="comment">// 正确，变量b也可作为右值</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> = <span class="number">6</span>;   <span class="comment">// 出错，5不是左值，没有地址</span></span><br><span class="line">a+<span class="number">1</span> = <span class="number">3</span>; <span class="comment">// 错误，a+1是右值</span></span><br></pre></td></tr></table></figure><p>你可能会疑惑为什么表达式<code>a</code> 是左值，<code>a+1</code> 是左值？</p><p>因为<code>a+1</code>没有自己的地址（临时计算的结果存入寄存器中），从根本否定了它是左值。</p><p>那什么又是右值？</p><p><strong>与左值相反的便是右值（r值，即没有内存地址</strong>），右值可以文字、表达式等：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">// 正确，1是右值</span></span><br><span class="line">a = a+<span class="number">1</span>; <span class="comment">// 正确，a+1是右值</span></span><br></pre></td></tr></table></figure><p>特别的，在赋值运算时，<u>所有左值会隐式转换为右值</u>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = a; <span class="comment">// a被隐式转换为右值</span></span><br></pre></td></tr></table></figure><h5 id="空指针">空指针</h5><p>空指针是一个特殊的指针，可以通过“0”来为指针分配空值，表示没有指向任何东西。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>这似乎听起来没什么用</strong>？</p><p>根据变量的最佳实践，声明时最好进行初始化，这个时候我们可以将指针设为空值完成最佳实践。</p><p>如下，此时指针<code>p</code>未被初始化（也称<strong>野指针</strong>），就被使用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span>* p;     <span class="comment">// 未初始化</span></span><br><span class="line">    std::cout&lt;&lt; *p &lt;&lt; std::endl; <span class="comment">// 未初始化就被使用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据最佳实践声明同时进行初始化，<code>int* p = 0</code> ，然后再使用。</p><p><strong>但使用0值表示空指针不安全，请使用nullptr关键字</strong>。</p><p>因为文字0不是任何类型，在少数情况下，编译器无法判断我们是使用空指针还是整数0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;int* &quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;int &quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>);  <span class="comment">// 虽然我们希望传入空指针，但是编译器解释为int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int</span><br></pre></td></tr></table></figure><p>为了解决上述问题，C++11 引入了一个新的关键字nullptr ，称为 <strong>空指针</strong>。</p><p>C++ 会隐式地将 nullptr 转换为任何指针类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">nullptr</span> ;</span><br></pre></td></tr></table></figure><p>在上面的例子中，<strong>nullptr被隐式转换为整数指针，然后将nullptr的值赋给ptr</strong>。这具有使整数指针 ptr 成为空指针的效果。</p><h5 id="void指针">void指针</h5><p>void指针，也称为泛型指针，是一种特殊类型的指针，可以指向任何数据类型的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nValue;</span><br><span class="line"><span class="keyword">float</span> fValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* ptr;</span><br><span class="line">ptr = &amp;nValue;</span><br><span class="line">ptr = &amp;fValue;</span><br></pre></td></tr></table></figure><p>但也有由于这种不确定的包容特性，我们需要在使用void指针时转换为具体的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(voidPtr)  =  <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>void指针有什么用</strong>？</p><p>这种特性使得void指针可以在<strong>一个函数处理多种类型</strong>的数据。</p><p>以下函数展示了如何使用“泛型指针”作为函数参数（C++20前是不允许使用auto类型的参数），去处理多种类型的实参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">tInt,</span><br><span class="line">    tFloat,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">(<span class="keyword">void</span>* ptr, Type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> Type::tInt:</span><br><span class="line">            std::cout &lt;&lt; *<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(ptr) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Type::tFloat:</span><br><span class="line">            std::cout &lt;&lt; *<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>*&gt;(ptr) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">assert</span>(<span class="literal">false</span> &amp;&amp; <span class="string">&quot;type not found&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nValue&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">float</span> fValue&#123; <span class="number">7.5f</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printValue</span>(&amp;nValue, Type::tInt);</span><br><span class="line">    <span class="built_in">printValue</span>(&amp;fValue, Type::tFloat);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但一方面它看起来也很傻：</p><ol><li><p>因为我们往往有更好的办法替代void指针，比如模板。</p><p>相比前面代码更加清晰，简洁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">(T ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; ptr &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>void指针也并不安全，它没有类型检查</p><p>没有编译器自动的类型检查，你又粗心写作了传入的参数类型，这显然很糟糕。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> fValue2&#123; <span class="number">5.4</span> &#125;;</span><br><span class="line"><span class="built_in">printValue</span>(&amp;fValue2, Type::tInt);</span><br></pre></td></tr></table></figure></li></ol><p><strong>最佳实践：尽量减少使用void指针，除非真的找不到第二个更好的办法来进行替代</strong>。</p><h5 id="箭头运算符再思考">箭头运算符再思考</h5><p>对于普通类/结构体的对象，我们使用成员选择运算符<code>.</code>选择成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person person;</span><br><span class="line">person.age = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>但我们也被告知，如果是个指针对象，请使用箭头<code>-&gt;</code>运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person* p_person = &amp;person ;</span><br><span class="line">p_person-&gt;age = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>但这个时候，我们不禁想起以前如何使用一个指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* p_a = &amp;a;</span><br></pre></td></tr></table></figure><p>使用间接操作符<code>*</code> 让我们获取了指针指向的对象，然后进行操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*p_a = <span class="number">11</span>;</span><br></pre></td></tr></table></figure><p><strong>那么我们用<code>*</code> 获取<code>p_person</code> 指向的结构体对象，不就可以像普通结构体对象一样使用成员运算符<code>.</code>吗</strong>？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*p_person).age = <span class="number">6</span>;  <span class="comment">// 等价于：person.age = 6;</span></span><br></pre></td></tr></table></figure><p>更多的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person* p_person2 = <span class="keyword">new</span> <span class="built_in">Person</span>();</span><br><span class="line">(*p_person2).age = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><h4 id="2-1-3-指针和数组">2.1.3 指针和数组</h4><p>指针和数组它们之间的区别有时很具有迷惑性，特别是<u>很多时候编译器会将数组退化成指针使用</u>。以至于有些人错误地将数组等价于指针。</p><p>现在我们来进行仔细的区分和总结。</p><p><strong>指针加减法</strong></p><p>不过在此之前，先了解下指针加减法有利于更好地继续往下分析。</p><p>C++ 语言允许对指针执行整数加减运算：</p><ul><li>如果<code>ptr</code>指向一个整数，<code>ptr + 1</code>则为 <code>ptr</code> 之后内存中下一个整数的地址；<code>ptr - 1</code>是前一个整数的地址<code>ptr</code>。</li></ul><p>换句话说，在计算指针算术表达式的结果时，<strong>编译器总是将整数操作数乘以所指向对象的大小</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value&#123; <span class="number">7</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span>* ptr&#123; &amp;value &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ptr &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; ptr+<span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; ptr+<span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; ptr+<span class="number">3</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x7ffd05328dfc</span><br><span class="line">0x7ffd05328e00</span><br><span class="line">0x7ffd05328e04</span><br><span class="line">0x7ffd05328e08</span><br></pre></td></tr></table></figure><p>可以看到每个地址相差4字节（一个int大小），比如：0x7ffd05328e00-0x7ffd05328dfc=4。这里的地址是虚拟地址，4就表示4个字节。</p><h5 id="指针和数组的区别🌟">指针和数组的区别🌟</h5><blockquote><p>“万物皆为指针，数组首当其冲”。</p></blockquote><p>声明一个（静态）数组很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr1[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> new_arr[<span class="number">3</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">arr1 = new_arr;  <span class="comment">// error，数组无法重新分配指向新，可以理解为此时数组是常量指针（区分指向常量的指针）</span></span><br></pre></td></tr></table></figure><p>但很多时候我们更希望申请一个动态数组（比如声明时并不确定数组的内容）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">// ok，指针可以分配新内存区域</span></span><br></pre></td></tr></table></figure><p><code>new int[3]&#123;1,2,3&#125;</code> 返回了一个<code>int*</code> 指针，存储分配的数组空间首地址，然后赋值给<code>arr2</code> 。</p><p>体会一下下面场景下的<code>arr2</code> 和 <code>arr1</code> 表现何其像：</p><ul><li><p><strong>作为表达式使用时</strong></p><p>此时数组表现的就是指针，存储了数组元素首地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr1[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.打印数组/指针</span></span><br><span class="line">cout&lt;&lt;arr1&lt;&lt;endl; <span class="comment">// 0x7fff61b6b7d0，数组首元素地址</span></span><br><span class="line">cout&lt;&lt;arr2&lt;&lt;endl; <span class="comment">// 0x97b010，数组首元素地址，因为动态数组分配在堆上不在栈上，地址空间位数显得有些不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.打印数组/指针首元素</span></span><br><span class="line">cout&lt;&lt;*arr1&lt;&lt;endl; <span class="comment">// 1</span></span><br><span class="line">cout&lt;&lt;*arr2&lt;&lt;endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.打印第二个元素</span></span><br><span class="line">cout&lt;&lt;*(arr1+<span class="number">1</span>)&lt;&lt;endl; <span class="comment">// 2</span></span><br><span class="line">cout&lt;&lt;*(arr2+<span class="number">1</span>)&lt;&lt;endl; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>这是因为<strong>C++中如果把数组作为表达式使用，会衰减为一个指针</strong>。</p></li><li><p><strong>数组作为参数时</strong></p><p>将数组作为参数传递时，数组在函数内部表现得已经是一个指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSize</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in printArray: &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;in main: &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(array) &lt;&lt; endl; </span><br><span class="line">    <span class="built_in">printSize</span>(array); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in main: 20</span><br><span class="line">in printArray: 8</span><br></pre></td></tr></table></figure><p>这种情况是因为，在C++中复制数组代价可能会昂贵。因此<strong>将数组传递给函数时，不会复制数组，而是固定数组衰减为指针，然后将指针传递给函数</strong>。</p><ul><li>上述述代码中，数组<code>array</code>类型是<code>int[5]</code> ，作为实参时，退化为指针<code>int *</code> ，保存的数组中第一个元素的地址即<code>&amp;array[0]</code>，然后复制一份给形参<code>arr</code>。</li><li>题外话，当整个结构或类传递给函数时不会衰减。</li></ul><p>也正是因为<strong>C++ 使用数组语法 [] 会将数组衰减为指针</strong>。这意味着以下两个函数声明是相同的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSize</span><span class="params">(<span class="keyword">int</span> array[])</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printSize</span><span class="params">(<span class="keyword">int</span>* array)</span></span>; <span class="comment">// 最佳实践：指针语法 (*) 优于数组语法 ([])，它更表明实际接受的参数类型，C++也不用隐式转换</span></span><br></pre></td></tr></table></figure></li></ul><p>所以说，数组≠指针，只是在某些场景下退化成了指针而已，比如作为表达式或者函数参数时。</p><blockquote><p><strong>更准确来说是退化成了常量指针！因为数组本身默认是常量数组，无法作为左值</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      arr = <span class="number">0x778555622</span>; <span class="comment">// error，作为左值</span></span><br><span class="line">      new_arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">      arr = new_arr;   v <span class="comment">// error，作为左值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>题外话，正由于这种特性，我们往往不得不传递数组参数时<u>还传递数组长度</u>。因为你无法根据指针获取到其长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        cout&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span> (arr) / <span class="built_in"><span class="keyword">sizeof</span></span> (arr[<span class="number">0</span>]);</span><br><span class="line">   <span class="built_in">printArray</span>(array,len); </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里我们进行更详细的总结，数组和指针的区别</strong>。</p><p>数组和指针关键区别在于：类型、是符号不是变量、sizeof等。</p><ol><li><p><code>sizeof</code> ：<code>sizeof(数组)</code> 打印的是数组的长度（容量<code>*</code>存储类型所占字节数），但是<code>sizeof(指针)</code> 打印的是指针长度，一般是4字节或8字节；</p></li><li><p><strong>类型</strong>：数组类型是 <code>type[LEN]</code> ，指针类型是 <code>type*</code> ；</p></li><li><p><strong>定义</strong>：<strong>数组是一个符号</strong>，没有自己的存储空间；<strong>指针是一个变量</strong>，有自己的内存空间，存储其它变量的地址。</p><p>可以修改一个指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">array = <span class="literal">NULL</span>; <span class="comment">// 正确，array是指针，存储是数组首地址</span></span><br></pre></td></tr></table></figure><p>但你尝试修改数组内容是会出错的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">array = <span class="literal">NULL</span>;  <span class="comment">// 编译错误，array是符号，不是可以被修改的左值</span></span><br></pre></td></tr></table></figure><p>另外，如果你尝试打印<code>array</code>的地址，也会发现它并没有属于自己的地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">cout&lt;&lt;array;       <span class="comment">// 0x7ffffabf61f0，array[0]的地址</span></span><br><span class="line">cout&lt;&lt;&amp;array;      <span class="comment">// 0x7ffffabf61f0，没有数组自己的地址，而是array[0]的地址</span></span><br></pre></td></tr></table></figure><p><code>&amp;array</code> 返回一个指向整个数组的指针，这个指针也指向数组的第一个元素，只是类型信息不同（类型<code>&amp;array</code> 是 <code>int(*)[5]</code>）。</p><p>但是每个指针都有自己的地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">cout&lt;&lt;array;       <span class="comment">// 0x7f3010，array[0]的地址</span></span><br><span class="line">cout&lt;&lt;&amp;array;      <span class="comment">// 0x7ffcff233b48，指针本身的地址</span></span><br></pre></td></tr></table></figure></li><li><p><strong>修改</strong>。数组无法被重新初始化/分配，指针（动态数组）可以。</p></li></ol><h5 id="再理解">[]再理解</h5><p>前面我们提到，<u>C++ 使用数组语法 <code>[]</code> 会将数组衰减为指针<code>*</code></u> ，让我们更好地访问数组元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr1[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">arr[<span class="number">1</span>]; <span class="comment">// 等价于 *(arr+1)</span></span><br></pre></td></tr></table></figure><p>上述事实证明，当编译器看到下标运算符（[]）时，它实际上将其转换为指针加法和间接寻址。</p><p>为了更好说明这一点，请看下面代码：输出会是什么呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="number">2</span>[arr] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>下标运算符 ( <code>[]</code>) 等同于加法和间接法，操作数可以交换，因此它等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="number">2</span>+arr)</span><br></pre></td></tr></table></figure><h5 id="cout-和数组">cout 和数组</h5><p>不知道读者有没有注意到一个有趣的事情，cout会自动遍历char数组打印所有字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c_arr[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">cout&lt;&lt;c_arr&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure><p>理论上，此时输出应该是数组首选组<code>h</code>的首地址。就像下面的int数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i_arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">cout&lt;&lt;i_arr&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7fff74ecdc70</span><br></pre></td></tr></table></figure><p>这是因为<code>std::cout</code>上的<code>&lt;&lt;</code>运算符已重载， 实际上是几个不同的函数，都命名为<code>operator&lt;&lt;</code>。它的行为取决于操作数类型，编译器由此决定要调用哪个函数。</p><p>如果给它一个<code>char*</code>或<code>const char*</code>，它会把操作数当作一个指向C样式字符串(第一个字符)的指针，并顺序移动输出剩下的字符串。</p><p><strong>上面99% 的情况下都很棒，但它依旧可能会导致意想不到的结果</strong>。</p><p>下面代码尝试打印一个char类型字符的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c&#123; <span class="string">&#x27;Q&#x27;</span> &#125;;</span><br><span class="line">    std::cout &lt;&lt; &amp;c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q╠╠╠╠╜╡4;¿■A</span><br></pre></td></tr></table></figure><p>好吧，这种情况不一定会发生，编译器可能已经给我们做了优化。但是如果发生了，你需要知道为什么：</p><ul><li><code>&amp;c</code> 具有 <code>char*</code> 类型，因此 <code>std::cout</code> 尝试将其打印为字符串，直到遇到<code>\0</code>;</li><li>但很不幸地下一个地址是垃圾值，直到它终止前打印了一堆垃圾字符串。</li></ul><p>这个例子在现实情况不太可能发生，但对我们理解<code>std::cout</code> 如何工作很有帮助。</p><h4 id="2-1-4-指针和const">2.1.4 指针和const</h4><p>指针和const的组合通常让人感觉很迷惑，国内的相关考试也没少折磨过作者。本节，作者将尽量尝试用清晰、简洁的语言说明。</p><h5 id="指向常量的指针">指向常量的指针</h5><p>一个<strong>指向常量值的指针</strong>是指向常量值的（非常量）指针，它通常被如此声明（const位于<code>*</code>左侧即可）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 下面两种声明方式等同</span></span><br><span class="line"><span class="comment">// 只能使用右值进行初始化/赋值</span></span><br><span class="line"><span class="comment">// 可以指向非常量变量，但通过指针访问时该变量被视为常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p_value = &amp;value;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * p_value = &amp;value;</span><br></pre></td></tr></table></figure><p>“指向常量值的指针”，这里强调了两个要素：</p><ol><li><strong>指针是非const的</strong>，所以它本身可以被修改（存储的地址）；</li><li><strong>指针指向的变量是const的</strong>，它不能通过指针被修改（存储的地址对应的内存区域，即变量）。</li></ol><p>听起来有点绕，举个例子说明：</p><ul><li><p><strong>指针指向的变量无法被修改</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p_value = &amp;value; <span class="comment">// 指向“const int”</span></span><br><span class="line"><span class="comment">// 尝试修改变量value的值</span></span><br><span class="line">*p_value = <span class="number">6</span>; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure><p>更深刻地理解：<strong>指针指向整个内存区域都不能被修改</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p_array = <span class="keyword">new</span> <span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">cout&lt;&lt;*(p_array+<span class="number">1</span>)&lt;&lt;endl; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p><code>p_array</code>指向的好像只是是首元素（保存的是首元素地址），但其实应该理解为，指向的是分配给数组的整个连续内存区域。</p><p>如下，<code>p_array</code>所指向的内存区域任意数组元素都不能被修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(p_array+<span class="number">1</span>) = <span class="number">0</span>; <span class="comment">// 等价于：p_array[1] = 0;</span></span><br></pre></td></tr></table></figure><p>出错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: assignment of read-only location ‘*(p_array + 4u)’</span><br></pre></td></tr></table></figure><p>这种做法也使得我们可以放心地定义<u>指向常量的数组</u>。</p></li><li><p><strong>指针本身可以被修改</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p_value = &amp;value; <span class="comment">// 指向“const int”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试修改指针的值</span></span><br><span class="line"><span class="keyword">int</span> value1 = <span class="number">6</span>;</span><br><span class="line">p_value = &amp;value1; <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure></li></ul><p>那怎么让指针本身可以无法被修改？</p><h5 id="常量指针">常量指针</h5><p>常量指针，可以使得指针本身无法被修改，即指针对应内存区域存储的值（通常是存储一个地址）。</p><p>它通常被如此声明（const位于<code>*</code>右侧）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 声明常量指针</span></span><br><span class="line"><span class="comment">// 只能使用右值进行初始化/赋值</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p_value = &amp;value;</span><br></pre></td></tr></table></figure><p>“常量指针”，同样包含了两个要素：</p><ol><li><strong>指针是const的</strong>，所以它本身不可以被修改（存储的地址）；</li><li><strong>指针指向的变量是非const的</strong>，它能通过指针被修改。</li></ol><p>依旧是举个例子说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p_value1 = &amp;value1; <span class="comment">// 指向“int”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试修改指向的变量</span></span><br><span class="line">*p_value1 = <span class="number">7</span>; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试修改指针的值</span></span><br><span class="line"><span class="keyword">int</span> value2 = <span class="number">6</span>;</span><br><span class="line">p_value1 = &amp;value2; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure><p>好吧，或许有些变态般的需求，指针指向的值和指针都不可以被修改。请看下个小节。</p><p><strong>指向常量的常量指针</strong></p><p>最后，可以通过在类型之前和变量名之前使用const关键字，来声明<u>指向const 值的 const 指针</u>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value =  <span class="number">5</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> ptr = &amp;value ;</span><br></pre></td></tr></table></figure><p>正如你所需要的，指针和其指向的变量都无法被修改。</p><h5 id="最佳实践-2">最佳实践</h5><p>或许你有些疑问：const可以让指针或变量不被修改，很多时候可以保持程序的严谨、健壮性。这看起来确实有些优点，但它真的那么重要吗？</p><p>事实上，const非常重要&amp;有用！</p><ul><li>多位大师，比如候捷就曾说过：“程序写得是否大气严谨，大胆使用const就是直观的评价指标”。</li><li>所以，<u>大胆的在你的代码中使用const吧</u>。</li></ul><h5 id="扩展：函数与const">扩展：函数与const</h5><blockquote><p>选择性阅读：本节额外涉及到，<u>3.4 函数参数</u> &amp; 面对对象基本知识。</p></blockquote><p>const是衡量一个程序员是否老道的一个标准，除了修饰变量之外，主要便用于修饰函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp; a)</span></span>; <span class="comment">// 修饰返回值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a)</span></span>; <span class="comment">// 修饰形参</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp; a)</span> <span class="keyword">const</span></span>&#123;&#125; <span class="comment">// const成员函数</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>const修饰返回值</strong></p><p>const常用于返回值是引用类型的时候。</p><p>由于通常不会是局部变量的引用（返回局部引用是危险的，<u>3.5.3节</u>），那么通常是返回是，<u>函数参数/成员变量/全局变量</u>等。如果我们并不希望它们被修改，使用const修饰便可以做到这一点。</p><p>举个例子。</p><p>下面演示了没有const修饰函数返回值时，出现了我们并不期望的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salary</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> base;  <span class="comment">// base是不期望被修改的，但无法在这里被声明为const</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Salary</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        base = <span class="number">20000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Salary</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>&amp; <span class="title">get_base</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Salary s;</span><br><span class="line">    <span class="comment">// 修改base</span></span><br><span class="line">    s.<span class="built_in">get_base</span>() = <span class="number">22000</span>;</span><br><span class="line">    <span class="comment">// 修改成功</span></span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">get_base</span>()&lt;&lt;endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">22000</span><br></pre></td></tr></table></figure><p>但是，我们如果用const修饰函数返回值，私有成员<code>base</code> 便无法被修改（无法作为左值）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">get_base</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次尝试修改会报错：<code>error: assignment of read-only location ‘s.Salary::get_base()’</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 再次尝试修改base，非法</span></span><br><span class="line">s.<span class="built_in">get_base</span>() = <span class="number">22000</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>const修饰形参</strong></p><p>多数情况下，我们都会选择 pass by reference（按引用传递参数）。如果我们不希望修改实参的话，传递的引用参数请务必优先考虑加上const关键字。</p><p>这个很好理解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onlyPrint</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b = <span class="number">1</span>;   <span class="comment">// error，b无法作为左值</span></span><br><span class="line">    cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">onlyPrint</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别的，<strong>值传递传递用const修饰没有意义</strong>，因为形参本来就是拷贝了实参一份，和实参无关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onlyPrint</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> b)</span> <span class="comment">// 无意义，形参b和实参a完全独立</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>const成员函数</strong></p><p>这种情况多数情形下很容易被忽视，其实这个是非常重要的一个内容。</p><p>在前面<u>const返回值</u>避免了私有成员<code>base</code>被修改，但是依旧可能在函数返回前就不小心把<code>base</code> 修改了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salary</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> base;  <span class="comment">// base是不期望被修改的</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Salary</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        base = <span class="number">20000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Salary</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">get_base</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        base = <span class="number">22000</span>; <span class="comment">// 不小心在return前就修改了base</span></span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Salary s;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">get_base</span>()&lt;&lt;endl; <span class="comment">// 22000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们可以用const修饰整个成员函数，<strong>去避免成员函数修改对象成员变量</strong> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">get_base</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base = <span class="number">22000</span>; <span class="comment">// error，无法修改base</span></span><br><span class="line"><span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不过我们依然有疑问，const成员函数修饰了究竟是什么</strong>？</p><p>为什么要发出这种疑问，作者是不是神经质了？请看下例。</p><p>假设此时的<code>get_data()</code> 还没有被const修饰，也没做什么修改对象成员的事（很乖）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">get_base</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你尝试调用<code>get_data</code>方法出错了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Salary s;</span><br><span class="line">s.<span class="built_in">get_base</span>();</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: passing ‘const Salary’ as ‘this’ argument of ‘const int&amp; Salary::get_base()’ </span><br></pre></td></tr></table></figure><blockquote><p>好吧，不要和我说常量对象不能调用非常量函数之类的，我更想知道上面的报错是什么意思，深层次的原因是什么…</p></blockquote><p>报错大意是说，<code>get_base()</code> 函数有一个参数叫做<code>this</code>，尝试将实参 <code>const Salary</code> 传递给<code>this</code> 时出错。这由此需要解释两个问题：</p><ol><li><code>get_base()</code> 哪来的叫做<code>this</code>参数？</li><li><code>this</code> 指针是什么？</li></ol><p>其实在C++中任何成员函数的参数都隐含<code>this</code> 指针，不过不需要你显示写出来（熟悉python的同学是不是立马想到<code>self</code>？）。</p><p>比如，我们的<code>get_base</code> 在编译器眼中应该是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">get_base</span><span class="params">(Salary* <span class="keyword">this</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this</code> 指针指向正在操作成员函数的对象（在这里是<code>s</code> ）,此时对象的类型是<code>const Salary</code> 。</p><p>调用<code>s.get_base()</code> 在编译器眼里等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Salary s;</span><br><span class="line">s.<span class="built_in">get_base</span>(&amp;s);</span><br></pre></td></tr></table></figure><p>而我们的<code>get_base</code>函数参数类型是<code>Salary*</code> ，传递的形参<code>&amp;s</code>类型是<code>const Salary*</code> 。它们是不匹配的，故报错。</p><p>这也说明了，<strong>const 成员函数其实就是修饰了成员函数中this参数，也就是当前对象</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">get_base</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;       </span><br><span class="line">    base = <span class="number">22000</span>; <span class="comment">// 不小心在return前就修改了base</span></span><br><span class="line">      <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">get_base</span><span class="params">(<span class="keyword">const</span> Salary* <span class="keyword">this</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">    <span class="keyword">this</span>-&gt;base = <span class="number">22000</span>; <span class="comment">// 修改常量对象this，故出错</span></span><br><span class="line">    <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="扩展：类对象和const">扩展：类对象和const</h5><p>const修饰的对象，不能进行修改对象成员变量的尝试。</p><p>最明显的一点就是，const修饰的对象不能调用非const修饰的函数，即使函数没有修改任何数据成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salary</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> base;  <span class="comment">// base是不期望被修改的</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Salary</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        base = <span class="number">20000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Salary</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>&amp; <span class="title">print_base</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;base&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Salary s;  <span class="comment">// const修饰对象</span></span><br><span class="line">    s.print_base;    <span class="comment">// error，不能调用非const的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过编译也很简单，const修饰函数即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">print_base</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;base&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-X-智能指针🌟">2.1.X 智能指针🌟</h4><h5 id="从内存泄漏说起">从内存泄漏说起</h5><blockquote><p>和内存碎片概念区分。</p></blockquote><p>一般我们常说的内存泄漏是指<strong>堆内存的泄漏</strong>。</p><p>使用malloc,、realloc、 new等函数从堆中分配到块内存后，没有相应的调用free或delete释放该内存块，<strong>导致这块内存就不能被再次使用</strong>。这就是内存泄漏。</p><ul><li><p>例1，双重分配泄漏内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>();</span><br><span class="line">ptr = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>();  <span class="comment">// ptr指向了新一块内存，原来存储的内存地址丢失</span></span><br></pre></td></tr></table></figure></li><li><p>例2，类似指针不释放原先指向的内存区域。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>* ptr = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(); <span class="comment">// 堆上分配内存，返回分配的内存首地址</span></span><br><span class="line">ptr = &amp;value; <span class="comment">// 堆上内存没有释放，其ptr保存的地址丢失</span></span><br></pre></td></tr></table></figure></li></ul><p>上面感受可能不够直观，我们来举个具体例子。</p><p>下面一个很简单<code>int</code>堆内存（4字节）忘记使用delete释放，执行了百万次（比如线上代码的高频基础函数），便损失了40M内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;free -m&quot;</span>);</span><br><span class="line">    <span class="comment">// 内存泄漏*100W次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>* s = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>();</span><br><span class="line">        s = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>();</span><br><span class="line">        <span class="comment">// delete s;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;free -m&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出（栈占用了1M内存）：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220116122756258.png" alt="image-20220116122756258"></p><p>试想：如果不是简单int，而是复杂的大对象，很快就能把服务器所有内存干完。</p><p><strong>避免内存泄漏的几种方式</strong></p><p>在C++11前，我们通常通过以下方法尽量保证内存不被泄漏。</p><ol><li><p>利用&quot;查找&quot;功能，查询<code>new</code>与<code>delete</code>，看看内存的申请与释放是不是成对释放的，这使你迅速发现一些逻辑较为简单的内存泄漏情况。</p></li><li><p>计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄漏；</p></li><li><p>将基类的析构函数声明为<strong>虚函数</strong>，让子类去调用父类的析构函数，避免父类没有申请的空间没有被释放。</p></li></ol><p>当然，我们还可以使用一些检测工具：</p><ul><li>Linux下可以使用<strong>Valgrind工具</strong></li><li>Windows下可以使用<strong>CRT库</strong></li></ul><p><strong>但无论如何，在传统 C++ 中，『记得』手动释放资源，总不是最佳实践</strong>。</p><p>人远没有机器可靠，我们总可能在什么时候就忘记去是否内存资源。幸运的是，<strong>在C++11<u>智能指针</u>的概念中，对对象使用了<u>引用计数</u>，让程序员不再需要关心内存释放问题</strong>。</p><h5 id="智能指针简介">智能指针简介</h5><p>为了减少出现内存泄漏的情况，在C++ 11 中，移动语义的引入，结合 RAII ，采用代理模式的思想，管理动态分配对象的生命周期。</p><p>C++11提供四种智能指针供使用:</p><table><thead><tr><th style="text-align:center">指针类别</th><th style="text-align:center">支持</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><code>unique_ptr</code></td><td style="text-align:center">C++ 11</td><td style="text-align:center">拥有独有对象所有权语义的智能指针</td></tr><tr><td style="text-align:center"><code>shared_ptr</code></td><td style="text-align:center">C++ 11</td><td style="text-align:center">拥有共享对象所有权语义的智能指针</td></tr><tr><td style="text-align:center"><code>weak_ptr</code></td><td style="text-align:center">C++ 11</td><td style="text-align:center">std::shared_ptr 所管理对象的弱引用</td></tr><tr><td style="text-align:center"><code>auto_ptr</code></td><td style="text-align:center">C++ 17中移除</td><td style="text-align:center">拥有严格对象所有权语义的智能指针</td></tr></tbody></table><p>本文主要关注，  <code>std::shared_ptr</code>、<code>std::unique_ptr</code>、<code>std::weak_ptr</code>，使用它们需要包含头文件 <code>&lt;memory&gt;</code>。</p><h5 id="std-shared-ptr">std::shared_ptr</h5><p><code>std::shared_ptr</code> 是一种智能指针，一个动态分配的对象可以在多个 <code>std::shared_ptr</code> 之间共享。</p><ul><li><p>对象每多一个<code>shared_ptr</code> 指针计数就+1，反之-1；</p><blockquote><p>为保证线程安全，引用计数的增减必须是原子操作。</p></blockquote></li><li><p>动态分配的控制块包括了引用计数，弱引用计数，自定义的析构器等等数据。</p></li></ul><p>配套使用的还有<code>std::make_shared</code>方法 ：</p><ul><li>消除显式的使用 <code>new</code>，分配创建传入参数中的对象， 并返回这个对象类型的<code>std::shared_ptr</code>指针。</li></ul><p>这样一来，<code>std::shared_ptr</code> 能够通过访问引用计数来<u>确定自身是否是最后一个指向该对象的</u>：如果是，则析构该对象；否则将引用计数减一。</p><p>一个简单使用实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(std::shared_ptr&lt;<span class="keyword">int</span>&gt; i)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*i)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 原先创建对象需显示new声明：int* pointer = new int&#123;10&#125;;</span></span><br><span class="line">    <span class="comment">// shared_ptr消除了new显示声明</span></span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; pointer = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">foo</span>(pointer);</span><br><span class="line">    std::cout &lt;&lt; *pointer &lt;&lt; std::endl; <span class="comment">// 11</span></span><br><span class="line">    <span class="comment">// pointer离开作用域，此时引用计数为1，判断出自己是最后一个指向对象</span></span><br><span class="line">    <span class="comment">// 自动调用delete析构该对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::shared_ptr</code> 还有其它的一些有用方法：</p><ul><li><code>get()</code> 方法来获取原始指针；</li><li><code>reset()</code> 来减少一个对象的引用计数；</li><li><code>use_count()</code>来查看一个对象的引用计数。</li></ul><p>使用<code>auto</code> 关键字替代<code>std::shared_ptr&lt;int&gt;</code> 声明。</p><p>*注释的数字表示一开始声明的对象，被多少shared_ptr所指向。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pointer = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">auto</span> pointer2 = pointer; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">auto</span> pointer3 = pointer; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = pointer.<span class="built_in">get</span>(); <span class="comment">// 不会增加引用计数</span></span><br><span class="line">pointer.<span class="built_in">use_count</span>(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">pointer2.<span class="built_in">reset</span>();</span><br><span class="line">pointer3.<span class="built_in">reset</span>();</span><br><span class="line">pointer.<span class="built_in">use_count</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong><code>std::shared_ptr</code> 看着很美好，但它存在循环引用的问题</strong>。</p><p>请看下例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::shared_ptr&lt;B&gt; pointer;</span><br><span class="line">    ~<span class="built_in">A</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::shared_ptr&lt;A&gt; pointer;</span><br><span class="line">    ~<span class="built_in">B</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = std::make_shared&lt;A&gt;(); <span class="comment">// 此时指针a指向的对象记为A对象</span></span><br><span class="line">    <span class="keyword">auto</span> b = std::make_shared&lt;B&gt;(); <span class="comment">// 此时指针b指向的对象记为B对象</span></span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">use_count</span>()&lt;&lt;endl; <span class="comment">// A对象计数：1</span></span><br><span class="line">    cout&lt;&lt;b.<span class="built_in">use_count</span>()&lt;&lt;endl; <span class="comment">// B对象计数：1</span></span><br><span class="line">    a-&gt;pointer = b; </span><br><span class="line">    b-&gt;pointer = a; </span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">use_count</span>()&lt;&lt;endl; <span class="comment">// A对象计数：2，内部引用B对象</span></span><br><span class="line">    cout&lt;&lt;b.<span class="built_in">use_count</span>()&lt;&lt;endl; <span class="comment">// B对象计数：2，内部引用A对象，发生循环引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时运行对象A、B均不会被销毁（引用计数不为0）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><ul><li>main 函数退出前，B 对象的引用计数为2，A 对象的引用计数为 2；</li><li>main 函数退出后：b 指针销毁，B 对象的引用计数变为 1；a 指针销毁，A 对象的引用计数变为1；</li></ul><p>这样就导致了 对象A、B的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄漏。</p><p><img src="https://changkun.de/modern-cpp/assets/figures/pointers1.png" alt="图 5.1"></p><p><code>std::weak_ptr</code> 的存在便可以解决这个问题。</p><h5 id="std-weak-ptr">std::weak_ptr</h5><p><code>std::weak_ptr</code>是一种弱引用（相比较而言 <code>std::shared_ptr</code> 就是一种强引用）。</p><p><code>std::weak_ptr</code> 是针对 <code>std::shared_ptr</code> 功能的扩展， 不能解引用，也不能检查是否为空，<u>主要作用是用于观察 <code>std::shared_ptr</code> 的内部状态，查看其引用计数</u>，<u>查看指针是否空悬</u>，是一种具有临时所有权语义的智能指针。</p><p><strong>为什么需要<code>std::weak_ptr</code></strong>？</p><p>一种常用的用法就是前面所说，打断 <code>std::shared_ptr</code> 所管理的对象组成的环状引用。</p><p>上代码解释。</p><p>和前面唯一的区别是<u>只在</u>结构体<code>B</code>内部替换了<code>std::shared_ptr</code>  --&gt; <code>std::weak_ptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::shared_ptr&lt;B&gt; pointer; <span class="comment">// 强引用</span></span><br><span class="line">    ~<span class="built_in">A</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::weak_ptr&lt;A&gt; pointer; <span class="comment">// 替换为弱引用</span></span><br><span class="line">    ~<span class="built_in">B</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主函数中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = std::make_shared&lt;A&gt;(); <span class="comment">// 此时指针a指向的对象记为A对象</span></span><br><span class="line">    <span class="keyword">auto</span> b = std::make_shared&lt;B&gt;(); <span class="comment">// 此时指针b指向的对象记为B对象</span></span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">use_count</span>()&lt;&lt;endl; <span class="comment">// A对象计数：1</span></span><br><span class="line">    cout&lt;&lt;b.<span class="built_in">use_count</span>()&lt;&lt;endl; <span class="comment">// B对象计数：1</span></span><br><span class="line">    a-&gt;pointer = b; </span><br><span class="line">    b-&gt;pointer = a; </span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">use_count</span>()&lt;&lt;endl; <span class="comment">// A对象计数：1，内部弱引用B对象，引用计数没有增加</span></span><br><span class="line">    cout&lt;&lt;b.<span class="built_in">use_count</span>()&lt;&lt;endl; <span class="comment">// B对象计数：2，内部引用A对象，发生循环引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果，一切岁月静好（析构函数被执行）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">A 被销毁</span><br><span class="line">B 被销毁</span><br></pre></td></tr></table></figure><p>可见弱引用不会引起引用计数增加（A对象的引用计数始终是1），当换用弱引用时候，最终的释放流程如图所示（虚线表示弱引用）：</p><p><img src="https://changkun.de/modern-cpp/assets/figures/pointers2.png" alt="图 5.2"></p><ul><li>main 函数退出前，B 对象的引用计数为2，A 对象的引用计数为 1；</li><li>b 指针销毁，B 对象的引用计数变为 1；</li><li>a 指针销毁，A 对象的引用计数变为0，A 对象立刻析构，A 对象析构的过程中会导致其包含的 b 指针被销毁，从而导致 B 对象的引用计数变为0，使得 B 对象也被正常析构。</li></ul><h5 id="std-unique-ptr">std::unique_ptr</h5><p>在前面<code>std::shared_ptr</code>，可以使得多个智能指针共有一个对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pointer = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 引用计数：1</span></span><br><span class="line"><span class="keyword">auto</span> pointer2 = pointer; <span class="comment">// 引用计数：2</span></span><br><span class="line"><span class="keyword">auto</span> pointer3 = pointer; <span class="comment">// 引用计数：3</span></span><br></pre></td></tr></table></figure><p>然而<code>std::unique_ptr</code> 是一种独占的智能指针， 是具有<u>专属所有权语义</u>（exclusive ownership semantics）的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全。</p><p><strong>为什么需要<code>std::unique_ptr</code></strong>？</p><ol><li>避免内存泄漏，这没什么好说的；</li><li>避免更大开销，相比于shared_ptr，它的开销更小，甚至可以说和裸指针相当，它<u>不需要维护引用计数的原子操作</u>等等。</li></ol><p>回到前面，既然<code>std::unique_ptr</code>是独占，也就是不可复制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pointer = std::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 引用计数：1</span></span><br><span class="line"><span class="keyword">auto</span> pointer2 = pointer; <span class="comment">// 报错，此时pointer2无法作为左值，即无法将pointer复制给pointer2</span></span><br></pre></td></tr></table></figure><p><code>std::make_unique</code>  在C++14才被支持（C++11委员主席原话说他忘了）需要我们自己实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">( Args&amp;&amp; ...args )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::unique_ptr&lt;T&gt;( <span class="keyword">new</span> <span class="built_in">T</span>( std::forward&lt;Args&gt;(args)... ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然<code>unique_ptr</code>不能复制，但我们可以利用 <code>std::move</code> 将对象所有权转移给其它的 <code>unique_ptr</code>，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;执行Foo构造函数&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;执行Foo析构函数&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;执行Foo函数foo&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Foo&gt; p1 = make_unique&lt;Foo&gt;();</span><br><span class="line">    p1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    <span class="comment">// std::move转移p1指向的Foo对象所有权给p2</span></span><br><span class="line">    std::unique_ptr&lt;Foo&gt; p2 = std::<span class="built_in">move</span>(p1);</span><br><span class="line">    p2-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    <span class="comment">// 函数退出前（准确来说，是离开作用域前），Foo对象被销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行Foo构造函数</span><br><span class="line">执行Foo函数foo</span><br><span class="line">执行Foo函数foo</span><br><span class="line">执行Foo析构函数</span><br></pre></td></tr></table></figure><ol><li>创建对象，构造函数进行初始化并由智能指针<code>p1</code> 管理，输出“执行Foo构造函数”；</li><li>执行foo函数，输出“执行Foo函数foo”；</li><li><code>std::move</code>转移原先<code>p1</code> 所指向的Foo对象（内存区域）所有权转移给了<code>p2</code> ，因此并没有创建新对象，故代码16行处不会产生输出；</li><li>执行foo函数，“执行Foo函数foo”；</li><li><code>p2</code> 管理的对象离开作用范围，析构函数自动执行，“执行Foo析构函数”。</li></ol><h3 id="2-2-引用">2.2 引用</h3><p>在本章开篇我们便已提到，尽量避免使用指针。最重要的原因便是指针它的不安全性与不确定性，一个crazy的野指针可能会让你更加crazy。</p><p>条件允许的话，请多多使用引用：</p><ol><li><strong>更安全</strong>。引用使用前必须初始化，且不能为空；指针可以随意改变他的指向的对象（野指针的一大温床），但引用不可以。</li><li><strong>效率更高</strong>。指针最后析构时，要处理内存释放问题。</li><li><strong>数组不会退化为指针</strong>。将数组引用作为参数时，不会像指针传递一样退化为指针。</li></ol><p>现在我们来进行更详细的介绍。</p><h4 id="2-2-1-引用简介">2.2.1 引用简介</h4><h5 id="引用初识">引用初识</h5><p><strong>声明</strong>一个引用很简单，类型+<code>&amp;</code> 即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;  <span class="comment">// 引用声明必须初始化</span></span><br></pre></td></tr></table></figure><p><strong>引用就是变量的别名</strong>，对引用的任何操作等价于操作于本体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">1</span>;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>变量a、b被视为同义词。在<code>b</code>上返回地址，会打印<code>a</code>的地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 0x7fff16db208c</span></span><br><span class="line">std::cout &lt;&lt; &amp;b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 0x7fff16db208c</span></span><br></pre></td></tr></table></figure><p>特别的引用还有两个重要特性：</p><ol><li><p><strong>无法修改引用指向，可以理解为引用默认就是常量引用</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line">b = c;  <span class="comment">// 等价于：b=2，无法重新指向c</span></span><br></pre></td></tr></table></figure></li><li><p><strong>就像指针一样，引用只能用左值（l值）进行赋值</strong></p><p>（结合下节理解）因为只有左值才有属于自己内存地址，才能引用时间接寻址找到本体变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp; b = a; <span class="comment">// 合法，变量b是左值</span></span><br><span class="line"><span class="keyword">int</span>&amp; b = <span class="number">1</span>; <span class="comment">// 非法，文字1是右值</span></span><br><span class="line"><span class="keyword">int</span>&amp; b = a+<span class="number">1</span>; <span class="comment">// 非法，表达式a+1也是右值</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="从汇编角度看引用">从汇编角度看引用</h5><p>引用到底是什么？变量的别名？是指针？初学者难免都要被绕晕。</p><p>这里先给出结论：<strong>引用的本质就是一个常量指针，指针在CPU眼中也和一个普通变量没什么区别</strong>。</p><p>铁证如下，堂下引用还不露出原型？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用引用</span></span><br><span class="line">    <span class="keyword">int</span>&amp; b = a;</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用指针</span></span><br><span class="line">    <span class="keyword">int</span>* c = &amp;a;</span><br><span class="line">    *c = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应汇编代码：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220116151955111.png" alt="image-20220116151955111"></p><p>可以看到使用指针（②处）和使用引用（①处）汇编代码基本一致。以指针汇编代码为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 将变量a的地址（-20(%rbp)）存入寄存器rax</span><br><span class="line">leaq    -20(%rbp), %rax</span><br><span class="line"># 为指针c分配内存（-16(%rbp)），同时将变量a的地址存入</span><br><span class="line">movq    %rax, -16(%rbp)</span><br><span class="line"># 指针的值（变量a的地址）存入寄存器rax</span><br><span class="line">movq    -16(%rbp), %rax</span><br><span class="line"># 将立即数通过间接寻址(),赋值给变量a</span><br><span class="line">movl    $2, (%rax)</span><br></pre></td></tr></table></figure><p>这说明，<strong>引用在编译器眼里就是一个指针，存储了变量地址，使用引用时编译器会自动加上间接操作符<code>*</code>，本质还是一样的</strong> 。</p><p>不过这个“指针”还是“常量指针”，所以引用本身无法被修改且必须初始化（const修饰的特性）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; b = a;  <span class="comment">// 编译器眼里等价于：int* const b = &amp;a;</span></span><br><span class="line">b = <span class="number">1</span>;       <span class="comment">// 编译器眼里等价于：*b=1</span></span><br></pre></td></tr></table></figure><p>希望看到这儿的你有种豁然开朗的感觉。</p><h4 id="2-2-2-引用和const">2.2.2 引用和const</h4><p>前面我们说到，引用本身就不能改变，因此“引用”本来就具备“常量引用”特性（无法修改）。</p><p>在C++中也不存在“常量引用”这个概念：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">const</span> b = a;  <span class="comment">// error: ‘const’ qualifiers cannot be applied to ‘int&amp;’</span></span><br></pre></td></tr></table></figure><p>但存在指向<u>指向常量的引用</u>。</p><h5 id="指向常量的引用">指向常量的引用</h5><p>就像“指向常量的指针”，指向常量的引用可以用<u>常量或非常量的<strong>左值</strong></u>进行<strong>初始化</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; c = a;  <span class="comment">// ok，a是左值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; d = b;  <span class="comment">// ok，b是左值</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span> ; <span class="comment">// ok</span></span><br><span class="line">c = <span class="number">3</span> ; <span class="comment">// error，指向常量的引用将变量当做常量，即使变量本身不是声明为常量</span></span><br></pre></td></tr></table></figure><p>但指向常量的引用，<strong>还可以使用<u>文字右值</u>初始化</strong>（这和普通引用/指针不同）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; e = <span class="number">5</span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><h5 id="引用作为函数参数">引用作为函数参数</h5><p>引用作为函数参数相比指针作为参数更加推荐，原因就是本节开头所说：安全、效率高、避免了数组退化问题。</p><p>条件允许的话，我们还建议你<u>尽量使用const修饰引用</u>，这可以避免传递的参数被修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x = 1 ; // 不合法</span></span><br><span class="line">    std::cout &lt;&lt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-指针和引用小结">2.2.3 指针和引用小结</h4><p>前面核心内容总结：</p><ul><li><strong>本质</strong>：引用本质就是<u>常量指针</u>，指针本质就是<u>存储了其它变量地址的变量</u>。</li><li><strong>声明/赋值</strong>：引用和指针都<u>只能用左值</u>进行初始化/赋值（但<u>指向常量的引用可以用右值</u>初始化），引用还必须声明时就初始化。</li><li><strong>const+指针/引用</strong>：const位于<code>&amp;</code> / <code>*</code> 前后具有不同语义；const让修饰的变量无法被修改。</li><li><strong>智能指针</strong>：善于使用智能指针帮我们自动管理内存释放，循环引用使用<code>std::weak_ptr</code>进行解决。</li></ul><p>指针和引用的区别：</p><ol><li><strong>本质</strong>：指针本质是变量，引用本质是指针也是变量；</li><li><strong>初始化</strong>：引用必须初始化（且不能为NULL），指针不必要初始化（但不初始化就使用是使用野指针）；</li><li><strong>赋值</strong>：引用和指针都<u>只能用左值</u>进行初始化/赋值（但<u>指向常量的引用可以用右值</u>初始化）；</li><li><strong>修改</strong>：引用一旦初始化之后就不可以再改变，指针变量可以重新指向别的变量；</li><li>…</li></ol><h3 id="2-3-功力提升">2.3 功力提升</h3><h4 id="2-3-1-循环你真的会了吗：for-each-迭代器">2.3.1 循环你真的会了吗：for_each&amp;迭代器</h4><p>少年，想更优雅的遍历假装高手吗？</p><p>来使用更简单、更安全的循环称为<strong>for-each</strong>循环、<strong>迭代器</strong>替换普通的for循环吧。</p><h5 id="for-each">for_each</h5><p><em>for</em> 循环遍历元素时更加的灵活（比如<u>指定长度的数组元素</u>），但也很容易出错。比如你不小心写错了数组长度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ; i&lt;<span class="number">4</span> ; i++)</span><br><span class="line">   std::cout&lt;&lt;arr[i]&lt;&lt;std::endl; <span class="comment">// 出错，访问arr[3]越界</span></span><br></pre></td></tr></table></figure><p><em>for-each</em> 提供了更简单、安全的方式，特别你需要获取<u>所有元素</u>的情况。</p><ul><li><em>for-each</em> 还适合<code>std::array</code>、<code>std::vector</code>等容器；</li><li><em>for-each</em> 不适合指向数组的指针（动态数组），因为指针不是数组，无法遍历（根本原因是无法根据指针知道数组的长度）。</li></ul><p><em>for-each</em>语句的语法如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (element_declaration : array)</span><br><span class="line">   statement;</span><br></pre></td></tr></table></figure><p>试一试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num:arr)</span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;num&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好起来了。</p><p>我们还可以优化上面的程式，让世界更美好：</p><ul><li><strong>使用引用</strong>。<em>for-each</em> 用<u>值复制</u>方式把数组每个元素复制给<code>num</code> ，这显然有点糟糕，使用<u>引用更好</u>。</li><li><strong>const修饰</strong>。一个大气的程序员要善于使用const，这里显然不需要改动</li></ul><p>这里还是使用auto关键字自动推断类型（懒蛋狂喜）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// auto关键字会消除&amp;和const语义，所以这里显示声明</span></span><br><span class="line"><span class="comment">// 请参考，3.X节：再谈auto</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num:arr)</span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;num&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>美好的世界值得吟诗一首。</p><blockquote><p>深圳夏天的阳光刺得眼睛眯成一条缝</p><p>腾讯大厦外天空蓝得可以看见白云</p><p>感觉一切暖洋洋、软绵绵</p><p>我也慢悠悠、晃荡荡</p><p>好像就要飘去外太空</p><p>— by royhuang</p></blockquote><h5 id="迭代器">迭代器</h5><p><strong>迭代器</strong> 旨在用来遍历容器的对象（例如，数组中的值，或字符串中的字符），提供对每个元素的<u>访问</u>。</p><p>迭代器并没有那么神秘，我们熟悉的指针（应该已经熟悉了吧？）就可以当做迭代器。</p><p>依旧是改写之前的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* begin = arr; </span><br><span class="line"><span class="comment">// 注意，此时end指向的数组尾元素下一个位置，不是尾元素</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* end = begin+<span class="built_in"><span class="keyword">sizeof</span></span>(arr)/<span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 此时ptr就是迭代器</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span>* ptr = begin ; ptr != end ; ptr++)</span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;*ptr&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<u>标准库容器</u> 还通常会直接提供对迭代的支持，无需自己写。</p><p>以<code>std::array</code> 为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::array array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> begin =  array.<span class="built_in">begin</span>(); </span><br><span class="line">    <span class="keyword">auto</span> end =  array.<span class="built_in">end</span>() ; <span class="comment">// 数组尾元素的下一个元素</span></span><br><span class="line">    <span class="comment">// 迭代器基于for循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p=begin ; p != end; ++p) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; *p &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure><p>当然你使用<em>for</em> 或者 <em>for_each</em> 循环遍历库容器也是ok的。</p><h5 id="小结">小结</h5><ul><li><p>遍历数组、库容器等可以使用<em>for</em>循环、<em>for_each</em>循环以及<u>迭代器（基于<em>for</em>循环</u>）。</p></li><li><p>库容器都支持迭代器，因此对于库容器，使用<em>for</em>循环+迭代器更好（复杂的循环最好的做法是结合库函数使用，比如<code>std::sort</code> ，2.3.3节介绍）。</p></li></ul><h4 id="2-3-2-使用更好的数组：array-vector">2.3.2 使用更好的数组：array&amp;vector</h4><p>在前面我们详细讨论了固定数组和动态数组，尽管两者都内置于 C++ 语言中，但它们都有缺点：</p><ol><li>固定数组衰减为指针，这样做时会丢失数组长度信息；</li><li>动态数组存在混乱的释放问题，并且难以无误地调整大小。</li></ol><p>因此我们说使用<u>array&amp;vector</u>替代C++内置数组，是更好的编程实践。</p><h5 id="std-array：替代静态数组">std::array：替代静态数组</h5><p><code>std::array</code> 提供<u>固定</u>的数组功能，<u>当传递给函数时不会衰减，而且超出范围时会自行清理</u>。</p><p>声明和使用一个<code>std::array</code>变量很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++17前不允许省略长度</span></span><br><span class="line">std::array&lt;<span class="keyword">int</span>, 3&gt; my_array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">my_array[<span class="number">1</span>];  <span class="comment">// 和普通数组一样使用</span></span><br></pre></td></tr></table></figure><p>注意到<code>std::array</code> 和普通数组差别很大（可以重新赋值）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_array = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  <span class="comment">// 重新赋值，内置的数组更像是个常量指针，一旦初始化不能重新赋值</span></span><br></pre></td></tr></table></figure><p>验证一下<code>std::array</code> 作为函数参数不会退化为指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">const</span> std::array&lt;<span class="keyword">float</span>, <span class="number">5</span>&gt;&amp; my_array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; elem : my_array) <span class="comment">// 不会衰减为指针，可以使用for_each循环</span></span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::array&lt;<span class="keyword">float</span>, 5&gt; my_array = &#123; <span class="number">9.0</span>, <span class="number">7.2</span>, <span class="number">5.4</span>, <span class="number">3.6</span>, <span class="number">1.8</span> &#125;;</span><br><span class="line">    <span class="built_in">printArray</span>(my_array);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// my_array被自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 7.2 5.4 3.6 1.8 </span><br></pre></td></tr></table></figure><p>优化：使用模板让函数支持<u>任意类型的参数、长度</u>的数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="keyword">size_t</span> size&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">const</span> std::array&lt;T, size&gt;&amp; my_array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; elem : my_array)</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这涉及到模板相关知识，暂不细表。</p><p>当然，<code>std::array</code>不限于数字作为元素，可以在常规数组中使用的每种类型都可以在<code>std::array</code>中使用。</p><p><strong>请看下面的结构数组</strong>。</p><p>注意相比普通结构体数组，array结构体数组初始化还要多一对大括号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">House</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> stories&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> roomsPerStory&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    House houses[] = </span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        &#123; 13, 4, 30 &#125;,</span></span><br><span class="line"><span class="comment">        &#123; 14, 3, 10 &#125;,</span></span><br><span class="line"><span class="comment">        &#123; 15, 3, 40 &#125;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    std::array&lt;House, 3&gt; houses = </span><br><span class="line">    &#123; </span><br><span class="line">        &#123;  <span class="comment">// 外侧多了一对大括号，否则初始化会出错</span></span><br><span class="line">            &#123;<span class="number">13</span>, <span class="number">4</span>, <span class="number">30</span> &#125;,  </span><br><span class="line">            &#123;<span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span> &#125;, </span><br><span class="line">            &#123;<span class="number">15</span>, <span class="number">3</span>, <span class="number">40</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; house : houses)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;House number &quot;</span> &lt;&lt; house.number</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; has &quot;</span> &lt;&lt; (house.stories * house.roomsPerStory)</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; rooms\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">House number 13 has 120 rooms</span><br><span class="line">House number 14 has 30 rooms</span><br><span class="line">House number 15 has 120 rooms</span><br></pre></td></tr></table></figure><blockquote><p><code>std::array</code>  有用的方法。</p></blockquote><p>公共代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="keyword">int</span>, 5&gt; my_array = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><ol><li><p>获取大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myArray.<span class="built_in">size</span>(); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li><li><p>排序</p><p>2.3.3节有详细的介绍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span> <span class="comment">// for std::sort</span></span></span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(myArray.<span class="built_in">begin</span>(), myArray.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li></ol><p><strong>小结</strong>：<code>std::array</code> 声明时必须要指定长度有点笨拙，但它有很多优点----<u>比如不会退化为指针</u>、<u>不用手动释放内存</u>，<u>标准库众多函数支持</u>。所以尽可能地去使用它替代普通静态数组吧。</p><h5 id="std-vector：替代动态数组">std::vector：替代动态数组</h5><p>相比<code>std::array</code> 提供<u>固定</u>的数组 ，<code>std::vector</code> 同样会自动管理数组内存，不衰减为指针。</p><p>而且<code> std::vector</code> 还支持<u>可变</u>的数组，也就是<u>动态数组</u>。</p><p>一个简单例子，注意到 <code>std::vector</code>声明时不必指明长度（动态数组特性）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; array;  <span class="comment">// 动态数组，可稍后初始化，不必指针长度</span></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; array2 = &#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">array2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">// 可以重新分配</span></span><br><span class="line">array[<span class="number">1</span>]; <span class="comment">// 使用和普通数组一样</span></span><br></pre></td></tr></table></figure><p>类似的，<code>std::vector</code> 作为函数参数不会退化为指针，这里不再重复验证。</p><blockquote><p><code>std::vector</code>  有用的方法。</p></blockquote><p>公共代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; my_array = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><ol><li><p>获取大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_array.<span class="built_in">size</span>(); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li><li><p>调整大小</p><p>调大后多余空间默认用<code>0</code>填充。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_array.<span class="built_in">resize</span>(<span class="number">8</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : my_array)</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 1 2 3 4 5 0 0 0</span></span><br></pre></td></tr></table></figure><p>向下调整，只打印resize后长度包含的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_array.<span class="built_in">resize</span>(<span class="number">3</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : my_array)</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>小细节：<code>std::vector</code>  中容量和长度并不相等。</p></blockquote><p><strong>长度</strong>是数组中使用了多少元素，而<strong>容量</strong>是在内存中分配了多少元素。</p><p>为了避免频繁的<code>resize</code>分配空间（调整数组大小通常<u>代价比较昂贵</u>），<code>std::vector</code> 中长度和容量不一定相等。</p><p>下面代码看起来好像一切正常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; array2 = &#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; array2.<span class="built_in">size</span>() &lt;&lt;std::endl;</span><br><span class="line">std::cout &lt;&lt; array2.<span class="built_in">capacity</span>() &lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>但是我们如果进行<code>resize</code>后再看 ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array2.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; array2.<span class="built_in">size</span>() &lt;&lt;std::endl; <span class="comment">// []基于长度，array[4]非法</span></span><br><span class="line">std::cout &lt;&lt; array2.<span class="built_in">capacity</span>() &lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>容量依旧是<code>5</code> 并没有随之改变，即预留了一些空间，<u>这样如果再次发生resize&lt;=5可以不用重新分配空间</u>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array2.<span class="built_in">resize</span>(<span class="number">4</span>);</span><br><span class="line">std::cout &lt;&lt; array2.<span class="built_in">size</span>() &lt;&lt;std::endl;</span><br><span class="line">std::cout &lt;&lt; array2.<span class="built_in">capacity</span>() &lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span>  # 数组实际上没有进行resize，还是之前的容量<span class="number">4</span></span><br></pre></td></tr></table></figure><blockquote><p>leetcode神器：<code>std::vector</code> 还有一大用途是作为堆栈使用。</p></blockquote><p>一个简单的小例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> element : stack)</span><br><span class="line">std::cout &lt;&lt; element &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;(cap &quot;</span> &lt;&lt; stack.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot; length &quot;</span> &lt;&lt; stack.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; stack&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printStack</span>(stack);   <span class="comment">// (cap 0 length 0)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3--&gt;2--&gt;1 依次压入</span></span><br><span class="line">stack.<span class="built_in">push_back</span>(<span class="number">3</span>); </span><br><span class="line"><span class="built_in">printStack</span>(stack);   <span class="comment">// 3 (cap 1 length 1)</span></span><br><span class="line"></span><br><span class="line">stack.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printStack</span>(stack);   <span class="comment">// 3 2 (cap 2 length 2)</span></span><br><span class="line"></span><br><span class="line">stack.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printStack</span>(stack);  <span class="comment">// 3 2 1 (cap 4 length 3)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1--&gt;2--&gt;3 依次弹出</span></span><br><span class="line">stack.<span class="built_in">pop_back</span>(); </span><br><span class="line"><span class="built_in">printStack</span>(stack); <span class="comment">// 3 2 (cap 4 length 2)</span></span><br><span class="line"></span><br><span class="line">stack.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">printStack</span>(stack); <span class="comment">// 3 (cap 4 length 1)</span></span><br><span class="line"></span><br><span class="line">stack.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">printStack</span>(stack); <span class="comment">// (cap 4 length 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个细节需注意：</p><ol><li>容量经过：0–&gt;1–&gt;2–&gt;4，四次调整容量，比较影响性能；</li><li>当<code>vector</code>被调整大小时，可能会分配比需要的更多的容量（第三次push进<code>1</code>后，容量从2–&gt;4，而不是2–&gt;3）。</li></ol><p>为了避免容量被频繁调整，我们可以提前分配一定容量（leetcode避免超时）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加到代码14行处</span></span><br><span class="line">stack.<span class="built_in">reserve</span>(<span class="number">5</span>);   <span class="comment">// 预分配容量5</span></span><br></pre></td></tr></table></figure><p>再次打印出容量变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(cap 5 length 0)</span><br><span class="line">3 (cap 5 length 1)</span><br><span class="line">3 2 (cap 5 length 2)</span><br><span class="line">3 2 1 (cap 5 length 3)</span><br><span class="line">3 2 (cap 5 length 2)</span><br><span class="line">3 (cap 5 length 1)</span><br><span class="line">(cap 5 length 0)</span><br></pre></td></tr></table></figure><p>perfect~整个过程除了第一次调整过容量，便没有再次调整过了。</p><h4 id="2-3-3-多使用标准库算法">2.3.3 多使用标准库算法</h4><p>前面我们说到，库容器<code>std::array</code>、<code>std::vector</code>一大好处就是被标准库支持很多相关算法。</p><ul><li><p>对于新手程序员玩家来说，<u>自己写循环遍历数组是经常需要做的事</u>。简单的可能只是为了<u>打印</u>下数组，复杂点可能还要去处理数组<u>排序</u>、<u>查找</u>、<u>计数</u>等。</p></li><li><p>但如果我们使用的<u>库容器</u>，就可以很好配合C++标准库函数，轻松地完成复杂的循环处理操作（大佬预先帮你写好接口不舒服嘛？）。</p></li></ul><p>C++标准库提供的函数功能分为三类：</p><ul><li><strong>Inspectors</strong> ：检查器，仅只读容器中的数据，比如搜索和计数；</li><li><strong>Mutators</strong> ：修改器，修改容器中数据，比如排序或分发；</li><li><strong>Facilitators</strong>：促进器，根据数据成员的值生成结果。</li></ul><p>本节将介绍常用的一些算法，虽然只是一小部分，但是大部分算法工作方式相似。关键在于了解其工作原理，就可以轻松使用其它算法。</p><h5 id="遍历：std-for-each">遍历：std::for_each</h5><p><code>std::for_each</code>简介：</p><ul><li>输入：列表，每个列表元素的操作规则；</li><li>输出：指定操作后的列表；</li><li>应用：当我们希望<u>对列表执行相同操作</u>时。</li></ul><p>举例说明：对列表每个元素超级加倍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doubleNumber</span><span class="params">(<span class="keyword">int</span>&amp; i)</span>  <span class="comment">// 超级加倍</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>,6&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">    <span class="comment">// 对迭代器获取的每个元素进行指定操作（doubleNumber）</span></span><br><span class="line">    std::for_each(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), doubleNumber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 4 6 8</span><br></pre></td></tr></table></figure><p><strong>相比之下似乎内置的<em>for_each</em> 循环还能实现得更简单？这个例子没看到相比<em>for</em> 循环有什么优势</strong>？</p><ul><li>相比<em>for</em> 循环，<em>for_each</em> 能更清晰表达我们的意图也更不容易出错（不用定义额外的索引变量<code>i</code>）；</li><li><code>std::for_each</code>支持并行化，更适合大项目/大数据。</li></ul><h5 id="排序：std-sort">排序：std::sort</h5><p><code>std::sort</code>简介：</p><ul><li>输入：列表，两个元素比较规则；</li><li>输出：排序后的列表；</li><li>应用：当我们希望<u>对列表进行排序</u>时。</li></ul><p><code>std::sort</code> 排序实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">greater</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Order @a before @b if @a is greater than @b.</span></span><br><span class="line">    <span class="keyword">return</span> (a &gt; b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>,6&gt; arr = &#123; <span class="number">13</span>, <span class="number">90</span>, <span class="number">99</span>, <span class="number">5</span>, <span class="number">40</span>, <span class="number">80</span> &#125;;</span><br><span class="line">    <span class="comment">// greater定义列表两个元素比较规则</span></span><br><span class="line">    std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), greater);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">99 90 80 40 13 5</span><br></pre></td></tr></table></figure><p>好消息，因为降序排序很普遍，C++大开方便之门提供了<u>自定义类型</u><code>std::greater</code> ，而不用我们自己写一个比较函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), std::greater&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure><p>注意到，<code>std::greater</code> 调用有点奇怪，因为它是个模板类（参数类型要求是函数指针）：1）<code>&lt;int&gt;</code> 传入模板参数，2）类中重载了操作符<code>()</code> ，返回一个函数对象。</p><h5 id="查找：std-find-std-find-if">查找：std::find  &amp; std::find_if</h5><p><code>std::find</code>简介：</p><ul><li>输入：列表，被查找的元素；</li><li>输出：（找到时）元素的指针，（未找到时）尾元素的指针；</li><li>应用：当我们希望<u>查找某个元素时</u>时。</li></ul><p>下面代码展示：找到容器指定的某个元素，并进行修改替换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>,6&gt; arr = &#123; <span class="number">13</span>, <span class="number">90</span>, <span class="number">99</span>, <span class="number">5</span>, <span class="number">40</span>, <span class="number">80</span> &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;输入要查找的元素，和欲替换的值: &quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> search=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> replace=<span class="number">-1</span>;</span><br><span class="line">    std::cin &gt;&gt; search &gt;&gt; replace;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> found =  std::<span class="built_in">find</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), search);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没找到</span></span><br><span class="line">    <span class="keyword">if</span> (found == arr.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到指定元素： &quot;</span> &lt;&lt; search &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果找到，还进行替换</span></span><br><span class="line">        *found = replace;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt;<span class="string">&quot;found: &quot;</span> &lt;&lt; *found &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp <span class="built_in">test</span>]<span class="comment"># ./test.out </span></span><br><span class="line">输入要查找的元素，和欲替换的值 99 -1</span><br><span class="line">found: -1</span><br><span class="line">[root@roy-cpp <span class="built_in">test</span>]<span class="comment"># ./test.out </span></span><br><span class="line">输入要查找的元素，和欲替换的值 12 -1</span><br><span class="line">未找到指定元素： 12</span><br><span class="line">found: 1767305032</span><br></pre></td></tr></table></figure><p>如果还希望更灵活去自定义查找规则，请使用<code>std::find_if</code> 。</p><p><code>std::find_if</code>简介：</p><ul><li>输入：列表，列表每个元素的查找规则；</li><li>输出：（找到时）元素的指针，（未找到时）尾元素的指针；</li><li>应用：当我们希望<u>自定义查找某个元素时</u>时。</li></ul><p>一个示例，<code>std::find_if</code>查找子字符串“nut”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNut</span><span class="params">(std::string_view str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// str.find可用来查找指定子串</span></span><br><span class="line">    <span class="comment">// 找到返回true，否则false</span></span><br><span class="line">    <span class="keyword">return</span> (str.<span class="built_in">find</span>(<span class="string">&quot;nut&quot;</span>) != std::string_view::npos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// &quot;walnut&quot;包含要查找的子串&quot;nut&quot;</span></span><br><span class="line">    std::array&lt;std::string_view, 4&gt; arr = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;walnut&quot;</span>, <span class="string">&quot;lemon&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> found = &#123; std::<span class="built_in">find_if</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), containsNut) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (found == arr.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没找到“nuts”\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;找到了： &quot;</span> &lt;&lt; *found &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到了： walnut</span><br></pre></td></tr></table></figure><p>本来至少需要三个循环，使用标准库函数只用几行代码就完成了。</p><h5 id="统计：std-count-std-count-if">统计：std::count &amp; std::count_if</h5><p><code>std::count</code>和<code>std::count_if</code>统计指定元素或满足自定义的查找规则的元素出现次数。</p><p>在下面的示例中，我们将计算有多少元素包含子字符串“nut”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNut</span><span class="params">(std::string_view str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (str.<span class="built_in">find</span>(<span class="string">&quot;nut&quot;</span>) != std::string_view::npos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::array&lt;std::string_view, 5&gt; arr = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;walnut&quot;</span>, <span class="string">&quot;lemon&quot;</span>, <span class="string">&quot;peanut&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> nuts = &#123; std::<span class="built_in">count_if</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), containsNut) &#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;共计：&quot;</span> &lt;&lt; nuts &lt;&lt; <span class="string">&quot; nut(s)\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">共计：2 nut(s)</span><br></pre></td></tr></table></figure><h4 id="2-3-X-最佳实践">2.3.X 最佳实践</h4><ul><li>善于使用容器+算法库中的函数，而不是编写自己的函数来做同样的事情，这可以使我们的代码更简单、更健壮。</li><li>具体来说，数组立马想到<code>std::array</code>、<code>std::vector</code> ；<u>简单</u>循环立马想到<em>for_each</em> 或者 <em>std::for_each</em> ；循环还需要结合<u>复杂</u>的操作，请尽量使用<code>std::sort</code> 等标准库算法。</li></ul><h2 id="更新记录">更新记录</h2><div class="timeline"><div class="timenode"><div class="meta"><p><p>2021-01-30 ：更新笔记</p></p></div><div class="body"><ol><li>修改智能指针相关描述</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-01-07 ：更新笔记</p></p></div><div class="body"><ol><li>第一次更新</li></ol></div></div></div><h2 id="参考资料">参考资料</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">梳理c++ const 修饰函数：https://zhuanlan.zhihu.com/p/110159656<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">第 5 章 智能指针与内存管理：https://changkun.de/modern-cpp/zh-cn/05-pointers/#5-1-RAII-%E4%B8%8E%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">理解 C++ 智能指针：https://supwills.com/post/understanding-cpp-smart-pointer/<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 教程 </tag>
            
            <tag> C++基础 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++从零开始（五）：务实基础（下）函数</title>
      <link href="/p/51595/"/>
      <url>/p/51595/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，开始更新中…</p></blockquote><div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div><h2 id="三、函数">三、函数</h2><h3 id="3-1-基本概念">3.1 基本概念</h3><blockquote><p>怎么定义函数？</p></blockquote><p>以前，我比较倾向将函数定义为<strong>顺序执行的语句集合</strong>。现在我认为更恰当的说法应该是：<strong>函数是一个<u>可重用</u>的语句序列，旨在完成特定的工作</strong>。<br>C++ 中函数一般形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter_list )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// body of the function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面包含一个函数的所有组成部分：</p><ul><li><strong>返回类型(return_type)</strong>：一个函数可以返回一个值，<strong>return_type</strong> 是函数返回的值的数据类型。不需要返回值，return_type 是关键字 <strong>void</strong>。</li><li><strong>函数名称(function_name)</strong>：函数的实际名称，<strong>函数名和参数列表一起构成了函数签名</strong>。<ul><li>所谓”签名“则意味着这可以唯一标识一个函数。</li></ul></li><li><strong>参数列表(parameter_list)</strong>：参数就像是占位符。当函数被调用时，可向参数传递一个值，这个值被称为实际参数，参数列表包括函数参数的<strong>类型、顺序、数量</strong>。<ul><li>参数列表的顺序、类型、数量不完全一致的话，形成不同函数签名，即是不同函数。</li></ul></li><li><strong>函数主体(boby)</strong>：函数主体包含一组定义函数执行任务的语句。</li></ul><p>特别的，C++是不支持嵌套函数的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 编译出错</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max1</span><span class="params">(<span class="keyword">int</span> num1=<span class="number">0</span>, <span class="keyword">int</span> num2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1&gt;num2?num1:num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-1-前向声明🌟">3.1.1 前向声明🌟</h4><h5 id="前向声明初识">前向声明初识</h5><p>在很多IDE中，如果你尝试在main函数使用未在之前定义的函数，会出现编译错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">max</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 编译错误</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回两个数中较大的那个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> num1&gt;num2?num1:num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为<strong>max函数定义在main函数之后，顺序编译到代码第6行max(1,2)时找不到max的定义</strong>，所以main不知道max是什么（是的怎么这么笨？）。</p><p>解决这个问题，可以：</p><ul><li><p><strong>将max函数整体定义在main函数前</strong>；</p></li><li><p><strong>前向声明</strong>。</p><p>前向声明告诉编译器标识符在实际定义之前就已经存在，这样编译器会<u>在链接时进行符号链接寻找标识符的定义</u>。</p><blockquote><p>感觉和extern关键字很像？请见下节对比。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>; <span class="comment">// 前向声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">max</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 编译正确</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回两个数中较大的那个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> num1&gt;num2?num1:num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果max定义在其它文件（max.cpp）中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*max.cpp*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> num1&gt;num2?num1:num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你在main中（定义在main.cpp）中，可以不通过include “main.cpp”而使用前置声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>; <span class="comment">// 前向声明,会在链接的时候寻找max的定义，编译器时不报错</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">max</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 编译正确</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译（一切正常）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp max.cpp -o main.out</span><br><span class="line">./main.out</span><br></pre></td></tr></table></figure></li></ul><p>但经过我的实践，在很多编译器中进行了优化。<strong>同一个文件的函数</strong>即使不进行前向声明，上面的代码也不会报错。</p><p>而且，在<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/?highlight=%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E#forward-declarations">Google code style</a> 也明确指出尽量不要使用前置声明：</p><blockquote><p>尽可能地避免使用前置声明。使用 <code>#include</code> 包含需要的头文件即可。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220116163129065.png" alt="image-20220116163129065"></p></blockquote><p><strong>那么，前向声明还存在的意义是什么</strong>？</p><ol><li>减少编译时间。使用include也可以使用别的的文件中定义的变量，但是也会把头文件其它不需要的变量引入。如果只是需要使用很少的外部变量，使用前向声明能减少编译的头文件展开。</li><li>打破循环引用。</li></ol><h5 id="循环引用">循环引用</h5><p>前置声明现在<strong>用来解决多文件中循环引用的问题</strong>。</p><p>以类循环引用为例。</p><p><strong>想象这么一个情况：A.h定义了Class A，它需要引用B.h定义的Class B，也就是要写入#include “B.h” ；类似的情况，B.h也需要写入#include “A.h”</strong>。</p><p>这就造成了两个类互相引用，但由于C++蛋疼顺序编译的规则。如果是先编译A.h，引用的类B则找不到实现的定义；如果是先编译B.h，则找不到类A的定义。形成“先有鸡还有先有蛋”的世纪难题。</p><p>我们举一个具体的例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;B.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      B *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* B.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      A *a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*test.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;B.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   A a;</span><br><span class="line">   B b;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试编译一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++  test.cpp -o test.out</span><br></pre></td></tr></table></figure><p>显示在<code>B.h</code>中找不到<code>A</code>的定义：<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227163519959.png" alt="image-20211227163519959"></p><p><strong>现在我们从底层编译过程探讨下这个循环引用出现的原因和解决方案</strong>。</p><p>我们知道编译四大流程为：预编译→编译→汇编→链接，先看看预编译源文件test.cpp产生的test.i。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -E  test.cpp  -o test.i</span><br></pre></td></tr></table></figure><p>预编译后内容如下：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227171957061.png" alt="image-20211227171957061"></p><p>下面是<code>test.i</code>中具体内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      A *a;  <span class="comment">// 前面没有A的定义</span></span><br><span class="line">&#125;;</span><br><span class="line"># <span class="number">4</span> <span class="string">&quot;A.h&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      B *b;</span><br><span class="line">&#125;;</span><br><span class="line"># <span class="number">10</span> <span class="string">&quot;test.cpp&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   A a;</span><br><span class="line">   B b;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，test.i中<strong>第6行代码<code>A* a</code>，在类B中引用了<code>A</code> ，但是前面没有关于<code>A</code> 的定义</strong>。这为后面编译出错埋下了伏笔。</p><p>预编译后完成后，我们进行第2个阶段：编译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -S test.cpp -o  test.s</span><br></pre></td></tr></table></figure><p>Error！出现了最开始的“未定义”错误：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227210145942.png" alt="image-20211227210145942"></p><p>也就是说这个错误在编译阶段就产生了：当C++<strong>按顺序编译</strong>到 <code>A *a</code> 这行时，编译器进行语法检查，发现<strong>在前面找不到<code>A</code>相关的定义</strong>，于是报错。</p><p><strong>怎么解决这个问题</strong>？</p><p>我们可以在<code>B.h</code> 中进行前向声明，解决这个错误。</p><ul><li><strong>类似于全局变量，这样<code>A</code>作用范围就到本文件结尾：即编译器还会在<code>test.i</code> 中其它位置寻找<code>A</code>的定义</strong>；</li><li><strong>不仅如此，即使<code>test.i</code>中不存在，编译器还会在链接时符号解析时寻找A的定义，而不是在编译时就报错</strong>。</li></ul><p>这样编译器就不会在编译阶段报错了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;A.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span>  <span class="comment">// 前向声明，</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      A *a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>新的预编译文件<code>test.i</code>文件也在相应位置多了一行<code>Class A;</code>（其余无变化）:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>如果不使用#ifndef 、#define 和#endif</strong>？</p><p>#ifndef 、#define 和#endif，即条件编译：只有满足要求代码才参与编译，否则不参与编译。基本用法为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> 标识符  </span></span><br><span class="line">程序段<span class="number">1</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line">程序段<span class="number">2</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在本节中，对B.h和A.h都使用了条件编译：<strong>防止头文件被重复定义，在链接时出现大量重定义错误</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> A_H <span class="comment">// 或B_H</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A_H <span class="comment">// 或B_H</span></span></span><br><span class="line"><span class="comment">// A_H或B_H中的代码 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>以<code>A.h</code>为例：</p><ol><li>如果<code>A.h</code>被<u>第一个文件</u>引入时，会定义标识符<code>A_H</code> ，这个时候<code>A.h</code>其后的代码会被预编译插入到文件中；</li><li>如果<u>其它文件</u>存在代码<code>#include “A.h”</code> ，尝试预编译替换为<code>A.h</code>中内容；</li><li>因为<code>A_H</code> 已被定义，直接跳转到<code>#endif</code>结束，<strong>避免了头文件重复引入</strong>。</li></ol><p>在本节中，如果对B.h和A.h都<u>不使用</u>条件编译，<strong>预编译时不但会出现重定义错误还会出现无限嵌套</strong>：</p><ol><li>main.cpp中：#include “A.h” 被替换为A.h中具体内容；</li><li>A.h中： 由于在头文件引入了 #include “B.h” ，所以 #include “B.h”也会被替换为B.h中具体内容；</li><li>B.h中： 重复引入了 #include “A.h”，重复替换头文件A.h，跳转到步骤2发生无限嵌套。</li></ol><h5 id="extern和前向声明">extern和前向声明</h5><p>extern和前向声明作用非常相似：<strong>都可以用来声明<u>函数/结构体/类</u>等是在外部定义的，这样在编译时不出错，在链接时会在其它<code>.o</code>寻找相关定义</strong>。</p><p>但是extern关键字和前向声明也有些不同：</p><ol><li><strong>extern可以作用于变量</strong>，前向声明无法声明变量（变量会默认初始化），只能声明函数/结构体/类等；</li><li><strong>extern还有extern “C”相关用法</strong>；</li><li><strong>extern是一个关键字</strong>，前向声明是种声明方式（使用前声明）。</li></ol><h5 id="最佳实践：extern-前向声明-include">最佳实践：extern/前向声明/include</h5><ul><li><p><strong>如果只是<u>少量</u>地要使用别的文件中定义的变量/函数/结构体/类等</strong>：请使用extern关键字，它可以减少编译时间；</p><p>虽然函数/结构体/类等使用前向声明也可以但不推荐，使用extern更好。</p></li><li><p><strong>打破循环引用</strong>。前向声明。</p></li><li><p><strong>其余情况使用include更好</strong>，代码逻辑更清晰。</p></li></ul><h4 id="3-1-2-最佳实践：什么时候使用函数">3.1.2 最佳实践：什么时候使用函数</h4><p>作为曾经稚嫩的（现在不那么稚嫩的）程序员，什么时候使用函数是一个挺纠结的问题。参考<a href="learncpp.com">learncpp</a> 中建议：</p><ul><li><strong>多次出现的语句应该组成一个函数</strong>。例如，如果我们以相同的方式多次读取用户的输入，那么这是一个很好的函数候选。</li><li><strong>具有明确定义的输入和输出目标的代码</strong>。例如，如果我们有一个要排序的项目列表，那么进行排序的代码将是一个很好的功能，<u>即使它只完成了一次</u>。输入是未排序的列表，输出是排序的列表。</li><li><strong>一个函数应该执行有且只有一项任务</strong>。</li><li><strong>当一个函数变得太长、太复杂或难以理解时</strong>。可以将其拆分为多个子函数，也就是重构。</li></ul><h3 id="3-2-函数重载">3.2 函数重载</h3><p>在前面我们提到：函数通过函数签名来唯一确定一个函数，而函数签名由 <u>函数名&amp;参数列表</u> 组成。</p><p>比如，<strong>两个函数函数名相同而参数列表不同，这个时候是同一函数吗</strong>？</p><p>显然不是，因为函数签名中的参数列表不同，因此是两个函数，这也就是<strong>函数重载</strong>。</p><h4 id="3-2-1-为什么需要函数重载？">3.2.1 为什么需要函数重载？</h4><p>重载函数通常用来命名一组功能相似的函数。这样做的好处：</p><ol><li>减少了函数名的数量；</li><li>避免了名字空间的污染，对于程序的可读性有很大的好处。</li></ol><p>请看下例。</p><p>我们有两个函数：一个返回两个整数相加的值，一个返回两个浮点数相加的值。我们<strong>定义了多个名称但极其相似（功能、名字etc.）的函数</strong>。它们核心功能虽然都是add，但却对应多个不同的函数名，增加了记忆负担。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addInteger</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">addDouble</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优雅的做法应该是：<strong>每个函数同名，编译器靠参数<u>类型</u>、<u>数量</u>、<u>顺序</u>来自动匹配调用</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">// 匹配第一个add</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 匹配第二个add</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">3.4</span>,<span class="number">5</span>); <span class="comment">// 匹配第三个add</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-二义性匹配">3.2.2 二义性匹配</h4><p>前面介绍的都是传递的参数和定义函数参数完全匹配的简单情况。但实际上，还会出现<strong>函数调用中的参数类型与任何重载函数中的参数类型不完全匹配</strong> 。</p><p>这会发生什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;print int : &quot;</span>&lt;&lt; x &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;print double : &quot;</span>&lt;&lt; d &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print int : 97</span><br></pre></td></tr></table></figure><p>发生了什么？<code>print('a')</code> 匹配了 <code>print(int)</code>? <code>97</code>又是什么？</p><p>这是因为编译器如果找不到完全匹配的函数，<strong>会自动进行隐式转换将某些窄整数和浮点类型自动提升为更宽类型</strong>。所有这里的<code>char('a')</code> 自动提升为<code>int</code> ，匹配到了<code>print(int)</code> , <code>97</code>是<code>a</code> 的ASCII编码。</p><p>特别的，由于匹配到了<code>print(int)</code> ，便不会自动继续提升类型去匹配<code>print(double)</code>。</p><p>关于<u>类型转换</u> 会在第十章统一总结，这里先简单了解下即可。</p><blockquote><p>特别的，<strong>如果上述过程（数字转换找不到）未找到匹配项，编译器将尝试通过任何用户定义的转换找到匹配项</strong>。</p></blockquote><p>这涉及到<u>类型重载</u>，会在下篇文章<u>面对对象</u> 进行讲解。这里只要了解这个例子即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125; <span class="comment">// 用户自定义从X转换int</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X x; </span><br><span class="line">    <span class="built_in">print</span>(x);  <span class="comment">// 匹配print(int)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里例子中（也是一般函数参数匹配流程总结）：</p><ol><li>编译器寻找是否存在<code>print(X)</code> ，不存在转至第2步；</li><li>编译器检查<code>x</code>是否可以类型提升，不能进行第3步；</li><li>编译器将查找任何用户定义的转换，存在，进行转换。</li></ol><h3 id="3-3-函数模板">3.3 函数模板</h3><p>在前面<u>函数重载</u>中，我们通过将两个<u>功能相似仅参数列表不同</u>的函数，<u>改为同名函数</u>让编译器通过函数签名来区分，减少了思维负担。</p><p>但是考虑一种更特殊的情况，<u>两个函数不仅功能极其相似，连参数列表的个数都相同</u>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;print result : &quot;</span>&lt;&lt; x+y &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;print result : &quot;</span>&lt;&lt; x+y &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">   <span class="built_in">print</span>(<span class="number">3.0</span>,<span class="number">4.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总感觉哪里不对，似乎造成了很多代码重复？它们只是参数类型不同啊，函数体、名字什么都一样？</p><p>在C++中提供了函数模板，用来优雅地应对这种情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;    <span class="comment">// template和typename是关键字，T是类型名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;print result : &quot;</span>&lt;&lt; x+y &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">   <span class="built_in">print</span>(<span class="number">3.0</span>,<span class="number">4.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不错，一切顺眼了很多。</p><h4 id="3-3-1-模板函数是如何工作的？">3.3.1 模板函数是如何工作的？</h4><p>在前文我们介绍了函数模板，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;print result : &quot;</span>&lt;&lt; x+y &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但函数模板实际上并不是函数——它们的代码不是直接编译或执行的。函数模板只有一个功能：<strong>为每个具有一组唯一参数类型的函数，调用创建（并编译）一个函数</strong>。</p><p>让我们看一个简单的例子，展示了一个不同以往的模板函数调用方式<code>funName&lt;actual_type&gt;(arg1, arg2)</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;print result : &quot;</span>&lt;&lt; x+y &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// print(1,2);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但相比<code>funName(arg1, arg2)</code> 这种方式，上面的才是更接近本质的调用方式。</p><p>因为<code>print(1,2)</code>，本质就是编译器克隆了函数模板<code>void print(T x, T y)</code>，将模板类型<code>T</code>替换为我们指定的实际类型<code>&lt;int&gt;</code>，最终生成指定类型的函数<code>void print&lt;int&gt;(int x, int y)</code> 。</p><blockquote><p>亲眼看一看：实例化完成后编译的内容。</p></blockquote><p>由于直接使用 <code>g++ -S</code> 生成的是汇编代码，不太直观，我们借助https://cppinsights.io/ 观察模板实例化后的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">print&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220111224749061.png" alt="image-20220111224749061"></p><p>实例化后，编译器确实生成了两个函数：<code>void print&lt;int&gt;(int x, int y)</code>、<code>void print&lt;double&gt;(double x, double y)</code>供我们调用。</p><p>上述<strong>从函数模板创建指定类型的函数的过程，称为函数模板实例化</strong>。如果这个过程是因为函数调用而产生的，则称为<strong>隐式实例化</strong>。</p><ul><li><p><strong>实例化函数每次调用都会发生吗</strong>？仅在<strong>第一次</strong>函数调用时实例化，对该函数的进一步调用将路由（指向）到已实例化的函数。</p></li><li><p><strong>最佳实践</strong>：优先使用普通函数调用方式，即<code>print(1,2)</code> 。</p></li></ul><h4 id="3-3-2-多个函数模板类型">3.3.2 多个函数模板类型</h4><p>多个函数模板类型适用于函数拥有多个不同类型参数的情况。</p><p>请看下例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">2</span>, <span class="number">3.5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// compile error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下阅读前，请思考：为什么编译会出错？有什么好的解决办法吗？</p><ul><li><p><strong>为什么编译出错</strong>？</p><ol><li>根据调用的函数<code>max(2, 3.5)</code> ，编译器会尝试寻找匹配的函数，没找到转下一步；</li><li>编译器尝试根据函数模板<code>max(T,T)</code>，生成函数<code>max(int,double)</code> 。显然这是不可能生成<strong>不同类型</strong>的参数。</li><li>函数调用解析出错。</li></ol><p>当然你可能还会问：<strong>为什么编译器不会生成函数<code>max(double,double)</code>，这调用时<code>max(int,double)</code> 中<code>int</code>可以隐式转换为<code>double</code>呢</strong>?</p><p>因此，类型转换仅在解析函数重载时进行，而不是在执行模板参数推导时进行。</p></li><li><p><strong>有什么好的解决办法吗</strong>？</p><p>当然，最简单办法是传参时便进行类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">max</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>), <span class="number">3.5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这样函数模板就可以生成函数<code>max(double,double)</code>，从而正确被调用了。但这很不cool。</p><p>或者你又想到了，我们不是新学会一种调用函数模板的方法吗，它可以<u>显示指定转换类型，编译器就不用自己去推导了</u>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; max&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">3.5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br></pre></td></tr></table></figure><p>这也是ok的。</p><p>但最佳的解决办法，还是从根源解决：既然是调用参数类型有多个，而模板函数参数类型只有一个导致出现上面的问题。</p><p>那为什么不直接定义模板函数时也定义为多个类型呢？</p></li><li><p><strong>多个模板类型参数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T x, U y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">2</span>, <span class="number">3.5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// compile error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，一切看起来挺不错，让我们输出一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>啊？大惊失色。为什么输出结果是3而不是3.5？</p><p>因为函数内部结果<code>3.5</code>为<code>double</code> 类型，返回的是<code>T</code>类型，已经被编译器自动推断（根据传的参数<code>2</code>）替换为<code>int</code> 类型。因此将3.5强制转换为3。</p><p>那我们直接指定返回类型<code>T</code> 变为<code>U</code> 不就行了吗？很可惜，不行。<strong>因为T、U的实际类型都是根据调用时传的参数进行推断的，而调用时传递参数的位置可以随意换动</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cout &lt;&lt; max(2, 3.5) &lt;&lt; &#x27;\n&#x27;; </span></span><br><span class="line">cout &lt;&lt; <span class="built_in">max</span>(<span class="number">3.5</span>, <span class="number">2</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br></pre></td></tr></table></figure><p>此时<code>U</code>被推断为<code>int</code> 类型。更好的做法是使用<code>auto</code>关键字，<strong>自动推导函数的返回类型</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span><span class="params">(T x, U y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.5</span><br></pre></td></tr></table></figure><p>好了，一切都好起来了。关于<code>auto</code>关键字还会在后面做更详细的总结，希望你有了个初步的认识。</p></li></ul><h3 id="3-4-函数参数🌟">3.4 函数参数🌟</h3><blockquote><p>⚠️ 本节知识设计到较多指针和引用相关内容，此前无基础建议先阅读：<u>第二章：指针和引用</u>。</p></blockquote><p>在正式探讨函数参数前，我们先了解下函数中的两种参数：</p><ul><li><strong>形式参数</strong>：函数声明时表示的变量，函数调用时才分配内存。</li><li><strong>实际参数</strong>：调用函数数实际传递的参数值，必须是确定的值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// x,y 是形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">foo</span>(<span class="number">6</span>, <span class="number">7</span>); <span class="comment">// 6,7 是实参，被赋值给形参x,y</span></span><br></pre></td></tr></table></figure><p>它们更多的区别会在3.4.6节中进行对比。</p><p>本节核心：按值传递、按引用传递和按指针传递，这 3 种向函数传递参数的主要方式。我们一起了解下吧。</p><h4 id="3-4-1-按值传递">3.4.1 按值传递</h4><ul><li><p><strong>什么是按值传递</strong>？</p><p>一般来说，<strong>C++ 中的非指针参数都是按值传递：实参的值被复制到相应函数形参中</strong>。</p><p>按值传递既然是复制，即只是将实参的副本传递给函数，那么函数修改副本（形参）的值是不能影响到实参值。请看下例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">foo</span>(x); <span class="comment">// 实参x复制一份给y</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = 5</span><br><span class="line">x = 5</span><br></pre></td></tr></table></figure><p><code>x</code>的值并没有被改变，虽然<code>foo</code> 函数内容修改了传递过来的值，但那只是<code>x</code>的副本。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211231000603042.png" alt="image-20211231000603042" style="zoom:80%;" /><p>上图对这一过程进行形象说明，注意到实参x、形参y对应的是不同内存区域（地址都不一样）。</p></li><li><p><strong>什么时候用值传递</strong>？</p><p>按值传递通常用于需要传递的参数不希望被修改的时候，实参可以是：<u>变量（例如 x）、数字（例如 6）、表达式（例如 x+1）、结构和类以及枚举数</u>。</p><p>但是按值传递也有明显的缺点，应该避免以下几种情况使用：</p><ol><li>复制结构和类。复制结构和类开销过大，导致明显性能损失；</li><li>希望参数被改变；</li><li>返回多个值。</li></ol><p>其它情况优先考虑值传递。</p></li></ul><h4 id="3-4-2-按引用传递">3.4.2 按引用传递</h4><ul><li><p><strong>为什么需要引用传递</strong>？</p><p>在前面我们说到值传递的几个缺点：复制结构和类开销大、无法改变参数、只能返回一个值。</p><p>对应，如果你不希望以上发生，请使用引用传递。</p><p><strong>引用就相当于变量别名，操作引用等价于直接操作本体变量</strong>。请看下例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAdd</span><span class="params">(<span class="keyword">int</span> x_add_1, <span class="keyword">int</span>&amp; y_add_2,<span class="keyword">int</span>&amp; z_add_3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x_add_1 += <span class="number">1</span>;</span><br><span class="line">    y_add_2 += <span class="number">2</span>;</span><br><span class="line">    z_add_3 += <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// print(1.2,2);</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span> ,y = <span class="number">0</span> , z =<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">getAdd</span>(x,y,z);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>上述过程简略分析。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211231160958522.png" alt="image-20211231160958522" style="zoom:80%;" /><ul><li>引用传递变量 <code>y</code> 、<code>z</code> 均被修改（<code>x</code>值传递未被修改）。</li></ul><p>类似值传递。例如，引用传递中的<code>y_add_2</code> 也是被调函数栈上的一个局部变量，它保存了<code>y</code>的地址。对于引用参数的<strong>任何处理都会通过间接寻址，等价直接操作实参<code>y</code>本体</strong>。</p><p>特别的，引用还有几个特点（2.2节）：</p><ul><li>引用必须使用右值进行初始化，除非是执行常量的引用；</li><li>引用传递值必须被初始化，所以不必担心空值。</li></ul></li><li><p><strong>这么棒了你后面还讲指针传递干嘛</strong>？</p><blockquote><p>一般来说，我们确实推荐尽量使用引用传递参数，但是地址传递参数还是有它的用武之地。</p></blockquote><p>比如，引用传递值可以使得函数“返回”多个值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAdd</span><span class="params">(<span class="keyword">int</span> x_add_1, <span class="keyword">int</span>&amp; y_add_2,<span class="keyword">int</span>&amp; z_add_3)</span></span>;</span><br></pre></td></tr></table></figure><p>但是观察这个表达式，输入参数<code>x_add_1</code> ，和输出参数（返回值）<code>y_add_2</code>、<code>z_add_3</code> 放在一块，无法很好的区分哪些是要被修改的（输出参数）。毕竟，<strong>它们连调用都是这么相似</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span> ,y = <span class="number">0</span> , z =<span class="number">0</span>;</span><br><span class="line"><span class="built_in">getAdd</span>(x,y,z);</span><br></pre></td></tr></table></figure><p>你能区分哪些是<code>x、y、z</code>哪些输出参数吗？</p></li></ul><h4 id="3-4-3-按指针传递">3.4.3 按指针传递</h4><ul><li><p><strong>为什么要需要指针传递值</strong>?</p><p>前面说到，引用传值用来“返回”多个参数时，很难区分哪些参数是输出参数，连调用时都过分相似（多胞胎搞人心态是吧？）。</p><p>上面代码修改为指针传值后，函数形参由<code>&amp;</code>变为<code>*</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAdd</span><span class="params">(<span class="keyword">int</span> x_add_1, <span class="keyword">int</span>* y_add_2,<span class="keyword">int</span>* z_add_3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     x_add_1 += <span class="number">1</span>;</span><br><span class="line">    *y_add_2 += <span class="number">2</span>;  <span class="comment">// y_add_2存的是y的地址，使用*操作符取值</span></span><br><span class="line">    *z_add_3 += <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时（<strong>y、z可以很好的认出是输出参数</strong>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span> ,y = <span class="number">0</span> , z =<span class="number">0</span>;</span><br><span class="line"><span class="built_in">getAdd</span>(x,&amp;y,&amp;z);  <span class="comment">// &amp;--取地址运算符</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>上面，<code>y_add_2</code> 获取了形参<code>&amp;y</code>保存的值，即变量<code>y</code>的内存地址。通过取值运算符<code>*y_add_2</code> ，可以获取变量<code>y</code>的内存区域操作权，即可以修改<code>y</code>的值了（+2）。因此变量<code>y</code>的值被修，<code>z</code>同理。</p></li><li><p><strong>惊讶！指针其实值传递</strong>？</p><p>这就是说我们像值传递一样将<strong>实参的值（一般是某个变量的地址）复制了一份给形参</strong>，形参<u>也作为局部变量在栈中开辟了内存空间</u>。</p><p>换句话说，指针是按值传递的！当然，这其实没多大惊讶（除非你和作者一样是个惊讶怪），因为我们早在<u>2.1节</u>分析过，指针本质就是一个变量，它有自己的值（其它变量的地址）和自己的地址。</p><p>请看下例，试分析：<strong>为什么<code>pfive</code>值没有被修改成功？</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量 ptr保存了p_five的值（five的地址）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNull</span><span class="params">(<span class="keyword">int</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptr = <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> five = <span class="number">5</span>;</span><br><span class="line">    cout&lt;&lt;&amp;five&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">int</span>* pfive = &amp;five; <span class="comment">// p_five = &amp;five = 0x7ffdb136b8e4</span></span><br><span class="line">    cout&lt;&lt;&amp;pfive&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">setNull</span>(pfive); <span class="comment">// 将p_five指向null</span></span><br><span class="line">    cout&lt;&lt;pfive&lt;&lt;endl; <span class="comment">// 输出此时p_five内存地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x7ffd037a0ecc</span><br><span class="line">0x7ffd037a0ec0</span><br><span class="line">0x7ffd037a0ea8</span><br><span class="line">0x7ffd037a0ecc</span><br></pre></td></tr></table></figure><p>显然<code>pfive</code>没有修改成功（NULL）。整个过程如图所示：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220109145535610.png" alt="image-20220109145535610"></p></li></ul><ol><li><p>局部变量<code>pfive</code> 保存了<code>&amp;five</code>的值，即<code>five</code> 的地址；</p></li><li><p>随后<code>pfive</code>作为实参，其值（<code>five</code>地址）复制给形参<code>ptr</code>，编译器给形参<code>ptr</code>开辟了空间专门保存<code>five</code>地址；</p></li><li><p>随后<code>ptr=NULL</code>，但是影响不到<code>pfive</code>，二者是不同的变量拥有各自独立的空间。</p></li></ol><p>这验证了我们之前的结论：<strong>指针传值只是复制了实参值给形参，只不过这个实参值一般是某个变量的地址</strong>。</p><p><strong>那如果我们想在指针传值时修改形参就可以影响实参</strong>？</p><p>显然这就是引用的做法，对形参的任何修改直接等价操作实参本体。不过为了更好的讲解，我们先总结一下前面引用、指针传值的用法。</p><p>我们知道引用相当于变量的别名，使用引用时可以认为就是在使用变量本身。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; a_ref = a;  <span class="comment">// 使用a_ref和使用a没什么区别</span></span><br></pre></td></tr></table></figure><p>又如之前的引用传值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// var = ...;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">func</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时形参是<code>int&amp; var</code> ，实参<code>tmp</code> ，实参值初始化形参<code>var</code>，就相当于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; var = tmp;</span><br></pre></td></tr></table></figure><p>也可以推广到函数其余参数传递情况：</p><ul><li><p>值传递</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// var = ...;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">func</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实参值初始化形参<code>var</code>等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = tmp;</span><br></pre></td></tr></table></figure></li><li><p>指针传递</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>* var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// *var = ...;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">func</span>(&amp;tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实参值初始化形参<code>var</code>等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* var = &amp;tmp;</span><br></pre></td></tr></table></figure></li></ul><p>好了，接受了上面的概念，我们再来说说<strong>怎么修改形参<code>ptr</code> 等价于修改实参<code>pfive</code></strong>？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量 ptr保存了p_five的值（five的地址）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNull</span><span class="params">(<span class="keyword">int</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptr = <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> five = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span>* pfive = &amp;five; </span><br><span class="line">    <span class="built_in">setNull</span>(pfive); <span class="comment">// 将p_five指向null</span></span><br><span class="line">    cout&lt;&lt;p_five&lt;&lt;endl; <span class="comment">// 输出此时p_five内存地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，<strong>引用</strong>可以做到这点：将<code>ptr</code> 视为<code>pfive</code>的别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>*&amp; ptr = pfive;</span><br></pre></td></tr></table></figure><p>只需将第5行修改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNull</span><span class="params">(<span class="keyword">int</span>*&amp; ptr)</span></span></span><br></pre></td></tr></table></figure><p>我们再尝试输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="comment">// 表示指针指向NULL</span></span><br></pre></td></tr></table></figure><h4 id="3-4-4-最佳实践">3.4.4 最佳实践</h4><h5 id="传引用快还是传指针快？">传引用快还是传指针快？</h5><p>虽然前面的分析，你对引用和指针传递有一定的了解、区分。</p><p><strong>但如果要你回答这么一个问题：是传引用快还是传指针快</strong>？</p><p>先上结论：一样快。</p><p><strong>因为引用就是特殊的指针，它底层实现和指针是一致的</strong>。</p><p>准备一段地址传参代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">func</span>(&amp;x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code>对应汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">        # 保存main栈帧信息</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        subq    $16, %rsp </span><br><span class="line">        # 用0初始化x（对应地址为-4(%rbp)，并将x压栈</span><br><span class="line">        movl    $0, -4(%rbp)</span><br><span class="line">        # 将x地址保存到寄存器rax中，然后保存在rdi中</span><br><span class="line">        leaq    -4(%rbp), %rax </span><br><span class="line">        movq    %rax, %rdi</span><br><span class="line">        # 调用函数func</span><br><span class="line">        call    _Z4funcPi</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>可以看到<code>main</code>中最终将实参<code>&amp;x</code>（变量<code>x</code>的地址）保存在寄存器<code>rdi</code>中 。</p><p>接着我们开始重头戏<code>func</code>函数：<strong>指针通过保存变量地址到寄存器中，实现对变量所在内存区域进行修改</strong>，因此修改指针就是直接影响变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_Z4funcPi:</span><br><span class="line">        # 保存func栈帧相关信息</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        # 进行地址复制：将寄存器rdi的值（实参&amp;x）复制给形参y（对应地址-8(%rbp)），并将y压栈</span><br><span class="line">        movq    %rdi, -8(%rbp)</span><br><span class="line">        # 进行赋值运算：先用寄存器rax保存形参y的的值（x的地址），然后将2复制给x</span><br><span class="line">        movq    -8(%rbp), %rax</span><br><span class="line">        movl    $2, (%rax)</span><br><span class="line">        nop</span><br><span class="line">        popq    %rbp</span><br><span class="line">        # 返回main</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>现在我们将上述代码从地址传递改为引用传递：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">func</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看其汇编代码：不能说毫不相干，只能说和之前指针传值的汇编代码完全<strong>一模一样</strong>。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220109193419428.png" alt="image-20220109193419428"></p><p>也就是说，<strong>引用本质和指针一样，都是通过保存变量对应内存区域地址，来实现操作变量</strong>。对引用的任何操作，都会通过间接寻址直接操作变量本身，只不过相比指针隐藏了一些细节（编译器对使用引用会自动加上<code>*</code>，<u>2.2.1节</u>）。</p><h5 id="参数传递选择规则">参数传递选择规则</h5><blockquote><p>有引选引。</p></blockquote><p><strong>优先选用引用传递（引用：拜托了</strong>），除非：</p><ol><li><strong>希望参数不被修改</strong>，选择按值传递，否则转下一步；</li><li><u><strong>需要返回空指针、or返回局部变量内存、OR数组</strong></u>，选择按指针传递，否则转下一步。</li></ol><h5 id="数组怎么使用引用传参？">数组怎么使用引用传参？</h5><p>这是个很有意思的问题。</p><p>先看看数组的引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (&amp;arr)[<span class="number">5</span>] = array;</span><br></pre></td></tr></table></figure><p>此时数组的类型可以认为是<code>int [5]</code> ，<code>&amp;arr</code> 便是声明一个<code>array</code>的别名。</p><p>因此，我们如此使用数组的引用作为参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_array</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">5</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">   <span class="built_in">modify_array</span>(array);</span><br><span class="line">   cout&lt;&lt;array[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>可以看到，确实被成功修改了。但<code>int (&amp;arr)[5]</code> 编译器<u>要检查数组实参和形参的大小</u>，扩展性太差！</p><p>为此，我们使用模板进行改进（其余不变）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">int</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_array</span><span class="params">(T (&amp;arr)[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">   <span class="built_in">modify_array</span>(array);</span><br><span class="line">   cout&lt;&lt;array[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完美！</p><h4 id="3-4-5-参数传递总结">3.4.5 参数传递总结</h4><blockquote><p>一些面试常考题对前面所学进行总结和验证。</p></blockquote><ul><li><p><strong>形参和实参的区别</strong>？</p><ul><li><strong>何时分配内存</strong>：<strong>形参变量只有在被调用时才分配内存单元</strong>，在调用结束时， 即刻释放所分配的内存单元（这一部分内容还会在<u>8.6函数返回值</u> 详细举例）；实参在调用前就已经分配了内存。</li><li><strong>参数类型</strong>： 实参可以是常量、变量、表达式、函数等，在进行函数调用时，它们<strong>都必须具有确定的值</strong>；实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。</li><li><strong>单向传递</strong>。只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。</li></ul></li><li><p><strong>值传递、指针传递、引用传递的区别</strong>？</p><p>请看下表。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">值传递</th><th style="text-align:center">引用传递</th><th style="text-align:center">指针（地址）传递</th></tr></thead><tbody><tr><td style="text-align:center"><strong>拷贝内容</strong></td><td style="text-align:center">实参的副本（数组例外，会退化为指针）</td><td style="text-align:center">给实参起个别名</td><td style="text-align:center">指针（4字节或8字节）</td></tr><tr><td style="text-align:center"><strong>效率</strong></td><td style="text-align:center">低，特别是拷贝结构体或类对象时</td><td style="text-align:center">高（推荐），起个别名即可</td><td style="text-align:center">高，拷贝指针即可</td></tr><tr><td style="text-align:center"><strong>是否修改</strong></td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">不能修改为其它对象的引用</td></tr><tr><td style="text-align:center"><strong>初始化</strong></td><td style="text-align:center">不必要</td><td style="text-align:center">一定要</td><td style="text-align:center">不必要</td></tr><tr><td style="text-align:center"><strong>何时使用</strong></td><td style="text-align:center">参数不希望被修改时</td><td style="text-align:center"><strong>优先选用引用</strong>、传递<strong>结构或类对象</strong>、希望参数被修改</td><td style="text-align:center">返回多个值、需传递空指针（引传递用不允许空值）、返回<strong>局部变量内存（3.5中详述）</strong></td></tr></tbody></table></li><li><p><strong>指针传递、引用传递底层区别</strong>？</p><ul><li><p><strong>指针传递本质是值传递</strong>。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的<strong>实参值</strong>，从而形成了实参的一个副本（替身）。</p><p>所以形参指针（内容）变了（保存了其它变量地址），实参指针不会变。</p></li><li><p><strong>引出传递本质是间接寻址</strong>。引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的<strong>实参的地址</strong>。被调函数对形参（本体）的任何操作都被处理成<strong>间接寻址</strong>，通过栈中存放的地址访问主调函数中的实参变量。</p></li><li><p><strong>符号表不同</strong>。程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的<u>地址值</u>为<strong>指针变量的地址值</strong>，而引用在符号表上对应的<u>地址值</u>为<strong>引用对象的地址值</strong>（与实参名字不同，地址相同，编译器直接处理为操作引用对象）。</p></li></ul></li></ul><h4 id="3-4-6-特殊参数">3.4.6 特殊参数</h4><p>在这一小节将来认识下比较特殊的两类参数。</p><ul><li><p><strong>命令行参数</strong></p><p>如果你运行过一些开源代码/库，经常会要求你输入指定参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ program arg1 arg2</span><br></pre></td></tr></table></figure><p>这为我们提供了一个<strong>可以向其他函数输入参数的方法</strong>，特别是<u>你无法修改源码或程序需要用户提供参数时</u>。当然，还可以通过配置文件实现，这里暂不表。</p><p>下面形式的main函数可以接受命令行参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>argc</code>：传递的参数量个数，至少为1，因为至少存在<code>argv[0]</code> 指向函数本身名称；</li><li><code>argv</code>： C风格二维数组，存储参数。例如，<code>argv[0][0]</code>指向第一个数组第一个字符，<code>argv[0]</code>是第一个数组第一个字符的地址。</li></ul><p>一个简单的程序，打印用户输入的姓名和年龄：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the count of paramters: &quot;</span>&lt;&lt; argc&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the name of program: &quot;</span>&lt;&lt; argv[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;your name: &quot;</span>&lt;&lt; argv[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;your age: &quot;</span>&lt;&lt; argv[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220102165327119.png" alt="image-20220102165327119"></p><p>特别的，操作系统对如何处理特殊字符（<strong>如双引号和反斜杠</strong>）有特殊的规则。</p><ul><li><p><strong>双引号</strong>：以双引号传递的字符串被认为是同一字符串的一部分（即使它们之间存在空格）；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.out <span class="string">&quot;royhuang cqu&quot;</span>  <span class="number">25</span></span><br></pre></td></tr></table></figure></li><li><p><strong>斜杠</strong>：如果要包含文字双引号，则必须反斜杠双引号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.out \<span class="string">&quot;royhuang\&quot;  25</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>省略号（可变参数</strong>）</p><p>到目前为止，在我们看到的所有函数中，函数将采用的参数数量必须事先知道。但是，在某些情况下，能够将<u>可变数量</u>的参数传递给函数会很有用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(argument_list, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>例如：我们要编写一个函数来计算一组整数的平均值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span> <span class="comment">// needed to use ellipsis</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findAverage</span><span class="params">(<span class="keyword">int</span> count, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过预定义宏va_list获取参数列表</span></span><br><span class="line">    va_list list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过宏va_start对va_list初始化</span></span><br><span class="line">    <span class="built_in">va_start</span>(list, count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> arg&#123; <span class="number">0</span> &#125;; arg &lt; count; ++arg)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">// 通过宏va_arg获取具体参数</span></span><br><span class="line">         sum += <span class="built_in">va_arg</span>(list, <span class="keyword">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用完后通过宏va_end清理va_list</span></span><br><span class="line">    <span class="built_in">va_end</span>(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum / count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">findAverage</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">findAverage</span>(<span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述结果输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3.5</span><br></pre></td></tr></table></figure><p>看起来这很棒。但是我们并不推荐使用省略号：</p><ol><li><p><strong>省略号很危险：无法判断传递的参数个数是正确</strong></p><p>假设你只传递了5个参数，而实际要求是6个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">findAverage</span>(<span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>在作者的机器上，这产生了奇怪的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">699773</span><br></pre></td></tr></table></figure><p><code>va_arg(list, int)</code> 返回的前5个值是我们传入的值。它返回的第 6 个值（<strong>没有报错</strong>）是一个垃圾值堆栈。结果，我们得到了一个垃圾答案。</p></li><li><p><strong>省略号很危险：类型检查被暂停</strong></p><p>如果你尝试传递一个浮点数（<code>1.0</code>）作为参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">findAverage</span>(<span class="number">6</span>, <span class="number">1.0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>结果一定让你大吃一惊（这是什么？这么大的数字？）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.78782e+008</span><br></pre></td></tr></table></figure><p>这是因为<code>va_arg(list, int)</code> 指定预期类型是<code>int</code> ，但是我们又传递double类型参数。这导致：</p><ul><li>va_arg 的第一次调用将只读取 double 的前 4 个字节（产生垃圾结果）；</li><li>va_arg 的第二次调用将读取 double 的后 4 个字节（产生另一个垃圾结果）；</li><li>因此，我们的总体结果是垃圾。</li></ul></li><li><p><strong>限定省略号：参数数量和类型</strong></p><p>幸运的是，我们可以人为的传递一个“解码器字符串”，它告诉程序如何解释参数（限定了数量和类型）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span> <span class="comment">// needed to use ellipsis</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findAverage</span><span class="params">(std::string decoder, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> sum&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">va_list list;</span><br><span class="line"></span><br><span class="line"><span class="built_in">va_start</span>(list, decoder);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> codetype&#123; decoder[count] &#125;;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (codetype)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\0&#x27;</span>:</span><br><span class="line"><span class="built_in">va_end</span>(list);</span><br><span class="line"><span class="keyword">return</span> sum / count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">sum += <span class="built_in">va_arg</span>(list, <span class="keyword">int</span>);</span><br><span class="line">++count;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">sum += <span class="built_in">va_arg</span>(list, <span class="keyword">double</span>);</span><br><span class="line">++count;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">findAverage</span>(<span class="string">&quot;iiiii&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">findAverage</span>(<span class="string">&quot;iiiiii&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">findAverage</span>(<span class="string">&quot;iiddi&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3.5</span>, <span class="number">4.5</span>, <span class="number">5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来很好，但是一般情况我们完全有其它合理的解决方案。比如：<strong>为什么不将<code>...</code> 换成一个数组</strong>？</p></li><li><p><strong>换成其它方案：动态数组</strong></p><p>一般情况，我们都要避免使用省略号，选择其它的方案。比如这里我们完全可以传递一个数组作为参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findAverage</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span>* nums)</span></span>;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="3-5-函数返回值">3.5 函数返回值</h3><p>在前面我们学习了<u>按值、引用和地址</u>向函数<strong>传递参数</strong>，如果作为函数<strong>返回值</strong>会有什么不同呢？</p><ul><li>按值返回的是<code>value</code>的副本？</li><li>按指针返回的是<code>value</code>的地址？局部变量在退出函数被销毁时，它的地址不是没有了吗？</li><li>按引用返回的是<code>value</code>的别名？局部变量在退出函数被销毁时，别名还有用吗？</li></ul><p>请看下文分解。</p><h4 id="3-5-1-按值返回">3.5.1 按值返回</h4><p>和按值传参一样，按值返回很安全，因为它<strong>只返回<code>value</code>的副本，不用担心返回之后<code>value</code>发生什么变化</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doubleValue</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value&#123; x * <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> value; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">doubleValue</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，它的缺点也和按值传参一致，返回大型结构或类时很慢。一般希望值不被修改或者返回局部变量时使用值传递。</p><p><strong>返回局部变量？函数调用结束时局部变量不就被销毁了，为什么还能返回</strong>？</p><p>在函数调用过程中是局部变量被压到栈中，当函数退出时，临时变量出栈，确实已经被销毁。</p><p><strong>但局部变量作为返回值时在函数调用时，有些特别的变化</strong>。</p><ul><li><p>C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit。</p></li><li><p>由此可见，函数调用结束后，<strong>返回值被临时存储到寄存器中</strong>，并没有放到堆或栈中，也就是说与内存没有关系了。</p><p>下图的汇编代码也表明了这一点：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220112002905629.png" alt="image-20220112002905629"></p></li></ul><p>这也就是为啥：上述代码value虽然作为返回值但也是局部变量，函数调用结束时，依旧正确返回了其值。</p><p>现在让我们来特别关注一下按地址/引用返回局部变量的情况。</p><h4 id="3-5-2-按指针返回">3.5.2 按指针返回</h4><p>和按指针传递参数类似，按指针返回的只是<strong>将<code>value</code> 的地址复制一份返回</strong>，所以速度很快。</p><ul><li><p><strong>危险：返回局部变量地址</strong></p><p>局部变量在函数退出时就会被销毁，如果尝试返回局部变量的地址，这种行为非常的危险（地址对应的内存可能已被释放）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">doubleValue</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> d_value = i*<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">return</span> &amp;d_value; <span class="comment">// 返回局部变量地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="built_in">doubleValue</span>(value);</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220103143317023.png" alt="image-20220103143317023"></p><p>编译器（VSCode）给出了警告，虽然输出值很幸运是正确的。但这是因为局部变量<code>d_value</code>对应栈空间还存在没有被重新分配使用，通过地址获取到了正确的值。</p><p>很显然这种做法很危险，你并不知道什么时候就返回的是一个垃圾值，因此不建议你去尝试。</p></li><li><p><strong>那按指针返回还有什么用途吗</strong>？</p><p><strong>按指针返回常用于将动态内存返回给调用者</strong>，因为动态分配的内存不会在函数退出时被销毁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">allocateArray</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[size]; <span class="comment">// 动态分配空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* array&#123; <span class="built_in">allocateArray</span>(<span class="number">25</span>) &#125;;</span><br><span class="line">    <span class="keyword">delete</span>[] array;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，分配空间（new[]）和删除空间（delete[]）在代码不同的函数中，使得谁负责删除资源和是否需要删除资源变得有点难以理解。</p><p>这里更好的做法是使用智能指针，第二章有相关介绍。</p><p><strong>另外一个用途就是返回按地址传递的参数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">doubleValue</span><span class="params">(<span class="keyword">int</span>* p_i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     *p_i = (*p_i)*<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">return</span> p_i; <span class="comment">// 返回指针参数p_i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="built_in">doubleValue</span>(&amp;value);</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>不说说返回地址其它用途吗</strong>？</p><p>既然提到返回地址很快，那用来返回结构体、类不应该很好吗？然而并不是。道理同参数传递中尽量建议使用引用一样：</p><ol><li>引用更安全。引用一定会被初始化，不能为空。</li><li>引用效率更好。比如它不用管理指针析构释放之类的问题。</li></ol></li></ul><h4 id="3-5-3-按引用返回">3.5.3 按引用返回</h4><p>与按指针返回类似，按引用返回的值不能是局部变量。</p><ul><li><p><strong>危险：不要返回局部引用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">doubleValue</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> d_value = i*<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">return</span> d_value;  <span class="comment">// 返回局部引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; ref = <span class="built_in">doubleValue</span>(value);</span><br><span class="line">    cout&lt;&lt;ref&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>道理同上按指针返回，除非你想哪天收到一个对垃圾的引用。</p></li><li><p><strong>什么时候按引用返回</strong></p><p>除了上述说的按值返回、按指针返回的情况，其它时候一般都建议按引用返回。</p><p><strong>比如返回大型数据结构、类等，以及返回按引用传递参数时</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">doubleValue</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     i = i*<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">return</span> i;    <span class="comment">// 返回按引用传递的参数i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; ref = <span class="built_in">doubleValue</span>(value);</span><br><span class="line">    cout&lt;&lt;ref&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-5-4-小结">3.5.4 小结</h4><p><strong>编码时选择何种方式返回参数</strong>？</p><p>和选择何种方式传递参数很像：</p><ol><li>不想修改<code>value</code>就是想返回<code>value</code>一个副本，or返回局部变量（见下节述）用值传递，否则转下一步；</li><li>需要动态内存分配时、返回按地址传递的参数，选择地址传递，否则转下一步；</li><li>其它情况，一般选用引用传递（返大型结构体、类、按引用传递的参数）。</li></ol><h4 id="3-5-5-返回多个值">3.5.5 返回多个值</h4><p>在<u>3.4.3</u> 介绍了使用地址传递参数，达到类似返回多个参数的效果。但是这种做法比较别扭，也不够优雅。C++有两种比较好的方式：</p><ol><li><p><strong>使用结构体</strong></p><p>将要返回的多个参数定义为一个结构体，最后直接返回结构体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> m_x;</span><br><span class="line"><span class="keyword">double</span> m_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">S <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S s;</span><br><span class="line">s.m_x++;</span><br><span class="line">s.m_y++;</span><br><span class="line"><span class="keyword">return</span> s;  <span class="comment">// 值传递，复制一个s的副本返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S s = <span class="built_in">add</span>();</span><br><span class="line">cout &lt;&lt; s.m_x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s.m_y &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比返回数组，结构体允许定义更多类型的值，显然更灵活。元组 <code>std::tuple</code> 也可以定义不同类型元素序列。</p></li><li><p><strong>使用元组</strong></p><p>见下例，使用元组返回多个不同类型的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; <span class="title">returnTuple</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="number">5</span>, <span class="number">6.7</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tuple s&#123; <span class="built_in">returnTuple</span>() &#125;; </span><br><span class="line">cout &lt;&lt; get&lt;<span class="number">0</span>&gt;(s) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; get&lt;<span class="number">1</span>&gt;(s) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-6-内联函数">3.6 内联函数</h3><p>函数给我们提供了非常多有用的功能：</p><ul><li>代码可以重复使用；</li><li>提供类型检查，确保参数类型匹配（类似函数的宏不会）；</li><li>便于阅读、调试；</li><li>…</li></ul><h4 id="3-6-1-那函数有什么缺点吗？">3.6.1 那函数有什么缺点吗？</h4><p>函数的一个主要缺点是每次<strong>调用函数</strong>时，都会发生一定量的性能开销（中断等），比如：</p><ol><li>CPU 必须存储它正在执行的当前指令的地址（因此它知道稍后返回到哪里）以及其他寄存器；</li><li>必须创建所有函数参数并赋值，并且程序必须跳转到新位置；</li><li>…</li></ol><p>当然，<strong>对于大型复杂的函数，函数调用时间相比函数运行时间微不足道。但是对于比较轻巧的函数，若是频繁调用，函数调用的时间便很可观了</strong>。</p><p>此时，我们希望这些轻巧又被经常调用的函数，最好不好进行这些复杂调用、返回操作。</p><p>如何做到这一点？类似于预编译头文件的替换，直接把<strong>函数体嵌入到每一个调用了它的地方，重复地嵌入</strong>。</p><p>请看下例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? y : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">min</span>(<span class="number">5</span>, <span class="number">6</span>) ;</span><br><span class="line">    <span class="built_in">min</span>(<span class="number">3</span>, <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>min(int,int)</code> 被声明为内联函数。在编译时，相当直接在相应调用位置替换为实际<code>min(int,int)</code>函数体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span> &gt; <span class="number">6</span> ? <span class="number">6</span> : <span class="number">5</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> &gt; <span class="number">2</span> ? <span class="number">2</span> : <span class="number">3</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小问题：内联函数这么棒，那把所有的函数写成内联函数?</p></blockquote><p>内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。</p><ul><li><strong>只适合比较简单的函数</strong>。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；</li><li><strong>占用内存空间多</strong>。另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间。</li></ul><p>典型的空间换时间策略。</p><h4 id="3-6-2-内联函数什么时候被替换？">3.6.2 内联函数什么时候被替换？</h4><p>在前面我们知道，宏会由预处理器对宏进行替代（预编译阶段）。而内联函数也会通过编译器来实现展开替换（编译阶段）。</p><blockquote><p>为了更好地验证所学，我们通过反汇编来对比加上<code>inline</code>前后代码的不同之处对比。</p></blockquote><p>准备一个更简单的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span>  <span class="title">add</span><span class="params">(<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">add</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成可执行文件后进行反汇编：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -save-temps -fverbose-asm -g  test.cpp -o test.out</span><br><span class="line">objdump -S --disassemble test.out</span><br></pre></td></tr></table></figure><p>关键性代码截图如下：</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220103183107580.png" alt="image-20220103183107580" style="zoom:80%;" /><p>可以看到<code>main</code> <strong>函数体内</strong>被直接插入了<code>add</code>函数的代码（绿色框）。</p><p>但是如果<code>add</code>函数是非内联函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止编译器自己优化，强制声明为非内联函数</span></span><br><span class="line"><span class="keyword">int</span> __attribute__ ((noinline)) <span class="built_in">add</span>(<span class="keyword">int</span> y)</span><br></pre></td></tr></table></figure><p>反汇编结果如图所示，<code>add</code>函数代码并没有插入到<code>main</code>函数体内。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220103183933062.png" alt="image-20220103183933062" style="zoom:80%;" /><h4 id="3-6-3-内联函数和宏对比">3.6.3 内联函数和宏对比</h4><p>一个常考的面试题，加深下印象。</p><ol><li><strong>替换时机</strong>。宏在预编译时被替换，内联函数是在运行时（至少不是预编译时）；</li><li><strong>调试</strong>。内联函数在运行时可调试，而宏定义不可以;</li><li><strong>安全</strong>。编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会；</li><li><strong>访问</strong>。内联函数可以访问类的成员变量，宏定义则不能。</li></ol><h3 id="3-7-函数指针">3.7 函数指针</h3><h4 id="3-7-1-函数和指针">3.7.1 函数和指针</h4><p>在前一节，通过反汇编，你也看到了（在<code>main</code>函数中）调用（<code>add</code>）函数是通过一个地址，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callq 40052d&lt;_Z3addi&gt;</span><br></pre></td></tr></table></figure><p>其中 <code>40052d</code> 便是函数<code>add</code> 的地址。让我们尝试打印一下函数地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 如果你的编译器打印出来的地址是1</span></span><br><span class="line">   <span class="comment">// 需要转换为空指针，强制编译器打印出地址：(void*)func</span></span><br><span class="line">   cout&lt;&lt;func&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x4007ad</span><br></pre></td></tr></table></figure><p>可以看到，就像指针一样，<code>func</code> 保存的也是一个地址，只不过它保存的是函数地址。<strong>有函数地址就可以调用函数，此时可将函数压入栈</strong>（3.8节详述）。</p><p>像指针一样？那么可以像下面这样，使用<code>int*</code>指针保存函数指针吗？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p_func = func;</span><br><span class="line"><span class="built_in">p_func</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>很不幸报错了：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220104223733205.png" alt="image-20220104223733205"></p><p>主要原因是因为：虽然<code>func</code> 和<code>p_func</code>都是指针，但它们类型是不一样的。函数<code>func</code> 类型是<code>int(*)()</code> ,而我们给出的指针<code>p_func</code>类型是<code>int*</code> ，无法赋值。就像你不能将<code>string*</code> 类型指针赋值给<code>int*</code> 类型指针。</p><p>所以，我们至少还得让他们参数类型一致：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p_func)() = func;</span><br><span class="line"><span class="built_in">p_func</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>依旧报错了：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220104224700403.png" alt="image-20220104224700403"></p><p>这是因为<u>函数指针<code>p_func</code>的类型参数和函数<code>func</code>不一致</u>，编译器类型检查时出错。</p><blockquote><p>题外话：为什么是在运行时报错，而不在编译代码时报错？</p><p>因为函数指针是在运行时才会进行解析。</p></blockquote><p>我们还应该指定其参数类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p_func)(<span class="keyword">int</span>) = func;</span><br><span class="line"><span class="built_in">p_func</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>一切到此就好起来了。<code>p_func</code>此时获得了函数的地址，就可以像<code>func</code>一样使用了。</p><p>特别的下面这种方式也是正确的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p_func)(<span class="keyword">int</span>) = &amp;func; <span class="comment">// 函数名多了个&amp;，func和&amp;func打印出来其实是一样的，都是函数地址</span></span><br><span class="line"><span class="built_in">p_func</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="3-7-2-为什么需要函数指针：回调函数">3.7.2 为什么需要函数指针：回调函数</h4><p>虽然，前面我们了解了怎么定义和使用函数指针。但不禁还是有疑惑：<strong>使用函数指针<code>p_func</code> 调用函数<code>func</code>不是多此一举？直接使用<code>func</code>不就好了</strong>？</p><p>想象这么一种情况：</p><ul><li>你有一个函数假定为<code>funcA</code> , 但你的功能需要外部自定义一些规则，这些规则用户自定义的；</li><li>所以你需要一个“参数”来保存这些特定的规则，而这个规则显然是一个逻辑集合——换句话，它应该是个函数。</li></ul><p>那么这个“参数”是不是应该是函数类型？某个函数如果作为参数传递给另一个函数，就是<strong>回调函数</strong>。</p><p>我们举一个更具体的例子：</p><ul><li>我们定义一个排序函数，将数字进行排序：但排序的规则由用户自定义，它可能是从大到小排列，也可能是从小到大或者其它——总之它取决于用户怎么定义“规则”。</li></ul><p>我们给定一个排序函数如下，它有一个参数<code>bool (*comparisonFcn)(int, int)</code>用来定义排序规则：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换数组值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> idx_i,<span class="keyword">int</span> idx_j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[idx_i];</span><br><span class="line">    arr[idx_i] = arr[idx_j];</span><br><span class="line">    arr[idx_j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序规则</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">bool</span> (*compare)(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)   <span class="comment">// 外轮=n-1</span></span><br><span class="line">        <span class="comment">// * j=0,每次都是从头开始比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; len-i<span class="number">-1</span>; j++ ) <span class="comment">// 内轮=余下乱序数-1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">compare</span>(arr[j],arr[j+<span class="number">1</span>]))</span><br><span class="line">                <span class="built_in">swap</span>(arr,j,j+<span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> array[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(array)/<span class="built_in"><span class="keyword">sizeof</span></span>(array[<span class="number">0</span>]);</span><br><span class="line">   <span class="built_in">bubbleSort</span>(array,len,myCompare);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len  ;i++)</span><br><span class="line">       cout&lt;&lt;array[i]&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>显然这种方式，优雅且灵活，<u>除了定义的函数指针实在过于丑陋</u>。当然在上述<code>myCompare</code> 函数中，你甚至可以定义一些奇怪的规则：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ((a % <span class="number">2</span> == <span class="number">0</span>) &amp;&amp; !(b % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以尝试输出试一试。</p><h4 id="3-7-3-更优雅地使用函数指针">3.7.3 更优雅地使用函数指针</h4><p>前面我们提到，函数指针的声明实在过于丑陋：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*compare)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*)(<span class="keyword">int</span>,<span class="keyword">int</span>) compare;</span><br></pre></td></tr></table></figure><p>好消息你现在有两种方式让它看起来顺眼很多：</p><h5 id="1-类型别名">1. 类型别名</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">using</span>  bool_compare = <span class="built_in"><span class="keyword">bool</span></span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数中使用：就行使用普通的类型一样</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, bool_compare compare)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-function">2. function</h5><p>std::function是标准库 <code>&lt;functional&gt;</code> 头文件的一部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们将之前的排序函数，重新定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, std::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt;)</span></span></span><br></pre></td></tr></table></figure><p>在主函数中，如此调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其余函数代码同前，略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> array[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(array)/<span class="built_in"><span class="keyword">sizeof</span></span>(array[<span class="number">0</span>]);</span><br><span class="line">   std::function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; compare = myCompare;</span><br><span class="line">   <span class="built_in">bubbleSort</span>(array,len,compare);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len  ;i++)</span><br><span class="line">       cout&lt;&lt;array[i]&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h5 id="3-function是什么？">3. function是什么？</h5><p>有一个很有意思的事情，函数定义必须要和主函数中传递的参数类型一致（都是<code>std::function</code>），不能定义为指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">bool</span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>) compare)</span></span></span><br></pre></td></tr></table></figure><p>如果你这个时候这样调用函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在main中</span></span><br><span class="line">std::function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; compare = myCompare;</span><br><span class="line"><span class="built_in">bubbleSort</span>(array,len,compare);</span><br></pre></td></tr></table></figure><p>会报错：<code>error: cannot convert ‘std::function&lt;bool(int, int)&gt;’ to ‘bool (*)(int, int)’</code>。</p><p>因为<code>std::function</code>本质是一种<strong>类模板，不是函数</strong>，是对通用、多态的函数封装。</p><ul><li>通过<code>std::function</code>对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，形成一个std::function对象。让我们不再纠结那么多的可调用实体，一切变的简单粗暴。</li><li>换句话说，<code>std::function</code><strong>就是函数的容器，它自己是个类对象</strong>。当我们有了函数的容器之后便能够<strong>更加方便的将函数、函数指针作为对象进行处理</strong>。</li></ul><p>我们来看看它的原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="title">class</span>... <span class="title">Args</span> &gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function</span>&lt;</span><span class="built_in">R</span>(Args...)&gt;</span><br></pre></td></tr></table></figure><p>类为function，R是返回值类型，Args是函数的参数类型。再回想我们之前的调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; compare = myCompare;</span><br></pre></td></tr></table></figure><p>很显然，<strong>此时<code>compare</code> 本质是一个function类对象，只不过重载了其函数调用操作符()，所以使用的时候可以直接像函数一样调用</strong>。</p><p>特别的，<strong>function类还重载了赋值操作符=，这样可以将可调用的函数实体赋值给它</strong>。其函数调用操作符重载函数里间接的调用赋值时传进来的调用实体。</p><h5 id="4-使用auto">4. 使用auto</h5><p>使用auto关键字自动推断类型，可更简便地使用函数指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> compare = myCompare;</span><br></pre></td></tr></table></figure><p>但是这个时候<code>compare</code>隐藏了类型具体定义，如果希望读者更了解这段代码意义，使用<code>typedef</code> 应该是个更好的做法。</p><h4 id="3-7-4-CPU眼中的函数指针：变量">3.7.4  CPU眼中的函数指针：变量</h4><p>去繁归真，我们来看看CPU眼中的函数指针是什么？</p><p>答案可能会让你惊奇：它在CPU眼中不过是一个过度包装的变量而已，就像指针一样也只是变量。</p><p>参考：<a href="https://www.zhihu.com/zvideo/1433792635044048898">CPU眼里的“函数指针”：过度包装的“变量” - 阿布的视频 - 知乎 </a></p><h4 id="3-7-5-小结">3.7.5 小结</h4><ul><li><p><strong>什么是函数指针</strong>？</p><p>函数指针是指向特殊的数据类型（即函数）的指针变量。</p><ul><li>函数的名字也可视为是函数的指针；</li><li>使用重载后的<code>()</code> 即<code>函数名()</code> 便是调用一个函数。</li></ul><p>它在CPU眼中不过是过度包装的“变量”。</p></li><li><p><strong>函数指针的声明&amp;赋值方式</strong>？</p><p>以下为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p_func)(<span class="keyword">int</span>) = func </span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p_func)(<span class="keyword">int</span>) = &amp;func</span><br></pre></td></tr></table></figure></li><li><p><strong>函数指针的用途</strong>？</p><p>函数指针还允许将函数作为参数传递给其他函数，即回调函数。</p></li></ul><h3 id="3-8-栈和堆🌟">3.8 栈和堆🌟</h3><p>在这一节中，我们来了解程序运行时，函数调用更底层的过程。不过在这之前，我们先了解下内存布局。</p><h4 id="3-8-1-内存布局">3.8.1 内存布局</h4><h5 id="内存布局初识">内存布局初识</h5><blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span>位系统4GB（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>=</mo><mn>4</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{32}=4GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span></span></span></span>）。</p></blockquote><p>下图展示了一个虚拟进程（程序）内存空间<u>运行时</u>分布布局，注意到此时还<u>多了堆&amp;栈用来给程序运行时进行空间分配</u>。</p><ul><li><p><strong>一个程序（比如hello.out）本质是由数据段、代码段、.bss段（图中和数据段合并了）三个组成的。</strong></p></li><li><p>另外，高地址的1GB（Windows默认2GB）空间分配给内核，也称为<strong>内核空间</strong>；剩下的3GB分给用户，也称<strong>用户空间</strong>（程序使用的）。</p></li></ul><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/5e8d39d19a216fd03392d36081e70b7e.jpg" alt="你确定你理解内存分配吗？" style="zoom:80%;" /><p>作为程序员，我们更关注的是用户空间中的内容，也就是：</p><ul><li><p><strong>栈（Stack</strong>）：存储代码中调用函数、定义<u><strong>局部</strong>变量</u>(但不包含static修饰的变量)、保存的上下文等；</p><ul><li><p><strong>特点</strong>：存放的数据从<strong>栈顶（低地址</strong>）压入，也是从<strong>栈顶（低地址</strong>）弹出，所以有人说栈是<strong>向下生长</strong>的。函数退出时，所有数据会自动释放内存（出栈）。</p><img src="https://pic1.zhimg.com/v2-4a47248b485bc764430e802f87ee950c_b.webp" alt="img" style="zoom:67%;" /></li></ul></li><li><p><strong>文件映射区域 ：</strong> 栈和堆中间那个空白区域。动态库、共享内存等映射物理空间的内存，一般是 <code>mmap</code> 函数所分配的虚拟地址空间。</p></li><li><p><strong>堆（Heap</strong>）：存储那些生存期<u>与函数调用无关的数据</u>，如动态分配的内存。堆（动态）分配的接口通常有malloc()、calloc()、realloc()、new等。</p><ul><li><strong>特点</strong>：相对于栈，堆是<strong>向上生长</strong>的；堆空间需要主动释放，否则会依然存在。</li></ul></li><li><p><strong>.bss段</strong>：全称Block Started by Symbol，也就是未被初始化的<strong>全局</strong>变量、<strong>静态</strong>变量的内容的一块内存区域。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;  <span class="comment">// a保存.bss段</span></span><br><span class="line"><span class="keyword">int</span> b;         <span class="comment">// b保存在.bss段</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>数据段（.data</strong>）：保存<strong>全局</strong>变量、<strong>常量</strong>、<strong>静态变量</strong>的内容的一块内存区域，区别.bss段在于变量已经被初始化。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;  <span class="comment">// a保存在.data段中静态区，1是文字常量在代码区</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;         <span class="comment">// b保存在.data段中全局区，2是文字常量在代码区</span></span><br><span class="line"><span class="keyword">char</span>* str =  <span class="string">&quot;royhuang&quot;</span>; <span class="comment">// str保存在栈上，&quot;royhuang&quot;是字符常量，保存在常量区</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">3</span>;   <span class="comment">// c保存在.data段中常量区，3是文字常量在代码区</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>代码段（.text &amp; .init</strong>）： <code>.text</code> 用于存放整个程序中的代码， <code>.init</code> 用于存放系统中用来初始化启动你的程序的一段代码 。</p></li></ul><p><strong>一个程序本质其实都是由.bss段、数据段、代码段三个组成的。</strong></p><h5 id="静态存储区探讨">静态存储区探讨</h5><p>前面我们认识到C++内存布局分为：</p><ul><li>堆：存放动态分配的内存；</li><li>栈：存放临时分配局部变量；</li><li>代码段：存储程序指令，也可能包含只读的常量（如文字常量）；</li><li>.bss段和数据段：分别存储初始化和未初始化的<code>全局变量</code>和<code>静态变量</code>，数据段还可以存储常量。</li></ul><p>.bss段和数据段主要区别在于是否初始化，这里我们不做区分，统称为<u>静态存储区</u>。</p><p>根据.bss段和数据段存储的数据类型，静态存储区又可分为：</p><ul><li>静态变量区，存储静态变量</li><li>全局变量区，存取全局变量</li><li>常量区，存储字符串常量和全局常量（局部常量存储在栈中），<u>只读</u></li></ul><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a保存在静态变量区，1是文字常量在代码区，此时a值为1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;  </span><br><span class="line"><span class="comment">// b保存在全局变量区（此时值为2），2是文字常量在代码区，此时b值为2</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;   </span><br><span class="line"><span class="comment">// c保存在常量区，3是文字常量在代码区，此时c的值为3</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">3</span>;   </span><br><span class="line"><span class="comment">// str保存在全局区，&quot;royhuang&quot;是字符常量，保存在常量区，此时str只是保存&quot;royhuang&quot;地址</span></span><br><span class="line"><span class="keyword">char</span>* str1 =  <span class="string">&quot;royhuang&quot;</span>; </span><br><span class="line"><span class="comment">// str是数组，保存在全局区，此时str复制了字符串常量&quot;hwh&quot;，所以值为&quot;hwh&quot;</span></span><br><span class="line"><span class="keyword">char</span> str2[] =  <span class="string">&quot;hwh&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">4</span>;  <span class="comment">// d在栈上，4是文字常量在代码区，d的值在【运行时】被赋值为4</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> f = <span class="number">5</span>; <span class="comment">// 区分c，此时f是局部变量保存在栈上，f在【运行时】被赋值为5</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> g = <span class="number">6</span>; <span class="comment">// 同a  </span></span><br><span class="line">    <span class="keyword">char</span>* str3 =  <span class="string">&quot;roy&quot;</span>; <span class="comment">// 同str1，不过此时str3保存在栈上,&quot;roy&quot;在常量区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应汇编代码也验证了这一点（静态变量区内容汇编代码未展示）：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220208134212195.png" alt="image-20220208134212195"></p><p>还应注意到：</p><ul><li>存储在静态存储区的变量的值，在编译期间就确定了；</li><li>而堆、栈上变量的值是运行时动态分配的。</li></ul><p>继续分析下面这个问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[] =  <span class="string">&quot;royhuang&quot;</span>;</span><br><span class="line">   str[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;   <span class="comment">// ok</span></span><br><span class="line">   <span class="keyword">char</span>* pstr  =  <span class="string">&quot;royhuang&quot;</span>;</span><br><span class="line">   pstr[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;  <span class="comment">// error，为什么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>char str[] =  &quot;royhuang&quot;</code> ，<code>str</code> 保存在栈上，运行时将常量区的字符串常量“royhuang”，赋值给了数组<code>str</code> ，修改<code>str</code>数组成员是合法的；</li><li><code>char* pstr  =  &quot;royhuang&quot;</code> ，<code>pstr</code> 保存在栈上，但运行时只是将字符串常量“royhuang”的<u>地址</u>，赋值给了指针<code>pstr</code> ，<strong>尝试修改常量区的成员是非法的</strong>！</li></ul><h4 id="3-8-2-函数调用过程">3.8.2 函数调用过程</h4><p>在这一小节我们来深入探讨下函数调用时的原理和过程。</p><h5 id="栈帧">栈帧</h5><p>前面我们说到，栈是位于进程的高地址位置，且栈顶是向下增长的。在<u>函数调用</u>时，<strong>栈会专门使用一个独立的栈帧保存函数调用需要的所有信息</strong>。这对后面理解函数执行过程很关键。</p><p>一个典型的栈帧如下：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/stack1.png" alt="img"></p><ul><li><strong>栈帧保存的内容</strong>：每一次函数调用需要的函数返回地址、参数、临时变量、保存的上下文等；</li><li><strong><code>esp</code>和<code>ebp</code></strong> ：非常重要的两个寄存器，记录了当前<strong>栈帧</strong>的<strong>栈顶位置和栈底位置</strong>（对于<code>X86-64</code>平台上来说，对应的寄存器则为<code>rsp</code>及<code>rbp</code>） 。<ul><li>可以看到在上图压栈（push）会使得esp向下移动（地址变小）。</li></ul></li></ul><h5 id="汇编分析">汇编分析</h5><p>我们准备的验证代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> sp1, <span class="keyword">int</span> sp2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = sp1 + sp2;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res =  <span class="built_in">foo</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编的代码及分析如下。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220109134057556.png" alt="image-20220109134057556"></p><ul><li><p>main函数汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">        pushq   %rbp   # 寄存器rbp保存上一个栈帧栈底位置 </span><br><span class="line">        movq    %rsp, %rbp # 寄存器rsp指向栈顶位置，用rsp内容初始化寄存器rbq</span><br><span class="line">        subq    $16, %rsp</span><br><span class="line">        movl    $2, %esi # 立即数寻址，将foo第二个参数存入寄存器esi中</span><br><span class="line">        movl    $1, %edi # 将foo的第一个参数存入寄存器edi中</span><br><span class="line">        call    _Z3fooii # 调用foo，转到分析foo函数汇编代码，此时call还将下一条指令当做返回地址压入到栈中</span><br><span class="line">        movl    %eax, -4(%rbp) # 返回函数结果给res，它的地址是-4(%rbp)</span><br><span class="line">        movl    $0, %eax # eax被置为0，主函数退出</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure></li><li><p>foo函数汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_Z3fooii:</span><br><span class="line">        pushq   %rbp  # 保存main的栈底地址rbp，用于返回</span><br><span class="line">        movq    %rsp, %rbp # 重置foo函数的栈帧</span><br><span class="line">        movl    %edi, -20(%rbp) # 参数1入栈</span><br><span class="line">        movl    %esi, -24(%rbp) # 参数2入栈</span><br><span class="line">        movl    -20(%rbp), %edx # 参数1存入edx</span><br><span class="line">        movl    -24(%rbp), %eax # 参数2存入eax</span><br><span class="line">        addl    %edx, %eax      # 加法运算，结果保存在eax中</span><br><span class="line">        movl    %eax, -4(%rbp)  # 将运算结果赋值给result,它的位置为rbp-4 </span><br><span class="line">        movl    -4(%rbp), %eax  # 将result赋值给eax，eax为函数返回值</span><br><span class="line">        popq    %rbp # 跳转到main函数（栈底），然后还需要跳到返回地址</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>栈压入顺序</strong>：当前栈帧状态信息（如rbp）—&gt; 当前函数的参数（逆序）—&gt;当前函数的局部变量等—&gt;…—&gt;退出。</p></blockquote><ul><li><strong>在调用函数（main）函数中</strong><ol><li><strong>保存上一个栈帧的rbp，重置main栈帧的rbp</strong>；</li><li>按照与被调函数foo的<strong>形参顺序相反的顺序</strong>压入栈中（在本例是直接存入寄存器中，因为直接传入常量foo(1,2)）；</li><li><strong>call指令调用</strong>： 调用者函数（main）使用call指令调用被调函数（foo），为foo函数分配栈帧空间，<strong>并把call指令的下一条指令的地址当成返回地址</strong>压入栈中（这个压栈操作是隐含的）</li></ol></li><li><strong>在被调用函数（foo）函数中</strong><ol><li>保存main栈帧的rbp，重置foo栈帧的rbp；</li><li>被调参数sp1、sp2压入栈中；</li><li>执行foo函数体中代码，返回值res入栈，<strong>然后保存在寄存器eax中</strong> ；</li><li>执行完毕，栈帧所有数据出栈；</li><li><code> popq %rbp 和 ret</code> 跳转main中call指令的下一条指令地址继续执行。</li></ol></li><li><strong>回到调用函数（main）函数中</strong><ol><li>返回值res（寄存器eax中内容）压入栈；</li><li>继续main函数中后续代码执行；</li><li>main函数退出。</li></ol></li></ul><h4 id="3-8-3-malloc-free-原理">3.8.3 malloc/free 原理</h4><h5 id="从静态分配说起">从静态分配说起</h5><p>我们之前接触数据通常保存在：</p><ol><li><strong>栈</strong>，比如函数内部局部变量；</li><li><strong>数据段</strong>，静态区、全局区、常量区；</li><li><strong>.bss段</strong>，未初始化的数据。</li></ol><p>上面的数据有两个共同点：</p><ul><li><strong>变量/数组的大小必须在编译时知道</strong>。</li><li><strong>内存分配和释放自动发生（当变量被实例化/销毁时</strong>）。</li></ul><p>大多数时候，这很好。那什么时候在<strong>堆</strong>上分配内存？</p><p>很多时候，我们需要<u>在堆上动态申请/释放内存</u>。</p><ol><li><strong>不知道分配对象的大小</strong>。比如我们想创建声明一个数组，但是事先并不知道数组的大小（稍后才能知道）。这个时候<u>无法使用静态数组分配</u>，因为它必须指定数组的大小；</li><li><strong>分配的对象太大</strong>。栈等空间不够。</li></ol><p>在C中，我们常常使用malloc/free在堆上分配和释放内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配：大小为4的int数组</span></span><br><span class="line"><span class="keyword">int</span>* <span class="built_in">array</span> ;</span><br><span class="line"><span class="built_in">array</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);</span><br></pre></td></tr></table></figure><p><strong>malloc和free函数底层是如何去实现的，如何在堆上分配内存的</strong>？</p><h5 id="从堆块说起">从堆块说起</h5><blockquote><p>主要参考：<a href="https://zhuanlan.zhihu.com/p/57863097">malloc 的实现原理 内存池 mmap sbrk 链表</a></p></blockquote><p><strong>什么是堆</strong>？</p><p>C++使用动态内存分配器（下简称分配器）进行动态内存分配，它维护一个<u>进程的虚拟内存区域</u>，也就是堆。</p><p><strong>分配器眼里的堆是什么？如何进行管理</strong>？</p><p>分配器将堆视为<strong>一组不同大小的块（block）<strong>的集合来维护。每个块就是</strong>一个连续的虚拟内存片（chunk）</strong>,要么是已分配的，要么是空闲的。</p><p>chunk结构图：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/10681867-ce8d3eeabf100d45.png" alt="img"></p><ul><li>正在使用的chunk标识意义<ul><li><code>prev_size</code>： 表示前一个 chunk 的 size,程序可以使用这个值来找到前一个 chunk 的开始地址（<code>P=0</code>才有效）；</li><li><code>size</code>： 表示当前chunk的size大小；</li><li><code>A</code>：为1表示属于主分配区（已分配），否则属于非主分配区（未分配）；</li><li><code>M</code>：为 1 表示该 chunk 是从 mmap 映射区域分配的，否则是从 heap 区域分配的；</li><li><code>P</code>：为1表示前一个chunk在使用中，为0表示空闲。</li></ul></li><li>空闲chunk标识意义<ul><li><code>fd、bk</code> ：分别指向前、后的空闲chunk，通过这种方式将将大小相近的chunk连成一个双向链表；</li></ul></li></ul><p>具体来说，<strong>分配器通过bins+空闲链表（非常类似哈希表），对堆块进行管理</strong>。</p><p>一个典型的堆整体结构：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/10681867-9c09c94096413f83.png" alt="img"></p><p>可以看到，内存分成了大小不同的chunk，然后通过<strong>bins</strong>来组织起来；相似大小的chunk用<strong>双向链表</strong>链接起来，一个链表被称为<strong>bin</strong>。</p><ul><li><strong>unsorted bin</strong>：即bin[1]（bin[0]没有被使用），用于<u>维护free释放的chunk</u>；</li><li><strong>small_bins</strong>：即bins[2,63)，用于维护＜512字节的内存块，其中每个元素对应的链表中的chunk大小相同，均为<code>index*8</code>；</li><li><strong>large_bins</strong>：即bins[64,127)，用于维护&gt;512字节的内存块，每个元素对应的链表中的chunk大小不同，index越大，链表中chunk的内存大小相差越大；</li></ul><p>在堆中，还有一个很特殊的top chunk。</p><ul><li><strong>产生时机</strong>：程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk，所以它不属于任何一个 bin；</li><li><strong>作用</strong>：在于当所有的 bin 都无法满足用户请求的大小时，就使用top chunk进行分配，并将剩下的部分作为新的 top chunk。堆顶指针brk位于top chunk的顶部，移动brk指针，即可扩充top chunk的大小。</li></ul><p>现在我们再来探讨malloc分配的过程。</p><h5 id="malloc原理">malloc原理</h5><p>glibc在内存池中查找合适的chunk时，采用了<strong>最佳适应</strong>的伙伴算法。</p><p><strong>第一次分配内存时会进行堆初始化</strong>：</p><ol><li>一开始时，brk和start_brk是相等的，这时实际heap大小为0；</li><li>如果第一次用户请求的内存大小&lt; <strong>mmap分配阈值</strong>，则（<strong>通过移动brk指针扩展堆大小</strong>）malloc会申请(chunk_size+128kb) align 4kb大小的空间作为初始的heap。</li></ol><p><strong>往后会按照顺序：bins查找分配–&gt;brk扩展堆分配—&gt;mmap分配</strong>：</p><ol><li><p><strong>如果分配内存&lt;max_fast=默认64B</strong>，在fast bins 中查找相应的空闲块；</p></li><li><p><strong>如果分配内存&lt;512字节</strong>，则通过内存大小定位到smallbins对应的index上：</p><ul><li>如果smallbins[index]为空，进入步骤3；</li><li>如果smallbins[index]非空，直接返回第一个chunk。</li></ul></li><li><p><strong>如果分配内存&gt;512字节</strong>，定位到largebins对应的index上：</p><ul><li>如果largebins[index]为空，进入步骤3；</li><li>如果largebins[index]非空，扫描链表，找到第一个大小最合适的chunk，如size=12.5K，则使用chunk B，<u>剩下的0.5k释放并放入unsorted_list中</u>。</li></ul></li><li><p><strong>遍历unsorted_list</strong>：</p><ul><li>查找合适size的chunk，如果找到则返回；</li><li>否则，将这些chunk都归类放到smallbins和largebins里面。</li></ul></li><li><p><strong>在bin更大的链表寻找</strong>：从index++更大的链表继续寻找：</p><ul><li>查找合适size的chunk，如果找到则返回，<u>同时还会将chunk拆分</u>，并将<u>剩余的加入到unsorted_list中</u>。</li><li>找不到则通过top chunk。</li></ul></li><li><p><strong>通过top chunk分配</strong>：默认top chunk分配的最大大小为128K（也是mmap分配的阈值）：</p><ul><li><p>top chunk大小&gt;分配的内存，则返回合适大小chunk，剩余的作为新的 top chunk；</p></li><li><p>top chunk大小&lt;分配的内存&lt;128K，<u>移动brk指针</u>扩展top chunk大小，满足分配；</p></li><li><p>分配的内存&gt;128K，通过mmap分配内存。</p></li></ul></li><li><p><strong>通过mmap分配</strong>。在进程的虚拟地址空间中（堆和栈中间的文件映射区域）找一块空闲的虚拟内存返回地址。</p></li></ol><p>总结以上，内存分配（malloc）主要由两种系统调用完成：brk和mmap（不考虑共享内存）。</p><ul><li><strong>brk</strong>：分配内存 &lt; DEFAULT_MMAP_THRESHOLD，走<code>__brk</code>，将数据段(.data)的最高地址指针<code>_edata</code>，往高地址推；</li><li><strong>mmap</strong>：分配内存 &gt; DEFAULT_MMAP_THRESHOLD，走<code>__mmap</code>，直接调用mmap系统调用。在进程的虚拟地址空间中（堆和栈中间的文件映射区域）找一块空闲的虚拟内存。</li></ul><p>其中，DEFAULT_MMAP_THRESHOLD是mmap分配阈值，默认为128K。</p><p>值得注意的是，这两种方式分配的<strong>都是虚拟内存</strong>，没有分配物理内存。只有实际调用发生缺页中断时，才会建立虚拟内存和物理内存之间的映射关系。</p><blockquote><p>不过这里有个小问题，<strong>既然<code>brk、mmap</code>提供了内存分配的功能，直接使用<code>brk、mmap</code>进行内存管理不是更简单吗，为什么需要glibc呢</strong>？</p></blockquote><p>因为系统调用本身会产生软中断，导致程序从用户态陷入内核态，比较消耗资源。试想，<strong>如果频繁分配回收小块内存区，那么将有很大的性能耗费在系统调用中</strong>。</p><p>因此，为了减少系统调用带来的性能损耗，glibc采用了内存池的设计，增加了一个代理层，每次内存分配，都优先从内存池中寻找，如果内存池中无法提供，再向操作系统申请。</p><h5 id="free原理">free原理</h5><p>前面我们说到，C++将对视为堆视为一个个chunk（block）的集合，每个chunk的结构如下：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/10681867-ce8d3eeabf100d45.png" alt="img"></p><p>malloc分配好内存，返回的是<strong>User data的起始地址</strong>，<strong>header</strong>则保存了当前chunk的一些信息。</p><p>但free并非真的直接将相应内存区域返回操作系统：</p><ul><li><p><strong>如果<code>free</code> 释放<code>mmap</code> 分配内存</strong>，<code>free</code>可以很顺利就释放掉其相关的虚拟和物理内存，返回操作系统；</p></li><li><p><strong>如果<code>free</code> 释放 <code>brk</code>分配的内存</strong>，<strong><code>free</code>只是标记chunk可被重新分配并加入空闲链表（A=0），但没有真的删除任何数据</strong>！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a  = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a = &quot;</span>&lt;&lt;*a&lt;&lt;endl; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a = &quot;</span>&lt;&lt;*a&lt;&lt;endl; <span class="comment">// 0，数据被清除，但没被操作系统回收</span></span><br><span class="line">*a=<span class="number">2</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a = &quot;</span>&lt;&lt;*a&lt;&lt;endl; <span class="comment">// 2，依据可以被使用，虽然这很危险</span></span><br></pre></td></tr></table></figure><p>具体加入到空闲链表何处，也分三种情况考虑：</p><ul><li>如果该chunk<u>和top chunk相邻，则将其和top chunk合并</u>；<ul><li>特别的，如果top chunk&gt;128K，会执行内存紧缩（trim）操作移动brk指针。</li></ul></li><li>如果free的chunk的大小在0x20~0x80之间（fastbin的范围），<u>那么该chunk直接放到fast bin上</u>；</li><li>如果free的chunk的大小大于0x80（大于fast bin的范围），此时不会直接放到small bin或者large bin上面，<u>而是放到unsorted bin上面</u>；</li></ul></li><li><p><strong>最佳实践：删除一个指针时，请将指针设置为 nullptr</strong>。</p><p>否则的话，使用一个指向的内存已经被释放的一种指针，是使用<strong>悬空指针</strong>。</p><p>（区分野指针是指使用时还没被初始化）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;*a&lt;&lt;endl; <span class="comment">// 危，此时a是悬空指针，已经被free(a)</span></span><br><span class="line">a = <span class="literal">nullptr</span>;    <span class="comment">// 最佳实践：将已经释放的指针置空</span></span><br><span class="line">cout&lt;&lt;*a&lt;&lt;endl; <span class="comment">// 此时编译器会报错，ok</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>可以看到，如果free的chunk没有和top chunk相邻被合并，其又太小的话，可能永远不会被使用</strong>——这就产生了内存碎片。</p><p>如下图：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/10681867-4b414b22810c9e9d.png" alt="img"></p><p>free(A)后，由于chunk A无法和top chunk合并，在堆中便产生了内存空洞，也就是内存碎片。幸运的是，它还足够大（40K），有很大概率其空间是能够被利用的。</p><p><strong>小细节：free如何知道释放多大空间</strong>？</p><p>在前面地址传递我们知道：<strong>向一个函数传递指针的时候，它的长度信息往往会被截断（如果是数组名），无法标示数组的长度</strong>。因此，在函数中我们也无法获取它的长度信息，除非显示传递一个长度参数。</p><p>那free如何知道释放多大的空间？</p><p>原因很简单，free根本不用关系chunk大小，malloc分配的时候就是分配一个合适大小chunk。chunk包含header和user data。<strong>free只是将header中的相关标记为可用，加入空闲链表中即可</strong>。</p><h4 id="3-8-4-new-delete-原理">3.8.4 new /delete 原理</h4><p>在3.8.3节介绍了C语言中的动态内存分配方式：malloc，malloc函数分配失败返回指针空值，成功返回首地址。</p><p>现在我们来认识一下C++中的动态内存管理方式：new和delete。</p><p>准备好一个公共类<code>Stu</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>                           </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span>                                          </span></span><br><span class="line"><span class="class">&#123;</span>                   </span><br><span class="line">  <span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">Stu</span>()           </span><br><span class="line">    &#123;                         </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;默认构造函数初始化&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;                     </span><br><span class="line">    <span class="built_in">Stu</span>(<span class="keyword">int</span> num, string name):_num(num), _name(name)</span><br><span class="line">    &#123;                         </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;自定义构造函数初始化&quot;</span> &lt;&lt; endl;   </span><br><span class="line">    &#125;                      </span><br><span class="line">    ~<span class="built_in">Stu</span>()              </span><br><span class="line">    &#123;                       </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;析构销毁&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;                         </span><br><span class="line">  <span class="keyword">private</span>:   </span><br><span class="line">    <span class="keyword">int</span> _num;               </span><br><span class="line">    string _name;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h5 id="new原理">new原理</h5><p>无论是new还是delete，它们在<u>内置类型/自定义类型</u>上使用有些不同。</p><ul><li><p><strong>new底层实现（内置类型</strong>）</p><p>对于内置类型来说，new和malloc功能基本一致：</p><ul><li>分配内存空间；</li><li>返回内存空间地址。</li></ul><p>不过new还可以进行<strong>初始化</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化单个：等同于int* a = (int*)malloc(sizeof(int));</span></span><br><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">// 初始化单个：同时进行初始化</span></span><br><span class="line"><span class="keyword">int</span>* c = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>new在C++中被定义为一个<strong>运算符</strong>，它会在底层调用全局函数operator new。</p><p>我们可以通过查看<code>int* array = new int;</code> 对应汇编源码验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 首先在寄存器edi中存入数组大小（4，一个int大小）</span><br><span class="line">movl    $4, %edi</span><br><span class="line"># 调用operator new分配空间</span><br><span class="line">call    operator new(unsigned long)</span><br><span class="line"># 寄存器rax保存new返回的首地址给a（对应地址 -16(%rbp)）</span><br><span class="line">movq    %rax, -16(%rbp)</span><br></pre></td></tr></table></figure><p>operator new只是malloc的一层封装：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* __CRTDECL <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="keyword">const</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// malloc</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">void</span>* <span class="keyword">const</span> block = <span class="built_in">malloc</span>(size))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> block;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (size == SIZE_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                __scrt_throw_std_bad_array_new_length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                __scrt_throw_std_bad_alloc();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The new handler was successful; try to allocate again...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>执行流程：</p><ol><li><p>当malloc申请空间成功时直接返回<code>return (p)</code>；</p></li><li><p>申请空间失败，尝试执行空间不足应对措施（<strong>malloc中失败直接返回空指针</strong>）；</p></li><li><p>如果改应对措施用户设置了，则继续申请，否则抛异常。</p></li></ol></li><li><p>从源码中能看出的是<strong>operator new</strong>在底层是利用malloc分配内存，因此可以说<strong>new只是malloc一层封装</strong>。</p></li></ul></li><li><p><strong>new底层实现（自定义类型</strong>）</p><p>但对于自定义类型，new还会调用构造函数初始化：</p><ol><li>调用operator new为对象分配内存；</li><li><strong>调用对象的构造函数对对象进行初始化</strong>；</li><li>返回分配的内存空间地址。</li></ol><p>分析下例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">  <span class="comment">// malloc分配对象  </span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;malloc:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  Stu* a = (Stu*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Stu));</span><br><span class="line">  <span class="comment">// new分配对象</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;new:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  Stu* b = <span class="keyword">new</span> <span class="built_in">Stu</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>);             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">malloc:</span><br><span class="line">new:</span><br><span class="line">自定义构造函数初始化</span><br></pre></td></tr></table></figure><p>可以看到malloc分配的方式不会调用构造函数，但是new还会调用构造函数。</p><p>因此也可以理解为<strong>malloc分配出来的只不过是一个和类一样大小的空间（在前面我们称为chunk），并不能称作是一个对象</strong>，而new和delete分配出来的才能被成为对象。</p></li><li><p><strong>new与new[]</strong></p><p>new[]和new有些细微区别：</p><ul><li><p>new[]是调用operator new[]对多个对象进行分配，<strong>operator new[]本质还是多次调用operator new</strong>；</p><p>但operator new[]还会多申请4个字节的空间保存此次对象个数。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220110001617014.png" alt="image-20220110001617014"></p><p><strong>为什么要这么做</strong>？</p><p>使用delete[] 释放空间时可以知道被释放的对象个数。</p></li><li><p>当然，<strong>对于自定义类型</strong>，类似new，还会调用N次构造函数对N个对象进行初始化。</p><blockquote><p>举例说明。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// malloc分配对象  </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;malloc:&quot;</span> &lt;&lt; endl;</span><br><span class="line">Stu* a = (Stu*)<span class="built_in">malloc</span>(<span class="number">3</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(Stu));</span><br><span class="line"><span class="comment">// new分配对象</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;new:&quot;</span> &lt;&lt; endl;</span><br><span class="line">Stu* b = <span class="keyword">new</span> Stu[<span class="number">3</span>];  </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">malloc:</span><br><span class="line">new:</span><br><span class="line">默认构造函数初始化</span><br><span class="line">默认构造函数初始化</span><br><span class="line">默认构造函数初始化</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="delete原理">delete原理</h5><p>delete也分两种情况讨论：</p><ul><li>对于内置类型：底层调用free实现，和free无多大区别（也没有异常处理）；</li><li>对于自定义类型：除了调用free释放对象空间，在此之前还会调用对象的析构函数。</li></ul><p>通过具体例子来看看。</p><ul><li><p><strong>delete底层实现（内置类型</strong>）</p><p>先看一个简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br></pre></td></tr></table></figure><p>查看对应的汇编源码，核心是调用operator delete：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*int* a = new int;*/</span><br><span class="line"># 首先在寄存器edi中存入数组大小（4，一个int大小）</span><br><span class="line">movl    $4, %edi</span><br><span class="line"># 调用operator new分配空间</span><br><span class="line">call    operator new(unsigned long)</span><br><span class="line"># 寄存器rax保存new返回的首地址给a（对应地址 -16(%rbp)）</span><br><span class="line">movq    %rax, -16(%rbp)</span><br><span class="line"></span><br><span class="line">/*delete a*/</span><br><span class="line">movq    -16(%rbp), %rax</span><br><span class="line">testq   %rax, %rax</span><br><span class="line">je      .L2</span><br><span class="line">movl    $4, %esi</span><br><span class="line">movq    %rax, %rdi</span><br><span class="line"># 核心是调用operator delete</span><br><span class="line"># 前面在干什么？暂不清楚。</span><br><span class="line">call    operator delete(void*, unsigned long)</span><br></pre></td></tr></table></figure><p>operator delete也只是free的一层封装（没有异常处理）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __CRTDECL <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* <span class="keyword">const</span> block)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    _free_dbg(block, _UNKNOWN_BLOCK);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">free</span>(block);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>delete底层实现（自定义类型</strong>）</p><p>但对于自定义类型，delete还会调用析构函数：</p><ol><li><strong>调用对象的析构函数清理对象</strong>；</li><li>调用operator delete清理内存；</li></ol><p>一个小例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">  <span class="comment">// malloc分配对象  </span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;malloc:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  Stu* a = (Stu*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Stu));</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;free:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  <span class="comment">// new分配对象</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;new:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  Stu* b = <span class="keyword">new</span> Stu;  </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;delete:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">delete</span> b;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">malloc:</span><br><span class="line">free:</span><br><span class="line">new:</span><br><span class="line">默认构造函数初始化</span><br><span class="line">delete:</span><br><span class="line">析构销毁</span><br></pre></td></tr></table></figure><p>可见free不会调用析构函数，但delete会。</p></li><li><p><strong>delete与delte[]</strong></p><p>delete[]用来删除多个对象（和new[]成对出现），本质是对每个对象调用delete清理。</p><p>大致流程如下：</p><ol><li><p>首先根据对象数组前4个字节，获取对象个数N；</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220110001617014.png" alt="image-20220110001617014"></p></li><li><p>对后续每个对象使用delete删除。</p></li></ol><p>同样的，对于自定义类型还会调用对象的析构函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">  <span class="comment">// malloc分配多个对象  </span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;malloc:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  Stu* a = (Stu*)<span class="built_in">malloc</span>(<span class="number">3</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(Stu));</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;free:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// free释放内存</span></span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  <span class="comment">// new[]分配对象</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;new:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  Stu* b = <span class="keyword">new</span> Stu[<span class="number">3</span>];  </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;delete:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// delete[] 释放内存</span></span><br><span class="line">  <span class="keyword">delete</span>[] b;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">malloc:</span><br><span class="line">free:</span><br><span class="line">new:</span><br><span class="line">默认构造函数初始化</span><br><span class="line">默认构造函数初始化</span><br><span class="line">默认构造函数初始化</span><br><span class="line">delete:</span><br><span class="line">析构销毁</span><br><span class="line">析构销毁</span><br><span class="line">析构销毁</span><br></pre></td></tr></table></figure><p>这里有两个有意思的小细节：</p><ul><li><p><code>malloc</code>出的对象不会调用析构函数；</p></li><li><p>我们只用了一次<code>free(a)</code> 释放了分配对象数组<code>a</code> ，而对象数组<code>b</code>实际通过<code>delete[]</code> 调用了多次<code>delete</code>。</p></li></ul><p>这个细节也验证了我们之前结论：</p><ul><li><code>malloc</code>分配出来的只不过是一个我们需要的大小（这里是3个<code>stu</code>）的内存空间，它并没有真的分配了3个<code>stu</code>对象，所以<code>free</code>一次就可以释放这块内存。</li><li>但<code>new[]</code>是真正分配了3个<code>stu</code>对象内存空间，所以要<code>delete</code>多次且会执行析构函数。</li></ul></li></ul><h5 id="plain-nothrow-placement-new">plain/nothrow/placement new</h5><p>在C++中，new有三种典型的使用方法：plain new，nothrow new和placement new。</p><p><strong>plain new</strong></p><p>言下之意就是普通的new，就是我们常用的new，在C++中定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plain new原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="comment">// plain new对应delete</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>可见<code>plain new</code>在空间分配失败的情况下，抛出异常<code>std::bad_alloc</code>而不是返回NULL。</p><p>因此通过判断返回值是否为NULL是徒劳的，请使用<code>try-catch</code>捕获异常：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10e11</span>];</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> std::bad_alloc &amp;ex)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bad allocation</span><br></pre></td></tr></table></figure><p><strong>nothrow new</strong></p><p>nothrow new在空间分配失败的情况下不抛出异常，而是返回NULL，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nothrow new原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span>,<span class="keyword">const</span> std::<span class="keyword">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 对应delete原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="built_in"><span class="keyword">new</span></span>(nothrow) <span class="keyword">char</span>[<span class="number">10e11</span>];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;alloc failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc failed</span><br></pre></td></tr></table></figure><p><strong>placement new</strong></p><p><code>placement new</code>允许在一块<u>已经分配成功的内存</u>上重新构造对象或对象数组。</p><p><code>placement new</code>不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// placement new原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>,<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="comment">// 对应delete</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*,<span class="keyword">void</span>*)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>主要用途</strong>：反复使用一块较大的动态分配的内存，来构造不同类型的对象或者他们的数组；</li><li><strong>使用析构函数删除而不是delete</strong>：placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存）。这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ADT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ADT</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">10</span>;</span><br><span class="line">        j = <span class="number">100</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ADT construct i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;,j=&quot;</span>&lt;&lt;j &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ADT</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ADT destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="built_in"><span class="keyword">new</span></span>(nothrow) <span class="keyword">char</span>[<span class="keyword">sizeof</span> ADT + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;alloc failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用指针p申请的内存来构建类ADT对象adt</span></span><br><span class="line">    <span class="comment">// placement new：不必担心失败，只要p所指对象的的空间足够ADT创建即可</span></span><br><span class="line">    ADT *adt = <span class="built_in"><span class="keyword">new</span></span>(p) ADT;  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    delete adt; // error，不能在此处调用delete</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 调用析构函数删除adt</span></span><br><span class="line">    adt-&gt;ADT::~<span class="built_in">ADT</span>(); </span><br><span class="line">    <span class="comment">// delete删除p</span></span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADT construct i=10,j=100</span><br><span class="line">ADT destruct</span><br></pre></td></tr></table></figure><h5 id="小结">小结</h5><ol><li>new和delete分别是malloc和free的一层封装，对于自定义类型还会分别调用构造函数初始化/析构函数清理内存。<strong>不过new相比malloc还会有一层申请空间失败应对措施，以及可以初始化</strong>。</li><li>new[]/delete[]，是分别用来分配对象数组/清理对象数组的，本质是多次调用了new/free。值得注意的是，<strong>new[]分配的对象数组，还会多分配4个字节标识对象的个数</strong>。</li><li>在C++中有plain new，nothrow new和placement new。plain new就是最普通的new，分配错误返回bad alloc异常；nothrow new分配失败返回NULL异常；placement new不分配内存，请只调用析构函数进行释放，否则可能会导致double free。</li></ol><h4 id="3-8-5-问答测验">3.8.5 问答测验</h4><p>本节是八股重灾区，因为特地准备一些常见面试问题来巩固所学。</p><ol><li><p><strong>堆栈的区别</strong>？</p><p>主要的区别如下：</p><ul><li><p><strong>申请方式</strong>：<strong>栈由系统自动分配</strong>，比如函数中的局部变量<code>int a</code> ，调用函数时会自动为<code>a</code>开辟空间；<strong>堆是程序员申请并负责释放</strong>，并指明大小，例如 <code>int* array= new int[LEN]&#123;1,2,3&#125;;</code> ，但指针<code>array</code>本身是存于栈中。</p></li><li><p><strong>存储内容</strong>：栈存放和函数相关的数据，如定义<u><strong>局部</strong>变量</u>(但不包含static修饰的变量)、保存的上下文等；堆存放函数无关的数据，如动态分配的内存。</p></li><li><p><strong>大小限制</strong>：栈空间默认是4M，连续的 ；堆是不连续的内存区域，一般是 1G - 4G，大小受限于计算机系统中有效的虚拟内存。</p></li><li><p><strong>申请效率</strong>：栈由系统自动分配，计算机在底层对栈提供支持，速度快；堆是由程序员new分配的内存，一般速度比较慢，但更灵活。</p></li><li><p><strong>存储效率</strong>：栈的存取效率更高。请看下例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr1[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>* arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = arr1[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> b = arr2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转成汇编语言分析：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220108202348644.png" alt="image-20220108202348644"></p></li></ul></li><li><p><strong>new / malloc 的异同</strong>？</p><p>都可用于内存的动态申请，返回用户分配使用空间的首地址。</p><ul><li><p><strong>本质</strong>：new是关键字，malloc是函数，所以malloc还需要引入库文件，new不用；</p></li><li><p><strong>返回值类型</strong>：malloc返回的是void类型指针（必须进行类型转换），new返回的是具体类型指针；</p></li><li><p><strong>空间计算</strong>：new会自动分配空间大小，编译器会根据类型信息自行计算，malloc需要手工计算；</p></li><li><p><strong>类型安全</strong>：new是类型安全的，malloc不是；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">2</span>]; <span class="comment">// 编译错误</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>));<span class="comment">// 编译无错误</span></span><br></pre></td></tr></table></figure></li><li><p><strong>构造函数</strong>： new调用名为<strong>operator new</strong>的标准库函数分配足够空间，如果是自定义类型还会调用相关对象的构造函数，malloc则不会；</p></li><li><p><strong>分配失败措施</strong>：new是malloc的一层封装，如果分配失败还会有相应措施执行，抛出bac_alloc异常；malloc返回null。</p></li></ul></li><li><p><strong>free / delete 的异同</strong>？</p><p>都可用于内存的动态释放。</p><ul><li><strong>本质</strong>：delete 是关键字，free 是函数，所以free 还需要引入库文件，delete 不用；</li><li><strong>返回值类型</strong>：free返回的是void类型指针（必须进行类型转换），delete 返回的是具体类型指针；</li><li><strong>析构函数</strong>： delete 调用名为<strong>operator delete</strong>的标准库函数分配足够空间，如果是自定义类型还会调用相关对象的析构函数，free 则不会。</li></ul></li><li><p><strong>new实现原理？delete实现原理</strong>？</p><ul><li><strong>new原理</strong>：operator new分配内存 （底层是malloc实现）—&gt; （自定义类型）分配的内存上调用构造函数初始化—&gt;返回指向该对象的指针；</li><li><strong>delete原理</strong>：operator delete清理内存 （底层是free实现）—&gt; （自定义类型）删除内存前还会调用析构函数；</li></ul></li><li><p><strong>malloc/free底层原理</strong>？</p><p>参考前文。这里只简略说明：</p><ul><li>malloc：brk初始化分配–&gt;后续分配通过内存池：bins+双向链表实现—&gt;太大则top chunk 和mmap分配；</li><li>free：将chunk标记可使用，并加入空闲链表。在上一个步骤free的时候，发现最高地址空闲内存超过128K，还会内存紧缩。</li></ul></li><li><p><strong>被free回收的内存是立即返还给操作系统吗</strong>？</p><p>如前，free回收只是标识这块内存空闲，同时会加入空闲链表中等待下一次分配。</p></li><li><p><strong>delete和free可以混用吗</strong>?</p><p>我们知道delete也只是free一种封装，只有自定义类型时delete会调用析构函数。new和malloc同理。</p><p>所以在以下情况是<strong>可以free/delete混用</strong>：</p><ol><li><p><strong>对象是基本类型时</strong>。</p><p>free掉new申请的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a  = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// delete a;</span></span><br><span class="line"><span class="built_in">free</span>(a); </span><br></pre></td></tr></table></figure><p>delete掉malloc申请的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span>* a  = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">delete</span> a;</span><br></pre></td></tr></table></figure><p>上面也适用于new/malloc混用。</p></li><li><p><strong>自定义的类型，但没有显示定义析构函数</strong>。</p><p>delete和free混用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">test</span>()&#123;a = <span class="number">0</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    test* t1 = (test*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(test));</span><br><span class="line">  <span class="built_in"><span class="keyword">delete</span></span>(t1);</span><br><span class="line">    </span><br><span class="line">  test* t2 = <span class="keyword">new</span> <span class="built_in">test</span>();</span><br><span class="line">  <span class="built_in">free</span>(t2);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>如果是自定义类型，<strong>malloc混用new需要显示调用构造函数的逻辑实现（或者该类不会有构造函数作用）</strong>。</p></li><li><p><strong>malloc、realloc、calloc的区别</strong>？</p><ul><li><p>malloc</p><p>malloc申请20个int类型的空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void* malloc(unsigned int num_size);</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="number">20</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure></li><li><p>calloc</p><p>malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void* calloc(size_t n,size_t size);</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="built_in">calloc</span>(<span class="number">20</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure></li><li><p>realloc</p></li></ul><p>给动态分配的空间分配额外的空间，用于扩充容量。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void realloc(void *p, size_t new_size);</span></span><br></pre></td></tr></table></figure></li><li><p><strong>为什么C++没有垃圾回收机制？这点跟Java不太一样</strong>。</p><ul><li><strong>资源消耗</strong>。实现一个垃圾回收器会带来额外的空间和时间开销；<ul><li>你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark；</li><li>然后需要单独开辟一个线程在空闲的时候进行free操作。</li></ul></li><li><strong>C++本身原因</strong>。垃圾回收会使得C++不适合进行很多底层的操作。</li></ul></li></ol><h3 id="3-9-Lambda表达式">3.9 Lambda表达式</h3><p>很多时候我们常常需要定义一个<strong>简单、甚至只被使用一次</strong>的函数，额外地定义了一个函数调用既浪费了空间，甚至未必有<strong>简化成一行代码</strong>好理解。</p><p>另外，前面的学习我们了解到C++是不允许函数嵌套的，但lambda可以被函数嵌套（lambda并不是函数，下文细说）。</p><p>lambda表达式就为我们做了这么一件事：<strong>将一个简单函数简化为一行，还允许我们在一个函数进行嵌套lambda</strong>。</p><h4 id="3-9-1-lambda初识">3.9.1 lambda初识</h4><h5 id="第一个lambda">第一个lambda</h5><p>C++中lambda表达式格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ captureClause ] ( parameters ) -&gt; returnType</span><br><span class="line">&#123;</span><br><span class="line">    Statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>captureClause</code>：允许我们使用lambda外部的变量，这一点在3.9.5中详述，这里先略过；</li><li><code>parameters</code>：传递的参数，可空；</li><li><code>returnType</code>：返回类型，编译器会自动推断，可空；</li><li><code>Statement</code>：代码体，一般就一行，当然多行也行。</li></ul><p>一个最简单的lambda表达式可定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]()&#123;&#125;</span><br></pre></td></tr></table></figure><p>现在举例说明用法。</p><p>我们之前写过一个冒泡函数<code>bubbleSort</code>：它有一个参数，允许我们传递定义排序规则，即<code>myCompare</code>函数来实现排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换数组值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> idx_i,<span class="keyword">int</span> idx_j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[idx_i];</span><br><span class="line">    arr[idx_i] = arr[idx_j];</span><br><span class="line">    arr[idx_j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序规则</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">bool</span> (*compare)(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)   <span class="comment">// 外轮=n-1</span></span><br><span class="line">        <span class="comment">// * j=0,每次都是从头开始比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; len-i<span class="number">-1</span>; j++ ) <span class="comment">// 内轮=余下乱序数-1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">compare</span>(arr[j],arr[j+<span class="number">1</span>]))</span><br><span class="line">                <span class="built_in">swap</span>(arr,j,j+<span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> array[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(array)/<span class="built_in"><span class="keyword">sizeof</span></span>(array[<span class="number">0</span>]);</span><br><span class="line">   <span class="built_in">bubbleSort</span>(array,len,myCompare);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len  ;i++)</span><br><span class="line">       cout&lt;&lt;array[i]&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将这个<code>myCompare</code>函数改为更简洁<code>lambda</code>表达式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;&#125;</span><br></pre></td></tr></table></figure><p>这样我们如此调用bubbleSort函数：代码更加的紧凑，上下文更清晰，一眼明白我们排序的规则。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bubbleSort(array,len,myCompare);</span></span><br><span class="line"><span class="built_in">bubbleSort</span>(array,len,[](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;&#125;);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h5 id="lambda本质探讨🌟">lambda本质探讨🌟</h5><p>虽然3.9.2节（下节）的名字叫做“lambda与函数指针”，但值得提前声明的一点是：<strong>lambda并不是函数，它是一种特殊的对象，称为函数对象（也称为函数子）。函数不能嵌套，但lambda可以</strong>。</p><p><strong>怎么理解函数对象</strong>？</p><p><strong>C++函数对象实质上是实现了对()操作符的重载</strong>。C++函数对象不是函数指针，但它的调用方式与函数指针一样，后面加个括号就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a,<span class="keyword">const</span> <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// addFunction的Add类对象，此也是函数对象</span></span><br><span class="line">    Add addFunction;</span><br><span class="line">    <span class="comment">// 像函数（指针）一样调用</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">addFunction</span>(<span class="number">2</span>,<span class="number">3</span>)&lt;&lt;endl;  <span class="comment">// 5</span></span><br><span class="line">    cout&lt;&lt;addFunction.<span class="built_in"><span class="keyword">operator</span></span>()(<span class="number">2</span>,<span class="number">3</span>)&lt;&lt;endl;    <span class="comment">// 5</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">Add</span>()(<span class="number">2</span>,<span class="number">3</span>)&lt;&lt;endl;   <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数对象相比普通函数有什么好处吗</strong>？</p><ul><li><p><strong>函数对象带有状态</strong>：函数对象相对于普通函数是“智能函数”，这就如同智能指针相较于传统指针。因为函数对象除了提供函数调用符方法，还可以拥有其他方法和数据成员。所以函数对象有状态。即使同一个类实例化的不同的函数对象其状态也不相同，这是普通函数所无法做到的。而且函数对象是可以在运行时创建。</p></li><li><p><strong>每个函数对象有自己的类型</strong>：对于普通函数来说，只要签名一致，其类型就是相同的。但是这并不适用于函数对象，因为函数对象的类型是其类的类型。这样，函数对象有自己的类型，这意味着函数对象可以用于模板参数，这对泛型编程有很大提升。</p></li><li><p><strong>函数对象一般快于普通函数</strong>：因为函数对象一般用于模板参数，模板一般会在编译时会做一些优化。</p></li></ul><p>回到lambda表达式。</p><p><strong>我们看看一个lambda表达式是如何被转换成函数对象</strong>。</p><p>准备代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>);         <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依旧是https://cppinsights.io/，观察编译过程变化：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220112200056709.png" alt="image-20220112200056709"></p><p>编译器如何将我们写的lambda表达式转换为函数对象便一目了然：</p><ol><li>首先为我们生成类<code>__lambda_3_16</code> （①处），它有一个内联函数（②处），重载了符号<code>()</code>；</li><li>代码30行处，为我们生成了lambda函数对象<code>add</code>，也就是我们定义的lambda表达式名；</li><li>随后调用了函数对象<code>add</code> （③处），完成整个转换过程。</li></ol><h5 id="存储lambda">存储lambda</h5><p>虽然一般来说我们不需要像函数一样给lambda表达式一个名字，但是有时候也需要能将lambda表达式（作为右值）存储起来，供以后使用。</p><p>在C++中提供三种方式：</p><ol><li><strong>使用函数指针方式存储</strong>：只有在<code>capture clause</code>为空时；</li><li><strong>使用function方式存储</strong>：<code>capture clause</code>不为空时，也可以使用；</li></ol><p>先来看看函数指针方式。</p><p>函数指针指向不仅限于函数，只要是函数对象都可以指向。lambda作为函数对象，自然是可以被其存储的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*myCompare)(<span class="keyword">int</span>, <span class="keyword">int</span>) = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;&#125;;</span><br></pre></td></tr></table></figure><p>用 <code>auto</code> 关键字可简化函数指针类型书写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myCompare = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;&#125;;</span><br></pre></td></tr></table></figure><p>再来关注下<code>std::function</code>方式。</p><p>前面我们提到过：<code>std::function</code>本质就是类模板，也就是函数容器，可以将<strong>函数指针/函数转换成（函数）对象</strong>进行处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; myCompare = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;&#125;;</span><br></pre></td></tr></table></figure><h5 id="lambda参数">lambda参数</h5><p>Lambda表达式的参数和普通函数的参数相比有些限制（C++11）：</p><ol><li><p>参数列表中不能有默认参数；</p></li><li><p>不支持可变参数（比如使用auto关键字）；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11:编译出错，参数类型无法使用auto</span></span><br><span class="line"><span class="keyword">auto</span> myCompare = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;<span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>所有参数必须有参数名。</p></li></ol><p>关于第2点，从<code>C++14</code>开始，<code>lambda</code>表达式支持泛型：其参数可以使用自动推断类型的功能，而不需要显示地声明具体类型。</p><p>具体介绍参考3.9.2节。</p><h4 id="3-9-2-泛型lambda（C-14）">3.9.2 泛型lambda（C++14）</h4><h5 id="什么是泛型lambda？">什么是泛型lambda？</h5><p>从 C++14 开始，我们被允许<code>auto</code>用于参数。当 lambda 具有一个或多个<code>auto</code>参数时，编译器将从对 lambda 的调用中推断出需要哪些参数类型。</p><p>这使得<strong>具有一个或多个<code>auto</code>参数的lambda可适用于多种类型，<strong>它们也被称为</strong>泛型 lambda</strong>。</p><p>看一个小例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>);         <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">double</span> y = <span class="built_in">add</span>(<span class="number">2.5</span>, <span class="number">3.4</span>);  <span class="comment">// 5.9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是非常像模板函数？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>);         <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">double</span> y = <span class="built_in">add</span>(<span class="number">2.5</span>, <span class="number">3.4</span>);  <span class="comment">// 5.9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>add(2, 3)</code> 、<code>add(2.5, 3.4)</code> 分别让函数模板生成了函数实例<code> add(int, int)</code>、<code> add(double, double)。</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220112193845733.png" alt="image-20220112193845733"></p><p><strong>auto关键字自动推断lambda参数类型</strong>，让lambda表达式起到了和模板函数相同的效果。前面我们说到，<strong>模板函数会为每种不同类型生成实例函数：那泛型lambda也会为不同类型生成一个lambda表达式吗</strong>？</p><p>答案是肯定的。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220112194112575.png" alt="image-20220112194112575"></p><p>完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">class</span> __<span class="title">lambda_3_16</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type_parameter_0_0</span>, <span class="keyword">class</span> <span class="title">type_parameter_0_1</span>&gt;</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="comment">/*constexpr */</span> <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(type_parameter_0_0 x, type_parameter_0_1 y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> INSIGHTS_USE_TEMPLATE</span></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="comment">/*constexpr */</span> <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> INSIGHTS_USE_TEMPLATE</span></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="comment">/*constexpr */</span> <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type_parameter_0_0</span>, <span class="keyword">class</span> <span class="title">type_parameter_0_1</span>&gt;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">auto</span> __invoke(type_parameter_0_0 x, type_parameter_0_1 y)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_3_16 add = __lambda_3_16&#123;&#125;;</span><br><span class="line">  <span class="keyword">int</span> x = add.<span class="built_in"><span class="keyword">operator</span></span>()(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">double</span> y = add.<span class="built_in"><span class="keyword">operator</span></span>()(<span class="number">2.5</span>, <span class="number">3.3999999999999999</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面代码中：</p><ol><li><p>编译器自动生成了lambda类<code>__lambda_3_16</code></p></li><li><p>类<code>__lambda_3_16</code> ，根据40、41行函数调用的不同参数类型，分别生成了两个成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="comment">/*constexpr */</span> <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="comment">/*constexpr */</span> <span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure><p>注意到，两个函数都重载了操作符<code>()</code> 。</p></li><li><p>代码39行，生成了类<code>__lambda_3_16</code> 对象<code>add</code>，<code>add</code>就是我们定义的泛型lambda名，显然此时<code>add</code>也是函数对象，可以用<code>名字()</code>方式调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__lambda_3_16 add = __lambda_3_16&#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>代码40、41行调用了不同的类<code>__lambda_3_16</code> 不同重载函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = add.<span class="built_in"><span class="keyword">operator</span></span>()(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">double</span> y = add.<span class="built_in"><span class="keyword">operator</span></span>()(<span class="number">2.5</span>, <span class="number">3.3999999999999999</span>);</span><br></pre></td></tr></table></figure></li></ol><h5 id="更好地理解泛型闭包行为🌟">更好地理解泛型闭包行为🌟</h5><p>前面已经说到，泛型lambda会为每种不同类型生成成员函数 。</p><p>同时，我们也了解局部静态变量同样具有全局的生命周期，下面这个例子展示了这种特性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">myCount</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the type of your input:&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(value).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> count++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout&lt;&lt;<span class="built_in">myCount</span>(<span class="number">0</span>)&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;<span class="built_in">myCount</span>(<span class="number">0</span>)&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">the type of your input:i</span><br><span class="line">1</span><br><span class="line">the type of your input:d</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><code>count</code> 虽然是局部变量，但是由于是静态变量函数存储在全局数据段，和堆栈无关，退出也不会销毁。<strong>所以被myCount函数共享，可进行计数</strong>。</p><p><strong>但是如果我们<code>myCount</code>替换成泛型函数，即允许参数类型为auto，一切开始变得不一样了</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++20支持参数类型为auto</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">myCount</span><span class="params">(<span class="keyword">auto</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the type of your input:&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(value).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> count++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout&lt;&lt;<span class="built_in">myCount</span>(<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;<span class="built_in">myCount</span>(<span class="number">1.2</span>)&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">the type of your input:i</span><br><span class="line">1</span><br><span class="line">the type of your input:d</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>此时静态变量<code>count</code>没有被<code>myCount</code>函数共享？这是因为此时<code>myCount</code>函数已经是泛型函数。</p><ul><li>执行代码第13行，推断出<code>value</code>为<code>int</code>类型，编译器生成函数<code>int myCount&lt;int&gt;(int value)</code>，它拥有自己作用范围的静态变量<code>count</code>；</li><li>执行代码第14行，类似的，<strong>无法匹配上一次生成函数<code>int myCount&lt;int&gt;(int value)</code></strong>。所以编译器还需生成函数<code>int myCount&lt;double&gt;(double value)</code>，它也拥有自己作用范围的静态变量<code>count</code>。</li></ul><p>两个<code>myCount</code> 是重载函数，但它们并不一样，自然无法共享各自的局部静态变量<code>count</code>。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220113000047727.png" alt="image-20220113000047727"></p><p><strong>类似的结果也出现在泛型lambda、函数模板中</strong>。</p><p>下面以泛型lambda为例进行展示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> myCount</span><br><span class="line">&#123;</span><br><span class="line">   [](<span class="keyword">auto</span> value)</span><br><span class="line">   &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;the type of your input:&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(value).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> count++; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout&lt;&lt;<span class="built_in">myCount</span>(<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;<span class="built_in">myCount</span>(<span class="number">1.2</span>)&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">the type of your input:i</span><br><span class="line">1</span><br><span class="line">the type of your input:d</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>查看编译转换后的代码验证：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220113000753408.png" alt="image-20220113000753408"></p><h4 id="3-9-3-使用标准库函数">3.9.3 使用标准库函数</h4><p>和array配合时，lambda表达式会接受数组两个元素，定义它们的比较规则</p><p>lambda表达式常配合标准库函数使用，简洁优雅。</p><p>下面展示了几个排序用例。</p><ul><li><p><strong>例1：<code>std::sort</code>和lambda配合用在<code>std::array</code>上</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span> <span class="comment">// for std::greater</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::array&lt;<span class="keyword">int</span>,6&gt; arr = &#123; <span class="number">13</span>, <span class="number">90</span>, <span class="number">99</span>, <span class="number">5</span>, <span class="number">40</span>, <span class="number">80</span> &#125;;</span><br><span class="line">  <span class="comment">// 此时lambda参数接受数组两个元素，返回它们的比较规则（bool类型）</span></span><br><span class="line">  <span class="comment">// 可以结合之前我们写的冒泡排序自定义规则理解，此时是在双重for循环中接受数组相邻两个元素进行比较</span></span><br><span class="line">  std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a,<span class="keyword">int</span> b )&#123;<span class="keyword">return</span> a&gt;b;&#125;); </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">  &#123;</span><br><span class="line">     std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">99 90 80 40 13 5</span><br></pre></td></tr></table></figure><p>对于常见的操作（例如加法、求反或比较），标准库附带了许多可直接使用的函数对象。</p><p>比如这个例子可用<code>std::greater</code>替代我们写的lambda表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), std::greater);</span><br></pre></td></tr></table></figure></li><li><p><strong>例2：排序对象是结构数组、类数组、RDD等</strong></p><p><code>struct Student</code>用来存储学生姓名和分数的，将下面<code>Student</code>数组按成绩进行排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::string name&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> points&#123;&#125;;</span><br><span class="line">    <span class="comment">// 需要初始化函数</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="keyword">const</span> <span class="keyword">char</span> my_name[],<span class="keyword">const</span> <span class="keyword">int</span> my_points)  </span><br><span class="line">    &#123;</span><br><span class="line">         name = std::<span class="built_in">string</span>(my_name);</span><br><span class="line">         points = my_points;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::array&lt;Student, 8&gt; arr</span><br><span class="line">&#123;</span><br><span class="line">    &#123; </span><br><span class="line">        &#123; <span class="string">&quot;Albert&quot;</span>, <span class="number">3</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;Ben&quot;</span>, <span class="number">5</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;Christine&quot;</span>, <span class="number">2</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;Dan&quot;</span>, <span class="number">8</span> &#125;, </span><br><span class="line">        &#123; <span class="string">&quot;Enchilada&quot;</span>, <span class="number">4</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;Francis&quot;</span>, <span class="number">1</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;Greg&quot;</span>, <span class="number">3</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;Hagrid&quot;</span>, <span class="number">5</span> &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现流程如下：</p><ol><li>明确lambda接受的参数是数组两个元素，这里元素是结构体<code>Student</code>对象；</li><li>假设两个<code>Student</code>对象分别是stu1、stu2，它们比较的规则应该是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>u</mi><mn>1.</mn><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>s</mi><mo>&gt;</mo><mi>s</mi><mi>t</mi><mi>u</mi><mn>2.</mn><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">stu1.points&gt;stu2.points</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord">1.</span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord">2.</span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span></span></span></span> 。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),[](Student s1,Student s2)&#123;<span class="keyword">return</span> s1.points&gt;s2.points;&#125;);</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    std::for_each(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),[](Student s)&#123;std::cout&lt;&lt;s.name&lt;&lt;std::endl;&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-9-4-捕获">3.9.4 捕获</h4><h5 id="为什么需要捕获">为什么需要捕获</h5><p>前面我们说过lambda表达式原理：</p><ol><li>每定一个lambda表达式，会生成一个匿名类，这个类重载了<code>()</code>运算符；</li><li>使用lambda表达式，其实就是返回一个闭包类实例。</li></ol><p>既然是闭包，当然无法使用外部的变量，请看下例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    []()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl;  <span class="comment">// 无法使用外部变量a</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过捕获可以让我们使用外部变量<code>a</code>。</p><h5 id="按值捕获">按值捕获</h5><p>下面展示了按值捕获方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    [a]()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl;  </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按值捕获只是将变量<code>a</code> 复制一份，而且由于lambda匿名生成了重载函数<code>()</code> 被<code>const</code>修饰，所以不能在lambda表达式内部修改数据成员<code>a</code>的值。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220113145733566.png" alt="image-20220113145733566"></p><p>要想修改<code>a</code>的值，需要声明为<code>mutable</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[a]()<span class="keyword">mutable</span></span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;a++&lt;&lt;endl;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时重载函数的<code>const</code>关键字不会被声明。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220113150219048.png" alt="image-20220113150219048"></p><p>但<code>mutable</code>这种方式，我们依旧无法修改lambda外部变量<code>a</code>的值，毕竟lambda内部变量<code>a</code>只是值复制了一份。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> print = [a]() <span class="keyword">mutable</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a++&lt;&lt;endl;  </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>要想能修改lambda外部的变量，有两种方式：</p><ol><li><p>声明外部变量为<code>a</code>为static：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> print = []() </span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a++&lt;&lt;endl;  </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>();  <span class="comment">// 1</span></span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到此时，不用mutable也可以捕获外部静态变量<code>a</code>，因为此时<code>a</code>具有全局生命周期，可被<strong>隐式捕获</strong>（下个小节详细列出）。</p></li><li><p>用引用捕获的方式。</p></li></ol><h5 id="按引用捕获">按引用捕获</h5><p>引用捕获方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> print = [&amp;a]() <span class="comment">// 引用捕获</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a++&lt;&lt;endl;  </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>原因很简单，修改引用时会通过间接寻址到本体外部的变量<code>a</code>，然后进行修改的。</p><h5 id="混合捕获">混合捕获</h5><p>上面的例子，要么是值捕获，要么是引用捕获，Lambda表达式还支持混合的方式捕获外部变量，这种方式主要是以上几种捕获方式的组合使用。</p><table><thead><tr><th style="text-align:center">捕获形式</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">[]</td><td style="text-align:center">不捕获任何外部变量</td></tr><tr><td style="text-align:center"><strong>[变量名, …]</strong></td><td style="text-align:center">默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td></tr><tr><td style="text-align:center">[this]</td><td style="text-align:center">以值的形式捕获this指针</td></tr><tr><td style="text-align:center">[=]</td><td style="text-align:center">以值的形式捕获<strong>所有</strong>外部变量</td></tr><tr><td style="text-align:center">[&amp;]</td><td style="text-align:center">以引用形式捕获<strong>所有</strong>外部变量</td></tr><tr><td style="text-align:center">[=, &amp;x]</td><td style="text-align:center">变量x以引用形式捕获，其余变量以传值形式捕获</td></tr><tr><td style="text-align:center">[&amp;, x]</td><td style="text-align:center">变量x以值的形式捕获，其余变量以引用形式捕获</td></tr></tbody></table><h5 id="隐式捕获">隐式捕获</h5><p>前面介绍的都是显示捕获，在C++中，如果变量被声明为static或者const，其实是可以隐式捕获使用的。</p><p>请回答：下面变量哪些可以在<code>main</code>不显式捕获它们的情况下使用？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i&#123;&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> j&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a&#123;&#125;;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">int</span> b&#123;&#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> c&#123;&#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> d&#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> e&#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> f&#123; <span class="built_in">getValue</span>() &#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> g&#123;&#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> h&#123; <span class="built_in">getValue</span>() &#125;;</span><br><span class="line"></span><br><span class="line">  []()</span><br><span class="line">  &#123;</span><br><span class="line">    a;</span><br><span class="line">    b;</span><br><span class="line">    c;</span><br><span class="line">    d;</span><br><span class="line">    e;</span><br><span class="line">    f;</span><br><span class="line">    g;</span><br><span class="line">    h;</span><br><span class="line">    i;</span><br><span class="line">    j;</span><br><span class="line">  &#125;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了a、f，其余都是被static或者const修饰，可以隐式被lambda捕获。</p><h3 id="3-X-再谈-auto">3.X 再谈 auto</h3><p>前面我们或多或少了使用了auto关键字，它的作用也很明显：<strong>自动类型推断</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in"><span class="keyword">typeid</span></span>(a).<span class="built_in">name</span>() <span class="comment">// i</span></span><br></pre></td></tr></table></figure><p>但像这种<strong>简单类型变量声明不建议使用auto关键字</strong>，直接写出变量的类型更加清晰易懂。</p><p>现在进行常见场景下auto总结&amp;使用。</p><h4 id="auto用法总结">auto用法总结</h4><ol><li><p><strong>代替冗长复杂、变量使用范围专一的变量声明</strong></p><p>比如：存储函数指针或lambda表达式、模板对象声明等。</p><blockquote><p>STL标准库将在后续进行总结。</p></blockquote><p>想象一下在没有auto的时候，我们操作标准库时经常需要这样（难受啊兄弟）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; vs;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;std::string&gt;::iterator i = vs.<span class="built_in">begin</span>(); i != vs.<span class="built_in">end</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用auto能简化代码（舒服了）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; vs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = vs.<span class="built_in">begin</span>(); i != vs.<span class="built_in">end</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又如函数指针声明比较复杂，存储时不好书写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*p_func)(<span class="keyword">int</span>,<span class="keyword">int</span>) = func;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有lambda表达式，类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*myCompare)(<span class="keyword">int</span>, <span class="keyword">int</span>) = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;&#125;;</span><br></pre></td></tr></table></figure><p>auto优化后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">auto</span></span> (*myCompare)(<span class="keyword">int</span>, <span class="keyword">int</span>) = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>在定义模板函数时，用于声明依赖模板参数的变量类型</strong></p><p>若不使用auto变量来声明<code>v</code>，则无法进行定义，因为其类型无法确定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tx,<span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Multiply</span><span class="params">(_Tx x, _Ty y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> v = x*y;</span><br><span class="line">    std::cout &lt;&lt; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++11中如果<code>v</code>作为返回值，还需要在尾部指定返回类型（否则会发出警告）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tx, <span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">multiply</span><span class="params">(_Tx x, _Ty y)</span>-&gt;<span class="title">decltype</span><span class="params">(x*y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>decltype用于计算出表达式<code>x*y</code>的类型。</p></li></ol><h4 id="注意事项">注意事项</h4><ol><li><p><strong>auto关键字必须初始化</strong></p><p>需要在声明时auto就可以推断出变量类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">10</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">auto</span> b;  <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li><li><p><strong>auto会自动去除右值的引用、const语义，需要显示声明</strong></p><p>右值引用语义被去除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> c = b; <span class="comment">// 此时c的类型是int不是int&amp;</span></span><br></pre></td></tr></table></figure><p>需要显示声明为引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp; c = b; <span class="comment">// 此时c的类型才是int&amp;</span></span><br></pre></td></tr></table></figure><p>auto还会去除const语义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> b = a; <span class="comment">// 此时b为int类型，而不是const int</span></span><br><span class="line">b = <span class="number">100</span>;  <span class="comment">// b可以被修改</span></span><br></pre></td></tr></table></figure><p>需要显示声明为const常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> b = a;</span><br><span class="line">b = <span class="number">100</span>; <span class="comment">// 非法，无法被修改</span></span><br></pre></td></tr></table></figure><blockquote><p>有个有意思的问题：如果auto&amp; 还会去除const语义吗？理论上来说，此时引用是某种意义上等价本体的，自然类型也应该是一致的。</p></blockquote><p>答案是不会的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; b = a; <span class="comment">// 此时b为const int，const语义未被去除</span></span><br><span class="line">b = <span class="number">100</span>;     <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure></li><li><p><strong>auto关键字不去除指针的语义</strong></p><p>请看下例，auto正确推导除了变量的类型为指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> b = &amp;a;  <span class="comment">// b是int*类型</span></span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;*b&lt;&lt;endl; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>auto不能作为函数形参</strong></p><p>这样做的话，声明的函数实际上就是个函数模板了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="keyword">auto</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种做法在C++20中已被支持。</p></li></ol><h2 id="更新记录">更新记录</h2><div class="timeline"><div class="timenode"><div class="meta"><p><p>2021-02-8：更新笔记</p></p></div><div class="body"><ol><li>3.8.1节增加了静态存储区相关描述</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-01-16 ：更新笔记</p></p></div><div class="body"><ol><li>第一次更新</li></ol></div></div></div><h2 id="参考资料">参考资料</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++中引用传递与指针传递的区别：https://blog.csdn.net/u013130743/article/details/80806179<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C/C++ 程序的内存布局：https://blog.csdn.net/m0_45047300/article/details/118389444<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">内存分配的原理--molloc/brk/mmap：http://abcdxyzk.github.io/blog/2015/08/05/kernel-mm-malloc/<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++ lambda表达式与函数对象：https://www.jianshu.com/p/d686ad9de817<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++ auto 关键字的使用：https://cloud.tencent.com/developer/article/1660750<a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 教程 </tag>
            
            <tag> C++基础 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++从零开始（一）：环境搭建（上）VSCode远程开发</title>
      <link href="/p/18652/"/>
      <url>/p/18652/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，开始更新中…</p></blockquote><div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div><p>实习的时候，公司会给每个人配置一台远程服务器，用于日常开发。体验下来感觉很不错的：</p><ul><li>所有的开发代码、环境均运行在云端，任何一台机器可直连快速开发，<strong>本地无需任何部署环境或者代码</strong>等；</li><li>实际C/C++开发大部分也是在<strong>Linux</strong>环境上完成的，拥有一台自己的（云）Linux开发机还是很有必要的（<strong>省去了Win上开发各种怪问题</strong>）。</li></ul><p>因此，在这个C++系列中，所有的代码也将以：本地（Win）+远程（Linux）形式进行开发。</p><p>好了，让我们快速开始吧。</p><h3 id="快速开始">快速开始</h3><blockquote><p>本文开发环境如下：</p><ul><li>本地：Win10 + VSCode</li><li>远程：CentOS 7 （腾讯云）</li></ul></blockquote><h4 id="云上开发">云上开发</h4><p>腾讯云/阿里云服务器都有学生优惠≈10元/月，以下是撸羊毛详细过程。</p><ol><li><p>进入学生优惠购买界面，以腾讯云为例：<a href="https://cloud.tencent.com/act/campus">腾讯云学生优惠</a></p><p>地区可选 <code>上海三区</code> &amp; <code>广州四区</code>等，广州离重庆更近一点所以选择 <code>广州四区</code> 。</p><p>选择操作系统为：<code>CentOS 7.6.64</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/qiJSVvHcUyPTGOr.png" alt="1579750584238"></p></li><li><p>付费&amp;设置密码</p><p>点击立即购买后，<strong>记得设置好相应root密码</strong>。</p><p>现在你可以右上角点击：控制台–&gt;云服务器，查看你购买的云服务器：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/s7R9KFTe1oaYIcC.png" alt="1579755304749"></p><p>你应该看到上图类似界面。红框部分是对应 <strong>内网&amp;公网IP</strong>，记录下来后面多次要用到。</p></li></ol><h4 id="本地配置">本地配置</h4><ol><li><p>配置SSH</p><p>Win10默认自带安装OpenSSH，下面我们直接进入到环境变量配置环节。</p><ul><li><p>用<a href="https://www.voidtools.com/zh-cn/">everything</a>进行搜索<code>ssh.exe</code> ，并记录OpenSSH文件夹路径：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206162135005.png" alt="image-20211206162135005"></p></li><li><p>win10搜索环境变量—&gt;编辑系统环境变量—&gt;环境变量，找到系统变量(S)—&gt;选择Path—&gt;编辑：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206162428787.png" alt="image-20211206162428787"></p></li><li><p>选择：新建–&gt;输入OpenSSH路径</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206162532446.png" alt="image-20211206162532446"></p><p>保存后退出。</p></li><li><p>测试：打开CMD，输入<code>ssh</code> ，出现如下则环境变量配置成功（被系统成功识别）：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206162726410.png" alt="image-20211206162726410"></p></li></ul></li><li><p>安装相关插件</p><ul><li><p>安装Remote-SSH：左侧Extension图标 —&gt; 输入 <code>Remote-SSH</code> —&gt;安装即可。注意，需要<strong>远程和本地都进行安装</strong>。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206163014391.png" alt="image-20211206163014391"></p></li><li><p>安装C/C++插件：同上安装不再赘述。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206163953436.png" alt="image-20211206163953436"></p></li></ul></li><li><p>配置Remote-SSH</p><p>如图所示选择<code>.ssh/config</code> 文件进行配置：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206163445062.png" alt="image-20211206163445062"></p><p>打开文件后，需要设置以下字段：</p><ul><li>Host：自定义即可</li><li>HostName：云主机公网IP</li><li>User：登陆的用户</li></ul><p>以下为示例：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206163758522.png" alt="image-20211206163758522"></p></li><li><p>登陆测试</p><p>点击下图按钮进行登陆：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206164334870.png" alt="image-20211206164334870"></p><p>输入密码后，便可以看到远程服务器已经成功连接。</p></li><li><p>hello cpp!</p><p>现在我们来编写一个简单的cpp文件，体验远程编码的快感。</p><ul><li><p>打开远程服务器文件夹</p><p>File—&gt;Open Folder—&gt;指定文件夹路径。</p></li><li><p>hello.cpp文件编写</p><p>新建文件hello.cpp–&gt;编写如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello Cpp!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g hello.cpp -o hello.out </span><br></pre></td></tr></table></figure><p>执行我们刚刚生成的可执行文件：<code>hello.out</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206165317305.png" alt="image-20211206165317305"></p></li></ul></li></ol><p>至此，顺利完成了初步的远程开发环境配置。</p><p>或许聪明的你已经想到：<strong>远程开发怎么在本地进行debug呢？</strong></p><h3 id="远程Debug">远程Debug</h3><p>VSCode中进行远程调试，通常需配置以下文件<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="vscode中c++的三个配置文件的作用：https://blog.csdn.net/zhxue_11/article/details/89457545 ">[1]</span></a></sup>：</p><ol><li><code>launch.json</code>：最重要的文件，配置<strong>调试器</strong>与<strong>需要调试的可执行文件</strong>进行调试；</li><li><code>c_cpp_properties.json</code>： c与cpp选项，实际开发主要作用是，<strong>解决系统环境的头文件找不到</strong>的情况；</li><li><code>setting.json</code> ：可以对VS Code进行页面风格、代码格式、字体颜色大小等的编辑设置，这里只用来<strong>将其它语言识别为cpp</strong>；<ul><li>更多作用可参考：<a href="https://www.zhihu.com/question/366164002">settings.json是什么?对VS Code有什么用？</a></li></ul></li><li><code>tasks.json</code>：通常用来执行<strong>比较简单的编译指令</strong>，所以一般不用，不进行过多介绍。</li></ol><p>下面正式进行相关配置介绍<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="vscode C++远程调试运行：https://zhuanlan.zhihu.com/p/104131448">[2]</span></a></sup>。</p><blockquote><p>⚠️ 以下过程执行前提：</p><ol><li>你已经根据前面步骤，成功编译生成了一个可执行文件，如：<code>hello.out</code> ；</li><li>编译生成的执行文件<strong>可以被Debug</strong>，e.g.，g++带上<code>-g</code>参数。</li></ol></blockquote><h4 id="launch-json">launch.json</h4><p>菜单栏依次选择：Run—&gt; Add Configuration—&gt; 选择C++ (GDB/LLDB) —&gt; 选择g++ build and debug active file。</p><blockquote><p>如果以上创建过程报错：<strong>VScode找不到任务c/c++：g++.exe生成活动文件</strong> 。</p><ul><li>需要你<strong>先打开一个cpp文件</strong>，再执行上面步骤。</li></ul></blockquote><p>VSCode<strong>会根据你的机器环境</strong>，自动创建<code>launch.json</code> 。正如前所言该文件的作用，我们需进行以下配置：</p><ul><li><p><strong>配置调试器信息</strong>：创建文件时系统自动配置好了，所以不用管；</p></li><li><p><strong>配置可执行文件</strong>：也就是我们<strong>编译生成的可执行文件路径</strong></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206173236205.png" alt="image-20211206173236205"></p><p>当然我们还可以为可执行文件<strong>设置参数</strong>，格式如下：<br><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206173526162.png" alt="image-20211206173526162" style="zoom:67%;" /></p></li><li><p><strong>注释多余参数</strong>：<code>preLaunchTask</code>（调试会话开始前执行的任务），不需要。</p></li></ul><p>最终完整的配置示例文件如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;(gdb) Launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="comment">// 将要进行调试的可执行文件的路径</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/bin/hello.out&quot;</span>,   </span><br><span class="line">            <span class="comment">// 调试的可执行文件参数</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="c-cpp-properties-json">c_cpp_properties.json</h4><p>VSCode开发过程中，经常容易出现：<strong>明明路径正确引用其它头文件，但VSCode就是一直提示无法找到</strong>。所以在这个文件中，提供了<code>includePath</code>参数，让编译器顺利找到其它路径的文件。</p><p>在菜单栏中：F1—&gt;选择C/Cpp: Edit configurations，让VSCode根据实际环境自动生成c_cpp_properties.json。</p><p>以下给出示例配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Linux&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;defines&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span>: <span class="string">&quot;/usr/bin/gcc&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span>: <span class="string">&quot;gnu11&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span>: <span class="string">&quot;gnu++11&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;linux-gcc-x64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setting-json">setting.json</h4><p>这里只用来，将其它语言识别为CPP，不太重要。按以下配置好了就行。</p><p>在菜单栏中：F1—&gt;输入 “Open Settings”—&gt; 选择 “Preferences: Open Settings (JSON)” ，自动生成该文件。</p><p>编辑以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;files.associations&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;*.tcc&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cctype&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;clocale&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cstdarg&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cstdint&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cstdio&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cstdlib&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cwchar&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cwctype&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;exception&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;initializer_list&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;iosfwd&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;iostream&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;istream&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;limits&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;new&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;ostream&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;streambuf&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;type_traits&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;typeinfo&quot;</span>: <span class="string">&quot;cpp&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;C_Cpp.errorSquiggles&quot;</span>: <span class="string">&quot;Enabled&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试">测试</h4><p>现在让我们波澜不惊的在<code>hello.cpp</code> ，打上断点，按上<code>F5</code> 进行调试。</p><p>发现可以顺利进行远程调试，跨越了你离技术专家的一小步 😃 。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206180754574.png" alt="image-20211206180754574"></p><h3 id="体验优化">体验优化</h3><h4 id="免密登陆">免密登陆</h4><p>每次连接到远程服务器要输入密码，实在让暴躁开发的我难以忍受。现在让我们来配置免密登陆，减少服务器被我再次remake的风险。</p><ol><li><p><strong>本地</strong>生成密钥对</p><p>打开cmd —&gt; 输入 <code>ssh-keygen -t  rsa</code> 生成密钥对。</p><ul><li>在该过程会有三个系统提示，一直回车即可；</li><li>该过程会显示<strong>密钥保存路径</strong>，记录下来。</li></ul><p>打开密钥保存路径—&gt;打开<code>id_rsa.pub</code> 文件，并<strong>复制其全部内容</strong>。</p></li><li><p><strong>远程</strong>密钥配置</p><p>在VSCode打开远程服务器终端，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>按下 <code>i</code> 进入插入模式 —&gt; 粘贴刚刚复制的密钥—&gt;按下<code>:</code>，输入<code>wq!</code> 进行保存。</p></li><li><p>登陆测试</p><p>现在你可以重新登陆远程服务器，发现可以愉快的免密登陆了。</p><ul><li>如果依旧不行，建议在第一步生成密钥对时，<strong>选择覆盖之前密钥</strong>。</li></ul></li></ol><h4 id="文件同步">文件同步</h4><p>工作中经常需要<strong>同步本地和服务器之间的文件</strong>，通常有以下几种方式：</p><ol><li><code>FileZilla</code>软件同步 ；</li><li>VSCode 中<code>STFP</code>插件同步；</li><li>命令行<code>SCP</code>命令同步。</li></ol><p>在这里我们主要介绍1、2两种方式。</p><div class="tabs" id="文件同步方式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#文件同步方式-1">STFP插件</button></li><li class="tab"><button type="button" data-href="#文件同步方式-2">FileZilla</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="文件同步方式-1"><p>因为本文主要是基于VSCode开发，所以介绍一下使用VSCode相关插件进行同步<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="vscode使用sftp快速同步服务器文件：https://blog.csdn.net/qq_24798295/article/details/90228795">[3]</span></a></sup>。</p><ol><li><p>安装SFTP插件</p><p>左侧Extension图标 —&gt; 输入 <code>STFP</code> —&gt;安装即可。注意，需要<strong>远程和本地都进行安装</strong>。</p></li><li><p>工作区：准备</p><p>在<strong>本地</strong>路径下：创建新文件夹—&gt;使用VSCode打开，文件夹被自动加入到工作区中。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206154403565.png" alt="image-20211206154403565"></p></li><li><p>配置<code>sftp.json</code></p><p>在：F1—&gt; 输入SFTP —&gt;选择 SFTP: config ，进行文件配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;roy-cpp&quot;</span>, <span class="comment">// 随意</span></span><br><span class="line">    <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;119.111.111.111&quot;</span>, <span class="comment">// 你的云主机公网IP</span></span><br><span class="line">    <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;sftp&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;port&quot;</span>: <span class="number">22</span>,</span><br><span class="line">    <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>,  <span class="comment">// 登陆用户名</span></span><br><span class="line">    <span class="attr">&quot;remotePath&quot;</span>: <span class="string">&quot;/home/royhuang/syn&quot;</span>, <span class="comment">// 随意，不存在会自动创建</span></span><br><span class="line">    <span class="attr">&quot;uploadOnSave&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指定本地同步文件夹</p><p>在：F1—&gt;输入SFTP —&gt;选择SFTP: Sync Local -&gt; Remote ，将会显示本地工作区的文件夹。</p><p>选择一个文件夹，作为我们同步到远端的本地路径（输入登陆用户密码后确定）。</p><p>同步设置完成后，在VSCode底部会显示SFTP标识：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206160159444.png" alt="image-20211206160159444"></p></li><li><p>（可选）BUG解决：No Such File</p><p>这是SFTP的一个Bug，参考<a href="https://stackoverflow.com/questions/67506693/error-no-such-file-sftp-liximomo-extension">stackoverflow</a>进行解决。</p><ul><li><p>找到<code>sftp.js</code>（Win下可用<a href="https://www.voidtools.com/zh-cn/">everything</a>进行搜索），通常是在以下路径：<code>C:\Users\account_name\.vscode\extensions\liximomo.sftp-1.12.9\node_modules\ssh2-streams\lib\sftp.js</code></p></li><li><p>修改第388行，将 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( code === STATUS_CODE . OK ) &#123;</span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (code === STATUS_CODE.OK || code === STATUS_CODE.NO_SUCH_FILE) &#123;</span><br></pre></td></tr></table></figure></li><li><p>保存文件后，重启VSCode一般可解决。</p></li></ul></li><li><p>测试</p><ul><li><p>本地</p><ol><li>准备测试文件，放入之前设置的<strong>本地同步文件夹</strong>中</li><li>用VSCode打开该同步文件夹：选择测试文件–&gt;右击–&gt;选择<strong>底部Upload</strong> 上传</li></ol></li><li><p>远程服务器</p><ol><li>VSCode打开<strong>远程服务器同步文件夹</strong> ，发现文件已经被顺利上传</li><li>当然远程文件也可同步到本地：选择测试文件–&gt;右击–&gt;选择<strong>底部DownLoad</strong>下载即可。</li></ol></li></ul><p>尽情愉快玩耍吧！</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="文件同步方式-2"><blockquote><p>这里引用<a href="https://github.com/Wanghui-Huang/CQU_bigdata/blob/master/Experiment/Ex2_WordCount/ex2.md">之间写的教程</a> ，文件路径可能有点奇怪，但不影响阅读。</p></blockquote><p>该小节将介绍如何使用FTP软件将本地（Windows）文件上传到服务器(Linux)。</p><ol><li><p>下载软件</p><p>FTP工具我们选择<code>Filezilla</code> ，下载地址：<a href="https://pc.qq.com/search.html#!keyword=fielzilla">Filezilla下载</a></p><p><img src="https://i.loli.net/2020/09/17/RLvUt4bDNa69X1Y.png" alt="1579960280360"></p><p>点击进行下载安装，安装过程较为简单不再赘述。</p></li><li><p>连接服务器</p><p>依次点击：文件 --&gt; 站点管理器 --&gt;  新站点</p><p><img src="https://i.loli.net/2020/09/17/snKEbvuzyc2CXLR.png" alt="1580056871863"></p></li><li><p>上传文件</p><p>如下图所示，左侧为本地文件，右侧为服务器文件目录（默认为 <code>/home/hadoop</code>）</p><p><img src="https://i.loli.net/2020/09/17/aWGltFuJnEXmvpV.png" alt="1580057006302"></p><p>上传完毕后，可在服务器上查看文件：</p><p><img src="https://i.loli.net/2020/09/17/c12v7n9fI4h5BSi.png" alt="1580057304136"></p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="写在最后">写在最后</h3><p>看到这里，相信聪明的你已经将远程开发环境顺利搭建起来。同时，使用g++编译了个小demo，还顺手进行了一次不错的调试体验。</p><p>但在实际开发中，对于<strong>如何优雅去编译我们的项目</strong>，是个不小的问题。为此，我们还需要学习下：</p><ul><li>g++/Makefile/CMake 原理及基础命令；</li><li>项目构建逻辑及编译。</li></ul><p>在下一篇文章：<a href="https://www.hwh.zone/p/2834">环境搭建（下）g++/Makefile/CMake快速入门</a> ，和我一起学习下吧。</p><h3 id="更新记录">更新记录</h3><div class="timeline"><div class="timenode"><div class="meta"><p><p>2021-12-06 ：第一次更新</p></p></div><div class="body"><ol><li>初稿完成并发布</li></ol></div></div></div><h3 id="参考资料">参考资料</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">vscode中c++的三个配置文件的作用：https://blog.csdn.net/zhxue_11/article/details/89457545<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">vscode C++远程调试运行：https://zhuanlan.zhihu.com/p/104131448<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">vscode使用sftp快速同步服务器文件：https://blog.csdn.net/qq_24798295/article/details/90228795<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
          <category> C++环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 教程 </tag>
            
            <tag> C++环境搭建 </tag>
            
            <tag> 远程开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门</title>
      <link href="/p/2834/"/>
      <url>/p/2834/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，开始更新中…</p></blockquote><div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div><p>作为一名C/C++程序员，g++/Makefile/CMake等相关工具是必备的基础。但之前使用中一直存在一些困惑，因此参考了一些资料<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="g++，CMake和Makefile了解一下 ： https://zhuanlan.zhihu.com/p/55027085">[1]</span></a></sup><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Linux下使用CMake编译C++：https://zhuanlan.zhihu.com/p/373256365">[2]</span></a></sup><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="阮一峰--编译器的工作过程：http://www.ruanyifeng.com/blog/2014/11/compiler.html">[3]</span></a></sup>，动笔写了这篇文章，希望可以帮助自己或大家：</p><ul><li>对编译处理过程有个基本认知；</li><li>能初步使用编译工具g++/Makefile/CMake；</li><li>能初步使用CMake编译大型项目。</li></ul><p>才疏学浅，若有错误不吝指正。</p><h3 id="g">g++</h3><p>在下文中，我们将多次利用了g++编译代码。为了方便后续学习Makefile和CMake，我们先进行简单总结。</p><p>以hello.cpp为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt;endl;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速入门">快速入门</h4><p>程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。</p><p>当然，用 gcc 来编译链接 C++ 程序是可行的，如下例所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.cpp -lstdc++ -o hello.out</span><br></pre></td></tr></table></figure><p>不过我们还是主要熟悉g++基本用法来编译C++代码。</p><ol><li><p>g++最简单的编译方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ hello.cpp</span></span><br></pre></td></tr></table></figure><p>由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></li><li><p>指定可执行程序文件名</p><p>我们使用 <strong>-o</strong> 选项指定可执行程序的文件名，以下实例生成一个 名为hello.out 的可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ hello.cpp -o hello.out</span><br></pre></td></tr></table></figure><p>执行 hello.out:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello.out</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></li><li><p>多个 C++ 代码文件</p><p>如 a.cpp、b.cpp，编译命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ a.cpp cpp、b.cpp -o test.out</span><br></pre></td></tr></table></figure><p>生成一个 test.out可执行文件。</p></li></ol><p>g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 hello.cpp 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -Wall -std=c++11 hello.cpp -o hello.out</span><br></pre></td></tr></table></figure><h4 id="g-常用命令选项">g++ 常用命令选项</h4><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">-ansi</td><td style="text-align:center">只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td></tr><tr><td style="text-align:center">-c</td><td style="text-align:center">只编译并生成目标文件。</td></tr><tr><td style="text-align:center">-DMACRO</td><td style="text-align:center">以字符串&quot;1&quot;定义 MACRO 宏。</td></tr><tr><td style="text-align:center">-DMACRO=DEFN</td><td style="text-align:center">以字符串&quot;DEFN&quot;定义 MACRO 宏。</td></tr><tr><td style="text-align:center">-E</td><td style="text-align:center">只运行 C 预编译器。</td></tr><tr><td style="text-align:center">-g</td><td style="text-align:center">生成调试信息。GNU 调试器可利用该信息。</td></tr><tr><td style="text-align:center">-IDIRECTORY</td><td style="text-align:center">指定额外的头文件搜索路径DIRECTORY。</td></tr><tr><td style="text-align:center">-LDIRECTORY</td><td style="text-align:center">指定额外的函数库搜索路径DIRECTORY。</td></tr><tr><td style="text-align:center">-lLIBRARY</td><td style="text-align:center">连接时搜索指定的函数库LIBRARY。</td></tr><tr><td style="text-align:center">-m486</td><td style="text-align:center">针对 486 进行代码优化。</td></tr><tr><td style="text-align:center">-o</td><td style="text-align:center">FILE 生成指定的输出文件。用在生成可执行文件时。</td></tr><tr><td style="text-align:center">-O0</td><td style="text-align:center">不进行优化处理。</td></tr><tr><td style="text-align:center">-O</td><td style="text-align:center">或 -O1 优化生成代码。</td></tr><tr><td style="text-align:center">-O2</td><td style="text-align:center">进一步优化。</td></tr><tr><td style="text-align:center">-O3</td><td style="text-align:center">比 -O2 更进一步优化，包括 inline 函数。</td></tr><tr><td style="text-align:center">-shared</td><td style="text-align:center">生成共享目标文件。通常用在建立共享库时。</td></tr><tr><td style="text-align:center">-static</td><td style="text-align:center">禁止使用共享连接。</td></tr><tr><td style="text-align:center">-UMACRO</td><td style="text-align:center">取消对 MACRO 宏的定义。</td></tr><tr><td style="text-align:center">-w</td><td style="text-align:center">不生成任何警告信息。</td></tr><tr><td style="text-align:center">-Wall</td><td style="text-align:center">生成所有警告信息。</td></tr></tbody></table><h3 id="编译过程初探">编译过程初探</h3><p>现在让我们从一个简单的例子，来一步步探讨下编译过程。</p><p>准备的<code>hello.cpp</code>程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt;endl;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对它进行简单的编译&amp;输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++  hello.cpp -o hello.out  <span class="comment"># 文件名可包含指定路径</span></span><br></pre></td></tr></table></figure><p>可以看到，当前路径生成了<code>hello.out</code>文件，这是一个可执行的二进制文件。</p><p><strong>hello.out本质是什么</strong> ?</p><p><strong>一个程序（比如hello.out）本质是由数据段、代码段、.bss段组成。</strong></p><p>下图展示了一个虚拟进程（程序）内存空间<u>运行时</u>分布布局（下图.bss段和数据段合并了）：</p><ul><li><p>注意到此时<u>还多了堆&amp;栈用来给程序运行时进行空间分配</u>；</p></li><li><p>高地址的1GB（Linux下如此，Windows默认2GB）空间分配给内核，也称为<strong>内核空间</strong>；剩下的3GB分给用户，也称<strong>用户空间</strong>。</p></li></ul><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/5e8d39d19a216fd03392d36081e70b7e.jpg" alt="你确定你理解内存分配吗？" style="zoom:80%;" /><ul><li><p><strong>栈（Stack</strong>）：存储代码中调用函数、定义<u><strong>局部</strong>变量</u>(但不包含static修饰的变量)、保存的上下文等；</p></li><li><p><strong>文件映射区域 ：</strong> 栈和堆中间那个空白区域。动态库、共享内存等映射物理空间的内存，一般是 <code>mmap</code> 函数所分配的虚拟地址空间。</p></li><li><p><strong>堆（Heap</strong>）：存储那些生存期<u>与函数调用无关的数据</u>，如动态分配的内存。</p></li><li><p><strong>.bss段</strong>：全称Block Started by Symbol，也就是未被初始化的<strong>全局</strong>变量、<strong>静态</strong>变量的内容的一块内存区域。</p></li><li><p><strong>数据段（.data</strong>）：保存<strong>全局</strong>变量、<strong>常量</strong>、静态变量的内容的一块内存区域，区别.bss段在于变量已经被初始化。比如：</p></li><li><p><strong>代码段（.text &amp; .init</strong>）： <code>.text</code> 用于存放整个程序中的代码； <code>.init</code> 用于存放系统中用来初始化启动你的程序的一段代码 。</p></li></ul><p>回来神来，让我们继续执行一下试试：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208140718480.png" alt="image-20211208140718480"></p><p>我们的代码被正确执行了。但这整个过程的细节被隐藏了，如果不了解清楚对我们以后的学习工作阻碍很大。</p><p>正式开始接触细节前，我们先大致了解下上述编译过程（四步）：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/20200423003518622.png" alt="C/C++程序编译的过程| 码农家园"></p><ol><li><code>预处理</code>：资源进行等价替换，生成<strong>预编译文件</strong>（<strong>.i</strong>文件）；</li><li><code>编译</code> ：生成<strong>汇编代码</strong>（<strong>.s</strong>文件）；</li><li><code>汇编</code> ：将汇编代码最终生成<strong>机器代码</strong>（<strong>.o</strong>文件）；</li><li><code>链接</code>：动态或静态链接外部函数/库(lib)/变量，生成<strong>可执行的二进制(hex)文件/静态库(.a)文件/动态库(.so)文件</strong>。</li></ol><p>现在让我们来逐步分析。</p><h4 id="预处理">预处理</h4><p>预处理的主要作用：通过内建功能对<strong>预处理指令进行等价文本替换</strong>。</p><p>一般地，<code>C/C++</code> 程序的源代码中包含以 <code>#</code> 开头的各种编译指令，被称为<strong>预处理指令</strong>。根据ANSI C 定义，主要包括：<strong>文件包含、宏定义、条件编译和特殊控制</strong>等4大类<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="gcc编译生成可执行文件的过程中发生了什么：https://blog.csdn.net/albertsh/article/details/89309107">[7]</span></a></sup>。</p><ul><li><p><strong>文件包含</strong>：例如常用的预处理指令 <code>#include &lt;iostream&gt;</code> ，预编译阶段会使用系统目录下<code>iostream</code>文件中的全部内容，替换 <code>#include &lt;iostream&gt;</code> 。</p><blockquote><p><code>#include &quot;xxx.h&quot;</code> ，表示使用当前目录下xxx.h文件，<code>&lt;&gt;</code> 是在系统目录下查找。</p></blockquote></li><li><p><strong>宏定义展开及处理</strong>： 预处理阶段会将定义的常量符号进行等价替换，e.g. <code>#define A 100</code> , 所有的宏定义符号A都会被替换成<code>100</code>。还会将一些内置的宏展开，比如用于显示文件全路径的<code>__FILE__</code>。</p></li><li><p><strong>条件编译处理</strong>: 如 <code>#ifdef，#ifndef，#else，#elif，#endif</code>等，这些条件编译指令的引入，使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预处理时会将那些不必要的代码过滤掉，防止文件重复包含等。</p></li><li><p>其它：特殊控制处理…</p></li></ul><p>特别的，预处理过程还会发生：</p><ul><li><strong>添加行号和文件名标识</strong>： 比如在文件<code>hello.i</code>中就有类似 <code># 2 &quot;main.c&quot; 2</code> 的内容，以便于编译时编译器产生调试用的行号信息，编译时产生编译错误或警告时能够显示行号；</li><li>清理注释内容等。</li></ul><p>在这一步，我们亲眼瞧瞧<strong>预处理的等价文本替换</strong>究竟做了什么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -E hello.cpp &gt; hello.i  <span class="comment"># 输出文件重定向到hello.i中</span></span><br></pre></td></tr></table></figure><p>可以看到：</p><ol><li><p><strong>文件包含</strong>：我们之前引入的头文件 <code>#include &lt;iostream&gt;</code> ，<strong>预处理后会将<code>#include &lt;iostream&gt;</code> 代码替换为iostream文件的内容，插入到<code>hello.i</code>中</strong>。</p><p>文件过长，以下是部分截图：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208235953948.png" alt="image-20211208235953948"></p><p>特别的，<strong>iostream文件本身也#include了头文件，同样会被替换</strong>，也就是进行大杂烩嵌套拼接。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/20200422202617233.png" alt="在这里插入图片描述" style="zoom:80%;" /></li><li><p>其它，<u>条件编译处理</u>、<u>添加行号和标识</u>等也一并可以（左图）观察到。</p></li></ol><h4 id="编译">编译</h4><p>编译过程是整个程序构建的核心部分，也是最复杂的部分之一，其工作就是把预处理完生成的 <code>.i</code> 文件进行一系列的<strong>词法分析、语法分析、语义分析以及代码优化</strong>，最终产生相应的汇编代码文件，也就是 <code>.s</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -S hello.cpp -o hello.s  <span class="comment"># 该命令包含等价替换过程</span></span><br></pre></td></tr></table></figure><p>打开当前目录下<code>hello.s</code> ，入目即是熟悉的汇编天书：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208150625682.png" alt="image-20211208150625682"></p><h4 id="汇编">汇编</h4><p>相对来说比较简单，每个汇编语句都有相对应的机器指令，只需根据汇编代码语法和机器指令的对照表翻译过来就可以了。</p><p>有了上述汇编代码后，我们便可以将其转换为机器码（<code>.o</code>文件，即object file）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c hello.cpp -o hello.o  <span class="comment"># -c 表示不进行链接，只生成目标文件</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208151441286.png" alt="image-20211208151441286"></p><p>但是在这一步还不能直接执行，会报错：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208151833947.png" alt="image-20211208151833947"></p><p>这是因为我们还<strong>没有链接其它相应的文件</strong>，因此会报错。我们来试试链接再生成可执行代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.o -o hello.out</span><br></pre></td></tr></table></figure><p>然后执行：<code>./hello.out</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208160023661.png" alt="image-20211208160023661"></p><p>假装惊喜的发现（是的就是这么戏精），文件确实已经被成功执行了。</p><p>那么，<strong>链接过程中究竟发生了什么？为什么一定要链接后才能执行</strong>？</p><h4 id="链接">链接</h4><h5 id="链接过程究竟做了什么？">链接过程究竟做了什么？</h5><p><strong>链接就是进行符号解析和重定位</strong>的过程<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="符号解析：https://www.jianshu.com/p/2786533a34c9">[4]</span></a></sup>。</p><ul><li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li><li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li></ul><p><strong>为什么一定要进行符号解析和重定位</strong>？</p><p>比如我们上一步生成的可执行文件<code>hello.o</code> 执行出错，就是因为<strong>符号<code>std::cout</code>没有进行解析和重定位</strong>。</p><p>在前面预处理阶段，我们知道 <code>#include&lt;iostream&gt;</code> 会被替换为头文件<code>iostream</code>中的内容。</p><p>但头文件<code>iostream</code>中的符号，如<code>cout</code>只是被定义，并没有实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> ostream cout;<span class="comment">/// Linked to standard output</span></span><br></pre></td></tr></table></figure><p>具体是在<code>libstdc++.so.6</code>中被实现的。我们必须要让编译器找到<code>libstdc++.so</code>，也就是通过链接，然后将<strong>cout符号解析重定向libstdc++.so中</strong>。这样，<code>cout</code>才可以被正常执行。</p><h5 id="准备代码片段">准备代码片段</h5><p>为了更清楚的说明整个过程，我们不妨换一个例子，<strong>不使用系统库文件</strong>（预处理后的文件太复杂）。</p><ul><li><p>Main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> shared;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>*,<span class="keyword">int</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="built_in">swap</span>(&amp;a, &amp;shared);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Libtest.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> shared = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   *a ^= *b ^= *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>可以看到：Libtest.cpp<strong>不引用</strong>任何外部变量符号，但Main.cpp文件会<strong>引用</strong>Libtest.cpp中的<strong>shared变量</strong> 和 <strong>swap函数</strong>。</p><p>那么，<strong>Main.cpp中外部符号即shared和swap，怎么样才能被正确解析到Libtest.cpp中</strong>？</p><h5 id="链接前置知识">链接前置知识</h5><blockquote><p>下面有不理解的地方，建议阅读：<a href="https://www.cnblogs.com/fellow1988/p/6158240.html">ELF学习–重定位文件</a></p></blockquote><p>继续讲解前，我们还需补充几个基本概念<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="计算机原理系列之七-链接过程分析：https://luomuxiaoxiao.com/?p=572">[5]</span></a></sup>：</p><ul><li><p><strong>符号和外部符号</strong></p><ul><li>在链接中，我们将函数和变量统称为<strong>符号</strong>（<strong>Symbol</strong>）；</li><li>在本目标文件中使用，而又没有在本目标文件中定义的全局符号，称为<strong>外部符号</strong>（<strong>External Symbol</strong>）。</li></ul></li><li><p><strong>重定位表</strong></p><p>由于<strong>外部符号在编译后并不能确定其位置地址（链接重定位后才能确定</strong>）。所以需要这么一个文件：<strong>将需要重定位的外部符号进行标记</strong>。</p><p>比如，编译后<code>Main.o</code> 文件符号表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c Main.cpp -o Main.o # -c参数表示不进行链接</span><br><span class="line">objdump -r Main.o</span><br></pre></td></tr></table></figure><ul><li><p>可见，<code>shared</code>和<code>swap()</code>为外部符号被标记记录，显然，<strong>这些符号是需要被解析重定向</strong>的。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227201402682.png" alt="image-20211227201402682"></p></li></ul><p>但是<strong>Libtest.o中没有外部符号</strong>，因此其重定位表为空。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c Libtest.cpp -o Libtest.o</span><br><span class="line">objdump -r Libtest.o</span><br></pre></td></tr></table></figure><p>重定位表为空。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227215524264.png" alt="image-20211227215524264"></p></li><li><p><strong>符号表</strong></p><p>目标文件使用<strong>符号表</strong>（<strong>Symbol Table</strong>）来记录本目标文件中的<strong>全局符号</strong>的信息。</p><p>e.g. <strong>自定义的全局符号地址</strong>，这样别的文件中引用了该自定义的全局符号，就可以查找其真实地址。</p><ul><li><p><strong>Main.o符号表</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s Main.o</span><br></pre></td></tr></table></figure><ul><li><p>Main.o定义了全局符号<code>main</code>，使用到了外部符号<code>shared</code>和<code>swap</code>。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227201514728.png" alt="image-20211227201514728"></p><p><code>UND</code> 即表示未定义需要重定义。</p></li></ul></li><li><p><strong>Libtest.o的符号表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s Libtest.o</span><br></pre></td></tr></table></figure><p>Libtest.o定义了符号<code>shared</code>和<code>swap</code>，没有使用到外部符号</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227201608874.png" alt="image-20211227201608874"></p></li></ul></li></ul><h5 id="静态链接过程">静态链接过程</h5><blockquote><p><strong>静态链接的主要目的：1）将多个目标文件合并，2）并处理各目标文件用到的外部符号（e.g. main.cpp 中的 swap和shared）</strong>，对外部符号重定位（ 调整地址到真正定义实现的地方，e.g.，swap→Libtest.o），最后生成<strong>可独立运行</strong>的可执行文件。</p></blockquote><p>现在我们进行静态链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g++ -static Main.cpp Libtest.cpp -o main.out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">g++ -c Main.cpp  -o Main.o</span><br><span class="line">g++ -c Libtest.cpp  -o Libtest.o</span><br><span class="line">g++ -static Main.o Libtest.o -o main.out <span class="comment"># 目标文件（可执行文件）静态链接</span></span><br></pre></td></tr></table></figure><p>静态链接一般采用<strong>两步链接</strong>（<strong>Two-pass Linking</strong>）的方法，下面以链接 Main.cpp 和 Libtest.cpp为例具体说明。</p><p><strong>第一步，空间与地址分配。</strong></p><p>扫描<strong>所有的编译生成的可重定向文件（Main.o和Libtest.o）并合并</strong>，同时获得其以下信息：</p><ol><li><p><strong>全局符号表</strong>：包含所有的符号定义和符号引用；</p><table><thead><tr><th style="text-align:center">符号名</th><th style="text-align:center">状态</th><th style="text-align:center">所在目标文件</th><th style="text-align:center">…</th></tr></thead><tbody><tr><td style="text-align:center">main</td><td style="text-align:center">定义</td><td style="text-align:center">Main</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">shared</td><td style="text-align:center"><strong>引用</strong></td><td style="text-align:center">Main</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">swap</td><td style="text-align:center"><strong>引用</strong></td><td style="text-align:center">Mian</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">shared</td><td style="text-align:center">定义</td><td style="text-align:center">Lib</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">swap</td><td style="text-align:center">定义</td><td style="text-align:center">Lib</td><td style="text-align:center"></td></tr></tbody></table></li><li><p><strong>段信息</strong>：各个段的长度、属性和位置。</p></li></ol><p><strong>第二步，符号解析与重定位。</strong></p><ol><li><p>查看<strong>全局符号表</strong>，发现<code>shared</code>需要重定位；</p></li><li><p>在<strong>全局符号表</strong>发现Libtest.o定义了<code>shared</code>；</p></li><li><p>查看<strong>Libtest.o的符号表</strong>以及第一步的<strong>段信息</strong>，确定<code>shared</code>的地址；</p></li><li><p>再查看<strong>Main.o的重定位表</strong>，找到所有<code>shared</code>需要重定位的地址，修改为<code>shared</code>的真实地址；</p><blockquote><p>Main.o和Libtest.o被合并，必须要查看重定位表，知道哪些是属于Main的<code>share</code>，进行重定位。</p></blockquote></li><li><p>继续查看<strong>全局符号表</strong>，发现<code>swap</code> 需要重定位，过程同上；</p></li><li><p>直至所有的<strong>符号引用都被修改为真实地址</strong>，结束。</p></li></ol><p>我们可以反编译一下最后的可执行文件，看看是否如上所示已经全部重定义完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d main.out &gt; tmp.txt</span><br></pre></td></tr></table></figure><p>例如，主函数中调用的swap函数的地址被修正为40050d。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227204728883.png" alt="image-20211227204728883"></p><p><strong>其它信息合并</strong></p><p>在静态链接下，链接器还会将<strong>各个目标文件的代码段和数据段【合并拷贝】到可执行文件</strong>，因此静态链接下可执行文件当中<strong>包含了所依赖的所有代码和数据</strong>。</p><ul><li><p>在本例中，Main.o和Libtest.o中的代码段和数据段被合并拷贝到可执行文件中，然后进行解析重定位。</p></li><li><p>下图进行了图解展示合并过程。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/807220-2e1bc10a88be493b" alt="img"></p></li></ul><p>看到这里，相信你已经明白，在静态链接中外部符号：</p><ul><li><strong>为什么要被解析重定位</strong>：外部符号能被定位到真正实现的地方；</li><li><strong>如何被解析重定位</strong>：通过符号表实现。</li></ul><p>同时，静态链接还会将需要的目标文件进行合并，因此体积比较大。</p><h5 id="动态链接过程">动态链接过程</h5><p><strong>为什么需要动态链接</strong>？</p><p>试试想想以下两种糟糕的情况：</p><ul><li><p><strong>空间浪费</strong>： 假设你是个腾讯技术专家，你写的代码Libtest.cpp性能挺好，于是开源出来<strong>生成一个静态库</strong>给其它人也用用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c Libtest.cpp -o libtest.o</span><br><span class="line">ar cqs libtest.a libtest.o</span><br></pre></td></tr></table></figure><p>github反应不错，你的大作很受欢迎，基本机器上每个程序都调用了你的库。但是<strong>由于每个程序都静态链接你的静态库libtest.a，导致每个程序都会【拷贝】Libtest.a中的代码</strong>，造成了很大的空间浪费。</p></li><li><p><strong>更新困难</strong>： 不幸的是，你不但技术精湛<s>头发稀少</s>同时精力旺盛，经常对你的大作libtest.a进行更新。这样你每更新一次，<strong>为了跟上你技术专家的步伐，所有的程序都要重新编译一次，来静态链接拷贝你的最新代码</strong>。情况严重的话，这可能收到一些礼貌的问候。</p></li></ul><p>聪明的你，自然想到号召大家使用<strong>动态链接</strong>：</p><ul><li>对那些组成程序的目标文件，比如你的libtest，不进行直接链接，而只是将<strong>必要信息写入了可执行文件，等到程序要运行时才进行链接</strong>。这样他们只用下载你大作libtest.so最新的版本，可执行文件运行时就会自动（动态）链接新版本，从而<strong>不用重新编译</strong>了。</li></ul><p>于是你开心地开始尝试下动态链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment"># 生成的动态库的名字必须是lib+名字.so</span></span><br><span class="line">g++ -shared  -o libtest.so Libtest.cpp</span><br><span class="line"><span class="comment"># 保存在/usr/lib64/下</span></span><br><span class="line">mv libtest.so  /usr/lib64/</span><br><span class="line"><span class="comment"># 动态链接你的大作libtest.so，可以直接使用-ltest来引用</span></span><br><span class="line">g++  Main.cpp  -L/usr/lib64/ -ltest -o main.out</span><br></pre></td></tr></table></figure><p>得到可执行文件<code>main.out</code>。</p><p>但是<code>main.out</code><strong>仅包含了<code>libtest.so</code> 的相关符号信息</strong>，并没有将 <code>libtest.so</code>和 <code>main.out</code>合并。只有当我们执行 <code>./main.out</code> ，此时才会动态加载<code>Libtest.so</code> 。</p><blockquote><p>前面提到的<code>hello.out</code>中的<code>std::cout</code> 也是动态链接的：</p><ol><li>编译生成了可执行文件<code>hello.out</code> ，但此时<code>hello.out</code>只包含了<code>cout</code>符号信息；</li><li>执行可执行文件<code>hello.out</code>时 ，根据<code>cout</code>符号信息加载<code>libstdc++.so.6</code> 动态库。</li></ol></blockquote><p>从上也回答本节开头的问题：<strong>动态链接生成的可执行文件体积小，避免了空间浪费，同时灵活性强</strong>。这也就是使用动态链接的主要原因。</p><p>那么，动态链接的需要的动态库，和静态链接需要的静态库又是什么呢？</p><h5 id="静态库和动态库">静态库和动态库</h5><blockquote><p>Windows下的静态库和动态库分别为<code>.lib</code>和<code>.dll</code> 结尾的文件，本节中仅以在Linux系统中说明相关概念。</p></blockquote><p>Linux 下的库有两种<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="C/C++中关于静态链接库(.a)、动态链接库（.so）的编译与使用：https://blog.csdn.net/qq_27825451/article/details/105700361">[8]</span></a></sup>：<strong>静态库(.a</strong>)和<strong>共享库（动态库，.so</strong>） ，都采用以下方式进行链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 【例】Main.cpp动态链接libtest.so，静态链接需加上-static参数</span></span><br><span class="line"><span class="comment"># -L：指定搜素路径，:可分隔多个路径</span></span><br><span class="line"><span class="comment"># -l：指定库名，前缀&quot;lib&quot;和后缀&quot;.a&quot; 或&quot;.so&quot;省略</span></span><br><span class="line">g++  Main.cpp  -L/usr/lib64/ -ltest -o main.out</span><br></pre></td></tr></table></figure><ul><li><p><strong>静态库</strong></p><ul><li><p><strong>特点</strong>：编译过程中已经被载入可执行程序，因此体积较大；</p></li><li><p><strong>命名</strong>：.a为后缀，lib为前缀， 例如 <code>libtest.a</code> ；</p></li><li><p><strong>生成</strong>：先生成<code>.o</code> 文件，再用<code>ar</code>工具可生成；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c Libtest.cpp -o libtest.o</span><br><span class="line">ar cqs libtest.a libtest.o</span><br></pre></td></tr></table></figure></li><li><p><strong>链接路径</strong>：</p><ol><li><strong>参数-L</strong>：ld会去找gcc/g++命令中的参数<code>-L</code>指定的路径；</li><li><strong>环境变量</strong>：gcc的环境变量<code>LIBRARY_PATH</code>，它指定程序<strong>静态</strong>链接库文件搜索路径；</li><li><strong>默认库</strong>：再找默认库目录 <code>/lib</code>、 <code>/usr/lib</code>、 <code>/usr/local/lib</code>。</li></ol></li></ul></li><li><p><strong>动态库</strong></p><ul><li><p><strong>特点</strong>：可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小；</p></li><li><p><strong>命名</strong>：.so为后缀，lib为前缀，通常还会加上版本号， 例如 <code>libtest.a.0.1</code> ;</p></li><li><p><strong>生成</strong>：<code>g++</code>工具可生成；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c Libtest.cpp -o libtest.o</span><br><span class="line">g++ -shared  libtest.o -o libtest.so.1.0</span><br></pre></td></tr></table></figure></li><li><p><strong>链接路径</strong>：</p><ol><li><strong>参数-L</strong>：ld会去找gcc/g++命令中的参数<code>-L</code>指定的路径；</li><li><strong>环境变量</strong>：gcc的环境变量<code>LD_LIBRARY_PATH</code>，它指定程序<strong>动态</strong>链接库文件搜索路径；</li><li><strong>配置文件</strong>：配置文件 <code>/etc/ld.so.conf</code> 中指定动态库路径；</li><li><strong>默认库</strong>：再找默认库目录 <code>/lib</code>、 <code>/usr/lib</code>。</li></ol></li></ul></li></ul><h4 id="全过程总结">全过程总结</h4><blockquote><p>源码到执行全过程分析。</p></blockquote><p>在linux中程序的加载（不是链接），涉及到linker和loader两个工具。linker主要涉及动态链接库的使用，loader主要涉及软件的加载。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/807220-3b44242bee5ba363" alt="img" style="zoom:80%;" /><p>上图是一个典型的编译将源文件<code>main.cpp</code> 生成可执行文件<code>myProc.out</code> 并执行的过程 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -L/usr/lib -laaa  -lbbb -o myProc.out </span><br><span class="line">./myProc.out </span><br></pre></td></tr></table></figure><ol><li><p><strong>链接前</strong>：依次按预处理→编译→汇编，生成可执行文件<code>main.o</code> ；</p></li><li><p><strong>链接</strong>：分静态链接和动态链接。</p><ul><li><strong>静态链接</strong>：对<code>main.o</code> 中未定义的符号进行解析重定位到静态库<code>aaa.o</code> 中，然后把需要的目标文件<code>lib1.o</code> 、<code>lib2.o</code> 和<code>main.o</code> 的.text段、.data段、.bss段进行合并生成初步的可执行文件<code>myProc.out</code> ；</li><li><strong>动态链接</strong>：此时<code>main.o</code> 中依旧有部分符号没有被解析，它们的实现存于动态库<code>bbb.so</code>中 ，但动态链接仅将<code>bbb.so</code> 相关<u>符号信息</u>保存在<code>myProc.out</code>中。</li></ul><p>现在我们获取最终的可执行文件<code>myProc.out</code>。</p></li><li><p><strong>执行</strong>：执行可执行文件。</p><p><code>myProc.out</code> 由代码段（.text，只读可执行），数据段（.data，只读），.bss段组成，现在看看如何被加载到内存中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./myProc.out  <span class="comment"># 开始执行程序，通过loader加载器加载程序</span></span><br></pre></td></tr></table></figure><ul><li><strong>内存映射</strong>。loader启动通过mmap系统调用，将代码段和数据段映射到<u>虚拟内存</u>中 ，不占物理内存；</li><li><strong>动态库加载</strong>。动态链接器将编译时指明依赖的动态链接库，映射到虚拟内存中；</li><li><strong>执行<code>.text</code> 中指令</strong>。程序开始运行，通常伴随着栈、堆空间分配等。</li></ul></li></ol><h3 id="编译工具简介">编译工具简介</h3><p>在前面我们简单使用g++进行文件编译、执行。当然，主要还是偏“<strong>务虚</strong>”探讨了下编译的过程及原理。</p><p>接下来，我们将偏”<strong>务实</strong>“的介绍一下基本三大编译工具的使用 ：g++/Makefile/CMake。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/catkin.jpg" alt="ROS课程讲义--2.1 Catkin编译系统_jinking01的专栏-CSDN博客"></p><p>三者关系如上图所示。</p><ul><li><strong>gcc/g++</strong>：Linux编译器有gcc/g++，随着源文件的增加，直接用gcc/g++命令的方式<strong>效率较低</strong>，于是发明了Makefile来进行编译；</li><li><strong>Makefile</strong>： Makefile描述了整个工程的编译、链接等规则，可以<strong>有效的减少大工程中需要编译和链接的文件，只编译和链接那些需要修改的文件</strong>。然而随着工程体量的增大，Makefile也不能满足需求，于是便出现了Cmake工具；</li><li><strong>CMake</strong>：CMake是一个跨平台的编译(Build)工具，可以用简单的语句来描述所有平台的编译过程。早期的make需要程序员写Makefile文件进行编译，而现在CMake能够通过对<a href="https://www.zhihu.com/search?q=cmakelists.txt&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%2255027085%22%7D">CMakeLists.txt</a>的编辑，<strong>轻松实现对复杂工程的组织</strong>。</li></ul><p>具体实操练习掌握。</p><h3 id="Makefile">Makefile</h3><h4 id="快速入门-2">快速入门</h4><p>Makefile基本格式如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure><ul><li><p><strong>target（目标）</strong> ： 目标文件, 可以是 Object File, 也可以是可执行文件；</p></li><li><p><strong>prerequisites（前置条件）</strong> ： 生成target所需要的文件或者目标；</p></li><li><p><strong>command（命令）</strong>： make需要执行的命令(任意的shell命令)，Makefile中的命令必须以 <code>[tab],即四个空格</code> 开头。</p></li></ul><p><strong>基本语法</strong></p><blockquote><p>先熟悉以下偏理论总结上的东西，实践时互相验证效果更好~</p></blockquote><p>Makefile包含了五个重要的东西：<strong>显示规则、隐晦规则、变量定义、文件指示和注释</strong>。</p><ul><li><strong>显示规则</strong>： 即<strong>需要指明target和prerequisite文件</strong>。<ul><li><u>一条规则可以包含多个target</u>，这意味着其中每个target的prerequisite都是相同的；</li><li><u>当其中的一个target被修改后</u>，整个规则中的其他target文件都会被重新编译或执行。</li></ul></li><li><strong>隐晦规则</strong>：make自动推导功能所执行的规则。</li><li><strong>变量和定义</strong>：Makefile中定义的变量，一般是字符串。</li><li><strong>文件指示</strong>：通常指以下<ol><li>Makefile中引用其他Makefile；</li><li>指定Makefile中有效部分；</li><li>定义一个多行命令。</li></ol></li><li><strong>注释</strong>：只有行注释<code>#</code> 。</li></ul><h5 id="一起试试">一起试试</h5><p>我们准了一段代码<code>DisplayImage.cpp</code>：使用c++和opencv对图片进行读取和显示。</p><p>为了方便阅读，代码已经尽量精简。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 读取</span></span><br><span class="line">    Mat image = cv.<span class="built_in">imread</span>( argv[<span class="number">1</span>], <span class="number">1</span> );</span><br><span class="line">    <span class="comment">// 显示</span></span><br><span class="line">    cv.<span class="built_in">namedWindow</span>(<span class="string">&quot;Display Image&quot;</span>, WINDOW_AUTOSIZE );</span><br><span class="line">    cv.<span class="built_in">imshow</span>(<span class="string">&quot;Display Image&quot;</span>, image);</span><br><span class="line">    cv.<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先给出已完成的Makefile文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/home/royhuang/lib/pkgconfig</span><br><span class="line"></span><br><span class="line">CXXFLAGS:=<span class="variable">$(<span class="built_in">shell</span> pkg-config --cflgs --libs opencv)</span></span><br><span class="line"></span><br><span class="line"><span class="section">DispalyImage:DispalyImage.o</span></span><br><span class="line">g++ DispalyImage.o -o DispalyImage</span><br><span class="line"><span class="section">DispalyImage.o:DispalyImage.cpp</span></span><br><span class="line">        g++ -c DispalyImage.cpp -o DispalyImage.o</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *o test</span><br></pre></td></tr></table></figure><p>现在建议我们<strong>从下往上</strong>分析：</p><ol><li><p><strong>编写clean</strong> ：删除所有的.o文件和可执行文件，避免过多的中间文件产生；</p></li><li><p><strong>编写 DispalyImage.o:DispalyImage.cpp</strong> ：根据之前的格式，<code>target  : prerequisites</code> ，这个时候 <code>target</code> 为   <strong>DispalyImage.o</strong> ，<code>prerequisites</code> 为<strong>DispalyImage.cpp</strong> 。</p><p>下一行的g++命令，将cpp文件进行编译为object file（<code>.o</code> 文件）。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">DispalyImage.o:DispalyImage.cpp</span></span><br><span class="line">        g++ -c DispalyImage.cpp -o DispalyImage.o</span><br></pre></td></tr></table></figure></li><li><p><strong>编写 DispalyImage:DispalyImage.o</strong> ：在上一步我们得到了编译后的目标文件 DispalyImage.o 。现在我们可以build生成可执行文件DispalyImage。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">DispalyImage:DispalyImage.o</span></span><br><span class="line">g++ DispalyImage.o -o DispalyImage</span><br></pre></td></tr></table></figure></li><li><p><strong>应用OpenCV库和头文件</strong> 。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/home/royhuang/lib/pkgconfig</span><br><span class="line"></span><br><span class="line">CXXFLAGS:=<span class="variable">$(<span class="built_in">shell</span> pkg-config --cflgs --libs opencv)</span></span><br></pre></td></tr></table></figure><ul><li><p><code>PKG_CONFIG_PATH</code> ：添加指定路径到环境变量。如上例，添加了路径<code>/home/royhuang/lib/pkgconfig</code>到环境变量 ，这样我们就可以直接在命令行中使用<code>pkg-config</code>命令 。</p></li><li><p><code>CXXFLAGS</code> ：指定文件（.h文件或lib文件）的路径，使得编译时可以找到相应头文件和库文件。</p><p>在本例中，<code>pkg-config</code>命令可查看opencv的include头文件的路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --libs 参数可查看库文件</span></span><br><span class="line">shell pkg-config --cflgs  opencv</span><br></pre></td></tr></table></figure><p>同时引入头文件和库文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config opencv --cflgs --libs opencv</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>有了<code>makefile</code>文件后，我们就可以make生成可执行文件<code>DisplayImage</code>了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动查找当前目录下叫“Makefile”或“makefile”的文件</span></span><br><span class="line">make </span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">./DisplayImage ../01.jpg</span><br></pre></td></tr></table></figure><p>从上也可总结出：<strong>Makefile 包含了所有的规则和目标，而 make 则是为了完成目标而去解释 Makefile 规则的工具</strong>。</p><p>总的来说，Makefile的基本套路就是以上，熟练使用需要实际项目多练习下。</p><h4 id="进阶学习">进阶学习</h4><p>这里准备举一些较复杂的项目，怎么来编写Makefile文件。</p><p>但是一般较复杂的项目我现在一般用<strong>CMake</strong>，也是后文需要介绍的。因此这里复杂项目Makefile编写案例，暂时留白，后续补上。</p><p>当然，你可以先看看：<a href="https://www.ruanyifeng.com/blog/2015/02/make.html">Make 命令教程 - 阮一峰</a> 。</p><h3 id="CMake">CMake</h3><p>早期的make需要程序员写Makefile文件，进行编译。而现在CMake能够通过对<code>CmakeLists.txt</code>的编辑，轻松实现对复杂工程的组织。</p><h4 id="快速入门-3">快速入门</h4><p>首先，我们在Linux系统（CentOS）下安装下CMake：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install cmake</span><br></pre></td></tr></table></figure><p>一般使用CMake生成Makefile并编译的流程如下：</p><ol><li>编写<code>CMakeLists.txt</code>，假定其路径为<code>PATH</code>；</li><li>执行命令<code>cmake PATH</code>生成Makefile；</li><li>最后使用<code>make</code>进行编译。</li></ol><h5 id="一起试试-2">一起试试</h5><p>我们准备一个<code>hello.cpp</code> 文件，它所在的目录如下所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- build  <span class="comment"># cmake生成的中间文件都放这</span></span><br><span class="line">|-- hello.cpp</span><br><span class="line">|-- CMakeLists.txt <span class="comment"># 每个子目录下都要有CMakeLists.txt文件</span></span><br></pre></td></tr></table></figure><p>文件内容很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hello.cpp */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello Cpp!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们编写的<code>CMakeLists.txt</code>，每一行代码解释如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式：&lt;命令名&gt;(参数 参数值) ，中间参数空格隔开</span></span><br><span class="line"><span class="comment"># 设置项目名</span></span><br><span class="line"><span class="keyword">project</span>(helloDemo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限定CMAKE最低版本</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">2.6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索当前目录所有源代码文件，并赋值给PROJECT_ROOT_SRCS</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. PROJECT_ROOT_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加C++11特性</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-std=c++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_executable 从一组源文件编译出一个可执行文件 </span></span><br><span class="line"><span class="comment"># 这里将$&#123;PROJECT_ROOT_SRCS&#125;中文件编译，生成可执行文件hello.out</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello.out <span class="variable">$&#123;PROJECT_ROOT_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure><p>开始编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成makefile等中间文件</span></span><br><span class="line"><span class="comment"># 生成的可执行文件 【如果要可以被调试】，还要带上参数：cmake -DCMAKE_BUILD_TYPE:STRING=Debug</span></span><br><span class="line"><span class="built_in">cd</span> ./build  &amp;&amp; cmake ..</span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>最后执行刚刚生成的可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello.out</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211209221810181.png" alt="image-20211209221810181"></p><p>看到这里，相信你对CMake有了个基本的认知。在前面我们也知道，CMake通常是用来编译大型项目的。</p><p>那么，<strong>大型项目结构是什么样的？又如何进行编译呢</strong>？</p><h4 id="大型项目结构">大型项目结构</h4><blockquote><p>主要参考：<a href="https://github.com/hattonl/cpp-project-structure">cpp-project-structure</a>。</p></blockquote><p>这里假定项目名为 <code>my_poject</code> ，一个完整的大项目结构通常如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">my_poject  </span><br><span class="line">├── deploy <span class="comment"># 存放部署、交付的文件 </span></span><br><span class="line">│   └── bin      <span class="comment"># 项目生成的可执行文件</span></span><br><span class="line">│   └── lib      <span class="comment"># 项目生成的库文件</span></span><br><span class="line">│   └── include  <span class="comment"># 项目对外提供的头文件</span></span><br><span class="line">├── build  <span class="comment"># 存放cmake产生的中间文件</span></span><br><span class="line">│   └── release</span><br><span class="line">│   └── debug  </span><br><span class="line">├── doc      <span class="comment"># 存放项目文档</span></span><br><span class="line">├── src      <span class="comment"># 存放资源文件</span></span><br><span class="line">│   └── pic            </span><br><span class="line">├── 3rdparty <span class="comment"># 存放第三方库</span></span><br><span class="line">│   └── lib       <span class="comment"># 库文件  </span></span><br><span class="line">│   └── include   <span class="comment"># 头文件</span></span><br><span class="line">├── my_poject <span class="comment"># 项目【代码源文件】</span></span><br><span class="line">|   └── module_1</span><br><span class="line">│        ├── 1.cpp</span><br><span class="line">│        ├── 1.h</span><br><span class="line">│        ├── CMakeLists.txt</span><br><span class="line">|   └── module_2</span><br><span class="line">│        ├── 2.cpp</span><br><span class="line">│        ├── 2.h</span><br><span class="line">│        ├── CMakeLists.txt</span><br><span class="line">├── tools     <span class="comment"># 项目构建支持工具，如编译器</span></span><br><span class="line">├── scripts   <span class="comment"># 脚本文件，如预处理脚本</span></span><br><span class="line">├── config    <span class="comment"># 配置文件</span></span><br><span class="line">│   └── xxx.yml       </span><br><span class="line">│   └── yyy.yml   </span><br><span class="line">├── <span class="built_in">test</span>      <span class="comment"># 测试代码</span></span><br><span class="line">├── LICENSE   <span class="comment"># 版权信息</span></span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── build.sh  <span class="comment"># 构建项目的脚本</span></span><br><span class="line">├── .gitignore</span><br><span class="line">├── README.md <span class="comment"># 项目说明文件</span></span><br><span class="line">└── sample    <span class="comment"># 示例代码</span></span><br></pre></td></tr></table></figure><h4 id="编译复杂项目">编译复杂项目</h4><p>现在我们举一个复杂点的，<strong>多层级项目</strong>如何用CMake进行编译。</p><p>整个目录结构如下（为方便，进行了精简）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">|-- 3rdparty </span><br><span class="line">|   |-- include</span><br><span class="line">|   `-- lib</span><br><span class="line">|-- deploy </span><br><span class="line">|   |-- bin</span><br><span class="line">|   `-- lib</span><br><span class="line">|-- build</span><br><span class="line">|-- hello  <span class="comment"># 整个项目源码</span></span><br><span class="line">|   |-- module1</span><br><span class="line">|   |   |-- people.cpp</span><br><span class="line">|   |   |-- people.h</span><br><span class="line">|   |   `-- CMakeLists.txt</span><br><span class="line">|   |-- module2</span><br><span class="line">|   |   |-- bird.cpp</span><br><span class="line">|   |   |-- bird.h</span><br><span class="line">|   |   `-- CMakeLists.txt</span><br><span class="line">|   |-- hello.cpp</span><br><span class="line">|   |-- CMakeLists.txt</span><br><span class="line">|-- LICENSE</span><br><span class="line">|-- README.md</span><br><span class="line">|-- src</span><br><span class="line">|   `-- video</span><br><span class="line">|       `-- 1577414323962.mp4</span><br></pre></td></tr></table></figure><p>其中<code>hello</code>目录下各源文件如下：</p><ul><li><p><code>moule1/people</code> 相关源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*people.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;people.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">people_hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;people say : Hello Cpp!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*people.h*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">people_hello</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><code>moule2/bird</code> 相关源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*bird.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bird.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bird_hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;bird say : Hello Cpp!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*bird.h*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bird_hello</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><code>hello/hello.cpp</code> 源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;./module1/people.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;./module2/bird.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">people_hello</span>();</span><br><span class="line">    <span class="built_in">bird_hello</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最后给出各个目录下的CMakeLists.txt文件。</p><div class="tabs" id="tags"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tags-1">module1</button></li><li class="tab"><button type="button" data-href="#tags-2">module2</button></li><li class="tab"><button type="button" data-href="#tags-3">hello</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tags-1"><ul><li><p><strong>module1</strong></p><p>编译生成动态库<code>libmodule1.so</code> 。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录（module1）下的相关文件,并赋值给MODULE1_SRC</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. MODULE1_SRC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的源文件（MODULE1_SRC）生成库文件libmodule1.so</span></span><br><span class="line"><span class="comment"># 【注1】不需要写全libmodule1.so，只需写module即可，cmake会自动补全。</span></span><br><span class="line"><span class="comment"># 【注2】SHARED参数指定生成动态库（.so文件），不加参数默认生成静态库（.a）文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(module1 SHARED <span class="variable">$&#123;MODULE1_SRC&#125;</span>)</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tags-2"><ul><li><p><strong>module2</strong></p><p>编译生成动态库<code>libmodule2.so</code> ，基本同前。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录（module2）下的相关文件,并赋值给MODULE2_SRC</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. MODULE2_SRC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的源文件（MODULE1_SRC）生成库文件libmodule1.so</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(module2 SHARED <span class="variable">$&#123;MODULE2_SRC&#125;</span>)</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tags-3"><ul><li><p><strong>hello</strong></p><p>编译生成可执行文件<code>hello.out</code> ，然后链接<code>libmodule1.so</code>和 <code>libmodule2.so</code>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式：&lt;命令名&gt;(参数 参数值) ，中间参数空格隔开</span></span><br><span class="line"><span class="comment"># 设置项目名</span></span><br><span class="line"><span class="keyword">project</span>(helloDemo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置可执行文件保存路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/../deploy/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限定CMAKE最低版本</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">2.6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将module1和module2文件夹加入子目录,这样cmake就可以去其中查找编译</span></span><br><span class="line"><span class="comment"># 【注1】没有这个会报错，ld:找不到 -lmoudle1 和 -lmoudle2</span></span><br><span class="line"><span class="comment"># 【注2】这里只能用相对路径，不是hello项目下的路径，是指</span></span><br><span class="line"><span class="comment">#       build下的相对路径。</span></span><br><span class="line"><span class="comment">#       因为最后make是在build路径下，libmoudule1.so和</span></span><br><span class="line"><span class="comment">#       libmoudule2.so是分别保存在build/moudle1 和build/module2下</span></span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(./module1) </span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(./module2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索当前目录所有源代码文件，并赋值给PROJECT_ROOT_SRCS</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. PROJECT_ROOT_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加C++11特性</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-std=c++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【编译】</span></span><br><span class="line"><span class="comment"># add_executable 从一组源文件编译出一个可执行文件 </span></span><br><span class="line"><span class="comment"># 这里将$&#123;PROJECT_ROOT_SRCS&#125;中文件编译，生成可执行文件hello.out</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello.out <span class="variable">$&#123;PROJECT_ROOT_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【链接】</span></span><br><span class="line"><span class="comment"># 将目标文件与库文件进行链接，不显示指示文件后缀（如 module1.so），优先链接动态库</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(</span><br><span class="line">    hello.out </span><br><span class="line">    module2 </span><br><span class="line">    module1</span><br><span class="line">) </span><br></pre></td></tr></table></figure><p>特别的，如果你还引用了第三方库，还应该做如下修改。</p><blockquote><p>假设你引用的第三方库为<code>ffmpeg</code> ，相关头文件和库文件都放在<code>3rdparty</code>目录下。</p></blockquote><ul><li><p>增加ffmpeg库文件和头文件搜索路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 头文件搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>../<span class="number">3</span>rdparty/inclue)</span><br><span class="line"><span class="comment"># 库文件搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>../<span class="number">3</span>rdparty/lib)</span><br></pre></td></tr></table></figure></li><li><p>链接ffmepeg相应库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 链接ffmpeg库</span></span><br><span class="line"><span class="comment"># 将目标文件与库文件进行链接</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(</span><br><span class="line">    hello.out </span><br><span class="line">    module2 </span><br><span class="line">    module1</span><br><span class="line">    libavcodec.so   <span class="comment"># 显示指定动态库</span></span><br><span class="line">    libavdevice.so  </span><br><span class="line">    libavfilter.so</span><br><span class="line">    libavformat.so</span><br><span class="line">    libavutil.so</span><br><span class="line">    libpostproc.so</span><br><span class="line">    libswresample.so</span><br><span class="line">    libswscale.so</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>准备好所有的文件后，我们开始进行cmake构建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./build</span><br><span class="line">cmake ../hello &amp;&amp; make</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211210122630662.png" alt="image-20211210122630662"></p><p>在<code>bin</code> 下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../deploy/bin/hello.out </span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211210122942175.png" alt="image-20211210122942175"></p><p>👨‍💻 CMake相关介绍到此完结。</p><h3 id="写在最后">写在最后</h3><p>这篇博客主要介绍了编译的基本过程和原理，以及常用的编译工具（g++/Makefile/CMake）使用。</p><p>从构思大纲到最后初步完工大概用了五天，比最初预估的进度多花了一倍时间。最主要的原因就是中间我一直在删删改改，特别是写<u>编译过程初探</u>这一节：<strong>每写完一个版本，我就自己先看一遍再问自己：你真的能看明白吗</strong>？还是有些不理解的地方，就继续Google些资料看，直到把自己说服----至少文章逻辑上自恰了。同时也更深刻地体会到了：<strong>自己觉得懂了可能不是真的懂了，能把别人讲明白才可能算是懂了</strong>。</p><p>C++环境相关介绍就先告一段落了，接下来准备整理一下<strong>C++基础相关知识</strong>（有事情做的感觉还不错😀 ），回复完论文评审意见后尽快开始更新。</p><h3 id="更新记录">更新记录</h3><div class="timeline"><div class="timenode"><div class="meta"><p><p>2022-01-24 ：更新笔记</p></p></div><div class="body"><ol><li>增加可执行文件执行过程分析</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-12-20 ：更新笔记</p></p></div><div class="body"><ol><li>增加g++相关介绍</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-12-10 ：上传初稿</p></p></div><div class="body"><ol><li>第一次更新，发布初稿</li></ol></div></div></div><h3 id="参考资料">参考资料</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">g++，CMake和Makefile了解一下 ： https://zhuanlan.zhihu.com/p/55027085<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Linux下使用CMake编译C++：https://zhuanlan.zhihu.com/p/373256365<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">阮一峰--编译器的工作过程：http://www.ruanyifeng.com/blog/2014/11/compiler.html<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">符号解析：https://www.jianshu.com/p/2786533a34c9<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">计算机原理系列之七-链接过程分析：https://luomuxiaoxiao.com/?p=572<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">静态链接与动态链接在链接过程和文件结构上的区别：https://www.polarxiong.com/<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">gcc编译生成可执行文件的过程中发生了什么：https://blog.csdn.net/albertsh/article/details/89309107<a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C/C++中关于静态链接库(.a)、动态链接库（.so）的编译与使用：https://blog.csdn.net/qq_27825451/article/details/105700361<a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">cpp_new_features：https://github.com/0voice/cpp_new_features/blob/main/<a href="#fnref:9" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
          <category> C++环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 教程 </tag>
            
            <tag> C++环境搭建 </tag>
            
            <tag> CMake </tag>
            
            <tag> Makefile </tag>
            
            <tag> g++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++从零开始（零）</title>
      <link href="/p/62712/"/>
      <url>/p/62712/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🖋 《C++从零开始》系列，持续更新中…</p></blockquote><h3 id="写在前面">写在前面</h3><h4 id="为什么写这份笔记">为什么写这份笔记</h4><p>这个系列虽然名为：《C++从零开始》，但细细算来，我已经不止系统性地学过C++一次了。说来惭愧，每次目的也都是为了对付考试，取个不错的成绩而下点苦工罢了。</p><p>阴差阳错，<a href="https://hwh.zone/p/29708/">我明年即将入职腾讯，并以C++开始自己职业生涯的第一站</a>，正好在校还有段较清闲的时光，于是下笔写了这个C++系列笔记。<strong>一是分享记录、以讲代学</strong>，希望能对同样学习C++的读者有点帮助；<strong>二是好记性不如烂笔头</strong>，同时帮助自己时时记忆和温习；三是<strong>开源分享、贡献一点力量</strong>，中文（文字版）开源教程/笔记太少，希望能自己整理一份精炼也足够清晰的C++总结记录。</p><p>动笔前，我仔细构思了下该系列笔记的整体结构，下节会开始介绍具体介绍。</p><ul><li>特别的，这个系列处于初建状态，文章可能会由于更新等原因和之前版本有所不同；</li><li>所有的文章更新记录变化，可以在第三大节：<strong>更新记录</strong>中查看。</li></ul><h4 id="谁适合阅读本文">谁适合阅读本文</h4><p>这个系列虽然叫做“<u>从零</u>开始”，但如果你真的零基础，阅读了前面《环境搭建》两篇文章便可能要开始怀疑自己是不是适合做程序员了。</p><p>当然作者并非有意让你感到这种沮丧的情绪，一是希望<u>以讲代学</u> 的方式帮助自己和读者提高C++水平，二是因为希望这个系列的阅读人群：</p><ul><li>具有一定编程语言基础，比如C、Python、Java，有C++最好；</li><li>希望进一步提高、巩固C++基础，看完本系列能达到校招大厂C++至少“及格线”水平（因此本系列也插入了很多“八股文”相互验证）。</li></ul><p>如果你真的需要更基础的教程，但因为作者还没有在中文互联网找到比较好的<u>开源文字教程</u>，英文教程倒是找到不少（不禁再次感慨英文的重要性），因此对于零基础的同学，分别推荐英、中（文字）教程一份：</p><ul><li>英文：<a href="learncpp">强烈推荐—learncpp</a>，英文如果阅读吃力建议安装谷歌翻译插件；</li><li>中文：<a href="https://cloud.tencent.com/edu/learning/course-1844-21311">腾讯云C++教程</a>，偏基础，适合英文阅读过于困难又无基础的同学。</li></ul><h3 id="总目录">总目录</h3><blockquote><p>⏰ 最后更新时间：<code>2022/02/11 17:00</code> 。</p></blockquote><p>从零开始系列暂分为三部曲：《C++篇》、《Linux/C++系统编程篇》、《网络编程篇》，以及可能补充的《C++开源分析》部分。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><strong>文章</strong></th><th style="text-align:center"><strong>备注</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>C++篇</strong></td><td style="text-align:center"><a href="https://hwh.zone/p/18652/">C++从零开始（一）：环境搭建（上）VSCode远程开发</a></td><td style="text-align:center">✔️更新完成</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://www.hwh.zone/p/2834">C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门</a></td><td style="text-align:center">✔️更新完成</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://www.hwh.zone/p/26224">C++从零开始（三）：务实基础（上）快速入门</a></td><td style="text-align:center">✔️更新完成</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://www.hwh.zone/p/24237">C++从零开始（四）：务实基础（中）指针和引用</a></td><td style="text-align:center">✔️更新完成</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://www.hwh.zone/p/51595">C++从零开始（五）：务实基础（下）之函数</a></td><td style="text-align:center">✔️更新完成</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://www.hwh.zone/p/6587">C++从零开始（六）：务实基础（下）复合类型及转换</a></td><td style="text-align:center">✔️更新完成</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://www.hwh.zone/p/17506">C++从零开始（七）：面对对象（上）快速入门</a></td><td style="text-align:center">✔️更新完成</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://www.hwh.zone/p/43924">C++从零开始（八）：面对对象（中）运算符重载</a></td><td style="text-align:center">✔️更新完成</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://www.hwh.zone/p/60158">C++从零开始（九）：面对对象（下）继承与虚函数</a></td><td style="text-align:center">✔️更新完成</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://www.hwh.zone/p/51012">C++从零开始（十）：C++进阶（上）模板</a></td><td style="text-align:center">✔️更新完成</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://www.hwh.zone/p/17467">C++从零开始（十一）：C++进阶（下）STL</a></td><td style="text-align:center">✔️更新完成</td></tr><tr><td style="text-align:center"><strong>Linux/C++篇</strong></td><td style="text-align:center"><a href="https://www.hwh.zone/p/45495">C++从零开始（十二）：Linux系统编程入门</a></td><td style="text-align:center">✔️更新完成</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（十三）：Linux系统编程之文件IO</a></td><td style="text-align:center">🔨 更新ing</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（）：Linux/C++之</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（）：Linux/C++之</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（）：Linux/C++之</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>网络编程篇</strong></td><td style="text-align:center">未定</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>C++开源</strong></td><td style="text-align:center"><a href="https://hwh.zone/p/37224/">C++从零开始（开源）：一文读懂muduo</a></td><td style="text-align:center">✔️更新完成</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（）：C++开源之实现自己的ffmpeg转码器</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（）：C++开源之SRS源码分析</a></td><td style="text-align:center"></td></tr></tbody></table><h3 id="写在最后">写在最后</h3><blockquote><p>⏲ 更新时间：<code>2021/12/05 17:00</code> 。</p></blockquote><p>从玩到无聊开始学习到十二月初给自己挖了个大坑，<code>play hard study hard</code> 居然不知不觉成了我的行为习惯。当然，玩到胖了十多斤并不是我本意…</p><p>借此机会，提前许下几个新年愿望（是的，就是这么突然）：</p><ul><li>三个月内顺利更新完这个系列大部分文档；</li><li>多花点时间学习，不能过分玩乐；</li><li>少熬夜，多喝茶；</li><li>如意考试顺利。</li></ul><p>敬请期待~ 😋 （顺便分享一下<s>我的新插件</s>一首应景的小诗）</p><div class='poem'><div class='poem-title'>[飞鸟集]</div><div class='poem-author'>[泰戈尔]</div><p>闲暇在动作时</p><p>便是工作。<br>静止的海水荡动时</p><p>便成波涛。</p></div><h3 id="更新记录">更新记录</h3><div class="timeline"><div class="timenode"><div class="meta"><p><p>2022-03-10：文章更新</p></p></div><div class="body"><ol><li><a href="https://hwh.zone/p/37224/">C++从零开始（开源）：一文读懂muduo</a>更新完成</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2022-02-19：文章更新</p></p></div><div class="body"><ol><li><a href="https://www.hwh.zone/p/17467">C++从零开始（十一）：C++进阶（下）STL</a>更新完成</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2022-02-11：文章更新</p></p></div><div class="body"><ol><li><a href="https://www.hwh.zone/p/51012">C++从零开始（十）：C++进阶（上）模板</a>更新完成</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2022-02-08：文章更新</p></p></div><div class="body"><ol><li><a href="https://www.hwh.zone/p/60158">C++从零开始（九）：面对对象（下）继承与虚函数</a> 更新完成</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2022-01-31：文章更新</p></p></div><div class="body"><ol><li><a href="https://www.hwh.zone/p/43924">C++从零开始（八）：面对对象（中）运算符重载</a> 更新完成</li><li>🙂 新年快乐！</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2022-01-27 ：文章更新</p></p></div><div class="body"><ol><li><a href="https://www.hwh.zone/p/17506">C++从零开始（七）：面对对象（上）快速入门</a>更新完毕</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2022-01-22 ：文章更新</p></p></div><div class="body"><ol><li><a href="https://www.hwh.zone/p/6587">C++从零开始（六）：务实基础（下）复合类型及转换</a>更新完毕</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2022-01-18 ：文章更新</p></p></div><div class="body"><ol><li><a href="https://www.hwh.zone/p/26224">C++从零开始（三）：务实基础（上）之快速入门</a>更新完毕</li><li><a href="https://www.hwh.zone/p/24237">C++从零开始（四）：务实基础（中）之指针和引用</a> 更新完毕</li><li><a href="https://www.hwh.zone/p/51595">C++从零开始（五）：务实基础（下）之函数</a> 更新完毕</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-12-10 ：文章更新</p></p></div><div class="body"><ol><li><a href="https://www.hwh.zone/p/2834">C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门</a>更新完毕</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-12-06 ：文章更新</p></p></div><div class="body"><ol><li><a href="https://hwh.zone/p/18652/">C++从零开始（一）：环境搭建（上）之VSCode远程开发</a> 更新完毕</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-12-05 ：第一次更新</p></p></div><div class="body"><ol><li>初步确定《C++从零开始系列》大纲</li><li>即将更新：<code>C++基础系列</code></li></ol></div></div></div><h2 id="参考资料">参考资料</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">阿秀的求职笔记：https://interviewguide.cn/<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">zavar开源地址: https://github.com/zyearn/zaver<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">ffmpeg-trancode开源地址: https://github.com/leichn/exercises/tree/master/source/ffmpeg/ffmpeg_transcode<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">SRS开源地址：https://github.com/ossrs/srs<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">腾讯云C++教程：https://cloud.tencent.com/edu/learning/course-1844-21296<a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github Pages快速打造属于自己的网站</title>
      <link href="/p/56326/"/>
      <url>/p/56326/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>⚠️ 阅读本文前，你需要具备：</p><ol><li>会打字</li><li>熟练掌握Ctrl+C/Ctrl+V</li><li>或许有一点的网络知识</li></ol><p>如果操作遇到困难，可在文章下方进行留言😃。</p></blockquote><h3 id="前言">前言</h3><blockquote><p>迫不及待？建站效果实时预览：<a href="https://hwh.zone/">royhuang‘s blog</a> 。</p></blockquote><div class="tag link"><a class="link-card" title="royhuang's blog" href="https://www.hwh.zone"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">royhuang's blog</p><p class="url">https://www.hwh.zone</p></div></a></div><p>第一次建站时还是三年前用<strong>WordPress</strong>搭建，网站放在腾讯云VPS上运行。因为机器配置较低比较卡，有次暴躁debug把整个服务器remake了，不了了之。再后面又因为对<strong>Java Web开发</strong>比较感兴趣，折腾了SpringBoot Web开发和前后端相关知识，打算自己<strong>完全前后端自主开发</strong>一个博客。因为主客观各种原因，做了一个残次品，阴差阳错最后要以C++开始自己职业生涯第一站，也没有最终完善。</p><p>趁着这段时间，使用<strong>Hexo+Github Pages</strong> 作为最终建站方案折腾了几天，总体来说效果还比较满意。为了后来人少踩点坑，同时为自己糟糕的记忆留点回忆，特此记录。</p><h3 id="主流建站方式比较">主流建站方式比较</h3><p>在正式开始前，我们不妨先来分析下主流建站方式，做到心中有数。自然，此节也可以略过。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">建站难度</th><th style="text-align:center">所需知识</th><th style="text-align:center">定制化程度</th><th style="text-align:center">适合人群</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>WordPress</strong></td><td style="text-align:center">⭐️⭐️</td><td style="text-align:center">Linux、Git基本知识</td><td style="text-align:center">一般</td><td style="text-align:center">Web开发小白人群</td><td style="text-align:center">之前写的教程：<a href="https://blog.csdn.net/hwh1996/article/details/90666775">教练,我想建网站！</a></td></tr><tr><td style="text-align:center"><strong>Java Web</strong></td><td style="text-align:center">⭐️⭐️⭐️⭐️</td><td style="text-align:center">Web前后端开发知识，多且杂</td><td style="text-align:center">非常高，前后端代码全栈开发</td><td style="text-align:center">Java Web开发人员</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>Hexo + Github Pages</strong></td><td style="text-align:center">⭐️⭐️</td><td style="text-align:center">Linux、Git基本知识</td><td style="text-align:center">较高，基于配置文件修改较方便</td><td style="text-align:center">Web开发小白人群</td><td style="text-align:center"><strong>不需要备案域名</strong></td></tr><tr><td style="text-align:center"><strong>Hexo + 腾讯云</strong></td><td style="text-align:center">⭐️⭐️</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td><td style="text-align:center"><strong>域名需要备案</strong>，但网站访问速度会变快很多</td></tr></tbody></table><p>根据以上，我们可以根据不同情况进行选择：</p><ul><li><p><strong>Java Web全栈搭建</strong>？</p><ul><li>适合Java Web为技术栈的<strong>专业人员</strong>，可以作为个小项目；</li><li>但如果你<strong>并非专业</strong>的Java Web开发人员，不想学习复杂的Java Web体系，但是又具备开发基础知识，想搭建一个漂亮的博客：<strong>WordPress 和 Hexo是你不二的选择</strong>。</li></ul></li><li><p><strong>WordPress还是Hexo</strong><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="从wordpress到hexo：https://www.wenjinyu.me/zh/from-wordpress-to-hexo-my-blog-should-have-been-like-this/">[3]</span></a></sup>  ？</p><p>作为都体验过的人，我说说一下自己比较主观的对比：</p><ul><li>WordPress优点：很简单，适合特别小白的同学；</li><li>WordPress缺点：占用资源多，<strong>响应慢</strong>；<strong>不支持原生markdown</strong>（每次要导出.html太痛苦了）；主题也不够合心意（不美观）。</li></ul><p>所以我自己（有开发基础）还是推荐使用Hexo。</p></li><li><p><strong>Hexo + Github Pages 还是 Hexo + 腾讯云</strong>?</p><ul><li><strong>Github Pages 托管网站</strong>：因为服务器在国外（Github），域名无需备案，但访问速度会比较慢，也无需购买云服务器；</li><li><strong>腾讯云托管网站</strong>：需要购买云服务器（或COS），且域名需要备案，但访问速度会很快。</li></ul></li></ul><p>因为本文考虑<strong>更低成本，我也比较懒不想备案，访问速度虽然慢点但还能接受</strong>，所以采用Hexo + Github Pages作为最终的建站方案。</p><p>好了，现在让我们开始激动人心的环节吧，动手搭建自己的网络快乐小窝。</p><h3 id="Hexo-Github-Pages">Hexo + Github Pages</h3><p>Hexo是一款基于Node.js的静态博客框架，<strong>依赖少易于安装使用</strong>，可以方便的生成静态网页<strong>托管在GitHub Pages上</strong>（<u>无需云服务器</u>），是搭建博客的首选框架<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Hexo 知乎教程：https://zhuanlan.zhihu.com/p/26625249">[2]</span></a></sup>。</p><p>用大白话来说就是：</p><ul><li>Hexo：用来将我们写的文章，渲染<strong>生成本地生成静态网页</strong> ，但只有你自己能看到；</li><li>Github Pages : 将Hexo生成的静态网页，<strong>部署托管到云服务器（Github Pages，VPS，COS均可）上</strong>，这样别人也可以访问。</li></ul><h4 id="快速开始">快速开始</h4><blockquote><p>以下主要操作均已在虚拟机中经过二次验证。</p></blockquote><h5 id="准备工作：Github-Git">准备工作：Github &amp; Git</h5><ol><li><p>创建Github个人仓库</p><p>⚠️ 注意命令方式必须为：<code>你的Github用户名.github.io</code> ，这种形式。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202204544684.png" alt="image-20211202204544684"></p><ul><li><p><strong>登陆用户名和昵称分不清</strong>?你的个人主页，下面红框所示才是你的用户名。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211209194854716.png" alt="image-20211209194854716"></p></li><li><p>我已创建过该项目，故显示重复</p></li></ul></li><li><p>安装Git</p><p><a href="https://git-scm.com/downloads">Git下载地址</a> , 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，则Git安装成功。</p><p>同时还需配置基本Github相关信息，主要是用户名和邮箱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Wanghui-Huang&quot;</span>    </span><br><span class="line">$ git config --global user.email <span class="string">&quot;380141202@qq.com&quot;</span></span><br></pre></td></tr></table></figure><p>本文默认你具备基本Git相关知识，故不再赘述，如果不具备可以学习：<a href="https://hwh.zone/p/43848/">Git基础笔记</a> 。</p></li><li><p>安装Node.js</p><blockquote><p>Hexo基于Node.js，自然需要安装相关组件。</p></blockquote><p>下载 <a href="https://nodejs.org/en/download/">Node.js </a>  , 一直默认安装即可（不要随意勾选）。</p><p>安装成功后，分别输入 <code>node -v</code> &amp; <code>npm -v</code>，出现以下版本信息则安装成功：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202211811979.png" alt="image-20211202211811979"></p></li></ol><h5 id="搭建Hexo">搭建Hexo</h5><ol><li><p>新建文件夹</p><p>我们在合适的路径新建一个文件夹，命名随意，我命名为：<code>www.hwh.zone</code>。</p></li><li><p>安装Hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br></pre></td></tr></table></figure></li><li><p>初始化博客</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./www.hwh.zone/</span><br><span class="line">hexo init blog</span><br></pre></td></tr></table></figure></li><li><p>本地测试验证</p><blockquote><p>⚠️ 注意以下命令全部都在：<code>./www.hwh.zone/blog</code> 路径下执行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./blog/</span><br><span class="line">hexo new test_my_site  <span class="comment"># 生成一篇新文章</span></span><br><span class="line">hexo g  <span class="comment"># 生成静态文件（网页）</span></span><br><span class="line">hexo s  <span class="comment"># 本地生成静态网站预览</span></span><br></pre></td></tr></table></figure><p>执行完毕后，输入：<a href="http://localhost:4000">http://localhost:4000</a> ，出现以下页面则生成成功：</p><blockquote><p>如果<code>hexo s</code> 执行成功，浏览器却打不开，通常是端口（4000）被占用。可以设置hexo使用别的端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server -p 4001</span><br></pre></td></tr></table></figure><p>然后输入：<a href="http://localhost:4001">http://localhost:4001</a> ，重新打开即可。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/53_21AIX_V3NIT9L0O6_H$8.png" alt="img"></p><p>现在你已经初步搭建好了自己的网站，现在让我们开始<strong>发布自己的网站</strong>，让更多人看到~</p></li><li><p>配置远程推送信息</p><p>在 <code>./www.hwh.zone/blog</code> 路径下，找到<strong>主配置文件：__config.yml</strong> ：</p><ul><li>[注1]：因为这个文件<strong>很重要</strong>，特附图示例 。</li><li>[注2]：该配置文件对<strong>缩进</strong>等都严格要求，建议用IDE打开编辑（比如VScode），不易出错。</li></ul><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202214234731.png" alt="image-20211202214234731" style="zoom:80%;" /><p>在文件最下方配置相关信息：</p><ul><li>⚠️ 注意： <code>:</code> 后面需要留一个空格 ，repo地址最后需要带上 <code>.git</code> !</li></ul><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202214436348.png" alt="image-20211202214436348" style="zoom:80%;" /></li><li><p>安装Git插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>写一篇自己的文章</p><blockquote><p><code>_posts</code>  路径下的 <code>md</code> 文件，会被Hexo自动解析、渲染生成网页。我们所有的博客都是放在这个目录的。</p></blockquote><p>我们在：<code>www.hwh.zone\blog\source\_posts</code> 路径下，写一篇属于自己的文章：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202220312686.png" alt="image-20211202220312686"></p></li><li><p>开始发布网站</p><p>以上命令如果不出错，依次执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清除缓存网页</span></span><br><span class="line">hexo clean  </span><br><span class="line"><span class="comment"># 生成静态网页</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment"># 推送发布网站，要输入Github账号和token（注意不是密码，github从上月开始已经使用token验证身份，生成token可参考：https://zhuanlan.zhihu.com/p/38800965）</span></span><br><span class="line">hexo d  </span><br></pre></td></tr></table></figure><p>🐛 解决BUG：<strong>OpenSSL SSL_read：Connection was reset，erron 10054</strong>。</p><ul><li><p>第一种情况：未解除SSL验证</p><ol><li><p>打开<code>git</code>，切换到<code>www.hwh.zone/blog</code> 目录下</p></li><li><p>取消SSL验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>第二种情况：开了小飞机，让小飞机重新换个服务器重新连接。</p></li></ul></li><li><p>欣赏你自己的网站~！</p><p>现在我们在浏览器输入：<code>Wanghui-Huang.github.io</code> , 可以看到我们第一篇博客已经正式发布了！🤙</p><p>愉快的多欣赏一下吧~</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202220438110.png" alt="image-20211202220438110"></p></li><li><p>TIPS</p><p>💡 一般我们发布文章（或修改主题CSS样式等）, 流程如下：</p><ul><li><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code> ，打开 <code>localhost:4000</code>本地预览；</li><li><strong>本地</strong>进行修改，e.g. 文章增改、CSS样式修改；</li><li><strong>F5刷新下网页</strong>即可看到修改后的文章或样式，一般<strong>不需要</strong>重新执行<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code> ；</li><li>但是如果<strong>出现刷新无效</strong>，此时最好重新执行下以上三个命令；</li><li>最后再执行<code>hexo d</code> , 发布文章。</li></ul></li></ol><h4 id="主题-美化：以Butterfly为例">主题&amp;美化：以Butterfly为例</h4><p>hexo的众多开发者，无私提供了非常多主题供我们进行主题美化。去<a href="https://hexo.io/themes/">Hexo官网</a>或在<a href="https://github.com/search?q=hexo+theme">Github-hexo theme</a> ，搜索一个你喜欢的主题：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202221852344.png" alt="image-20211202221852344"></p><p>在这里，我使用主题 <a href="https://github.com/jerryc127/hexo-theme-butterfly">Github-Butterfly</a> ，作为最终的选择。</p><h5 id="快速开始-2">快速开始</h5><ol><li><p>下载主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>⚠️ 下载完毕后，文件重命名为 <code>butterfly</code> ， 放在 <code>www.hwh.zone\blog\themes</code> 目录下。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202222937528.png" alt="image-20211202222937528"></p></li><li><p>应用主题</p><p>在Hexo根目录下主配置文件 <code>_config.yml</code> , 进行配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure></li><li><p>安装必要插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure></li><li><p>测试查看</p><p>重新生成静态网页：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>打开 ：<a href="http://localhost:4000">http://localhost:4000</a>  , 可看到主题已经被成功替换。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/UP$@K0WX1%602JNDTP%60~DLFZM.png" alt="img" style="zoom:80%;" /></li></ol><h5 id="基本配置">基本配置</h5><blockquote><p>如果你想参考我的配置信息，可在进行<strong>附录</strong>中查看。</p></blockquote><p>在这一节我们将进行主题的基本信息设置，包括但不限于：</p><ul><li>网站基本信息设置</li><li>背景图片设置</li><li>目录相关设置</li><li>…</li></ul><p>但是在本文<strong>并不准备将以上设置过程详细列出</strong>，因为官网对这些的描述已经非常清晰和简洁。因此，<strong>强烈建议</strong>你参考官网文档：<a href="https://butterfly.js.org/posts/21cfbf15/">butterfly主题配置官方文档</a> ，根据个人喜欢进行这些基本设置。</p><p>在这里将主要记录：<strong>官网文档未提及的优化</strong>，以及根据<strong>官网文档配置时遇到的问题解决办法</strong>。</p><h5 id="Markdowm渲染优化">Markdowm渲染优化</h5><p>本节涉及：数学公式、脚注、表情、标题大小等设置。</p><div class="tabs" id="markdown"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#markdown-1">数学公式</button></li><li class="tab"><button type="button" data-href="#markdown-2">表情</button></li><li class="tab"><button type="button" data-href="#markdown-3">脚注</button></li><li class="tab"><button type="button" data-href="#markdown-4">标题大小</button></li><li class="tab"><button type="button" data-href="#markdown-5">标签外挂</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="markdown-1"><p>按照 <a href="https://butterfly.js.org/posts/ceeb73f/#Math-%E6%95%B8%E5%AD%B8">官方文档</a> , 进行配置：</p><ol><li><p>修改<strong>主题配置文件</strong>，加载katex.min.css</p><blockquote><p>⚠️ per_page 属性不能设置true，否则会出现bug：公式被渲染两次。</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">katex:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># true 表示每一頁都加載katex.js</span></span><br><span class="line">  <span class="comment"># false 需要時加載，須在使用的Markdown Front-matter 加上 katex: true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span>   <span class="comment"># 不要选择为true！！</span></span><br><span class="line">  <span class="attr">hide_scrollbar:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后在需要打开数学公式渲染的文章，开头设置：<code>katex: true</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202231613955.png" alt="image-20211202231613955"></p></li><li><p>安裝 hexo-renderer-markdown-it</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save <span class="comment"># 如果有安裝這個的話，卸載</span></span><br><span class="line">npm un hexo-renderer-kramed --save <span class="comment"># 如果有安裝這個的話，卸載</span></span><br><span class="line"></span><br><span class="line">npm i hexo-renderer-markdown-it --save <span class="comment"># 需要安裝這個渲染插件</span></span><br><span class="line">npm install @neilsustc/markdown-it-katex --save <span class="comment">#需要安裝這個katex插件</span></span><br></pre></td></tr></table></figure></li><li><p>修改Hexo根目录配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">markdown:</span><br><span class="line">  plugins:</span><br><span class="line">    - plugin:</span><br><span class="line">      name: <span class="string">&#x27;@neilsustc/markdown-it-katex&#x27;</span></span><br><span class="line">      options:</span><br><span class="line">        strict: <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-2"><p>表情插件配置过程如下：</p><ol><li><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install markdown-it-emoji --save</span><br></pre></td></tr></table></figure></li><li><p>根目录配置文件添加插件</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202233532272.png" alt="image-20211202233532272"></p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-3"><p>脚注直接安装插件即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-reference --save</span><br></pre></td></tr></table></figure><p>如果安装后，本地（typora）可以正确渲染，hexo无法正确渲染：多半是脚注使用出现<strong>语法错误</strong>。</p><ul><li>在正文中：严格按照[^1] 写入脚注，<strong>不要用任何空格</strong>！</li><li>在链接中：严格按照[^1]: 写入引用链接，<strong>不要用任何空格</strong>！</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-4"><p>butterfly主题标题大小默认的过小，不易于和正文进行区分。</p><p>为此，我们需要：</p><ol><li>找到<code>\www.hwh.zone\blog\themes\butterfly\source\css\_third-party</code> 路径下的<code>normalize.min.css</code> 文件</li><li>手动设置 h1~h5标题大小<br><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202234443112.png" alt="image-20211202234443112"></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-5"><p>标签外挂插件 <code>Tag Plugins Plus</code> ，提供了丰富的<strong>markdown文件编写美化</strong>：</p><ul><li>时间轴</li><li>各种卡片</li><li>音频、视频插入</li><li>…</li></ul><p>可以让你的文章看起来美观许多，具体配置请参考：<a href="https://akilar.top/posts/615e2dec/">Tag Plugins Plus官网</a> 。</p><p>文档清晰简洁，这里不再赘述。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h5 id="支持评论功能">支持评论功能</h5><p>官网文档虽然给了很多种设置的评论方式，但就我自己尝试而言，<strong>Utterances和Twikoo</strong>属于比较方便的方式。</p><p>Utterances主要优点：</p><ul><li>和Gitalk类似，但不需要过多的权限设置；</li><li>相比Facebook Comments 等无需翻墙；</li><li>相比Disqus等UI更简洁美观。</li></ul><p>唯一美中不足的便是<strong>不能匿名评论</strong>，留言必须要用Github账号先登录。<strong>Twikoo</strong>在下文进行介绍。</p><div class="tabs" id="tags"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tags-1">Utterances（免费）</button></li><li class="tab"><button type="button" data-href="#tags-2">Twikoo（付费）</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tags-1"><p>以下是Utterances设置过程：</p><ol><li><p>在Github创建一个public的项目</p><p>不再赘述过程，我使用的是：<a href="https://github.com/Wanghui-Huang/gittalk">https://github.com/Wanghui-Huang/gittalk</a> ，这个项目。</p></li><li><p>安装 utterances</p><p>点击：<a href="https://github.com/apps/utterances">https://github.com/apps/utterances</a> ，安装app（右上方处<code>Install</code>按钮）。</p><p>安装成功后，会出现下面<code>Configure</code>按钮：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203105709777.png" alt="image-20211203105709777"></p></li><li><p>设置相关信息</p><p>点击<code>Configure</code>按钮，进入设置界面，注意<strong>红框处</strong>相关信息设置：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203105915848.png" alt="image-20211203105915848"></p><p>设置完毕后保存。</p></li><li><p>主题文件配置</p><p>修改主题配置文件：repo修改为你刚刚创建的repo，形式为 <code>你的用户名.项目名</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203110208806.png" alt="image-20211203110208806"></p><p>继续修改配置文件，指定评价插件名：<br><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203110412952.png" alt="image-20211203110412952"></p></li><li><p>测试 &amp; bug解决</p><p>选择任意一篇文章，可以看到评论框已经顺利出现：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203110741161.png" alt="image-20211203110741161"></p><p>经过实际测试，依旧会出现评论框无法显示的问题：</p><ul><li>我的问题是因为使用了自己的域名，<code>https</code>不安全便会出现这个问题；</li><li>如何使用自己的域名，后续小节有详细教程 &amp; 踩坑记录。</li></ul><p>可以在 Github项目：<code>Wanghui-Huang.github.io</code> → <code>Setting</code>→<code>Pages</code>   ，勾选<code>Enforce HTTPS</code>  ：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203111826078.png" alt="image-20211203111826078"></p><p>三连重新生成静态网页：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>便可以看到评论框已经正确显示了。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tags-2"><p>虽然Utterances已经足够简洁优秀且免费，但是Twikoo基于腾讯云开发，<strong>在国内速度很快&amp;支持匿名</strong>，价格也足够实惠（包年大约6元/月）。另一方面，支持下东家业务最后选择了这个方案。</p><ol><li><p>腾讯云函数配置</p><p>这一部分看<a href="https://twikoo.js.org/quick-start.html">官网文档</a>即可，很详细不再赘述。</p></li><li><p>Butterfly主题配置</p><p>修改 <code>主題配置文件</code> ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">twikoo:</span></span><br><span class="line">  <span class="attr">envId:</span> <span class="string">blog-comments-5g2cfs*******</span>  <span class="comment"># 腾讯云函数配置完后的id</span></span><br><span class="line">  <span class="attr">region:</span> <span class="string">ap-shanghai</span>  <span class="comment"># 默认上海 </span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span>        <span class="comment"># 显示文章浏览数</span></span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><p>静态网页生成三连，便可以看到已经生成成功了：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203160342989.png" alt="image-20211203160342989"></p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="其它补充">其它补充</h4><blockquote><p>链接太长不好分享？</p><p>想要一个属于自己的漂漂域名？</p><p>网站发布后本地图片全挂？</p><p>…</p></blockquote><p>在这里我们依次进行解决各种问题，让你的网络小窝看起来更加的专业。</p><h5 id="使用短连接">使用短连接</h5><p>hexo 默认生成文章<strong>长链接具有以下几个缺点</strong>：</p><ol><li>如果文章名包含中文，将会被转码，链接不雅观且长；</li><li>长链接不利于搜索引擎收录；</li><li>长链接不方便分享给他人。</li></ol><p>因此，参考<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Hexo-abbrlink插件生成唯一文章链接：https://zhuanlan.zhihu.com/p/112318081">[4]</span></a></sup>，我们利用Hexo-abbrlink插件，生成唯一文章短链接。</p><ol><li><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure></li><li><p>修改根目录配置文件</p><ul><li><code>url</code>：你的域名 ，如果是Github Pages命令方式为 <code>https://你的用户名.github.io</code></li><li><code>permalink</code>：按下图修改</li><li><code>permalink_defaults</code>：注释掉</li></ul><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203120905856.png" alt="image-20211203120905856"></p></li><li><p>三连重新生成</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></li><li><p>测试</p><p>生成完毕后，可以看到，在每一篇文章开头，自动多出了以下属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">abbrlink:</span> <span class="number">56326</span>  <span class="comment"># 这个id每篇文章都不一样</span></span><br></pre></td></tr></table></figure><p>文章链接也变成了短链接的形式：<br><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203121301172.png" alt="image-20211203121301172"></p></li></ol><h5 id="使用图床">使用图床</h5><p>使用markdown最头疼的地方，估计就是图片问题了：文章图片通常保存在<strong>本地</strong>，发布网站还是分享给他人通常还需要单独保存图片。显然，这一点也不cool。</p><p>幸运的是，我们可以使用<strong>图床</strong>，将图片通通保存在<strong>云端</strong>，本地只需像如下引用个链接即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![image-20211203121301172](https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203121301172.png)</span><br></pre></td></tr></table></figure><p>特别的，配合<a href="https://typora.io/">Typora</a>，所有本地图片可以自动上传到云端，可以说是很方便了。</p><p>因此，本文参考<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Typora+PicGo+腾讯云COS实现图片上传功能：https://www.daimajiaoliu.com/daima/56a7c8410d4cc09">[5]</span></a></sup>，使用<strong>Typora配合腾讯云COS存储搭建图床</strong>。</p><blockquote><p><strong>为什么选择要付费的腾讯云COS？</strong></p><p>在这之前我也选择了其它的免费图床，使用体验不太佳：</p><ul><li>速度很慢，而且限制一天上传的数量和频率，有时候需要集中上传本地文件的大量图片便很不友好了；</li><li>腾讯云COS虽然付费，但是价格很便宜，10元可以租10G/年。</li></ul><p>因此，最终我还是选择了腾讯云COS存储作为图床。</p></blockquote><ol><li><p>下载Typora</p><p>下载地址：<a href="https://pc.qq.com/search.html#!keyword=typora">腾讯云高速下载</a> ，默认安装即可。</p></li><li><p>下载PicGo</p><p>下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases">官网下载</a> ，默认安装即可。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203123433623.png" alt="image-20211203123433623"></p></li><li><p>腾讯云创建COS存储</p><p>进入腾讯云对象存储，在存储桶列表中点击创建存储桶：</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/736d7f4664f36fc1d2b286ac0859e814.png" alt="在这里插入图片描述" style="zoom:80%;" /><p>设置存储信息如下：</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/56fdfdd3b03104661de1abc72ea521fe.png" alt="在这里插入图片描述" style="zoom:80%;" /></li><li><p>密钥管理</p><p>密钥需要等会儿在配置文件中用到，因此我们需要提前设置好。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/604771ab575b32e30683e83e058c49a5.png" alt="在这里插入图片描述"></p><p>如果没有密钥，则新建密钥：</p><ul><li>记录以下：<strong>SecretID 和 SecretKey</strong>，等下要用到。</li></ul><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/a0c7902b4f48200a071bf216d574aba4.png" alt="在这里插入图片描述"></p></li><li><p>配置PicGo</p><p>打开PicGo后，图片上传选择腾讯云COS，然后进行以下设置：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1cf828eadf1b5b060fdd6f9337afa205.png" alt="在这里插入图片描述"></p><p>建议域名信息也进行设置：配置管理→域名信息→访问域名，复制粘贴在最后一栏域名框中。</p></li><li><p>测试PicGO</p><p>在左上【上传区】，任意拖拽一张图片，如果上传成功则说明配置成功。</p></li><li><p>配置Typora</p><p>打开Typora：<code>文件</code>→<code>偏好设置</code>→<code>图像</code>：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/5b009f6cfef200d2b3ef58655730777d.png" alt="在这里插入图片描述"></p></li><li><p>测试Typora配置</p><ol><li>在右侧栏中左下角，找到【验证图片上传选项】，测试是否成功；</li><li>打开typora，任意在文章中粘贴一张本地图片，看是否会<strong>自动上传</strong>。</li></ol><p>以上成功，便可以愉快的开始编写文章了，开始你的大文豪生活了。</p></li></ol><h5 id="使用自己的域名">使用自己的域名</h5><blockquote><p><code>xxxxx.github.io</code> 看起来丑丑的，怎么拥有一个自己的漂漂域名呢？</p></blockquote><ol><li><p>买一个属于自己的域名</p><p>点击：<a href="https://dnspod.cloud.tencent.com/">腾讯云域名注册</a> ，注册一个自己的域名。</p></li><li><p>实名认证</p><p>参考官方文档：<a href="https://cloud.tencent.com/document/product/242/6707">域名实名认证</a> , 不进行实名认证可能无法进行正常域名解析。</p></li><li><p>域名解析设置</p><p>进入腾讯云解析设置：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203130549613.png" alt="image-20211203130549613"></p><p>分别添加以下解析记录：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203130911464.png" alt="image-20211203130911464"></p><ul><li>配置CNAME：我的域名 <code>www.hwh.zone</code>  可以解析到原本域名<code>Wanghui-Huang.github.io</code>  ，这个时候 <code>www.hwh.zone</code>相当是个别名，也就是<strong>暴露给别人看到的名字</strong>。</li><li>配置A记录：可以把域名<code>www.hwh.zone</code> <strong>直接解析</strong>到 <code>Github IP地址</code> （二次保障能解析到Github IP地址）。</li></ul><p><strong>不理解CNAME作用？有了A记录解析为什么还要CNAME</strong>？可参考：<a href="https://www.zhihu.com/question/22916306">cname记录是什么？他存在的意义是什么？</a></p></li><li><p>申请免费SSL证书</p><p>参考官方文档：<a href="https://cloud.tencent.com/document/product/400/6814">域名型（DV）免费 SSL 证书申请流程</a></p></li><li><p>Github Page设置</p><p>在 Github项目：<code>Wanghui-Huang.github.io</code> → <code>Setting</code>→<code>Pages</code>   ，设置你自己的域名  ：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203132157159.png" alt="image-20211203132157159"></p></li><li><p>创建CNAME文件</p><p>进入本地博客文件夹目录，例如我的：<code>www.hwh.zone\blog\source</code> ：</p><ul><li><p><strong>新建文件CNAME→输入你的域名</strong></p><p>⚠️ 注意：域名不要带<code>www.</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203132639333.png" alt="image-20211203132639333"></p></li><li><p><strong>保存文件</strong></p><p>⚠️ 保存文件<strong>类型为所有文件</strong>，不是TXT文件！</p></li></ul></li><li><p>测试</p><p>网站三连发布后，浏览器输入：<code>你的域名</code> ，便可以正常开始解析了。</p><p>如果遇到错误，可以在下方评论留言。</p></li></ol><h5 id="网站备案">网站备案</h5><p>网站备案后通常有不少好处<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="网站域名备案的好处有哪些？https://www.ggcx.com/news/2105/251639.html">[6]</span></a></sup>，对于个人博客来说最重要的三个便是：</p><ol><li>加快网站的访问速度；</li><li>利于搜索引擎收录；</li><li>Github Pages访问较慢，备案后可以<strong>将服务器部署到（国内服务器）腾讯云COS或者腾讯云VPS</strong>上，访问速度极大加快。</li></ol><p>但这<strong>不影响网站域名的正常解析（除了慢点</strong>），因为毕竟网站部署在<strong>国外服务器</strong>（Github）上。</p><p>另外，网站备案经过我的尝试相比之前简便很多，只需要在<a href="https://cloud.tencent.com/product/ba">腾讯云全程线上备案</a>登记注册就好。但因为我身份证归属省份（江西），根据当地政策<strong>备案需要关闭网站</strong>，所以放弃折腾了。后续有时间补上。</p><h3 id="写在最后">写在最后</h3><p>断断续续写了大概一天，终于记录完了Hexo建站的基本所有的过程。因为没怎么运动，肩膀一直隐隐酸痛还是坚持写完了，可以说是身残志坚了。</p><p>后续的话可能会继续更新这篇文章，更好的打造自己的小窝，但主要还是更新一些C++和音视频相关博文：</p><ul><li>C++从零开始系列：C++基础、C++11特性学习、C++八股总结、C++开源源码分析；</li><li>音视频系列：待定；</li><li>其它：<strong>备案完成后</strong>，更新部署到腾讯云COS上教程。</li></ul><p>欢迎继续关注，一起学习。</p><img src="https://thumb.jfcdns.com/thumb/up/2017-8/201788194159800965660810_460_0.jpg" alt="溜了表情包-溜了溜了表情包下载全套无水印--pc6下载" style="zoom: 50%;" /><h3 id="更新记录">更新记录</h3><div class="timeline"><div class="timenode"><div class="meta"><p><p>2021-12-06 ：更新文档</p></p></div><div class="body"><ol><li>修改备案相关描述；</li><li>新增腾讯云COS相关描述。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-12-05 ：更新文档</p></p></div><div class="body"><ol><li>支持标签外挂，并新增安装教程</li><li>优化文章版式：分栏书写</li><li>更新配置文件</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-12-01 ：第一次更新</p></p></div><div class="body"><ol><li>上传初稿并发布</li></ol></div></div></div><h3 id="附录">附录</h3><blockquote><p>以下配置文件最终更新时间：2021/12/05  00:00 。</p></blockquote><ul><li><p><strong>royhuang’s 主配置文件</strong></p><p>点击这里查看：<a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/hwh.zone/p/hexo-build-site/_config.yml">_config.yml</a></p></li><li><p><strong>royhuang’s Butterfly配置文件</strong></p><p>点击这里查看：<a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/hwh.zone/p/hexo-build-site/_config.butterfly.yml">_config.butterfly.yml</a></p></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Butterfly 官方教程：https://butterfly.js.org/posts/21cfbf15/<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Hexo 知乎教程：https://zhuanlan.zhihu.com/p/26625249<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">从wordpress到hexo：https://www.wenjinyu.me/zh/from-wordpress-to-hexo-my-blog-should-have-been-like-this/<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Hexo-abbrlink插件生成唯一文章链接：https://zhuanlan.zhihu.com/p/112318081<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Typora+PicGo+腾讯云COS实现图片上传功能：https://www.daimajiaoliu.com/daima/56a7c8410d4cc09<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">网站域名备案的好处有哪些？https://www.ggcx.com/news/2105/251639.html<a href="#fnref:6" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站建设 </tag>
            
            <tag> hexo </tag>
            
            <tag> github pages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（八）_计算机基础_场景&amp;智力题</title>
      <link href="/p/31667/"/>
      <url>/p/31667/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h1>八、场景题&amp;智力题</h1><h2 id="8-1-场景题">8.1 场景题</h2><h4 id="1-设计一个微信运动排行榜？（Redis）">1. <strong>设计一个微信运动排行榜？（Redis</strong>）</h4><ul><li><p><strong>被CSIG伤过的的心还可以爱谁（第一次回答</strong>）</p><blockquote><p>“可以使用mysql, 将用户的好友列表关联的运动记录查询出来，然后通过order by 来进行排序，就可以实现了。”</p></blockquote><p>一旦数据量大达到千万级别的时候，不可避免地会出现慢查询，效率就会降低。所以<u>这不是面试官想听到的回答！</u></p></li><li><p><strong>Redis–高效</strong></p><p>使用Redis的有序集合 zset（<strong>有序且不重复</strong>） 。因为 zset 排序的下标从0 开始，自带一个score 值，该值可以当作排行的标准 。</p><ul><li><strong>添加用户和步数</strong>： <code>zadd key score member</code></li><li><strong>查询指定排名范围内用户</strong>： （从小到大）<code>zrange key start stop withscores </code>or （从大到小）<code>zrevrange key start stop withscores</code></li></ul><p>根据上面，所以用户按score从小到大排序完毕了，如果还要获取排名也可以使用下面命令：</p><ul><li><strong>查询指定用户排名</strong> ： <code>zrank key member</code> or <code>zrevrank key member</code></li></ul><p>一个简单的排行榜就设计完成了。</p><blockquote><p>如果面试官进一步问：一周排行榜怎么设计？</p></blockquote><p>一周的数据其实就是7天数据的累加，累加完后再排序，一个月的数据原理也是一样。可以使用 ：</p><ul><li><p><code>ZINTERSTORE</code> ： 计算给定一个或多个有序集的交集并将结果放到一个新的有序集合destination中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</span><br></pre></td></tr></table></figure><p>默认情况使用的函数是求和。</p></li></ul><p>所以可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zunionstore last_seven_days 7 20210315  20210316 20210317 20210318 20210319 20210320 20210321</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-海量数据问题">2. <strong>海量数据问题</strong></h4><blockquote><p>参考：<a href="https://blog.csdn.net/v_JULY_v/article/details/6279498">https://blog.csdn.net/v_JULY_v/article/details/6279498</a></p></blockquote><p>在海量数据中，针对top K类问题，通常比较好的方案是：</p><ul><li><p><strong>Top数问题：小根堆</strong></p><blockquote><p><strong>有1亿个浮点数，如何找出其最大的10000个</strong>？</p></blockquote><p>直接进行排序，大约需要10^8*4字节 = 400M ，如果内存够可以直接进行排序；如果内存不够采用：</p><ol><li><strong>最小堆法</strong> ：（1）先读入10000个数来创建大小为10000的<strong>最小堆</strong>（假设这10000个数是最大的10000个，然后每次和这10000中最小的比较）（2）遍历后续数字，和堆顶最小数字比较：如果小于堆顶数字，继续；如果大于堆顶数字，则替换堆顶并重新调整为最小堆（3）整个过程直至1亿个数全部遍历完为止</li><li><strong>分治法</strong>。 （1）1亿分为100份，每份100万个数据，找到每份的<strong>最大的1万</strong>个 （2）在剩下的100*1万个数据找到最大的1万个</li><li><strong>哈希法</strong>。 <u>如果这1亿个书里面有很多重复的数</u>，先通过Hash法，把这1亿个数字去重复。 然后再采用方法 1 或 2 。</li></ol></li><li><p><strong>最多重复（频率最高）：Hash映射+HashMap频率计算</strong></p><blockquote><p><strong>【最多重复】海量日志数据，提取出某日访问百度次数最多的那个IP。</strong></p></blockquote><ul><li><strong>分治法（基于Hash</strong>）。 （1）按照IP地址的<code>Hash(IP)%1024</code>值，把海量IP日志分别存储到1024个小文件中 （2）对于每一个小文件，可以构建一个IP为key，出现次数为value的<strong>Hash map</strong> （3）可以得到1024个小文件中的出现次数最多的IP ，再根据常规排序得到。</li></ul><p><u>⚠️ 使用Hash分散ip可以保证相同ip都在同一个文件夹</u>，如果只是简单均分是不行的。</p><blockquote><p><strong>【最多重复】有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词</strong>。</p></blockquote><ul><li>同上，<strong>分治法（基于Hash</strong>）。 首先计算下：1G / 1M = 1000个小文件，为保险分为2000个（1）<code>Hash(词)%2000</code> 映射到2000个文件中（2）分别计算2000个文件频率最高的那个单词，然后常规排序即可（2000个单词占：2k*16B=32KB&lt;&lt;1M）</li></ul><blockquote><p><strong>【最多重复】有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序</strong>。</p></blockquote><ul><li>同上，<strong>分治法（基于Hash</strong>）。 顺序读取10个文件，然后将query重新映射到若干个文件中，保证相同query都在同一个文件。其余同上。</li></ul></li><li><p><strong>不重复数：位图</strong></p><blockquote><p>【<strong>不重复</strong>】 <strong>在2.5亿个整数中找出不重复的整数。注，内存不足以容纳这2.5亿个整数</strong>。</p></blockquote><ul><li><p><strong>采用2位图（<a href="https://www.cnblogs.com/54chensongxia/p/11591979.html">BitMap</a></strong>）。00表示不存在，01表示出现一次，10表示多次，11无意义，需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2.5</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mi>b</mi><mo>=</mo><mn>2.5</mn><mo>∗</mo><mn>0.1</mn><mi>G</mi><mi>b</mi><mo>=</mo><mn>0.25</mn><mi>G</mi><mi>b</mi><mo>=</mo><mn>25</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2.5*10^8b = 2.5*0.1Gb=0.25Gb=25MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2.5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2.5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">0.1</span><span class="mord mathnormal">G</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">0.25</span><span class="mord mathnormal">G</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">25</span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span></span></span></span>。但是我们<strong>需要把所有的整数都表示出来</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><msup><mn>2</mn><mn>32</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi><mo>=</mo><mn>1</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2*2^{32}bit=1GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span></span></span></span>（1）扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变（2）查看bitmap，<u>把对应位是<strong>01</strong></u> 的整数输出即可。</p><p>注，int类型占32个字节，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span> 表示其能表示的整数个数。</p></li></ul><blockquote><p>【<strong>不重复·腾讯</strong>】<strong>给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中</strong>？</p></blockquote><ul><li><strong>采用2位图（<a href="https://www.cnblogs.com/54chensongxia/p/11591979.html">BitMap</a></strong>）。 需要40亿bit，大约500M，但实际是要表示所有整数，故还是1GB。其余同上。</li></ul></li><li><p><strong>共同数</strong></p><blockquote><p>【<strong>相同数</strong>】 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</p></blockquote><ul><li><strong>分治法（基于Hash</strong>）。 （1）分别将a，b两个大文件各自映射为10000个小文件，这样相同url会映射到a,b相同哈希值小文件中。（2）在a,b每一对小文件找到相同的url。</li></ul></li></ul><h4 id="3-分布式相关">3. <strong>分布式相关</strong></h4><blockquote><p><strong>谈一谈，分布式集群中如何保证线程安全</strong>？</p></blockquote><ul><li><p>对于单一服务来说，只要保证一台机器上的对于共享资源的访问是同步进行的就能保证线程安全了；但是对于分布式系统而已，保证一台服务器的同步，并不能保证访问共享资源是同步的；</p></li><li><p>所以可以考虑使用<strong>分布式锁</strong>的方式来保证分布式中的线程的安全线，这样不同的服务不同的线程通过竞争分布式锁来获取共享资源的操作权限；</p></li><li><p>例如<u><strong>redis的分布式锁、zookeeper锁</strong></u>，都可以作为分布式线程安全的手段。</p></li></ul><blockquote><p><strong>在淘宝购物，这个场景下，你会怎样来设计消息队列</strong>？</p></blockquote><ul><li><p><a href="https://juejin.cn/post/6844903817348136968">什么是消息队列？</a></p><p>消息队列（MQ）可以简单理解为：<strong>把要传输的数据放在队列中</strong>，一种先进先出的结构。</p></li><li><p><strong>怎么去设计淘宝消息队列</strong>？</p><p>待补充。</p></li></ul><h4 id="4-微信抢红包">4. <strong>微信抢红包</strong></h4><blockquote><p><a href="https://www.cnblogs.com/alimayun/p/12795698.html">例如一个人在群里发了100块钱的红包，群里有10个人一起来抢红包，每人抢到的金额随机分配。</a></p><ol><li><p>所有人抢到的金额之和要等于红包金额，不能多也不能少。</p></li><li><p>每个人至少抢到1分钱。</p></li><li><p>要保证红包拆分的金额尽可能分布均衡，不要出现两极分化太严重的情况。</p></li></ol></blockquote><p><strong>二倍均值法</strong>：假设剩余红包金额为m元，剩余人数为n，那么有如下公式：</p><ul><li><p><strong>每次抢到的金额 =  [0.01，m /n × 2 - 0.01]</strong></p></li><li><p>这个公式，保证了每次随机金额的平均值是相等的，不会因为抢红包的先后顺序而造成不公平。</p></li></ul><p>举例说明：</p><ul><li>假设有5个人，红包总额100元。100÷5×2 = 40，所以第1个人抢到的金额随机范围是[0.01，39.99]元，在正常情况下，平均可以抢到20元。假设第1个人随机抢到了20元，那么剩余金额是80元。80÷4×2 = 40，所以第2个人抢到的金额的随机范围同样是[0.01，39.99]元，在正常的情况下，还是平均可以抢到20元。假设第2个人随机抢到了20元，那么剩余金额是60元。60÷3×2 = 40，所以第3个人抢到的金额的随机范围同样是[0.01，39.99]元，平均可以抢到20元。以此类推，每一次抢到金额随机范围的均值是相等的。</li></ul><h2 id="8-2-智力题">8.2 智力题</h2><h4 id="1-厉害了我的杯">1. <strong>厉害了我的杯</strong></h4><blockquote><p>有一种玻璃杯质量确定但未知，需要检测。 有一栋100层的大楼，该种玻璃杯从某一层楼扔下，刚好会碎。 现给你两个杯子，问怎样检测出这个杯子的质量，即找到在哪一层楼刚好会碎？</p></blockquote><p>参考：<a href="https://cloud.tencent.com/developer/article/1497944">https://cloud.tencent.com/developer/article/1497944</a></p><h4 id="2-赛马问题">2. <strong>赛马问题</strong></h4><blockquote><p>64匹马，8个跑道，问最少比赛多少场，可以选出跑得最快的4匹马。</p><ul><li>Assumptions：每场比赛每个跑道只允许一匹马，且不存在并列情形。</li></ul></blockquote><h4 id="3-三人三鬼过桥">3. 三人三鬼过桥</h4><blockquote><p>有三个人跟三个鬼要过河,河上没桥只有条小船,然后船一次只能渡一个人和一个鬼,或者两个鬼或者两个人,无论在哪边岸上,只有是人比鬼少的情况下(如两鬼一人,三鬼两人,三鬼一人)人会被鬼吃,然而船又一定需要人或鬼操作才能航行(要有人或鬼划船),问,如何安全的把三人三鬼渡过河对岸?</p></blockquote><p>参考回答</p><ul><li>先两鬼过去。在一鬼回来。对面有一鬼。这边有三人两鬼。</li><li>再两鬼过去。在一鬼回来。对面有两鬼。这边有三人一鬼。</li><li>再两人过去。一人一鬼回来。对面一人一鬼。这边两人两鬼。</li><li>最后两人过去。一鬼回来。对面三人。这边三鬼。</li><li>剩下的就三个鬼二个过去一个回来在接另外个就OK了。</li></ul><h4 id="3-给定随机函数，生成别的随机数">3. 给定随机函数，生成别的随机数</h4><blockquote><p>给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？</p></blockquote><p>由大的生成小的容易，比如由Rand7()生成Rand5()，所以我们先构造一个大于7的随机数生成函数。 记住下面这个式子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成1到N^2之间的随机数,可以看作是在数轴上撒豆子。N是跨度/步长，是RandN()生成的数的范围长度</span></span><br><span class="line"><span class="comment">// RandN()-1的目的是生成0到N-1的数，是跳数。后面+RandN()的目的是填满中间的空隙Copy to clipboardErrorCopied</span></span><br><span class="line"></span><br><span class="line">RandNN= N( RandN()<span class="number">-1</span> ) + RandN() ;</span><br></pre></td></tr></table></figure><p>比如<code>Rand25= 5( Rand5()-1 ) + Rand5()</code>可以生成1到25之间的随机数。我们可以只要1到21（3*7）之间的数字，所以可以这么写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand7</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x=INT_MAX;</span><br><span class="line">  <span class="keyword">while</span>(x&gt;<span class="number">21</span>)&#123;</span><br><span class="line">    x=<span class="number">5</span>*(<span class="built_in">rand5</span>()<span class="number">-1</span>)+<span class="built_in">rand5</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x%<span class="number">7</span>+<span class="number">1</span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h4 id="4-砝码称轻重，找出最轻的">4. 砝码称轻重，找出最轻的</h4><p>其实这都是一类题，这里列举几个经典的：</p><blockquote><p>1、有一个天平，九个砝码，其中一个砝码比另八个要轻一些，问至少要用天平称几次才能将轻的那个找出来？</p></blockquote><p>参考回答：至少2次。第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个； 第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个；至少称2次．</p><blockquote><p>2、十组砝码每组十个，每个砝码都是10g重，但是现在其中有一组砝码每个都只有9g重，现有一个能显示克数的秤，最少称几次能找到轻的那组？</p></blockquote><p>参考回答：至少1次。</p><p>将砝码分组1~10，第一组拿一个，第二组拿两个以此类推。。第十组拿十个放到秤上称出克数x，则y = 550 - x，第y组就是轻的那组。</p><h4 id="5-利用空瓶换饮料，最多喝几瓶">5. 利用空瓶换饮料，最多喝几瓶</h4><blockquote><p>1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶？</p></blockquote><p><strong>第一种思路</strong></p><p>拿走3瓶，换回1瓶，相当于减少2瓶。</p><p>但是最后剩下4瓶的时候例外，这时只能换1瓶。所以我们计算1000减2能减多少次，直到剩下4.（1000-4=996，996/2=498）所以1000减2能减498次直到剩下4瓶，最后剩下的4瓶还可以换一瓶，所以总共是1000+498+1=1499瓶。</p><p><strong>第二种思路</strong></p><ul><li><p>1000瓶饮料，3个空瓶子能换1瓶饮料，最多可以喝几瓶？</p></li><li><p>第一种思维：可以考虑成dp思路</p><ul><li><p>初始情况，3个瓶子时将发生一次交换，因此视为特殊情况</p></li><li><p>之后每增加两个瓶子又可以再换一瓶</p></li><li><p>即dp[i] = dp[i - 2] + (i - (i - 2)) + 1</p></li><li><ul><li>由dp[i - 2]可求得dp[i]</li><li>(i - (i - 2))，即为当前增加的2瓶饮料（写成这样便于理解）</li><li>1即为增加了2个空瓶，之后又可以换一瓶饮料</li></ul></li><li><p>简化为dp[i] = dp[i - 2] + 2 + 1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// n为0/1/2的特殊情况省略了</span></span><br><span class="line">    <span class="comment">// 定义dp数组</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始状态</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line"> &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li></ul></li><li><p>回归正题</p><ul><li>特殊情况：从上面的分析中，留下2个瓶子</li><li>剩下998个瓶子相当于每消耗2个瓶子即可获得一瓶，即为499瓶</li><li>最后剩下的2个瓶子无法再进行兑换，因此总共为1000 + 499 = 1499</li></ul></li><li><p>第二种思维</p><ul><li>因为兑换一瓶饮料需要三个空瓶，这瓶饮料如果是找老板借来的，那么喝完后这个空瓶将会还给他，同时需要附赠给他另外两个空瓶，即每消耗手里两个空瓶就获得一瓶饮料</li><li>但是值得注意的是，上面只是一种假设，实际情况老板是不会借给你的，因此我们至少需要保留2个空瓶，这样可以在998个瓶子剩下一个瓶子时，对其进行补足为3个空瓶，从而兑换一瓶新饮料</li><li>此时使用998个瓶子进行上述的兑换，将获得499瓶饮料</li><li>之前留下的两个瓶子正好无法兑换，最终获得饮料为1000 + 499 = 1499瓶</li></ul></li></ul><h4 id="6-毒药毒白鼠，找出哪个瓶子中是毒药">6. 毒药毒白鼠，找出哪个瓶子中是毒药</h4><blockquote><p>有1000个一模一样的瓶子，其中有999瓶是普通的水，有1瓶是毒药。任何喝下毒药的生命都会在一星期之后死亡。现在你只有10只小白鼠和1个星期的时间，如何检验出哪个瓶子有毒药？</p></blockquote><p>参考回答</p><ol><li><p>将10只老鼠剁成馅儿，分到1000个瓶盖中，每个瓶盖倒入适量相应瓶子的液体，置于户外，并每天补充适量相应的液体，观察一周，看哪个瓶盖中的肉馅没有腐烂或生蛆。（你要是胆子够大就可以这么回答，是个狼人）</p></li><li><p>首先一共有1000瓶，2的10次方是1024，刚好大于1000，也就是说，1000瓶药品可以使用10位二进制数就可以表示。从第一个开始：</p><p>第一瓶 ： 00 0000 0001</p><p>第二瓶： 00 0000 0010</p><p>第三瓶： 00 0000 0011</p><p>……</p><p>第999瓶： 11 1111 0010</p><p>第1000瓶： 11 1111 0011</p><p>需要十只老鼠，如果按顺序编号，ABCDEFGHIJ分别代表从低位到高位每一个位。 每只老鼠对应一个二进制位，如果该位上的数字为1，则给老鼠喝瓶里的药。</p><p>观察，若死亡的老鼠编号为：ACFGJ，一共死去五只老鼠，则对应的编号为 10 0110 0101，则有毒的药品为该编号的药品，转为十进制数为：613号。（这才是正解，当然前提是老鼠还没被撑死）</p></li></ol><blockquote><p>类似问题：8瓶酒一瓶有毒，用小老鼠测试。每次测试结果8小时后才会得出，而你只有8个小时的时间。最少需要（ ）老鼠测试？</p><ul><li>A 、2  B、3  C、4  D、6</li></ul></blockquote><p>解析：用3位2进制代表8瓶酒，如下表所示</p><p>瓶序号 二进制 中毒情况</p><p>第一瓶 000 全没中毒</p><p>第二瓶 001 只有第一个老鼠中毒</p><p>第三瓶 010 只有第二个老鼠中毒</p><p>第四瓶 011 第一个老鼠、第三个老鼠同时中毒</p><p>第五瓶 100 只有第三个老鼠中毒</p><p>第六瓶 101 第一个老鼠、第三个老鼠同时中毒</p><p>第七瓶 110 第二个老鼠、第三个老鼠同时中毒</p><p>第八瓶 111 三个老鼠同时中毒</p><p>其中，第一个老鼠喝下最低位为1对应的酒，第二个老鼠喝下中间位为1对应的酒，第三个老鼠喝下最高位为1对应的酒。</p><p>最后将所有中毒的老鼠，对应的位次进行与操作即可以知道那瓶毒药有毒了。</p><h4 id="7-利用烧绳子计算时间">7. 利用烧绳子计算时间</h4><blockquote><p>现有若干不均匀的绳子，烧完这根绳子需要一个小时，问如何准确计时15分钟，30分钟，45分钟，75分钟。。。</p></blockquote><ul><li><p>计算15分钟：对折之后两头烧(要求对折之后绑的够紧，否则看45分钟解法)</p></li><li><p>计算30分钟：两头烧</p></li><li><p>计算45分钟：两根，一根两头烧一根一头烧，两头烧完过了30分钟，立即将第二根另一头点燃，到烧完又过15分钟，加起来45分钟</p></li><li><p>计算75分钟：将30和45分钟的方式加起来就可以了</p></li></ul><p>其余类似</p><h4 id="8-在24小时里面时针分针秒针可以重合几次">8. 在24小时里面时针分针秒针可以重合几次</h4><p>24小时中时针走2圈，而分针走24圈，时针和分针重合24-2=22次，而只要时针和分针重合，秒针一定有机会重合，所以总共重合22次。</p><h4 id="9-100个奴隶猜帽子颜色">9. 100个奴隶猜帽子颜色</h4><blockquote><p>一百个奴隶站成一纵列，每人头上随机带上黑色或白色的帽子，各人不知道自己帽子的颜色，但是能看见自己前面所有人帽子的颜色． 然后从最后一个奴隶开始，每人只能用同一种声调和音量说一个字：”黑”或”白”， 如果说中了自己帽子的颜色，就存活，说错了就拉出去斩了，说的参考回答所有奴隶都能听见。 是否说对，其他奴隶不知道。</p><p>在这之前，所有奴隶可以聚在一起商量策略，问如果奴隶都足够聪明而且反应足够快，100个人最大存活率是多少？</p></blockquote><p>参考回答：这是一道经典推理题</p><ol><li><p>最后一个人如果看到奇数顶黑帽子报“黑”否则报“白”，他可能死</p></li><li><p>其他人记住这个值（实际是黑帽奇偶数），在此之后当再听到黑时，黑帽数量减一</p></li><li><p>从倒数第二人开始，就有两个信息：记住的值与看到的值，相同报“白”，不同报“黑”</p></li></ol><p>99人能100%存活，1人50%能活</p><blockquote><p>变种：每个奴隶只能看见前面一个人帽子颜色又能最多存活多少人？</p></blockquote><p>增加限制条件后，上面的方法就失效了，此时只能约定偶数位奴隶说他前一个人的帽子颜色，奇数奴隶获取信息100%存活，偶数奴隶50几率存活。</p><h4 id="10-小猴子搬香蕉">10. 小猴子搬香蕉</h4><blockquote><p>一个小猴子边上有100根香蕉，它要走过50米才能到家，每次它最多搬50根香蕉，（多了就被压死了），它每走 1米就要吃掉一根，请问它最多能把多少根香蕉搬到家里？</p><p>（提示：他可以把香蕉放下往返的走，但是必须保证它每走一米都能有香蕉吃。也可以走到n米时，放下一些香蕉，拿着n根香蕉走回去重新搬50根。）</p></blockquote><p>这种试题通常有一个迷惑点，让人看不懂题目的意图。此题迷惑点在于：走一米吃一根香蕉，一共走50米，那不是把50根香蕉吃完了吗？如果要回去搬另外50根香蕉，则往回走的时候也要吃香蕉，这样每走一米需要吃掉三根香蕉，走50米岂不是需要150根香蕉？</p><p>其实不然，本题关键点在于：猴子搬箱子的过程其实分为两个阶段，第一阶段：来回搬，当香蕉数目大于50根时，猴子每搬一米需要吃掉三根香蕉。第二阶段：香蕉数&lt;=50，直接搬回去。每走一米吃掉1根。</p><ol><li><p>第一阶段：假如把100根香蕉分为两箱，一箱50根</p><p>第一步，把A箱搬一米，吃一根。</p><p>第二步，往回走一米，吃一根。</p><p>第三步，把B箱搬一米，吃一根。</p><p>这样，把所有香蕉搬走一米需要吃掉三根香蕉。这样走到第几米的时候，香蕉数刚好小于50呢？</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>100</mn><mo>−</mo><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mn>3</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mn>50</mn><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mn>100</mn><mo>−</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>∗</mo><mn>3</mn><mo stretchy="false">)</mo><mo>&gt;</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">100-(n*3)&lt;50 \&amp;\&amp; 100-(n-1*3)&gt;50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">100</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">50&amp;&amp;100</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">50</span></span></span></span></span></p><p>走到16米的时候，吃掉48根香蕉，剩52根香蕉。这步很有意思，它可以直接搬50往前走，也可以再来回搬一次，但结果都是一样的。</p><p>到17米的时候，猴子还有49根香蕉。这时猴子就轻松啦，直接背着走就行。</p></li><li><p>第二阶段：走一米吃一根</p><p>把剩下的50-17=33米走完。还剩49-33=16根香蕉。</p></li></ol><h4 id="11-N只蚂蚁走树枝，问总距离或者总时间">11. N只蚂蚁走树枝，问总距离或者总时间</h4><blockquote><p>问题：放N只蚂蚁在一条长度为M树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间为多少？</p></blockquote><p>这个其实就一个诀窍：蚂蚁相碰就往反方向走，可以直接看做没有发生任何事：大家都相当于独立的</p><p>A蚂蚁与B蚂蚁相碰后你可以看做没有发生这次碰撞，这样无论是求时间还是距离都很简单了。</p><h4 id="12-N个强盗分配M个金币，求方案使得自己分配最多">12. N个强盗分配M个金币，求方案使得自己分配最多</h4><blockquote><p>5个海盗抢到了100枚金币，每一颗都一样的大小和价值。 他们决定这么分：</p><ol><li><p>抽签决定自己的号码（1，2，3，4，5）</p></li><li><p>首先，由1号提出分配方案，然后大家5人进行表决，当 半数以上的人同意时（ 不包括半数，这是重点），按照他的提案进行分配，否则将被扔入大海喂鲨鱼。</p></li><li><p>如果1号死后，再由2号提出分配方案，然后大家4人进行表决，当且仅当半超过半数的人同意时，按照他的提案进行分配，否则将被扔入大海喂鲨鱼。</p></li><li><p>依次类推…</p></li></ol><p>假设每一位海盗都足够聪明，并且利益至上，能多分一枚金币绝不少分，那么1号海盗该怎么分金币才能使自己分到最多的金币呢？</p></blockquote><p>从后向前推，如果1至3号强盗都喂了鲨鱼，只剩4号和5号的话，5号一定投反对票让4号喂鲨鱼，以独吞全部金币。所以，4号惟有支持3号才能保命。</p><ul><li><p>3号知道这一点，就会提出“100，0，0”的分配方案，对4号、5号一毛不拔而将全部金币归为已有，因为他知道4号一无所获但还是会投赞成票，再加上自己一票，他的方案即可通过。</p></li><li><p>不过，2号推知3号的方案，就会提出“98，0，1，1”的方案，即放弃3号，而给予4号和5号各一枚金币。由于该方案对于4号和5号来说比在3号分配时更为有利，他们将支持他而不希望他出局而由3号来分配。这样，2号将拿走98枚金币。</p></li><li><p>同样，2号的方案也会被1号所洞悉，1号并将提出（97，0，1，2，0）或（97，0，1，0，2）的方案，即放弃2号，而给3号一枚金币，同时给4号（或5号）2枚金币。由于1号的这一方案对于3号和4号（或5号）来说，相比2号分配时更优，他们将投1号的赞成票，再加上1号自己的票，1号的方案可获通过，97枚金币可轻松落入囊中。这无疑是1号能够获取最大收益的方案了！</p></li></ul><p>1号强盗分给3号1枚金币，分给4号或5号强盗2枚，自己独得97枚。分配方案可写成（97，0，1，2，0）或（97，0，1，0，2）。</p><blockquote><p>变种：就是只需要一半人同意即可，不需要一半人以上同意方案就可以通过，在其他条件不变的情况下，1号该怎么分配才能获得最多的金币？</p></blockquote><ul><li><p>4号：4号提出的方案的时候肯定是最终方案，因为不管5号同意不同意都能通过，所以4号5号不必担心自己被投入大海。那此时5号获得的金币为0，4号获得的金币为100。</p></li><li><p>5号：因为4号提方案的时候 ，自己获取的金币为0 。所以只要4号之前的人分配给自己的金币大于0就同意该方案。</p></li><li><p>4号：如果3号提的方案一定能获得通过（原因：3号给5号的金币大于0， 5号就同意 因此就能通过），那自己获得的金币就为0，所以只要2号让自己获得的金币大于0就会同意。</p></li><li><p>3号：因为到了自己提方案的时候可以给5号一金币，自己的方案就能通过，但考虑到2号提方案的时候给4号一个金币，2号的方案就会通过，那自己获得的金币就为0。所以只要1号让自己获得的金币大于0就会同意。</p></li><li><p>2号：因为到了自己提方案的时候只要给4号一金币，就能获得通过，根本就不用顾及3 号 5号同意不同意，所以不管1号怎么提都不会同意。</p></li><li><p>1号：2号肯定不会同意。但只要给3号一块金币，5号一块金币（因为5号如果不同意，那么4号分配的时候，他什么都拿不到）就能获得通过。</p></li></ul><p>所以参考回答是： 98，0，1，0，1。</p><h4 id="14-火枪手决斗，谁活下来的概率大？">14. 火枪手决斗，谁活下来的概率大？</h4><blockquote><p>问题：彼此痛恨的甲、乙、丙三个枪手准备决斗。甲枪法最好，十发八中；乙枪法次之，十发六中；丙枪法最差，十发四中。如果三人同时开枪，并且每人每轮只发一枪；那么枪战后，谁活下来的机会大一些？</p></blockquote><p>一般人认为甲的枪法好，活下来的可能性大一些。但合乎推理的结论是，枪法最糟糕的丙活下来的几率最大。</p><p>那么我们先来分析一下各个枪手的策略。</p><p>如同田忌赛马一般，枪手甲一定要对枪手乙先。因为乙对甲的威胁要比丙对甲的威胁更大，甲应该首先干掉乙，这是甲的最佳策略。</p><p>同样的道理，枪手乙的最佳策略是第一枪瞄准甲。乙一旦将甲干掉，乙和丙进行对决，乙胜算的概率自然大很多。</p><p>枪手丙的最佳策略也是先对甲。乙的枪法毕竟比甲差一些，丙先把甲干掉再与乙进行对决，丙的存活概率还是要高一些。</p><p>我们根据分析来计算一下三个枪手在上述情况下的存活几率： 第一轮：甲射乙，乙射甲，丙射甲。</p><ul><li><p>甲的活率为24%（40% X 60%）</p></li><li><p>乙的活率为20%(100% - 80%)</p></li><li><p>丙的活率为100%（无人射丙）</p></li></ul><p>由于丙100％存活率，因此根据上轮甲乙存活的情况来计算三人第二轮的存活几率：</p><ul><li>情况1：甲活乙死（24% X 80% = 19.2%） 甲射丙，丙射甲：甲的活率为60%，丙的活率为20%。</li><li>情况2：乙活甲死（20% X 76% = 15.2%） 乙射丙，丙射乙：乙的活率为60%，丙的活率为40%。</li><li>情况3：甲乙同活（24% X 20% = 4.8%） 重复第一轮。 情况4：甲乙同死（76% X 80% = 60.8%） 枪战结束。</li></ul><p>据此来计算三人活率：</p><ul><li>甲的活率为(19.2% X 60%) + (4.8% X 24%) = 12.672%</li><li>乙的活率为(15.2% X 60%) + (4.8% X 20%) = 10.08%</li><li>丙的活率为(19.2% X 20%) + (15.2% X 40%) + (4.8% X 100%) + (60.8% X 100%) = 75.52%</li></ul><p>通过对两轮枪战的详细概率计算，我们发现枪法最差的丙存活的几率最大，枪法较好的甲和乙的存活几率却远低于丙的存活几率。</p><h4 id="15-先手必胜的问题">15. 先手必胜的问题</h4><blockquote><p>100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿？</p></blockquote><p>寻找每个回合固定的拿取模式，最后一次是我拿，那么上个回合最少剩下6本。那么只要保持每个回合结束后都剩下6的倍数，并且在这个回合中我拿的和对方拿的加起来为6（这样这个回合结束后剩下的还是6的倍数），就必胜。</p><p>关键是第一次我必须先手拿（100%6=4）本（这不算在第一回合里面）。</p><h4 id="16-掰巧克力问题或者参加辩论赛">16. 掰巧克力问题或者参加辩论赛</h4><blockquote><p>1、掰巧克力问题 N<em>M块巧克力，每次掰一块的一行或一列，掰成1</em>1的巧克力需要多少次？</p><p>2、1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛？</p></blockquote><p>每次拿起一块巧克力，掰一下（无论横着还是竖着）都会变成两块，因为所有的巧克力共有N<em>M块，所以要掰N</em>M-1次，-1是因为最开始的一块是不用算进去的。</p><p>每一场辩论赛参加两个人，消失一个人，所以可以看作是每一场辩论赛减少一个人，直到最后剩下1个人，所以是1000-1=999场。</p>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 场景题 </tag>
            
            <tag> 智力题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（七）_计算机基础_数据结构</title>
      <link href="/p/61434/"/>
      <url>/p/61434/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h1>七、数据结构和算法</h1><h4 id="1-如何对快排进行优化？">1. 如何对快排进行优化？</h4><ul><li><p><strong>三数取中法和随机交换法</strong></p><blockquote><p>快排将选取的基准点经过调整放到合适的位置，之后将这个基准点左右两边的区间分别递归的进行快排。</p><p>如果基准点的数据比较小，将会导致调整后基准点处于靠近两侧的位置，那么两边的区间长度将会严重失去平衡.</p></blockquote><p><strong>三数取中法：指的是选取基准点之前</strong>我们可以拿出数列中间位置元素的值，将它和首尾的元素进行比较，之后将这三个数中的<strong>中间数</strong>交换到<strong>数列首位</strong>的位置，之后将这个数作为基准点，<u>尽量减小之后的分区后左右两边的区间长度之差</u>。</p></li><li><p><strong>三路分割法</strong></p><p><strong>三路法同样是针对含有大量【重复数列】的优化</strong>。</p><p>3路法的思想是将数列分成3个区间，分别是<strong>小于、等于和大于基准点的区间</strong>。那么分区之后，对于等于基准点的区间内的元素，我们就不需要对其做任何处理了，只需要递归的处理小于和大于基准点的元素即可。</p></li><li><p><strong>结合插入排序</strong></p><p>当待排序序列的长度分割到一定大小后，使用<strong>插入排序</strong>。</p><ul><li><strong>对于很小和部分有序的数组，快排不如插排好</strong>。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排。</li></ul></li></ul><h4 id="2-快排和堆排的区别？什么时候使用快排和堆排？">2.<strong>快排和堆排的区别</strong>？<strong>什么时候使用快排和堆排</strong>？</h4><ul><li><p><strong>快排和堆排区别</strong>？</p><ul><li><p><strong>综合性能</strong>：实际应用中，虽然<u>堆排序的时间复杂度要比快速排序稳定</u>（快排最差退化成O(N^2)） ，但是统计意义上这种情况较少，所以综合性能还是快排更优；</p></li><li><p><strong>交换次数</strong>： 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序；</p></li><li><p><strong>访问友好</strong>： 堆排序数据访问的方式没有快速排序友好。</p><blockquote><p><strong>对于快速排序来说，数据是顺序访问的；而堆排序来说，数据是跳着访问的</strong>。比如，堆排序中，最重要的一个操作就是数据的堆化。对堆顶节点进行堆化，会一次访问<strong>数组下标1，2，4，8</strong>的元素，而不是像快排那样，局部顺序访问，<u>所以对<strong>CPU缓存</strong>是不友好的</u>。</p></blockquote></li></ul></li><li><p><strong>快排和堆排使用场景</strong>？</p><ul><li><p><strong>快排</strong>： 绝大多数场合。</p></li><li><p><strong>堆排</strong>： topK问题、优先队列（需要在一组不停更新的数据中不停地找最大/小元素）</p><blockquote><p>在N个元素中找到top K，时间复杂度是O(N log K)，空间复杂的是O(K)，而快速排序的空间复杂度是O(N)。</p></blockquote></li></ul></li></ul><h4 id="3-【面试重点】有哪些排序算法，各算法的时间复杂度-哪些是稳定的？为什么是稳定的？">3. 【面试重点】有哪些排序算法，各算法的时间复杂度 ? 哪些是稳定的？为什么是稳定的？</h4><p><img src="https://i.loli.net/2021/05/01/K3s7DFEvyhHkwI9.png" alt="image-20210501224258097"></p><h5 id="3-1-如果数据大致有序的，用什么排序比较好？">3.1 如果数据大致有序的，用什么排序比较好？</h5><p>如果是<strong>大致有序</strong>，用 <u>插入排序</u> 比较好：</p><ul><li><u>直接插入排序</u>是将第i个元素插入到已经排序好的前i-1个元素中 ，当元素基本有序时。和前i-1个元素<strong>末尾比较一次</strong>就可以直接插入。</li></ul><p>在相比使用其它排序：</p><ul><li><p><u>归并排序：</u> 归并排序和数组是否有序无关，都是O(nlgn)。</p><blockquote><p>归并排序是把一个有n个记录的无序文件看成由<strong>n个长度为1</strong>的有序子文件组成的文件，然后进行两两归并，得到[n/2]个长度为2或1的有序文件，再两两归并 。</p></blockquote></li><li><p><u>快速排序：</u> 数组基本有序时，此时如果使用基点是最后一个元素，划分的两个子数组极为不平衡，每次划分比较次数都很多。所以不推荐。</p></li></ul><h4 id="4-二叉查找树，红黑树和平衡二叉树的区别？（有了二叉查找树、平衡树（AVL）为啥还需要红黑树？）">4. 二叉查找树，红黑树和平衡二叉树的区别？（有了二叉查找树、平衡树（AVL）为啥还需要红黑树？）</h4><blockquote><p>总结来说：平衡树是为了解决二叉查找树退化为链表的情况；而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。</p></blockquote><ul><li><p><strong>二叉查找树退化成单链表</strong></p><p>正常使用二叉查找树是类似于<u>二分查找 O（logn）</u>，但是极端情况：</p><ul><li><p>构建的二叉树所有节点都只有右子树或左子树，此时时间复杂度退化成O(N)</p><p><img src="https://i.loli.net/2021/05/01/38TASb1DB7sYN5k.jpg" alt="preview"></p></li></ul></li><li><p><strong>平衡二叉树频繁左右旋</strong></p><p>平衡二叉树就是为了解决二叉查找树退化成一颗链表而诞生了，平衡树具有如下特点：</p><ol><li><p>具有二叉查找树的全部特性；</p></li><li><p><strong>每个节点的左子树和右子树的高度差至多等于1</strong>。</p></li></ol><p>避免了二叉查找树极端情况产生，但是：</p><ul><li>每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过<strong>左旋</strong>和<strong>右旋</strong>来进行调整，使之再次成为一颗符合要求的平衡树。</li></ul><p>平衡树性能大打折扣。</p></li><li><p><strong>红黑树规不需要频繁着调整</strong></p><p>红黑树具有如下特点：</p><blockquote><p>最坏情况下，也能在 O(logn) 的时间复杂度查找到某个节点。</p><ul><li>与平衡树不同的是，红黑树在插入、删除等操作，（🚩*1）<strong>不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整</strong>，这也是我们为什么大多数情况下使用红黑树的原因；</li><li>但是，单单在查找方面的效率的话，平衡树比红黑树快。</li></ul></blockquote><p><img src="https://i.loli.net/2021/05/01/sFSaG9POEi73hdo.jpg" alt="img"></p><ol><li>具有二叉查找树的特点；</li><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据；</li><li><strong>任何相邻的节点都不能同时为红色</strong>，也就是说，红色节点是被黑色节点隔开的；</li><li>每个节点，<strong>从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点</strong>。</li></ol></li></ul><h5 id="4-1-为什么红黑树不需要频繁调整？">4.1 为什么红黑树不需要频繁调整？</h5><blockquote><p>详细理解红黑树一篇不错的文章：<a href="https://zhuanlan.zhihu.com/p/97523789">百图详解红黑树，想不理解都难</a></p></blockquote><p>平衡二叉树这种高度差为 1 的要求太严格了，尤其是对于频繁删除、插入的场景非常浪费时间。</p><p>但是由于红黑树：</p><ul><li>具有二叉树所有特点。</li><li>每个节点只能是红色或者是黑色。</li><li><strong>根节点只能是黑色</strong>，且黑色根节点不存储数据。</li><li><strong>任何相邻的节点都不能同时为红色</strong>。</li><li>红色的节点，它的子节点只能是黑色。</li><li>从任一节点到其每个叶子的所有路径都包含<strong>相同数目的黑色节点</strong>。</li></ul><p><strong>不追求插入、删除等操作绝对平衡</strong>，只需满足上述条件即可。它的旋转次数少，<strong>插入最多两次旋转</strong>，<strong>删除最多三次旋转</strong>。</p><p>所以在搜索、插入、删除操作较多的情况下，红黑树的效率是优于平衡二叉树的。</p><h4 id="5-快速排序的过程-？">5.快速排序的过程 ？</h4><ul><li><p>手撕一个<a href="">二分查找</a> 和快排？</p><ul><li><p><strong>二分查找</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binary search</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid ;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right) <span class="comment">//*&lt;= 而不是&lt; </span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(value == arr[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid; <span class="comment">// 如果数组存在待查找元素，按照逻辑一定会是mid</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span>(value &lt; arr[mid])</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// value &gt; arr[mid]</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>快速排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] quick_sort(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;=left)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择基准：数组最右数字</span></span><br><span class="line">        <span class="comment">// *如果选择最左，思考交换过程</span></span><br><span class="line">        <span class="comment">// *partition 左侧始终是比pivot小的数</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[right];</span><br><span class="line">        <span class="keyword">int</span> partition = left;</span><br><span class="line">        <span class="comment">// 遍历分区元素</span></span><br><span class="line">        <span class="comment">// 小于基准的放基准左边，大于的放基准右边</span></span><br><span class="line">        <span class="comment">// * 终止条件：i &lt; right 而非 right-1！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt; right;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;pivot) <span class="comment">// 实际只交换小于到左边即可</span></span><br><span class="line">            &#123;</span><br><span class="line">                swap(arr,i,partition);</span><br><span class="line">                partition++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// *基准插入位置partition位置</span></span><br><span class="line">        swap(arr,partition,right);</span><br><span class="line">        <span class="comment">//递归的排序</span></span><br><span class="line">        quick_sort(arr,left,partition-<span class="number">1</span>);</span><br><span class="line">        quick_sort(arr,partition+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-布隆过滤器原理？为什么使用多个哈希函数？其它相关应用？">6. 布隆过滤器原理？为什么使用多个哈希函数？其它相关应用？</h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/43263751">详解布隆过滤器的原理，使用场景和注意事项</a></p></blockquote><blockquote><p>“布隆说：<strong>不存在</strong>的那么<strong>一定不存在</strong>”</p><p>“布隆说：<strong>存在</strong>的那么<strong>只是可能存在</strong>”</p></blockquote><h5 id="7-1-从HashMap说起—当你判断某个元素时候你在想什么？">7.1 从HashMap说起—当你判断某个元素时候你在想什么？</h5><blockquote><p>通常我们怎么判断一个数组，是否存在某个元素呢？</p></blockquote><p>聪明的你一定想到HashMap：（1）HashMap将数组所有元素使用哈希函数，映射到HashMap上（HashMap本身也是一个数组）（2）然后就可以在O(1)级别判断某个元素是否存在。</p><p>但是这种做法通常会导致以下问题：</p><ol><li><strong>一旦数组很大</strong>，比如上亿，HashMap将会占据非常大的内存；</li><li>数组很大，不大可能一次性能在内存构建HashMap；</li><li>而且HashMap，通常存在负载因子，是不能充分利用内存的。</li></ol><p>为此，我们可以从以下方向优化：</p><ul><li><p><strong>只存储key。<strong>但是，因为我们</strong>只要判断某个元素（key）是否存在</strong>， 不需要取出对应key的value—也就是<strong>不需要存储value</strong>。</p></li><li><p><strong>key映射为bit数组索引。<strong>key映射为<code>bit</code>数组索引，即</strong>位图对应索引</strong>，  索引对应数值用 <code>0/1</code> 就可以标识为是否存在该key。</p></li></ul><p>为此，我们可以【第一阶段优化】如下：</p><p><img src="https://i.loli.net/2021/05/28/acoknPGdU3DVMEw.png" alt="img"></p><p>看样子似乎是满足我们要求了，但是依旧存在以下问题：</p><ol><li>只使用一个<code>hash</code>函数，<strong>空间利用率低</strong>。</li></ol><p>一个<code>hash</code>函数只能<strong>将key散列到一个位置</strong> ，虽然hash尽量优良映射均匀，但是空间利用率依然不算高。</p><p>因此，我们可以多个函数，将<strong>key同时映射到多个位置</strong>，即使发生哈希冲突，某个位置被覆盖，其它依旧存在，<strong>变相的降低了哈希冲突</strong>。</p><h5 id="7-2-数据结构及原理">7.2 数据结构及原理</h5><p>布隆过滤器，最终结构如下：一个<code>bit</code>数组，采用<strong>多个hash函数</strong>进行映射。</p><p><img src="https://i.loli.net/2021/05/28/zIxX9WcwUoT2lGK.png" alt="img"></p><h5 id="7-3-布隆函数优缺点">7.3 布隆函数优缺点</h5><ul><li><strong>优点</strong><ol><li><code>存储/插入/查询</code>时间复杂度，都是常数级别<code>O(1)</code></li><li><strong>保密性好</strong>，因为不需要存储数据本身</li><li><strong>存储数据大</strong>，可以存储非常大的数据本身</li></ol></li><li><strong>缺点</strong><ol><li>随着元素数量增加，<strong>误算率</strong>会增加</li><li><strong>不能删除</strong>元素，因为删除某个元素，要把其对应所有hash函数散列的位置如A,B，置为<code>0</code> 。其它元素的可能散列到位置A，再去判断这个元素是否存在就会出现<strong>误判</strong>。</li></ol></li></ul><h5 id="7-4-应用场景">7.4 应用场景</h5><ol><li><p><strong>解决缓存穿透</strong>，防止<strong>不存在</strong>的元素去查询数据库</p></li><li><p><strong>防止重复被攻击</strong>，用户第一次请求，将请求参数放入布隆过滤器中，当第二次请求时，先判断请求参数是否被布隆过滤器命中。可以提高缓存命中率</p></li><li><p><strong>判断用户是否阅读过某视频或文章</strong>， 比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（六）_计算机基础_Redis</title>
      <link href="/p/31215/"/>
      <url>/p/31215/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h1>六、Redis</h1><h2 id="6-1-Redis基本">6.1 Redis基本</h2><h4 id="1-什么是-Redis？">1.<strong>什么是</strong> <strong>Redis？</strong></h4><p>Redis 是一个开源（BSD 许可）、基于<u>内存（读写快）</u>、支持多种数据结构的存储系统，可以作为<u>数据库、缓存和消息中间件</u>。</p><ul><li>支持的数据结构有<strong>5</strong>种：字符串（String）、哈希（hash）、列表（list）、集合（set）、有序集合（sorted set）。</li></ul><h5 id="1-1-有MySQL不就够用了吗？为什么要用Redis这种新的数据库？">1.1 有MySQL不就够用了吗？为什么要用Redis这种新的数据库？</h5><p>主要是因为 Redis <strong>具备高性能和高并发</strong>两种特性。</p><ul><li><strong>高性能</strong>：除了第一次读取硬盘比较慢，后面加载到缓存，读取速度都相关快，性能高；</li><li><strong>高并发</strong>：直接<strong>操作缓存能够承受的并发请求是远远大于直接访问数据库</strong>的，所以我们可以考虑把数据库中的<strong>部分热点数据</strong>转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</li></ul><h5 id="1-2-C-JAVA-中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？">1.2 C++ / JAVA 中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？</h5><p>缓存分为本地缓存和分布式缓存 。</p><ul><li><strong>本地缓存不具一致性</strong>。以Java为例 ，使用自带的map或者guava实现的是本地缓存，最主要的特点是<strong>轻量以及快速</strong>，生命周期<strong>随着jvm的销毁而结束</strong>，并且在多实例的情况下，<strong>每个实例都需要各自保存一份缓存</strong>，缓存不具有一致性；</li><li><strong>Redis分布式缓存具有一致性</strong>。 使用redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性；</li><li><strong>Redis可以使用更大内存作为缓存</strong>。 Redis可以使用几十G内存作为缓存，Map不行，比如JVM最多使用几个G ；</li><li><strong>Redis可以持久化</strong>。 Redis可以实现持久化，而Map是内存对象，程序重启就没了；</li><li><strong>Redis可以处理百万级别并发；</strong></li><li><strong>Redis有丰富的API &amp; 缓存过期等机制</strong>。</li></ul><h4 id="2-【重点】redis的数据类型，以及每种数据类型的使用场景？">2. 【重点】redis的数据类型，以及每种数据类型的使用场景？</h4><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">使用场景</th></tr></thead><tbody><tr><td style="text-align:center">String</td><td style="text-align:center">存储key-value键值对，注意redis中String可修改。统计在线人数；也可以存储<strong>视频、图片</strong>等</td></tr><tr><td style="text-align:center">hash</td><td style="text-align:center">购物车：<code>hset [key] [field] [value]</code> 命令， 存放键值对，一般可以用来存某个对象的基本属性信息，例如，用户信息，商品信息等</td></tr><tr><td style="text-align:center">set</td><td style="text-align:center">全局去重，JVM自带的set不适合分布式集群情况</td></tr><tr><td style="text-align:center">zset</td><td style="text-align:center">排行榜，比如微信运动排行榜</td></tr><tr><td style="text-align:center">list</td><td style="text-align:center">分页功能，lrange做基于redis的分页功能，性能很好；模仿一个消息队列</td></tr></tbody></table><h4 id="3-说一下-Redis有什么优点和缺点-？">3.<strong>说一下</strong> <strong>Redis</strong>有什么优点和缺点 ？</h4><table><thead><tr><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center"><strong>速度快</strong>：因为在内存中</td><td style="text-align:center"><strong>存储有限</strong>：因为Redis是内存数据库，大小和机器本身内存有关</td></tr><tr><td style="text-align:center"><strong>支持多种数据结构：</strong> String，List，Set，Hash，Sorted Set等</td><td style="text-align:center">完成重同步耗费CPU资源和带宽</td></tr><tr><td style="text-align:center"><strong>持久化存储</strong>：RDB和AOF</td><td style="text-align:center"><strong>当Redis重启后</strong>通过把硬盘文件重新加载到内存，速度比较慢，这个时候redis做不了其它事。</td></tr><tr><td style="text-align:center"><strong>高可用</strong>：内置 <u>Redis Sentinel</u> （哨兵），实现主从故障自动转移。 内置 <u>Redis Cluster</u> ，提供集群方案。</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>丰富特性</strong>：Key过期、计数、分布式锁</td><td style="text-align:center"></td></tr></tbody></table><h4 id="4-Redis的数据结构？key是怎么存储的？">4. Redis的数据结构？key是怎么存储的？</h4><blockquote><p>参考：<a href="https://juejin.cn/post/6862291064624152583">【大课堂】Redis底层数据存储原理</a></p></blockquote><ul><li><p><strong>概述</strong></p><p>Redis底层采用<strong>数组</strong>， key就是对应数组的<strong>索引</strong> ，采用Hash(key)映射到数组上。解决冲突采用<strong>链地址法</strong>。</p><p>具体可看参考下文。</p></li><li><p><strong>底层存储原理</strong></p><p>redis 中以<code>redisDb</code>作为整个缓存存储的核心，保存着我们<strong>客户端需要的缓存</strong>数据。</p><p>其结构如下：</p><p><img src="https://i.loli.net/2021/05/26/tbGEW3eV986aRkj.png" alt="RedisDB主体数据结构"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span>    </span><br><span class="line">       dict *dict;           <span class="comment">// 最重要--字典类型，保存数据库的键值对</span></span><br><span class="line">       dict *expires;        <span class="comment">// 重要--字典类型，保存过期的时间          </span></span><br><span class="line">       dict *blocking_keys;  <span class="comment">// 和ready_key 实现BLPOP等阻塞命令         </span></span><br><span class="line">       dict *ready_keys;     <span class="comment">// 同上      </span></span><br><span class="line">       dict *watched_keys;   <span class="comment">// 实现watch命令，记录正在被watch的key         </span></span><br><span class="line">       <span class="keyword">int</span> id;    <span class="comment">// 数据库id，默认16个，支持单个                      </span></span><br><span class="line">       <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;    <span class="comment">/* Average TTL, just for stats */</span>      </span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>现在我们来查看，<strong>dict</strong> 的结构。</p><ul><li><p><strong>dict的结构</strong></p><p><img src="https://i.loli.net/2021/05/26/kV1JhcrUwFHLznG.png" alt="image-20210526111544663"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  字典 : 每个字典使用两个哈希表，用于实现渐进式 rehash */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span>    </span><br><span class="line">       <span class="comment">// type存储了hash函数，key和value的复制函数等，比较以及销毁函数</span></span><br><span class="line">      dictType *type;   </span><br><span class="line">      <span class="comment">// privdata保存一些私有数据，决定了*type保存的函数，实现了【多态】</span></span><br><span class="line">      <span class="keyword">void</span> *privdata;     </span><br><span class="line">      dictht ht[<span class="number">2</span>];      <span class="comment">// 哈希表（2 个）,  正常使用ht[0],rehash就会扩容使用ht[1]</span></span><br><span class="line">      <span class="keyword">int</span> rehashidx;     <span class="comment">// 记录 rehash 进度的标志，值为 -1 表示 rehash 未进</span></span><br><span class="line">      <span class="keyword">int</span> iterators;    <span class="comment">// 当前正在运作的安全迭代器数量</span></span><br><span class="line">&#125; dict;  </span><br></pre></td></tr></table></figure><p>上述<code>dictht</code>就是个hash表，包含：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span>    </span><br><span class="line">   <span class="comment">// 哈希表节点指针数组（俗称桶，bucket）    </span></span><br><span class="line">   dictEntry **table;    </span><br><span class="line">   <span class="comment">// 指针数组的大小   </span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> size;    </span><br><span class="line">   <span class="comment">// 指针数组的长度掩码，用于计算索引值，其实永远都是size-1    </span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;   </span><br><span class="line">   <span class="comment">// 哈希表现有的节点数量   </span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><ul><li><p><strong>dictEntry 指针数组（table</strong>）。key 的哈希值最终映射到这个数组的某个位置上（对应一个 bucket）。如果多个 key 映射到同一个位置，就发生了冲突，那么就拉出一个 dictEntry 链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表节点dictEntry</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span>     </span><br><span class="line">    <span class="keyword">void</span> *key;    <span class="comment">// redis的键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>        </span><br><span class="line">    <span class="keyword">void</span> *val;    <span class="comment">// 存储了对应string/set/list/hash/zset的数据     </span></span><br><span class="line">    <span class="keyword">uint64_t</span> u64;        </span><br><span class="line">    <span class="keyword">int64_t</span> s64; </span><br><span class="line">    &#125; v;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  <span class="comment">//链表后续节点</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure></li><li><p><em><strong>size</strong></em>：标识 dictEntry 指针数组的长度。它总是 2 的指数次幂。</p></li></ul><p>上面<code>dictEntry</code> 的<strong>value</strong> 最终指向了<code>redisObject</code>对象，我们来观察下其结构。</p></li><li><p><strong>Redis Object</strong></p><p><img src="https://i.loli.net/2021/05/26/kvhZQdtOuJjE6gY.png" alt="image-20210526112251563"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span>    </span><br><span class="line">     <span class="keyword">unsigned</span> type:<span class="number">4</span>;     <span class="comment">// 类型 ，比如string，set等，才能确定是哪种数据结构使用什么API操作   </span></span><br><span class="line">     <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// encoding 表示 ptr 指向的具体数据结构,这个对象使用什么数据结构实现   </span></span><br><span class="line">     <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS;  <span class="comment">// 对象最后一次被访问的时</span></span><br><span class="line">     <span class="keyword">int</span> refcount;    <span class="comment">// 引用计数         </span></span><br><span class="line">     <span class="keyword">void</span> *ptr;  <span class="comment">// 指向底层数据结构的指针 </span></span><br><span class="line"> robj;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="4-1-String、list、hash、set、zset的底层结构是什么？">4.1 String、list、hash、set、zset的底层结构是什么？</h5><blockquote><p>参考：<a href="https://i6448038.github.io/2019/12/01/redis-data-struct/">图解redis五种数据结构底层实现(动图哦)</a></p><p>版本：redis 3.0.6中版本各种数据结构的实现</p></blockquote><ol><li><p><strong>String</strong></p><ul><li>embstr和raw都是由SDS动态字符串构成的 ，底层结构应该都是<strong>char数组</strong>吧 ；</li><li>int ，就是指<strong>int类型</strong>。</li></ul><p><img src="https://i.loli.net/2021/05/26/h4mzJvU9I5BEj1o.png" alt="img"></p></li><li><p><strong>list</strong></p><p><img src="https://i.loli.net/2021/05/26/QSgDl39yIA5uXN2.png" alt="img"></p></li><li><p><strong>hash</strong></p><p><img src="https://i.loli.net/2021/05/26/9X8gPmG6MeDb4V3.png" alt="img"></p></li><li><p><strong>set</strong></p><p>intset是集合键的底层实现方式之一，是int类型数组。</p><p><img src="https://i.loli.net/2021/05/26/KXD9yHLewkIFGha.png" alt="img"></p><img src="https://i.loli.net/2021/05/26/rn3BfhLOT8dsRCH.png" alt="img" style="zoom:67%;" /></li><li><p><strong>zest</strong></p><p><img src="https://i6448038.github.io/img/redis-data-struct/object_zset.png" alt="img"></p></li></ol><h5 id="4-2-讲讲redis的hash表扩容方式？">4.2 讲讲redis的hash表扩容方式？</h5><blockquote><p>参考：<a href="https://luoming1224.github.io/2018/11/12/%5Bredis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Dredis%E6%B8%90%E8%BF%9B%E5%BC%8Frehash%E6%9C%BA%E5%88%B6/">[redis学习笔记]redis渐进式rehash机制</a></p></blockquote><ul><li><p><strong>扩容条件</strong></p><ul><li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 （<strong>保存的key超过哈希表大小</strong>）；</li><li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；</li></ul></li><li><p><strong>渐进式rehash</strong></p><ol><li><p>新建一个哈希表大小，为<code>2^N</code> 次方，并分配内存，此时字典<strong>同时持有：ht[0] 和 ht[1] 两个哈希表</strong></p><blockquote><p>同hashmap：哈希表掩码sizemask为size-1，当size满足2的n次方时，计算每个key的索引值时只需要用key的hash值与掩码sizemask进行位与操作，替代求余操作，计算更快。</p></blockquote></li><li><p>哈希表赋值给字典的ht[1]，然后将rehashidx赋值为0，表示rehash工作开始</p><blockquote><p>rehashidx也标识了，当前rehash<strong>进行到了哪个槽</strong></p></blockquote></li><li><p>在 rehash 进行期间，：每次对字典执行<strong>添加、删除、查找或者更新操作</strong>时， 程序除了执行指定的操作以外， 还会顺带将 <strong>ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]</strong> 。</p><p>当 rehash 工作完成之后， 程序将 rehashidx 属性的值**+1**</p></li><li><p>随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] 。此时<code>rehashidx=-1</code>，表示rehash完成。</p></li></ol><p>采取分而治之的方式， 将 rehash 键值对所需的计算工作<strong>均摊</strong>到对字典的每个添加、删除、查找和更新操作上， 从而<strong>避免了集中式 rehash 而带来的庞大计算量</strong>。</p></li><li><p><strong>渐进式rehas优缺点</strong></p><ul><li>优点：避免redis阻塞</li><li>缺点：rehash需要分配一个新的hash表，会使得<strong>内存爆增，使得大量key被驱逐</strong></li></ul></li></ul><h5 id="4-3-rehash过程中增删查改怎么操作呢？">4.3 rehash过程中增删查改怎么操作呢？</h5><ul><li><p><strong>增加</strong>： 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作</p></li><li><p><strong>删除（delete）、查找（find）、更新（update）等</strong>： 同时在ht[0] &amp; ht[1]两个表进行。</p><blockquote><p>比如：要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找。</p></blockquote></li></ul><h4 id="5-说说Redis有序集合zset的底层结构？">5. 说说Redis有序集合zset的底层结构？</h4><p>zset底层的存储结构包括<u>ziplist</u>或<u> skiplist &amp; dic</u> ，<strong>当满足以下两个条件的时候使用ziplist</strong>：</p><ul><li>有序集合保存的元素数量小于128个</li><li>有序集合保存的所有元素的长度小于64字节</li></ul><p>其余情况用skiplist。</p><ul><li><p><strong><a href="https://www.cnblogs.com/exceptioneye/p/7040815.html">什么是ziplist？</a></strong></p><p>ziplist是一个经过特殊编码的<u>双向链表</u>，以O(1)的时间复杂度在表的两端提供push和pop操作。</p><p>ziplist将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。</p><ul><li><p><strong>使用原因</strong>：一个普通的<u>双向链表</u>，链表中每一项都<u>占用独立的一块内存</u>，各项之间用地址指针（或引用）连接起来；这种方式会带来大量的<strong>内存碎片</strong>，而且<strong>地址指针也会占用额外的内存</strong>。</p></li><li><p><strong>具体结构</strong></p><p><img src="https://i.loli.net/2021/05/04/zYwG2PtCZq84hgV.jpg" alt="img"></p><ul><li>entry：表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构。</li></ul></li></ul></li><li><p><a href="https://segmentfault.com/a/1190000037473381"><strong>什么是skiplist ?</strong></a></p><p>跳表是在单链表上实现多级索引，<strong>可以实现 <u>二分查找</u> 的有序链表</strong>。</p><blockquote><p>跳表插入、删除、查找元素的时间复杂度跟红黑树都是一样量级的，时间复杂度都是O(logn)。</p></blockquote><ul><li><p>主要形式</p><p>在单链表上进行多级索引。</p><p><img src="https://i.loli.net/2021/05/28/Rc6tAuOmELHz5nN.png" alt="image-20210528143426041"></p></li><li><p>构建过程</p><blockquote><p>上面链表是如何构建的呢，请见下图。</p></blockquote><p>⚠️ skiplist为了避免上下两层出现<strong>严格1:2</strong>数量对应关系后，新插入节点会打乱这种关系，而需要<strong>把新插入节点后所以节点都进行调整</strong>。</p><p><strong>它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)</strong>。</p><img src="https://i.loli.net/2021/05/28/sEy7B6gUHuIfbd3.png" alt="preview" style="zoom: 67%;" /></li><li><p>查找过程</p><blockquote><p>zset : <code>&lt;key&gt; &lt;score&gt; &lt;member&gt;</code></p></blockquote><p>在上图中，我们没有区分member和score，但是实际上链表是<strong>按score进行排序，查找也是在比较score</strong>。</p><blockquote><p>以查找 和 插入23为例。</p></blockquote><ol><li>从最高层（第4）层开始查找，因为<code>7&lt;23</code> ,本应该继续往后查找，但是后继节点为null，所以往下一层进行查找</li><li>此时第3层，满足<code>7&lt;23&lt;37</code> ，继续往下一层继续查找</li><li>此时第2层，<code>7&lt;23 &amp; 19&lt;23</code> ，往下第二层的下一个节点（19）查找；此时满足<code>19&lt;23&lt;37</code> ，继续往下一层</li><li>此时第1层，一直往后遍历到22，发现<code>22&lt;23&lt;26</code> ：<ul><li>如果此时是<strong>查询23</strong>：返回null，不存在</li><li>此时是<strong>插入23</strong>：生成新节点 &amp; 随机生成层数，（1）将新节点各层指针指向对应层的<strong>下一个节点</strong>（不存在则指向null）（2）将新节点节点各层<strong>前一个节点</strong>对应层数的指针指向新节点</li></ul></li></ol></li></ul></li></ul><h5 id="5-1-Redis为什么不用红黑树">5.1 Redis为什么不用红黑树</h5><blockquote><p>参考 ： <a href="https://www.zhihu.com/question/20202931">知乎回答</a></p></blockquote><p>虽然跳表操作<strong>时间复杂度和红黑树相同</strong> ，但是：</p><ol><li><p><strong>实现简单</strong>：跳表代码实现更易读</p></li><li><p><strong>区间查找</strong>：跳表区间查找效率更高</p></li></ol><h4 id="6-Redis持久化方式有哪些？以及有什么区别？">6. <strong>Redis持久化方式有哪些？以及有什么区别</strong>？</h4><p><code>Redis</code> 提供两种持久化机制 <code>RDB</code> 和 <code>AOF</code> 机制。</p><ul><li><p><strong>各自优点</strong></p><table><thead><tr><th style="text-align:center">RDB</th><th style="text-align:center">AOF</th></tr></thead><tbody><tr><td style="text-align:center">【<strong>方便</strong>】只有一个文件 <code>dump.rdb</code> ，方便持久化</td><td style="text-align:center">【<strong>数据安全</strong>】 AOF 持久化有 <code>always</code>，每进行一次命令操作就记录到 AOF 文件中一次。</td></tr><tr><td style="text-align:center">【<strong>容灾性好</strong>】一个文件可以保存到安全的磁盘</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">【<strong>性能</strong>】最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">【<strong>启动效率高</strong>】相对于数据集大时，比 AOF 的<strong>启动效率</strong>更高</td><td style="text-align:center"></td></tr></tbody></table></li><li><p><strong>各自缺点</strong></p><table><thead><tr><th style="text-align:center">RDB</th><th style="text-align:center">AOF</th></tr></thead><tbody><tr><td style="text-align:center">【<strong>安全性低</strong>】 <code>RDB</code> 是间隔一段时间进行持久化</td><td style="text-align:center">【<strong>启动效率低</strong>】数据集大的时候，比 RDB 启动效率低。</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">【<strong>恢复慢</strong>】<code>AOF</code> 文件比 <code>RDB</code> 文件大，且恢复速度慢。</td></tr></tbody></table></li></ul><h5 id="6-1-AOF-重写了解吗？">6.1 AOF 重写了解吗？</h5><p>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，<strong>但体积更小</strong>。</p><blockquote><p>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的<strong>键值</strong>对来实现的，程序<strong>无须对现有AOF文件进行</strong>任伺读入、分析或者写入操作。</p></blockquote><p>具体过程如下：</p><ol><li>在执行 <code>BGREWRITEAOF</code> 命令，开始重写；</li><li>Redis 服务器会维护一个 AOF <strong>重写缓冲区</strong>，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令；</li><li>当子进程完成创建新AOF文件的工作之后，服务器会将重写<strong>缓冲区中的所有内容追加到新AOF文件的末尾</strong> ；</li><li>最后，服务器用新的AOF文件替换旧的 AOF文件，以此来完成AOF文件重写操作。</li></ol><h4 id="7-Redis持久化有两种，那应该怎么选择呢？">7. Redis持久化有两种，那应该怎么选择呢？</h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/39412293">https://zhuanlan.zhihu.com/p/39412293</a></p></blockquote><ol><li><strong>如果Redis中的数据完全丢弃也没有关系</strong>（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化；</li><li><strong>单机环境</strong>： 如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF；</li><li><strong>主从架构</strong>：<ul><li><strong>master</strong>：完全关闭持久化（包括RDB和AOF），这样可以让master的性能达到最好；</li><li><strong>slave：关闭RDB，开启AOF</strong>（如果对数据安全要求不高，开启RDB关闭AOF也可以），并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；然后关闭AOF的自动重写，然后添加定时任务，在每天Redis闲时（如凌晨12点）调bgrewriteaof。</li></ul></li></ol><h4 id="8-（-u-不太理解-u-）pipeline有什么好处，为什么要用-pipeline？">8. （<u>不太理解</u>）pipeline有什么好处，为什么要用 pipeline？</h4><ul><li><p>使用 pipeline（管道）的好处在于可以将多次 I/O 往返的时间缩短为一次，但是要求管道中执行的指令间没有因果关系；</p></li><li><p>用 pipeline 的原因在于可以实现请求/响应服务器的功能，当客户端尚未读取旧响应时，它也可以处理新的请求。如果客户端存在多个命令发送到服务器时，那么客户端无需等待服务端的每次响应才能执行下个命令，只需最后一步从服务端读取回复即可。</p></li></ul><h4 id="9-怎么使用-Redis实现消息队列？-如何实现延时队列？">9.<strong>怎么使用</strong> Redis实现消息队列？ 如何实现延时队列？</h4><ul><li><p><strong>消息队列</strong>：一般使用 <code>list</code> 结构作为队列， <code>rpush</code> 生产消息， <code>lpop</code> 消费消息。当 <code>lpop</code> 没有消息的时候，要适当<code>sleep</code> 一会再重试；</p></li><li><p><strong>延时队列</strong>： ：使用<code>sortedset</code> ，拿<u>时间戳</u>作为 <code>score</code> ，消息内容作为 <code>key</code> 调用 <code>zadd</code> 来生产消息，消费者用<code>zrangebyscore</code> 指令获取符合条件的数据轮询进行处理。</p><blockquote><p>什么是延时队列？</p><p>当用户发送一个消息请求给服务器后台的时候，服务器会检测这条消息是否需要进行延时处理：</p><ul><li>如果需要就放入到延时队列中，由延时任务检测器进行检测和处理；</li><li>如果不需要进行延时处理的任务，服务器会立马对消息进行处理，并把处理后的结果返会给用户。</li></ul><p>【举个例子】</p><ul><li>点外卖时，下单后不会立即安排配送，而是等待一段时间让商户接单才正式安排配送，否则超时取消</li></ul></blockquote></li></ul><h2 id="6-2-Redis单线程模型">6.2 Redis单线程模型</h2><h4 id="1-为什么-Redis-使用单线程模型？单线程模型效率也能那么高？">1.<strong>为什么</strong> <strong>Redis 使用单线程模型？单线程模型效率也能那么高</strong>？</h4><ol><li><p>采用单线程，避免了不要的上下文切换和竞争条件；</p></li><li><p><strong>其次 CPU 不是 Redis 的瓶颈</strong>，Redis 的瓶颈最有可能是机器内存或者网络带宽。</p></li></ol><p>【<strong>效率高的原因</strong>】</p><p>. 1. <strong>C语言</strong>实现，效率高</p><ol start="2"><li><p>纯<strong>内存</strong>操作</p></li><li><p><strong>基于非阻塞的IO复用模型机制</strong>（可能会跟自己挖坑）</p></li><li><p>单线程的话就能避免多线程的频繁上下文切换问题（为什么单线程效率高）</p></li><li><p>丰富的数据结构（<u>全程采用hash结构，读取速度非常快</u>，对数据存储进行了一些优化，<u>比如zset压缩表，跳表等</u>）</p></li></ol><h4 id="2-（新，易忘）说说-Redis-的单线程模型-？">2.<strong>（新，易忘）说说 Redis 的单线程模型</strong> ？</h4><blockquote><p>这问题是因为前面回答问题的时候提到了 Redis 是基于非阻塞的IO复用模型。如果这个问题回答不上来，就相当于前面的回答是给自己挖坑了。</p></blockquote><p>redis 内部使⽤⽂件事件处理器 file event handler ，这个⽂件事件处理器是单线程的，所以redis 才叫做单线程的模型。它采⽤ IO 多路复⽤机制一个线程同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进⾏处理。<br>⽂件事件处理器的结构包含 4 个部分：</p><ol><li>多个 socket</li><li>IO 多路复⽤程序</li><li>⽂件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ol><p>（1） IO 多路复⽤程序会监听多个 socket，（2）会将 socket 产⽣的事件<strong>放⼊队列中排</strong>队，（3）事件分派器每次从队列中取出⼀个事件，（4）把该事件交给对应的事件处理器进⾏处理。</p><h4 id="3-你说Redis是单线程的，那如何处理高并发？比如1000个并发请求同时发生？">3. 你说Redis是单线程的，那如何处理高并发？比如1000个并发请求同时发生？</h4><ul><li><p>Redis采用了<strong>IO多路复用机制</strong>，使其在网络IO操作中能并发处理大量的客户端请求。</p><blockquote><p>详见上一个问题。</p></blockquote></li><li><p>Redis可以采用<strong>主从架构</strong>，master负责写，slave负责读。</p></li></ul><h4 id="4-说说你对Redis事务的理解-？">4.<strong>说说你对Redis事务的理解</strong> ？</h4><p>Redis 中的事务是<strong>一组命令的集合</strong>，是 Redis 的最小执行单位。</p><blockquote><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的 Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p></blockquote><ul><li><p><strong>需要注意的地方</strong></p><ol><li><p><strong>Redis 事务不支持回滚</strong>：不像 MySQL 的事务一样，要么都执行要么都不执行；</p><blockquote><p>因为回滚需要增加很多工作，而不支持回滚则可以保持简单、快速的特性。</p></blockquote></li><li><p>Redis 服务端在执行事务的过程中，<u><strong>不会被其他客户端发送来的命令请求打断</strong></u>，直到事务命令全部执行完毕才会执行其他客户端的命令。</p></li></ol></li></ul><h4 id="5-为什么Redis的操作是原子性的，怎么保证原子性的？">5.<strong>为什么Redis的操作是原子性的，怎么保证原子性的</strong>？</h4><ul><li><strong>原子性</strong>。 因为Redis是单线程的， Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。</li><li><strong>事务性</strong>。 Redis中的事务其实是要保证<u>批量操作</u>的原子性。</li></ul><h2 id="6-3-Redis缓存">6.3 Redis缓存</h2><h4 id="1-为什么要用缓存-？怎么提高缓存命中率？">1.<strong>为什么要用缓存</strong> <strong>？怎么提高缓存命中率</strong>？</h4><ul><li><p><strong>为什么用缓存</strong>？</p><p>把热点数据存入内存中，提高读写性能。</p></li><li><p><strong>提高命中率</strong>？</p><ol><li>增加缓存空间</li><li>提升缓存更新频率</li><li>提前加载数据到缓存中</li></ol></li></ul><h4 id="2-缓存雪崩、缓存穿透、缓存击透、缓存预热、缓存更新、缓存降级等？">2.<strong>缓存雪崩、缓存穿透、缓存击透、缓存预热、缓存更新、缓存降级等</strong>？</h4><blockquote><p>参考：<a href="https://juejin.cn/post/6844904173725548557">https://juejin.cn/post/6844904173725548557</a></p></blockquote><ul><li><p><strong>缓存雪崩</strong></p><blockquote><p>简而言之：<strong>Redis 挂掉了</strong>，请求全部走数据库 。</p></blockquote><ul><li><p><strong>例如</strong>： 对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库；</p><ul><li><strong>key过期解决</strong>： 在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。</li></ul><p>更通用情况的做法：</p><ul><li><strong>事发前</strong>：实现 Redis 的<strong>高可用 (主从架构 + Redis Cluster)</strong>，尽量避免 Redis 挂掉这种情况发生；</li><li><strong>事发中</strong>：万一 Redis 真的挂了，我们可以设置<strong>本地缓存 (ehcache)+ 限流 (hystrix)</strong>，尽量避免我们的数据库被干掉；</li><li><strong>事发后：<strong>redis <strong>持久化</strong>，重启后</strong>自动</strong>从磁盘上加载数据，<strong>快速恢复缓存数据</strong>。</li></ul></li></ul></li><li><p><strong>缓存穿透</strong></p><blockquote><p>查询一个一定<strong>不存在的数据</strong> ，导致<strong>每次请求都要到数据库去查询</strong>，失去了缓存的意义 。</p></blockquote><ul><li><strong>解决1：</strong> 使用布隆过滤器 (BloomFilter) <strong>提前拦截</strong>，不合法就不让这个请求到数据库层；</li><li><strong>解决2：<strong>当我们从数据库找不到的时候，我们也将这个</strong>空对象设置到缓存里边去</strong>，下次再请求的时候，就可以从缓存里边获取了。</li></ul></li><li><p><strong>缓存击穿</strong></p><p>在平常高并发的系统中，大量的请求同时查询一个key时，此时这个<strong>高热key</strong>正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为缓存击穿。</p><ul><li><p><strong>解决1：使用互斥锁(mutex key</strong>)。 是只让一个线程构建缓存，<strong>其他线程等待构建缓存</strong>的线程执行完，重新从缓存获取数据就行。</p><blockquote><p>如果是单机，可以用synchronized或者lock来处理，如果是【<strong>淘特】分布式环境可以用分布式锁</strong>就可以了。</p><p><img src="https://i.loli.net/2021/05/06/4oRvz638eOiEFTf.png" alt="image-20210506115517283"></p></blockquote></li><li><p><strong>解决2：</strong> <strong>key永不过期</strong>。 把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建。</p><p><img src="https://i.loli.net/2021/05/06/jZ9v47kthTmADqg.png" alt="image-20210506115748032"></p></li></ul></li><li><p><strong>缓存预热</strong></p><blockquote><p>系统上线后，将相关的缓存数据直接加载到缓存系统。</p></blockquote><p>这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。</p></li><li><p><strong>缓存更新</strong></p><ul><li><code>LRU</code>(访问时间最旧淘汰)/<code>LFU</code>(把频次低的淘汰掉)</li><li>超时剔除：设置key过期时间</li><li>主动更新：开发设置生命周期</li></ul></li><li><p><strong>缓存降级</strong></p><p>降级的情况，<u>就是<strong>缓存失效或者缓存服务挂掉</strong>的情况下，我们也不去访问数据库</u>。我们<strong>直接访问内存部分数据缓存</strong>或者直接返回默认数据。</p><blockquote><p>对于应用的首页，一般是访问量非常大的地方，首页里面往往包含了部分推荐商品的展示信息。这些推荐商品都会放到缓存中进行存储，同时我们为了避免缓存的异常情况，对<strong>热点商品数据</strong>也存储到了<strong>内存</strong>中。同时内存中还保留了一些默认的商品信息。</p><p>如下图所示：</p></blockquote><p><img src="https://i.loli.net/2021/05/06/a1XZHWCterV3uR2.png" alt="image-20210506115200276"></p></li></ul><h4 id="3-Redis-设置key过期后如何处理？Redis缓存刷新策略（内存淘汰机制）有哪些？">3. Redis 设置key过期后如何处理？<strong>Redis缓存刷新策略（内存淘汰机制）有哪些</strong>？</h4><ul><li><p><strong>Redis 设置过期时间</strong></p><p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置⼀个过期时间。</p><ul><li>如我们⼀般项⽬中的 <strong>token</strong> 或者⼀些登录信息，尤其是短信验证码都是有时间限制的，过期后基本不会使用</li></ul></li><li><p><strong>过期后采用什么策略进行删除</strong>？</p><ul><li><strong>定期删除</strong>：redis默认是<strong>每隔 100ms</strong> 就<strong>随机抽取</strong>⼀些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这⾥是随机抽取的。<strong>为什么要随机呢</strong>？你想⼀想假如 redis 存了⼏⼗万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li></ul></li><li><p><strong>惰性删除</strong>：<u><strong>定期删除可能会导致很多过期 key 到了时间并没有被删除掉</strong></u>，所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存⾥，除⾮你的系统去查⼀下那个 key，才会被redis给删除掉。</p><ul><li><strong>内存淘汰策略</strong> ：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没⾛惰性删除，此时会怎么样？如果大量过期key堆积在内存⾥，导致redis内存块耗尽了。所以有内存淘汰策略。</li><li><strong>volatile-lru</strong>：从已设置过期时间的数据中挑选最近最少使⽤的数据淘汰<ul><li><p><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选<strong>将要过期的数据</strong>淘汰</p></li><li><p><strong>volatile-random</strong>：从已设置过期时间的数据中任意选择数据淘汰</p></li><li><p><strong>allkeys-lru</strong>：当内存不⾜以容纳新写⼊数据时，在键空间中，移除最近最少使⽤的key（这个是最常⽤的）</p></li><li><p><strong>allkeys-random</strong>：从数据集中任意选择数据淘汰</p></li><li><p><strong>no-eviction</strong>：禁⽌驱逐数据，也就是说当内存不⾜以容纳新写⼊数据时，新写⼊操作会报错。这个应该没⼈使⽤吧！</p></li></ul></li></ul></li></ul><h4 id="4-Redis报内存不足怎么处理？">4. Redis报内存不足怎么处理？</h4><ul><li>增加 Redis 可用内存：<ol><li>修改件 <code>redis.conf</code> 的 <code>maxmemory</code> 参数；</li><li>使用分布式集群，提高存储量；</li></ol></li><li><strong>设置缓存淘汰策略</strong>：提高内存的使用效率；</li></ul><h4 id="5-【重点】缓存和数据库谁先更新呢？-（保持缓存和数据库一致性）">5. 【<strong>重点</strong>】<strong>缓存和数据库谁先更新呢</strong>？ <strong>（保持缓存和数据库一致性</strong>）</h4><blockquote><p>参考：<a href="https://learnku.com/articles/22363">https://learnku.com/articles/22363</a></p></blockquote><ul><li><p><strong>对于读（查询）操作</strong></p><p>一般我们对<strong>读操作</strong>的时候有这么一个固定的套路：</p><ol><li>如果我们的数据在缓存里边有，那么就直接取缓存的；</li><li>如果缓存里没有我们想要的数据，我们会先去查询数据库，<u>然后将数据库查出来的数据写到缓存中</u>；</li><li>最后将数据返回给请求。</li></ol><p><strong>不用更新（写）数据库，只用更新（写）缓存</strong>。</p></li><li><p><strong>对于写操作导致双写问题</strong></p><blockquote><p><a href="https://developer.aliyun.com/article/712285">如何保证缓存(redis)与数据库(MySQL)的一致性</a></p></blockquote><p>写操作会更新数据库，那么缓存也要进行更新，此时会发生数据库和缓存不一致的问题。</p><blockquote><p><strong>键的过期时间</strong>：能保证缓存和数据库的数据最终是一致的。</p><p><u>因为只要缓存数据过期了，就会被删除</u>。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据<strong>重新写入到缓存</strong>中。<br>除了设置过期时间，我们还需要做更多的措施来尽量避免数据库与缓存处于不一致的情况发生。</p></blockquote><p>直接看结论：</p><blockquote><p>不考虑更新缓存而是<strong>直接删除缓存</strong>，因为更新逻辑较为复杂涉及到其它数据，更新cache消耗会比较大。</p></blockquote><ul><li><strong>先删除缓存，再更新数据库</strong><ul><li>在高并发下可能<strong>会导致数据长时间不一致</strong></li><li>采用<u>异步更新缓存</u>的策略，不会导致数据不一致，但在数据库更新完成之前，都需要到数据库层面去读取数据，读的效率不太好——<strong>保证了数据的一致性，适用于对一致性要求高的业务</strong></li></ul></li><li><strong>先更新数据库，再删除缓存</strong> (<strong>Cache Aside Pattern 设计模式</strong>)<ul><li>在高并发下不会导致数据长时间不一致</li><li>在<strong>更新数据库期间，cache中的旧数据会被读取</strong>，可能会有一段时间的数据不一致，但读的效率很好。——<strong>保证了数据读取的效率，如果业务对一致性要求不是很高，这种方案最合适</strong></li></ul></li></ul></li><li><p><strong>先删除缓存，再更新数据库</strong></p><blockquote><p>⚠️ <strong>只有读才会更新缓存！！</strong></p></blockquote><ul><li><p><u>正常情况</u></p><ol><li>A线程进行写操作，先淘汰缓存，再更新数据库</li><li>B线程进行读操作，发现缓存中没有想要的数据，从数据库中读取更新后的新数据 ，并更新缓存</li></ol></li><li><p><u>高并发异常</u></p><ol><li>A线程进行<strong>写</strong>操作，先淘汰缓存，但由于<u>网络原因等未及时更新数据库</u></li><li>B线程<strong>读</strong>取缓存失败，去<u>读取数据库的是旧值</u> ，并将<u>旧数据放入缓存</u></li><li>A线程再更新数据库成功（<strong>同步情况下写操作不更新redis而读操作更新redis</strong>），<u>此时缓存（旧）和数据库（新）不一致</u></li></ol><p>而且没有设置键过期，会保持很长时间的数据不一致。</p></li><li><p><u>解决方案</u></p><ul><li><strong>异步更新缓存</strong> ：B线程读操作不更新缓存，而是由<u>A线程写操作更新数据库成功后，通过binlog异步更新缓存</u></li><li><strong>延时双删</strong>： A线程<u>休眠M秒（确保事务都已提交）</u>，再更新数据库成功后，<strong>再次删除缓存</strong>。其它线程进行<strong>读</strong>操作时，缓存中无数据，从数据库中读取的是更新后的新数据，<u>又再次一致了</u>。</li></ul></li></ul></li><li><p><strong>先更新数据库，再删除缓存</strong></p><ul><li><p><u>正常情况</u></p><ol><li>A线程进行<strong>写</strong>操作，先更新数据库，再删除缓存</li><li>B线程进行<strong>读</strong>操作，发现缓存中没有想要的数据，从数据库中读取更新后的新数据 ，并更新缓存</li></ol></li><li><p><u>高并发异常</u></p><ol><li><p>A线程进行<strong>写</strong>操作，先更新数据库，<u>但未来得及删除缓存</u></p></li><li><p>B线程进行<strong>读</strong>操作，<u><strong>读取缓存的旧数据</strong>（背错一次），此时数据不一致</u></p></li><li><p>A线程再删缓存</p></li></ol><p>但其它线程进行读数据的时候更新缓存，更新缓存又一致了，<u>不一致的时间很短。</u></p><p>但是还可能会考虑：3. <strong>A线程删除缓存失败</strong> ，此后读取的一直都是旧数据了。</p></li><li><p><u>解决方案</u></p><ul><li><strong>消息队列进行删除补偿</strong>。如果Redis删除发现报错，将Redis的key作为消息发送到消息队列中，系统收到消息队列再次对Redis进行删除操作。</li></ul></li></ul></li></ul><h2 id="6-4-集群相关">6.4 集群相关</h2><h4 id="1-Redis的同步机制了解是什么？">1. Redis的同步机制了解是什么？</h4><p>Redis主从复制可以根据是否是全量分为：<u>全量同步</u>和<u>增量同步</u>。</p><blockquote><p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。</p></blockquote><ul><li><p><strong>全量同步</strong></p><p>Redis全量复制一般发生在Slave初始化阶段，这时<strong>Slave需要将Master上的所有数据都复制一份</strong>：</p><p>​       1）从服务器连接主服务器，发送<code>SYNC</code>命令；<br>　　2）主服务器接收到SYNC命名后，开始执行<code>BGSAVE</code>命令（1）生成<u>RDB文件</u>  （2）并使用<u>缓冲区记录</u>此后执行的所有<strong>写</strong>命令；<br>　　3）主服务器<code>BGSAVE</code>执行完后，向所有从服务器发送RDB快照文件，并在发送期间继续记录被执行的写命令；<br>　　4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；<br>　　5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</p></li><li><p><strong>增量同步</strong></p><p>Slave初始化后开始正常工作时：<strong>主服务器发生的写操作同步到从服务器的过程</strong>。</p><ol><li>主服务器每执行一个<strong>写命令</strong>就会向从服务器发送相同的写命令；</li><li>从服务器接收并执行收到的写命令。</li></ol></li></ul><h4 id="2-【新补充】-Redis集群架构模式有哪几种？集群的原理是什么？">2.【新补充】 <strong>Redis</strong>集群架构模式有哪几种？集群的原理是什么？</h4><blockquote><p>待补充：<a href="https://blog.csdn.net/zzhongcy/article/details/108446687">Redis 架构模式详解（单机、主从、哨兵、集群模式）</a></p></blockquote><ul><li><p><strong>1. 单机模式</strong></p><blockquote><p>QPS（每秒查询速度）大约在几万左右。</p></blockquote><p>安装一个 Redis，启动起来，业务调用即可。</p><p><img src="https://i.loli.net/2021/05/25/m5euvrDF1UOtYbn.png" alt="image-20210525232444113"></p><ul><li><strong>优点</strong>： 部署简单；成本低；高性能</li><li><strong>缺点</strong>： 单节点宕机风险 ;  单机高性能受限于 CPU 的处理能力</li></ul></li><li><p><strong>2. 主从复制</strong></p><p><img src="https://i.loli.net/2021/05/25/tGy6WCzmKpS4Mfr.png" alt="image-20210525232806643"></p><p>Redis 的复制（Replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品。</p><ul><li>被复制的服务器为主服务器（Master），而通过复制创建出来的复制品则为从服务器（Slave）。</li></ul><p>主要优缺点：</p><ul><li><strong>优点</strong>： Master/Slave 角色方便水平扩展，降低 Master <strong>读</strong>压力，转交给 Slave 节点；</li><li><strong>缺点</strong>： 可靠性保证不是很好，主节点故障便无法提供写入服务；没有解决主节点<strong>写的压力</strong> ；主节点宕机，需要人为干预。</li></ul></li><li><p><strong>3. 哨兵模式</strong></p><blockquote><p>Redis 2.8版本后引入了哨兵的概念。</p></blockquote><p><img src="https://i.loli.net/2021/05/01/81lKSUu7skhM2Yr.png" alt="img"></p><p>主从模式中，当主节点宕机之后，<strong>从节点是可以作为主节点顶上来继续提供服务</strong>，<u>但是需要修改应用方的主节点地址</u>，还需要命令所有从节点去复制新的主节点数据，整个过程需要<strong>人工干预</strong>。</p><p>为此，引入了哨兵（Sentinel）这个概念，在<strong>主从复制的基础</strong>上，哨兵实现了<strong>自动化故障恢复</strong>。哨兵模式由两部分组成，哨兵节点和数据节点：</p><ul><li><p><strong>哨兵节点</strong>：哨兵节点是特殊的 Redis 节点，不存储数据；</p></li><li><p><strong>数据节点</strong>：主节点和从节点都是数据节点。</p></li></ul><p><strong>哨兵工作原理</strong>：</p><ol><li>每个 Sentinel 以每秒一次的频率向它所知的 <strong>Master，Slave 以及其他 Sentinel</strong> 节点发送一个 <code>PING</code> 命令；</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间<strong>超过配置文件 <code>own-after-milliseconds</code> 选项所指定的值</strong>，则这个实例会被 Sentinel 标记为<strong>主观下线</strong>；</li><li>如果一个 Master 被标记为主观下线，那么正在监视这个 Master 的所有 Sentinel 要以<strong>每秒一次</strong>的频率确认 Master 是否真的进入主观下线状态；</li><li>当有<strong>足够数量的 Sentinel</strong>（大于等于配置文件指定的值）在<strong>指定的时间范围内确认</strong> Master 的确进入了主观下线状态，则 Master 会被标记为<strong>客观下线</strong>；</li><li>如果 Master 处于 <strong>ODOWN 状态</strong>，则投票自动选出新的主节点;将剩余的从节点指向新的主节点继续进行数据复制；</li><li>若没有足够数量的 Sentinel 同意 Master 已经下线，Master 的客观下线状态就会被移除。<u>若 Master 重新向 Sentinel 的 PING 命令返回有效回复</u>，Master 的主观下线状态就会被移除。</li></ol><p><u><strong>哨兵模式优缺点</strong></u>：</p><ul><li><strong>优点</strong>：（1）主从自动切换，更加健壮</li><li><strong>缺点</strong>： （1）主从切换需要时间还是会丢失数据；（2）没有解决主节点<strong>写</strong>压力 （3）动态扩容复杂</li></ul></li><li><p><strong>4. 集群模式</strong></p><blockquote><p>Redis 3.0 版本引入了Redis Cluster集群模式。</p></blockquote><img src="https://i.loli.net/2021/05/25/yfskJDK3vrzUoWp.png" alt="img" style="zoom:80%;" /><ul><li>如上图所示：该集群中包含 6 个 Redis 节点，3 主 3 从，分别为 M1，M2，M3，S1，S2，S3。除了主从 Redis 节点之间进行数据复制外，所有 Redis 节点之间采用 <strong>Gossip</strong> 协议进行通信，交换维护节点元数据信息</li></ul><p>Redis Cluster 采用<strong>无中心</strong>结构，<strong>每个节点都可以保存数据</strong>和整个集群状态，每个节点<strong>都</strong>和其他所有节点<strong>连接</strong>。</p><ul><li>Cluster 一般由多个节点组成，节点数量至少为 6 个才能保证组成完整高可用的集群，其中3个为<strong>主</strong>节点，3个为<strong>从</strong>节点；</li></ul><p><strong>4.1 Redis 集群分片概念</strong></p><blockquote><p>单机、主从、哨兵的模式数据都是存储在<strong>一个master节点</strong>上，<strong>其他节点进行数据的复制</strong>。</p><p>集群模式就是把数据进行<strong>分片</strong>存储，当一个分片数据达到上限的时候，还可以分成多个分片。</p></blockquote><p>Redis Cluster 采用<strong>虚拟哈希槽分区</strong>，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式：</p><ul><li><code>HASH_SLOT = CRC16(key) % 16384</code></li></ul><p><strong>每一个主</strong>节点负责维护一部分<strong>槽</strong>以<strong>及</strong>槽所<strong>映射的键值数据</strong>。</p><ul><li><p><strong>举例说明</strong>：</p><blockquote><p>有 3 个节点的集群环境如下</p><ul><li>节点 A 哈希槽范围为 0 ~ 5500；</li><li>节点 B 哈希槽范围为 5501 ~ 11000；</li><li>节点 C 哈希槽范围为 11001 ~ 16383。</li></ul></blockquote><p><strong>增加数据</strong>： （1）根据上述公式计算<strong>新增的key存储</strong> ，映射到相应节点（假设为B）</p><p><strong>增加节点</strong>： （1）从各个节点拿出一部分哈希槽分配到新增的D节点上即可</p><p><strong>删除节点</strong>： （1）删除A节点，只需将A节点的哈希槽移动到其它节点接口</p></li></ul><p><strong>4.2 Reids集群的主从模式</strong></p><p>Redis Cluster 为了保证数据的高可用性，加入了主从模式，<strong>一个主节点对应一个或多个从节点</strong>，主节点提供数据存取，从节点复制主节点数据备份，当这个主节点挂掉后，就会通过这个主节点的从节点选取一个来充当主节点，从而保证集群的高可用。</p><p><strong>4.3 优缺点总结</strong></p><ul><li><strong>优点</strong>： （1）无中心结构 ，<strong>多</strong>节点<strong>存储</strong>数据；（2）节点动态<strong>删除、移动</strong>数据分布方便；（3）<strong>部分节点不可用</strong>，集群依旧可用（哈希槽 + 从节点备份并故障晋升主节点）；</li><li><strong>缺点</strong>： （1）<strong>异步</strong>复制，<strong>无法保证数据一致性</strong>（2）集群搭建<strong>复杂</strong>（3）<strong><code>mget</code>,<code>pipeline</code><strong>等命令。它们需要把请求</strong>分散到多个节点执行</strong>、再聚合。节点越多，性能越低</li></ul></li></ul><h4 id="3-说说-Redis哈希槽的概念？什么情况下会导致整个集群不可用？">3.<strong>说说</strong> <strong>Redis哈希槽的概念</strong>？<strong>什么情况下会导致整个集群不可用</strong>？</h4><blockquote><p>Redis 没有使用哈希一致性算法，而是使用哈希槽。Redis 中的哈希槽一共有 16384 个，计算给定密钥的哈希槽，我们只需要对密钥的 CRC16 取摸 16384。</p></blockquote><p>假设集群中有 A、B、C 三个集群节点，<strong>不存在复制模式</strong>下，每个集群的节点包含的哈希槽如下：</p><ul><li><p>节点 A 包含从 0 到 5500 的哈希槽；</p></li><li><p>节点 B 包含从 5501 到 11000 的哈希槽；</p></li><li><p>节点 C 包含从 11001 到 16383 的哈希槽；</p></li></ul><p>这时，如果<strong>节点 B 出现故障</strong>，<u>整个集群就会出现缺少 5501 到 11000</u> 的哈希槽范围而不可用。</p><h4 id="4-Redis-常见性能问题和解决方案有哪些？">4. <strong>Redis 常见性能问题和解决方案有哪些</strong>？</h4><p>Redis 常见性能问题和解决方案如下：</p><ul><li><strong>Master不做持久化，   Slave 做 AOF</strong>：Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件；如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次；</li><li><strong>同局域网</strong>：为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内；</li><li>尽量避免在压力很大的主库上增加从库；</li><li><strong>主从复制不要用图状结构</strong>，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;-Slave3….；这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变</li></ul><h2 id="6-5-Redis-Key相关">6.5 Redis Key相关</h2><h4 id="1-假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如果将它们全部找出来？">1.<strong>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某</strong>个固定的已知的前缀开头的，如果将它们全部找出来？</h4><p>我们可以使用 keys 命令和 scan 命令，但是会发现使用 scan 更好。</p><ul><li><p><strong>keys命令</strong></p><p>虽然可以查询但不太推荐：</p><ul><li><strong>时间长且会导致线程阻塞</strong>： 时间长是因为O(N)遍历 ； 阻塞是因为Redis单线程，要等遍历完，这使得Redis要等keys执行完毕才能恢复生产（在生成环境中这是不被允许的）。</li><li><strong>没有分页功能</strong>： 一次查找所有的结果</li></ul></li><li><p><strong>scan命令</strong></p><p>推荐：</p><ul><li><p>不会阻塞，但查找出的元素可能重复，需要客户端去重下</p><blockquote><p><strong>为什么不会阻塞</strong>？</p><p>因为 scan 是通过游标方式查询的 ，查询过程中会把游标返回给客户端，单次返回空值且游标不为 0，则说明遍历还没结束，客户端继续遍历查询。</p></blockquote></li></ul></li></ul><h4 id="2-如果有大量的-key-需要设置同一时间过期，一般需要注意什么？">2.<strong>如果有大量的 key 需要设置同一时间过期，一般需要注意什</strong>么？</h4><p>如果有大量的 key 在同一时间过期，那么可能同一秒都从数据库获取数据，给数据库造成很大的压力，导致<strong>缓存雪崩</strong>。</p><ul><li><strong>解决方案</strong>： 最好给数据的过期时间加一个<strong>随机值</strong>，让过期时间更加分散</li></ul><h4 id="3-什么是-bigkey？会存在什么影响？">3.<strong>什么是</strong> <strong>bigkey？会存在什么影响</strong>？</h4><p>bigkey 是指键值占用内存空间非常大的 key。例如一个字符串 a 存储了 200M 的数据。</p><p><strong>bigkey 的主要影响有</strong>：</p><ul><li><p><strong>网络阻塞</strong>：获取 bigkey 时，传输的数据量比较大，会增加带宽的压力；</p></li><li><p>超时阻塞：因为 bigkey 占用的空间比较大，所以<u>操作起来效率会比较低</u>，导致出现阻塞的可能性增加。</p></li></ul><h4 id="4-Redis如何解决-key冲突？">4. <strong>Redis如何解决 key冲突</strong>？</h4><blockquote><p>Redis 如果 key 相同，后一个 key 会覆盖前一个 key。</p></blockquote><p>如果要解决 key 冲突，最好给 <strong>key 取好名</strong>区分开，可以按业务名和参数区分开取名，避免重复 key 导致的冲突。</p><h4 id="5-如何解决Redis的并发竞争Key问题-？">5. 如何解决Redis的并发竞争Key问题 ？</h4><blockquote><p>多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同。</p></blockquote><ul><li><p>解决方案：<strong>分布式锁</strong>（zookeeper 和 Redis 都可以实现分布式锁）。</p><ul><li><p><strong>zookeeper分布式锁</strong>：（1）每个客户端对某个方法加锁时，在zookeeper上的 与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点；（2）判断是否获取锁的方式很简单，只需要判断有 序节点中序号最小的一个；（3）当释放锁的时候，只需将这个瞬时节点删除即可。</p><blockquote><p>同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p></blockquote></li></ul></li></ul><h4 id="6-Redis删除key的底层原理实现？">6. Redis删除key的底层原理实现？</h4><blockquote><p>参考：<a href="https://www.hoohack.me/2019/06/24/redis-expire-strategy">https://www.hoohack.me/2019/06/24/redis-expire-strategy</a></p></blockquote><p>Redis在启动的时候，会注册两种事件：</p><ol><li><strong>时间事件</strong>： Redis处理后台操作的一类事件，比如客户端超时、删除过期key</li><li><strong>文件事件</strong>： redis注册的回调函数是serverCron，在<strong>定时任务（惰性删除</strong>）回调函数中，通过调用databasesCron清理部分过期key</li></ol><p><strong>定时删除</strong></p><p>对于每一个设置了过期时间的key都会创建一个<strong>定时器</strong>，一旦到达过期时间就立即删除：</p><ul><li>缺点：占用了大量的CPU资源去处理过期的数据，会影响Redis的吞吐量和响应时间。</li></ul><p><strong>惰性删除</strong></p><p><strong>每次访问key的时候</strong>，都会调用<code>expireIfNeeded</code>函数判断key是否过期，如果是，清理key：</p><ul><li>缺点：大量的过期key没有被再次访问，因此不会被清除，导致占用了大量的内存。</li></ul><p><strong>定期删除</strong></p><p>每隔一段时间，扫描Redis中过期key字典，并清除部分过期的key：</p><ul><li>缺点：折中方案</li></ul><p><strong>Redis单线程清理key的时机</strong></p><p>Redis是以<strong>单线程运行的，在清理key是不能占用过多的时间和CPU</strong>，需要在尽量不影响正常的服务情况下，进行过期key的清理。</p><ul><li><p><strong>以随机删除为例</strong></p><ol><li><p>server.hz配置了serverCron任务的执行周期，默认是10，<strong>即CPU空闲时每秒执行十次</strong>；</p></li><li><p><strong>每次清理过期key的时间不能超过CPU时间的25%</strong> ；</p></li><li><p>如果是快速清理模式（在beforeSleep函数调用），则一次清理的最大时间是1ms；</p></li><li><p>依次遍历所有的DB；</p></li><li><p>从db的过期列表中随机取20个key，判断是否过期，如果过期，则清理；</p></li><li><p>如果有5个以上的key过期，则重复步骤5，否则继续处理下一个db ；</p></li><li><p>在清理过程中，如果达到CPU的25%时间，退出清理过程。</p></li></ol></li><li><p><strong>Redis4.0使用BIO处理</strong></p><p>Redis4.0以前，删除指令是del，del会直接释放对象的内存，但是，如果删除的key是一个<strong>非常大的对象</strong>，那么删除操作就会导致单线程卡顿，Redis的响应就慢了。</p><ul><li>在Redis4.0版本引入了unlink指令，能对删除操作进行“懒”处理，<strong>将删除操作丢给后台线程，由后台线程BIO来异步回收内存</strong>。</li></ul></li></ul><p><strong>内存淘汰策略</strong></p><p>Redis的内存淘汰策略，是指内存达到maxmemory极限时，使用某种算法来决定清理掉哪些数据，以保证新数据的存入。</p>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（五）_计算机基础_MySQL</title>
      <link href="/p/56848/"/>
      <url>/p/56848/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h1>五、MySQL</h1><h2 id="5-1-MySQL基本">5.1 MySQL基本</h2><h4 id="0-关系型数据库和非关系数据库的区别？">0. 关系型数据库和非关系数据库的区别？</h4><ul><li><strong>关系型数据库的优点</strong><ul><li>容易理解，因为它采用了关系模型来组织数据；</li><li>可以<strong>保持数据的一致性</strong>；</li><li>数据<strong>更新的开销比较小</strong>；</li><li><strong>支持复杂查询</strong>（带where子句的查询）。</li></ul></li><li><strong>非关系型数据库的优点</strong><ul><li>不需要经过SQL层的解析，<strong>读写效率高</strong>；</li><li><strong>基于键值对</strong>，数据的扩展性很好；</li><li><strong>支持多种类型数据的存储</strong>，如图片，文档等等。</li></ul></li></ul><h4 id="1-介绍一下数据库三范式？">1.<strong>介绍一下数据库三范式</strong>？</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html">https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html</a></p></blockquote><ul><li><p><strong>第一范式</strong>： 数据库表中的<u>所有字段值都是不可分解的原子值</u> 。</p><blockquote><p>数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要<u>将“地址”这个属性重新拆分为省份、城市、详细地址</u>等多个部分进行存储。</p><p><img src="https://i.loli.net/2021/05/03/NiPm9KajxLXpRQf.png" alt="img"></p></blockquote></li><li><p><strong>第二范式</strong>： 第二范式基于第一范式，且要求：<u>数据库表中的每一列都和主键相关，且不能只与主键的某一部分相关</u>（主要针对联合主键而言）, 即<strong>不存在部分依赖</strong>；</p><blockquote><p>下表是以：<u>订单编号&amp;商品编号</u>作为联合主键。这样在该<strong>表中商品名称、单位、商品价格等信息不与该表的订单编号相关</strong>，而仅仅是与商品编号相关。</p><p><img src="https://i.loli.net/2021/05/03/RoCLmOBcgJKhvyx.png" alt="img"></p><p>所以根据第二范式，将它进行拆分三个表：</p><p><img src="https://i.loli.net/2021/05/03/TnN8t5k3lrWxIgp.png" alt="img"></p></blockquote></li><li><p><strong>第三范式</strong>： 基于第二范式，数据表中的每一列数据都和主键<strong>直接相关</strong>，即<strong>不存在传递依赖</strong>；</p><blockquote><p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/2012040114105477.png" alt="img"></p></blockquote></li></ul><h4 id="2-MySQL数据库引擎有哪些？">2. <strong>MySQL数据库引擎有哪些</strong>？</h4><blockquote><p>MySQL查看所有的数据引擎：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engines;</span><br></pre></td></tr></table></figure></blockquote><p>MySQL常用引擎包括：<code>MYISAM</code>、<code>Innodb</code>、<code>Memory</code>、<code>MERGE</code>，</p><ul><li><p><strong><code>MYISAM</code></strong> （读：my+i+son）</p><p>以select、insert为主的应用基本上可以使用这引擎。</p><ul><li><strong>优点</strong>：<strong>全表锁</strong>，拥有较高的执行速度，占用空间小；</li><li><strong>缺点</strong> ：不支持事务，不支持外键，并发性能差。</li></ul></li><li><p><strong><code>Innodb</code></strong></p><p>Innodb引擎提供了对数据库ACID<strong>事务</strong>的支持，并且实现了SQL标准的四种隔离级别，它的设计目标是<u>处理大容量数据库系统</u>。</p><ul><li><strong>优点</strong>：<strong>行级锁</strong>，<strong>支持事务</strong>，支持<u><strong>自动增长列</strong></u>，支持外键约束，<strong>并发能力强</strong></li><li><strong>缺点</strong>： 占用空间是MYISAM的2倍，处理效率相对也更低</li></ul></li><li><p><strong><code>Memory</code></strong></p><p>主要用于<strong>内容变化不频繁的</strong>代码表。</p><ul><li><strong>优点</strong>：<strong>全表锁</strong>，<u>存储在内存中，默认使用Hash，检索效率非常高</u></li><li><strong>缺点</strong>： 会占用和数据量成正比的内存空间且，mysql重启时会丢失，不适合精确查找</li></ul></li><li><p><strong><code>MERGE</code></strong></p><p>是一组MYISAM表的组合。</p></li></ul><h5 id="2-1-InnoDB、MyISAM、Memory-【索引】（按数据结构分）">2.1 InnoDB、MyISAM、Memory 【索引】（按数据结构分）</h5><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000037683781">https://segmentfault.com/a/1190000037683781</a></p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210820194526488.png" alt="image-20210820194526488"></p><h5 id="2-2-为什么Innodb使用自增id作为主键？">2.2 为什么Innodb使用自增id作为主键？</h5><ul><li><strong>如果不使用自增主键</strong>， 如身份证号、学号，每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置（<strong>涉及到B+树分裂等</strong>）， 频繁的移动、分页操作造成了大量的碎片；</li><li><strong>如果使用自增主键，</strong> 那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。</li></ul><h4 id="3-说说InnoDB与MyISAM的区别？">3.<strong>说说InnoDB与MyISAM的区别</strong>？</h4><p>见前。</p><h5 id="3-1-说说InnoDB与MyISAM在B-数索引方式区别？">3.1 说说InnoDB与MyISAM在B+数索引方式区别？</h5><ul><li><p><strong>MyISAm</strong> , B+Tree叶节点的data域存放的是数据<strong>记录的地址</strong>，在索引检索的时候，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引” ；</p></li><li><p><strong>InnoDB，</strong> 树的节点data域保存了完整的数据记录，这个索引的<strong>key是数据表的主键（自增id）</strong> ；而<strong>其它索引都叫做辅助索引</strong>， 助索引的data域存储相应记录<strong>主键的值</strong>而不是记录地址。</p><blockquote><ul><li>在根据主索引搜索时，直接找到key所在的节点即可取出数据；</li><li>在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</li></ul></blockquote></li></ul><h5 id="3-2-【百度】说说InnoDB与MyISAM在适用场景上的区别？">3.2 【百度】说说InnoDB与MyISAM在适用场景上的区别？</h5><ul><li><strong>MyISAM</strong> ，没有事务， 适合<strong>插入不频繁，查询非常频繁</strong>；</li><li><strong>Innodb：</strong> 有事务，适合<strong>可靠性要求比较高</strong>，或者<strong>更新和查询比较频繁</strong>。</li></ul><h4 id="4-为什么-SELECT-COUNT-FROM-table-在-InnoDB-比MyISAM-慢？">4. 为什么 SELECT COUNT(*) FROM table 在 InnoDB 比MyISAM 慢？</h4><p>对于 SELECT COUNT(*) FROM table 语句，在没有 WHERE 条件的情况下，InnoDB 比 MyISAM 可能会慢很多，尤其在大表的情况下。</p><ul><li>InnoDB 是去实时统计结果，会<strong>全表扫描</strong>；</li><li>而 MyISAM内部维持了一个<u><strong>计数器</strong></u>，<strong>预存了结果</strong>，所以直接返回即可。</li></ul><h4 id="5-简单说一说drop、delete与truncate的区别？">5.<strong>简单说一说drop、delete与truncate的区别</strong>？</h4><p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别：</p><ul><li><strong>删除类型</strong>： drop删除表结构；delete、truncate删除表内容。</li><li><strong>删除速度</strong>：  <strong>drop</strong>&gt; truncate &gt;delete</li><li><strong>生效速度</strong>： drop和truncate ，操作立即生效，不能回滚也不触发触发器；<strong>delete事务提交后才生效，会触发相应触发器</strong>。</li></ul><h4 id="6-什么是视图？-游标？">6.<strong>什么是视图</strong>？ 游标？</h4><p>视图是一种虚拟的表，通常是一个表或者多个表的行或列的子集，具有和物理表相同的功能。</p><ul><li>可以对视图进行增，改，查，操作，但<strong>对视图的修改不影响基本表</strong>；</li><li>相比多表查询，获取数据速度更容易。</li></ul><p>游标，是对<strong>查询出来的结果集</strong>作为一个单元来有效的处理。</p><ul><li>一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</li></ul><h4 id="7-什么是内联接、左外联接、右外联接？">7.<strong>什么是内联接、左外联接、右外联接</strong>？</h4><ul><li><p><strong>内联接（Inner Join）</strong>：两个表（或连接）中某一数据项相等的连接称为内连接。 连接的结果是形成一个新的数据表。 内连接中参与连接的表（或连接）的地位是相等的；</p></li><li><p><strong>左外联接（Left Outer Join</strong>）：除了匹配2张表中相关联的记录外，<u>还会匹配左表中剩余的记录</u>，<u>右表中未匹配到的字段用NULL表示</u>；</p></li><li><p><strong>右外联接（Right Outer Join）</strong>：除了匹配2张表中相关联的记录外，还会<u>匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示</u>。</p></li></ul><h4 id="8-说说在-MySQL-中一条查询-SQL-是如何执行的？">8.<strong>说说在 MySQL 中一条查询 SQL 是如何执行的</strong>？</h4><p>例如：<code>select name from t_user where id=1</code></p><ol><li><p><strong>取得链接</strong>，使用使用到 MySQL 中的<strong>连接器</strong>；</p></li><li><p><strong>查询缓存</strong>，key 为 SQL 语句，value 为查询结果，如果查到就直接返回；</p><blockquote><p>在 MySQL 8.0 版本已经将查询缓存删除，也就是说 MySQL 8.0 版本后不存在此功能。</p></blockquote></li><li><p><strong>分析器</strong>，分为词法分析和语法分析。此阶段只是做一些 SQL 解析，语法校验。所以一般语法错误在此阶段；</p></li><li><p><strong>优化器</strong>，是在表里<strong>有多个索引的时候，决定使用哪个索引</strong>；或者一个语句中存在多表关联的时候（join），决定<strong>各个表的连接顺序</strong>；</p></li><li><p><strong>执行器</strong>，开始执行语句。执行语句的时候还要判断是否具备此权限，如果有权限：（1）根据表的引擎定义，使用引擎提供的接口，获取表的第一行，判断id是否等于1 ；（2）如果不是则继续调用引擎接口去获取下一行，继续判断；（3）直至取到这个表的最后一行</p></li></ol><h4 id="9-MySQL-中-varchar-与-char-的区别？-int-3-呢？">9. <strong>MySQL 中 varchar 与 char 的区别</strong>？ int(3) 呢？</h4><ul><li><p>char 是一种固定长度的类型，varchar 则是一种可变长度的类型。</p><p><img src="https://i.loli.net/2021/05/03/SoHv6lyhp94TwWP.png" alt="image-20210503214113219"></p></li><li><p><strong>float(3,2) 和 int(3)</strong></p><ul><li><code>float(3,2)</code> : &quot;浮点型&quot;的长度是用来<strong>限制数字存储范围</strong>的。比如 float(3,2) 只能够写入 <code>0.00~999.99</code>。</li><li><code>int(3)</code> ：&quot;整型&quot;的长度并<strong>不会限制存储的数字范围</strong>，都是<code>-2147483648 ~ 2147483647</code> 。只<strong>限制显示长度</strong>。</li></ul></li></ul><h4 id="10-超键、主键、候选键和外键有什么区别？">10.<strong>超键、主键、候选键和外键有什么区别</strong>？</h4><ul><li><strong>超键(super key)</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键；</li><li><strong>候选键(candidate key)</strong>：不含有多余属性的超键称为候选键，<u>是超键的子集</u>；</li><li><strong>主键(primary key)</strong>：用户选作元组标识的一个候选键程序主键，<u>是候选键的子集</u> ；</li><li><strong>外键</strong>：如果关系模式<strong>R中属性K是其它模式的主键</strong>，那么<strong>k在模式R中称为外键</strong>。</li></ul><p>下面举例说明（<strong>假设姓名不重复唯一</strong>）：</p><table><thead><tr><th style="text-align:center">身份证</th><th style="text-align:center">姓名</th><th style="text-align:center">性别</th><th style="text-align:center">年龄</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><ul><li><u>超键：</u> 身份证、姓名、（姓名、性别）、（姓名、性别、年龄）都可以作为超键；</li><li><u>候选键</u> ：身份证、姓名 都唯一，都可以作为候选键；</li><li><u>主键：</u> 在候选键选一个作为主键，例如：身份证。</li></ul><h4 id="11-解释⼀下什么是池化设计思想。什么是数据库连接池-为什么需要数据库连接池">11.  解释⼀下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?</h4><ul><li><p><strong>池化设计思想</strong></p><p>我们常⻅的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会<u>初始预设资源</u>，<strong>解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销</strong>等。</p></li><li><p><strong>数据库连接池</strong></p><p>数据库连接本质就是⼀个 <strong>socket</strong> 的连接。数据库服务端还要维护⼀些缓存和⽤户权限信息之类的所以<strong>占⽤了⼀些内存</strong>。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以<strong>重⽤这些连接</strong>。</p></li><li><p><strong>为什么要用数据库连接池</strong>？</p><p>为每个⽤户打开和维护数据库连接，尤其是对动态数据库驱动的网站应⽤程序的请求，既昂贵⼜浪费资源。在连接池中，创建连接后，将其放置在池中，并再次使⽤它，因此不必建⽴新的连接。如果使⽤了所有连接，则会建⽴⼀个新连接并将其添加到池中。</p></li></ul><h4 id="12-如果数据不存储在磁盘而是在内存，用什么数据结构？为什么Mysql不使用hash？">12. 如果数据不存储在磁盘而是在内存，用什么数据结构？为什么Mysql不使用hash？</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/wangtao_20/p/3643994.html">为什么hash作为内存使用的经典数据结构?</a></p></blockquote><p>数据放在磁盘，使用<strong>B+树</strong>，<strong>核心是为了减少磁盘IO</strong>，因为磁盘IO的代价很大（是内存的十万倍）。</p><p>我们使用<strong>hash</strong>寻找数据的时候，<strong>数据随机分散到各个物理位置</strong>，不是有序的数据。而<strong>内存设备也是随机访问设备</strong>，内存很适合用hash方式来读取数据。</p><ul><li><p><strong>随机访问</strong>：存储器单元的内容可以根据需要自由取出或存储，而且<strong>访问的速度与存储器单元的位置</strong>无关 。(通过行，列地址总线就可以快速定位存储的数据)</p><blockquote><p>但是磁盘，每次访问数据，是需要先定位，然后<strong>顺序</strong>移动；如果下个数据不在磁头附近，又要重新定位。</p><p>如果Hash索引磁盘数据，（1）每次访问都要IO<strong>不能范围</strong>（2）数据太多，Hash索引保存不了键值，而<strong>高度为3的B+数就能保存千万级别的数据</strong>（3）当数据量很大时，<strong>hash冲突</strong>的概率也会非常大（4）组合索引可以支持部分索引查询，如(a,b,c)的组合索引，查询中只用到了阿和b也可以查询的，如果使用hash表，组合索引会将几个字段合并hash，<strong>没办法支持部分索引</strong> （5）当需要按照索引进行order by时，hash值<strong>没办法支持排序</strong> 。</p></blockquote></li></ul><h4 id="13-【字节】Mysql-Join的原理？">13.【字节】Mysql Join的原理？</h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/54275505">https://zhuanlan.zhihu.com/p/54275505</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user tb1 left join level tb2 on tb1.id=tb2.user_id</span><br></pre></td></tr></table></figure><ol><li><p><strong>简单嵌套循环</strong></p><p><strong>双层for 循环</strong> ，通过循环外层表的行数据，逐个与内层表的所有行数据进行比较来获取结果。</p><img src="https://i.loli.net/2021/09/04/u3LJnMgZsIV6Atd.png" alt="image-20210904063419237" style="zoom:50%;" /></li><li><p><strong>索引嵌套循环连接</strong></p><p>通过外层表匹配条件<strong>直接与内层表索引进行匹配</strong>，避免和内层表的每条记录去进行比较， 这样极大的减少了对内层表的匹配次数。</p><ul><li>从原来的匹配次数=外层表行数 * 内层表行数,变成了 外层表的行数 * 内层表索引的高度，极大的提升了 join的性能；</li><li>注意，<strong>要为表user_level 去建立索引</strong></li></ul><img src="https://i.loli.net/2021/09/04/1gkP9upMosUtYS4.png" alt="image-20210904063546011" style="zoom:80%;" /></li><li><p><strong>缓存块嵌套循环连接</strong></p><p>其优化思路是<strong>减少内层表的扫表次数</strong>。</p><ul><li>通过简单的嵌套循环查询的图，我们可以看到，左表的每一条记录都会对右表进行一次扫表，扫表的过程其实也就是<strong>从内存读取数据</strong>的过程，那么这个过程其实是比较消耗性能的。</li></ul><p><img src="https://i.loli.net/2021/09/04/s1nE7IzYZ6TGlkK.jpg" alt="img"></p><p>所以缓存块嵌套循环连接算法意在通过<strong>一次性缓存外层表的多条数据</strong>，以此来减少内层表的扫表次数，从而达到提升性能的目的。如果无法使用<strong>Index Nested-Loop Join</strong>的时候，数据库是默认使用的是<strong>Block Nested-Loop Join算法的</strong>。</p><ul><li><strong>当level 表的 user_id 不为索引</strong>的时候，默认会使用Block Nested-Loop Join算法。</li></ul><p><img src="https://i.loli.net/2021/09/04/iP9o6OpU8ZxcIwF.jpg" alt="img"></p></li></ol><h5 id="13-1-join和left-join区别">13.1 join和left join区别?</h5><p><strong>join相当于我们平时用的where</strong>，就是把两张表中同时满足a.id=b.id的数据找出来；</p><p>left join是以左表（a）为参考对象，相当于做一个for循环，把a表的数据一条一条的读取出来，然后根据a.id=b.id的条件到b表中查找数据。</p><h5 id="13-2-unio和unio-all的区别">13.2 unio和unio all的区别?</h5><p>如果我们需要将<strong>两个select语句的结果作为一个整体显示出来</strong>，我们就需要用到union或者union all关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select employee_id,job_id from employees union select employee_id,job_id from job_history</span><br></pre></td></tr></table></figure><p><strong>union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来</strong>，不管是不是重复。</p><h5 id="13-3-unio-和-join的区别">13.3 unio 和 join的区别?</h5><blockquote><p>参考：<a href="https://www.jb51.net/article/30975.htm">https://www.jb51.net/article/30975.htm</a></p></blockquote><p>join是对两个表进行联合，相当于where，满足条件的行会被选出，<strong>其中列会被扩充！</strong>  但unio是连接结果集，需要满足列个数相同，<strong>只会保存第一个表列个数，列个数不会被扩充！</strong></p><h2 id="5-2-分布式数据库">5.2 分布式数据库</h2><h4 id="0-【字节】分布式数据库锁如何实现？">0. 【字节】分布式数据库锁如何实现？</h4><ul><li><strong>什么时候用到分布式数据库</strong>？<ol><li><strong>水平拆分</strong> <strong>：数据量大到单机数据库已存储不下</strong>时， 可以对数据进行拆分，化整为零，将数据均匀分布到多个数据库节点中。</li><li><strong>读写分离</strong>：主要用在<strong>数据量并不大</strong>，单机数据库能够hold得住，<strong>但读请求很高</strong>的情况下。此时，可以配置多个只读数据库节点，来分担主节点的读请求。通过数据复制机制，<strong>在主节点和只读节点之间进行数据的实时同步</strong>，保证主从节点的数据一致性。</li></ol></li><li><strong>分布式数据库锁</strong>？<ol><li><strong>直接锁表</strong>，代价比较大</li><li><strong>加入排它锁</strong>，查询语句后面增加<strong>for update</strong>（这里我们希望使用行级锁，就要给method_name添加索引）</li><li><strong>Zookeeper实现分布式锁</strong></li></ol></li></ul><h4 id="1-请说说MySQL数据库的锁？">1. 请说说MySQL数据库的锁？</h4><p><img src="https://i.loli.net/2021/05/24/S7HoKh8EcpXT1Mz.png" alt="img"></p><p>MySQL 中常见锁如下：</p><p>【<u>按使用方式划分</u>】</p><ul><li><p><strong>共享锁</strong>：不堵塞，多个用户可以同一时刻<strong>读取</strong>同一个资源，相互之间没有影响；</p></li><li><p><strong>排它锁（写锁</strong>）：<u>一个写操作阻塞其他的读锁和写锁</u>，<strong>只允许一个用户进行写入</strong>，<strong>防止其他用户读取正在写入的资源</strong>。</p></li></ul><p>【<u>按锁粒度划分</u>】</p><ul><li><p><strong>表锁</strong>：系统开销最小，会锁定整张表，<u>不会出现死锁</u>；但是由于粒度太大，因此造成锁的冲突几率大，并发性能低。<strong>MyISAM 使用表锁。</strong></p></li><li><p><strong>行锁</strong>：<u>容易出现死锁</u>，发生冲突概率低，并发性能高。<strong>InnoDB 支持行锁</strong>。</p><blockquote><p><strong>必须有索引才能实现</strong>，否则会自动锁全表，那么就不是行锁。</p></blockquote></li></ul><p>【<u>按思想划分</u>】</p><ul><li><strong>乐观锁</strong></li><li><strong>悲观锁</strong></li></ul><h4 id="2-说说什么是锁升级？什么情况发生锁升级？">2.<strong>说说什么是锁升级？什么情况发生锁升级</strong>？</h4><blockquote><p>区分一下sycronized锁升级。</p></blockquote><p>锁升级是指将当前锁的粒度降低：<code>行锁→页锁→表锁</code>。</p><p>发生锁升级的情况：</p><ol><li>当一条SQL语句对<u>同一个对象</u>上持有的锁数量超锁了阈值，默认这个阈值为5000，<strong>但是对于不同对象不会发生锁升级</strong></li><li>锁资源占用的内存超过<u>激活内存</u>的百分之40 就会发生锁升级</li></ol><h5 id="2-1-为什么说innoDB-引擎不存在锁升级的问题-？">2.1 为什么说innoDB 引擎不存在锁升级的问题 ？</h5><p>待补充。</p><h5 id="2-2-什么时候触发行锁和表级锁？">2.2 什么时候触发行锁和表级锁？</h5><p>mysql默认存储引擎都是<strong>innodb</strong>，默认是使用<strong>行锁</strong> 。</p><ul><li><p>触发行级锁 ，<strong>行级锁锁的是索引记录</strong> ，使用了索引所以就会触发行级锁。</p></li><li><p>触发表级锁，有以下三种情况</p><blockquote><p>其实不管是读操作(select)还是写操作(update,delete,insert),只要涉及到带有筛选条件的语句，<strong>如果筛选条件中没有用到索引</strong>，就会触发全表扫描。</p></blockquote><ol><li><strong>全表更新</strong>：事务<strong>需要更新大部分数据或全部数</strong>据，如果使用行级锁，会导致事务执行效率低，从而导致其他事务长时间等待锁和更多的锁冲突</li><li><strong>多表级联：事务涉及多张表</strong>，比较复杂的关联查询，很可能造成死锁，这种情况若能一次性锁住事务涉及的表，从而避免死锁，减少数据库事务回滚所带来的开销</li><li><strong>筛选条件中未用到索引</strong>： 全表扫描</li><li><strong>用到索引，但区分度程度不高</strong> ：innodb认为全表扫描比走索引效率更高导致索引失效，这个时候就要通过explain去查看下查询计划，看下查询语句是否真的用到了索引</li></ol></li></ul><h5 id="2-3-行锁适合的场景？">2.3 行锁适合的场景？</h5><p>A用户消费，service层先查询该用户的账户余额，若余额足够，则进行后续的扣款操作；这种情况查询的时候应该对该记录进行加锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for update # 操作该记录时加上</span><br></pre></td></tr></table></figure><p>否则，B用户在A用户查询后消费前先一步将A用户账号上的钱转走，而此时A用户已经进行了用户余额是否足够的判断，则可能会出现余额已经不足但却扣款成功的情况。</p><h4 id="3-怎样尽量避免死锁的出现？">3.<strong>怎样尽量避免死锁的出现</strong>？</h4><ol><li><p><strong>设置获取锁的超时时间</strong>，至少能保证最差情况下，可以退出程序，不至于一直等待导致死锁；</p></li><li><p><strong>设置按照同一顺序访问资源</strong>，类似于串行执行；</p></li><li><p><strong>避免事务中的用户交叉</strong>；</p></li><li><p>保持事务简短并在一个批处理中；</p></li><li><p>使用<strong>低隔离级别</strong>。</p></li></ol><h4 id="4-解释一下悲观锁和乐观锁？">4.<strong>解释一下悲观锁和乐观锁</strong>？</h4><ul><li><p><strong>悲观锁</strong>： 悲观锁是基于一种悲观的态度类来防止一切数据冲突。它是以一种预防的姿态 <u>在修改数据之前把数据锁住</u>，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作。一般数据库本身锁的机制都是基于悲观锁的机制实现的。</p><ul><li><p><strong>特点</strong>： 完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁；但是造成性能消耗</p></li><li><p><strong>实现</strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 加读锁</span><br><span class="line">LOCK tables test_db READ </span><br><span class="line"># 释放锁</span><br><span class="line">UNLOCK TABLES</span><br><span class="line"># 加写锁</span><br><span class="line">LOCK tables test_db WRITE </span><br><span class="line"># 释放锁</span><br><span class="line">UNLOCK TABLES</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>乐观锁</strong>： 对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁，使得<u>多个任务可并行对数据操作</u>。但是<u>使用一种验证机制来避免数据冲突</u> （一般通过加版本后对比来实现）。</p><ul><li><p><strong>特点</strong>： 并发类型的锁，<u>本身不加锁但通过业务实现锁的功能</u> ，没有锁操作因此性能更高。</p></li><li><p><strong>实现形式</strong>：</p><p>（1）两个请求同时操作操作标Name字段，二者查询需检索的数据都是一样的：</p><p><img src="https://i.loli.net/2021/04/20/H6wyLdqZN8BJipx.png" alt="img"></p><p>（2）请求1修改字段数据<code>“zhangsan”→“lisi”</code> ，并将版本号增加+1 ，验证版本号一直后提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update A set Name=lisi,version=version+1 where ID=#&#123;id&#125; and version=#&#123;version&#125;</span><br></pre></td></tr></table></figure><p>（3）请求2也想修改<code>“zhangsan”→“liming”</code>  ，但是提交时由于 <u>版本号不一致，无法提交成功</u></p></li></ul></li></ul><h5 id="4-1-数据库乐观锁和悲观锁，如何实现？">4.1 数据库乐观锁和悲观锁，如何实现？</h5><ul><li><p><strong>实现乐观锁</strong></p><ol><li><p>利用版本号，如MVCC；</p></li><li><p><strong>时间戳</strong>：同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似。</p><p>也是在更新提交的时候，将当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</p></li></ol></li><li><p><strong>实现悲观锁</strong></p><p>直接加上读锁或者写锁，SELECT … FOR UPDATE 。</p></li></ul><h4 id="5-介绍一下分布式数据库全局ID唯一且自增，如何生成？-（或者问分库分表之后，id-主键如何处理？）">5.<strong>介绍一下分布式数据库全局ID唯一且自增，如何生成</strong>？ （<strong>或者问分库分表之后，id 主键如何处理</strong>？）</h4><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要⼀个全局唯⼀的 id来支持。</p><ol><li><p><strong>UUID</strong>：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。</p></li><li><p>ID自增量为<u>分布式数据库个数</u>，缺点是扩展性不好；</p></li><li><p><a href="https://www.cnblogs.com/jiangxinlingdu/p/8440413.html">snow flake算法</a>：snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。</p><p><img src="https://pic3.zhimg.com/80/v2-b3a91b9e3f6468be39f3dc3345e9f4f2_720w.jpg" alt="img"></p><ul><li><strong>核心思想</strong>： 使用41bit作为毫秒数，10bit作为机器的ID（<strong>5个bit是数据中心，5个bit的机器ID</strong>），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 <u>不同ID</u>），最后还有一个符号位，永远是0。</li></ul></li><li><p><a href="https://blog.csdn.net/minkeyto/article/details/104943883">Leaf算法</a>：分号段</p></li></ol><h4 id="8-介绍一下哈希算法？和一致性哈希算法？">8.<strong>介绍一下哈希算法？和一致性哈希算法</strong>？</h4><ul><li><p><strong>哈希算法</strong></p><ul><li><strong>介绍</strong>： 哈希算法<u>将任意长度的二进制值映射为较短的固定长度的二进制值</u>，这个小的二进制值称为<strong>哈希值</strong>。哈希值是一段数据唯一且<strong>极其紧凑的数值表示形式</strong>。</li><li><strong>分布式应用中缺点</strong>： 在分布式的存储系统中，<u>要将数据存储到具体的节点上</u>。如果采用哈希算法：<code>key%N</code>（key是数据的key，N是机器节点数） 。出现机器加入或退出集群（<strong>N变了，映射值不一样了</strong>），所有的数据映射都无效了。</li></ul></li><li><p><strong>一致性哈希算法</strong></p><ul><li><p><strong>介绍</strong>：解决普通哈希算法造成负载均衡时，在<strong>服务节点数量变动</strong>时出现<strong>哈希失效</strong> 问题</p></li><li><p><strong>实现</strong>：</p><ol><li><p><strong>构建环</strong>：按照常用的hash算法来将对应的key哈希到一个具有<strong>2^32</strong>次方个节点的空间中（即0 ~ (2^32)-1）。</p><blockquote><p>Note: 节点的个数可以自定义, hash环我们可以用TreeMap来实现, 因为treeMap是排序的，我们刚好可以利用上。</p></blockquote><img src="https://i.loli.net/2021/04/20/Al6k3ZmHJO2qbe9.jpg" alt="img" style="zoom:50%;" /></li><li><p><strong>映射服务器节点</strong>： 将各个服务器使用Hash进行一个哈希，确定每台机器其在哈希环上的位置。</p><blockquote><p>一般用服务器ip或唯一主机名进行哈希。</p></blockquote><img src="https://i.loli.net/2021/04/20/1ZKalnT9CStVc8s.jpg" alt="img" style="zoom:50%;" /></li><li><p><strong>映射数据。</strong> 对于要存储的数据：<code>ojectA、objectB、objectC、objectD</code> ，首先通过特定哈希函数计算出<code>hash</code>值 ，散列到环上。然后从数据所在位置<u>沿环顺时针“行走”</u>，第一台遇到的服务器就是其应该定位到的服务器。</p><img src="https://i.loli.net/2021/04/20/SwUijYkyJPp34v1.jpg" alt="img" style="zoom:50%;" /></li><li><p><strong>出现服务器变动。</strong> 如果此时NodeC宕机了，此时Object A、B、D不会受到影响，只有Object C会重新分配到Node D。<u>避免了大量数据迁移，减小了服务器的的压力</u> 。</p></li></ol></li></ul></li></ul><h4 id="9-（再理解）介绍一下MVVC？">9. （再理解）介绍一下MVVC？</h4><p>MVCC（Multi-Version Concurrency Control）多版本并发控制，是</p><p>数据库控制并发访问的一种手段。</p><blockquote><ul><li>特别要注意<strong>MVCC</strong>只在<strong>读已提交(RC)</strong> 和<strong>可重复读（RR）</strong> 这两种事务隔离级别下才有效</li><li>是<strong>数据库引擎（InnoDB）</strong> 层面实现的，用来处理读写冲突的手段（不用加锁），提高访问性能</li></ul></blockquote><ul><li><p>MVCC协议中，事务提交不会覆盖原数据，而是产生新版本数据，<strong>每个数据有多个历史版本</strong>，但同一时刻只有最新的版本有效；</p></li><li><p>MVCC是在并发访问数据库时，通过对数据做多版本管理，避免<u>【<strong>因为写锁的阻塞而造成读数据的并发阻塞</strong>】</u>问题。可以让<strong>读取数据同时修改，【修改数据时同时可读取】</strong>。简单来说，就是<strong>不对数据库加上读写锁！</strong></p></li></ul><h5 id="9-1-MVCC-如何实现-？">9.1 MVCC 如何实现 ？</h5><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/52977862">Innodb MVCC实现原理</a></p></blockquote><ul><li><p><strong>总结性回答</strong></p><p>MVCC是以一个多版本并发控制系统，它主要通过以下两个部分实现：</p><ul><li>每行记录：记录最近操作该行记录的事务ID，和上一版本数据的指针（指向undo log）</li><li>readview：每次<strong>读（写不可以</strong>） 可以获取一个readview，记录当前活跃的事务ID ，可以在<strong>写的过程进行读</strong></li></ul><p>写的时候并发读，通过比较当前行记录的事务ID和readview活跃的事务ID，来决定是否读取该行记录还是上一版本的数据。</p></li></ul><p>MVCC实现的核心部分为：</p><ol><li><p><strong>事务版本号</strong>：每次<strong>事务开启前</strong>都会从数据库获得一个自增长的<strong>事务ID</strong>，可以从事务ID判断事务的执行先后顺序。</p></li><li><p><strong>表的隐藏列</strong> <strong>：每一行</strong> 有如下三个重要字段属性：</p><table><thead><tr><th style="text-align:center">隐藏列</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>DB_TRX_ID</strong></td><td style="text-align:center">记录操作该行事务的ID</td></tr><tr><td style="text-align:center"><strong>DB_ROLL_PTR</strong></td><td style="text-align:center">指向上一个版本的数据（在undo log）的指针</td></tr><tr><td style="text-align:center"><strong>DB_ROW_ID</strong></td><td style="text-align:center">隐藏ID，当表没有合适的索引作为聚簇索引时，会用该ID创建聚簇索引</td></tr></tbody></table></li><li><p><strong>undo log</strong> ：每一行记录被修改之前的日志。</p><blockquote><p>当事务被回滚时，可以用通过undo log日志对数据进行还原。</p></blockquote><p>一个小例子：修改某行记录name从 <code>“张三→李四”</code></p><p><img src="https://pic1.zhimg.com/v2-1daaeab59495ff3378dae24ea21dc158_r.jpg" alt="preview"></p></li><li><p><strong>read view</strong>。在innodb 中<strong>每个SQL语句执行前</strong>都会得到一个read_view，保存了当前数据库系统中正<strong>处于活跃（没有提交</strong>）的事务的ID号。</p><blockquote><p>根据事务的隔离性，这些事务ID列表不会被其它事务看到。</p></blockquote><p>其相关重要属性如下：</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>trx_ids</strong></td><td style="text-align:center">当前系统：活跃<code>（未提交）事务版本号集合</code></td></tr><tr><td style="text-align:center"><strong>low_limit_id</strong></td><td style="text-align:center">当前系统：<code>最大版本事务号+1</code></td></tr><tr><td style="text-align:center"><strong>up_limit_id</strong></td><td style="text-align:center">当前系统：<code>活跃的最小事务版本号</code></td></tr><tr><td style="text-align:center"><strong>creator_trx_id</strong></td><td style="text-align:center">当前read view：<code>事务版本号</code></td></tr></tbody></table></li></ol><p>具体原理可以描述如下：</p><blockquote><p>举个例子，假设有一个user_info表，初始数据如下：</p><p><img src="https://i.loli.net/2021/05/30/ATDHgI7sKeziOxE.png" alt="image-20210529211818428"></p><p>现在有事务A，B<strong>同时对<code>id=1</code> 这行数据进行操作</strong>，先开启事务A（未提交），此时执行事务B，最后返回什么结果呢？</p></blockquote><ol><li><p>事务A（写），执行 <code>update user_info set name =”李四”</code></p><ul><li><p>获得事务编号：102</p></li><li><p>当前事务A的视图为：（<strong>写）不会获得read view</strong>！</p></li></ul></li><li><p>事务B（读），执行 <code>select * fom user_info where id=1</code></p><ul><li><p>获得事务B编号：103</p></li><li><p>当前事务B的视图为：</p><table><thead><tr><th style="text-align:center"><strong>trx_ids</strong></th><th style="text-align:center">当前活跃的事务：102,103</th></tr></thead><tbody><tr><td style="text-align:center"><strong>low_limit_id</strong></td><td style="text-align:center">当前最大事务id+1:<strong>104</strong></td></tr><tr><td style="text-align:center"><strong>up_limit_id</strong></td><td style="text-align:center">当前最小事务id：<strong>102</strong></td></tr><tr><td style="text-align:center"><strong>creator_trx_id</strong></td><td style="text-align:center">当前事务id：<strong>103</strong></td></tr></tbody></table></li></ul><blockquote><p><strong>不同隔离级别下，read view的工作方式</strong>：</p><ol><li><p><strong>读未提交</strong>：不会获得read view的副本（等于没有并发控制所以会出现脏读）</p></li><li><p><strong>读提交</strong>：每一次select都会获得一个read view的副本，所以会造成【不可重复读】</p><p><img src="https://i.loli.net/2021/05/30/EQSJBYZMeUljA3g.png" alt="image-20210529222746175"></p></li><li><p><strong>可重复读</strong>：同一个事务select只会获得一次read view副本（select的时候不允许修改），所以不会出现不可重复读。</p><p><img src="https://i.loli.net/2021/05/30/ITXb5OukhL1EJ4N.png" alt="image-20210529222905837"></p></li></ol></blockquote></li><li><p>事务A（写），开始执行update语句：（1）把原数据拷贝到undo log，（2）然后进行修改name字段：<code>“张三→李四”</code>，（3）并设置DB_TRX_ID 隐藏字段：<code>99→102</code> （4）设置DB_ROLL_PTR隐藏字段：<code>执行上个事务版本地址</code></p><p><img src="https://i.loli.net/2021/05/30/zjCi4AeRQsbHaPO.png" alt="image-20210529213739125"></p><p>此时，<strong>事务A还并未提交</strong>，依旧是处于活跃状态。</p></li><li><p>事务B（读），开始执行select语句，<strong>查询到是事务A修改后的语句</strong></p><p><img src="https://i.loli.net/2021/05/30/xspAhSDXbOGroqC.png" alt="image-20210529214159799"></p><p>把<strong>数据和read view （视图）匹配</strong>： <u>保证</u>（1）<strong>数据已提交，没有其他事物修改，否则去找上一版本的数据</strong>。</p><blockquote><ol><li><code>当前数据记录的事务id &lt; 事务B视图中最小活跃事务id</code> : 说明<strong>数据</strong>，是在<strong>事务B的read view 创建前</strong>就存在，所以可以显示。</li><li><code>当前数据记录的事务id &gt; 事务B视图中最大活跃事务id</code> ：说明<strong>数据</strong>，是在<strong>事务B的read view 创建后</strong>才存在，此时不应该显示。</li><li><code>事务B视图中最小活跃事务id&lt;= 当前数据记录的事务id &lt;= 事务B视图中最大活跃事务id</code> ： 说明有<strong>其它事务在修改这行记录数据</strong>，但可能还没有提交。把id和事务B的read view的活跃事务集合trx_ids进行匹配：<ul><li>如果数据记录的ID不存在trx_ids，说明已经提交了事务，可以显示</li><li>如果存在trx_ids，说明<strong>数据还没提交，此时事务B查询到数据不能显示</strong>（除非此时数据记录的事务id == 事务B的id，由于是自己的当然可以显示）</li></ul></li></ol></blockquote></li><li><p>事务B（读），根据上述匹配规则，<strong>此时不能读</strong>，应该去undo log中找到上一版本数据。</p><blockquote><p>此时<code>事务B的id=103，数据记录的事务id=102</code> ：满足条件3，且此时trx_ids存在事务id=102，说明事务A（id=102）还没提交，因此<strong>不能显示。</strong></p></blockquote><p>故，最终查找的数据为：</p><img src="https://i.loli.net/2021/05/30/ATDHgI7sKeziOxE.png" alt="image-20210529211818428" style="zoom:80%;" /></li></ol><p>可以看到，整个过程MVCC<strong>事务A【写】没有加锁</strong>，只是进行版本号控制 &amp; undo log，可以进行<strong>并发【读】</strong>。</p><h5 id="9-2-MVCC-版本号如何变化的？更新的数据如何确定版本的？【幻读】又是怎么解决的呢？">9.2 MVCC 版本号如何变化的？更新的数据如何确定版本的？【幻读】又是怎么解决的呢？</h5><ul><li><p><strong>版本号变化</strong></p><p>每条记录有三个隐藏列：（1）<strong>DB_TRX_ID</strong> （2）<strong>DB_ROLL_PTR</strong> （3）<strong>DB_ROW_ID</strong></p><p>每一次新事务，<strong>update更新语句</strong>，都会将（1）拷贝数据到undo log（2）DB_ROLL_PTR指向上个数据的版本undo log（3）DB_TRX_ID修改为新事务的id 。</p></li><li><p><strong>为什么MVCC可解决幻读</strong></p><p><strong>在RR（可重复读级别下）不会出现幻读</strong>。例如：</p><ol><li>开启事务1，获得事务ID为1；</li><li>事务1执行查询，得到readview；</li><li>开始事务2；</li><li>执行insert；</li><li>提交事务2；</li><li>执行事务1的第二次查询 (因为这里是RR级别，所以<strong>不会再去获得readview，<strong>还是使用第一次获得的readview，所以</strong>当前read view 事务的ID不会更新</strong>，即不会加入插入事务2)；</li><li>最后得到的结果是，插入的数据不会显示，因为<strong>插入的数据事务ID &gt; readview里的最大活跃事务ID</strong>。</li></ol></li></ul><h5 id="9-3-mvvc-和-for-update的区别">9.3 mvvc 和 for update的区别</h5><ol><li><strong>是否加锁</strong>：  mvvc不加锁，只通过多版本来进行并发控制；for update会加锁（<strong>即X/写锁</strong>）。</li></ol><h5 id="9-4-（快手）MVCC作用，如何实现RC，RR">9.4 <strong>（快手）MVCC作用，如何实现RC，RR?</strong></h5><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/73078137">https://zhuanlan.zhihu.com/p/73078137</a></p></blockquote><p><strong>作用如下</strong>：</p><ol><li>最简单的描述，<strong>读写不阻塞，读的时候可以写</strong></li><li>提高性能</li></ol><p><strong>实现RC，RR两个隔离级别</strong>：</p><blockquote><p>MVCC <strong>读</strong>某一个数据时，<strong>根据隔离级别</strong>，事务选择要读取哪个版本的数据，过程中完全不需要加锁。</p></blockquote><ol><li><p><strong>Read Committed</strong> ：一个事务读取数据时总是读这个数据<strong>最近一次被commit</strong>的版本 ，<strong>所以可以避免脏读（快手</strong>）；</p></li><li><p><strong>Repeatable Read</strong> ： 一个事务读取数据时总是读取当前【<strong>事务开始之前】最后一次被commit</strong>的版本（所以底层实现时需要比较当前事务和数据被commit的版本号），<strong>所以避免了幻读（快手</strong>）。</p></li></ol><p><strong>举个简单的例子</strong>：</p><ol><li><strong>一个事务A（txnId=100）修改了数据X，使得X=1，并且commit了</strong></li><li><strong>另外一个事务B（txnId=101）开始尝试读取X，但是还X=1。但B没有提交。</strong></li><li><strong>第三个事务C（txnId=102）修改了数据X，使得X=2。并且提交了</strong></li><li><strong>事务B又一次读取了X。这时</strong><ul><li><strong>如果事务B是Read Committed。那么就读取X的最新commit的版本，也就是X=2</strong></li><li><strong>如果事务B是Repeatable Read。那么读取的就是当前事务（txnId=101）之前X的最新版本，也就是X被txnId=100提交的版本，即X=1。</strong></li></ul></li></ol><p>注意，这里B不论是Read Committed，还是Repeatable Read，<strong>都不会被锁</strong>，都能立刻拿到结果。这也就是MVCC存在的意义。</p><h2 id="5-3-索引相关">5.3 索引相关</h2><blockquote><p>🛰 强烈建议对索引更深刻理解，先看完美团这篇技术文章：<a href="https://tech.meituan.com/2014/06/30/mysql-index.html">MySQL索引原理及慢查询优化</a></p></blockquote><h4 id="0-MySQL索引原理及慢查询优化">0. <a href="https://tech.meituan.com/2014/06/30/mysql-index.html">MySQL索引原理及慢查询优化</a></h4><h5 id="0-1-为什么要需要索引">0.1 为什么要需要索引</h5><blockquote><p>答到：遍历磁盘开销太大这个关键。</p></blockquote><p>数据库实现比较复杂，数据保存在<strong>磁盘</strong>上，而为了提高性能，每次又可以把<strong>部分读入内存</strong>来计算 。</p><p>磁盘的成本大概是访问内存的<strong>十万倍</strong>左右 ， 每次去遍历磁盘找到数据再读入内存，是难以接受的。因此需要一种快速找到磁盘数据的方式，就像字典通过<strong>字母索引→快速定位单词</strong>。因此索引由此而出现。</p><h5 id="0-2-局部性原理（磁盘IO一次读取大小）">0.2 局部性原理（磁盘IO一次读取大小）</h5><blockquote><p>在继续往下讲之前，先来讲讲磁盘读取局部性原理。</p></blockquote><p>局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与<strong>其相邻的数据也会很快被访问到</strong>。</p><ul><li>因此，当<strong>一次</strong>IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内。</li></ul><p>每次IO读取的数据，分为下面情况：</p><ul><li>Linux：上以<strong>页</strong>为单位，一次一页（<strong>4K</strong>）</li><li>数据库：mysql（InnoDB引擎）一页（<strong>16K</strong>）; SQL Server/ Oracle，默认<strong>块</strong>，大小都是<strong>8KB</strong></li></ul><h5 id="0-3-索引→B-树">0.3 索引→B+树</h5><p>相比二叉树，平衡树等，<strong>B+树</strong> 作为<strong>高度可控的多路搜索树</strong> ，可以很好的满足要求。（详细选择原因，可以参考：<u>5.3 索引相关–问答6</u>）</p><ul><li><p><strong>B+树基本结构</strong></p><p><img src="https://i.loli.net/2021/05/23/xXQFuqgEfpreHdG.jpg" alt="b+树"></p><p>浅蓝色是一个磁盘块，数据项就是被组织索引那<strong>列</strong>的字段值。</p><blockquote><p>如果是Innodb引擎，使用聚簇索引就是按照每张表的<strong>主键</strong> 构造索引，那么此时<strong>数据项就是主键值</strong>。</p></blockquote><ul><li><p>蓝色部分（如17,35）是数据项；黄色部分（如P1,P2,P3）是指针，指向<strong>下个磁盘块（页地址</strong>）。</p></li><li><p><strong>1. 为什么B+树非叶子节点不存放数据</strong>？</p><p>IO次数取决于b+数的高度h，每个磁盘块大小也是一定（一页）的。<strong>如果数据项占的空间越小，一个磁盘块数据项的数量越多，树的高度越低，B+可以更高阶（指针占用先忽略</strong>）。</p><p>所以磁盘<strong>非叶子</strong>节点不保存数据，是为了保存更多的数据项和指针，这样一颗B+树<strong>叶子</strong>节点就能存储更多的数据。</p></li><li><p><strong>2. 数据查找过程</strong>？</p><p>以查找<code>数据项=28</code> ，过程为例：<br>（1） 先 <u>加载（一般常驻内存）</u> 根页面1（磁盘块1），因为<code>17&lt;28&lt;35</code> 所以使用<code>P2</code>指针 ， 找到磁盘块3（页面3）<strong>地址</strong></p><p>（2）在 <u>IO加载</u> 磁盘块3，因为 <code>26&lt;28&lt;30</code>  ，因此根据此时的<code>P2</code> 指针，找到磁盘块8所在的地址</p><p>（3） <u>IO加载</u> 磁盘块8，因为此时是叶子节点，可以得到<code>数据项=28</code>对应的<strong>那行记录</strong> 。</p><p>仅仅最多<strong>3</strong>次磁盘IO就找到了数据，这提升是巨大的。</p></li><li><p><strong>3. 高度为3的B+数可以存储多少数据</strong>？</p><ul><li><p><strong>叶子节点一页存储的记录数</strong></p><p>mysql一页16K，所以一页存储<code>16K/1K = 16条</code> 记录。（实际真实业务场景一条记录一般就是1K）</p></li><li><p><strong>非叶子节点一页存储的指针数</strong></p><p>由于数据项也要占用空间，其和指针只相差1，按<strong>成对</strong>算。</p><p>假设主键ID（数据项）为bigint类型，长度为<code>8</code>字节，而<code>指针大小</code>在InnoDB源码中设置为<code>6字节</code> 。那么一共<code>14</code>字节。</p><p>所以一页可以存储：<code>16K / 14B ≈ 1K</code> 个指向页面的指针。</p></li><li><p><strong>计算可以存储多少页</strong></p><p>高度为3的B+树，第3层叶子节点存储真实<strong>数据页</strong>，前2层是存储<strong>数据项+指针</strong>。<strong>第二层指针</strong>==叶子节点存储的页面数。</p><ol><li>第一层：根页面可以存储1K个指针，每个指针指向一个新的页面</li><li>第二层：存储 <code>1K*1K = 1M</code> ，约一百万个指针，指向一百万个叶子数据页面</li></ol><p>所以一共存储：<code>1M*16≈16M</code> ，即千万级别的数据。</p></li></ul></li></ul></li></ul><h5 id="0-4-慢查询优化">0.4 慢查询优化</h5><p>（暂略）</p><h4 id="1-MySQ索引的原理和数据结构能介绍一下吗？索引的缺点？">1. <strong>MySQ索引的原理和数据结构能介绍一下吗</strong>？<strong>索引的缺点</strong>？</h4><ul><li><p><strong>索引原理</strong>： 本质是用来优化查询速度。<u>用一个数据结构组织某一列的数据</u>，然后如果你要根据那一列的数据查询的时候，就可以<u>不用全表扫描</u>，只要根据那个特定的数据结构快速去找到那一列的值。</p></li><li><p><strong>数据结构</strong>： MySQL索引通过B+树来实现（按数据结构分也有hash索引、fulltext索引）。</p></li><li><p><strong>索引缺点</strong>： （1）占用磁盘存储空间 （2）降低表更新速度，表发生变化，索引也要发生变化</p></li></ul><h4 id="2-MySQL-索引类型有哪些？">2. <strong>MySQL 索引类型有哪些</strong>？</h4><p>按数据结构分类可分为：<strong>B+tree索引、Hash索引、Full-text索引</strong>。<br>按物理存储分类可分为：<strong>聚簇索引、二级索引（辅助索引</strong>）。<br>按字段特性分类可分为：<strong>主键索引、普通索引、前缀索引</strong>。<br>按字段个数分类可分为：<strong>单列索引、联合索引（复合索引、组合索引</strong>）。</p><ul><li><p><strong>主键索引</strong>：索引列中的值必须是唯一的，不允许有空值；</p></li><li><p><strong>唯一索引</strong>：索引列中的值必须是唯一的，但是允许为空值；</p></li><li><p><strong>普通索引</strong>：MySQL中<u>基本索引类型</u>，没有什么限制，允许在定义索引的列中插入重复值和空值；</p></li><li><p><strong>全文索引</strong>：只能在<strong>文本类型CHAR,VARCHAR,TEXT</strong>类型字段上创建全文索引；</p><blockquote><p>字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引；</p><p>MyISAM和InnoDB中都可以使用全文索引。</p></blockquote></li><li><p><strong>前缀索引</strong>：在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定；</p></li><li><p><strong>空间索引</strong>： MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。</p><blockquote><p>MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。</p></blockquote></li></ul><h5 id="2-1-什么是覆盖索引？">2.1 什么是覆盖索引？</h5><p>我们在<u>非聚簇索</u>引一般只获得了，记录的key值（Innodb引擎），还需要回到聚簇索引中<strong>再次查询</strong>。</p><ul><li><strong>覆盖索引</strong>： 从<strong>非主键索引中就能查到的记录</strong>，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。</li></ul><blockquote><p>一个小例子。</p></blockquote><p>以name和age两个字段建立<strong>联合索引</strong>，sql命令与建立后的索引树结构如下：</p><img src="https://i.loli.net/2021/05/28/V2ApYvt9zWGFhcf.png" alt="image-20210526230732546" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student DROP INDEX I_name;</span><br><span class="line">ALTER TABLE student ADD INDEX I_name_age(name, age);</span><br></pre></td></tr></table></figure><p>此时执行如下sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT age FROM student WHERE name = &#x27;小李&#x27;；</span><br></pre></td></tr></table></figure><p>在<strong>非聚簇索引中包含了age信息</strong>，那么直接返回12，不需要再到聚簇索引中查询。</p><h4 id="【重点】3-什么时候使用索引比较好？什么时候不要使用索引？">【重点】3.<strong>什么时候使用索引比较好</strong>？什么时候不要使用索引？</h4><h5 id="3-1-什么时候用索引">3.1 什么时候用索引</h5><blockquote><p>特别的，主键自动建立唯一索引。</p></blockquote><ol><li><p><strong>频繁</strong>作为查询条件的字段应该创建索引 ；</p></li><li><p><strong>查询中与其他表关联的字段</strong>，外键关系建立索引；</p></li><li><p><strong>查询中排序的字段</strong>，排序字段若通过索引去访问将大大提高排序速度（<strong>索引就是排序加快速查找</strong>）；</p></li><li><p><strong>查询中统计或者分组字段</strong>。</p></li></ol><h5 id="3-2-什么时候不用索引">3.2 什么时候不用索引</h5><ol><li><p><strong>经常增删改</strong>的列不要建立索引（因为每次更新不单单是更新记录，还会更新索引，保存索引文件）；</p></li><li><p><strong>表记录太少</strong>不要建立索引；</p></li><li><p>（<strong>被CSIG问过</strong>）区分度低，数据重复且分布平均的字段不适合做索引；</p><blockquote><p>例如性别字段，只有男女，不适合建立索引。</p><ul><li>因为从索引中拿到的只是地址，要想真正访问到数据还是要对表进行一次IO；</li><li>假如你要从表的100万行数据中取几个数据，那么利用索引迅速定位，访问索引的这IO开销就非常值了；</li><li>但如果你是从100万行数据中取50万行数据，就比如性别字段，那你相对需要 <u>访问50万次索引，再访问50万次表</u>，加起来的开销并不会比直接对表进行一次完整扫描小。</li></ul></blockquote></li><li><p><strong>text，image</strong>等类型不应该建立索引，<strong>这些列的数据量大</strong>；</p></li><li><p><strong>多个单列索引并不是最佳选择</strong> MySQL 只能使用一个索引，会从多个索引中选择一个限制最为严格的索引 ；</p></li><li><p><strong>参加运算 或 作为函数参值等字段</strong>，不要建立索引，这会使得索引失效而全表扫描 。</p></li></ol><h4 id="4-主键与唯一索引有什么区别？">4.<strong>主键与唯一索引有什么区别</strong>？</h4><ul><li><p>主键一<strong>定会创建一个唯一索引，但是有唯一索引的列不一定是主键；</strong></p></li><li><p>主键不允许为空值，唯一索引列允许空值；</p></li><li><p>一个表只能有一个主键，但是可以有多个唯一索引；</p></li><li><p>主键可以被<strong>其他表引用为外键，唯一索引列不可以；</strong></p></li><li><p>主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本质差别。</p></li></ul><h4 id="5-b-树和b树有什么区别？">5. <strong>b+树和b树有什么区别</strong>？</h4><p>B树：</p><p><img src="https://i.loli.net/2021/04/21/YsAxSctJ1wKUm3g.png" alt="clip_image002"></p><ul><li>索引与数据存储在每个节点中（增加了IO次数）；</li><li>搜索过程有可能在非叶子节点结束（最好情况下<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>）。</li></ul><p>B+树：</p><p><img src="https://i.loli.net/2021/04/21/ihT3SbqwodNUvPe.png" alt="clip_image039"></p><ul><li>所有数据<strong>按顺序</strong>存储在叶子节点中；</li><li>所有叶子节点被<strong>双向链连接</strong>；</li><li>搜索过程固定时间复杂度（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>）；</li><li>（优点易忘）<u>适合范围查找，降低磁盘IO次数</u>。</li></ul><h4 id="6-为什么MySQL使用B-树作为索引？而不是平衡二叉树、红黑树、B树、或者Hash？">6.<strong>为什么MySQL使用B+树作为索引？而不是平衡二叉树、红黑树、B树、或者Hash？</strong></h4><ul><li><p><strong>不用平衡二叉树或者红黑树</strong>： 树的查询时间和树的结构有关，B+树是一颗多路搜索数，可以降低树的高度提高查询速度。</p></li><li><p><strong>不用B树</strong>： （1）无法范围查询，而<strong>B+树所有叶子节点形成有序链表便于范围查询</strong>；（2）N阶B+数，B树，B+数可以存储n个关键字，而B树是n个。</p></li><li><p><strong>不用Hash：</strong> （1）B+树允许分配加载节点，如果内存数据太大B+树更好（2）B+树更适合范围查询</p><blockquote><p>用Hash需要把数据全部<strong>加载到内存中</strong>，如果数据量大，是一件很<strong>消耗内存</strong>的事，而采用B+树，是基于<strong>按照节点分段加载，由此减少内存消耗</strong>。</p></blockquote></li></ul><h5 id="6-1-无限增加树的路数是不是可以有最优的查找效率？">6.1 <strong>无限增加树的路数是不是可以有最优的查找效率</strong>？</h5><ul><li><p>这样会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，<u>不一定能一次性加载到内存中</u>。</p></li><li><p><strong>有序数组没法一次性加载进内存</strong>，这时候B+树的多路存储威力就出来了，<strong>可以每次加载B+树的一个结点，然后一步步往下找</strong>。</p></li></ul><h4 id="7-B-树怎么进行分裂、合并的？知道具体步骤吗？">7. <strong>B+树怎么进行分裂、合并的？知道具体步骤吗</strong>？</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/nullzx/p/8729425.htm">https://www.cnblogs.com/nullzx/p/8729425.htm</a></p></blockquote><p><img src="https://i.loli.net/2021/04/21/aejwRD2WxNb7slY.png" alt="image-20210421124006795"></p><h4 id="8-MySQL聚簇索引和非聚簇索引的区别是什么？">8. <strong>MySQL聚簇索引和非聚簇索引的区别是什么</strong>？</h4><ul><li><p><strong>主要区别</strong></p><ul><li><p><strong>聚簇索引</strong> ： 找到索引就找到了需要的数据，那么这个索引就是聚簇索引;</p><blockquote><p>所以Innodb主键就是<strong>聚簇索引</strong>，修改聚簇索引其实就是修改主键；但在<u>Myisam下主键索引是非聚集索引</u>。</p><p>InnoDB 会<strong>隐式定义一个主键</strong>来作为聚簇索引（但是这个主键如果更改代价较高，<u>故建表时要考虑自增ID不能频繁update</u>这点）。</p></blockquote><p><img src="https://i.loli.net/2021/05/03/mzwGgCjxuIpaeA7.png" alt="img"></p></li><li><p><strong>非聚簇索引</strong>：索引的存储和数据的存储是分离的 , 找到了索引但没找到数据，需要根<u>据<strong>索引上的值(主键/地址)再次回表查询</strong></u>，<strong>也叫做辅助索引</strong>。</p><blockquote><p>MyISM使用的是非聚簇索引 ，下图叶节点的<strong>data域存放的是数据记录的地址</strong> 。</p></blockquote><p><img src="https://i.loli.net/2021/05/03/A1X5aOY6qkuEol9.png" alt="img"></p></li></ul></li><li><p><strong>聚簇索引查找过程</strong></p><blockquote><p>首先澄清一个概念，聚簇索引和和辅助索引。</p><p>Innodb存储引擎的B+树分为，聚簇索引保存的是放着一整行的数据；辅助索引都引用<u>主键作为data域</u>。</p><p>例如，下图以Col3建立一个<strong>Innodb辅助索引</strong> ：</p><p><img src="https://i.loli.net/2021/05/03/l1IHbpgGAYr73sT.png" alt="img"></p><p>对于MyISAM，主索引和辅助索引（Secondary key）在结构上没有任何区别。<strong>只是主索引要求key是唯一的，而辅助索引的key可以重复</strong>。</p><p>例如，下图以Col2建立一个<strong>MyISAM的辅助索引</strong>：</p><p><img src="https://i.loli.net/2021/05/03/9jpKvRbIWFwucLT.png" alt="img"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * Where name=‘Alice’</span><br></pre></td></tr></table></figure><p>首先根据<u>辅助索引</u> ，在叶子节点找到<strong>0X56对应主键值</strong><code>18</code> ；然后在<u>聚簇索引</u>，根据<code>18</code> 找到对应行数据。</p></li></ul><h5 id="8-1-看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B-树查找，这不是多此一举吗？聚簇索引的优势在哪？">8.1 <strong>看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，这不是多此一举吗？聚簇索引的优势在哪</strong>？</h5><ul><li><p><strong>重复访问同一页更快</strong>：由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，<strong>已经把页加载到了Buffer中</strong>，<strong>再次访问的时候，会在内存中完成访问</strong>，不必访问磁盘；</p><blockquote><p>B+树的每个节点的数量都是一个mysql分区页的大小(阿里面试) 。</p></blockquote></li><li><p><strong>辅助索引使用主键值作为指针</strong>： 辅助索引使用主键作为&quot;指针&quot;而不是使用地址值作为指针（MyISAM） ，<strong>减少了当出现【行移动】或者数据页分裂时（<u>地址值变化</u>）辅助索引的维护工作</strong> 。</p></li></ul><h5 id="8-2-为什么name-age这些字段不适合做索引？">8.2 为什么name,age这些字段不适合做索引？</h5><p>在InnoDB中每一个表都会有聚集索引，如果表定义了主键，则（默认）主键就是聚簇索引。</p><p>一个表只有一个聚集索引，其余为普通索引。所以name，age就是普通索引，也就是作为辅助索引。</p><p>在使用普通索引name查询时，会先加载普通索引：</p><p>（1）通过普通索引查询到实际行的主键</p><p>（2）再使用主键通过聚集索引查询相应的行</p><p>（3）以此<strong>循环查询所有的行</strong><br>若直接全量搜索聚集索引，则不需要在普通索引和聚集索引中来回切换。相比两种操作的总开销可能扫描全表效率更高。</p><h4 id="9-MySQL联合索引如何使用？什么是最左匹配原则？">9. <strong>MySQL联合索引如何使用</strong>？<strong>什么是最左匹配原则</strong>？</h4><blockquote><p>参考：<a href="https://blog.csdn.net/Abysscarry/article/details/80792876">https://blog.csdn.net/Abysscarry/article/details/80792876</a></p></blockquote><p>对多个字段同时建立的索引(有顺序，ABC，ACB是完全不同的两种联合索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test` (</span><br><span class="line">  `id` int(4) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `a` varchar(10) NOT NULL,</span><br><span class="line">  `b` varchar(10) NOT NULL,</span><br><span class="line">  `c` varchar(10) NOT NULL,</span><br><span class="line">  `d` varchar(10) NOT NULL,</span><br><span class="line">  `e` varchar(10) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  # 联合索引(a,b,c)</span><br><span class="line">  UNIQUE KEY `idx_a_b_c` (`a`,`b`,`c`) USING BTREE </span><br><span class="line">) ENGINE=I</span><br></pre></td></tr></table></figure><p>以联合索引(a,b,c)为例：</p><ul><li><p><strong>建立这样的索引相当于建立了索引a、ab、abc三个索引</strong>。一个索引顶三个索引当然是好事，毕竟每多一个索引，都会增加写操作的开销和磁盘空间的开销。</p><blockquote><p><strong>a,c</strong>组合也可以但不是为他建立了索引，但实际上只用到了a的索引，c并没有用到！</p></blockquote></li><li><p><strong>最左匹配原则</strong></p><p>最左优先，在检索数据时从联合索引的最左边开始匹配，<strong>即是where条件必须有联合索引的第一个字段。</strong></p><ul><li><p>不包含第一个字段</p><p>不会走索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  * from test where  b = &#x27;333&#x27; and c = &#x27;333&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>where和索引顺序不一样</p><p>会走索引，<u>和顺序无关</u>。</p><blockquote><p>where 后面列的顺序是被<strong>优化器</strong>优化了的，所以才会觉得无影响，你可以查看一下优化器优化后的语句，会帮你调整为满足最左前缀的顺序。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  * from test where c = &#x27;333&#x27; and b = &#x27;333&#x27; and a = &#x27;333&#x27;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="9-1-联合索引的好处？">9.1 联合索引的好处？</h5><h4 id="10-（还要补充）介绍一下索引失效的原因？">10. （还要补充）介绍一下索引失效的原因？</h4><blockquote><p>很不错的一篇文章：<a href="https://cloud.tencent.com/developer/article/1704743">索引失效原理，终于有人讲明白了</a></p><p>结合这篇文章：<a href="https://juejin.cn/post/6844904073955639304">https://juejin.cn/post/6844904073955639304</a></p></blockquote><p>假设mysql 存在联合索引（a,b），显然也是一颗B+树:</p><p><img src="https://i.loli.net/2021/05/24/GlDckpZzWTnodIf.png" alt="image-20210524114029113"></p><ul><li><p><strong>不符合最左匹配失效</strong></p><ol><li><p>情况1 ：<code>select * from testTable where b=2</code></p><p>联合索引是通过第一个索引<code>a</code> 来构建B+树，进行定位二分查找的，不能直接通过<code>b</code> 来进行二分查找。</p></li><li><p>情况2：<code>like</code>查询失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">where name like &quot;a%&quot;  # 会有效，因为可以匹配到首字母</span><br><span class="line"></span><br><span class="line">where name like &quot;%a%&quot; # 首字母是任意匹配的，所以索引用不上</span><br><span class="line"></span><br><span class="line">where name like &quot;%a&quot; # 同上，不能根据尾字母来索引</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>范围查询失效</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from testTable where a&gt;1 and b=2</span><br></pre></td></tr></table></figure><p>首先<strong>a字段在B+树上是有序</strong>的，所以可以用二分查找法定位到1，然后将所有大于1的数据取出来，a可以用到索引。</p><p><strong>b有序的前提是a是确定的值</strong>，那么现在a的值是取大于1的，可能有10个大于1的a，也可能有一百个a。</p><p>大于1的a那部分的B+树里，b字段是无序的（开局一张图），所以b不能在无序的B+树里用二分查找来查询，b用不到索引。</p></li><li><p><strong>多个单列索引</strong></p><p>我们首先建立了三个单列索引：userid，mobile，billMonth。然后使用以下查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE  userid=&#x27;2222&#x27; AND mobile=&#x27;13281899972&#x27; AND billMonth=&#x27;2018-04&#x27;</span><br></pre></td></tr></table></figure><ul><li><p><code>explain</code> 结果分析，最终只有<code>userid</code> 这<strong>一个索引有效</strong>。</p><blockquote><p>此处<code>userid 、mobile 、billMonth</code>这三个索引列都能用，只不过<strong>优化器判断使用<code>userid</code>这一个索引能最高效完成本次查询</strong>，故最终explain展示的key为userid。</p></blockquote></li></ul><p>特别的，如果改为 <code>or</code> 进行判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE  userid=&#x27;2222&#x27; OR mobile=&#x27;13281899972&#x27; </span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/24/UDQxsm7YIrglvu8.png" alt="这里写图片描述"></p><ul><li><p><strong>此时两个索引 userid &amp; mobile都用上了</strong>。</p><blockquote><p>mysql <u>5.0 版本之前</u> 使用or<strong>只会用到一个索引</strong>, 自从<u>5.0版本开始</u> ，引入了index_merge索引合并优化！也就是说，我们现在可以利用上多个索引去优化or查询了。</p></blockquote></li></ul></li><li><p><strong>或者索引加上了运算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c - 1 = 1000;</span><br></pre></td></tr></table></figure><p>这种情况不会有效，应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c = 1000 + 1;</span><br></pre></td></tr></table></figure><p>又比如用了函数操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where pow(c,2) = 1000;</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-【⚠️-新增】索引实战篇">11. 【⚠️ 新增】索引实战篇</h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/115778804">https://zhuanlan.zhihu.com/p/115778804</a></p></blockquote><ol><li><p><code>where a=xxx and b=xxx order by c</code>  ，如何建立索引？</p><p>建立联合索引<code>（a,b,c）</code> ，因为这样的话<strong>无需做一次额外的排序操作</strong>。</p><p>因为建立联合索引时，根据最左匹配原则，先按<code>a</code>排序，再按<code>b</code>排序，最后按<code>c</code> 排序。根据联合索引检索到，<code>a=xxx and b=xxx</code>条件时，再去检索<code>c</code>本身已排序的。那么不用 <code>order by c</code> ，不用进行文件排序。</p><ul><li>注意，建立联合索引 <code>（a,b）</code> , 则是走不到 sort的！</li></ul></li><li><p><code>where a=xxx  order by b,c</code>  ，如何建立索引？</p><p>道理同上，建立<code>（a,b,c）</code> 。</p></li><li><p><code>where a &gt; 1 ORDER BY b</code>，怎么建立索引？</p><p>建立索引（a）即可，因为a是范围查询：</p><ul><li>建立（a,b）的 话b也用不上，因为是a是范围查询；</li><li>建立（b,a）, <strong>b按索引排好序，a&gt;1可以用上？错误，因为先where筛选才会order by！</strong></li></ul></li><li><p><code>where a=1 and b=2 and c&gt;3 and d=4</code> ，如何建立索引？</p><p>建立联合索引，<code>(a,b,d,c)</code>  即可。</p><ul><li>但是对于建立<code>(a,b,c,d)</code> ，<strong>a,b,c三个字段能用到索引，而d就匹配不到</strong>，因为遇到了<strong>范围查询，在c&gt;3这个范围内，d不是有序的；但是c=3，这个范围内，d是有序的</strong>！</li></ul></li><li><p><code>where a &gt; 1 and b = 2 and c &gt; 3</code>，如何建立索引？</p><p>建立（b,c）或者（b,a）即可，但至少有一个索引要失效（遇上范围查询）。</p></li><li><p><code>WHERE a IN (1,2,3) and b &gt; 1</code>，怎么建立索引？</p><p>还是对(a，b)建立索引，因为IN在这里可以视为等值引用，不会中止索引匹配，所以还是(a,b)！</p></li></ol><h5 id="11-1-有个字段值可能正，可能负，查询该字段要绝对值，但计算会导致索引失效，怎么优化？">11.1 <strong>有个字段值可能正，可能负，查询该字段要绝对值，但计算会导致索引失效，怎么优化</strong>？</h5><ol><li>拆成两列1列只存绝对值，另起一列tinyint来表示正负或者方向；</li><li>先查询到结果，然后再查询的结果上进行操作（取绝对值）？</li></ol><h4 id="12-order-by-怎么进行排序的？怎么优化？">12. order by 怎么进行排序的？怎么优化？</h4><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000040357292">https://segmentfault.com/a/1190000040357292</a></p></blockquote><p>假设存在以下数据：</p><p><img src="https://i.loli.net/2021/09/04/cudfwqEHGmn3Ppt.png" alt="image-20210904013336980"></p><p>此时进行如下查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select city, order_num, user_code from `order` where city=&#x27;广州&#x27; order by order_num limit 1000;</span><br></pre></td></tr></table></figure><ol><li><p><strong>建立索引(city)：order by过程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `order` ADD INDEX city_index ( `city` );</span><br></pre></td></tr></table></figure><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210904013506155.png" alt="image-20210904013506155" style="zoom:80%;" /><ul><li><p><strong>用 explain 看看执行情况</strong></p><p><img src="https://i.loli.net/2021/09/04/lv3uyaxWkKPtqjd.png" alt="img"></p><p>注意到最后一个 extra 字段的结果是：<strong>Using filesort</strong>，表示需要排序。<strong>其实 MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer</strong>。</p></li><li><p><strong>完整执行过程</strong></p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/Pm7eJ1vQFg8l2xA.png" alt="image-20210904013732363" style="zoom:80%;" /><ol><li><p>初始化 <strong>sort_buffer</strong>，放入 <code>city、order_num、user_code</code> 这三个字段；</p></li><li><p>从索引 city 找到第一个满足 city=’ 广州’条件的主键 id，也就是图中的 ID_3；</p></li><li><p><strong>到主键 id 索引取出整行</strong>，取 city、order_num、user_code 三个字段的值，存入 sort_buffer 中；</p></li><li><p>从索引 city 取下一个记录的主键 id；</p></li><li><p>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_X；</p></li><li><p>对 sort_buffer 中的数据按照字段 <strong>order_num 做快速排序</strong>；</p><blockquote><p>其中，<strong>按 order_num 排序</strong>这个步骤，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 <strong>sort_buffer_size</strong>。</p></blockquote></li><li><p>按照排序结果取前 1000 行返回给客户端。</p></li></ol></li></ul></li><li><p><strong>优化1：使用rowid</strong></p><p>上面的全字段排序其实会有很大的问题，你可能发现了。<strong>我们需要查询的字段都要放到 sort_buffer 中，如果查询的字段多了起来，内存占用升高，就会很容易打满 sort_buffer</strong> 。</p><ul><li><p><strong>sort_buffer 只存 order_num 和 id 字段</strong>。</p><img src="https://i.loli.net/2021/09/04/PRwrO4ae3BJLciH.png" alt="img" style="zoom:80%;" /><ol><li>初始化 sort_buffer，确定放入两个字段，即 order_num 和 id；</li><li>从索引 city 找到第一个满足 city=’ 广州’条件的主键 id，也就是图中的 ID_3；</li><li><strong>回表</strong>，取 order_num、id 这两个字段，存入 sort_buffer 中；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到不满足 city=’ 广州’条件为止，也就是图中的 ID_X；</li><li>对 sort_buffer 中的数据按照字段 order_num 进行排序；</li><li>遍历排序结果，取前 1000 行，再次回表取出 city、order_num 和 user_code 三个字段返回给客户端。</li></ol></li></ul></li><li><p><strong>优化2：建立联合索引</strong></p><p>参见索引部分解释，不再赘述。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1460000040357304" alt="img" style="zoom:80%;" /><ol><li><p>从索引 (city,order_num) 找到第一个满足 city=’ 广州’条件的主键 id；</p></li><li><p>回表，取 city、order_num、user_code 三个字段的值，作为结果集的一部分直接返回；</p></li><li><p>从索引 (city,order_num) 取下一个记录主键 id；</p></li><li><p>重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’ 广州’条件时循环结束。</p></li></ol></li></ol><h2 id="5-3-事务相关">5.3 事务相关</h2><h4 id="1-请介绍一下数据库事务？和-u-事务特性-u-（ACID）？">1.<strong>请介绍一下数据库事务？和<u>事务特性</u>（ACID）</strong>？</h4><ul><li><p><strong>数据库事务</strong>： 数据库事务指的是一组数据操作，事务内的操作要么就是全部成功，要么就是全部失败。</p><blockquote><p><em>e.g.</em>  假设一个网购付款的操作，用户付款后要涉及到订单状态更新、扣库存以及其他一系列动作，这就是一个事务，如果一切正常那就相安无事，一旦中间有某个环节异常，那整个事务就要回滚，总不能更新了订单状态但是不扣库存吧。</p></blockquote></li><li><p><strong>事务特性</strong>：（1） 原子性（Atomicity）：一个事务必须视为一个不可分割的最小工作单元，要么都成功要么都失败（2）一致性（Consistency）：数据库总能从一个<strong>一致性的状态转换到另一个一致性的状态</strong>（3）隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的（4）持久性（Durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中</p></li></ul><h5 id="1-1-四大特性得不到保障会出现什么情况？">1.1 四大特性得不到保障会出现什么情况？</h5><blockquote><p>我们以从A账户转账50元到B账户为例进行说明一下ACID这四大特性。</p></blockquote><ul><li><p><strong>原子性</strong> : 原子性是指一个事务是一个不可分割的工作单位，<strong>其中的操作要么都做，要么都不做</strong>。即要么转账成功，要么转账失败，是不存在中间的状态。</p><blockquote><p><strong>如果无法保证原子性会怎么样</strong>？</p></blockquote><p>会出现数据不一致的情形，A账户减去50元，而B账户增加50元操作失败。系统将无故丢失50元~</p></li><li><p><strong>一致性</strong> ：一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的。 那什么是合法的数据状态呢？这个状态是满足预定的约束就叫做合法的状态，再通俗一点，这状态是由你自己来定义的。<strong>满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的。</strong></p><blockquote><p><strong>如果无法保证一致性会怎么样</strong>？</p></blockquote><ul><li><p>例一: A账户有200元，转账300元出去，此时A账户余额为-100元。</p><p>你自然就发现了此时数据是不一致的，为什么呢？因为你定义了一个状态，<strong>余额这列必须大于0</strong>。</p></li><li><p>例二：A账户200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。</p><p>你也知道此时数据是不一致的，为什么呢？因为你定义了一个状态，<strong>要求A+B的余额必须不变</strong>。</p></li></ul></li><li><p><strong>隔离性</strong> ：隔离性是指<strong>多个事务并发执行的时候，事务内部的操作与其他事务是隔离的</strong>，并发执行的各个事务之间不能互相干扰。</p><blockquote><p><strong>如果无法保证隔离性会怎么样</strong>？</p></blockquote><p>假设A账户有200元，B账户0元。A账户往B账户转账两次，金额为50元，分别在两个事务中执行。</p><p>如果无法保证隔离性，A可能就会出现扣款两次的情形，而B只加款一次，凭空消失了50元，依然出现了数据不一致的情形！</p></li><li><p><strong>持久性</strong> : 根据定义，<strong>持久性是指事务一旦提交，它对数据库的改变就应该是永久性的</strong>。接下来的其他操作或故障不应该对其有任何影响。</p><blockquote><p><strong>如果无法保证持久性会怎么样</strong>？</p></blockquote><p>在MySQL中，为了解决CPU和磁盘速度不一致问题，MySQL是将磁盘上的数据加载到内存，对内存进行操作，然后再回写磁盘。好，假设此时宕机了，在内存中修改的数据全部丢失了，持久性就无法保证。</p><p>设想一下，系统提示你转账成功。但是你发现金额没有发生任何改变，此时数据出现了不合法的数据状态，我们将这种状态认为是<strong>数据不一致</strong>的情形。</p></li></ul><h5 id="1-2-数据库如何保证四大特性（如何实现事务）？">1.2 数据库如何保证四大特性（如何实现事务）？</h5><p>数据库事务的 ACID 四大特性是事务的基础，了解了 ACID 是如何实现的，我们也就清楚了事务的实现，接下来我们将依次介绍数据库是如何实现这四个特性的。</p><ul><li><p><strong>保证原子性</strong></p><p>主要是利用Innodb的<strong>undo log</strong>。</p><p>undo log名为回滚日志，是实现原子性的关键，当<strong>事务回滚时能够撤销所有已经成功执行的sql语句</strong>，他需要记录你要回滚的相应日志信息。</p><p>例如</p><ul><li>(1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据</li><li>(2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作</li><li>(3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操</li></ul><p>undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p></li><li><p><strong>保证一致性</strong></p><p>数据库对于 ACID 中的一致性的定义是这样的：<strong>如果一个事务原子地在一个一致地数据库中独立运行，那么在它执行之后，数据库的状态一定是一致的</strong>。</p><ul><li>它的第一层意思就是对<strong>于数据完整性的约束</strong>，包括主键约束、引用约束以及一些约束检查等等，在事务的执行的前后以及过程中不会违背对数据完整性的约束，所有对数据库写入的操作都应该是合法的，并不能产生不合法的数据状态。</li><li>第二层意思其实是指逻辑上的对<strong>于开发者的要求</strong>，我们要在代码中写出正确的事务逻辑，比如银行转账，事务中的逻辑不可能只扣钱或者只加钱，这是应用层面上对于数据库一致性的要求。</li></ul></li><li><p><strong>保证隔离性</strong></p><p>在 SQL 标准中定义了四种数据库的事务的隔离级别：<code>READ UNCOMMITED</code>、<code>READ COMMITED</code>、<code>REPEATABLE READ</code> 和 <code>SERIALIZABLE</code>；</p><p>数据库对于隔离级别的实现就是使用<strong>并发控制机制</strong>对在同一时间执行的事务进行控制：</p><ol><li><p><strong>锁</strong>： MySQL 和常见数据库中的锁都分为两种，共享锁（Shared）和互斥锁（Exclusive），前者也叫读锁，后者叫写锁。</p></li><li><p><strong>mvcc实现</strong>：实现RC和RR。</p></li></ol></li><li><p><strong>保证持久性</strong></p><p>利用Innodb的<strong>redo log</strong>，为什么要使用redo log，请看下面：</p><ul><li>正如之前说的，Mysql是把磁盘上的数据<strong>先加载到内存</strong>中，在内存中对数据进行修改，再刷回磁盘上。<strong>如果此时突然宕机，内存中的数据就会丢失；</strong></li><li><strong>如果事务提交前直接把数据写入磁盘，只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了</strong>。</li></ul><p><strong>redo log解决方案</strong>：</p><ul><li>当做数据修改的时候，<strong>不仅在内存中操作，还会在redo log中记录这次操作</strong>；</li><li>当事务提交的时候，<strong>会将redo log日志进行刷盘</strong>(redo log一部分在内存中，一部分在磁盘上)；</li><li><strong>当数据库宕机重启</strong>的时候，会将redo log中的内容恢复到数据库中，<strong>再根据undo log和binlog内容决定回滚数据</strong>还是提交数据。</li></ul></li></ul><h5 id="1-3-binlog日志是做什么的？">1.3 binlog日志是做什么的？</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/kevingrace/p/5907254.html">https://www.cnblogs.com/kevingrace/p/5907254.html</a></p></blockquote><p>MySQL的二进制日志binlog可以说是MySQL最重要的日志，<strong>它记录了所有的DDL和DML语句（除了数据查询语句select）</strong>，以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。</p><blockquote><p>DDL ，即 Data Definition Language 数据库定义语言。</p><ul><li>主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。</li></ul><p>DML，即Data Manipulation Language 数据操纵语言。</p><ul><li>主要的命令是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言。</li></ul></blockquote><p>binlog日志有两个最重要的使用场景：</p><ol><li><strong>MySQL主从复制</strong>：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves来达到<br>master-slave数据一致的目的。</li><li><strong>自然就是数据恢复了</strong>，通过使用mysqlbinlog工具来使恢复数据。</li></ol><h4 id="2-介绍一下（并发）事务不同隔离级别？对应可能出现的问题？">2.<strong>介绍一下（并发）事务不同隔离级别</strong>？<strong>对应可能出现的问题</strong>？</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/shan-kylin/p/9543294.html">https://www.cnblogs.com/shan-kylin/p/9543294.html</a></p></blockquote><p>下面<strong>排它锁和共享锁</strong>都是<strong>行锁</strong>，锁住一行。</p><ul><li><p><strong>Read uncommitted：</strong> 顾名思义，就是一个事务可以读取另一个未提交事务的数据。但这种情况会出现<strong>脏读</strong>： 因为<strong>写</strong>数据的时候添加一个<strong>X锁（排他锁，拿到锁的事务可以写，其它事务只能等待阻塞</strong>）；但<strong>读</strong>不受限制，读不加锁。</p><blockquote><p>由于读不加锁，读的是可能是修改前（未提交）的数据，也就是<strong>脏读</strong>。</p></blockquote></li><li><p><strong>Read Committed ：写</strong>数据的时候加上<strong>X锁（排他锁</strong>），<strong>读</strong>数据的时候添加<strong>S锁（共享锁，拿到锁的事务可以查看但无法修改和删除，其它事务【只能加S锁】【不能加其它锁】如X锁</strong>）。解决脏读，但会导致出现<strong>不可重复读</strong>的问题。</p><blockquote><ol><li>初始x=100,；</li><li>事务A<strong>读</strong>x，加上<strong>S锁</strong>，读到x=<strong>100</strong>，<strong>立即释放S锁且未提交</strong>；</li><li>事务B<strong>修改</strong>x，加上<strong>X锁</strong>，修改x=50，提交 ；</li><li>事务A再次<strong>读取x</strong>，加上<strong>S锁</strong>，读取x=<strong>50</strong>，发现和第一次读取不一致，提交事务。</li></ol><p>上述过程，事务A在提交前读取两次不一样的x值，为<strong>不可重复读</strong>。</p></blockquote></li><li><p><strong>Repeatable read</strong> ：<strong>MySQL 默认隔离界别</strong> , 开始<strong>读取</strong>数据（事务开启）时，<strong>【S】锁不再立即释放，其它事务就不能加上【X】锁修改数据</strong>。解决了脏读、不可重复读，但是可能会出现<strong>幻读</strong>：-</p><ul><li>Mysql官方给出的幻读解释是：<strong>只要在一个事务中，第二次select（读）多出了row就算幻读</strong>。</li></ul><blockquote><p>现在做如下修改：</p><ul><li>写：X锁保持不变</li><li>读：S锁，<strong>读完不再立即释放</strong>，而是<strong>在提交的时候再释放</strong>。</li></ul><p>这样的话，保证事务A在<u>提交前</u>，读取的x是一致的。解决了<strong>不可重复读</strong>，但依旧可能出现<strong>幻读</strong>。例如，<strong>X锁不能阻止（表中其它记录）插入操作，因为只锁住了当前记录，是行级锁</strong>。</p><ol><li>事务A加上X锁，更新了<strong>所有用户</strong>年龄从<code>20→18</code>；</li><li>过一会儿再读发现<strong>还有一个用户没修改</strong>，还是20岁？出现幻觉了吗？</li></ol><p>这是因为，其它事务B同时插入了一行新数据，年龄就是20岁。所以再读发现没修改。</p></blockquote></li><li><p><strong>Serializable</strong>： 序列化，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。耗费性能，一般不用。</p></li></ul><h5 id="2-1【猿辅导】-怎么解决幻读？">2.1【猿辅导】 怎么解决幻读？</h5><p>解决幻读使用两种方式：</p><ol><li><p><strong>间隙锁</strong></p><ul><li><p><strong>间隙锁（Gap Lock</strong>）：当我们用【范围条件】而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给<strong>符合条件的已有数据记录的索引项加锁</strong>；对于键值在<strong>条件范围内但并不存在的记录，叫做“间隙（GAP)”</strong>，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁；</p></li><li><p><strong>举例</strong>： 假如user表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  <span class="keyword">user</span> <span class="keyword">where</span> user_id <span class="operator">&gt;</span> <span class="number">99</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><p>是一个范围条件的检索，InnoDB不仅会对（1）<strong>符合条件的user_id值（100、101）的记录加锁</strong>，也会对（2）user_id大于101（这些<strong>记录并不存在）的“间隙”加锁</strong>。</p></li><li><p><strong>如何解决幻读</strong>？ 产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”，导致下次读取产生幻读。如果锁住了间隙，自然也就没锁的问题了。</p></li></ul></li><li><p><strong>mvvc</strong></p><p>在RR（可重复读级别下）不会出现幻读。例如：</p><ol><li><p>开启事务1，获得事务ID为1。</p></li><li><p>事务1执行查询，得到readview。</p></li><li><p>开始事务2。</p></li><li><p>执行insert。</p></li><li><p>提交事务2。</p></li><li><p>执行事务1的第二次查询 (因为这里是RR级别，所以<strong>不会再去获得readview，<strong>还是使用第一次获得的readview，所以</strong>当前read view 事务的ID不会更新</strong>，即不会加入插入事务2)</p></li><li><p>最后得到的结果是，插入的数据不会被读取显示，因为<strong>插入的数据事务ID &gt; readview里的最大活跃事务ID</strong>。</p></li></ol></li></ol><h2 id="5-4-MySQ优化">5.4 MySQ优化</h2><h4 id="0-分页查询慢的原因？如何优化？">0. 分页查询慢的原因？如何优化？</h4><blockquote><p>参考：<a href="https://juejin.cn/post/6844904141878214664">https://juejin.cn/post/6844904141878214664</a></p></blockquote><p>在偏移量非常大的时候，也就是翻页到很靠后的页面时，查询速度会变得越来越慢，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_order order by id limit 1000000000, 10;</span><br></pre></td></tr></table></figure><p>这是因为，需要查询 100000000010 (100000000000 + 10) 条记录，然后只返回最后 10 条，并将前面的 100000000000 条记录抛弃，这样当翻页越靠后时，代价就变得越来越高。</p><p><strong>优化方法</strong>：</p><ol><li><p><strong>最大id法</strong></p><ul><li><p>举例：查询第一页的时候是limit 400000,10 查询到的最后一条id是4000000，那么下一页的查询只需要查询id大于400000的10条数据即可。</p></li><li><p>语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from user where id &gt; 4000000  limit 10;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>BETWEEN … AND</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id BETWEEN 4000000 and 4000010</span><br></pre></td></tr></table></figure></li><li><p><strong>分表查询</strong></p><p>mysql推荐一张表的存储不要超过500w数据，查询400w不到1秒对于一般的查询来说已经可以了，如果还要更快的话，我建议使用分表存储，分表又分两种情况，水平分表于垂直分表。</p></li><li><p><strong>延迟关联（个人推荐</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table a,(select id from table limit 100000,20) b on a.id=b.id</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-SQL优化手段有哪些？">1. <strong>SQL优化手段有哪些</strong>？</h4><ol><li><p>查询语句中不要使用select</p></li><li><p><strong>尽量减少子查询，使用关联查询</strong>（left join,right join,inner join）替代</p></li><li><p><strong>减少使用IN或者NOT IN ,使用exists，not exists</strong>或者关联查询语句替代(在确认没有重复数据或者不用剔除重复数据时，union all会更好)</p></li><li><p><strong>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符</strong>，否则将引擎放弃使用索引而进行全表扫描。</p></li><li><p><strong>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</strong>，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0</p></li></ol><h4 id="2-请问如何防止SQL被注入？">2.<strong>请问如何防止SQL被注入</strong>？</h4><ul><li><p><strong>什么是SQL注入</strong>？</p><p>攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。</p><ul><li><p>例如：用户登录，攻击者输入：<code>用户名 = liangzone</code>，<code>密码 = ‘ or ‘1’=’1</code>  ，那么拼接后的语句是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name = ‘lianggzone’ and password = ‘’ or ‘1’=‘1’ </span><br></pre></td></tr></table></figure><p>攻击者就可以<strong>查询出所有的用户表信息</strong>！</p></li></ul></li><li><p><strong>如何防范SQL注入</strong>？</p><ul><li>Web端：1）有效性检验； 2）限制字符串输入的长度</li><li>服务器端：1）不用拼接SQL字符串， 2）使用预编译的PrepareStatement， 3）有效性检验，4）<strong>过滤SQL需要的参数中的特殊字符，比如单引号、双引号</strong>。</li></ul></li></ul><h4 id="3-MySQL-如何做到高并发解决方案？">3. <strong>MySQL 如何做到高并发解决方案</strong>？</h4><ol><li><strong>在web服务框架中加入缓存</strong>。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li><li><strong>增加数据库索引，进而提高查询速度</strong>。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li><li><strong>主从读写分离分库</strong>，让主服务器负责写，从服务器负责读。</li><li><strong>将数据库表进行拆分表</strong>，使得数据库的表尽可能小，提高查询的速度。</li><li><strong>使用分布式架构</strong>，分散计算压力。</li></ol><h4 id="4-大表如何进行优化？">4. 大表如何进行优化？</h4><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，⼀些常⻅的优化措施如下。</p><ul><li><p><strong>限定数据的范围</strong>：务必禁⽌不带任何限制数据范围条件的查询语句。⽐如：我们当⽤户在查询订单历史的时候，我们可以控制在⼀个⽉的范围内；</p></li><li><p><strong>读/写分离</strong>：经典的数据库拆分⽅案，主库负责写，从库负责读；</p></li><li><p><strong>垂直分区</strong>：根据数据库⾥⾯数据表的相关性进行拆分。</p><blockquote><p>例如，⽤户表中既有⽤户的登录信息⼜有⽤户的基本信息，可以将⽤户表拆分成两个单独的表，甚⾄放到单独的库做分库。</p><ul><li><p>简单来说垂直拆分是指数据表列的拆分，把⼀张列⽐较多的表拆分为多张表。</p><p><img src="https://i.loli.net/2021/05/16/25HtBIuXygCUVrq.png" alt="image-20210516234359675"></p></li></ul></blockquote></li><li><p><strong>水平分区 :</strong> 保持数据表结构不变，通过某种策略存储数据分⽚。这样每⼀⽚数据分散到不同的表或者库中，<strong>达到了分布式的⽬的</strong>。 ⽔平拆分可以支撑⾮常大的数据量。</p></li></ul><p>其它数据库结构方面优化：</p><ul><li><strong>范式优化</strong>： 比如消除冗余（节省空间。。）</li><li><strong>反范式优化</strong>：比如适当加冗余等（减少join）</li></ul><h4 id="5-数据库如何去重？">5. 数据库如何去重？</h4><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000002508404">MySQL数据库行去重复和列去重复</a></p></blockquote><h5 id="5-1-行去重">5.1 行去重</h5><blockquote><p>存在行重复，则无法建立 <u>唯一索引</u> 等。</p></blockquote><blockquote><p>用<code>distinct</code> 得到我们要保留的数据也是可以的。</p></blockquote><p>下面假设的是email字段重复。</p><ol><li><p>查看我们的分组后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *,count(id) from demo_table group by email having count(id)&gt;1 order by id;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----+------+--------------+-----------+</span><br><span class="line">| id | name | email        | count(id) |</span><br><span class="line">+----+------+--------------+-----------+</span><br><span class="line">|  1 | u1   | u1@email.com |         4 |</span><br><span class="line">|  2 | u2   | u2@email.com |         4 |</span><br><span class="line">|  3 | u3   | u3@email.com |         3 |</span><br><span class="line">|  4 | u4   | u4@email.com |         2 |</span><br><span class="line">|  5 | u5   | u5@email.com |         2 |</span><br><span class="line">+----+------+--------------+-----------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>保留每个分组<strong>最小的id</strong>，表中其余都删除</p><p>在表中删除不符合要求的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from demo_table where id not in (select min(id) from demo_table group by email);</span><br></pre></td></tr></table></figure><p>但是似乎有保护机制，无法直接删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1093 (HY000): You can&#x27;t specify target table &#x27;demo_table&#x27; for update in FROM clause</span><br></pre></td></tr></table></figure></li><li><p>创建临时表再删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建临时表保存每个分组中最小的那个id</span><br><span class="line">create table tmp_table as select min(id) from demo_table group by email;</span><br><span class="line"></span><br><span class="line"># 删除表中数据</span><br><span class="line">delete from demo_table where id not in (select * from tmp_table);</span><br><span class="line"></span><br><span class="line"># 删除临时表</span><br><span class="line">drop table tmp_table;</span><br></pre></td></tr></table></figure></li></ol><h5 id="5-2-列重复">5.2 列重复</h5><ol><li><p>先找到重复字段的<strong>行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from demo_table as a, demo_table as b where a.id=b.id and a.name=b.email;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----+--------------+--------------+----+--------------+--------------+</span><br><span class="line">| id | name         | email        | id | name         | email        |</span><br><span class="line">+----+--------------+--------------+----+--------------+--------------+</span><br><span class="line">| 31 | 31@email.com | 31@email.com | 31 | 31@email.com | 31@email.com |</span><br><span class="line">| 32 | 32@email.com | 32@email.com | 32 | 32@email.com | 32@email.com |</span><br><span class="line">| 33 | 33@email.com | 33@email.com | 33 | 33@email.com | 33@email.com |</span><br><span class="line">| 34 | 34@email.com | 34@email.com | 34 | 34@email.com | 34@email.com |</span><br><span class="line">| 35 | 35@email.com | 35@email.com | 35 | 35@email.com | 35@email.com |</span><br><span class="line">+----+--------------+--------------+----+--------------+--------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>重复记录的id都已经找出来了，删除就参考上述方式处理了。</p></li></ol><h4 id="6-select慢的原因？慢查询的优化策略？">6. select慢的原因？慢查询的优化策略？</h4><h5 id="6-1-select-很慢的原因">6.1 select 很慢的原因</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/kubidemanong/p/10734045.html">腾讯面试：一条SQL语句执行得很慢的原因有哪些?</a></p></blockquote><ul><li><p><strong>如果是偶尔很慢</strong></p><p>针对这种情况，这条SQL语句的书写本身是没什么问题的。可能是其它原因导致：</p><ol><li><strong>被加锁。</strong> 要执行的这条语句，刚好这条语句涉及到的<strong>表</strong>，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了；或者，表没有加锁，但要使用到的某个一<strong>行</strong>被加锁了 。</li><li>数据库在刷新脏页 ？ 看链接，不太明白流程。</li></ol></li><li><p><strong>如果是经常很慢</strong></p><ol><li><p><strong>没用到索引</strong></p></li><li><p><strong>索引失效了</strong> ：</p><p>（1）联合索引不满足最左匹配（不包含第一个索引）；</p><p>（2）like语句不满足最左匹配（不包含第一个索引）</p><p>（3）或者索引加上了运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c - 1 = 1000;</span><br></pre></td></tr></table></figure><p>这种情况不会有效，应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c = 1000 + 1;</span><br></pre></td></tr></table></figure><p>（4）或者函数操作用上索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where pow(c,2) = 1000;</span><br></pre></td></tr></table></figure></li><li><p><strong>数据库使用非聚簇索引</strong></p><p>我们在进行查询操作的时候，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where 100 &lt; c and c &lt; 100000;</span><br></pre></td></tr></table></figure><p>此时使用的非聚簇索引（辅助索引），只是存储了<strong>主键的key</strong> ，还是要再次通过聚簇索引去查找。效率可能不必全表扫描高。</p></li></ol></li></ul><h4 id="7-select…for-update用法？">7. select…for update用法？</h4><blockquote><p><a href="https://segmentfault.com/a/1190000023045909">数据库-MySQL中for update的作用和用法</a></p></blockquote><p><code>for update</code>是一种<code>行级锁</code>，又叫<code>排它锁</code>。</p><p>一旦用户对某个行施加了行级加锁，则<strong>该用户可以查询也可以更新</strong>被加锁的数据行，<strong>其它用户只能查询</strong>但不能更新被加锁的数据行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 开启事务</span><br><span class="line">begin;</span><br><span class="line">SELECT * FROM user WHERE id=3 FOR UPDATE;</span><br><span class="line">SELECT * FROM user WHERE id=3 and name=&#x27;Tom&#x27; FOR UPDATE;</span><br><span class="line">-- 提交事务</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><h4 id="8-场景题：假如选择MySQL数据库，一天五万条增量，运维三年，有哪些优化手段？">8. 场景题：假如选择MySQL数据库，一天五万条增量，运维三年，有哪些优化手段？</h4><ol><li><strong>设计良好的数据库结构</strong>，允许部分数据冗余，尽量避免join查询，提高效率；</li><li>选择合适的表字段数据类型和存储引擎，适当的<strong>添加索引</strong>；</li><li>MySQL库主从<strong>分库读写分离</strong>；</li><li>找规律<strong>分表</strong>，减少单表中的数据量提高查询速度；</li><li><strong>添加缓存机制</strong>，比如Memcached，Apc等；</li><li><strong>书写高效率的SQL</strong>。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（四）_计算机基础_操作系统</title>
      <link href="/p/15646/"/>
      <url>/p/15646/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h1>四、操场系统</h1><h2 id="4-1-操作系统基础">4.1 操作系统基础</h2><h4 id="0-（百度安全一面）-冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？">0. （百度安全一面） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？</h4><ul><li>存储器：内存</li><li><strong>控制器：南桥北桥</strong></li><li>运算器：CPU</li><li>输入设备：键盘</li><li>输出设备：显示器、网卡</li></ul><h4 id="1-什么是操作系统？">1. 什么是操作系统？</h4><ol><li>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基⽯；</li><li>操作系统本质上是运行在计算机上的软件程序 ；</li><li>操作系统为用户提供⼀个与系统交互的操作界面 ；</li><li>操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。</li></ol><h4 id="2-什么是系统调用呢？-能不能详细介绍⼀下？">2. 什么是系统调用呢？ 能不能详细介绍⼀下？</h4><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ol><li><strong>用户态(user mode) :</strong> 用户态运行的进程或可以直接读取用户程序的数据。</li><li><strong>系统态(kernel mode)</strong>：可以简单的理解系统态运行的进程或程序⼏乎可以访问计算机的任何资源，不受限制。</li></ol><p>我们运行的程序基本都是运行在<strong>用户态</strong>，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p><p>这些系统调用按功能大致可分为如下⼏类：</p><ul><li><strong>设备管理</strong>。完成设备的请求或释放，以及设备启动等功能。</li><li><strong>⽂件管理</strong>。完成⽂件的读、写、创建及删除等功能。</li><li><strong>进程控制</strong>。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li><strong>进程通信</strong>。完成进程之间的消息传递或信号传递等功能。</li><li><strong>内存管理</strong>。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li></ul><h4 id="3-CentOS-和-Linux的关系？">3. <strong>CentOS 和 Linux的关系？</strong></h4><p>Linux意思较广广义的范围，多指是Linux内核。CentOS是RedHat的一个分支，RedHat是Linux的一个发行版本，RedHat与CentOS的区别在于，RedHat收费，CentOS免费。</p><h4 id="4-什么是分布式，优缺点？集群？">4. 什么是分布式，优缺点？集群？</h4><ul><li><p><strong>分布式</strong></p><p>根据业务需求进行拆<strong>分成N个子系统</strong>，多个子系统相互协作才能完成业务流程<strong>子系统之间通讯</strong>使用<strong>RPC</strong>远程通讯技术。</p></li><li><p><strong>集群</strong></p><p>同一个工程部署在多个不同的服务器上。</p></li><li><p><strong>分布式优点</strong></p><p>1.把模块拆分，使用接口通信，降低模块之间的耦合度。</p><p>2.把项目拆分成若干个子项目，不同的团队负责不同的子项目。</p><p>3.增加功能时只需要再增加一个子项目，调用其它系统的接口就可以。</p><p>4.可以灵活的进行分布式部署。</p></li><li><p><strong>分布式缺点</strong></p><p>1.系统之间交互需要使用远程通信，接口开发增加工作量。</p><p>2.各个模块有一些通用的业务逻辑无法共用。</p></li></ul><h4 id="5-在Linux-windows栈空间的大小？">5. 在Linux/windows栈空间的大小？</h4><ul><li><p><strong>Linux环境下由操作系统决定</strong>，一般是<code>8KB</code> ， 通过ulimit命令查看以及修改</p><blockquote><p>在Linux下通过如下命令可查看和设置栈的大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">ulimit</span> -a            <span class="comment"># 显示当前栈的大小 （ulimit为系统命令，非编译器命令）</span></span>       </span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">ulimit</span> -s 32768      <span class="comment"># 设置当前栈的大小为32MCopy to clipboardErrorCopied</span></span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>Windows环境下由编译器决定</strong>，VC++6.0一般是<code>1M</code> \</p><blockquote><p>Windows平台下栈的大小是被记录在可执行文件中的（由编译器来设置)，即：windows下可以由编译器决定栈大小，而在Linux下是由系统环境变量来控制栈的大小的。</p></blockquote></li></ul><h4 id="6-ASCII、Unicode和UTF-8编码的区别？">6. ASCII、Unicode和UTF-8编码的区别？</h4><ul><li><p><strong>ASCII :</strong>  ASCII 只有127个字符，表示英文字母的大小写、数字和一些符号 ；</p><blockquote><p>常用中文需要两个字节，且不能和ASCII冲突，中国定制了<code>GB2312</code>编码格式。</p></blockquote></li><li><p><strong>Unicode：</strong> Unicode就是将<strong>不同语言统一到一套编码格式中</strong>，通常<strong>两个</strong>字节表示一个字符，而<strong>ASCII是一个</strong>字节表示一个字符 ；</p><blockquote><p>如果你编译的文本是全英文的，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p></blockquote></li><li><p><strong>UTF-8 :</strong>  把Unicode编码转化为 “<strong>可变长编码</strong>” UTF-8编码，UTF-8编码将Unicode字符按数字大小编码为<strong>1-6</strong>个字节，英文字母被编码成<strong>1</strong>个字节，常用汉字被编码成<strong>2</strong>个字节。</p></li></ul><h5 id="6-1-三者区别和联系">6.1 三者区别和联系</h5><ul><li><p>在<strong>计算机内存</strong>中，统一使用<strong>Unicode</strong>编码 ；</p></li><li><p>当需要<strong>保存到硬盘或者需要传输</strong>的时候，就转换为<strong>UTF-8</strong>编码</p></li></ul><p>举例说明：</p><blockquote><p>例1 ：记事本编辑（内存）→保存（磁盘）。</p></blockquote><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。</p><p><img src="https://i.loli.net/2021/06/11/9IjWniLHqrwRd2s.png" alt="image-20210611131935690"></p><blockquote><p>例2：网络传输服务器→浏览器。</p></blockquote><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。</p><p><img src="https://i.loli.net/2021/06/11/hZFaKbezvQEsxko.png" alt="image-20210611132058826"></p><h4 id="7-什么是并发和并行？同步和异步？">7. 什么是并发和并行？同步和异步？</h4><ul><li><strong>并发和并行</strong><ul><li><strong>并发</strong>： 是指宏观上在<strong>一段时间</strong>内能同时运行多个<strong>程序</strong>；</li><li><strong>并行</strong> ：则指<strong>同一时刻</strong>能运行多个<strong>指令</strong>。</li></ul></li><li><strong>同步和异步</strong><ul><li><p><strong>同步</strong>：可以理解为在执行完一个函数或方法之后，<strong>一直等待系统返回值或消息，这时程序是出于阻塞的</strong>，只有接收到返回的值或消息后才往下执行其他的命令。</p></li><li><p><strong>异步</strong>：执行完函数或方法后，<strong>不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程</strong>，那么当系统接收到返回值或消息时，系统会<strong>自动触发委托的异步过程</strong>，从而完成一个完整的流程。</p></li></ul></li></ul><h4 id="8-什么是共享？">8. 什么是共享？</h4><ul><li><p><strong>共享定义</strong>： 系统中的资源可以被多个并发进程共同使用 ；</p></li><li><p><strong>共享方式</strong>：<u>互斥</u>共享和<u>同时</u>共享：</p><ul><li><strong>互斥共享</strong>： 在<strong>同一时刻只允许一个进程访问</strong>，需要用同步机制来实现互斥访问 ，如：打印机。</li></ul></li></ul><h2 id="4-2-进程和线程">4.2 进程和线程</h2><h4 id="1-请问64位和32位的区别？">1.<strong>请问64位和32位的区别</strong>？</h4><ol><li><strong>运行能力不同</strong>：64位可以一次性可以处理8个字节的数据量，而32位一次性只可以处理4个字节的数据量，因此64位比32位的运行能力提高了一倍。</li><li><strong>内存寻址不同</strong>：64位最大寻址空间为2的64次方，理论值直接达到了16TB，而32位的最大寻址空间为2的32次方，为4GB，换而言之，就是说32位系统的处理器最大只支持到4G内存，而64位系统最大支持的内存高达亿位数。</li><li><strong>运行软件不同</strong>：由于32位和64位<u>CPU的指令集是不同</u>的。所以需要区分32位和64位版本的软件。<br>为了保证兼容性，64位CPU上也能运行老的32位指令，但反过来32位系统不可以运行64位的软件。</li></ol><h4 id="2-介绍一下线程和进程的区别？">2.<strong>介绍一下线程和进程的区别？</strong></h4><ol><li><p><strong>根本区别</strong>：进程是操作系统<strong>资源分配</strong>的基本单位，而线程是处理器<strong>任务调度</strong>和执行的基本单位</p></li><li><p><strong>资源开销：每个进程都有独立的代码和数据空间（程序上下文）</strong>，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，<strong>每个线程都有自己独立的运行栈和程序计数器</strong>（PC），线程之间切换的开销小</p></li><li><p><strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</p></li><li><p><strong>内存分配</strong>：同一进程的线程<strong>共享本进程的【地址空间和资源】</strong>，而进程之间的地址空间和资源是相互独立的</p></li><li><p><strong>影响关系</strong>：一个进程崩溃后，在保护模式下不会对其他进程产生影响，<strong>但是一个线程崩溃整个进程都死掉</strong>，<strong>所以多进程要比多线程健壮</strong>。</p><blockquote><p>线程没有独立的地址空间，如果崩溃，会发信号，如果没有错误处理的handler，OS一般直接杀死进程。</p></blockquote></li><li><p><strong>能否独立</strong>：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p></li></ol><h5 id="2-1-线程和协程之间的区别？">2.1 线程和协程之间的区别？</h5><blockquote><p><strong>进程是资源调度的基本单位</strong>，<strong>运行一个可执行程序会创建一个或多个进程</strong>，进程就是运行起来的可执行程序 ;</p><p><strong>线程是程序执行的基本单位</strong>，是轻量级的进程。<strong>每个进程中都有唯一的主线程，和多个线程</strong>，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束；</p><p><strong>协程</strong>是用户态的<strong>轻量级线程</strong>，<strong>也是线程内部调度的基本单位</strong> 。</p></blockquote><p>协程和线程的区别如下（补充了和进程的区别，方便对比）。</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">进程</th><th style="text-align:left">线程</th><th>协程</th></tr></thead><tbody><tr><td style="text-align:left">定义</td><td style="text-align:left">资源分配和拥有的基本单位</td><td style="text-align:left">程序执行的基本单位</td><td>用户态的轻量级线程，线程内部调度的基本单位</td></tr><tr><td style="text-align:left">切换情况</td><td style="text-align:left">进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td><td style="text-align:left">保存和设置程序计数器、少量寄存器和栈的内容</td><td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td></tr><tr><td style="text-align:left">切换者</td><td style="text-align:left">操作系统</td><td style="text-align:left">操作系统</td><td>用户</td></tr><tr><td style="text-align:left">切换过程</td><td style="text-align:left">用户态-&gt;内核态-&gt;用户态</td><td style="text-align:left">用户态-&gt;内核态-&gt;用户态</td><td>用户态(没有陷入内核)</td></tr><tr><td style="text-align:left">调用栈</td><td style="text-align:left">内核栈</td><td style="text-align:left">内核栈</td><td>用户栈</td></tr><tr><td style="text-align:left">拥有资源</td><td style="text-align:left"><strong>CPU资源、内存资源、文件资源和句柄等</strong></td><td style="text-align:left"><strong>程序计数器、寄存器、栈和状态字</strong></td><td><strong>拥有自己的寄存器上下文和栈</strong></td></tr><tr><td style="text-align:left">并发性</td><td style="text-align:left">不同进程之间切换实现并发，各自占有CPU实现并行</td><td style="text-align:left">一个进程内部的多个线程并发执行</td><td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td></tr><tr><td style="text-align:left">系统开销</td><td style="text-align:left">切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td><td style="text-align:left">切换时只需保存和设置少量寄存器内容，因此开销很小</td><td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td></tr><tr><td style="text-align:left">通信方面</td><td style="text-align:left">进程间通信需要借助操作系统</td><td style="text-align:left">线程间可以直接读写进程数据段(如全局变量)来进行通信</td><td>共享内存、消息队列</td></tr></tbody></table><h5 id="2-2-一个进程可以创建多少个线程，和什么有关？">2.2 一个进程可以创建多少个线程，和什么有关？</h5><p>一个进程可用虚拟空间是（C++）2G，默认情况下，（假设）<strong>线程的栈的大小是1MB</strong>（Linux是8kb），则理论上最多只能创建2048个线程。如果要创建多于2048的话，必须修改编译器的设置。</p><h5 id="2-3-进程之间的同步方式？（区分通信方式）">2.3 进程之间的同步方式？（区分通信方式）</h5><ol><li><p><strong>临界区</strong>。 对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p></li><li><p><strong>同步和互斥</strong>。</p><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻<strong>只有一个进程</strong>能进入临界区。</li></ul></li><li><p><strong>信号量</strong>。 常见的 P 和 V 操作。</p><ul><li>特别的，<u>如果信号量的取值只能为 0 或者 1</u>，那么就成为了<strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</li></ul></li><li><p><strong>条件变量</strong>。</p><blockquote><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p></blockquote><p>管程引入了<strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程：解决生产者、消费者问题</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function">procedure <span class="title">insert</span><span class="params">(item: integer)</span></span>;</span><br><span class="line">    begin</span><br><span class="line">        <span class="keyword">if</span> count = N then wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> then signal(empty);</span><br><span class="line">    end;</span><br><span class="line"></span><br><span class="line">    function remove: integer;</span><br><span class="line">    begin</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> then wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N <span class="number">-1</span> then signal(full);</span><br><span class="line">    end;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line">procedure producer</span><br><span class="line">begin</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    begin</span><br><span class="line">        item = produce_item;</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    end</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line">procedure consumer</span><br><span class="line">begin</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    begin</span><br><span class="line">        item = ProducerConsumer.remove;</span><br><span class="line">        consume_item(item);</span><br><span class="line">    end</span><br><span class="line">end;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-请问【进程】之间如何进行通信？">3.<strong>请问【进程】之间如何进行通信</strong>？</h4><p>可以分为如下两个方面：</p><ol><li>本地进程之间的通信方式</li><li>远程进程之间的通信方式</li></ol><p><strong>1. 本地进程之间的通信方式（没有同步互斥！！</strong>）</p><ul><li><p><strong>无名管道</strong> ：半双工通信方式，<strong>数据(消息)单向流动</strong>，只能是字节流格式的消息。</p><ul><li><strong>优点</strong>：简单方便</li><li><strong>缺点</strong>：单向通信、只能用于<strong>具有亲缘关系（一般指父子</strong>）的进程之间、<strong>缓冲区有限</strong></li></ul></li><li><p><strong>有名管道：半双工通信</strong>方式，数据也称为命名管道：是一种文件类型，以一种特殊设备文件形式存在于文件系统中。</p><ul><li><strong>优点</strong>：可以实现<strong>任意关系的进程</strong>间的通信（无法同步）</li><li><strong>缺点</strong>： 长期存于系统中，使用不当容易出错、<strong>缓冲区有限</strong></li></ul></li><li><p><strong>消息队列</strong>：消息队列是消息的<strong>链表</strong>,存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少,管道只能承载无格式字节流以及缓冲区大小受限等特点。</p><ul><li><strong>优点</strong>：<u>可以实现任意进程间的通信</u>，并通过系统调用函数来实现消息发送和接收之间的同步<u>，无需考虑同步</u>问题</li><li><strong>缺点</strong>：信息的复制需要<u>额外消耗CPU的时间</u>，不适宜于信息量大或操作频繁的场合</li></ul></li><li><p><strong>共享内存</strong></p><p>直接对内存存取，<u>通信快</u>，但是多个进程可以同时操作，<u>需要用信号量进行同步</u>。</p></li><li><p><strong>信号量</strong></p><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><ul><li><p><strong>优点</strong>：可以同步进程；</p></li><li><p><strong>缺点</strong>：信号量有限</p><blockquote><p>注解：P操作就是对S减一，V操作就是对S加一</p></blockquote><ul><li><strong>同步</strong>：S = 0，进程A执行完进行V操作，进程B执行前执行P操作，这样B就可以等A执行完再执行；</li><li><strong>互斥</strong>：S = 1，进程执行前进行P操作，执行后进行V操作。</li></ul></li></ul></li></ul><p><strong>2.远程进程之间的通信方式</strong></p><p>首要解决的问题是如何唯一标识一个进程？本地上采用PID即可，但是网络中 <u>TCP/IP五层网络模型中传输层的 “<strong>套接字：IP+端口</strong>”</u></p><ul><li><p><strong>套接字交互</strong></p><ul><li><strong>优点</strong>：1）传输数据为字节级，传输数据可自定义，数据量小效率高；2）传输数据时间短，性能高；3) 适合于客户端和服务器端之间信息实时交互；4) 可以加密,数据安全性强</li><li><strong>缺点</strong>：1) 需对传输的数据进行解析，转化成应用级的数据。</li></ul></li><li><p><strong>远程过程调用（RPC）</strong></p></li></ul><h4 id="4-请问【线程】间同步方式（通信方式）？">4. 请问【线程】间同步方式（通信方式）？</h4><p><img src="https://i.loli.net/2021/06/11/38AqLbJEZnhSPC9.png" alt="image-20210611000107784"></p><p>【<strong>1. Linux下线程通知方式</strong>】</p><ol><li><strong>互斥量(Mutex)</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有⼀个，所以可以保证公共资源不会被多个线程同时访问。<ul><li>⽐如 Java 中的<strong>synchronized 关键词和各种 Lock锁</strong> 都是这种机制。</li></ul></li><li><strong>信号量(Semphares)</strong> ：它允许同⼀时刻多个线程访问同⼀资源，但是需要控制同⼀时刻访问此资源的最大线程数量</li><li><strong>条件变量</strong> : 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级<ul><li>比如Wait/Notify</li></ul></li></ol><p>【<strong>2. Windows下线程通知方式</strong>】</p><ol><li><strong>全局变量</strong>：需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防编译器对此变量进行优化 ；</li><li><strong>CEvent对象</strong>：CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法；</li><li><strong>Message消息机制</strong>：常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。</li></ol><h4 id="5-什么时候用多线程-多进程？">5.<strong>什么时候用多线程 / 多进程</strong>？</h4><ul><li><strong>需要<u>频繁创建销毁</u>的优先用线程</strong> ：创建和销毁的代价是很难承受的 ；</li><li><strong>需要进行<u>大量计算</u>的优先使用线程</strong> ：此时<strong>耗费很多CPU，切换频繁</strong>，用线程更轻量；</li><li><strong>任务间相关性比较强的用多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单；</li></ul><p>考虑多进程：</p><ul><li>扩展到<strong>多机分布</strong>的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong> ；</li><li>其它一般用多线程比较好</li></ul><h4 id="6-【线程】调度算法？">6.<strong>【线程】调度算法？</strong></h4><p>在资源一定的情况下，调度算法需要在<strong>吞吐量（Throughput）、平均响应时间（延迟，Average Response Time）、公平性、调度引起的额外开销（overhead</strong>）等几个方面做权衡。</p><ol><li><p><strong>先进先出算法（FIFO，First-In-First-Out）</strong></p><ul><li><strong>优点</strong>：<ul><li><strong>最少的任务切换开销</strong>（因为没有在任务执行过程中发生切换，故任务切换开销为0）</li><li><strong>最大的吞吐量</strong>（因没有任务切换开销，在其他一定的情况下，吞吐量肯定是最大的）</li><li><strong>最朴实的公平性</strong>（先来先做）</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>平均响应时间高</strong>：耗时只需10毫秒的任务若恰巧在耗时1000毫秒的任务后到来，他则需要1010毫秒才能执行完成，绝大部分时间都花在等待被调度。</li></ul></li></ul></li><li><p><strong>最短耗时任务优先算法</strong></p><p>优先调度耗时短的任务，需要预先知道每个任务的耗时情况，这在实际情况中是不大现实的。</p><ul><li>（<strong>优点</strong>）<strong>平均响应时间较低</strong>：这里有一点，因为将时间长的任务无限往后推移，实际计算的平均响应时间的任务都是执行较快的任务，统计出来的平均响应时间必然较低的。</li><li><strong>（缺点</strong>）<strong>耗时长任务饥饿</strong>：耗时长的任务迟迟得不到调度，不公平，容易形成饥饿 。</li><li><strong>（缺点</strong>）<strong>开销大</strong>：<u>频繁的任务切换</u>，调度的额外开销大。</li></ul></li><li><p><strong>时间片轮转算法</strong></p><p>给队列中的每个任务一个时间片，第一个任务先执行，时间片到了之后，将此任务放到队列尾部，切换到下个任务执行，<u>解决最短耗时任务优先算法中耗时长任务饥饿的问题</u> 。</p><ul><li><strong>（特点）时间片设置问题</strong>： 算法介于FIFO和SJF之间，若时间片足够<strong>大</strong>，则退化到FIFO ；若分片足够小（假设不考虑任务切换的开销），则任务的完成时间顺序是以耗时从小到大排列。</li><li>（<strong>优点）公平调度</strong>：每个任务都能够得到公平的调度<ul><li>（<strong>优点）不会饥饿</strong>：耗时短的任务即使落在耗时长的任务后面，也能够较快的得到调度执行</li></ul></li><li><strong>（缺点）开销大</strong>：<u>任务切换引起的调度开销较大</u>，需要多次切换任务上下文<ul><li><strong>（缺点</strong>）时间片不太好设置</li></ul></li></ul></li><li><p><strong>最大最小公平算法</strong></p></li></ol><h4 id="7-【进程】调度算法？">7.<strong>【进程】调度算法？</strong></h4><ul><li>先来先服务调度算法</li><li>短作业(进程)优先调度算法</li><li>时间片轮转法</li><li><strong>多级反馈队列调度算法</strong></li><li>优先权调度算法</li></ul><h4 id="8-CPU上下文切换？有什么类型？线程发生在什么地方？">8. <strong>CPU上下文切换？有什么类型？线程发生在什么地方？</strong></h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/52845869">https://zhuanlan.zhihu.com/p/52845869</a></p></blockquote><ul><li><p><strong>什么是 CPU 上下文</strong> ？</p><p><u>CPU 寄存器和程序计数器</u> 就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前，<strong>必须的依赖环境</strong>。</p><blockquote><ul><li><u>CPU 寄存器</u> 是 CPU 内置的容量小、但速度极快的内存。</li></ul></blockquote></li><li><p><strong>什么是 CPU 上下文切换?</strong></p><p>通常指以下过程：</p><ol><li>前一个任务的 CPU 上下文（也就是 <strong>CPU 寄存器和程序计数器</strong>）保存起来;</li><li>然后加载新任务的上下文到这些寄存器和程序计数器;</li><li>最后再跳转到程序计数器所指的新位置，运行新任务。</li></ol></li><li><p><strong>CPU 上下文切换的类型</strong>？</p><p>根据任务的不同，可以分为以下三种类型 : <strong>进程上下文切换 - 线程上下文切换 - 中断上下文切换</strong> 。</p><ol><li><p><strong>进程上下文切换</strong></p><p>进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。</p><blockquote><ul><li><p>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</p></li><li><p>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</p></li></ul></blockquote><p>从用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成，在<u>这个过程中就发生了 <strong>CPU</strong> 上下文切换（<strong>两</strong>次，用户态-内核态-用户态））</u>。</p><blockquote><p><strong>系统调用</strong> : 查看文件时read()、wirte() 操作就发生了系统调用。</p><p>但是，系统调用过程中，<strong>并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程</strong>。</p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-440bb1699b2fa0f0340b38eabcbd7452_720w.jpg" alt="img"></p><p>而<u><strong>进程</strong>上下文切换</u> ，比系统调用时多了一步：在<strong>保存内核态资源</strong>（当前进程的<u>内核状态和 CPU 寄存器</u>）之前，需要先把该进程的<strong>用户态资源</strong>（<u>虚拟内存、栈等</u>）保存下来。</p></li><li><p><strong>线程上下文调用</strong></p><p>线程是调度的基本单位，而进程则是资源拥有的基本单位。</p><p>【面试高频】发生线程上下文切换的场景</p><ul><li><strong>前后两个线程属于不同进程</strong>。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。</li><li><strong>前后两个线程属于同一个进程</strong>。此时，因为虚拟内存是共享的，所以在切换时，<u>虚拟内存</u>这些资源就保持不动，只需要切换<strong>线程的私有数据（栈、寄存器等</strong>)不共享的数据</li></ul></li><li><p><strong>中断上下文切换</strong></p></li></ol></li></ul><h4 id="9-如何杀死一个进程？进程终止的方式？">9.<strong>如何杀死一个进程</strong>？进程终止的方式？</h4><ol><li>linux命令：<code>kill -9 &lt;pid&gt;</code></li><li>接受能导致进程终止的信号：ctrl+c (^C)、SIGINT(SIGINT中断进程)</li><li>main函数的自然返回，<code>return</code></li><li>调用<code>exit</code>函数，属于c的函数库 3、调用<code>_exit</code>函数，属于系统调用</li><li>调用<code>abort</code>函数，异常程序终止，同时发送SIGABRT信号给调用进程</li></ol><h5 id="9-1-终端退出，终端运行的进程会怎么样？">9.1 终端退出，终端运行的进程会怎么样？</h5><ol><li><p>终端在退出时会发送<code>SIGHUP</code>给对应的bash进程，</p></li><li><p>bash进程收到这个信号后首先将它发给session下面的进程</p><blockquote><p>一个session就是一个shell终端会话窗口。</p></blockquote></li><li><p>如果程序没有对SIGHUP信号做特殊处理，那么进程就会随着终端关闭而退出</p></li></ol><h5 id="9-2-怎么让进程后台运行？">9.2 怎么让进程后台运行？</h5><ol><li><code>命令 + &amp;</code> 即可，实际上，这样是将命令放入到一个作业队列中了</li><li><code>ctrl + z</code> 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程</li><li><code>nohup + &amp;</code>，将标准输出和标准错误缺省会被重定向到 nohup.out 文件中，忽略所有挂断（SIGHUP）信号</li><li><code>setsid + 命令</code>，使其父进程编程init进程，不受HUP信号的影响</li><li>将<code>命令+ &amp;</code>放在()括号中，也可以是进程不受HUP信号的影响</li></ol><h4 id="10-外中断和异常的区别？">10. 外中断和异常的区别？</h4><ul><li><p><strong>外中断是指由 CPU 执行指令以外的事件引起</strong>，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p></li><li><p><strong>异常时由 CPU 执行指令的内部事件引起</strong>，如非法操作码、地址越界、算术溢出等。</p></li></ul><h4 id="11-什么是父进程、子进程、进程组、作业和会话？">11. 什么是父进程、子进程、进程组、作业和会话？</h4><ul><li><p><strong>父进程</strong>： 已创建一个或多个子进程的进程 ；</p></li><li><p><strong>子进程</strong>： 由<strong>fork</strong>创建的新进程被称为子进程（child process），函数被调用一次，但返回两次；</p><p>fork之后，操作系统会<strong>复制一个与父进程完全相同的子进程</strong>，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系：</p><ul><li>（1）它们共<strong>享代码空间</strong>，（2）<strong>数据空间是互相独立</strong>的，但<strong>子进程数据空间中的内容是父进程的完整拷贝</strong>，（3）<strong>指令指针也完全相同</strong>，（4）子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同）。</li></ul><p>除了：fork成功，<strong>子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号pid</strong> 。</p></li><li><p><strong>进程组</strong>： 进程组就是多个进程的集合，其中肯定有一个组长，其进程PID等于进程组的PGID ；</p></li><li><p><strong>作业</strong>： shell<strong>分前后台</strong>来控制的不是进程而是作业（job）或者进程组（Process Group）。</p><blockquote><p>一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，shell可以运行一个前台作业和任意多个后台作业，这称为作业控制。、</p></blockquote></li><li><p><strong>会话</strong>。 一个或多个<strong>进程组的集合</strong>，<strong>一个会话可以有一个控制终端</strong>。在xshell或者WinSCP中打开一个窗口就是新建一个会话。</p></li></ul><h4 id="12-什么是守护进程、僵尸进程、孤儿进程？">12. 什么是守护进程、僵尸进程、孤儿进程？</h4><blockquote><p>参考：<a href="https://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/">Linux 之守护进程、僵死进程与孤儿进程</a></p></blockquote><ul><li><p><strong>守护进程</strong></p><p><strong>在后台运行的，没有控制终端与之相连</strong>的进程。它<strong>独立于控制终端</strong>，周期性地执行某种任务。它不需要用户输入就能运行而且提供某种服务，不是<strong>对整个系统就是对某个用户程序</strong>提供服务。</p><ul><li>举例：常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。</li></ul><p>一个守护进程的父进程是init进程，也是一个<u>孤儿进程</u> ，一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。</p></li><li><p><strong>孤儿进程</strong></p><p>一个<strong>父进程退出，而它的一个或多个子进程还在运行</strong>，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p></li><li><p><strong>僵尸进程</strong></p><p>一个进程使用fork创建子进程，如果<strong>子进程退出</strong>，而父进程并没有调用wait或waitpid获取子进程的状态信息（子进程必须<strong>等到父进程捕获到了子进程的退出状态才真正结束</strong>），那么<strong>子进程的进程描述符仍然保存在系统中</strong>。这种进程称之为僵死进程。</p></li></ul><h5 id="11-1-如何避免僵尸进程？">11.1 如何避免僵尸进程？</h5><ul><li><p>通过<strong>signal(SIGCHLD, SIG_IGN</strong>)通知内核对子进程的结束不关心，由内核回收；</p><blockquote><p>如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN); 表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。</p></blockquote></li><li><p>父进程调用wait/waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞；</p><blockquote><p>waitpid可以通过传递WNOHANG使父进程不阻塞立即返回。</p></blockquote></li><li><p>如果父进程很忙可以用signal注册信号处理函数，在信号处理函数调用wait/waitpid等待子进程退出;</p></li><li><p>通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等待回收。</p></li></ul><h2 id="4-3-socket编程">4.3 socket编程</h2><p>暂略</p><h2 id="4-4-内存管理">4.4 内存管理</h2><h4 id="1-介绍一下操作系统的堆和栈？">1.<strong>介绍一下操作系统的堆和栈？</strong></h4><ul><li><p><strong>栈内存</strong>：栈内存首先是一片内存区域，存储的都是<u>局部变量</u>，栈内存的<u>更新速度很快</u>，因为局部变量的生命周期都很短。</p><blockquote><p>局部变量：方法内的变量，for循环内部定义的也是局部变量等。</p></blockquote></li><li><p><strong>堆内存</strong>：存储的是<u><strong>数组</strong></u>和<strong>对象</strong>（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象）。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</p></li></ul><h5 id="1-1-什么时候会栈溢出？">1.1 什么时候会栈溢出？</h5><p>栈能使用的内存是有限的，一般是 1M~8M，这在编译时就已经决定了，程序运行期间不能再改变。</p><ul><li>如果程序使用的栈内存超出最大值，就会发生栈溢出（Stack Overflow）错误，程序就崩溃了；</li><li>一般常见的情况，如<strong>递归过深</strong></li></ul><h4 id="2-介绍一下什么内存管理？常用的内存管理机制？">2. 介绍一下什么内存管理？常用的内存管理机制？</h4><ul><li><p><strong>内存管理</strong></p><p>操作系统的内存管理主要负责内存的（1）<strong>分配与回收（<strong>malloc 函数：申请内存，free 函数：释放内存），（2）另外地址转换也就是将</strong>逻辑地址转换成相应的物理地址</strong>等功能也是操作系统内存管理做的事情。</p></li><li><p><strong>常用内存管理机制</strong></p><p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为⼀个用户程序分配⼀个连续的内存空间，常见的如<strong>块式管理</strong> 。同样地，非连续分配管理方式允许⼀个程序使用的内存分在离散或者说不相邻的内存中，常见的如<strong>页式管理 和 段式管理</strong>。</p><ol><li><p><strong>块式管理</strong> ： 远古时代的计算机操系统的内存管理方式。<strong>将内存分为⼏个固定大小的块</strong>，每个块中只包含⼀个进程。如果程序运行需要内存的话，操作系统就分配给它⼀块，如果程序运行只需<br>要很小的空间的话，分配的这块内存很大⼀部分⼏乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</p></li><li><p><strong>页式管理</strong> ：把主存分为大小相等且固定的⼀页⼀页的形式，<strong>页较小，相对相⽐于块式管理的划分⼒度更大</strong>，提高了内存利用率，减少了碎片。页式管理通过<u>页表对应逻辑地址和物理地址</u>。</p></li><li><p><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。段式管理把主存分为⼀段段的，<strong>每⼀段的空间⼜要⽐⼀页的空间小很多</strong> 。</p></li></ol><blockquote><p>但是，最重要的是段是有实际意义的，每个段定义了⼀组逻辑信息，例如，有主程段 MAIN、子程序段 X、数据段 D及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</p></blockquote><ol start="4"><li><strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲页，也就是说 段页式管理机制中段与段之间以及段的内部的都是离散的。</li></ol></li></ul><h5 id="2-1-介绍一下逻辑地址和物理地址？">2.1 介绍一下逻辑地址和物理地址？</h5><ul><li>我们编程⼀般只有可能和逻辑地址打交道，⽐如在 C 语⾔中，指针⾥面存储的数值就可以理解成为<strong>内存⾥的⼀个地址</strong>，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。</li><li>物理地址指的是<strong>真实物理内存中地址</strong>，更具体⼀点来说就是内存地址寄存器中的地址。</li></ul><h5 id="2-2-操作系统在内存管理需要做什么？">2.2 操作系统在内存管理需要做什么？</h5><ul><li>内存空间的分配与回收；</li><li>从逻辑上对内存空间进行扩充；</li><li>逻辑地址与物理地址的转换；</li><li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。</li></ul><h4 id="3-介绍一下快表和多级页表？">3. 介绍一下快表和多级页表？</h4><p>在分页内存管理中，很重要的两点是：</p><ol><li>虚拟地址到物理地址的转换要快。</li><li>解决虚拟地址空间大，<strong>页表也会很大</strong>的问题。</li></ol><h5 id="快表介绍">快表介绍</h5><p>快表理解为⼀种<strong>特殊的高速缓冲存储器</strong>（Cache），其中的<strong>内容是页表的⼀部分或者全部内容</strong>。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。</p><blockquote><p>但有时快表不命中要访问两次缓存，不过总体还是提高了性能。</p></blockquote><h5 id="多级页表介绍">多级页表介绍</h5><p>引⼊多级页表的主要⽬的是为了 <u><strong>避免把全部页表⼀直放在内存中占用过多空间</strong></u>，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表<strong>属于时间换空间</strong>的典型场景。</p><h4 id="4-分页机制和分段机制的共同点和区别-？">4. 分页机制和分段机制的共同点和区别 ？</h4><ol><li>共同点 ：<ul><li>分页机制和分段机制都是为了<strong>提高内存利用率，较少内存碎片</strong>。</li><li>页和段都是<strong>离散存储</strong>的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li></ul></li><li>区别 ：<ul><li><strong>页的大小是固定的</strong>，由操作系统决定；<strong>而段的大小不固定</strong>，取决于我们当前运行的程序。</li><li>分页仅仅是为了<strong>满⾜操作系统内存管理</strong>的需求，而<strong>段是逻辑信息的单位，在程序中可以体现为代码段，数据段</strong>，能够更好满⾜用户的需要。</li></ul></li></ol><h4 id="5-【待扩充】CPU-寻址了解吗-为什么需要虚拟地址空间">5. 【待扩充】CPU 寻址了解吗?为什么需要虚拟地址空间?</h4><ul><li><p>现代处理器使用的是⼀种称为 虚拟寻址(Virtual Addressing) 的寻址⽅式。使用虚拟寻址，<strong>CPU 需要虚拟地址翻译成物理地址</strong>，这样才能访问到真实的物理内存。</p><blockquote><p>实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有⼀个被称为 内存管理单元（Memory Management Unit, MMU） 的硬件。</p></blockquote></li><li><p><strong>如果直接把物理地址暴露出来的话会带来严重问题</strong>，⽐如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</p></li></ul><h4 id="6-如果系统中具有快表后，那么地址的转换过程变成什么样了？">6. 如果系统中具有快表后，那么地址的转换过程变成什么样了？</h4><blockquote><p>简单来说：cup计算页号 → 快表查询是否有该页号 → 否则页表查询</p></blockquote><ol><li><strong>计算页号和页偏移量</strong>。 CPU给出逻辑地址，由某个硬件算得页号、页内偏移量；</li><li><strong>快表中查找内存块号</strong>。 将页号与快表中的所有页号进行比较，如果找到匹配的页号，则直接从中取出该页对应的内存块号，再<strong>将内存块号与页内偏移量拼接形成物理地址</strong>；</li><li><strong>页表中查找内存块号</strong>。 如果快表中查找不存在，访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。</li></ol><h4 id="7-进程内存分配动态分区算法？">7. 进程内存分配动态分区算法？</h4><ol><li><p><strong>首次适应法</strong>。</p><ul><li><p><strong>算法思想</strong>：每次都从低地址开始查找，找到第一个能满足大小的空闲分区；</p></li><li><p><strong>实现方式</strong>：空闲分区以<strong>地址递增</strong>的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分[表)，找到大小能满足要求的第-一个空闲分区。</p></li><li><p><strong>优点</strong>： 综合性能最好，开销小。</p><p><img src="https://i.loli.net/2021/06/10/PEpjmDW52eqGl4f.png" alt="image-20210610231604639"></p></li></ul></li><li><p><strong>最佳适应法</strong>。</p><ul><li><strong>算法思想</strong>：为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区；</li><li><strong>实现方式</strong>： 空闲分区按<strong>容量递增</strong>次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</li><li><strong>优点</strong>： 会有更多的大分区被保留下来，<u>更能满足大进程需求</u></li><li><strong>缺点</strong>： 产生很多太小的、难以利用的碎片，算法开销大</li></ul></li><li><p><strong>最坏适应法</strong>。</p><ul><li><strong>算法思想</strong>： 为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</li><li><strong>实现方式</strong>：空闲分区按<strong>容量递减</strong>次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</li><li><strong>优点</strong>： 可以减少难以利用的小碎片</li><li><strong>缺点</strong>： 大分区容易被用完，不利于大进程，算法开销大</li></ul></li><li><p><strong>领近适应法</strong>。</p><ul><li><strong>算法思想</strong>： 首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。</li><li><strong>实现方式</strong>：空闲分区以<strong>地址递增</strong>的顺序排列(可排成一个<strong>循环链表</strong>)。每次分配内存时<u>从上次查找结束的位置开始</u> ，查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</li><li><strong>优点</strong>： 算法开销小</li></ul></li></ol><h4 id="8-什么是内存覆盖和内存交换？">8. 什么是内存覆盖和内存交换？</h4><ul><li><strong>内存覆盖</strong><ul><li><strong>思想</strong>： 把用户空间分成为一个<strong>固定区</strong>和<strong>若干个覆盖区</strong>。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。</li><li><strong>特点</strong>：<strong>打破</strong>了必须将<strong>一个进程的全部信息装入内存后才能运行</strong>的限制 。</li></ul></li><li><strong>内存交换</strong><ul><li><strong>思想</strong>： <u>内存空间紧张</u> 时，系统将内存中<strong>某些进程暂时换出外存</strong>，把外存中某些已<strong>具备运行条件的进程换入内存</strong>。</li></ul></li></ul><h2 id="4-5-虚拟内存">4.5 虚拟内存</h2><h4 id="0-什么是虚拟技术-？从时间和空间两方面来说。">0. 什么是虚拟技术 ？从时间和空间两方面来说。</h4><p>虚拟技术<strong>把一个物理实体转换为多个逻辑实体</strong> ：</p><ul><li><strong>时分复用技术</strong> ： 如多个进程能在同一个处理器上并发执行使用了时分复用技术，让<u>每个进程轮流占用处理器，每次只执行一小个时间片并快速切换</u> ；</li><li><strong>空分复用技术</strong>： <u>物理内存抽象为地址空间，每个进程都有各自的地址空间</u>。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</li></ul><h4 id="1-介绍一下局部性原理吧？">1. 介绍一下局部性原理吧？</h4><p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装⼊部分程序到内存就开始运行。</p><p>局部性原理表现在以下两个⽅面：</p><ol><li><strong>时间局部性</strong>：如果程序中的<strong>某条指令</strong>⼀旦执行，不久以后<strong>该指令可能再次执</strong>行；如果某数据被访问过，不久以后该数据可能再次被访问。产⽣时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li></ol><blockquote><p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。</p></blockquote><ol start="2"><li><strong>空间局部性</strong>：⼀旦程序访问了<strong>某个存储单元</strong>，在不久之后，其<strong>附近的存储单</strong>元也将被访问，即程序在⼀段时间内所访问的地址，可能集中在⼀定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也⼀般是以向量、数组、表等形式簇聚存储的。</li></ol><blockquote><p>空间局部性通常是使用教大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。</p></blockquote><p>虚拟内存技术实际上就是建⽴了 “内存⼀外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p><h4 id="2-介绍一下，什么是虚拟内存？页式存储？">2.<strong>介绍一下，什么是虚拟内存？页式存储</strong>？</h4><ul><li><p><strong>虚拟内存</strong></p><p>虚拟内存是一种存储机制，可为用户提供一个拥有很大主内存的错觉。<strong>通过将辅存的一部分作为主存</strong>来完成。在虚拟内存中，用户可以存储比可用主内存更大的进程。</p><blockquote><p>每个进程创建加载的时候，会被分配一个大小为4G的连续的虚拟地址空间，仅仅是每个进程“认为”自己拥有4G的内存。等到进程真正运行的时候，<strong>需要某些数据并且数据不在物理内存中，才会触发缺页异常，进行磁盘数据拷贝到物理内存中</strong></p></blockquote><p><img src="https://i.loli.net/2021/04/20/NO5zyG824P9FSHs.jpg" alt="img"></p></li><li><p><strong>页式存储</strong></p><p>大部分虚拟存储系统采用的是一种称为<strong>分页（paging</strong>）的技术。这种方式叫做虚拟页式存储管理。</p><ul><li><p>物理内存空间划分为固定大小的内存块，称为物理页面，或者是<strong>页框</strong>（page frame）</p></li><li><p>虚拟地址空间也划分成大小相同的块，称为虚拟页面，或者简称<strong>页面</strong>（page）</p><blockquote><p>页表：将<strong>虚拟页面映射为</strong>相应的<strong>物理页面</strong>。</p></blockquote></li></ul></li></ul><h4 id="3-虚拟内存的技术实现-？">3. 虚拟内存的技术实现 ？</h4><p>虚拟内存的实现需要建⽴在离散分配的内存管理⽅式的基础上。 虚拟内存的实现有以下三种⽅式：</p><ol><li><strong>请求分页存储管理</strong> ：建⽴在分页管理之上，为了支持虚拟存储器功能而增加了<strong>请求调页功能和页面置换功能</strong>。请求分页是⽬前最常用的⼀种实现虚拟存储器的⽅法。请求分页存储管理系统中，在作业开始运行之前，仅装⼊当前要执行的部分页即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调⼊到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li><li><strong>请求分段存储管理</strong>：建⽴在分段存储管理之上，增加了<strong>请求调段功能、分段置换功能</strong>。请求分段储存管理⽅式就如同请求分页储存管理⽅式⼀样，在作业开始运行之前，仅装⼊当前要执行的部分段即可运行；在执行过程中，可使用请求调⼊中断动态装⼊要访问但⼜不在内存的程序段；当内存空间已满，而⼜需要装⼊新的段时，根据置换功能适当调出某个段，以便腾出空间而装⼊新的段。</li><li><strong>请求段页式存储管理</strong></li></ol><h4 id="4-请你介绍一下页面置换算法？">4. 请你介绍一下页面置换算法？</h4><p>当发⽣缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择⼀个页面将其移出内存，以便为即将调⼊的页面让出空间。用来选择淘汰哪⼀页的规则叫做页面置换算法，我们可以把页<br>⾯置换算法看成是淘汰页面的规则。</p><ul><li><p><strong>OPT （最佳页面置换算法）</strong>：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最⻓时间内不再被访问的页面,这样可以保证获得最低的缺页率。</p><blockquote><p>但由于⼈们⽬前无法预知进程在内存下的若千页面中哪个是未来最⻓时间内不再被访问的，因⽽该算法无法实现。⼀般作为衡量其他置换算法的⽅法。</p></blockquote></li><li><p><strong>FIFO（First In First Out） （先进先出页面置换算法</strong>）: 总是淘汰最先进⼊内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</p></li><li><p><strong>LRU （Least Currently Used）（最近最久未使用页面置换算法</strong>）：LRU算法赋予每个页面⼀个访问字段，用来记录⼀个页面⾃上次被访问以来所经历的时间 T，当须淘汰⼀个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</p></li><li><p><strong>LFU （Least Frequently Used）（最少使用页面置换算法</strong>）: 该置换算法选择在前时期使用最少的页面作为淘汰页。</p></li></ul><h4 id="5-你怎么理解操作系统里的内存碎片，有什么解决办法？">5.<strong>你怎么理解操作系统里的内存碎片，有什么解决办法</strong>？</h4><p>内存碎片分为：内部碎片和外部碎片。</p><ul><li><p><strong>内部碎片</strong>： 已经<strong>被分配</strong>出去（能明确指出属于哪个进程）却<strong>不能被利用</strong>的内存空间；</p><blockquote><p><strong>内存泄漏</strong>：不再会被使用的<strong>对象</strong>的内存不能被<strong>回收</strong> 。</p></blockquote></li><li><p><strong>外部碎片</strong>： 还<strong>没有被分配</strong>出去（不属于任何进程），但由于<strong>太小了无法分配</strong>，给申请内存空间的新进程的内存空闲区域。</p></li></ul><h4 id="6-什么是内存抖动？">6. 什么是内存抖动？</h4><ul><li><strong>现象</strong>：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种<strong>频繁的页面调度行为</strong>称为抖动，或颠簸；</li><li><strong>原因</strong>： 程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够) ；</li><li><strong>解决</strong>： 分配更多的物理块</li></ul><h2 id="4-6-并发和死锁">4.6 并发和死锁</h2><h4 id="0-介绍几种典型的锁？">0. 介绍几种典型的锁？</h4><ol><li><strong>读写锁</strong>。 可以同时读，但写必须互斥，只允许一个写；</li><li><strong>互斥锁</strong>。 一次只能一个线程拥有锁，其它只能等待；</li><li><strong>条件变量</strong>：  互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定；而条件变量<strong>通过允许线程阻塞和等待另一个线程发送信号</strong>的方法弥补了互斥锁的不足；</li><li><strong>自旋锁</strong>。 如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。</li></ol><h4 id="1-【重点】什么是线程死锁？什么情况下会发生死锁？解决死锁的策略有哪些？">1. 【<strong>重点</strong>】<strong>什么是线程死锁？什么情况下会发生死锁？解决死锁的策略有哪些</strong>？</h4><ul><li><p><strong>什么是死锁</strong></p><p>死锁是指<u>两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</u>，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p></li><li><p><strong>发生死锁的条件</strong></p><ol><li><strong>互斥</strong>：一个资源只能给一个进程使用；</li><li><strong>占有并等待</strong>：进程持有资源并申请新资源，在申请到需要的资源之前，<u>已有的资源不释放</u>；</li><li><strong>不可剥夺</strong>：进程申请到的资源在使用完之前，不可以被其他进程使用；</li><li><strong>循环等待</strong>：各个进程的资源请求形成首尾连接循环等待。</li></ol></li><li><p><strong>解决方法：预防，避免，检测与恢复三种</strong></p><ol><li><strong>预防：破坏死锁会发生的四个条件</strong><ul><li>破坏互斥：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的</li><li><strong>破坏请求和保持</strong>：实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源；</li><li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进⼀步申请其他资源时，<strong>如果申请不到</strong>，可以<strong>主动释放它占有的资源</strong>；</li><li><strong>破坏循环等待</strong>：资源分类标号，进行有序分配。</li></ul></li><li><strong>避免</strong>： <u>它不限制进程有关申请资源的命令</u>，而是对进程所发出的每一个申请资源命令加以<strong>动态地检查</strong>，并根据检查结果决定是否进行资源分配<ul><li><strong>安全序列</strong>：找到一种能让进程安全执行完的有序序列<code>&#123;P1，P2，...，Pn&#125;</code></li><li><strong>银行家算法</strong>：系统在为进程分配资源之前，首先计算此次资源分配的安全性，<strong>如果是安全的，则进行分配</strong>；如果这次分配会导致进入不安全状态，不进行分配。</li></ul></li><li><strong>恢复</strong>： 用<u>资源分配图、进程等待图</u>来协助这种检测出死锁，然后进行恢复。<ul><li>系统重新启动，但代价很大</li><li><strong>撤消参与死锁的全部或部分进程，剥夺资源</strong></li></ul></li></ol></li></ul><h5 id="1-1-什么时候需要使用分布式锁？">1.1 <strong>什么时候需要使用分布式锁</strong>？</h5><ul><li>在<strong>单体应用的</strong>时候，如果<strong>多个线程要访问共享资源的时候，我们通常线程间加锁的机制</strong>，在某一个时刻，只有一个线程可以对这个资源进行操作，其他线程需要等待锁的释放，Java中也有一些处理锁的机制，比如synchronized。</li><li>而到了<strong>分布式的环境</strong>中，当<strong>某个资源可以被多个系统访问使用到的时候（例如，有多个客户端需要访问并操作同一个资源，还需要保持这个资源一致性的时候，就需要使用【分布式锁）</strong>，为了保证大家访问这个数据是一致性的，那么就要求再同一个时刻，只能被一个系统使用，这时候<strong>线程之间的锁机制就无法起到作用</strong>了，因为分布式环境中，系统是会部署到不同的机器上面的，那么就需要【分布式锁】了。</li></ul><h4 id="2-（待补充）请你解释一下，通常系统CPU比较高是什么原因？">2. （待补充）<strong>请你解释一下，通常系统CPU比较高是什么原因</strong>？</h4><ol><li>首先查看是哪些进程的CPU占用率最高</li></ol><h4 id="3-说一下NIO，BIO，AIO区别">3.<strong>说一下NIO，BIO，AIO区别?</strong></h4><blockquote><p>参考：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/basis/IO%E6%A8%A1%E5%9E%8B.md">JAVaGuide</a></p></blockquote><p>【<strong>BIO（同步阻塞）</strong>】</p><ul><li><p><strong>BIO</strong>：同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把<u> </u>。</p><img src="https://i.loli.net/2021/05/06/HqJyg2Ykxtm6Wba.png" alt="图源：《深入拆解Tomcat & Jetty》" style="zoom: 67%;" /></li></ul><p>【<strong>NIO（同步非阻塞）</strong>】</p><p>NIO 本身是基于 <u>事件驱动</u> 的思想来实现的，其目的就是解决 BIO 的大并发问题：</p><ul><li>BIO 模型中，<strong>如果需要并发处理多个 I/O 请求，那就需要多线程来支持</strong>；</li><li><strong>IO 多路复用模型</strong>中，线程首先发起 <u>select 调用，询问内核数据是否准备就绪</u>，等内核把数据准备好了，用户线程再发起 <strong>read 调用</strong>。<strong>read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的</strong>。</li></ul><img src="https://i.loli.net/2021/05/06/9iJE3IaVOW2xAwh.png" alt="img" style="zoom:67%;" /><p>【<strong>AIO（异步非阻塞）</strong>】</p><blockquote><p>Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型 。</p></blockquote><p><strong>AIO：</strong> 异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。</p><blockquote><p>异步 IO 是基于事件和<strong>回调机制</strong>实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p></blockquote><p><img src="https://i.loli.net/2021/05/06/uIcCQeBUliqT2gk.png" alt="img" style="zoom:67%;" />0.</p><h4 id="4-【重点】介绍一下select，poll，epoll-原理？">4. 【重点】<strong>介绍一下select，poll，epoll 原理？</strong></h4><blockquote><p><strong>参考</strong></p><ol><li><a href="https://blog.csdn.net/jiejiemcu/article/details/107083724">select、poll、epoll的原理与区别</a></li></ol></blockquote><h5 id="4-1-从阻塞I-O-非阻塞I-O说起">4.1 从阻塞I/O &amp; 非阻塞I/O说起</h5><ul><li><p><strong>阻塞I/O</strong></p><blockquote><p>在linux中，默认情况下所有的socket都是阻塞的。</p></blockquote><p><img src="https://i.loli.net/2021/05/17/aJFOtPvy4xiMKkI.png" alt="image-20210517125922790"></p><ol><li>当用户进程调用了<code>read()/recvfrom()</code>等系统调用函数，它会进入内核空间中；</li><li>当这个网络I/O没有数据的时候，内核就要等待数据的到来，此时<strong>用户进程被阻塞</strong>；</li><li>当内核空间的数据准备好了，它就会将数据从<strong>内核空间中拷贝到用户空间</strong>；</li><li>用户进程才解除阻塞的的状态，重新运行读取数据。</li></ol></li><li><p><strong>非阻塞I/O</strong></p><blockquote><p>linux下，可以通过设置socket使其变为非阻塞模式，这种情况下，当内核空间并无数据的时候，它会<u>马上返回结果而不会阻塞</u>。</p></blockquote><p><img src="https://i.loli.net/2021/05/17/hW2DtsGBiU8AnHN.png" alt="image-20210517130232559"></p><ol><li>当用户进程调用了<code>read()/recvfrom()</code>等系统调用函数，它会进入内核空间中；</li><li>如果内核空间中的数据还没有准备好，那么它并不会阻塞用户进程，而是<strong>立刻返回一个error</strong>；</li><li>对于应用进程来说，它发起一个<code>read()</code>操作后，并不需要等待，那么它可以再次调用read()/recvfrom()等函数；</li><li>当内核空间的数据准备好了，它就会将数据从内核空间中拷贝到用户空间；</li><li>用户进程才解除阻塞的的状态，重新运行读取数据。</li></ol></li></ul><blockquote><p>多路复用I/O就是我们说的<code>select，poll，epoll</code>等操作，复用的好处就在于<strong>单个进程</strong>就可以同时处理<strong>多个</strong>网络连接的I/O，能实现这种功能的原理就是<code>select、poll、epoll</code>等函数会不断的<strong>轮询</strong>它们所负责的所有<code>socket</code>，当某个<code>socket</code>有数据到达了，就通知用户进程。</p></blockquote><h5 id="4-2-select原理">4.2 select原理</h5><blockquote><p>更加深刻对比理解：<a href="https://www.cnblogs.com/skyfsm/p/7079458.html">Linux编程之select</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>select函数监视的文件socket描述符分3类，分别是writefds、readfds、和exceptfds；</li><li>调用后select<strong>函数会阻塞（不是线程）</strong>，直到有描述符就绪（有数据 <u>可read、可write、except、超时timeout</u>），函数返回。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">select(socket);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">sockets = select(); <span class="comment">// 还是要从内核拷贝到用户</span></span><br><span class="line"><span class="keyword">for</span>(socket in sockets) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(can_read(socket)) </span><br><span class="line">&#123;</span><br><span class="line">read(socket, buffer);</span><br><span class="line">process(buffer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细执行原理如下：</p><ol><li><p>用户首先将需要进行IO操作的<strong>socket添加到select</strong>中，然后<strong>阻塞函数select（不是线程）等待系统调用返回</strong>；</p></li><li><p><strong>当数据到达时，socket被激活，select函数返回</strong>，会唤醒其等待队列上睡眠的内核进程，即在<strong>socket可读写时唤醒</strong>，或者在<strong>超时</strong>后唤醒；</p><blockquote><p>每次调用<code>select</code>查看fd，都需要把fd集合拷贝进行系统调用<strong>陷入内核态</strong> 。</p></blockquote></li><li><p>返回<code>select()</code>函数的调用结果给用户进程，<strong>返回就绪socket描述符的数目</strong>，超时返回0，出错返回-1；</p></li><li><p>在select()函数返回后<strong>还是需要轮询</strong>去找到就绪的socket描述符的（<u>将此前传入内核空间的<code>fd_set</code>拷贝到用户空间</u>），此时用户进程才可以去操作socket；</p></li><li><p>进程调用<code>read() / recvfrom()</code> 读取数据 。</p></li></ol><p><strong>select优点</strong>：</p><blockquote><p>从流程上来看，使用select函数进行IO请求和<strong>同步阻塞模型</strong>没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。</p><p><strong>那为什么还要使用select？</strong></p></blockquote><ul><li>使用select以后最大的优势是用户可以在一<strong>个线程内同时处理多个socket</strong>的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的；</li><li>而在<strong>同步阻塞模型</strong>中，必须通过<strong>多线程的方式才能达到这个目的</strong>。</li></ul><p><strong>select缺点</strong>：</p><ol><li><p><strong>描述符数量</strong>：<code>select</code>支持的文件描述符数量太小了，默认是<code>1024</code>  ；</p></li><li><p><strong>系统开销</strong>：每次调用<code>select</code>都需要把fd集合拷贝进行系统调用<strong>陷入内核态</strong>，这个开销在fd很多时会很大 ；</p></li><li><p><strong>二次轮询</strong>：<code>select</code>需要二次查询拷贝所有文件描述fd_set进行遍历查看是否有描述符准备就绪。</p></li></ol><h5 id="4-3-poll原理">4.3 poll原理</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 <strong>pollfd指针</strong>实现。</p><blockquote><p>poll使用<strong>链表</strong>维护这些socket描述符，而select使用的是<strong>数组</strong>（位图）。</p></blockquote><p>其他的都差不多和select()函数一样，poll()函数返回后，需要轮询pollfd来获取就绪的描述符，根据描述符的状态进行处理，<u>但是poll没有最大文件描述符数量的限制</u>。</p><p><strong>poll缺点</strong>：</p><p>解决了selec第一个缺点（文件描述符数量太少），但是依旧存在后面两个缺点。</p><ol start="2"><li><p><strong>系统开销</strong>：每次调用<code>poll</code>都需要把fd集合拷贝进行系统调用<strong>陷入内核态</strong>，这个开销在fd很多时会很大 ；</p></li><li><p><strong>二次轮询</strong>：<code>poll</code>需要二次查询拷贝所有文件描述fd_set进行遍历查看是否有描述符准备就绪。</p></li></ol><h5 id="4-3-epoll原理">4.3 epoll原理</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll只有epoll_create()、epoll_ctl()、epoll_wait() 3个系统调用函数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>epoll_create</code></p><p>创建一个epoll文件描述符的epfd（或者称之为句柄）, <strong>epoll使用一个epfd文件描述符管理多个socket描述符</strong>。</p><blockquote><p>当创建好epoll句柄后，它就是会占用一个fd值，必须调用close()关闭，否则可能导致fd被耗尽 。</p></blockquote></li><li><p><code>epoll_ctl</code></p><p>该函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，以及删除事件。相关参数：</p><blockquote><p>使用<strong>红黑树</strong>对监视的文件描述符进行：添加、修改、删除等。</p></blockquote><ul><li><p><code>epdf</code>：由epoll_create()函数返回的epoll文件描述符（句柄）；</p></li><li><p><code>op</code> ： op是操作的选项，注册要监听的目标socket描述符fd到epoll句柄中 ；修改epoll句柄已经注册的fd的监听事件；从epoll句柄删除已经注册的socket描述符 ；</p></li><li><p><code>fd</code>：指定监听的socket描述符；</p></li><li><p><code>event</code>：事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>        *ptr;</span><br><span class="line">    <span class="keyword">int</span>          fd;</span><br><span class="line">    <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>epoll_wait()</code></p><p>epoll_wait()函数的作用就是等待监听的事件的发生，<strong>类似于调用select()函数</strong>。 相关参数如下：</p><blockquote><p>函数的返回值表示需要处理的事件数目，如返回0表示已超时。</p></blockquote><ul><li><code>events</code>：用来从内核得到事件的集合。</li><li><code>maxevents</code> ：告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的指定的size。</li><li><code>timeout</code>：超时时间。</li></ul></li></ul><p><strong>epoll高效运行过程</strong></p><blockquote><p>参考：<a href="https://www.jianshu.com/p/31cdfd6f5a48">彻底搞懂epoll高效运行的原理</a></p></blockquote><ol><li><p>执行<code>epoll_create</code>会在内核的高速cache区中建立一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。接着用户执行<code>epoll_ctl</code> 函数添加文件描述符会在红黑树上增加相应的结点。</p><blockquote><p>select：创建3个文件描述符集并<u>拷贝到内核</u>中 ; poll：将传入的struct pollfd结构体数组<u>拷贝到内核</u>中进行监听。</p></blockquote></li><li><p>调用<code>epoll_wait</code> <strong>阻塞，等待可读事件</strong>；</p></li><li><p>内核在检测到满足条件的socket描述符会调用<strong>回调函数</strong> ，回调函数将文件描述符<strong>放在就绪链表</strong>中 ；</p><blockquote><p>而select/poll 都需要 ，遍历所有文件描述符fd_set 。</p><p>而执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，只需调用回调函数。</p></blockquote></li><li><p>epoll_wait只用观察就绪链表中有无数据即可，最后将链表的数据<strong>返回给读写事件数组events</strong> &amp;<strong>返回就绪的数量</strong>，只用<strong>遍历events</strong>依次处理即可。</p><blockquote><p>这里返回的文件描述符是通过<strong>mmap让内核和用户空间共享同一块内存</strong>实现传递的，减少了不必要的拷贝。</p><p>而select/poll <u>只返回socket就绪数目</u>， 还需要将<strong>所有的文件描述符再次从内核→用户</strong>，遍历就绪的socket文件描述符。</p></blockquote></li></ol><h5 id="4-4-select，poll，epoll-各自区别？">4.4 select，poll，epoll 各自区别？</h5><blockquote><p>不错的文章：<a href="https://www.codenong.com/cs105364662/">https://www.codenong.com/cs105364662/</a></p></blockquote><p><strong>相同点</strong>：</p><ul><li><p>select，poll，epoll 都是 IO 多路复用的机制（NIO？yes）；</p><blockquote><p>IO 多路复用的本质是通过一种机制，让<strong>单个进程可以监视多个描述符</strong>，当发现某个描述符就绪之后，能够通知程序进行相应的操作。</p></blockquote></li><li><p>select，poll，epoll 都是同步 IO 。</p></li></ul><p><strong>不同点</strong>：</p><img src="https://i.loli.net/2021/05/17/xj2ncf8VLbAGrwh.png" alt="image-20210517125057917" style="zoom: 80%;" /><ol><li><strong>IO 效率</strong>：（1）select 只知道<u>有 IO 事件发生，却不知道是哪几个流</u>，只能采取轮询所有流（ fd_set 集合）的方式，故其具有 O(n) 的无差别轮询复杂度，处理的流越多，无差别轮询时间就越长；（2）poll 与 select 并无区别，它的时间复杂度也是O(n)；（3）epoll 会将哪个流发生了怎样的 IO 事件通知我们（当描述符就绪时，<u>系统注册的回调函数会被调用</u>，将就绪描述符放到 readyList 里面），<strong>它是事件驱动的</strong>，其时间复杂度为 O(1)；</li><li><strong>操作方式</strong>：select 和 poll 都是采取遍历的方式，而 epoll 则是采取了回调的方式；</li><li><strong>底层实现</strong>：select 的底层实现为数组，poll 的底层实现为链表；而 epoll 的底层实现为红黑树；</li><li><strong>最大连接数</strong>：select 的最大连接数为 1024 或 2048；而 poll 和 epoll 是无上限的；</li><li><strong>对描述符的拷贝</strong>：select 和 poll 每次被调用时都会把描述符集合从用户态拷贝到内核态，而 epoll 在调用 epoll_ctl 时会拷贝进内核并保存，之后每次 epoll_wait 时不会拷贝；</li><li><strong>性能</strong>：<u>epoll 在绝大多数情况下性能远超 select 和 poll</u>，但在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，因为 epoll 的通知机制需要很多函数回调 。</li></ol><h5 id="4-5-ET-LT-模式介绍？各自优缺点？">4.5 ET , LT 模式介绍？各自优缺点？</h5><blockquote><p>参考：<a href="https://cloud.tencent.com/developer/article/1636224">https://cloud.tencent.com/developer/article/1636224</a></p></blockquote><ul><li><p><strong>边缘触发模式</strong>（<strong>E</strong>dge <strong>T</strong>rigger，ET），只有一个事件从无到有才会触发；</p><blockquote><ol><li>低电平 =&gt; 高电平 。</li></ol></blockquote></li><li><p><strong>水平触发模式</strong>（<strong>L</strong>evel <strong>T</strong>rigger，LT），一个事件只要有，就会一直触发。</p><blockquote><ol><li>低电平 =&gt; 高电平 ; 2. 处于高电平状态</li></ol></blockquote></li><li><p><strong>举例说明</strong></p><ul><li><strong>socket 的读事件</strong><ul><li><strong>LT模式</strong>，只要 socket 上有未读完的数据，就会一直产生 EPOLLIN 事件；</li><li><strong>ET模式</strong>，socket 上每新来一次数据就会触发一次，如果上一次触发后，<strong>未将 socket 上的数据读完，也不会再触发</strong>，除非再新来一次数据。</li></ul></li><li><strong>对于 socket 写事件</strong><ul><li><strong>LT模式</strong>，如果 socket 的 TCP 窗口一直不饱和，会一直触发 EPOLLOUT 事件；</li><li><strong>ET模式</strong>，只会触发一次，除非 TCP 窗口由不饱和变成饱和再一次变成不饱和，才会再次触发 EPOLLOUT 事件。</li></ul></li></ul></li><li><p><strong>优缺点</strong></p><ul><li>使用 LT 模式，我们可以自由决定<strong>每次收取多少字节（对于普通 socket）或何时接收连接</strong>（对于侦听 socket），但是可能会<strong>导致多次触发</strong>；</li><li>使用 ET 模式，我们必须<strong>每次都要将数据收完</strong>（对于普通 socket）或必须理解调用 accept 接收连接（对于侦听socket），其<strong>优点是触发次数少</strong>。</li></ul></li></ul><h4 id="5-操作系统底层是怎么实现原子操作的？">5. 操作系统底层是怎么实现原子操作的？</h4><p>处理器使用基于对<strong>缓存加锁</strong>或<strong>总线加锁</strong>的方式，来实现多处理器之间的原子操作。</p><ol><li><p><strong>总线锁</strong>： 处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器<strong>可以独占共享内存</strong>；</p><blockquote><p><strong>总线锁定把CPU和内存之间的通信锁住了</strong>，这使得锁定期间，其他处理器不能操作其他内存地址的数据</p></blockquote></li><li><p><strong>缓存锁</strong>：相比总线锁，缓存锁即降低了锁的力度。核心机制是基于<u>缓存一致性协议</u>来实现的。</p><blockquote><p>详细参考：<a href="https://www.jianshu.com/p/06717ac8312c">JMM基础（总线锁、缓存锁、MESI缓存一致性协议、CPU 层面的内存屏障）</a></p></blockquote></li></ol><h2 id="4-7-其它">4.7 其它</h2><h4 id="1-常见的磁盘调度算法？">1. 常见的磁盘调度算法？</h4><p>读写一个磁盘块的时间的影响因素有：</p><ul><li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li><li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li><li>实际的数据传输时间</li></ul><p>其中，<strong>寻道时间最长</strong>，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><ol><li><p><strong>先来先服务</strong>。 按照磁盘请求的顺序进行调度。</p><ul><li><strong>优点</strong>：公平、简单；</li><li><strong>缺点</strong>：未对寻道做任何优化，使平均寻道时间可能较长。</li></ul></li><li><p><strong>最短寻道优先</strong>。 优先调度与当前磁头所在磁道距离最近的磁道。</p><ul><li><strong>优点</strong>： 平均寻道时间比较低；</li><li><strong>缺点</strong>：不公平，如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去。</li></ul></li><li><p><strong>电梯扫描算法</strong>。 电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p><ul><li><strong>优点</strong>： 性能较好，同时不会存在饥饿现象。</li></ul></li></ol><h4 id="2-服务器高并发的解决方案你知道多少？">2. 服务器高并发的解决方案你知道多少？</h4><ul><li><strong>应用数据与静态资源分离</strong>：将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从<strong>静态资源服务器中返回静态资源</strong>，从<strong>主服务器中返回应用数据</strong>；</li><li><strong>客户端缓存</strong> ：例如先生成静态页面，然后用ajax异步请求获取动态数据；</li><li><strong>集群和分布式</strong> ：使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度；</li><li><strong>反向代理</strong>： 在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（三）_计算机基础_计算机网络</title>
      <link href="/p/46361/"/>
      <url>/p/46361/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h1>三、计算机网络</h1><h2 id="3-1-ISO-OSI模型-和-TCP-IP-模型">3.1 ISO/OSI模型  和 TCP/IP 模型</h2><h4 id="1-请你简要介绍一下TCP-IP-五层协议-和-ISO-OSI七层协议？">1.<strong>请你简要介绍一下TCP/IP 五层协议 和 ISO/OSI七层协议？</strong></h4><p><img src="https://uploadfiles.nowcoder.com/images/20190814/980266035_1565787665824_1ABB2DC3D76311944FFDBE9980FBAADD" alt="img"></p><ul><li><p><strong>应用层</strong>：为用户的<strong>应用程序</strong>（如：电子邮件、文件传输和仿真终端）<u><strong>*提供网络服务</strong></u>；</p></li><li><p><strong>表示层</strong>： 可以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取；</p></li><li><p><strong>会话层</strong>：  通过运输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求；</p></li><li><p><strong>运输层:</strong> 任务是为两台主机中<strong>进程之间的通信</strong>提供通用的<u><strong>*数据传输服务</strong></u>，传输的是<strong>报文段（tcp）/用户数据报（udp）</strong>；</p><blockquote><p>复用：多个应用层进程可同时使用下面运输层的服务。<br>分用：运输层把收到的信息分别交付上面应用层中的相应进程。</p></blockquote></li><li><p><strong>网络层</strong>： 为主机间<u><strong>*提供通信服务</strong></u>。在发送数据时，网络层把运输层的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为<strong>数据报</strong></p></li><li><p><strong>数据链路层（忘</strong>）： 两台主机通信，总是在<strong>一段一段的链路</strong>上传送的，这就需要需要专门的链路层的协议。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的<u><strong>*IP数据报组装成帧</strong></u>，在两个相邻结点间的链路上传送帧。每一帧包括数据和必要的控制信息。</p></li><li><p><strong>物理层</strong>：主要作用是<u>传入比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0）</u>，定义物理设备标准（例如网线的接口类型、光线的接口类型、各种传输介质的传输速率）。</p></li></ul><h4 id="2-请你简要介绍一下各层的协议？">2.<strong>请你简要介绍一下各层的协议？</strong></h4><ul><li><p><strong>物理层</strong>：暂无</p></li><li><p><strong>（<u>快手</u>）数据链路层</strong>：数据链路层主要是负责传输数据，</p><ul><li><p><strong>PPP（点到点协议</strong>）：在<strong>点对点</strong>连接上传输多协议数据包提供了一个标准方法，PPP 最初设计是为<strong>两个对等节点</strong>之间的 IP <strong>流量传输</strong>提供一种封装协议。这种链路提供<strong>全双工</strong>操作，并按照顺序传递数据包。</p><blockquote><p>设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。</p></blockquote></li><li><p><strong>以太网（Ethernet)</strong>：</p></li><li><p><strong>CSMA/CD 协议</strong>： 冲突检测的载波监听多路访问技术(载波监听多点接入/碰撞检测)。</p><blockquote><p>许多计算机以<strong>多点接入</strong>的方式连接<strong>在一根总线</strong>上，每个主机都必须不停地监听信道。发送前监听，如果忙则等待，如果空闲则发送。</p><p>若检测到信道有干扰信号，则表示产生了碰撞，于是就要停止发送数据，计算出退避等待时间，然后使用 CSMA 方法继续尝试发送。</p></blockquote></li></ul></li><li><p><strong>网络层</strong>： <a href="https://www.hhcycj.com/post/item/491.html">可参考</a></p><p><strong>IP</strong>：网络协议，非常重要的中间层协议，TCP和UDP必须基于IP工作</p><p><strong>ICMP</strong>：非常重要的中间层协议，用于在 <u>IP主机、路由器</u> 之间传递控制消息</p><p><strong>IGMP</strong>：网络组消息协议，用来在<u>IP主机</u>和与其<strong>直接相邻的<u>组播路由器</u>之间</strong>建立、维护组播组成员</p><p><strong>ARP</strong>：地址解析协议，建立<code>IP→MAC</code>地址映射表</p><p><strong>RARP</strong>：反向地址解析协议，某个网络设备的MAC物理地址转换为IP地址</p></li><li><p><strong>运输层:TCP(Transmission Control Protocol)</strong> 面向连接的，数据传输的单位是<u><strong>报文段</strong></u>，能够提供可靠的交付。</p><p><strong>UDP(User Datagram Protocol)</strong> ：无连接的，数据传输的单位<strong>是<u>用户数据报</u>，不保证提供可靠的交付</strong>，只能提供“尽最大努力交付”</p></li><li><p><strong>应用层</strong>：如支持万维网应用的<strong>HTTP</strong>协议，支持电子邮件的<strong>SMTP</strong>协议，支持文件传送的<strong>FTP</strong>协议，DNS，POP3，SNMP，Telnet等等。</p></li></ul><h5 id="2-1-RARP-工作原理？">2.1 RARP 工作原理？</h5><p>RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。</p><blockquote><p>网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。</p></blockquote><ol><li>主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包；</li><li><strong>RARP服务器</strong>收到了<strong>RARP请求数据包</strong>，<strong>为其分配IP地址</strong>，并将<strong>RARP回应发送</strong>给主机；</li><li>主机收到RARP回应后，就使用得到的IP地址进行通讯。</li></ol><h4 id="3-端口在哪一层？有效端口范围？">3. 端口在哪一层？有效端口范围？</h4><p>端口在<strong>传输层</strong>。传输层以下的包封装过程：</p><ul><li>数据报在传输层：加源端口号和目的端口号；</li><li>在网络层加上：源ip和目的ip ；</li><li>在数据链路层转化成：数据桢进行校验；</li><li>在物理层变成信号（电、光、等信号）发送出去。</li></ul><p>UDP和TCP报头使用<strong>两个字节存放端口号</strong>，端口一共有一共有<strong>65535</strong>个。</p><ul><li>知名端口号从0~1023，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口） ；</li><li>动态端口的范围是从1024~65535。</li></ul><h2 id="3-2-运输层">3.2 运输层</h2><h4 id="0-TCP报文头？UDP报文头？">0. TCP报文头？UDP报文头？</h4><blockquote><p>参考：<a href="http://st233.com/blog.php?id=30">IP、TCP、UDP报文头说明</a></p></blockquote><ul><li><p><strong>TCP报文头</strong></p><p><img src="https://i.loli.net/2021/06/11/RtnwTmysWBvVlPD.png" alt="img"></p><ul><li><p><strong>来源端口</strong>：向目标主机指明接入他的主机所使用的端口号 用于目标主机回应</p></li><li><p><strong>目标端口</strong>：指明要连接的目标主机的端口号</p><blockquote><p>从这也可以看书，端口占16bit，故范围是0~65535。</p></blockquote></li><li><p><strong>顺序号：数据包编号</strong>， 表明发送的数据包的顺序 。其值通常应该为<code>上次发送包中的顺序号+1</code> ，若该数据包是整个TCP连接中的第一个包(SYN包) 则该值随意(通常随机)</p></li><li><p><strong>确认号</strong>：通常该值是<code>接受到的顺序号+1</code> ，若该数据包是整个TCP连接中的第一个数据包(SYN包) 则该值随意(通常为0)</p></li><li><p><strong>首部长度</strong>：TCP头长度 。表明包好多少个32Bit 包括可选头(如果有) 值为TCP头大小除以4 ：</p><ul><li>如：没有可选头TCP头为20字节 则该值为5</li></ul></li><li><p><strong>标志位</strong>：</p></li><li><ul><li>紧急标志位(URG)：开启时表明此数据包处于紧急状态应该优先处理</li><li>确认标志位(ACK)：开启时表明确认号有效 否则忽略确认号</li><li>推送标志位(PSH)：开启时表明应该尽快交付给应用进程 而不必等到缓存区填满才推送</li><li>复位标志位(RST)：开启时表明TCP连接出现连接出现错误 数据包非法拒绝连接</li><li>同步标志位(SYN)：开启时表明一个连接的请求或者接受报文</li><li>终止标志位(FIN)：开启时表明释放一个连接</li></ul></li><li><p><strong>窗口大小</strong>：表示期望接受到的每个数据包字节数</p></li><li><p><strong>校验和</strong>：该值为TCP报文头括数据部分中每16Bit的二进制反码求和</p></li><li><p><strong>紧急指针</strong>：若指定该值 他应该是一个偏移量 该值加上顺序号表示紧急数据最后一个字节的顺序号</p></li><li><p><strong>可选字段</strong>：包含最大载荷与窗口比例等信息 注：若使用该字段则长度必须为32Bit的倍数 不足则填充0</p></li></ul></li><li><p><strong>UDP报文</strong></p><p><img src="https://i.loli.net/2021/06/11/Bfh3THSLgzZCUAu.png" alt="img"></p><ul><li><p><strong>来源端口</strong>：向目标主机指明接入他的主机所使用的端口号 用于目标主机回应</p></li><li><p><strong>目标端口</strong>：指明要连接的目标主机的端口号</p></li><li><p><strong>数据包长度</strong>：UDP头和数据总长度字节数</p></li><li><p><strong>检验和</strong>：该值为UDP报文头括数据部分中每16Bit的二进制反码求和</p></li><li><ul><li><strong>注：UDP检验和不是必须的</strong></li></ul></li></ul></li></ul><h4 id="1-请你说明一下，TCP协议的3次握手（进行连接）？">1. 请你说明一下，TCP协议的3次握手（进行连接）？</h4><blockquote><p>参考：<a href="https://juejin.cn/post/6844903834708344840">三次握手与四次挥手面试官想考我们什么？</a></p></blockquote><blockquote><p>TCP中，对<strong>确认ACK报文是不需要发送确认</strong>的 。</p></blockquote><ul><li><p><strong>简略过程</strong></p><blockquote><p>⚠️ SYN 和ACK报文是一起发的！！</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/27203200-7e3630b0fe1442898e6824ac061d475e.x-png" alt="TCP三次握手原理- asfion - 博客园"></p><p><strong>1、第一次握手</strong>：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 <strong>ISN©</strong>。此时客户端处于 <strong>SYN_Send</strong> 状态。</p><p><strong>2、第二次握手</strong>：（⚠️ <strong>SYN+ACK是在一个包里发的！（字节一面</strong>） ）服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 <strong>ISN(s)</strong>，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <strong>SYN_REVD</strong> 的状态。</p><p><strong>3、第三次握手</strong>：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <strong>establised</strong> 状态。</p><p>服务器收到 ACK 报文之后，也处于 <strong>establised 状态</strong>，此时，双方以建立起了链接。</p></li></ul><h5 id="1-1-ISN-（Initial-Sequence-Number）是固定的吗？">1.1 ISN （Initial Sequence Number）是固定的吗？</h5><ul><li><p><strong>ISN作用</strong></p><p>三次握手，其中一个重要功能是客户端和服务端交换 ISN，以便让对方知道<strong>接下来接收数据的时候如何按序列号组装数据</strong>。</p></li><li><p><strong>ISN为什么不固定</strong>（还是不太理解）</p><blockquote><p>ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个<strong>32比特</strong>的计数器，<strong>每4ms加1</strong> 。</p></blockquote><ul><li><strong>防止在网络中被延迟的分组在以后被重复传输</strong>，而导致某个连接的一端对它作错误的判断；</li><li>如果 ISN 是固定的，攻击者很<strong>容易猜出后续的确认号</strong>，因此 ISN 是动态生成的。</li></ul></li></ul><h4 id="2-为什么要三次握手？">2.<strong>为什么要三次握手</strong>？</h4><p>1.<strong>用来确定服务端和客户端的发送能力是否正常；</strong></p><ul><li><strong>第一次握手</strong>：客户端发送网络包，服务端收到了。这样服务端就能得出结论：<u>客户端的发送能力、服务端的接收能力是正常的。</u></li><li><strong>第二次握手</strong>：服务端发包，客户端收到了。这样客户端就能得出结论：<u>服务端的接收、发送能力，客户端的接收、发送能力是正常的</u>。<strong>不过此时服务器并不能确认客户端的接收能力是否正常</strong>。</li><li><strong>第三次握手</strong>：客户端发包，服务端收到了。这样服务端就能得出结论：<u>客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</u></li></ul><p>2.<strong>指定自己的初始化序列号，为后面的可靠传送做准备；</strong></p><ul><li>如果只有两次握手，那么客户端的起始序列号可以确认，<u>服务端的起始序列号</u>将得不到确认。</li></ul><ol start="3"><li><strong>如果是 https 协议的话，三次握手这个过程，还会进行数字<u>证书的验证以及加密密钥</u>的生成</strong>。</li></ol><h5 id="2-1-三次握手可以携带数据吗？">2.1 三次握手可以携带数据吗？</h5><p><strong>第一次、第二次握手不可以携带数据 ，</strong> 第三次可以携带数据：</p><ul><li><strong>对于第一次握手</strong>，不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。<ul><li>如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，<strong>消耗服务器空间来接收数据</strong>；</li></ul></li><li><strong>对于第三次握手</strong>，客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，<strong>已经知道服务器的接收、发送能力正常</strong>，所以能携带数据。</li></ul><h4 id="3-请你说明一下，TCP协议的4次挥手（断开连接）？">3.<strong>请你说明一下，TCP协议的4次挥手（断开连接）</strong>？</h4><blockquote><p><a href="https://www.zhihu.com/question/63264012">为什么不像三次握手一样执行三次即可？</a></p><p>因为第二次和第三次对于被动方来说，意义是不一样的。<br>第二次是为了让主动方闭嘴（不再发挥手请求），自己该干嘛还是干嘛（但是自己可能还有数据美处理完）。<br>第三次是为了表示“我的活儿干完了，可以结束了”。<br>通常server接收到挥手的时候，手里还有活儿没做完。</p></blockquote><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。</p><p><u>收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据</u>。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p>TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211127191012778.png" alt="image-20211127191012778"></p><p>（1）客户端A发送一个FIN，<u>报文中会指定一个序列号</u>M，用来关闭客户A到服务器B的数据传送，此时客户端处于<strong>FIN_WAIT1</strong>状态；</p><p>（2）服务器B收到这个FIN，它发回一个ACK，<u>确认序号为收到的序号M+1</u>。和SYN一样，一个FIN将占用一个序号，此时服务端处于 <strong>CLOSE_WAIT</strong>状态；</p><p>（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A和序列号N，此时服务端处于 <strong>LAST_ACK</strong> 的状态；</p><p>（4）客户端A发回ACK报文确认，并将确认序号设置为收到序N+1，此时客户端处于 <strong>TIME_WAIT</strong> 状态，需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 <strong>CLOSED</strong> 状态；服务端收到 ACK 报文之后，就处于关闭连接了，处于 <strong>CLOSED</strong> 状态。</p><h5 id="3-1-为什么TCP四次挥手要基于全双工，不基于半双工呢？基于半双工可以改为三次挥手吗？">3.1 为什么TCP四次挥手要基于全双工，不基于半双工呢？基于半双工可以改为三次挥手吗？</h5><blockquote><p>半双工：<strong>同时</strong>只能有一端发送消息 ； 全双工：两端都可以随机接受/发送。</p></blockquote><p>在四次挥手过程中，似乎C/S两端都是等待对方发送FIN/ACK，才会发送对应的ACK/FIN版本。同一时刻只有一方在发送消息，满足半双工。</p><p>但是，半双工模式效率会更低：比如C端（客户端）发送FIN报文请求关闭，但是S端（<strong>服务端</strong>）依旧<strong>可以同时发生数据</strong> ，这个时候效率更高。</p><h5 id="3-2（重点）-服务器出现大量close-wait的连接的原因是什么？有什么解决方法？">3.2（重点） 服务器出现大量close_wait的连接的原因是什么？有什么解决方法？</h5><p>close_wait状态是在，TCP四次挥手的时候<strong>服务器收到FIN，但是没有发送自己的FIN时出现的</strong>。服务器出现大量close_wait状态的原因有两种：</p><ul><li><strong>服务器内部业务处理占用了过多时间</strong>，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li><li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候<strong>子进程处理但父进程没有处理该信号</strong>，导致socket的引用不为0无法回收</li></ul><p>处理方法：</p><ul><li>停止应用程序</li><li>修改程序里的bug</li></ul><h4 id="4-为什么要有TIME-WAIT-状态？为什么等待是2MSL？">4. 为什么要有TIME_WAIT 状态？为什么等待是2MSL？</h4><ul><li><p><strong>要确保服务器是否已经收到了客户端最后的ACK 报文</strong>，如果没有收到的话，<u>服务器会重新发 FIN + ACK报文给客户端</u>，客户端再次收到 FIN + ACK 报文之后，就知道之前的 ACK 报文丢失了，然后<u>再次发送 ACK 报文。</u></p></li><li><p><strong>确保之前连接的一些数据不在滞留在网络中</strong>：确保已经失效连接请求报文段不会再出现在本连接中，<strong>客户端发完最后一个ACK报文段后</strong>，再经过<strong>2MSL</strong>可以使得本连接中所有的报文段都从网络中消失。客户端就可以放心地<strong>释放</strong>TCP占用的资源、端口号，连接任何服务器。</p><blockquote><p>如果<strong>客户端</strong>直接CLOSED，然后又再次向服务器<strong>发起一个新连接</strong>，有可能<strong>新、老连接的端口号一样</strong>的。假设新、老连接端口号一致，若老连接的一些数据仍滞留在网络中，这些滞留数据在新连接建立后才到达服务器，鉴于前后端口号一致，TCP协议就默认这些数据属于新连接，于是数据就这样乱成一锅粥了。</p></blockquote></li></ul><h5 id="4-1-为什么是2MSL">4.1 为什么是2MSL?</h5><p>MSL是报文在网络中最长生存时间，这是一个工程值(经验值)，不同的系统中可能不同 。</p><p>考虑最坏 情况，客户端A最后一次挥手发送给服务端B的ACK报文丢失了：</p><ol><li>ACK从最多经过1MSL会到达服务端，<strong>超过1MSL服务端会重发FIN</strong></li><li>服务端重发的FIN最多经过1MSL到达A</li></ol><p>所以为了确保，客户端能<strong>接收到服务端重发的FIN报文</strong>。</p><h4 id="5-【重点】请问TCP为什么要更可靠？哪种场景会有所应用？">5. 【重点】<strong>请问TCP为什么要更可靠？哪种场景会有所应用？</strong></h4><ol><li><p><strong>超时重传</strong>：当 TCP 发出⼀个报文段后，它启动⼀个定时器，等待⽬的端确认收到这个报⽂段。如果不能及时收到⼀个确认，将重发这个报⽂段；</p></li><li><p><strong>数据排序</strong>：TCP有专门的序列号<strong>ISN字段</strong>，可提供数据re-order；</p></li><li><p><strong>流量控制</strong>：滑动窗口和计时器的使用。TCP窗口中会指明双方能够<u>发送接收的最大数据量；</u></p><blockquote><p><strong>ARQ协议</strong>： 也是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待对方确认。在收到确认后再发下⼀个分组。</p></blockquote></li><li><p><strong>拥塞控制</strong>：TCP的拥塞控制由4个核心算法组成。“慢启动”（Slow Start）、<u>“拥塞避免”</u>（Congestion avoidance）、“快重传 ”（Fast Retransmit）、“快恢复”（Fast Recovery）；</p></li><li><p><strong>校验和</strong>： TCP 将保持它⾸部和数据的检验和。这是⼀个端到端的检验和，⽬的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将<strong>丢弃这个报⽂段和不确认收到此报⽂段</strong>。</p></li></ol><p>【<strong>应用场景</strong>】</p><p><u>当对网络通讯质量有要求的时候，</u>比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用</p><ul><li>比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议</li></ul><h5 id="5-1-超时重传机制原理？">5.1 超时重传机制原理？</h5><p>基本原理：在发送一个数据之后，就开启一个<strong>定时器</strong>，若是在这个时间内<strong>没有收到发送数据的ACK确认报文</strong>，则对该报文进行<strong>重传</strong>，在达到一定次数还没有成功时放弃并发送一个复位信号。</p><p>TCP中有四种计时器（Timer），分别为：</p><ol><li><p><strong>重传计时器</strong>：在<strong>滑动窗口协议</strong>中，接受窗口会在<strong>连续收到的包序列（连续ARQ）<strong>中的</strong>最后一个包</strong>向接收端发送一个ACK。当网络拥堵的时候，发送端的数据包和接收端的ACK包都有可能丢失。TCP为了保证数据可靠传输，就规定在<strong>重传的“时间片”<strong>到了以后，如果还没有收到对方的ACK，就</strong>重发此包</strong>，以避免陷入无限等待中。</p></li><li><p><strong>坚持计时器</strong>：在<strong>滑动窗口协议</strong>中，当发送TCP收到<strong>窗口大小为0</strong>的确认ACK时，就坚持启动计时器。当坚持计时器期限到时，发送TCP就发送一个特殊的报文段，叫做探测报文。这个报文段只有一个字节的数据。他有一个序号，但他的序号永远不需要确认；甚至在计算机对其他部分的数据的确认时该序号也被忽略。探测报文段提醒接受TCP：确认已丢失，必须重传。</p></li><li><p><strong>保活计时器</strong>：保活计时器使用在某些实现中，用来<strong>防止在两个TCP之间的连接出现长时间的空闲</strong>。假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远的处于打开状态。</p><p>通常设置为两小时。若服务器过了两小时还没有收到客户的信息，他就发送探测报文段。若<strong>发送了10个探测报文段</strong>（每一个像个75秒）还没有响应，就假定客户除了故障，因而就终止了该连接。</p></li><li><p><strong>时间等待计时器</strong>：四次挥收后time waiter状态中使用。</p></li></ol><h5 id="5-2-介绍一下ARQ协议-？">5.2 介绍一下ARQ协议 ？</h5><p>⾃动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之⼀。它通过使用<strong>确认和超时</strong>这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。</p><p>ARQ包括<strong>停⽌等待ARQ协议</strong>和<strong>连续ARQ协议</strong>。</p><ul><li><strong>停⽌等待ARQ协议</strong>。 停⽌等待协议是为了实现可靠传输的，它的基本原理就是每发完⼀个<strong>分组</strong>就停⽌发送，等待对方确认（回复ACK）。如果过了⼀段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下⼀个分组；在停⽌等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。<ul><li><strong>优点</strong>：简单</li><li><strong>缺点</strong>：信道利用低，等待时间长</li></ul></li><li><strong>连续ARQ协议</strong>。连续 ARQ 协议可提高信道利用率。发送方维持⼀<strong>个发送窗口</strong>，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方⼀般采用<strong>累计确认</strong>，对按序到达的<strong>最后⼀个分组发送确</strong>认，表明到这个分组为⽌的所有分组都已经正确收到了。<ul><li><strong>优点</strong>： 信道利用率高，容易实现，即使确认丢失，也不必重传。</li><li><strong>缺点</strong>： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 ⽐如：发送方发送了 5条 消息，<strong>中间第三条丢失（3号</strong>），这时接收方<strong>只能对前两个发送确认</strong>。发送方无法知道后三个分组的下落，而只好把后<strong>三个全部重传</strong>⼀次。这也叫 <strong>Go-Back-N</strong>（回退 N），表示需要退回来重传已经发送过的N 个消息。</li></ul></li></ul><h5 id="5-2-介绍一下连续ARQ协议滑动窗口和流量控制？">5.2 介绍一下连续ARQ协议滑动窗口和流量控制？</h5><p>TCP 利用滑动窗口实现流量控制。流量控制是为了<strong>控制发送方发送速率，保证接收方来得及接收</strong>。 接收方发送的确认报⽂中的窗口字段可以用来控制<strong>发送方窗口</strong>大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h5 id="5-3-介绍一下拥塞控制？">5.3 介绍一下拥塞控制？</h5><p>为了进行拥塞控制，TCP 发送方要维持⼀个 <u>拥塞窗口(cwnd)</u> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让⾃⼰的<strong>发送窗口 == 取为拥塞窗口和接收方的接受窗口中较小的⼀个</strong>。</p><p>TCP的拥塞控制采用了四种算法：</p><ul><li><p><strong>慢开始</strong>： 慢开始算法的思路是当主机开始发送数据时，如果⽴即把大量数据字节注⼊到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测⼀下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，<strong>每经过⼀个传播轮次RTT，cwnd加倍</strong>；</p></li><li><p><strong>拥塞避免</strong>： 拥塞避免算法的思路是让拥塞窗⼝cwnd缓慢增大，即每经过<strong>⼀个往返时间RTT，就把发送放的cwnd加1</strong>；</p></li><li><p><strong>快重传/快恢复</strong>：</p><blockquote><p>区分快重传，连续ARQ中间丢失是Go back n。</p></blockquote><p>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是⼀种拥塞控制算法，<u>它能快速恢复丢失的数据包。</u>如果<strong>接收机</strong>接收到⼀个【<strong>不按顺序】的数据段，它会⽴即给发送机发送⼀个重复确认（而不是等到自己发送数据时才捎带确认）。如果发送机接收到三个重复确认</strong>，它会假定确认指出的数据段丢失了，并⽴即重传这些丢失的数据段（<strong>而不必继续等待为该报文段设置的重传计时器的超时</strong>）。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/20170823152124856" alt="img"></p></li></ul><h5 id="5-4-如何区分流量控制和拥塞控制？">5.4 如何区分流量控制和拥塞控制？</h5><ul><li><strong>流量控制属于通信双方协商，拥塞控制涉及通信链路全局；</strong></li><li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，<strong>接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定</strong>；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</li></ul><h4 id="6-如何提高客户端并发数？">6.<strong>如何提高客户端并发数？</strong></h4><p>客户端建立的tcp数量受限于最大文件句柄数，一个连接就会建一个文件句柄，在linux 上默认是<strong>1024</strong>。</p><ul><li>使用<code>ulimit</code> 可以修改最大进程数（<strong>最大为65535</strong>）</li></ul><h4 id="7-说说HTTP、TCP、Socket-的关系是什么？">7.<strong>说说HTTP、TCP</strong>、Socket 的关系是什么？</h4><ul><li><strong>TCP/IP</strong> 代表传输控制协议/网际协议，指的是一系列协议族；</li><li><strong>HTTP</strong> 本身就是一个协议，是从 <u>Web 服务器和本地浏览器</u>的超文本传送协议；</li><li><strong>Socket</strong> 是 TCP/IP 网络的 <strong>API</strong> ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</li></ul><h4 id="8-什么是半连接队列？泛洪攻击（DDos攻击的一种），以及解决策略-？">8. 什么是半连接队列？<strong>泛洪攻击（DDos攻击的一种），以及解决策略</strong> ？</h4><ul><li><p><strong>半连接队列</strong></p><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个<strong>队列</strong>里，我们把这种队列称之为<strong>半连接队列</strong>。</p><blockquote><p>已经完成三次握手，建立起连接的就会放在<strong>全连接队列</strong>中。如果队列满了就有可能会出现丢包现象。</p></blockquote></li><li><p><strong>泛洪攻击</strong></p><p>在 TCP 的三次握手机制的第一步中，客户端会向服务器发送 SYN 报文段。</p><ol><li>服务器接收到 SYN 报文段后会为该 <u>TCP分配<strong>缓存和变量</strong></u>，如果<u>攻击分子<strong>伪造大量不存在的IP地址</strong>，大量地往服务器发送 SYN 报文段</u>，服务器的连接资源终将被耗尽，导致<strong>内存溢出</strong>无法继续服务。</li><li>当服务端接收到 SYN 后进入 SYN-RECV 状态，此时的连接称为<strong>半连接</strong>，同时会被服务端写入一个<strong>半连接队列</strong>。<br>想象一下，如果攻击者在短时间内不断的向服务端发送大量的 SYN 包而不响应，那么服务器的<strong>半连接队列很快会被写满</strong>，从而导致无法工作。</li></ol></li><li><p><strong>解决策略</strong></p><p><strong>设置验证机制</strong>：当服务器接受到 SYN 报文段时，<strong>不直接为该 TCP 分配资源</strong>，而只是打开一个<u>半开的套接字</u>。接着会使用 SYN 报文段的<u>源 Id，目的 Id，端口号</u>以及只有服务器自己知道的一个<u>秘密函数生成一个 cookie，并<strong>把 cookie作为序列号响应</strong></u> 给客户端。</p><p>如果客户端是正常建立连接，将会返回一个确认字段为 <strong>cookie + 1 的报文段</strong>。接下来服务器会根据确认报文的源 Id，目的 Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1 等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源 。</p><p><strong>防火墙过滤</strong>： 暂不了解具体</p></li></ul><h4 id="9-为什么DNS（域名解析）用UDP，而区域传送用TCP">9.<strong>为什么DNS（域名解析）用UDP，而区域传送用TCP?</strong></h4><ul><li><strong>DNS用UDP</strong>：客户端向DNS服务器查询域名，一<u>般返回的内容都不超过512字节，用UDP传输即可</u>。不用经过TCP三次握手，这样<u>DNS服务器负载更低，响应更快</u>。</li><li><strong>区域传送用TCP：</strong> TCP协议可靠性好，<u>TCP协议传输的内容大，而UDP最大只能传512字节</u>。</li></ul><h4 id="10-说一下-TCP-粘包是怎么产生的？怎么解决粘包？">10.<strong>说一下 TCP 粘包是怎么产生的？怎么解决粘包？</strong></h4><p><strong>TCP粘包</strong></p><p><strong>TCP粘包</strong>是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><p>客户端要发送原信息是A和B两个数据包，服务端接收到之后，可能出现如下情况：</p><ul><li><strong>正常情况</strong>：读取到了A和B两个数据包；</li><li><strong>粘包</strong>：A和B两个数据包一起读取了；</li><li><strong>拆包</strong>：读取了A数据包的一部分，A的另一部分和B数据包一起读取了。</li></ul><p><strong>TCP粘包原因</strong></p><ul><li><strong>【发送方】TCP默认使用Nagle算法</strong>。客户端通过socket给服务端发送数据，为了传输更有效率，会将<strong>多次间隔较小的且数据量小的数据</strong>，通过<strong>nagle</strong>算法，合并成一个大的数据块，然后进行封包。这样做提高了效率，缺点就是你发送到服务端的数据，服务端不知道是不是完整的，不知道哪几小块数据拼起来才是原来的数据；</li><li><strong>【接收方】来不及接收缓存区的包</strong>，导致多个包接收；</li><li>TCP<strong>连接复用</strong>造成的粘包问题；</li><li>流量控制，<strong>拥塞控制</strong>也可能导致粘包。</li></ul><p><strong>解决粘包</strong></p><p>解决问题的关键在于如何给<strong>每个数据包添加边界信息</strong>：</p><ol><li><strong>Nagle算法</strong>问题导致的，需要结合应用场景适当关闭该算法；</li><li><strong>发送端给每个数据包添加包 <u>首部</u> <strong>，首部中应该至少包含数据包的</strong>长度</strong>，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了；</li><li><strong>数据包之间设置边界</strong>，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开 ；</li><li><strong>发送端将每个数据包封装为固定长度</strong>（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li></ol><h4 id="11-TCP-UDP的区别？">11. TCP, UDP的区别？</h4><ul><li>UDP 在<strong>传送数据之前不需要先建立连接</strong>。远地主机在收到 UDP 报⽂后，不需要给出任何确认。虽然UDP 不提供可靠交付，但在某些情况下 UDP 确是⼀种最有效的⼯作方式（⼀般用于即时通信）<ul><li>⽐如： <u>QQ 语⾳、 QQ 视频 、直播</u>等等</li></ul></li><li>TCP <strong>提供面向连接的服务</strong>。在传送数据之前必须先建⽴连接，数据传送结束后要释放连接。 TCP 不提供⼴播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握⼿来建⽴连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这⼀难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的⾸部增大很多，还要占用许多处理机资源。<ul><li>TCP ⼀般用于<u>⽂件传输、发送和接收邮件、远程登录</u>等场景。</li></ul></li><li><strong>数据包</strong>： TCP是<strong>报文段</strong>，UDP是<strong>用户数据报</strong>。</li><li><strong>应用场景</strong> ： TCP用于一些需要可靠传输的场景； UDP则应用一些即时通信场景，不需要可靠传输的场景。</li><li><strong>长度</strong>：UDP在DNS最长只能是512字节，TCP会更长。</li></ul><h2 id="3-3-网络层">3.3 网络层</h2><h4 id="1-请简单解释一下，ARP协议和ARP攻击">1.<strong>请简单解释一下，ARP协议和ARP攻击?</strong></h4><ul><li>ARP协议：地址解析协议，建立<code>IP/MAC</code>地址映射表</li><li>ARP攻击：</li></ul><h4 id="2-什么是ICMP协议，它的作用是什么？">2.<strong>什么是ICMP协议，它的作用是什么</strong>？</h4><p>用于在<strong>IP主机、路由器</strong>之间传递控制消息。</p><blockquote><p>控制消息是指：<strong>网络通不通、主机是否可达、路由是否可用</strong>等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p></blockquote><h4 id="3-请你讲一下路由器和交换机的区别？">3.<strong>请你讲一下路由器和交换机的区别？</strong></h4><ol><li><p><strong>动态IP</strong>：<u>路由器可以给你的局域网自动分配IP</u>，虚拟拨号，就像一个交通警察，指挥着你的电脑该往哪走，你自己不用操心那么多了。<u>交换机只是用来分配网络数据的</u>。</p><p><u>路由器可以把一个IP分配给很多个主机使用，这些主机对外只表现出一个IP</u>。交换机可以把很多主机连起来，这些主机对外各有各的IP。</p></li><li><p><strong>寻址方式</strong>：路由器在<strong>网络层</strong>，<u>路由器根据IP地址寻址</u>，路由器可以处理TCP/IP协议，交换机不可以；交换机在<strong>中继层</strong>，<u>交换机根据MAC地址</u>寻址。</p></li><li><p><strong>防火墙</strong>：路由器提供防火墙的服务，交换机不能提供该功能。集线器、交换机都是做端口扩展的，就是扩大局域网(通常都是以太网)的接入点，也就是能让局域网可以连进来更多的电脑。路由器是用来做网间连接，也就是用来连接不同的网络。</p></li></ol><h4 id="4-请解释ping命令过程？">4.<strong>请解释<code>ping</code>命令过程？</strong></h4><ol><li>域名在DNS服务器查找IP地址；</li><li>通过Ping程序发送<strong>ICMP包；</strong></li><li>同一网段的情况下，调用IP层的<strong>ARP协议</strong>请求<strong>广播</strong>（不同网段的情况下，交给路由器处理），<strong>查找目标主机的MAC地址</strong>；</li><li>目标主机ARP协议收到请求后，将本机<strong>MAC地址填充</strong>并<strong>发送ARP应答</strong>回到请求发送方；</li><li>请求发送方发送<strong>ICMP数据</strong>到目标主机；</li><li>目标主机<strong>响应ICMP包</strong>；</li><li>请求主机收到目标主机的<strong>ICMP响应包</strong>。</li></ol><h4 id="5-（补充介绍）介绍一下IPV6？一共多少位？">5. （补充介绍）介绍一下IPV6？一共多少位？</h4><p><img src="https://i.loli.net/2021/05/17/i5Nz6lF9RXYsShw.png" alt="IPv6 协议基础_果子哥丶的博客-CSDN博客"></p><p>源IP和目的IP地址都是，128（4*32）位（图中标识不清晰）！</p><h4 id="6-介绍一下IP地址分类？C类哪些是保留地址？网络号全-0-全-1-，主机号全-0-全1-分别什么含义？">6. 介绍一下IP地址分类？C类哪些是保留地址？网络号全 0 全 1   ，主机号全 0 全1 分别什么含义？</h4><ul><li><p><strong>IP地址分类</strong></p><p><code>IP地址 == &#123;&lt;网络号&gt;，&lt;主机号&gt;&#125;</code></p><p><img src="https://i.loli.net/2021/05/17/ZINJCj9l8WM7qhf.jpg" alt="img"></p><ul><li><p><strong>A类</strong>： 第1位固定为0，网络号只有7位 。0（0000 0000）的IP地址是<strong>保留地址</strong>，意思是“本网络” ； 127（0111 1111）的IP地址也是<strong>保留地址</strong>，作为本地环回软件测试 。</p><blockquote><p>特别的，<strong>主机号全1</strong>的是<a href="https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80">广播地址</a>，它代表了网络全部的<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA">主机</a>。</p></blockquote></li><li><p><strong>B类</strong>： 第1、2位固定为10，网络号有14位可以使用 。</p><blockquote><p>B类地址网络号为128.0（1000 000  0000 0000）的IP地址是不指派的，所以可指派的网络号需要减一。</p></blockquote></li><li><p><strong>C类</strong>： 第1、2、3位固定为110，网络号有21位可以使用 。</p><blockquote><p>（快手问）C类IP地址包含<strong>私有C类地址</strong>，范围从192.0.0.0 到223.255.255.255，其中私有C类地址范围从<strong>192.168.0.0 到192.168.255.255。</strong></p></blockquote></li></ul></li><li><p><strong>全0或者全1的含义</strong></p><ul><li><p><strong>网络号全0：</strong>（1）如果主机号也为全0，那么此类ip地址可以当源端但不可以做目的端 （2）如果主机号不全为0，那么此类ip地址的使用和（1)相同，只是它代表的是网络上特定的主机</p></li><li><p><strong>网络号全1：<strong>全1的网络号和</strong>任意的主机号</strong>组合当做<strong>回环地址</strong>来使用。</p><blockquote><p>例如：127（0111 1111）的IP地址</p></blockquote></li><li><p><strong>主机号全0：</strong> 全为0，所得到的地址就是192.168.100.0，它是一个网络地址，代表的是一个<strong>网段</strong>；</p></li><li><p><strong>主机号全1：</strong> 机号全1 代表的是<strong>广播地址</strong>，广播地址是不可以做源端的，但是可以做目的端。</p></li></ul></li></ul><h2 id="3-4-应用层">3.4 应用层</h2><h4 id="1-请你谈谈DNS的寻址过程？">1.<strong>请你谈谈DNS的寻址过程？</strong></h4><p>（1）检查<strong>浏览器缓存、检查本地hosts文</strong>件：是否有这个网址的映射，如果有，就调用这个IP地址映射，解析完成。</p><p>（2）如果没有，则查找<strong>本地DNS解析器缓存</strong>：是否有这个网址的映射，如果有，返回映射，解析完成。</p><blockquote><p><strong>本地dns服务器一般都是你的网络接入服务器商提供</strong>，比如中国电信，中国移动等。</p></blockquote><p>（3）如果没有，则查找填写或分配的<strong>首选DNS服务器</strong>：称为本地DNS服务器。服务器接收到查询时：</p><ul><li><p>如果要查询的域名包含在本地配置区域资源中，返回解析结果，查询结束，此解析具有权威性。</p></li><li><p>如果要查询的域名不由本地DNS服务器区域解析，但服务器缓存了此网址的映射关系，返回解析结果，查询结束，此解析不具有权威性。</p></li></ul><p>（4）如果本地DNS服务器也失效：</p><ul><li>如果未采用<u>转发模式</u>（<strong>迭代</strong>，从上至下）（1）<strong>本地DNS服务器</strong>就把<strong>请求发至13台根DNS</strong>，根DNS服务器收到请求后，会判断这个域名（<a href="http://xn--bvs.com">如.com</a>）是谁来授权管理，<u>并返回一个负责该顶级域名服务器的IP</u>，（2）本地DNS服务器收到顶级域名服务器IP信息后，继续向该<strong>顶级域名</strong>服务器IP发送请求，（3）该服务器如果无法解析，则会找到负责这个域名的下一级DNS服务器（如http://baidu.com）的IP给本地DNS服务器，循环往复直至查询到映射，（4）将解析结果<strong>返回<u>本地DNS服务器</u>，再由本地DNS服务器</strong>返回解析结果，查询完成。</li><li>如果采用<u>转发模式</u>（<strong>递归</strong>，从下至上）（1）则此DNS服务器就会把请求转<strong>发至上一级DNS服务器</strong>，（2）如果上一级DNS服务器不能解析，则继续向上请求，（3）最终将解析结果依次<u>返回本地DNS服务器</u>，本地DNS服务器再返回给客户机，查询完成。</li></ul><h5 id="1-1-怎么获取13台根服务器？">1.1 怎么获取13台根服务器？</h5><p>ping -R ? 抓包？</p><h5 id="1-2-解释一下DNS劫持和DNS污染？">1.2 <strong>解释一下DNS劫持和DNS污染</strong>？</h5><blockquote><p>参考：<a href="https://juejin.cn/post/6844903991764058126">什么是http劫持 ? </a></p></blockquote><p><strong>一、DNS劫持</strong></p><p>DNS劫持某些手段取得<strong>某域名的解析记录控制权</strong>，进而修改此域名的解析结果，返回给用户一个错误的查询结果。</p><ul><li><p><strong>劫持过程</strong></p><ol><li><p>客户端发起域名请求到DNS解析服务器（一般是LocalDNS），<u>但此时DNS解析服务器被攻击篡改</u>；</p></li><li><p>被攻击篡改后的DNS解析服务器将请求转发给虚假服务器；</p><blockquote><p>DNS查询没有任何认证机制且基于UDP不可靠连接，因此很容易被篡改。</p></blockquote></li><li><p>虚假服务器返回<u>响应虚假信息</u>给被攻击篡改后的DNS解析服务器（也可能直接不响应）；</p></li></ol></li><li><p><strong>解决办法</strong></p><p>DNS劫持的本质是<strong>运营商的DNS解析服务器被攻击篡改</strong></p><ul><li>使用国外免费公用的DNS服务器解决。例如OpenDNS（208.67.222.222）或GoogleDNS（8.8.8.8）</li><li>直接使用ip进行访问</li></ul></li></ul><p><strong>二、DNS污染</strong></p><p>DNS污染是一种让一般用户由于<strong>得到虚假目标主机IP</strong>而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。因为是不是<u>劫持单个DNS服务器，而是监听所有的，所以个人比较难防范。</u></p><ul><li><p><strong>污染原理</strong></p><ol><li><p>通过对UDP端口53上的<strong>DNS查询进行入侵检测</strong>；</p><blockquote><p>由于通常的DNS查询没有任何认证机制，而且DNS查询通常基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改。</p></blockquote></li><li><p>一经发现与关键词相匹配的请求则<u><strong>立即伪装成目标域名的解析服务器</strong></u>（NS，Name Server）给查询者返回虚假结果。</p></li></ol></li><li><p><strong>解决办法</strong></p><ol><li>VPN代理或者域名远程解析的方法解决</li><li>通过修改Hosts，手动设置<u>域名正确的IP地址</u></li></ol></li></ul><h4 id="2-Forward和Redirect的区别？">2. <strong>Forward和Redirect的区别</strong>？</h4><ul><li><p><strong>浏览器 URL 地址</strong>：Forward 是服务器<u>内部的重定向</u>，服务器<strong>内部请求某个 servlet</strong>，然后获取响应的内容，<strong>浏览器的 URL 地址不会变化</strong>；Redirect 是客户端请求服务器，然后服务器给客户端返回了一个<strong>302</strong> 状态码和<strong>新的 location</strong>，客户端<u><strong>重新发起 HTTP 请求</strong></u>，服务器给客户端响<u>应 location 对应的 URL 地址，</u>浏览器的 <strong>URL 地址发生了变化</strong>。</p></li><li><p><strong>数据的共享</strong>：Forward 是服务器内部的重定向，request 在整个重定向过程中是不变的，<strong>request 中的信息在 servlet 间是共享</strong>的。Redirect 发起了<strong>两次 HTTP 请求</strong>分别使用<strong>不同的request</strong>。</p></li><li><p><strong>请求的次数</strong>：Forward 只有一次请求；Redirect 有两次请求。</p></li></ul><h4 id="3-请你简单讲解一下，负载均衡反向代理模式的优点、缺点？">3.<strong>请你简单讲解一下，负载均衡反向代理模式的优点、缺点？</strong></h4><blockquote><p>联系实际：<a href="https://server.zol.com.cn/633/6339623_all.html">正反向代理、科学上网、VPN之间的关系</a> 和<a href="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">翻墙基本原理（看他的其他文章补充）</a></p></blockquote><p>【基本介绍】</p><ol><li><p><strong>反向代理</strong>（Reverse Proxy）：方式是指<u>以代理服务器来接受internet上的连接请求</u>，然后将请求转发给内部网络上的服务器，并将从<strong>服务器上得到的结果返回给internet上请求连接的客户端</strong>，此时代理服务器对外就表现为一个服务器；</p><ul><li><p><strong>优点</strong>： 网络络外部用户不能直接访问真实的服务器，具备额外的安全性</p></li><li><p><strong>缺点</strong>： 反向代理是处于OSI参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反向代理服务器；限制了应用范围；</p><p><u><strong>针对每一次代理，代理服务器就必须打开两个连接</strong></u>，一个对外，一个对内，因此在并发连接请求数量非常大的时候，<strong>代理服务器的负载也就非常大了</strong>，在最后代理服务器本身会成为服务的瓶颈。</p></li></ul></li><li><p><strong>反向代理负载均衡技术</strong>：是把将来自internet上的连接请求以反向代理的方式动态地<strong>转发</strong>给内部网络上的<strong>多台服务器</strong>进行处理，从而达到负载均衡的目的。</p><ul><li><strong>实现</strong>：apache mod_proxy、netscape proxy等，也可以在高速缓存器、负载均衡器等硬件设备上实现。</li><li><strong>优点</strong>：可以将优化的 <u>负载均衡策略和代理服务器的高速缓存技术</u>结合在一起，提升静态网页的访问速度，提供有益的性能</li><li><strong>缺点</strong>：</li></ul></li></ol><h5 id="3-1-请解释下负载均衡的相关算法？">3.1 请解释下负载均衡的相关算法？</h5><p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。</p><ul><li>给配置高、负载低的机器配置更高的权重，让其处理更多的请求；</li><li>给配置低、负载高的机器分配较低的权重，降低系统负载。</li></ul><p>下面是几种比较相关的算法。</p><ul><li><p><strong>加权轮询算法</strong></p><blockquote><p>参考：<a href="https://www.fanhaobai.com/2018/11/load-balance-round-robin.html">加权轮询算法</a></p></blockquote><ul><li><p>基本定义</p><ol><li>假设有 N 台实例 S = {S1, S2, …, Sn}，权重 W = {W1, W2, …, Wn}</li><li>currentPos 表示当前选择的实例 ID，初始化为 -1；</li><li>currentWeight 表示当前权重，初始值为 max(S)；</li><li>max(S) 表示 N 台实例的最大权重值，gcd(S) 表示 N 台实例权重的最大公约数。</li></ol></li><li><p>算法过程</p><ol><li>从上一次调度实例起，<strong>遍历后面</strong>的每个实例；</li><li>若所有实例已被遍历过一次，则减小 currentWeight 为 currentWeight - gcd(S)，并从头开始遍历；若 currentWeight 小于等于 0，则重置为 max(S)；</li><li><strong>直到</strong> 遍历的实例的权重 &gt;= currentWeight 时结束，<strong>此时实例为需调度的实例</strong>；</li><li>每次调度重复步骤 1、2、3；</li></ol></li><li><p>算法实例</p><p><img src="https://i.loli.net/2021/05/30/YCVDN4miMvPy7sJ.png" alt="image-20210529232315965"></p><p>例如，上述 4 个服务，最大权重 max(S) 为 4，最大公约数 gcd(S) 为 1。其调度过程如下：</p><p><img src="https://i.loli.net/2021/05/30/7A4s6i3opra8LWR.png" alt="image-20210529232350799"></p></li><li><p>算法优缺点</p><ul><li><p><strong>优点</strong>： 相比 <u>简单轮询</u> 方式，通过权重进行分配，更加均匀</p></li><li><p><strong>缺点</strong>：如下一个极端情况</p><blockquote><p>服务实例 S = {a, b, c}，权重 W = {5, 1, 1}，使用加权轮询调度生成的实例序列为 {a, a, a, a, a, b, c}，那么就会存在连续 5 个请求都被调度到实例 a。</p></blockquote><p>关于这点，可以采用  <a href="https://www.fanhaobai.com/2018/11/load-balance-round-robin.html#">平滑加权轮询</a> 调度算法 。</p></li></ul></li></ul></li><li><p><strong>一致性哈希算法</strong></p><p>负载均衡算法中的哈希算法，就是根据某个值生成一个哈希值，然后对应到某台服务器上去，即<strong>哈希环</strong>。</p><p><img src="https://i.loli.net/2021/05/30/fAa2jzXxGZ7lVq1.png" alt="image-20210529232953082"></p><p>但是可能出现一种，<strong>哈希倾斜</strong>的情况：A负责的区域太大，B，C负责的小。这个时候采用虚拟节点去解决，这里不表。</p></li></ul><h5 id="3-2-DNS-负载均衡是什么策略？">3.2 DNS 负载均衡是什么策略？</h5><blockquote><p>参考：<a href=""></a></p></blockquote><ul><li><strong>原理</strong>： 还是不太明白，DNS递归查询本身就是个负载均衡策略吧？多台服务器满足同一个查询服务？</li></ul><h4 id="4-请说明一下http和https的区别？">4.<strong>请说明一下http和https的区别？</strong></h4><ol><li>https协议要申请证书到ca，需要一定<u>经济成本</u>；</li><li>http是明文传输，https是加密的安全传输；</li><li>（🚩*1）连接的端口不一样，http是<strong>80</strong>，https是<strong>443</strong>；</li><li>http连接很简单，没有状态；</li><li>https是ssl加密的传输，身份认证的网络协议，相对http明文传输比较安全。</li></ol><h5 id="4-1-讲一讲http的请求报文和响应报文？协议？">4.1 讲一讲http的请求报文和响应报文？协议？</h5><ul><li><p><strong>请求报文和协议</strong></p><p>一个HTTP请求报文由<strong>请求行（request line）</strong>、<strong>请求头部（header）</strong>、<strong>空行</strong>和<strong>请求数据</strong>4个部分组成，下图给出了请求报文的一般格式。</p><p><img src="https://i.loli.net/2021/05/17/uxX1gbcnhTsS9td.png" alt="img"></p><ul><li><p><strong>请求行</strong> ：由请求方法字段、URL字段和HTTP协议版本字段3个字段组成。</p><blockquote><p><strong>HTTP协议</strong> :  的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</p></blockquote></li><li><p><strong>请求头部</strong>： 请求头部由<strong>关键字/值</strong>对组成，每行一对，关键字和值用英文冒号“:”分隔 。 请求头部<strong>通知服务器有关于客户端请求的信息</strong>。</p><blockquote><p>User-Agent：产生请求的浏览器类型。</p><p>Accept：客户端可识别的内容类型列表。</p><p><strong>Host</strong>：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</p></blockquote></li><li><p><strong>请求数据 :</strong> 请求数据<strong>不在GET方法中使用，而是在POST方法</strong>中使用。POST方法适用于需要客户填写表单的场合。</p></li></ul></li><li><p><strong>响应报文和协议</strong></p><p>HTTP响应也由四个部分组成，分别是：<strong>状态行、响应头、空格、响应数据</strong>。</p><p><img src="https://i.loli.net/2021/05/17/QNIRoY5f7jk6sHv.jpg" alt="img"></p><ul><li><strong>状态行</strong> ： 状态行（status line）通过提供一个状态码来说明所请求的资源情况。如<strong>404</strong>等</li></ul></li></ul><h5 id="4-2-一个TCP连接中多个HTTP请求发生可以【同时】一起发生吗？">4.2  一个TCP连接中多个HTTP请求发生可以【同时】一起发生吗？</h5><ul><li><strong>HTTP/1.1单个 TCP 连接在同一时刻只能处理一个请求</strong>。意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠；</li><li><strong>Pipelining 技术 &amp; Multiplexing。</strong> Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行；</li></ul><blockquote><p>那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？</p></blockquote><ul><li>维持和服务器已经建立的 TCP 连接，在同一连接上<strong>顺序处理多个请求</strong>；</li><li><strong>和服务器建立多个 TCP 连接</strong>。</li></ul><h4 id="5-请说明一下http1-0-和https1-1-区别？">5.<strong>请说明一下http1.0 和https1.1 区别</strong>？</h4><ul><li><strong>长连接</strong><ul><li>HTTP1.0默认使用短连接，每次HTTP请求都需要建立新的TCP连接，连接不能复用；</li><li>HTTP1.1支持<strong>持久连接和请求的流水线处理（但不是并发！！</strong>），在<strong>一个TCP连接上可以传送多个HTTP请求和响应</strong>，<u>减少建立和关闭TCP连接的消耗和延迟，提高效率</u></li></ul></li><li><strong>host字段</strong><ul><li>在<strong>HTTP1.0中为每台服务器绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名</strong>（hostname）</li><li>HTTP1.1的请求消息和响应消息都应支持Host头域（<u>补充：F12 抓包可以看到</u>），且请求消息中如果<strong>没有Host头域</strong>，会<strong>报400 Bad Request错误</strong></li></ul></li><li><strong>缓存处理</strong><ul><li>HTTP1.1则引入了更多的缓存控制策略</li></ul></li><li><strong>带宽优化及网络连接的使用</strong><ul><li>HTTP1.0中存在浪费带宽现象，例如：（1）客户端只需要某个对象的一部分，而服务器却<u>将整个对象发送过来</u>；(2) 下载大文件不支持断点续传功能，在发生断连后需要重新下载完整的包；</li><li>HTTP1.1则在请求头中引入range头域，它允许<strong>只请求资源的某个部分(因此也支持断点重传)</strong>，即返回码是206；</li></ul></li><li><strong>新增一些错误通知状态码</strong><ul><li>如：409（Conflict）表示请求的资源与资源的当前状态发生冲突 。</li></ul></li></ul><h4 id="6-请说明一下http1-0-和https2-0-区别？">6.<strong>请说明一下http1.0 和https2.0 区别</strong>？</h4><h4 id="7-请讲一下浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程？">7.<strong>请讲一下浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程</strong>？</h4><ol><li><p>在浏览器地址栏中输入URL；</p></li><li><p>DNS域名解析，获得域名相对应的IP地址（详见：<u>应用层DNS寻址过程</u>）；</p><blockquote><p>浏览器首先会从（1）本地浏览器缓存、hosts文件是否存在相应的域名、IP对应关系，如果有则向这个IP地址发送请求，如果没有则向（2）本地DNS<strong>解析器</strong>缓存中查找，如果都没有，（3）再去DNS<strong>服务器</strong>中找IP。</p></blockquote></li><li><p>浏览器向服务器发起TCP连接，与浏览器建立TCP三次握手；然后 <u><strong>向服务器发送HTTP请求</strong></u>，请求数据包</p><blockquote><p><strong>HTTP请求是由三部分组成：请求行、请求报头和请求正文</strong>。</p><p>与服务器建立了连接后，就可以向服务器发起请求了。发送HTTP请求的过程就是<u>构建HTTP请求报文</u>，并通过TCP协议发送到服务器指定端口（<u>HTTP协议80/8080，HTTPS协议443</u>）。</p></blockquote></li><li><p>服务端（由web服务器）处理收到的请求</p><blockquote><p>服务器端收到请求后，由web服务器（准确来说应该是HTTP服务器）处理请求，诸如Apache、Ngnix、IIS 。</p></blockquote></li><li><p>服务器返回相应结果（响应报文）至浏览器</p><blockquote><p>HTTP响应报文也是由三部分组成：<strong>状态码、响应报头和响应报文</strong>。</p><p>状态码是由三位数组成，<u>第一个数字定义了响应的类别</u>：</p><ul><li><strong>1XX</strong>：指示信息，表示请求已接受，继续处理；</li><li><strong>2XX</strong>：成功，表示请求已被成功接收、理解、接受；</li><li><strong>3XX</strong>：重定向，要完成请求必须进行更进一步的操作；</li><li><strong>4XX</strong>：客户端错误，请求有语法错误或无法实现；</li><li><strong>5XX</strong>：服务器端错误，服务器未能实现合法的请求。</li></ul></blockquote></li><li><p>四次挥手关闭TCP连接</p><blockquote><p>四次挥手，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。</p></blockquote></li><li><p>浏览器解析渲染页面</p><blockquote><p>浏览器在 <u>收到HTML、CSS、JS文件</u>后，就需要进行渲染。</p><p>（1）浏览器解析HTML文件构建<u>DOM树</u>，（2）然后解析CSS文件构建<u>渲染树</u>，（3）等到渲染树构建完成后，浏览器开始布局渲染树并将其<u>绘制到屏幕</u>上</p></blockquote></li></ol><h4 id="8-请解释一下SSL工作过程（Https传输过程）？">8.<strong>请解释一下SSL工作过程（Https传输过程）？</strong></h4><blockquote><p>https是http的扩展，在传输层使用了安全协议：<strong>安全套接字层SSL(Secure Socket Layer)</strong>。</p><p>参考：<a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p></blockquote><blockquote><p><strong>公钥</strong>通常用于加密会话密钥、验证数字签名，或加密可以用相应的私钥解密的数据。公钥和私钥是通过一种算法得到的一个密钥对(即一个公钥和一个私钥)。</p><ul><li>通过这种算法得到的密钥对能保证在世界范围内是唯一的。</li><li>使用这个密钥对的时候,如果用其中一个密钥加密一段数据，必须用另一个密钥解密。</li></ul></blockquote><p>SSL/TLS协议的基本思路是采用<a href="http://en.wikipedia.org/wiki/Public-key_cryptography">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p><img src="https://i.loli.net/2021/04/21/aH6gjc5UT9Xu2io.png" alt="image-20210421171336262"></p><p>所以基本过程是：</p><blockquote><p>（1） 客户端向服务器端索要并验证公钥。</p><p>（2） 双方协商生成&quot;对话密钥&quot;。</p><p>（3） 双方采用&quot;对话密钥&quot;进行加密通信。</p></blockquote><ol><li><p><strong>协商加密算法</strong>。客户端（通常是浏览器）先向服务器发出<u>加密通信的请求</u>，这被叫做ClientHello请求；</p><blockquote><p>（1） 支持的协议版本，比如TLS 1.0版。</p><p>（2） <u>一个客户端生成的随机数</u>，来生成&quot;对话密钥&quot;。</p><p>（3） 支持的加密方法，比如RSA公钥加密。</p><p>（4） 支持的压缩方法。</p></blockquote></li><li><p><strong>服务器回应</strong>。服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello；</p><blockquote><p>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</p><p>（2） <u>一个服务器生成的随机数</u>，稍后用于生成&quot;对话密钥&quot;。</p><p>（3） 确认使用的加密方法，比如RSA公钥加密。</p><p>（4） 服务器证书。</p></blockquote></li><li><p><strong>客户端鉴别</strong>。客户端收到服务器回应以后，（1）<u>首先验证服务器证书</u>：如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p><p>（2）<u>如果证书没有问题，客户端就会从证书中取出服务器的公钥</u>。然后，向服务器发送下面三项信息：</p><blockquote><p>（1） <u>一个随机数</u>。该随机数用服务器公钥加密，防止被窃听。</p><p>（2） <u>编码改变通知</u>，表示随后的信息都将用双方商定的加密方法和密钥发送。</p><p>（3） <u>客户端握手结束通知</u>，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p></blockquote></li><li><p><strong>会话秘钥计算</strong>。 服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的&quot;会话密钥&quot;（使用3个随机数生成更安全）；</p><blockquote><p>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p><p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p></blockquote></li><li><p><strong>安全数据传输</strong>。双方用会话秘钥加密和解密之间传送的数据。</p></li></ol><h5 id="8-1-公钥如何保证不被篡改？说一说证书。">8.1 公钥如何保证不被篡改？说一说证书。</h5><p>将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p><ul><li><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p></li><li><p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，<strong>会对已申请的公开密钥做数字签名</strong>，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p></li><li><p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过（<strong>证书不可信浏览器会提示</strong>），就可以开始通信了。</p></li></ul><h5 id="8-2-公钥加密计算量太大，如何减少耗用的时间？">8.2 公钥加密计算量太大，如何减少耗用的时间？</h5><p>每一次对话（session），客户端和服务器端都生成一个&quot;对话密钥&quot;（session key），用它来加密信息。由于<strong>对话密钥是对称加密</strong>，所以<strong>运算速度非常快</strong>，而服务器公钥只用于加密&quot;对话密钥&quot;本身，这样就减少了加密运算的消耗时间。</p><h5 id="8-3-为什么有的时候刷新页面不需要重新建立-SSL-连接？">8.3 为什么有的时候刷新页面不需要重新建立 SSL 连接？</h5><p>TCP 连接有的时候会被浏览器和服务端维持一段时间，<strong>TCP 不需要重新建立，SSL 自然也会用之前的</strong>。</p><h4 id="9-介绍一下常见的几种非对称加密算法？优缺点？">9. 介绍一下常见的几种非对称加密算法？优缺点？</h4><ul><li><p><strong>非对称加密</strong></p><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，<strong>通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密</strong>，<strong>接收方收到通信内容后使用私有密钥解密</strong>。</p></li><li><p><strong>常用非对称加密算法</strong></p><p><img src="https://i.loli.net/2021/04/21/8cmyAzUZYDw5vJt.png" alt="面试题——对称加密和非对称加密3"></p><ul><li>RSA：由 RSA 公司发明，是一个支持<strong>变长密钥</strong>的公共密钥算法，需要加密的文件块的长度也是可变的</li><li>DSA（Digital Signature Algorithm）<strong>：数字签名</strong>算法，是一种标准的 DSS（数字签名标准）</li><li>ECC（Elliptic Curves Cryptography）<strong>：椭圆曲线加密</strong></li></ul></li><li><p><strong>非对称加密优缺点</strong></p><ul><li><strong>优点</strong>： 可以更安全地将公开密钥传输给通信发送方；</li><li><strong>缺点</strong>： 运算速度慢。</li></ul></li></ul><h4 id="10-公钥加密–私钥解密与公钥解密–私钥加密有什么区别">10.<strong>公钥加密–私钥解密与公钥解密–私钥加密有什么区别?</strong></h4><p>主要是应用场景不同。</p><ul><li><p>加解密：公钥加密，私钥解密</p><blockquote><p>不希望别人知道我的消息，<u>所以只有我才能解密</u>，所以可得出公钥负责加密，私钥负责解密</p></blockquote></li><li><p>签名：私钥签名，公钥验签</p><blockquote><p>是不希望有人冒充我发消息，只有<u>我才能发布这个签名</u>，所以可得出私钥负责签名，公钥负责验证</p></blockquote></li><li><p><strong>https可以只有非对称加密吗?</strong></p><p>https<u>验证证书阶段是非对称加密</u>，但是在数据传输阶段是对称加密。<strong>https不可以只有非对称加密</strong>：</p><ul><li><strong>非对称加密</strong>的加解密<strong>效率是非常低</strong>的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的；</li><li>在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。</li></ul></li></ul><h4 id="11-HTTPS-为什么安全？为什么需要CA证书？只有认证机构可以生成证书吗？HTTPS-绝对安全吗？">11. <strong>HTTPS 为什么安全？为什么需要CA证书？只有认证机构可以生成证书吗？HTTPS 绝对安全吗？</strong></h4><ul><li><p><strong>安全</strong>：因为 HTTPS 保证了传输安全，防止传输过程被监听、防止数据被窃取，可以确认网站的真实性；</p></li><li><p><strong>CA证书</strong>： <u>HTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器</u>，而 HTTPS 协议主要解决的便是网络传输的安全性问题，所以需要CA证书</p></li><li><p><strong>证书生成</strong>： 如果需要浏览器不提示安全风险，那只能使用认证机构签发的证书。但<strong>浏览器通常只是提示安全风险，并不限制网站不能访问</strong>，所以从技术上<strong>谁都可以生成证书</strong>，只要有证书就可以完成网站的 HTTPS 传输。</p></li><li><p><strong>不绝对安全</strong>： 不是绝对安全的，可以通过中间人攻击。</p><blockquote><p>CA证书不是可以解决“中间人”吗？</p></blockquote><p>过程原理：</p><ol><li>本地请求被劫持（<u>如DNS劫持等</u>），所有请求均发送到中间人的服务器</li><li>中间人服务器返回中间人自己的证书（<strong>但是这一步服务器不是会对服务器证书进行验证吗？</strong>）</li><li>客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输</li><li>中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密</li><li>中间人以客户端的请求内容再向官方网站发起请求</li><li>因为中间人与服务器的通信过程是合法的，官方网站通过建立的安全通道返回加密后的数据</li><li>中间人凭借与官方网站建立的对称加密算法对内容进行解密</li><li>中间人通过与客户端建立的对称加密算法对官方内容返回的数据进行加密传输</li><li>客户端通过与中间人建立的对称加密算法对返回结果数据进行解密</li></ol></li></ul><h4 id="12-http应答码中的301-2-4、500、502、503、504状态码进行解释？">12. <strong>http应答码中的301/2/4、500、502、503、504状态码进行解释</strong>？</h4><ul><li><p><strong>200：</strong>  请求成功。</p></li><li><p><img src="https://i.loli.net/2021/04/21/MRi5Oy9Ltd3v8uA.png" alt="image-20210421150625709"></p></li><li><p><strong>500：</strong> 500 (<strong>服务器内部错误</strong>) 服务器遇到错误，无法完成请求。 例如，服务器<strong>无法识别请求方法</strong>时可能会返回此代码。</p></li><li><p><strong>501：<strong>服务器</strong>不支持请求的功能</strong>，无法完成请求</p></li><li><p><strong>502：</strong> 作为<strong>网关或者代理工作的服务器</strong>尝试执行请求时，从<u>上游服务器</u>接收到<strong>无效</strong>的响应。</p></li><li><p><strong>503：</strong> 由于超载或系统维护，服务器暂时的<strong>无法处理客户端</strong>的请求。</p></li><li><p><strong>504(及时)</strong>：作为网关或者代理工作的服务器尝试执行请求时，<strong>未能及时</strong>从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。</p></li></ul><h4 id="13-介绍一下http请求get、post等？">13.<strong>介绍一下http请求get、post等</strong>？</h4><p><img src="https://i.loli.net/2021/04/21/WRLspE4fvjdKq8F.png" alt="image-20210421140204266"></p><p><strong>重点区分一下get和post：</strong></p><ul><li><p><code>get</code> ：GET方法用于使用给定的URI从给定服务器中<u>检索信息</u>，即从指定资源中请求数据。</p><ul><li><strong>GET请求是可以缓存的</strong>，浏览器历史记录中查找到GET请求；<strong>长度有限制</strong>；不安全，<strong>url会暴露请求的参数</strong></li></ul></li><li><p><code>post</code>：POST方法用于将数据发送到服务器以<u>创建或更新资源</u> 。</p><ul><li><strong>POST请求不会被缓存</strong>；<strong>长度无限制</strong>；更安全</li></ul></li><li><p><strong>特别的：<code>GET产生一个TCP数据包;POST产生两个TCP数据包。</code></strong></p><ul><li><p>get：http header和body一并发送出去 ；</p></li><li><p>post：浏览器先发送header，服务器响应100 continue，浏览器再发送body 。</p><blockquote><p>⚠️ post是不一定会发生两个的。</p><ul><li>HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送；</li><li>header 和 body 分开发送<strong>是部分浏览器或框架的请求方法</strong>，不属于 post 必然行为。</li></ul></blockquote></li></ul></li></ul><h5 id="13-1-Get方法长度有限制是怎么回事？">13.1 Get方法长度有限制是怎么回事？</h5><p>HTTP 协议没有 Body 和 URL 的长度限制，<strong>对 URL 限制的大多是浏览器 / 服务器的原因</strong>。</p><ul><li>服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制；</li><li>浏览器也会设置url有限。</li></ul><h5 id="13-2-POST-方法相比GET方法是绝对安全吗？">13.2 POST 方法相比GET方法是绝对安全吗？</h5><ul><li>POST 比 GET 安全，因为数据在地址栏上不可见；</li><li><strong>POST不是绝对安全</strong>，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。</li></ul><p>想要安全，只有使用<strong>HTTPS</strong>。</p><h4 id="14-HTTP是不保存状态的协议-如何保存用户状态">14.  HTTP是不保存状态的协议,如何保存用户状态?</h4><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太⼀样。</p><ul><li><strong>Cookie ⼀般用来保存用户<u>信息</u></strong><ul><li>我们在 Cookie 中<strong>保存已经登录过得用户信息</strong>，下次访问网站的时候页面可以⾃动帮你登录的⼀些基本信息给填了；</li><li>⼀般的网站都会有<strong>保持登录</strong>也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以<strong>存放了⼀个 Token 在 Cookie</strong>中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录⼀般要将 Token<br>重写)；</li><li>登录⼀次网站后访问网站其他页面不需要重新登录。</li></ul></li><li><strong>Session 的主要作用就是通过服务端记录用户的<u>状态</strong></u>。<ul><li><strong>典型的场景是购物⻋</strong>，当你要添加商品到购物⻋的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</li><li><strong>既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢</strong>？大部分情况下，我们都是通过在Cookie 中附加⼀个 Session ID 来方式来跟踪。</li></ul></li></ul><h4 id="15-cookie-、session的作用和区别？">15. <strong>cookie 、session的作用和区别</strong>？</h4><ul><li><p><strong>Cookie</strong></p><ul><li><p><strong>作用</strong>： 服务器发送到用户浏览器并保存在本地的一小块数据，它会在<u>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</u>。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。</p><blockquote><p>Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p></blockquote></li></ul></li><li><p><strong>Session</strong></p><ul><li><strong>作用</strong>： Session 代表着服务器和客户端<strong>一次会话的过程</strong>，Session <u>对象存储特定用户会话所需的属性及配置信息</u>。</li></ul></li><li><p><strong>二者区别</strong></p><ul><li><strong>作用范围不同</strong>，Cookie 保存在客户端（浏览器），Session 保存在服务器端；</li><li><strong>有效期不同</strong>，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效；</li><li><strong>安全性</strong>： Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些；</li><li><strong>存储大小不同</strong>：  <u>单个 Cookie 保存的数据不能超过 4K</u>，Session 可存储数据远高于 Cookie；</li><li><strong>存取类型的不同</strong>，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li></ul></li></ul><h5 id="15-1-Session的共享方式？（好未来问过）">15.1 Session的共享方式？（好未来问过）</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/jing99/p/11785070.html">Session如何共享</a></p></blockquote><ul><li><p><strong>问题描述</strong></p><ol><li>在集群环境中，假设客户端第一次访问服务A，服务A响应返回了一个sessionId并且存入了本地Cookie中。第二次不访问服务A了，转去访问服务B；</li><li>访问服务B的时候，会将sessionId加入到请求头中，而服务B因为通过sessionId没有找到相对应的数据，因此它就会<strong>创建一个新的sessionId并且响应返回给客户端</strong></li></ol><p>这样就造成了不能共享Session的问题。</p></li><li><p><strong>解决方案</strong></p><ol><li><strong>使用Cookie实现</strong>。 将系统用户的Session信息加密、序列化后，以Cookie的方式， 统一种植在根域名下（如：.host.com），利用浏览器访问该根域名下的所有二级域名站点时，会传递与之域名对应的所有Cookie内容的特性，从而实现用户的Cookie化Session在多服务间的共享访问。</li><li><strong>数据库同步session。</strong>  每次将session数据存到数据库中。这个方案还是比较可行的。<ul><li><strong>缺点</strong>： Session的并发读写能力取决于MySQL数据库的性能，对数据库的压力大，同时需要自己实现Session淘汰逻辑，以便定时从数据表中更新、删除 Session记录，当并发过高时容易出现表锁。</li></ul></li><li><strong>使用token代替session。</strong> 就是Token方式替代了，但是还是没解决。</li><li><strong>Spring-Sesion实现</strong> 。将原本需要由Web服务器创建会话的过程转交给Spring-Session进行创建。Spring-Session会将原本应该保存在Web服务器内存的Session存放到Redis中。然后<strong>Web服务器之间通过连接Redis来共享数据</strong>，达到Sesson共享的目的。</li></ol></li></ul><h4 id="16-Cookie-和-Session有什么关联？（问过）token有什么作用，优点，（JWT）结构是什么？">16.  Cookie 和 Session有什么关联？（问过）token有什么作用，优点，（JWT）结构是什么？</h4><blockquote><p>参考：<a href="https://juejin.cn/post/6844904009061367821">一文彻底搞懂Cookie、Session、Token到底是什么</a></p></blockquote><ul><li><p><strong>为什么需要session？</strong></p><blockquote><p>既然浏览器已经通过<code>Cookie</code>实现了有状态这一需求，那么为什么又来了一个<code>Session</code>呢？</p></blockquote><p>如果将账户的一些重要信息都存入<code>Cookie</code>中的话，一旦<strong>被拦截</strong>，那么我们所有的账户信息都会丢失掉。所以就出现了<code>Session</code>，在一次会话中将重要信息保存在<code>Session</code>中，浏览器只记录<code>SessionId</code>一个<code>SessionId</code>对应一次会话请求。</p></li><li><p><strong>session和cookie二者关联</strong></p><p><img src="https://i.loli.net/2021/05/04/jNerb9CXZ6Jpgs2.jpg" alt="img"></p><blockquote><p>以用户一次登录为例。</p></blockquote><ol><li>用户第一次请求服务器的时候，用户提交包含<strong>用户名和密码</strong>的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 <strong>Redis</strong> 中，它在 Redis 中的 Key 称为 Session ID；并将此 Session 的唯一标识信息 SessionID 返回给浏览器；</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名；</li><li>当用户第二次访问服务器的时候，请求会自动判断<u>此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端</u>；</li><li>服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 <u>Session 信息，如果没有找到说明用户没有登录或者登录失效</u>，如果找到 Session 证明用户已经登录可执行后面操作。</li></ol></li><li><p><strong>什么是Token？</strong></p><blockquote><p><code>Session</code>是将要验证的信息存储在服务端，并以<code>SessionId</code>和数据进行对应，<code>SessionId</code>由客户端存储，在请求时将<code>SessionId</code>也带过去，因此实现了状态的对应。</p></blockquote><p>但是，而<code>Token</code>是在服务端将<strong>用户信息经过Base64Url【编码，不是加密】过后传给在客户端</strong>，每次用户请求的时候都会带上这一段信息，因此服务端拿到此信息进行解密后就知道此用户是谁了。</p><p>这个方法叫做<strong>JWT(Json Web Token)</strong>。</p><blockquote><p>一个例子理解：基于Token的身份验证流程，在服务端不需要存储用户的登录记录 。</p><ol><li><p>客户端<strong>使用用户名跟密</strong>码请求登录</p></li><li><p>服务端收到请求，去验证用户名与密码</p></li><li><p>验证成功后，服务端会<strong>签发一个 Token</strong>，再把这个 Token 发送给客户端</p><blockquote><p>Token在服务器端，可以保存在Redis缓存中。</p></blockquote></li><li><p>客户端收到 Token 以后可以把它存储起来，比如<strong>放在 Cookie 里或者 Local Storage</strong> 里</p></li><li><p>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p></li><li><p>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p></li></ol></blockquote><ul><li><p><strong>Token的优点</strong></p><ol><li><strong>无状态，可扩展和解耦</strong>： 使用 token 而不是 cookie 的最大优点应该就是无状态，<strong>后端不需要保持对 token 的记录，每个 token 都是独立的</strong>，包含了检查其有效性的所有数据，并通过申明传达了用户信息。</li><li><strong>在 JWT 中存储数据</strong> ： 当使用 cookie 进行验证时，你是将 session id 存储到 cookie 里，JWT 允许你存储任何类型的元数据，只要是合法的 JSON。</li><li><strong>自包含</strong>：由于串包含了用户所需要的信息，避免了多次查询数据库。</li></ol></li><li><p><strong>JWT介绍</strong></p><p>JWT有三部分组成：Header，Payload，Signature。</p><p><img src="https://i.loli.net/2021/05/26/AC6ULh5293HQngE.png" alt="image-20210526214555872"></p><ul><li><p><strong>Header：</strong> 一个Json对象，描述JWT的元数据，通常是下面这样子的。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>, # 签名的算法为HS256</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>    # Token类型为JWT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Payload：</strong> 也是一个Json对象，用来存放实际需要传输的数据，也可以自己定义一些私有字段，如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xiaoMing&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Signature</strong>： <strong>对前面的两部分的数据进行签名</strong>，<strong>防止数据篡改</strong> 。</p><blockquote><p>首先需要定义一个<strong>秘钥</strong>，这个秘钥只有服务器才知道，不能泄露给用户，然后使用<strong>Header中指定的签名算法</strong>(默认情况是HMAC SHA256)。算出签名以后将Header、Payload、Signature三部分拼成一个字符串，<strong>每个部分用<code>.</code>分割开来</strong>，就可以返给用户了。</p></blockquote></li></ul></li></ul></li></ul><h5 id="16-1-session和cookie应该如何去选择（适用场景）？">16.1 session和cookie应该如何去选择（适用场景）？</h5><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在<strong>考虑数据复杂性时首选 Session</strong>；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；<strong>考虑安全考虑session</strong></li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此<strong>不建议将所有的用户信息都存储到 Session 中，一般是cookie和session配合使用的</strong>。</li></ul><h4 id="17-说说HTTP、TCP、Socket-的关系是什么？">17.<strong>说说HTTP、TCP、Socket 的关系是什么</strong>？</h4><ul><li>TCP/IP 代表<u>传输控制协议/网际协议</u>，指的是一系列协议族；</li><li>HTTP 本身就是一个协议，是<u>从 Web 服务器传输超文本到本地浏览器</u>的传送协议；</li><li><strong>Socket 是 TCP/IP 网络的 API</strong> ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</li></ul><h2 id="3-5-其它">3.5 其它</h2><h4 id="1-介绍一下CDN-？-CDN分发节点各个数据都一样吗？">1. 介绍一下CDN ？ <strong>CDN</strong>分发节点各个数据都一样吗？</h4><ul><li><p><strong>CDN，即内容分发网络</strong></p><ul><li><p><strong>解决静态网页加载</strong></p><p>不同地区用户访问服务器速度不同，<strong>可以把静态网页放在不同地区的服务器，这样用户可以就近去连接</strong>，大大提升体验；</p></li><li><p>发展转换成，<strong>就近接入解决访问网络资源</strong></p><ol><li>如一个电信用户送请求，进入解析系统，会<strong>让用户连接到最近的边缘节点</strong>，然后请求数据；</li><li>如果边缘节点没有数据，则去访问<strong>源节点</strong>；</li><li>源节点也没有，就会去访问<strong>主干节点，去联通服务器中查找；</strong></li><li>最后返回数据。</li></ol></li></ul></li><li><p><strong>CDN分发节点各个数据不一样</strong></p><p>不一样，就相当于DNS服务器<strong>缓存</strong>了些域名→ip数据，如果没有的话还要向上级查询，最终把源站数据拉下来。</p></li></ul><h4 id="2-什么是CDN三级溯源？">2.  什么是CDN三级溯源？</h4><ul><li><strong>CDN目的</strong>。CDN 系统设计的首要目标是<strong>尽量减少用户的访问响应时间</strong></li><li><strong>CDN实现思路</strong>。为达到这一目标，CDN 系统应该<strong>尽量将用户所需要的内容存放在距离用户最近的位置</strong>。也就是说，负责为用户提供内容服务的 <strong>Cache设备应部署在物理上的网络边缘位置</strong>，我们称这一层为 CDN边缘层 。</li><li><strong>CDN系统架构</strong>。CDN 系统中负责全局性管理和控制的设备组成 中心层 ，<strong>中心层同时保存着最多的内容副本</strong>，当边缘层设备未命中时，会向中心层请求，如果在中心层仍未命中，则需要中心层向源站回源。</li></ul><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210813124031742.png" alt="image-20210813124031742"></p>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（二）_计算机基础_Linux&amp;Git</title>
      <link href="/p/44980/"/>
      <url>/p/44980/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h1>二、Linux &amp; Git</h1><h2 id="2-1-Linux">2.1 Linux</h2><h3 id="2-1-1-常用命令">2.1.1 常用命令</h3><ol><li><p><strong>查看80端口状态</strong>？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntulp | grep 80</span><br></pre></td></tr></table></figure><ul><li><code>-t</code> : 指明显示TCP端口</li><li><code>-u</code> : 指明显示UDP端口</li><li><code>-l</code> : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)</li><li><code>-p</code> : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序</li><li><code>-n</code> : 不进行DNS轮询，显示IP(可以加速操作)</li></ul></li><li><p><strong>怎么查看指定端口是否开放</strong>？</p><p>通过 netstat 命令，注意加上-a参数，看是否有<code>0.0.0.0:22</code> 在被监听。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210906215822732.png" alt="image-20210906215822732"></p><p>通过lsof命令，如果没有任何显示，则端口没有被打开。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210906215941036.png" alt="image-20210906215941036"></p></li><li><p><strong>查看进程状态？怎么退出？怎么搜索进程？怎么查看某一个进程的内存和CPU使用情况</strong>？</p><ul><li><p>所有进程状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -aux  <span class="comment"># 内存中进程信息</span></span><br><span class="line">ps -l    <span class="comment"># 本次登陆所有的进程信息</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/19/ayQRIA8FcqBjtlV.png" alt="image-20210519183338193"></p></li><li><p>退出进程：</p><p><code>exit</code></p></li><li><p>搜索进程：</p><p><code>ps -ef </code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep &lt;进程名&gt;</span><br></pre></td></tr></table></figure><ul><li><code>-e</code>相当于<code>-a</code>是全部列出，<code>-f</code>是显示UID等；</li></ul></li><li><p>查看指定进程（如kalfa）CPU和内存占用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep java</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/23/r5vaDgo4sYGfA8c.png" alt="image-20210523171131744"></p><ul><li>1.3是<strong>CPU占用率</strong>，12.7是<strong>内存占用率</strong>，943100是<strong>物理内存使用量</strong></li></ul><p>还可以使用 top命令查看指定进程（PID）的内存和CPU使用率：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p 2913</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>查看占用指定端口的进程</strong> ？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :8040</span><br></pre></td></tr></table></figure><p>这一步只<u>能获取进程名</u>，还要<code>ps</code> 命令进一步获取进程<code>id</code></p><p>如果要杀死相应进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 &lt;进程id&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>任务管理器</strong>（cpu占用率、内存占用率、进程）？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p>（<strong>总忘</strong>）还可以使用 top命令查看<strong>指定进程（PID）的内存和CPU使用率</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p</span><br></pre></td></tr></table></figure></li><li><p><strong>内存使用情况 和 磁盘使用情况</strong>？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m  <span class="comment"># 内存使用情况</span></span><br></pre></td></tr></table></figure><p>磁盘使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -m</span><br></pre></td></tr></table></figure><p><code>-m</code> : 以Mb为单位显示磁盘使用量和占用率</p></li><li><p><strong>统计单词个数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -o &lt;单词&gt; &lt;文件地址&gt; ｜ wc -l   <span class="comment"># -l表示统计行数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>修改用户权限及常用参数</strong>？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod &lt;参数(可选)&gt; &lt;模式&gt; &lt;文件/文件夹&gt;</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li><code>-R</code> ：递归的修改文件夹下所有子文件/文件夹的所属用户</li></ul><blockquote><p>【示例】如何修改 <code>/test5/5.txt</code> ，权限从<code>rw-r--r--</code> —&gt; <code>r--rwxrwx </code> ？</p><p><img src="https://camo.githubusercontent.com/fc3e66b1514a14614059e9423b7393b39d9a79db57cdcf11f0efd07fd95d32ca/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30392f31372f527a664d625165377471756b786c452e706e67" alt="1580875509098"></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户（U）权限[减去写]权限</span></span><br><span class="line">chmod u-w /test5/5.txt</span><br><span class="line"><span class="comment"># 组（G）/其他用户（O）权限[加上写、执行]</span></span><br><span class="line">chmod go+wx /test5/5.txt</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/20/3wrFPWplI47MTbO.png" alt="1580875689076"></p></li><li><p><strong>查看文件的命令有哪些</strong>？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi 文件名   <span class="comment">#编辑方式查看，可修改</span></span><br><span class="line">cat 文件名  <span class="comment">#显示全部文件内容</span></span><br><span class="line">more 文件名 <span class="comment">#分页显示文件内容</span></span><br><span class="line">less 文件名 <span class="comment">#与 more 相似，更好的是可以往前翻页</span></span><br><span class="line">tail 文件名 <span class="comment">#仅查看尾部，还可以指定行数</span></span><br><span class="line">head 文件名 <span class="comment">#仅查看头部,还可以指定行数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>你平时怎么查看日志的</strong>？</p><p>Linux查看日志的命令有多种: tail、cat、tac、head、echo等，本文只介绍几种常用的方法。</p><ul><li><p><strong>tail（最常使用）</strong></p><p>命令格式: <code>tail[必要参数][选择参数][文件]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail -n 10 test.log 查询日志尾部最后10行的日志;</span><br><span class="line">tail -n +10 test.log 查询10行之后的所有日志;</span><br><span class="line">tail -fn 10 test.log 循环实时查看最后10行记录(最常用的)</span><br></pre></td></tr></table></figure><p>一般还会配合着grep搜索用，例如 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -fn 1000 test.log | grep <span class="string">&#x27;关键字&#x27;</span></span><br></pre></td></tr></table></figure><p>如果一次性查询的数据量太大,可以进行翻页查看，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 4700 aa.log |more -1000 可以进行多屏显示(ctrl + f 或者 空格键可以快捷键)</span><br></pre></td></tr></table></figure></li><li><p><strong>其它配合的命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span>              <span class="comment"># 所有的历史记录</span></span><br><span class="line"><span class="built_in">history</span> | grep XXX   <span class="comment"># 历史记录中包含某些指令的记录</span></span><br><span class="line"><span class="built_in">history</span> | more       <span class="comment"># 分页查看记录</span></span><br><span class="line"><span class="built_in">history</span> -c           <span class="comment"># 清空所有的历史记录</span></span><br><span class="line">!! 重复执行上一个命令</span><br><span class="line">查询出来记录后选中 : !323</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>怎么让进程后台运行</strong>？</p><ol><li><p>命令后面加上**&amp;**即可，实际上，这样是将命令放入到一个作业队列中了；</p><p>通常配合<strong>nohup</strong> ，忽略发送给子命令的挂断SIGHUP信号（<strong>终端关闭</strong>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup subcommand &amp;</span><br></pre></td></tr></table></figure></li><li><p>ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程；</p><blockquote><p>ctrl + c 是进程终止。</p></blockquote></li><li><p>运行指令前面**+ setsid**，使其父进程编程init进程，<strong>不受SIGHUP信号的影响</strong>。</p></li></ol></li></ol><h3 id="2-1-2-其它问题">2.1.2 其它问题</h3><h4 id="1-请问-proc-目录有什么用？">1.<strong>请问<code>/proc</code> 目录有什么用</strong>？</h4><p>Linux系统上的/proc目录是一种文件系统，即proc文件系统。 /proc是一种伪文件系统（也即虚拟文件系统），存储的是<strong>当前内核运行状态</strong>的一系列特殊文件，用户可以通过这些文件：</p><ul><li><strong>查看系统有关（1）硬件及当前（2）正在运行进程</strong>的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。</li></ul><h4 id="2-Linux的软-硬链接是什么？有什么区别？">2. <strong>Linux的软/硬链接是什么？有什么区别</strong>？</h4><blockquote><p>参考：<a href="https://www.linuxprobe.com/soft-and-hard-links.html">“软链接”和“硬链接”的区别</a></p></blockquote><ul><li><p><strong>什么是链接</strong> ？</p><p>文件在Linux上被分成两部分：<strong>用户数据 (user data) 与元数据 (metadata)</strong> 。</p><ul><li><strong>用户数据</strong>：即文件数据块，保留记录文件真实内容的地方</li><li><strong>元数据</strong>：  是文件的附加属性，如创建大小、时间，所有信息等。其中<strong>inode号</strong> ，是文件的唯一标识。</li></ul><p>系统通过inode号快速找到文件，有一种方式可以<strong>快速寻找到数据元信息</strong>，那就是软/硬链接。</p><p>现在我们创建一个新文件<code>myfile</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch myfile &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;This is a plain text file.&quot;</span> &gt; myfile</span><br><span class="line">$ cat myfile</span><br><span class="line"></span><br><span class="line">This is a plain text file.</span><br></pre></td></tr></table></figure><p>来展示二者区别。</p></li><li><p><strong>硬链接</strong></p><p>建立 <code>myfile</code> 的一个硬链接 <code>hard</code> ，可以看到二者的<code>inode</code>  是一致的，也就是说<strong>指向了同一个物理区块</strong>。</p><blockquote><p>硬链接inode ：指向文件的地址 &amp; 维护了一个引用计数，只要有文件还指向这个区块，它就不会从硬盘消失。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ln myfile hard  <span class="comment"># 建立硬链接hard</span></span><br><span class="line">$ ls -li</span><br><span class="line"></span><br><span class="line">25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 hard</span><br><span class="line">25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 myfile</span><br></pre></td></tr></table></figure><ul><li><p><strong>操作硬链接更新文件，等价更新原文件</strong></p><p>使用hard硬链接修改文件，发现原文件也被修改了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;New line&quot;</span> &gt;&gt; hard</span><br><span class="line">$ cat myfile</span><br><span class="line"></span><br><span class="line">This is a plain text file.</span><br><span class="line">New line</span><br></pre></td></tr></table></figure></li><li><p><strong>删除原文件，使用硬链接依旧可以显示</strong></p><p>因为<strong>磁盘块还有硬链接在引用，所以不会消失</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rm myfile  <span class="comment"># 删除原文件</span></span><br><span class="line">$ cat hard   <span class="comment"># 硬链接依旧可以显示</span></span><br><span class="line"></span><br><span class="line">This is a plain text file.</span><br><span class="line">New line</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>软链接</strong></p><p>建立一个<code>soft</code>软链接如下，可以看到二者的inode号是不一样的。</p><blockquote><p>软连接的inode ：保存真实的文件的<strong>绝对路径地址</strong>，找到软链接，还<strong>要根据inode号找到真实文件路径</strong>。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s myfile soft <span class="comment"># 建立软连接soft</span></span><br><span class="line">$ ls -li</span><br><span class="line"></span><br><span class="line">25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 myfile</span><br><span class="line">25869216 lrwxr-xr-x 1 unixzii staff 6 7 8 17:47 soft -&gt; myfile</span><br></pre></td></tr></table></figure><ul><li><p><strong>操作软链接更新文件，等价更新原文件</strong></p><p>因为软链接就是相当个快捷方式，当然更新原文件。</p></li><li><p><strong>删除原文件，使用软链接不会显示</strong></p><p>因为软件inode指向的绝对地址，已经不存在文件了，所以当然不存在文件了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rm myfile</span><br><span class="line">$ cat soft</span><br><span class="line"></span><br><span class="line">cat: soft: No such file or directory</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>软硬连接区别总结</strong></p><ol><li><p><strong>inode号不同</strong>。硬链接原文件/链接文件公用一个inode号，说明他们是同一个文件，而软链接原文件/链接文件拥有不同的inode号，表明他们是两个不同的文件；</p></li><li><p><strong>链接数目不同</strong>。 软链接的链接数目不会增加；硬链接每多一个链接就会+1。</p></li><li><p><strong>文件大小不同</strong>。硬链接文件显示的大小是跟原文件是一样 ；软链接显示的大小与原文件就不同了，BBB大小是95B，而BBBsoft是3B，因为BBB共有3个字符。</p></li><li><p><strong>文件系统限制</strong>。 软链接没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。</p><blockquote><p><strong>建立软链接就是建立了一个新文件</strong>：当访问链接文件时，系统就会发现他是个链接文件，它读取链接文件找到真正要访问的文件。</p></blockquote></li></ol></li></ul><h3 id="3-查询日志的top10-IP">3. 查询日志的top10 IP?</h3><p>命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="built_in">log</span> | cut -d <span class="string">&#x27; &#x27;</span> -f 1 | sort | uniq -c | sort -nr | awk <span class="string">&#x27;&#123;print $0&#125;&#x27;</span> | head -n 10</span><br></pre></td></tr></table></figure><ol><li><p><code>cat *.log</code>  ：将文本内容打印到屏幕</p></li><li><p><code>cut</code>：截取指定IP那一列</p></li><li><p><code>sort </code>，按IP ASCII码排序：进行排序，默认是按照ascii码进行排序的</p></li><li><p><code>uniq -c  </code> ，统计重复的IP ：统计<strong>相邻的行</strong>的重复数量，结果是类似 <code>3 127.13.13.13</code> ，前面的数字代码重复的行数</p><p><code>sort|uniq -c</code>  统计重复的行数</p></li><li><p><code>sort -n</code>，再次排序 ：是按照数值进行由小到大进行排序， -r是表示逆序，-t是指定分割符，-k是执行按照第几列进行排序</p></li><li><p><code>awk</code> ，只显示IP：按照分割符将一行分割为多个列，第一列用1表示，第二列用​2表示，依次类推</p><p><code>awk -F&quot; &quot; '&#123;print $2&#125;</code>   ，表示用空格作为分隔符进行分割，打印出第2列</p></li><li><p><code>head -n ：</code>表示取前n个</p></li></ol><h2 id="2-2-Git">2.2 Git</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/96631135">讲git原理的的一篇不错文章</a></p></blockquote><h3 id="2-2-1-常问命令">2.2.1 常问命令</h3><h4 id="1-什么是Git？是用什么语言编写的？">1.什么是Git？是用什么语言编写的？</h4><ul><li>Git是一个 <u>分布式</u> <u>代码控制系统</u> ；</li><li>Git使用 C 语言编写：<u>使得 GIT 很快，C 语言减少运行时开销</u>来做到这一点。</li></ul><h4 id="2-如何在Git中创建存储库？">2.如何在Git中创建存储库？</h4><ol><li>如果项目不存在，创建</li><li>然后运行 <code>git init</code> ，会在目录下创建一个 <code>.git</code> 目录</li></ol><h4 id="3-列举工作中常用的几个git命令？">3.<strong>列举工作中常用的几个git命令</strong>？</h4><ul><li><code>git add</code> : 增加文件</li><li><code>git commit -m</code> ：提交文件</li><li><code>git status</code> ：拉取远程分支</li><li><code>git push</code> ：合并当前分支和主分支</li><li><code>git pull</code> OR <code>git fetch/git merge</code> ：拉取远程分支</li></ul><h4 id="4-讲讲Git-commit-基本参数？">4.<strong>讲讲Git commit 基本参数</strong>？</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/qianqiannian/p/6005628.html">https://www.cnblogs.com/qianqiannian/p/6005628.html</a></p></blockquote><ul><li><code>git commit -m “message”</code> ：简要说明这次提交的语句</li><li><code>git commit -a</code> ：即使没有经过 <code>git add</code> ，也可以将所有 <u>修改</u> 或 <u>删除</u> 的文件提交到本地仓库，<strong>但新建的文件不会提交</strong></li><li><code>git commit --amend</code> ：追加提交，它可以在<u>不增加一个新的commit-id</u> 的情况下将新修改的代码追加到前一次的commit-id中，</li></ul><h4 id="5-在Git中，你如何还原已经-push-并公开的提交？">5.<strong>在Git中，你如何还原已经 push 并公开的提交</strong>？</h4><ul><li><p>删除或修复新提交中的错误文件，并将其<strong>覆盖</strong>推送到远程存储库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;commit message&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>创建一个新的提交，<strong>撤消</strong>在错误提交中所做的所有更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;name of bad commit&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-git-pull-和-git-fetch-有什么区别？">6. <strong>git pull 和 git fetch 有什么区别</strong>？</h4><ul><li><p><code>git pull</code></p><p>取回远程主机某个分支的更新，<strong>再与本地的指定分支合并</strong> （可能要解决冲突）。</p></li><li><p><code>git fetch</code></p><p>从远程获取最新版本到本地，<strong>不会自动合并</strong> ，需要手动执行 <code>git merge</code></p></li></ul><h4 id="7-什么是-git-stash-你一般什么情况下会使用它？">7.<strong>什么是 git stash?你一般什么情况下会使用它</strong>？</h4><blockquote><p>经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是<code>git stash</code>命令。储藏(stash)可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用</p></blockquote><ul><li><strong>使用情况</strong>： 当前分支还没处理完，不能去commit提交，但是要去处理一个紧急开发项目，使用 <code>git stash</code></li><li>处理完后<code>git stash pop</code> 继续处理工作</li></ul><h4 id="8-如果本次提交误操作，如何撤销？">8.<strong>如果本次提交误操作，如何撤销</strong>？</h4><ul><li><p><strong>场景1</strong>:改乱了（包括删除等）工作区某个文件的内容（<code>git add 之前</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure><p>丢弃之前所有的修改。</p></li><li><p><strong>场景2</strong>:撤销提交到索引区的文件 （<code>git add 之后</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure><p>此时回到了场景1，然后再使用 <code>git checkout</code></p></li><li><p><strong>场景3</strong>： 撤销已经提交之后的文件（<code>git commit之后</code>）：</p><p>回退版本号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog  <span class="comment"># 查看版本</span></span><br><span class="line">$ git reset --hard  3928   <span class="comment"># 回退版本</span></span><br></pre></td></tr></table></figure></li><li><p><strong>场景4：</strong> 撤销已经push到远程分支之后的文件（<code>git push之后</code>）</p><ul><li><p>创建一个新的提交，<strong>撤消</strong>在错误提交中所做的所有更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;name of bad commit&gt;</span><br></pre></td></tr></table></figure></li><li><p>删除或修复新提交中的错误文件，并将其<strong>覆盖</strong>推送到远程存储库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;commit message&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="9-使用过git-merge和git-rebase吗？它们之间有什么区别？">9.<strong>使用过git merge和git rebase吗？它们之间有什么区别</strong>？</h4><p>都是用来合并分支的，但是：</p><ul><li><p><code>git merge &lt;当前分支要合并的分支&gt;</code> ： 在当前分支合并&lt;指定要合并的分支&gt;，会自动在当前分支（下图为master）创建一个commit节点，保留了要合并的分支（下图为branch1）的提交记录</p><p><img src="https://i.loli.net/2021/05/02/oLOVlIs7yNazKnJ.png" alt="preview"></p></li><li><p><code>git rebase &lt;当前分支变基的基点分支&gt;</code> ：相当将当前分支（下图为branch1）的分支节点（5,6） 依次提交到基点分支（master）的4节点之后，保留了更干净的历史记录，没有生成行的commit 节点</p><p><img src="https://i.loli.net/2021/05/02/ebDoLAUMSd13QRI.png" alt="image-20210502231023075"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 校招 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（一）_Java_JVM</title>
      <link href="/p/42516/"/>
      <url>/p/42516/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h2 id="1-6-JVM相关">1.6 JVM相关</h2><h3 id="1-6-1-常问问题">1.6.1 常问问题</h3><h4 id="1-（被问过）JVM启动的基本配置参数有哪些？（或者说调优参数）">1. （被问过）<strong>JVM启动的基本配置参数有哪些</strong>？（或者说调优参数）</h4><p><strong>「堆栈内存相关」</strong></p><ul><li><p>-Xms： 设置初始堆的大小</p></li><li><p>-Xmx： 设置最大堆的大小</p></li><li><p>-Xmn ：设置年轻代大小，相当于同时配置-XX:NewSize和-XX:MaxNewSize为一样的值</p></li><li><p>-Xss： 每个线程的堆栈大小</p></li><li><p>-XX:NewSize 设置年轻代大小(for 1.3/1.4)</p></li><li><p>-XX:MaxNewSize 年轻代最大值(for 1.3/1.4)</p></li><li><p>-XX:NewRatio 年轻代与年老代的比值(除去持久代)</p></li><li><p>-XX:SurvivorRatio Eden区与Survivor区的的比值</p></li><li><p>-XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。</p></li><li><p>-XX:MaxTenuringThreshold设定对象在Survivor复制的最大年龄阈值，超过阈值转移到老年代</p></li></ul><p><strong>「垃圾收集器相关」</strong></p><p>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。</p><ul><li><p>-XX:ParallelGCThreads=20：配置并行收集器的线程数</p></li><li><p>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。</p></li><li><p>-XX:CMSFullGCsBeforeCompaction=5 由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行5次GC以后对内存空间进行压缩、整理。</p></li><li><p>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</p></li></ul><p><strong>「辅助信息相关」</strong></p><ul><li><p>-XX:+PrintGCDetails 打印GC详细信息</p></li><li><p>-XX:+HeapDumpOnOutOfMemoryError让JVM在发生内存溢出的时候自动生成内存快照,排查问题用</p></li><li><p>-XX:+DisableExplicitGC禁止系统System.gc()，防止手动误触发FGC造成问题.</p></li><li><p>-XX:+PrintTLAB 查看TLAB空间的使用情况</p></li></ul><h4 id="2-说说堆和栈的区别？">2.<strong>说说堆和栈的区别</strong>？</h4><ol><li><p><strong>功能不同</strong>：栈内存用来存储<u>局部变量和方法调用</u>，而堆内存用<u>来存储Java中的对象</u>；</p><blockquote><p>注：无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p></blockquote></li><li><p><strong>共享性不同</strong>：栈内存是线程私有的； 堆内存是所有线程共有的；</p></li><li><p><strong>异常错误不同</strong>：如果栈内存或者堆内存不足，都会抛出异常但不同；</p><blockquote><p>栈空间不足：<code>java.lang.StackOverFlowError</code>。 堆空间不足：<code>java.lang.OutOfMemoryError</code>；</p></blockquote></li><li><p><strong>空间大小</strong>：栈的空间大小远远小于堆的。</p></li></ol><h4 id="3-【重点】请问JVM运行时内存布局分布？-哪些是线程共享的？">3.<strong>【重点】请问JVM运行时内存布局分布？ 哪些是线程共享的</strong>？</h4><p>从概念上大致分为 6 个（逻辑）区域，参考下图。注：Method Area 中还有一个常量池区，图中未明确标出。</p><ul><li>总的来看，JVM 把内存划分为<u>“栈(stack)”与“堆(heap)”</u>两大类</li></ul><p><img src="https://static001.infoq.cn/resource/image/dd/a9/dd614bf56417939aa0e0694fedf2caa9.png" alt="img"></p><p><u>线程私有的：</u></p><ul><li><p><strong>程序计数器</strong>：当同时进行的线程数超过CPU数或其内核数时，就要通过时间片轮询分派CPU的时间资源，不免发生线程切换。这时，<u>每个线程就需要一个属于自己的计数器来记录下一条要运行的指令</u>；</p></li><li><p><strong>虚拟机栈</strong>： <u>每个java方法执行时都会创建一个<strong>桢栈</strong></u>来存储方法的：</p><ul><li><p>变量表、操作数栈、动态链接方法、返回值、返回地址等信息；</p></li><li><p>栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法），“<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">栈帧参考</a>” ；</p></li></ul></li><li><p><strong>本地方法栈</strong>： 与虚拟机栈作用相似。但它不是为Java方法服务的，而是调用操作系统原生本地方法时，所需要的内存区域。</p><ul><li>本地方法被执行的时候，在本地方法栈也会创建⼀个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</li></ul></li></ul><p><u>线程共享的：</u></p><ul><li><p><strong>堆</strong>：GC 垃圾回收的主站场，用于<u>存放类的实例对象及 数组实例</u>等；</p><p><img src="https://i.loli.net/2021/05/05/6Ri9BzxGtLpFemP.png" alt="img"></p></li><li><p><strong>方法区</strong>： 线程共享的，用于存放被虚拟机加载的<strong>类的元数据信息</strong>：</p><ul><li>如 <u><strong>常量</strong>、<strong>静态变量</strong></u>和 <u> 即时<strong>编译器编译后的代码</strong></u><strong>；</strong></li><li><strong>运行时常量池：字符串</strong>，int -128~127 范围的值等，它是 <u>方法区</u> 中的一部分。</li></ul></li></ul><h5 id="3-1-JVM-堆中又怎么分的？为什么要这么划分？为什么要取消永久代用元空间代替？">3.1 JVM 堆中又怎么分的？为什么要这么划分？为什么要取消永久代用元空间代替？</h5><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/111809384">https://zhuanlan.zhihu.com/p/111809384</a></p></blockquote><ul><li><p><strong>堆划分</strong>：堆又被划分为，新生代，老年代。新生代又被划分为eden和survivor区。</p></li><li><p><strong>为什么划分新生代、老年代</strong>？</p><p>因为有的对象寿命长，有的对象寿命短。<strong>应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率</strong>。</p></li><li><p><strong>代替</strong>： 在java7版本前，堆和方法区连在了一起，但这并不能说堆和方法区是一起的，它们在逻辑上依旧是分开的。<strong>但在物理上来说，它们又是连续的一块内存</strong>。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210906224656302.png" alt="image-20210906224656302" style="zoom:50%;" /><p><strong>也就是说，方法区和前面讲到的Eden和老年代是连续的</strong>。</p><p><strong>永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集</strong>。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210906224744446.png" alt="image-20210906224744446" style="zoom:50%;" /><p>在Java8中，元空间(Metaspace)登上舞台，<strong>方法区存在于元空间(Metaspace)</strong>。同时，元空间不再与堆连续，<strong>而且是存在于本地内存（Native memory）。本地内存（Native memory），也称为C-Heap</strong>，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210906224848120.png" alt="image-20210906224848120" style="zoom:50%;" /><p><strong>元空间存在于本地内存，意味着只要本地内存足够，它不会出现像永久代中“java.lang.OutOfMemoryError: PermGen space”这种错误。看上图中的方法区，是不是“膨胀”了</strong>。</p></li></ul><h5 id="3-2-程序计数器存哪些东西？能为空吗？">3.2 <strong>程序计数器存哪些东西？能为空吗</strong>？</h5><p>程序计数器是用于存放下一条指令所在单元的地址的地方。</p><p>如果正在执行的是Native方法，这个计数器值为空（Ubdifined）。</p><h4 id="4-（新）说一下Java创建对象的过程？">4. （新）说一下Java创建对象的过程？</h4><p><img src="https://i.loli.net/2021/05/16/EBIujUDhkF9VRtg.png" alt="image-20210516205754856"></p><ol><li><p><strong>类加载检查</strong>： 虚拟机遇到⼀条 new 指令时，⾸先将去检查这个指令的参数是否能在<strong>常量池中定位到这个类的符号引用</strong>，并且检查这个符号引用代表的<strong>类是否已被加载过、解析和初始化过</strong>。如果没有，那必须先执行相应的类加载过程。</p></li><li><p><strong>分配内存</strong>： 在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把⼀块确定大小的内存从 <u>Java 堆中划分出来</u>。</p><blockquote><p><strong>（重要）分配方式有 “指针碰撞” 和 “空闲列表” 两种</strong>，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整⼜由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p><img src="https://i.loli.net/2021/05/16/S27KdREVrpGqt5I.png" alt="image-20210516210222497"></p></blockquote></li><li><p><strong>初始化对象字段零值</strong>。 内存分配完成后，进行对象初始化操作。</p><blockquote><p>例如给<strong>对象中（区分类加载过程，初始化类变量</strong>）所有的基本数据变量赋上初始化值， 当我们没有对它们进行赋值操作时就可以使用对象了。</p></blockquote></li><li><p><strong>设置对象头</strong>： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是<u>哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息</u>。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用<u>偏向锁</u>等，对象头会有不同的设置方式。</p></li><li><p><strong>执行init() &amp; 构造函数</strong>。然后执行对象内部生成的init方法，然后执行构造器方法（程序员设置的）。</p></li><li><p><strong>内存地址赋给引用</strong>： 在虚拟机会将刚创建好对象的内存地址赋给引用对象。完成此操作后，便可以在程序中通过引用访问对象的实例数据。</p></li></ol><h5 id="4-1-什么是指针碰撞？空闲列表？TLAB">4.1 什么是指针碰撞？空闲列表？TLAB?</h5><p>三种虚拟机<strong>划分堆内存</strong>区域的方法，TLAB也可用来给堆内存分配空间。</p><ul><li><p><strong>指针碰撞</strong></p><p>一般情况下，JVM的对象都放在堆内存中（发生逃逸分析除外）。当类加载检查通过后，Java虚拟机开始为新生对象分配内存。</p><ul><li>如果Java堆中内存是绝对规整的，所有被<strong>使用过的的内存都被放到一边，空闲的内存放到另外一边</strong>，中间放着一个<strong>指针作为分界点</strong>的指示器，<u>所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例</u>，这种分配方式就是指针碰撞。</li></ul></li><li><p><strong>空闲列表</strong></p><p><u>如果Java堆内存中的内存并不是规整的</u>，已被使用的内存和空闲的内存相互交错在一起，<u>不可以进行指针碰撞</u>。</p><ul><li>虚拟机必须维护一个列表，<strong>记录哪些内存是可用的</strong>，在分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表。</li></ul></li><li><p><strong>TLAB</strong></p><p>TLAB 是虚拟机在内存的<u><strong>eden 区</strong>划分出来的一块专用空间，是线程专属的</u>。 在启用TLAB 的情况下，当线程被创建时，虚拟机会为每个线程分配一块TLAB 空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提高分配效率。</p><blockquote><p>虚拟机通过 -XX:UseTLAB 设定它的。</p></blockquote></li></ul><h5 id="4-2-JVM如何保证对象分配的线程安全问题？">4.2 JVM如何保证对象分配的线程安全问题？</h5><p>因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>TLAB</strong>： 为<strong>每⼀个线程预先在Eden区分配⼀块⼉内存TLAB</strong>，JVM在<strong>给线程中的对象分配内存时，⾸先在TLAB分配</strong>，当<u>对象大于TLAB中的剩余内存或TLAB的内存已用尽时</u>，再采用的CAS进行内存分配。</li><li><strong>CAS+失败重试</strong>： CAS 是乐观锁的⼀种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为⽌。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li></ul><h4 id="5-描述一下对象分配【原则】？（区分前面new对象【过程】）">5.<strong>描述一下对象分配【原则】？（区分前面new对象【过程】</strong>）</h4><p>JVM 中的堆可划分为两大部分，<u>新生代和老年代</u>，大小比例为1:2：</p><ul><li>新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to 区</li></ul><p><img src="https://i.loli.net/2021/05/05/6Ri9BzxGtLpFemP.png" alt="img"></p><p>具体回收过程：</p><p><img src="https://i.loli.net/2021/04/19/p2LqRv6krQnbga4.png" alt="image-20210419224230046"></p><p>对象的正常流程：<em>Eden 区 -&gt; Survivor 区 -&gt; 老年代</em>。</p><ol><li>新的对象<strong>优先在 Eden 区分配</strong>（<em>大对象直接进入老年区，避免在Eden区及两个Survivor区之间发生大量的内存复制</em>） ,<strong>当 Eden 区没有足够空间时</strong>，会发起一次<em><strong>Minor GC</strong></em>；</li><li><em><strong>Minor GC</strong></em>采用<strong>复制回收算法</strong>的改进版本回收Eden中对象：<ul><li>先将Eden存活对象迁移到 to 区，然后清空Eden</li><li>最后交换to和from区域<strong>标签</strong></li></ul></li><li>每经过一次<em><strong>Minor GC</strong></em>  （在交换区）后对象年龄加1，对象年龄达到<em><strong>15次</strong></em>后将会晋升到老年代；</li><li>对象提前晋升到老年代，动态年龄判定：如果在 Survivor 区中相<u>同年龄所有对象大小总和大于 Survivor 区大小的一半</u>， 年龄大于或等于该年龄的对象就可以直接进入老年代；</li><li>老年代空间不够时进行<em><strong>Full GC</strong></em>。</li></ol><h5 id="5-1-对象一定分配到堆上吗？">5.1 对象一定分配到堆上吗？</h5><blockquote><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTQxOTc5NQ==&amp;mid=2650500024&amp;idx=1&amp;sn=0997c486387bf56bbe8ca909d55a7edf&amp;chksm=83c88c44b4bf05521d66f6a396550cd9c8379c3fdddee1ee198968f6a9ddd172550d3329a94d&amp;scene=21#wechat_redirect">面试官：是不是所有的对象和数组都会在堆内存分配空间</a></p></blockquote><blockquote><p>小伙，来给我讲一下是不是<strong>所有的对象和数组</strong>都会在堆内存分配空间？</p></blockquote><p>并不是，这涉及到<strong>对象逃逸</strong>。请看下面的代码：</p><p>StringBuffer对象，最终会被return，也就是<strong>会被该方法之外的给利用</strong>。 发生了对象逃逸。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/640" alt="图片"></p><p><strong>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识</strong>。 但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一<strong>个对象并没有逃逸出方法的话</strong>，那么就可能被<strong>优化成栈上分配</strong>。</p><h4 id="6-对象的访问定位有哪两种方式">6.<strong>对象的访问定位有哪两种方式</strong>?</h4><p>建⽴对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，⽬前主流的访问方式有：<strong>①使用句柄和 ②直接指针两种</strong>。</p><ol><li><p><strong>句柄</strong>： 如果使用句柄的话，那么Java堆中将会划分出⼀块内存来作为句柄池，reference 中存储的就是<strong>对象的句柄地址</strong>，而句柄中包含了<strong>对象实例数据</strong>与<strong>类型数据（存放在方法区</strong>）各⾃的具体地址信息；</p><blockquote><p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p></blockquote><p><img src="https://i.loli.net/2021/05/16/4XShu2w1nRbZl5x.png" alt="image-20210516211902118"></p></li><li><p><strong>直接指针</strong>： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，<strong>而reference 中存储的直接就是对象的地址</strong>。</p><blockquote><p>使用直接指针访问方式最大的好处就是速度快，它节省了⼀次指针定位的时间开销。</p></blockquote><p><img src="https://i.loli.net/2021/05/16/lTvrqnOFu5X9VJk.png" alt="image-20210516212141885"></p></li></ol><h4 id="7-如何判断对象是否需要回收（死亡）？">7.<strong>如何判断对象是否需要回收（死亡</strong>）？</h4><ul><li><strong>可达性分析</strong>：根据引用的关系构造引用链（有向图），在图中不可达的对象就是要被回收的；</li><li><strong>引用计数</strong>：有地方引用该对象，计数器++，引用失效，计数器–，有循环引用的问题。</li></ul><h4 id="8-如何判断一个常量是废弃变量？如何判断一个类是无用类？">8. 如何判断一个常量是废弃变量？如何判断一个类是无用类？</h4><ul><li><p><strong>判断常量是废弃变量</strong></p><p>运行时常量池主要回收的是废弃的常量。</p><p>假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量&quot;abc&quot; 就是废弃常量，如果这时发⽣内存回收的话而且有必要的话，“abc” 就会被系统清理出常量池。</p></li><li><p><strong>判断类是无用类</strong>？</p><p>虚拟机可以对满足下面3个条件的无用类进行回收，这⾥说的仅仅是“可以”，而并不是和对象⼀样不使用了就会必然被回收。</p><ul><li><p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例；</p></li><li><p>加载该类的 ClassLoader 已经被回收；</p></li><li><p>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ul></li></ul><h3 id="1-6-1-GC相关">1.6.1 GC相关</h3><blockquote><p>不错的GC介绍文章：<a href="https://www.infoq.cn/article/3wyretkqrhivtw4frmr3">一文看懂 JVM 内存布局及 GC 原理</a></p></blockquote><h4 id="1-请介绍GC基本原理？有什么优点？GC可以马上回收内存吗？如何主动让虚拟机回收？">1.<strong>请介绍GC基本原理？有什么优点？GC可以马上回收内存吗？如何主动让虚拟机回收</strong>？</h4><p>当程序员创建对象时，GC就开始监控这个对象的<u>地址、大小</u>及<u>使用情况</u> ，当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间 ：</p><ul><li><strong>基本原理</strong>： GC采用<u><strong>有向图</strong></u>的方式记录和管理<strong>堆(heap)<strong>中的所有对象 ，并确定对象</strong>是否“可达”</strong></li><li><strong>GC优点</strong>：（1）使得程序员不用考虑内存管理 （2）Java中的对象不再有&quot;作用域&quot;的概念，只有对象的引用才有&quot;作用域&quot; （3）有效防止内存泄漏</li><li><strong>马上回收</strong>： 程序员<strong>不能实时</strong>的调用垃圾回收器对某个对象或所有对象进行垃圾回收。</li><li><strong>主动回收</strong>： 手动执行<code>System.gc()</code> ，但是Java语言规范 <u>并不保证</u> GC一定会执行。</li></ul><h5 id="1-1-本地java程序默认启动的是什么垃圾回收器？">1.1 本地java程序默认启动的是什么垃圾回收器？</h5><p>cmd执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><p>输出：<a href="http://codewenda.com/xx%EF%BC%9Auseparallelgc%E5%92%8C-xx%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A-useparnewgc/">-XX：UseParallelGC</a>。</p><h4 id="2-什么是GC-Root？可以作为GC-Root的对象？">2.<strong>什么是GC Root？可以作为GC Root的对象</strong>？</h4><ul><li><p><strong>GC Root <strong>：  判断对象是通过可达性分析，所以所有的可达性算法</strong>都会有起点</strong> ，这就是 GC Root。</p><ul><li><strong>特点</strong>：当前时刻存活的对象！</li></ul><p>通过GC Root 找出所有活的对象，那么剩下所有的没有标记的对象就是需要回收的对象。</p><p><img src="https://pic1.zhimg.com/80/v2-38552a00d9bfb53f0c780e26a0d4b078_720w.jpg" alt="img"></p></li><li><p><strong>GC Root对象</strong>： （1）虚拟机栈中<strong>引用</strong>的<strong>对象</strong>；（2）方法区中的<strong>静态</strong>变量、<strong>常量</strong>对象；（3）本地方法<strong>引用</strong>的<strong>对象</strong>；（4）被<code>synchronized</code>修饰的对象等。</p></li></ul><h4 id="3-哪些内存区域需要GC">3.<strong>哪些内存区域需要GC?</strong></h4><ul><li><p><strong>（无需）线程独享区域</strong>：<code>PC Regiester、JVM Stack、Native Method Stack</code>，其生命周期都与线程相同（即：与线程共生死），所以无需 GC;</p></li><li><p><strong>（需）线程共享</strong>的 Heap 区、Method Area 则是 GC 关注的重点对象。</p></li></ul><p><img src="https://static001.infoq.cn/resource/image/e3/71/e36c624e8b4300775123f95a34b86571.png" alt="img"></p><h4 id="4-什么时候会触发Full-GC？">4.<strong>什么时候会触发Full GC？</strong></h4><ol><li><p><strong>调用 System.gc()</strong> ；</p></li><li><p><strong>老年代空间不足</strong>；</p></li><li><p><strong>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</strong>；</p><blockquote><p>如果发现<strong>统计之前Minor GC的平均晋升大小比目前old gen剩余的空间大</strong>，则不会触发Minor GC而是转为触发full GC。</p></blockquote></li><li><p><strong>方法区空间不足</strong>。</p><blockquote><p>JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中存放的为一些<u><strong>class的信息、常量、静态变量等数据</strong></u>，当系统中<strong>要加载的类、反射的类和调用的方法较多</strong>时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：<code>java.lang.OutOfMemoryError: PermGen space</code> 。<br>为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p></blockquote></li></ol><h4 id="5-什么时候触发-Minor-GC-什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？">5.<strong>什么时候触发 Minor GC ? 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢</strong>？</h4><ul><li><p><strong>什么时候触发Minor GC ?</strong></p><p><strong>当Eden区不足时</strong>就会触发 Minor GC 。</p></li><li><p><strong>minor gc运行频繁</strong></p></li></ul><ol><li><p>产生了太多朝生夕灭的对象导致需要频繁minor gc</p></li><li><p>新生代空间设置太小</p></li></ol><ul><li><p><strong>minor gc运行很慢</strong></p><ol><li><u>新生代空间设置过大</u>；</li><li><u>对象引用链较长</u>，进行可达性分析时间较长；</li><li><u>新生代survivor区设置的比较小</u>，清理后剩余的对象不能装进去需要移动到老年代，造成移动开销；</li><li><u>内存分配担保失败</u>，由minor gc转化为full gc；</li><li><u>采用的垃圾收集器效率较低</u>，比如新生代使用serial收集器。</li></ol></li></ul><h4 id="6-描述一下GC算法？">6.<strong>描述一下GC算法</strong>？</h4><p>GC算法包含：引用计数法，标记清除，标记复制，标记压缩。</p><ul><li><strong>引用计数</strong>：对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用；</li><li><strong>标记清除</strong>： 垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象；然后，在清除阶段，<u>清除所有未被标记的对象，<strong>但会产生很多垃圾碎片</strong></u> ；</li><li><strong>标记复制</strong>： 将内存对半分，总是<strong>保留一块空着</strong>（上图中的右侧），将左侧存活的对象（浅灰色区域）复制到右侧。<strong>避免了内存碎片问题，但是内存浪费很严重</strong>，<u>相当于只能使用 50%的内存</u>；</li><li><strong>标记压缩（标记整理</strong>）：标记过程仍然与<u>“标记-清除”</u>算法一样，但后续步骤<strong>不是直接对可回收对象进行清理</strong>，而是让<strong>所有存活的对象都向一端移动</strong>，然后<strong>直接清理掉端边界以外的内存</strong>（类似于 windows 的磁盘碎片整理），避免垃圾碎片。</li></ul><h5 id="6-1-新生代和老年代用哪些算法？stw问题会发生在新生代吗">6.1 <strong>新生代和老年代用哪些算法？stw问题会发生在新生代吗?</strong></h5><ul><li><p><strong>针对新生代，采用标记复制算法</strong></p><blockquote><p>参考：<a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">https://tech.meituan.com/2017/12/29/jvm-optimize.html</a></p></blockquote><p>大多数对象在新生代中被创建，其中很多对象的生命周期很短。<strong>每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活</strong>，所以选用复制算法，只需要<strong>少量的复制成本</strong>就可以完成回收。</p><p>HotSpot实现的<strong>复制算法流程</strong>如下:</p><ol><li>当Eden区满的时候,<strong>会触发第一次Minor gc，把还活着的对象拷贝到Survivor From区</strong>；当Eden区<strong>再次触发Minor gc</strong>的时候,会扫描Eden区和From区域，<strong>对两个区域进行垃圾回收,经过这次回收后还存活的对象,则直接复制到To区域</strong>,并将Eden和From区域清空。</li><li>当后续Eden又发生Minor gc的时候,会对<strong>Eden和To区域进行垃圾回收</strong>,存活的对象复制到From区域,并将Eden和To区域清空。</li><li>部分对象会在From和To区域中复制来复制去，<strong>如此交换15次</strong>(由JVM参数MaxTenuringThreshold决定,这个参数默认是15)，最终如果还是存活,就存入到老年代。</li></ol></li><li><p><strong>针对老年代对象存活率高的特点</strong></p><p>在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，<strong>该区域中对象存活率高</strong>。</p><p>老年代的垃圾回收（又称Major GC）通常使用<strong>标记-清理或标记-整理算法。整堆包括新生代和老年代的垃圾回收称为Full GC</strong>（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。</p></li></ul><h4 id="7-什么是Stop-The-World-什么是安全点？安全区域？">7.<strong>什么是Stop The World ?</strong> 什么是安全点？安全区域？</h4><ul><li><p><strong>Stop The World</strong></p><p>进行<strong>垃圾回收</strong>的过程中，<u>会<strong>涉及对象的移动。为了保证对象引用更新的正确性</strong>，必须暂停所有的用户线程</u>，像这样的停顿，虚拟机设计者形象描述为「Stop The World」。也简称为STW。JVM在暂停的时候，需要选准一个时机。</p><p>由于JVM系统运行期间的复杂性，不可能做到随时暂停，因此引入了<strong>安全点</strong>的概念。</p></li><li><p><strong>安全点</strong></p><blockquote><p>安全点，即程序（非GC先）执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。</p></blockquote><p>安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，<strong>Java虚拟机的堆栈不会发生变化</strong>。这么一来，<strong>垃圾回收器便能够“安全”地执行可达性分析</strong>。只要不离开这个安全点，Java虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。</p></li><li><p><strong>如何保证中断时所有线程都在安全点</strong></p><ul><li><p><strong>抢先式中断（Preemptive Suspension）</strong><br>抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，<strong>如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上</strong>。现在几乎没有虚拟机采用这种方式来暂停线程从而响应GC事件。</p></li><li><p><strong>主动式中断（Voluntary Suspension）</strong><br>主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。<strong>轮询标志的地方和安全点是重合的</strong>，另外再加上创建对象需要分配内存的地方。</p></li></ul></li></ul><h4 id="8-常见的垃圾回收器有哪些（比如G1）？">8. 常见的垃圾回收器有哪些（比如G1）？</h4><p><img src="https://i.loli.net/2021/05/16/ypmn6LRB5trC3Dl.png" alt="image-20210516215006746"></p><ul><li><p><strong>Serial收集器</strong>。 Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是⼀个单线程收集器了。它的<strong>单线程</strong> 的意义不仅仅意味着它只会使用⼀条垃圾收集线程去完成垃圾收集⼯作，更重要的是它在进行垃圾收集⼯作的时候必须<strong>暂停其他所有的⼯作线程（ “Stop The World”</strong>），直到它收集结束。</p></li><li><p><strong>ParNew收集器</strong>。 ParNew收集器其实就是<strong>Serial收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全⼀样。</p><ul><li>新⽣代采用<u><strong>标记-复制</strong>算法，⽼年代采用<strong>标记-整理</strong>算法</u>。</li></ul></li><li><p><strong>Parallel Scavenge收集器</strong>。 Parallel Scavenge 收集器类似于ParNew 收集器。 那么它有什么特别之处呢？ Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量。</p><blockquote><p>如果对于收集器运作不太了解的话，⼿⼯优化存在的话可以选择把内存管理优化交给虚拟机去完成也是⼀个不错的选择。-</p></blockquote><ul><li><u>新⽣代采用<strong>标记-复制</strong>算法，⽼年代采用<strong>标记-整理</strong>算法</u>。</li></ul></li><li><p><strong>（重点）CMS收集器。<strong>CMS（Concurrent Mark Sweep）收集器是一种以</strong>获取最短回收停顿时间</strong>为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以<code>并发</code>执行，以此来达到降低收集停顿时间的目的。</p><ul><li>CMS收集器仅作用于<strong>老年代</strong>的收集，基于 <u>“<strong>标记-清除</strong>”</u> 。</li><li><strong>优点</strong>： 并发收集、低停顿。</li><li><strong>缺点（快手</strong>）： CMS收集器<strong>对CPU资源非常敏感</strong>；CMS收集器<strong>无法处理浮动垃圾</strong>（Floating Garbage）。</li></ul></li><li><p><strong>（重点）G1收集器</strong>。 G1重新定义了堆空间，<strong>打破了原有的分代模型，将堆划分为一个个区域</strong>。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。区域划分的好处就是带来了<strong>停顿时间可预测的收集模型</strong>：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</p><ul><li><strong>并行与并发</strong>：G1能充分利⽤CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核⼼）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li><li><strong>分代收集</strong>：虽然G1可以不需要其他收集器配合就能独⽴管理整个GC堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与CMS的<u>“标记–清除”</u>算法不同，G1从整体来看是基于<strong>标记-整理</strong>算法实现的收集器；从局部上来看是<strong>基于<u>标记-复制</u>算法</strong>实现的。</li><li><strong>可预测的停顿</strong>：这是G1相对于CMS的另⼀个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建⽴可预测的停顿时间模型，能让使用者明确指定在⼀个⻓度为M毫秒的时间片段内。</li></ul></li></ul><h5 id="8-1-介绍一下CMS-和-G1-垃圾回收器原理？">8.1 介绍一下CMS 和 G1 垃圾回收器原理？</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/heyonggang/p/11718170.html">弄明白CMS和G1，就靠这一篇了</a></p></blockquote><ul><li><p><strong>CMS收集器</strong></p><p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的。</p><p>CMS收集器仅作用于老年代的收集，是基于<u>标记-清除</u>算法的，它的运作过程分为4个步骤：</p><ol><li><strong>初始标记（CMS initial mark） :</strong> 需要<strong>STW</strong>，标记一下GC Roots能<strong>直接</strong>关联到的对象 ；</li><li><strong>并发标记（CMS concurrent mark）</strong>：从GC Roots开始堆中对象进<strong>行可达性分析</strong>，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行；</li><li><strong>重新标记（CMS remark）</strong>：需要<strong>STW</strong> ，<strong>修正并发标记期间</strong>因用户程序继续运作而导致<strong>标记产生变动</strong>的那一部分对象的标记记录 ；</li><li><strong>并发清除（CMS concurrent sweep）</strong>： 清除对象。</li></ol></li><li><p><strong>G1收集器</strong></p><p>在堆的结构设计时，G1打破了以往将收集范围固定在新生代或老年代的模式，G1将堆分成许多<strong>相同大小</strong>的区域单元，每个单元称为<strong>Region</strong>。Region是一块地址连续的内存空间，G1模块的组成如下图所示：</p><blockquote><p>区域划分的好处就是带来了<strong>停顿时间可预测的收集模型</strong>：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</p></blockquote><p>和CMS挺像的。</p><ol><li>初始标记（Initial Marking）：仅仅只是标记一下GC Roots能<strong>直接关联</strong>到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</li><li>并发标记（Concurrent Marking）：是从GC Roots开始堆中对象进行<strong>可达性分</strong>析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</li><li>最终标记（Final Marking）：是为了修正并发标记期间因用户程序继续运作而导致<strong>标记产生变动</strong>的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</li><li><strong>筛选回收</strong>（Live Data Counting and Evacuation）：首先<strong>对各个Region的回收价值和成本进行排序</strong>，根据用户<strong>所期望的GC停顿时间来制定回收计划</strong>。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li></ol></li></ul><h5 id="8-2-为什么CMS不用标记-压缩算法？">8.2 为什么CMS不用标记-压缩算法？</h5><p>CMS主要关注<strong>低延迟</strong>，因而采用并发方式。</p><p>在<strong>并发清理垃圾</strong>时，如果采用压缩算法，这<strong>涉及到移动存活的对象。如果不进行停顿会很难处理</strong>，违背了CMS初衷，所以采用<strong>标记-清除</strong>算法。</p><h4 id="9-什么是内存泄漏？">9.<strong>什么是内存泄漏</strong>？</h4><p>广义并通俗的说，就是：<u>不再会被使用的<strong>对象</strong>的内存不能被回收</u>，就是内存泄漏。</p><p><strong>内存泄漏场景</strong>：</p><ul><li><p>静态集合类、数组<strong>添加对象以后遗漏了对于他们的处理</strong>，例如HashMap和Vector；</p></li><li><p>各种连接，如数据库连接、网络连接、IO连接；</p></li><li><p>单例模式；</p></li><li><p>变量不合理的作用域。</p></li></ul><h3 id="1-6-2-类加载">1.6.2 类加载</h3><h4 id="1-介绍一下类文件结构？">1. 介绍一下类文件结构？</h4><p>Class⽂件字节码结构组织示意图 。</p><p><img src="https://i.loli.net/2021/05/16/VkMjgwfFb9NGr2L.png" alt="image-20210516220600929"></p><ol><li><strong>魔数:</strong> 确定这个⽂件是否为⼀个能被虚拟机接收的 Class ⽂件。</li><li><strong>Class ⽂件版本</strong>：Class ⽂件的版本号，保证编译正常执行。</li><li><strong>常量池</strong> ：常量池主要存放两大常量：字面量和符号引用。</li><li><strong>访问标志</strong>：标志用于识别⼀些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</li><li><strong>当前类索引,⽗类索引</strong> ：类索引用于确定这个类的全限定名，⽗类索引用于确定这个类的⽗类的全限定名，由于 Java 语⾔的单继承，所以⽗类索引只有⼀个，除了 java.lang.Object 之外，所有的 java 类都有⽗类，因此除了 java.lang.Object 外，所有 Java 类的⽗类索引<br>都不为 0。</li><li><strong>接口索引集合</strong>：接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 implents (如果这个类本身是接口的话则是 extends ) 后的接口顺序从左到右排列在接口索引集合中。</li><li><strong>字段表集合</strong>：描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</li><li><strong>方法表集合</strong> ：类中的方法。</li><li><strong>属性表集合</strong>： 在 Class ⽂件，字段表，方法表中都可以携带⾃⼰的属性表集合。</li></ol><h4 id="2-什么是类加载器？请你解释一下java程序运行的过程？">2. 什么是类加载器？请你解释一下java程序运行的过程？</h4><blockquote><p>参考 ： <a href="https://cloud.tencent.com/developer/article/1350078">一个简单java程序的运行全过程</a></p></blockquote><p><u>类加载器是一个用来加载类文件的<strong>类</strong></u> 。</p><p>我们所说的类加载过程即是指<strong>JVM虚拟机把.class文件中类信息加载</strong>进内存。主要分为以下3大步、5小步：</p><p><img src="https://i.loli.net/2021/04/21/m1Ot3nQcMGq2YfW.jpg" alt="img"></p><ol><li><p><strong>编译</strong>。 将编译的<code>.java</code> 文件编译为<code>.class</code>字节码文件，然后交给JVM运行；</p></li><li><p><strong>加载</strong> ：class字节码文件从各个来源通过<strong>类加载器</strong>装载入<u>内存</u>中 。</p><blockquote><ul><li><strong>来源</strong>：包本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译</li><li><strong>类加载器</strong> ：一般包括<strong>启动类加载器</strong>，<strong>扩展类加载器</strong>，<strong>系统类加载器</strong>，以及用户的<u><strong>自定义类加载器</strong> （代码加密防止反编译）</u>。</li></ul></blockquote></li><li><p><strong>链接</strong>： 分为，验证、准备、解析（”正-中-准-心“）三阶段</p><ul><li><p><strong>验证</strong>： 保证加载进来的<u>字节流符合虚拟机规范</u>；</p><blockquote><p><strong>文件格式的验证</strong>，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</p><p><strong>元数据的验证</strong>，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</p><p><strong>字节码的验证</strong>，保证程序语义的合理性，比如要保证<u>类型转换的合理性</u>。</p><p><strong>符号引用的验证</strong>，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p></blockquote></li><li><p><strong>准备</strong>：类变量（<strong>注意，不是实例变量</strong> ）分配内存，并且赋予<strong>初值</strong>（虚拟机根据不同类型设定的初始值）；</p><blockquote><p>这些变量所使用的内存都将在<strong>方法区</strong>中进行分配 ，进行<strong>零初始化</strong>：</p><ul><li>即数字类型初始化为 0 ，boolean 初始化为 false，引用类型初始化为 null 等</li></ul></blockquote></li><li><p><strong>解析</strong>：将常量池内的 <u>符号引用</u> 替换为 <u>直接引用</u> 的过程。</p><blockquote><p><u>符号引用：</u>即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。<br><u>直接引用：</u>可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量。</p><p>🌾 实例： 调用方法hello()，方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。</p></blockquote></li></ul></li><li><p><strong>初始化</strong>。 初始化就是执行类的<code> cinit</code>()的过程。</p><blockquote><p>❔ 和准备阶段那个初始化看得我有点迷糊？</p><ul><li><strong>在编译阶段</strong>，编译器收集所有的<strong>静态字段的赋值语句及静态代码块</strong>，并按 <u>语句出现的顺序</u> 拼接出一个类初始化方法 <code>&lt;clinit&gt;()</code>。此时，执行引擎会调用这个方法对静态字段进行代码中编写的初始化操作。</li></ul></blockquote></li></ol><h4 id="3-知道类的生命周期吗？">3.<strong>知道类的生命周期吗</strong>？</h4><p><strong>在类加载的过程</strong>再加上：</p><ol start="4"><li><strong>使用</strong>。new出对象程序中使用</li><li><strong>卸载</strong>。执行垃圾回收</li></ol><h4 id="4-请你介绍一下类加载器？">4.<strong>请你介绍一下类加载器</strong>？</h4><img src="https://upload-images.jianshu.io/upload_images/7634245-7b7882e1f4ea5d7d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom:50%;" /><p>JVM预定义的三种类型类加载器：</p><ul><li><strong>启动类加载器（BootstrapClassLoader）</strong>：是一般用本地代码实现，负责将 <code>&lt;Java_Runtime_Home&gt;/lib</code>下面的类库加载到内存中；</li><li><strong>标准扩展类加载器（ExtensionClassLoader）</strong>：<code>&lt; Java_Runtime_Home &gt;/lib/ext</code>或者由系统变量 <code>java.ext.dir</code>指定位置中的类库加载到内存中；</li><li><strong>系统类加载器（AppClassLoader）</strong>：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从<u>环境变量或者系统属性<code>java.class.path</code></u>所指定的目录中加载类，是<strong>用户自定义加载器的默认父加载器</strong>。</li></ul><h4 id="5-请你介绍一下双亲委派机制？为什么要这么做？">5.<strong>请你介绍一下双亲委派机制？为什么要这么做</strong>？</h4><ul><li><p><strong>双亲委派机制</strong>。某个特定的类加载器在接到加载类的请求时，首先将加载任务<strong>委托给父类加载器</strong>，<strong>依次递归</strong>，如果父类加载器可以完成类加载任务，就成功返回；<strong>只有父类加载器无法完成此加载任务时，才自己去加载</strong>；</p></li><li><p><strong>为什么要这么做？防止内存中出现多份同样的字节码</strong> 。</p><blockquote><p>比如两个类A和类B都要加载System类：</p><ul><li>如果不用委托：而是自己加载自己的，那么类A就会加载一份System字节码，然后类B又会加载一份System字节码，<strong>这样内存中就出现了两份System字节码</strong>。</li><li>如果使用委托机制：会递归的向父类查找，也就是<strong>首选用Bootstrap尝试加载</strong>，如果找不到再向下。这里的System就能在Bootstrap中找到然后加载，如果此时类B也要加载System，也从Bootstrap开始，此时<strong>Bootstrap发现已经加载过了System那么直接返回内存中的System即可而不需要重新加载</strong>，这样内存中就只有一份System的字节码了。</li></ul></blockquote></li></ul><h5 id="5-1-如何自定义类加载器-，如何打破双亲委派机制-？">5.1 如何自定义类加载器 ，如何打破双亲委派机制 ？</h5><ul><li><p><strong>自定义类加载器 &amp; 打破双亲委派机制</strong></p><p>在实现自己的ClassLoader之前，我们先看一下JDK中的ClassLoader是怎么实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line"> <span class="number">2</span>     <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line"> <span class="number">3</span>     &#123;</span><br><span class="line"> <span class="number">4</span>     <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line"> <span class="number">5</span>     Class c = findLoadedClass(name);</span><br><span class="line"> <span class="number">6</span>     <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">7</span>         <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="number">8</span>         <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">9</span>             c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line"><span class="number">10</span>         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">11</span>             c = findBootstrapClass0(name);</span><br><span class="line"><span class="number">12</span>         &#125;</span><br><span class="line"><span class="number">13</span>         &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="number">14</span>             <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line"><span class="number">15</span>             <span class="comment">// to find the class.</span></span><br><span class="line"><span class="number">16</span>             c = findClass(name);</span><br><span class="line"><span class="number">17</span>         &#125;</span><br><span class="line"><span class="number">18</span>     &#125;</span><br><span class="line"><span class="number">19</span>     <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line"><span class="number">20</span>         resolveClass(c);</span><br><span class="line"><span class="number">21</span>     &#125;</span><br><span class="line"><span class="number">22</span>     <span class="keyword">return</span> c;</span><br><span class="line"><span class="number">23</span>     &#125;</span><br></pre></td></tr></table></figure><p>1、<strong>如果不想打破双亲委派模型，那么只需要重写findClass方法即可</strong></p><p><strong>（1）继承ClassLoader</strong></p><p><strong>（2）重写findClass()方法</strong></p><p>2、<strong>如果想打破双亲委派模型，那么就重写整个loadClass方法</strong></p><p><strong>（1）继承ClassLoader</strong></p><p><strong>（2）重写findClass()方法</strong>6</p><p><strong>（3）调用defineClass()方法</strong></p></li><li><p><strong>tomcat 为什么要违背双亲委托机制</strong>？</p><ol><li>双亲委托机制不能满足tomcat的业务需求；</li><li>Webapp类加载器需要独立加载自身的class以及依赖的jar；</li><li>例如，<strong>webapp1</strong>依赖的spring版本为4.x，另一个<strong>webapp2</strong>依赖的spring版本为5.x. 如果使用双亲委托，那么spring的版本只能存在一个，没法满足这个需求。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（一）_Java_锁</title>
      <link href="/p/45493/"/>
      <url>/p/45493/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h2 id="1-5-锁">1.5 锁</h2><h4 id="【新增】-java常用的并发工具类？">【新增】 java常用的并发工具类？</h4><blockquote><p>这篇不错：<a href="https://zhuanlan.zhihu.com/p/163654320">《今天面试了吗》- 并发编程之AQS同步工具类</a></p></blockquote><p>JUC就是java.util.concurrent包，这个包俗称JUC，里面都是<strong>解决并发问题</strong>。</p><p>常用四大并发工具包（以下都是基于<strong>AQS</strong>实现的）：</p><ol><li><p><strong>CountDownLatch</strong>： CyclicBarrier描述的是“允许一组线程相互等待，直到<strong>到达某个公共屏障点</strong>，才会进行后续任务”。</p><p>而<strong>CountDownLatch</strong>所描述的是“在<strong>完成一组正在其他线程中</strong>执行的操作之前，它允 一个或多个线程一直等待”。</p><p>在API中是这样描述的：用给定的计数初始CountDownLatch。由于调用了countDown方法，所以在当前计数到达零之前，await方法会一直受阻塞。之后，会释放所有等待的线程，await的所有后续调用都将立即返回。这种现象只出现一次（计数无法被重置。如果需要重置计数，请考虑使CyclicBarrier）。</p></li><li><p><strong>CyclicBarrier</strong>：CyclicBarrier是一个同步辅助类。它允许<strong>一组线程互相等待</strong>，<strong>直到到达某个公共屏障点</strong>。在涉及一组固定大小的线程的程序里，这些线程必须不时的互相等待，此时CyclicBarrier 很有用。因为CyclicBarrier在释放等待线程后可以重用，因此成为循环的屏障。</p><blockquote><p>使用**await()**方法，每个线程调用await()方法告诉CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。当所有线程都到达了屏障，结束阻塞，所有线程可继续执行后续逻辑。</p></blockquote></li><li><p><strong>Semaphore</strong>：信号量Semaphore是一个控制访问<strong>多个共享资源的计数器</strong>，和CountDownLatch一样，其本质上是一个“共享锁”。在API是这么介绍信号量的：一个计数信号量，从概念上讲，信号量维护了一个许可集。</p></li><li><p><strong>ExChanger</strong> ：Exchanger是一个同步器，字面上就可以看出这个类的主要作用是交换数据。Exchanger有点<strong>类似CyclicBarrier</strong>，前面说到CyclicBarrier是一个栅栏，到达栅栏的 线程需要等待一定数量的线程到达后，才能通过栅栏。Exchanger可以看成是一个双向的栅栏。线程1到达栅栏后，会首先观察有没有其他线程已经到达栅栏，如果没有就会等待。如果已经有其他线程（比如线程2）到达了，就会<strong>以成对的方式交换各自携带的信息</strong>，因此Exchanger非常适合<strong>两个线程</strong>之间的<strong>数据交换</strong>。</p></li></ol><h4 id="1-5-1-synchronized-相关">1.5.1 synchronized 相关</h4><h5 id="1-1-重点-说一说自己对于-synchronized-关键字的了解-synchronized-底层原理">1.1 [重点]<strong>说一说自己对于 synchronized 关键字的了解? synchronized 底层原理</strong> ?</h5><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/356010805">Java面试常见问题：Monitor对象是什么？</a></p><p><a href="https://www.cnblogs.com/aspirant/p/11470858.html">深入分析Synchronized原理(阿里面试题)</a></p></blockquote><ul><li><p><strong>基本了解</strong></p><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><ul><li>synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是<strong>依赖于底层的操作系统的<u>Mutex Lock</u></strong> 来实现的；</li><li>Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，<strong>而操作系统实现线程之间的切换</strong>时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。</li></ul></li><li><p><strong>moniter介绍</strong></p><blockquote><p><strong>Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用</strong>。</p></blockquote><p>在HotSpot虚拟机中，Monitor是基于C++的<strong>ObjectMonitor类</strong>实现的，其主要成员包括：</p><ul><li>_owner：指向持有ObjectMonitor对象的线程</li><li>_WaitSet：存放处于wait状态的线程队列，即调用wait()方法的线程</li><li>EntryList：存放处于等待锁block状态的线程队列</li><li>_count：约为_WaitSet 和 _EntryList 的节点数之和</li><li>_cxq: 多个线程争抢锁，会先存入这个单向链表</li><li>_recursions: 记录重入次数</li></ul></li><li><p><strong>底层原理</strong></p><p>synchronized 关键字底层原理属于 JVM 层面。</p><p><strong>① synchronized同步语句块的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 JDK ⾃带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：</p><ul><li><p>⾸先切换到类的对应⽬录执行 javac SynchronizedDemo.java 命令⽣成编译后的 .class ⽂件，然后执行 <code>javap -c -s-v -l SynchronizedDemo.class</code></p></li><li><p><img src="https://i.loli.net/2021/05/16/DTSB86Z2GcRy9XC.png" alt="image-20210516130259067"></p></li></ul><p><strong>synchronized</strong>同步语句块的实现使用的是monitorenter和 monitorexit指令，其中<strong>monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置</strong>。</p><ol><li><p>当执行monitorenter 指令时，线程试图获取锁也就是获取 monitor的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1 ;</p><blockquote><p>monitor对象存在于每个Java对象的对象头中 synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因。</p></blockquote></li><li><p>相应的在执行monitorexit 指令后，<strong>将锁计数器设为0</strong>，表明锁被释放；</p></li><li><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外⼀个线程释放为⽌。</p></li></ol></li></ul><p><strong>② synchronized修饰方法的的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/16/oElScfCHI978Qtw.png" alt="image-20210516131938787"></p><ul><li><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是<code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是⼀个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问。</p><blockquote><p>当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。<strong>在方法执行期间，其他任何线程都无法再获得同一个monitor对象</strong>。</p></blockquote><p>两种同步方式<strong>本质上没有区别</strong>，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。两个指令的执行是JVM通过调用操作系统的<strong>互斥原语mutex</strong>来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p></li></ul><h5 id="1-2-请你谈谈关于Synchronized和ReentrantLock？">1.2 <strong>请你谈谈关于Synchronized和ReentrantLock？</strong></h5><ul><li><p><strong>相似点</strong></p><ul><li><p><strong>都是阻塞式同步</strong>：一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待；</p><blockquote><p>线程阻塞和唤醒的代价是比较高的（操作系统需要在用户态与内核态之间来回切换，代价很高，不过可以通过对锁优化进行改善）。</p></blockquote></li><li><p><strong>都是可重入锁</strong>：是同一个线程可重复获得锁，每获得一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p></li></ul></li><li><p><strong>不同点</strong></p><ul><li><p><strong>实现原理</strong>： Synchronized是java语言的关键字，是原生语法层面的互斥， JVM 层面；ReentrantLock是JDK 1.5后的API层面的互斥锁，需要<u>lock()和unlock()方法配合try/finally语句块来完成</u>；</p><blockquote><p><img src="https://i.loli.net/2021/04/28/tSoiYbRl5kdA9my.png" alt="image-20210428222639476"></p></blockquote></li><li><p><strong>是否避免死锁</strong>： synchronized<strong>在发生异常时</strong>，会自动释放线程占有的锁，<strong>因此不会导致死锁现象</strong>发生；Lock不会主动适应 <code>unLock()</code> 释放，必须手动在f<code>inally</code>释放；相⽐synchronized，ReentrantLock增加了⼀些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</p></li><li><p><u><strong>线程等待可中断</strong>：</u> Lock可以让等待锁的线程响应中断，线程可以中断去干别的事务；而synchronized却不行，使用synchronized时，等待的线程会一直等待下去；</p></li><li><p><strong>公平锁</strong>： synchronized的锁是非公平锁，ReentrantLock默认情况下也是非公平锁，但可以通过带布尔值的构造函数要求使用公平锁；</p><ul><li><strong>选择性通知</strong>： synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。<br>Condition是JDK1.5之后才有的，它具有很好的灵活性，⽐如可以实现多路通知功能也就是在⼀个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使⽤notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，⽤ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有⼀个Condition实例，所有的线程都注册在它⼀个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，<u>而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程</u>。</li></ul></li></ul></li></ul><h5 id="1-3-synchronized锁住的是什么，在项目中遇到了吗？">1.3 <strong>synchronized锁住的是什么，在项目中遇到了吗</strong>？</h5><p>synchronized本身并不是锁，锁本身是一个对象，synchronized最多相当于“加锁”操作，所以synchronized并不是锁住代码块。</p><p>（<strong>重点</strong>）Java中的每一个对象都可以作为锁，具体表示有三种形式：</p><p><img src="https://i.loli.net/2021/05/04/LzjeqdIi5rbM819.png" alt="image-20210504232344320"></p><blockquote><p>面试中面试官经常会说：“单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁方式实现单例模式的原理呗！”</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton       <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码</span></span><br><span class="line">       <span class="keyword">if</span> (uniqueInstance WX <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//类对象加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance WX <span class="keyword">null</span>) &#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure><p>这段代码其实是分为三步执行：</p><ol><li><p>为 uniqueInstance 分配内存空间</p></li><li><p>初始化 uniqueInstance</p></li><li><p>将 uniqueInstance 指向分配的内存地址</p></li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致⼀个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回uniqueInstance，<u>但此时 uniqueInstance 还未被初始化</u>。</p><h5 id="1-4-synchronized锁的优化机制了解吗？">1.4 <strong>synchronized锁的优化机制了解吗</strong>？</h5><blockquote><p>参考：<a href="https://juejin.cn/post/6844903726545633287">死磕Synchronized底层实现</a></p><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html">美团技术团队</a></p></blockquote><p>synchronized本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括：</p><ul><li>自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁；</li><li>锁的状态从低到高依次为：<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong>。</li></ul><p><img src="https://i.loli.net/2021/05/16/PjXkchreF9sSEKG.png" alt="image-20210516131559341"></p><p>常见的锁：</p><ul><li><p><strong>无锁</strong>：无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，<strong>但同时只有一个线程能修改成功</strong>。</p><blockquote><p>锁到底存在哪里呢？答案就是对象头中。</p><p>对象头主要又包括了两部分数据：Mark Word（标记字段）、Class Point（类型指针）。</p></blockquote><ol start="0"><li><p>初始mark word 将是可偏向状态，此时的 <u>是否偏向锁</u> 为 0，表示当前没有任何一个线程持有该锁。</p><p><img src="https://i.loli.net/2021/05/21/bNepQwU6scYXCv5.png" alt="image-20210521210754337"></p></li></ol></li><li><p><strong>偏向锁</strong>：在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><blockquote><p>JDK1.6 中为了提高一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能，引入了偏向锁。在<strong>第一次</strong>获得锁时，会有一个 CAS 操作（见下）；<strong>之后</strong>该线程再获取锁，只会执行几个简单的命令，而不是开销相对较大的 CAS 命令。</p></blockquote><ol><li><p><strong>CASE 1 :</strong> 线程<strong>第一次</strong>获得锁，如果<strong>未偏向</strong>，通过 <strong>CAS</strong> 指令：</p><p><img src="https://i.loli.net/2021/05/21/fwEX4OAMFnyWrbJ.png" alt="image-20210521210949942"></p><ul><li><strong>插入线程ID :</strong> 向mark word插入线程ID</li><li><strong>偏向锁标识</strong>：将 mark word 中的偏向锁标识从<code>0→1</code></li><li><s><strong>锁标志位</strong>：不修改！因为不变！</s></li></ul><p>如果操作成功：，则说明获得了偏向锁，以后当前<u>线程等于owner</u>就可以<strong>零成本</strong>的直接获得锁；</p><p>如果操作失败，说明有其它线程获取了锁：</p><ul><li><strong>如果偏向线程还存在</strong>：直接进行升级为轻量级锁；</li><li><strong>如果偏向线程不存在：先修改锁标识为01→00</strong> ，再升级为轻量级锁。</li></ul></li><li><p><strong>CASE 2 :</strong>  这是<strong>一次可重入</strong>，偏向线程是自己。</p><p>在<u>当前线程栈</u>中找到一个可用的 <strong>Lock Record</strong> <strong>：并将其 obj 指向锁对象 &amp; Displaced Mark Word 置为null</strong></p><img src="https://i.loli.net/2021/05/18/LXj2NZi7fVOzpox.png" alt="img" style="zoom:50%;" /></li></ol></li><li><p><strong>轻量级锁</strong>：当发现多线程竞争时，偏向锁会升级为轻量级锁，一般来说，会在 safepoint（此时用户代码不会执行）中去查看<u>偏向的线程是否还存活</u>。</p><p><img src="https://i.loli.net/2021/05/18/anN1S6AD7MI9gK8.jpg" alt="img"></p><ol><li>如果偏向的线程已经不存活或者不在同步块中，则将对象头的 mark word 改为无锁状态（unlocked），<strong>重新偏向新的线程</strong>；</li><li>如果存活且还在<strong>同步块</strong>中，原偏向的线程继续拥有锁，当前线程则走入到轻量级锁的加锁逻辑中；</li></ol><p>轻量级锁的处理流程 ：</p><ol start="3"><li>发现已经有偏向的线程了，则会<strong>先 撤 销偏向锁，然后升级为轻量锁</strong> 。通过<strong>CAS命令更新</strong>：</li></ol><p><img src="https://i.loli.net/2021/06/02/BMyh36f2OPCGkKe.png" alt="image-20210602161303534"></p><ul><li><p><strong>修改此前 <u>当前线程栈帧Lock Record</u>：</strong> （1）Displaced Mark Word 复制 mark word （此时<strong>无锁</strong>状态）中的现有内容</p></li><li><p><strong>修改mark word <strong>：<u>mark word 指向</strong>当前线程栈帧Lock Record的</strong> <strong>Displaced Mark Word</strong>的地址</u>，见上图；</p></li><li><p><strong>修改锁标志位</strong>： <code>01 → 00</code></p><p><img src="https://i.loli.net/2021/05/21/QNDEreAK6Ulohvg.png" alt="image-20210521214141329"></p></li></ul><ol start="4"><li><p>上述CAS更新成功，则<strong>当前线程获得了对象的锁</strong>  ；</p><p>如果不成功：</p><ul><li><p>检查Mark Word是否指向当前线程的栈帧的Lock Record ，是则是一次<strong>可重入</strong></p><blockquote><p>设置<code>Lock Record</code>第一部分（<code>Displaced Mark Word</code>）为null，起到了一个重入计数器的作用。然后结束。</p></blockquote></li><li><p>如果不是则是进行<strong>自旋等待</strong></p></li></ul></li><li><p>当<strong>1.自旋超过一定的次数</strong>（默认10），或者<strong>2.一个线程在持有锁，一个在自旋，又有第三个来访时</strong>，轻量级锁升级为重量级锁。</p></li></ol></li><li><p><strong>重量级锁</strong>：内置锁在Java中被抽象为<strong>监视器锁（monitor）</strong>。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种<strong>同步方式的成本非常高</strong>，<u>包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等</u>。</p><blockquote><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。<strong>每一个Java对象就有一把看不见的锁Monitor</strong>，称为内部锁或者Monitor锁。</p><p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个<strong>Owner</strong>字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p></blockquote><p>如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。<u>线程去获取重量级锁，其实就是就尝试获取对象的monitor锁。</u></p><blockquote><p>即将 monitor锁的 <strong>Owner字段修改为当前线程ID</strong> 。</p></blockquote><p>如果获取成功，此时线程获得了锁，<strong>CAS修改</strong> ：</p><ol start="2"><li><p><strong>修改mark word</strong> ：然后将对象头mark word 改为<strong>指向该 monitor 的指针</strong>。</p></li><li><p><strong>锁标志位</strong>：<code>00 → 10</code></p><p><img src="https://i.loli.net/2021/05/21/NLFv3fKIh14RlzY.png" alt="image-20210521214213205"></p></li></ol></li></ul><h5 id="1-5-为什么说Synchronized是非公平锁，这样的优缺点是什么？">1.5 <strong>为什么说Synchronized是非公平锁，这样的优缺点是什么</strong>？</h5><p>并非是按照申请锁的时间前后给等待线程分配锁的，<strong>每当锁被释放后，任何一个线程都有机会竞争到锁</strong>。</p><ul><li><strong>优点</strong>：这样做的目的是为了提高执行性能；</li><li><strong>缺点</strong>：是可能产生线程饥饿现象。</li></ul><h5 id="1-6-为什么说synchronized是一个悲观锁？乐观锁的实现原理又是什么？">1.6 <strong>为什么说synchronized是一个悲观锁？乐观锁的实现原理又是什么</strong>？</h5><blockquote><p>没看完，了解了下核心问题：<a href="https://www.cnblogs.com/jojop/p/14022029.html">https://www.cnblogs.com/jojop/p/14022029.html</a></p></blockquote><ul><li><p><strong>synchronized悲观锁</strong></p><p>Synchronized显然是一个悲观锁，因为它的并发策略是悲观的：</p><ul><li><strong>不管是否会产生竞争，任何的数据都必须加锁</strong>。</li></ul></li><li><p><strong>synchronized原理</strong></p><p>Synchronized是通过<strong>获取对象内部的一个叫做监视器锁（monitor</strong>）来实现的，每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权。</p><blockquote><p>监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。</p></blockquote><ol><li><p>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</p></li><li><p>如果线程已经占有该monitor，<u>只是重新进入</u>，则进入monitor的进入数加1；</p></li><li><p>如果<u>其他线程已经占用了monitor，则该线程进入阻塞状态</u>，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p></li></ol></li><li><p><strong>乐观锁实现原理：CAS</strong></p><blockquote><p>参考好文：<a href="https://zhuanlan.zhihu.com/p/94762520">一文彻底搞懂CAS实现原理</a></p></blockquote></li></ul><h5 id="1-7-（CAS原理重点）什么是CAS？CAS的缺点？说说CAS源码实现？">1.7 （CAS原理重点）什么是CAS？CAS的缺点？说说CAS源码实现？</h5><p>乐观锁的核心算法是CAS（Compared And Swap，比较并交换）：</p><ul><li><p><strong>关键逻辑</strong>： CAS，有几个重要的参数：</p><p>（1）<strong>this</strong>，Unsafe 对象本身，需要通过这个类来获取 value 的内存偏移地址。</p><p>（2）<strong>valueOffset</strong>，value 变量的内存偏移地址。</p><p>（3）<strong>expect</strong>，期望更新的值。</p><p>（4）<strong>update</strong>，要更新的最新值。</p><p>如果原子变量中的 <strong>value 值等于 expect</strong>，则使用 update 值更新该值并返回 true，否则返回 false。</p></li><li><p><strong>CAS特性</strong>： CAS具有原子性，它的原子性由CPU硬件指令实现保证。</p><ul><li>【<strong>缺点1</strong>】<strong>ABA问题</strong>：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。<ul><li><strong>解决ABA：</strong> 在变量前面加上版本号，每次变量更新的时候变量的<strong>版本号都<code>+1</code></strong>，即<code>A-&gt;B-&gt;A</code>就变成了<code>1A-&gt;2B-&gt;3A</code></li></ul></li><li>【<strong>缺点2】只能保证一个共享变量的原子操作</strong>：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</li><li>【<strong>缺点3</strong>】<strong>循环时间长开销大</strong>：对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li></ul></li><li><p><strong>CAS源码分析</strong></p><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000014858404?utm_source=sf-similar-article">Java CAS 原理分析</a></p></blockquote><blockquote><p>CAS 全称是 compare and swap，是一种用于在<strong>多线程环境下实现同步</strong>功能的机制。</p></blockquote><p>CAS 操作包含三个操作数 – 内存位置、预期数值和新值。CAS 的实现逻辑是将内存位置处的数值与预期数值想比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。</p><p>Java 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的，下面是具体分析。</p><ul><li><p><strong>背景介绍</strong></p><p>在多核心时代下，<strong>多个核心通过同一条总线和内存以及其他硬件进行通信</strong>。</p><p><img src="https://segmentfault.com/img/remote/1460000014858409?w=1598&amp;h=710" alt="img"></p><p><strong>CPU 的多个核心同时对同一片内存进行操作</strong>，会导致错误。例如，递增指令<code>inc dword ptr [...]</code>，等价于<code>DEST = DEST + 1</code>。该指令包含三个操作<code>读-&gt;改-&gt;写</code>，涉及两次访存。</p><ol><li>核心1,2从内存读取数据<code>1</code>，并写到各自寄存器中</li><li>核心1将寄存器中数据<code>1→2</code></li><li>核心2将寄存器中数据<code>1→2</code></li><li>然后都写回主存，此时为<code>2</code></li></ol><p>可以看到，由于核心2在核心1<strong>写入主存操作完成前进行读取</strong>，导致并不是我们期望的<code>3</code> 。</p><p>通过在递增<code>inc</code> 指令前添加 lock 前缀，可以让核心独占某个内存区域，由此可以避免上面问题。lock 前缀保证核心独占某片内存区域，有两种方式：</p><ol><li><strong>总线锁</strong>。总线被锁定后，其他核心就不能访问内存了，可能会导致其他核心短时内停止工作；</li><li><strong>缓存锁</strong>。若<strong>某处</strong>内存数据被缓存在处理器缓存中，处理器发出的 LOCK# 信号不会锁定总线，而是<strong>锁定缓存对应的内存区域</strong>。其他处理器在这片内存区域锁定期间，无法对这片内存区域进行相关操作。（<strong>不是乐观机制都可以操作吗？不能写入内存</strong>？）</li></ol></li><li><p><strong>源码分析</strong></p><blockquote><p>我们分析，<code>java.util.concurrent.atomic</code> 包下的原子类 <code>AtomicInteger</code> 中的 <code>compareAndSet</code> 方法 。</p></blockquote><ol><li><p>AtomicInteger具体实现中，compareAndSet 实际上只是一个壳子，主要的逻辑封装在 Unsafe 的 compareAndSwapInt 方法中；</p></li><li><p>compareAndSwapInt是一个native方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,<span class="keyword">int</span> expected,<span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 计算变量 value 在类对象中的偏移</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * compareAndSet 实际上只是一个壳子，主要的逻辑封装在 Unsafe的compareAndSwapInt 方法中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    <span class="comment">// compareAndSwapInt 是 native 类型的方法，继续往下看</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们进入unsafe.cpp（compareAndSwapInt是native方法）具体实现中，看看调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unsafe.cpp</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个看起来好像不像一个函数，不过不用担心，不是重点。UNSAFE_ENTRY 和 UNSAFE_END 都是宏，</span></span><br><span class="line"><span class="comment"> * 在预编译期间会被替换成真正的代码。下面的 jboolean、jlong 和 jint 等是一些类型定义（typedef）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);</span><br><span class="line">  <span class="comment">// 根据偏移量，计算 value 的地址。这里的 offset 就是 AtomaicInteger 中的 valueOffset</span></span><br><span class="line">  jint* addr = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>(p, offset);</span><br><span class="line">  <span class="comment">// 调用 Atomic 中的函数 cmpxchg，该函数声明于 Atomic.hpp 中</span></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::<span class="built_in">cmpxchg</span>(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br><span class="line"></span><br><span class="line"><span class="comment">// atomic.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">Atomic::cmpxchg</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> exchange_value, <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>* dest, <span class="keyword">unsigned</span> <span class="keyword">int</span> compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) == <span class="built_in"><span class="keyword">sizeof</span></span>(jint), <span class="string">&quot;more work to do&quot;</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载</span></span><br><span class="line"><span class="comment">   * 接下来分析 atomic_windows_x86.inline.hpp 中的 cmpxchg 函数实现</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)Atomic::<span class="built_in">cmpxchg</span>((jint)exchange_value, (<span class="keyword">volatile</span> jint*)dest,</span><br><span class="line">                                       (jint)compare_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析 Windows 平台下的 Atomic::cmpxchg 函数为例，看看具体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// atomic_windows_x86.inline.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) __asm cmp mp, 0  \</span></span><br><span class="line"><span class="meta">                       __asm je L0      \</span></span><br><span class="line"><span class="meta">                       __asm _emit 0xF0 \</span></span><br><span class="line"><span class="meta">                       __asm L0:</span></span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">inline</span> jint <span class="title">Atomic::cmpxchg</span> <span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否是多核 CPU</span></span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    <span class="comment">// 将参数值放入寄存器中</span></span><br><span class="line">    mov edx, dest  <span class="comment">// 注意: dest 是指针类型，这里是把内存地址存入 edx 寄存器中</span></span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, <span class="function">compare_value</span></span><br><span class="line"><span class="function">    <span class="title">LOCK_IF_MP</span><span class="params">(mp)</span>  <span class="comment">// 核心比较写入操作</span></span></span><br><span class="line"><span class="function">    cmpxchg dword ptr [edx], ecx</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>其中LOCK_IF_MP实际内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// LOCK_IF_MP</span></span><br><span class="line">    cmp mp, <span class="number">0</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 mp = 0，表明是线程运行在单核 CPU 环境下。此时 je 会跳转到 L0 标记处，</span></span><br><span class="line"><span class="comment">     * 也就是越过 _emit 0xF0 指令，直接执行 cmpxchg 指令。也就是不在下面的 cmpxchg 指令前加 lock 前缀。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    je L0</span><br><span class="line">     <span class="comment">/* 0xF0 是 lock 前缀的机器码，这里没有使用 lock，而是直接使用了机器码的形式。*/</span></span><br><span class="line">    _emit <span class="number">0xF0</span></span><br><span class="line">L0:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 比较并交换。简单解释一下下面这条指令，熟悉汇编的朋友可以略过下面的解释:</span></span><br><span class="line"><span class="comment">     *   cmpxchg: 即“比较并交换”指令</span></span><br><span class="line"><span class="comment">     *   dword: 全称是 double word，在 x86/x64 体系中，一个</span></span><br><span class="line"><span class="comment">     *          word = 2 byte，dword = 4 byte = 32 bit</span></span><br><span class="line"><span class="comment">     *   ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元</span></span><br><span class="line"><span class="comment">     *   [edx]: [...] 表示一个内存单元，edx 是寄存器，dest 指针值存放在 edx 中。</span></span><br><span class="line"><span class="comment">     *          那么 [edx] 表示内存地址为 dest 的内存单元</span></span><br><span class="line"><span class="comment">     *        </span></span><br><span class="line"><span class="comment">     * 这一条指令的意思就是，将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值</span></span><br><span class="line"><span class="comment">     * 进行对比，如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实际举例说明</strong></p><p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile</strong> 来保证原子操作。AtomicInteger 的主要方法都是通过调用Unsafe类方法去实现，如 compareAndSet 实际是调用AtomicInteger 的compareAndSwapInt方法。</p><blockquote><p>下面以 getAndIncrement实现来说明。</p></blockquote><ol><li><p>getAndIncrement调用了 Unsafe的getAndAddInt方法，传递了（1）当前this对象，（2）value偏移量，用来计算得到value值（3）要加上的值，由于是递增所以是1</p><blockquote><p>⚠️ <strong>为什么不传value的值，而是偏移量</strong>？ 传偏移量是为了计算value所在的内存地址，进而获取最新的value值。</p></blockquote></li><li><p>getAndAddInt采用CAS方式进行更新，还需要进行当前期望值的计算</p><ul><li>通过<code>getIntVolatile</code>获取到<strong>线程此时内存value值</strong>（期望值），也就是记录<strong>执行CAS前</strong>的内存最新value值；</li></ul></li><li><p>然后开始执行Unsafe的 <code>compareAndSwapInt</code> ，主要是通过<code>Atomic::cmpxchg</code> 逻辑来实现</p><p>（1）将要dest（value内存地址），compareValue（期望值），exchange_value（要更新的值）写入寄存器中</p><p>（2）线程如果是运行多核CPU，上<strong>LOCK#锁，将dest内存区域锁住</strong> ；否则不上LOCK#锁</p><p>（3）执行cmpxchg（比较并交换命令），如果dest的value值（<strong>执行CAS中</strong>的最新value值） == compareValue，则写入exchange_value ；</p><p>（4）否则写入失败，通过不断自旋（循环）期望得到执行</p></li></ol></li></ul></li></ul><h5 id="1-8-请说明一下synchronized的-u-可重入-u-怎么实现？">1.8 <strong>请说明一下synchronized的<u>可重入</u>怎么实现</strong>？</h5><p>每个锁关联一个线程持有者对象和一个计数器。</p><ol><li>当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁（即monitor对象）而调用相应方法。</li><li>当一个线程请求成功后，JVM对象头会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。</li><li>而该持有锁的线程如果<strong>再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增</strong>。</li><li>当线程退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁。</li></ol><h5 id="1-9-在synchronized偏向锁过程中，调用hashcode方法，markword会发生什么？">1.9 在synchronized偏向锁过程中，调用hashcode方法，markword会发生什么？</h5><p>第一次调用Hashcode：当<u>对象的hashCode()方法</u>（非用户自定义）第一次被调用时，JVM会生成对应的<strong>identity hash code</strong>值，并将该值<u>存储到Mark Word</u>中 。</p><blockquote><p>后续如果该对象的hashCode()方法再次被调用则不会再通过JVM进行计算得到，<strong>而是直接从Mark Word中获取，保证唯一相同</strong>。</p></blockquote><ul><li><strong>无锁状态</strong>：在无锁状态下，Mark Word中可以存储对象的identity hash code值 ；</li><li><strong>偏向锁状态</strong>：需要计算其identity hash code的话，则它的偏向锁会被撤销（因为没有保存的位置），并且锁会膨胀为轻量级锁或者重量锁 ；</li><li><strong>轻量锁状态</strong>：<u>线程栈帧</u>的Lock Recode可以记录存储Displaced Mark Word ，所以轻量级锁可以和identity hash code <strong>共存</strong> ；</li><li><strong>重量级锁状态</strong>：<u>ObjectMonitor</u>类里有字段HashCode<strong>可以记录</strong>非加锁状态<strong>下的mark word，所以重量级锁也可以和identity hash code共存</strong>；</li></ul><h5 id="1-10-Synchronized-确定不可中断吗？如果一个线程访问Synchronized-代码，其它线程可以能否中断？比如使用Stop？是在中断前还是中断后获取锁？">1.10 Synchronized 确定不可中断吗？如果一个线程访问Synchronized 代码，其它线程可以能否中断？比如使用Stop？是在中断前还是中断后获取锁？</h5><blockquote><p>参考：<a href="https://blog.csdn.net/deel_feel/article/details/105771902">https://blog.csdn.net/deel_feel/article/details/105771902</a></p></blockquote><p>正确说法时：<strong>只有获取到锁之后才能中断，等待锁时不可中断</strong>。</p><h4 id="1-5-2-Reetrantlock-相关">1.5.2 Reetrantlock 相关</h4><p>ReentrantLock意思为可重入锁 。</p><h5 id="2-1-非公平锁和公平锁在reetrantlock里的实现过程是怎样的？">2.1 <strong>非公平锁和公平锁在reetrantlock里的实现过程是怎样的</strong>？</h5><blockquote><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html">美团技术文章-java-lock</a></p></blockquote><ul><li><p>公平锁：那么锁的 <u>获取顺序</u> 就应该符合请求的 <u>绝对时间顺序</u>，FIFO</p></li><li><p>非公平锁：只要<strong>CAS</strong>设置同步状态成功state，则表示当前线程获取了锁</p><blockquote><p>但公平锁还需要判断当前节点是否有前驱节点，如果有，则表示有线程比当前线程更早请求获取锁，因此需要等待。</p></blockquote></li></ul><p>【<strong>源码分析</strong>】</p><ul><li><p><strong>基本结构</strong></p><p>根据代码可知，ReentrantLock里面有一个内部类<strong>Sync</strong>，Sync继承AQS，添加锁和释放锁的大部分操作实际上都是在Sync中实现的。</p><ul><li>Sync有公平锁FairSync和非公平锁NonfairSync两个子类；</li><li>ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</li></ul><p><img src="https://i.loli.net/2021/05/21/YDAreyBEImxQfj2.png" alt="img"></p></li><li><p><strong>公平和非公平锁区分</strong></p><p><img src="https://i.loli.net/2021/05/21/zsPnT7qrXN5ovKZ.png" alt="img"></p><p>公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在<strong>CAS获取同步状态时</strong>，多了一个限制条件：<strong>hasQueuedPredecessors()</strong>。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/bd0036bb.png" alt="img"></p><ul><li><strong>该方法主要做一件事情</strong>：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</li></ul></li></ul><h5 id="2-2-ReentrantLock的实现原理？">2.2 ReentrantLock的实现原理？</h5><p>ReentrantLock的实现基于队列同步（AbstractQueuedSynchronizer，后面简称AQS）。关于AQS的实现原理见下。</p><p>ReentrantLock的核心，是通过修改AQS中state的值来同步锁的状态。</p><h5 id="2-3-希望等待一段时间锁没有获取，可以自动放弃用哪种锁？">2.3 希望等待一段时间锁没有获取，可以自动放弃用哪种锁？</h5><p>Lock（ReentranLock）</p><p>但是基于AQS的源码哪里体现了？ 应该Lock锁的代码里自己的实现吧。</p><h4 id="1-5-3-AQS-相关">1.5.3 AQS 相关</h4><h5 id="3-1-什么是AQS请你简单介绍一下？">3.1 什么是AQS请你简单介绍一下？</h5><p>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。</p><p><img src="https://i.loli.net/2021/05/16/QhJg8pnTv3zWj4w.png" alt="image-20210516144436982"></p><p><strong>AQS是⼀个用来构建锁和同步器的框架</strong>，使⽤AQS能简单且高效地构造出应用⼴泛的大量的同步器。</p><ul><li>例如：ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue等等皆是基于AQS的。当然，我们⾃⼰也能利⽤AQS非常轻松容易地构造出符合我们⾃⼰需求的同步器。</li></ul><h5 id="3-2-请介绍一下AQS原理？">3.2 请介绍一下AQS原理？</h5><blockquote><p>后续建议研读：<a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用</a></p></blockquote><p>先带着问题来进行看下面内容：</p><blockquote><p>Q：某个线程获取锁失败的后续流程是什么呢？</p><p>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p><p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p><p>A：是CLH变体的FIFO双端队列。</p><p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p><p>A：可以详细看下2.3.1.3小节。</p><p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</p><p>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。</p><p>Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p><p>A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。</p></blockquote><ul><li><p><strong>核心原理概览</strong></p><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。</p><p>如果被请求的共享资源被占用，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，<u>这个机制AQS是⽤CLH队列锁实现的</u>，即将暂时获取不到锁的线程加⼊到队列中。</p><blockquote><p>CLH(Craig,Landin,and Hagersten)队列是⼀个<strong>虚拟的双向队列</strong>（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成⼀个CLH锁队列的⼀个结点（Node）来实现锁的分配。</p></blockquote><p><img src="https://i.loli.net/2021/05/16/XqshLCnMYKbB7Ip.png" alt="image-20210516145134124"></p><p>AQS使用⼀个int成员变量<code>state</code>来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队⼯作。<strong>AQS使⽤CAS对该同步状态进行原子操作实现对其值的修改</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state; <span class="comment">//共享变量，使⽤volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure><p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作 。</p><img src="https://i.loli.net/2021/05/28/g7GORpXKhuo8aS4.png" alt="image-20210526122910138" style="zoom:67%;" /></li><li><p><strong>AQS 对资源的共享方式</strong><br>AQS定义两种资源共享方式，可以通过修改state字段来实现多线程的独占（经典如ReentranLock）和共享模式。</p><p><img src="https://i.loli.net/2021/05/26/YdcSGMs5jgiFnmk.png" alt="img"></p><ul><li><strong>Exclusive（独占）</strong>：只有⼀个线程能执行，如ReentrantLock。⼜可分为公平锁和非公平锁：<ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><strong>Share（共享）</strong>：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li></ul></li><li><p><strong>AQS详细原理</strong></p><blockquote><p>最终参考：<a href="https://zhuanlan.zhihu.com/p/90851418">从源码角度彻底理解ReentrantLock(重入锁)</a></p></blockquote><blockquote><p>以下是基于ReentractLock语境下进行分析。</p></blockquote><ul><li><p><strong>加锁过程：非公平锁</strong></p><blockquote><p>简单来说：<strong>新建线程→CAS尝试快速获取锁→tryAcquire()CAS修改state→addWaiter() 获取失败CAS尝试插入队尾入队→acquireQueued等待前驱线程唤醒继续CAS获取锁</strong></p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-28c16752466cd95dfe0504f0306d6352_720w.jpg" alt="img"></p><p>加锁流程从<code>lock.lock()</code>开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入该源码,正确找到sycn的实现类后可以看到真正有内容的入口方法：</p></li></ul><ol><li><strong>CAS尝试快速加锁</strong>，在ReentranLock只有state=0，才能更新成功（因为是非多线程共享资源）</li><li>获取锁失败执行acquire方法</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 加锁流程真正意义上的入口</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//以cas方式尝试将AQS中的state从0更新为1</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">          setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//获取锁成功则将当前线程标记为持有锁的线程,然后直接返回</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          acquire(<span class="number">1</span>);<span class="comment">//获取锁失败则执行该方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquire</code> 在主要的逻辑都在if判断条件中,这里面有3个重要的方法tryAcquire()，addWaiter() 和 acquireQueued() 。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">          selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>acquire流程1：tryAcquire()</strong></p><p>tryAcquire()在公平和非公平下获取的方式不一样，这里<strong>只说非公平</strong>实现。</p><ol><li><p>如果<strong>state==0（未被其它线程持有）</strong>，<strong>CAS</strong>尝试获取锁,</p></li><li><p>如果当前线程==持有锁的线程，<strong>可重入</strong> ，<strong>state+1</strong></p><ol start="3"><li><p>否则 reture false获取锁失败，加入等待队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Thread current = Thread.currentThread();<span class="comment">//获取当前线程实例</span></span><br><span class="line">     <span class="keyword">int</span> c = getState();<span class="comment">//获取state变量的值,即当前锁被重入的次数</span></span><br><span class="line">     <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;   <span class="comment">//state为0,说明当前锁未被任何线程持有</span></span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//以cas方式获取锁</span></span><br><span class="line">             setExclusiveOwnerThread(current);  <span class="comment">//将当前线程标记为持有锁的线程</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//获取锁成功,非重入</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">//当前线程就是持有锁的线程,说明该锁被重入了</span></span><br><span class="line">         <span class="keyword">int</span> nextc = c + acquires;<span class="comment">//计算state变量要更新的值</span></span><br><span class="line">         <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">         setState(nextc);<span class="comment">//非同步方式更新state值</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//获取锁成功,重入</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;     <span class="comment">//走到这里说明尝试获取锁失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p><strong>acquire流程2：addWaiter()</strong></p><p>主要逻辑如下：</p><ol><li>首先通过new Node()创建一个空结点；</li><li>如果队列不空**，以<strong>CAS</strong>方式让新节点插入到队尾;</li><li>如果队列为空，执行<code>enq(node)</code> 逻辑</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">       Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);<span class="comment">//首先创建一个新节点,并将当前线程实例封装在内部,mode这里为null</span></span><br><span class="line">       <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">       Node pred = tail;</span><br><span class="line">       <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">           node.prev = pred;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">               pred.next = node;</span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       enq(node);<span class="comment">//入队的逻辑这里都有</span></span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               Node t = tail;<span class="comment">//t指向当前队列的最后一个节点,队列为空则为null</span></span><br><span class="line">               <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize  //队列为空</span></span><br><span class="line">                   <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">//构造新结点,CAS方式设置为队列首元素,当head==null时更新成功</span></span><br><span class="line">                       tail = head;<span class="comment">//尾指针指向首结点</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;  <span class="comment">//队列不为空</span></span><br><span class="line">                   node.prev = t;</span><br><span class="line">                   <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">//CAS将尾指针指向当前结点,当t(原来的尾指针)==tail(当前真实的尾指针)时执行成功</span></span><br><span class="line">                       t.next = node;    <span class="comment">//原尾结点的next指针指向当前结点</span></span><br><span class="line">                       <span class="keyword">return</span> t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>acquire流程3：acquireQueued()</strong></p><blockquote><p><strong>线程加入同步队列后，获取锁的流程是什么呢</strong>？</p><p>简单来说，就是不断判断当前是否是老二，并尝试去获取锁。</p></blockquote><img src="https://pic4.zhimg.com/v2-f83b087a039a8de3f9815d9018e2273f_b.jpg" alt="img" style="zoom:80%;" /><ul><li><code>SIGNAL ：</code>意味着线程释放锁后会唤醒后面阻塞的线程。毕竟，只有确保能够被唤醒，当前线程才能放心的阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//死循环,正常情况下线程只有获得锁才能跳出循环</span></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//获得当前线程所在结点的前驱结点</span></span><br><span class="line">              <span class="comment">//第一个if分句</span></span><br><span class="line">              <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; </span><br><span class="line">                  setHead(node); <span class="comment">//将当前结点设置为队列头结点</span></span><br><span class="line">                  p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                  failed = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> interrupted;<span class="comment">//正常情况下死循环唯一的出口</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//第二个if分句</span></span><br><span class="line">              <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  <span class="comment">//判断是否要阻塞当前线程</span></span><br><span class="line">                  parkAndCheckInterrupt())      <span class="comment">//阻塞当前线程</span></span><br><span class="line">                  interrupted = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p><strong>解锁：非公平锁</strong></p><img src="https://i.loli.net/2021/05/26/sSQZlA2paTcNKXi.png" alt="image-20210526170709280" style="zoom:67%;" /></li><li><p><strong>加锁：公平锁</strong></p><blockquote><p>简单来说：<strong>新来线程→【必须】先CAS加入等待队列→等待前驱节点释放锁（state=0），如果是老二则获取锁</strong>。</p></blockquote><p>公平锁加锁入口加锁从：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finally void lock() &#123;</span><br><span class="line">    acqiuire();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前非公平锁的逻辑中，线程有三次机会获取锁：</p><ol><li><strong>新创建时</strong>，CAS尝试修改state=1，去获取</li><li><strong>可重入</strong>，当前获取锁线程为自己</li><li><strong>前驱节点释放锁</strong>，自己作为老二被唤醒</li></ol><p>而<strong>公平锁</strong>，只能按加入队列的<u>先后次序 &amp; 可重入</u>获得锁 ：</p><ol><li><p>所有线程在获取锁前<strong>必须先加入同步队列</strong></p></li><li><p>如果state=0，<code>hasQueuedPredecessors</code>判断当前是头节点，则获取锁</p></li></ol><p><img src="https://i.loli.net/2021/05/26/wZSLYOP4bTGEqRJ.jpg" alt="img"></p></li></ul></li></ul><h5 id="3-3-为什么基于FIFO的同步队列可以实现非公平锁？">3.3 为什么基于FIFO的同步队列可以实现非公平锁？</h5><p>因为非公平锁，除了等<strong>前驱节点唤醒去获取锁</strong> ，还有以下三种方式获取锁：</p><ol><li><p><strong>新创建时</strong>，CAS尝试修改state=1，去获取</p><blockquote><p>公平锁：进来先执行<code>hasQueuedPredecessors()</code> , 看等待队列是否有有效节点，有的话不能获取锁！</p></blockquote></li><li><p><strong>可重入</strong>，当前获取锁线程为自己</p><blockquote><p>公平锁：也可以</p></blockquote></li><li><p><strong>同步队列等待</strong>，等待唤醒获取锁</p><blockquote><p>公平锁：也可以</p></blockquote></li></ol><p>并且在锁释放时：是<strong>先释放锁（修改state=-1），再去唤醒后继节点</strong></p><ol><li>会导致新来的线程，可能在<strong>后继节点被唤醒前</strong>就获取了锁，这就不会公平</li></ol><h5 id="3-4-【易忘】为什么非公平锁性能好？">3.4 【易忘】为什么非公平锁性能好？</h5><ol><li>.线程不必加入等待队列就可以获得锁,不仅<strong>免去了构造结点并加入队列的繁琐操作</strong> ，<strong>节省了线程阻塞、唤醒</strong>的开销（这涉及到上下文的切换）；</li><li><strong>减少CAS竞争</strong>。如果<strong>线程必须要加入阻塞队列才能获取锁</strong>,那<strong>0</strong>将变得异常激烈,CAS操作虽然不会导致失败线程挂起,但不断失败重试导致的对CPU的浪费也不能忽视</li></ol><h5 id="3-4-AQS-有哪些组件，请简单介绍一下？介绍一下CountDownLatch的应用场景-？">3.4 AQS 有哪些组件，请简单介绍一下？介绍一下CountDownLatch的应用场景 ？</h5><p><img src="https://i.loli.net/2021/05/26/OWhD4Hu3GkBP2vc.png" alt="image-20210526215800096"></p><ul><li><p><strong>Semaphore(信号量)：<strong>Semaphore(信号量)可以指定</strong>多个</strong>线程<strong>同时</strong>访问某个资源； <strong>synchronized 和 ReentrantLock</strong> 都是⼀次只允许<strong>⼀个</strong>线程访问<strong>同时</strong>某个资源。</p><blockquote><p>计数信号量具备两种操作动作，称为V（signal()）与P（wait()）（即部分参考书常称的“PV操作”）。V操作会增加信号标S的数值，P操作会减少它。</p><p>运行P（wait()），信号标S的值将被减少。企图进入临界区段的进程，需要先运行P（wait()）。当信号标<strong>S减为负值</strong>时，进程会被挡住，不能继续；当<strong>信号标S不为负值</strong>时，进程可以获准进入临界区段。</p></blockquote></li><li><p><strong>CountDownLatch （倒计时器）</strong>： CountDownLatch是⼀个同步⼯具类，用来协调多个线程之间的同步。这个⼯具通常用来控制线程等待，<u>它可以让<strong>某⼀个线程等待直到倒计时结束</strong></u>，再开始执行。</p></li><li><p><strong>CyclicBarrier(循环栅栏)</strong>： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能⽐ CountDownLatch 更加复杂和强大。主要应用场景和CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让⼀组线程到达⼀个屏障（也可以叫同步点）时被阻塞，直到最后⼀个线程到达屏障时，屏障才会开⻔，所有被屏障拦截的线程才会继续⼲活。</p><blockquote><p>CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调⽤**await()**方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</p></blockquote></li></ul><p><strong>CountDownLatch的应用场景</strong></p><p>我们要读取处理<strong>6</strong>个⽂件，这6个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这6个⽂件的处理的结果进行统计整理。</p><p>为此我们定义了⼀个线程池和<strong>count为6的 CountDownLatch 对象</strong> 。使用线程池处理读取任务，每⼀个线程处理完之后就将count-1，调用 CountDownLatch 对象的 await() 方法，直到所有⽂件读取完之后，才会接着执行后面的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理⽂件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">6</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建⼀个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">     ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">     <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span></span><br><span class="line">CountDownLatch(threadCount);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> threadnum = i;</span><br><span class="line">         threadPool.execute(() → &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//处理⽂件的业务操作</span></span><br><span class="line">                ......</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//表示⼀个⽂件已经被完成</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       countDownLatch.await();</span><br><span class="line">       threadPool.shutdown();</span><br><span class="line">       System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-4-Volatile-关键字">1.5.4 Volatile 关键字</h4><h5 id="4-0-JMM-是什么-？-缓存一致性协议MESI-CPU内存屏障？JAVA内存屏障？">4.0 JMM 是什么 ？ 缓存一致性协议MESI ? CPU内存屏障？JAVA内存屏障？</h5><blockquote><p>参考：<a href="https://www.jianshu.com/p/06717ac8312c">并发编程-（4）-JMM基础（总线锁、缓存锁、MESI缓存一致性协议、CPU 层面的内存屏障）</a></p></blockquote><ul><li><p><strong>JMM定义</strong></p><p>全称Java Memory Model（java内存模型）是一系列的Java虚拟机平台对开发者提供的多线程环境下的内存可见性、是否可以重排序等问题的无关具体平台的统一的保证。</p></li><li><p><strong>MESI 缓存一致性协议协议</strong></p><ul><li><p><strong>缓存不一致问题</strong></p><p>CPU处理速度，远大于I/O设备（磁盘），为了解决了处理器与内存的速度矛盾，引入了<strong>高速缓存</strong>。但是由此也带来了缓存不一致的问题。</p><ul><li><strong>每个线程都会缓存内存的数据在各自寄存器中</strong>，在<strong>不同 CPU 中运行的不同线程看到同一份内存的缓存值不一样</strong>就会存在缓存不一致的问题。</li></ul></li><li><p><strong>MESI协议内容</strong></p><p>为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，<strong>最常见的就是 MESI 协议</strong>：<br>MESI 表示缓存行的四种状态，分别是：</p><blockquote><p>在 MESI 协议中，每个缓存的缓存控制器不仅知道自己的 读写操作，而且<strong>也监听(snoop)其它 Cache 的读写操作</strong>。</p></blockquote><ul><li><strong>M(Modify)</strong> 表示共享<strong>数据</strong>只缓存在<strong>当前 CPU 缓存</strong>中， 并且是被修改状态，也就是缓存的数据和主内存中的<strong>数据不一致</strong>。</li><li><strong>E(Exclusive)</strong> 表示缓存的独占状态，<strong>数据</strong>只缓存在<strong>当前 CPU 缓存</strong>中，并且<strong>没有被修改</strong>。</li><li><strong>S(Shared)</strong> 表示<strong>数据</strong>可能被<strong>多个 CPU 缓存</strong>，并且各个缓存中的<strong>数据和主内存数据一致</strong>。</li><li><strong>I(Invalid)</strong> 表示缓存已经<strong>失效</strong>。</li></ul><p>对于 MESI 协议，从 CPU 读写角度来说会遵循以下原则：</p><p><img src="https://i.loli.net/2021/06/11/YbfKoySNDMX5swn.png" alt="image-20210611200929872"></p><ul><li><strong>CPU 读请求</strong>：缓存处于 M、E、S 状态都可以被读取，I 状 态 CPU 只能从主存中读取数据；</li><li><strong>CPU 写请求</strong>：缓存处于 M、E 状态才可以被写。对于 S 状 态的写，需要将<strong>其他 CPU 中缓存行置为无效</strong>才可写。</li></ul></li><li><p><strong>Store Bufferes（存储缓存）</strong></p><blockquote><p>CPU 缓存行的状态是通过消息传递来进行的，如果 CPU0 要对一个在缓存中<strong>共享的变量</strong>进行<strong>写入</strong>，首先发送一个失效的消息给到其他缓存了该数据的 CPU。并且要<strong>等到他们的确认回执</strong>。CPU0 在这段时间内都会处于<strong>阻塞状态</strong>。</p></blockquote><p>为了避免阻塞带来的资源浪费。在 cpu 中引入 了 Store Bufferes（存储缓存） 和 Invalidate Queue（无效队列）。</p><ul><li>CPU0 写入共享数据时，<strong>直接把数据写入到 store bufferes 中，同时发送 invalidate 消息，然后继续去处理其他指令</strong>；</li><li>收到其他所有 CPU 发送了 invalidate ACK消息时，<strong>再将 store bufferes 中的数据数据存储至 cache 中</strong>；</li><li>最后再从<strong>本地Cache同步到主内存</strong>。</li></ul></li><li><p><strong>CPU层面内存屏障</strong></p><blockquote><p>内存屏障就是<strong>将 Store Bufferes 中的指令写入到内存</strong>，从而使得其他访问同一共享内存的线程的可见性。</p></blockquote><p>硬件层的内存屏障分为两种：<strong>Load Barrier （读屏障</strong>）和 <strong>Store Barrier（写屏障）及 Full Barrier（全屏障</strong>）是读屏障和写屏障的合集。</p><ul><li><strong>写屏障</strong>：强制<strong>把写缓冲区/高速缓存</strong>中的脏数据等<strong>写回主内存</strong></li><li><strong>读屏障</strong>：将缓冲区/高速缓存中相应的<strong>数据失效</strong>。</li></ul></li><li><p><strong>JAVA 内存屏障</strong></p><p>java的内存屏障通常所谓的四种，<strong>LoadLoad（LL）, StoreStore（SS）, LoadStore（LS）, StoreLoad（SL</strong>)实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</p><ul><li><strong>LoadLoad（LL）屏障</strong>：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li><strong>StoreStore（SS）屏障</strong>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li><strong>LoadStore（LS）屏障</strong>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li><strong>StoreLoad（SL）屏障</strong>：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li></ul></li></ul></li></ul><h5 id="4-1-什么是HappenBefore原则？">4.1 什么是HappenBefore原则？</h5><p>在 JMM 中，<strong>如果一个操作执行的结果需要对另一个操作【可见】，那么这两个操作必须要存在 happens-before 关系</strong>。这两个操作可以是同一个线程，也可以是不同的线程。</p><p><strong>它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</strong> 。</p><ul><li><p><strong>HappenBefore原则</strong></p><ul><li><p><strong>as-if-serial 规则（程序顺序执行）</strong>：单个线程中的代码顺序不管怎么重排序，对于结果来说是不变的。</p></li><li><p><strong>volatile 变量规则</strong>，对于 volatile 修饰的变量的<strong>写操作</strong>， 一定 happen-before 后续对于 volatile 变量的<strong>读操作</strong>;</p></li><li><p><strong>监视器锁规则（monitor lock rule）</strong>：对一个监视器的解锁，happens-before于随后对这个监视器的加锁。</p></li><li><p><strong>传递性规则</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</p></li><li><p><strong>start 规则</strong>：如果线程 A 执行操作 ThreadB.start(),那么线程 A 的 ThreadB.start()操作 happens-before 线程 B 中的任意操作。</p></li><li><p><strong>join 规则</strong>：如果线程 A 执行操作 ThreadB.join()并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join()操作成功返回。</p></li></ul></li><li><p><strong>举例说明：什么是指令重排序</strong>？</p><p>请看下面代码：</p><blockquote><p><strong>假设</strong> 线程A执行writer()方法之<strong>后</strong>，线程B执行reader()方法，那么线程B执行4的时候一定能看到线程A写入的值吗？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;           <span class="comment">//1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;     <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;       <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> i = a;    <span class="comment">//4</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是<strong>肯定的</strong>。因为根据happens-before规则，我们可以得到如下关系：</p><ol><li>根据<strong>程序顺序规则</strong>，1 happens-before 2；3 happens-before 4</li><li>根据<strong>volatile规则</strong>，2 happens-before 3；</li><li>根据<strong>传递性规则</strong>，1 happens-before 4 。</li></ol><p>因此，综合运用<strong>程序顺序规则、volatile规则及传递性规则</strong>，我们可以得到1 happens-before 4，即线程B在执行4的时候一定能看到A写入的值。</p></li></ul><h5 id="4-2-Volatile-关键字原理">4.2 Volatile 关键字原理</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/paddix/p/5428507.html">https://www.cnblogs.com/paddix/p/5428507.html</a> 。</p></blockquote><p>此题考察的是<code>volatile</code>这个关键字。可以从<code>volatile</code>的作用和<code>volatile</code>的原理这三个方面来进行回答。<strong>volatile只能保证变量的可见性、有序性，但是不能保证原子性</strong>。</p><ul><li><strong>可见性实现原理</strong></li></ul><blockquote><p>为了实现<strong>volatile可见性</strong>和<strong>happen-befor</strong>的语义。JVM底层是通过一个叫做“<strong>内存屏障（基于MESI）</strong>”的东西来完成（也实现了<strong>有序性</strong> ？）。</p></blockquote><p><strong>线程本身并不直接与主内存进行数据的交互</strong>，而是通过线程的工作内存来完成相应的操作。这也是导致线程间数据不可见的本质原因。</p><p>使用<strong>MESI</strong> 协议，使得<strong>任意一个线程修改了 volatile 修饰的变量，其他线程可以马上识别到最新值</strong>。</p><blockquote><p>最终目标：保证了<strong>缓存的一致性</strong>。</p><p>具体的话，下面是用<strong>内存屏障</strong>来实现的。</p></blockquote><ol><li>修改本地工作内存，强制刷回主内存；</li></ol><p><img src="https://i.loli.net/2021/06/11/JTFaYRu13pfQg9d.png" alt="image-20210611204633903"></p><ol start="2"><li><p>强制让其他线程的工作内存失效过期；</p><p><img src="https://i.loli.net/2021/06/11/2kphvOoJu4K65Hb.png" alt="image-20210611204715422"></p></li><li><p>其他线程重新从主内存加载最新值；</p><p><img src="https://i.loli.net/2021/06/11/rvo58ueDB6CPyMa.png" alt="image-20210611204743839"></p></li></ol><ul><li><p><strong>有序性实现原理</strong></p><blockquote><p>参考：<a href="https://blog.csdn.net/qq_42764468/article/details/106898608">https://blog.csdn.net/qq_42764468/article/details/106898608</a></p></blockquote><p>从源代码到最终执行的指令，可能会经过三种重排序：</p><p><img src="https:////upload-images.jianshu.io/upload_images/2845835-8fc217f556cd34f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680/format/webp" alt="img"></p></li><li><p><strong>【指令】重排序</strong>，<strong>JMM</strong> 会要求编译器生成指令时，会<strong>插入内存屏障</strong>来禁止处理器重排序。</p></li></ul><blockquote><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止：①特定类型的编译器重排序和②处理器重排序，为程序员提供一致的内存可见性保证。</p></blockquote><ul><li><p><strong>编译器重排序</strong>，<strong>JMM</strong> <strong>禁止了特定类型的编译器</strong>重排序（不是所有的编译器重排序都要禁止）。</p></li><li><p><strong>内存重排序</strong>：由于处理器会使用读/写缓冲区，出于性能的原因，内存会对读/写进行重排序</p></li></ul><p>JVM 是<strong>使用内存屏障来禁止【指令】重排，从而达到：可见性 + 部分有序性</strong>效果。</p><blockquote><p><strong>lock前缀指令实际相当于一个内存屏障</strong>？ 下面不是可见性吗？？？</p></blockquote><p>对volatile变量的<strong>写</strong>操作与普通变量的主要区别有两点：</p><ol><li><p>修改volatile变量<strong>前</strong>，<strong>会强制将修改后的值刷新的主内存中</strong>。</p><blockquote><p>每个volatile写操作前插入<strong>StoreStore（SS）屏障</strong></p></blockquote></li><li><p>修改volatile变量<strong>后</strong>，<strong>会导致其他线程工作内存中对应的变量值失效</strong>，因此，再读取该变量值的时候就需要重新从读取主内存中的值。</p><blockquote><p>在写操作后插入StoreLoad屏障；</p></blockquote></li></ol><p>对volatile变量的<strong>读</strong>操作类似：</p><ol><li><p>在每个volatile读操作前插入<strong>LoadLoad（LL）屏障</strong>；</p><blockquote><p>确保Load2及后续Load指令加载数据之前能访问到Load1加载的数据。</p></blockquote></li><li><p>在读操作后插入<strong>LoadStore（LS屏障</strong>）。</p><blockquote><p>确保Store2和后续Store指令执行前，可以访问到Load1加载的数据。</p></blockquote></li></ol><h5 id="4-3-volatile为什么不能保证原子性？">4.3 volatile为什么不能保证原子性？</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/simpleDi/p/11517150.html">为什么volatile能保证有序性不能保证原子性</a></p></blockquote><p>对于i++这种复合操作，即使使用volatile关键字修饰也不能保证操作的原子性，可能会引发数据不一致问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure><p>上述<code>i++</code>操作，其实分为三个操作：</p><ol><li><p>线程读取i</p></li><li><p>temp = i + 1</p></li><li><p>i = temp</p></li></ol><p>A,B两个线程多线程操作时：</p><ol><li><p>A线程读取i并执行了 temp = i + 1的操作， 此时的 i（0） 的值还没有变化</p></li><li><p>此时B也读入i并执行temp = i + 1操作，此时i（0）也没变化</p><blockquote><p>⚠️ 虽然有MESI协议，但是<code>temp</code>不保存变量<code>i</code>所在内存区域，<strong>是cpu内部的计算</strong>，不会被立马刷新内存！</p></blockquote></li><li><p>当A写入i = temp（1）时，由于可见性立马在主存被刷新了值 i=1</p></li><li><p>当B也写入i = temp时，<strong>此时A依旧是1，而不是2</strong></p></li></ol><h5 id="4-4-并发编程的三个重要特性-？">4.4 <strong>并发编程的三个重要特性</strong> ？</h5><ol><li><strong>原子性 :</strong> ⼀个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的⼲扰而中断，<strong>要么所有的操作都执行，要么都不执行</strong>。 <code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性 <strong>：当</strong>⼀个变量对共享变量进行了修改，那么另外的线程都是⽴即可以看到修改后的最新值</strong>。 volatile 关键字可以保证共享变量的可见性。</li><li><strong>有序性</strong>：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。 <code>volatile</code> 关键字可以禁⽌指令进行重排序优化。</li></ol><h5 id="4-5-说说-synchronized-关键字和-volatile-关键字的区别？">4.5 <strong>说说</strong> synchronized <strong>关键字和</strong> volatile <strong>关键字的区别</strong>？</h5><p>synchronized关键字和volatile关键字比较：</p><ul><li><p><strong>volatile关键字是线程同步的轻量级实现</strong>，所以volatile性能肯定⽐synchronized关键字要好。</p></li><li><p><strong>volatile关键字只能用于变量</strong>，而synchronized关键字可以修饰方法以及代码块。</p><blockquote><p>synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引⼊的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用<br>synchronized 关键字的场景还是更多⼀些。</p></blockquote></li><li><p><strong>volatile关键字只能保证数据的可见性</strong>，但不能保证数据的原子性。synchronized关键字两者都能保证。</p></li><li><p><strong>多线程访问volatile关键字不会发生阻塞</strong>，而synchronized关键字可能会发⽣阻塞</p></li></ul><h4 id="1-5-5-Atomic-原子类">1.5.5 Atomic 原子类</h4><h5 id="5-1-什么是Atomic-原子类？">5.1 什么是Atomic 原子类？</h5><p>所以，所谓原子类说简单点就是<strong>具有原子/原子操作特征的类</strong>。</p><blockquote><p>在我们这⾥ Atomic 是指⼀个操作是不可中断的。即使是在多个线程⼀起执行的时候，⼀个操作⼀旦开始，就不会被其他线程⼲扰。</p></blockquote><h5 id="5-2-JUC-包中的原子类是哪4类">5.2 JUC <strong>包中的原子类是哪</strong>4<strong>类</strong>?</h5><p><img src="https://i.loli.net/2021/05/16/vS4DHpKCN9bjnTF.png" alt="image-20210516152124223"></p><h5 id="5-3-Volatile-和-atomic-变量区别？">5.3 Volatile 和  atomic  变量区别？</h5><ul><li>Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。</li><li>而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</li></ul><h5 id="5-4-讲讲-AtomicInteger-的使用-？">5.4 讲讲 AtomicInteger 的使用 ？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并⾃增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并⾃减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输⼊的数值等于预期值，则以原子方式将该值设置为输⼊值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet设置之后可能导致其他线程在之后的⼀小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 基本类型也要是原子类</span></span><br><span class="line">       <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">       <span class="comment">//使⽤AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-5（重点提问）-AtomicInteger-原理？">5.5（重点提问） AtomicInteger 原理？</h5><p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile</strong> 和 <strong>native</strong> 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>我们以自增方法为例： <code>getAndIncrement</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，本质是在调用 unsafe中的 <code>getAndAddInt</code></p><blockquote><p>unsafe中的compareAndSwapInt方法参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compareAndSwapInt(Object o, <span class="keyword">long</span> offset,<span class="keyword">int</span> expected,<span class="keyword">int</span> x);  <span class="comment">// x是准备更新的值</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.<span class="built_in">getAndAddInt</span>(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unsafe中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="comment">// getIntVolatile方法获取到期望值value后去调用compareAndSwapInt方法，失败则进行重试</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// var5是计算得到的期望值，获取此时内存的最新值（因为value是votilate修饰，修改总是被能及时看到）</span></span><br><span class="line">        var5 = <span class="keyword">this</span>.<span class="built_in">getIntVolatile</span>(var1, var2);</span><br><span class="line">    <span class="comment">// 计算传入compareAndSwapInt的四个参数</span></span><br><span class="line">    <span class="comment">// var1：传入的this对象；var2：value内存偏移值；var5：期望值，希望和【var2】一致； var5+var4：var5+var4（1），递增</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.<span class="built_in">compareAndSwapInt</span>(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最终总结如下</strong></p><p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile</strong> 来保证原子操作。AtomicInteger 的主要方法都是通过调用Unsafe类方法去实现，如 compareAndSet 实际是调用AtomicInteger 的compareAndSwapInt方法。</p><p>下面以 getAndIncrement实现来说明。</p><ol><li><p>getAndIncrement调用了 Unsafe的getAndAddInt方法，传递了（1）当前this对象，（2）value偏移量valueoffset，用来计算得到value值（3）要加上的值，由于是递增所以是1</p><blockquote><p>⚠️ <strong>为什么不传value的值，而是偏移量</strong>？ 传偏移量是为了计算value所在的内存地址，进而获取最新的value值。</p></blockquote></li><li><p>getAndAddInt采用CAS方式进行更新，还需要进行当前期望值的计算</p><ul><li>通过<code>getIntVolatile</code>获取到<strong>线程此时内存value值</strong>（期望值），也就是记录<strong>执行CAS前</strong>的内存最新value值；</li></ul></li><li><p>然后开始执行Unsafe的 <code>compareAndSwapInt</code> ，主要是通过<code>Atomic::cmpxchg</code> 逻辑来实现</p><p>（1）将要dest（value内存地址），compareValue（期望值），exchange_value（要更新的值）写入寄存器中</p><p>（2）线程如果是运行多核CPU，上<strong>LOCK#锁，将dest内存区域锁住</strong> ；否则不上LOCK#锁</p><p>（3）执行cmpxchg（比较并交换命令），如果dest的value值（<strong>执行CAS中</strong>的最新value值） == compareValue，则写入exchange_value ；</p><p>（4）否则写入失败，通过不断<strong>自旋（循环</strong>）期望得到执行</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（一）_Java_多线程</title>
      <link href="/p/8959/"/>
      <url>/p/8959/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h2 id="1-4-多线程">1.4 多线程</h2><h4 id="0-三个线程，如何让他们按顺序打印A、B、C？如果是循环打印10次呢？依次打印1-100呢？交替打印奇偶10次呢？">0.<strong>三个线程，如何让他们按顺序打印A、B、C？如果是循环打印10次呢？依次打印1~100呢？交替打印奇偶10次呢？</strong></h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/370130458">https://zhuanlan.zhihu.com/p/370130458</a></p></blockquote><h5 id="0-1-synchronized-条件变量">0.1 <strong>synchronized + 条件变量</strong></h5><ol><li><p><strong>synchronized + 条件变量</strong>（循环打印1次）</p><p>思路如下：</p><ul><li>新建三个线程1、2、3 ，分别负责打印A、B、C；同时，每个线程对应一个条件变量：<code>num%3==当前线程条件变量?</code> ；</li><li>把打印的代码用synchronized 加锁，每个线程拿到锁后，<strong>while循环判断</strong>是否满足当前线程的条件变量 ；</li><li><strong>如果满足</strong> ，便执行后续逻辑打印当前线程，之后<strong>notifyall()唤醒其它线程</strong>；</li><li><strong>如果不满足</strong>，执行wait等待释放锁；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wait_Notify_ACB</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">// targetNum ： 每个线程应该满足的对应条件变量</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) </span><br><span class="line">                &#123;   <span class="comment">// while ：线程阻塞在wait(),再次被唤醒应该先检查下是否满足条件，因为这个时候未必轮到当前线程执行；用if会导致直接往下执行。</span></span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Wait_Notify_ACB  wait_notify_acb = <span class="keyword">new</span> Wait_Notify_ACB ();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>synchronized + 条件变量</strong>（循环打印10次）</p><p>打印10次，只需让三个线程，尝试去竞争10次锁即可。所以在<strong>synchronized前加上for循环</strong>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wait_Notify_ACB</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">// targetNum ： 每个线程应该满足的对应条件变量</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">10</span> ;i++)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) </span><br><span class="line">                &#123;   <span class="comment">// while ：线程阻塞在wait(),再次被唤醒应该先检查下是否满足条件，因为这个时候未必轮到当前线程执行；用if会导致直接往下执行。</span></span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Wait_Notify_ACB  wait_notify_acb = <span class="keyword">new</span> Wait_Notify_ACB ();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>synchronized + 条件变量</strong>（打印1~100)</p><p>设置一个全局变量，synchronized 中加锁函数对num+1，保证只要每次只有一个线程能执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wait_Notify_100</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxnum = <span class="number">10</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) &#123; <span class="comment">//想想这里为什么不能用if代替，想不起来可以看公众号上一篇文章</span></span><br><span class="line">                    <span class="keyword">if</span>(num &gt;= maxnum)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(num &gt;= maxnum)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + num);</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wait_Notify_100  wait_notify_100 = <span class="keyword">new</span> Wait_Notify_100 ();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread3&quot;</span>).start();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>synchronized + 条件变量</strong>（奇偶打印10次）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Wait_Notify_Odd_Even</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object monitor = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line">    Wait_Notify_Odd_Even(<span class="keyword">int</span> initCount) &#123;</span><br><span class="line">        <span class="keyword">this</span>.count = initCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printOddEven</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> <span class="comment">// 这里不用while循环判断，是因为下次notifyAll的一定是奇数或偶数</span></span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print( Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span>);</span><br><span class="line">                    System.out.println(++count);</span><br><span class="line">                    monitor.notifyAll();</span><br><span class="line">                    monitor.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//防止count=10后，while()循环不再执行，有子线程被阻塞未被唤醒，导致主线程不能退出</span></span><br><span class="line">            monitor.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Wait_Notify_Odd_Even waitNotifyOddEven = <span class="keyword">new</span> Wait_Notify_Odd_Even(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(waitNotifyOddEven::printOddEven, <span class="string">&quot;odd&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>); <span class="comment">//为了保证线程odd先拿到锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread(waitNotifyOddEven::printOddEven, <span class="string">&quot;even&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="0-2-join">0.2 join</h5><p><code>join()</code>方法**：在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行**。</p><p>基于这个原理，我们使得三个线程按顺序执行，然后循环多次即可。无论线程1、线程2、线程3哪个先执行，最后执行的顺序都是线程1——&gt;线程2——&gt;线程3。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Join_ABC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> printABC(<span class="keyword">null</span>),<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> printABC(t1),<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> printABC(t2),<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t3.start();</span><br><span class="line">            Thread.sleep(<span class="number">10</span>); <span class="comment">//这里是要保证只有t1、t2、t3为一组，进行执行才能保证t1-&gt;t2-&gt;t3的执行顺序。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">printABC</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread beforeThread;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">printABC</span><span class="params">(Thread beforeThread)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.beforeThread = beforeThread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(beforeThread!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeThread.join(); </span><br><span class="line">                    System.out.print(Thread.currentThread().getName());</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="0-3-Lock">0.3 Lock</h5><p>该方法很容易理解，不管哪个线程拿到锁，<strong>只有符合条件的才能打印</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Lock_ABC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;   <span class="comment">// 当前状态值：保证三个线程之间交替打印</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">3</span> == targetNum) &#123;</span><br><span class="line">                num++;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock(); <span class="comment">// 不符合要求直接释放锁，不会像sync一样阻塞在sync或wait处</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock_ABC lockABC = <span class="keyword">new</span> Lock_ABC();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="0-4-Semaphore">0.4 <strong>Semaphore</strong></h5><p>Semaphore：用来控制同时访问某个特定资源的操作数量，或者同时执行某个制定操作的数量。Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。</p><ul><li>一个线程要访问共享资源，先使用<code>acquire()</code>方法获得信号量，如果信号量的计数器值大于等于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。如果计数器值为0,线程进入休眠；</li><li>当某个线程使用完共享资源后，使用<code>release()</code>释放信号量，<strong>并将信号量内部的计数器加1</strong>，之前进入休眠的线程将被唤醒并再次试图获得信号量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SemaphoreABC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s1 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>); <span class="comment">//因为先执行线程A，所以这里设s1的计数器为1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s2 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s3 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(Semaphore currentThread, Semaphore nextThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentThread.acquire();       <span class="comment">//阻塞当前线程，即信号量的计数器减1为0</span></span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                nextThread.release();          <span class="comment">//唤醒下一个线程，即信号量的计数器加1</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SemaphoreABC printer = <span class="keyword">new</span> SemaphoreABC();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s1, s2);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s2, s3);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s3, s1);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-1-线程基本">1.4.1 线程基本</h3><h4 id="1-什么是线程和进程？如何保证线程安全？">1. 什么是线程和进程？<strong>如何保证线程安全？</strong></h4><h5 id="1-1-什么是线程和进程？">1.1 什么是线程和进程？</h5><ul><li><p><strong>什么是进程？</strong></p><p><strong>进程是程序的⼀次执行过程，是系统运行程序的基本单位</strong>，因此进程是<strong>动态</strong>的。系统运行⼀个程序即是⼀个进程从创建，运行到消亡的过程。</p><blockquote><p>如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe ⽂件的运行）。在Windows操作系统中，一个程序只对应一个进程，里面可以有一个或多个线程。</p><p><img src="https://i.loli.net/2021/05/16/cxYPKI1LnR4V3Mt.png" alt="image-20210516101110229"></p></blockquote></li><li><p><strong>什么是线程？</strong></p><p><strong>线程与进程相似，但线程是⼀个⽐进程更小的执行单位</strong>。⼀个进程在其执行的过程中可以产⽣多个线程。</p><ul><li>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有⾃⼰的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></li></ul><p>所以系统在产⽣⼀个线程，或是在各个线程之间作<u>切换⼯作</u>时，<strong>负担要⽐进程小得多</strong>，也正因为如此，线程也被称为轻量级进程。</p><blockquote><p>⼀个 Java 程序的运行是 main 线程和多个其他线程同时运行。</p></blockquote></li></ul><h5 id="1-2-如何保证线程安全？">1.2 如何保证线程安全？</h5><ol><li><strong>原子性</strong>，简单说就是<u>相关操作不会中途被其他线程干扰，一般通过同步机制实现</u>；</li><li><strong>可见性</strong>，<u>是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓</u>，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的；</li><li><strong>有序性</strong>，<u>是保证线程内串行语义，避免指令重排</u>等。</li></ol><h5 id="1-3-为什么程序计数器、虚拟机栈和本地方法栈是-u-线程-u-私有的">1.3 为什么程序计数器、虚拟机栈和本地方法栈是<u>线程</u>私有的?</h5><ul><li><p><strong>程序计数器为什么是私有</strong></p><p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪⼉了。</p><p>所以，程序计数器<u>私有</u>主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p></li><li><p><strong>虚拟机栈和本地方法栈为什么私有</strong></p><ul><li><p><strong>虚拟机栈</strong>： <u>每个 Java 方法在执行的同时会创建⼀个栈帧用于存储局部变量表、操作数栈、常量池引用等信息</u>。从方法调用直⾄执行完成的过程，就对应着⼀个栈帧在 Java 虚拟机栈中<strong>⼊栈和出栈</strong>的过程。</p></li><li><p><strong>本地方法法栈</strong>： 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行</strong> <strong>Java</strong> 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 <strong>Native方法服务</strong>。 在 HotSpot 虚拟机中和 Java 虚拟机栈合⼆为⼀。</p></li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p></li></ul><h4 id="2-创建线程的方式（非线程池）？-哪种最好？">2.<strong>创建线程的方式（非线程池）？ 哪种最好？</strong></h4><p>一般有三种方式来进行创建：</p><ol><li><p><strong>继承Thread类</strong>：（1）定义Thread类的子类，并重写该类的run方法（2）创建Thread子类的实例对象 （3）调用对象start()方法</p><blockquote><ul><li>优点：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用this即可获取当前线程；</li><li>缺点：因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了。</li></ul></blockquote></li><li><p><strong>实现Runnable接口</strong>：（1）定义runnable接口的<strong>实现类</strong>，并重写该接口的run()方法 （2）创建实现类的实例对象（3）调用线程对象的start()方法来启动该线程</p></li><li><p><strong>通过Callable和Future创建线程</strong>：（1）创建Callable接口的实现类，<strong>并实现call()方法</strong>（2）创建Callable实现类的实例，并使用FutureTask类来包装Callable对象（3）使用FutureTask对象作为Thread对象的target创建并启动新线程（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p></li></ol><p>其中 <u>实现Runnalbe接口更好</u>  ，使用实现Runnable接口的方式创建的线程<strong>可以处理同一资源</strong>，从而实现资源的共享。</p><h4 id="3-如何停止一个正在运行的线程？">3.<strong>如何停止一个正在运行的线程？</strong></h4><ol><li><p>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止；</p></li><li><p>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法；</p></li><li><p>使用interrupt方法中断线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">     <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">           sleep(<span class="number">1000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;week up from blcok...&quot;</span>);</span><br><span class="line">            stop = <span class="keyword">true</span>; <span class="comment">// 在异常处理代码中修改共享变量的状态</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    System.out.println(getName() + <span class="string">&quot; is exiting...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterruptThreadDemo3</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>          InterruptedException </span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">          MyThread m1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">          System.out.println(<span class="string">&quot;Starting thread...&quot;</span>);</span><br><span class="line">          m1.start();</span><br><span class="line">          Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;Interrupt thread...: &quot;</span> +           m1.getName());</span><br><span class="line">          m1.stop = <span class="keyword">true</span>; <span class="comment">// 设置共享变量为true</span></span><br><span class="line">          m1.interrupt(); <span class="comment">// 阻塞时退出阻塞状态</span></span><br><span class="line">          Thread.sleep(<span class="number">3000</span>); <span class="comment">// 主线程休眠3秒以便观察线程m1的中断情况</span></span><br><span class="line">          System.out.println(<span class="string">&quot;Stopping application...&quot;</span>);</span><br><span class="line">       &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-什么是Daemon线程？它有什么意义？">4.<strong>什么是Daemon线程？它有什么意义？</strong></h4><p>所谓后台(daemon)线程，也叫守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。</p><ul><li><strong>意义</strong>：JVM的垃圾回收线程就是Daemon线程，Finalizer也是守护线程。</li></ul><h4 id="5-说说CyclicBarrier和CountDownLatch的区别？">5.<strong>说说CyclicBarrier和CountDownLatch的区别？</strong></h4><p>两个看上去有点像的类，都在<code>java.util.concurrent</code>下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><ol><li>CyclicBarrier的某个线程运行到某个点上之后，<strong>该线程即停止运行</strong>，<strong>直到所有的线程都到达了这个点</strong>，所有线程才重新运行CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值**-1**而已，该线程继续运行；</li><li>CyclicBarrier<strong>只能唤起一个任务</strong>，CountDownLatch可以唤起多个任务</li><li>CyclicBarrier可重用，<strong>CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</strong></li></ol><h4 id="6-请你简要说明一下线程的基本状态以及状态之间的关系？">6.<strong>请你简要说明一下线程的基本状态以及状态之间的关系？</strong></h4><p><img src="https://i.loli.net/2021/04/28/VCN8xckXHMdrl1R.png" alt="image-20210428164922743"></p><ol><li><strong>新建状态</strong>：new语句创建的线程对象处于新建状态，仅被分配了内存；</li><li><strong>等待状态</strong>： 当线程在new之后，并且<u>在调用start方法前</u>，线程处于等待状态 ;</li><li><strong>就绪状态</strong>： 其他线程调用它的**start()**方法，该线程就进入就绪状态，<u>只差等待cpu的使用权 </u> ;</li><li><strong>运行状态</strong>： <u>线程占用CPU，执行程序代码</u>  ;</li><li><strong>阻塞状态</strong>： 阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。<u>阻塞状态分为三种：</u><ul><li><u>等待阻塞:</u> 运行的线程执行**wait()**方法，JVM会把该线程放入等待池中；</li><li><u>同步阻塞:</u> 运行的线程在获取<strong>对象同步锁</strong>时，若该同步锁被别的线程占用，则JVM会把线程放入锁池中；</li><li><u>其他阻塞:</u> 运行的线程执行Sleep()方法，或者发出I/O请求时，JVM会把线程设为阻塞状态。</li></ul></li><li><strong>死亡状态</strong>： 线程执行完<strong>run()方法中的代码</strong>，或者遇到了未捕获的异常，就会退出run()方法，结束生命周期</li></ol><h4 id="7-notify-和notifyAll-有什么区别？">7. <strong>notify()和notifyAll()有什么区别？</strong></h4><ul><li><strong>notify可能会导致死锁（why？</strong>），而notifyAll则不会；</li><li>使用notifyall,可以唤醒 所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。</li></ul><h4 id="8-sleep-和wait-有什么区别？">8. <strong>sleep()和wait() 有什么区别？</strong></h4><ul><li><p><strong>继承的类</strong>：sleep()方法，我们首先要知道该方法是属于Thread类中的；而wait()方法，则是属于Object类中的；</p><blockquote><p><em>sleep()</em> 是 <em>Thread</em> 类静态方法，可以使 <u>当前</u> 线程阻塞，并指定暂停时间，重点在于理解 <u>当前</u>。休眠时间期满后，该线程不一定会立即执行被CPU调度，只是到了就绪状态。</p></blockquote></li><li><p><strong>是否释放锁</strong>：sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。<strong>在调用sleep()方法的过程中，线程不会释放对象锁；当调用wait()方法的时候，线程会放弃对象锁</strong>，进入等待此对象的等待锁定池；</p></li><li><p><strong>用处</strong>： <strong>Wait 通常被用于线程间交互/通信</strong>，sleep 通常被用于暂停执行；</p></li><li><p><strong>再次唤醒</strong>： wait() 方法被调用后，线程不会⾃动苏醒，需要别的线程调用同⼀个对象上的 notify() 或者notifyAll() 方法。sleep() 方法执行完成后，线程会⾃动苏醒。</p></li></ul><h5 id="8-1-Thread类中的yield方法有什么作用？">8.1 <strong>Thread类中的yield方法有什么作用？</strong></h5><p><em>yield()</em> 也是 <em>Thread</em> 类静态方法，<strong>使当前线程变为<u>就绪状态</u></strong> （<em>sleep()</em> 是阻塞），使得其他线程更多机会获取CPU。执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p><h5 id="8-2-java-中Wait、Sleep和Yield方法的区别？">8.2 <strong>java 中Wait、Sleep和Yield方法的区别？</strong></h5><p><a href="https://www.jianshu.com/p/25e959037eed">https://www.jianshu.com/p/25e959037eed</a></p><h4 id="9-volatile-是什么-可以保证有序性吗">9. <strong>volatile 是什么?可以保证有序性吗?</strong></h4><ol><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存；</li><li>禁止进行指令重排序。</li></ol><p><strong>能保证有序性</strong>，因为禁止指令重排。</p><h4 id="10-为什么wait-notify-和-notifyAll这些方法不在thread类里面？">10. 为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h4><p><a href="https://www.zhihu.com/question/321674476">https://www.zhihu.com/question/321674476</a></p><p>明显的原因是<strong>JAVA提供的锁是对象级的而不是线程级的</strong>，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。<u>如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了</u>。</p><ul><li>简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</li></ul><h4 id="11-为什么wait和notify方法要在同步块中调用？">11.<strong>为什么wait和notify方法要在同步块中调用？</strong></h4><ul><li><u>wait()方法<strong>强制当前线程释放对象锁</strong></u>。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法；</li><li>在调用对象的notify()和notifyAll()方法之前，<u>调用线程必须<strong>已经得到该对象的锁</strong></u>。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。</li></ul><h4 id="12-（没细看）Java中interrupted-和-isInterruptedd方法的区别？">12. （没细看）<strong>Java中interrupted 和 isInterruptedd方法的区别？</strong></h4><p>interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法。</p><h3 id="1-4-2-线程池">1.4.2 线程池</h3><h4 id="1-请你解释一下什么是线程池（thread-pool）？">1.<strong>请你解释一下什么是线程池（thread pool）？</strong></h4><p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，<u>使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销</u>。 除此之外：</p><ul><li>提高性能，利用多线程压榨CPU算力；</li><li>提高线程的可管理性，限制线程数量并可以进行统一的分配、调优和监控。</li></ul><h5 id="1-1-请介绍一下使用线程池任务执行过程？"><strong>1.1 请介绍一下使用线程池任务执行过程？</strong></h5><p><strong>核心参数</strong>：其中<code>corePool</code>是核心线程池（保活线程），<code>maximumPool</code>是总线程池（保活线程+工作线程），<code>blockQueue </code>是等待任务队列，<code>rejectedExecutionHandler</code>是拒绝策略：</p><p><img src="https://i.loli.net/2021/04/19/Pn4wc5621hqIXpl.png" alt="image-20210419235537833" style="zoom: 33%;" /><img src="https://segmentfault.com/img/remote/1460000038860133" alt="iShot2021-01-03 20.18.23.png" style="zoom: 67%;" /></p><p><strong>流程：corePoolSize→队列→maximumPool→拒绝策略</strong></p><ol><li>未达到corePoolSize时，核心线程池会开辟新线程运行任务（<u>可以使用已有线程吗？</u>），<strong>任务结束后线程不销毁</strong>；</li><li>达到corePoolSize，而任务队列未满时，新任务提交到等待队列，<strong>线程空闲时间超过keepAliveTime时被销毁；</strong></li><li>任务队列也满了，但未超过最大线程数，新建工作线程执行任务；</li><li>超过最大线程数时，<strong>按拒绝策略处理</strong>，包括：<u>抛出异常、使用调用者线程运行任务、丢弃新任务、丢弃队列头任务</u>等。</li></ol><h5 id="1-2-线程池会回收核心线程吗？">1.2 线程池会回收核心线程吗？</h5><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000038836285">线程池是怎么回收空闲线程的</a></p></blockquote><p>会，可以通过allowCoreThreadTimeOut参数来进行设置。</p><ul><li><p>先回忆一下整体线程池流程</p><img src="https://segmentfault.com/img/remote/1460000038860133" alt="iShot2021-01-03 20.18.23.png" style="zoom:67%;" /></li><li><p><strong>excute方法</strong></p><p>我们的任务放到线程池后，是从调用execute执行开始的。<br><img src="https://i.loli.net/2021/05/26/hc4w6ZIbm57CpOQ.png" alt="image-20210526234652655" style="zoom: 67%;" /></p><ul><li><p>核心是addWorker办法， 里面最最重要的就是初始化Worker同时启动thread。</p></li><li><p>Worker实现了Runnable接口，我们直接看它的run方法，看截图的③处标记，抽离出来一个runWorker方法：</p><p><img src="https://i.loli.net/2021/05/26/39woAvIR4QjNfxd.png" alt="iShot2021-01-03 20.39.22.png"></p><p>也就是说：①处是一个while循环，<strong>getTask</strong>方法就是从线程池队列取任务，<strong>如果取不到任务</strong>就会执行</p><p>​                   ②<strong>一旦跳出while循环，即进入到processWorkExit方法，这就是回收Worker</strong></p></li></ul></li><li><p><strong>getTask方法</strong></p><p>可以看到，①判断是否回收线程的条件，<strong>timed</strong> ，有两种情况要回收线程：</p><ol><li><strong>wc&gt;corePoolSize</strong> ，当前线程数大于核心线程数</li><li><strong>allowCoreThreadTimeOut</strong>，核心线程超时，所以<strong>核心线程是会被回收</strong>的</li></ol><p>然后②处就是从任务队列取任务了，<strong>带了timeOut参数的poll方法超时</strong> ，未能从任务队列获取任务即返回null，从而实现最终的<strong>线程回收</strong>。</p><blockquote><p>不是processWorkExit处理吗，怎么在getTask处理，还是得好好看看。</p></blockquote><p><img src="https://i.loli.net/2021/05/26/hxJerXAo16msf38.png" alt="image-20210526235850331"></p></li></ul><h4 id="2-请介绍一下什么是生产者消费者模式？">2.<strong>请介绍一下什么是生产者消费者模式？</strong></h4><p><img src="https://uploadfiles.nowcoder.com/images/20180925/308572_1537880635592_7142B8354CA8A352B2B805F997C71549" alt="img"></p><p>生产者消费者问题是线程模型中的经典问题：</p><ul><li>生产者和消费者在<strong>同一时间段内共用同一存储空间</strong>，生产者向空间里生产数据，而消费者取走数据。</li></ul><h4 id="3-线程池的拒绝策略有哪些？">3.<strong>线程池的拒绝策略有哪些？</strong></h4><p>主要有4种拒绝策略：</p><ol><li>AbortPolicy：直接丢弃任务，抛出异常，这是默认策略</li><li><strong>CallerRunsPolicy</strong>：只用调用者所在的线程来处理任务</li><li>DiscardOldestPolicy：<strong>丢弃等待队列中最旧</strong>的任务，并执行当前任务</li><li>DiscardPolicy：直接丢弃任务，也不抛出异常</li></ol><h4 id="4-如何创建一个线程池（四大方法）？相关参数（七大参数）是什么">4.<strong>如何创建一个线程池（四大方法）？相关参数（七大参数）是什么?</strong></h4><p>java通过Executors提供<strong>四大方法</strong>：</p><ol><li><strong>newCachedThreadPool</strong>：创建一个可缓存线程池，如果线程池长度超过处理需要，<strong>可灵活回收空闲线程，若无可回收，则新建线程</strong>；</li><li><strong>newFixedThreadPool</strong>：创建一个定长线程池，<u>可控制线程最大并发数</u>，<strong>超出的线程会在<u>队列中等待</u></strong>；</li><li><strong>newScheduledThreadPool</strong>：创建一个定长线程池，<u>支持定时及周期性任务执行</u>；</li><li><strong>newSingleThreadExecutor</strong>： 创建一个<u>单线程化的线程池</u>，它只会用<strong>唯一的工作线程</strong>来执行任务，保证<u>所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</u>。</li></ol><p><strong>七大参数设置</strong>：</p><ol><li><p><strong>corePoolSize</strong>：当使用了<code>LinkedBlockingQueue = new LinkedBlockQueue</code>的时候，<strong>队列长度默认无限长</strong>，会导致线程数量永远等于<code>corePoolSize</code>，任务激增时任务响应时间也激增；</p></li><li><p><strong>maximumPoolSize</strong>：线程池中线程个数，增加线程的公式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>任务数</mtext><mo>−</mo><mi>q</mi><mi>u</mi><mi>e</mi><mi>u</mi><mi>e</mi><mi>C</mi><mi>a</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mtext>原线程数</mtext><mo>÷</mo><mtext>原任务数</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(任务数-queueCapacity) \times (原线程数 \div 原任务数)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">任务数</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">原线程数</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">原任务数</span><span class="mclose">)</span></span></span></span>；</p></li><li><p><strong>keepAliveTime</strong>：线程最大（空闲）存活时间；</p></li><li><p><strong>rejectedExecutionHandler</strong>：线程被拒绝的解决方案，可以自己重写；</p></li><li><p><strong>workQueue</strong> ： 阻塞队列；</p></li><li><p><strong>unit</strong>：keepAliveTime的单位 ；</p></li><li><p><strong>threadFactory</strong>：表示生成线程池中工作线程的线程工厂，用于创建线程一般默认即可</p></li></ol><h4 id="5-线程池核心线程数corePoolSize怎么设置呢？">5.<strong>线程池核心线程数corePoolSize怎么设置呢？</strong></h4><p>分为CPU密集型和IO密集型来考虑：</p><ul><li><p><strong>CPU密集型</strong>。这种任务消耗的主要是 CPU 资源，可以将线程数设置为 <code>N（CPU 核心数）+1</code>。</p><blockquote><p><u>比 CPU 核心数多出来的一个线程</u> ：是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p></blockquote></li><li><p><strong>IO密集型</strong>。这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，<strong>而线程在处理 I/O 的时间段内不会占用 CPU 来处理</strong>，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 ： <code>核心线程数=CPU核心数量*2</code></p></li></ul><h4 id="6-（不熟悉）Java线程池中队列常用类型有哪些？">6.<strong>（不熟悉）Java线程池中队列常用类型有哪些？</strong></h4><ul><li><code>ArrayBlockingQueue</code> ：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序；</li><li><code>LinkedBlockingQueue</code> :一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于 ArrayBlockingQueue ；</li><li><code>SynchronousQueue</code> : 一个不存储元素的阻塞队列；</li><li><code>PriorityBlockingQueue</code>： 一个具有优先级的无限阻塞队列，PriorityBlockingQueue 也是基于最小二叉堆实现。</li></ul><h4 id="7-有三个线程T1-T2-T3-如何保证顺序执行？">7.<strong>有三个线程T1,T2,T3,如何保证顺序执行？</strong></h4><p>因为在每个线程的run方法中用join()方法限定了三个线程的执行顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="comment">// 1.现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() </span><br><span class="line">         &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">               </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         <span class="keyword">final</span> Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// t2线程内run方法最开始，引用t1.join，等待t1线程执行完</span></span><br><span class="line">                   t1.join();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">                   System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// t3线程内run方法最开始，引用t2.join，等待t2线程执行完</span></span><br><span class="line">                        t2.join();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                          &#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                          &#125;</span><br><span class="line">                         System.out.println(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">                         &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//这里三个线程的启动顺序可以任意，大家可以试下！</span></span><br><span class="line">         t3.start();</span><br><span class="line">         t2.start();</span><br><span class="line">         t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-3-多线程">1.4.3 多线程</h3><h4 id="1-请简述一下实现多线程同步的方法？-为什么需要使用多线程？使用多线程会带来什么问题？">1.<strong>请简述一下实现多线程同步的方法？</strong> 为什么需要使用多线程？使用多线程会带来什么问题？</h4><ul><li><p><strong>同步方法</strong>：可以使用synchronized、lock、volatile和ThreadLocal来实现同步。</p></li><li><p><strong>为什么需要使用多线程？</strong></p><ul><li>减少<strong>上下文切换开销</strong>（共享进程的堆和方法区 ，注意，减少≠没有）</li><li>利用好多线程机制可以大大提<strong>高系统整体的并发能⼒</strong>以及性能</li><li><strong>多核时代</strong> ：多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算⼀个复杂的任务，我们只用⼀个线程的话，CPU <strong>只会⼀个 CPU 核⼼</strong>被利用到，而创建多个线程就可以让多个 CPU 核⼼被利用到，这样就提高了 CPU 的利用率。</li></ul></li><li><p><strong>带来的问题？</strong></p><ul><li><u>内存泄漏、上下⽂切换、死锁</u>还有受限于硬件和软件的资源闲置问题。</li></ul></li></ul><h4 id="2-什么是线程安全？如何保证线程安全？">2. 什么是线程安全？如何保证线程安全？</h4><blockquote><p>好文：<a href="https://zhuanlan.zhihu.com/p/94762520">一文搞懂CAS</a></p></blockquote><ul><li><p><strong>什么是线程安全？</strong></p><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。<u>如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的</u>，就是线程安全的。</p></li><li><p><strong>如何保证线程安全？</strong></p><ol><li><strong>使用 synchronized 关键字</strong> 。开销比较大</li><li><strong>使用Lock 锁</strong> 。高并发场景下，使用 Lock 锁要比使用synchronized 关键字，在性能上得到极大的提高。因为 Lock 底层是通过 AQS + CAS 机制来实现的。</li><li><strong>使用 Atomic 原子类</strong> 。使用 Lock 方式，一旦 unlock() 方法使用不规范，可能导致死锁。 Atomic 原子类，因为其底层基于 CAS 乐观锁来实现的，性能较高。</li><li><strong>使用Volatile？不可行！</strong> 因为无法保证原子性。</li></ol></li></ul><h4 id="3-线程安全需要保证几个基本特征？">3.<strong>线程安全需要保证几个基本特征？</strong></h4><ul><li><strong>原子性</strong>，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</li><li><strong>可见性</strong>，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将<br>线程本地状态反映到主内存上，volatile 就是负责保证可见性的。</li><li><strong>有序性</strong>，是保证线程内串行语义，避免指令重排等。</li></ul><h4 id="4-【待补充】如何在线程安全的情况下实现一个计数器？">4. 【待补充】<strong>如何在线程安全的情况下实现一个计数器？</strong></h4><p>可以使用加锁，比如synchronized或者lock。也可以使用Concurrent包下的原子类。</p><h4 id="5-多线程中的i-线程安全吗？请简述一下原因？">5.<strong>多线程中的i++线程安全吗？请简述一下原因？</strong></h4><p>不安全，因为<strong>i++不是原子性操作</strong>。i++分为读取i值，对i值加一，再赋值给i++，执行期中任何一步都是有可能被其他线程抢占的。</p><h4 id="6-介绍一下ThreadLocal原理？">6.<strong>介绍一下ThreadLocal原理？</strong></h4><blockquote><p>一篇讲的不错的文章：<a href="https://www.cnblogs.com/wupeixuan/p/12638203.html">https://www.cnblogs.com/wupeixuan/p/12638203.html</a></p></blockquote><p>当多线程访问共享可变数据时，涉及到线程间同步的问题，<u><strong>并不是</strong>所有时候，都要用到共享数据</u>，所以就需要线程封闭出场了。<strong>数据都被封闭在各自的线程之中</strong>，就不需要同步，这种通过将数据封闭在线程中而避免使用同步的技术称为<strong>线程封闭</strong>。</p><p>ThreadLocal 是 Java 里一种特殊变量，它是一个线程级别变量，<u>每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量</u>，竞态条件被彻底消除了，在并发模式下是绝对安全的变量。</p><ul><li><p><strong>使用示例</strong></p><p>在下面例子中，TreadLocal 做到多个线程对同一对象 set 操作，但是 get 获取的值还都是每个线程 set 的值，体现了线程的封闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadLocal变量，每个线程都有一个副本，互不干扰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; THREAD_LOCAL = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadLocalDemo().threadLocalTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadLocalTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 主线程设置值</span></span><br><span class="line">        THREAD_LOCAL.set(<span class="string">&quot;wupx&quot;</span>);</span><br><span class="line">        String v = THREAD_LOCAL.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread-0线程执行之前，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程取到的值：&quot;</span> + v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String v = THREAD_LOCAL.get();</span><br><span class="line">                <span class="comment">// 此时新建线程Thread-0取到的是null，意味着不同线程取到的值不同的</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程取到的值：&quot;</span> + v);</span><br><span class="line">                <span class="comment">// 设置 threadLocal</span></span><br><span class="line">                THREAD_LOCAL.set(<span class="string">&quot;huxy&quot;</span>);</span><br><span class="line">                v = THREAD_LOCAL.get();</span><br><span class="line">                System.out.println(<span class="string">&quot;重新设置之后，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程取到的值为：&quot;</span> + v);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 等待所有线程执行结束</span></span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        v = THREAD_LOCAL.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread-0线程执行之后，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程取到的值：&quot;</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  输出结果 */</span></span><br><span class="line"><span class="comment">// 虽然Thread-0已经改变了值，但是main取到的值依旧是一样的。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thread-0线程执行之前，main线程取到的值：wupx</span></span><br><span class="line"><span class="comment">Thread-0线程取到的值：null</span></span><br><span class="line"><span class="comment">重新设置之后Thread-0线程取到的值为：huxy</span></span><br><span class="line"><span class="comment">Thread-0线程执行结束</span></span><br><span class="line"><span class="comment">Thread-0线程执行之后，main线程取到的值：wupx</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>ThreadLocal原理</strong></p><p>ThreadLocal有一个<strong>静态内部类ThreadLocalMap，ThreadLocalMap又包含了一个Entry数组</strong>，Entry本身是一个弱引用，他的key是指向ThreadLocal的弱引用，Entry具备了保存key value键值对的能力。</p><p><img src="https://i.loli.net/2021/05/16/MXKyQxYDjWdOku2.png" alt="image-20210516142348550"></p><ul><li><p><strong>ThreadLocalMap</strong></p><blockquote><p>ThreadLocalMap 是 ThreadLocal 的静态内部类，当一个<strong>线程有多个 ThreadLocal 对象时</strong>时，需要一个容器来管理多 ThreadLocal，ThreadLocalMap 的作用就是管理线程中多个 ThreadLocal。</p></blockquote><p>从源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构，底层是数组，有初始化大小，也有扩容阈值大小，数组的元素是 Entry，<strong>Entry 的 key 就是 ThreadLocal 的引用，value 是 ThreadLocal 的值</strong>。ThreadLocalMap 解决 hash 冲突的方式采用的是<strong>线性探测法</strong>，如果发生冲突会继续寻找下一个空的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 键值对实体的存储结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 当前线程关联的 value，这个 value 并没有用弱引用追踪</span></span><br><span class="line">Object value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造键值对</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k k 作 key,作为 key 的 ThreadLocal 会被包装为一个弱引用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v v 作 value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line"><span class="keyword">super</span>(k);</span><br><span class="line">value = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始容量，必须为 2 的幂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储 ThreadLocal 的键值对实体数组，长度必须为 2 的幂</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadLocalMap 元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容的阈值，默认是数组大小的三分之二</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Set方法</strong></p><blockquote><p>调用 ThreadLocal对象.set(value)，实际在调用当前线程的ThreadLocalMap对象.set(this,value) ，会把当前 <code>threadLocal</code> 对象作为 key，想要保存的对象作为 value，存入 map。</p></blockquote><p>set 方法的流程主要是：</p><ul><li>先获取到当前线程的引用</li><li>利用这个引用来获返回当前线程到 ThreadLocalMap</li><li>如果 map 为空，则去创建一个 ThreadLocalMap</li><li>如果 map 不为空，就利用 ThreadLocalMap 的 <code>set (this当前对象，value)</code> 添加键值对</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为当前 ThreadLocal 对象关联 value 值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要存储在此线程的线程副本的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 返回当前ThreadLocal所在的线程</span></span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line"><span class="comment">// 返回当前线程持有的map</span></span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line"><span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果 ThreadLocalMap 不为空，则直接存储&lt;ThreadLocal, T&gt;键值对</span></span><br><span class="line">        <span class="comment">// 此时this是ThreadLocal对象，这是在ThreadLocal类中</span></span><br><span class="line">map.set(<span class="keyword">this</span>, value);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 否则，需要为当前线程初始化 ThreadLocalMap，并存储键值对 &lt;this, firstValue&gt;</span></span><br><span class="line">createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程 thread 持有的 ThreadLocalMap对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Get方法</strong></p><blockquote><p>调用ThreadLocal对象.get() 方式时，实际在调用ThreadLocalMap对象.getEntry(this) 方法。this是当前ThreadLocal对象。</p></blockquote><p>get 方法的主要流程为：</p><ul><li>先获取到当前线程的引用</li><li>获取当前线程内部的 ThreadLocalMap对象</li><li>如果 map 存在，则获取当前 ThreadLocal 对应的 value 值</li><li>如果 map 不存在或者找不到 value 值，则调用 setInitialValue() 进行初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前 ThreadLocal 对象关联的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 返回当前 ThreadLocal 所在的线程</span></span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line"><span class="comment">// 从线程中拿到 ThreadLocalMap</span></span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line"><span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 从 map 中拿到 entry</span></span><br><span class="line">ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 如果不为空，读取当前 ThreadLocal 中保存的值</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">T result = (T) e.value;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若 map 为空，则对当前线程的 ThreadLocal 进行初始化，最后返回当前的 ThreadLocal 对象关联的初值，即 value</span></span><br><span class="line"><span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>resize 方法</strong></p><p>当前线程的 ThreadLocalMap 中的 ThreadLocal 的个数超过容量阈值时，ThreadLocalMap 就要开始扩容了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 略</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7-为什么ThreadLocal造成内存泄漏？">7.<strong>为什么<code>ThreadLocal</code>造成内存泄漏？</strong></h4><p>ThreadLocalMap 是 ThreadLocal 的静态内部类，当一个线程有多 个ThreadLocal 时，需要一个容器来管理多个 ThreadLocal，ThreadLocalMap 的作用就是管理线程中多个 ThreadLocal。</p><blockquote><p>源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构：</p><p>底层是数组<code>Entry[] table</code>，数组的元素是 Entry类：<strong>Entry 的两个属性， key 是 ThreadLocal类型的引用，value 是 ThreadLocal 的值</strong>。</p></blockquote><ul><li><strong>原因</strong>：<code>ThreadLocalMap</code>的key为<strong>弱引用</strong>（有用但非必需，下一次GC会被回收），value为<strong>强引用</strong>（GC过程不会被回收），<u>有可能造成key被GC，value没被G</u>C，<code>ThreadLocalMap</code>中出现<code>null</code>为key的<code>Entry</code>，产生<u>内存泄漏</u>（<strong>软引用</strong>：有用但非必需，内存溢出之前被回收）；</li><li><strong>解决</strong>： 调用<code>set()</code>、<code>get()</code>和<code>remove()</code>方法时，会自动清理掉key为<code>null</code>的记录，但使用<code>ThreadLocal</code>方法后<strong>手动<code>remove()</code></strong>。</li></ul><h4 id="8-什么是多线程中的上下文切换？">8.<strong>什么是多线程中的上下文切换？</strong></h4><p><u>一个线程<strong>让出处理器使用权</strong>，就是“切出”；另外一个线程获取处理器使用权，就是“切入”。</u>在这个切入切出的过程中，操作系统会保存和恢复相关的进度信息，这个进度信息就是我们常说的“上下文”，上下文中一般包含了寄存器的存储内容以及程序计数器存储的指令内容。</p><h4 id="9-请问什么是死锁-deadlock">9.<strong>请问什么是死锁(deadlock)?</strong></h4><p>死锁是指<u>两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</u>，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p><h4 id="10-JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？">10. <strong>JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？</strong></h4><p><u>最简单方法：<strong>指定获取锁的顺序，并强制线程按照指定的顺序获取锁</strong>。</u></p><p>因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。或者通过破坏死锁的四个条件：</p><ul><li><strong>互斥</strong> ： 不可能破坏。</li><li><strong>破坏请求和保持条件</strong>：进程必须 <u>等所有要请求的资源都空闲时才能申请资源</u>， 这种方法会使<strong>资源浪费严重</strong> 。允许进程获取初期所需资源后，便开始运行，运行过程中再逐步释放自己占有的资源。</li><li><strong>破坏不可抢占条件</strong>： 方法代价大，实现复杂。</li><li><strong>破坏循坏等待条件</strong> ：对各进程请求资源的顺序做一个规定，避免相互等待。这种方法对<u>资源的利用率比前两种都高</u>，但是前期要为设备指定序号，新设备加入会有一个问题，其次对用户编程也有限制。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（一）_Java_集合</title>
      <link href="/p/21069/"/>
      <url>/p/21069/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h2 id="1-3-集合">1.3 集合</h2><h3 id="1-3-1-集合类">1.3.1 集合类</h3><h4 id="1-请说明Java集合类框架的基本接口有哪些？">1.<strong>请说明Java集合类框架的基本接口有哪些</strong>？</h4><ul><li><code>Collection</code>：代表一组对象，每一个对象都是它的子元素。</li><li><code>Set</code>：不包含重复元素的Collection。</li><li><code>List</code>：有顺序的collection，并且可以包含重复元素。</li><li><code>Map</code>：可以把键(key)映射到值(value)的对象，键不能重复。</li></ul><h4 id="2-（补充：举例说明）说说什么是fail-fast？">2.<strong>（补充：举例说明）说说什么是fail-fast？</strong></h4><p>fail-fast 机制是 Java 集合（Collection）中的一种错误<strong>快速反馈</strong>机制。当<strong>多个线程对同一个集合的内容进行操作时</strong>，就可能会产生 fail-fast 事件。</p><blockquote><p>例如：当某一个线程 A 通过 iterator 去遍历某集合的过程中，<strong>若该集合的内容被其他线程所改变了，那么线程 A 访问集合时，就会抛出 ConcurrentModifificationException 异常</strong>，产生 fail-fast 事件。这里的操作主要是指 add、remove 和 clear，对集合元素个数进行修改。</p></blockquote><h4 id="3-请说明List、Map、Set三个接口区分？">3.<strong>请说明List、Map、Set三个接口区分</strong>？</h4><ul><li><strong>重复元素</strong>：List以特定索引来存取元素，可以有重复元素；Map以键值对映射，不能有重复key；Set元素不能重复</li><li><strong>继承collection</strong>： List、Set继承于collection；Map和前二者明显区分，不继承collection</li><li><strong>实现方式</strong>： List是线性结构的容器 ，典型实现有<u>ArrayList 、LinkedList、Vector</u>； Map、Set都有 <u>基于哈希存储和排序树</u> 的两种实现版本，前者实现有 <u>HashMap和Hashtable</u> ，后者有<u>HashSet</u></li></ul><h4 id="4-请讲讲你所知道的常用集合类以及主要方法？">4.<strong>请讲讲你所知道的常用集合类以及主要方法</strong>？</h4><p>最常用的集合类是List 和 Map。</p><ul><li><strong>List</strong>：典型实现有<u>ArrayList 、LinkedList、Vector</u> ，大小可变，适合用于按数值索引元素类型；</li><li><strong>Map</strong>： 其中每个键映射到一个值，实现有 <u>HashMap和Hashtable</u> 。</li></ul><h3 id="1-3-2-Map-Set">1.3.2 <strong>Map &amp; Set</strong></h3><h4 id="1-请你介绍一下map的分类和常见的情况？">1.<strong>请你介绍一下map的分类和常见的情况</strong>？</h4><p>java为数据结构中的映射定义了一个接口<code>java.util.Map</code>  ， 它有四个实现类,分别是<code>HashMap、 Hashtable、 LinkedHashMap、 和TreeMap</code>.</p><ul><li><p><strong>Hashmap</strong>  ：根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度。</p><ul><li>遍历：访问快，遍历时取得的<u>数据随机</u></li><li>线程：不支持线程同步（但可以用Collections的synchronizedMap 实现同步）</li><li>key和记录：<strong>HashMap允许键和值是null</strong></li></ul></li><li><p><strong>Hashtable</strong> ：和Hashmap类似，是其子类。但其：</p></li><li><p>线程： 支持线程同步，也导致写入比较慢（一个时候只能一个线程写入）</p></li><li><p>key和记录：不允许记录的键或者值为空 ；</p></li><li><p><strong>LinkedHashMap</strong> ：HashMap的一个子类，<u>保存了记录插入顺序</u>：</p></li><li><p>遍历：<strong>遍历</strong>先得到的记录是先插入、一般情况比HashMap慢。</p></li><li><p><strong>TreeMap</strong> ： 实现SortMap接口，默认是按键值的升序排序，</p></li><li><p>遍历：当用<strong>遍历</strong>TreeMap时，得到的记录是<u>排过序</u>的</p><ul><li>线程：线程安全</li></ul></li></ul><p>一般情况下，我们用的最多的是HashMap, 在Map 中插入、删除和定位元素，HashMap 是最好的选择。但<u>如果您要按自然顺序或自定义顺序遍历键</u>，那么TreeMap会更好。如果需要<u>输出的顺序和输入的相同</u>,那么用LinkedHashMap 可以实现,它还<strong>可以按读取顺序来排列</strong>。</p><h5 id="1-1-TreeMap的底层实现？">1.1  TreeMap的底层实现？</h5><p>TreeMap实现了SotredMap接口，它是有序的集合。<strong>而且是一个红黑树结构，每个key-value都作为一个红黑树的节点</strong>。如果在调用<strong>TreeMap的构造函数时没有指定比较器，则根据key执行自然排序</strong>。这点会在接下来的代码中做说明，如<strong>果指定了比较器则按照比较器来进行排序</strong>。</p><ul><li>自然排序：TreeMap的所有key必须实现Comparable接口，所有的key都是同一个类的对象</li><li>定制排序：创建TreeMap对象传入了一个Comparator对象，该对象负责对TreeMap中所有的key进行排序，采用定制排序不要求Map的key实现Comparable接口。等下面分析到比较方法的时候在分析这两种比较有何不同。</li></ul><h4 id="2-请问HashMap和Hashtable区别？">2.<strong>请问HashMap和Hashtable区别</strong>？</h4><ul><li><strong>共同点</strong>：都实现Map接口</li><li><strong>不同点</strong>：<ol><li><strong>对Null key 和Null value的支持</strong>：HashMap<u>允许键和值是null</u>，而Hashtable不允许键或者值是null；</li><li><strong>线程安全</strong>：Hashtable是同步的线程安全，而HashMap不是；</li><li><strong>初始容量大小和每次扩充容量大小不同</strong>：  （1）创建时如果不指定容量初始值，Hashtable 默认的初始大小为<strong>11</strong>，之后每次扩充，容量变为原来的<strong>2n+1</strong>。HashMap 默认的初始化大小为<strong>16</strong>，之后每次扩充，容量变为原来的<strong>2</strong>倍 ；（2）创建时如果给定了容量初始值，那么 Hashtable 会直接使用<strong>你给定的大小</strong>，而 HashMap 会将其<strong>扩充为2的幂次方大小</strong>，也就是说 <u>HashMap 总是使用2的幂作为哈希表的大小</u>；</li><li><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表⻓度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有转换为红黑树这样的机制；</li><li><strong>继承父类</strong>：HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。</li></ol></li></ul><h4 id="3-请问Map接口实现：HashMap、Hashtable和ConcurrentHashMap区别？">3.<strong>请问Map接口实现：HashMap、Hashtable和ConcurrentHashMap区别</strong>？</h4><p>都是key-value存储形式。</p><ul><li><p><strong>底层数据结构</strong>：<code>HashMap</code>与<code>ConcurrentHashMap</code>底层数据结构相似（数组+链表+红黑树），<code>Hashtable</code>没有红黑树；</p></li><li><p><strong>线程安全</strong>：<code>Hashtable</code>的<code>synchronized</code>修饰在方法，是对象级的加锁，同一时间只有一个线程能对数据进行操作；<code>ConcurrentHashMap</code>使用了修饰具体对象的<code>synchronized</code>（锁一个桶）和CAS机制，实现了更细粒度的锁；</p></li><li><p><strong>地址计算</strong>：</p></li></ul><ul><li><code>HashMap</code>使用<code>key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16)</code>；-<ul><li><code>Hashtable</code>使用<code>(key.hashCode() &amp; 0x7fffffff) % tab.length()</code></li></ul></li><li><code>ConcurrentHashMap</code>使用<code>(key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16)) &amp; 0x7fffffff</code>。</li></ul><h4 id="4-说一说红黑树特征？">4.<strong>说一说红黑树特征</strong>？</h4><blockquote><p>紧接上个问题，面试官很有可能会问红黑树。</p></blockquote><ul><li>每个节点是黑色是红色</li><li><strong>根节点和叶子节点是黑色</strong></li><li>红色节点不能相邻</li><li>从一个节点到子孙节点路径上相同数目的黑节点</li></ul><p><img src="https://i.loli.net/2021/05/05/yismA9xYt5MEeFw.png" alt="image-20210505132113159"></p><h4 id="5-hashmap的基本原理，扩容方式（rehash）？">5. <strong>hashmap的基本原理，扩容方式（rehash）</strong>？</h4><blockquote><p>很棒的一篇文章：<a href="https://www.jianshu.com/p/dde9b12343c1">https://www.jianshu.com/p/dde9b12343c1</a></p><p>更棒的一篇文章：<a href="https://zhuanlan.zhihu.com/p/81587796">https://zhuanlan.zhihu.com/p/81587796</a></p></blockquote><ul><li><p><code>HashMap定义</code></p><p>HashMap继承了Map端口，实现了Serializable等接口。存储HashMap的是一个Entry[]数组，Entry是一个单向链表：</p><blockquote><p>所以我们说HashMap实现的是一个<code>数组+链表</code> 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li><li><p><code>Entry类</code></p><p>Entry在HashMap中实现为一个静态内部类，封装了key和value，还有<u>类型为Entry的next指向下一个Entry引用</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       V value;</span><br><span class="line">       Entry&lt;K,V&gt; next;</span><br><span class="line">       <span class="keyword">int</span> hash;</span><br></pre></td></tr></table></figure></li><li><p><code>图解HashMap</code></p><p>根据前面所知，我们可以得到HashMap的实现如下（默认初始化容量为16）：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/4843132-05b3a55bd2686dd3.png" alt="img"></p></li><li><p><code>put方法实现</code></p><ol><li><p>输入的<code>key</code>根据<code>hash(key)</code> 计算出hash值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 对key为null的处理</span></span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="comment">// 根据key算出hash值</span></span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br></pre></td></tr></table></figure><ul><li><p><strong>hash方法如下（JDK1.8版本</strong>）</p><p>下面这段代码也叫<strong>扰动函数</strong> ，参考：<a href="https://www.zhihu.com/question/20733617">JDK 源码中 HashMap 的 hash 方法原理是什么？</a></p><p><img src="https://i.loli.net/2021/05/15/OZT8G6PdxkAtQVi.png" alt="img"></p><p>混合原始哈希码的高位和低位，以此来加大低位的随机性 。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"><span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line"><span class="comment">// ^ ：按位异或</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt;⽆符号右移，忽略符号位，空位都以0补⻬</span></span><br><span class="line"><span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相⽐于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差⼀点点，因为毕竟扰动了 4 次。</p></li><li><p><strong>Object类HashCode实现</strong></p><blockquote><p>详细源码分析参考 ：<a href="https://juejin.cn/post/6844903487432556551">Java Object.hashCode()返回的是对象内存地址？</a></p></blockquote><p>JDK8 的<strong>默认</strong>hashCode的计算方法是通过和当前线程有关的<strong>一个随机数+三个确定值</strong>，运用Marsaglia’s xorshift scheme随机数算法得到的一个随机数 。</p><p>可以通过在JVM启动参数中添加<code>-XX:hashCode=4</code>，<u>改变默认的hashCode计算方式</u>：</p><ul><li>hashCode == 0 ：返回一个Park-Miller伪随机数生成器生成的随机数 ，OpenJdk 6 &amp;7的默认实现；</li><li>hashCode == 1：此类方案将对象的内存地址，做移位运算后与一个随机数进行异或得到结果 ；</li><li>hashCode == 2：此类方案返回固定的1；</li><li>hashCode == 3：此类方案返回一个自增序列的当前值；</li><li>hashCode == 4：此类方案返回当前对象的内存地址。</li></ul></li></ul></li><li><p>根据<code>indexFor(hash, table.length)</code> ，计算在table中下标</p><p><code>key.hashcode得到hash → 经过高低16异或扰动得到行hash →  indexFor计算下标</code></p><blockquote><p><code>indexFor()</code>  实际就是hash值取余：<code>hash%(table.lenght-1)</code> 。但在具体实现中通过位运算实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><strong>计算原理</strong>。 顺便说一下，这也正好解释了<strong>为什么HashMap的数组长度要取2的整次幂</strong>。因为这样（数组长度-1）正好相当于一个<strong>低位掩码</strong>。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是<strong>截取了最低的四位值</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">          10100101 11000100 00100101</span><br><span class="line">&amp;         00000000 00000000 00001111 （16）</span><br><span class="line">------------------------------------------</span><br><span class="line">          00000000 00000000 000000101</span><br></pre></td></tr></table></figure></li><li><p><strong>位运算要求<code>length</code> 一定是偶数</strong>。<code>length-1</code>则一定是奇数。 这样<code>h &amp; (length-1)</code>进行位运算出现的结果可奇可偶，不会一直是偶数，浪费奇数空间。而length为2的幂次，可以保证length一定是偶数，<strong>这也是扩容为什么要求一定是2的幂次</strong>。</p></li></ul></li><li><p><u>遍历table中下标为i的Entry单向链表</u>，找是否有相同的key已经在HashMap中，如果有，就替换value为最新的值；没有就直接插入。所以HashMap中只能存储唯一的key。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="comment">// 先判断hash值是否一样，如果一样，再判断key是否一样</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果是第一次put上面<code>for</code>循环不会执行，而是<code>addEntry</code>方法直接把key和value封装成Entry，然后加入到table中的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modCount++;</span><br><span class="line">addEntry(hash, key, value, i);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>这涉及到HashMap的<strong>扩容机制</strong>。</p></li></ol></li><li><p><code>扩容机制</code></p><blockquote><p>当HashMap中存储的元素个数达到扩容的阀值 ，那如何进行扩容？</p></blockquote><blockquote><p>⚠️ 在jdk1.8版本以后，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><img src="https://i.loli.net/2021/05/04/PoScN7yntJRhFvd.png" alt="在这里插入图片描述" style="zoom: 50%;" /></blockquote><p>我们再来看看addEntry方法中的扩容相关代码：</p><ul><li>扩容就是通过<code>resize()</code>方法创建一个长度为原来<strong>2</strong>倍的新table ；</li><li><code>resize()</code>方法内部通过遍历的方式，将老table的数据，重新计算hash并存储到新table的适当位置，最后使用新的table，并重新计HashMap的扩容阀值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">      <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">      <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">          threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">     <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">     transfer(newTable);     </span><br><span class="line">     <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">     table = newTable;  </span><br><span class="line">     <span class="comment">//修改阈值</span></span><br><span class="line">     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure><p>transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">      Entry[] src = table;                   </span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                  <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                  <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">                 e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                 newTable[i] = e; <span class="comment">//将元素放在数组上</span></span><br><span class="line">                 e = next; <span class="comment">//访问下一个Entry链上元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式 。下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p><p><img src="https://i.loli.net/2021/05/15/nCYJf3KPqBdEU4G.png" alt="image-20210515115619336"></p></li><li><p><code>get方法实现</code></p><p>用key的hash值算出key对应的Entry所在链表在在table的下标，然后遍历下标即可。</p><img src="4843132-9b5f706433247a6c.webp" alt="img" style="zoom:80%;"/></li></ul><h5 id="5-1-为什么HashMap默认链表长度超过8转为红黑树，而不是6、7或9？">5.1 为什么HashMap默认链表长度超过8转为红黑树，而不是6、7或9？</h5><ul><li><p>在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为 8 的时候，概率仅为 0.00000006。源码中注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line"><span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line"><span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line"><span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line"><span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line"><span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line"><span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line"><span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line"><span class="number">8</span>:    <span class="number">0.00000006</span></span><br><span class="line">more: less than <span class="number">1</span> in ten million</span><br></pre></td></tr></table></figure><p>这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。</p></li><li><p>特别的，默认是链表长度达到 8 就转成红黑树，而当长度降到 6 就转换回去，这体现了时间和空间平衡的思想。<strong>长度较小时，使用链<u>表空间占用少</u>，时间也不会长（因为链表短</strong>）。</p></li></ul><h5 id="5-2-HashMap-多线程操作导致死循环问题？">5.2  HashMap 多线程操作导致死循环问题？</h5><p><strong>总结</strong>： HashMap之所以在并发下的扩容造成死循环，是因为，多个线程并发进行时，<strong>因为一个线程先期完成了扩容</strong>，将原的链表重新散列到自己的表中，并且链表变成了<strong>倒序</strong>，后一个线程再扩容时，又进行自己的散列，再次将<strong>倒序链表变为正序链表</strong>，于是形成了一个环形链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">      Entry[] src = table;                   </span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              src[j] = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                  Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                  <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">               <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">               e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">               newTable[i] = e;    <span class="comment">//将元素放在数组上</span></span><br><span class="line">                e = next;    <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li><p>map初始化为一个长度为2的数组，loadFactor=0.75，<code>threshold=2*0.75</code>=1，也就是说当put第二个key的时候，map就需要进行resize。</p></li><li><p>设置断点让线程1和线程2同时debug到transfer方法的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p><p><img src="https://i.loli.net/2021/05/15/9wiAnOHdBe7hjLs.png" alt="image-20210515120319361"></p></li><li><p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，<strong>指向了线程二重组后的新链表</strong>。</p></li><li><p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p><p><img src="https://i.loli.net/2021/05/15/NFfwAOguQmsyeWh.png" alt="image-20210515120436107"></p></li><li><p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p><p><img src="https://i.loli.net/2021/05/15/ApClYedO6JTWmnx.png" alt="image-20210515120503570"></p></li></ol><h5 id="5-3-说说HashMap的put方法？">5.3 说说HashMap的put方法？</h5><p>根据key值计算在数组中的位置：</p><ul><li>如果定位到的数组位置没有元素 就直接插入；</li><li>如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，<u>依次和插入的 key 比较，如果 <strong>hash值&amp;equals对象相同</strong>就直接<strong>覆盖</strong>，<strong>不同</strong>就采用<strong>头插法</strong>插入元素</u>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//table[i]的位置已经存在元素，遍历链表</span></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;    </span><br><span class="line">    Object k;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用 equals 方法判断key是否相等，若相等，该key对应的键值对已经存在，用新的value取代旧的value</span></span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;    </span><br><span class="line">        V oldValue = e.value;    </span><br><span class="line">        e.value = value;    </span><br><span class="line">        e.recordAccess(<span class="keyword">this</span>);    </span><br><span class="line">        <span class="keyword">return</span> oldValue;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h5 id="5-4-说说HashMap的get方法？"><strong>5.4 说说HashMap的get方法</strong>？</h5><p>根据key值计算在数组中的位置：</p><ul><li>遍历链表或者在红黑树，比较key来获取value</li></ul><h5 id="5-5-【百度】rehash扩容时机？在插入前还是插入后？">5.5 【百度】rehash扩容时机？在插入前还是插入后？</h5><p>rehash过程在put函数中，其大致扩容时机如下：</p><ol><li><p>计算hash，定位到桶；且遍历桶外挂链表，如果有相同key则覆盖；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)  <span class="comment">// 【百度】怎么处理key或value为NULL的情况？</span></span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);<span class="comment">//计算键的hash值</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//通过hash值对应到桶位置</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;<span class="comment">//顺序遍历桶外挂的单链表</span></span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;/</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);<span class="comment">//遍历单链表完毕，没有找到与键相对的Entry，需新建一个Entry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>【如果没有找到相同key，说明要插入一个新entry】</strong> ，执行addEntry，<strong>插入前</strong>先验证下是否扩容；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * table.length);<span class="comment">//将容量扩容为原来的2倍</span></span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);<span class="comment">//扩容后的，该hash值对应的新的桶位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);<span class="comment">//在指定的桶位置上，创建一个新的Entry</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);<span class="comment">//链表的头插法插入新建的Entry</span></span><br><span class="line">        size++;<span class="comment">//更新size</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>因此总结扩容时机如下：</p><ul><li>在执行put时，如果遍历指定桶外挂链表<strong>没有找到相同key</strong>的节点时，说明需要<strong>新建一个entry</strong>，这个时候在<strong>插入前</strong>验证下是否要扩容。</li></ul><h5 id="5-6-hashmap在1-7版本之前为什么使用头插法？">5.6 hashmap在1.7版本之前为什么使用头插法？</h5><blockquote><p>1.7版本之前采用头插法，1.8之后采用尾插法。</p></blockquote><p><strong>头插法</strong>会改变链表中元素原本的顺序，以至于在并发场景下<strong>导致链表成环</strong>的问题；而<strong>尾插法</strong>，在扩容时<strong>会保持链表元素原本的顺序</strong>，就不会出现链表成环的问题 。</p><blockquote><p>既然有多线程并发问题，那为什么1.8之前还要使用头插法？</p></blockquote><ol><li><strong>局部性原理</strong>： 最近访问过的数据下次大概率会再次访问，把刚访问过的元素<strong>放在链表最前面</strong>可以直接被查询到，减少查找次数</li><li><strong>不是为了适应多线程而设计</strong>：　只有在并发情况下，头插法才会出现链表成环的问题，多线程情况下，HashMap 本就非线程安全，这就<strong>相当于你在它的规则之外</strong>出了问题。</li></ol><h5 id="5-7-为什么-HashMap-的负载因子设置成-0-75，而不是-1-也不是-0-5？">5.7 <strong>为什么 HashMap 的负载因子设置成 0.75，而不是 1 也不是 0.5？</strong></h5><p>在 HashMap 中，临界值（threshold） = 负载因子（loadFactor） * 容量（capacity）。</p><p><strong>那么如何能有效的避免哈希碰撞呢</strong>？</p><p>我们先反向思维一下，你认为什么情况会导致 HashMap 的哈希碰撞比较多？</p><p>无外乎两种情况：</p><ol><li><p>容量太小。容量小，碰撞的概率就高了。狼多肉少，就会发生争抢。</p></li><li><p>hash 算法不够好。算法不合理，就可能都分到同一个或几个桶中。分配不均，也会发生争抢。</p></li></ol><p><strong>为了避免哈希碰撞，HashMap 需要在合适的时候进行扩容</strong>。那就是当其中的元素个数达到临界值的时候（<strong>等全满了再扩容，那么在此之前容量太少，导致碰撞的概率过高</strong>），而这个临界值前面说过和 loadFactor 有关，换句话说，<strong>设置一个合理的 loadFactor</strong>，可以有效的避免哈希冲突。</p><blockquote><p>JVM中原话：</p><p><strong>一般来说，默认的负载因子 (0.75) 在时间和空间成本之间提供了很好的权衡。更高的值减少了空间开销，但增加了查找成本(反映在 HashMap 类的大多数操作中，包括 get 和 put)</strong>。</p><p>另一方面，<strong>为了保证负载因子（loadFactor） * 容量（capacity）的结果是一个整数，这个值是 0.75(3/4) 比较合理，因为这个数和任何 2 的幂乘积结果都是整数</strong>。</p></blockquote><h5 id="5-8-Hashmap-怎么处理key和value为null的情况？">5.8 Hashmap 怎么处理key和value为null的情况？</h5><h4 id="6-Hashtable-源码分析">6. Hashtable 源码分析</h4><blockquote><p>参考：<a href="https://juejin.cn/post/6844903509725282317">Java集合之Hashtable源码解析</a></p></blockquote><ul><li><p><strong>构造函数</strong></p><p>和HashMap还是挺相似的，但是默认初始容量是11（HashMap是16）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;<span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;<span class="comment">//键值对的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;<span class="comment">//阀值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> loadFactor;<span class="comment">//加载因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;<span class="comment">//修改次数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;<span class="comment">//下面的三个构造函数都是调用这个函数，来进行相关的初始化</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">            initialCapacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[initialCapacity];<span class="comment">//这里是与HashMap的区别之一，HashMap中table</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">        initHashSeedAsNeeded(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;<span class="comment">//指定初始数组长度</span></span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;<span class="comment">//从这里可以看出容量的默认值为16，加载因子为0.75f.</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">        putAll(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>put方法</strong></p><p>和HashMap整体过程依旧很像，但有4点注意：</p><ol><li><p>put方法是加锁synchronized，所以线程安全</p></li><li><p>Hashtable计算hash值的hash(key)，不允许为null，所以会抛出异常</p></li><li><p>获取数组散列的下标 <code>(hash &amp; 0x7FFFFFFF) % tab.length</code> 和HashMap <code>hash &amp; length-1</code> 不同</p><blockquote><ul><li><code>(hash &amp; 0x7FFFFFFF) % tab.length</code>  是（1）<code>hash &amp; 0x7FFFFFFF</code>  保证hash是正数 （2）然后取余</li><li>相比之下，HashMap是位运算进行了优化，更高效</li></ul></blockquote></li><li><p>Hashtable没有链表转红黑树的机制</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;<span class="comment">//这里方法修饰符为synchronized,所以是线程安全的。</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();<span class="comment">//value如果为Null,抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        Entry tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);<span class="comment">//hash里面的代码是hashSeed^key.hashcode（）,null.hashCode（）会抛出异常，所以这就解释了Hashtable的key和value不能为null的原因。</span></span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;<span class="comment">//获取数组元素下标,先对hash值取正，然后取余。</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                V old = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;<span class="comment">//修改次数。</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;<span class="comment">//键值对的总数大于其阀值</span></span><br><span class="line">            rehash();<span class="comment">//在rehash里进行扩容处理</span></span><br><span class="line"></span><br><span class="line">            tab = table;</span><br><span class="line">            hash = hash(key);</span><br><span class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>rehash方法（扩容</strong>）</p><p>和HashMap依旧很像，但是扩容每次是 <code>old*2+1</code> 。</p></li><li><p><strong>get方法</strong></p><p>也是相比Hashmap直接加了 synchronized 进行修饰，保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;<span class="comment">//没有什么特殊性，就是加了一个synchronized，就是根据index来遍历索引处的单链表。</span></span><br><span class="line">       Entry tab[] = table;</span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">               <span class="keyword">return</span> e.value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="6-1-（容易忘）HashMap-和-Hashtable-的区别-？">6.1 （容易忘）HashMap <strong>和</strong> Hashtable <strong>的区别</strong> ？</h5><ol><li><p><strong>关于null</strong>，HashMap允许key和value都可以为null，而Hashtable则不接受key为null或value为null的键值对。</p></li><li><p><strong>关于线程安全</strong>，HashMap是线程不安全的，Hashtable是线程安全的，因为Hashtable的许多操作函数都用synchronized修饰。</p></li><li><p><strong>Hashtable与HashMap实现的接口不一致</strong>，但Hashtable继承Dictionary，而HashMap继承自AbstractMap，即父类不同</p></li><li><p><strong>默认初始容量不同</strong>，扩容大小不同。HashMap的hash数组的默认大小是16，而且一定是2 的指数<code>old*2</code>；Hashtable中hash数组默认大小是11，增加的方式是<code>old*2+1</code>。</p></li></ol><h5 id="6-2-ConcurrentHashMap-和-Hashtable-的区别-？">6.2 ConcurrentHashMap <strong>和</strong> Hashtable <strong>的区别</strong> ？</h5><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用<strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构⼀样，数组+链表/红黑⼆叉树。Hashtable 和 JDK1.8 之前的HashMap 的底层数据结构类似都是采用<strong>数组+链表/红黑树</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要</strong>）： ①<strong>在JDK1.7</strong>的时候ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提高并发访问率。<strong>到JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和CAS 来操作</strong>。（JDK1.6以后 对 synchronized锁做了很多优化） <u>整个看起来就像是优化过且线程安全的 HashMap</u>，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同⼀把锁，全表锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当⼀个线程访问同步方法时，其他线程也访问同步方法，可能会进⼊阻塞或轮询状态，如使用 put 添加元素，另⼀个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><h4 id="7-ConcurrentHashMap线程安全的具体实现方式-底层具体实现-？">7.  ConcurrentHashMap<strong>线程安全的具体实现方式</strong>/<strong>底层具体实现</strong> ？</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/huangjuncong/p/9478505.html">https://www.cnblogs.com/huangjuncong/p/9478505.html</a></p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ConcurrentHashMap%E6%BA%90%E7%A0%81%2B%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.md">javaGuide</a></p></blockquote><p>Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p><p>Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p><ul><li><p><strong>JDK 1.7 实现</strong></p><p>Java 7 中 ConcurrentHashMap 的存储结构如下图。</p><img src="https://i.loli.net/2021/05/15/iT9npPGIdazS4vw.png" alt="img" style="zoom:150%;" /><ul><li><p><strong>存储结构</strong></p><p>ConcurrentHashMap 为了提高本身的并发能力，在内部采用了一个叫做 Segment 的结构，<strong>一个 Segment 其实就是一个类 HashTable 的结构</strong>，Segment 内部维护了一个链表数组。</p><blockquote><p><strong>两次Hash</strong>。ConcurrentHashMap 定位一个元素的过程需要进行两次Hash操作，第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部。</p><p>因此，这一种结构的带来的副作用是 Hash 的过程要比普通的 HashMap 要长，但是带来的好处是写操作的时候可以只对元素所在的 Segment 进行操作即可，不会影响到其他的 Segment。</p></blockquote><p><strong>1. ConcurrentHashMap的成员变量和构造函数</strong></p><blockquote><p><strong>ConcurrentHashMap扩容</strong>： 元素数量增加导致ConrruentHashMap需要扩容，ConcurrentHashMap不会增加Segment的数量，而<strong>只会增加Segment中链表数组的容量大小</strong>。 需要对整个ConcurrentHashMap做rehash，而只需要对Segment里面的元素做一次rehash就可以了。</p></blockquote><p>核心初始化函数逻辑如下：</p><blockquote><p>2的指数是为了可以使用移位操作加快hash计算过程。</p></blockquote><ol><li><p>计算出Segment的数量<code>ssize</code>，是不大于concurrencyLevel的最大的2的指数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">          ++sshift; </span><br><span class="line">           ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据intialCapacity确定Segment的容量的大小，每一个Segment的容量大小也是2的指数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">      ++c;</span><br><span class="line">      <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">      <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ol><p>下面是完整代码：</p><blockquote><ul><li>segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到 <strong>。默认是 32 - sshift = 28</strong></li><li>segmentMask，默认是 ssize - 1 = 16 -1 = 15</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 默认segment层级</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// segment最小容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 一个segment最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 锁之前重试次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数：无参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数：指定初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数：指定初始容量，负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数：指定初始容量，负载因子，并发级别</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">        <span class="comment">// 找到两种大小的最匹配参数</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// segment数组的长度是由concurrentLevel计算来的，segment数组的长度是2的N次方，</span></span><br><span class="line">        <span class="comment">// 默认concurrencyLevel = 16, 所以ssize在默认情况下也是16,此时 sshift = 4</span></span><br><span class="line">        <span class="comment">// sshift相当于ssize从1向左移的次数</span></span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift; </span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 段偏移量，默认值情况下此时segmentShift = 28</span></span><br><span class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">        <span class="comment">// 散列算法的掩码，默认值情况下segmentMask = 15</span></span><br><span class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// create segments and segments[0]</span></span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">            <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                             (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">        <span class="comment">// 创建ssize长度的Segment数组</span></span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">        <span class="keyword">this</span>.segments = ss;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>2.来查看具体代码定义，Segment的成员变量</strong>：</p><blockquote><p>Segment 继承于 ReentrantLock，不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;    <span class="comment">//Segment中元素的数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;      <span class="comment">//对table的大小造成影响的操作的数量(比如put或者remove操作)</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;    <span class="comment">//阈值,Segment里面元素的数量超过这个值那么就会对Segment进行扩容</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;   <span class="comment">//负载因子,用于确定threshold</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;    <span class="comment">//链表数组,数组中的每一个元素代表了一个链表的头部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 继续查看HashEntry组成</strong>：</p><blockquote><p>和 HashMap 非常类似，唯一的区别就是其中的核心数据如 <strong>value ，以及链表都是 volatile 修饰的</strong>，保证了获取时的可见性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    　<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ConcurrentHashMap列表Entry。注意，这不会作为用户可见的Map.Entry导出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">    </span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置具有volatile写语义的next字段。</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(HashEntry&lt;K,V&gt; n)</span> </span>&#123;</span><br><span class="line">      UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面不太重要，略。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>put() 方法实现</strong></p><blockquote><p>相比Hashtable，1.7版本concurrentHashmap的更加细粒度，只有定位到段，才会锁住。也就是段锁！</p><p>而Hashtable直接锁住整个方法。</p></blockquote><ol><li><p>计算key的hash值 ;</p></li><li><p>根据<strong>hash值，segmentShift，segmentMask定位到哪个Segment</strong>；</p></li><li><p>如果指定位置的 Segment 为空，则初始化这个 Segment；</p></li><li><p>在对应的 Segment 中进行具体的 put。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span></span><br><span class="line">    <span class="comment">// 其实也就是把高4位与segmentMask（1111）做与运算</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        <span class="comment">// 如果查找到的 Segment 为空，初始化</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Segment 中进行具体的 put的源码如下：</p><blockquote><p>判断元素个数是否超过了阈值或者segment中数组的长度超过了MAXIMUM_CAPACITY，如果满足条件则rehash扩容！</p></blockquote><p>由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p><ol><li><p>tryLock() 获取锁，获取不到使用<code>scanAndLockForPut</code>方法继续获取；</p><blockquote><p>这里面的第一步中的 scanAndLockForPut 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。</p></blockquote></li><li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry ；</p></li><li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待；</p><p>如果这个位置上的 <strong>HashEntry 不存在</strong>：</p><ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接<strong>头插法</strong>插入。</li></ol><p>如果这个位置上的 <strong>HashEntry 存在</strong>：</p><ol><li>判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致，<strong>一致则替换值</strong></li><li>不一致，<u>获取链表下一个节点</u>，直到发现相同进行值替换，或者链表表里完毕没有相同的。<ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接链表<strong>头插法</strong>插入。</li></ol></li></ol></li><li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 计算要put的数据位置</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// CAS 获取 index 坐标的值</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>扩容 rehash</strong></p><blockquote><p>rehash在put()内部被触发。</p></blockquote><p>ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，<strong>位置要么不变，要么变为 index+ oldSize</strong>，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> idx = e.hash &amp; sizeMask;  <span class="comment">// 新位置计算</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="comment">// 老容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 新容量，扩大两倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 新的扩容阀值 </span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新的数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历老数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算新的位置，新的位置只可能是不变或者是：老的位置+老的容量。</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                <span class="comment">// 如果当前位置还不是链表，只是一个元素，直接赋值</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// 如果是链表了</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">// 新的位置只可能是不变或者是：老的位置+老的容量。</span></span><br><span class="line">                <span class="comment">// 遍历结束后，lastRun 后面的元素位置都是相同的</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="keyword">null</span>; last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    <span class="comment">// 遍历剩余元素，头插法到指定 k 位置。</span></span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头插法插入新的节点</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>get方法</strong></p><blockquote><p>注意，Hashtable 会使用Synchronized进行修饰，所以不支持并发。但是ConcurrentHashmap <strong>没有使用同步机制</strong>：</p><ul><li>1.7版本 <strong>。使用unsafe方法（）等方式直接操作来保证并发处理的安全性</strong>，使用的是硬件的安全机制。</li><li>1.8版本。没有使用同步，也没有使用unsafe方式。所以<strong>是并发</strong>的。</li></ul></blockquote><ul><li><p>到这里就很简单了，get 方法只需要两步即可。</p><ol><li>计算得到segment的位置 u</li><li><strong>CAS方式获取segment数组对象 segment[u]</strong></li><li>计算HashEntry数组的下标 i</li><li><strong>CAS方式获取HashEntry[i]，即数组首节点</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 计算得到 key 的存放位置</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="comment">// 如果是链表，遍历查找到相同 key 的 value。</span></span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>JDK 1.8 实现</strong></p><blockquote><p>1.8版本分析，建议参考：<a href="https://www.cnblogs.com/zerotomax/p/8687425.html">https://www.cnblogs.com/zerotomax/p/8687425.html</a> 。</p></blockquote><p><img src="https://i.loli.net/2021/05/15/F6UhuXNQGKnldVk.png" alt="image-20210515224441806"></p><p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p><blockquote><p>和JDK1.8的HashMap是很相似 , 抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p></blockquote><ul><li><p><strong>存储结构和属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>; <span class="comment">// hashmap也是16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">// 超过8扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">// 超过64红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// 表示正在转移</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 表示已经转换成树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Node数组存储元素</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;<span class="comment">//默认没初始化的数组，用来保存元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<span class="comment">//转移的时候用的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来控制表初始化和扩容的，默认值为0，当在初始化的时候指定了大小，这会将这个大小保存在sizeCtl中，大小为数组的0.75</span></span><br><span class="line"><span class="comment">     * 当为负的时候，说明表正在初始化或扩张，</span></span><br><span class="line"><span class="comment">     *     -1表示初始化</span></span><br><span class="line"><span class="comment">     *     -(1+n) n:表示活动的扩张线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在ConcurrentHashMap中使用了unSafe方法，通过直接操作内存的方式来保证并发处理的安全性，使用的是硬件的安全机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用来返回节点数组的指定位置的节点的原子操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * cas原子操作，在指定位置设定值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 原子操作，在指定位置设定值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">        U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMapDebug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果在实例化对象的时候指定了容量，则初始化sizeCtl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMapDebug</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当出入一个Map的时候，先设定sizeCtl为默认容量，在添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMapDebug</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>put方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>再来看putVal ：</p><blockquote><p>可以发现相比HashTable直接对方法进行加锁synchronized / 1.7版本的ConcurrentHashMap 进入的开头尝试获取锁，1.8版本的ConcurrentHashMap 锁更加细粒度化。</p><ul><li>只有：（1）table不为初始化 （2）定位到table位置<code>i</code>不存在元素（此时会用CAS方式进行添加）（3）数组也没有在进行扩张（MOVED=-1）</li></ul><p>此时才会进行synchronized 添加元素（不会锁住rehash方法，最后才判断是否扩容）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当添加一对键值对的时候，首先会去判断保存这些键值对的数组是不是初始化了，</span></span><br><span class="line"><span class="comment">     * 如果没有的话就初始化数组</span></span><br><span class="line"><span class="comment">     *  然后通过计算hash值来确定放在数组的哪个位置</span></span><br><span class="line"><span class="comment">     * 如果这个位置为空则直接添加，如果不为空的话，则取出这个节点来</span></span><br><span class="line"><span class="comment">     * 如果取出来的节点的hash值是MOVED(-1)的话，则表示当前正在对这个数组进行扩容，复制到新的数组，则当前线程也去帮助复制</span></span><br><span class="line"><span class="comment">     * 最后一种情况就是，如果这个节点，不为空，也不在扩容，则通过synchronized来加锁，进行添加操作</span></span><br><span class="line"><span class="comment">     *    然后判断当前取出的节点位置存放的是链表还是树</span></span><br><span class="line"><span class="comment">     *    如果是链表的话，则遍历整个链表，直到取出来的节点的key来个要放的key进行比较，如果key相等，并且key的hash值也相等的话，</span></span><br><span class="line"><span class="comment">     *          则说明是同一个key，则覆盖掉value，否则的话则添加到链表的末尾</span></span><br><span class="line"><span class="comment">     *    如果是树的话，则调用putTreeVal方法把这个元素添加到树中去</span></span><br><span class="line"><span class="comment">     *  最后在添加完成之后，会判断在该节点处共有多少个节点（注意是添加前的个数），如果达到8个以上了的话，</span></span><br><span class="line"><span class="comment">     *  则调用treeifyBin方法来尝试将处的链表转为树，或者扩容数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();<span class="comment">//K,V都不能为空，否则的话跑出异常</span></span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());    <span class="comment">//取得key的hash值</span></span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;    <span class="comment">//用来计算在这个节点总共有多少个元素，用来控制扩容或者转移为树</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;    <span class="comment">//</span></span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)    </span><br><span class="line">                tab = initTable();    <span class="comment">//第一次put的时候table没有初始化，则初始化table</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;    <span class="comment">//通过哈希计算出一个表中的位置因为n是数组的长度，所以(n-1)&amp;hash肯定不会出现数组越界</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,        <span class="comment">//如果这个位置没有元素的话，则通过cas的方式尝试添加，注意这个时候是没有加锁的</span></span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))        <span class="comment">//创建一个Node添加到数组中区，null表示的是下一个节点为空</span></span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果检测到某个节点的hash值是MOVED，则表示正在进行数组扩张的数据复制阶段，</span></span><br><span class="line"><span class="comment">             * 则当前线程也会参与去复制，通过允许多线程复制的功能，一次来减少数组的复制所带来的性能损失</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)    </span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果在这个位置有元素的话，就采用synchronized的方式加锁，</span></span><br><span class="line"><span class="comment">                 *     如果是链表的话(hash大于0)，就对这个链表的所有元素进行遍历，</span></span><br><span class="line"><span class="comment">                 *         如果找到了key和key的hash值都一样的节点，则把它的值替换到</span></span><br><span class="line"><span class="comment">                 *         如果没找到的话，则添加在链表的最后面</span></span><br><span class="line"><span class="comment">                 *  否则，是树的话，则调用putTreeVal方法添加到树中去</span></span><br><span class="line"><span class="comment">                 *  </span></span><br><span class="line"><span class="comment">                 *  在添加完之后，会对该节点上关联的的数目进行判断，</span></span><br><span class="line"><span class="comment">                 *  如果在8个以上的话，则会调用treeifyBin方法，来尝试转化为树，或者是扩容</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;        <span class="comment">//再次取出要存储的位置的元素，跟前面取出来的比较</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;                <span class="comment">//取出来的元素的hash值大于0，当转换为树之后，hash值为-2</span></span><br><span class="line">                            binCount = <span class="number">1</span>;            </span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;    <span class="comment">//遍历这个链表</span></span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;        <span class="comment">//要存的元素的hash，key跟要存储的位置的节点的相同的时候，替换掉该节点的value即可</span></span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)        <span class="comment">//当使用putIfAbsent的时候，只有在这个key没有设置值得时候才设置</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;    <span class="comment">//如果不是同样的hash，同样的key的时候，则判断该节点的下一个节点是否为空，</span></span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,        <span class="comment">//为空的话把这个要加入的节点设置为当前节点的下一个节点</span></span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;    <span class="comment">//表示已经转化成红黑树类型了</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,    <span class="comment">//调用putTreeVal方法，将该元素添加到树中去</span></span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)    <span class="comment">//当在同一个节点的数目达到8个的时候，则扩张数组或将给节点的数据转为tree</span></span><br><span class="line">                        treeifyBin(tab, i);    </span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);    <span class="comment">//计数，可能也会触发扩容</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>扩容<code>transfer</code></p><blockquote><p>扩容主要是通过transfer方法来进行的。</p><ul><li>只有在往map中添加元素的时候，在某一个节点的数目已经超过了8个，调用<strong>treeifyBin()</strong> 触发数组的扩容/转换为数；</li><li>使用**addCount()**添加元素数组元素，会进行判断达到了sizeCtl的数量的时候，则会调用transfer方法来进行扩容</li></ul></blockquote><ul><li><p><strong>treeifyBin()</strong></p><p>某一个节点的数目已经超过了8个，执行treeifyBin() 。</p><ol><li><p>当需要扩容的时候，调用的时候tryPresize方法</p><p>（1）<strong>tryPresize方法并没有加锁</strong>，允许多个线程进入，如果数组正在扩张，则当前线程也去帮助扩容使用<strong>transfer</strong>方法</p><p>（2）<u>transfer比较复杂还没有详细看，它里面使用的synchronized 进行单个节点处理扩容</u>  （查看上面看transfer源码）</p></li><li><p>否则synchronized进行链表转换为树</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当数组长度小于64的时候，扩张数组长度一倍，否则的话把链表转为树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;treeifyBin方\t==&gt;数组长：&quot;</span>+tab.length);</span><br><span class="line">            <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)    <span class="comment">//MIN_TREEIFY_CAPACITY 64</span></span><br><span class="line">                tryPresize(n &lt;&lt; <span class="number">1</span>);        <span class="comment">// 数组扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;    <span class="comment">//使用synchronized同步器，将该节点出的链表转为树</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;    <span class="comment">//hd：树的头(head)</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p =</span><br><span class="line">                                <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)        <span class="comment">//把Node组成的链表，转化为TreeNode的链表，头结点任然放在相同的位置</span></span><br><span class="line">                                hd = p;    <span class="comment">//设置head</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                tl.next = p;</span><br><span class="line">                            tl = p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));<span class="comment">//把TreeNode的链表放入容器TreeBin中</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>addCount()</strong></p><p>addCount也主要是调用transfer，这里主要还是寄一下transfer的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Moves and/or copies the nodes in each bin to new table. See</span></span><br><span class="line"><span class="comment">     * above for explanation.</span></span><br><span class="line"><span class="comment">     * 把数组中的节点复制到新的数组的相同位置，或者移动到扩张部分的相同位置</span></span><br><span class="line"><span class="comment">     * 在这里首先会计算一个步长，表示一个线程处理的数组长度，用来控制对CPU的使用，</span></span><br><span class="line"><span class="comment">     * 每个CPU最少处理16个长度的数组元素,也就是说，如果一个数组的长度只有16，那只有一个线程会对其进行扩容的复制移动操作</span></span><br><span class="line"><span class="comment">     * 扩容的时候会一直遍历，知道复制完所有节点，没处理一个节点的时候会在链表的头部设置一个fwd节点，这样其他线程就会跳过他，</span></span><br><span class="line"><span class="comment">     * 复制后在新数组中的链表不是绝对的反序的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)    <span class="comment">//MIN_TRANSFER_STRIDE 用来控制不要占用太多CPU</span></span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range    //MIN_TRANSFER_STRIDE=16</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果复制的目标nextTab为null的话，则初始化一个table两倍长的nextTab</span></span><br><span class="line"><span class="comment">         * 此时nextTable被设置值了(在初始情况下是为null的)</span></span><br><span class="line"><span class="comment">         * 因为如果有一个线程开始了表的扩张的时候，其他线程也会进来帮忙扩张，</span></span><br><span class="line"><span class="comment">         * 而只是第一个开始扩张的线程需要初始化下目标数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 创建一个fwd节点，这个是用来控制并发的，当一个节点为空或已经被转移之后，就设置为fwd节点</span></span><br><span class="line"><span class="comment">         * 这是一个空的标志节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">        <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;    <span class="comment">//是否继续向前查找的标志位</span></span><br><span class="line">        <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep(清扫) before committing nextTab,在完成之前重新在扫描一遍数组，看看有没完成的没</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing) &#123;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                         (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="keyword">int</span> sc;</span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;        <span class="comment">//已经完成转移</span></span><br><span class="line">                    nextTable = <span class="keyword">null</span>;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);    <span class="comment">//设置sizeCtl为扩容后的0.75</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)            <span class="comment">//数组中把null的元素设置为ForwardingNode节点(hash值为MOVED[-1])</span></span><br><span class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;                <span class="comment">//加锁操作</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;        <span class="comment">//该节点的hash值大于等于0，说明是一个Node节点</span></span><br><span class="line">                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                 * 因为n的值为数组的长度，且是power(2,x)的，所以，在&amp;操作的结果只可能是0或者n</span></span><br><span class="line"><span class="comment">                                 * 根据这个规则</span></span><br><span class="line"><span class="comment">                                 *         0--&gt;  放在新表的相同位置</span></span><br><span class="line"><span class="comment">                                 *         n--&gt;  放在新表的（n+原来位置）</span></span><br><span class="line"><span class="comment">                                 */</span></span><br><span class="line">                            <span class="keyword">int</span> runBit = fh &amp; n; </span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * lastRun 表示的是需要复制的最后一个节点</span></span><br><span class="line"><span class="comment">                             * 每当新节点的hash&amp;n -&gt; b 发生变化的时候，就把runBit设置为这个结果b</span></span><br><span class="line"><span class="comment">                             * 这样for循环之后，runBit的值就是最后不变的hash&amp;n的值</span></span><br><span class="line"><span class="comment">                             * 而lastRun的值就是最后一次导致hash&amp;n 发生变化的节点(假设为p节点)</span></span><br><span class="line"><span class="comment">                             * 为什么要这么做呢？因为p节点后面的节点的hash&amp;n 值跟p节点是一样的，</span></span><br><span class="line"><span class="comment">                             * 所以在复制到新的table的时候，它肯定还是跟p节点在同一个位置</span></span><br><span class="line"><span class="comment">                             * 在复制完p节点之后，p节点的next节点还是指向它原来的节点，就不需要进行复制了，自己就被带过去了</span></span><br><span class="line"><span class="comment">                             * 这也就导致了一个问题就是复制后的链表的顺序并不一定是原来的倒序</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> b = p.hash &amp; n;    <span class="comment">//n的值为扩张前的数组的长度</span></span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 构造两个链表，顺序大部分和原来是反的</span></span><br><span class="line"><span class="comment">                             * 分别放到原来的位置和新增加的长度的相同位置(i/n+i)</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                         * 假设runBit的值为0，</span></span><br><span class="line"><span class="comment">                                         * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同为0的节点)设置到旧的table的第一个hash计算后为0的节点下一个节点</span></span><br><span class="line"><span class="comment">                                         * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">                                    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                         * 假设runBit的值不为0，</span></span><br><span class="line"><span class="comment">                                         * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同不为0的节点)设置到旧的table的第一个hash计算后不为0的节点下一个节点</span></span><br><span class="line"><span class="comment">                                         * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);    </span><br><span class="line">                            &#125;</span><br><span class="line">                            setTabAt(nextTab, i, ln);    </span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;    <span class="comment">//否则的话是一个树节点</span></span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 在复制完树节点之后，判断该节点处构成的树还有几个节点，</span></span><br><span class="line"><span class="comment">                             * 如果≤6个的话，就转回为一个链表</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>get方法</strong></p><p>get操作中，根本没有使用同步机制，<strong>也没有使用unsafe方法</strong>，所以读（get）操作是支持并发操作的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 相比put方法，get就很单纯了，支持并发操作，</span></span><br><span class="line"><span class="comment">     * 当key为null的时候回抛出NullPointerException的异常</span></span><br><span class="line"><span class="comment">     * get操作通过首先计算key的hash值来确定该元素放在数组的哪个位置</span></span><br><span class="line"><span class="comment">     * 然后遍历该位置的所有节点</span></span><br><span class="line"><span class="comment">     * 如果不存在的话返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">        <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="7-1-你知道-ConcurrentHashMap-的工作原理吗？">7.1 你知道 ConcurrentHashMap 的工作原理吗？</h5><ul><li>Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。<ul><li><strong>主要采用锁机制</strong>，在对某个Segment进行操作时，将该Segment锁定，不允许对其进行非查询操作</li></ul></li><li>Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。<ul><li><strong>CAS无锁算法</strong>，这种乐观操作在完成前进行判断，如果符合预期结果才给予执行</li></ul></li></ul><h5 id="7-2-请问ConcurrentHashMap中变量使用final和volatile修饰有什么用呢？其中链表是final的next属性，那么发生删除某个元素，如何实现的？">7.2 请问ConcurrentHashMap中变量使用final和volatile修饰有什么用呢？其中链表是final的next属性，那么发生删除某个元素，如何实现的？</h5><p>ConcurrentHashMap被final修饰的变量，（部分）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 默认segment层级</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// segment最小容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 一个segment最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 锁之前重试次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>HashEntry中被volatile修饰的部分变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="keyword">volatile</span> V value;  <span class="comment">// 保证可见性</span></span><br><span class="line">       <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure><ul><li><strong>使用final</strong>。用来实现不变模式（immutable），他是多线程安全里最简单的一种保障方式。因为你拿他没有办法，想改变它也没有机会。不变模式主要通过final关键字来限定的。在JMM中final关键字还有特殊的语义。Final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让不可变形对象不需要同步就能自由地被访问和共享。</li><li><strong>使用volatile</strong>。保证某个变量内存的改变对其他线程即时可见，在配合CAS可以实现不加锁对并发操作的支持。</li></ul><h5 id="7-3-HashTable与ConcurrentHashMap有什么区别，描述锁分段技术。">7.3 HashTable与ConcurrentHashMap有什么区别，描述锁分段技术。</h5><ul><li><strong>锁机制</strong>。 所有访问HashTable的线程都必须竞争同一把锁，效率更低；ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li><li><strong>底层数据结构</strong>。 1.8之后很相似，都是数组+链表/红黑树 ； 1.8之前，ConcurrentHashMap是Segement数组 + HashEntry数组 + 链表。</li></ul><h5 id="7-4-（阿里·淘特）ConcurrentHashMap1-8为什么不使用分段锁？">7.4 （阿里·淘特）ConcurrentHashMap1.8为什么不使用分段锁？</h5><p>先说分段锁的优点：</p><ol><li>保证在<strong>操作不同段 map</strong> 的时候<strong>可以并发执行</strong>；操作<strong>同段 map</strong> 的时候，进行<strong>锁的竞争和等待</strong>。这相<strong>对于直接对整个map同步synchronized</strong>是有优势的。</li></ol><p>但是分段锁也有一些不可忽视的缺点：</p><ol><li>分成很多段时会比较<strong>浪费内存空间</strong>(不连续，碎片化)；</li><li><strong>操作map时竞争同一个分段锁的概率非常小（段散列比较好的时候</strong>）时，分段锁反而会造成更新等操作的长时间等待；</li><li>当某个段很大时，分段锁的性能会下降。</li></ol><p>综上考虑1.8不再使用分段锁。</p><h5 id="7-5-为什么1-8中-get-方法不加锁？">7.5 为什么1.8中 get() 方法不加锁？</h5><p>因为链表每个节点的val和next都使用volatile修饰，保证了可见性。</p><h5 id="7-6-为什么1-8不使用lock而是使用sync？">7.6 为什么1.8不使用lock而是使用sync？</h5><ol><li>因为sync加入锁升级机制（jdk1.6之后），已经优化的不错了；</li><li>lock通过reentranclock实现，reentranlock是通过AQS实现，需要增加额外内存开销（CLH双向队列）。</li></ol><h5 id="7-7-ConcurrenthashMap使用的时候有可能出现不安全的情况？">7.7 ConcurrenthashMap使用的时候有可能出现不安全的情况？</h5><blockquote><p>参考：<a href="https://blog.csdn.net/luzhensmart/article/details/108133560">https://blog.csdn.net/luzhensmart/article/details/108133560</a></p></blockquote><p>查了一些资料后发现，<strong>原来ConcurrentHashMap的线程安全指的是，它的【每个方法】单独调用（即原子操作）都是线程安全的，但是代码总体的互斥性并不受控制</strong>。以上面的代码为例，最后一行中的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            this.addup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void addup() &#123;</span><br><span class="line">        if (!map.containsKey(KEY)) &#123;</span><br><span class="line">            map.put(KEY, 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.put(KEY, map.get(KEY) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>在上面一个线程内部进行了100次加法，但是其实加1在线程内部本身也并不是原子操作</strong>。</p><p>实际上并不是原子操作，它包含了三步：</p><ol><li>map.get</li><li>加1</li><li>map.put</li></ol><p>是由于在上面的代码中，map本身是一个共享变量。<strong>当线程A执行map.get的时候，其它线程可能正在执行map.put</strong>，这样一来当线程A执行到map.put的时候，线程A的值就已经是脏数据了，然后脏数据覆盖了真值，导致线程不安全。</p><h4 id="8-HashMap-和-HashSet区别-？">8. HashMap <strong>和</strong> HashSet<strong>区别</strong> ？</h4><blockquote><p>如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了clone() 、 writeObject() 、 readObject() 是 HashSet ⾃⼰不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p></blockquote><table><thead><tr><th style="text-align:center"><strong>HashMap</strong></th><th style="text-align:center"><strong>HashSet</strong></th></tr></thead><tbody><tr><td style="text-align:center">实现了Map接⼝</td><td style="text-align:center">实现Set接⼝</td></tr><tr><td style="text-align:center">存储键值对</td><td style="text-align:center">仅存储对象</td></tr><tr><td style="text-align:center">调⽤ <code>put()</code> 向map中添加元素</td><td style="text-align:center">调⽤ <code>add()</code> ⽅法向Set中添加元素</td></tr><tr><td style="text-align:center">HashMap使⽤键（Key）计算Hashcode：<code>int hash = hash(key);</code></td><td style="text-align:center">HashSet使⽤成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()⽅法⽤来判断对象的相等性。</td></tr></tbody></table><h4 id="9-说说HashSet的基本原理？">9. 说说HashSet的基本原理？</h4><ul><li><p><strong>底层结构</strong></p><p><code>HashSet</code>底层原理完全就是包装了一下<code>HashMap</code> ，只不过存储的时候<code>value</code>是默认存储了一个<code>Object</code>的静态常量，取的时候也是只返回<code>key</code>，所以看起来就像<code>List</code>一样。</p></li><li><p><strong>初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>add()方法</strong></p><p>可以看到这三个方法都是直接调用的<code>HashMap</code>的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>add其实就是调用HashMap的put方法，那么如何保证<strong>唯一性</strong>？</p></blockquote><p><strong>如果<code>哈希值</code>和<code>key</code>都一样</strong>，就会直接拿新值<strong>覆盖旧值</strong>，而<code>HashSet</code>就是利用这个特性来保证唯一性。</p><p>其实和HashMap就是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br></pre></td></tr></table></figure></li><li><p><strong>contains方法</strong>（<s>Get()方法</s> ）</p><p><strong>hashset没有get方法</strong>，因为没有意义：不需要获取某个键值对应的value。</p><p>具体实现直接调用hashmap的containsKey()方法：</p><blockquote><p>过程和hashmap的get方法过程差不多，返回为null则是不存在。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="9-1-HashSet如何检查重复-？">9. 1 HashSet<strong>如何检查重复</strong> ？</h5><ol><li>把对象加⼊ HashSet 时，HashSet先计算对象的hashcode 值；</li><li>根据hashcode值计算出要加⼊的位置，同时也会与其他加⼊的对象的hashcode值作⽐教；</li><li>如果没有相符的hashcode，HashSet会假设对象没有重复出现；</li><li><strong>如果发现有相同hashcode值的对象，这时会调用 equals()</strong> 方法来检查hashcode相等的对象是否真的相同，如果两者相同，HashSet就不会让加⼊操作成功。</li></ol><h5 id="9-2-【新】contains-方法在HashSet和ArrayList的实现区别？">9.2 【新】contains()方法在HashSet和ArrayList的实现区别？</h5><ul><li><p><strong>Arraylist</strong></p><p>因为底层是object数组，判断某个对象是否存在，其实是通过遍历来进行判断的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;<span class="comment">//#1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回指定元素在列表中第一次出现的索引，如果该列表不包含该元素，则返回-1。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Hashset</strong></p><p>Hashset是<strong>hash值 &amp;&amp; 遍历链表equals()</strong> 都相等，来判断的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-comparable-和-Comparator的区别？">10. comparable <strong>和</strong> Comparator的区别？</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/xujian2014/p/5215082.html">https://www.cnblogs.com/xujian2014/p/5215082.html</a></p></blockquote><ul><li><p>Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。</p><blockquote><p>例如Person类，实现Comparable接口，使得所有Person类对象可以按照各自年龄大小进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.age-p.getAge();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p><blockquote><p>Person类没有实现Comparable接口，该如何比较大小呢？我们可以新建一个类，让其实现Comparator接口，从而构造一个“比较器&quot;。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。。</p></li></ul><h4 id="11-如何选用集合">11. <strong>如何选用集合</strong>?</h4><p><img src="https://img-blog.csdn.net/20140630092900390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaml1cWl5dWxpYW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p><strong>需要存储键值对</strong>：</p><ul><li><strong>Map接口的集合</strong><ul><li>需要排序时选择TreeMap</li><li>不需要排序时就选择HashMap</li><li>需要保证线程安全就选⽤ConcurrentHashMap</li></ul></li></ul><p><strong>只需要存储元素，实现collection接口的集合，又分为</strong>：</p><ul><li><strong>需要保证元素唯一–Set接口的集合</strong><ul><li>HashSet</li></ul></li><li><strong>不需要元素唯一–List接口结合</strong><ul><li>查找比较多：ArrayList</li><li>增删比较多：LinkedList</li></ul></li></ul><h3 id="1-3-3-List">1.3.3 <strong>List</strong></h3><h4 id="1-用过-ArrayList-吗？说一下它有什么特点？">1.<strong>用过 ArrayList 吗？说一下它有什么特点</strong>？</h4><ul><li><strong>自动扩容</strong>： 当加入数据达到一定程度后，会实行自动扩容，即扩大数组大小 ；</li><li><strong>底层实现</strong>：底层是使用数组实现，add(int,o)，添加到某个位置，那么可能会挪动大量的数组元素，并且可能会触发扩容机制；</li><li><strong>线程不安全</strong></li></ul><h4 id="2-ArrayList-与-Vector-区别呢-为什么要用Arraylist取代Vector呢？">2. ArrayList <strong>与</strong> Vector <strong>区别呢</strong>?<strong>为什么要用</strong>Arraylist<strong>取代</strong>Vector<strong>呢</strong>？</h4><ul><li><p><strong>线程安全</strong>： Vector线程安全，ArrayList 不是；</p></li><li><p><strong>Vector耗时</strong>：Vector 类的所有方法都是同步的。可以由两个线程安全地访问⼀个Vector对象、但是⼀个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p></li></ul><h4 id="3-Array-ArrayList不同点">3. Array &amp; ArrayList不同点?</h4><ol><li><strong>Array可以包含基本类型和对象类型</strong>，<strong>ArrayList只能包含对象类型</strong> ；</li><li>Array大小是固定的，ArrayList的大小是 <u>动态变化</u> 的 ；</li><li>ArrayList提供了更多的方法和特性: addAll()，removeAll()，iterator()。</li></ol><h4 id="4-Arraylist-与-LinkedList-区别">4. Arraylist <strong>与</strong> LinkedList <strong>区别</strong>?</h4><ul><li><p><strong>索引/插入</strong>：ArrayList按序号索引，索引快插入慢；LinkedList不是，索引慢，插入快；</p></li><li><p><strong>内存方面</strong>： Arraylist 是线性连续存储， 内存利用更低；LinkedList 是链表，内存利用更高（将内存零散空间串联），但也更占有内存（每个节点存储了两个引用）；</p></li><li><p><strong>线程安全</strong>： ArrayList 和 LinkedList 都是不同步的，也就是<strong>都不</strong>保证线程安全；</p></li><li><p><strong>底层数据结构</strong>： Arraylist 底层使用的是 <strong>Object</strong>数组； LinkedList  底层使用的是<strong>双向链表</strong> 数据结构 ；</p><blockquote><p>JDK1.6之前为循环链表，JDK1.7取消了循环。</p></blockquote></li></ul><h4 id="5-【-u-源码解读-u-】说说ArrayList的扩容机制吧-？为什么是扩容1-5倍？默认大小是多少。">5. 【<u>源码解读</u>】说说ArrayList的扩容机制吧 ？为什么是扩容1.5倍？默认大小是多少。</h4><blockquote><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81%2B%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90.md">逐源码分析扩容机制</a></p></blockquote><p>先把回答写在下面：</p><blockquote><p><strong>ArrayList/vector默认大小都是10，但vectot扩容是2倍</strong>。</p></blockquote><p><strong>1. 扩容机制</strong>：</p><p>使用无参构造函数创建的数组长度为0，当第一次add后数组长度为10 ； 如果继续add超过10后，也就是不满足<strong>minCapacity（最小需要容量） - elementData.length &gt; 0</strong> 会触发扩容机制。 将新容量更新为旧容量的1.5倍 ，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】。</p><p>最后检查设置的新容量是否大于最大容量MAX_ARRAY_SIZE ，进入<code>hugeCapacity()</code> :</p><ul><li>如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code> 。</li></ul><p><strong>2. 为什么是1.5倍</strong>？</p><p>因为，<strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)，所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同。</p><p>比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数。</p><ul><li><p><strong>ArrayList总览</strong></p><p><code>ArrayList</code>继承于<strong>AbstractList</strong> ，实现了<strong>List</strong>,<strong>RandomAccess</strong>,<strong>Cloneable</strong>,<strong>java.io.Serializable</strong> 这些接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问；</li><li><code>ArrayList</code> 实现了<strong>Cloneable 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆；</li><li><code>ArrayList</code> 实现了 <code>java.io.Serializable </code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li></ul></li><li><p><strong>ArrayList 核心源码解读（先耐心看一遍</strong>）</p><p>直接点击上面链接 <a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81%2B%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90.md">逐源码分析扩容机制</a> 查看。</p></li><li><p><strong>【重点】JDK8 <u>扩容机制</u> 解读</strong></p><ol><li><p><strong>从构造函数说起</strong></p><p>（JDK8）ArrayList 有三种方式来初始化 :</p><ul><li>以<strong>无参数构造方法</strong>创建 ArrayList 时，实际上初始化赋值的是一个<strong>空数组</strong>。<u>当真正对数组进行添加元素操作时，才真正分配容量</u>。即向数组中添加第一个元素时，数组容量扩为 10。</li><li>jdk8中的ArrayList的对象的创建<strong>类似于单例的懒汉式</strong>。JDK8的内存优化也值得我们在平时开发中学习。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 默认初始容量大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 空数组（用于空实例）。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">     </span><br><span class="line">  <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">   <span class="comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 保存ArrayList数据的数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * ArrayList 所包含的元素个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment"> /**</span></span><br><span class="line"><span class="comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">         <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">         <span class="comment">//创建空数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">     elementData = c.toArray();</span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// replace with empty array.</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>再看<code>add</code>方法</strong></p><blockquote><p>这里<u>以无参构造函数创建的 ArrayList</u> 为例分析 。</p></blockquote><blockquote><p>JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">      ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">      <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">      elementData[size++] = e;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>再看 <code>ensureCapacityInternal()</code> 方法</strong></p><p>第2步（JDK7）可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code> 。</p><ul><li><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></li><li>然后开始调用 <code>ensureExplicitCapacity()</code> 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">          minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">      ensureExplicitCapacity(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>调用 <code>ensureCapacityInternal()</code> 进入<code>ensureExplicitCapacity()</code>这个方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们来仔细分析一下：</p><ul><li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，<strong>所以 minCapacity 此时为 10</strong>。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li><li>当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>添加第 3、4···到第 9 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li></ul><p>直到添加第 10 个元素，<code>minCapacity &lt; elementData.length</code><strong>不成立</strong>。进入 grow 方法进行扩容。</p></li><li><p><strong>elementData.length（实际容量）&gt;= minCapacity（最小需要容量）  , 执行 grow()</strong></p><blockquote><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数。</p></blockquote><p>将新容量更新为旧容量的1.5倍 ，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】。</p><ul><li>最后检查设置的新容量是否大于最大容量MAX_ARRAY_SIZE ，进入<code>hugeCapacity()</code> :<ul><li>如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code> 。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">     </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ArrayList扩容的核心方法grow。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">       <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】，</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">      <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">      <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br></pre></td></tr></table></figure></li><li><p><strong>设置完新容量 newCapacity ，进行<code>Arrays.copyOf</code></strong></p><p>Arrays的copyOf()方法传回的数组是新的数组对象，改变传回数组中的元素值，不会影响原来的数组。</p><ul><li><u>第二个自变量指定要建立的新数组长度</u>，如果新数组的长度超过原数组的长度，则保留数组默认值，例如：</li></ul><p>使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容。</p></li></ol></li><li><p><strong>contains()方法</strong></p><p>就是遍历数组看是否存在该元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;<span class="comment">//#1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回指定元素在列表中第一次出现的索引，如果该列表不包含该元素，则返回-1。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="5-1-多线程操作ArrayList会出现什么错误？">5.1 多线程操作ArrayList会出现什么错误？</h5><p>从ArrayList的（1）添加元素（<code>add</code>/<code>addAll</code>）和（2）获取元素（<code>get</code>）  两个角度来说：</p><ol><li><p><strong>多线程添加元素</strong></p><p>假设此时<code>minCapacity（最小需要容量）= 10</code> ，此时数组容量是10。A,B两个线程各需要添加若干元素，<strong>同时</strong> 判断此时不需要扩容，后续可能就会发生<strong>数组越界</strong>。</p></li><li><p><strong>多线程获取元素</strong></p><p>一个线程正在修改某个元素，另外一个线程此时正在读，那么读到的就是修改前的元素，也就是<strong>脏数据</strong>。</p></li></ol><h5 id="5-2-arraylist可以存多少数据？">5.2 <strong>arraylist可以存多少数据</strong>？</h5><p>Integer.MAX_VALUE = 2147483647 。</p><p>arraylist底层是一个数组对象：Object[] arr = new Object[10]，数组的大小只能设置int类型。所以能存储2147483647 字节数据。</p><h4 id="6-说一下LinkedList底层原理？">6. 说一下LinkedList底层原理？</h4><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000021433760">Java集合系列之三：LinkedList底层原理</a></p></blockquote><p>LinkedList实现了<strong>List</strong>接口和<strong>Deque</strong>接口的，底层的<strong>双端链表</strong>结构使它支持高效的插入和删除操作，<u>也具有队列的特性</u>，非线程安全的。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/2192701-9c26f117619ad840.png" alt="img"></p><blockquote><p>相比ArrayList要简单很多，主要是双向链表那些操作。</p></blockquote><ul><li><p><strong>底层结构</strong></p><p>核心属性、构造方法和Node定义如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;<span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;   <span class="comment">//LinkedList中存放的元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;  <span class="comment">//头节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;   <span class="comment">//尾节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，创建一个空的列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个指定的集合添加到LinkedList中，先完成初始化，在调用添加操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span>     </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node节点    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     E item;</span><br><span class="line">     Node&lt;E&gt; next;</span><br><span class="line">     Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">     Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">         <span class="keyword">this</span>.item = element;</span><br><span class="line">         <span class="keyword">this</span>.next = next;</span><br><span class="line">         <span class="keyword">this</span>.prev = prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>add() 方法</strong></p><p><strong>朴实无华的双向链表尾插法</strong>。获得当前最后一个节点最为当前节点的前置节点，同样把当前节点设置为前置节点的后置节点，然后把当前节点作为最后一个节点，因为只需要创建一个节点与前一个节点建立前后关系即可，时间复杂度是O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得当前最后一个节点作为前置节点，可能为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 初始化当前节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 把当前节点作为最后的节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 第一次添加设置为第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 把当前节点设置为前置节点的后置节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>add(int index,E e)</strong></p><p>按索引插入元素，首先判断是不是第一个添加的元素，如果是的话，直接使用add()方法添加就可以了，如果不是则需要根据索引来遍历寻找链表上对应位置。</p><ul><li>这里用了个小技巧，<strong>判断索引是在前半段还是在后半段</strong>，从短的那头开始遍历，找到之后，新建一个节点，建立新的前置节点和后置节点的关系。时间复杂度是O(n)，n为size/2。</li></ul></li><li><p><strong>get(int index)方法</strong></p><p>get()方法是用的上面介绍过的node()方法，时间复杂度是O(n)，n为size/2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 判断数组越界</span></span><br><span class="line">     checkElementIndex(index);</span><br><span class="line">     <span class="comment">// 遍历寻找节点</span></span><br><span class="line">     <span class="keyword">return</span> node(index).item;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得被插入索引上的元素</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"><span class="comment">// 如果索引是在链表的前半段</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="comment">// 获得第一个节点</span></span><br><span class="line">    Node&lt;E&gt; x = first;</span><br><span class="line">    <span class="comment">// 往后找到插入索引位置上的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        x = x.next;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果索引是在链表的前半段</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获得最后个节点</span></span><br><span class="line">    Node&lt;E&gt; x = last;</span><br><span class="line">    <span class="comment">// 往前找到插入索引位置上的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">        x = x.prev;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-4-迭代器">1.3.4 迭代器</h3><h4 id="1-请简单说明一下什么是迭代器？">1.<strong>请简单说明一下什么是迭代器</strong>？</h4><p>Iterator提供了统一遍历操作集合元素的统一接口, <strong>Collection接口实现Iterable接口</strong>。</p><ul><li>每个集合<strong>都通过实现Iterable接口中iterator()方法</strong>返回Iterator接口的实例, 然后对集合的元素进行迭代操作；</li><li>在<u><strong>迭代元素的时候不能通过集合的方法删除元素</strong></u>, 否则会抛出ConcurrentModificationException 异常. 但是可以通过Iterator接口中的remove()方法进行删除。</li></ul><h4 id="2-请你说说Iterator和ListIterator的区别？">2.<strong>请你说说Iterator和ListIterator的区别</strong>？</h4><ul><li><strong>遍历类型</strong>：<code>Iterator</code>可用来遍历Set和List集合，但是<code>ListIterator</code>只能用来遍历List；</li><li><strong>遍历方向</strong>：<code>Iterator</code>对集合只能是前向遍历，<code>ListIterator</code>既可以前向也可以后向；</li><li><strong>功能区别</strong>：<code>ListIterator</code>实现了Iterator接口，并包含其他的功能</li></ul>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（一）_Java_面对对象</title>
      <link href="/p/7257/"/>
      <url>/p/7257/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h2 id="1-2-面对对象">1.2 面对对象</h2><h3 id="1-2-1-基本问题">1.2.1 基本问题</h3><h4 id="1-介绍一下面对对象七大原则？三大特性？">1.<strong>介绍一下面对对象七大原则？三大特性</strong>？</h4><h5 id="七大原则">七大原则</h5><ul><li><p><strong>单一职责原则</strong>： 就一个类来说，应该仅有一个引起它变化的原因。也就是说，<strong>一个类应该只有一个职责</strong>。</p><blockquote><p>如果有多个职责，那么就相当于把这些指责耦合在起，一个职责的变化就可能削弱或抑制了这个类完成其他职责的能力，引起类的变化的原因就会有多个。所以在构造一个类时， 将类的不同职责分离至两个或多个类中(或者接口中)，确保引起该类变化的原因只有一个。</p></blockquote></li><li><p><strong>开闭原则(OCP)</strong>： 软件组成实体应该是可扩展的，但是不可修改。开放-封闭原则认为应该试图设计永远也不需要改变的模块。可以添加新代码来打展系统的行为，不能对已有的代码进行修改。</p><blockquote><p>这个原则很好的实现了面向对象的封装性和可重用性。</p></blockquote></li><li><p><strong>李氏替换原则(LSP)</strong>： 子类应当可以替换父类并出现在父类能够出现的任何地方。</p><blockquote><p>以圆和椭圆为例，圆是椭圆的一一个特殊子类。因此任何出现椭圆的地方，圆均可以出现。</p></blockquote></li><li><p><strong>依赖倒置原则(DIP)</strong>： 在进行业务设计时，与<u>特定业务有关的依赖</u>关系应该尽量依赖<strong>接口和抽象类</strong>，<strong>而不是依赖于具体类</strong>。具体类只负责相关业务的实现，修改具体类不影响与特定业务有关的依赖关系。</p><blockquote><p>为此，在进行业务设计时，应尽量在接口或抽象类中定义业务方法的原型，并通过具体的实现类(子类)来实现该业务方法，业务方法内容的修改将不会影响到运行时业务方法的调用。</p></blockquote></li><li><p><strong>接口分离原则(ISP)</strong>：  <u>采用多个与特定客户类有关的接口</u> 比采用一个通用的涵盖多个业务方法的接口要好。</p><blockquote><p>举例：如果拥有一个针对多个客户的类，为每一个客户创建特定业务接口，然后使该客户类继承多个特定业务接口将<u>比直接加载客户所需所有方法有效</u>。</p></blockquote></li><li><p><strong>组合重用原则</strong> ：能用组合实现的地方，<strong>尽量用组合来</strong>实现，而<strong>不要使用继承</strong>来扩展功能。</p><blockquote><p>097因为组合能更好地实现封装，比继承具有更大的灵活性和更稳定的结构。</p></blockquote></li><li><p><strong>迪米特原则 :</strong> <u>一个对象应该对于其他对象有最少的了解</u>，这样做的好处就是可以有效地降低类之间的耦合要求。</p></li></ul><h5 id="三大特性">三大特性</h5><ul><li><p><strong>封装</strong>。<u>封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的方法</u>，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果⼀个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p></li><li><p><strong>继承</strong>。 <u>继承是使用已存在的类的定义作为基础建⽴新类的技术，新类的定义可以增加新的数据或新的功能</u>，也可以用⽗类的功能，但不能选择性地继承⽗类。通过使用继承我们能够非常方便地<strong>复用</strong>以前的代码。</p><blockquote><ol><li>子类拥有⽗类对象所有的属性和方法（包括私有属性和私有方法），但是⽗类中的私有属性和方法子类是无法访问，只是拥有。</li><li>子类可以拥有⾃⼰属性和方法，即子类可以对⽗类进行扩展。</li><li>子类可以用⾃⼰的方式实现⽗类的方法。</li></ol></blockquote></li><li><p><strong>多态</strong>。（1）<strong>静态多态：重载</strong> （2）<strong>动态多态</strong>：所谓多态就是指程序中定义的<strong>引用变量所指向的具体类型</strong>和&lt;通过该<strong>引用变量发出的方法调用</strong>在<strong>编程时并不确定</strong>，而是在【<strong>程序运行期间才确定</strong>】。即⼀个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><blockquote><p>在 Java 中有两种形式可以实现多态：<strong>继承</strong>（多个子类对同⼀方法的重写）和<strong>接口</strong>（实现接口并覆盖接口中同⼀方法）。</p></blockquote></li></ul><h5 id="1-1-java多态的原理？【阿里-待重写】">1.1 java多态的原理？【阿里&amp;待重写】</h5><p>多态分两种：（1）【编译】时多态（静态多态）（2）运行时多态（动态多态）。</p><ol><li><p><strong>静态多态</strong></p><p><strong>重载</strong>（overload）就是编译时多态的一个例子，<strong>编译时</strong>多态在编译时就已经<strong>确定</strong>。</p><p>运行时运行的时候调用的是确定的方法。</p></li><li><p><strong>动态多态</strong></p><blockquote><p>我们通常所说的多态指的都是运行时多态，也就是<strong>编译时不确定究竟调用哪个具体方法</strong>，一直延迟到运行时（<strong>链接过程</strong>）才能确定。</p></blockquote><p>通常动态多态的实现方法：</p><ol><li>子类继承父类（extends）</li><li>类实现接口（implements）</li></ol><p>核心之处就在于<strong>对父类方法的改写或对接口方法的实现</strong>，以取得在运行时不同的执行效果。</p></li><li><p><strong>多态运行的原理</strong></p><blockquote><p>详细建议查看：<a href="https://zhuanlan.zhihu.com/p/94086109">深入理解Java多态的实现原理</a></p></blockquote><ul><li><p><strong>背景介绍</strong></p><p><img src="https://i.loli.net/2021/04/21/m1Ot3nQcMGq2YfW.jpg" alt="img"></p><p><u>类加载</u> 时会将<strong>类的元数据信息</strong>（<strong>类的方法代码、类变量、成员变量的定义</strong>等等）保存到方法区，<strong>方法区</strong>主要分为两部分：</p><ol><li><strong>常量池</strong>：Java 类引用的一些常量信息，比如<strong>类的符号引用信息</strong></li><li><strong>方法区其它部分</strong>： 保存<strong>方法表</strong>等</li></ol><p><u>链接过程</u> <strong>类的多态就发生在 <u>链接的解析</u></strong> 过程，将 <u>符号引用替换为直接引用</u>。</p></li><li><p><strong>原理简述（子类方法继承</strong>）</p><blockquote><p>参考：<a href="https://www.huaweicloud.com/articles/9b805c24ab31a65f5883c0dfeaf5a39b.html">https://www.huaweicloud.com/articles/9b805c24ab31a65f5883c0dfeaf5a39b.html</a></p></blockquote></li></ul></li></ol><h4 id="2-请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？">2.<strong>请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数</strong>？</h4><ul><li><strong>构造函数</strong>： 每一个类都有构造函数，程序员没有创建时，编译器会默认创建一个构造函数；<strong>对象被创建时，构造函数被调用</strong>；</li><li><strong>构造函数重载</strong>： 和方法重载类似，一个类可以创建多个构造函数，每个构造函数都有<strong>唯一参数列表</strong>；</li><li><strong>复制构造函数</strong>： Java不支持像C++中那样的复制构造函数。</li></ul><h4 id="3-请说明Java中的方法重写-Overriding-和方法重载-Overloading-是什么意思？构造函数能否被重写？">3.<strong>请说明Java中的方法重写(Overriding)和方法重载(Overloading)是什么意思？构造函数能否被重写</strong>？</h4><ul><li><p>Overriding ： 方法重写是说<u>子类重新定义了父类的方法</u>，有<u>相同的方法名，参数列表和返回类型</u> ；</p></li><li><p>Overloading： 同一个类里面两个或者是多个方法<u>同名</u> ，但 <u>参数列表不同</u>不同。</p><blockquote><p>特别的重写要求返回类型一致，但<strong>重载不要求返回类型一致</strong>！</p></blockquote></li></ul><p><strong>构造函数不能被 override（重写）</strong>！但是可以 overload（重载）,所以你可以看到⼀个类中有多个构造函数的情况。</p><h5 id="3-1-f（List-String-l）-f（List-Integer-l）是重载么？">3.1 f（List&lt;String&gt; l） f（List&lt;Integer&gt; l）是重载么？</h5><p>不是重载。</p><p>静态类型一致，并<strong>不会因为泛型而改变</strong>。因为<strong>编译</strong>期间，会对泛型进行<strong>擦除</strong>。</p><h4 id="4-介绍一下接口和抽象类的区别？">4.<strong>介绍一下接口和抽象类的区别</strong>？</h4><ul><li><p><strong>设计层面</strong></p><p>接口，是对类的行为进行约束，<strong>强制要求</strong>不同类实现相同行为 ； 抽象类，既 1.<strong>非抽象类实现代码复用</strong> 2.又同时有<strong>抽象方法使得被继承类各自实现</strong>。</p></li><li><p><strong>方法实现</strong></p><p>抽象类可以<strong>有非抽象方法，有方法体</strong> ； 接口不能有。</p><blockquote><p><strong>抽象类中添加新的方法，你可以给它提供默认的实现</strong>。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。</p></blockquote></li><li><p><strong>构造函数</strong></p><p>抽象类有；接口没有。</p></li><li><p><strong>修饰符</strong></p><p>抽象类除private 都有（抽象类目的是被继承，所以<strong>抽象方法是为被重写，不能私有</strong>）；接口<strong>默认public</strong>。</p></li><li><p><strong>继承个数 [接口优]</strong></p><p>抽象类只能被继承一次；接口可以有多个。</p></li></ul><h4 id="5-Java的四种引用？强软弱虚-？">5. <strong>Java的四种引用？强软弱虚</strong> ？</h4><ul><li><p><strong>强引用</strong> ：强引用是平常中使用最多的引用，强引用<strong>在程序内存不足（OOM</strong>）的时候也不会被回收，使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure></li><li><p><strong>软引用</strong>： 软引用<strong>在程序内存不足时，会被回收（“软”，没钱用了第一个被打劫</strong>），使用方式：</p><blockquote><p>可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收<u>早先创建的对象</u>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，</span></span><br><span class="line"><span class="comment">// 这里的软引用指的是指向new String(&quot;str&quot;)的引用，也就是SoftReference类中T</span></span><br><span class="line">SoftReference&lt;String&gt; wrf = <span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>弱引用</strong>：是<strong>只要<u>JVM垃圾回收器发现了弱引用</u>，就会将之回收</strong>，使用方式：</p><blockquote><p><strong>可用场景</strong>：  Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用。一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; wrf = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure></li><li><p><strong>虚引用：无法通过虚引用来获取对一个对象的真实引用</strong>； 虚引用必须与ReferenceQueue一起使用，当GC准备回收一个<strong>对象</strong>，如果发现<strong>它还有虚引用</strong>，就会在回收之前，把这个虚引用加入到与之关联的ReferenceQueue中。</p><blockquote><p>可用场景： 对象销毁前的一些操作，比如说资源释放等。 Object.finalize() 虽然也可以做这类动作，但是这个方式即不安全又低效。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; prf = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>),</span><br><span class="line"><span class="keyword">new</span> ReferenceQueue&lt;&gt;());</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-JAVA创建对象的机制？">6. <strong>JAVA创建对象的机制</strong>？</h4><ul><li><p>new创建新对象</p></li><li><p>通过反射机制</p></li><li><p>采用clone机制</p></li><li><p>通过序列化机制</p></li></ul><h4 id="7-简述Java的对象结构？">7.<strong>简述Java的对象结构</strong>？</h4><p>Java对象由三个部分组成：对象头、实例数据、<u>对齐填充</u>。</p><ol><li><p><strong>对象头</strong>。 在JVM中，对象在内存中除了本身的数据外还会有个对象头，对于普通对象而言，其对象头中有两类信息：<strong>mark word和类型指针</strong>。 如果是数组对象，还有数组长度。</p><ol><li><p><u><code>mark word(32位)</code></u></p><p><img src="https://i.loli.net/2021/05/16/PjXkchreF9sSEKG.png" alt="image-20210516131559341"></p><ul><li>具体的内容包含对象的hashcode、分代年龄、轻量级锁指针、重量级锁指针、GC标记（分代年龄）、偏向锁线程ID、偏向锁时间戳。</li><li>当对象状态为偏向锁时，<code>mark word</code>存储的是偏向的线程ID；当状态为轻量级锁（lightweight locked）时，<code>mark word</code>存储的是指向线程栈中<code>Lock Record</code>的指针；<strong>当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针</strong>。</li></ul></li><li><p><u>存储类型指针</u>，也就是指向类的元数据的指针，通过这个指针才能确定对象是<strong>属于哪个类的实例</strong>；</p></li><li><p><u>数组长度：</u>另外对于数组而言还会有一份记录数组长度的数据。</p></li></ol></li><li><p><strong>实例数据</strong>。 来存储对象真正的有效信息（包括父类继承下来的和自己定义的）；</p></li><li><p><strong>对齐填充</strong>。JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）。</p></li></ol><h4 id="8-Object有哪些常用方法？">8. Object有哪些常用方法？</h4><ul><li><em>equals方法</em></li><li>hashCode方法</li><li>wait方法</li><li>notify方法</li><li>notifyAll方法</li></ul><h3 id="1-2-2-反射">1.2.2 反射</h3><h4 id="1-请说明一下JAVA中反射的实现过程和作用分别是什么？-（快手）优缺点？">1.<strong>请说明一下JAVA中反射的实现过程和作用分别是什么</strong>？ （快手）优缺点？</h4><ul><li><p><strong>定义</strong></p><p>反射机制是<strong>在运行时</strong>，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p><blockquote><p>jdbc就是典型的反射 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&#x27;com.mysql.jdbc.Driver.class&#x27;</span>);<span class="comment">//加载MySQL的驱动类</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>实现和作用</strong></p><p>JAVA语言编译之后会生成一个<code>.class</code>文件，反射就是通过<strong>字节码</strong>文件<strong>找到某一个类、类中的方法以及属性</strong>等。</p><ul><li><p><strong>实现</strong>： （1）<strong>代码会编译成一个.class文件</strong> （2）<strong>类加载器加载进JVM的内存中，在方法区创建了Object类的Class对象</strong></p><blockquote><p>不是new出来的对象，而是类的类型对象，每个类都只有一个Class对象，作为方法区类的数据结构的接口。</p></blockquote><p>我们便是通过这个class对象来进行反射获取类的信息。</p></li><li><p><strong>作用</strong>：</p><ol><li>反射机制指的是程序在运行时能够获取自身的信息。在JAVA中，<strong><u>只要给定类的名字</u></strong>，那么就可以通过反射机制来获取类的所有信息。</li><li>根据类名在<strong>运行时创建实例</strong>（类名可以从配置文件读取，不用new）</li></ol></li></ul></li><li><p><strong>反射优缺点</strong></p><ul><li><strong>优点</strong>：（1）对于任意一个类，都能够知道这个类的所有属性和方法；（2）对于任意一个对象，都能够调用它的任意一个方法</li><li><strong>缺点</strong>：<ul><li><strong>性能降低</strong> ： 反射包括了一些<strong>动态类型</strong>，所以JVM<strong>无法对这些代码进行优化</strong></li><li><strong>安全限制</strong>： 使用反射技术要求程序必须在一个<strong>没有安全限制的环境</strong>中运行</li><li><strong>内部暴露</strong>：由于反射允许代码执行一些在正常情况下不被允许的操作（比如<strong>访问私有的属性和方法</strong>），所以使用反射可能会导致意料之外的副作用</li></ul></li></ul></li></ul><h4 id="2-解释一下JAVA代理模式？动态代理的原理？">2. 解释一下JAVA代理模式？动态代理的原理？</h4><blockquote><p>参考这个：<a href="https://zhuanlan.zhihu.com/p/54733692">JAVA面试50讲之9：动态代理的原理是什么？</a></p></blockquote><p>代理模式是给某一个对象提供一个代理，并由【<strong>代理对象】控制对【原对象】的引用(使用)</strong>。</p><ul><li><strong>优点</strong>：代理模式能够协调调用者和被调用者，<u>在一定程度上降低了系统的<strong>耦合度</strong></u>；可以<u>灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务</u>。</li><li><strong>缺点</strong>：由于使用了代理模式，因此程序的性能<u>没有直接调用性能高</u>；使用代理模式<u>提高了代码的复杂度</u>。</li></ul><p>根据代理模式又可以分为：静态代理和动态代理。</p><h5 id="2-1-静态代理">2.1 静态代理</h5><blockquote><p>静态代理：由程序员创建或特定工具自动生成源代码，也就是在<strong>编译时</strong>就已经将接口、被代理类、代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。</p></blockquote><p>代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。</p><ul><li><p>一个班的同学（Student）要向老师交班费，但是都是通过班长（StudentProxy）把自己的钱转交给老师。这里，班长就是代理学生上交班费，班长就是学生的代理。</p></li><li><p><strong>公共Person接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Student实现Person接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;上交班费50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>StudentsProxy实现Person接口</strong></p><p>实现了Peson接口，<strong>同时持有一个Student对象</strong>，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为。</p><blockquote><p>⚠️ 自己实现的giveMoney，调用的是<strong>被代理的学生对象.giveMoney()</strong> 方法！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsProxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentsProxy</span><span class="params">(Person stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理上交班费，调用被【代理学生的上交班费】行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用实例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//被代理的学生张三，他的班费上交有代理对象monitor（班长）完成</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成代理对象，并将张三传给代理对象</span></span><br><span class="line">        Person monitor = <span class="keyword">new</span> StudentsProxy(zhangsan);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//班长代理上交班费，实际上是调用被代理对象的giveMoney方法</span></span><br><span class="line">        monitor.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用实例2</strong>：扩充增强原对象方法</p><p>班长在帮张三上交班费之前，想要先反映一下<strong>张三最近学习有很大进步</strong>，通过代理模式很轻松就能办到 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsProxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentsProxy</span><span class="params">(Person stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张三最近学习有进步！&quot;</span>);</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-2-动态代理">2.2 动态代理</h5><blockquote><p>上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就<strong>已经编译</strong>完成 。</p></blockquote><p>然而动态代理，代理类<strong>并不是在Java代码中定义</strong>的，而是在运行时根据我们在Java代码中的“指示”<strong>动态生成</strong>“的 。</p><ul><li><p><strong>优点</strong>： 可以很方便的对代理类的函数进行统一的处理，<strong>而不用修改每个代理类中的方法</strong>。 比如说，想要在每个代理的方法前<u>都加上</u>一个处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="comment">//调用被代理方法前加入处理方法</span></span><br><span class="line">        beforeMethod();</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 代理类其它方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveHomework</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//调用被代理方法前加入处理方法</span></span><br><span class="line">        beforeMethod();</span><br><span class="line">        stu.giveHomework();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>除了giveMonney还有很多其他的方法（giveHomework），那就需要写很多次beforeMethod方法，麻烦。</p></li><li><p><strong>简单实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">  InvocationHandler stuHandler = <span class="keyword">new</span> MyInvocationHandler&lt;Person&gt;(stu);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">  Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler);</span><br></pre></td></tr></table></figure></li><li><p><strong>公共Person接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Student实现Person接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//假设数钱花了一秒时间</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;上交班费50元&quot;</span>);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>增加一个计算方法执行时间的检测方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tl.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束时打印耗时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> finishTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(methodName + <span class="string">&quot;方法耗时&quot;</span> + (finishTime - tl.get()) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>StuInvocationHandler 实现 InvocationHandler接口</strong></p><blockquote><p>并没有像之前一样：用一个代理类 StudentsProxy实现公共<strong>Person</strong>接口，而是代理类StuInvocationHandler 实现<strong>InvocationHandler</strong>接口。</p><p>但二者<strong>都是持有被代理的对象Student引用</strong>。</p></blockquote><p>InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。</p><ul><li>通过<strong>反射</strong>，可以执行被代理对象Student的相应方法giveMoney()。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StuInvocationHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">   <span class="comment">//invocationHandler持有的被代理对象</span></span><br><span class="line">    T target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StuInvocationHandler</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxy:代表动态代理对象</span></span><br><span class="line"><span class="comment">     * method：代表正在执行的方法</span></span><br><span class="line"><span class="comment">     * args：代表调用目标方法时传入的实参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理执行&quot;</span> +method.getName() + <span class="string">&quot;方法&quot;</span>);</span><br><span class="line">     */   </span><br><span class="line">        <span class="comment">//代理过程中插入监测方法,计算该方法耗时</span></span><br><span class="line">        MonitorUtil.start();</span><br><span class="line">        <span class="comment">// 原来的代理对象Student中的方法</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        MonitorUtil.finish(method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>具体实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个实例对象，这个对象是被代理的对象</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">        InvocationHandler stuHandler = <span class="keyword">new</span> StuInvocationHandler&lt;Person&gt;(zhangsan);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)；</span><br><span class="line"></span><br><span class="line">       <span class="comment">//代理执行上交班费的方法</span></span><br><span class="line">        stuProxy.giveMoney();</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/26/bIVRJdO5vKX36nQ.jpg" alt="img"></p></li></ul><h5 id="2-3-动态代理的原理">2.3 动态代理的原理</h5><p>从 JVM 角度来说，动态代理是在运行时<u>，通过<strong>反射</strong>动态生成类<strong>字节码</strong>，</u>并加载到 JVM 中的。</p><h4 id="3-如何利用反射创建一个对象？">3. 如何利用反射创建一个对象？</h4><p>过程如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 得到Stu类的运行时Class描述符</span></span><br><span class="line">            <span class="comment">//简单理解为你现在有了这个类，可以调用相应的方法进行实例化了</span></span><br><span class="line">            Class&lt;?&gt; stu = Class.forName(<span class="string">&quot;Stu&quot;</span>);</span><br><span class="line">            <span class="comment">//2.从getDeclaredConstructor()的字面意思就能理解，得到所有声明的构造器</span></span><br><span class="line">            <span class="comment">//这里得到的是所有声明的构造器，getConstructor()则只能得到被public修饰的构造器</span></span><br><span class="line">            Constructor&lt;?&gt; declaredConstructor = stu.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;String.class, <span class="keyword">int</span>.class&#125;);</span><br><span class="line">            <span class="comment">//3. 使用newInstance()方法创建对象并传入参数</span></span><br><span class="line">            <span class="comment">//简单的理解为Stu o = new Stu(&quot;zhangsan&quot;, 01)</span></span><br><span class="line">            Stu o = (Stu) declaredConstructor.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="number">01</span>&#125;);</span><br><span class="line">            <span class="comment">//4.调用Stu这个类里面的方法</span></span><br><span class="line">            <span class="comment">// getDeclaredMethod()方法能调用到所有声明的方法</span></span><br><span class="line">            Method method = stu.getDeclaredMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line">            <span class="comment">//5. 简单的理解为o.toStirng()</span></span><br><span class="line">            String invoke = (String)method.invoke(o, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">            System.out.println(invoke);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（一）_Java_Java入门</title>
      <link href="/p/51787/"/>
      <url>/p/51787/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h2 id="1-1-JAVA入门">1.1  JAVA入门</h2><h3 id="1-1-1-JAVA基本">1.1.1 JAVA基本</h3><h4 id="1-介绍一下JVM-JRE-JDK？-JAVA语言有什么特点？">1.<strong>介绍一下JVM&amp;JRE&amp;JDK？</strong> JAVA语言有什么特点？</h4><ul><li><strong>JVM&amp;JRE&amp;JDK</strong><ul><li><strong>JVM:</strong>  即java虚拟机，针对不同操作系统，JVM把Java代码翻译成<u>对应操作系统可以识别的内容，实现跨平台</u> ；</li><li><strong>JRE</strong> : <u>JVM + 核心类库 = JRE</u> ， 即Java运行时环境。只有JVM不能运行，它还<strong>需要核心类库，才能保证Java运行</strong> ；</li><li><strong>JDK:</strong> <u>JRE + <strong>java开发工具</strong>（编译器等) = JDK</u> ，Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具。</li></ul></li><li><strong>Java语言特点</strong><ol><li><p>简单易学；</p></li><li><p>面向对象（封装，继承，多态）；</p></li><li><p><strong>平台无关性</strong>（ Java 虚拟机实现平台无关性）；</p></li><li><p>可靠性；</p></li><li><p>安全性；</p></li><li><p><strong>支持多线程</strong>（ <u>C++ 语⾔没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计</u>，而 Java 语⾔却提供了多线程支持）；</p></li></ol></li></ul><h4 id="2-什么是Java虚拟机？为什么Java被称为平台无关的编程语言？">2.<strong>什么是Java虚拟机？为什么Java被称为平台无关的编程语言</strong>？</h4><p><img src="https://i.loli.net/2021/05/12/b4HUYmVo6P5uFCi.png" alt="image-20210512104311616"></p><ul><li><p>java虚拟机，是<strong>执行字节码文件（.class</strong>）的<u>虚拟机进程</u>；</p><blockquote><p>在 Java 中，<strong>JVM 可以理解的代码就叫做 字节码</strong> （即扩展名为 .class 的⽂件），它不面向任 何特定的处理器，<strong>只面向虚拟机</strong>。</p></blockquote></li><li><p>java源程序（.java）被编译器编译成字节码文件（.class）。然后字节码文件，将由<u>java虚拟机，解释成机器码（<strong>不同平台的机器码不同</strong>）</u>。</p></li></ul><h4 id="3-请你谈谈Java中是如何支持正则表达式操作的？（补充实例）">3. 请你谈谈Java中是如何支持正则表达式操作的？（补充实例）</h4><p>Java中的String类提供了支持正则表达式操作的方法，包括：</p><ul><li><code>matches()、replaceAll()、replaceFirst()、split()</code></li></ul><p>此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegExpTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;成都市(成华区)(武侯区)(高新区)&quot;</span>;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;.*?(?=\\()&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(str);</span><br><span class="line">        <span class="keyword">if</span>(m.find()) &#123;</span><br><span class="line">            System.out.println(m.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实例示范（PCG问过）">实例示范（PCG问过）</h5><blockquote><p>参考：<a href="https://www.runoob.com/regexp/regexp-syntax.html">https://www.runoob.com/regexp/regexp-syntax.html</a></p></blockquote><ul><li><p><strong>特殊字符</strong></p><img src="https://i.loli.net/2021/05/12/9IBVheAOz5aGnxC.png" alt="image-20210512110705420" style="zoom:80%;" /></li><li><p><strong>普通字符</strong></p><p><img src="https://i.loli.net/2021/05/12/QcjTKqEJZwx7LdM.png" alt="image-20210512111050519"></p></li><li><p><strong>实例示范</strong></p><ol><li><p>匹配邮箱</p><p><img src="https://i.loli.net/2021/05/12/Lvo56GHie2Qqla1.png" alt="img"></p></li><li><p>匹配电话号码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配电话号码</span></span><br><span class="line">String phone = <span class="string">&quot;18637866964&quot;</span>;</span><br><span class="line">String reg = <span class="string">&quot;^1[3,5,7,8,9]\\d&#123;9&#125;$&quot;</span>;</span><br><span class="line">System.out.println(phone.matches(reg));</span><br></pre></td></tr></table></figure></li><li><p>匹配第一个出现的数字</p><p>下面好像是不对的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String phone = <span class="string">&quot;avss1sdp22&quot;</span>;</span><br><span class="line">String reg = <span class="string">&quot;\d?&quot;</span>;</span><br><span class="line">System.out.println(phone.matches(reg));</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="4-（补充例子）请你简单描述一下正则表达式及其用途。">4.<strong>（补充例子）请你简单描述一下正则表达式及其用途</strong>。</h4><p>在编写处理字符串的程序时，经常会有查找 <u>符合某些复杂规则的字符串</u> 的需要。</p><ul><li>计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具；</li><li>绝大多数语言都提供了对正则表达式的支持。</li></ul><h4 id="5-和-区分？">5.<strong>&amp;和&amp;&amp;区分？</strong></h4><ul><li><strong>共同点</strong>：都要求运算符左右两端的布尔值 <u>都是true</u> 整个表达式的值才是true</li><li>区别：&amp;&amp;之称为短路运算，<u>如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算</u>。 好处：<ul><li><em>e.g.</em> ：右边判别式有如果有空指针<code>NullPointerException</code>异常判断风险，可以避免。</li></ul></li></ul><h4 id="6-值传递和引用传递区分？">6.<strong>值传递和引用传递区分？</strong></h4><ul><li><p>值传递是<strong>该变量</strong>的一个<u>副本</u>， 改变副本<u>不影响</u>原变量；</p></li><li><p>引用传递是<strong>对象地址</strong>的<u>副本</u>，引用对象进行操作会同时<u>改变</u>原对象。</p></li></ul><h4 id="7-十进制与二进制？">7.<strong>十进制与二进制？</strong></h4><ul><li><p><strong>请你讲讲一个十进制的数在内存中是怎么存的？</strong></p><p>补码形式。</p></li><li><p><strong>为什么会出现4.0-3.6=0.40000001这种现象？</strong></p><p>2进制的小数无法精确的表达10进制小数，计算机在 <u>计算10进制小数的过程中要先转换为2进制进行计算</u> ，这个过程中出现了误差。</p></li></ul><h4 id="8-（重要）equals与-的区别">8.<strong>（重要）equals与==的区别</strong></h4><blockquote><p>很清晰严谨的一篇文章：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p></blockquote><ul><li><p><strong>==</strong></p><ol><li>基本类型：比较的是值是否相同；</li><li>引用类型：比较的是<strong>引用（对象地址</strong>）是否相同；</li></ol></li><li><p><strong>equals</strong></p><p>要看<strong>类是否覆盖equals()方法</strong>，将它分为两种情况：</p><ol><li><p>若某个类没有覆盖equals()方法，当它的通过<strong>equals()比较两个对象</strong>时，实际上是比较两个对象（地址）是不是同一个对象。这时，<u>等价于通过“==”去比较这两个对象</u>；</p></li><li><p>我们可以覆盖类的equals()方法，来让equals()通过其它方式比较两个对象的内容（<strong>而不是地址</strong>）是否相等。</p><blockquote><p>String 中的 equals 方法是被重写过的：</p><ul><li>因为 object 的 equals 方法是⽐教的对象的内存地址</li><li>而 <strong>String 的 equals 方法（1）先比较对象地址是否相等 ，相同则ture，否则（2）再比较值是否相等</strong></li></ul></blockquote></li></ol></li></ul><h4 id="7-请解释hashCode-和equals-方法有什么联系？">7.<strong>请解释hashCode()和equals()方法有什么联系？</strong></h4><blockquote><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode方法？”</p><ul><li>建议看文中例子理解：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html">https://www.cnblogs.com/skywang12345/p/3324958.html</a></li></ul></blockquote><ul><li><p><strong>hashCode()介绍</strong></p><p>hashCode() 的作用是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个int整数。这个<strong>哈希码的作用</strong>是确定该 <u>对象在哈希表中的索引位置</u>。</p><blockquote><p>我们仅在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。  其它情况下hashCode() 则根本没有任何作用，所以，不用理会hashCode()。</p><ul><li>在这种情况下对象相等，hashcode值也会不相等。</li></ul></blockquote></li><li><p><strong>为什么要有hashcode()</strong></p><p>hashCode() 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回⼀个 int整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。 <strong>hashCode()</strong><u>在散列表中</u>才有用，在其它情况下没用。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><p><strong>先判断hashcode，而不是直接遍历O(n)复杂度用equals()判断，减少判断时间</strong>。</p><blockquote><p><strong>如果hashcode一样，会调用equals()去比较</strong>。</p><ul><li><strong>HashSet</strong> 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加⼊操作成功。如果不同的话，就会重新散列到其他位置。</li></ul></blockquote></li></ul><h5 id="7-1-为什么重写了equals-一定要重写hashcode-方法？">7.1 为什么重写了equals()一定要重写hashcode()方法？</h5><blockquote><p>参考：<a href="https://blog.csdn.net/xyh269/article/details/69171545">为什么重写了equals()，还要重写hashCode()？</a></p></blockquote><p>在Hashmap / Hashset中，通过计算hash = hash(key.hashcode) 然后进行取余操作，快速定位到数组中。</p><p>因为<strong>map中是不允许重复key</strong>的，所以对内部get()/add()方法：对于散列到数组同一位置的对象来说，<strong>如果hash相等 &amp;&amp; equals()判断相等</strong> ，是要进行<strong>覆盖</strong>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用 equals 方法判断key是否相等，若相等，该key对应的键值对已经存在，用新的value取代旧的value</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;    </span><br></pre></td></tr></table></figure><p>如果我们只重写了equals方法：用来判断两个对象是否相等。但是依旧可能出现：两个相同对象<strong>equals相等，但hashcode不等，被散列到不同桶上，map中依旧出现了重复键值对！</strong></p><p><img src="https://i.loli.net/2021/05/26/v5aHJGt8qErx6P9.png" alt="hashcode"></p><p>所以，需要重写hashcode方法，保证<strong>相同对象一定是散列到同一个位置（具有同样的hash值）</strong>。</p><h5 id="7-2-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，该说法是否正确，为什么？">7.2 <strong>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么</strong>？</h5><p>不一定正确，<u>如果在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中</u>，两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。</p><p>其它情况下可能会出现题目描述的情况。</p><h4 id="8-自动拆箱和装箱？">8. 自动拆箱和装箱？</h4><h5 id="8-1-介绍一下int-Integer？">8.1 <strong>介绍一下int&amp;Integer？</strong></h5><p>Java为了编程的方便还是引入了基本数据类型，但是 <u>为了能够将这些基本数据类型当成对象操作</u>，Java为每一个基本数据类型都引入了对应的<strong>包装类型</strong>（wrapper class）</p><ul><li><p>int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e.g. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">        Integer b = <span class="number">3</span>;          <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">        System.out.println(a == b);  </span><br><span class="line">        <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">        System.out.println(a == c);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>Java 为<u>每个原始类型</u>提供了包装类型：</p><ul><li>（<strong>8种基本类型</strong>）原始类型: boolean，char，byte，short，int，long，float，double</li><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li></ul></li></ul><h5 id="8-2-拆箱、装箱存在的意义？">8.2 <strong>拆箱、装箱存在的意义？</strong></h5><blockquote><p>为什么要有装箱、拆箱，它们的作用是什么？</p></blockquote><p><em>java</em> 是 面对对象编程，而基本数据类型不是对象，<strong>所有才有封装类 引用基本数据类型进行操作</strong>。比如，下面打印出<em>int</em>型数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>； </span><br><span class="line">System.out.println(i); <span class="comment">// 自动装箱</span></span><br></pre></td></tr></table></figure><p>其实，查看源码，实际经过以下几个过程：</p><ul><li>将 <em>i</em> 自动装箱成封装类 <em>Integer</em></li><li>然后调用 <em>Integer</em>中 <em>toString</em>() 方法，打印出字符串输出到控制台。</li></ul><blockquote><p>自动装箱和拆箱？</p></blockquote><ul><li>自动装箱：就是自动将基本数据类型转换为包装器类型</li><li>自动拆箱：就是自动将包装器类型转换为基本数据类型</li></ul><h5 id="8-3-char和byte的区别-，-能否强制转换？">8.3 char和byte的区别 ， 能否强制转换？</h5><p>区别：</p><ul><li>Char是无符号型的，可以表示一个整数，不能表示负数，大小范围 是0—65535；而byte是有符号型的，可以表示-128—127 的数</li><li>char可以表中英文字符，byte不可以</li></ul><p>强制转换：</p><p>可以，但是会出现精度丢失。</p><h4 id="9-String-StringBuffer-StringBuilder-区别？为什么String不可变">9.  String &amp; StringBuffer&amp; StringBuilder 区别？为什么String不可变?</h4><ul><li><p><strong>请解释String &amp; StringBuffer区别？</strong></p><ul><li><p><strong>共同点</strong>：它们可以<strong>储存和操作</strong>字符串，即包含多个字符的字符数据；</p></li><li><p><strong>可否修改</strong>：String类提供了数值不可改变的字符，StringBuffer可以修改字符串，需要 <u>字符数据要改变</u> 时用。</p></li></ul><p>典型地，你可以使用StringBuffers来动态构造字符数据。</p></li><li><p><strong>请解释 StringBuilder&amp; StringBuffer 区别？</strong></p><ul><li><p><strong>共同点</strong>：<code>AbstractStringBuilder</code> 是 StringBuilder 与 StringBuffer 的公共⽗类。都可以修<u>改字符串，操作字符串方法丰富</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value is used for character storage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">char</span>[] value;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The count is the number of characters used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> count;</span><br><span class="line"> AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line"> value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><u><strong>线程安全</strong>：</u>单线程且操作大量字符串用StringBuilder,速度快，但线程不安全，可修改；在多线程且操作大量字符串用<strong>StringBuffer，线程安全，可修改</strong>。</p><blockquote><p>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p></blockquote></li></ul></li><li><p><strong>为什么String 不可变？</strong></p><p>String 类中使用 final 关键字修饰字符数组来保存字符串， 所以 String 对象是不可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[]</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-说说深拷贝和浅拷贝？">10.<strong>说说深拷贝和浅拷贝</strong>？</h4><ul><li><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址；</p><blockquote><p>因此，可能会出现出现浅拷贝时释放同一个内存的错误。</p></blockquote></li><li><p>深拷贝（deepCopy）是增加了一个指针<strong>并且申请了一个新的内存</strong>，使这个增加的指针指向这个新的内存。</p></li></ul><h4 id="11-【新增】介绍一下JDK1-8的新特性？">11. 【新增】介绍一下JDK1.8的新特性？</h4><p>JDK1.8新增了非常多的特性，如：</p><ul><li><strong>Lambda表达式</strong>：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li><li><strong>方法引用</strong>：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li><li><strong>默认方法</strong>：默认方法就是一个<strong>在接口里面有了一个实现的方法</strong>。</li><li><strong>新工具</strong>：新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li><li><strong>Stream API</strong>：新添加的Stream API（java.util.stream） 把真正的<strong>函数式编程风格</strong>引入到Java中。</li><li><strong>Date Time API</strong>：加强对日期与时间的处理。</li><li><strong>Optional类</strong>：Optional 类已经成为 Java 8 类库的一部分，用来解决<strong>空指针异常</strong>。</li><li><strong>Nashorn，JavaScript引擎</strong>：JDK1.8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li></ul><h4 id="12-【新增】java一个程序能不能有多个main方法？一个类里呢？">12. 【新增】java一个程序能不能有多个main方法？一个类里呢？</h4><ul><li><p><strong>一个程序里，多个class都有main方法</strong></p><p>可以，默认第一个为入口，其余为普通函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>一个类有多个main方法</strong></p><p>可以，其余就相当是重载。但是具有以下sigature（签名）的主要方法将被视为app入口点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-1-2-关键字">1.1.2 关键字</h3><h4 id="1-请你讲讲Java里面的final关键字是怎么用的？">1.<strong>请你讲讲Java里面的final关键字是怎么用的</strong>？</h4><ul><li><p><strong>修饰类</strong>：表示不能被继承，final类 <u>成员变量</u> 可以设为final；但final类<u>所有方法</u> ，都被隐式指定为final方法；</p></li><li><p><strong>修饰方法</strong>：防任何继承类修改它的含义 ； 在早期的Java实现版本中，会将final方法转为内嵌调用，效率会更高；</p></li><li><p><strong>修饰变量、引用</strong>：<u>基本类型</u>的话一旦初始化不能修改；<u>引用类型</u>，不能指定其他对象 。</p></li></ul><h4 id="2-【重点】请你谈谈关于Synchronized和lock-？">2. 【<strong>重点</strong>】请你谈谈关于Synchronized和lock ？</h4><ul><li><p><strong>Synchronized</strong>：是一个关键字，修饰<u>类、方法 </u> 或 <u>代码块</u> ，保证在同一时刻最<strong>多只有一个线程</strong>执行该段代码；</p><blockquote><p>作用范围：</p><ol><li>修饰一个类/静态方法，<strong>作用的对象是这个类的所有对象</strong>。</li><li>修饰一个方法/代码块，<strong>作用的对象是调用这个方法/代码块的对象</strong>。</li></ol></blockquote></li><li><p>Lock：<strong>是一个接口</strong>，Lock能完成synchronized所实现的所有功能。</p><blockquote><p>Lock接口是不能直接实例化的，需要靠它的实现类ReentrantLock来进行实例化。</p></blockquote><ul><li><p>区别：</p><ul><li><u>锁释放：</u><strong>synchronized在发生异常时，会自动释放线程占有的锁</strong>，因此不会导致死锁现象发生；Lock不会主动适应 <code>unLock()</code> 释放，必须手动在f<code>inally</code>释放。；</li><li><u>线程等待：</u> <u>Lock可以让<strong>等待锁的线程可以响应中断</strong></u>，线程可以中断去干别的事务；而synchronized却不行，使用synchronized时，等待的线程会一直等待下去；</li><li><u>成功获取锁：</u> 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li></ul></li></ul></li></ul><h4 id="3-instanceof关键字的作用？">3. <strong>instanceof</strong>关键字的作用？</h4><p>instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Integer);<span class="comment">//编译不通过 i必须是引用类型，不能是基本类型</span></span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Object);<span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(integer <span class="keyword">instanceof</span> Integer);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="4-final有哪些用法">4. <strong>final有哪些用法?</strong></h4><ul><li><p>被final修饰的类不可以被继承 ；</p></li><li><p>被final修饰的方法<strong>不可以被重写</strong>，<u>而且JVM会尝试将其内联，以提高运行效率</u>；</p></li><li><p>被final修饰的<u>变量</u>不可以被改变；</p><ul><li><p>被final修饰的<u>引用</u>，那么表示引用不可变，<u>引用指向的内容可变</u>；</p></li><li><p>被final修饰的<u>常量</u>，在编译阶段会存入常量池中。</p></li></ul></li></ul><h4 id="5-static都有哪些用法">5. <strong>static都有哪些用法 ?</strong></h4><ul><li><p><strong>修饰静态变量和静态方法</strong> ：都属于类的静态资源，类实例所共享 ；</p></li><li><p><strong>修饰静态块</strong>：用于初始化操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss PreCache&#123;</span><br><span class="line"> <span class="keyword">static</span>&#123;</span><br><span class="line"> <span class="comment">//执行相关操作</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>修饰静态包</strong>：在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且<strong>不需要使用类名,<strong>可以直接</strong>使用方法名</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(Math.sin(20));传统做法</span></span><br><span class="line">        System.out.println(sin(<span class="number">20</span>));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-谈一谈transient关键字？">6. 谈一谈transient关键字？</h4><blockquote><p><strong>参考</strong> : <a href="https://www.cnblogs.com/chenpi/p/6185773.html">Java中的关键字 transient</a></p></blockquote><ul><li><p><strong>Java中序列化操作</strong></p><p>Java中对象的序列化指的是将<strong>对象转换成以【字节序列】的形式来表示</strong>，这些字节序列<strong>包含了对象的数据和信息</strong>。</p><blockquote><p>当然，序列化后的最终目的是为了反序列化，恢复成原先的Java对象，要不然序列化后干嘛呢，所以序列化后的字节序列都是可以恢复成Java对象的，这个过程就是反序列化。</p></blockquote><ul><li><u>一个序列化后的对象可以<strong>被写到数据库或文件</strong>中</u>，也可用于<strong>网络传输</strong>，一般当我们使用缓存cache（内存空间不够有可能会本地存储到硬盘）或远程调用rpc（网络传输）的时候，经常需要让我们的实体类实现Serializable接口，目的就是为了让其可序列化。</li></ul></li><li><p><strong>关于transient关键字</strong></p><p>Java中transient关键字的作用，向虚拟机表明: <strong><code>transient</code>变量不是对象的<u>持久状态</u>的一部分</strong>。</p><p>简单地说，就是让某些被修饰的成员属性变量不被序列化，例如：</p><ol><li><p>类中的字段值可以根据其它字段推导出来，如一个长方形类有三个属性：长度、宽度、面积（示例而已，一般不会这样设计），那么在序列化的时候，面积这个属性就没必要被序列化了；</p></li><li><p>其它，看具体业务需求吧，哪些字段不想被序列化；</p></li></ol></li></ul><h5 id="7-1-HashMap中源码modCount为什么用tranisent修饰？">7.1 HashMap中源码modCount为什么用tranisent修饰？</h5><p>modCount主要用于判断HashMap是否被修改（像put、remove操作的时候，modCount都会自增）。</p><p>对于这种变量，一开始可以为任何值，0当然也是可以（new出来、反序列化出来、或者克隆clone出来的时候都是为0的），没必要持久化其值。</p><h3 id="1-1-3-Java异常">1.1.3 Java异常</h3><h4 id="1-Java常见异常和分类？">1. Java常见异常和分类？</h4><p><img src="https://i.loli.net/2021/05/26/1ctoGfDdrj6Wapv.png" alt="Java异常的分类和类结构图1"></p><p>常见分为两类，Error和Exception ：</p><ul><li><strong>Error</strong> ：指程序无法恢复的异常情况，对于其所有类型，都不要求程序处理。<ul><li>常见错误：Stackoverflow，outOfMemory</li></ul></li><li><strong>Exception：</strong> 程序有可能恢复的错误，又分为IOException &amp; RuntimeException ，常见错误：<ul><li><strong>IOException</strong>：FileNotFoundExcepetion</li><li><strong>RuntimeException</strong>  : 空指针，参数不合法，类未找到等</li></ul></li></ul><h4 id="2-OOM产生原因和分析？">2. OOM产生原因和分析？</h4><blockquote><p>OOM，全称“Out Of Memory”，翻译成中文就是“内存用完了”，来源于java.lang.OutOfMemoryError 。</p></blockquote><ol><li><p><strong>java.lang.OutOfMemoryError: Java heap space</strong> （堆溢出）</p><ul><li><p><strong>产生原因</strong></p><ol><li><strong>内存泄漏</strong>；</li><li>堆分配太小；</li></ol></li><li><p><strong>解决办法</strong></p><ol><li><strong>内存泄漏要手动去释放内存</strong>，比如数据库连接池，单例模式</li><li>通过虚拟机参数<code>-Xms,-Xmx</code>等修改，对内存大小</li></ol></li></ul></li><li><p><strong>java.lang.OutOfMemoryError: PermGen space</strong> （永久代（方法区）溢出）</p><ul><li><p><strong>产生原因</strong></p><p>即方法区溢出了：</p><ol><li>一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生<strong>大量的Class信息存储于方法区</strong> ；</li><li><strong>过多的常量</strong>尤其是字符串也会导致方法区溢出。</li></ol></li><li><p><strong>解决办法</strong></p><ol><li>永久代的内存分配增大 ：-XX:PermSize和-XX:MaxPermSize</li></ol></li></ul></li><li><p><strong>java.lang.StackOverflowError ------&gt; 不会抛OOM error，但也是比较常见的Java内存溢出</strong>。</p><p>线程栈相关的内存异常有两个：</p><ul><li>StackOverflowError(方法调用层次太深，内存不够新建栈帧)</li><li>OutOfMemoryError（线程太多，内存不够新建线程）</li></ul></li><li><p><strong>java.lang.OutOfMemoryError: Metaspace</strong></p><blockquote><p>Java中<strong>普通I/O</strong>采用<strong>输入/输出流</strong>方式实现，输入流InputStream（  终端—&gt;直接内存-&gt;JVM），输出流（JVM-&gt;直接内存-&gt;终端），这一过程中有kenel与JVM之间的拷贝（很多次）。</p></blockquote><p>为了使用<strong>直接内存</strong>，Java是有一块区域叫<strong>DirectBuffer</strong>，不是JavaHeap而是<strong>cHeap</strong>的一部分。</p><p>但由于直接内存没有被java虚机完全托管，若使用不当，也容易触发溢出，导致宕机。</p></li></ol><h4 id="3-try-catch-finally，try里有return，finally还执行么？"><strong>3. try catch finally，try里有return，finally还执行么</strong>？</h4><p>执行，并且finally的执行早于try里面的return ：</p><ol><li>不管有木有出现异常，finally块中代码都会执行；</li><li>当try和catch中有return时，finally仍然会执行；</li><li>finally是<strong>在return后面的表达式运算后执行</strong>的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以<strong>函数返回值是在finally执行前确定</strong>的。</li></ol><h4 id="4-说说你是怎么处理异常的？">4.<strong>说说你是怎么处理异常的？</strong></h4><p><em><strong>try-catch-finally</strong></em></p><p><img src="https://i.loli.net/2021/05/05/JfavipzFPb6GI2t.png" alt="image-20210505154833171"></p><ul><li><p>try 块负责监控可能出现异常的代码</p></li><li><p>catch 块负责捕获可能出现的异常，并进行处理</p></li><li><p>finally 块负责清理各种资源，不管是否出现异常都会执行</p></li><li><p>其中 try 块是必须的，<strong>catch 和 finally 至少存在一个标准异常处理流程</strong></p></li></ul><h4 id="5-web网页卡怎么排查？cpu100-怎么排查？OOM怎么排查？">5. web网页卡怎么排查？cpu100%怎么排查？OOM怎么排查？</h4><ul><li><p><strong>web网页卡顿</strong></p><ol><li><strong>用户端</strong>：硬件配置低、资源不足；CPU 或者内存资源不足, 比如用户是否使用了 Chrome 这种 “吃内存大户” 的浏览器并且打开了很多网页?</li><li><strong>网络分析</strong>：<strong>DNS 解析慢</strong>；<strong>未设置 CDN</strong>，如果没有设置 CDN, 在跨线路访问(比如用户是铁通, 但是服务器部署在联通, 这种情况就是跨线路), 地理位置相差很远 等情况 ；用户端的带宽不足或所处环境网络不佳；</li><li><strong>服务端</strong>：服务端响应慢，性能比较差 。</li></ol></li><li><p><strong>cpu100%</strong></p><blockquote><p>参考：<a href="https://www.cnblogs.com/dennyzhangdd/p/11585971.html">https://www.cnblogs.com/dennyzhangdd/p/11585971.html</a></p></blockquote><ol><li><p><strong>执行<code>top</code>命令</strong>：查看所有进程占系统CPU的排序；</p><blockquote><p>极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。</p></blockquote></li><li><p>执行<strong>top -Hp 进程号</strong>命令：查看java进程下的<strong>所有线程占CPU的情况</strong>；</p></li><li><p>执行<strong>printf &quot;%x\n 10</strong>命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，咱们需要把线程号转成16进制。</p></li><li><p>执行<strong>jstack 进程号 | grep 线程ID” 查找某进程下</strong>–&gt;<code>线程ID(jstack堆栈信息中的nid)=0xa</code>的<strong>线程状态</strong>。</p><p>代码中有大量消耗CPU的操作，导致CPU过高，系统运行缓慢：</p><blockquote><ol><li><p>jstack，可直接定位到代码行。例如某些复杂算法，甚至算法BUG，无限循环递归等等。</p></li><li><p>如果有死锁，会直接提示关键字：deadlock。步骤4，会打印出业务死锁的位置。</p></li></ol></blockquote></li><li><p>执行<strong>jstat -gcutil 进程号</strong> 统计间隔毫秒 统计次数（缺省代表一致统计）”，<strong>查看某进程GC持续变化情况</strong>，<strong>如果发现返回中FGC很大且一直增大–&gt;确认Full GC!</strong></p><p>也可以使用“<strong>jmap -heap 进程ID”查看一下进程的堆内从是不是要溢出了</strong>，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。</p><blockquote><p>jstat命令监控GC情况，可以看到Full GC次数非常多，并且次数在不断增加。</p></blockquote></li><li><p>执行<strong>jmap -dump:format=b,file=filename 进程ID</strong>，导出某进程下内存heap输出到文件中。</p></li></ol></li><li><p><strong>OOM</strong></p><blockquote><p>参考：<a href="https://www.cnblogs.com/valjeanshaw/p/13130102.html">https://www.cnblogs.com/valjeanshaw/p/13130102.html</a></p></blockquote><p>先通过内存映像工具对Dump出来的堆转储快照进行分析，<strong>重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=$java_pid.hprof     #java_pid为java进程ID</span><br></pre></td></tr></table></figure><p>然后看具体是报什么错：很明显下面是堆溢出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to oom.out ...</span><br><span class="line">Heap dump file created [3196858 bytes in 0.016 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">        at java.util.Arrays.copyOf(Arrays.java:3332)</span><br><span class="line">        at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)</span><br><span class="line">        at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:700)</span><br><span class="line">        at java.lang.StringBuilder.append(StringBuilder.java:214)</span><br><span class="line">        at jvm.OomDemo.main(OomDemo.java:13)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（零）_写在前面</title>
      <link href="/p/29708/"/>
      <url>/p/29708/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>转眼就到了属于我的毕业季，还记得初来学校的期待和兴奋，却从“小师弟”眨眼变成了“老油条”。实习和秋招也算正式告一段落，对于我这种懒蛋，有幸拿到了<u>腾讯</u>、<u>美团</u>、<u>Shoope SG</u>等 <u>后端开发岗</u> offer，勉强算是一个 “happy ending”。找工作是今年我经历的最重要事情之一，同时也想给师弟师妹提供一点帮助，便整理了这份 <u>（互联网）校招笔记</u>。</p></blockquote><h3 id="直入主题">直入主题</h3><p>互联网校招主要形式和考察内容如下：</p><ul><li><p><strong>考察形式</strong></p><p>线上考察，视频面试（大部分公司）或电话面试（阿里等部分公司喜欢这种方式）。</p></li><li><p><strong>考察内容</strong></p><ul><li><p><strong>算法能力</strong></p><p>俗称“刷题”，一般面试都是常见题，理论上刷完<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a>，能做到烂熟于心（指现场<strong>秒背题或模板</strong>），大厂面试一般没有多大问题。</p><p>当然针对心仪公司，可以在面试前<strong>更加针对性</strong>地练习该公司的常出题，这一点上<a href="https://codetop.cc/">codeTop</a>是一个不错的网站。</p></li><li><p><strong>计算机基础</strong></p><p>俗称“八股”，考察范围包含：计算机网络、Linux、数据库、操作系统、常见中间件&amp;框架、智力题等。可以看得到<strong>考察范围非常广</strong>，但是<strong>考察的题目非常固定</strong>。所以只要背熟常见题目问答便能不错地应对面试，这也是该部分内容被称为“八股文”的原因。</p></li><li><p><strong>项目 &amp; 实习</strong></p><p>项目顾名思义，就是实际做的开发项目（如果是算法岗则对应论文）。根据面试经验，一个<strong>好的开源项目</strong>是非常加分的。</p><p>实习通常是指大厂实习，在竞争这么激烈的情况下，如果没有实习，秋招想进入互联网大厂将会变得很困难。</p></li></ul></li></ul><p>根据以上内容，这份校招笔记争取尽量全面覆盖，整个目录安排如下：</p><ul><li>[注1]：本份笔记除自身总结外，主要参考资料来源于<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Java Guide：https://github.com/Snailclimb/JavaGuide">[1]</span></a></sup><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="阿秀C++面试笔记：https://github.com/forthespada/InterviewGuide">[2]</span></a></sup><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="牛客网面经：https://www.nowcoder.com/interview/center">[3]</span></a></sup>，特此注明。</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><p>下面是一些奇怪没有脑袋的絮絮叨叨，迫不及待年入百万可以根据上面目录直接开始学习了，以下可略过。</p><h3 id="算法还是后端？">算法还是后端？</h3><blockquote><p>读了个（<s>末流</s>）985硕士，也有篇不错的（<s>水</s>）论文，最后去做了当时本科毕业就能做的开发岗？—《本科同学竟是我的面试官》系列。</p></blockquote><p>如果你和我有一样的困惑和选择，不妨来看看我的经历，也许会有点帮助。在这之前，我们先分析下算法和后端的各自优劣。</p><h4 id="算法-P-K-后端">算法 P.K. 后端</h4><p>在这里我将从，起薪、门槛、竞争强度、未来发展等维度来分析二者优劣。</p><ul><li>[注1]：以下均以一线大厂（腾讯、阿里、字节、美团等）为基准。</li><li>[注2]：CV=Computer Vision，NLP=Natural Language Processing 。</li><li>[注3]：非特别说明，不考虑特例情况。</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">算法</th><th style="text-align:center">后端</th></tr></thead><tbody><tr><td style="text-align:center"><strong>起薪</strong></td><td style="text-align:center">同级别比后端高：1~2K/月</td><td style="text-align:center">中档薪资：40W+</td></tr><tr><td style="text-align:center"><strong>简历门槛</strong></td><td style="text-align:center">211硕士起</td><td style="text-align:center">211本起（部分知名双非）</td></tr><tr><td style="text-align:center"><strong>竞争强度</strong></td><td style="text-align:center">CV&gt;&gt;搜广推&gt;NLP</td><td style="text-align:center">CV&gt;Java后端&gt;&gt;C++后端&gt;其它</td></tr><tr><td style="text-align:center"><strong>未来发展</strong></td><td style="text-align:center">二者发展相差不大，和个人强相关</td><td style="text-align:center">二者发展相差不大，和个人强相关</td></tr><tr><td style="text-align:center"><strong>其它</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>可以看到，CV竞争强度远大于其它算法岗位，即使和后端中竞争最激烈的<strong>Java后端</strong>相比，也依旧更大。</p><p>在读研期间，我个人研究方向就是CV领域（Object Tracking），有一篇论文（CCF-A，三审）和几篇专利。但是并没有信心去竞争CV相关岗位（学历和论文无优势），也对深度学习产生了迷茫：<u>调参和模型缝补也许并不是我想做的事，虽然有更底层的研究方向但自己的数学基础不够牢靠</u>。</p><p>就这样，带着<strong>七分迷茫三分盲目自信</strong> 的我一股脑扎进Java的苦海。可是<strong>Java后端岗位</strong>的竞争激烈程度远超我想象，实习和秋招一直都在失业边缘疯狂试探。无论是实习还是秋招，最后我接受的Offer都是<strong>C++后端岗位(腾讯)</strong> ，可以说是现实Java小丑了。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/b393ec036fd14f3c9d9610f7d0c839ff.png" alt="2021Q1天猫淘宝同比增长达53%，爆发的男士香水市场背后……_品牌" style="zoom:67%;" /><p>现在回头想想，Java后端竞争之所以这么激烈也基本是必然的：互联网的高薪（<s>和996</s>）吸引了大量其它专业转行的同学，而Java相比C++：易上手速成、需求大、生态丰富（<s>培训班一条龙服务</s>），自然是首选。</p><p>那么：<strong>到底是选择Java后端还是C++后端呢?</strong> 这里我也简单分析一下各自优劣，大家可以根据个人情况进行抉择。</p><h4 id="Java后端-P-K-C-后端">Java后端 P.K. C++后端</h4><blockquote><p>一家之言，仅供参考。</p></blockquote><p>在这里我将从，起薪&amp;门槛、岗位需求，竞争强度、未来发展等维度来分析二者优劣。</p><ul><li>[注1]：以下均以一线大厂（腾讯、阿里、字节、美团等）为基准。</li><li>[注2]：非特别说明，不考虑特例情况。</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><strong>Java后端</strong></th><th style="text-align:center"><strong>C++后端</strong></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>起薪&amp;门槛</strong></td><td style="text-align:center">基本一致</td><td style="text-align:center">基本一致</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>岗位需求</strong></td><td style="text-align:center">非常多</td><td style="text-align:center">一般</td><td style="text-align:center"><strong>今年嵌入式爆热</strong>，C++岗位需求预计会增加</td></tr><tr><td style="text-align:center"><strong>竞争强度</strong></td><td style="text-align:center">非常大，Java&gt;&gt;C++</td><td style="text-align:center">一般</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>未来发展</strong></td><td style="text-align:center">相差不大，和个人相关</td><td style="text-align:center">相差不大，和个人相关</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>其它</strong></td><td style="text-align:center">银行和国企等<strong>养老性质</strong>单位对Java需求比较大，后期职业发展<strong>有更多选择</strong></td><td style="text-align:center">C++岗位需求主要是<strong>大厂</strong>，后期职业发展跳槽<strong>可选较少</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>对口公司</strong></td><td style="text-align:center">阿里、美团等</td><td style="text-align:center">腾讯、百度、华为等</td><td style="text-align:center"></td></tr></tbody></table><p>相信看到这里的聪明你，根据自己的技术倾向、意向公司等已经有了大概的思路：</p><ul><li>想更容易去大厂，做一些更底层（网络、存储、操作系统、安全方面等）的事情，C++自然是不错的选择；</li><li>但是未来考虑去一些养老单位养老，对Web开发、移动开发等更感兴趣的话，Java应该是更好的选择。</li></ul><h3 id="求职时间节点"><strong>求职时间节点</strong></h3><p>整个实习和秋招，由于自己的拖延和懒散，所有的时间节点基本都是在DDL上反复横跳。如果不是运气还不错，现在说不定正在寝室抱着浅蓝色床单哭泣 😭 ，留下不学无术的泪水。</p><p>所以根据自己的经验，整理了一份<strong>我认为</strong>的完美求职时间节点，同时也整理了一份工作小丑时间节点安排，供对比参考。</p><ul><li>[注1]：年份以当年应届求职年份为准。</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">自律大佬 ⛹</th><th style="text-align:center">工作小丑 😹</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1月份</strong></td><td style="text-align:center">刷完<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a>，准备项目</td><td style="text-align:center">玩</td></tr><tr><td style="text-align:center"><strong>2月份</strong></td><td style="text-align:center">二刷LeetCode，开始背诵八股，优化项目</td><td style="text-align:center">继续玩</td></tr><tr><td style="text-align:center"><strong>3月份</strong></td><td style="text-align:center">八股基本烂熟，开始面试（<strong>找实习</strong>）小试锋芒</td><td style="text-align:center">焦虑的玩</td></tr><tr><td style="text-align:center"><strong>4月份</strong></td><td style="text-align:center">LeetCode和八股烂熟，收获众多大厂实习Offer，赢来工作小丑羡慕的赞叹</td><td style="text-align:center">特别焦虑，开始一边羡慕一边投简历，面试被无情暴打</td></tr><tr><td style="text-align:center"><strong>5月份</strong></td><td style="text-align:center">开始<strong>第一段</strong>大厂实习</td><td style="text-align:center">极度焦虑，开始熬夜准备刷题和八股，继续面试</td></tr><tr><td style="text-align:center"><strong>6月份</strong></td><td style="text-align:center">已实习两个月，同时面试收获了第二个大厂Offer，波澜不惊</td><td style="text-align:center">终于收获Offer，现代范进中举，奔走相告</td></tr><tr><td style="text-align:center"><strong>7月份</strong></td><td style="text-align:center">开始<strong>第二段</strong>大厂实习，开始<strong>提前批</strong></td><td style="text-align:center">实习第一个月，下班就是玩，<strong>提前批那是个啥？</strong></td></tr><tr><td style="text-align:center"><strong>8月份</strong></td><td style="text-align:center">第二段大厂实习二个月，提前批收获校招Offer，同时无意外<strong>转正</strong></td><td style="text-align:center">实习两个月，继续无视提前批，运气好也<strong>转正</strong>了</td></tr><tr><td style="text-align:center"><strong>9月份</strong></td><td style="text-align:center"><code>Offer收割机</code>+<code>SSP收割机</code>称号达成，羡慕听到麻</td><td style="text-align:center">又玩了半个月，开始投简历，捡了几家Offer，彻底躺平</td></tr><tr><td style="text-align:center"><strong>10月份</strong></td><td style="text-align:center">开始准备<strong>选调</strong></td><td style="text-align:center"><code>白菜收割机</code>称号达成，最终无奈选一颗大白菜<strong>结束秋招</strong></td></tr></tbody></table><ul><li><p><strong>关于实习</strong>：可以看到，工作小丑如果不是<strong>运气好转正</strong>，秋招<strong>凭借实习经历（另一方面也说明了实习的重要性</strong>）拿了几个Offer，整个求职过程并不乐观。</p></li><li><p><strong>关于提前批</strong> ：实习的时候<strong>一定要去准备提前批</strong>，提前批<strong>HC众多</strong>（特别是好岗位），<strong>难度也较低（亲身感受）</strong> ，拿到Offer的概率<strong>相比秋招</strong>会大很多。</p></li></ul><p>所以，大家<strong>尽量早点</strong>充分准备，找工作不至于长期处于焦虑状态。拼运气自然不如拼实力，当然也要劳逸结合，有空闲多和师兄打打LOL放松下也是很有必要的 🕹 ，哈哈。</p><h3 id="一些有用的app-网站"><strong>一些有用的app &amp; 网站</strong></h3><blockquote><p>未必全面，仅供参考。</p></blockquote><ul><li>[注1]：各大公司校招官网，比如：<a href="join.qq.com">腾讯校园招聘</a> ，最好先去提前一次性注册好简历。</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">应用/网站名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>网站</strong></td><td style="text-align:center"><a href="https://www.nowcoder.com/">牛客网</a></td><td style="text-align:center">找内推、看面经、求职交流等</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode-cn.com/">Leetcode</a></td><td style="text-align:center">刷题</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://codetop.cc/">codeTop</a></td><td style="text-align:center">刷题</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://www.wondercv.com/">超级简历</a></td><td style="text-align:center">制作简历的不二之选</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://www.hwh.zone">royhuang’s blog</a></td><td style="text-align:center">毛遂自荐，看看八股</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/">github</a></td><td style="text-align:center">神奇的地方，多在这里找各种资源：面经总结、项目教程等</td></tr><tr><td style="text-align:center"><strong>APP</strong></td><td style="text-align:center">牛客网</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">脉脉</td><td style="text-align:center">求职信息交流，国内最大的职场交流APP</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">闲鱼</td><td style="text-align:center">各种教学视频课程，不妨这里先搜一搜</td></tr></tbody></table><p>🔼 以上大概就是我求职所用到的，全部网站或APP，不算多但基本有点用。</p><h3 id="写在最后"><strong>写在最后</strong></h3><p>碎碎念又写了小几K字了，9月底结束秋招时，便想着把自己求职的笔记总结&amp;经历复盘。不知不觉又拖延/玩了两个月，这个星期把网站搞好了也正好顺手开始整理。写到这里，终于有了初步了结，感觉像是De一个大BUG 🐛 ，心情都舒畅了起来。</p><p>后面还会<strong>继续更新没填好的坑</strong>，e.g. 怎么准备一个秋招项目。也会开始记录一些<strong>C++音视频相关方向博文</strong>，和一些生活记录（虽然大部分时间都是无聊地待在寝室或家里）。当然，如果还有什么想要和我说的，可以在下面留言。</p><p>最后，给上我最诚挚的祝福：</p><div align = "center" style="bold"> <h5>“ 明年请务必倒挂我，谢谢。”</h5></div><h3 id="更新记录">更新记录</h3><div class="timeline"><div class="timenode"><div class="meta"><p><p>2021-11-29 ：更新文档</p></p></div><div class="body"><ol><li>更新校招心得记录 &amp; 重新分类整理笔记</li><li>支持评论系统</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-11-24 ：第一次更新</p></p></div><div class="body"><ol><li>上传所有笔记并发布</li></ol></div></div></div> <div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Java Guide：https://github.com/Snailclimb/JavaGuide<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">阿秀C++面试笔记：https://github.com/forthespada/InterviewGuide<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">牛客网面经：https://www.nowcoder.com/interview/center<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 目录 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础笔记（初步整理）</title>
      <link href="/p/43848/"/>
      <url>/p/43848/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="一、Git-简介">一、Git 简介</h2><h3 id="1-1-安装">1.1 安装</h3><ul><li><p>安装地址</p><p>官网下载：<a href="https://git-scm.com/downloads">Git官网下载</a></p></li><li><p>设置用户信息</p><p>主要是设置 ： 名字 &amp; Email 地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;hwh&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;380141202@qq.com&quot;</span></span><br></pre></td></tr></table></figure><p><code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p></li></ul><h3 id="1-2-创建版本库">1.2 创建版本库</h3><ul><li><p>创建仓库</p><p>​       windows可以直接在桌面创建一个名为：&quot;Git&quot;文件夹，下有“test”子文件夹，子文件夹含有一个名为“<a href="http://readme.md">readme.md</a>”文件。</p><p>​       然后切换到其目录下（这里切换的是&quot;Git&quot;文件夹，而非“test”子文件夹）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> Git/</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/c/Users/86151/Desktop/Git</span><br></pre></td></tr></table></figure></li><li><p>初步提交过程</p><ul><li><p>初始化仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure></li><li><p>修改仓库文件</p><p>将“test”子文件夹，下readme.md文件，增加内容。</p></li><li><p>添加文件到仓库</p><p>注意：可以同时 一次添加<strong>多个</strong>文件到仓库！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure></li><li><p>提交文件</p><p>可以增加m参数：添加修改信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;第一次文件改动&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="二、时光机穿梭">二、时光机穿梭</h2><h3 id="2-0-更多控制修改提交">2.0 更多控制修改提交</h3><ul><li><p>概览</p><ul><li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li><li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff &lt;filepath&gt;</code>可以查看修改内容。</li></ul></li><li><p>实操</p><ul><li><p>再次修改文件</p><p>可以先清除原文件，再增添readme.md文档内容 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“i am  huitailang , here  is my first test word .“</span><br><span class="line"></span><br><span class="line"> “这是我第二次修改这个文件”</span><br></pre></td></tr></table></figure><p>使用 <code>git status</code>，查看状态发现readme.md文件已被修改但未提交（<strong>no changes</strong>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560766427962.png" alt="1560766427962"></p></li><li><p>查看具体修改了什么内容</p><p><code>git diff &lt;filepath&gt;</code>查看文件具体修改，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560766437006.png" alt="1560766437006"></p></li><li><p>添加仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure><p>同时可用 <code>git status</code>，查看此时状态会显示，readme.md将要被提交修改。</p></li><li><p>提交仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;这是我第二次修改&quot;</span></span><br></pre></td></tr></table></figure><p>​     再用 <code>git status</code>，查看仓库当前状态，显示没有需要提交的修改，而且工作目录是干净的（working tree clean）。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560766449576.png" alt="1560766449576"></p></li></ul></li></ul><h3 id="2-1-版本回退">2.1 版本回退</h3><ul><li><p>概览</p><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本</li></ul></li><li><p>实操</p><ul><li><p>N次修改文件</p><p>先多修改几次文件提交，得到多个版本。</p></li><li><p>版本回退</p><ul><li><p>查看版本历史</p><p><code>git log </code>查看当前版本和之前的历史，<code>git relog</code> 查看所有版本历史</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span>  <span class="comment"># 可以加上 --pretty=oneline 参数使显示更简洁</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560778515569.png" alt="1560778515569"></p></li></ul></li><li><p>回退版本</p><p><code>git reset --hard &lt;指定版本&gt;</code>：可用于回到指定版本，&lt;<strong>指定版本</strong>&gt;方式：</p><ul><li><p>HEAD ^</p><p>HEAD ^ 回到上个版本；HEAD ^ ^  回到上上 个版本，依此类推。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^^  <span class="comment"># 回到上上个版本</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560779037449.png" alt="1560779037449"></p></li><li><p>HEAD~&lt;数字&gt;</p><p>回到前&lt;数字&gt;版本。如HEAD~100，回到前100个版本。</p></li><li><p><commit ID> :</p><p>commit ID 不用打全，一般打前面几个字符即可。如，如果回退第2版本，<code>git log</code>，只能看到第2版本及之前的版本信息。那么可用 <code>git reflog</code>查看所有版本ID，然后指定ID，回到第4版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560779323726.png" alt="1560779323726"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 3928d   <span class="comment"># 再次回到第四次修改版本</span></span><br><span class="line">HEAD is now at 3928d9f 第四次修改</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="2-2-工作区和暂存区">2.2 工作区和暂存区</h3><ul><li><p>概览</p><ul><li>理解工作区和暂存区的区别，暂存区是版本库的一个子集</li><li>比较文件有三个不同命令<ul><li>git diff   <filename></li><li>git diff  --cached <filename></li><li>git diff  --HEAD <filename></li></ul></li></ul></li><li><p>工作区</p><p>工作区就是我们能看到的目录，如我前面创建的<code>Git</code>文件夹就是一个工作区</p></li><li><p>版本库 &amp; 暂存区</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/0" alt="git-repo"></p><p>工作区有一个隐藏目录<code>.git</code>，不属于工作区而是Git版本库，版本库包含</p><ul><li><p>Git自动创建的分支<code>master</code>&amp;指向<code>master</code>的指针<code>HEAD</code></p></li><li><p>stage（或叫index）暂存区</p></li></ul></li><li><p>暂存区工作</p><ul><li><p><strong>git add</strong></p><p>这一步实际上就是把文件修改（已存在被修改 OR 新文件）添加到暂存区，可以add多个文件，一次被提交。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/0" alt="git-stage"></p></li><li><p><strong>git commit</strong></p><p>把暂存区的<strong>所有</strong>内容提交到当前分支。</p><p>但是注意，git commit 后<strong>暂存区文件不会消失</strong>，始终是上一次git add之后文件！</p></li><li><p><strong>git diff</strong>  &amp;<strong>git diff --cached</strong> &amp;<strong>git diff HEAD</strong></p><p>git diff  比较的是<strong>工作区文件和暂存区文件</strong>区别。</p><p>git diff --cached 比较的是<strong>暂存区文件和仓库分支文件</strong>区别。</p><p>git diff --HEAD 比较的是<strong>工作区文件和仓库分支最新版本</strong>区别。</p><ul><li><p>暂存区：就是 .git / index 这个文件，git add 会把工作区修改的文件添加到暂存区，即使 git commit 后也不会空，<strong>始终保存最近一次 git add后的内容</strong>。</p></li><li><p>仓库分支：<strong>始终保存上次git commit 内容</strong>。</p></li></ul></li></ul></li></ul><h3 id="2-3-管理修改">2.3 管理修改</h3><ul><li><p>概览</p><ul><li>git管理的是修改，而非文件</li></ul></li><li><p>实操</p><p>新建一个文件 readme1.txt，然后依次：</p><blockquote><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p></blockquote><p>​      用<code>git diff HEAD test/readme1.txt</code> 比较<strong>工作区和版本分支</strong>，会发现第二次修改没有被提交，说明git只把git add后暂存区内容提交了，而不管理文件。</p><p>如果要把第二次修改也提交了，需要进行以下操作：</p><blockquote><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改-&gt; <code>git add</code>  -&gt; <code>git commit</code></p></blockquote></li></ul><h3 id="2-4-撤销修改">2.4 撤销修改</h3><ul><li><p>概览</p><ul><li><p>场景1：改乱了工作区某个文件的内容，想直接丢弃工作区的修改时</p><p>用命令<code>git checkout -- file</code>。</p></li><li><p>场景2：不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改</p><ul><li>第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1</li><li>第二步按场景1操作。</li></ul></li><li><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交</p><p>参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p></li></ul></li><li><p>实操</p><ul><li><p>场景1</p><p>不小心在文件里增加了一句话：</p><blockquote><p>刘婷是傻子</p></blockquote><p>用 <code>git checkout</code>命令撤回工作区修改，有两种情况</p><ul><li><code>readme.txt</code>修改但未被放到暂存区，撤销修改就回到和版本库一样状态；</li><li><code>readme.txt</code>修改且添加到暂存区后，撤销修改就回到添加到暂存区后的状态。</li></ul><blockquote><p>⚠️ 总之，就是让文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>🕵所以，也可用于恢复误删的文件（撤销工作区删除操作）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560826918878.png" alt="1560826918878"></p></li><li><p>场景2</p><p>不小心在文件里增加了一句话，而且已经git add提交到暂存区</p><blockquote><p>刘婷是傻子哈哈哈</p></blockquote><p>命令<code>git reset </code><strong>不仅可以回退版本 而且可以把暂存区的修改撤销</strong>。</p><p>⚠️之所以不直接 git checkout 是因为此时会用<strong>暂存区内容覆盖工作区</strong>，显然不行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD <span class="built_in">test</span>/readme.md <span class="comment"># HEAD表示最新版本</span></span><br></pre></td></tr></table></figure><p>然后此时再用git checkout ，暂存区内容覆盖工作区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure><p>再次查看文件发现，‘’刘婷是傻子哈哈哈‘’ 的胡话已经被没了，暂存区也没了。</p></li><li><p>场景3</p><p>又说胡话，不但 git add 且git  commit（暂存区和版本库<strong>HEAD</strong>都是修改后版本）</p><blockquote><p>刘婷是傻子哈哈哈哈哈哈</p></blockquote><p>这个时候只有回退版本了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog  <span class="comment"># 查看版本号</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard  3928</span><br><span class="line">HEAD is now at 3928d9f 第四次修改</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-5-删除文件">2.5 删除文件</h3><ul><li><p>rm 删除</p><ul><li><p>原理</p><p>rm 删除文件，只相当于删除了 工作区文件，如果要恢复文件撤销工作区修改即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure></li><li><p>恢复</p><p>用<code>git checkout -- &lt;file&gt;</code>，它会用最新版本库文件（如果已经git add 用最新暂存区内容，见前）覆盖工作区文件，则相当于撤销工作区修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure></li></ul></li><li><p>git rm 删除</p><ul><li><p>原理</p><p>git rm 删除文件，不但相当于<strong>删除工作区文件 &amp;  而且git add添加到暂存区</strong>。</p><p>所以此时直接<code>git checkout </code>是用暂存区内容覆盖 工作区，显然是没用的。</p></li><li><p>恢复</p><ul><li><p>先恢复暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD <span class="built_in">test</span>/readme.md <span class="comment"># HEAD表示最新版本</span></span><br></pre></td></tr></table></figure></li><li><p>再用暂存区覆盖工作区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure></li></ul></li><li><p>彻底删除</p><p>如前所述，git rm 已经删除了 ①工作区文件 ② 添加到暂存区，那么此时只需要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --m <span class="string">&#x27;彻底删除&#x27;</span>  <span class="comment"># 将③版本库内容也修改</span></span><br></pre></td></tr></table></figure><p>那么文件就会从工作区、暂存区、版本库全部删除。</p></li><li><p>彻底删除恢复</p><p>如果已经commit，那么只能<code>git reset</code>回退版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard  3928</span><br><span class="line">HEAD is now at 3928d9f 第四次修改</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="三、远程仓库">三、远程仓库</h2><h3 id="3-1-添加远程库上传本地文件">3.1 添加远程库上传本地文件</h3><blockquote><p>以下操作基于默认你</p><ul><li>创建好 github 账号 &amp; 创建好一个仓库</li><li>设置好本地ssh -key 而且已经同时在github网页服务端账号设置里添加 ssh -key</li></ul></blockquote><ol><li><p>添加用户信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;hwh&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;380141202@qq.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>初始化本地仓库</p><blockquote><p>如果本地仓库从未被初始化才需要，初始化会创建一个隐藏的 .git 文件管理版本。</p></blockquote><ul><li><p>cd切换 + git init</p><p>cd命令切换到后本地仓库；</p><p>git init 初始化本地仓库，会为你创建一个 .git文件，已经初始化不用。</p></li><li><p>手动 bash</p><blockquote><p>⚠️ 很奇怪的是，这样 git add . --&gt; git commit --&gt; git push后，会把整个父文件夹推送上去。</p><p>比如：地址 TEST 文件夹下有 <a href="http://README.md">README.md</a> ，推送后github上显示的 TEST文件夹，而不是我想的README.md文件。</p></blockquote><p>右击本地仓库，选择<code>Git Bash here</code></p></li></ul></li><li><p>把本地仓库添加到版本库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add .  <span class="comment"># add . 提交所有新建、修改文件</span></span><br><span class="line">$ git commit -m <span class="string">&#x27;第一次添加本地仓库到版本库&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>本地仓库关联远程库</p><p><code>git remote add &lt;远程库名设置&gt;  &lt;远程仓库地址&gt;</code></p><p>显然这里把<strong>远程仓库地址设置为 origin</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:huangwanghuiYY/gitTest.git</span><br></pre></td></tr></table></figure></li><li><p>推送到远程库</p><p>下面代码表示：将本地<code>master</code>分支推送到远程仓库<code>origin</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master  <span class="comment"># 第一次推送带 -u 参数</span></span><br></pre></td></tr></table></figure><p><code>-u</code>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2-从远程库克隆">3.2 从远程库克隆</h3><blockquote><p>​       当我们想多人协作时会用到克隆。比如有一个不错的开源项目，你可以克隆到<code>本地仓库</code>进行修改等。</p></blockquote><ol><li><p>确定要克隆的仓库</p><p>比如我的XSurvey项目。</p></li><li><p>git clone 进行克隆</p><p>克隆会在<code>当前文件夹</code>创建克隆的仓库，克隆仓库以XSuery为名，下含项目文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:huangwanghuiYY/XSurvey.git</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560943024969.png" alt="1560943024969"></p></li></ol><h2 id="四、分支管理">四、分支管理</h2><h3 id="4-1-创建和合并分支">4.1 创建和合并分支</h3><blockquote><p>这一节，涉及大量图形，<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424">廖雪峰教程</a>  讲的很好，这里尽量精简记录心得。</p></blockquote><ul><li><p>概述</p><ul><li><p>查看分支：<code>git branch</code></p></li><li><p>创建分支：<code>git branch &lt;name&gt;</code></p></li><li><p>切换分支：<code>git checkout &lt;name&gt;</code></p></li><li><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p></li><li><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p></li><li><p>删除分支：<code>git branch -d &lt;name&gt;</code></p></li></ul></li><li><p>实操记录</p><ul><li><p>主分支</p><p>​       <code>master</code>分支也是一条时间线，每次<strong>提交</strong> master 分支都会向前移动一步，随着不断提交 master分支也就越长。</p><p>⚠️下图有两个指针：<code>HEAD</code> &amp; <code>master</code> ，<code>HEAD</code>严格来说不是指向提交。HEAD指向master，master指向最新分支。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/0" alt="git-br-initial"></p></li><li><p>新分支创建切换</p><ul><li><p>创建新分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev1   <span class="comment"># 新建分支</span></span><br><span class="line">$ git branch        <span class="comment"># 查看分支</span></span><br><span class="line">  dev1</span><br><span class="line">* master           <span class="comment"># * 表示当前所在的分支（master）</span></span><br></pre></td></tr></table></figure><p>​     当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>指向的提交。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560997582503.png" alt="1560997582503"></p></li><li><p>切换到当前分支</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev1</span><br></pre></td></tr></table></figure><p>如果checkout 加上 -b参数，表示 创建 &amp; 切换两个操作</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev1</span><br></pre></td></tr></table></figure><p>切换到当前分支，其实把head指向master所指向的提交。</p><p>⚠️这张图，还表示dev分支还执行了<strong>一次提交</strong>。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/0" alt="git-br-dev-fd"></p></li></ul></li><li><p>合并分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master  <span class="comment"># 先切回master分支（即HEAD指向master）</span></span><br><span class="line">$ git merge dev1   <span class="comment"># 表示当前分支（master）合并 dev1分支</span></span><br></pre></td></tr></table></figure><p>根据上图我们可以看到：</p><p>​      <code>dev</code>分支向前走了一步，<code>dev</code>指向了<strong>当前最新</strong>提交，而<code>master</code>指针依然指向<strong>上次</strong>提交。</p><p>​      如果要合并，那么直接<strong>让<code>master</code>指向<code>dev</code>指向的当前提交</strong> 。相当于，master也提交过一次。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/0" alt="git-br-ff-merge"></p></li><li><p>删除分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure><p>​     删除分支，等价于删除创建分支后的提交记录（上图红色线），但由于master指向了最新提交，等价复制dev1的提交记录（蓝色线）。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/0" alt="git-br-rm"></p><p>​</p></li></ul></li></ul><h3 id="4-2-解决同时修改冲突">4.2 解决同时修改冲突</h3><ul><li><p>产生冲突原因</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561001334904.png" alt="1561001334904"></p><ul><li><p>在master分支上</p><ul><li><p>在当前<code>master</code>分支上，创建一个新分支  <code>dev2</code></p></li><li><p>同时master分支上，对README.md文件增加一句话</p><blockquote><p>i said master</p></blockquote></li><li><p>⚠️ 然后，<code>git add  --&gt; git commit</code></p></li></ul></li><li><p>在dev2分支上</p><ul><li><p>checkout切回master分支上，对README.md文件增加一句话</p><blockquote><p>i said dev2</p></blockquote></li><li><p>⚠️ 然后，<code>git add  --&gt; git commit</code></p></li></ul></li><li><p>合并</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge dev2</span><br></pre></td></tr></table></figure><p>显示，README.md文件同时被修改，发生冲突（也可用 <code>git status</code> 查看）</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561001544117.png" alt="1561001544117"></p><p>vim 查看文件显示具体冲突：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim README.md <span class="comment">#当前HEAD指向master，所以下图显示HEAD</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561001684363.png" alt="1561001684363"></p></li></ul></li><li><p>解决冲突</p><p>Ⓜ️此时<strong>两</strong><a href="http://xn--README-ov7i.md">个README.md</a><strong>已经是一个文件了</strong>，文件内容就是上图vim查看的<strong>所有</strong>内容 。</p><p>我们再命令行端口也可以看到，提示我们在 master|MERGING 合并中。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561002765319.png" alt="1561002765319"></p><p>​     我们打开文件，修改文件内容为：（第一句话有误，此时实在master分支上，不用在意）</p><blockquote><p>这是的dev分支，我增加了一句话</p><p>修改冲突，这里变成这样。其实不修改直接提交也解决冲突，只是没解决同时修改。</p></blockquote><p>然后再提交，发现冲突已经解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add README.md </span><br><span class="line">$ git commit -m <span class="string">&#x27;解决冲突&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561002865426.png" alt="1561002865426"></p></li></ul><h3 id="4-3-分支管理策略-–-禁用Fast-forward">4.3 分支管理策略 – 禁用Fast forward</h3><ul><li><p>概览</p><blockquote><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，则直接把 master 的指针直接指向了 dev 分支的最新提交，这样两个分支的最新提交的 commit id 就是一样的。但这种模式下，删除分支后，会丢掉分支信息。</p><p><strong>加上<code>--no-ff</code>参数，强制禁用<code>Fast forward</code>模式，使用普通模式</strong>。Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p></blockquote></li><li><p>实操</p><blockquote><p>默认已经创建好分支 dev3，且修该了文，进行了一次<strong>commit</strong>。</p><p>然后下面都是在 master分支上尝试合并操作</p></blockquote><ol><li><p>切回master</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure></li><li><p>合并分支</p><p>–no–ff ： 普通模式合并。</p><p>-m ：由于本次合并<strong>dev</strong>要创建一个新的commit，所以加上<code>-m</code>参数，添加描述。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">&quot;merge with no-ff&quot;</span> dev</span><br></pre></td></tr></table></figure></li><li><p>查看历史</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure></li><li><p>Fast forward模式 &amp; 普通模式 对比</p><blockquote><p>FF模式不用<code>--no-ff</code>，实际上只是将master的指针update成dev分支而已。用的还是dev的commit ID。</p><p>普通模式用，则是重新commit一次，有了新的commit ID，<strong>保留了分支版本记录</strong>。</p></blockquote><ul><li><p>Fast forward模式</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/0" alt="git-br-ff-merge"></p></li><li><p>普通模式</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/0" alt="git-no-ff-mode"></p></li></ul></li></ol></li></ul><h3 id="4-4-BUG分支—git-stash">4.4 BUG分支—git stash</h3><ul><li><p>概览</p><blockquote><p>​      修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>​      当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p></blockquote></li><li><p>实操（应用场景）</p><ol><li><p>master 上面发布的是A的1.0版本</p></li><li><p>dev 上开发的是A的2.0版本 ，<strong>刚刚新建了test文件</strong> &amp;<strong><a href="http://xn--README-2g0js76l.md">修改README.md</a></strong>：</p><blockquote><p>这里是dev分支。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561019801527.png" alt="1561019801527"></p></li><li><p>这时，用户反映 1.0版本存在漏洞，有人利用这个漏洞开外挂</p></li><li><p>需要从dev切换到master去填这个漏洞，正常必须先提交dev目前的工作，才能切换。</p><ul><li><p>如果不commit切换分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master </span><br></pre></td></tr></table></figure><p>发现当前工作目录，是dev分支工作目录！</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561018815751.png" alt="1561018815751"></p></li><li><p>解释1</p><blockquote><p>一个本地的git repo只有一个工作区和暂存区，但是有多个分支的提交区，而我们的checkout只是将HEAD指针从一个分支切换到另一个分支。</p></blockquote><p>所以：</p><ol><li><p>切换后工作区内容是branch的工作内容</p></li><li><p>经过测试，如果切回dev分支，进行<code>add --&gt; commi</code>t 再切回master就回到       master工作区。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561019439523.png" alt="1561019439523"></p></li></ol></li></ul></li><li><p>而dev的工作还未完成，不想提交，所以先把dev的工作stash一下，然后切换到master：</p><ol><li><p>先git add test</p><blockquote><p>⚠️  为什么要先add test文件？</p><p>test文件是新建，还未被git管理！让git add<strong>追踪test文件</strong>，否则即使 git stash ，test文件也依然会出现在master工作目录中！</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li><li><p>git stash 然后切换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561021862083.png" alt="1561021862083"></p></li><li><p>恢复dev工作目录</p><p>简单恢复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop  <span class="comment"># 恢复的同时把stash内容也删了</span></span><br></pre></td></tr></table></figure><p>有多个因此目录，可以配合下面目录恢复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list  </span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br><span class="line">$ git stash apply stash@&#123;0&#125; <span class="comment"># 恢复不会删除stash内容</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>在master建立分支issue101并切换。</p></li><li><p>在issue101上修复漏洞。</p></li><li><p>修复后，在master上合并issue101  。</p></li><li><p>切回dev，恢复原本工作，继续工作。</p></li></ol></li></ul><h3 id="4-5-删除分支">4.5 删除分支</h3><p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h3 id="4-6-多人协作">4.6 多人协作</h3><ul><li><p><strong>查看分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v  <span class="comment"># 带-v参数查看更加详细</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561023498006.png" alt="1561023498006"></p></li><li><p><strong>push 推送分支</strong></p><p><code>git push &lt;远程库名&gt; &lt;要推送分支名&gt;</code></p><blockquote><p>​      推送本地主分支master到 origin master，相当用本地master版本覆盖远程origin master版本。</p><p>⚠️ git push 只能用户该项目属于自己的情况，因为要输入账号密码！参与他人开源：</p><ul><li>成为该开源项目贡献者（由项目作者设置）</li><li>fork 该项目 ----&gt; clone到本地----&gt; 修改 ----&gt; 发起 pull requset —&gt; 讨论 &amp; 等待合并</li></ul><p>还有其他更多情况，如产生冲突等，查看：<a href="%5Bhttps://progit.bootcss.com/#_%E5%AF%B9%E9%A1%B9%E7%9B%AE%E5%81%9A%E5%87%BA%E8%B4%A1%E7%8C%AE%5D(https://progit.bootcss.com/#_%E5%AF%B9%E9%A1%B9%E7%9B%AE%E5%81%9A%E5%87%BA%E8%B4%A1%E7%8C%AE)">pro git 中文# 对项目做出贡献</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561024444763.png" alt="1561024444763"></p><blockquote><p>推送其他分支到远程库 ，也可以查看。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561024648502.png" alt="1561024648502"></p></li><li><p>clone 克隆分支工作</p><p>多人协作时，大家都会往<strong>远程库</strong><code>master</code>和<code>dev</code>分支上推送各自的修改。</p><ol><li><p>克隆主分支</p><blockquote><p>⚠️ 克隆只能克隆master分支！！</p></blockquote><p>现在，模拟你的小伙伴，在另一台电脑（注意要把SSH Key添加到GitHub）克隆：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:michaelliao/Python-100-Days</span><br></pre></td></tr></table></figure></li><li><p>克隆远程dev分支开发</p><p>由于只能克隆master分支，而又要在远程dev分支开发，那么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>之后就可进行修改 —&gt; 提交 ：git push了</p></li></ol></li><li><p><code>git pull</code></p><blockquote><p>一种应用情况：A、B都克隆了项目，在远程分支dev上进行开发（分别在本地也克隆dev分支）</p><ol><li><p>A修改了文件 README，并进行了push提交 。</p></li><li><p>你也修改了README，进行提交修改，会出错，原因是</p><p>⚠️<strong>远程分支比你的本地更新！</strong></p></li><li><p>只有先 pull 最新分支你的分支合并 —&gt; 解决冲突—&gt;提交</p></li></ol></blockquote><p><code>git pull</code>命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并，它的完整格式稍稍有点复杂。</p><blockquote><p>在默认模式下，<code>git pull</code>是<code>git fetch</code>后跟<code>git merge FETCH_HEAD</code>的缩写。</p><p>git pull == git fetch+  git merge （默认是检索头部合并到当前分支）</p><p>⚠️ 使用–rebase，它运行<code>git rebase</code>而不是<code>git merge</code>。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull&lt;可选参数&gt; &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span></span><br></pre></td></tr></table></figure><h2 id="示例">示例</h2><p>比如，要取回<code>origin</code>主机的<code>next</code>分支，与本地的<code>master</code>分支合并：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin next:master</span></span><br></pre></td></tr></table></figure><ul><li><p>省略当前分支名</p><p>如果远程分支(<code>next</code>)要与当前分支合并，则冒号后面的部分可以省略。上面命令可以简写为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin next</span></span><br></pre></td></tr></table></figure><p>上面命令表示，取回<code>origin/next</code>分支，再与当前分支合并。实质上，这等同于先做<code>git fetch</code>，再执行<code>git merge</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/next</span></span><br></pre></td></tr></table></figure></li><li><p>省略远程分支名</p><blockquote><p>某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在<code>git clone</code>的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的<code>master</code>分支自动”追踪”<code>origin/master</code>分支。</p><p>Git也允许手动建立追踪关系，指定<code>master</code>分支追踪<code>origin/next</code>分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream master origin/next</span></span><br></pre></td></tr></table></figure></blockquote><p>如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin</span></span><br></pre></td></tr></table></figure><p>上面命令表示，本地的当前分支自动与对应的<code>origin</code>主机”追踪分支”(remote-tracking branch)进行合并。</p></li><li><p>省略远程主机名</p><p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>git fetch和git pull的区别</strong></p><ol><li><em>git fetch</em>：相当于是从远程获取最新版本到本地，不会自动合并。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p master..origin/master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/master</span></span><br></pre></td></tr></table></figure><p>以上命令的含义：</p><ul><li>首先从远程的<code>origin</code>的<code>master</code>主分支下载最新的版本到<code>origin/master</code>分支上</li><li>然后比较本地的<code>master</code>分支和<code>origin/master</code>分支的差别</li><li>最后进行合并</li></ul><p>上述过程其实可以用以下更清晰的方式来进行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin master:tmp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff tmp</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge tmp</span></span><br></pre></td></tr></table></figure><ol start="2"><li><em>git pull</em>：相当于是从远程获取最新版本并<code>merge</code>到本地</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin maste</span><br></pre></td></tr></table></figure></li></ul><h2 id="五、标签管理">五、标签管理</h2><h3 id="5-1-创建标签">5.1 创建标签</h3><h3 id="5-2-操作标签">5.2 操作标签</h3><h2 id="六、使用Github">六、使用Github</h2><h3 id="6-1-简单上传">6.1 简单上传</h3><ol><li><p>设置用户信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;hwh&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;380141202@qq.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>git init 初始化仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></li><li><p>本地创建ssh key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;380141202@qq.com&quot;</span> <span class="comment"># 后面会要求设置密码可不设置</span></span><br></pre></td></tr></table></figure><p>然后会在：C:\Users\80651\.ssh 生成ssh key 文件，其下有一个公钥 <code>id_rsa.pub</code>，记事本打开复制。</p></li><li><p>打开github设置</p><p>打开github 在个人设置中添加**2.**中ssh key。</p><p>可用 <code>ssh -T</code>查看是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></li><li><p>对文件一些操作</p><p>比如，这里以增加一个README文件，然后<strong>git commit 提交</strong>到版本库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add README   <span class="comment"># 也可add . 提交所有新建、修改文件</span></span><br><span class="line">$ git commit -m <span class="string">&#x27;增加readme&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>push 上传到版本库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><blockquote><p>Q : git push 出现错误 ‘’ error: failed to push some refs to git‘’</p><p>A : 一般是因为github中的<code>README.md</code>文件不在本地代码目录中</p><ul><li><p>添加 -f 参数强制覆盖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure></li><li><p>通过如下命令进行github与本地代码合并:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git pull --rebase origin master   <span class="comment"># 先和本地代码合并</span></span><br><span class="line">$ git push    <span class="comment"># 然后再上传</span></span><br></pre></td></tr></table></figure></li></ul></blockquote></li></ol><h3 id="6-2-参与开源项目">6.2 参与开源项目</h3><blockquote><p>可参考：<a href="https://www.zhihu.com/question/21682976/answer/79489643">GitHub的Pull Request 是指什么意思</a></p></blockquote><h2 id="七、自定义Git">七、自定义Git</h2><ol><li><p>服务器端安装Git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install git</span><br></pre></td></tr></table></figure></li><li><p>创建用户 &amp; 组 管理仓库目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ groupadd git</span><br><span class="line">$ useradd git -g git  <span class="comment"># -g 参数表示把用户gituser主组设置为 git</span></span><br></pre></td></tr></table></figure></li><li><p>创建目录</p><p>我们先创建一个目录<code>gitrepo</code>用来管理其下仓库，一般习惯在 /var下创建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var</span><br><span class="line">$ mkdir gitrepo</span><br></pre></td></tr></table></figure><p>给其设置好用户 &amp; 组，便于管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chown -R gituser:git gitrepo <span class="comment"># 把目录gitrepo 设置用户gituser &amp; 组 git</span></span><br></pre></td></tr></table></figure><p><code>ls -l</code> 查看是否设置成功：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561122220352.png" alt="1561122220352"></p></li><li><p>创建仓库</p><p>创建<code>hwhComputer2Backup.git</code>仓库，并初始化用来上传电脑备份。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> gitrepo  <span class="comment"># 注意先切换到git下</span></span><br><span class="line">$ git init --bare hwhComputer2Backup.git</span><br></pre></td></tr></table></figure></li><li><p>创建证书</p><ul><li><p>在本地电脑上</p><p>执行以下命令创建ssh 公钥。会在：<code>C:\Users\80651\\.ssh</code> 生成ssh key 文件，其下有一个公钥 <code>id_rsa.pub</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;380141202@qq.com&quot;</span> <span class="comment"># 后面会要求设置密码可不设置</span></span><br></pre></td></tr></table></figure></li><li><p>切回服务端</p><blockquote><p>裸机需创建<code>/home/git/.ssh/authorized_keys</code>文件。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> gitrepo/</span><br><span class="line">$ mkdir .ssh</span><br><span class="line">$ touch .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>然后把本地电脑上公钥复制导入，一行一个（？）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561123680464.png" alt="1561123680464"></p></li></ul></li><li><p>再次修改权限</p><blockquote><p>创建的子目录 用户 &amp; 组 默认是 root root</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561124160395.png" alt="1561124160395"></p><p>⚠️由于.ssh &amp; 仓库 hwhComputer2Backup.git 都不属于 gituser ，所有还需设置权限。否则进行 push pull 操作 没有足够权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var</span><br><span class="line">$ chown -R gituser:git gitrepo</span><br></pre></td></tr></table></figure></li><li><p>本地上传文件</p><ol><li><p>添加用户信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;hwh&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;380141202@qq.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>初始化本地仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> D:/hwh/uploadToGit</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure></li><li><p>把本地仓库添加到版本库</p><blockquote><p>错误：c#程序练习 does not have a commit checked out</p><p>解决：是因为 c#程序练习 这个文件夹已经被初始化，查看隐藏文件可以发现 .git文件删除其即可。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add .  <span class="comment"># add . 提交所有新建、修改文件</span></span><br><span class="line">$ git commit -m <span class="string">&#x27;第一次备份文件&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>本地仓库关联远程库</p><blockquote><p>移除当前远程连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin </span><br></pre></td></tr></table></figure></blockquote><p><code>git remote add origin &lt;服务端用户名&gt;@&lt;远程库名地址&gt;:&lt;远程仓库地址&gt;</code></p><p>⚠️<code>&lt;服务端用户名&gt; :</code> 是在服务端的用户！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin gituser@129.28.154.240:/var/gitrepo/hwhComputer2Backup.git</span><br></pre></td></tr></table></figure></li><li><p>推送到远程库</p><blockquote><p>似乎由于 <em>ssh key</em> 设置不对，<em>git push</em> 要输入用户 <em>gituser</em> 的密码 123456？</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master  <span class="comment"># 第一次推送带 -u 参数</span></span><br></pre></td></tr></table></figure><p>等待上传服务器(速度有点慢)：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561128011507.png" alt="1561128011507"></p></li></ol></li></ol><h2 id="八、debug-记录">八、<code>debug</code> 记录</h2><blockquote><p><strong>ERROR</strong>：由于存在 <code>&gt;100M</code> 文件，提交后报错，不允许提交超过<code>100M</code> 文件，进行如下操作：</p><ul><li>压缩并删除<code>&gt;100M</code>文件</li><li>将相应文件加入 <code>.gitignore</code></li><li>再次<code>commit</code>  --&gt; <code>push</code></li></ul><p>依旧报相同错误。</p></blockquote><p>解决办法如下，参考：<a href="https://medium.com/@marcosantonocito/fixing-the-gh001-large-files-detected-you-may-want-to-try-git-large-file-storage-43336b983272">Fixing the “GH001…</a></p><ol><li><p>删除文件</p><blockquote><p>建议可以先回退最近的<code>commit</code> 分支</p></blockquote><p>利用以下命令删除所有在仓库中  <code>&gt;100M</code> 的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --index-filter <span class="string">&#x27;git rm --cached --ignore-unmatch &lt;大于100M文件URL&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>例如，我的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --index-filter <span class="string">&#x27;git rm --cached --ignore-unmatch  Experiment/Ex4_CustomerForecast/src/train.csv&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>再次提交</p><p>为了保险，可以先：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached ./   <span class="comment"># 本地代码不会被删除</span></span><br></pre></td></tr></table></figure><p>接下来正常：<code>git add --&gt; git commit --&gt; git push</code> 即可</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（九）_计算机基础_相关补充</title>
      <link href="/p/5582/"/>
      <url>/p/5582/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h1>九、相关补充</h1><h2 id="9-1-（要扩充）设计模式">9.1 （要扩充）设计模式</h2><blockquote><p>没有足够实际代码经验，只好先写这些应付下面试。</p></blockquote><h4 id="1-说说什么是单例模式-手写一个？">1.说说什么是单例模式 ?手写一个？</h4><p>单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。</p><ul><li><p><strong>手写单例模式</strong></p><blockquote><p>参考：<a href="https://www.runoob.com/design-pattern/singleton-pattern.html">https://www.runoob.com/design-pattern/singleton-pattern.html</a></p></blockquote><blockquote><p>记忆：“2private + 1public ”</p></blockquote><ol><li><p><strong>饿汉式</strong></p><p>线程安全 ， 但：类加载时就初始化，浪费内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建 SingleObject 的一个对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingleObject();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// *让构造函数为 private，这样该类就不会被实例化</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 获取唯一可用的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>懒汉式（不加锁）</strong></p><p>只有真正调用获取实例对象时，才会创建一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 调用时才判断</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) </span><br><span class="line">    &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>懒汉式（加锁）</strong></p><p>线程安全，但加锁性能不够高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="comment">// 就是多了个synchronized关键字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>双检锁式</strong></p><p>懒汉式（加锁）虽然可以保证只创建一个单例，但其性能不高，因为每次访问<strong>整个方法都加锁</strong>。</p><p>因此出现双检索式，在<code>instance=new DoubleCheckSingleton();</code> 进行加锁 ， <code>return instance;</code><strong>不加锁</strong>！</p><blockquote><p><strong>为什么要进行两次检查instance==null？</strong></p><ol><li><p>第一层检查作用</p><p>主要为了提高性能。如果没有第一层，上来就要加锁比较耗费性能</p></li><li><p>第二层检查作用</p><p>解决多线程并发问题。假设是第一次开始执行<code>getInstance</code>方法：</p><ol><li>A，B两个线程，此时<code>instance==null</code> ，A，B都通过了第一层检查。</li><li>假设A先拿到锁，往下执行创建一个实例，然后释放了锁；</li><li>此时B也拿到了锁，<strong>如果没有第二层检查，B会进行重新new一个实例</strong>，违背单例模式！</li></ol></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckSingleton</span></span></span><br><span class="line"><span class="class"></span>&#123;      </span><br><span class="line">     <span class="comment">// volitale 关键字修饰，避免指令重排，因为初始化操作是不原子化的 ：</span></span><br><span class="line">    <span class="comment">//  (1) 给DoubleCheckSingleton类的实例instance分配内存</span></span><br><span class="line">    <span class="comment">//  (2) 调用实例instance的构造函数来初始化成员变量</span></span><br><span class="line">    <span class="comment">//  (3) 将instance指向分配的内存地址</span></span><br><span class="line">    <span class="comment">//  在多线程中，A可能是 1→3→2的顺序，执行到1→3，此时另外一个线程看到instance不为null（因为前面线程执行了3）就直接返回实例。而此时并没有被分配内存故可能出现问题。</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123; <span class="comment">//第一层检查，是否存在实例</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckSingleton.class)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123; <span class="comment">//第二层检查，防止出现另外一个线程阻塞在synchronized，获得锁后重复创建实例</span></span><br><span class="line"></span><br><span class="line">                    instance=<span class="keyword">new</span> DoubleCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="2-说说你对代理模式的理解？">2.<strong>说说你对代理模式的理解</strong>？</h4><p>代理模式是给某一个对象提供一个代理，并由<strong>代理对象控制对原对象的引用</strong>。</p><ul><li><strong>优点</strong>：代理模式能够协调调用者和被调用者，<u>在一定程度上降低了系统的<strong>耦合度</strong></u>；可以<u>灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务</u>。</li><li><strong>缺点</strong>：由于使用了代理模式，因此程序的性能<u>没有直接调用性能高</u>；使用代理模式<u>提高了代码的复杂度</u>。</li></ul><h4 id="3-说说简单工厂模式？">3.<strong>说说简单工厂模式</strong>？</h4><p>简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，<strong>对实现了同一接口的一些类进行实例的创建</strong>。</p><ul><li><p>比如，一台咖啡机就可以理解为一个工厂模式，你只需要按下想喝的咖啡品类的按钮（摩卡或拿铁），它就会给你生产一杯相应的咖啡，你不需要管它内部的具体实现，只要告诉它你的需求即可；</p></li><li><p>【<strong>优点</strong>】<strong>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例</strong>，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；</p></li><li><p>【<strong>缺点</strong>】 不易拓展，<u>一旦添加新的产品类型，就不得不修改工厂的创建逻辑</u>； 产品类型较多时，工厂的创建逻辑可能过于复杂，一旦出错可能造成所有产品的创建失败，不利于系统的维护。</p></li></ul><h4 id="4-说说抽象工厂模式？">4.<strong>说说抽象工厂模式</strong>？</h4><p>抽象工厂模式是在简单工厂的基础上将未来<strong>可能需要修改的代码抽象出来</strong>，通过继承的方式让子类去做决定。</p><ul><li>【<strong>简单工厂模式缺点</strong>】以上面的咖啡工厂为例，某天我的口味突然变了，<u>不想喝咖啡了想喝啤酒，这个时候如果直接修改简单工厂里面的代码</u>，这种做法不但不够优雅，也不符合软件设计的“开闭原则”，因为每次新增品类都要修改原来的代码。</li><li>【<strong>抽象工厂</strong>】<strong>抽象工厂里只声明方法，具体的实现交给子类（子工厂）去实现</strong>，这个时候再有新增品类的需求，只需要新创建代码即可。如，创建一个啤酒工厂而不是咖啡工厂。</li></ul><h4 id="5-装饰器模式是什么？">5.<strong>装饰器模式是什么</strong>？</h4><blockquote><p>不够深入。</p></blockquote><p>装饰器模式是指<u>动态地给一个对象增加一些额外的功能</u>，同时<strong>又不改变其结构</strong>。</p><h2 id="9-2-分布式问题【校招必问】">9.2 分布式问题【校招必问】</h2><blockquote><p>非常系统的总结文档：<a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/03%20%20%E9%9D%A2%E8%AF%95%E5%AE%98%E5%A6%82%E4%BD%95%E8%80%83%E5%AF%9F%E4%B8%8E%20CAP%20%E6%9C%89%E5%85%B3%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%EF%BC%9F.md">分布式相关：第一页</a></p></blockquote><p>CAP 理论指的是什么：C（Consistency）是数据一致性、A（Availability）是服务可用性、P（Partition tolerance）是分区容错性。</p><ul><li><p><strong>问题引入</strong></p><p>现在有一个分布式系统 A，它有一个副本 A1，在正常情况下，客户端 Client 写数据到系统 A，然后数据从 A 节点同步到 A1 节点，再返回给 Client 成功状态。</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/assets/CgqCHl_-eW2ALOs5AAFBvaYD4f8199.png" alt="6.png"></p><p>但由于网络是不可靠的，节点 A 和 A1 的网络随时会因为中断而出现分区。所谓网络分区就是由于网络不通导致节点 A 和 A1 被隔离在不同的网络子集中，此时节点 A 的数据就不能及时同步到节点 A1 中了。</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/assets/Ciqc1F_-eXaAcu6nAAE3Pk18sD8666.png" alt="7.png"></p></li></ul><h4 id="9-1-1-在CAP基础上讲讲BASE？举实例说说？">9.1.1 在CAP基础上讲讲BASE？举实例说说？</h4><p>BASE 理论，它是 CAP 理论的延伸。BASE 是 Basically Available（基本可用）、Soft State（软状态）和 Eventually Consistent（最终一致性）三个单词的简写，作用是保证系统的可用性，然后通过<strong>最终一致性来代替强一致性</strong>，它是目前分布式系统设计中最具指导意义的经验总结。</p><p>其实是做了“可用性”方面的妥协，比如：</p><ul><li>电商网站在双十一大促等访问压力较大的时候，关闭商品排行榜等次要功能的展示，从而保证商品交易主流程的可用性，这也是我们常说的<strong>服务降级；</strong></li><li>为了错开双十一高峰期，电商网站会将<strong>预售商品的支付时间</strong>延后十到二十分钟，这就是<strong>流量削峰</strong>；</li><li>在你抢购商品的时候，往往会在队列中等待处理，这也是常用的<strong>延迟队列</strong>。</li></ul><p>软状态和最终一致性指的是允许系统中的数据存在中间状态，这同样是<strong>为了系统可用性而牺牲一段时间窗内的数据一致性</strong>，从而保证最终的数据一致性的做法。</p><h4 id="9-1-2-亿级商品分布式存储问题？">9.1.2 亿级商品分布式存储问题？</h4><h5 id="1-如何设计一个支持海量商品存储的高扩展性架构？">1.如何设计一个支持海量商品存储的高扩展性架构？</h5><p><strong>从这一点出发会考察你Hash（哈希）分片的具体实现原理</strong>。</p><ol><li>以商品 ID 作为关键字进行分片，系统会通过一个 Hash 函数计算商品 ID 的 Hash 值，然后取模，就能得到对应的分片；</li></ol><h5 id="2-在做分库分表时，基于-Hash-取模和一致性-Hash-的数据分片是如何实现的？">2.在做分库分表时，基于 Hash 取模和一致性 Hash 的数据分片是如何实现的？</h5><ol><li><strong>解决 Hash 分片的缺点，既保证数据均匀分布，又保证扩展性</strong> ，最终采用一致性 Hash ：它是指将存储节点和数据都映射到一个首尾相连的哈希环上。</li><li>具体见前，一致性哈希相关算法描述</li></ol><h5 id="3-在电商大促时期，如何对热点商品数据做存储策略-？">3.在电商大促时期，如何对热点商品数据做存储策略 ？</h5><ul><li><p><strong>问题</strong></p><p>一致性 Hash 提升了稳定性，使节点的加入和退出不会造成大规模的数据迁移，但<strong>本质上 Hash 分片是一种静态的分片方式</strong>，必须要提前设定分片的最大规模，<strong>而且无法避免单一热点问题，</strong> 某一数据被海量并发请求后，不论如何进行 Hash，数据也只能存在一个节点上，这势必会带来热点请求问题。</p></li><li><p><strong>解决</strong></p><p><strong>做 Range（范围）分片</strong>。 与 Hash 分片不同的是，Range 分片能结合业务逻辑规则，例如，我们用 “Category（商品类目）” 作为关键字进行<strong>动态分片时</strong>，不是以统一的商品一级类目为标准，而是可以按照一、二、三级类目进行灵活分片。例如，对于京东强势的 3C 品类，可以按照 3C 的三级品类设置分片；对于弱势品类，可以先按照一级品类进行分片，这样会让分片间的数据更加平衡。</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/assets/CgpVE1_-ed6AfUBMAAFtDc6PlH4881.png" alt="15.png"></p></li></ul><p><strong>4.强一致性和最终一致性的数据共识算法是如何实现的</strong>？</p><h4 id="9-1-3-海量并发，分布式事务一致性问题？">9.1.3 海量并发，分布式事务一致性问题？</h4><ul><li><p><strong>什么是分布式事务问题</strong>？</p><p>一次大的操作由多个小操作组成，这些<strong>小的操作分布在不同的服务器上</strong>，分布式事务需要<strong>保证这些小操作要么全部成功，要么全部失败</strong>。</p><p>举一个实例：</p><ul><li>京东旅行系统，拆分成多个子系统，如商品系统、促销系统、订单系统。用户下单时，<strong>订单系统生成订单，商品系统扣减库存，促销系统扣减优惠券</strong>，<strong>只有当三个系统的事务都提交之后，才认为此次下单成功</strong>，否则失败。</li></ul></li><li><p><strong>解决方案</strong></p><p>有两阶段提交协议（Two-Phase Commit，2PC）、3PC 、TCC 和基于消息队列的实现方式。</p><ul><li><p><strong>错误回答</strong>：方案很多，可以选择 2PC ，2PC 实现的流程是…</p></li><li><p><strong>错误原因</strong>： 因为在实际工作中，<strong>很少采用前几种方案（互联网中落地方案代价大）</strong>，基本都是基于 MQ 的可靠消息投递的方式来实现。</p></li><li><p><strong>正确回答</strong>：先介绍目前主流实现分布式系统事务一致性的方案（也就是基于 MQ 的可靠消息投递的机制）然后回答出可实现方案和关键知识点。另外，<strong>为了和面试官进一步交流，你可以提出 2PC 或 TCC</strong> （这是一种交流方案）。</p></li><li><p><strong>回答一、基于 MQ 的可靠消息投递方案</strong></p><ul><li><p><strong>什么是MQ</strong></p><p>核心的五个概念：</p><ol><li><strong>Queue</strong>: 真正存储数据的地方</li><li><strong>Exchange</strong>: 接收请求，转存数据</li><li><strong>Bind:</strong> 收到请求后存储到哪里</li><li><strong>消息生产者</strong>:发送数据的应用</li><li><strong>消息消费者</strong>: 取出数据处理的应用</li></ol></li><li><p><strong>场景实例</strong></p><blockquote><p><strong>订单系统（1）完成订单后，（2）购物车系统减购物车中的商品</strong>。</p></blockquote><p><img src="https://i.loli.net/2021/09/05/B2uKDL8cyfhplis.png" alt="img"></p><ol><li><p>订单系统在<strong>消息队列上</strong>开启一个事务（没有创建订单）；</p></li><li><p>订单系统给消息服务器发送一个“半消息”；</p><blockquote><p>这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，<strong>在事务提交之前，对于消费者来说，这个消息是不可见的</strong>。</p></blockquote></li><li><p>半消息发送成功后，<strong>订单系统就可以执行本地事务了</strong>，在订单库中创建一条订单记录，并提交订单库的数据库事务。</p></li><li><p>然后<strong>根据本地事务的执行结果决定提交或者回滚事务消息</strong>。</p><blockquote><p>如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。</p></blockquote></li><li><p>购物系统消费这条拿到的订单系统消息（<strong>确认了订单系统事务执行完毕</strong>），这样就可以继续下一步购物操作</p></li></ol></li></ul></li></ul></li></ul><h4 id="9-1-4-分布式锁问题">9.1.4 分布式锁问题</h4><blockquote><p><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/06%20%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F.md">06 分布式系统中，如何回答锁的实现原理？</a></p></blockquote><p>分布式锁是解决协调分布式系统之间，同步访问共享资源的一种方式。详细来讲：在分布式环境下，<strong>多个系统在同时操作共享资源</strong>（如写数据）时，发起操作的系统通常会通过一种方式去协调其他系统，然后获取访问权限，得到访问权限后才可以写入数据，其他系统必须等待权限释放。</p><img src="https://i.loli.net/2021/09/05/f7Fh83wrnqvH6PK.png" alt="image-20210905232542573" style="zoom:80%;" /><ul><li><p><strong>基于redis的分布式锁</strong></p><p><strong>使用setnx命令加锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongGetLock1</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 第一步：加锁</span></span><br><span class="line">    Long result = jedis.setnx(lockKey, requestId);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 第二步：设置过期时间</span></span><br><span class="line">        jedis.expire(lockKey, expireTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>setnx命令，意思就是 set if not exist，<strong>如果lockKey不存在，把key存入Redis</strong>，保存成功后如果result返回1，表示设置成功，如果非1，表示失败，别的线程已经设置过了。</p></li><li><p>expire()，设置过期时间，防止死锁，假设，如果一个锁set后，一直不删掉，那这个锁相当于一直存在，产生死锁。</p></li></ul></li></ul><p><strong>解决setnx与expire不是一个原子操作</strong></p><ul><li><p>加锁总共分两步，第一步jedis.setnx，第二步jedis.expire设置过期时间，setnx与expire不是一个原子操作，如果程序执行完第一步后异常了，第二步jedis.expire(lockKey, expireTime)没有得到执行，<strong>相当于这个锁没有过期时间，有产生死锁的可能</strong>。</p></li><li><p>解决方案为：一步操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockDemo</span> </span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">&quot;NX&quot;</span>;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">&quot;PX&quot;</span>;   </span><br><span class="line">        <span class="comment">/**     </span></span><br><span class="line"><span class="comment">        * 获取分布式锁    </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> jedis Redis客户端     </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> lockKey 锁    </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> requestId 请求标识     </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> expireTime 超期时间     </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> 是否获取功     */</span>   </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span></span></span><br><span class="line"><span class="function">   </span>&#123;    </span><br><span class="line">           <span class="comment">// 两步合二为一，一行代码加锁并设置 + 过期时间。       </span></span><br><span class="line">     <span class="keyword">if</span> (<span class="number">1</span> == jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime))</span><br><span class="line">      &#123;           </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//加锁成功        </span></span><br><span class="line">      &#125;       </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//加锁失败   </span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 解锁：对应del删除key即可</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;           </span><br><span class="line">      <span class="comment">// 第一步： 使用 requestId 判断加锁与解锁是不是同一个客户端    </span></span><br><span class="line">      <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) </span><br><span class="line">      &#123;       </span><br><span class="line">          <span class="comment">// 第二步： 若在此时，这把锁突然不是这个客户端的，则会误解锁     </span></span><br><span class="line">          jedis.del(lockKey);    </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​</p><ul><li><p><strong>基于Zoopkeeper的分布式锁</strong></p><blockquote><p>sync，lock也只能保证你当前机器线程安全，这样分布式访问还是有问题。</p><p>建议参考：<a href="https://www.cnblogs.com/aobing/p/12650036.html">https://www.cnblogs.com/aobing/p/12650036.html</a></p></blockquote><p>一个机器接收到了请求之后，先获取 zookeeper 上的一把分布式锁（zk会创建一个 znode），执行操作；然后另外一个机器也<strong>尝试去创建</strong>那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等待，等第一个机器执行完了方可拿到锁。</p><p>下面是创建临时顺序节点的情况：</p><ol><li><p>客户端调用create()方法创建名为“/dlm-locks/lockname/lock-”的临时顺序节点。</p></li><li><p>客户端调用getChildren(“lockname”)方法来获取所有已经创建的子节点。</p></li><li><p>客户端获取到所有子节点path之后，如果发现<strong>自己在步骤1中创建的节点是所有节点中序号最小</strong>的，就是看自己创建的序列号是否排第一，如果是第一，那么<strong>就认为这个客户端获得了锁</strong>，在它前面没有别的客户端拿到锁。</p></li><li><p>如果创建的节点不是所有节点中需要最小的，那么则<strong>监视比自己创建节点的序列号小的最大的节点，进入等待</strong>。直到下次监视的<strong>子节点变更的时候</strong>，再进行子节点的获取，判断是否获取锁。</p></li></ol></li><li><p><strong>基于关系型数据库 MySQL 实现分布式锁</strong></p><blockquote><p>参考：<a href="https://juejin.cn/post/6844904137172189198">https://juejin.cn/post/6844904137172189198</a></p></blockquote><p>利用 Mysql 的锁表，创建一张表，设置一个 UNIQUE KEY（如，<strong>利用主键ID的唯一性</strong>） 这个 KEY 就是要锁的 KEY，所以同一个 KEY 在mysql表里只能插入一次了。</p><blockquote><p>这样对锁的竞争就交给了数据库，处理同一个 KEY 数据库保证了只有一个节点能插入成功，其他节点都会插入失败。</p></blockquote><p>定义加锁、解锁代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lock</span> ：  </span></span><br><span class="line"><span class="function">    <span class="title">exec</span> <span class="title">sql</span>:</span> insert into lockedtable (xxx) values (xxx)    </span><br><span class="line">    <span class="keyword">if</span> result == true :       </span><br><span class="line">         <span class="keyword">return</span> true    </span><br><span class="line">    <span class="keyword">else</span> :        </span><br><span class="line">         <span class="keyword">return</span> falsedef </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">unlock</span> ：   # 解锁就是删除</span></span><br><span class="line"><span class="function"> <span class="title">exec</span> <span class="title">sql</span>:</span> delete <span class="keyword">from</span> lockedOrder where order_id=<span class="string">&#x27;order_id&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="9-3-其它问题">9.3 其它问题</h2><h4 id="1-【字节-懂车帝】什么是跨域？">1. 【字节-懂车帝】什么是跨域？</h4><blockquote><p>参考：<a href="https://www.jianshu.com/p/f049ac7e2220">https://www.jianshu.com/p/f049ac7e2220</a></p></blockquote><p>跨域，是指浏览器不能执行其他网站的脚本。它是由<strong>浏览器的同源策略</strong>造成的，是浏览器对JavaScript实施的安全限制。</p><p>同源策略限制了一下行为：</p><ol><li><p>Cookie、LocalStorage 和 IndexDB 无法读取</p></li><li><p>DOM 和 JS 对象无法获取</p></li><li><p>Ajax请求发送不出去</p></li></ol><p>具体的一些实例：</p><ol><li><p><strong>非跨域</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxxyyy.cn/index.html 调用 http://www.xxxyyy.cn/server.php 非跨域</span><br></pre></td></tr></table></figure></li><li><p><strong>跨域：主域不同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxxyyy.cn/index.html 调用  http://www.xxx.cn/server.php</span><br></pre></td></tr></table></figure></li><li><p><strong>跨域：子域名不同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://abc.xxxyyy.cn/index.html 调用  http://def.xxx.cn/server.php</span><br></pre></td></tr></table></figure></li><li><p><strong>跨域：端口不同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.cn:**8080**/index.html 调用  http://www.xxx.cn/server.php</span><br></pre></td></tr></table></figure></li><li><p><strong>跨域：协议不同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**https**://www.xxx.cn/index.html 调用  **http**://www.xxx.cn/server.php</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
