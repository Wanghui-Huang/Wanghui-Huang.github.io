<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端基础（一）JavaScript基础笔记(上)</title>
      <link href="/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>第一章：快速入门</h1><h2 id="1-1-hello-javaScript">1.1 <em>hello javaScript!</em></h2><p>我们编写一个简单 <em>test.js</em> 文件，里面有一行代码输出 <em>“hello javaScript!”</em> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">&quot;hello javaScript!&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后在准备好的 <em>.html</em> 文件<em>head</em> 标签内引入<em>test.js</em> 文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里默认当前路径是index.html所在目录--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>  <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;test.js&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>注意区分引入 <em>.js</em>文件 和 <em>css</em>文件区别：</p><ul><li><p><em>.js</em>文件 用一对 <u><em>&lt;script&gt;&lt;/script&gt;</em></u> 标签包围引用 ；<em>.css</em> 文件用 <u><em><link></em></u> 标签指向：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span>  <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>  <span class="attr">href</span>=<span class="string">&quot;main.css&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure></li><li><p><em>.js</em>文件 用 <em>src</em> 属性指向 ；<em>.css</em> 文件用 <em>href</em> 属性指向。</p></li></ul></li></ul><h4 id="引入-js-css文件不成功？">引入 js / css文件不成功？</h4><ol><li><p>没有保存文件</p><p>默认 <em>VSCode</em> 不会自动保存文件，如果不自己 <code>ctrl+s</code> ，打开浏览器 <em>F12</em>  --&gt; <em>Source</em> 发现 <em>mian.css</em>文件为空。</p><p>可以设置自动保存文件，或者自己手动保存解决。</p></li><li><p>错用 <em>href</em> 属性 引用 <em>js</em>文件</p><p>见前。</p></li></ol><h2 id="1-2-安装-codeRunner-插件">1.2 安装 <em>codeRunner</em> 插件</h2><p>我们肯定不希望，每次输出一些信息，都要打开浏览器去查看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">&quot;我想输出一些信息&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果可以直接在 <em>VSCoder</em> 中就打印出信息多好啊！但是直接写在<em>js</em> 文件中，只能在浏览器控制台查看。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;我想输出一些信息&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="如何直接打印信息？">如何直接打印信息？</h4><blockquote><p><em>JavaScript</em> 可以直接打印：<u>数组</u>、<u>对象</u>、字符串、数值类型等</p></blockquote><p>第一种方式只能在浏览器中查看，后来两种可以直接在VS中查看。</p><ul><li><p>在浏览器控制台中</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1563360135726.png" alt="1563360135726"></p></li><li><p>使用VS自带终端</p><p>我们可以用vs自带终端，如果已经安装好 <em>node.js</em> 便可以直接在VS中输出：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1563360509909.png" alt="1563360509909"></p><p>其实，这就实现相当于在 <em>cmd</em> 中执行这段代码。</p></li><li><p>利用 <em>CodeRunner</em> 插件</p><p>下载好 <em>CodeRunner</em> 插件，也可以直接运行 <em>js</em> 文件：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1563360768328.png" alt="1563360768328"></p></li></ul><h4 id="CodeRunner-运行乱码-报错"><em>CodeRunner</em> 运行乱码/报错</h4><ol><li><em>Node.js</em> 是否安装</li></ol><p><em>CodeRunner</em>  还是通过  <em>Node.js</em> 来运行 <em>js</em> 文件，如果没有安装自然出错。</p><p>特别的，安装 <em>Node.js</em> 会自动配置好环境变量，所以基本可以排除环境变量配置错误导致该问题。</p><ol start="2"><li><p>终端是否能输出</p><p>首先在 <em>cmd</em> 尝试运行 <em>js</em>文件 ，如果能正确输出 ；但是在 <em>VS</em>终端中还是运行报错/乱码。可以排除是<em>Node.js</em> 相关配置问题。</p><p>如果<em>cmd</em> 中也无法运行，尝试重新配置 <em>node.js</em> 环境变量或者直接卸载重新安装。</p></li><li><p>尝试以管理员身份运行<em>VSCoder</em></p><blockquote><p>我出现的乱码/无法执行问题以管理员身份运行成功解决。</p></blockquote><p><strong>1、2</strong> 均无问题， 可以尝试以管理员身份运行 <em>VSCoder</em> 。也可以设置每次打开都是以管理员身份：</p><p>右键 <em>VSCoder</em> 图标 —&gt; 属性 --&gt; 兼容性 —&gt; 以管理员身份运行此程序 --&gt; 应用。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1563361391550.png" alt="1563361391550"></p></li></ol><h2 id="1-3-基本语法">1.3 基本语法</h2><h3 id="1-变量和注释">1. 变量和注释</h3><p><em>javsScript</em> 注释有单行注释 &amp; 多行注释两种方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alert(&quot;我不想被执行&quot;);   </span></span><br><span class="line"><span class="comment">/* alert(&quot;我不想被执行&quot;); */</span> </span><br></pre></td></tr></table></figure><p><em>javsScript</em> 是弱类型语言，所有变量都可用 <code>var &lt;变量名&gt;</code> 形式定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.javsScript不区分整数和浮点型，统称Number</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">3.5</span>; <span class="keyword">var</span> num1 = <span class="number">3</span>; <span class="keyword">var</span> num2 = <span class="number">1.234</span>*e3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.字符串</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;我是单引号包围字符串&#x27;</span>; <span class="keyword">var</span> str1 = <span class="string">&#x27;&#x27;</span>我是双引号包围字符串<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.布尔类型</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.比较运算符</span></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="literal">false</span> == <span class="number">0</span>;  <span class="keyword">var</span> b2 = <span class="literal">false</span> === <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> b3 = <span class="number">2</span> &gt; <span class="number">4</span>? ; <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.常量</span></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;  <span class="comment">// const&amp;let修饰都是块级作用域（见后）</span></span><br></pre></td></tr></table></figure><h4 id="小心！-、NaN、浮点数">小心！== 、NaN、浮点数</h4><ul><li><p>不推荐<code>==</code>比较运算符</p><p>不推荐使用 <code>==</code> 运算符，这是 <em>JavaScript</em> 语言设计缺陷，会出现难以意料的错误，推荐使用 <code>===</code>来替换。</p></li><li><p>判断浮点数相等</p><p>由于计算机不能精确表示浮点数，所以判断两个浮点数是否相等，比较它们差值是否小于某个足够小值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs(<span class="number">1</span> / <span class="number">3</span> - (<span class="number">1</span> - <span class="number">2</span> / <span class="number">3</span>)) &lt; <span class="number">0.0000001</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>判断是否<em>NaN</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="literal">NaN</span>;</span><br><span class="line">alert(num === <span class="literal">NaN</span>); <span class="comment">// 输出false</span></span><br></pre></td></tr></table></figure><p>为什么输出 <em>false</em> ？这是因为 <em>NaN</em>和所有其它值都判断不相等，包括它自己，唯一判断方法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN); // true</span><br></pre></td></tr></table></figure></li><li><p>判断 <em>null</em> ： <code>变量 === null；</code></p></li><li><p>判断 <em>Array</em>：<code>Array.isArray(arr);</code></p></li><li><p><em>typeof</em> 可以判断出 <em>Number、Boolean、String、function &amp; undefined</em> 类型，例如：</p><ul><li>判断全局变量是否存在：<code>typeof window.myVar === 'undefined'</code></li><li>判断局部变量是否存在：<code>typeof myVar === 'undefined'</code> 。</li></ul></li></ul><h4 id="全局变量">全局变量</h4><p>我们知道，常规定义全局变量，把变量不定义在任何嵌套{}中即可。</p><p>事实上，变量定义可<u>不用 <em>var</em> 关键字</u>，此时定义的也是全局变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">3.5</span>; </span><br><span class="line">str = <span class="string">&#x27;我是字符串&#x27;</span>; </span><br><span class="line">b = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;num = &#x27;</span>+num + <span class="string">&#x27; , str = &#x27;</span>+ str + <span class="string">&#x27;, b = &#x27;</span>+b);</span><br></pre></td></tr></table></figure><p>如何理解此时定义的是全局变量？请看下例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不用var关键字声明函数内部变量</span></span><br><span class="line">    a = <span class="number">1</span> ;   </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; <span class="number">3</span> ; i++);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 可访问，输出：1</span></span><br><span class="line"><span class="built_in">console</span>.log(i);   <span class="comment">// 可访问，输出：3</span></span><br></pre></td></tr></table></figure><p><em>a、i</em> 看似是函数内部局部变量，实际已是全局变量，可以访问。</p><h4 id="类型转换">类型转换</h4><p>由于 <em>JavaScript</em> 没有那么复杂类型，比如数值类型之间转换（<em>int --&gt; double</em> …）。</p><p>常用的有如 <em>Number 、 String 、Boolean、object</em>类型之间转换 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型转换</span></span><br><span class="line"><span class="comment">// 1.任何类型转换为String类型： String()转换 OR .toString</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">123.45</span> , b = <span class="literal">true</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toString()</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString());   <span class="comment">// 输出：123.45</span></span><br><span class="line"><span class="built_in">console</span>.log(b.toString());     <span class="comment">// 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(num));      <span class="comment">// 输出：123.45</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(b));        <span class="comment">// 输出：true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.任意类型转换成Number类型：用Number() OR parseInt()、parseFloat()</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;123.45&#x27;</span> , b = <span class="literal">true</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Number()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(str));   <span class="comment">// 输出：123.45</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(b));     <span class="comment">// 输出：1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parseInt()、parseFloat()</span></span><br><span class="line"><span class="comment">// 转换不了boolean类型！</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(str)); <span class="comment">// 输出：123.45</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(b));   <span class="comment">// 输出：NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.任意类型转换为Boolean类型：用Boolean()</span></span><br><span class="line"><span class="comment">// 注意：只有 0、&#x27;&#x27;转换为：false ；其余全部转换为ture</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下都转换为ture</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27;false&#x27;</span>));    <span class="comment">// 也是ture！只有数字0、&#x27;&#x27;会转换为false！！</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27;123.45&#x27;</span>)); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">123.45</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下都转换为false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27;&#x27;</span>));   </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>)); </span><br></pre></td></tr></table></figure><blockquote><p>特别的，具体的值也可以调用 <em>.toString()</em> 方法，转换为 <em>Sting</em> 类型。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 注意1.toString()出错，两个.. OR (1).toString()</span></span><br><span class="line"><span class="number">1.</span>.toString();      <span class="comment">// 1</span></span><br><span class="line"><span class="literal">false</span>.toString();   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="2-字符串">2. 字符串</h3><h4 id="如何优雅表示字符串">如何优雅表示字符串</h4><p>除了前面介绍用 <code>’ ‘</code> 或者 <code>“ ”</code> 包围，还可以用最新ES6标准，反引号 <strong>``</strong> 包围多行字符串。</p><p>:warning: 反引号是左上角 <kbd>ESC</kbd> 正下方对应键 <kbd>~</kbd> ，切换到英文状态下可以打出**`**</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">`我是</span></span><br><span class="line"><span class="string">多行字符串</span></span><br><span class="line"><span class="string">酷不酷`</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">`我是\n多行字符串\n酷不酷`</span>) <span class="comment">// 和上面写法等价</span></span><br></pre></td></tr></table></figure><h4 id="字符串拼接">字符串拼接</h4><p>除了常见用 <code>+</code> 号进行拼接，还可以用ES6新增的模板字符串进行拼接。</p><p>:warning: 模板字符一定要使用反引号 <strong>`</strong> ，否则${…}当字符串输出了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;hwh&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// var message = &#x27;我是&#x27;+ name + &#x27;,今年&#x27;+ age+&#x27;岁啦！&#x27;;</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`我是<span class="subst">$&#123;name&#125;</span>,今年<span class="subst">$&#123;age&#125;</span>岁啦！`</span>; <span class="comment">// 一定要使用反引号 `,否则$&#123;..&#125;当字符串输出</span></span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure><h4 id="常用字符串操作">常用字符串操作</h4><ul><li><p>获取字符串指定位置字符</p><p>直接把字符串当做数组进行索引即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">alert(s[<span class="number">0</span>]);  <span class="comment">// 输出：h</span></span><br></pre></td></tr></table></figure><p>但是字符串是不可变的，不能对其某个字符索引赋值，不会有任何效果（但不报错）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">alert(s); <span class="comment">// 还是输出：hello world</span></span><br></pre></td></tr></table></figure></li><li><p>常用字符串方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.转换字符串大小写</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> upper = s.toUpperCase(); <span class="comment">// 返回&#x27;HELLO&#x27;</span></span><br><span class="line"><span class="keyword">var</span> lower = s.toLowerCase(); <span class="comment">// 返回&#x27;hello&#x27;并赋值给变量lower</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.返回字符在字符串中位置</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;hello javaScript!&quot;</span>;</span><br><span class="line">alert(str.indexOf(<span class="string">&#x27;java&#x27;</span>)); <span class="comment">// 输出6：j是第6个字符，从0计数。前面有6字符： hello + 空格 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.字符串截取</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">s.substring(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 从索引0开始到5（不包括5），返回&#x27;hello&#x27;</span></span><br><span class="line">s.substring(<span class="number">7</span>); <span class="comment">// 从索引7开始到结束，返回&#x27;world&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-数组">3. 数组</h3><p>定义一个简单数组，通常有 <u>直接定义</u> &amp; <em><u>new</u></em> 两种方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = [];  </span><br><span class="line"><span class="comment">// var s = new Array();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="comment">// var s1 = new Array(1,2);</span></span><br></pre></td></tr></table></figure><h4 id="奇妙数组">奇妙数组</h4><p><em>JavaScript</em> 和其它语言数组有很多不同，这里一一说道。</p><ol><li><p>数组不限制类型</p><p>下面是一个长度 = 6，包含多种类型的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="literal">null</span>, <span class="literal">true</span>]; </span><br></pre></td></tr></table></figure></li><li><p>改变数组大小很简单</p><p>以往语言要扩展数组总是一件复杂的事，比如 <em>java</em> 用集合 <em>ArrayList</em> 来实现。</p><p><em>JavaScript</em> 直接改变数组 <em>length</em> 属性即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 扩大数组</span></span><br><span class="line">arr.length = <span class="number">6</span>; <span class="comment">// arr数组变为：[1, 2, 3, undefined, undefined, undefined]</span></span><br><span class="line"><span class="comment">// 缩小数组</span></span><br><span class="line">arr.length = <span class="number">1</span>; <span class="comment">// arr数组变为：[1]</span></span><br></pre></td></tr></table></figure></li><li><p>可以越界赋值</p><p>很多编程语言是不允许越界赋值数组，但<em>JavaScript</em> 允许，它会自动扩大数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">6</span>] = <span class="number">6</span>; <span class="comment">// arr数组变为：[1, 2, 3, undefined, undefined, 6]</span></span><br></pre></td></tr></table></figure><p>但是，这种做法不被推荐，尽量保证索引不会越界！</p></li></ol><h4 id="常用数组操作">常用数组操作</h4><p>以下是常用数组操作的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.数组转为字符串</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="built_in">String</span>(arr);</span><br><span class="line"><span class="built_in">console</span>.log(str);  <span class="comment">// 输出：1,2,3,4,5,6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.indexOf：返回指定元素位置</span></span><br><span class="line"><span class="keyword">var</span> i = arr.indexOf(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(i);   <span class="comment">// 输出：0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.slice：左开右闭截取元素, 对应String的substring()方法</span></span><br><span class="line"><span class="comment">// 不指定第二个参数，会截取第一个参数位置以后所有元素</span></span><br><span class="line"><span class="keyword">var</span> sub03 = arr.slice(<span class="number">0</span>,<span class="number">3</span>) </span><br><span class="line"><span class="keyword">var</span> sub3 = arr.slice(<span class="number">0</span>)    </span><br><span class="line"><span class="built_in">console</span>.log(sub03);  <span class="comment">// 输出：[ 1, 2, 3 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(sub3);   <span class="comment">// 输出：[ 1, 2, 3, 4, 5, 6 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.push 和 pop 尾部增减元素</span></span><br><span class="line">arr.push(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;js&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">// 输出：[ 1, 2, 3, 4, 5, 6, &#x27;hello&#x27;, &#x27;js&#x27; ]</span></span><br><span class="line">arr.pop() ; arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">// 输出：[ 1, 2, 3, 4, 5, 6 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.unshift 和 shift 头部增减元素</span></span><br><span class="line">arr.unshift(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);    <span class="comment">// 输出：[ &#x27;A&#x27;, &#x27;B&#x27;, 1, 2, 3, 4, 5, 6 ]</span></span><br><span class="line">arr.shift(); arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(arr);    <span class="comment">// 输出：[ 1, 2, 3, 4, 5, 6 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.反转和排序</span></span><br><span class="line">arr.reverse();  </span><br><span class="line"><span class="built_in">console</span>.log(arr);    <span class="comment">// 输出：[ 6, 5, 4, 3, 2, 1 ]</span></span><br><span class="line">arr.sort();       </span><br><span class="line"><span class="built_in">console</span>.log(arr);    <span class="comment">// 输出：[ 1, 2, 3, 4, 5, 6 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.splice：从指定位置删除若干元素，再从该位置添加若干元素</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;c#&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;c++&quot;</span>,<span class="string">&quot;python&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;javascript&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除&amp;添加：从索引1开始删除2个元素，然后再从原索引位置添加两个元素</span></span><br><span class="line"><span class="keyword">var</span> delElem = arr.splice(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>); <span class="comment">// 返回被删除的元素:[&quot;c&quot;,&quot;c++&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);    <span class="comment">// 输出：[ &#x27;c#&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;python&#x27;, &#x27;java&#x27;, &#x27;javascript&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只删除：不设定2个参数以上就行</span></span><br><span class="line"><span class="keyword">var</span> delElem1 = arr.splice(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);    <span class="comment">// 输出：[ &#x27;c#&#x27;, &#x27;python&#x27;, &#x27;java&#x27;, &#x27;javascript&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只添加：设置第二个参数为0，即删除0个元素</span></span><br><span class="line"><span class="keyword">var</span> delElem2 = arr.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;c++&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">// 输出：[ &#x27;c#&#x27;, &#x27;c&#x27;, &#x27;c++&#x27;, &#x27;python&#x27;, &#x27;java&#x27;, &#x27;javascript&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.concat：连接两个数组,但不改变原数组，只是返回一个新数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1.concat(<span class="string">&quot;hwh&quot;</span>,[<span class="string">&quot;上&quot;</span>,<span class="string">&quot;山&quot;</span>,<span class="string">&quot;打&quot;</span>,<span class="string">&quot;老&quot;</span>,<span class="string">&quot;虎&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arr2);  <span class="comment">// 输出：[ 1, 2, 3, 4, 5, &#x27;hwh&#x27;, &#x27;上&#x27;, &#x27;山&#x27;, &#x27;打&#x27;, &#x27;老&#x27;, &#x27;虎&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.join：将数组转为字符串，可指定连接字符</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr1.join(<span class="string">&#x27;~&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr3);  <span class="comment">// 输出：1~2~3~4~5</span></span><br></pre></td></tr></table></figure><h4 id="多维数组">多维数组</h4><p>多维数组：如果某个元素是多维数组，那么就可以形成多维数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多维数组</span></span><br><span class="line"><span class="keyword">var</span> darr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">400</span>, <span class="number">500</span>, <span class="number">600</span>], <span class="string">&#x27;-&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(darr[<span class="number">1</span>][<span class="number">1</span>]); <span class="comment">// 输出：500</span></span><br></pre></td></tr></table></figure><h3 id="4-对象">4. 对象</h3><blockquote><p>注意：在 <em>JavaScript</em> 中没有类这个概率，通过原型链来实现类作为模板概念，在后详述。下面都是具体对象！</p></blockquote><p>例如下面创建一个<em>hwh</em>对象，类似于 <em>python</em> 使用键值对定义 <em>map</em> 。</p><p>当然，还可以给对象增添方法（注意，此时不叫函数！），<u><em>详见 第二章：函数  2.3节</em></u></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;huangwanghui&quot;</span>,</span><br><span class="line">    <span class="attr">school</span>:<span class="string">&quot;chongqingU&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;stu-num&#x27;</span>: <span class="number">123456</span>    <span class="comment">// 注意：最后一行代码不要加逗号，否则在低版本IE可能会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问对象属性">访问对象属性</h4><p>访问对象属性有两种办法：</p><ol><li><p>通过<code>&lt;对象名.属性名&gt;</code> 形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(hwh.name);     <span class="comment">// 输出：huangwanghui</span></span><br><span class="line"><span class="built_in">console</span>.log(hwh.school);   <span class="comment">// 输出：chongqingU</span></span><br></pre></td></tr></table></figure><p>特别的，访问不存在属性不会报错，但是会返回 <em><u>undefined</u></em> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(hwh.school);       <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure></li><li><p>通过<code>&lt;对象名['属性名']&gt;</code> 形式</p><p>理论上，所有访问对象属性都可通过该方式，特别以下两种情况只能使用<code>&lt;对象名['属性名']&gt;</code>这种方式。</p><ul><li><p>属性名不是标准变量名</p><p>如 <em><u>‘stu-num’</u></em> 含变量定义非法字符 <code>-</code> ，所以要用 <code>’‘</code> 包围，只能通过 <code>&lt;对象名['属性名']&gt;</code> 访问该属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(hwh.stu-num);     <span class="comment">// 输出：NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(hwh[<span class="string">&#x27;stu-num&#x27;</span>]);  <span class="comment">// 输出：123456</span></span><br></pre></td></tr></table></figure></li><li><p>循环遍历属性时</p><blockquote><p>在下面遍历对象属性，为什么都是输出 <em>undefined</em>？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历属性</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> a <span class="keyword">in</span> hwh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);       <span class="comment">// 输出：name  shcool   &#x27;stu-num&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(hwh.a);   <span class="comment">// 输出：undefined undefined undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为，此时 hwh.a 相当于访问的是hwh对象一个属性名为a的属性，这自然是不存在的。</p><p>正确做法使用<code>对象名['属性名']</code>便可正常输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> a <span class="keyword">in</span> hwh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(hwh[a]);  <span class="comment">// 输出：huangwanghui chongqingU 123456</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="给对象增删属性">给对象增删属性</h4><p>给对象增减属性较为简单，增加属性类似于数组增加元素，删除属性要利用 <em>delete</em> 关键字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增删属性</span></span><br><span class="line">hwh.age = <span class="number">23</span>;</span><br><span class="line"><span class="built_in">console</span>.log(hwh.age);  <span class="comment">// 输出：23</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> hwh.age;</span><br><span class="line"><span class="built_in">console</span>.log(hwh.age);  <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure><h4 id="判断对象是否拥有某属性">判断对象是否拥有某属性</h4><p>判断对象是否用于某属性也有两种办法。</p><ul><li><p>利用 <em>in</em> 判断一个属性是否存在</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> hwh);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;age&#x27;</span> <span class="keyword">in</span> hwh);</span><br></pre></td></tr></table></figure><p>但是这种方法有一个问题，<em>in</em> 判断属性不一定属于 <em>hwh</em>，还可能是 <em>hwh</em> 继承得到的。</p><p>比如原型链中，<em>hwh</em> 肯定会指向所有属性都指向的 <em>Object</em>， <em>Object</em> 含有一个<em>toString</em> 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> hwh); <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure></li><li><p>利用<code>hasOwnProperty()</code>方法</p><p>这种方法可以不会判断继承得到的属性属于对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> hwh); <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-条件判断-循环">5. 条件判断 &amp; 循环</h3><h4 id="条件判断">条件判断</h4><p><em>JavaScript</em> 把<em>null、undefined、0、NaN</em>  &amp; 空字符串<code>''</code>视为<code>false</code>，其他值一概视为<code>true</code>，因此下面代码条件判断的结果是<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (s.length) <span class="comment">// 条件计算结果为3</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环">循环</h4><p>在 <em>JavaScript</em> 循环和 <em>java</em> 等高级语言循环没有太大区别。</p><p>特别的，在 <em>JavaScript</em> 中数组也被看作是对象，它的索引则被视为一个属性。然而遍历数组时，如果使用 <em>for…in</em>循环时，如给数组增加一个属性，将导致一个难以意料的结果。</p><p>这个问题可以用 <em>for…of</em> 循环解决，它还可以专用于遍历集合类型，详见 <u>7. <em>iterable</em> 类型</u> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&quot;上山打老虎&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.普通for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; num.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num[i]);  <span class="comment">// 输出： 1 2 3 4 5 上山打老虎</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.for..in 循环</span></span><br><span class="line"><span class="comment">// 除了前面用来遍历对象属性，遍历数组也类似</span></span><br><span class="line"><span class="comment">// for..in 循环的到时 String 而不是 Number，for循环呢？</span></span><br><span class="line"><span class="comment">// 直接输出i是数组序号：0 1 2 3 4 5  ，可理解为把数组当对象，序号是它“属性名”</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);     <span class="comment">// 输出： 0 1 2 3 4 5 </span></span><br><span class="line">    <span class="built_in">console</span>.log(num[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.while 循环</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num[i]);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.do...while 循环</span></span><br><span class="line"><span class="comment">// 注意：do...while 循环至少会执行一次！</span></span><br><span class="line"><span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num[j]);</span><br><span class="line">    j++;</span><br><span class="line">&#125;<span class="keyword">while</span>(j&lt;<span class="number">6</span>);</span><br></pre></td></tr></table></figure><h3 id="6-Map-Set">6. <em>Map &amp; Set</em></h3><p>在前面 <em>JavaScript</em> 中 <u>4.对象</u>  中<code>&#123;&#125;</code> 表达方式可以视作其它语言 <em>Map</em> 或 <em>Dictionary</em> 数据结构键值对表达方式。</p><p>BUT，<em>JavaScript</em> 中 <u>对象中键只能是字符串</u> ，而在本讲 <em>Map &amp; Set</em> 将不局限于这点，还可以是 <em>Number</em>等类型。</p><h4 id="MAP"><em>MAP</em></h4><p><em>MAP</em> 基本创建、增 == 改、删操作，和：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="comment">// 1.创建：注意是([[..],[..],[..]])形式外侧还有一个[]</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>,<span class="string">&quot;hwh&quot;</span>],[<span class="number">2</span>,<span class="string">&#x27;liuting&#x27;</span>],[<span class="number">3</span>,<span class="string">&#x27;xiaoming&#x27;</span>]]); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.增加(修改)键值对</span></span><br><span class="line">m.set(<span class="number">4</span>,<span class="string">&#x27;xiaobai&#x27;</span>);   <span class="comment">// 不存在该键4，则是创建新键值对</span></span><br><span class="line">m.set(<span class="number">4</span>,<span class="string">&#x27;xiaohei&#x27;</span>);   <span class="comment">// 存在键值4，那么是修改键4对应键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.删除键值对</span></span><br><span class="line">m.delete(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.判断是否存在键值</span></span><br><span class="line"><span class="keyword">var</span> b = m.has(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);      <span class="comment">// 由于被删除所以是：false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.获取键值对</span></span><br><span class="line"><span class="keyword">var</span> a = m.get(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);     <span class="comment">// 输出：liuting</span></span><br></pre></td></tr></table></figure><p>注意，当<em>map</em> 键是<em>String</em> 类型一定要加<u>引号</u>（对象如果变量名符合规范可以不加），而且访问也要加引号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>],[<span class="string">&quot;b&quot;</span>,<span class="number">2</span>]]);  </span><br><span class="line"><span class="comment">// m.get(a); // 出错</span></span><br><span class="line">m.get(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p><em>MAP</em> 和对象有什么区别？</p></blockquote><p><em>MAP</em> 和对象都是利用 <u>键值对</u> 形式构造，但是也有以下区别：</p><ol><li>删除、添加元素方式不同</li><li>访问形式不同：MAP通过<em>get()</em> 方法，对象通过 <u>对象.属性名</u> 或者 <u>对象[属性名]</u>形式</li><li>访问速度不同：MAP 拥有极快的访问速度</li><li>支持key类型不同：MAP支持多种类型作为key，对象只支持字符串<em>String</em> 类型</li></ol><h4 id="Set"><em>Set</em></h4><p><code>Set</code>和<code>Map</code>类似，也是一组key的集合，但不存储<em>value</em>。</p><p>由于<em>key</em>不能重复，所以，在<code>Set</code>中，没有重复的key。如，创建时出现重复<em>key</em>，只会保留一个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="comment">// 1.创建：出现重复键值被过滤</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]);  <span class="comment">// 实际集合中数据：&#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="comment">// 类似的：map也只会保存最后插入的重复键值</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>],[<span class="string">&#x27;a&#x27;</span>,<span class="number">2</span>],[<span class="string">&quot;b&quot;</span>,<span class="number">2</span>]]);  <span class="comment">// 实际集合中数据：&#123;[&#x27;a&#x27;,2],[&quot;b&quot;,2]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.增加</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.删除</span></span><br><span class="line">s.delete(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><blockquote><p><em>Set</em> 和数组 <em>Array</em> 区别？</p></blockquote><ol><li>删除、添加元素方法不同</li><li><em>Set</em> 可以去重，而且可以 <u>快速查找</u> ，但无法实现按下标查找等操作</li></ol><h3 id="7-如何优雅遍历集合">7. 如何优雅遍历集合</h3><h4 id="for-…-in-遍历集合"><em>for … in</em> 遍历集合</h4><blockquote><p>遍历数组 <em>Array</em> 可以用下标循环，如何遍历集合类型如 <em>Map &amp; Set</em> 类型？能用 <em>for … in</em> 循环吗？</p></blockquote><p>我们尝试用 <em>for…in</em> 循环遍历集合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>,<span class="string">&quot;hwh&quot;</span>],[<span class="number">2</span>,<span class="string">&#x27;liuting&#x27;</span>],[<span class="number">3</span>,<span class="string">&#x27;xiaoming&#x27;</span>]]); </span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); </span><br><span class="line"></span><br><span class="line"><span class="comment">// for...in 遍历集合</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);  <span class="comment">// 什么都没输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很不幸，什么都没输出。</p><p>事实上，<u><em>Array、Map &amp; Set</em> 都属于<em>iterable</em> 类型</u>。对于 <em>iterable</em> 类型可以用 <em>for…of</em> 循环输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for...of 遍历集合</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);  <span class="comment">// 输出：[ 1, &#x27;hwh&#x27; ]   [ 2, &#x27;liuting&#x27; ]  [ 3, &#x27;xiaoming&#x27; ]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);  <span class="comment">// 输出：1  2  3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forEach-遍历集合"><em>forEach()</em> 遍历集合</h4><p>遍历集合更加优雅安全的方式是通过 <em>iterable</em>内置的<em>forEach()</em> 方法，<u>它接受一个函数，每次迭代自动回调该函数</u>。</p><blockquote><p><em>forEach()</em> 是一个高级方法，接收一个函数，用来遍历数组。详见 <u>2.4 高阶函数 – <em>forEach(</em>)</u></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach() 遍历集合</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>,<span class="string">&quot;hwh&quot;</span>],[<span class="number">2</span>,<span class="string">&#x27;liuting&#x27;</span>],[<span class="number">3</span>,<span class="string">&#x27;xiaoming&#x27;</span>]]); </span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历Map</span></span><br><span class="line">m.forEach</span><br><span class="line">(</span><br><span class="line">   <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);    <span class="comment">// 输出：hwh   liuting   xiaoming</span></span><br><span class="line">   &#125;</span><br><span class="line">); </span><br><span class="line"><span class="comment">// 遍历Set</span></span><br><span class="line">s.forEach</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(element);    <span class="comment">// 输出：1   2   3</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 遍历Array</span></span><br><span class="line">arr.forEach</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(element);    <span class="comment">// 输出：A   B   C</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历对象：注意不能遍历对象！！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="for-…-in-循环的弊端：数组长度不一致"><em>for … in</em> 循环的弊端：数组长度不一致</h4><p>我们已经知道 ，<em>Array</em> 都属于<em>iterable</em> 类型 ，但我们用 <em>for … in</em> 可以遍历输出<em>Array</em> 。</p><p>但是，我们在前也知道，数组也是对象，它的下标就是属性名。如果我们给一个数组增加属性名，然后遍历：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="comment">// 类似对象一般，给数组增加属性</span></span><br><span class="line">arr.name = <span class="string">&#x27;alpha&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);     <span class="comment">// 输出属性名：0  1  2  name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次输出的是数组的属性名，好吧，这没什么不正常。</p><p>但是我们再尝试打印此时的数组大小：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.length);  <span class="comment">// 输出：3</span></span><br></pre></td></tr></table></figure><p>噢…不忍直视，数组长度竟然是3，而不是4！</p><blockquote><p>为什么说<em>for… of</em> 循环可以避免这个问题呢？</p></blockquote><p>因为<em>for… of</em>  循环只会遍历，集合内的元素，这种不正当通过 <code>数组名.属性 </code> 赋值方式不会被输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> arr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);       <span class="comment">// 输出元素而非属性名：A  B  C  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);  <span class="comment">// 输出：3</span></span><br></pre></td></tr></table></figure><p>这样循环遍历数组元素个数 === 数组长度，保证了一致性。</p><p>而且，你应该还注意到一个细节，此时<u>输出的是元素，而非是属性名</u>。</p><h1>第二章 ：函数</h1><h2 id="2-1-函数基本入门">2.1 函数基本入门</h2><h3 id="函数定义">函数定义</h3><p>在 <em>JavaScript</em> 中，定义函数有两种方式：一种类似于其它高级语言，但没有返回值类型；一种匿名函数方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="comment">// 1.第一种类似其它高级语言定义函数，但没有返回值类型，js也不需要定义类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.第二种匿名函数，其实函数也是对象，把函数名max1视作指向该函数的变量</span></span><br><span class="line"><span class="keyword">var</span> max1 = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <em>JavaScript</em> 中，这两种方式是完全等价的，自然调用方式也是一致的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="built_in">console</span>.log(max(<span class="number">1</span>,<span class="number">2</span>));   <span class="comment">// 输出：2</span></span><br><span class="line"><span class="built_in">console</span>.log(max1(<span class="number">1</span>,<span class="number">2</span>));  <span class="comment">// 输出：2</span></span><br></pre></td></tr></table></figure><p>:warning: 不加()，直接调用函数不会报错，只会输出函数名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(max);       <span class="comment">// [Function: max]</span></span><br></pre></td></tr></table></figure><p>但是可以把函数作为变量传递给另外一个变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> my_max = max;</span><br><span class="line">my_max(<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="小心你的-return-语句">小心你的 <em>return</em> 语句</h4><p><em>JavaScript</em> 引擎 <u>会在行末自动添加分号</u>，这可能会导致使用 <em>return</em> 产生意料之外的错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">    a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用max</span></span><br><span class="line">max(<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">// 输出：什么都没有输出</span></span><br></pre></td></tr></table></figure><p>你会惊喜的发现，什么都没有输出！这是因为，由于自动添加分号，函数实际已经变成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  ;  <span class="comment">// 这里被添加了分号，函数执行到这结束了</span></span><br><span class="line">    a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，细心的你一定会避过这个坑吧？</p><h3 id="奇妙的函数参数">奇妙的函数参数</h3><h4 id="传递参数个数任意？">传递参数个数任意？</h4><p>如果是第一次接触 <em>JavaScript</em> ，在上面定义<em>max</em> 函数我们可以惊讶的发现，可以传递不止两个参数！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多个参数调用</span></span><br><span class="line"><span class="built_in">console</span>.log(max(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>));   <span class="comment">// 输出：2</span></span><br></pre></td></tr></table></figure><p>而且它还计算出了正确结果！</p><p>事实上，<em>JavaScript</em> 允许传递任意个参数，如果函数内部不使用多余的参数自然也就不会影响到结果。</p><blockquote><p>那么传递参数比实际定义少呢？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(max(<span class="number">1</span>));            <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure><h4 id="怎么处理所有参数？">怎么处理所有参数？</h4><blockquote><p>在上面虽然我们调用 <em>max()</em> 函数输入了多余参数，但是我还是想把多余参数给输出来，该如何处理？</p></blockquote><p>在函数内部利用 <em>arguments</em> ，可以获取所有参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) <span class="comment">// 输出超过定义个数的参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2</span> ; i &lt; <span class="built_in">arguments</span>.length ; i++ )</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用max</span></span><br><span class="line">max(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;hhh不许笑！&quot;</span>);    <span class="comment">// 输出：hhh不许笑！</span></span><br></pre></td></tr></table></figure><p>一般常用的也就是：<em>arguments.length</em>  &amp; <em>arguments[i]</em>  用来获取参数长度和指定索引参数。</p><h4 id="优雅的处理多余参数">优雅的处理多余参数</h4><p>上面虽然用<em>arguments</em> 获取到所有参数，然后输出多余参数，但是总感觉很变扭。</p><blockquote><p>但是有没有一种方式，让我们直接处理多余参数 ，而不是要从索引 <strong>2</strong> 先排除前两个参数？</p></blockquote><p>可以使用 <em>rest</em> 来达到这个目的，<u>多余参数会以数组形式</u> 交给 <em>rest</em> 变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rest</span></span><br><span class="line"><span class="comment">// 函数定义的时候要以：...rest来标识[从哪里开始算是多余参数]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">a,b,...rest</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rest);  <span class="comment">// 会以[数组]形式输出</span></span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用max</span></span><br><span class="line">max(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;hhh不许笑！&quot;</span>);    <span class="comment">// 输出：[ &#x27;hhh不许笑！&#x27; ]</span></span><br></pre></td></tr></table></figure><h2 id="2-2-变量作用域与解构赋值">2.2 变量作用域与解构赋值</h2><h3 id="1-快速了解变量作用域">1. 快速了解变量作用域</h3><p>变量作用域块{}知识基本和其它语言没有太大区别，但是有几个 <em>JavaScript</em> 所特有特性。</p><h4 id="变量提升">变量提升</h4><blockquote><p>执行下面函数会报错吗？如果不会，那么输出什么？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>; </span><br><span class="line">    <span class="built_in">console</span>.log( x + y);  </span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>执行这段代码，我们发现：编译器没有报错，但是输出 <em>NaN</em> 。</p><p>这是因为<em>javascript</em> 有一个很奇怪的特性：它会自动提升 <u>变量的声明</u> 到<strong>函数</strong>顶端，但是又不会提升 <u>变量的赋值</u>。</p><p>在编译器眼里，它看到的代码是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">var</span> y ; <span class="comment">// 提升了定义</span></span><br><span class="line">    <span class="built_in">console</span>.log( x + y);  <span class="comment">// 执行后也并没有报错    </span></span><br><span class="line">    y = <span class="number">2</span>;  <span class="comment">// 没有提升赋值</span></span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>所以虽然可以使用变量 <em>y</em> 但是又不能使用它的值，所以输出：<em>NaN</em> 。</p><h4 id="避免错误">避免错误</h4><blockquote><p>:yum: 对于这种怪异特性，我们最好提前用 <em>var</em> 声明所有要使用的变量。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>,</span><br><span class="line">        y = <span class="number">2</span>,</span><br><span class="line">        z;</span><br><span class="line">   <span class="comment">// do something  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>:yum: 用 <em>let</em> 关键字来限定变量范围，申明一个块级作用域。</p></blockquote><p>由于这种变量提升特性，导致<u>变量实际作用域是函数内部</u>，会使得<em>for</em> 等循环语块无法定义具有局部作用域变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);  <span class="comment">// 不报错可以使用i，但是输出：undefined</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i);  <span class="comment">// 可以使用i值，输出：3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>我们可以通过 <em>let</em> 关键字来达到，限定 <em><strong>i</strong></em> 为局部变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i);   <span class="comment">//  会报错，不能使用局部变量i</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i);  <span class="comment">// 会报错，不能使用局部变量i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure><h3 id="2-全局作用域">2. 全局作用域</h3><p>不在任何函数内定义的变量就具有全局作用域。</p><p>特别的，顶层函数也是全局变量。虽然乍看有点难以理解，但是回想它的匿名函数写法，便一目了然。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"><span class="keyword">var</span> author = <span class="string">&#x27;hwh&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;顶层函数也是全局变量&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量任意嵌套块中都可以调用</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(author);</span><br><span class="line">    <span class="built_in">console</span>.log(f2());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="window-对象"><em>window</em> 对象</h4><p><em>window</em> 是<em>javascript</em>  <u>默认全局对象</u> ，<u>所有全局变量</u> 都被绑定到 <em>window</em> 上作为一个<u>属性</u>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// window</span></span><br><span class="line"><span class="comment">// 调用window对象：console.log 会报错，用alert打开网页可正常输出？</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//  console.log(window.author);  // 出错</span></span><br><span class="line">    alert(<span class="built_in">window</span>.author);        <span class="comment">// 打开网页输出：hwh</span></span><br><span class="line">    alert(<span class="built_in">window</span>.f2());          <span class="comment">// 打开网页输出：顶层函数也是全局变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，全局变量可以作为它的属性一样被调用。事实上 <em>alert()</em> 也是一个全局变量。</p><blockquote><p>下面尝试给 <u>函数变量</u> <em>alert</em> 赋值一个新的函数，使得它不能执行 <em>alert()</em> 原本输出功能。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.alert(<span class="string">&#x27;调用window.alert()&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个变量保存函数（函数也是变量）</span></span><br><span class="line"><span class="keyword">var</span> old_alert = <span class="built_in">window</span>.alert;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给alert赋一个新函数:</span></span><br><span class="line"><span class="built_in">window</span>.alert = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试调用alert()</span></span><br><span class="line">alert(<span class="string">&#x27;我还能输出吗？&#x27;</span>); <span class="comment">// 打开网页发现这句话不会被输出</span></span><br></pre></td></tr></table></figure><h4 id="更好的定义全局变量">更好的定义全局变量</h4><p>全局变量会绑定到对象<em>window</em>上，不同的 <em>JavaScript</em> 文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。</p><p>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唯一的全局变量<span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="keyword">var</span> NOTE = &#123;&#125;;  <span class="comment">// 对象？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他变量:</span></span><br><span class="line">NOTE.author = <span class="string">&#x27;hwh&#x27;</span>;</span><br><span class="line">NOTE.version = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他函数:</span></span><br><span class="line">NOTE.f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-解析构值">3. 解析构值</h3><p>什么是解析构值？简单来说，可以 <u>同时对一组变量进行赋值</u>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析构值</span></span><br><span class="line"><span class="comment">// 注意：解析构值涉及多个变量赋值，两边都要用[]包围</span></span><br><span class="line"><span class="keyword">var</span> x,y,z,rest;</span><br><span class="line">[x,y,z] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];   </span><br></pre></td></tr></table></figure><p>还可以像前一样，用<code>...</code> 标识<em>rest</em> ，以数组形式接收指定位置之后所有赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.解析赋值：...rest</span></span><br><span class="line">[x,y,z,...rest] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(rest);      <span class="comment">// 输出：[ 4, 5]</span></span><br></pre></td></tr></table></figure><h4 id="解构数组">解构数组</h4><p>除了上述基本特点，解构数组还有以下特点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析数组  </span></span><br><span class="line"><span class="keyword">var</span> x,y,z,rest;</span><br></pre></td></tr></table></figure><ol><li><p>允许待赋值变量个数 ≠ 右侧变量数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 允许待赋值变量个数 ≠ 右侧变量数</span></span><br><span class="line"><span class="comment">// 待赋值变量 &gt; 右侧，剩余未赋值变量赋undefined </span></span><br><span class="line">[x,y,z] = [<span class="number">1</span>,<span class="number">2</span>];                       <span class="comment">// 等价于：[x,y,z] = [1,2,undefined];</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;x=&#x27;</span>+x+<span class="string">&#x27;,y=&#x27;</span>+y+<span class="string">&#x27;,z =&#x27;</span>+z);  <span class="comment">// 输出 ：x=1,y=2,z=undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 待赋值变量 &lt; 右侧，只会对应依次将待赋值变量赋值完毕</span></span><br><span class="line">[x,y,z] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];                  <span class="comment">// 等价于：[x,y,z] = [1,2,3]; </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;x=&#x27;</span>+x+<span class="string">&#x27;,y=&#x27;</span>+y+<span class="string">&#x27;,z =&#x27;</span>+z);   <span class="comment">// 输出：x = 1,y = 2,z = 3</span></span><br></pre></td></tr></table></figure></li><li><p>设置默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.可以设置默认值</span></span><br><span class="line">[x,y,z = <span class="number">666</span>] = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;x=&#x27;</span>+x+<span class="string">&#x27;,y=&#x27;</span>+y+<span class="string">&#x27;,z =&#x27;</span>+z);    <span class="comment">// 输出：x=1,y=2,z=666</span></span><br></pre></td></tr></table></figure></li><li><p>忽略某些值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.忽略值</span></span><br><span class="line"><span class="keyword">var</span> a,b;</span><br><span class="line">[a, ,b ] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a = &#x27;</span>+ a + <span class="string">&#x27;,b = &#x27;</span>+ b);     <span class="comment">// 输出：a = 1,b = 3</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="解构对象">解构对象</h4><p>前面都是解构数组，对象由一对对键值组成，和解构数组自然有些不同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象解构赋值</span></span><br><span class="line"><span class="keyword">var</span> o =  &#123;<span class="attr">x</span>:<span class="string">&#x27;one&#x27;</span> , <span class="attr">y</span>:<span class="string">&#x27;two&#x27;</span>,<span class="attr">z</span>:<span class="string">&#x27;three&#x27;</span>,<span class="attr">a</span>:<span class="string">&#x27;four&#x27;</span>,<span class="attr">b</span>:<span class="string">&#x27;five&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;x,y,z,a,b&#125; = o;</span><br></pre></td></tr></table></figure><p>特别的，如果不是对一个已存在对象解构，而是进行无声明赋值，赋值语句有所不同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种无声明赋值，要求赋值语句周围有 (...)</span></span><br><span class="line"><span class="keyword">var</span> x,y,z;</span><br><span class="line">( &#123;x,y,...rest&#125; = &#123;<span class="attr">x</span>:<span class="string">&#x27;one&#x27;</span> , <span class="attr">y</span>:<span class="string">&#x27;two&#x27;</span>,<span class="number">3</span>:<span class="string">&#x27;three&#x27;</span>,<span class="number">4</span>:<span class="string">&#x27;four&#x27;</span>,<span class="number">5</span>:<span class="string">&#x27;five&#x27;</span>&#125; );</span><br><span class="line"><span class="built_in">console</span>.log(x);        <span class="comment">// 输出：one</span></span><br><span class="line"><span class="built_in">console</span>.log(rest);     <span class="comment">// 输出：&#123; &#x27;3&#x27;: &#x27;three&#x27;, &#x27;4&#x27;: &#x27;four&#x27;, &#x27;5&#x27;: &#x27;five&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>对象解构还有以下一些基本特点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o =  &#123;<span class="attr">x</span>:<span class="string">&#x27;one&#x27;</span> , <span class="attr">y</span>:<span class="string">&#x27;two&#x27;</span>,<span class="attr">z</span>:<span class="string">&#x27;three&#x27;</span>,<span class="attr">a</span>:<span class="string">&#x27;four&#x27;</span>,<span class="attr">b</span>:<span class="string">&#x27;five&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><ol><li><p>允许待赋值变量个数 ≠ 右侧变量数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.待赋值变量 &lt; 右侧，按对应键值赋值完毕,[顺序不影响]</span></span><br><span class="line"><span class="keyword">var</span> &#123;x,b,a&#125; = o;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;x=&#x27;</span>+x+<span class="string">&#x27;,y=&#x27;</span>+y+<span class="string">&#x27;,z =&#x27;</span>+z);  <span class="comment">// 输出：x=one ,a=four ,b=five</span></span><br></pre></td></tr></table></figure></li><li><p>左右两侧键值要对应</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.左右两侧键值要对应</span></span><br><span class="line"><span class="keyword">var</span> &#123;x,Y,z,a,b&#125; = o;   <span class="comment">// 左侧Y和右侧键值y，不对应</span></span><br><span class="line"><span class="built_in">console</span>.log(Y);        <span class="comment">// 无法解构成功，输出：undefined</span></span><br></pre></td></tr></table></figure></li><li><p>给新变量提供默认值和参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.给新变量提供默认值和参数</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>:xx = <span class="number">10</span>, <span class="attr">y</span>:yy = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(xx); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(yy); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="解构嵌套对象和数组">解构嵌套对象和数组</h4><p>解构嵌套对象和数组，具有的基本特点和上面是一致的。主要不同在于：</p><p>解构嵌套对象要保证层次一致；解构嵌套数组，不仅要保证层次一致还要保证位置一致。</p><h5 id="嵌套数组">嵌套数组</h5><p>数组本身有嵌套，解构赋值要保证嵌套位置和层次一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.数组嵌套</span></span><br><span class="line"><span class="keyword">let</span> [x,[y,z]] = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> [[y,z],x] = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]];   <span class="comment">// 出错位置不一致</span></span><br></pre></td></tr></table></figure><h5 id="嵌套对象">嵌套对象</h5><p>对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，保证层次一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;hwh&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">address</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&#x27;FUZHOU&#x27;</span>,</span><br><span class="line">        <span class="attr">street</span>: <span class="string">&#x27;No.1 Road&#x27;</span>,</span><br><span class="line">        <span class="attr">zipcode</span>: <span class="string">&#x27;341000&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需保证层次一致：赋值时按键值赋值，顺序位置可以调换</span></span><br><span class="line"><span class="keyword">var</span> &#123;name, <span class="attr">address</span>: &#123;city, zipcode&#125;&#125; = person;</span><br></pre></td></tr></table></figure><p>注意，<em>address</em> 并不是变量名，尝试输出会报错。它只是为了<em>city、zipcode</em>获取对象属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试输出</span></span><br><span class="line"> <span class="built_in">console</span>.log(address); <span class="comment">// 报错，address不是变量</span></span><br><span class="line"> <span class="built_in">console</span>.log(person.address); <span class="comment">// 输出： &#123; city: &#x27;FUZHOU&#x27;, street: &#x27;No.1 Road&#x27;, zipcode: &#x27;341000&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：name:hwh,city:FUZHOU ,zipcode:341000</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;name:&#x27;</span>+name+<span class="string">&#x27;,city:&#x27;</span>+ city,<span class="string">&#x27;,zipcode:&#x27;</span>+ zipcode);</span><br></pre></td></tr></table></figure><h4 id="使用场景">使用场景</h4><ol><li><p>交换两个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.交换变量x y</span></span><br><span class="line"><span class="keyword">var</span> x=<span class="number">1</span>, y=<span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x]</span><br></pre></td></tr></table></figure></li><li><p>快速获取页面域名 &amp; 路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.快速获取页面域名和路径</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">hostname</span>:domain, <span class="attr">pathname</span>:path&#125; = location;</span><br></pre></td></tr></table></figure></li><li><p>减化函数参数定义</p><p>如下面可以方便快速创建一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myDate</span>(<span class="params">&#123;year, mon, day, hour=<span class="number">0</span>, min=<span class="number">0</span>, sec=<span class="number">0</span>&#125;</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(year + <span class="string">&#x27;-&#x27;</span> + month + <span class="string">&#x27;-&#x27;</span> + day + <span class="string">&#x27; &#x27;</span> + hour + <span class="string">&#x27;:&#x27;</span> + minute + <span class="string">&#x27;:&#x27;</span> + second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面函数接收一个对象作为参数，而不是去定义6个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myDate</span>(<span class="params">year,mon,day,hour=<span class="number">0</span>,min=<span class="number">0</span>,sec=<span class="number">0</span></span>) </span></span><br></pre></td></tr></table></figure><p>在调用函数的时候，根据解析构值，<u>形参对象给实参对象赋值</u> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myDate(&#123;<span class="number">2019</span>,<span class="number">07</span>,<span class="number">19</span>&#125;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-3-方法与this大坑">2.3 方法与<em>this</em>大坑</h2><p>在一个对象中绑定函数，称为这个对象的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">        <span class="keyword">return</span> nowYear - <span class="built_in">this</span>.birth;    <span class="comment">// 调用对象里属性，不用this会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hwh.age());   <span class="comment">// 输出：23</span></span><br><span class="line"><span class="built_in">console</span>.log(hwh.age);     <span class="comment">// 输出：[Function: age]</span></span><br></pre></td></tr></table></figure><p>我们知道，<em>this</em> 关键字是用来指向当前对象。在<em>JavaScript</em> 没有类这个概念，<em>this</em> 在上述代码指向的是 <em>hwh</em> 这个对象。<em>this.birth</em> 因此可以拿到 <em>hwh</em> 的 <em>birth</em> 属性。</p><p>在这里，我们也看到 <em>JavaScript</em> 中 <em>this</em> 关键字和常用高级语言第一个不同点：</p><ul><li>即使是在对象内部，调用对象属性也要 <em>this.属性名</em> 进行调用，否则会出错。</li></ul><p>但是，由于<em>js</em>本身设计缺陷，<u><em>this</em> 在函数内部不一定指向当前对象，也可能指向全局对象 <em>window</em></u>  。</p><h3 id="1-小心使用你的-this">1. 小心使用你的 <em>this</em></h3><h4 id="新变量指向方法">新变量指向方法</h4><p>如果你尝试用一个新变量 <em>my_age</em> 指向函数内部方法 <em>age()</em> :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">        <span class="keyword">return</span> nowYear - <span class="built_in">this</span>.birth;    <span class="comment">// 调用对象里属性，不用this会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新变量指向对象方法</span></span><br><span class="line"><span class="keyword">var</span> my_age = hwh.age;</span><br><span class="line"><span class="built_in">console</span>.log(my_age());    <span class="comment">// 输出： NaN</span></span><br></pre></td></tr></table></figure><p>why？？为什么突然报错？</p><p>这是因为，以 <u>对象名.方法名()</u> 调用 <em>this</em> 指向当前对象 ；但是 <u>单独调用函数</u> ，<em>this</em> 指向全局对象 <em>window</em> ！</p><h4 id="多层函数内部用-this">多层函数内部用 <em>this</em></h4><p>喜欢重构的你，又闲得蛋疼，突发奇想，在<em>age</em>方法内部再定义一个函数来返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> nowYear - <span class="built_in">this</span>.birth;    <span class="comment">// 调用对象里属性，不用this会报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAge();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hwh.age());   <span class="comment">// 输出：NaN</span></span><br></pre></td></tr></table></figure><p>又出错了！虽然 <em>this</em> 关键字在 <u>对象<em>age</em>方法内部</u> 指向当前对象，但在 <u><em>age</em>方法内函数内</u> 指向全局对象 <em>window</em> ！</p><p>聪明的你也许会想，既然在 <em>age</em>方法内部还是指向当前对象，那我可以捕获此时<em>this</em> ，再在方法内部函数使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 捕获this</span></span><br><span class="line">        <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> nowYear - <span class="built_in">this</span>.birth;    <span class="comment">// 调用对象里属性，不用this会报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAge();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hwh.age());   <span class="comment">// 输出：23</span></span><br></pre></td></tr></table></figure><blockquote><p>更优雅解决<em>this</em> 错误指向：改写为箭头函数，详见：<em><u>2.6 箭头函数</u></em> 。</p></blockquote><h4 id="提醒不要犯错：strict-模式">提醒不要犯错：<em>strict</em> 模式</h4><p>上述两种情况，还可以在 <em>strict</em> 模式下让函数的<em>this</em> 指向 <em>undefined</em> ，而不是<em>window</em> ，这样编译器会抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面函数写法...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hwh1.age());  <span class="comment">//抛出错误： Cannot read property &#x27;birth&#x27; of undefined</span></span><br></pre></td></tr></table></figure><h3 id="2-apply-方法">2. <em>apply</em> 方法</h3><p>在前面，我们可以用 <em>strict</em> 模式，使得<em>this</em> 指向 <em>undefined</em> 让编译器提醒我们不要让 <em>this</em> 错误指向。</p><p>但是，可以控制 <em>this</em> 正确指向我们所期望的吗？ 每个函数本身拥有的<em>apply()</em> 方法，可以做到这点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> nowYear - <span class="built_in">this</span>.birth;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123; </span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:getAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让getAge() 中this从指向 undefined (严格模式下不是window） --&gt; hwh</span></span><br><span class="line"><span class="comment">// 参数1：表示方法要指向的对象</span></span><br><span class="line"><span class="comment">// 参数2：表示方法需要的参数，用数组封装好。这里[]表示为空</span></span><br><span class="line"></span><br><span class="line">getAge.apply(hwh,[]);    </span><br><span class="line"><span class="built_in">console</span>.log(hwh.age());  <span class="comment">// 输出23</span></span><br></pre></td></tr></table></figure><h4 id="call-方法"><em>call</em> 方法</h4><p><em>call</em> 方法和 <em>apply</em> 方法很类似，能达到相同效果，它们唯一区别是传递参数不同。</p><p>比如，调用 <code>Math.max(3, 5, 4)</code>，分别用 <em>apply()</em> 和 <em>call()</em> 实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>可以看到，<em>apply()</em> 需要把参数封装好 <em>Araay</em> 数组再传入 ； <em>call()</em> 则需逐个传入参数。</p><h4 id="新的问题">新的问题</h4><p>在 <u>新变量指向方法</u> 小节中，我们尝试用 <em>apply</em> 来改变新变量函数指向：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">        <span class="keyword">return</span> nowYear - <span class="built_in">this</span>.birth;    <span class="comment">// 调用对象里属性，不用this会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新变量指向对象方法</span></span><br><span class="line"><span class="keyword">var</span> my_age = hwh.age;</span><br><span class="line">my_age.apply(hwh,[]);    <span class="comment">// 改变this指向不成功？</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(my_age());    <span class="comment">// 输出： NaN</span></span><br></pre></td></tr></table></figure><p>却发现，<em>my_age</em> 方法指向并没有被改变，还是输出 <em>NaN</em> ?</p><blockquote><p>之所以不尝试，<u>多层函数内部用 <em>this</em></u> 一节用<em>apply</em> 改变，是因为无法取里层函数名。而直接尝试在里层函数里使用函数名，那就变成递归了！</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 只能在这里可以取到getAge函数名，可是变成了递归</span></span><br><span class="line">            <span class="comment">// getAge.apply(hwh,[]);   // 报错：无限递归</span></span><br><span class="line">            <span class="keyword">var</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> nowYear - <span class="built_in">this</span>.birth;    <span class="comment">// 调用对象里属性，不用this会报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAge();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="装饰器">装饰器</h4><p>利用 <em>apply()</em>，我们还可以动态改变函数的行为。</p><p><em>JavaScript</em> 的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。（ <u>覆写？？</u>）</p><blockquote><p>增加统计调用多少次方法 <em>parseInt()</em> ，在不改变原有功能基础上。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装饰器 </span></span><br><span class="line"><span class="comment">// 下面代码在 VSCode + codeRunner报错：window is not defined</span></span><br><span class="line"><span class="comment">// 在浏览器中控制台可正常输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     count++;</span><br><span class="line">     <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>,<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>); <span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>); <span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count);    <span class="comment">// 输出：3</span></span><br></pre></td></tr></table></figure><blockquote><p>但是下面方法也能调用原函数，无法说明装饰器作用？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     count++;     </span><br><span class="line"><span class="comment">//   return oldParseInt(null,arguments);     // 报错：parseInt是函数变量，这里返回的是函数值</span></span><br><span class="line">     <span class="keyword">return</span> oldParseInt;                     <span class="comment">// 成功输出 ：函数之间的赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-高阶函数">2.4 高阶函数</h2><p>在 <em>JavaScript</em> 中 ，变量可以指向函数，函数参数能接收变量，那么自然可以把 <u>函数当做另一个函数参数传递</u> 。</p><blockquote><p>高阶函数，简单来说就是把函数当参数，类似于C/C++中函数指针和C#中委托。</p></blockquote><p>下面是四个基本四则运算函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 除</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">div</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 乘、减..</span></span><br></pre></td></tr></table></figure><p>我们可以把它们当做参数，实现一个函数就可以计算四种不同运算：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myfuc</span>(<span class="params">a,b,f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = myfuc(<span class="number">1</span>,<span class="number">3</span>,div);   <span class="comment">// 0.3333333..</span></span><br></pre></td></tr></table></figure><h3 id="映射：map-reduce">映射：<em>map / reduce</em></h3><h4 id="map"><em>map()</em></h4><p>这里的<em>map()</em> 和前面集合<em>map</em> 不同，它是一个方法，表现对数组每个元素进行某种映射关系。</p><p>假设存在一个数组：<em>arr</em> = [<em>x1</em>,<em>x2</em>,<em>x3</em>…]  ，和<u>回调函数</u> <em>f(x)</em>。</p><blockquote><p><em>arr.map()</em> 把函数 <em>f(x)</em> 作为参数 ，会返回一个新数组 [<em>f(x1)</em>, <em>f(x2)</em>, <em>f(x3)</em> …]</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(pow);</span><br><span class="line"><span class="built_in">console</span>.log(newArr);    <span class="comment">// 输出：[ 1, 4, 9, 16, 25 ]</span></span><br></pre></td></tr></table></figure><p>:grey_question: 数组的元素会自动作为回调函数<em>f(x)</em> 第一个形参的实参进行赋值，如果<em>f(x)</em> 没有参数呢？或者不止一个参数呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有参数，每一次pow函数返回值 1 作为新数组元素</span></span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(pow);</span><br><span class="line"><span class="built_in">console</span>.log(newArr);    <span class="comment">// 输出：[ 1, 1, 1, 1, 1 ]</span></span><br></pre></td></tr></table></figure><p>事实上回调函数 <em>f(x)</em> 有三个参数，通常我们只使用第一个参数，表示 <em>Array</em> 某个元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newArr = arr.map</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">element,index,self</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(element);   <span class="comment">// 依次打印: 1,2,3,4,5</span></span><br><span class="line">        <span class="built_in">console</span>.log(index);     <span class="comment">// 依次打印: 0,1,2,3,4</span></span><br><span class="line">        <span class="built_in">console</span>.log(self);      <span class="comment">// self就是变量arr,每次都打印arr:[ 1, 2, 3, 4, 5 ]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> element*element;                       </span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr);    <span class="comment">// 输出：[ 1, 4, 9, 16, 25 ]</span></span><br></pre></td></tr></table></figure><blockquote><p>试分析：把<em>parseInt</em>函数作为参数，为什么得到意料之外的结果？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(<span class="built_in">parseInt</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr);    <span class="comment">// 输出：[ 1, NaN, NaN, NaN, NaN ]</span></span><br></pre></td></tr></table></figure><p>:slightly_smiling_face: 查看MDN文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><em>MDN-Array.map()</em></a></p><h4 id="reduce"><em>reduce()</em></h4><p><em>reduce()</em> 和 <em>map()</em> 类似：传入的参数函数<strong>f</strong> 循环每次对数组前两个元素运算，运算结果r作为数组首元素插入头部。</p><p>假设存在一个数组：<em>arr</em> = [<em>x1</em>,<em>x2</em>,<em>x3</em>,<em>x4</em>…]  ，和某个函数 <em>f(x,y)</em>。</p><blockquote><p><em>arr.map()</em> 把函数 <em>f(x,y)</em> 作为参数 ，会返回一个值：<em>f(f(x1,x2),x3)</em></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reduce</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x1,x2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x1+x2;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = arr2.reduce(sum);</span><br><span class="line"><span class="built_in">console</span>.log(s);    <span class="comment">// 输出：15</span></span><br></pre></td></tr></table></figure><p>当然无论是 <em>map / reduce</em> 传递参数都可以用 <em>lambada</em> 表达式进行简化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = arr2.reduce(<span class="function">(<span class="params">x1,x2</span>) =&gt;</span> x1+x2);</span><br><span class="line"><span class="built_in">console</span>.log(s);    <span class="comment">// 输出：15</span></span><br></pre></td></tr></table></figure><h3 id="自定规则：filter-sort-…">自定规则：<em>filter / sort …</em></h3><p>下列高级函数都有以下特点：</p><ul><li>根据传递的回调函数 <u>自定义某种判断规则</u></li><li>对数组每个元素进行判断，根据返回结果 <em>ture / false</em> 决定对元素进行不同操作</li></ul><h4 id="filter"><em>filter()</em></h4><p><em>filter</em>也是常用高级函数，它用于把<em>Array</em> 某些元素过滤掉，然后返回剩下的元素。</p><p>具体过程：*filter()*把传入的回调函数依次作用于每个元素 ，回调函数返回值为 <em>ture</em> 则该元素保留，否则删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = arr.filter</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; <span class="comment">// 只返回偶数</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1);  <span class="comment">// 输出：[ 2, 4 ]</span></span><br></pre></td></tr></table></figure><blockquote><p>给定数组<em>Array</em> ，去除里面重复的元素。（没看太明白）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  r,</span><br><span class="line">     arr = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line"></span><br><span class="line">r = arr.filter</span><br><span class="line">(</span><br><span class="line">    <span class="comment">// 数组当前元素、数组当前元素索引、数组本身分别作为回调函数3形参的实参值</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">element, index, self</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.indexOf(element) === index;  <span class="comment">// 这里没太明白</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(r.toString());   <span class="comment">// 输出：apple,strawberry,banana,pear,orange</span></span><br></pre></td></tr></table></figure><h4 id="sort"><em>sort()</em></h4><p><em>JavaScript</em> 中的 <em>sort()</em> 高级排序函数，<u>无传递回调函数情况下</u>，排序的操作顺序如下：</p><ol><li>先将数组的所有元素转换成 <em>String</em> 字符串</li><li><em>sort()</em> 根据每个字符串  <u>首字符 <em>ASCII</em>值</u>  来从小到大排序</li></ol><p>所以看起来会有下面&quot;奇怪&quot;结果：10 排在 2 前面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>].sort(); <span class="comment">// [1, 10, 2, 20]</span></span><br></pre></td></tr></table></figure><p>这是因为数组元素先转换成 <em>String</em> 类型，按 <u>首字符 <em>ASCII</em>值</u> 排序规则： ‘1’ &gt; ‘2’  ==&gt; ‘10’ &gt; ‘2’。</p><h5 id="定义自己的排序规则">定义自己的排序规则</h5><p>我们来定义数字从小到大排序规则回调函数，使得能正常输出我们期望的数字排序结果。</p><blockquote><p>排序规则：类比冒泡排序，判断两个元素大小，决定是否交换位置？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">arr1 = arr.sort</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)   <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1);  <span class="comment">// 输出：[ 1, 2, 10, 20 ]</span></span><br></pre></td></tr></table></figure><p>对应，冒泡排序写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cmp</span>(<span class="params">x,y</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y)   <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(j = arr.length -<span class="number">1</span> ; j -i &gt; <span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cmp作为排序规则，决定是否交换两个元素</span></span><br><span class="line">        <span class="keyword">if</span>(cmp(s[j],s[j-<span class="number">1</span>]) == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = s[j];   </span><br><span class="line">            s[j] = s[j-<span class="number">1</span>];   </span><br><span class="line">            s[j-<span class="number">1</span>] = temp; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(s[i]);    <span class="comment">// 依次输出：1  2  10  20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果，要求从小到大输出呢？</p></blockquote><p>重新定义下 <u>何为大</u> 即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">arr1 = arr.sort</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)   <span class="keyword">return</span> -<span class="number">1</span>;    <span class="comment">// 改成返回 -1</span></span><br><span class="line">        <span class="keyword">else</span>      <span class="keyword">return</span> <span class="number">1</span>;     <span class="comment">// 改成返回  1</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1);  <span class="comment">// 输出：[ 20, 10, 2, 1 ]</span></span><br></pre></td></tr></table></figure><p>同理，对应冒泡排序改换<em>cmp</em>排序规则（交换<em>if / else</em>返回值）。已测试成功输出，这里不再赘述。</p><h4 id="every"><em>every()</em></h4><p><em>every()</em> 自定<u>回调函数</u>判断规则，对所有数组元素进行判断，如果回调函数<u>都</u> 返回<em>ture</em> ，说明所有元素都满足判断条件，那么*<u>every()</u>* 返回 <em>ture</em>，否则返回<em>false</em> 。</p><blockquote><p>给定一个包含指定字符串数组，判断字符串是否满足指定测试条件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> b = arr.every</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> s.length &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">); </span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">// true, 因为每个元素都满足 s.length&gt;0</span></span><br></pre></td></tr></table></figure><h4 id="find"><em>find()</em></h4><p>同上自定 <u>回调函数</u>判断规则，对所有元素进行判断。如果回调函数返回 <em>ture</em> ，则找到第一个元素， <u><em>find()</em></u> 返回该元素；如果所有元素都遍历完毕，没有返回 <em>ture</em> ，则说明未找到元素，<em>find()</em> 返回 <em>undefined</em>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> tmp = arr.find</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s.toLowerCase() === s;  <span class="comment">// 找到第一个全是小写字母的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">); </span><br><span class="line"><span class="built_in">console</span>.log(tmp);<span class="comment">// 输出：pear</span></span><br></pre></td></tr></table></figure><h4 id="findIndex"><em>findIndex()</em></h4><p>和 <em>find()</em> 类型，不同在于 <em>findIndex()</em> 找到元素返回该索引而非返回元素；如果没找到元素则返回 -1。</p><h3 id="特别：forEach">特别：<em>forEach()</em></h3><p>同前 <em>forEach</em>  循环，它可用来遍历 <u>数组</u>、<u>集合</u> 。只单纯传递数组元素等信息，具体对数组元素等进行什么操作由传递的回调函数决定。</p><blockquote><p>利用<em>forEach()</em> 尝试遍历一个数组。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line">arr.forEach(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><p>由于回调函数默认有三个参数：<em>element、index、self</em> ，<em>console.log</em> 接收这三个实参依次打印它们信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apple 0 [ &#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27; ]</span><br><span class="line">pear 1 [ &#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27; ]</span><br><span class="line">orange 2 [ &#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27; ]</span><br></pre></td></tr></table></figure><blockquote><p><em>forEach()</em> 遍历一个数组，只打印出数组元素。</p></blockquote><p>我们可以重写 <em>console.log</em> 方法，让它只接收一个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> old_console_log = <span class="built_in">console</span>.log;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) // 重写</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    old_console_log(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="built_in">console</span>.log);    <span class="comment">// 依次输出：Apple   pear    orange</span></span><br></pre></td></tr></table></figure><blockquote><p><em>forEach()</em> 还可以遍历集合，如 <em>Set</em>、<em>Map</em> 等。注：不能遍历对象！遍历对象直接<em>for</em> 循环就行。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); </span><br><span class="line">arr2.forEach</span><br><span class="line">(</span><br><span class="line">    <span class="built_in">console</span>.log    <span class="comment">// 依次输出：1  2  3</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="2-5-闭包">2.5 闭包</h2><h4 id="什么是闭包？">什么是闭包？</h4><p>前面我们了解到，函数可以作为 <u>参数</u>，那么函数自然也可作为 <u>返回值</u>。</p><p>闭包，简单来说就是携带状态的函数，其返回值是一个也是函数，而且它的状态可以完全对外隐藏起来。</p><p>它的作用有：</p><ul><li>可创建函数工厂、减少函数参数</li><li>实现携带状态的闭包，获取函数内部局部变量且变量一直在内存中</li></ul><h4 id="函数工厂">函数工厂</h4><blockquote><p>计算指定 <em>x</em> 值的 2次方 / 3次方。</p></blockquote><p>也许聪明的你，很快想到利用系统自带 <em>API</em> 计算<em>x</em> 次方：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;   <span class="comment">// x值任意</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(x,<span class="number">2</span>);   <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">Math</span>.pow(x,<span class="number">3</span>);   <span class="comment">// 125</span></span><br></pre></td></tr></table></figure><p>但是，如果计算指定 <em>x</em> 值的 2次方 / 3次方是 <u>常用</u> 的，你觉得没必要每次都指定参数 <u>幂次</u> ，干脆直接自定义 <em>pow2 / pow3</em> 函数，只接收参数 <u>x</u> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow2</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow3</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pow2(<span class="number">5</span>);</span><br><span class="line">pow3(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>但是，如果计算 <em>x</em> 值的 4次方 / 5次方也 <u>常用</u>  ，定义4个函数显然不太简洁。</p><p>这里，可以用闭包创建一个函数工厂，返回同类我们需要的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creat_pow</span>(<span class="params">n</span>)    // 创建<span class="title">pow</span>函数工程，参数为指定幂次</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)   // 返回函数，参数为变量<span class="title">x</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow2 = creat_pow(<span class="number">2</span>);   <span class="comment">// 注意这里参数是：幂次，返回计算指定幂次函数</span></span><br><span class="line"><span class="keyword">var</span> pow3 = creat_pow(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">pow2(<span class="number">5</span>);   <span class="comment">// 25        注意这里参数是：变量x，即闭包里隐藏的局部变量x，计算它的指定幂次</span></span><br><span class="line">pow3(<span class="number">5</span>);   <span class="comment">// 125</span></span><br></pre></td></tr></table></figure><p>在这里我们还可以看到，闭包函数<em>pow</em> 隐藏一个状态：变量<em>x</em> ，即<em>pow</em> 内部返回的匿名函数局部变量参数<em>x</em> 。从而把一个多参数函数，变为单参数函数。</p><blockquote><p>又有，利用闭包快速生成不同类似函数，给Web进行事件绑定。</p></blockquote><p>参照：<a href="https://www.cnblogs.com/cjvae/p/9786598.html">闭包的应用 – 应用于web开发</a></p><h4 id="更深入理解-“闭包”">更深入理解 “闭包”</h4><p>难道闭包只是为了返回函数进而创建函数工厂 OR 减少函数参数吗？怎么理解闭包是携带状态的函数？请看下例：</p><p>我们知道，函数内部的局部变量，在函数退出后便自动消亡：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creat_counter</span>(<span class="params">initial</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = initial;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> n++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = creat_counter(<span class="number">0</span>);  <span class="comment">// 返回的是函数，故带上()是为了执行然后返回函数</span></span><br><span class="line"><span class="built_in">console</span>.log(c());    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(c());    <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(c());    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>非常奇怪的是，为什么这里的局部变量 <em>n</em> 实现了递增呢？变量<em>n</em> 不是应该在执行：<code>var c = creat_counter(0);</code> 后就已经消亡了吗？</p><p>其实：在返回的函数中，<u>实现了一个闭包环境，该闭包携带了外部无法访问的局部变量x</u> 。</p><p>这是由于 <em>creat_counter</em> 是内部匿名子函数的父函数，而<em>creat_counter</em> 被赋值给全局变量 <em>c</em>，因此其内部变量<em>n</em> 、匿名子函数都在内存中，没有被垃圾回收机制回收。</p><p>这样父函数内部，子函数外部的局部变量<em>n</em>，在 <em>JavaScript</em> 类似类的私有变量。我们还可以返回一个对象，看起来更像是 <u>类对象调用方法</u>。</p><blockquote><p>实现类似<em>class</em>机制封装私有变量的一个简单计数器。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creat_counter</span>(<span class="params">initial</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = initial;     <span class="comment">// 看起来就是一个私有变量，外部无法访问</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个对象，里面有inc属性，这样调用起来像是对象调用方法。</span></span><br><span class="line">    <span class="comment">// 注意 inc:f2() 错误，带()是执行函数</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">inc</span>:increase&#125;;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = creat_counter(<span class="number">0</span>);  <span class="comment">// 返回的是对象，带上()是为了执行函数后返回对象</span></span><br><span class="line"><span class="comment">// 看起来像是对象调用方法</span></span><br><span class="line">c.inc();   <span class="comment">// 1</span></span><br><span class="line">c.inc();   <span class="comment">// 2</span></span><br><span class="line">c.inc();   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h4 id="小心！返回函数不立即执行">小心！返回函数不立即执行</h4><p>我们需要注意一个问题，闭包返回的 <u>函数fun</u> 并不会立即执行，而是直到调用 <u>函数fun()</u> 才会执行。</p><p>这样，在我们返回函数引用任何后续会发生的变量都会产生意料之外结果，比如循环变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">var</span> arr = [];   <span class="comment">// 定义一个数组，用于压入三个函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++)   <span class="comment">// 循环压入一个匿名函数计算当前i^2：用箭头函数简写     </span></span><br><span class="line">        arr.push( <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> i * i &#125;);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results = count();</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>]; <span class="keyword">var</span> f2 = results[<span class="number">1</span>];  <span class="keyword">var</span> f3 = results[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>当我们尝试执行 <em>f1()</em>、 <em>f2()</em>、 <em>f3()</em> 会发现一个出人意料的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1(); // 16</span><br><span class="line">f2(); // 16</span><br><span class="line">f3(); // 16</span><br></pre></td></tr></table></figure><p>全都是16！这是因为，由于变量提升，循环局部变量 <strong>i</strong> 已经是函数内部全局变量了。</p><p>同时，<em>arr.push()</em> 压入函数时，函数并未立即执行。等到 <em>return  arr</em> 时，此时引用的变量<strong>i</strong> 已经执行完<strong>3</strong>次循环后变为 <strong>4</strong> 了。</p><p>我们有两种解决办法：</p><ol><li><p>循环内部变量用 <em>let</em> 关键字声明，这样等到 <em>return  arr</em> 时，函数引用的变量是对应循环次数局部变量 <strong>i</strong> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++)   <span class="comment">// let</span></span><br><span class="line">        arr.push( <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> i * i &#125;);</span><br></pre></td></tr></table></figure></li><li><p>再创建一个函数 <u>立即执行</u>，用该函数的参数绑定循环变量当前的值，参照：<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023021250770016">廖雪峰教程–闭包</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) </span><br><span class="line">    arr.push(</span><br><span class="line">        (</span><br><span class="line">            <span class="function"><span class="keyword">function</span> (<span class="params">n</span>)</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> n * n;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )(i)   <span class="comment">// 当前i赋值给函数形参n立即执行</span></span><br><span class="line">            );</span><br></pre></td></tr></table></figure><p>为什么直接压入匿名函数，而是要内部再返回一个函数，否则会报错？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">var</span> arr = [];   <span class="comment">// 定义一个数组，用于压入三个函数   </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) </span><br><span class="line">        arr.push(</span><br><span class="line">            (</span><br><span class="line">                <span class="function"><span class="keyword">function</span> (<span class="params">n</span>)</span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> n * n;   <span class="comment">// 直接返回出错？？</span></span><br><span class="line">                &#125;</span><br><span class="line">            )(i)</span><br><span class="line">                );</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> results = count();</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f1());  <span class="comment">// 报错： f1 is not a function</span></span><br></pre></td></tr></table></figure><p>这是因为表面看<em>arr.push()</em> 压入的是一个函数，但由于立即执行，实际上压入的是函数返回值！所以才必须设计压入函数返回值是一个函数。</p></li></ol><h2 id="2-6-箭头函数">2.6 箭头函数</h2><p>箭头函数和 <em>Lambda</em> 表达式都用于简写匿名函数，其语法也基本相同：<code>(parameters) =&gt; &#123; statements; &#125;</code>。</p><p>同时在满足一定条件下，还可以进一步简写：</p><ul><li><em>参数类型可选</em> ：不需要声明参数类型，编译器可以统一识别参数值；</li><li><em>只有一个参数</em> ： 参数 ()可选</li><li><em>主体{}只有一条语句</em> ：此时 <em>return</em> 关键字 &amp; {} ，可不写。注意 ！<ul><li>主体{} 不省略时，哪怕只有一条语句，函数有返回值<em>return</em>关键字不可省！</li><li>主体{} 省略时，<em>return</em> 也必须省略！</li></ul></li></ul><blockquote><p>利用箭头函数，实现给指定数组排序。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// arr.sort( (x, y) =&gt; x &gt; y ? 1: -1;);  // 错误：函数作为参数不要加分号！</span></span><br><span class="line">arr.sort( <span class="function">(<span class="params">x, y</span>) =&gt;</span> x &gt; y ? <span class="number">1</span>: -<span class="number">1</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 10, 20]</span></span><br></pre></td></tr></table></figure><blockquote><p>:warning: 试着指出下列箭头函数为什么不对？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.sort( <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;  x &gt; y ? <span class="number">1</span>: -<span class="number">1</span>; &#125;);    <span class="comment">// 错误写法</span></span><br></pre></td></tr></table></figure><p>主体{}只有一条语句，不省略{}时，语句要有分号 &amp; <em>return</em>不可省！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.sort( <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123; <span class="keyword">return</span> x &gt; y ? <span class="number">1</span>: -<span class="number">1</span>; &#125;);  <span class="comment">// 正确写法</span></span><br></pre></td></tr></table></figure><h4 id="优雅的解决-this-错误指向">优雅的解决 <em>this</em> 错误指向</h4><p>在前面，我们提到 <em>JavaScript</em> 一个设计错误，在嵌套函数内部 <em>this</em> 会指向全局对象<em>window</em> (严格模式下指向 <em>undefined</em>) 而非调用函数的对象！为此我们提出一种解决办法：在嵌套函数里捕获<em>this</em>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 捕获this，此时this不在嵌套函数内部还是指向调用对象</span></span><br><span class="line">        <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> nowYear - <span class="built_in">this</span>.birth;    <span class="comment">// 调用对象里属性，不用this会报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAge();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hwh.age());   <span class="comment">// 输出：23</span></span><br></pre></td></tr></table></figure><p>现在我们可以箭头函数更加优雅的解决<em>this</em> 指向错误问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 无需捕获this，此时this也能正确指向调用方法的对象</span></span><br><span class="line">        <span class="keyword">var</span> getAge = <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="built_in">this</span>.birth;  </span><br><span class="line">        <span class="keyword">return</span> getAge();   <span class="comment">// 注意：返回不是函数，而是调用后函数值 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hwh.age());   <span class="comment">// 输出：23</span></span><br></pre></td></tr></table></figure><p>我的理解是，此时已经不是在嵌套函数内部调用<em>this</em> ，而在外层函数内调用<em>this</em>，不会出现<em>this</em> 错误指向问题。</p><p>因为在外层函数使用<em>this</em> 是可以自动绑定到当前调用函数的对象，但直接在对象内部调用<em>this</em> 还是会出错。</p><blockquote><p>试分析：为什么对象内部直接<em>this</em> 调用属性出错。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">my_birth</span>: <span class="built_in">this</span>.birth,</span><br><span class="line">    <span class="attr">age</span>:<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="built_in">this</span>.birth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hwh.my_birth);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(hwh.age());     <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>比如调用 <em>hwh.my_birth</em> 相当于以下过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hwh = <span class="keyword">new</span> hwh();            </span><br><span class="line">hwh.my_birth = <span class="built_in">this</span>.birth;   <span class="comment">// 此时this指向了全局对象！</span></span><br></pre></td></tr></table></figure><p><em>hwh.age()</em> 调用错误同理。那么如何解决这个问题？</p><p>目前除了<em>apply、call</em> 改变 <em>this</em> 指向（没试过），可声明一个函数在里面<em>this</em> 调用可以绑定到正确对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">my_birth</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">return</span> <span class="built_in">this</span>.birth; &#125;,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="built_in">this</span>.birth;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hwh.my_birth);  <span class="comment">// 1996</span></span><br><span class="line"><span class="built_in">console</span>.log(hwh.age());     <span class="comment">// 23</span></span><br></pre></td></tr></table></figure><h2 id="2-7-generator">2.7 <em>generator</em></h2><p><em>generator</em> 即生成器，是<em>ES6</em> 新引入数据类型，看上去像一个函数，但可以返回多次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myGenerator =  f(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> x1 = myGenerator.next();   <span class="built_in">console</span>.log(x1);  <span class="comment">// 输出：&#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="keyword">var</span> x2 = myGenerator.next();   <span class="built_in">console</span>.log(x2);  <span class="comment">// 输出：&#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="keyword">var</span> x3 = myGenerator.next();   <span class="built_in">console</span>.log(x3);  <span class="comment">// 输出：&#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="keyword">var</span> x4 = myGenerator.next();   <span class="built_in">console</span>.log(x4);  <span class="comment">// 输出：&#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>它多个返回值可以 <u>记录函数不同时刻的执行状态</u>，从语法上看和函数有以下几个区别：</p><ul><li>基本定义：函数是<em>function f(x)</em> ，而生成器要多出一个<code>*</code> ，<em>function* f(x)</em></li><li>返回值：<em>generator</em> 生成器可以有多个返回值，记录函数不同时刻状态</li><li>使用：直接调用 <em>generator</em> 不是返回值，而是返回 <u>一个生成器对象</u> ，可调用它的 <em>next()</em> 函数来输出返回值。<ul><li>生成器不同返回值以对象形式保存：<u>{<em>value</em> : 当前返回值，<em>done</em>: 判断是否已经输出完毕}</u></li></ul></li></ul><p>我们还可以更简洁用 <em>for…of</em> 循环来遍历<em>generator</em> 输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面在浏览器里如是输出：如果直接在VSCode打印，还会在第一行输出：</span></span><br><span class="line"><span class="comment">// Object [Generator] &#123;&#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x <span class="keyword">of</span> myGenerator)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 依次输出：1  2  3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，<em>generator</em> 这种可以返回多个值，记录不同时刻执行状态的&quot;函数&quot;有什么作用呢？请看下例：</p><blockquote><p>试着编写一个以 <code>0、1</code> 开头的斐波那契数列：0 1 1 2 3 5 8 13 21 34 …</p></blockquote><p>按照以前思路，我们若要返回该斐波那契数列，必须要用 <u>数组保存多个值</u> ，且看更优雅的<em>generator</em> 如何做到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fib</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> a;   <span class="comment">// 返回 0</span></span><br><span class="line">    <span class="keyword">yield</span> b;   <span class="comment">// 返回 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(c &lt; x)</span><br><span class="line">    &#123;</span><br><span class="line">        c = a + b;</span><br><span class="line">        [a,b] = [b,c];  </span><br><span class="line">        <span class="keyword">yield</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myGenerator =  fib(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x <span class="keyword">of</span> myGenerator)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 依次输出：0  1  1  2  3  5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>generator</em> 不用数组来保存每次循环计算的值，而是直接将当前计算值的值 <em>yield</em> 返回即可。</p><h3 id="generator-简化-AJAX-（待）"><em>generator</em> 简化 <em>AJAX</em> （待）</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础（一）JavaScript基础笔记(中)</title>
      <link href="/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
      <url>/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>第三章：标准对象</h1><h2 id="3-1-小城少年对象与坑">3.1 小城少年对象与坑</h2><h3 id="typeof"><em>typeof</em></h3><p>在 <em>JavaScript</em> 的世界里，一切都是对象，你喜欢但不喜欢你的姑娘也是。</p><p><em>typeof</em> 操作符获取对象的类型，它总是返回一个 <u>字符串</u>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.字符串、数值、布尔基本类型</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>;      <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>;     <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>;    <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.函数</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.abs;  <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.预设特殊值</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>;       <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>;      <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.[] &#123;&#125; ?</span></span><br><span class="line"><span class="keyword">typeof</span> [];        <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;;        <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure><p>根据利用 <em>tepeof</em> 来判断一些变量。比如：</p><blockquote><p>判读全局变量、局部变量是否存在。</p></blockquote><ul><li>判断全局变量是否存在：<code>typeof window.myVar === 'undefined'</code></li><li>判断局部变量是否存在：<code>typeof myVar === 'undefined'</code> 。</li></ul><blockquote><p>判断是否 <em>null</em>、<em>Array</em> 。</p></blockquote><p>我们从上也知道，<em>typeof</em> 无法判断出是否 <em>null</em>、<em>Array</em> (它们和 <strong>[]、 {}</strong> 都是 <em>object</em>类型)，但可以：</p><ul><li>判断 <em>null</em> ： <code>变量 === null；</code></li><li>判断 <em>Array</em>：<code>Array.isArray(arr);</code></li></ul><h3 id="包装对象">包装对象</h3><p>和 <em>java</em> 类似，<em>JavaScript</em> 还提供了包装对象，比如 <em>int</em> 可封装转换为 <em>integer</em> 类型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装返回的是一个对象</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) ;     <span class="built_in">console</span>.log(n);  <span class="comment">// 输出：[Number: 123]</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);    <span class="built_in">console</span>.log(b);  <span class="comment">// 输出：[Boolean: true]</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;str&#x27;</span>);    <span class="built_in">console</span>.log(s);  <span class="comment">// 输出：[String: &#x27;str&#x27;]</span></span><br></pre></td></tr></table></figure><p>但是注意：包装对象看上去值和原来一样但是已经是 <em>object</em> 类型！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n);   <span class="comment">// 输出：object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);   <span class="comment">// 输出：object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s);   <span class="comment">// 输出：object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和此前不同！</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">123</span>);    <span class="comment">// 输出：number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);   <span class="comment">// 输出：boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);  <span class="comment">// 输出：string</span></span><br></pre></td></tr></table></figure><h2 id="3-2-Date">3.2 <em>Date</em></h2><p><code>Date</code>对象用来表示日期和时间，有以下三种创建其对象方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.默认构造函数</span></span><br><span class="line"><span class="comment">// 用now对象获取的时间始终是[当前最新]时间</span></span><br><span class="line"><span class="comment">// 输出的是UTC时间，与本地时间相差8个小时</span></span><br><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span><br><span class="line"><span class="built_in">console</span>.log(now);          <span class="comment">// 输出：2019-07-23T08:25:35.884Z</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.指定日期和时间构建</span></span><br><span class="line"><span class="comment">// 默认参数 = 0</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>,<span class="number">6</span>,<span class="number">23</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(date);         <span class="comment">// 输出：2019-07-23T16:20:30.123Z</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.指定时间戳创建</span></span><br><span class="line"><span class="comment">// 先将符合[ISO 8601格式]字符串---&gt;时间戳</span></span><br><span class="line"><span class="keyword">var</span> timeStamp = <span class="built_in">Date</span>.parse(<span class="string">&#x27;2019-07-23T16:20:30.123&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(timeStamp);     <span class="comment">// 输出：1563870030123，这是一个时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为Date对象</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(timeStamp);</span><br><span class="line"><span class="built_in">console</span>.log(date);          <span class="comment">// 输出：2019-07-23T16:20:30.123Z</span></span><br></pre></td></tr></table></figure><p>常用的获取时间各种信息对象方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">now;                       <span class="comment">// 2019-07-23T08:47:48.033Z</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象方法</span></span><br><span class="line">now.getFullYear();         <span class="comment">// 2019, 年份</span></span><br><span class="line">now.getMonth();            <span class="comment">// 6, 月份，注意月份范围是0~11，6表示7月</span></span><br><span class="line">now.getDate();             <span class="comment">// 23, 24号</span></span><br><span class="line">now.getDay();              <span class="comment">// 2, 星期二</span></span><br><span class="line">now.getHours();            <span class="comment">// 16, 24小时制</span></span><br><span class="line">now.getMinutes();          <span class="comment">// 47, 分钟</span></span><br><span class="line">now.getSeconds();          <span class="comment">// 48, 秒</span></span><br><span class="line">now.getMilliseconds();     <span class="comment">// 033, 毫秒数</span></span><br><span class="line">now.getTime();             <span class="comment">// 1563871956469, 时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.now());   <span class="comment">// 输出：1563871956469</span></span><br></pre></td></tr></table></figure><h3 id="时区问题">时区问题</h3><p>我们看到上面输出的时间，并不是我们本地时间，而是UTC时间和本地相差8个小时，我们可以输出本地时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.直接将当前时间转为本地时间</span></span><br><span class="line"><span class="built_in">console</span>.log(now.toLocaleString());   <span class="comment">// 输出：2019-7-23 5:10:21 PM</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.获取时间戳，然后进行时区转换</span></span><br><span class="line"><span class="comment">// 静态OR动态方法获取时间戳</span></span><br><span class="line"><span class="keyword">var</span> timeStamp = <span class="built_in">Date</span>.now();          <span class="comment">// 或者 var timeStamp = new Date().getTime();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接用时间戳构建对象</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(timeStamp);</span><br><span class="line"><span class="built_in">console</span>.log(date.toLocaleString());  <span class="comment">// 输出：2019-7-23 5:10:21 PM</span></span><br></pre></td></tr></table></figure><h2 id="3-3-RegExp（待）">3.3 <em>RegExp</em>（待）</h2><p><em>RegExp</em> 是专门用于正则解析的类，首先我们要对正则表达式熟悉。</p><h3 id="正则表达式">正则表达式</h3><h2 id="3-4-JSON">3.4 <em>JSON</em></h2><p><em>JSON</em> 是 <em>JavaScript Object Notation</em> 的缩写，它是一种数据交换格式，实际上也是 <em>JavaScript</em> 的一个子集。</p><p>其支持的数据类型有：</p><ul><li><em>object</em>：即<em>JavaScript</em> 的<code>&#123; ... &#125;</code>表示方式 (可嵌套)</li><li><em>number</em>、<em>boolean</em>、 <em>string</em>、<em>null</em>、<em>array</em>：和 <em>JavaScript</em> 中对应类型完全一致</li></ul><p><em>json</em> 数据可以是上面支持数据类型 <u>任意一个或多个组合</u> ，而不是只能在<em>object</em> <strong>{…}</strong> 包含键值对形式 。</p><blockquote><p>观察下面 <em>json</em> 格式数据{…}和 <em>js</em> 对象{…}有什么不同？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合成json格式数据</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;birth&quot;</span>: <span class="number">1996</span>,</span><br><span class="line"> <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line"> <span class="string">&quot;school&quot;</span>: <span class="string">&quot;chongqingU&quot;</span>,</span><br><span class="line"> <span class="string">&quot;skills&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;3C&quot;</span>,</span><br><span class="line">  <span class="string">&quot;python&quot;</span>,</span><br><span class="line">  <span class="string">&quot;2j&quot;</span></span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只要是字符串，如键值必须用双引号 <strong>‘’ ‘’</strong></li></ul><p>而且 <em>json</em> 还规定字符集必须是 UTF-8，这样可以支持多语言了。</p><p><em><u>json</u></em> 和 <em>js</em> <u>对象/数组/字符串（<em>json</em>支持）等</u> 可以互相转换，这又称为序列化和反序列化。</p><h3 id="序列化">序列化</h3><p>将<em>JavaScript</em> 数据类型转换为 <em>json</em> 称之为序列化。如下面是一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">skills</span>: [<span class="string">&#x27;3C&#x27;</span>,<span class="string">&#x27;python&#x27;</span>,<span class="string">&#x27;2j&#x27;</span>],</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="built_in">this</span>.birth; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <em>JavaScript</em> 内置了 <em>json  API</em>，我们可以直接调用 <code>JSON.stringify()</code>来转换为 <em>json</em> 格式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @value：传递一个对象或者数组(?)</span></span><br><span class="line"><span class="comment">// @replacer: 传递一个方法用来改变结果显示，或者传递数组筛选指定键值</span></span><br><span class="line"><span class="comment">// @space : 传递空白字符等用来格式化结果，使得结果更易读</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(hwh,<span class="literal">null</span>,<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure><p>尝试输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(hwh,<span class="literal">null</span>,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s);   <span class="comment">// 输出：string，说明转换后json格式数据是字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化结果</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;birth&quot;</span>: <span class="number">1996</span>,</span><br><span class="line"> <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line"> <span class="string">&quot;school&quot;</span>: <span class="string">&quot;chongqingU&quot;</span>,</span><br><span class="line"> <span class="string">&quot;skills&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;3C&quot;</span>,</span><br><span class="line">  <span class="string">&quot;python&quot;</span>,</span><br><span class="line">  <span class="string">&quot;2j&quot;</span></span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别的，允许的数据类型如果不属于<em>json</em> 支持类型，序列化时不会显示该类型，如 <u>函数<em>age</em>键值对</u> 没有显示。</p><p>当然，我们也可以转换其它<em>json</em> 支持的数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="string">&#x27;str&#x27;</span>));  <span class="comment">// 输出：&quot;str&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="number">123</span>));    <span class="comment">// 输出：123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="literal">true</span>));   <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure><h4 id="进一步处理：传递函数">进一步处理：传递函数</h4><p>在前介绍，我们还可以通过第二个参数 <em>@replacer</em> 对键值对进行筛选、指定处理方法等。</p><blockquote><p>筛选出<em>JavaScript</em>对象指定键值：<em>birth、gender、school</em>  对应键值对。</p></blockquote><p>我们可以通过传递一个数组包含我们希望留下的键值，来达到目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(hwh,[<span class="string">&#x27;birth&#x27;</span>,<span class="string">&#x27;gender&#x27;</span>,<span class="string">&#x27;school&#x27;</span>],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化结果</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;birth&quot;</span>: <span class="number">1996</span>,</span><br><span class="line"> <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line"> <span class="string">&quot;school&quot;</span>: <span class="string">&quot;chongqingU&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组好像不行？？</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify([<span class="string">&#x27;hwh&#x27;</span>,<span class="string">&#x27;lt&#x27;</span>],[<span class="number">0</span>],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化结果</span></span><br><span class="line">[</span><br><span class="line"> <span class="string">&quot;hwh&quot;</span>,</span><br><span class="line"> <span class="string">&quot;lt&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>将所有键值转换为大写。（为什么不能对键值 <em>key</em> 大写？只能修改属性？）</p></blockquote><p>需要对键值对进行处理，可以传递一个函数，它会对所有键值对进行操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="comment">// 必须判断是否是 string类型，因为如birth属性就是Number</span></span><br><span class="line"><span class="comment">// 注意：typeof返回String类型字符串！</span></span><br><span class="line"><span class="comment">// 为什么不能转换键值key为大写？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  valueToUpper = <span class="function">(<span class="params">key,value</span>) =&gt;</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span> ? value.toUpperCase():value;</span><br></pre></td></tr></table></figure><p>:warning: 传递的函数任何情况要有返回值！比如上面不打算对属性<em>value</em> 进行修改也要 <code>return value</code> 。</p><p>我们尝试输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(hwh,valueToUpper,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;birth&quot;</span>: <span class="number">1996</span>,</span><br><span class="line"> <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line"> <span class="string">&quot;school&quot;</span>: <span class="string">&quot;CHONGQINGU&quot;</span>,</span><br><span class="line"> <span class="string">&quot;skills&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;3C&quot;</span>,</span><br><span class="line">  <span class="string">&quot;PYTHON&quot;</span>,</span><br><span class="line">  <span class="string">&quot;2J&quot;</span></span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反序列化">反序列化</h3><p>我们也可以利用 <code>JSON.parse()</code> 将 <em>json</em> 格式字符串解析转换为 <em>javaScript</em>对象 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.反序列化对象 </span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;hwh&quot;, &quot;age&quot;:23&#125;&#x27;</span>);  <span class="comment">// Object &#123;name: &#x27;hwh&#x27;, age: 23&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.反序列化数组</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;[1,2,3,true]&#x27;</span>);             <span class="comment">// [1, 2, 3, true]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.反序列化其它基本类型</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;true&#x27;</span>);                     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;123.45&#x27;</span>);                   <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure><p>:warning: 要解析的 <em>json</em> 数据一定要是字符串！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.尝试解析对象？</span></span><br><span class="line"><span class="keyword">var</span> hwh = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;hwh&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="number">23</span>&#125;;  <span class="comment">// 这既不是对象（键值有&quot;&quot;），也不是字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(hwh));        <span class="comment">// 解析错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.尝试解析数组？</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">true</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(arr));        <span class="comment">// 解析错误</span></span><br></pre></td></tr></table></figure><h4 id="进一步处理：传递函数-2">进一步处理：传递函数</h4><p>事实上<code>JSON.parse()</code> 有两个参数，还可传第二个函数参数 <em>@reviver</em> 对<em>json</em> 字符串进行处理：</p><blockquote><p>把传递进来的<em>json</em> 字符串，键值<em>name</em>对应属性后加上“同学”。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化：json字符串转换为对象</span></span><br><span class="line"><span class="comment">// JSON.parse(@text,@reviver)</span></span><br><span class="line"><span class="comment">// @text：传递合法json字符串</span></span><br><span class="line"><span class="comment">// @reviver：传递一个函数改变输出结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> json_hwh = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;hwh&quot;, &quot;age&quot;:23&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> addSome = <span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key === <span class="string">&quot;name&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> value + <span class="string">&#x27;同学&#x27;</span>;  <span class="comment">// 对value进行修改</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> value;          <span class="comment">// 易错：其它情况也一定要有返回值！否则最后解析为undefined的！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(json_hwh,addSome);</span><br></pre></td></tr></table></figure><p>尝试输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化结果</span></span><br><span class="line">&#123; <span class="attr">name</span>: <span class="string">&#x27;hwh同学&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span> &#125;</span><br></pre></td></tr></table></figure><h1>第四章：面对对象编程</h1><h2 id="4-1-在-JS-世界面对对象">4.1 在 <em>JS</em> 世界面对对象</h2><p><em>JavaScript</em> 所有数据都可以看成对象，比如我们之前使用：<em>Number</em>、<em>Array</em>、<em>string</em> &amp; 基本的**{…} **定义的对象。</p><p>但这并没有真正发挥面对对象编程威力。</p><p>熟悉 <em>java、C#</em> 的你一定知道：类 &amp;  实例之间区别，就是模板与创建的实例对象。<em>BUT</em> ，在<em>JavaScript</em> 中并没有类和实例概念，在<em>JavaScript</em> 世界里是通过 <u><em>原型（prototype）</em></u> 等方式实现的。</p><h3 id="1-创建对象">1.创建对象</h3><p>闲的蛋疼的你想创建一个<em>hwh</em>对象，他会唱 、跳、rap、喜欢打篮球，又懒得9点钟都不一定起床的你恰好看到你之前创建的一个<em>student</em>对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span> : <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&quot;chongqingU&quot;</span>,</span><br><span class="line">    <span class="attr">sing</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;i am sing..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可是<em>hwh</em> 不叫小明，也不是18岁啊！更重要的小明他居然不会跳、rap、:basketball:！</p><p>熟悉原型链的你微微一笑，不慌不忙的创建了一个<em>hwh</em> 对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;huangwanghui&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="comment">// 对象增加额外方法</span></span><br><span class="line">    <span class="attr">jump</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;i am jump..&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">rap</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;i am rap..&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">play_basketball</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;i am playing basketball ..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把<em>hwh._<em>proto</em>_</em> 属性指向<em>student</em>，看上去好像继承了<em>student</em>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hwh.__proto__ = student; <span class="comment">// 注意：proto左右各有两个_，不是一个！</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;大家好，我是渣渣辉 :&quot;</span> + hwh.name);</span><br><span class="line">hwh.sing();                <span class="comment">// 唱：i am sing..</span></span><br><span class="line">hwh.jump();                <span class="comment">// 跳：i am jump..</span></span><br><span class="line">hwh.rap();                 <span class="comment">// rap：i am rap..</span></span><br><span class="line">hwh.play_basketball();     <span class="comment">// 打篮球：i am playing basketball ..</span></span><br></pre></td></tr></table></figure><p>通过同名键值可以覆盖student原有键值，通过创建新键值对可以使得<em>hwh</em> 可以跳、<em>rap</em>、打篮球。</p><h4 id="扩展了解">扩展了解</h4><blockquote><p>为什么这种方式看上去好像 “继承”了 <em>student</em> 属性？</p></blockquote><p>因为在<em>JavaScript</em> 中，实例对象<em>hwh</em>如果没有找到属性、方法它会自动在其 <em>hwh._<em>proto</em>_</em> 对象属性中查找（<em>_<em>proto</em>_</em> 是一个对象）。这个时候把对象<em>student</em> 赋值 <em>hwh._<em>proto</em>_</em> ，那么就会自动查找对象 <em>student</em> 属性。</p><p>:warning: <em>_<em>proto</em>_</em> 是每一个对象或函数都有的属性（<u>默认指向 <em>Object.prototype</em></u>），但是函数还有 <em>prototype</em> 属性。</p><p>所以<em>hwh._<em>proto</em>_</em> （也就是对象<em>student</em> ）中也有这个属性：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564110563722.png" alt="1564110563722"></p><p>此时查找的原型链为：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564110665280.png" alt="1564110665280"></p><p>如果是用后面介绍 <u>构造函数创建<em>hwh</em>对象方式</u> ，其查找原型链为：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564109191794.png" alt="1564109191794"></p><h4 id="Object-create-创建对象"><code>Object.create()</code>创建对象</h4><p>通常在写 <em>JavaScript</em> 代码，<u>不推荐</u> 使用 <code>对象名.__proto__</code> 方式改变对象原型。</p><p>我们应该用 <code>Object.create(对象o)</code> 创建一个基于<code>对象o</code> 原型新对象：</p><blockquote><p>用<code>Object.create()</code> 方式创建基于原型<em>student</em> 的对象<em>hwh</em> ，相当 <u>复制</u> 了<em>student</em>对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于原型student创建对象hwh</span></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="built_in">Object</span>.create(student);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象修改属性</span></span><br><span class="line">hwh.name = <span class="string">&#x27;huangwanghui&#x27;</span>;</span><br><span class="line">hwh.age = <span class="number">23</span>;</span><br><span class="line"><span class="comment">// 对象增加方法</span></span><br><span class="line">hwh.jump = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am jump..&quot;</span>);</span><br><span class="line">hwh.rap = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am rap..&quot;</span>);</span><br><span class="line">hwh.play_basketball = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am playing basketball ..&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试调用</span></span><br><span class="line"><span class="built_in">console</span>.log(hwh.name);  <span class="comment">// 输出：huangwanghui</span></span><br><span class="line">hwh.jump();             <span class="comment">// 输出：i am jump..</span></span><br></pre></td></tr></table></figure><h4 id="构造函数创建对象">构造函数创建对象</h4><p>前面我们介绍了两种基于student原型创建<em>hwh</em> 对象方式：其中 <code>hwh.__proto___ = student</code>  这种创建对象方式，我们不推荐修改实例<em>hwh</em> 的*_<em>proto</em>__* 属性。</p><p>而且我们知道，此前<em>student</em> 都是对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型对象student</span></span><br><span class="line"><span class="keyword">var</span> student = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span> : <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&quot;chongqingU&quot;</span>,</span><br><span class="line">    <span class="attr">sing</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;i am sing..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把<em>student</em> 改写成一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数Student</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,school</span>)  // 构造函数首字母建议大写</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name =  name;</span><br><span class="line">    <span class="built_in">this</span>.age = age,</span><br><span class="line">    <span class="built_in">this</span>.school = school,</span><br><span class="line">    <span class="built_in">this</span>.sing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)   // 必须全部用<span class="title">this</span>引用函数内部变量</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;i am sing..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数内部看起来很像对象键值对形式只不过 <code>键值:属性</code> 变为：<code>this.键值:属性</code>，特别的</p><ul><li>函数所有变量（“键值”）必须用<em>this</em> 引用 ，在函数内部（非<em>strict</em> 模式）<em>this</em> 指向全局对象<em>window</em> ；<em>new</em> 创建新对象后，会自动将 <em>this</em> 指向到新创建的对象。</li></ul><p>这也就是构造函数，使用 <em>new</em> 它会返回一个实例对象：</p><ul><li>实例对象 <u>继承构造函数所有属性</u></li><li>实例对象 <em>_<em>proto</em>_</em> 属性自动绑定为构造函数原型<em>prototype</em> 属性。</li></ul><p>同样，自然我们也可以对对象进行增改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new返回一个对象</span></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student(<span class="string">&quot;hwh&quot;</span>,<span class="number">23</span>,<span class="string">&quot;chongqingU&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象增加额外方法</span></span><br><span class="line">hwh.jump = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am jump..&quot;</span>);</span><br><span class="line">hwh.rap = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am rap..&quot;</span>);</span><br><span class="line">hwh.play_basketball = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am playing basketball ..&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试输出</span></span><br><span class="line">hwh.sing();   <span class="comment">// 输出：i am sing..</span></span><br><span class="line">hwh.jump();   <span class="comment">// 输出：i am jump..</span></span><br></pre></td></tr></table></figure><p>同前，此时原型链查找顺序为：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564109191794.png" alt="1564109191794"></p><ol><li><p>对象<em>student</em> 原型对象<em>prototype</em> 会自动赋值给 <em>hwh._<em>proto</em>_</em> （<em>student.prototype</em> 属性也是一个对象）</p></li><li><p>如果没有在实例<em>hwh</em> 中找到属性、方法就会自动在<em>hwh._<em>proto</em>_</em> 中查找，等价于在 <em>student.prototype</em> 查找</p></li><li><p>对象<em>student.prototype</em> 又有个对象属性 <em>student.prototype._<em>proto</em>_</em> 它被赋值为<em>Object</em> 原型<em>Object.prototype</em></p></li><li><p>如果<em>student.prototype</em> 没有找到属性，就会接着在 <em>student.prototype._<em>proto</em>_</em> 中查找（等价在原型<em>Object.prototype</em> 中查找）</p></li><li><p>最后还有还找到返回null</p></li></ol><h3 id="2-初识原型链">2. 初识原型链</h3><p>当我们用<code>对象名.xxx</code>访问一个对象属性时，<em>JavaScript</em> 引擎查找顺序如下：</p><ol><li>先在当前对象上查找该属性，如果没有找到；</li><li>在其原型对象上找，如果还没有找到；</li><li>一直上溯到 <em>Object.prototype</em> --&gt; <em>null</em>  ；</li><li>上溯到<em>null</em> 说明未找到，返回 <em>undefined</em> 。</li></ol><blockquote><p>等等，这里原型链是什么？</p></blockquote><p>当我们创建一个 <em>Array</em> 对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>数组 <em>arr</em> 它的原型链是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr ----&gt; <span class="built_in">Array</span>.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>由于 <em>Array.prototype</em> 定义了 <em>indexof()</em> 、<em>shift()</em> 等方法，所以我们可以直接使用。</p><p>同理，创建一个函数 <em>fun()</em> 其原型链为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo ----&gt; <span class="built_in">Function</span>.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure><blockquote><p>那么前面以构造函数创建的hwh对象原型链是？（参考 <u>1.创建对象 — 构造函数创建对象</u> 一节）</p></blockquote><p><code>构造函数</code> 创建的<em>hwh</em>对象其原型链：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwh ----&gt; Student.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>或者用图表达：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564109191794.png" alt="1564109191794"></p><p>:warning: 这里 <em>Array、Function、Student</em> 都是构造函数，因此有<em>prototype</em> 属性 即<u>函数原型</u>（见下详述）。</p><p>​      注：每一个对象或函数都有*_<em>proto</em>_*属性（<u>默认指向 <em>Object.prototype</em></u>），但只有函数才有 <em>prototype</em> 属性。</p><h4 id="使用原型链基本原则">使用原型链基本原则</h4><p>基本使用原型链原则：</p><ul><li><p>原型链不应该过长，这会在查找对象属性花费过多时间。</p></li><li><p>构造函数名首字母应该为大写（像约定类名首字母大写）。</p></li></ul><h3 id="3-深入理解原型链">3.深入理解原型链</h3><h4 id="prototype-proto"><em>prototype</em> &amp; <em>_<em>proto</em>_</em></h4><p>在前我们知道构造函数也是可以拥有属性的，<em>prototype</em> 是只有函数才拥有的共有属性。属性<em>prototype</em> 又称为 <u>函数原型</u>，它是一个对象。</p><p><em>_<em>proto</em>_</em>  是所有对象、函数都有属性，它也是一个对象，指向生成它的构造函数原型<em>prototype</em> 属性。因为所有对象都派生自 <em>Object</em> 构造函数，所以默认指向原型<em>object.prototype</em> 属性。如果是通过构造函数创建的实例对象，则指向生成它的构造函数原型<em>prototype</em> 。</p><p>（而<em>prototype</em> 也是一个对象，所以不难理解它也有*_<em>proto</em>_*属性 ：<em>prototype._<em>proto</em>_</em>）</p><p><u>在函数原型上定义的方法、属性会被所有实例“继承”</u>，（<strong>准确来说，构造函数<em>new</em> 出的实例才会继承构造函数所有属性，函数原型上定义的方法、属性只是可以通过原型链查找而被使用，看上去好像“继承”了</strong>）。</p><p>函数原型对象<em>prototype</em>主要包含的属性方法如下（<em>prototype</em> 是一个对象所以也有很多键值对属性）：</p><ul><li><p>原型本身定义的 <strong>原型</strong> 属性、方法（只有通过 <code>函数名.prototype.属性名 = 方法/属性</code> 定义的才是原型方法、属性 ）</p></li><li><p><em>constructor</em> 属性：指向构造函数本身</p></li><li><p><em>_<em>proto</em>_</em> 属性：和原型链上级构造函数原型<em>prototype</em>属性等价</p></li></ul><blockquote><p>进一步理解函数原型对象？</p></blockquote><p>我们创建一个空构造函数 <em>Student()</em> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)  // 构造函数首字母建议大写</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;hwh&quot;</span>;  <span class="comment">// [注1]</span></span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.shcool = <span class="string">&quot;chongqingU&quot;</span>;   <span class="comment">// 给Student函数增加属性，这样可以增加到原型对象上</span></span><br><span class="line">Student.age = <span class="number">23</span>;       <span class="comment">// [注2]</span></span><br></pre></td></tr></table></figure><p>试想一下，如果我们之前用对象来作为原型创建实例， 把函数<em>Student()<em>改为对象</em>Student</em>应该是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [注1] 添加的属性name不属于函数原型方法属性，但可被创建的实例继承，是实例属性</span></span><br><span class="line"><span class="comment">// [注2] 添加的属性age，既不属于函数原型方法属性，也不会被实例继承，只能自娱自乐</span></span><br><span class="line"></span><br><span class="line">Student     </span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们便有了函数原型 <em>Student.prototype</em> 的一个初步雏形：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype   </span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，实际的 <em>Student.prototype</em> 属性不会这么简单：它还拥有<em>constructor</em>属性指向构造函数本身 ；<em>_<em>proto</em>_</em> 属性指向上一级构造函数原型<em>prototype</em> 。</p><p>我们尝试打印会出来类似下面结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Student.prototype);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">shcool</span>:<span class="string">&quot;chongqingU&quot;</span>               <span class="comment">// 1.函数原型增加的原型属性：shcool</span></span><br><span class="line">    <span class="attr">constructor</span>: ƒ doSomething(),     <span class="comment">// 2.constructor：指向Student本身</span></span><br><span class="line">    <span class="attr">__proto__</span>: &#123;                      <span class="comment">// 3.__proto__：== object.prototype</span></span><br><span class="line">        <span class="attr">constructor</span>: ƒ <span class="built_in">Object</span>(),</span><br><span class="line">        <span class="attr">hasOwnProperty</span>: ƒ hasOwnProperty(),</span><br><span class="line">        <span class="attr">isPrototypeOf</span>: ƒ isPrototypeOf(),</span><br><span class="line">        <span class="attr">propertyIsEnumerable</span>: ƒ propertyIsEnumerable(),</span><br><span class="line">        <span class="attr">toLocaleString</span>: ƒ toLocaleString(),</span><br><span class="line">        <span class="attr">toString</span>: ƒ toString(),</span><br><span class="line">        <span class="attr">valueOf</span>: ƒ valueOf()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到构造函数<em>Student.prototype._<em>proto</em>_</em> 属性指向—&gt;上一级构造函数<em>object.prototype</em> 属性。</p><p>(<em>_<em>proto</em>_</em> 属性默认指向<em>Object</em> 原型)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype.__proto__ === object.prototype;   <span class="comment">// ture</span></span><br></pre></td></tr></table></figure><p>t由上介绍我们也知道，用构造函数创建的实例*_<em>proto</em>_* 属性，会指向生成它的构造函数原型 <em>prototype</em> 属性。</p><blockquote><p>利用构造函数<em>Student</em> 创建实例<em>hwh</em> 对象，打印出它的 <em>_<em>proto</em>_</em> 属性。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="built_in">console</span>.log(hwh.__proto__);</span><br></pre></td></tr></table></figure><p>下面打印出的实际就是原型 <em>Student.prototype</em> :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">shcool</span>:<span class="string">&quot;chongqingU&quot;</span>               <span class="comment">// 1.原型本身拥有的属性：shcool</span></span><br><span class="line">    <span class="attr">constructor</span>: ƒ doSomething(),     <span class="comment">// 2.constructor：指向Student本身</span></span><br><span class="line">    <span class="attr">__proto__</span>: &#123;                      <span class="comment">// 3.__proto__：== object.prototype</span></span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，函数原型可看作是 <u>构造函数的一个&quot;实例&quot;</u> ，但是：</p><ul><li>只有 <code>函数名.prototype.属性</code> OR  <code>函数名.prototype.方法</code> 声明的属性/方法才是原型属性/方法</li><li>&quot;实例&quot;还自动拥有 <em>constructor</em> &amp; <em>_<em>proto</em>_</em> 属性分别指向函数本身和下一级构造函数原型</li></ul><h4 id="原型链查找">原型链查找</h4><p>好的聪明的你肯定想起来，我们前面写出的 <em>Student</em> 构造函数创建的 <em>hwh</em> 对象原型链：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564109191794.png" alt="1564109191794"></p><p>和我们此前说过的原型链查找某属性规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前对象查找属性 ---&gt; 上一级原型查找 ---&gt; .... ---&gt; object原型查找 ---&gt; 还没找到则为<span class="literal">null</span></span><br></pre></td></tr></table></figure><p>用一张图概况整个过程应该是：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564027583727.png" alt="1564027583727"></p><ul><li>在对象 <em>hwh</em> 本身实例属性查找，未找到则在 <em>hwh._<em>proto</em>_</em> 查找</li><li><em>hwh._proto__</em> 实际 ===上级原型<em>Student.prototype</em> ，在该原型中查找定义的原型属性、方法</li><li>未找到则在<em>hwh._<em>proto</em>_.prototype._<em>proto</em>_</em> === <em>Student.prototype._<em>proto</em>_</em> ===上级原型 <em>Object.prototype</em>，查找该原型中定义的属性、方法</li><li>还未找到则返回null</li></ul><p>如果我们把构造函数<em>Student</em> 原型指向另外一个实例，那么原型链查找顺序如何变化？</p><blockquote><p>创建实例lt，它有属性<code>name = “liuting”</code> 。把<em>Student.prototype</em>指向lt后，分析原型链查找<em>name</em>过程。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lt = <span class="keyword">new</span> Student();  </span><br><span class="line">lt.name = <span class="string">&quot;liuting&quot;</span>;</span><br></pre></td></tr></table></figure><p>此时我们还可以看到：<code>lt.__proto__ === Student.prototype</code> 为<em>ture</em> ，指向生成它的构造函数原型。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564044783639.png" alt="1564044783639"></p><p>而当把<em>Student</em> 原型指向<em>lt</em> 后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = lt;   <span class="comment">// Student原型指向lt</span></span><br></pre></td></tr></table></figure><p><code>lt.__proto__ === Student.prototype</code> 为 <em>false</em>， <em><em><em>lt._<em>proto</em>_</em> 还是保存原来未修改前的</em>Student</em> 函数原型**。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564046067250.png" alt="1564046067250"></p><p>再用构造函<em>Student</em>数创建新对象hwh：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line">hwh.__proto__ === Student.prototype === lt;   <span class="comment">// ture</span></span><br></pre></td></tr></table></figure><p>用一张图概括原型链变化应该是：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564049416082.png" alt="1564049416082"></p><p>我们尝试输出 <code>hwh.name</code>，显然可以在原型链 <code>实例lt</code> 的 <code>lt属性方法</code> 找到 <code>name</code> 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(hwh.name);     <span class="comment">// 输出:liuting</span></span><br></pre></td></tr></table></figure><h2 id="4-2-构造函数继承">4.2 构造函数继承</h2><p>我们定义一个构造函数 <em>Student()</em>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure><p>其原型链为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwh ---&gt; Student.prototype ---&gt; <span class="built_in">Object</span>.prototype ---&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>现在我们又定义了个构造函数 <em>People()</em> :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.eat = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am eating&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望<em>Student</em> 能继承  <em>People</em> ,从而可以使用 <em>People</em> 的 <em>eat()</em> 方法，并且把原型链修改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwh ---&gt; Student.prototype ---&gt; People.prototype ---&gt; <span class="built_in">Object</span>.prototype ---&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>那么该怎么办呢？</p><h3 id="1-构造函数绑定">1. 构造函数绑定</h3><p>前面我们讲过<em>apply</em>方法：<code>函数名.apply(对象名,[])</code> 。</p><p>可以将函数所有 <u>绑定到this的属性</u> 转而—&gt; <u>绑定到指定对象</u> 上。（注：非严格模式下函数<em>this</em> 指向 <em>undefined</em>）</p><p>因此，我们可以将构造函数<em>People</em> <u>绑定到this的属性</u> —&gt; 绑定到构造函数<em>Student</em> 生成的对象上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// this指向Student构造函数创建的对象</span></span><br><span class="line">    <span class="comment">// 将构造函数People绑定到this的属性(不是People所有属性) ---&gt; 绑定到Student对象上</span></span><br><span class="line">    People.apply(<span class="built_in">this</span>,[]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line">hwh.eat();   <span class="comment">// 输出：i am eating</span></span><br></pre></td></tr></table></figure><p>这样只是继承了<em>Student</em> 所有的属性，但是其原型链没有改变，还是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwh ---&gt; Student.prototype ---&gt; <span class="built_in">Object</span>.prototype ---&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>之所以<em>hwh</em> 能调用 <em>eat()</em> 方法，是因为该方法已经绑定到 <em>hwh</em> 对象上。</p><h3 id="2-prototype-模式">2. <em>prototype</em> 模式</h3><p>如果我们把 <em>Student</em> 原型指向 —&gt;一个 <em>People</em> 的实例，那么所有<em>Student</em> 实例都能“继承”<em>People</em> 属性、方法（准确来说，是通过原型链使得<em>Student</em> 实例对象<em>hwh</em> 可以使用构造函数<em>People</em> 的属性、方法）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = <span class="keyword">new</span> People();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 良好习惯：修改了prototype要设置回prototype.constructor</span></span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line">hwh.eat();    <span class="comment">// 输出：i am eating</span></span><br></pre></td></tr></table></figure><p>此时原型继承链为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwh --&gt;Student.prototype == <span class="keyword">new</span> People() --&gt;People.prototype --&gt;<span class="built_in">Object</span>.prototype --&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>用一张图表示为：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564115792502.png" alt="1564115792502"></p><h4 id="为什么有“良好习惯”？">为什么有“良好习惯”？</h4><p>在上面我们修改了 <em>Student.prototype</em> 指向，立马有重新设置了 <em>Student.prototype.constructor</em> 指回<em>Student</em> 。</p><p>如果不这么做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = <span class="keyword">new</span> People();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line">hwh.eat();   <span class="comment">// 输出：i am eating</span></span><br></pre></td></tr></table></figure><p>不影响通过原型链使用<em>People.eat()</em> 方法，但我们尝试输出：<em>hwh.constructor</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cosole.log(hwh.constructor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.eat = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am eating&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现构造函数<em>Student</em> 生成的对象<em>hwh.constructor</em> 属性是指向构造函数<em>People</em> ！</p><p>首先，我们要知道<em>hwh</em> 本身是没有<em>constructor</em>这个属性的。它是通过原型链查找到构造函数 <em>People.prototype.constructor</em> 属性的，自然它是指向构造函数 <em>People</em> 了：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564133255074.png" alt="1564133255074"></p><p>但是对象<em>hwh</em>，是由构造函数<em>Student()</em> 生成的，我们在应该让<em>hwh.constructor</em>  指向生成它的构造函数<em>Student()</em>！</p><p>所以就有了上面的 <strong>“良好习惯</strong>”：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype.constructor = Student;</span><br></pre></td></tr></table></figure><blockquote><p>但是，你可能会担心，<u>这样<em>People.prototype.constructor</em> 不就被修改了吗</u>？</p></blockquote><p>实际上，这样做只会在<em>Student.prototype</em> 也就是匿名对象 <em>new People()</em> +键值对：<code>constructor : f Student()</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564133877508.png" alt="1564133877508"></p><p>看上去好像基本解决了原型链继承问题？但是由于要创建实例对象，开销较大。</p><h3 id="3-直接继承-prototype">3. 直接继承 <em>prototype</em></h3><p>通过直接把<em>Student.prototype</em> 原型属性直接指向 <em>People.prototype</em> 原型属性，来达到继承<em>People</em> 属性、方法。</p><p>通过这种方式，需要把<em>People</em> 的属性、方法绑定到原型对象<em>People.prototype</em> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.eat = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am eating&quot;</span>);</span><br></pre></td></tr></table></figure><p>好了，我们开始 “ 继承 ” <em>People.prototype</em> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = People.prototype;</span><br><span class="line"><span class="comment">// 良好的习惯：每次修改函数原型，都应该设置回constructor</span></span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line">hwh.eat();      <span class="comment">// 输出：i am eating</span></span><br></pre></td></tr></table></figure><p>看起来天衣无缝，而且这比第 <strong>2</strong> 种方法效率更高：不用创建 <em>People</em> 实例。</p><p>但这种方式的原型链为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwh ---&gt; Student.prototype == People.prototype ---&gt; <span class="built_in">Object</span>.prototype ---&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564129946659.png" alt="1564129946659"></p><p>它没有体现  <em>Student</em> 和<em>People</em>之间原型继承关系，而且也隐藏了一个缺点。</p><h4 id="继承-prototype-方式缺点">继承 <em>prototype</em> 方式缺点</h4><p>这种方式， <em>Student.prototype</em> 和 <em>People.prototype</em> 现在指向了 <u>同一个对象</u> ，任何对 <em>Student.prototype</em> 修改都将反应在<em>People.prototype</em> 上。</p><p>我们在第二行修改了：<code>Student.prototype.constructor = Student;</code> ，会导致<em>People.prototype.constructor</em> 也被指向为构造函数 <em>Student</em> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">People.prototype.constructor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="我的疑问？">我的疑问？</h4><blockquote><p>为什么不可以直接设置 <em>Student.prototype._<em>proto</em>_</em> 指向 <em>People.prototype</em>  ？？？</p></blockquote><p>这种方式被很多博文都指出不应该提倡，原因影响性能？<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto">MDN-不推荐使用<em>Object.prototype._<em>proto</em>_</em></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype.__proto__ = People.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line">hwh.eat();      <span class="comment">// 可以输出：i am eating</span></span><br></pre></td></tr></table></figure><ul><li>实现了原型链继承关系</li><li>同时因为没有修改<em>Student.prototype</em> ，不用设置 <code>Student.prototype.constructor = Student</code></li></ul><h3 id="4-利用空对象作为中介">4. 利用空对象作为中介</h3><blockquote><p>一种基本完美的方法：既可体现原型链 <em>Student</em> 和<em>People</em> 继承关系，也不会导致<em>constructor</em> 之类问题。</p></blockquote><p>由于第3种办法，会出现指向同一对象导致<em>constructor</em> 意料之外被修改问题，我们可以借用一个空函数作为中介。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空函数F作为媒介</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把F原型指向People原型</span></span><br><span class="line">F.prototype = People.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时Student.prototype原型指向空函数F实例对象</span></span><br><span class="line">Student.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 良好习惯：每次修改函数原型，都应该设置回constructor</span></span><br><span class="line"><span class="comment">// 由于此时Student.prototype 和 People.prototype不再指向同一对象</span></span><br><span class="line"><span class="comment">// 此时修改constructor不会导致 People.prototype.constructor 被同步修改</span></span><br><span class="line">Student.prototype.constructor = Student; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line">hwh.eat();    <span class="comment">// 输出：i am eating</span></span><br></pre></td></tr></table></figure><p>噢，我的天！这是再变魔术吗？到底怎么一回事呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwh ---&gt; Student.prototype == <span class="keyword">new</span> F() ---&gt; F.prototype = People.prototype --&gt; <span class="built_in">Object</span>.prototype ---&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564128658845.png" alt="1564128658845"></p><h3 id="5-拷贝继承">5. 拷贝继承</h3><p>这种方式比较暴力…</p><p>首先，把<em>People</em> 的属性、方法绑定到原型对象<em>People.prototype</em> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.eat = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am eating&quot;</span>);</span><br></pre></td></tr></table></figure><p>接着实现将<em>People</em> 原型属性全部拷贝到 <em>Student</em> 原型属性上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历对象只需普通for循环</span></span><br><span class="line"><span class="comment">// 遍历循环只能用&lt;对象名[&#x27;key&#x27;]&gt;方式，其中&#x27;&#x27;在[i]不用加，i已经是字符串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> People.prototype)</span><br><span class="line">&#123;</span><br><span class="line">    Student.prototype[i] = People.prototype[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line">hwh.eat();        <span class="comment">// 输出：i am eating</span></span><br></pre></td></tr></table></figure><p>可以看到，<u>通过原型链</u> 实例对象<em>hwh</em> 可以访问到构造函数<em>Student.prototype.eat</em> 属性方法。</p><h2 id="4-3-class-继承">4.3 <em>class</em> 继承</h2><blockquote><p>写的比较简单，需要时再补充。</p></blockquote><h3 id="初识-class">初识 <em>class</em></h3><p>在ES6标准引入了 <em>class</em> 关键字，比原先<em>JavaScript</em> 基于原型链的对象模型更加简单。</p><p>现在有一个构造函数 <em>Student</em> 可用来<em>new</em> 出实例对象，它像下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name; </span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.learn =  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;i am learning..&quot;</span>); &#125;;</span><br></pre></td></tr></table></figure><p>把它改写成<em>class</em> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="comment">// new生成实例对象时自动调用该方法，为所有类实例对象生成下列实例属性</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// learn方法</span></span><br><span class="line">    <span class="function"><span class="title">learn</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;i am learning..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试调用</span></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student(<span class="string">&#x27;hwh&#x27;</span>,<span class="number">23</span>);</span><br><span class="line">hwh.learn();   <span class="comment">// 输出：i am learning..</span></span><br></pre></td></tr></table></figure><p>看起来比此前写法简单多了，但其实在<em>JavaScript</em> 类 <em>class</em> 本质还是函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> Student;  <span class="comment">//  function</span></span><br></pre></td></tr></table></figure><p>另一方面，函数自然一定有原型属性<em>prototype</em>  ：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564147389409.png" alt="1564147389409"></p><p>当然，这个’'函数&quot;有点特殊，所有直接在类中定义的属性、方法会被直接绑定到函数原型上。</p><p>所以上面 <em>class Student</em> 等价这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.learn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;i am learning..&quot;</span>); &#125;;</span><br></pre></td></tr></table></figure><h3 id="使用-class-实现继承">使用 <em>class</em> 实现继承</h3><p>使用<em>class</em> 可以方便的实现继承，我想刚刚学完原型继承的你不会忘记被它支配的恐惧。</p><p>现在这有一个类 <em>Girl_Student</em> 继承 <em>Student</em> ，你可以这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl_Student</span> <span class="keyword">extends</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age,grade</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ES6规定必须调用父类构造函数一次</span></span><br><span class="line">        <span class="built_in">super</span>(name,age);</span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">myGrade</span>(<span class="params"></span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;I am at grade: &#x27;</span> + <span class="built_in">this</span>.grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gs = <span class="keyword">new</span> Girl_Student(<span class="string">&#x27;lt&#x27;</span>,<span class="number">23</span>,<span class="number">395</span>);</span><br><span class="line">gs.myGrade();  <span class="comment">// 调用自身方法：I am at grade 395</span></span><br><span class="line">gs.learn();    <span class="comment">// 调用父类方法：i am learning..</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础（二）CSS基础笔记</title>
      <link href="/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89CSS%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89CSS%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>第一部分：基本样式属性</h1><h2 id="文本样式">文本样式</h2><h3 id="字体：font-family">字体：<em>font-family</em></h3><p>指定设置元素的字体：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">font-family</span>: <span class="string">&quot;Times New Roman&quot;</span>, Times, serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>逗号分隔表示为备选字体，当不浏览器不支持 <em>“Times New Roman”</em> 后会依次选择 <em>Times、serif</em> 字体。</li><li>如果字体不止为一个单词，要用 <code>“ ”</code> 包围，比如 <em>“Times New Roman”</em></li></ul><h3 id="大小：font-size">大小：<em>font-size</em></h3><p><em>font-size</em> 属性用于设置字体的大小，常用设置字体方式有三种：</p><ul><li><p>关键字：<em>small</em> &lt; <em>medium</em> &lt;  <em>large</em> &lt; <em>xlarge</em></p></li><li><p>数值：像素值 <em>px</em> 、相对尺寸单位 <em>em</em>，特别的**：<em>1em = 16px</em>**</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: small;</span><br><span class="line">//  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">//  <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="斜体：font-style">斜体：<em>font-style</em></h3><p><em>font-style</em> 通常用于指定斜体文本，常用属性值用关键字设置：</p><ul><li>关键字：<em>normal(正常文本)</em>， <em>italic（斜体）</em>  ，<em>oblique(倾斜)</em> 和 <em>italic</em> 效果类似</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="粗细：font-weight">粗细：<em>font-weight</em></h3><p><em>font-weight</em> 控制文本的粗细，可以设置关键字或者数值来指定：</p><ul><li>关键字：<em>normal</em> (默认)，<em>bold</em>，<em>bolder</em>，和 <em>lighter</em></li><li>数值：<em>100（细）—&gt; 900（粗)</em> ，特别的：<em>normal == 400，700 == bold</em></li></ul><h3 id="大写：font-variant">大写：<em>font-variant</em></h3><p><em>font-variant</em> 属性可将字体转换 —&gt; <em><u>小型</u>大写字母</em> ,可设属性有：</p><ul><li>关键字：<em>normal、small-caps（小型大写）、inherit</em> ：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">p</span><span class="selector-class">.normal</span> &#123; <span class="attribute">font-variant</span>: normal;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">p</span><span class="selector-class">.small</span>  &#123; <span class="attribute">font-variant</span>: small-caps;&#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;normal&quot;</span>&gt;</span>设置为normal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;small&quot;</span>&gt;</span>设置为small-caps<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行效果：可以看到原小写 <em>small-caps</em> 被转换为大写 <em>SMALL-CAPS</em>，但是字体较小</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565925830019.png" alt="1565925830019"></p><h3 id="颜色：color">颜色：<em>color</em></h3><p><em>color</em> 可用于设置文本颜色，通常可用以下三种方法设置：</p><ul><li>颜色关键字，如：<em>red、blue、green</em></li><li>十六进制值，如：<em>#0000FF(蓝色)</em></li><li><em>RGB</em>，如：<em>rgb(255,0,0)(红色)</em></li></ul><h3 id="对齐：text-align-、vertical-align">对齐：<em>text-align</em> 、<em>vertical-align</em></h3><p><em>text-align</em> 用于水平对齐，可设置属性为：<em>left、center、rigth</em> 。</p><p><em>vertical-align</em> 用于垂直对齐，可设属性为：</p><ul><li>文字在 <u>表格单元</u> 居中、上、下：<em>top、middle、bottom</em> ，<em><strong>不可用数值</strong></em></li><li><em>字体能达到 <u>不改变</u>、<u>下标</u>、<u>上标</u> ：baseline、sub、super</em> ，<em><strong>可用数值</strong></em></li></ul><blockquote><p>使得文字在表格居中、上、下。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565927294013.png" alt="1565927294013"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">td</span><span class="selector-class">.top</span>    &#123; <span class="attribute">vertical-align</span>: top;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">td</span><span class="selector-class">.middle</span> &#123; <span class="attribute">vertical-align</span>: middle;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">td</span><span class="selector-class">.bottom</span> &#123; <span class="attribute">vertical-align</span>: bottom;&#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;2&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 150px;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;top&quot;</span>&gt;</span>Top<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>Middle<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;bottom&quot;</span>&gt;</span>Bottom<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>:warning: 但是特别的，如果 **文字 **要在div区域到垂直居中效果 ，必须：</p><ul><li><u>外部<em>div</em>标签</u> <em>display</em> 属性设置为内联表格：<code>display: inline-table;</code></li><li>文字用 <u>内部<em>div</em>标签</u> 包围，同时将该内部<em>div</em>标签 <em>display</em>属性设置为表格单元：<code>display: table-cell;</code></li></ul><p><em>html</em> 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;paragraph&quot;</span>&gt;</span> w3cschool <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>css</em> 代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>; <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: LightSkyBlue;</span><br><span class="line">    <span class="attribute">display</span>: inline-table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.paragraph</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终可达到的效果：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565928383476.png" alt="1565928383476"></p><blockquote><p>使得某些文字在一段文字起到下标、上标效果。（注：也可直接使用 <code>&lt;sub&gt;</code>、<code> &lt;sup&gt;</code> 标签达到效果）</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565927624194.png" alt="1565927624194"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">span</span><span class="selector-class">.baseline</span> &#123; <span class="attribute">vertical-align</span>: baseline;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">span</span><span class="selector-class">.sub</span>   &#123; <span class="attribute">vertical-align</span>: sub; &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">span</span><span class="selector-class">.super</span> &#123; <span class="attribute">vertical-align</span>: super;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">span</span><span class="selector-class">.pixel</span> &#123; <span class="attribute">vertical-align</span>: -<span class="number">10px</span>;&#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;baseline&quot;</span>&gt;</span>w3cschool<span class="tag">&lt;/<span class="name">span</span>&gt;</span> example.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sub&quot;</span>&gt;</span>w3cschool<span class="tag">&lt;/<span class="name">span</span>&gt;</span> example.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;super&quot;</span>&gt;</span>w3cschool<span class="tag">&lt;/<span class="name">span</span>&gt;</span> example.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;pixel&quot;</span>&gt;</span>w3cschool<span class="tag">&lt;/<span class="name">span</span>&gt;</span> example.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="下划：-text-decoration">下划： <em>text-decoration</em></h3><p><em>text-decoration</em> 指定文本如何装饰，如：增加下划线、上方水平线、删除线（也可用  <code>&lt;s&gt;</code> 标签实现）。</p><p>常用属性关键字有：</p><ul><li><em>none</em> ： 默认值，这定义了一个正常的文本</li><li><em>inherit</em> ： 从其父元素继承此属性</li><li><em>overline</em> ：在文本上方绘制水平线</li><li><em>underline</em> ： 在文本下方绘制水平线</li><li><em>line-through</em> ： 在文本中绘制水平线（ 替换HTML标记）</li></ul><p>比如给下面一段文字加上下划线：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        p.underline &#123; text-decoration: underline; &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p class=&quot;underline&quot;&gt;w3cschool&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565946057860.png" alt="1565946057860"></p><h3 id="缩进：text-indent">缩进：<em>text-indent</em></h3><p><em>text-indent</em> 属性指定在文本的第一行开始之前应该留下多少水平空间。</p><p>常用属性值以长度表示，其单位为：<em>px、em、pt、cm</em> 等。也可用 <em><u>%、inherit(继承父元素缩进)</u></em>。</p><p>:warning: 可使用负值，比如：<code>text-indent: -40px</code> 。</p><h3 id="大写：text-transform">大写：<em>text-transform</em></h3><p><em>text-transform</em> 可以使得 <u>文本字母</u> 全部大写、小写、每个单词首字母大写，对应属性关键字为：</p><ul><li><em>uppercase</em>：使得选中文本所有字母都大写</li><li><em>lowercase</em>：使得选中文本所有字母都小写</li><li><em>capitalize</em> ：使得选中文本每个单词首字母大写</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">p</span><span class="selector-class">.uppercase</span>  &#123; <span class="attribute">text-transform</span>: uppercase;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">p</span><span class="selector-class">.lowercase</span>  &#123; <span class="attribute">text-transform</span>: lowercase;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">p</span><span class="selector-class">.capitalize</span> &#123; <span class="attribute">text-transform</span>: capitalize;&#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;uppercase&quot;</span>&gt;</span> transforms all characters to uppercase.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;lowercase&quot;</span>&gt;</span> transforms all characters to lowercase.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;capitalize&quot;</span>&gt;</span> transforms the first character in each word to uppercase. <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果图：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565947015580.png" alt="1565947015580"></p><h3 id="间距：letter-spacing-、word-spacing">间距：<em>letter-spacing</em> 、<em>word-spacing</em></h3><p><em>letter-spacing</em> 用于设置文本中字符之间的间距，常设属性方式：</p><ul><li>关键字：<em>normal(正常文本)</em> 、<em>inherit（继承父元素）</em></li><li>数值：<em>px，pt，cm，mm</em> 等测量单位定义字符额外空间，<em><strong>负值可以减少字符间距，更密集</strong></em> 。</li></ul><p><em>word-spacing</em> 指定文本中单词之间的空格，常设属性方式：</p><ul><li>关键字：<em>normal(正常文本)</em> 、<em>inherit（继承父元素）</em></li><li>数值：同前</li></ul><h2 id="盒模型">盒模型</h2><h3 id="盒模型结构">盒模型结构</h3><p><img src="https://www.w3cschool.cn/attachments/image/20171201/1512118436585159.jpeg" alt="img"></p><ul><li><p>属性工作顺序为顺时针：上 --&gt; 右 --&gt; 下 --&gt; 左</p><blockquote><p>创建一个顶部10像素，底部15像素，右侧5像素，左侧10像素的 <em>padding</em> 。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">5px</span> <span class="number">15px</span> <span class="number">10px</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="盒模型宽高">盒模型宽高</h4><p>高度 = <em>height</em> + ( <em>padding-top</em>  + <em>border-top</em>  + <em>margin-top</em>)+ (<em>padding-bottom</em>  + <em>border-bottom</em>  + <em>margin-bottom</em>)</p><p>宽度 = <em>width</em> + ( <em>padding-left</em>  + <em>border-left</em>  + <em>margin-left</em> )+ ( <em>padding-right</em>  + <em>border-right</em>  + <em>margin-right</em> )</p><blockquote><p>试问：下面盒模型的高度为多少？</p></blockquote><p><img src="https://www.w3cschool.cn/attachments/image/20171201/1512119750562691.jpeg" alt="img"></p><p>按照公式应该是：200 + (15 + 2 + 10 ) + (10 + 2 + 15) = 254px</p><h3 id="边框：border">边框：<em>border</em></h3><p><em><strong>border</strong></em> 属性可以自定义盒模型边框：</p><ul><li>空格分隔分别表示：<u>宽度 、边框样式 、颜色</u> 。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;  <span class="attribute">border</span>: <span class="number">5px</span> solid green; &#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565950868033.png" alt="1565950868033"></p><h4 id="border-width、border-style、border-color"><em>border-width</em>、<em>border-style</em>、<em>border-color</em></h4><p><strong><em>border-width</em>、<em>border-style</em>、<em>border-color</em></strong> 属性可分别设置单独设置：<u>宽度 、边框样式 、颜色</u> :</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span></span><br><span class="line">&#123;   </span><br><span class="line">   <span class="attribute">border-style</span>: solid;</span><br><span class="line">   <span class="attribute">border-width</span>: <span class="number">2px</span>;</span><br><span class="line">   <span class="attribute">border-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>border-style</strong></em> 属性设置：</p><ul><li>关键字：<em>solid(实线)、dotted(虚线)、dashed(虚线)、double(双精度)</em> 等</li></ul><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565952098393.png" alt="1565952098393"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565952128417.png" alt="1565952128417"></p><p>:warning:  还可为不同的边指定不同的边框：<strong><em>border-top-style，border-right-style</em> …</strong></p><h3 id="宽高：width、height">宽高：<em>width、height</em></h3><p>元素的宽高属性一般设置：</p><ul><li>数值：如指定高度 = 100px，<code>height = 100px</code></li><li>百分比：如指定宽度占据整个屏幕宽，<code>width = 100%</code></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">5px</span> solid green;    </span><br><span class="line">   <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">90px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565952791068.png" alt="1565952791068"></p><h4 id="最大、最小高宽">最大、最小高宽</h4><p>要设置元素的最小和最大高度或者宽度，可以使用以下属性：</p><ul><li><em>min-width</em> ：元素的最小宽度</li><li><em>min-height</em> ：元素的最小高度</li><li><em>max-width</em> ：元素的最大宽度</li><li><em>max-height</em> ：元素的最大高度</li></ul><h2 id="背景">背景</h2><h3 id="背景色：background-color">背景色：<em>background-color</em></h3><p>前面我们可以使用属性 <em>color</em> 设置文本颜色；<em>background-color</em> 则可以设置元素指定背景颜色。常用属性值：</p><ul><li>关键字：<em>red、blue</em> 等</li><li>十六进制：<em>#fff、#000、#6e6e6e</em> 等</li><li>RGB：<em>rgb(255,255,255)、rgba(0,0,0,0.5)</em> （<em>rgba</em> 可以实现透明背景色）</li></ul><blockquote><p>下面例子把：<em>boby、h1、p</em> 分配了不同的背景颜色。（字体颜色默认黑色）</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566006674666.png" alt="1566006674666"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-tag">body</span></span></span><br><span class="line"><span class="css">            &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">background-color</span>:red;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">div</span></span></span><br><span class="line"><span class="css">            &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">background-color</span>: <span class="number">#00ffff</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">p</span></span></span><br><span class="line"><span class="css">            &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">background-color</span>:<span class="built_in">rgb</span>(<span class="number">142</span>,<span class="number">185</span>,<span class="number">245</span>);</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>啊，我绿了！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>啊，人生好蓝~<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="背景图：background-image">背景图：<em>background-image</em></h3><p><em>background-image</em> 用于设置背景图，设置属性值用相对/绝对路径指定：</p><ul><li>指定路径：<em>url(‘相对/绝对路径’)</em></li></ul><p>:warning: 如果要指定多个图片，以逗号分隔：<em>background-image ： url(‘1.png’),url(‘2.png’);</em></p><p>特别的 <em>background-image</em> 不仅可以用于设置 <u>整个页面</u>，也可以设置 <u>某个元素</u> 背景图：</p><blockquote><p>下面给<p>元素设置一个背景图片。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566007841812.png" alt="1566007841812"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-tag">p</span></span></span><br><span class="line"><span class="css">            &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">height</span>:<span class="number">100px</span>; </span></span><br><span class="line"><span class="css">                <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">                <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">                <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">                <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">&quot;https://wpdotorg.files.wordpress.com/2008/11/boat.jpg&quot;</span>)</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是p标签，我的颜色是红色，高度为100px，我的背景图是一艘小船。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="重复：background-repeat">重复：<em>background-repeat</em></h3><p><em>background-repeat</em> 指定如何重复背景图像，可设置属性值（关键字）：</p><ul><li><em>repeat</em>：全区域重复 （即使不设置，<em><strong>背景图片默认全区域重复</strong></em>）</li><li><em>repeat-x</em>：沿x轴重复</li><li><em>repeat-y</em>：沿y轴重复</li><li><em>no-repeat</em>：不重复，只使用一次</li><li><em>herit</em>：继承父元素的 <em>background-repeat</em> 属性值</li></ul><h3 id="滚动：background-attachment">滚动：<em>background-attachment</em></h3><p><em>background-attachment</em> 设置背景图片是 <u>固定</u> 的还是和 <u>其余部分一起滚动</u> 。可设置的参数（关键字）：</p><ul><li><em>scoll</em>：默认值，背景图像会随着页面其余部分的滚动而移动</li><li><em>fixed</em>：页面的其余部分滚动时，背景图像不会移动</li><li><em>inherit</em>：从父元素继承 <em>background-attachment</em> 属性值</li></ul><blockquote><p>下面展示设置图片滚动的实例。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566009284538.png" alt="1566009284538"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-tag">body</span></span></span><br><span class="line"><span class="css">            &#123;</span></span><br><span class="line"><span class="css">               <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;https://wpdotorg.files.wordpress.com/2008/11/boat.jpg&quot;</span>);</span></span><br><span class="line"><span class="css">               <span class="attribute">background-repeat</span>: no-repeat;</span></span><br><span class="line"><span class="css">               <span class="attribute">background-attachment</span>: scroll;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是文本...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="列表样式">列表样式</h2><h3 id="项标记：list-style-type">项标记：<em>list-style-type</em></h3><p><em>list-style-type</em> 可用于设置列表每项标记，比如：<strong>·</strong> 、<strong>□</strong> 、…，参数可用关键字设置：</p><ul><li><em>none,circle(空心原点), square(空心□), decimal(有序数字), disc(实心原点), lower-alpha(有序字母)</em></li></ul><p>:warning: 有序列表 <ol> 除了默认数字<em>decimal</em> 作为标记，上面属性只能使用 <em>lower-alpha</em> 字母等 <em><strong>有序标记</strong></em> 。</p><blockquote><p>以下是为实例设置不同项目标记。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566010961164.png" alt="1566010961164"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-tag">ol</span><span class="selector-class">.lower-alpha</span> </span></span><br><span class="line"><span class="css">            &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">list-style-type</span>: lower-alpha;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">ul</span><span class="selector-class">.circle</span></span></span><br><span class="line"><span class="css">            &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">list-style-type</span>: circle;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">ul</span><span class="selector-class">.square</span> </span></span><br><span class="line"><span class="css">            &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">list-style-type</span>: square;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">&quot;lower-alpha&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">li</span>&gt;</span>w3cschool<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;circle&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">li</span>&gt;</span>w3cschool<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;square&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">li</span>&gt;</span>w3cschool<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="项标记-图像：list-style-image-、list-style-position">项标记-图像：<em>list-style-image</em> 、<em>list-style-position</em></h3><p>进一步我们还可以使用<em>list-style-image</em> 设置<em>图像作为项标记</em>，用 <em>list-style-position</em> 指定标记位置：</p><ul><li><em>list-style-position:<strong>inside</strong></em>：指定位置在内容流中:grey_question:</li><li><em>list-style-position:<strong>outside</strong></em>：<em><strong>默认值</strong></em>，指定位置不在内容流中:grey_question:</li></ul><blockquote><p>设置项标记为指定图像，并设置在内容流中。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566011824468.png" alt="1566011824468"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-tag">ul</span></span></span><br><span class="line"><span class="css">            &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">list-style-image</span>: <span class="built_in">url</span>(<span class="string">&quot;https://www.w3cschool.cn/statics/images/favicon.ico&quot;</span>);</span></span><br><span class="line"><span class="css">                <span class="attribute">list-style-position</span>: inside;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">li</span>&gt;</span>w3cschool<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">li</span>&gt;</span>w3cschool<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">li</span>&gt;</span>w3cschool<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="list-style"><em>list-style</em></h3><p><em>list-style</em> 属性是设置 <em>list-style-type</em>*、<strong>list-style-image</strong>、*<em>list-style-position</em> 简写属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">list-style</span>: square outside none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下方是未简化版本：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">list-style-type</span>: square;</span><br><span class="line">   <span class="attribute">list-style-position</span>: outside;</span><br><span class="line">   <span class="attribute">list-style-image</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566011992601.png" alt="1566011992601"></p><h2 id="表格样式">表格样式</h2><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><em>boder</em></td><td style="text-align:left">该属性可依次指定：边框大小、边框类型、边框颜色</td></tr><tr><td style="text-align:left"><em>border-collapse</em></td><td style="text-align:left">是否把表格边框合并为单一的边框</td></tr><tr><td style="text-align:left"><em>border-spacing</em></td><td style="text-align:left">分隔单元格边框的距离</td></tr><tr><td style="text-align:left"><em>width、height</em></td><td style="text-align:left">设置表格宽高，可用px、em等，也可用百分比 %</td></tr><tr><td style="text-align:left"><em>caption-side</em></td><td style="text-align:left">表格标题的位置</td></tr><tr><td style="text-align:left"><em>empty-cells</em></td><td style="text-align:left">是否显示表格中的空单元格</td></tr><tr><td style="text-align:left"><em>table-layout</em></td><td style="text-align:left">显示单元、行和列的算法</td></tr></tbody></table><p>更多设置：</p><ul><li><em>text-align 、vertical-align</em> ：设置文本对齐方式，见前</li><li><em>padding</em> ：设置表格中内容与边框的距离</li></ul><h3 id="边框-：boder">边框 ：<em>boder</em></h3><p>可为表格、表格单元设置边框、以及颜色和粗细，比如存在以下表格：</p><p>:warning:这其实是<em><strong>盒模型边框 boder设置</strong></em> ，因为表格<em>table</em>、表格单元<em>th、td</em> 其实也是元素，是盒模型结构。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566013694426.png" alt="1566013694426"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Firstname<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Lastname<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Bill<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Gates<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Steven<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Jobs<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>把整个表格、表格第一行单元、表格其它行单元设置为 ：1px粗、实框、蓝色。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：不能只选中 <code>table</code> 设置，这样只有表格最外层被设置蓝色边框。每个单元格也要被选中！</li></ul><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566013318572.png" alt="1566013318572"></p><h4 id="给四边设置样式">给四边设置样式</h4><p>在前面我们通过 <em>border</em> 属性来指定边框：颜色、样式、宽度，但是边框上下左右都是统一颜色样式等。</p><p>实际上，元素盒子模型中边框可分为上、右、下、左四个矩形区域。我们并且可通过下面属性分别指定：</p><ul><li><em>border-color</em>：指定边框颜色，可依次按 <u>上、右、下、左</u> 顺序指定四边</li><li><em>border-style</em>： 指定边框样式，可依次按 <u>上、右、下、左</u> 顺序指定四边</li><li><em>border-width</em>：指定边框宽度，可依次按 <u>上、右、下、左</u> 顺序指定四边</li></ul><blockquote><p>试着分析写出下面图形CSS代码。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566378942688.png" alt="1566378942688"></p><p>显然，背景颜色为白色，边框颜色都是黑色，边框样式也一致都为 <em>solid</em> ，而边框宽度明显下边宽度要和上、左、右不同需要单独设置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#yin-yang</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">96px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">48px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">50px</span> <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>进阶：尝试画出下面的阴阳图形。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566379602064.png" alt="1566379602064"></p><p>首先我们只需将上例中正方形通过 <em>border-radius</em> 属性设置为圆形即可 ：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566379754425.png" alt="1566379754425"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#yin-yang</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">96px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">48px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">50px</span> <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再尝试生成下面小圆：内圆为白，外环为黑色。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566380502138.png" alt="1566380502138"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#yin-yang</span><span class="selector-pseudo">::before</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">18px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再把小圆下移到直径和大圆直径重合：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566380622632.png" alt="1566380622632"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#yin-yang</span><span class="selector-pseudo">::before</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，再画出一个小圆：内圆为黑，外环为白色。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566380792473.png" alt="1566380792473"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#yin-yang</span><span class="selector-pseudo">::after</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">background-color</span>:black;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">18px</span> solid <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">top</span>:  <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深入了解-border-属性：梯形">深入了解 <em>border</em> 属性：梯形</h4><p>在上面你可能理解边框是由上下左右是个<em><strong>矩形</strong></em>组成。实际上它可通过<em>border-top</em> 、<em>border-right</em> 属性分为上下左右四个<em><strong>梯形</strong></em>区域，每个梯形区域由盒子 <em><strong>相邻 内容区域边 和 盒子最外边</strong></em>  组成。</p><blockquote><p>请看下例：设置文本区域为长宽相等<em>50px</em>正方形，边界都厚度为<em>50px</em> 。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566205583174.png" alt="1566205583174"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">div</span></span></span><br><span class="line"><span class="css">&#123;   </span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">50px</span> solid red;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们分别修改边框上下左右颜色，便可以发现其实是由4个梯形组成：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566205756666.png" alt="1566205756666"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid red;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid yellow;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步我们把文本内容区域高宽设置为0，那么四个边框矩形区域可变为三角形：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566206218995.png" alt="1566206218995"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid red;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid yellow;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们接着例举几个实例进一步理解<em>border</em>属性。</p><blockquote><p>试分析：下面的右三角形是怎么画出的？</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566206862889.png" alt="1566206862889"></p><p>过程其实很简单，首先在上面基础上，我们把上下两个三角形设为透明：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566206978678.png" alt="1566206978678"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid yellow;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后删除掉<em>border-bottom</em> 属性，这样由于右侧三角形不存在，<em>div</em> 宽度自动减去原右三角形宽（厚）度，表现为保留原来的左半部分：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566206862889.png" alt="1566206862889"></p><p>最终<em>css</em> 样式设置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同理，试着实现下三角形。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566207269756.png" alt="1566207269756"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid red;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折叠：border-collapse">折叠：<em>border-collapse</em></h3><p><em>border-collapse</em> 可将表格边框是否折叠成单一边框，可设置的属性（关键字）：</p><ul><li><p><em>seperate</em>：<em><strong>默认值</strong></em>，折叠成单一表格，每个单元都有自己的完整边框（比如上面表格）</p></li><li><p><em>collapse</em>：不折叠，每个相邻单元边合并</p></li></ul><blockquote><p>设置每个相邻单元格边合并。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566014059423.png" alt="1566014059423"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">border-collapse</span>:collapse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="距离：border-spacing">距离：<em>border-spacing</em></h3><p><em>border-spacing</em> 设置分隔单元格边框的距离：</p><ul><li>设置格式：<code>border-spacing ：水平单元格相邻距离  垂直单元格相邻距离</code></li></ul><p>:warning: 只有在 <em>border-collapse:seperate</em> 设置分开才生效！</p><blockquote><p>设置表格：水平单元格相距10px，垂直单元格相距30px。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566014814728.png" alt="1566014814728"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">border-collapse</span>: separate;</span><br><span class="line">    <span class="attribute">border-spacing</span>:<span class="number">10px</span> <span class="number">30px</span> ;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="宽高：width、height-2">宽高：<em>width、height</em></h3><p><em>width、height</em> 可以设置<em>table、th、td</em>宽高：</p><ul><li>基本长度单位：<em>px，em…</em></li><li>百分比：如100%，表格可以占据整个宽度</li></ul><blockquote><p>表格宽度设置为 100%，同时将 th 元素的高度设置为 50px。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566029890674.png" alt="1566029890674"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">table,td,th</span><br><span class="line">&#123;</span><br><span class="line">    border:1px solid black; // 设置边框</span><br><span class="line">&#125;</span><br><span class="line">// 宽度==屏幕宽，水平单元格宽度 = 屏幕宽 / 水平单元格数</span><br><span class="line">// 但如果是选择单元格td、th来设置width:100%;  宽度并不会平分，而是第一个水平单元格占据尽可能多宽度</span><br><span class="line">table</span><br><span class="line">&#123;</span><br><span class="line">    width:100%;            </span><br><span class="line">&#125;</span><br><span class="line">th</span><br><span class="line">&#123;</span><br><span class="line">    height:50px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Firstname<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Lastname<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Bill<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Gates<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Steven<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Jobs<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自动宽度：table-layout">自动宽度：<em>table-layout</em></h3><p><em>table-layout</em> 可以当单元格宽度*<u>未明确设置</u>*时 （表宽度可指定），如果设置每列列宽：</p><ul><li><em>auto</em>  ： 当列或单元格宽度未明确设置时，列宽将与组成列的单元格中的内容量成比例</li><li><em>fixed</em> ： 当列或单元格宽度未明确设置时，列宽将不受组成列的单元格中的内容数量的影响</li></ul><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566030823028.png" alt="1566030823028"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">border-collapse</span>: separate;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid gray;</span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">td</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid gray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span><span class="selector-class">.auto</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">table-layout</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span><span class="selector-class">.fixed</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">table-layout</span>: fixed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="综合练习">综合练习</h3><blockquote><p>请尝试实现下面表格样式。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566031584408.png" alt="1566031584408"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#customers</span></span></span><br><span class="line"><span class="css">  &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">font-family</span>:<span class="string">&quot;Trebuchet MS&quot;</span>, Arial, Helvetica, sans-serif;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>:<span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-collapse</span>:collapse;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#customers</span> <span class="selector-tag">td</span>, <span class="selector-id">#customers</span> <span class="selector-tag">th</span> </span></span><br><span class="line"><span class="css">  &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">font-size</span>:<span class="number">1em</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#98bf21</span>; // 为什么不设置 <span class="selector-id">#customers</span>？没有效果，因为和单元格重叠 </span></span><br><span class="line"><span class="css">      <span class="attribute">padding</span>:<span class="number">3px</span> <span class="number">7px</span> <span class="number">2px</span> <span class="number">7px</span>;  // 设置文字离边框距离</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#customers</span> <span class="selector-tag">th</span> </span></span><br><span class="line"><span class="css">  &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">font-size</span>:<span class="number">1.1em</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">text-align</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>:<span class="number">#A7C942</span>;  // 标题单元格背景设置为深绿</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>:<span class="number">#ffffff</span>;             // 标题文字设置为白色，而不是默认黑色</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">// 设置奇数行默认背景色，含标题</span></span><br><span class="line"><span class="css"><span class="selector-id">#customers</span> <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n+<span class="number">1</span>)</span></span><br><span class="line"><span class="css">  &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>:<span class="number">#EAF2D3</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;customers&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Company<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Country<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Steven Jobs<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>USA<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">&quot;alt&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Baidu<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Li YanHong<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>China<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Larry Page<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>USA<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="链接样式">链接样式</h2><p>我们可以根据前面学的：</p><ul><li>文本样式：设置链接文字样式，比如去除下划线 <code>text-decoration:none;</code></li><li>盒模型：设置链接的边框、宽高等，比如 <code>boder : 2px solid green</code></li><li>背景图：设置链接的背景图等</li><li>…</li></ul><p>同时比较特殊的是：我们可以定义链接不同状态下样式：</p><ul><li><em>a:link</em> ： 普通的、未被访问的链接</li><li><em>a:visited</em> ： 用户已访问的链接</li><li><em>a:hover</em> ： 鼠标指针位于链接的上方</li><li><em>a:active</em> ： 链接被点击的时刻</li></ul><h3 id="综合练习-2">综合练习</h3><blockquote><p>尝试实现如下样式的导航栏。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566038437683.png" alt="1566038437683"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="css">    步骤1：设置基本导航栏div区域背景色、高宽</span></span></span><br><span class="line"><span class="comment"><span class="css">*/</span></span></span><br><span class="line"><span class="css"><span class="selector-id">#menu</span></span></span><br><span class="line"><span class="css">&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#34495e</span>; // 直接设置区域背景色</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="css">    步骤2：设置表格，去除列表项标记等</span></span></span><br><span class="line"><span class="comment"><span class="css">    Q1:为什么要设置：overflow: hidden？</span></span></span><br><span class="line"><span class="comment"><span class="css">    因为ul元素子元素li 为了可以在一行显示设置了向左浮动。</span></span></span><br><span class="line"><span class="comment"><span class="css">    设置overflow: hidden可以让ul包含li，而不是不显示了。</span></span></span><br><span class="line"><span class="comment"><span class="css">*/</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">ul</span></span></span><br><span class="line"><span class="css">&#123;</span></span><br><span class="line"><span class="css">   <span class="attribute">list-style-type</span>:none;</span></span><br><span class="line"><span class="css">   <span class="attribute">margin</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="css">   <span class="attribute">padding-left</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">   <span class="attribute">overflow</span>: hidden; <span class="comment">/*可以使用overflow:hidden;技术让父元素包含浮动子元素*/</span></span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/*li标签默认是块，为了在一栏显示，设置为float浮动*/</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">li</span></span></span><br><span class="line"><span class="css">&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;  </span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">    步骤3：设置链接基本样式。</span></span></span><br><span class="line"><span class="comment"><span class="css">    Q1:为什么设置display: block？</span></span></span><br><span class="line"><span class="comment"><span class="css">    1.可以让a标签整个区域被点击（而不是只有文字）2.可以设置a标签宽度、高度</span></span></span><br><span class="line"><span class="comment"><span class="css">    Q2:为什么设置line-height: 40px; ？</span></span></span><br><span class="line"><span class="comment"><span class="css">    为了让文字垂直居中。水平居中不能解决垂直居中，而vertical-align: middle不起作用。</span></span></span><br><span class="line"><span class="comment"><span class="css">    当然，也可以尝试设置 padding来模拟居中。</span></span></span><br><span class="line"><span class="comment"><span class="css">    */</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>,<span class="selector-tag">a</span><span class="selector-pseudo">:visited</span></span></span><br><span class="line"><span class="css">&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">130px</span>;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 设置a标签宽度 == div宽度，点击后整个区域都可以点击*/</span></span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">40px</span>; </span></span><br><span class="line"><span class="css">    <span class="comment">/* 高度 = 行高，可使得文字居中。直接vertical-align: middle;只能是表格单元格内起作用 */</span></span></span><br><span class="line"><span class="css">    // <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="css">    <span class="attribute">line-height</span>: <span class="number">40px</span>; </span></span><br><span class="line"><span class="css">    <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/*a:focus 可以保证点击后背景一直是红色，直到点了其它导航项目*/</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,<span class="selector-tag">a</span><span class="selector-pseudo">:focus</span></span></span><br><span class="line"><span class="css">&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;menu&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#home&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#news&quot;</span>&gt;</span>News<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#contact&quot;</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="定位与布局">定位与布局</h2><h3 id="内联与块：display">内联与块：<em>display</em></h3><p>网页上的每个元素都是一个盒模型，每个元素默认为块 或者内联行为方式：</p><ul><li>块元素：尽可能 占据最大宽度，<u>独占一行</u>、前后有 <u>换行符</u> ，<u><em>width、height</em> 可设置</u><ul><li>常用如：<em>div、p、h1~h6、ol、ul、table、from</em> 等</li></ul></li><li>内联元素：占据内容宽度，<u>不独占一行</u>、 <u>不强制换行</u> ，<u><em>width、height</em> 不可设置</u><ul><li>常见如：<em>span</em>、<em>a</em>、<em>img</em> 等</li></ul></li></ul><p><em>display</em> 属性可决定盒模型元素的 <em><strong>行为方式</strong></em> ：</p><ul><li><em>display:block</em> ：使得元素行为方式为<em><strong>块</strong></em></li><li><em>display:inline</em> ：使得元素行为方式为<em><strong>内联</strong></em></li><li><em>display:inline-block</em> ：使得元素行为方式为<em><strong>内联-块</strong></em> ，在内联的基础上又可以设置框高</li><li><em>display:none</em> ：<em><strong>隐藏</strong></em> 一个元素，<em>不占用任何空间 (<strong>visibility:hidden</strong> 占用空间 )</em> ，好像它不存在一样。</li></ul><h3 id="显隐：visibility">显隐：<em>visibility</em></h3><p><em>visibility</em> 用来设置元素是显示还是隐藏的，可设关键字：</p><ul><li><em>visibility:visible</em> ：元素可见</li><li><em>visibility:hidden</em> ：元素不可见，但是它<em>占据的空间还存在</em> ，依然会影响布局</li></ul><h3 id="定位：position">定位：<em>position</em></h3><p><em>position</em> 允许我们定位一个元素，常见定位方式有：</p><ul><li><p><em>static</em>：静态默认定位， 定位元素总是按照页面的正常流动进行定位，<u><em>忽略left、rigth等设置位置！</em></u></p></li><li><p><em>fixed</em>： 固定定位，即使窗口被滚动也不会移动，可设置垂直或水平位置，<em><u>相对于浏览器窗口定位</u></em></p></li><li><p><em>relative</em>：相对定位，可设置垂直或水平位置，<em><u>相对于它自身的起点位置定位</u></em></p></li><li><p><em>absolute</em> ：绝对定位，可设置垂直或水平位置，<em><u>相对最近<strong>已定位</strong>祖先元素 或者最初包含块</u></em></p><ul><li><p>设置后在 <em><u>原文档流中被完全删除，原占据空间关闭，好像不存在一样</u></em></p></li><li><p>因为绝对定位的框与文档流无关，可覆盖页面上的其它元素，通过 <em><strong>z-index</strong></em> 属性来设置</p></li></ul></li></ul><p>设置垂直或水平位置，通过属性：<em>top、bottom、left、right</em> 来设置：</p><ul><li>必须要先对 <em>position</em>属性进行初始化设置定位方式才能使用！</li><li><em>position:stactic</em> 设置的元素，<em>top、bottom、left、right</em> 会被忽略！</li></ul><h4 id="固定定位：fixed">固定定位：<em>fixed</em></h4><blockquote><p>实例：固定定位后，<em>div-a</em> 移动到相对浏览器窗口指定位置，原来位置被填充。</p></blockquote><p><img src="http://images.cnitblog.com/blog/153475/201307/26102414-9e01e2b20dc940578a8526c1c4ccc075.jpg" alt="img"></p><ul><li>脱离文档流，原空间不保留，随滚动条改变位置</li><li>相对浏览器窗口（左上角）位置定位</li></ul><h4 id="相对定位：relative">相对定位：<em>relative</em></h4><blockquote><p>实例：相对定位后，<em>div-a</em> 移动到相对自身在文档流的指定位置，原来位置保留。</p></blockquote><p><img src="http://images.cnitblog.com/blog/153475/201307/26095312-8b1f766cf0fa4ca9aa00b4a1a8f36039.jpg" alt="img"></p><ul><li>不脱离文档流，原空间保留</li><li>相对自身起点（左上角）定位</li></ul><h4 id="绝对定位：absolute">绝对定位：<em>absolute</em></h4><blockquote><p>实例：绝对定位后，<em>div-a</em> 移动到相对浏览器窗口（最近包含块）指定位置，原来位置被填充。</p></blockquote><p><img src="http://images.cnitblog.com/blog/153475/201307/26101124-2e6696331ba74e8190fd11a497b334cd.jpg" alt="img"></p><ul><li>脱离文档流，原空间不保留，但不随滚动条改变位置</li><li>相对最近已定位祖先元素定位，如果没有则相对最初包含块定位</li></ul><h3 id="重叠：z-index">重叠：<em>z-index</em></h3><p>如果两个元素发生重叠，可以通过设置<em>z-index</em> 属性改变层叠次序。定位元素沿 z 轴的位置，z 轴定义为垂直延伸到显示区的轴：</p><ul><li>默认<em>z-index</em> = 0， <em>z-index</em> 值越大，则沿着<em>z</em> 轴正轴越远，离用户越近</li><li><em>z-index</em> 属性必须要在设置了<em>position</em> 才能生效。（除了不能设置<em>position:static</em> ）</li></ul><blockquote><p>试着改变下面重叠红、蓝方块次序，把蓝色方块显示在上面。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566119983128.png" alt="1566119983128"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">       <span class="selector-class">.blue</span></span></span><br><span class="line"><span class="css">       &#123; </span></span><br><span class="line"><span class="css">           <span class="attribute">background-color</span>: <span class="number">#8EC4D0</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">width</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">height</span>: <span class="number">60px</span>;          </span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.red</span> </span></span><br><span class="line"><span class="css">        &#123;</span></span><br><span class="line"><span class="css">           <span class="attribute">background-color</span>: <span class="number">#FF4D4D</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">width</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">height</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">margin-top</span>: -<span class="number">30px</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">margin-left</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">   </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>blue<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>red<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，初始两个div方块按照 <em><u>后到显示在前</u></em> ，所以红色方块显示在前。</p><p>我们可以设置 <em><strong>.blue</strong></em> 的 <em>position</em> 属性为 <em>relative</em> （<em>fixed、absolute</em> 也可以，但是由于脱离文档流红色方块会上移动不方便设置）；然后增大它的 <em>z-index</em> 为 1。</p><p>:warning: 不用设置红色方块  <em><strong>.red</strong></em> 的 <em>position</em> 属性??</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.blue</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#8EC4D0</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;  </span><br><span class="line">    <span class="attribute">z-index</span>:<span class="number">1</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566120621698.png" alt="1566120621698"></p><h3 id="浮动：float">浮动：<em>float</em></h3><p>无论多么复杂的布局，基本出发点：<u>如何在一行显示多个<em>div</em>元素</u> 。这就用到了浮动，浮动只有两个关键字设置：</p><ul><li><em>left</em>：左浮动</li><li><em>right</em>：右浮动</li></ul><p>设置为浮动的框，<em>会脱离文档流向左或向右移动</em>，它们的移动规则是：</p><ul><li><p>多个元素浮动，从上至下依次向左、向右浮动</p></li><li><p>假设 <em>div</em> 元素A是浮动的，如果A元素上一个元素也浮动则紧跟其后（如果一行能放下）；如果A元素上一个元素不浮动（是标准流中元素），那么相对垂直位置不会改变（顶部和其底部同一条水平线，但可以对应左、右移动）</p></li><li><p>浮动元素总是飘浮在标准流之上（理解为<em>z-index</em>大）</p></li></ul><p>比如，存在下图4个非浮动<em>div</em> 元素：</p><p><img src="https://images0.cnblogs.com/blog/471788/201303/27004951-2cdc11e4340c484ab8a7eb8f515a683e.png" alt="img"></p><blockquote><p>设置 <em>div2</em> ：向右浮动，试分析结果？</p></blockquote><p>首先，<em>div2</em> 脱离标准流所以释放空间，下方<em>div3</em>、<em>div4</em> 向上移动。而<em>div2</em> 上一个块元素<em>div1</em> 不是浮动元素，所以相对<em>div2</em> 垂直位置不变（顶部和其底部同一条水平线，表现为不向上浮动），但是会向右浮动，故最后结果是：</p><p><img src="https://images0.cnblogs.com/blog/471788/201303/27005121-3bfe4640443c4cd19c850857cc1ce39b.png" alt="img"></p><blockquote><p>设置<em>div2</em>、<em>div3</em>、<em>div4</em>：向右浮动，试分析结果？</p></blockquote><p><em>div2</em>、<em>div3</em>、<em>div4</em> 都脱离标准流，多个元素浮动，从上至下则<em>div2</em>先右浮动，由于<em>div2</em> 上一个元素<em>div1</em> 不浮动故保持相对垂直位置不变（表现为不上浮），整体只移动到右端。</p><p>然后<em>div3</em> 向上浮动，由于它的上一个元素<em>div2</em> 是浮动的，所以紧靠其后。<em>div4</em>同理，紧靠<em>div3</em> 后。</p><p>故最终结果是：<br><img src="https://images0.cnblogs.com/blog/471788/201303/27005405-331c3a369d5c4bfb8692c40ac3e59bf9.png" alt="img"></p><h4 id="浮动与文字">浮动与文字</h4><blockquote><p>首先我们观察网页：设置图片向左浮动后，生成的文字环绕图片。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566185452421.png" alt="1566185452421"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">img</span> </span></span><br><span class="line"><span class="css">&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3388481411,1093632805&amp;fm=26&amp;gp=0.jpg&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">余告之曰：其形也，翩若惊鸿，婉若游龙。荣曜秋菊，华茂春松。髣髴兮若轻云之蔽月，飘飖兮若流风之回雪。远而望之，皎若太阳升朝霞；迫而察之，灼若芙蕖出渌波。秾纤得中，修短合度。肩若削成，腰如约素。延颈秀项，皓质呈露。芳泽无加，铅华弗御。云髻峨峨，修眉联娟。丹唇外朗，皓齿内鲜。明眸善睐，靥辅承权。瓌姿艳逸，仪静体闲。柔情绰态，媚于语言。奇服旷世，骨像应图。披罗衣之璀粲兮，珥瑶碧之华琚。戴金翠之首饰，缀明珠以耀躯。践远游之文履，曳雾绡之轻裾。微幽兰之芳蔼兮，步踟蹰于山隅。于是忽焉纵体，以遨以嬉。左倚采旄，右荫桂旗。攘皓腕于神浒兮，采湍濑之玄芝。</span><br><span class="line">余情悦其淑美兮，心振荡而不怡。无良媒以接欢兮，托微波而通辞。愿诚素之先达，解玉佩而要之。嗟佳人之信修，羌习礼而明诗。抗琼珶以和予兮，指潜川而为期。执眷眷之款实兮，惧斯灵之我欺。感交甫之弃言兮，怅犹豫而狐疑。收和颜而静志兮，申礼防以自持。</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>:grey_question: 令人困惑的是：<em>图片设置浮动已经脱离文档流不应该释放了空间不再影响布局了，为什么文字还能环绕它呢？</em></p><p>就像我们修改图片为绝对定位：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文字不再环绕，而是好像当图片不存在一样：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566185705499.png" alt="1566185705499"></p><p>这也就是绝对定位和浮动的最大区别，虽然它们都脱离了文档流：</p><ul><li>绝对定位不会影响布局好像它不存在一样；<em><strong>但浮动会影响布局，其它内容（包括元素？）会围绕它</strong></em> 。</li></ul><h3 id="清除浮动：clear">清除浮动：<em>clear</em></h3><p>经过上面浮动学习：元素浮动之前在标准流中，是 <u>竖向排列</u> 的，而浮动之后可以理解为 <u>横向排列</u>。</p><p>而清除浮动可以 <u>打破横向排列</u> ，但是 <em><strong>清除浮动只能在需要被影响的元素内使用</strong></em>  ，请看下例：</p><blockquote><p>已知下列 <em>div1</em>、 <em>div2</em> 元素都是左浮动从而在一行显示，如何使  <em>div2</em> 移至下一行打破横向排列？</p></blockquote><p><img src="https://images0.cnblogs.com/blog/471788/201303/27005535-a73c3a18ef8b432496fbaa26b532d9da.png" alt="img"></p><p>如果我们增加<em>CSS</em> 样式，设置  <em>div1</em> 右边不允许有浮动元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div1</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">clear</span><span class="selector-pseudo">:right</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>很不幸，这是不起作用的！我们希望<em>div2</em> 移动到下一行，那么<em>被影响的是 div2，所以只能设置 div2 左边不允许存在浮动元素</em>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div2</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">clear</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样就可以使得 <em>div2</em> 向下移动一行。</p><p><img src="https://images0.cnblogs.com/blog/471788/201303/27005603-199c35bf7d07478599bf355e3fb8aecf.png" alt="img"></p><blockquote><p>那么，下列 <em>div1</em>、 <em>div2</em> 元素都是右浮动，如何使得<em>div2</em> 移至 <em>div1</em> 下边呢？</p></blockquote><p><img src="https://images0.cnblogs.com/blog/471788/201303/27005626-2408e35fd5f74faa92e46df37c04974d.png" alt="img"></p><p>同上，被影响的是  <em>div2</em> 元素，那么不允许 <em>div2</em> 右边存在浮动元素即可：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div2</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">clear</span><span class="selector-pseudo">:right</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://images0.cnblogs.com/blog/471788/201303/27005712-4f0ff1cbbd30482694190d93834bd570.png" alt="img"></p><h3 id="溢出：overflow">溢出：<em>overflow</em></h3><p>当父元素不设置高度时候，高度随内容增加自适应高度。但是当我们指定了父元素的高度，如何解决内容增加溢出问题呢？</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566128192545.png" alt="1566128192545"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">     <span class="selector-tag">div</span></span></span><br><span class="line"><span class="css">     &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">850px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: LightBlue;</span></span><br><span class="line"><span class="css">     &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;none&quot;</span>&gt;</span></span><br><span class="line">        苏子愀（qiǎo）然，正襟危坐，而问客曰：“何为其然也？”客曰：“‘月明星稀，乌鹊南飞’,此非曹孟德之诗乎？西望夏口，东望武昌。山川相缪(liáo)，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳(zhú)舻(lú)千里，旌(jīng)旗蔽空，酾(shi)酒临江，横槊(shuò)赋诗，固一世之雄也，而今安在哉?况吾与子渔樵(qiáo)于江渚(zhǔ)之上，侣鱼虾而友麋(mí)鹿,驾一叶之扁舟，举匏（páo）樽以相属（zhǔ）。寄蜉(fú)蝣(yóu)于天地，渺沧海之一粟(sù)。哀吾生之须臾(yú)，羡长江之无穷。挟（xié）飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。”　</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以通过设置<em>overflow</em> 属性值（关键字）：</p><ul><li><em>visible</em>：默认值，超出内容依旧可以显示但是会溢出框</li><li>scroll：阻止溢出框，超出部分可以拖动滚动条显示（<em><strong>无论是否溢出都显示滚动条</strong></em>）</li><li><em>hidden</em>：隐藏内容溢出部分，溢出部分不可见</li><li><em>auto</em>：如果内容溢出自动出现滚动条阻止溢出</li></ul><h4 id="overflow：hidden-浮动-崩塌"><em>overflow：hidden</em> &amp; 浮动 &amp; 崩塌</h4><p><em>overflow：hidden</em> 在前面我们介绍可以隐藏溢出内容，它还有以下功能：</p><ul><li>清除浮动：解决由于父元素不设置高度，子元素都是浮动元素使得父元素高度为0的问题</li><li>解除坍缩：解决父、子元素非浮动元素，第一个子元素设置<em>margin-top</em>属性 ，等价父元素设置该属性问题</li></ul><h5 id="清除浮动">清除浮动</h5><p>在前我们知道，父级元素 <em><strong>不设置高度时</strong></em>，高度随着内容增加自动适应。</p><p>但是当子元素此时设置了浮动<em>float</em> ，由于子元素已经脱离了文档流，父元素<em>检测不到子元素高度，那么父元素高度 == 0</em>。</p><ul><li>子元素浮动依旧显示，只是父元素高度为0好似隐藏了</li><li>如果设置了父元素高度，子元素可以重新显示，超出部分溢出</li></ul><blockquote><p>比如下面黑色父级<em>div</em>包含了两个蓝、红子级<em>div</em> 。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566130159410.png" alt="1566130159410"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"> <span class="selector-class">.div</span></span></span><br><span class="line"><span class="css"> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: black;</span></span><br><span class="line"><span class="css"> &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.div1</span></span></span><br><span class="line"><span class="css">&#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.div2</span></span></span><br><span class="line"><span class="css">&#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们把两个子级<em>div</em> 设置为浮动：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div1</span>,<span class="selector-class">.div2</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>神奇的发现子级<em>div1、div2</em> 存在而黑色父级<em>div</em> 消失了！其实也就是高度变为0了。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566130342219.png" alt="1566130342219"></p><p>我们有三种解决办法：</p><ul><li><p>第一种：给父元素设置高度 = 100，使得父级元素不因为子元素都为浮动元素，高度自动=0</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566179636189.png" alt="1566179636189"></p></li><li><p>第二种：黑色父级<em>div</em> 设置 <em>overflow：hidden</em> ，使得父级元素可以包含浮动子元素</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566179636189.png" alt="1566179636189"></p><p>父级<em>div</em> 出现了，允许子元素为浮动元素：高度为子元素高度，<em><strong>宽度因为div 是块元素占据一行</strong></em>。</p></li><li><p>第三种：设置 父元素为浮动 <em>float:<strong>left</strong></em>，注意这种方法会使得父元素不再有块 <em><u>独占一行</u></em> 的特性</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566180027694.png" alt="1566180027694"></p><p>乍看好像父级元素没有出现，但我们审查元素可发现<em>div</em> 父级标签：高度 = 子元素高度，<em><strong>宽度也因为设置浮动不再独占一行自动调整为子元素宽度</strong></em>。</p><p>特别的：如果我们设置父元素为浮动 <em>float:<strong>right</strong></em>，而子元素都是左浮动，会以父元素为准：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566180880954.png" alt="1566180880954"></p></li></ul><h5 id="避免崩塌">避免崩塌</h5><p>首先我们来认识什么是崩塌？依旧以最开始示例为例：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566130159410.png" alt="1566130159410"></p><p>我们尝试给第一个子元素 <em>div1</em> 设置外边距上为50px：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div1</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">margin-top</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们期待得到的效果是：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566181881931.png" alt="1566181881931"></p><p>但实际是：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566181934864.png" alt="1566181934864"></p><p>就好像是给<u>父级元素<em>div</em> 设置了：<em>margin-top:50px</em></u> 。要解决这个问题我们可以：</p><ul><li>给父元素<em>div</em> 设置 <em>overflow：hidden</em> ，这样可以得到我们期待的效果</li></ul><p>由上我们得知满足崩塌的条件：</p><ul><li>父元素、子元素都不是浮动元素</li><li><em><strong>第一个</strong></em>子元素设置了 <em>margin-top</em>属性</li></ul><p>聪明的你也已经想到，如果子元素是浮动元素也可以完全避免崩塌（无论父元素是否浮动）。这里不详述。</p><h1>第二部分：CSS3</h1><h2 id="基础样式">基础样式</h2><h3 id="圆角：border-radius">圆角：<em>border-radius</em></h3><p>我们知道在CSS世界里，万物皆为框，每个元素都可视作为框。通过 <em>border-radius</em>  属性可指定圆<u>半径</u>为R，<em><strong>把元素框 R*R正方形四角换成  ----&gt; 半径为 R的1/4圆形</strong></em>。</p><p>怎么理解 <em>把元素框正方形四角换成1/4圆形</em> ？</p><blockquote><p>比如我们指定<em>div</em> 元素：宽 = <em>150px</em>，高 = <em>100px</em> ，圆半径为<em>50px</em> 。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566353422527.png" alt="1566353422527"></p><p>可以看到，原 <em>150px*100px</em> 矩形，它对应四角 <em>50px*50px</em> 矩形区域被替换成半径 = <em>50px</em> 的半圆。</p><p>:warning: 必须设置：<em><strong>圆半径  ≤ {1/2 宽，1/2 高} <sub>min </sub></strong></em>，如果超过则形成图形等价于：圆半径 = {1/2 宽，1/2 高}<sub>min </sub></p><blockquote><p>那么怎么生成圆形呢？</p></blockquote><p>显然，当框宽高相等恰为正方形，我们在把生成的四个1/4圆半径 = 1/2正方形边长。那么便可形成圆形。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566354382063.png" alt="1566354382063"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:aquamarine; </span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">75px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进一步理解">进一步理解</h4><p>在前面我们理解<em>border-radius</em> 属性为：</p><ul><li><p>指定圆<u>半径</u>为R，<em><strong>把元素框 R*R正方形四角换成  ----&gt; 半径为 R的1/4圆形</strong></em>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: <span class="number">50px</span>;</span><br></pre></td></tr></table></figure></li></ul><p>实际应该为：</p><ul><li><p>指定<u>长、短半径</u>为R1、R2，<em><strong>把元素框 R1*R2矩形四角换成  ----&gt; 长、短半径分别为 R1、R2的1/4椭圆形</strong></em>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: <span class="number">50px</span> / <span class="number">40px</span>;  <span class="comment">/* 只指定其中一个长度，则长短半径相等，也就是1/4圆 */</span></span><br></pre></td></tr></table></figure><p>甚至你还可以依次指定：左上 --&gt; 右上 --&gt; 右下 —&gt; 左下的1/4椭圆长短半径（顺时针）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>:  <span class="number">50px</span> <span class="number">40px</span> <span class="number">30px</span> <span class="number">20px</span> / <span class="number">40px</span> <span class="number">30px</span> <span class="number">20px</span> <span class="number">10px</span> ;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>尝试把指定<em>div</em> 元素：宽 = <em>150px</em>，高 = <em>100px</em> ，变为椭圆形 。</p></blockquote><p>显然，只要把四角：长半径 = 1/2 宽，短半径 = 1/2 高的四个1/4椭圆形即可：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566355724583.png" alt="1566355724583"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:aquamarine;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">75px</span> / <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="伪元素-before、-after">伪元素 <em>::before、::after</em></h3><p>在前面我们有一个概念叫做 <em>伪类</em> ，一种用来描述状态的关键字 ：</p><ul><li>常用伪类：<em>:hover、:link、:active、:target、:not()、:focus</em> 等</li></ul><p>而常用伪元素有：</p><ul><li>常用伪元素：<em>::first-letter、::first-line、::before、::after、::selection</em> 等</li></ul><p>其中伪元素 <em>::before、::after</em>，特有<em><strong>content</strong></em>样式用来给<u>内容元素 前、后 插入额外的元素</u> 。</p><p>为什么称伪元素为 “伪” ？它有什么特点呢？</p><ul><li><em>无法审查</em>：实际在DOM文档中没有生成这些元素，只是表面可见，审查元素没有生成</li><li><em>content</em> ：特有<em>content</em>样式，用于添加内容，可以为空但不能省略！</li></ul><p>利用伪元素可以做出一些非常有意思的功能，比如各种图形、小图标等。</p><h4 id="生成图形：菱形、六角星等">生成图形：菱形、六角星等</h4><blockquote><p>试分析：下面菱形生成代码。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566375169019.png" alt="1566375169019"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#test</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">     <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">     <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid red;</span><br><span class="line">     <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#test</span>:after</span><br><span class="line"> &#123;</span><br><span class="line">     content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">     <span class="attribute">position</span>: absolute;</span><br><span class="line">     <span class="attribute">left</span>: -<span class="number">50px</span>;</span><br><span class="line">     <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">     <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">     <span class="attribute">border-top</span>: <span class="number">50px</span> solid red;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>生成上三角</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#test</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">     <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">     <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid red;</span><br><span class="line">     <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前面 <em>border</em> 属性设置我们可以这么生成上三角：</p><ul><li><p>宽高设置为0后，上下左右四个边框角都设置为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>-x: <span class="number">50px</span> solid transparent;</span><br></pre></td></tr></table></figure></li><li><p>然后 <em>border-bottom</em> 、 <em>border-top</em>颜色设置为红色，<em>border-left、border-right</em> 设置为透明：</p></li></ul><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566375707762.png" alt="1566375707762"></p><ul><li>最后删除掉<em>border-top</em>  属性设置，使得只保留下半部分，至此成功生成上三角：</li></ul><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566375755125.png" alt="1566375755125"></p></li></ol><p>最后设置的 <code>position: relative</code> 属性是为了方便接下来生成的伪元素进行绝对定位。</p><ol start="2"><li><p>生成下三角</p><p>照猫画虎我们生成一个下三角：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566376273370.png" alt="1566376273370"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#test</span>:after</span><br><span class="line"> &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;   <span class="comment">/* 为空，但不能省略*/</span> </span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">50px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这我们对生成的下三角的初始位置不禁有些疑惑：</p><blockquote><p>下三角伪元素是绝对定位：<em>即相对于最近设置了position属性的祖先元素 ，如果没有则是包含它的框</em>。</p><p>按照这个理论，<em>#test</em> 并不是 <em>#test::after</em> 的祖先元素为什么还相对它定位呢？</p></blockquote><p>这个不太清楚暂不提。</p><blockquote><p>为什么 <em>#test::after</em> 绝对定位起点是*#test* 上中心点（红色三角形顶点）？不应该是左上角吗？</p></blockquote><p>第一：绝对定义不是相对于元素框的左上角，而是内容部分左上角。</p><p>第二：由于内容部分为0，所以内容左上角就是框中心点。</p><p>第三：又因为框上半部分没有，中心点上移，也就是现在红色三角形的顶点。</p></li><li><p>调整定位</p><p>最后我们调整一下生成的下三角形在上三角下方，即可生成一个菱形：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#test</span>:after</span><br><span class="line">&#123;</span><br><span class="line">    left: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566375169019.png" alt="1566375169019"></p><h4 id="制作小图标">制作小图标</h4><blockquote><p>尝试制作做下面：列表左侧下三角下拉图标，注意大小。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1566382243628.png" alt="1566382243628"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">div</span> <span class="selector-tag">ul</span></span></span><br><span class="line"><span class="css">&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#catalog</span> <span class="selector-tag">ul</span><span class="selector-pseudo">::before</span></span></span><br><span class="line"><span class="css">&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-top</span>: <span class="number">8px</span> solid red;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-right</span>: <span class="number">8px</span> solid transparent;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-left</span>: <span class="number">8px</span> solid transparent;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">18px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">6px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">div</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span></span></span><br><span class="line"><span class="css">&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">text-indent</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">list-style-type</span>: none;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;catalog&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span>我是下拉框</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是下拉1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是下拉2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是下拉3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础（一）JavaScript基础笔记（下）</title>
      <link href="/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>第五章：浏览器</h1><h2 id="5-1-浏览器常用对象">5.1 浏览器常用对象</h2><h3 id="window"><em>window</em></h3><p><em>window</em> 对象不但充当全局作用域，而且表示 <u>浏览器窗口</u>，常用属性如下：</p><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><em>innerWidth</em></td><td style="text-align:center">内宽度，不包含菜单栏、工具栏等占位元素</td></tr><tr><td style="text-align:center"><em>innerHeight</em></td><td style="text-align:center">内高度，不包含菜单栏、工具栏等占位元素</td></tr></tbody></table><h3 id="screen"><em>screen</em></h3><p><em>screen</em> 对象表示 <u>屏幕</u> 的信息，常用属性有：</p><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><em>width</em></td><td style="text-align:center">屏幕宽度，以像素为单位</td></tr><tr><td style="text-align:center"><em>height</em></td><td style="text-align:center">屏幕高度，以像素为单位</td></tr><tr><td style="text-align:center"><em>colorDepth</em></td><td style="text-align:center">颜色位数，如16</td></tr></tbody></table><h3 id="navigator"><em>navigator</em></h3><p><em>navigator</em> 对象表示 <u>浏览器</u> 信息，常用属性有：</p><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><em>appName</em></td><td style="text-align:center">浏览器名称</td></tr><tr><td style="text-align:center"><em>appVersion</em></td><td style="text-align:center">浏览器版本</td></tr><tr><td style="text-align:center"><em>language</em></td><td style="text-align:center">浏览器语言</td></tr><tr><td style="text-align:center"><em>platform</em></td><td style="text-align:center">操作系统类型</td></tr><tr><td style="text-align:center"><em>userAgent</em></td><td style="text-align:center">浏览器设定的 <em>user-Agent</em> 字符串</td></tr></tbody></table><h3 id="location"><em>location</em></h3><p><em>location</em> 对象表示 <u>当前页面<em>URL</em></u> 信息，常用属性有：</p><blockquote><p>以 <em><a href="http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP">http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</a></em> 为例。</p></blockquote><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><em>href</em></td><td style="text-align:center">完整地址：上面全部蓝字域名</td></tr><tr><td style="text-align:center"><em>protocol</em></td><td style="text-align:center">协议名： http</td></tr><tr><td style="text-align:center"><em>host</em></td><td style="text-align:center">域名： <a href="http://www.example.com">www.example.com</a></td></tr><tr><td style="text-align:center"><em>port</em></td><td style="text-align:center">端口： 8080</td></tr><tr><td style="text-align:center"><em>pathname</em></td><td style="text-align:center">路径名： /path/index.html</td></tr><tr><td style="text-align:center"><em>search</em></td><td style="text-align:center">查询？：?a=1&amp;b=2</td></tr><tr><td style="text-align:center"><em>hash</em></td><td style="text-align:center">哈希？：TOP</td></tr></tbody></table><p>还可以利用对象方法：</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center"><em>reload()</em></td><td style="text-align:center"><em>location.reload();</em>  // 重新加载当前界面</td></tr><tr><td style="text-align:center"><em>assign()</em></td><td style="text-align:center"><em>location.assign(‘<a href="https://www.baidu.com">https://www.baidu.com</a>’);</em>  // 当前界面打开百度，必须带有协议类型！</td></tr></tbody></table><h3 id="history"><em>history</em></h3><p>已不推荐使用，简单介绍常用方法：</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center"><em>back()</em></td><td style="text-align:center"><em>history.back()</em>     // 相当点击浏览器后退按钮</td></tr><tr><td style="text-align:center"><em>forward()</em></td><td style="text-align:center"><em>history.forward()</em>   // 相当点击浏览器前进按钮</td></tr></tbody></table><blockquote><p>不推荐使用的一个实例场景。</p></blockquote><p>如果我们在登陆成功调用 <em>history.back()</em> 试图回到登陆前界面，又要重新登陆了！</p><h3 id="document"><em>document</em></h3><p><em>document</em> 对象是浏览器中 <u>DOM树根节点</u> ，可利用它进行操作DOM、获取cookie等，常用属性如下：</p><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center"><em>cookie</em></td><td style="text-align:center"><em>document.cookie()</em>  // 获取 <em>cookie</em></td></tr></tbody></table><p>更多操作DOM，详见下节分解。</p><h2 id="5-2-操作DOM">5.2 操作DOM</h2><h3 id="1-获取节点">1.获取节点</h3><h4 id="getElementBy…-获取节点"><em>getElementBy…()</em> 获取节点</h4><p>注：标签也可称为元素、节点。</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><em>getElementById()</em></td><td style="text-align:center">根据 <u>标签ID属性</u> 来获取节点</td></tr><tr><td style="text-align:center"><em>getElementByName()</em></td><td style="text-align:center">根据 <u>name属性</u> 来获取节点</td></tr><tr><td style="text-align:center"><em>getElementByClassName()</em></td><td style="text-align:center">根据 <u>标签class属性</u> 来获取节点</td></tr><tr><td style="text-align:center"><em>getElementByTagName()</em></td><td style="text-align:center">根据 <u>标签名</u> 来获取节点，如div、img</td></tr></tbody></table><blockquote><p>一些简单操作实例。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回ID为&#x27;test&#x27;的节点：</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点test下的所有直属[子节点]:</span></span><br><span class="line"><span class="keyword">var</span> cs = test.children;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点test下第一个、最后一个[子节点]：</span></span><br><span class="line"><span class="keyword">var</span> first = test.firstElementChild;</span><br><span class="line"><span class="keyword">var</span> last = test.lastElementChild;</span><br></pre></td></tr></table></figure><h4 id="CSS选择器获取节点"><em>CSS</em>选择器获取节点</h4><p>我们也可以利用 <u>CSS选择器 <em>selector</em> 语法</u>来获取节点：</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><em>querySelector(selector)</em></td><td style="text-align:center">获取满足条件的第一个节点</td></tr><tr><td style="text-align:center"><em>querySelectorAll(selector)</em></td><td style="text-align:center">获取满足条件的所有节点</td></tr></tbody></table><p>基本选择器用法：</p><table><thead><tr><th style="text-align:center">选择器类型</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center">标签选择器：<code>标签名</code></td><td style="text-align:center"><em>document.querySelector(“div”)</em> //  获取第一个div标签节点</td></tr><tr><td style="text-align:center">类选择器：<code>.类名</code></td><td style="text-align:center"><em>document.querySelector(“.key”)</em> // 获取第一个class = key节点</td></tr><tr><td style="text-align:center">ID选择器：<code>#ID名</code></td><td style="text-align:center"><em>document.querySelector(“#uid”)</em> // 获取第一个ID = uid 节点</td></tr><tr><td style="text-align:center">属性选择器：<code>[属性=属性名]</code></td><td style="text-align:center"><em>document.querySelector(“[type=text]”)</em> // 获取第一个name =&quot; text&quot; 节点</td></tr></tbody></table><h5 id="层级选择器">层级选择器</h5><p>我们还可以进行选择器组合筛选指定元素后代：</p><table><thead><tr><th style="text-align:center">关系选择器组合</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>A B</code></td><td style="text-align:center">匹配A元素中的子元素B，B可以是A <u>任意级别后代</u></td></tr><tr><td style="text-align:center"><code>A &gt; B</code></td><td style="text-align:center">匹配A元素中的下级子元素B，只能是 <u>直系后代</u></td></tr><tr><td style="text-align:center"><code>A + B</code></td><td style="text-align:center">匹配A元素中的任一下一个兄弟元素B（同级）</td></tr><tr><td style="text-align:center"><code>B ~ E</code></td><td style="text-align:center">匹配B元素后面的拥有共同父元素的兄弟元素E</td></tr></tbody></table><h5 id="过滤器">过滤器</h5><p>过滤器一般不单独使用，附加到选择器上更精确定位元素 ：<code>&lt;选择器&gt;：&lt;元素状态关键字&gt;</code></p><p>:warning: 在<em>jQuery</em> 中冒号<code>： </code>和选择器前一定要有空格！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;#test-form:radio&#x27;);    // 错误写法：无法选择表单中单选框</span><br><span class="line">$(&#x27;#test-form :radio&#x27;);   // 正确写法，要有空格！</span><br></pre></td></tr></table></figure><blockquote><p>指定选定元素处于何种状态时的CSS样式 。</p></blockquote><ul><li><p>指定a标签处于各种状态的样式</p><blockquote><p>以 在CSS中修改不同状态<em>a</em> 标签颜色为例。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// link-匹配当前元素连接</span></span><br><span class="line"><span class="attr">a</span> :link &#123;<span class="attr">color</span>: slategray;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// visited-匹配已访问过的连接</span></span><br><span class="line"><span class="attr">a</span> :link &#123;<span class="attr">color</span>: #4b2f89;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// active-匹配元素当中激活状态（鼠标悬停）的链接</span></span><br><span class="line"><span class="attr">a</span> :active &#123;<span class="attr">color</span>: blue;&#125;</span><br><span class="line">             </span><br><span class="line"><span class="comment">// hover-匹配元素当中未激活状态的链接</span></span><br><span class="line"><span class="attr">a</span> :hover &#123;<span class="attr">color</span>: blue;&#125;             </span><br></pre></td></tr></table></figure></li><li><p>匹配一组兄弟元素某元素</p><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center"><em>:first-child</em></td><td style="text-align:center">匹配一组p标签第一个p标签：<em>p:first-child</em></td></tr><tr><td style="text-align:center"><em>:nth-child()</em></td><td style="text-align:center">匹配一组p标签第一个p标签：<em>p:nth-child(1)</em></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">匹配表格中的奇数行：<em>tr:nth-child(2n+1)</em></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">匹配表格中的偶数行：<em>tr:nth-child(2n)</em></td></tr></tbody></table><p>更多：<em>:nth-last-child(an + b)、:nth-of-type(an+b)、:last-of-type</em> …</p></li><li><p>表单相关</p><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center"><em>:input</em></td><td style="text-align:center">选择 <u>表单</u> 以下标签：<code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>，<code>&lt;select&gt;</code>和<code>&lt;button&gt;</code></td></tr><tr><td style="text-align:center"><em>:enabled</em></td><td style="text-align:center">选择 <u>表单</u> 可以正常输入的<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code> ：<em>$(‘#test-form :enabled’)</em></td></tr><tr><td style="text-align:center"><em>:disabled</em></td><td style="text-align:center">选择 <u>表单</u> 那些不能输入的 <code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>：<em>$(‘#test-form :disabled’)</em></td></tr><tr><td style="text-align:center"><em>:file</em></td><td style="text-align:center">选择文件： <em>input : file   === input[type=file]</em></td></tr><tr><td style="text-align:center"><em>:checkbox</em></td><td style="text-align:center">选择复选框：<em>input : checkbox=== input[type=checkbox]</em></td></tr><tr><td style="text-align:center"><em>:radio</em></td><td style="text-align:center">选择单选框：<em>input : radio   === input[type=radio]</em></td></tr><tr><td style="text-align:center"><em>:focus</em></td><td style="text-align:center">选择当前输入焦点：例如把光标放到一个<code>&lt;input&gt;</code>上，<em>$(‘input:focus’)</em> 便可选中</td></tr><tr><td style="text-align:center"><em>:checked</em></td><td style="text-align:center">选择当前勾上的单选框和复选框：<em>$(‘input[type=radio]:checked’)</em></td></tr></tbody></table><blockquote><p>选择表单<em>id = test-form</em> 下所有 <code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>，<code>&lt;select&gt;</code>和<code>&lt;button&gt;</code> 节点。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法用：document.querySelectorALL(&#x27;#test-form :input&#x27;) ？？</span></span><br><span class="line">$(<span class="string">&#x27;#test-form :input&#x27;</span>);   </span><br></pre></td></tr></table></figure></li><li><p>其它更多</p><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center"><em>:empty</em></td><td style="text-align:center">匹配没有子元素的元素</td></tr><tr><td style="text-align:center"><em>:target</em></td><td style="text-align:center">用于匹配URI中的ID标识（即：锚点）部分</td></tr></tbody></table></li></ul><h4 id="获取节点基本信息">获取节点基本信息</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;user&#x27;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以获取基本属性等信息，不存在的属性字符串类型返回空字符串 <code>“”</code> ，布尔类型默认返回 <code>false</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> u = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#user&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取存在的属性</span></span><br><span class="line">u.type;    <span class="comment">// &quot;text&quot;</span></span><br><span class="line">u.id;      <span class="comment">// &quot;user&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取不存在的属性</span></span><br><span class="line">u.name;    <span class="comment">// &quot;&quot;</span></span><br><span class="line">u.checked; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文本框值</span></span><br><span class="line">u.value ;  <span class="comment">// &quot;hwh&quot;，已经在文本框中输入hwh</span></span><br></pre></td></tr></table></figure><h3 id="2-更新DOM">2.更新DOM</h3><h4 id="更新DOM节点文本">更新DOM节点文本</h4><p>我们常用以下属性对DOM节点文本内容进行修改：</p><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center"><em>innerHTML</em></td><td style="text-align:center">可以插入HTML标签 &amp; 字符串</td></tr><tr><td style="text-align:center"><em>innerText</em></td><td style="text-align:center">只能插入字符串，插入HTML标签会解析成字符串</td></tr><tr><td style="text-align:center"><em>textContent</em></td><td style="text-align:center">同上，但会返回所有文本包括隐藏文本</td></tr></tbody></table><blockquote><p>更新标签、字符串实例。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span> test <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line">c.innerText; <span class="comment">// 输出：&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.插入HTML</span></span><br><span class="line">c.innerHTML = <span class="string">&#x27;&lt;p&gt; hello test!&lt;/p&gt;&#x27;</span>;      <span class="comment">// 打开浏览器div标签内输出：hello test!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.插入字符串</span></span><br><span class="line">c.innerText = <span class="string">&#x27;&lt;p&gt; hello test!&lt;/p&gt;&#x27;</span>;      <span class="comment">// 打开浏览器div标签内输出：&lt;p&gt; hello test!&lt;/p&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.插入字符串</span></span><br><span class="line">c.textContent = <span class="string">&#x27;&lt;p&gt; hello test!&lt;/p&gt;&#x27;</span>;    <span class="comment">// 打开浏览器div标签内输出：&lt;p&gt; hello test!&lt;/p&gt;</span></span><br></pre></td></tr></table></figure><h4 id="更新CSS样式">更新CSS样式</h4><p>获取节点后，利用 <em>style</em> 属性进行样式设置。</p><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center"><em>style</em></td><td style="text-align:center">DOM节点 <em>style</em> 属性对应所有的CSS，可直接获取OR设置。</td></tr></tbody></table><blockquote><p>进行简单CSS样式设置。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置CSS</span></span><br><span class="line">c.style.color = <span class="string">&#x27;#ff0000&#x27;</span>;</span><br><span class="line">c.style.fontSize = <span class="string">&#x27;1200px&#x27;</span>;</span><br></pre></td></tr></table></figure><p>:warning: 注意 <u><em>fontSize</em></u> 等在<em>javaScript</em> 中是驼峰命名，而在CSS中是 <u><em>font-size</em></u>  ！</p><h3 id="3-插入DOM">3.插入DOM</h3><p>在前我们利用：<code>c.innerHTML = '&lt;p&gt; hello test!&lt;/p&gt;';</code>  可以在<code>&lt;div&gt; ... &lt;/div&gt;</code>插入HTML标签，但是会替换掉里面所有DOM节点内容。</p><p>为此我们可以利用以下方法：</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center"><em>appendChild(newElem)</em></td><td style="text-align:center">添加子节点<em>newElem</em> 为当前父节点对象 <u>最后一个子节点</u></td></tr><tr><td style="text-align:center"><em>insertBefore(newElem，ref)</em></td><td style="text-align:center">添加子节点<em>newElem</em> 为当前父节点对象 <u>另一个子节点<em>ref</em>前</u></td></tr></tbody></table><p>下面为预设好的HTML结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;programLanguage&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;C#&quot;</span>&gt;</span>C#<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;C&quot;</span>&gt;</span>C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>java<span class="tag">&lt;/<span class="name">li</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>创建一个新节点：<code>&lt;li id=&quot;javascript&quot;&gt;javascript&lt;/li&gt;</code> 插入到列表末尾。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul_pl = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;programLanguage&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新节点</span></span><br><span class="line"><span class="keyword">var</span> li_js =  <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">li_js.id = <span class="string">&#x27;python&#x27;</span>;</span><br><span class="line">li_js.innerText = <span class="string">&#x27;javaScript&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入到末尾</span></span><br><span class="line">ul_pl.appendChild(li_js);</span><br></pre></td></tr></table></figure><blockquote><p>创建一个新节点：<code>&lt;li id=&quot;C++&quot;&gt;C++&lt;/li&gt;</code> 插入到列 <code>python</code> 前。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul_pl = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;programLanguage&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> li_py = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;python&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新节点</span></span><br><span class="line"><span class="keyword">var</span> li_cpp =  <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">li_cpp.id = <span class="string">&#x27;C++&#x27;</span>;</span><br><span class="line">li_cpp.innerText = <span class="string">&#x27;C++&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入到末尾</span></span><br><span class="line">ul_pl.insertBefore(li_cpp,li_py);</span><br></pre></td></tr></table></figure><h3 id="4-删除DOM">4. 删除DOM</h3><p>要删除一个节点，首先要获得该节点本身以及它的父节点，然后调用父节点的<code>removeChild()</code>把自己删掉：</p><blockquote><p>删除指定列表第三个节点。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul_pl = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;programLanguage&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取列表第三个子节点</span></span><br><span class="line"><span class="keyword">var</span> li3 = ul_pl.children[<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 调用该付节点删除该子节点</span></span><br><span class="line">ul_pl.removeChild(li3);</span><br></pre></td></tr></table></figure><p>:warning: 注意：</p><ul><li>DOM树中节点虽然被删除，但是还在内存中，可以随时被添加到别的位置</li><li><code>children</code>属性 <u>实时变化</u>，删除后<code>父节点.chidren</code>返回的列表会对应减少</li></ul><h2 id="5-3-操作表单">5.3 操作表单</h2><h3 id="常用表单元素">常用表单元素</h3><p>&lt;form&gt; 元素定义 HTML 表单，收集用户输入 ：<code>&lt;form&gt;... 表单元素...&lt;/form&gt;</code> 。以下是常用表单元素：</p><center>常用表单元素</center><table><thead><tr><th style="text-align:center">表单元素</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">&lt;input&gt;</td><td style="text-align:center">最重要的表单元素，含有<u>不同类型的 input 元素</u> 、复选框、单选按钮、提交按钮等。</td></tr><tr><td style="text-align:center">&lt;select&gt;</td><td style="text-align:center">定义下拉列表：<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565230361276.png" alt="1565230361276"></td></tr><tr><td style="text-align:center">&lt;textarea&gt;</td><td style="text-align:center">定义多行输入文本域：<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565230342229.png" alt="1565230342229"></td></tr><tr><td style="text-align:center">&lt;button&gt;</td><td style="text-align:center">按钮：点击后出发onclick事件代码，输出Hello World!<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565230477491.png" alt="1565230477491"></td></tr></tbody></table><p><u>不同类型的 input 元素</u> ：有复选框、单选按钮、提交按钮等：</p><center>常用input类型</center><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><em>text</em></td><td style="text-align:center">文本输入：<code>&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</code></td></tr><tr><td style="text-align:center"><em>password</em></td><td style="text-align:center">密码输入：<code>&lt;input type=&quot;password&quot; name=&quot;psw&quot;&gt;</code></td></tr><tr><td style="text-align:center"><em>submit</em></td><td style="text-align:center">提交表单按钮：<code>&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</code></td></tr><tr><td style="text-align:center"><em>radio</em></td><td style="text-align:center">单选按钮： ○<em>Male</em>  ○<em>Female</em> （多个单选按钮组合成 <u>多选一</u> ，name要相同）  <img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565231160124.png" alt="1565231160124"></td></tr><tr><td style="text-align:center"><em>checkbox</em></td><td style="text-align:center">复选框：□ <em>I have a bike</em>  □ <em>I have a car</em><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565231125219.png" alt="1565231125219"></td></tr><tr><td style="text-align:center"><em>button</em></td><td style="text-align:center">和前表单元素button类似，但没有后面&lt;/button&gt;：<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565231341774.png" alt="1565231341774"></td></tr><tr><td style="text-align:center"><em>number</em></td><td style="text-align:center">输入数值，并可对其作出限制：<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565231462510.png" alt="1565231462510"></td></tr><tr><td style="text-align:center"><em>date</em></td><td style="text-align:center">包含日期的输入字段：<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565232828624.png" alt="1565232828624"></td></tr><tr><td style="text-align:center"><em>color</em></td><td style="text-align:center">颜色选择器会出现输入字段：<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565231606516.png" alt="1565231606516"></td></tr></tbody></table><p>更多输入类型：time（时间选择器）、datetime &amp; datetime-local（日期选择器）、search（搜索字段类似文本字段）、tel &amp; url &amp; email （可自动验证是否是电话、网址、邮箱地址）</p><h3 id="操作表单">操作表单</h3><h4 id="操作值">操作值</h4><p>对于 <code>text</code>、<code>password</code>、<code>hidden</code>以及<code>select</code> 等直接<em>value</em> 获取、设置值即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; name = &quot;username&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementsByName(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line"></span><br><span class="line">input.value; <span class="comment">// 用户输入值</span></span><br><span class="line">input.value = <span class="string">&quot;hello!&quot;</span>;  <span class="comment">// 设置值</span></span><br></pre></td></tr></table></figure><p>对于 <code>radio</code> 、<code>checkbox</code>，如果获取 <em>value</em> 始终是预设值，不能获取用户输入选择值。</p><p>应该用节点 <code>checked</code>属性判断用户选中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;form&gt;</span></span><br><span class="line"><span class="comment">&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; id=&quot;b&quot; value=&quot;Bike&quot;&gt;I have a bike</span></span><br><span class="line"><span class="comment">&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; id=&quot;c&quot; value=&quot;Car&quot;&gt;I have a car </span></span><br><span class="line"><span class="comment">&lt;/form&gt; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> bike = <span class="built_in">document</span>.getElementsById(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bike.checked)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">bike.checked = <span class="literal">false</span>; <span class="comment">// 设置按钮未被选中</span></span><br></pre></td></tr></table></figure><h4 id="提交表单">提交表单</h4><p>HTML 表单用于收集用户输入，比如下例收集用户输入的账号、密码验证登陆：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565691221197.png" alt="1565691221197"></p><p>提交表单一般有如下三种方法：</p><ul><li>通过 <em><input type="submit"></em> 按钮提交</li><li>通过 <em>form</em> 对象 <em>submit()</em> 方法提交</li><li><em>ajax</em> 方式提交</li></ul><h5 id="type-“submit”-表单提交"><em>type=“submit”</em> 表单提交</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;demo_form.asp&quot;</span> <span class="attr">id</span>=<span class="string">&quot;demo_form&quot;</span> <span class="attr">style</span>=<span class="string">&#x27;text-align: center&#x27;</span> <span class="attr">method</span>=<span class="string">&quot;GET&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>用户：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;user&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;user&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;pwd&#x27;</span> <span class="attr">name</span> = <span class="string">&#x27;pwd&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>   </span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;立即登陆&quot;</span> <span class="attr">style</span>=<span class="string">&#x27;width:210px&#x27;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><em>action</em> 属性：定义提交表单执行的动作，如果省略则会被置为当前页面。在这里提交的表单值会交给脚本代码 <em>demo_form.asp</em> 处理。</li><li><em>method</em> 属性：定义提交方式为<em>GET</em> 或者 <em>POST</em></li></ul><p>点击 <em>立即登陆</em> 按钮后，会自动把表单值提交给脚本文件 <em>demo_form.asp</em> 处理 。</p><p>服务器接收到的提交内容为（<em>GET</em> 方式提交）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user=hwh&amp;pwd=123456</span><br></pre></td></tr></table></figure><p>:warning: 只有设置 <em>name</em> 属性的表单值才会被提交，提交的值构造方式为：<em>name1:value1&amp;name2:value2…</em></p><h5 id="submit-方法提交"><em>submit()</em> 方法提交</h5><p>可以通过：<em><u>点击button</u></em>、<em><u>点击链接</u></em> 等方式触发事件，<em>js</em> 调用<em>form</em> DOM对象<em>submit()</em> 方法提交表单数据。</p><p>:warning: 不推荐这种方式，扰乱了原有浏览器提交表单。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;demo_form.asp&quot;</span> <span class="attr">id</span>=<span class="string">&quot;demo_form&quot;</span> <span class="attr">style</span>=<span class="string">&#x27;text-align: center&#x27;</span> <span class="attr">method</span>=<span class="string">&quot;GET&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>用户：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;user&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;user&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;pwd&#x27;</span> <span class="attr">name</span> = <span class="string">&#x27;pwd&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>   </span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;btn&#x27;</span> <span class="attr">value</span>=<span class="string">&quot;立即登陆&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;submitForm()&quot;</span> <span class="attr">style</span>=<span class="string">&#x27;width:210px&#x27;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>和前面 <u><em>type=“submit”</em> 表单提交方式</u>  对比，<em>type=“submit”</em> 被修改为 —&gt; <em>type=“button”</em></li><li><em>button</em>  按钮设置了属性 <em>onclick</em> ，绑定<em>click</em> 事件执行 <em>submitForm()</em> 函数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo_form&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submitForm</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     form.submit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可用 <em>jQuery</em> 实现 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = $(<span class="string">&quot;#demo_form&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> button = $(<span class="string">&quot;#btn&quot;</span>);</span><br><span class="line">button.click</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       form.submit();</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>服务器接收到的提交内容为（<em>GET</em> 方式提交）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user=hwh&amp;pwd=123456</span><br></pre></td></tr></table></figure><h5 id="ajax-提交"><em>ajax</em> 提交</h5><p><em>ajax</em> 方式提交需要先理解 <u>5.5 <em>AJAX</em></u> 一节。</p><p><em>html</em> 代码部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;demo_form&quot;</span> <span class="attr">style</span>=<span class="string">&#x27;text-align: center&#x27;</span> <span class="attr">method</span>=<span class="string">&quot;GET&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>用户：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;user&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;user&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;pwd&#x27;</span> <span class="attr">name</span> = <span class="string">&#x27;pwd&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>   </span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;btn&#x27;</span> <span class="attr">value</span>=<span class="string">&quot;立即登陆&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;submitForm()&quot;</span> <span class="attr">style</span>=<span class="string">&#x27;width:210px&#x27;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>点击登陆按钮，发送 <em>ajax</em> 请求</li></ul><p><em>js</em> 代码部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submitForm</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建对象</span></span><br><span class="line">   <span class="keyword">var</span> xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">   <span class="comment">// 绑定onreadystatechange事件处理服务器响应</span></span><br><span class="line">   xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">            alert(xmlhttp.responseText)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 发送请求</span></span><br><span class="line">   xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/demo_form.asp&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">   xmlhttp.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:slightly_smiling_face: 也可用 <em>jQuery</em> 实现 <em>ajax</em> 请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submitForm</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">var</span> userName = $(<span class="string">&#x27;#user&#x27;</span>).val();</span><br><span class="line">     <span class="keyword">var</span> password = $(<span class="string">&#x27;#pwd&#x27;</span>).val();</span><br><span class="line">     $.ajax</span><br><span class="line">     (</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;Get&quot;</span>,</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&quot;/demo_form.asp&quot;</span>,</span><br><span class="line">      <span class="attr">username</span>: userName,</span><br><span class="line">      <span class="attr">password</span>:password,</span><br><span class="line">      <span class="attr">dataType</span> : <span class="string">&quot;json&quot;</span>,</span><br><span class="line">      <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">respMsg</span>)</span>&#123;&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="更多提交方式">更多提交方式</h5><p>更多提交方式，参考：<a href="http://www.anyrt.com/blog/list/submit.html">六种提交 <em>form</em> 表单方式</a></p><h2 id="5-4-操作文件">5.4 操作文件</h2><p>用到再提。</p><h2 id="5-5-AJAX">5.5 <em>AJAX</em></h2><h3 id="什么是-AJAX">什么是 <em>AJAX</em> ?</h3><p>传统的网页（不使用 <em>AJAX</em>）如果需要更新内容，必需重载整个网页面。</p><blockquote><p>如何不重新加载界面更新内容？</p></blockquote><p><em>AJAX = 异步 JavaScript 和 XML</em>，可以实现网页异步更新，这意味着不重新加载网页而进行更新。</p><h3 id="AJAX-应用实例"><em>AJAX</em> 应用实例</h3><p>当我们使用百度搜索，在输入框输入搜索内容时，通过<em>AJAX</em>和服务器进行请求返回一列推荐搜索结果。在这个过程中，并没有重新加载界面。</p><blockquote><p>那么在前端和服务器后台都是具体怎么实现沟通呢？这里以一个推荐姓名实例demo为例。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565667374702.png" alt="1565667374702"></p><h4 id="PART1-：-前端html"><em>PART1</em> ： 前端<em>html</em></h4><p>前端 <em>html</em> 实现见下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"> <span class="comment">// ajax部分...</span></span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>请在下面的输入框中键入字母（A - Z）：<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span> </span><br><span class="line">姓氏：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txt1&quot;</span> <span class="attr">onkeyup</span>=<span class="string">&quot;showHint(this.value)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>建议：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;txtHint&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="PART2-：前端-js-实现-AJAX"><em>PART2</em> ：前端 <em>js</em>  实现 <em>AJAX</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax部分...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">res</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;拿到服务器成功响应结果：&quot;</span> + res); &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">res</span>)    </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;拿到服务器失败响应结果：&quot;</span> + res);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHint</span>(<span class="params">str</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建对象</span></span><br><span class="line">   <span class="keyword">var</span> xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">   <span class="comment">// 绑定onreadystatechange事件处理服务器响应</span></span><br><span class="line">   xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             success(xmlhttp.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">             fail(xmlhttp.responseText); </span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 发送请求</span></span><br><span class="line">   xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/ajax/gethint.asp?q=&quot;</span>+str,<span class="literal">true</span>);</span><br><span class="line">   xmlhttp.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下细分<em>ajax</em> 执行过程：</p><ol><li><p>创建对象</p><p>现代浏览器使用 <em>XMLHttpRequest</em> 对象  用于在后台与服务器交换数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure><p>对于IE5、6不得不使用 <em>ActiveXObject</em>  对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure></li><li><p>发送请求</p><p>如需将请求发送到服务器，我们使用 <em>XMLHttpRequest</em> 对象的 <em>open() &amp; send()</em> 方法：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><em>open(method,url,async)</em></td><td style="text-align:center">规定：<em>请求的类型</em>、<em>URL处理脚本文件</em>  、<em>是否异步处理请求</em></td></tr><tr><td style="text-align:center"><em>send(string)</em></td><td style="text-align:center">将请求发送到服务器：<em>string</em> 参数仅用于 <em>POST</em> 请求</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/ajax/gethint.asp?q=&quot;</span>+str,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><ul><li>请求方法为<em>GET</em> 类型，在以下情况推荐使用 <em>POST</em> 请求：<ul><li>无法使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ul></li><li><em>url = /ajax/gethint.asp?q= str</em> ：<em>/ajax/gethint.asp</em> 是处理脚本通常为 <em>ASP/PHP</em> 文件 ；<em>?q=str</em>  是请求的参数，<em>GET</em> 方式必须向<em>URL</em> 添加信息。</li><li><em>true</em> ：表示开启异步，<em>XMLHttpRequest</em> 对象如果要用于 <em>AJAX</em> 的话必须设置为 <em>true</em> 。</li></ul></li><li><p>服务器响应</p><p>如需获得来自服务器的响应，使用 <em>XMLHttpRequest</em> 对象的 <em>responseText</em> 、 <em>responseXML</em> 属性：</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><em>responseText</em></td><td style="text-align:center">获得字符串形式的响应数据</td></tr><tr><td style="text-align:center"><em>responseXML</em></td><td style="text-align:center">获得 <em>XML</em> 形式的响应数据</td></tr></tbody></table><p>同时，通过脚本和服务器交互过程，我们需要根据连接状态来触发执行操作。我们可以使用<em>XMLHttpRequest</em> 对象的 <em>onreadystatechange</em> 事件：</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><em>onreadystatechange</em></td><td style="text-align:center">存储函数（或函数名），每当 <em>readyState</em> 属性改变时，就会调用该函数。</td></tr></tbody></table><p><em>readyState</em> 同前 <em>responseText</em> 、 <em>responseXML</em> 也是<em>XMLHttpRequest</em> 对象属性：</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><em>readyState</em></td><td style="text-align:center">存有 <em>XMLHttpRequest</em> 的状态：从 0 --&gt;  4 发生变化</td></tr><tr><td style="text-align:center"><em>status</em></td><td style="text-align:center">200: “OK”     404: 未找到页面</td></tr></tbody></table><p>对应实际代码为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">      &#123;</span><br><span class="line">           success(xmlhttp.responseText);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">           fail(xmlhttp.responseText); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="PART3-：服务器端-ASP-脚本"><em>PART3</em> ：服务器端*.ASP* 脚本</h4><p>以下为 <em>gethint.asp</em> 文件，根据用户输入字母返回推荐的名字：</p><blockquote><p>:slightly_smiling_face: 当然你也可以用 <em>PHP</em>  实现，这里从略。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">response.expires=-1</span><br><span class="line">dim a(30)</span><br><span class="line">&#x27;用名字来填充数组</span><br><span class="line">a(1)=&quot;Anna&quot;</span><br><span class="line">a(2)=&quot;Brittany&quot;</span><br><span class="line">a(3)=&quot;Cinderella&quot;</span><br><span class="line">a(4)=&quot;Diana&quot;</span><br><span class="line">a(5)=&quot;Eva&quot;</span><br><span class="line">a(6)=&quot;Fiona&quot;</span><br><span class="line">a(7)=&quot;Gunda&quot;</span><br><span class="line">a(8)=&quot;Hege&quot;</span><br><span class="line">a(9)=&quot;Inga&quot;</span><br><span class="line">a(10)=&quot;Johanna&quot;</span><br><span class="line">a(11)=&quot;Kitty&quot;</span><br><span class="line">a(12)=&quot;Linda&quot;</span><br><span class="line">a(13)=&quot;Nina&quot;</span><br><span class="line">a(14)=&quot;Ophelia&quot;</span><br><span class="line">a(15)=&quot;Petunia&quot;</span><br><span class="line">a(16)=&quot;Amanda&quot;</span><br><span class="line">a(17)=&quot;Raquel&quot;</span><br><span class="line">a(18)=&quot;Cindy&quot;</span><br><span class="line">a(19)=&quot;Doris&quot;</span><br><span class="line">a(20)=&quot;Eve&quot;</span><br><span class="line">a(21)=&quot;Evita&quot;</span><br><span class="line">a(22)=&quot;Sunniva&quot;</span><br><span class="line">a(23)=&quot;Tove&quot;</span><br><span class="line">a(24)=&quot;Unni&quot;</span><br><span class="line">a(25)=&quot;Violet&quot;</span><br><span class="line">a(26)=&quot;Liza&quot;</span><br><span class="line">a(27)=&quot;Elizabeth&quot;</span><br><span class="line">a(28)=&quot;Ellen&quot;</span><br><span class="line">a(29)=&quot;Wenche&quot;</span><br><span class="line">a(30)=&quot;Vicky&quot;</span><br><span class="line"></span><br><span class="line">&#x27;获得来自 URL 的 q 参数</span><br><span class="line">q=ucase(request.querystring(&quot;q&quot;))</span><br><span class="line"></span><br><span class="line">&#x27;如果 q 大于 0，则查找数组中的所有提示</span><br><span class="line">if len(q)&gt;0 then</span><br><span class="line">  hint=&quot;&quot;</span><br><span class="line">  for i=1 to 30</span><br><span class="line">    if q=ucase(mid(a(i),1,len(q))) then</span><br><span class="line">      if hint=&quot;&quot; then</span><br><span class="line">        hint=a(i)</span><br><span class="line">      else</span><br><span class="line">        hint=hint &amp; &quot; , &quot; &amp; a(i)</span><br><span class="line">      end if</span><br><span class="line">    end if</span><br><span class="line">  next</span><br><span class="line">end if</span><br><span class="line"></span><br><span class="line">&#x27;如果未找到提示，则输出 &quot;no suggestion&quot;</span><br><span class="line">&#x27;否则输出正确的值</span><br><span class="line">if hint=&quot;&quot; then</span><br><span class="line">  response.write(&quot;no suggestion&quot;)</span><br><span class="line">else</span><br><span class="line">  response.write(hint)</span><br><span class="line">end if</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="jQuery-ajax"><em>jQuery</em> &amp; <em>ajax</em></h3><p><em>jQuery</em> 提供了对<em>JavaScript</em> <em>ajax</em> 高度的封装<em>API</em> ，常用方法如下：</p><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><em>$.ajax({name:val, name:val,…})</em></td><td style="text-align:center"><strong>常用于其他<em>jQuery Ajax</em>方法不能完成的请求</strong></td></tr><tr><td style="text-align:center"><em>$.post(url, data, func, dataType)</em></td><td style="text-align:center"><em>POST</em>方式执行<em>Ajax</em>请求，从服务器加载数据。</td></tr><tr><td style="text-align:center"><em>$.get(url, data, func, dataType)</em></td><td style="text-align:center"><em>GET</em>方式执行<em>Ajax</em>请求，从服务器加载数据。</td></tr><tr><td style="text-align:center"><em>$.getJSON(url, data, func)</em></td><td style="text-align:center"><em>GET</em>方式从服务器加载<em>JSON</em>格式数据。相较于$.get()不必再指定<em>dataType</em></td></tr><tr><td style="text-align:center"><em>$.load(url, data, func)</em></td><td style="text-align:center"><em>POST</em>方式将服务器加载的数据插入指定DOM中，<u><em>data</em>不存在则以<em>GET</em>方式</u></td></tr><tr><td style="text-align:center"><em>$.getScript(url, func)</em></td><td style="text-align:center"><em>GET</em>方式执行<em>Ajax</em>请求，从服务器加载并执行回传的<em>JavaScript</em>。</td></tr></tbody></table><p>注：上述方法 <em>func</em> 都是指在方法完成后执行的回调（<em>callback</em>）函数 。</p><ul><li>格式：<em>func(data, status, xhr)</em></li><li>参数：<em>data</em> — 服务器返回数据；<em>status</em> — 响应状态 ；<em>xhr</em> – <em>XMLHttpRequest</em>对象。一般关注 <em>data</em> 即可。</li></ul><h4 id="ajax"><em>$.ajax()</em></h4><p><em><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">.</mi><mi>a</mi><mi>j</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo>∗</mo><mtext>完整参数形式为：</mtext><mo>∗</mo></mrow><annotation encoding="application/x-tex">.ajax()* 完整参数形式为：*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mord mathnormal">aja</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">完整参数形式为：</span><span class="mord">∗</span></span></span></span>.ajax({name:val, name:val,…})</em> ，其参数为一个对象 <strong>{}</strong> ，可选字段为：</p><ul><li><em><strong>url</strong></em>：链接地址，字符串表示</li><li><em><strong>data</strong></em>：需发送到服务器的数据，<em>GET、POST</em>都可以，格式为 <em>{A: ‘…’, B: ‘…’}</em></li><li><em><strong>type</strong></em>：指定请求类型为：“POST” 或 “GET”</li><li><em>timeout</em>：请求超时时间 / 毫秒</li><li><em>cache</em>：是否缓存请求结果，<em>bool</em>表示</li><li><em>contentType</em>：内容类型，默认为 <em>“application/x-www-form-urlencoded”</em></li><li><em><strong>dataType</strong></em>：<u>服务器响应的数据类型</u>，<u>字符串表示</u></li><li><em>success</em>：请求成功后，服务器回调的函数</li><li><em>error</em>：请求失败后，服务器回调的函数</li><li><em>complete</em>：请求完成后调用的函数，无论请求是成功还是失败，都会调用该函数；<u>如果设置了success与error</u>函数，则该函数在它们之后被调用</li><li><em><strong>async</strong></em>：是否异步处理，bool表示，默认为true；设置该值为false后，JS不会向下执行，而是原地等待服务器返回数据，并完成相应的回调函数后，再向下执行</li><li><em><strong>username</strong></em>：访问认证请求中携带的用户名，字符串表示</li><li><em><strong>password</strong></em>：返回认证请求中携带的密码，字符串表示</li></ul><blockquote><p>下面通过 <em>$.ajax()</em> 方法请求服务器加载一个txt文本。</p></blockquote><p>html代码部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/jquery/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>通过 AJAX 改变文本<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;b01&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>点我加载txt<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// ajax实现部分...</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565842814777.png" alt="1565842814777"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax实现部分...</span></span><br><span class="line">$(<span class="string">&quot;#b01&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  htmlobj=$.ajax</span><br><span class="line">  (&#123;</span><br><span class="line">      <span class="attr">url</span>:<span class="string">&quot;/jquery/test1.txt&quot;</span>,</span><br><span class="line">      <span class="attr">type</span>:<span class="string">&quot;GET&quot;</span>,</span><br><span class="line">      <span class="attr">async</span>:<span class="literal">false</span></span><br><span class="line">   &#125;);</span><br><span class="line">   $(<span class="string">&quot;#myDiv&quot;</span>).html(htmlobj.responseText);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>点击后显示：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565843001023.png" alt="1565843001023"></p><h5 id="回调函数">回调函数</h5><p>也可使用回调函数，如果成功就显示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax实现部分...</span></span><br><span class="line">$(<span class="string">&quot;#b01&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  htmlobj=$.ajax</span><br><span class="line">  (&#123;</span><br><span class="line">      <span class="attr">url</span>:<span class="string">&quot;/jquery/test1.txt&quot;</span>,</span><br><span class="line">      <span class="attr">type</span>:<span class="string">&quot;GET&quot;</span>,</span><br><span class="line">      <span class="attr">async</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="attr">success</span>:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123; $(<span class="string">&quot;#myDiv&quot;</span>).html(data); &#125;</span><br><span class="line">   &#125;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>回调函数<em>success</em>有参数 <em>data</em> ，接收服务器返回数据，这里接收的是文本：<em>test1.txt</em> 。</p></li><li><p>也可以使用链式调用回调函数，类似前面 <em>Promise</em> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax实现部分...</span></span><br><span class="line">$(<span class="string">&quot;#b01&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  htmlobj=$.ajax</span><br><span class="line">  (&#123;</span><br><span class="line">      <span class="attr">url</span>:<span class="string">&quot;/jquery/test1.txt&quot;</span>,</span><br><span class="line">      <span class="attr">type</span>:<span class="string">&quot;GET&quot;</span>,</span><br><span class="line">      <span class="attr">async</span>:<span class="literal">false</span></span><br><span class="line">   &#125;)</span><br><span class="line">  .done(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123; $(<span class="string">&quot;#myDiv&quot;</span>).html(data); &#125;)</span><br><span class="line">  .fail(<span class="function"><span class="keyword">function</span> (<span class="params">xhr,status</span>)</span>&#123; $(<span class="string">&quot;#myDiv&quot;</span>).html(<span class="string">&#x27;失败:&#x27;</span>+xhr.status+<span class="string">&#x27;原因:&#x27;</span>+  status);&#125;)</span><br><span class="line">  .always(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="string">&#x27;请求完成: 无论成功或失败都会调用&#x27;</span>);&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="get"><em>$.get()</em></h4><p>简单的 <em>GET</em> 请求功能以*<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">.</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo>∗</mo><mtext>取代复杂</mtext><mo>∗</mo></mrow><annotation encoding="application/x-tex">.get()* 取代复杂 *</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">取代复杂</span><span class="mord">∗</span></span></span></span>.ajax()* ，请求成功时可调用回调函数。</p><p>其格式为：<em>$.get(url, data, func, dataType)</em></p><ul><li><em>url</em>：链接地址，字符串表示</li><li><em>data</em>：需要发生到服务器的数据，以键值对形式</li><li><em>func(data, status, xhr)</em>：回调函数，<em>data</em> — 服务器返回数据；<em>status</em> — 响应状态 ；<em>xhr</em> – <em>XMLHttpRequest</em>对象。一般关注 <em>data</em> 即可。</li><li><em>dataType</em>：服务器返回数据的格式</li></ul><blockquote><p>以*$.get()* 实现上述点击按钮加载指定文本。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax实现部分...</span></span><br><span class="line">$(<span class="string">&quot;#b01&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   htmlobj=$.get(<span class="string">&quot;/jquery/test1.txt&quot;</span></span><br><span class="line">   ,<span class="function"><span class="keyword">function</span>(<span class="params">data,status</span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       $(<span class="string">&quot;#myDiv&quot;</span>).html(data);</span><br><span class="line">   &#125;);   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>回调函数<em>function(data,status)</em> 参数<em>data、status</em> 分别接收服务器返回的数据、状态。</li></ul><p>点击后显示：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565843001023.png" alt="1565843001023"></p><p>:warning: 经过测试，似乎只能在回调函数里接收数据，像*$.ajax()* 一样用<em>responseText</em> 获取返回数据不成功：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax实现部分...</span></span><br><span class="line">$(<span class="string">&quot;#b01&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   htmlobj=$.get(<span class="string">&quot;/jquery/test1.txt&quot;</span>);</span><br><span class="line">   $(<span class="string">&quot;#myDiv&quot;</span>).html(htmlobj.responseText); <span class="comment">// 点击按钮加载数据不成功？？！</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="post"><em>$.post()</em></h4><p>和  <em>$.get()</em> 类似，接收参数一致，除了请求方式变为了 <em>post</em> 方式。</p><p>其格式为：<em>$.post(url, data, func, dataType)</em></p><blockquote><p>向指定界面发送 <em>HTTP POST</em> 请求，并获得返回的结果 。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565858154265.png" alt="1565858154265"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/jquery/jquery-1.11.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> 姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&#x27;user&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> 城市：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&#x27;city&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>发送 POST 请求，获取返回结果 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="function"><span class="javascript"></span>&#123;</span></span><br><span class="line"><span class="javascript">      $.post(<span class="string">&quot;/example/jquery/demo_test_post.asp&quot;</span>,</span></span><br><span class="line"><span class="javascript">      &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">name</span>:$(<span class="string">&#x27;#user&#x27;</span>).val(),</span></span><br><span class="line"><span class="javascript">          <span class="attr">city</span>:$(<span class="string">&#x27;#city&#x27;</span>).val()</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span>(<span class="params">data,status</span>)</span></span></span><br><span class="line"><span class="function"><span class="javascript">      </span>&#123;</span></span><br><span class="line"><span class="javascript">          $(<span class="string">&#x27;#myDiv&#x27;</span>).html(<span class="string">&quot;数据：&quot;</span> + data + <span class="string">&quot;&lt;br&gt;状态：&quot;</span> + status);</span></span><br><span class="line"><span class="javascript">      &#125;);</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="load"><em>$.load()</em></h4><p><em>$.load()</em> 如果数据存在则以 <em>POST</em> 方式（不存在则以 <em>GET</em> 方式）加载服务器返回的数据到 <u>指定 DOM 节点</u>中 。</p><p>其格式为：<em>$(selector).load(URL,data,func)</em>。</p><h5 id="举个例子">举个例子</h5><blockquote><p>依旧以上 <em>$.post()</em> 所举实例为例，加载服务器返回的结果到指定节点中。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565859062033.png" alt="1565859062033"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/jquery/jquery-1.11.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> 姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&#x27;user&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> 城市：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&#x27;city&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>发送 POST 请求，获取返回结果 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="function"><span class="javascript"></span>&#123;</span></span><br><span class="line"><span class="javascript">   </span></span><br><span class="line"><span class="javascript">      $(<span class="string">&#x27;#myDiv&#x27;</span>).load(<span class="string">&quot;/example/jquery/demo_test_post.asp&quot;</span>,</span></span><br><span class="line"><span class="javascript">      &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">name</span>:$(<span class="string">&#x27;#user&#x27;</span>).val(),</span></span><br><span class="line"><span class="javascript">          <span class="attr">city</span>:$(<span class="string">&#x27;#city&#x27;</span>).val()</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      );</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面会将返回的结果自动加载到指定节点 <em><u>#myDiv</u></em> 中，当然你也可以使用回调函数来自定义加载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">      $(<span class="string">&#x27;#myDiv&#x27;</span>).load(<span class="string">&quot;/example/jquery/demo_test_post.asp&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="attr">name</span>:$(<span class="string">&#x27;#user&#x27;</span>).val(),</span><br><span class="line">          <span class="attr">city</span>:$(<span class="string">&#x27;#city&#x27;</span>).val()</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">data,status,xhr</span>)</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         $(<span class="string">&#x27;#myDiv&#x27;</span>).html(<span class="string">&quot;数据：&quot;</span> + data + <span class="string">&quot;&lt;br&gt;状态：&quot;</span> + status);</span><br><span class="line">      &#125;</span><br><span class="line">      );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>回调函数参数意义同前，显示结果为：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565859613517.png" alt="1565859613517"></p><h5 id="再举个例子">再举个例子</h5><p>也可直接加载<em>url</em> 指定资源，不用传递其它参数。</p><blockquote><p>点击按钮后，指定节点直接加载 <em>demo_test.txt</em> 文件内容。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565860429522.png" alt="1565860429522"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/jquery/jquery-1.11.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span>请点击下面的按钮，通过 jQuery AJAX 改变这段文本。<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>获得外部的内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  $(<span class="string">&quot;#btn1&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="function"><span class="javascript">  </span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;#test&#x27;</span>).load(<span class="string">&#x27;/example/jquery/demo_test.txt&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击后显示：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565859858855.png" alt="1565859858855"></p><h2 id="5-6-Promise">5.6 <em>Promise</em></h2><h3 id="初识-Promise">初识 <em>Promise</em></h3><p>先不理会那些复杂的概念，我们来直观了解下 <em>Promise</em> 是什么：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565770221805.png" alt="1565770221805"></p><p>很容易得知，<em>Promise</em> 原来是一个构造函数：</p><ul><li>在自己身上有 <em>all()、reject()、resolve()</em> 等方法</li><li>在原型上有 <em>then()、catch()</em> 等方法，<em>then()</em> 返回一个 <em>Promise</em> 对象。</li></ul><p>那么 <em>new Promise()</em> 出来的对象自然也拥有以上方法。</p><h3 id="举个栗子">举个栗子</h3><h4 id="原生-JavaScript-执行异步">原生 <em>JavaScript</em> 执行异步</h4><p>在 <em>JavaScript</em> 世界里，所有代码都是单线程执行。因此 <em>JavaScript</em> 所有网络操作、浏览器事件都必须异步执行。</p><p>也就是说，在某个时间点，会执行某个函数。然后根据函数状态执行不同的处理函数，也就是常说的回调函数。</p><blockquote><p>如，生成一个0-2之间的随机数，如果小于1，则等待1s后返回成功，否则返回失败。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">str</span>)</span>&#123;  <span class="built_in">console</span>.log(str); &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">str</span>)   </span>&#123;  <span class="built_in">console</span>.log(str); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeOut = <span class="built_in">Math</span>.random() * <span class="number">2</span>;</span><br><span class="line">    log(<span class="string">&#x27;set timeout to: &#x27;</span> + timeOut + <span class="string">&#x27; seconds.&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeOut &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            success(<span class="string">&#x27;成功：生成随机数小于1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            fail(<span class="string">&#x27;失败：生成随机数大于1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><ul><li>本文中所有异步操作均以 <em>setTimeout</em>为例子，而不使用 <em>ajax</em> 。</li></ul><p>可以看到，执行<em>test()</em> —&gt; 延迟1s后执行匿名判断函数 —&gt; 根据判断结果执行回调函数：<em>success()</em> 、<em>fail()</em> 。</p><h4 id="Promise-执行异步"><em>Promise</em>  执行异步</h4><p>如果我们用 <em>Promise</em> 对象来执行可以达到相同效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">resolve, reject</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeOut = <span class="built_in">Math</span>.random() * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeOut &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> date = <span class="string">&#x27;生成随机数小于1&#x27;</span>;</span><br><span class="line">            resolve(date);  <span class="comment">// 传递参数date给Promise对象.then方法内部匿名函数参数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> date = <span class="string">&#x27;生成随机数大于1&#x27;</span>;</span><br><span class="line">            reject(date);  <span class="comment">// 传递参数date给Promise对象.catch方法内部匿名函数参数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(test);</span><br><span class="line"><span class="keyword">var</span> p2 = p1.then</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;成功：&#x27;</span> + result); <span class="comment">// 如果执行成功输出：&#x27;成功：生成随机数小于1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">var</span> p3 = p2.catch</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;失败：&#x27;</span> + reason); <span class="comment">// 如果执行失败输出：&#x27;失败：生成随机数大于1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>咋看之下首先方法 <em>function test(…)</em> 和之前没什么区别，只不过多了两个函数参数 <em>resolve, reject</em> ，替换了之前回调函数 <em>success、fail</em> 在接下来代码中位置，整体逻辑没有变化。</p><ul><li><em>resolve, reject</em> 可以分别将 <em>Promise</em> 状态置为：<em>fullfiled、 rejected</em></li><li><em>resolve, reject</em> 还可将自身的接收的参数（本例为<em>date</em>） ，分别传给<em>then、catch</em> 方法（见下）</li></ul><p>只不过在下面多了一层对 <em>test()</em> 的封装：创建一个 <em>Promise</em> 对象，传递一个函数作为参数，承诺一定执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(test);</span><br></pre></td></tr></table></figure><p>紧接着根据此时 <em>Promise</em> 状态是<em>fullfiled、 rejected</em>  执行 <em>then()</em> 还是 <em>catch()</em> 方法。</p><p>比如，随机数&lt;1 —&gt; 执行<em>resolve()</em> —&gt; <em>Promise</em> 状态为<em>fullfiled</em>  ----&gt; 执行 <em>then()</em> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = p1.then</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;成功：&#x27;</span> + result); <span class="comment">// 如果执行成功输出：&#x27;成功：生成随机数小于1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><em>then(func)</em> 参数为一个函数，同时它也拿到了<em>resolve(date)</em>  的参数<em>date</em> ，赋值给了<em>result</em> （我是这么理解的的）。</p><p>所以如果执行会打印出：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565772961295.png" alt="1565772961295"></p><p>同理，随机数&gt;1 —&gt; 执行<em>reject()</em> —&gt; <em>Promise</em> 状态为 <em>rejected</em>   ----&gt; 执行 <em>catch()</em> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p3 = p2.catch</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;失败：&#x27;</span> + reason); <span class="comment">// 如果执行失败输出：&#x27;失败：生成随机数大于1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><em>Promise</em> 对象可以串联起来，所以上述代码可以简化为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(test).then (<span class="function"><span class="keyword">function</span> (<span class="params">result</span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;成功：&#x27;</span> + result); &#125;</span><br><span class="line">                 .catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;失败：&#x27;</span> + reason); &#125;</span><br></pre></td></tr></table></figure><h4 id="这就完了？">这就完了？</h4><p>看到这儿你可能不屑一顾，这么传的神乎其神的 <em>Promise</em> 就这点能耐？把原来好好的 <em>test()</em> 方法，整两个参数然后用 <em>Promise</em> 封装一下就没了？</p><p>当然，看到这你也可能发现了 <em>Promise</em> 其中一个优点：<em>执行代码和处理结果的代码清晰地分离</em> 。</p><p>比如上面：执行代码 <em>test()</em> 只负责整体逻辑传递数据，而处理代码接收数据进行处理由<em>then()</em> 、 <em>catch()</em> 完成。</p><p>更大优点，是用 <em>Promise</em> 处理多个异步操作，请看下节。</p><h3 id="更正确的使用Promise姿势：处理多异步">更正确的使用<em>Promise</em>姿势：处理多异步</h3><p>试想有多个异步任务函数，<em>job1、job2、job3</em>…：</p><blockquote><p>执行<em>job1</em>，<em>job1</em>执行成功 —&gt; 执行<em>job2</em>，<em>job2</em>执行成功 —&gt; 执行<em>job3</em>，<em>job3</em>执行成功 —&gt; …</p></blockquote><p>显然<em>job1</em>成了一个多层回调函数，<em>job2</em>执行完成后也有相应回调函数<em>job3</em>执行，<em>job3</em>有回调函数<em>job4</em>…</p><p>如果不使用 <em>Promise</em> 意味着我们要层层嵌套 <em>job1、job2、job3…</em>。这既不易读，也不灵活，而我们使用 <em>Promise</em> 后</p><p>可以将代码简写为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.then(job1).then(job2).then(job3).then...;</span><br></pre></td></tr></table></figure><blockquote><p>分别实现异步函数<em>job1_add1、job2_mul2、job3_div3</em> 依次对数字0进行 *<em>+1、<em>2、/3</em></em>：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个Promise对象</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    resolve(<span class="number">0</span>); <span class="comment">// 传递数据：数字0</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// job1任务：将传过来的数字加1,这里传过来的数字是0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">job1_add1</span>(<span class="params">num</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       为什么返回 Promise 对象？</span></span><br><span class="line"><span class="comment">       首先我们要知道，setTimeout共有四个参数，后面两个参数会传入回调函数（这里是resolve）</span></span><br><span class="line"><span class="comment">       我们知道，resolve参数可以被then方法拿到，这样在接下来的then方法可以获取到传递的参数:</span></span><br><span class="line"><span class="comment">            p.then(job1_add1).then(job2_mul2).then(job3_div3)</span></span><br><span class="line"><span class="comment">       你也可以直接传递数据而非Promise对象，后面then也可以接收到：</span></span><br><span class="line"><span class="comment">       return num+1;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;计算：&#x27;</span>+ num + <span class="string">&#x27; + 1&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, <span class="number">600</span>, num + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// job2任务：将传过来的数字×2，这里传过来的是0+1 = 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">job2_mul2</span>(<span class="params">num</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;计算：&#x27;</span>+ num + <span class="string">&#x27; * 2&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, num * <span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// job2任务：将传过来的数字÷3，这里传过来的是 (0+1)*2 = 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">job3_div3</span>(<span class="params">num</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;计算：&#x27;</span>+ num + <span class="string">&#x27; / 3&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, <span class="number">400</span>, num / <span class="number">3</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行多异步任务</span></span><br><span class="line">p.then(job1_add1).then(job2_mul2).then(job3_div3);</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565779644046.png" alt="1565779644046"></p><h3 id="更多有关-Promise">更多有关 <em>Promise</em></h3><p>除了前面提到 <em>then、catch</em> 方法，<em>Promise</em> 还提供了<u>静态</u> 方法 <em>all、race</em> 等。</p><h4 id="all-方法"><em>all()</em> 方法</h4><p><em>Promise</em> 的<em>all(PromiesArr)</em> 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。</p><p>由于可以在一个回调中处理所有返回数据，这样比如在打开网页，预先加载需要用到的所有资源如图片等，等全部加载完在执行回调。</p><p>依旧以上面异步函数<em>job1_add1、job2_mul2、job3_div3</em> 为例：</p><blockquote><p>异步执行三个异步函数，分别将各自传递的参数值进行：+1、*2、/3。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([job1_add1(1),job2_mul2(2),job3_div3(3)])</span><br><span class="line">       .then(function(results)</span><br><span class="line">        &#123;</span><br><span class="line">           console.log(results);      </span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li><p>三个异步操作都执行完毕后，<em>all(PromiesArr)</em> 会把它们返回的数据组成数组传给 <em>then()</em>，也就是上面<em>results</em>。</p></li><li><p>注意是传递 <em>Promise</em> 对象数组，而非函数，下面这种写法错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([job1_add1,job2_mul2,job3_div3])</span><br></pre></td></tr></table></figure><p>这是传递的参数是函数数组，而非<em>Promise</em>对象 数组。只有函数都执行后才是<em>Promise</em>对象数组（<em>job1_add1、job2_mul2、job3_div3</em> 返回<em>Promise</em>对象）。</p><p>所以，<em>all()</em> 不能实现前面三个异步操作结果交互依次进行：+1、*2、/3，因为传递的参数值被写死了，它们不存在嵌套关系，更何况论传值了。</p></li></ul><p>最后执行的结果为：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565783438113.png" alt="1565783438113"></p><h4 id="race-方法"><em>race()</em> 方法</h4><p>有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用<code>Promise.race()</code>实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&#x27;P1&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">600</span>, <span class="string">&#x27;P2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// &#x27;P1&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="练习：将AJAX-异步执行函数转为-Promise-对象">练习：将<em>AJAX</em> 异步执行函数转为 <em>Promise</em> 对象</h3><p>在前我们举个<em>ajax</em>应用实例：根据用户输入字母，触发<em>showHint</em> 方法<em>ajax</em> 方式请求服务器返回推荐姓名。</p><p>其中 <em>ajax</em> 实现部分见下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax部分...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">res</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;拿到服务器成功响应结果：&quot;</span> + res); &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">res</span>)    </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;拿到服务器失败响应结果：&quot;</span> + res);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHint</span>(<span class="params">str</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建对象</span></span><br><span class="line">   <span class="keyword">var</span> xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">   <span class="comment">// 绑定onreadystatechange事件处理服务器响应</span></span><br><span class="line">   xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             success(xmlhttp.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">             fail(xmlhttp.status); </span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 发送请求</span></span><br><span class="line">   xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/ajax/gethint.asp?q=&quot;</span>+str,<span class="literal">true</span>);</span><br><span class="line">   xmlhttp.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>现要求：将<em>ajax</em> 异步执行函数*showHint()*转换为 <em>Promise</em> 对象简化异步处理。</p></blockquote><p>最开始，我用<em>Promise</em> 对象直接封装 <em>showHint</em>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHint</span>(<span class="params">str</span>)  // 参数不对，应该为 <span class="function"><span class="keyword">function</span> <span class="title">showHint</span>(<span class="params">resolve, reject</span>)</span></span></span><br><span class="line"><span class="function"><span class="function"></span>&#123;</span></span><br><span class="line"><span class="function">   // 创建对象</span></span><br><span class="line"><span class="function">   <span class="title">var</span> <span class="title">xmlhttp</span> = <span class="title">new</span> <span class="title">XMLHttpRequest</span>(<span class="params"></span>)</span>;</span><br><span class="line">   <span class="comment">// 绑定onreadystatechange事件处理服务器响应</span></span><br><span class="line">   xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             resolve(xmlhttp.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">             reject(xmlhttp.status); </span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 发送请求</span></span><br><span class="line">   xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/ajax/gethint.asp?q=&quot;</span>+str,<span class="literal">true</span>);</span><br><span class="line">   xmlhttp.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(showHint);</span><br><span class="line">p.then (<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;拿到服务器成功响应结果：&quot;</span> + res);&#125;)</span><br><span class="line"> .catch(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;拿到服务器失败响应结果：&quot;</span> + res);&#125;);</span><br></pre></td></tr></table></figure><p>但是这样有一个问题：<em>function showHint(str){…}</em> 参数不对，应该为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function showHint(resolve, reject)</span><br><span class="line">&#123;</span><br><span class="line">     ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则无法在后面使用 <em>resolve、reject</em> 函数！但是这样又无法使用函数自带 <em>str</em> 参数，所以解决办法为：把函数<em>showHint</em> 内部需要判断执行不同回调函数的部分，包装成 <em>Promise</em>对象返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHint</span>(<span class="params">str</span>)  // 参数不对，应该为 <span class="function"><span class="keyword">function</span> <span class="title">showHint</span>(<span class="params">resolve, reject</span>)</span></span></span><br><span class="line"><span class="function"><span class="function"></span>&#123;</span></span><br><span class="line"><span class="function">   // 创建对象</span></span><br><span class="line"><span class="function">   <span class="title">var</span> <span class="title">xmlhttp</span> = <span class="title">new</span> <span class="title">XMLHttpRequest</span>(<span class="params"></span>)</span>;</span><br><span class="line">   <span class="comment">// 绑定onreadystatechange事件处理服务器响应</span></span><br><span class="line">   p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 resolve(xmlhttp.responseText);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 reject(xmlhttp.responseText); </span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">   <span class="comment">// 发送请求</span></span><br><span class="line">   xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/ajax/gethint.asp?q=&quot;</span>+str,<span class="literal">true</span>);</span><br><span class="line">   xmlhttp.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以使用<em>resolve、reject</em> 函数了，然后再让返回的<em>Promise</em>对象执行 <em>then</em> 、<em>catch</em> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.then (function(res)&#123; console.log(&quot;拿到服务器成功响应结果：&quot; + res);&#125;)</span><br><span class="line"> .catch(function(res)&#123; console.log(&quot;拿到服务器失败响应结果：&quot; + res);&#125;);</span><br></pre></td></tr></table></figure><h1>第六章：<em>jQuery</em></h1><h2 id="6-1-选择器">6.1 选择器</h2><p>在前 <u>5.2节</u> 介绍了：</p><ul><li>获取<em>DOM</em> 节点：<em>getElementby…()</em> 方法 <u>OR</u>  <em>CSS</em> 层级选择器</li><li>操作<em>DOM</em> 节点<ul><li>通过 <em>innerText、innerHtml</em> 属性修改节点文本</li><li>通过 <em>style</em> 属性修改<em>CSS</em> 样式</li><li>通过 <em>appendChild()</em> 、<em>insertBefore()</em> 、*removeChild()*方法插入、删除节点</li></ul></li></ul><p><em>jQuery</em> 提供获取<em>DOM</em> 节点方法 本质是 <u><em>CSS</em> 层级选择器</u> 语法，不再赘述。但是还特别提供 <em>find()、filter()、map()</em> 方法进行查找和过滤，详见下。</p><h3 id="查找和过滤">查找和过滤</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;programLanguage&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;C#&quot;</span>&gt;</span>C#<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;C&quot;</span>&gt;</span>C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>java<span class="tag">&lt;/<span class="name">li</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="find-、next-、prev-、parent"><em>find()</em>、<em>next()</em>、<em>prev()</em>、<em>parent()</em></h4><p>在前面我们知道怎么获取一个节点，但是如果获取一个节点后，还想获取它的子、兄弟、父节点呢？</p><p><em>jQuery</em> 为我们提供了 <em>find()</em>、<em>next()</em>、<em>prev()</em> 方法来做到这一点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find()</span></span><br><span class="line"><span class="keyword">var</span> C = $(<span class="string">&#x27;#programLanguage&#x27;</span>).find(<span class="string">&#x27;#C&#x27;</span>);</span><br><span class="line">C.text();  <span class="comment">// 输出: C</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parent()</span></span><br><span class="line"><span class="keyword">var</span> pl = C.parent(); </span><br><span class="line">pl;        <span class="comment">// 节点：ul#programLanguage</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// next()、prev()</span></span><br><span class="line">C.next();  <span class="comment">// 节点：li#python</span></span><br><span class="line"></span><br><span class="line">C.prev();  <span class="comment">// 节点：li#C#</span></span><br></pre></td></tr></table></figure><h4 id="first-、last"><em>first()、last()</em></h4><p>如果我们获取到一个节点数组，对节点数组的操作和普通数组操作有什么不同吗？</p><p>普通数组可以使用的API方法和<em>jQuery</em> 对象提供的API多有不同，不可混为一谈，以下是常用一些方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = $(<span class="string">&#x27;#programLanguage li&#x27;</span>);</span><br><span class="line"></span><br><span class="line">lis.first();     <span class="comment">// 获取第一个节点，等价于：#programLanguage li:first-child</span></span><br><span class="line">lis.last();      <span class="comment">// 获取最后一个节点，等价于：#programLanguage li:last-child</span></span><br><span class="line">lis.slice(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 输出：[C#,C], 数组的slice()方法一致</span></span><br></pre></td></tr></table></figure><p>更多方法以后用到再提。</p><h4 id="filter-、map"><em>filter()、map()</em></h4><p><em>filter()、map()</em> 和我们前介绍的高阶函数类似。</p><blockquote><p>通过 <em>filter()</em>  过滤出 ’C‘ 开头编程语言。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter()过滤符合条件的原对象数组元素</span></span><br><span class="line"><span class="comment">// 返回：数组 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lis = $(<span class="string">&#x27;#programLanguage li&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> firstIsC = lis.filter</span><br><span class="line">(</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      过滤条件；首字母为C</span></span><br><span class="line"><span class="comment">      注意：此时是DOM节点对象不是jQuery对象</span></span><br><span class="line"><span class="comment">      why? 直接箭头函数this绑定window</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// () =&gt; this.innerHTML.indexOf(&#x27;C&#x27;) === 0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="built_in">this</span>.innerHTML.indexOf(<span class="string">&#x27;C&#x27;</span>) === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出测试</span></span><br><span class="line">firstIsC ;    <span class="comment">// jQuery.fn.init(2) [li#C#, li#C, prevObject: jQuery.fn.init(4)]</span></span><br></pre></td></tr></table></figure><blockquote><p>通过 <em>map()</em>  遍历返回所有对象节点文本。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map()</span></span><br><span class="line"><span class="comment">// 遍历所有对象元素返回一个数组</span></span><br><span class="line"><span class="keyword">var</span> lis = $(<span class="string">&#x27;#programLanguage li&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> texts = lis.map</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.innerHTML;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出测试</span></span><br><span class="line">texts;  <span class="comment">//  [&quot;C#&quot;, &quot;C&quot;, &quot;python&quot;, &quot;java&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="综合练习">综合练习</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;test-form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;#0&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return false;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Email: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Gender: </span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;m&quot;</span> <span class="attr">checked</span>&gt;</span> Male<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;f&quot;</span>&gt;</span> Female<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>City: </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;BJ&quot;</span> <span class="attr">selected</span>&gt;</span>Beijing<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;SH&quot;</span>&gt;</span>Shanghai<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;CD&quot;</span>&gt;</span>Chengdu<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;XM&quot;</span>&gt;</span>Xiamen<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>输入值后，用 <em>jQuery</em> 获取表单的 <em>JSON</em> 字符串，如：<code>&#123;&quot;name&quot;:&quot;Michael&quot;,&quot;email&quot;:...&#125;</code>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定状态:input 可获取：&lt;input&gt;，&lt;textarea&gt;，&lt;select&gt;和&lt;button&gt; 元素</span></span><br><span class="line">$(<span class="string">&#x27;#test-form :input&#x27;</span>).filter</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="comment">// 过滤节点数组中：未选中的radio单选框节点和submit按钮节点</span></span><br><span class="line">      <span class="comment">// this是DOM对象，获取节点属性type、checked等</span></span><br><span class="line">       <span class="keyword">var</span> isNotChecked  = <span class="built_in">this</span>.type === <span class="string">&#x27;radio&#x27;</span> &amp;&amp; !<span class="built_in">this</span>.checked;</span><br><span class="line">       <span class="keyword">if</span>( isNotChecked  || <span class="built_in">this</span>.type === <span class="string">&#x27;submit&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">).map</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">// select元素可直接获取name属性和选中的值</span></span><br><span class="line">       <span class="keyword">return</span> obj[<span class="built_in">this</span>.name] = <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">json = <span class="built_in">JSON</span>.stringify(obj,<span class="literal">null</span>,<span class="string">&#x27;  &#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="6-2-jQuery-操作-DOM">6.2 <em>jQuery</em> 操作 <em>DOM</em></h2><h3 id="修改-Text-HTML">修改 <em>Text</em> &amp; <em>HTML</em></h3><p><em>jQuery</em> 对象提供了 <em>text()、html()</em> 方法来获取节点文本和HTML文本，例如以下HTML结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;programLanguage&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;C#&quot;</span>&gt;</span>C#<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;C&quot;</span>&gt;</span>C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>java<span class="tag">&lt;/<span class="name">li</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分别获取文本和HTML：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#C&#x27;</span>).html();    <span class="comment">// C</span></span><br><span class="line">$(<span class="string">&#x27;#C&#x27;</span>).text();    <span class="comment">// C</span></span><br></pre></td></tr></table></figure><p>设置文本 &amp; HTML，只需给<em>text()、html()</em> 方法传递参数即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#C&#x27;</span>).text(<span class="string">&#x27;我是西语言&#x27;</span>);    <span class="comment">// 我是西语言</span></span><br></pre></td></tr></table></figure><p>特别巧妙的是，<em>jQuery</em> 可以给选中多个节点设置文本、CSS、属性等，具有 <u>批量操作</u> 特点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// docment对象不具有 批量操作 特点</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;li&#x27;</span>).innerText = <span class="string">&#x27;test&#x27;</span>;   <span class="comment">// 设置不成功，节点内容未被改变</span></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>).innerText = <span class="string">&#x27;test&#x27;</span>;       <span class="comment">// 设置不成功，节点内容未被改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery对象具有 批量操作 特点</span></span><br><span class="line">$(<span class="string">&#x27;li&#x27;</span>).text(<span class="string">&#x27;test&#x27;</span>);        <span class="comment">// 设置成功，所有li节点文本被设置 &#x27;test&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="修改CSS">修改<em>CSS</em></h3><p>同前，也可用 CSS() 方法获取、修改CSS样式，也具有 <u>批量操作</u> 特点，关于该特点以下不再赘述。</p><p>获取CSS样式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;li&#x27;</span>).css(<span class="string">&#x27;color&#x27;</span>);        <span class="comment">// &quot;rgb(0, 0, 0)&quot;</span></span><br></pre></td></tr></table></figure><p>设置CSS样式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;li&#x27;</span>).css(<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;red&#x27;</span>);  <span class="comment">// 文本全变为红色</span></span><br></pre></td></tr></table></figure><p>清除CSS样式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;li&#x27;</span>).css(<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;&#x27;</span>);    <span class="comment">// 等价把该属性设置为空即可</span></span><br></pre></td></tr></table></figure><h3 id="显示和隐藏DOM">显示和隐藏DOM</h3><p>隐藏DOM节点，注意DOM树结构没有被改变：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;li&#x27;</span>).hide();   <span class="comment">// 对应CSS设置：display = none;</span></span><br></pre></td></tr></table></figure><p>显示DOM节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;li&#x27;</span>).show();   <span class="comment">// 对应CSS设置：display = inline; 或者 display = block;</span></span><br></pre></td></tr></table></figure><h3 id="修改DOM信息">修改DOM信息</h3><h4 id="节点宽高：width-、heigth">节点宽高：<em>width()、heigth()</em></h4><p>获取宽高：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;li&#x27;</span>).width();   <span class="comment">// 1860</span></span><br><span class="line">$(<span class="string">&#x27;li&#x27;</span>).heigth();  <span class="comment">// 21.5126</span></span><br></pre></td></tr></table></figure><p>:warning: 经过测试，多个标签显示的是其中一个标签宽高？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#C&#x27;</span>).width();   <span class="comment">// 1860</span></span><br><span class="line">$(<span class="string">&#x27;#C&#x27;</span>).heigth();  <span class="comment">// 21.5126</span></span><br></pre></td></tr></table></figure><p>设置宽高：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#C&#x27;</span>).width(<span class="number">400</span>);   </span><br><span class="line">$(<span class="string">&#x27;#C&#x27;</span>).heigth(<span class="number">1800</span>);  </span><br></pre></td></tr></table></figure><h4 id="节点属性：attr-、removeAttr">节点属性：<em>attr() 、removeAttr()</em></h4><p>获取属性，不存在返回 <em>undefined</em>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#C&#x27;</span>).attr(<span class="string">&#x27;id&#x27;</span>);    <span class="comment">// C</span></span><br><span class="line">$(<span class="string">&#x27;li&#x27;</span>).attr(<span class="string">&#x27;id&#x27;</span>);    <span class="comment">// C#，多个节点返回第一个节点指定属性值</span></span><br><span class="line">$(<span class="string">&#x27;#C&#x27;</span>).attr(<span class="string">&#x27;name&#x27;</span>);  <span class="comment">// undefined，不存在返回undefined</span></span><br></pre></td></tr></table></figure><p>设置属性，类似<em>CSS()</em> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#C&#x27;</span>).attr(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;iamC&#x27;</span>);  <span class="comment">//  &lt;li id=&quot;C&quot; name=&#x27;iamC&#x27;&gt;C&lt;/li&gt;</span></span><br></pre></td></tr></table></figure><p>删除属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#C&#x27;</span>).removeAttr(<span class="string">&#x27;name&#x27;</span>); </span><br></pre></td></tr></table></figure><blockquote><p>特别的，关于一些属性只有出现和没出现两种情况判断，如： <em>checked</em>、<em>selected</em> 。</p></blockquote><p>对于以下HTML结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;test-radio&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果使用<em>attr()</em> 获取 <em>checked</em> 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#test-radio&#x27;</span>).attr(<span class="string">&#x27;checked&#x27;</span>); <span class="comment">// &#x27;checked&#x27;</span></span><br></pre></td></tr></table></figure><p>虽然正确返回了属性值，但是 <em>checked</em> 属性只有[被选中]、[未被选中]两种情况，用 <em>true、false</em>返回更好：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#test-radio&#x27;</span>).is(<span class="string">&#x27;:checked&#x27;</span>); <span class="comment">// true,用is()方法判断更好</span></span><br></pre></td></tr></table></figure><p>:warning: 不知道为什么有时候 <em>attr</em> 设置选中无效，建议使用 <em>prop</em> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#test_checkbox&#x27;</span>).attr(<span class="string">&#x27;checked&#x27;</span>,<span class="string">&#x27;checked&#x27;</span>); <span class="comment">// 选中无效？</span></span><br><span class="line">$(<span class="string">&#x27;#test_checkbox&#x27;</span>).prop(<span class="string">&#x27;checked&#x27;</span>,<span class="literal">true</span>);      <span class="comment">// 可选中</span></span><br></pre></td></tr></table></figure><p><em>selected</em> 等同理不再赘述。</p><h3 id="修改DOM结构">修改DOM结构</h3><h4 id="添加节点">添加节点</h4><p>如果我们要在以下 <em>ul</em>  节点添加子节点 <code>&lt;li id=&quot;python&quot;&gt;python&lt;/li&gt;</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;programLanguage&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;C#&quot;</span>&gt;</span>C#<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;C&quot;</span>&gt;</span>C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>jQuery</em> 虽然提供了<em>html()</em> 方法，但是会修改 <em>ul</em> 节点所有节点。</p><p>为此我们可以利用以下方法：</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center"><em>append(newElem)</em></td><td style="text-align:center">添加子节点<em>newElem</em> 为当前父节点对象 <u>最后一个子节点</u></td></tr><tr><td style="text-align:center"><em>prepend(newElem)</em></td><td style="text-align:center">添加子节点<em>newElem</em> 为当前父节点对象 <u>第一个子节点</u></td></tr></tbody></table><p>如果是同级节点对象，还可以用：</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center"><em>after(newElem)</em></td><td style="text-align:center">添加子节点<em>newElem</em> 为当前节点对象 <u>下一个兄弟子节点</u></td></tr><tr><td style="text-align:center"><em>before(newElem)</em></td><td style="text-align:center">添加子节点<em>newElem</em> 为当前节点对象 <u>前一个兄弟子节点</u></td></tr></tbody></table><blockquote><p>将 <em>python</em> 新节点添加为<em>ul</em> 列表最后一个新节点。</p></blockquote><p>父节点对象方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pl = $(<span class="string">&#x27;#programLanguage&#x27;</span>);</span><br><span class="line">pl.append(<span class="string">&#x27;&lt;li id=&quot;python&quot;&gt;python&lt;/li&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure><p>同级节点对象方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> last = $(<span class="string">&#x27;#programLanguage li:last-child&#x27;</span>);</span><br><span class="line">last.after(<span class="string">&#x27;&lt;li id=&quot;python&quot;&gt;python&lt;/li&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="删除节点">删除节点</h4><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center"><em>remove()</em></td><td style="text-align:center">删除当前节点对象，可作用于多个节点对象。</td></tr></tbody></table><blockquote><p>删除所有列表项。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;li&#x27;</span>).remove();   <span class="comment">// 所有&lt;li&gt;被删除</span></span><br></pre></td></tr></table></figure><h4 id="综合测试">综合测试</h4><blockquote><p>对于以下<em>html</em> 结构：除了列出语言外，请再添加 <em>Pascal、Lua 、Ruby</em>，然后按字母顺序排序节点。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test-div&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> language = [<span class="string">&#x27;Pascal&#x27;</span>,<span class="string">&#x27;Lua&#x27;</span>,<span class="string">&#x27;Ruby&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> ul = $(<span class="string">&#x27;#test-div ul&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; language.length; i++ )</span><br><span class="line">&#123;</span><br><span class="line">    ul.append(<span class="string">&#x27;&lt;li&gt;&lt;span&gt;&#x27;</span> + language[i] + <span class="string">&#x27;&lt;/span&gt;&lt;/li&gt;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有li标签排序</span></span><br><span class="line"><span class="keyword">var</span> lis = ul.find(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">lis.sort</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 不是jQuery对象，而是DOM对象？不能用x.text() &gt; y.text()</span></span><br><span class="line">        <span class="keyword">if</span>(x.innerText &gt; y.innerText)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>                           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加已排序好的li标签</span></span><br><span class="line">ul.html(lis);</span><br></pre></td></tr></table></figure><h3 id="表单输入框值">表单输入框值</h3><p>对于表单元素，<em>jQuery</em> 统一用<em>val()</em> 方法获取 <em>DOM</em> 对象 <em>value</em> 属性，统一输入框取值和赋值问题：</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center"><em>val()</em></td><td style="text-align:center">无参数获取文本框值；有参数设置文本框值。</td></tr></tbody></table><p>对于以下 <em>html</em> 结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>尝试对以上不同 <em>input</em> 类型输入框值操作。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取输入框值</span></span><br><span class="line">$(<span class="string">&#x27;#test-input&#x27;</span>).val();      <span class="comment">// &#x27;test&#x27;</span></span><br><span class="line">$(<span class="string">&#x27;#test-select&#x27;</span>).val();     <span class="comment">// &#x27;BJ&#x27;</span></span><br><span class="line">$(<span class="string">&#x27;#test-textarea&#x27;</span>).val();   <span class="comment">// &#x27;Hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置输入框值</span></span><br><span class="line">$(<span class="string">&#x27;#test-input&#x27;</span>).val(<span class="string">&#x27;abc@example.com&#x27;</span>);   <span class="comment">// 文本框的内容已变为abc@example.com</span></span><br><span class="line">$(<span class="string">&#x27;#test-select&#x27;</span>).val(<span class="string">&#x27;SH&#x27;</span>);               <span class="comment">// 选择框已变为Shanghai</span></span><br><span class="line">$(<span class="string">&#x27;#test-textarea&#x27;</span>).val(<span class="string">&#x27;Hi&#x27;</span>);             <span class="comment">// 本区域已更新为&#x27;Hi&#x27;</span></span><br></pre></td></tr></table></figure><p>对应<em>docment</em> 对象 <em>value</em> 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;#test-input&#x27;</span>).value = <span class="string">&#x27;abc@example.com&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="不要尝试用-attr-方法">不要尝试用 <em>attr()</em> 方法</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;user&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br></pre></td></tr></table></figure><p><em>attr()</em> 方法是用来获取、设置属性，用于文本框会导致意想不到的错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#user&#x27;</span>).attr(<span class="string">&#x27;value&#x27;</span>,<span class="string">&#x27;hwh&#x27;</span>);    <span class="comment">// 成功设置文本框值为:&#x27;hwh&#x27;</span></span><br></pre></td></tr></table></figure><p>但是当我们重新修改文本框值为：‘lt’，再去尝试获取文本框值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#user&#x27;</span>).attr(<span class="string">&#x27;value&#x27;</span>);          <span class="comment">// &#x27;hwh&#x27;</span></span><br></pre></td></tr></table></figure><p>读取结果还是hwh！这是因为实际html结构已经是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;user&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;hwh&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每次读取都是value值， <u>修改文本框内容不会改变value属性</u> 。</p><h2 id="6-3-事件">6.3 事件</h2><p>类似C#事件，常用有鼠标事件、键盘事件、其他事件等。</p><h3 id="鼠标事件">鼠标事件</h3><p>常用鼠标事件，参数为函数用于处理事件：</p><table><thead><tr><th style="text-align:center">事件方法</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center"><em>click(func)</em></td><td style="text-align:center">鼠标单击时触发</td></tr><tr><td style="text-align:center"><em>dblclick(func)</em></td><td style="text-align:center">鼠标双击时触发</td></tr><tr><td style="text-align:center"><em>mouseenter(func)</em></td><td style="text-align:center">鼠标进入时触发</td></tr><tr><td style="text-align:center"><em>mouseleave(func)</em></td><td style="text-align:center">鼠标离开时触发</td></tr><tr><td style="text-align:center"><em>mousemove(func)</em></td><td style="text-align:center">鼠标内部移动时触发</td></tr><tr><td style="text-align:center"><em>hover(func)</em></td><td style="text-align:center">鼠标进入和退出时触发，相当于 <em>mouseenter()</em>+ <em>mouseleave()</em> 。</td></tr></tbody></table><p>存在以下html结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;programLanguage&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;C#&quot;</span>&gt;</span>C#<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;C&quot;</span>&gt;</span>C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>绑定 <em>click</em> 事件，点击 <code>&lt;li#C&gt;</code> 时触发。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> C = $(<span class="string">&#x27;#C&#x27;</span>);</span><br><span class="line">C.click</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        alert(<span class="string">&#x27;hello C!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>有时候还会用到一种 <em>on()</em> 方法绑定事件：</p><table><thead><tr><th style="text-align:center">事件方法</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center"><em>on(evet,func)</em></td><td style="text-align:center"><em>on()</em> 绑定事件，传入事件名称 &amp; 事件处理函数</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> C = $(<span class="string">&#x27;#C&#x27;</span>);</span><br><span class="line">C.on</span><br><span class="line">(<span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        alert(<span class="string">&#x27;hello C!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="事件参数">事件参数</h4><p>所有时间 都会传入<em>Event</em> 对象作为参数，可以获取更多信息。</p><blockquote><p>绑定 <em>mousemove</em> 事件，当鼠标在 <code>&lt;div#testMouseMoveDiv&gt;</code> 区域移动可以获取到鼠标位置。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#testMouseMoveDiv&#x27;</span>).mousemove</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $(<span class="string">&#x27;#testMouseMoveSpan&#x27;</span>).text(<span class="string">&#x27;pageX = &#x27;</span> + e.pageX + <span class="string">&#x27;, pageY = &#x27;</span> + e.pageY);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="键盘事件">键盘事件</h3><p>键盘事件仅作用在当前焦点的DOM上，通常是<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>：</p><table><thead><tr><th style="text-align:center">事件方法</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center"><em>keydown(func)</em></td><td style="text-align:center">键盘按下时触发</td></tr><tr><td style="text-align:center"><em>keyup(func)</em></td><td style="text-align:center">键盘松开时触发</td></tr><tr><td style="text-align:center"><em>keypress(func)</em></td><td style="text-align:center">按一次键后触发</td></tr></tbody></table><p>有以下<em>html</em> 结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;user&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">&quot;check&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;pwd&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br></pre></td></tr></table></figure><blockquote><p>当用户在 <em>&lt;input#user&gt;</em> 输入完毕，右侧 <em>&lt;lable#check&gt;</em> 显示是否已存在用户名。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = $(<span class="string">&#x27;#user&#x27;</span>);</span><br><span class="line">user.change</span><br><span class="line">(      </span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.value === <span class="string">&#x27;hwh&#x27;</span>)</span><br><span class="line">            $(<span class="string">&#x27;#check&#x27;</span>).text(<span class="string">&#x27;用户存在！&#x27;</span>).css(<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            $(<span class="string">&#x27;#check&#x27;</span>).text(<span class="string">&#x27;可以使用！&#x27;</span>).css(<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="其他事件">其他事件</h3><table><thead><tr><th style="text-align:center">事件方法</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center"><em>change(func)</em></td><td style="text-align:center">当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>或<code>&lt;textarea&gt;</code>的内容改变时触发</td></tr><tr><td style="text-align:center"><em>focus(func)</em></td><td style="text-align:center">当 <em>DOM</em> 获得焦点时触发</td></tr><tr><td style="text-align:center"><em>blur(func)</em></td><td style="text-align:center">当 <em>DOM</em> 失去焦点时触发</td></tr><tr><td style="text-align:center"><em>submit(func)</em></td><td style="text-align:center">当<code>&lt;form&gt;</code>提交时触发</td></tr><tr><td style="text-align:center"><em>ready(func)</em></td><td style="text-align:center">当页面被载入并且 <em>DOM</em> 树完成初始化后触发</td></tr></tbody></table><p>有以下<em>html</em> 结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;user&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">&quot;check&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;pwd&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br></pre></td></tr></table></figure><blockquote><p><em>change(func)</em> 事件：当用户在 <em>&lt;input#user&gt;</em> 输入完毕，右侧 <em>&lt;lable#check&gt;</em> 显示是否已存在用户名。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = $(<span class="string">&#x27;#user&#x27;</span>);</span><br><span class="line">user.change</span><br><span class="line">(      </span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.value === <span class="string">&#x27;hwh&#x27;</span>)</span><br><span class="line">            $(<span class="string">&#x27;#check&#x27;</span>).text(<span class="string">&#x27;用户存在！&#x27;</span>).css(<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            $(<span class="string">&#x27;#check&#x27;</span>).text(<span class="string">&#x27;可以使用！&#x27;</span>).css(<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><p><em>change</em> 事件当输入框失去焦点才会触发（移到别处了不再输入了）</p></li><li><p>最好把函数直接写在<em>change</em> 里面，否则不知道为什么触发不了？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.change(changeUserName());  <span class="comment">// 封装好的函数写入不成？</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><em>ready</em> 事件作用于<em>docment</em>对象，当<em>DOM</em>节点都载入浏览器触发：试分析以下错误？</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">        // 代码有误:</span><br><span class="line">        $(&#x27;#testForm).on(&#x27;submit&#x27;, function () </span><br><span class="line">        &#123;</span><br><span class="line">            alert(&#x27;submit!&#x27;);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;testForm&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><script> 标签内js代码在<body>前，DOM 节点还没加载完毕就操作 <form> 节点所以出错。我们可以：- 把<script> 标签在<body>后- 或者，<u>用 *docment* 对象 *read* 事件函数</u> 保证DOM节点都加载完毕 <u>再绑定*submit*事件</u>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     $(<span class="string">&#x27;#testForm).on(&#x27;</span>submit<span class="string">&#x27;, function () </span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            alert(&#x27;</span>submit!<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>  也可以像前一般简化不用on方法：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> $(<span class="built_in">document</span>).on(<span class="string">&#x27;ready&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     $(<span class="string">&#x27;#testForm).submit(function () </span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            alert(&#x27;</span>submit!<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>  甚至*read* 事件还可以再简化： *$(document).on('ready', function ()...*   ---> *$(function ()..*   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;init A...&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>### 事件触发条件事件的触发总是由用户操作引发的，但是，比如用JavaScript代码去改动文本框的值，不会触发`change`事件：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = $(<span class="string">&#x27;#test-input&#x27;</span>);</span><br><span class="line">input.val(<span class="string">&#x27;change it!&#x27;</span>); <span class="comment">// 无法触发change事件</span></span><br></pre></td></tr></table></figure>我们可以通过直接调用无参数 *change()* 方法手动触发事件：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = $(<span class="string">&#x27;#test-input&#x27;</span>);</span><br><span class="line">input.val(<span class="string">&#x27;change it!&#x27;</span>);</span><br><span class="line">input.change(); <span class="comment">// 触发change事件</span></span><br></pre></td></tr></table></figure>#### 浏览器安全限制在浏览器中，有些 *JavaScript* 代码只有在用户触发下才能执行。例如，`window.open()`函数：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法弹出新窗口，将被浏览器屏蔽:</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.open(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>这些“敏感代码”只能由用户操作来触发。### 综合测试有以下 *Form* 表单：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;test-form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>请选择想要学习的编程语言：<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;selectAll&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;selectAll&quot;</span>&gt;</span>全选<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;deselectAll&quot;</span>&gt;</span>全不选<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lang&quot;</span> <span class="attr">value</span>=<span class="string">&quot;python&quot;</span>&gt;</span> Python<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lang&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ruby&quot;</span>&gt;</span> Ruby<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lang&quot;</span> <span class="attr">value</span>=<span class="string">&quot;haskell&quot;</span>&gt;</span> Haskell<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lang&quot;</span> <span class="attr">value</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span> Scheme<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>> 要求完成：>> - 当用户勾上“全选”时，自动选中所有语言，并把“全选”变成“全不选”> - 当用户去掉“全不选”时，自动不选中所有语言，并把“全不选”变成“全选”<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    form = $(<span class="string">&#x27;#test-form&#x27;</span>),</span><br><span class="line">    langs = form.find(<span class="string">&#x27;[name=lang]&#x27;</span>),</span><br><span class="line">    selectAll = form.find(<span class="string">&#x27;label.selectAll :checkbox&#x27;</span>),</span><br><span class="line">    selectAllLabel = form.find(<span class="string">&#x27;label.selectAll span.selectAll&#x27;</span>),</span><br><span class="line">    deselectAllLabel = form.find(<span class="string">&#x27;label.selectAll span.deselectAll&#x27;</span>),</span><br><span class="line">    invertSelect = form.find(<span class="string">&#x27;a.invertSelect&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置初始化状态:</span></span><br><span class="line">form.find(<span class="string">&#x27;*&#x27;</span>).show().off();</span><br><span class="line">form.find(<span class="string">&#x27;:checkbox&#x27;</span>).prop(<span class="string">&#x27;checked&#x27;</span>, <span class="literal">false</span>).off();</span><br><span class="line">deselectAllLabel.hide();</span><br><span class="line"><span class="comment">// 拦截form提交事件:</span></span><br><span class="line">form.off().submit(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    alert(form.serialize());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>接上，绑定事件：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isAllSelected = <span class="literal">false</span>;</span><br><span class="line">selectAll.click</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!isAllSelected )</span><br><span class="line">        &#123;</span><br><span class="line">            langs.each</span><br><span class="line">            (</span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                不能用lambada表达式，应该下面this都未绑定正确？</span></span><br><span class="line"><span class="comment">                经过测试在function()&#123;...&#125; this绑定正确。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="comment">// () =&gt; this.checked = &#x27;checked&#x27;     </span></span><br><span class="line">                <span class="comment">// () =&gt; $(this).prop(&#x27;checked&#x27;,true)</span></span><br><span class="line">   </span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">                </span>&#123;     </span><br><span class="line">                    <span class="comment">/* attr无法成功设置属性 ：不起作用？ */</span></span><br><span class="line">                    <span class="comment">// $(this).attr(&#x27;checked&#x27;,&#x27;checked&#x27;) ;  </span></span><br><span class="line"></span><br><span class="line">                    $(<span class="built_in">this</span>).prop(<span class="string">&#x27;checked&#x27;</span>,<span class="literal">true</span>);        <span class="comment">// 测试成功</span></span><br><span class="line">                &#125;            </span><br><span class="line">           )</span><br><span class="line">           deselectAllLabel.show();</span><br><span class="line">           selectAllLabel.hide();</span><br><span class="line">           selectAll.prop(<span class="string">&#x27;checked&#x27;</span>,<span class="literal">false</span>);</span><br><span class="line">           isAllSelected = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            langs.each</span><br><span class="line">            (</span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                不能用lambada表达式，应该下面this都未绑定正确？</span></span><br><span class="line"><span class="comment">                经过测试在function()&#123;...&#125; this绑定正确。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="comment">// () =&gt; this.checked = &#x27;checked&#x27;     </span></span><br><span class="line">                <span class="comment">// () =&gt; $(this).prop(&#x27;checked&#x27;,true)</span></span><br><span class="line">   </span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">                </span>&#123;     </span><br><span class="line">                    <span class="comment">/* attr无法成功设置属性 ：不起作用？ */</span></span><br><span class="line">                    <span class="comment">// $(this).attr(&#x27;checked&#x27;,&#x27;checked&#x27;) ;  </span></span><br><span class="line"></span><br><span class="line">                    $(<span class="built_in">this</span>).prop(<span class="string">&#x27;checked&#x27;</span>,<span class="literal">false</span>);        <span class="comment">// 测试成功</span></span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">            deselectAllLabel.hide();</span><br><span class="line">            selectAllLabel.show();</span><br><span class="line">            isAllSelected = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>可以利用*jQuery* 批量操作特点，不用*each()*遍历:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isAllSelected = <span class="literal">false</span>; <span class="comment">// 判断此时单选框是：全部勾选 OR 全不勾选</span></span><br><span class="line">selectAll.click</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isAllSelected )  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 全部勾选</span></span><br><span class="line">            langs.prop(<span class="string">&#x27;checked&#x27;</span>,<span class="literal">true</span>); </span><br><span class="line">            <span class="comment">// 全选隐藏、全不选显示</span></span><br><span class="line">            deselectAllLabel.show();</span><br><span class="line">            selectAllLabel.hide();</span><br><span class="line">            selectAll.prop(<span class="string">&#x27;checked&#x27;</span>,<span class="literal">false</span>);</span><br><span class="line">            isAllSelected = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 全部取消勾选</span></span><br><span class="line">            langs.prop(<span class="string">&#x27;checked&#x27;</span>,<span class="literal">false</span>); </span><br><span class="line">            <span class="comment">// 全选显示，全不选隐藏</span></span><br><span class="line">            deselectAllLabel.hide();</span><br><span class="line">            selectAllLabel.show();</span><br><span class="line">            isAllSelected = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>## 6.4 动画用 *JavaScript* 实现动画，比如实现淡出效果，让选中元素在1s内改变 *CSS*  *opacity（透明度）*  属性值至0。本质都是通过修改CSS属性，*jQuery* 封装了函数让这一切变得更加简单。### 逐渐显隐无参数的 *show()、hide()* 方法直接显示、隐藏元素；有参数指定时间可以实现动画效果。|            方法            |                             描述                             || :------------------------: | :----------------------------------------------------------: ||  *show(timeSeconds,func)*  | 在指定 *timeSeconds* 显示全部，*func* 指定显示完成后指定的方法 ||  *hide(timeSeconds,func)*  | 在指定 *timeSeconds* 隐藏全部，*func* 指定显示完成后指定的方法 || *toggle(timeSeconds,func)* |         根据当前状态，自动调用 *show()、hide()* 方法         |- *timeSeconds* 以毫秒为单位，同时可以用 *‘slow’、‘fast’* 等特殊字符串作为参数值。- 显示过程是从左上角 ---> 展开铺满整个平面 ；隐藏则是从右下角 --> 隐藏整个平面。> :slightly_smiling_face: 简单实例 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">&#x27;#test-show-hide&#x27;</span>);</span><br><span class="line"><span class="comment">// 在1秒钟内逐渐消失</span></span><br><span class="line">div.hide(<span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在0.6秒钟内逐渐显示</span></span><br><span class="line">div.show(<span class="string">&#x27;slow&#x27;</span>); </span><br></pre></td></tr></table></figure>就像此前说过，上面显示是从左上展开，下面方法可以从垂直方法逐渐展开、收缩 ~ just like 拉窗帘。|              方法               |       描述       || :-----------------------------: | :--------------: ||   *slideUp(timeSeconds,func)*   |   拉窗帘般显示   ||  *slideDown(timeSeconds,func)*  | 拉窗帘般收起隐藏 || *slideToggle(timeSeconds,func)* | 自动调用上面方法 |### 淡入淡出*fadeIn()  、fadeOut()* 可通过不断设置 *DOM* *CSS* *opacity* 属性来实现淡入淡出动画效果。|              方法              |       描述       || :----------------------------: | :--------------: ||   *fadeIn(timeSeconds,func)*   |     淡入显示     ||  *fadeOut(timeSeconds,func)*   |     淡出隐藏     || *fadeToggle(timeSeconds,func)* | 自动调用上面方法 |存在以下表格：![1565600702619](https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1565600702619.png)> 试完成以下代码，使得每次删除表中第一项可以淡出显示。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteFirstTR</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tr = $(<span class="string">&#x27;#test-table&gt;tbody&gt;tr:visible&#x27;</span>).first();</span><br><span class="line">    <span class="comment">// 在以下完成事件绑定...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deleteFirstTR();</span><br></pre></td></tr></table></figure>完成的代码如下：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr.fadeOut(<span class="number">1000</span>,<span class="function">() =&gt;</span> tr.remove());</span><br></pre></td></tr></table></figure>### 自定义动画对上面提供的动画效果不满意？尝试自定义动画吧。|                 方法                  |                             描述                             || :-----------------------------------: | :----------------------------------------------------------: || *animate(cssStyle，timeSeconds,func)* | 在指定*timeSeconds*  达到预设*cssStyle* 值，最后执行 *func* 函数 |现在我们来试试自定义实现上面淡出删除表格效果吧。> 淡出删除表格。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteFirstTR</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tr = $(<span class="string">&#x27;#test-table&gt;tbody&gt;tr:visible&#x27;</span>).first();</span><br><span class="line">    <span class="comment">// 在以下完成事件绑定...</span></span><br><span class="line">    tr.animate(&#123; <span class="attr">opacity</span>:<span class="number">0</span> &#125;, <span class="number">1000</span>, <span class="function">() =&gt;</span> tr.remove())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deleteFirstTR();</span><br></pre></td></tr></table></figure>### 串行动画如果有两个动画效果：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">&#x27;#test-animates&#x27;</span>);</span><br><span class="line"><span class="comment">// 放大</span></span><br><span class="line">div.animate( &#123; <span class="attr">width</span>: <span class="string">&#x27;256px&#x27;</span>, <span class="attr">height</span>: <span class="string">&#x27;256px&#x27;</span>&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="comment">// 缩小</span></span><br><span class="line">div.animate( &#123; <span class="attr">width</span>: <span class="string">&#x27;128px&#x27;</span>, <span class="attr">height</span>: <span class="string">&#x27;128px&#x27;</span>&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>希望实现放大 --> 缩小 连续动画效果，如果这样简单的连续执行两个动画：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.animate( &#123; <span class="attr">width</span>: <span class="string">&#x27;256px&#x27;</span>, <span class="attr">height</span>: <span class="string">&#x27;256px&#x27;</span>&#125;, <span class="number">2000</span>).animate( &#123; <span class="attr">width</span>: <span class="string">&#x27;128px&#x27;</span>, <span class="attr">height</span>: <span class="string">&#x27;128px&#x27;</span>&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>是无法实现的，因为：*动画需要执行一段时间，所以jQuery必须不断返回新的Promise对象才能后续执行操作* 。所以我们需要借助 *delay()* 方法实现暂停，给予时间返回新的 *Promise* 对象执行后续操作：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div.animate( &#123; <span class="attr">width</span>: <span class="string">&#x27;256px&#x27;</span>, <span class="attr">height</span>: <span class="string">&#x27;256px&#x27;</span>&#125;, <span class="number">2000</span>)</span><br><span class="line">   .delay(<span class="number">1000</span>)</span><br><span class="line">   .animate( &#123; <span class="attr">width</span>: <span class="string">&#x27;128px&#x27;</span>, <span class="attr">height</span>: <span class="string">&#x27;128px&#x27;</span>&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>### 动画没有效果？*jQuery* 动画的原理是逐渐改变 *CSS* 值，而有些情况是无法改变成功的。例如：- *slideUp()* 逐渐把*CSS*属性*height* --> 0，但是非*block* 属性值*DOM* 元素对它们设置 *height* 是不起作用的。- *animate()* 设置 *background-color* 没有效果，因为 *jQuery* 没有实现。]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 基础笔记</title>
      <link href="/2021/11/25/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/11/25/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>第一章：函数基础</h1><h2 id="1-1-字符串">1.1 字符串</h2><h3 id="1-1-1-编码">1.1.1 编码</h3><h4 id="字符串和比特">字符串和比特</h4><p>常见字符串和比特表示方法见下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串表示的两种方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;i am string&#x27;</span>);      <span class="comment"># i am string</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;i am string&#x27;</span>);     <span class="comment"># i am string</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># byte表示：前面加b</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;i am byte&#x27;</span>);    <span class="comment"># b&#x27;i am byte&#x27;</span></span><br></pre></td></tr></table></figure><p>注意到最后<em>byte</em> 字符串输出结果有些奇怪，不像字符串直接输出双引号的内容。</p><p>我们还可以将字符串 <em>str</em> 编码成 <em>bytes</em>：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><em>encode(‘ascii’)</em></td><td style="text-align:center">可将纯英文编码成 <em>bytes</em>，如果含中文编码会出错</td></tr><tr><td style="text-align:center"><em>encode(‘utf-8’)</em></td><td style="text-align:center">可将含中文字符串编码成 <em>bytes</em></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串编码成byte</span></span><br><span class="line">strTobyte = <span class="string">&#x27;hwh&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(strTobyte);  <span class="comment"># 输出：b&#x27;hwh&#x27;</span></span><br><span class="line"></span><br><span class="line">strTobyte = <span class="string">&#x27;黄旺辉&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(strTobyte);  <span class="comment"># 输出：b&#x27;\xe9\xbb\x84\xe6\x97\xba\xe8\xbe\x89&#x27;</span></span><br></pre></td></tr></table></figure><p>当然我们也可以用*decode()*函数进行解码：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><em>decode(‘uft-8’)</em></td><td style="text-align:center">将<em>bytes</em> 变为 <em>str</em></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">b&#x27;\xe9\xbb\x84\xe6\x97\xba\xe8\xbe\x89&#x27;</span>.decode(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(a);     <span class="comment"># 输出：黄旺辉</span></span><br></pre></td></tr></table></figure><h3 id="1-1-2-格式字符串">1.1.2 格式字符串</h3><p>格式化字符串有两种方式：一种类C语言使用%占位符；一种利用 <em>format</em> 方法实现。</p><h4 id="占位符方式">%占位符方式</h4><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">替换内容</th></tr></thead><tbody><tr><td style="text-align:center"><em>%d</em></td><td style="text-align:center">整数</td></tr><tr><td style="text-align:center"><em>%f</em></td><td style="text-align:center">浮点数</td></tr><tr><td style="text-align:center"><em>%s</em></td><td style="text-align:center">字符串</td></tr><tr><td style="text-align:center"><em>%x</em></td><td style="text-align:center">十六进制整数</td></tr></tbody></table><p>还可指定长度、精度等：</p><ul><li>指定长度：%2d —&gt; 表示整数占位2空格，不足补空格； %02d —&gt;同样表示正式占位2空格，但不足补0</li><li>指定精度：%.1f —&gt; 表示小数保留1为小数</li></ul><p>以上为占位符方式，以下为举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%s 今年 %d 岁啦！&#x27;</span>%(<span class="string">&#x27;黄旺辉&#x27;</span>,<span class="number">23</span>)</span><br><span class="line"><span class="string">&#x27;黄旺辉 今年 23 岁啦！&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="format-格式化"><em>format()</em> 格式化</h4><p>在字符串方式<em>format()</em> 内部使用的占位符依次为：{0}、{1} …</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0&#125; 今年 &#123;1&#125; 岁啦！&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;黄旺辉&#x27;</span>,<span class="number">23</span>)</span><br><span class="line"><span class="string">&#x27;黄旺辉 今年 23 岁啦！&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="1-2-list-tuple">1.2 <em>list &amp; tuple</em></h2><h3 id="1-2-1-列表：list">1.2.1 列表：<em>list</em></h3><p><em>list</em> 类似我们此前接触的 <em>C/C++/C#</em> 数组，但是可以每个元素类型可以不同，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">&#x27;Apple&#x27;</span>, <span class="number">123</span>, <span class="literal">True</span>];</span><br></pre></td></tr></table></figure><p>特别的当，当元素类型也为数组时就可以看做一个多维数组了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [[<span class="string">&#x27;C#&#x27;</span>,C<span class="string">&#x27;,&#x27;</span>C++<span class="string">&#x27;],[&#x27;</span>JAVA<span class="string">&#x27;,&#x27;</span>JAVASCRIPT<span class="string">&#x27;],[&#x27;</span>PYTHON<span class="string">&#x27;,&#x27;</span>PHP<span class="string">&#x27;]];</span></span><br></pre></td></tr></table></figure><p>此时获取 <em>JAVASCRIPT</em> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;JAVASCRIPT&#x27;</span></span><br></pre></td></tr></table></figure><p>更多增删查改操作见下。</p><h4 id="索引">索引</h4><p>索引从0开始，<em>python</em> 不但可以使用 <em><u>自然数从正序</u></em> 开始索引，还可以使用 <em><u>负数从倒序</u></em> 开始索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = [<span class="string">&#x27;hwh&#x27;</span>,<span class="string">&#x27;lt&#x27;</span>,<span class="string">&#x27;dxj&#x27;</span>,<span class="string">&#x27;fs&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正序索引从0开始（正序第一个）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;hwh&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 倒序索引从-1开始(倒序第一个)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[-<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;dxj&#x27;</span></span><br></pre></td></tr></table></figure><p>:warning: 索引越界抛出 <em><strong>IndexErro</strong></em> 错误！</p><h4 id="插入">插入</h4><p>给<em>list</em> 插入数据有两种方法：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><em>append(data)</em></td><td style="text-align:center">在<em>list</em> 表<u><em>末尾</em></u> 插入数据</td></tr><tr><td style="text-align:center"><em>insert(index,data)</em></td><td style="text-align:center">在指定 <u><em>位置 index</em></u> 插入数据</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = [<span class="string">&#x27;hwh&#x27;</span>,<span class="string">&#x27;lt&#x27;</span>,<span class="string">&#x27;dxj&#x27;</span>,<span class="string">&#x27;fs&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># append()方法</span></span><br><span class="line">classmates.append(<span class="string">&#x27;lhy&#x27;</span>)</span><br><span class="line">classmates</span><br><span class="line">[<span class="string">&#x27;hwh&#x27;</span>, <span class="string">&#x27;lt&#x27;</span>, <span class="string">&#x27;dxj&#x27;</span>, <span class="string">&#x27;fs&#x27;</span>, <span class="string">&#x27;lhy&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># insert()方法</span></span><br><span class="line">classmates.insert(<span class="number">0</span>,<span class="string">&#x27;ljx&#x27;</span>)</span><br><span class="line">classmates</span><br><span class="line">[<span class="string">&#x27;ljx&#x27;</span>, <span class="string">&#x27;hwh&#x27;</span>, <span class="string">&#x27;lt&#x27;</span>, <span class="string">&#x27;dxj&#x27;</span>, <span class="string">&#x27;fs&#x27;</span>, <span class="string">&#x27;lhy&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="修改">修改</h4><p>要将元素A替换成别的元素B，直接赋值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[-<span class="number">1</span>] = <span class="string">&#x27;赖浩源&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;ljx&#x27;</span>, <span class="string">&#x27;hwh&#x27;</span>, <span class="string">&#x27;lt&#x27;</span>, <span class="string">&#x27;dxj&#x27;</span>, <span class="string">&#x27;fs&#x27;</span>, <span class="string">&#x27;赖浩源&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="删除">删除</h4><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><em>pop(index)</em></td><td style="text-align:center">删除指定位置 <em>index</em>  元素，<em><u>不带参数则删除末尾元素</u></em> ，返回值为被删除的元素</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop();</span><br><span class="line"><span class="string">&#x27;赖浩源&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop(<span class="number">0</span>);</span><br><span class="line"><span class="string">&#x27;ljx&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;hwh&#x27;</span>, <span class="string">&#x27;lt&#x27;</span>, <span class="string">&#x27;dxj&#x27;</span>, <span class="string">&#x27;fs&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="1-2-2-不可变列表：tuple">1.2.2 不可变列表：<em>tuple</em></h3><p><em>tuple</em> 和 <em>list</em> 和相似，但是它里面元素不可以改变，可看做是一个<em>常数列表</em> 。它简单定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (); <span class="comment"># 空列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">&#x27;Apple&#x27;</span>, <span class="number">123</span>, <span class="literal">True</span>);</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[-<span class="number">1</span>];</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>但是注意当只有一个元素时不能写做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span> t = (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这会和 <em>python</em> 数学公式中小括号产生歧义，<em><strong>此时定义的不是 tuple</strong></em> ，而是计算结果1这个数。为此我们需要加一个逗号消除歧义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span> t = (<span class="number">1</span>,);</span><br></pre></td></tr></table></figure><h2 id="1-3-循环">1.3 循环</h2><h3 id="1-3-1-for-循环">1.3.1 <em>for</em> 循环</h3><p>在其它语言循环遍历集合有两种方式：</p><ul><li><em>for、while</em> 循环：根据元素下标遍历集合</li><li><em>foreach</em> 循环：直接获取集合每个元素</li></ul><p><em>python</em> 只有：<em>for、while</em> 两种，但是<em>python</em> 中 <em>for</em> 循环其实更类似于其它语言<em>foreach</em>循环。</p><blockquote><p>C++语言尝试遍历列表：<code>L = ['hwh','lt','dxj','fs']</code> 。</p></blockquote><ol><li><p>遍历 <em>0~length(L)-1</em> 的下标索引来打印出数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length(L); i++)</span><br><span class="line">    <span class="built_in">print</span>(L[i]);</span><br></pre></td></tr></table></figure></li><li><p>利用 <em>foreach</em> 循环，获取列表每个元素打印数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foreach(<span class="built_in">int</span> x <span class="keyword">in</span> L)</span><br><span class="line">    <span class="built_in">print</span>(x);</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><em>python</em> 中遍历：<code>L = ['hwh','lt','dxj','fs']</code>。</p></blockquote><ol><li><p>根据 <em>python</em> <em>for</em> 循环基本类似 <em>foreach</em> 循环获取集合元素特性遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> L:</span><br><span class="line">    <span class="built_in">print</span>(x);</span><br></pre></td></tr></table></figure></li><li><p>巧妙达到用下标索引打印数组</p><p>在 <em>python</em> 中提供 <em>rang(start,end)</em> 函数，可生成 <em>start~end-1</em> 连续整数列表。从而根据下标索引打印数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(L)):</span><br><span class="line">    <span class="built_in">print</span>(L[i]);</span><br></pre></td></tr></table></figure></li></ol><h4 id="更多有关-range-函数">更多有关 <em>range</em> 函数</h4><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><em>range(start,end)</em></td><td style="text-align:center">生成指定从 <em>start~<strong>end-1</strong></em> 连续整数列表</td></tr><tr><td style="text-align:center"><em>range(end)</em></td><td style="text-align:center">生成指定从 <em>0~<strong>end-1</strong></em> 连续整数列表</td></tr></tbody></table><p>注意 <em>range</em> 生成的整数不包含最后一个指定参数整数。</p><blockquote><p>尝试生成列表：<code>[0,1,2,3]</code> 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = <span class="built_in">range</span>(<span class="number">4</span>);</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h3 id="1-3-2-while-循环">1.3.2 <em>while</em> 循环</h3><p><em>while</em> 循环和以前接触相同同，不再赘述。</p><h2 id="1-4-dict-set">1.4 <em>dict &amp; set</em></h2><h3 id="1-4-1-dict">1.4.1 <em>dict</em></h3><p><em>dict</em> 即字典，在别的语言中又称为 <em>map</em> ，都是采用键值对(<code>key-value</code>)形式 ，查找速度极快。且有以下特点：</p><ul><li><em>dict</em> 一个 <em>key</em> 只能对应一个 <em>value</em> ，重复对一个<em>key</em> 赋值会把前面值替换</li></ul><blockquote><p>简单增、删、查、改方式举例。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增：给不存在键值赋值，即可增加一堆键值对</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic[<span class="string">&#x27;shazi&#x27;</span>] = <span class="string">&#x27;lt&#x27;</span>;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic</span><br><span class="line">&#123;<span class="string">&#x27;shazi&#x27;</span>: <span class="string">&#x27;lt&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查：直接根据键值查找</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic[<span class="string">&#x27;shazi&#x27;</span>];</span><br><span class="line"><span class="string">&#x27;lt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改：给存在的键值赋新值，即可改</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic[<span class="string">&#x27;shazi&#x27;</span>] = <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic</span><br><span class="line">&#123;<span class="string">&#x27;shazi&#x27;</span>: <span class="string">&#x27;fs&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删：pop(key)方法即可删除</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic.pop(<span class="string">&#x27;shazi&#x27;</span>);</span><br><span class="line"><span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>还可利用 *get(key,returnValue)*验证指定键值是否存在：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断键值是否存在：不存在指定返回-1（如果不指定返回None，但是在交互环境什么都不显示）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic.get(<span class="string">&#x27;shazi&#x27;</span>,-<span class="number">1</span>);</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="1-4-2-set">1.4.2 <em>set</em></h3><p><em>set</em> 和 <em>dict</em> 类似，<em><strong>是一组 key 集合</strong></em> ，但不存储 <em>value</em> ，且：</p><ul><li><em>set</em> 中 <em>key</em> 值不能重复</li><li><em>set</em> 和 <em>dict</em> 都不是有序的</li></ul><p>创建一个<em>set</em> ，需要 <em>list</em> 作为输入集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>简单 <em>set</em> 增、删、改、查如下。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增：add方法，参数是字符串类型，带双引号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删：remove方法，参数是字符串类型，带双引号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查：必须要先转换为list类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = <span class="built_in">list</span>(s);</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">0</span>];</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p><em>set</em> 可以看做数学意义上无序、重复元素集合。因此还可以做交集、并集等操作。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="built_in">set</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-函数">1.5 函数</h2><h3 id="1-5-1-基本定义">1.5.1 基本定义</h3><blockquote><p>下面展示了在 <em>python</em> 如何定义一个函数（注意冒号），且带默认参数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 没有三目运算符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span>(<span class="params">x,y = <span class="number">5</span></span>):</span> </span><br><span class="line">    <span class="keyword">if</span> x &gt; y :</span><br><span class="line">        <span class="keyword">return</span>  x;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> y;</span><br></pre></td></tr></table></figure><p>在上面除了必选参数、默认参数还有：</p><ul><li>可变参数：定义为可变的参数的形参，接收的实参可以是多个（组成 <em>tuple</em> ）</li><li>关键字参数：定义为关键字的参数的形参，接收的实参可以是多个（组成 <em>dict</em> ）</li><li>命名关键字参数：通过分隔符 <code>*</code> 可限制关键字参数的名字</li></ul><p>以上在下节 <em><strong>1.5.2</strong></em> 会详细讲述，我们再来看一下 <em>python</em> 其它特性。</p><h4 id="可变和不可变对象">可变和不可变对象</h4><blockquote><p>什么是可变/不可变对象？</p></blockquote><p>简单来说：就是可变对象A充当函数<em><strong>实参</strong></em> 时，函数内部对 <em><strong>形参</strong></em> A进行修改，会同步改变A。</p><p>这是因为可变对象传递的是一个地址（引用传递），而不可变对象传递的是一份拷贝（值传递）！</p><p>常见可变对象/不可变对象：</p><ul><li>不可变对象：<em>Number ,String , Tuple，bool</em></li><li>可变对象：<em>List , Set , Dictionary</em></li></ul><h4 id="匿名函数">匿名函数</h4><p><em>python</em> 中匿名函数直接用 <em>lambda</em> 表达式表达，其语法格式为：</p><ul><li><code>lambda  参数列表 : 执行语句</code><ul><li>执行语句只有 <em><strong>一条</strong></em>，不用写 <code>return</code> ，返回值就是表达式结果。</li></ul></li></ul><blockquote><p>筛选出所有奇数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> n:n%<span class="number">2</span>==<span class="number">1</span>, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)))</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>] </span><br></pre></td></tr></table></figure><h3 id="1-5-2-返回值">1.5.2 返回值</h3><h4 id="return-返回多个值"><em>return</em> 返回多个值</h4><p>在 <em>python</em> 函数中可以返回多个值，但实际它返回的是一个元组 <em>tuple</em>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;</span><br><span class="line"><span class="built_in">print</span>(test());   <span class="comment"># (1, 2, 3)</span></span><br></pre></td></tr></table></figure><p>这个时候利用解构赋值，可以接收函数返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x,y,z = test();  <span class="comment"># x=1 y=2 z=3</span></span><br></pre></td></tr></table></figure><h4 id="返回函数-闭包">返回函数 &amp; 闭包</h4><blockquote><p>参照：<em>JavaScript</em> 笔记 &amp; <a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">阮一峰的闭包博客</a> 。</p></blockquote><p>:slightly_smiling_face: 什么是闭包？</p><p>简单来说，就是一个函数，内部定义了一个函数并返回。</p><p>:slightly_smiling_face: 为什么要有闭包？</p><ul><li>读取函数内部变量</li><li>让变量值始终保存在内存中</li></ul><p>下面开始详细介绍闭包两个作用。</p><blockquote><p>读取函数变量值。</p></blockquote><p>我们知道，根据作用域规则 <em><strong>函数内部的变量、参数是无法被外部获取</strong></em> 的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def test(a):</span><br><span class="line">    b = 1;</span><br><span class="line"></span><br><span class="line">a;  # 错误：无法读取</span><br><span class="line">b;  # 错误：无法读取</span><br></pre></td></tr></table></figure><p>但是，如果我在内部再定义一个子函数，返回变量、参数，最后再返回该子函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a</span>):</span></span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">        <span class="keyword">return</span>  a,b;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">f = test(<span class="number">0</span>);</span><br><span class="line">a,b = f();</span><br><span class="line"><span class="built_in">print</span>(a,b);   <span class="comment"># 输出：0 1</span></span><br></pre></td></tr></table></figure><p>这样闭包便起到函数内、外部沟通的桥梁。</p><blockquote><p>让变量始终保存在内存中。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span>():</span></span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f3</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x;</span><br><span class="line">        x += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x ;  <span class="comment"># 直接 return x+=1 出错？</span></span><br><span class="line">    <span class="keyword">return</span> f3;</span><br><span class="line">f3 = test3();</span><br><span class="line"><span class="built_in">print</span>(f3());  <span class="comment"># 输出：1</span></span><br><span class="line"><span class="built_in">print</span>(f3());  <span class="comment"># 输出：2</span></span><br><span class="line"><span class="built_in">print</span>(f3());  <span class="comment"># 输出：3</span></span><br></pre></td></tr></table></figure><ul><li>在内部子函数 <code>f3()</code> 对<code>x</code>进行修改，会屏蔽掉外部函数对 <code>x</code> 定义，这样内部函数 <code>f3()</code> 使用 <code>x</code> 会显示未定义。所以必须使用 <code>nonlocal</code>  关键字，让编译器知道这是前面已定义的 <code>x</code>。</li></ul><blockquote><p>为什么每次调用 <code>f3()</code> 输出的值都不一样？</p></blockquote><p>这是因为函数内部定义了子函数形成了闭包，函数的变量<code>x</code>都会保存在内存中，并没有消亡。</p><h5 id="不要引用循环变量！">不要引用循环变量！</h5><p>子函数（返回函数）不要引用循环变量！这是因为返回函数不会立即执行，直到调用它才会执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>():</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">             <span class="keyword">return</span> i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br></pre></td></tr></table></figure><p><code>count()</code> 函数尝试返回 <code>i = 1,2,3</code> 对应的不同函数。当我们尝试去执行它们：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p>发现函数执行结果都是 9，这是因为返回的函数<code>f1、f2、f3</code>没有立即执行。而当执行它们是 <code>i</code> 都已经是9了。</p><h3 id="1-5-3-函数参数">1.5.3 函数参数</h3><h4 id="可变参数">可变参数</h4><p>试想如果一个函数接收参数不确定，比如计算用户输入的若干数字之和。当然我们可以用 <em><u>列表接收多个参数</u></em>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="built_in">sum</span> += x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]); // <span class="number">15</span></span><br></pre></td></tr></table></figure><blockquote><p>采用可变参数形式，来接收多个参数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="built_in">sum</span> += x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); // <span class="number">15</span></span><br></pre></td></tr></table></figure><p>可见相比用列表接收参数，在 <em><strong>调用时不用传递一个列表而是一个个传递参数即可</strong></em>，简洁明了。</p><p>如果定义了可变参数，又想传递一个列表呢？在调用时加上<code>*</code> 即可 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(*L)); // <span class="number">15</span></span><br></pre></td></tr></table></figure><h4 id="关键字参数">关键字参数</h4><p>关键字参数类同可变参数，但它不同于可变参数接收多个参数组成 <em>tuple</em> 而是组成一个 <em>dict</em> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name,age,**other</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(other);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：&#123;&#x27;university&#x27;: &#x27;chongqingU&#x27;, &#x27;city&#x27;: &#x27;fuzhou&#x27;&#125;</span></span><br><span class="line">person(<span class="string">&#x27;hwh&#x27;</span>, <span class="number">20</span>, university=<span class="string">&#x27;chongqingU&#x27;</span>, city=<span class="string">&#x27;fuzhou&#x27;</span>); </span><br></pre></td></tr></table></figure><p>同样的它也解决 传递若干参数不用传递一个<em>dict</em> ，而是传递一个个 <code>key:value</code> 值就可以了 。</p><p>同前，如果已经定义了关键字参数，又想传递一个<em>dict</em> ，加上 <code>**</code> 即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;university&#x27;</span>: <span class="string">&#x27;chongqingU&#x27;</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;fuzhou&#x27;</span>&#125;;</span><br><span class="line">person(<span class="string">&#x27;hwh&#x27;</span>, <span class="number">20</span>, **dic);</span><br></pre></td></tr></table></figure><p>:warning: <em>other</em> 获取的是 <em>dic</em> 一份拷贝，对 <em>other</em> 修改不会影响 <em>dic</em> 。</p><h4 id="命名关键字参数">命名关键字参数</h4><p>在上述关键字参数中，会将传递进来的若干 <code>key:value</code> 参数组成 <em>dict</em> 。但是，有时候我们希望<em><strong>传递的 <code>key</code> 为指定名字，且个数被限定</strong></em> 。</p><p>这个时，可以使用命名关键字，不同于关键字参数 <code>**other</code> ，命令关键字使用一个特殊分隔符 <code>*</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name,age,*,Uni,City</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(name,age,Uni,City);</span><br><span class="line"></span><br><span class="line">person(<span class="string">&#x27;hwh&#x27;</span>,<span class="number">23</span>,Uni = <span class="string">&#x27;chongQingU&#x27;</span>,City = <span class="string">&#x27;fuzhou&#x27;</span>); <span class="comment"># hwh 23 chongQingU fuzhou</span></span><br></pre></td></tr></table></figure><p>在以下情况，没有传递正确命名关键字参数会出错：</p><ul><li><p>传递参数不带 <em>key</em>，只传 <em>value</em> 值 ，出错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person(<span class="string">&#x27;hwh&#x27;</span>,<span class="number">23</span>,<span class="string">&#x27;chongQingU&#x27;</span>,<span class="string">&#x27;fuzhou&#x27;</span>); <span class="comment"># 出错</span></span><br></pre></td></tr></table></figure></li><li><p>或者不是 <em>key</em> 值并不是限定的名字，出错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person(&#x27;hwh&#x27;,23,u=&#x27;chongQingU&#x27;,c=&#x27;fuzhou&#x27;); # 出错</span><br></pre></td></tr></table></figure></li><li><p>或传递了多余参数，出错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person(<span class="string">&#x27;hwh&#x27;</span>,<span class="number">23</span>,Uni = <span class="string">&#x27;chongQingU&#x27;</span>,City = <span class="string">&#x27;fuzhou&#x27;</span>,height = <span class="number">173</span>); <span class="comment"># 出错</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="关键字组合">关键字组合</h4><p>必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是顺序：</p><ul><li>必选参数 、 默认参数 、可变参数、命名关键字参数、关键字参数！</li></ul><h2 id="1-6-基本类型转换">1.6 基本类型转换</h2><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1567756264372.png" alt="1567756264372"></p><h1>第二章：高级特性</h1><h2 id="2-1-切片">2.1 切片</h2><blockquote><p>试想下有一数组和字符串，如何获取它们各自前三个元素？</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>];</span><br><span class="line">S = <span class="string">&#x27;python.py&#x27;</span>;</span><br></pre></td></tr></table></figure><p>我们可以联想到 ：C# 中 <em>substring()</em> 进行 <u>字符串</u> 截取；<em>JavaScript</em> 中 <em>slice()</em> 方法，进行 <u>数组、字符串</u> 截取。</p><p>在 <em>python</em> 中提供了类似 <em>JavaScript</em> 中 <em>slice()</em> 方法 ，进行更加优雅的 <u>列表（数组）、元组、字符串</u> 截取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.截取数组</span></span><br><span class="line"><span class="comment"># 第一个索引是0，还可以省略，L[:3]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">0</span>:<span class="number">3</span>]  </span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.截取字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>S[:<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;pyt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.截取元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[:<span class="number">3</span>]</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><ul><li><p>第二个索引值一定要比第二个索引大！特别注意负数情况</p></li><li><p>第一个索引是0，可以省略；最后一个索引是列表长度，也可以省略</p><blockquote><p>所以，下面获取的是整个列表。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-1-1-切片更多技巧">2.1.1 切片更多技巧</h3><ol><li><p>索引使用负数</p><p>注意，第二个索引一定要比第一个索引大，换言之只能从数组头到尾方向切片！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>];</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[-<span class="number">6</span>:-<span class="number">2</span>];</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p>指定间隔取数</p><p><code>L[s:e:j]</code> : 截取数组指定 <code>[s:e]</code> 范围， 然后每隔 <code>j</code> 个数取出数，返回一个新数组。</p><blockquote><p>取出数组下标为奇数元素。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>];</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">1</span>::<span class="number">2</span>]</span><br><span class="line">[<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-2-列表生成式">2.2 列表生成式</h2><p>什么是列表生成式？简而言之，就是快速创建列表的表达式，类似 <em>lambada</em> 表达式生成函数。</p><p>生成式格式：<code>[变量运算表达式 变量来源表达式 限制变量表达式 ]</code></p><p>最简单的利用 <em>range(s,e)</em> 来生成一个列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>利用列表生成式可写作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><blockquote><p>变形1：在 1 - 11 中删选出为偶数的数字，且开平方作为为列表元素。</p></blockquote><p>我们需要改变元素运算表达式开方，和增加限制变量表达式判断是否为偶数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>) <span class="keyword">if</span> x%<span class="number">2</span> == <span class="number">0</span>]; <span class="comment"># 注意，判断条件是 == 号</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><blockquote><p>变形2：将字典 <code>&#123;1:'one',2:'two',3:'three'&#125;</code>  变为列表 <code>['1=one','3=three']</code> 。</p></blockquote><p>利用 <em>for</em> 循环迭代字典获取 <em>key、value</em>，在元素运算表达式中拼接即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">str</span>(k)+<span class="string">&#x27;=&#x27;</span>+v <span class="keyword">for</span> k,v <span class="keyword">in</span> &#123;<span class="number">1</span>:<span class="string">&#x27;one&#x27;</span>,<span class="number">2</span>:<span class="string">&#x27;two&#x27;</span>,<span class="number">3</span>:<span class="string">&#x27;three&#x27;</span>&#125;.items() <span class="keyword">if</span> k!=<span class="number">2</span> ];</span><br><span class="line">[<span class="string">&#x27;1=one&#x27;</span>, <span class="string">&#x27;3=three&#x27;</span>]</span><br></pre></td></tr></table></figure><p>前面都是 <code>if</code> 判断条件都限制遍历的集合，下例可以限制生成的值。</p><blockquote><p>遍历<code>['hwh','lt','fs']</code> ,如果是 <code>'hwh'</code>就对应生成列表对应元素数字1，否则生成0。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span> <span class="keyword">if</span> name==<span class="string">&#x27;hwh&#x27;</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> name <span class="keyword">in</span> [<span class="string">&#x27;hwh&#x27;</span>,<span class="string">&#x27;lt&#x27;</span>,<span class="string">&#x27;fs&#x27;</span>] ]</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="2-3-生成器">2.3  生成器</h2><p>在前面我们利用 <em>列表生成式</em>  可以快速生成列表。但是：</p><blockquote><p>如果生成列表很大，如百万个元素，但后面很多元素当前不会用到，浪费空间存储又必须要保存怎么办呢？</p></blockquote><p>这个时候就可以利用生成器，<em>只保存列表元素的推算算法</em>，需要用到时可以不断推算出来。</p><p>创建一个 <em>generator</em> 和 列表生成式很像，只不过把 <code>[]</code> 变为了 <code>()</code> :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</span><br></pre></td></tr></table></figure><p>直接打印 <em>g</em> 是不会显示生成的列表，因为保存的是推算算法，我们可以利用 <em>next()</em> 函数 或者 直接 <em>for</em> 循环迭代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment"># 注意：因为已经前面已经next获取到2了，下面是从3开始打印</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> g:</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(x);</span><br><span class="line"><span class="meta">... </span>   </span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="2-3-1-yield-返回：进一步理解生成器">2.3.1 <em>yield</em> 返回：进一步理解生成器</h3><p>观测下面有多个 <em>yield</em> 返回值函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">g</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line"><span class="meta">... </span>    yiled <span class="number">2</span>;</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o = g();</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o</span><br><span class="line">&lt;generator <span class="built_in">object</span> g at <span class="number">0x000001B9C07059A8</span>&gt;</span><br></pre></td></tr></table></figure><p>可以看到，<em><strong>函数返回</strong></em> 的是一个 <em>generator</em> 对象，类似的可以通过 *next()*函数 或者 <em>for</em> 迭代 获取多个返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)</span><br><span class="line">Traceback (most recent call last):</span><br></pre></td></tr></table></figure><p>在这里，我们基本就可以明白，生成器  <code>(表达式)</code> 本质是生成了一个有多个 <em>yield</em> 返回值的 <em>generator</em> 对象。</p><blockquote><p>我们还可以将 <em>斐波拉契数列</em> 利用生成器依次打印出来。</p></blockquote><p>常规定义的 <code>fib()</code> 函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="built_in">print</span> b   <span class="comment"># 打印生成的数字</span></span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br></pre></td></tr></table></figure><p>我们只需要将本该打印数字 <code>print b</code>  ，变为返回 <code>yeild b</code> 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b   <span class="comment"># 打印生成的数字</span></span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br></pre></td></tr></table></figure><p>然后利用函数返回 <em>generator</em> 对象打印出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f = fib(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">next</span>(f);</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="built_in">next</span>(f);</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="built_in">next</span>(f);</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="built_in">next</span>(f);</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>注意：<em>generator</em> 对象拿不到 <em>return</em> 语句的返回值。</p><h2 id="2-4-for-迭代">2.4 <em>for</em> 迭代</h2><blockquote><p>什么是迭代？</p></blockquote><p>在其它语言也有类似的迭代器概念，换言之就是如何一种方式遍历各种类型数据结构集合。</p><p><em>python</em> 中 <em>for</em> 循环是一种比其它语言 <em>for</em> 更高度抽象的概念，可直接作用于 <em>for</em> 循环迭代的数据类型有：</p><ul><li>集合类型：如 <code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等</li><li><code>generator</code> 类型：包括 生成器 、带 <em>yield</em> 的 <code>generator</code> 函数</li></ul><h3 id="2-4-1-集合类型迭代">2.4.1 集合类型迭代</h3><ol><li><p>迭代 <em>list &amp; tuple</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(x)</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><blockquote><p>试着分析下面列表迭代，元素类型为元组。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">9</span>)]:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(x, y)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>这里同时引用了<strong>2</strong>个变量：因为列表的元素也是集合类型（元组），可以类似解析构值，将元组值赋值给 x、y。然后每一次循环都赋值一次，遍历所有元组打印。</p><p>:warning: 注意下面 <em>key-value</em> 字典不可以直接解析构值，要先利用 <em>items()</em> 方法变为元组，详情见下。</p></li><li><p>迭代 <em>dict</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代字典key</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;:</span><br><span class="line">   <span class="built_in">print</span>(k);   <span class="comment"># 输出：a c b</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代字典value</span></span><br><span class="line"><span class="comment"># 利用values()方法，将字典类型返回为values组成列表</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;.values():</span><br><span class="line">   <span class="built_in">print</span>(k);   <span class="comment"># 输出：1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时迭代字典 key，value</span></span><br><span class="line"><span class="comment"># 利用items()方法</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;.items():</span><br><span class="line">   <span class="built_in">print</span>(k,v);   <span class="comment"># 输出：a 1   b 2   c 3 </span></span><br></pre></td></tr></table></figure></li><li><p>迭代字符串</p></li></ol>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(c)  <span class="comment"># 输出：A B C</span></span><br></pre></td></tr></table></figure><h3 id="2-4-2-生成器类型迭代">2.4.2 生成器类型迭代</h3><p>生成器类型迭代直接 <em>for… in</em> 循环打印即可，可参见 <em>2.3 生成器</em> 一节。</p><h3 id="2-4-3-关于迭代更多">2.4.3 关于迭代更多</h3><h4 id="判断迭代对象">判断迭代对象</h4><p>判断迭代对象利用 <em>instance()</em> 方法判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterable)   <span class="comment"># str是否可迭代</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], Iterable) <span class="comment"># list是否可迭代</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">123</span>, Iterable)     <span class="comment"># 整数是否可迭代</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="把列表像字典一样迭代">把列表像字典一样迭代</h4><p><em>Python</em> 内置的<code>enumerate(list)</code>函数可以把一个 <em>list</em> 变成 <u>索引-元素对</u> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i, value) </span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> A</span><br><span class="line"><span class="number">1</span> B</span><br><span class="line"><span class="number">2</span> C</span><br></pre></td></tr></table></figure><h1>第三章：函数式编程</h1><h2 id="3-1-高阶函数">3.1 高阶函数</h2><p>所谓高阶函数即指：函数也是变量，从而可作为另一个函数（高阶函数）参数。</p><p>在 <em>JavaScript</em> 中已经详细讲解了 <code>map/reduce 、filter、sorted</code> 等高阶函数 ，但是调用方法、返回值不同：</p><ul><li>调用方法：<em>JavaScript</em>  中是数组对象方法， <code>[1,2,3].map(func)</code>  ; <em>python</em> 中需要传递两个参数 <code>map(func,[1,2,3])</code>  。</li><li>返回值：<em>JavaScript</em> 中直接返回一个列表；<em>python</em> 中返回一个是一个 <em><strong>iterator 惰性序列</strong></em> ，可以用 <em>next() 逐个打印</em> 、 <em>for 循环 迭代打印</em> 、 <em>list() 方法直接转为列表</em> 。</li></ul><p>以下为简单示例。</p><h3 id="3-1-1-高级函数示例">3.1.1 高级函数示例</h3><h4 id="映射：-map">映射： <em>map</em></h4><p><em>map</em> 高级函数可以原列表元素<code>x</code>根据传递的函数 <em>func</em> 依依映射成新值 <code>func(x)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="built_in">map</span>(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(r)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span></span><br></pre></td></tr></table></figure><ul><li><code>r</code> 是一个 <em><strong>iterator 惰性序列</strong></em> 而非列表，需要 <em>list()</em> 转换为列表，当然也可用 <em>next() 、for</em> 循环迭代打印</li></ul><p>事实上，第二个参数并不止可以是列表，还可以是其它可迭代对象集合，比如 <code>str</code>。</p><blockquote><p>利用 <em>map</em> 将字符串  <code>’123456‘</code>  转换成数字列表集合 <code>[1, 2, 3, 4, 5, 6]</code> 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">char2num</span>(<span class="params">s</span>):</span></span><br><span class="line"><span class="meta">... </span>      digits = &#123;<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>:<span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>:<span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>:<span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>:<span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>:<span class="number">9</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">return</span> digits[s]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="built_in">map</span>(char2num,<span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(r);</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>因为 <code>str</code> 也是可迭代对象，在<em>map</em> 函数迭代中中会依次把 <code>str</code> 每个字符当做一次迭代元素。</p><p><code>char2num</code> 函数如果返回的是 <code>return s</code> ，那么最后结果是返回：<code>['1', '2', '3', '4', '5', '6']</code> 。</p><p>由于实际上 <code>char2num</code> 函数是映射返回数字字符对应数字，所以最后结果是：<code>[1, 2, 3, 4, 5, 6]</code> 。</p><h4 id="逐减：reduce">逐减：<em>reduce</em></h4><blockquote><p>把序列<code>[1, 3, 5, 7, 9]</code>变换成整数<code>13579</code>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">x, y</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(fn, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"><span class="number">13579</span></span><br></pre></td></tr></table></figure><blockquote><p>结合上述两例，便可以将 字符串 转换为对应 数字。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">x, y</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">char2num</span>(<span class="params">s</span>):</span></span><br><span class="line"><span class="meta">... </span>    digits = &#123;<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>:<span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>:<span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>:<span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>:<span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>:<span class="number">9</span>&#125;</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> digits[s]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(fn, <span class="built_in">map</span>(char2num, <span class="string">&#x27;13579&#x27;</span>))  <span class="comment"># map 返回的是一个可迭代对象</span></span><br><span class="line"><span class="number">13579</span></span><br></pre></td></tr></table></figure><h4 id="过滤：filter">过滤：<em>filter</em></h4><p><em>filter</em> 把传入的函数作用于每个元素，返回值是 <em><strong>ture 过滤</strong></em>， <em><strong>false 保留</strong></em>。</p><blockquote><p>删除字符串中所有数字。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">isnum</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="meta">... </span>   <span class="keyword">return</span>  <span class="number">1</span> - (<span class="built_in">ord</span>(x) &gt;= <span class="number">48</span> <span class="keyword">and</span> <span class="built_in">ord</span>(x) &lt;= <span class="number">57</span>);</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="built_in">filter</span>(isnum, <span class="string">&#x27;A1B2C3&#x27;</span>);</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(r);</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br></pre></td></tr></table></figure><p>:warning: <em>python</em> <em>bool</em> 运算常见操作误解！</p><ul><li><em>python</em> 中 <code>&amp; |</code> 是位运算，非位运算只能用 <code>and 、or</code> 替换</li><li><em>python</em> 中取反 <code>!b</code> 非法，应该用 <code>1-b</code> 来达到取反效果</li></ul><h4 id="排序：sorted">排序：<em>sorted</em></h4><p><em>sorted(collection,key,reverse)</em> 函数有三个参数：</p><ul><li><em>collection</em> ： 可迭代集合数据类型都可</li><li><em>key</em>：函数变量，指定集合元素进行映射，比如都取绝对值等，但 <em><strong>只会改变排序结果不会改变集合元素</strong></em></li><li><em>reverse</em> ：指定是否反转</li></ul><p>返回值：是一个列表（不同前高阶函数返回的是一个 <em>genrator</em> 对象）。</p><blockquote><p>给指定字符列表 <code>['bob', 'about', 'Zoo', 'Credit']</code> 排序。</p></blockquote><p><em>python</em>会自动按首字母 <code>ASCII</code> 值给字符串数组排序，不用特定指定规则。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>]);</span><br><span class="line">[<span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>接上：将字符串全部变为小写，同时按降序排序。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>],key=<span class="built_in">str</span>.lower,reverse=<span class="literal">True</span>);</span><br><span class="line">[<span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="3-2-装饰器">3.2 装饰器</h2><blockquote><p>明月装饰了我的窗，我装饰了谁的梦？</p></blockquote><p>什么是装饰器？</p><p>在不修改函数的前提下，在代码运行期间动态给函数增加功能，称之为装饰器（<code>Decorator</code>）。</p><p>比如，现在我们有一个函数 <code>now</code> ，希望每次调用它时都能打印调用信息，但又不改动函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2019-9-7&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这个时候我们定义一个装饰器函数 <code>log</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用&quot;</span> + func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw) <span class="comment"># func是now的形参，但now没有参数啊，这里可以传任意参数？</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><ul><li>装饰器本身是一个函数，内部也返回了一个函数</li></ul><p>…</p><p>…</p><p>…</p><h2 id="3-3-偏函数">3.3 偏函数</h2><p>偏函数是一个语法糖，可用来固定函数某个参数（设置默认值）。其调用方式：</p><ul><li><code>functools.partial(func,parameter=value):</code>  <em>func</em>，是要固定的函数；<em>parameter=value</em> 是要固定函数参数及值。</li></ul><blockquote><p>固定 <code>int</code> 函数第二个参数值为 <code>2</code> ，返回函数 <code>int2</code> 使得可默认进行 二进制 --&gt; 十进制 转换。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2 = functools.partial(<span class="built_in">int</span>, base=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">&#x27;1000000&#x27;</span>)</span><br><span class="line"><span class="number">64</span></span><br></pre></td></tr></table></figure><h3 id="3-3-1-关于偏函数参数">3.3.1 关于偏函数参数</h3><p>实际上偏函数参数是：<code>functools.partial(func,*args,**kw)</code>。</p><p>也就是说，下面二者是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int2(<span class="string">&#x27;10010&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kw = &#123; <span class="string">&#x27;base&#x27;</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="built_in">int</span>(<span class="string">&#x27;10010&#x27;</span>, **kw)</span><br></pre></td></tr></table></figure><p>没太明白。</p><p>当传入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max2 = functools.partial(<span class="built_in">max</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>实际上会把<code>10</code>作为<code>*args</code>的一部分自动加到左边，也就是下面二者是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max2(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">args = (<span class="number">10</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">max</span>(*args)</span><br></pre></td></tr></table></figure><h1>第四章：面向对象编程</h1><h2 id="4-1-python-面对对象快速入门">4.1 <em>python</em> 面对对象快速入门</h2><blockquote><p>定义一个类，要求每次创建实例时类属性 <em>count</em> 自动加1，同时可打印成绩</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, score</span>):</span></span><br><span class="line">        Student.count += <span class="number">1</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    stu = Student(<span class="string">&#x27;hwh&#x27;</span>, <span class="number">99</span>)</span><br><span class="line">    <span class="built_in">print</span>(stu.count)   <span class="comment"># 输出：1</span></span><br></pre></td></tr></table></figure><ul><li><em>self</em> ：在类中定义的函数必须要带有<em>self</em> ，它指向类创建的实例对象。</li><li><em>_<em>init</em>_</em> : <em>_<em>init</em>_</em> 是一个特殊的函数用于创建实例时进行初始化。</li><li><em>类属性 count  &amp; 实例属性 name、score</em>：<em>count</em>是类属性它为所有创建的类实例共享 ；<em>name、score</em> 是实例属性，在创建实例的时候会根据传入的参数初始化。</li></ul><h2 id="4-2-面对对象进阶">4.2 面对对象进阶</h2><h3 id="4-2-1-访问限制">4.2.1 访问限制</h3><p>在前面我们定义实例属性，直接用 <code>self.属性名</code> 直接就可以绑定一个实例属性，在<em><strong>外部可以 读取、修改</strong></em>。</p><p>但是如果我们不希望进行修改呢？</p><p>在属性名前加上 <code>__</code> 可变为 <u>私有变量</u>，即 <code>self.__属性名</code> 即可，这样 <em><strong>外部不能访问、不能修改</strong></em> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, score</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_gender</span>(<span class="params">self, score</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(score) != <span class="built_in">str</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;error!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        self.__score = score</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    stu = Student(<span class="string">&#x27;hwh&#x27;</span>, <span class="number">99</span>)</span><br><span class="line">    <span class="comment">#  print(stu.__score)  # 出错，不能访问        </span></span><br></pre></td></tr></table></figure><ul><li><p><code>type</code> 方法可以获取类型属性进行判断，类似的还有 <code>instance</code> 方法。<code>instance</code> 不但可以判断所有<code>type</code> 可判断的类型，还可以方便的判断 <code>类型、实例</code> 之间关系。</p></li><li><p>如果需要外部需要访问，可定义 <code>get、set</code> 方法。</p></li></ul><h4 id="注意！这不是修改私有变量">注意！这不是修改私有变量</h4><p>在前我们尝试打印出私有变量 <code>__score</code> 出错，但是我们尝试修改似乎成功了？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stu.__score = <span class="number">88</span></span><br><span class="line"><span class="built_in">print</span>(stu.__score)  <span class="comment"># 输出：88</span></span><br></pre></td></tr></table></figure><p>其实不然，这和<code>Student</code> 类内部的 <code>__score</code> <u>不是同一个变量</u>，我们尝试利用 <code>get_score</code> 打印出内部私有变量 <code>__score</code> :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(stu.get_gender()) <span class="comment"># 输出：99</span></span><br></pre></td></tr></table></figure><h1>第五章：IO编程</h1><h2 id="5-1-增">5.1 增</h2><p><code>open(filePath,type)</code> 不仅可用于读写文件，还可在没有文件时创建一个新文件。</p><p><code>mkdir(filePath) </code> 可创建一个目录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">    os.makedirs(<span class="string">&#x27;myDir&#x27;</span>)</span><br><span class="line"><span class="comment"># 创建文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;myDir\myTxt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;hello world! \n i \n am \n a \n coder&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><p><code>with open as ...</code> 是 <code>python</code> 提供的文件读写操作简单写法，它等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">r&#x27;myDir\myTxt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">   f.write(<span class="string">&#x27;hello world! \n i \n am \n a \n coder&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure></li><li><p><code>windows</code> 目录路径使用反斜杠<code>\</code>，为了防止和文本其它字母转义，建议前面用 <code>r</code> 或者 双反斜杆 <code>\\</code></p></li></ul><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1568087566520.png" alt="1568087566520"></p><h3 id="5-1-1-打开文件模式">5.1.1 打开文件模式</h3><p><img src="https://www.runoob.com/wp-content/uploads/2013/11/2112205-861c05b2bdbc9c28.png" alt="img"></p><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:center">r</th><th style="text-align:center">r+</th><th style="text-align:center">w</th><th style="text-align:center">w+</th><th style="text-align:center">a</th><th style="text-align:center">a+</th></tr></thead><tbody><tr><td style="text-align:center">读</td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center"></td><td style="text-align:center">+</td><td style="text-align:center"></td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">写</td><td style="text-align:center"></td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">创建</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">覆盖</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">指针在开始</td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">指针在结尾</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">+</td><td style="text-align:center">+</td></tr></tbody></table><h2 id="5-2-删">5.2 删</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除目录</span></span><br><span class="line"> os.rmdir(<span class="string">&#x27;myDir&#x27;</span>)</span><br><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">os.remove(<span class="string">&#x27;test.py&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="5-3-查：读文件等">5.3 查：读文件等</h2><h3 id="5-3-1-文件读">5.3.1 文件读</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><em>read(filePath)</em></td><td style="text-align:center">一次读取所有内容</td></tr><tr><td style="text-align:center"><em>readline(filePath)</em></td><td style="text-align:center">每次读取一行</td></tr><tr><td style="text-align:center"><em>readlines(filePath)</em></td><td style="text-align:center">一次读取所有行，返回列表，每一个元素是一行内容</td></tr></tbody></table><blockquote><p>简单测试读取文本。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;myDir\myTxt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        <span class="built_in">print</span>(line.strip())  <span class="comment"># 去除\n，要不然会多打印换行</span></span><br></pre></td></tr></table></figure><blockquote><p>打印前两行。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;myDir\myTxt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">2</span>):</span><br><span class="line">        <span class="built_in">print</span>(f.readline().strip())  <span class="comment"># 去除\n，要不然会多打印换行</span></span><br></pre></td></tr></table></figure><h4 id="二进制文件-其它编码">二进制文件 &amp; 其它编码</h4><p>如果读取的文件是二进制文件，<em><strong>比如图片、视频</strong></em>  等要用 <code>rb</code> 模式打开文件：</p><blockquote><p>读取二进制文件。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">b&#x27;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&#x27;</span> <span class="comment"># 十六进制表示的字节</span></span><br></pre></td></tr></table></figure><p>如果读取是非UTF-8编码文件，要指定按什么编码格式读取：</p><blockquote><p>读取二进制且编码为<code>gbk</code> 文件。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/gbk.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">&#x27;测试&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="5-3-2-查看其它信息">5.3.2 查看其它信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前文件操作路径</span></span><br><span class="line">os.getcwd()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目录列表（重要）</span></span><br><span class="line"><span class="comment"># 该方法获取的不包括文件路径，仅文件名</span></span><br><span class="line">os.listdir(<span class="string">&quot;./&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="5-4-改：写文件等">5.4 改：写文件等</h2><h3 id="5-4-1-写文件">5.4.1 写文件</h3><p>写文件也是调用 <code>open()</code> 方法，传入标识符 <code>'w'、’wb‘</code> 写文本或者二进制文件。</p><p>也是采用类似读文件 <em>python</em> 提供的一种简易写法，也可同读文件传入 <code>encoding</code> 参数转换编码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="5-4-2-文件重命名等">5.4.2 文件重命名等</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对文件重命名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.rename(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;test.py&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="5-5-序列化与反序列化">5.5 序列化与反序列化</h2><p>序列化：即指可以将把指定类型对象从 内存 —&gt; 磁盘 ；</p><p>反序列化：则可将保存在磁盘的对象从 磁盘 —&gt; 内存 。</p><h2 id="5-5-1-pickle">5.5.1 <em>pickle</em></h2><p><em>python</em> 提供了 <code>pickle</code> 模块来进行任意对象的序列化和反序列化，但它序列化只能用于 <em>python</em>。</p><p>常用序列化、反序列化方法如下：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><em>pickle.dump(obj, fp, [,protocol])</em></td><td style="text-align:center">将任意对象序列化</td></tr><tr><td style="text-align:center"><em>pickle.load(fp)</em></td><td style="text-align:center">将保存在磁盘的<em>bytes</em>对象反序列化</td></tr><tr><td style="text-align:center"><em>pickle.dumps(obj, [,protocol])</em></td><td style="text-align:center">将<em>obj</em> 对象序列化为 <em>string</em> 形式，而不是存入文件中。</td></tr><tr><td style="text-align:center"><em>pickle.loads(string)</em></td><td style="text-align:center">从<em>string</em> 中读出序列化前的 <em>obj</em>对象</td></tr></tbody></table><blockquote><p>以下做一个简单实例将 <em>dict</em> 字典类型序列化与反序列化进行<em>io</em>读写。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 序列化：保存在磁盘中</span></span><br><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;hwh&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;23&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 注意：创建一个写二进制文件file对象</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">      pickle.dump(d,f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反序列化：从磁盘中读取</span></span><br><span class="line"><span class="comment"># 注意：创建一个读二进制文件file对象</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    dic = pickle.load(f)</span><br><span class="line"><span class="built_in">print</span>(dic)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;hwh&#x27;, &#x27;age&#x27;: &#x27;23&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>但是 <em>pickle</em> 模块序列化只用于 <em>python</em> ，如何在不同编程语言传递对象？</p><p>我们需要一种标准格式，比如 <code>XML 、JSON</code> ，<code>json</code> 是一种更好的选择。</p><h3 id="5-5-2-JSON">5.5.2 JSON</h3><p>因为要在不同语言中传递对象，首先要有一种把<em>python</em>对象 —&gt; 通用语(json) ，它们直接对应关系：</p><table><thead><tr><th style="text-align:center"><em>JSON</em> 类型</th><th style="text-align:center"><em>Python</em>类型</th></tr></thead><tbody><tr><td style="text-align:center"><em>{}</em></td><td style="text-align:center"><em>dict</em></td></tr><tr><td style="text-align:center"><em>[]</em></td><td style="text-align:center"><em>list</em></td></tr><tr><td style="text-align:center"><em>“string”</em></td><td style="text-align:center"><em>str</em></td></tr><tr><td style="text-align:center"><em>1234.56</em></td><td style="text-align:center"><em>int 或 float</em></td></tr><tr><td style="text-align:center"><em>true/false</em></td><td style="text-align:center"><em>True/False</em></td></tr><tr><td style="text-align:center"><em>null</em></td><td style="text-align:center"><em>None</em></td></tr></tbody></table><p>类似 <em>pickle</em> 模块，<em>json</em> 模块提供了序列化，反序列化方法：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><em>json.dump(obj, fp…)</em></td><td style="text-align:center">将任意对象序列化</td></tr><tr><td style="text-align:center"><em>json.load(fp)</em></td><td style="text-align:center">将保存在磁盘的<em>bytes</em>对象反序列化</td></tr><tr><td style="text-align:center"><em>json.dumps(obj)</em></td><td style="text-align:center">将<em>obj</em> 对象序列化为 <em>string</em> 形式，而不是存入文件中。</td></tr><tr><td style="text-align:center"><em>json.loads(string)</em></td><td style="text-align:center">从<em>string</em> 中读出序列化前的 <em>obj</em>对象</td></tr></tbody></table><blockquote><p>改写上面 <code>pickle</code> 模块读写。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 序列化：保存在磁盘中</span></span><br><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;hwh&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;23&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 注意：和pickle模块不同这里是 w，不是二进制</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">      json.dump(d,f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反序列化：从磁盘中读取</span></span><br><span class="line"><span class="comment"># 注意：这里是r</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    dic = json.load(f)</span><br><span class="line"><span class="built_in">print</span>(dic)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;hwh&#x27;, &#x27;age&#x27;: &#x27;23&#x27;&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>不进行io读写，<em>dumps()</em> 序列化为 <em>string</em>，然后 <em>loads()</em> 反序列化读取。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 序列化</span></span><br><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;hwh&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;23&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">str</span> = json.dumps(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反序列化</span></span><br><span class="line"><span class="comment"># 注意：这里是r</span></span><br><span class="line">dic = json.loads(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(dic)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;hwh&#x27;, &#x27;age&#x27;: &#x27;23&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="自定义序列化规则">自定义序列化规则</h3><p>在 <em>json</em> 中用 <code>&#123;&#125;</code> 表示对象，对应 <code>python</code> 中 <code>dict</code> 。不过我们一般用 <code>class</code> 表示对象，但是 <code>class</code> 类对象不能直接序列化，需要自己定义序列化规则。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, score</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">student2dict</span>(<span class="params">std</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;name&#x27;</span>:std.name, <span class="string">&#x27;age&#x27;</span>:std.age, <span class="string">&#x27;score&#x27;</span>:std.score&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;hwh&#x27;</span>, <span class="number">20</span>, <span class="number">99</span>)</span><br><span class="line"><span class="comment"># 输出：&#123;&quot;name&quot;: &quot;hwh&quot;, &quot;age&quot;: 20, &quot;score&quot;: 99&#125;</span></span><br><span class="line"><span class="built_in">print</span>(json.dumps(s, default=student2dict)) </span><br></pre></td></tr></table></figure><p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个<code>dict</code>，用来存储实例变量。</p><p>所以还可用 <code>lambda</code> 表达式直接简写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(json.dumps(s, default=<span class="keyword">lambda</span> obj: obj.__dict__))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（一）MySQL基础笔记</title>
      <link href="/2021/11/25/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89MySQL%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/25/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89MySQL%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>第一章 ：初识 MySQL</h1><h2 id="1-1-MySQL-概述">1.1 MySQL 概述</h2><ul><li><p><strong><em>SQL</em> &amp; 各大数据库</strong></p><blockquote><p>什么是 <em>SQL</em>?</p></blockquote><p><em>SQL</em> 是 <em>Structured Query Language</em> （结构化查询语言）缩写 ，可用来对数据库进行：<u>增、删、查、改</u> 等操作。</p><blockquote><p><em>SQL</em> 大小写特点？</p></blockquote><ul><li>关键字：<em>SQL</em> 语言关键字不区分大小写，<u>在本笔记中总是大写</u></li><li>表名 &amp; 列名 ：有些数据库区分、有些不区分 ，<u>在本笔记中总是小写</u></li><li>不同操作系统：同一个数据库可能在Linux上区分大小写，在Windows上不区分大小写。</li></ul><blockquote><p><em>SQL</em> 和各大数据库之间的关系？</p></blockquote><p><em>SQL</em> 已经被<em>ANSI</em>组织定义为标准 ，如果我们使用标准 <em>SQL</em> 语言，理论上所有数据都可以支持。但是各大数据都在标准 <em>SQL</em> 上进行了扩展。</p><p>如果只使用标准 <em>SQL</em> 核心功能，那么所有数据库都可以执行，而对于各个数据库各自 <u>方言</u>（扩展功能），只能在各自数据库下执行。</p></li><li><p><strong>关系模型</strong></p><p><em>mysql</em> 基于关系模型，对应其也就是一般我们常说的关系数据库。</p><blockquote><p>什么是关系模型？</p></blockquote><p>关系模型把数据看作是一个二维表格，任何数据都可以通过*<u>行号 +列号</u>* 来唯一确定：</p><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">姓名</th><th style="text-align:center">班级ID</th><th style="text-align:center">性别</th><th style="text-align:center">年龄</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">小明</td><td style="text-align:center">201</td><td style="text-align:center">M</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">小红</td><td style="text-align:center">202</td><td style="text-align:center">F</td><td style="text-align:center">8</td></tr></tbody></table></li><li><p><strong>关系数据库</strong></p><p>同前，基于关系模型数据库都可称为关系数据库，常用关系数据库可分为：</p><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">商用</td><td style="text-align:center"><em>Oracle、SQL Server、DB2</em></td></tr><tr><td style="text-align:center">开源</td><td style="text-align:center"><em>MySQL，PostgreSQL</em></td></tr><tr><td style="text-align:center">桌面</td><td style="text-align:center"><em>Access</em>：适合桌面应用程序使用</td></tr><tr><td style="text-align:center">嵌入式</td><td style="text-align:center"><em>Sqlite</em>：适合手机应用和桌面程序</td></tr></tbody></table></li><li><p><strong>数据类型</strong></p><p>对于每一个关系表，需要定义：<u>每一列名字</u> &amp; <u>每一列数据类型</u>，常用数据类型如下</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:left"><em>INT</em></td><td style="text-align:left">整型</td><td style="text-align:center">4字节整数类型，范围约 ±21亿</td></tr><tr><td style="text-align:left"><em>BIGINT</em></td><td style="text-align:left">长整型</td><td style="text-align:center">8字节整数类型，范围约 ±922亿亿</td></tr><tr><td style="text-align:left"><em>REAL</em></td><td style="text-align:left">浮点型</td><td style="text-align:center">4字节浮点数，范围约 ±-1038</td></tr><tr><td style="text-align:left"><em>DOUBLE</em></td><td style="text-align:left">浮点型</td><td style="text-align:center">8字节浮点数，范围约 ±10308</td></tr><tr><td style="text-align:left"><em>DECIMAL(M,N)</em></td><td style="text-align:left">高精小数</td><td style="text-align:center">由用户指定精度的小数，例如，<em>DECIMAL(20,10)</em> 表示一共20位，其中小数10位，通常用于财务计算</td></tr><tr><td style="text-align:left"><em>CHAR(N)</em></td><td style="text-align:left">定长字串</td><td style="text-align:center">存储指定长度的字符串，例如，<em>CHAR(100)</em> 总是存储100个字符的字符串</td></tr><tr><td style="text-align:left"><em>VARCHAR(N)</em></td><td style="text-align:left">变长字串</td><td style="text-align:center">存储可变长度的字符串，例如，<em>VARCHAR(100)</em> 可以存储0~100个字符的字符串</td></tr><tr><td style="text-align:left"><em>BOOLEAN</em></td><td style="text-align:left">布尔</td><td style="text-align:center">存储 <em>True</em> 或者 <em>False</em></td></tr><tr><td style="text-align:left"><em>DATE</em></td><td style="text-align:left">日期</td><td style="text-align:center">存储日期，例如，2018-06-22</td></tr><tr><td style="text-align:left"><em>TIME</em></td><td style="text-align:left">时间</td><td style="text-align:center">存储时间，例如，12:20:59</td></tr><tr><td style="text-align:left"><em>DATETIME</em></td><td style="text-align:left">日期 &amp; 时间</td><td style="text-align:center">存储日期+时间，例如，2018-06-22 12:20:59</td></tr></tbody></table><p>还有一些特殊类型：<u><em>JSON</em></u>  等。</p></li></ul><h2 id="1-2-安装-MySQL">1.2 安装 MySQL</h2><p>安装参考：<a href="https://www.cnblogs.com/laumians-notes/p/9069498.html#undefined"><em>MySQL-mysql 8.0.11</em>安装教程</a></p><h3 id="1-2-1-下载">1.2.1 下载</h3><p>点击下载 ：<a href="https://dev.mysql.com/downloads/file/?id=485812"><em>MySQL-8.0.16-winx64.zip</em> 下载地址</a></p><blockquote><p>不用登陆，直接点击下面蓝字：<em>No thanks,just start my download</em> ，即浏览器开始下载。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562490029517.png" alt="1562490029517"></p><h3 id="1-2-2-解压">1.2.2 解压</h3><p>浏览器默认下载 <em>zip</em> 压缩包位置：<em>C:\Users\86151\Downloads\mysql-8.0.16-winx64.zip</em>，解压到你指定位置。</p><p>比如我解压到：<em>D:\软件\mysql-8.0.16-winx64</em></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562490423559.png" alt="1562490423559"></p><h3 id="1-2-3-配置环境变量">1.2.3 配置环境变量</h3><p>常规操作：搜索 <code>高级系统设置 --&gt; 环境变量 --&gt; 系统变量 --&gt; 选中Path --&gt; 新建</code>：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562491794416.png" alt="1562491794416"></p><ul><li><em>变量值</em>：即解压后<em>bin</em>所在目录地址：<em>D:\软件\mysql-8.0.16-winx64\bin</em>。</li></ul><h3 id="1-2-4-初始化-my-ini">1.2.4 初始化 <em>my.ini</em></h3><blockquote><p>由于解压目录并没有发现 <em>my.ini</em> 文件，所以要自行创建，创建位置：<em>D:\软件\mysql-8.0.16-winx64\my.ini</em></p></blockquote><p>新建 <em>.txt</em> 文本文件，写入：</p><blockquote><p>:warning: 注意，下面 <em>basedir &amp; datedir</em> ，一定是你自己的 <em>mysql</em> 安装目录！</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line">port=3306</span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line">basedir=D:\软件\mysql-8.0.16-winx64   <span class="comment"># 切记此处一定要用双斜杠\\</span></span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></span><br><span class="line">datadir=D:\软件\mysql-8.0.16-winx64\\Data   <span class="comment"># 此处同上</span></span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line">max_connections=200</span><br><span class="line"><span class="comment"># 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统</span></span><br><span class="line">max_connect_errors=10</span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为UTF8</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"><span class="comment"># 默认使用“mysql_native_password”插件认证</span></span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line"><span class="comment"># 设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line">port=3306</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure><p>然后重名为：<em>my.ini</em> 即可。</p><h3 id="1-2-5-开始安装mysql">1.2.5 开始安装<em>mysql</em></h3><p>首先注意，安装 <em>mysql</em> 必须以管理员身份运行 <em>cmd</em> ，所以win10下：搜索<em>cmd</em> —&gt; 以管理员身份运行</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562492319408.png" alt="1562492319408"></p><p>然后依次进行以下操作：</p><ol><li><p>切换到 <em>bin</em> 目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt; <span class="built_in">cd</span> D:\软件\mysql-8.0.16-winx64\bin</span><br></pre></td></tr></table></figure></li><li><p>初始化数据库</p><p>出现错误，一般是 <em>my.ini</em> 目录没有配置好，见上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt; mysqld --initialize --console</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562493166195.png" alt="1562493166195"></p><p>注意，上图生成了一个临时密码：<code>I_?6&gt;&amp;l*_sw(</code> ，记住它稍后会用到。</p></li><li><p>安装服务</p><p>使用 <code>mysqld --install [服务名]</code> ，服务名可不写，默认为 <em>mysql</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt; mysqld --install</span><br></pre></td></tr></table></figure><p>然后，通过 <code>net start mysql</code> 启动服务：</p><blockquote><p>出错：服务无法启动。后来发现 <em><a href="http://my.in">my.in</a></em>i 文件的<em>basedir &amp; datedir</em> 没有成功保存修为自己的安装路径。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt; net start mysql</span><br><span class="line">MySQL 服务正在启动 .</span><br><span class="line">MySQL 服务已经启动成功。</span><br></pre></td></tr></table></figure><p>其余补充（以下命令不要执行）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql <span class="comment"># 停止mysql服务</span></span><br><span class="line">sc delete MySQL/mysqld -remove <span class="comment"># 卸载mysql服务</span></span><br></pre></td></tr></table></figure></li><li><p>更改密码</p><p>首先，进入到 <em>mysql</em>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt; mysql -u root -p</span><br></pre></td></tr></table></figure><p>会要求输入密码，密码就是上面生成的临时密码：<code>I_?6&gt;&amp;l*_sw(</code> 。</p><p>正确输入后会进入出现欢迎界面：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562494636697.png" alt="1562494636697"></p><p>然后，键入语句修改密码为 <em>123456</em>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;  </span><br></pre></td></tr></table></figure></li></ol><h1>第二章 ：关系模型</h1><h2 id="2-1-主键">2.1 主键</h2><ul><li><p><strong>记录与字段</strong></p><p>在关系数据库中，一张表中的<u>每一行数据被称为一条记录</u>，一条记录就是由多个字段组成的 。</p><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">class_id</th><th style="text-align:center">name</th><th style="text-align:center">gender</th><th style="text-align:center">score</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">小明</td><td style="text-align:center">M</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">小红</td><td style="text-align:center">F</td><td style="text-align:center">95</td></tr></tbody></table><p>如上图共有 2 条记录，每条记录有 5个字段。</p></li><li><p><strong>主键作用</strong></p><p>主键用来区分不同记录，如上表 <em>id</em> 则可用来区分不同记录。</p></li><li><p><strong>主键选取原则</strong></p><blockquote><p>主键不得轻易修改。</p></blockquote><p>主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。</p><blockquote><p>任何业务相关字段不用作主键。</p></blockquote><p>如，身份证号也是一种业务场景，但是如果身份证号升位、变更，<u>主键不得不修改</u>，对业务产生巨大影响。</p><p>同理，还有：手机号、邮箱号等。</p></li><li><p><strong>主键 <u>id</u> 两种类型</strong></p><p>通常选取和业务完全无关字段，可命名为 <u>id</u> ，常见 <u>id</u>字段类型为：</p><ul><li><p>自增整数类型</p><p>数据库会在插入数据时自动为每一条记录分配一个<u>自增不重复整数</u>，不用自己预先生成主键。</p></li><li><p><em>GUID</em>类型</p><blockquote><p>如：<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code> 是一个 <em>GUID</em> 标识符。</p></blockquote><p><em>GUID</em> 即 <em>Globally Unique Identifier</em>（全球唯一标识符），是微软使用的一个术语，由一个特定的算法，给某一个实体，如Word文档，创建一个唯一的标识，GUID值就是这个唯一的标识码。</p></li></ul></li><li><p><strong>联合主键</strong></p><p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。</p><table><thead><tr><th style="text-align:center">id_num</th><th style="text-align:center">id_type</th><th style="text-align:center">other columns</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">A</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">B</td><td style="text-align:center">…</td></tr></tbody></table><p>如上表，<em>id_num &amp; id_type</em> 同时作为主键标识每一行数据（每一条记录），允许其中一个主键重复，只要不都重复即可。</p></li></ul><h2 id="2-2-外键">2.2 外键</h2><blockquote><p>什么是外键？</p></blockquote><p>在一张表中，通过某个字段，可以把数据可另一张表联系起来，这种列称为外键。</p><p>如，在下列有两张构成 <u><em>一对多</em></u> 关系表中：</p><p>:warning: 一对一、一对多、多对多：描述的是两个表之间的关系，单个表不存在这种描述！</p><p>如：下两表，<em>class</em> 表中 <u>每个</u> 班级可以对应 <em>student</em> 表中 <u>多</u> 个学生，那么这就是<u>一对多</u>关系；</p><p>同理，如果存在一张 <em>studentID</em> 表，<u>每个</u>学号和 <em>student</em> 表 <u>每个</u>学生 一一对应，就是 <u>一对一</u>关系。</p><p>​                                                                             <em><strong>student</strong></em></p><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">name</th><th style="text-align:center">other columns…</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">小明</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">小红</td><td style="text-align:center">…</td></tr></tbody></table><p>​                                                                               <em><strong>class</strong></em></p><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">name</th><th style="text-align:center">other columns…</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">一班</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">二班</td><td style="text-align:center">…</td></tr></tbody></table><blockquote><p>如何在 <em>student</em> 表中，查到小明所属哪个班级呢？</p></blockquote><p>在 <em>student</em> 表中加入字段 <em>class_id</em> ，关联 <em>class</em> 表：</p><p>​                                                                           <em><strong>student</strong></em></p><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">class_id</th><th style="text-align:center">name</th><th style="text-align:center">other columns…</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">小明</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">小红</td><td style="text-align:center">…</td></tr></tbody></table><blockquote><p>如何通过编程实现外键呢？</p></blockquote><p>首先需要在表中增加一列 <em>class_id</em> ，然后添加外键约束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student  </span><br><span class="line">ADD CONSTRAINT fk_class_id  -- 自定义约束名 </span><br><span class="line">FOREIGN KEY (class_id)      -- 指定student表，外键字段</span><br><span class="line">REFERENCES class (id);      -- 指定class表，关联外键字段</span><br></pre></td></tr></table></figure><p>如果需要删除一个外键约束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">DROP FOREIGN KEY fk_class_id;</span><br></pre></td></tr></table></figure><blockquote><p>前面介绍了：一对一、一对多，那么多对多关系如何实现？</p></blockquote><p>我们知道，上面  <em>student</em> 表 &amp; <em>class</em> 表 一对多关系是单向的，一个班级可以对应多个学生，反之不成立。</p><p>如果存在两个表，有双向一对多关系，如下面 <em>teacher</em> 表 &amp; <em>class</em> 表 ：</p><p>​                                                                      <em><strong>teacher</strong></em></p><table><thead><tr><th style="text-align:left">id</th><th style="text-align:left">name</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">张老师</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">王老师</td></tr></tbody></table><p>​                                                                        <em><strong>class</strong></em></p><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">name</th><th style="text-align:center">other columns…</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">一班</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">二班</td><td style="text-align:center">…</td></tr></tbody></table><p>在这两张表中，一个老师可以对应多个班级，一个班级对应多个老师，则是双向一对多关系。</p><p>要实现 <u>多对多</u> ，则通过<u>中间表关联这两个一对多关系</u>即可：</p><p>​                                                                          <em><strong>中间表</strong></em></p><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">teacher_id</th><th style="text-align:center">class_id</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr></tbody></table><h2 id="2-3-索引">2.3 索引</h2><blockquote><p>索引的作用？</p></blockquote><p>索引注意有两个作用：一、加快查找记录速度 ；二、通过 唯一索引 保证某一列值具有唯一性。</p><ul><li><p><strong>加快索引</strong></p><p>如下面存在一个 <em>student</em> 表 ：</p><p>​                                                                   <em><strong>student</strong></em></p><table><thead><tr><th style="text-align:left">id</th><th style="text-align:left">class_id</th><th style="text-align:left">name</th><th style="text-align:left">gender</th><th style="text-align:left">score</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">小明</td><td style="text-align:left">M</td><td style="text-align:left">90</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">1</td><td style="text-align:left">小红</td><td style="text-align:left">F</td><td style="text-align:left">95</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">1</td><td style="text-align:left">小军</td><td style="text-align:left">M</td><td style="text-align:left">88</td></tr></tbody></table><p>我们可以加快 <em>score</em> 列的查询，为其创建索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student </span><br><span class="line">ADD INDEX idx_score(score);</span><br></pre></td></tr></table></figure><p>当然，可以同时为 <em>score</em> 列 &amp; <em>name</em> 列创建索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">ADD INDEX idx_score_name(score,name);</span><br></pre></td></tr></table></figure><blockquote><p>那么是否创建索引一定可以加快索引速度呢？</p></blockquote><p>索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。</p><p>反之，如果记录的列存在大量相同的值，如 <em>gender</em> 列，大约一半记录值是<code>M</code>，另一半是<code>F</code>，对该列创建索引就没有意义，甚至会降低查询速度。</p></li><li><p><strong>唯一索引</strong></p><p>前面说到，一些和业务相关的信息如：身份证号、邮箱地址等，不适合作为主键。但是它们又有唯一性，如何保证它们不重复呢？</p><p>这里，我们可以为其添加唯一索引，以保证 <em>student</em> 表 <em>name</em> 唯一性为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">ADD UNIQUE INDEX uni_name(name);</span><br></pre></td></tr></table></figure><blockquote><p>有没有其它保持唯一性方法？</p></blockquote><p>我们还可以添加<u>唯一性约束</u>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">ADD CONSTRAINT uni_name</span><br><span class="line">UNIQUE (name);</span><br></pre></td></tr></table></figure></li></ul><h1>第三章 ： 增、删、改</h1><h2 id="2-0-登">2.0 登</h2><p>首先，打开 <em>cmd</em> 切换到 <em>mysql</em> 安装的 <em>bin</em> 目录下进行登陆：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\86151&gt;cd D:\软件\mysql-8.0.16-winx64\bin</span><br><span class="line"></span><br><span class="line">C:\Users\86151&gt;mysql -u root -p</span><br><span class="line">Enter password: ******</span><br></pre></td></tr></table></figure><p>输入密码后，进行基本 <u>增、删、改</u> 操作（ <u>查询数据</u> 下一章）。</p><h2 id="2-1-增">2.1 增</h2><h3 id="2-1-1-CREATE-创建">2.1.1 CREATE 创建</h3><ul><li><p>创建数据库</p><p>语法：<code>CREATE TABLE &lt;数据库名&gt;;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE test; -- 注意有分号</span><br></pre></td></tr></table></figure><p>我们可以用 <code>SHOW  DATEBASES</code> 已存在的数据库：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562658032453.png" alt="1562658032453"></p></li><li><p>创建数据表</p><ol><li><p>创建 <em>class</em> 表</p><p>语法：<code>CREATE TABLE &lt;表名&gt; (&lt;列名&gt; &lt;列类型&gt;);</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE test；          -- 必须要先引用数据库test</span><br><span class="line">mysql&gt; CREATE TABLE class</span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt; id INT, -- 自动增长C</span><br><span class="line">    -&gt; name VARCHAR(10) NOT NULL,</span><br><span class="line">    -&gt; PRIMARY KEY(id)</span><br><span class="line">    -&gt; ); -- 命令要以分号结束</span><br></pre></td></tr></table></figure></li><li><p>创建 <em>student</em> 表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE student</span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt; id INT ,</span><br><span class="line">    -&gt; class_id INT,</span><br><span class="line">    -&gt; name VARCHAR(10) NOT NULL,</span><br><span class="line">    -&gt; gender VARCHAR(1),</span><br><span class="line">    -&gt; score INT,</span><br><span class="line">    -&gt; PRIMARY KEY(id)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.14 sec)</span><br></pre></td></tr></table></figure></li><li><p>设置 <em>student</em> 表外键</p><p>我们可以进一步，为 <em>class_id</em> 字段设置为外键：</p><blockquote><p>:warning: 解析错误：下面其实是一条语句，加 <code>，</code>会出错！</p><p>:warning:[3780]错误：<em>student</em> 表外键 <em>class_id</em> 与 <em>class</em>表中 <em>id</em>，<em>NULL</em> &amp; <em>UNSIGNED</em> 约束要一致！（为了方便删了这两个约束）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE student  </span><br><span class="line">    -&gt; ADD CONSTRAINT fk_class_id</span><br><span class="line">    -&gt; FOREIGN KEY(class_id)</span><br><span class="line">    -&gt; REFERENCES class(id);</span><br></pre></td></tr></table></figure></li><li><p>查看表</p><p>语法：<code>SHOW  TABLES；</code> 查看已经存在的数据表名</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562661152178.png" alt="1562661152178"></p><p>语法： <code>DESCRIBE &lt;表名&gt; ;</code>  查看表详细信息</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562661234805.png" alt="1562661234805"></p></li></ol></li></ul><h3 id="2-1-2-ALTER-ADD">2.1.2 <em>ALTER + ADD</em></h3><p><em>ALTER</em> 主要用于字段、约束方面。</p><ul><li><p>增加字段</p><p><u><em>ALTER</em> 命令 + <em>ADD</em> 子句</u> ：可用于增加字段（增加列）</p><blockquote><p><em>student</em> 表增加一列，名为 <em>xw</em>  类型为 <em>VARCHAR(1)</em>；（还可增加默认值）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student </span><br><span class="line">ADD xw VARCHAR(1);</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562728689290.png" alt="1562728689290"></p></li><li><p>增加索引</p><blockquote><p><em>student</em> 表 字段 score增加索引</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student </span><br><span class="line">ADD INDEX idx_score(score);</span><br></pre></td></tr></table></figure></li><li><p>增加主键约束</p><blockquote><p>给 <em>test_stu</em> 表新增字段 <em>id</em>，并设为主键。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE test_stu</span><br><span class="line">ADD id INT NOT NULL AUTO_INCREMENT PRIMARY KEY;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into t_user</span><br><span class="line">( avatar, password, id, nickname, email, type, username) </span><br><span class="line">values </span><br><span class="line">(&#x27;https://unsplash.it/100/100?image=1005&#x27;,&#x27;96e79218965eb72c92a549dd5a330112&#x27;, &#x27;1&#x27;, &#x27;管理员&#x27;, &#x27;380141202@qq.com&#x27;,  &#x27;1&#x27;, &#x27;hwh&#x27;);</span><br></pre></td></tr></table></figure><h3 id="2-1-3-INSERT-插入数据">2.1.3 <em>INSERT</em> 插入数据</h3><blockquote><p>下面插入表数据语法，是一条语句故没有<code>，</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &lt;表名&gt; ( &lt;字段1&gt;, &lt;字段2&gt;,...&lt;字段N&gt; )</span><br><span class="line">                   VALUES</span><br><span class="line">                   ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure><p>:warning: 如果数据字符类似，必须加上单/双引号，如 ：<em>“value”</em></p><ol><li><p><em>class</em>表插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO class(id,name)</span><br><span class="line">    -&gt; VALUES</span><br><span class="line">    -&gt; (1,&quot;一班&quot;), -- 多行数据以 , 分隔</span><br><span class="line">    -&gt; (2,&quot;二班&quot;),</span><br><span class="line">    -&gt; (3,&quot;三班&quot;),</span><br><span class="line">    -&gt; (4,&quot;四班&quot;);</span><br></pre></td></tr></table></figure></li><li><p><em>student</em> 表插入数据</p><blockquote><p>由于代码较长，用 <u><em>Notepad++</em></u> 写好代码保存 <em>test.sql</em>：<code>SOURCE &lt;test.sql文件地址&gt;</code> 执行。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- 由于代码较长，下面是在Notepad++中编辑，而非命令行中</span><br><span class="line">INSERT INTO student(id,class_id,name,gender,score)</span><br><span class="line">VALUES           </span><br><span class="line">(1,1,&quot;小明&quot;,&quot;M&quot;,90),</span><br><span class="line">(2,1,&quot;小红&quot;,&quot;F&quot;,95),</span><br><span class="line">(3,1,&quot;小军&quot;,&quot;M&quot;,95),</span><br><span class="line">(4,1,&quot;小米&quot;,&quot;F&quot;,73),</span><br><span class="line">(5,2,&quot;小白&quot;,&quot;F&quot;,81),</span><br><span class="line">(6,2,&quot;小兵&quot;,&quot;M&quot;,55),</span><br><span class="line">(7,2,&quot;小林&quot;,&quot;M&quot;,85),</span><br><span class="line">(8,3,&quot;小新&quot;,&quot;F&quot;,91),</span><br><span class="line">(9,3,&quot;小王&quot;,&quot;M&quot;,89),</span><br><span class="line">(10,3,&quot;小丽&quot;,&quot;F&quot;,88);</span><br><span class="line"></span><br><span class="line">-- 下面在cmd中执行，注意不要带 ；！！</span><br><span class="line">mysql&gt; source D:\hwh\uploadToGit\code\mysql\test.sql </span><br></pre></td></tr></table></figure></li><li><p>查看表中数据</p><p>实际就是查询数据 ：<code>SELECT * FROM &lt;表名&gt;;</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562666055408.png" alt="1562666055408"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562666146255.png" alt="1562666146255"></p></li></ol><h2 id="2-2-删">2.2 删</h2><h3 id="2-2-1-DROP">2.2.1 DROP</h3><ul><li><p>删除数据库</p><p>语法：<code>DROP DATABASE &lt;数据库名&gt;;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP DATABASE hwh;</span><br></pre></td></tr></table></figure></li><li><p>删除数据表</p><p>语法：<code>DROP TABLE &lt;表名&gt;;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP TABLE temp_table;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-2-DELETE">2.2.2 DELETE</h3><ul><li><p>删除表中记录</p><p>为了测试是否删除，在 <em>class</em> 表中，增加一行记录：<em>（5，“五班”）</em></p><p>语法：<code>DELETE FROM &lt;表名&gt; WHERE &lt;条件&gt;；</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM class WHERE id=5;</span><br></pre></td></tr></table></figure><p>经过测试，记录被删除。</p></li></ul><h3 id="2-2-3-ALTER-DROP">2.2.3 <em>ALTER</em> + <em>DROP</em></h3><ul><li><p>删除字段、默认值</p><p><u><em>ALTER</em> 命令 + <em>DROP</em> 子句</u> ：删除字段（列）、或者删除指定默认值</p><p>删除默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE student ALTER bust_size DROP DEFAULT;</span><br></pre></td></tr></table></figure><p>删除字段（列）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE student DROP bust_size;</span><br></pre></td></tr></table></figure></li><li><p>删除主/外键约束</p><p>语法： <code>ALTER TABLE &lt;表名&gt; DROP FOREGIN/PRIMARY KEY &lt;外键名&gt;;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABALE test_stu DROP PRIMARY KEY ; --主键只有一个不用指定名字</span><br></pre></td></tr></table></figure></li><li><p>删除索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h2 id="2-3-改">2.3 改</h2><p>以下操作都基于 <em>student</em> 表：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562725211849.png" alt="1562725211849"></p><h3 id="2-3-1-UPDATE">2.3.1 UPDATE</h3><p>语法：<code>UPDATE &lt;表名&gt; SET &lt;字段1&gt; = &lt;新值1&gt; , ...  WHERE &lt;条件1&gt; [AND | OR] &lt;条件2&gt;..</code></p><p>:warning: SET 设置多个值用 <u>，</u>分隔； WHERE 设置多个条件用 <u>AND 、OR</u> 分隔；</p><ul><li><p>更新某行记录字段值</p><blockquote><p>修改 <em>id = 10</em> 记录，<em>name</em> 字段值。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE student </span><br><span class="line">SET name=&#x27;刘婷&#x27;,score=89 </span><br><span class="line">WHERE id=10;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562726216762.png" alt="1562726216762"></p></li><li><p>修改所有记录某字段值</p><blockquote><p>所有人成绩 +1分。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 不加 WHERE 限定，同时SET可用表达式</span><br><span class="line">UPDATE student </span><br><span class="line">SET score=score+1; </span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-2-ALTER">2.3.2 ALTER</h3><p><em>ALTER</em> 命令主要是在我们，修改&lt;表名&gt; ；删除或增加 &lt;字段&gt;；修改&lt;字段类型&gt;、&lt;字段名&gt;。</p><blockquote><p>和 <em>UPDATE</em> 区别？</p></blockquote><ol><li><em>ALTER</em> 比 <em>UPDATE</em> 着眼于更宏观的字段上，而<em>UPDATE</em> 是修改记录某字段 <u>具体值</u> ；</li><li><em>ALTER</em> 不仅可以<u>更新</u>，还可以进行 <u>删除</u>、<u>增加</u>操作；</li><li><em>ALTER</em> 还可用于修改 &lt;表名&gt;。</li></ol><blockquote><p>语法格式？</p></blockquote><p><code>ALTER TABLE &lt;表名&gt; ADD/DROP/MODIFY/CHANGE/RENAME TO/ alter_tbl;</code></p><ul><li><p>修改字段名、类型、默认值</p><p><u><em>ALTER</em> 命令 + <em>MODIFY</em> 子句</u> ：可用于修改 字段类型、设置初始默认值</p><blockquote><p>修改 <em>xw</em> 类型为 <em>INT</em>，初始默认值 <em>B</em> ;</p></blockquote><p>:warning: <em>MODIFY 、CHANGE</em> 只能在没有默认值设置初始默认值，<strong>不能修改</strong>默认值！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student </span><br><span class="line">MODIFY xw INT DEFAULT 2;</span><br></pre></td></tr></table></figure><p><u><em>ALTER</em> 命令 + <em>CHANGE</em> 子句</u> ：可用于修改 字段名 &amp; 类型、设置初始默认值</p><blockquote><p>修改 <em>xw</em> 名为 <em>bust_size</em> ，类型为 <em>BIGINT</em> ;</p></blockquote><p>和 <em>MODIFY</em>  子句不同在于：<code>CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;类型&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student </span><br><span class="line">CHANGE xw bust_size BIGINT; </span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562731141100.png" alt="1562731141100"></p><p><u><em>ALTER</em> 命令 + <em>SET</em>子句</u> ：重新设置字段默认值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student </span><br><span class="line">ALTER bust_size </span><br><span class="line">SET DEFAULT 1;  -- 默认值2--&gt;1</span><br></pre></td></tr></table></figure></li><li><p>修改表名</p><p><u><em>ALTER</em> 命令 + <em>RENAME TO</em> 子句</u> ：修改表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student </span><br><span class="line">RENAME TO stu;</span><br></pre></td></tr></table></figure></li><li><p>修改存储引擎</p><p>语法：<code>ALTER TABLE &lt;表名&gt; &lt;旧引擎名&gt; = &lt;新引擎名&gt;;</code></p></li></ul><h1>第三章 ：查询数据</h1><h2 id="3-1-基本查询">3.1 基本查询</h2><ul><li><p><em>SELECT * FROM &lt;表名&gt;</em></p><p>这是<u>不带 <em>WHERE</em> 条件</u>进行查询，查询显示：指定表所有数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure></li><li><p><em>SELECT  &lt;数学表达式&gt;</em></p><blockquote><p>SELECT 可用于数学计算，但那并不是强项，但可用于检测数据库了解是否有效。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT 1+1;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-条件查询">3.2 条件查询</h2><ul><li><p>条件表达式</p><table><thead><tr><th style="text-align:center">条件</th><th style="text-align:left">举例1</th><th style="text-align:left">举例2</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:left">score = 80</td><td style="text-align:left">name = ‘abc’</td><td style="text-align:left">字符串需要用<code>单引号</code>括起来</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:left">score &gt; 80</td><td style="text-align:left">name &gt; ‘abc’</td><td style="text-align:left">字符串比较：<em>ASCII</em>码；中文比较：根据数据库设置</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:left">score &gt;= 80</td><td style="text-align:left">name &gt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:left">score &lt; 80</td><td style="text-align:left">name &lt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:left">score &lt;= 80</td><td style="text-align:left">name &lt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">&lt;&gt;</td><td style="text-align:left">score &lt;&gt; 80</td><td style="text-align:left">name &lt;&gt; ‘abc’</td><td style="text-align:left">&lt;&gt; ：用于判断不相等，如举例1表示 <em>score ≠ 80</em></td></tr><tr><td style="text-align:center">LIKE</td><td style="text-align:left"><em>name LIKE ‘ab%’</em></td><td style="text-align:left">name LIKE ‘%bc%’</td><td style="text-align:left">判断相似：<code>%</code>表示任意字符。例如<code>'ab%'</code>将匹配 <em>‘ab’，‘abc’，‘abcd’</em></td></tr></tbody></table></li><li><p><em>NOT、AND、OR</em></p><blockquote><p><em>NOT、AND、OR</em> 可用于组成多条件查询，同时可配合 <em>()</em> 改变优先级。</p></blockquote></li><li><p><em>SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;</em></p><blockquote><p>查询 <em>student</em> 表成绩80分以上男生，但不包含小兵。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM student </span><br><span class="line">WHERE NOT name=&#x27;小兵&#x27; AND score &gt; 80 AND gender=&#x27;M&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562749243199.png" alt="1562749243199"></p><p>其实，<u>NOT 等价于 &lt;&gt;</u> :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM student</span><br><span class="line">WHERE  name &lt;&gt; &#x27;小兵&#x27; AND score &gt; 80 AND gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure></li><li><p><em>SELECT (列1，列2…) FROM &lt;表名&gt; WHERE &lt;条件&gt;</em></p><p>这种方式也称为 <u>投影查询</u>，结果集合只包含指定列，而非所有列。</p><blockquote><p>查询 <em>student</em> 表成绩80分以上男生，但不包含小兵，结果只显示 <em>id 、name</em> 两列。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  SELECT id,name </span><br><span class="line">  FROM student </span><br><span class="line">WHERE  name &lt;&gt; &#x27;小兵&#x27; AND score &gt; 80 AND gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562750038321.png" alt="1562750038321"></p></li></ul><h2 id="3-2-查询进阶">3.2 查询进阶</h2><h3 id="3-2-1-排序">3.2.1 排序</h3><ul><li><p>单条件查询</p><blockquote><p>[单排序条件] 按一班成绩<u>升</u>序排列，并同时显示ta们：id、姓名、成绩。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,name,score</span><br><span class="line">FROM student </span><br><span class="line">WHERE class_id = 1 </span><br><span class="line">ORDER BY score ;</span><br></pre></td></tr></table></figure><ul><li>:warning: <em>WHERE</em> 要放在 <em>ORDER BY</em> 前，否则出错；</li><li>如果要降序：查询语句末加上 <em>DESC</em> 即可。</li></ul></li><li><p>多条件查询</p><blockquote><p>[多排序条件]  按一班成绩<u>升</u>序排列，成绩相同按性别降序，并同时显示ta们：id、姓名、成绩。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,name,score </span><br><span class="line">FROM student</span><br><span class="line">WHERE class_id = 1 </span><br><span class="line">ORDER BY score ,gender DESC ;</span><br></pre></td></tr></table></figure><ul><li>对于每个排序条件都要指定升序、降序：这里<em>score</em>默认升序、<em>gender</em>降序；</li><li><em>gender</em>值 是字符串，按<em>ASCII</em> 码规则进行排序。</li></ul><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562750814146.png" alt="1562750814146"></p></li></ul><h2 id="3-2-2-分页">3.2.2 分页</h2><p>分页，解决 SELECT 查询时，数据量太多，指定显示 <u>某页</u> 数据。</p><p>其语法格式：<code>&lt;SELECT查询&gt; LIMIT &lt;每页显示记录数&gt; OFFSET &lt;记录偏移量&gt;</code></p><ul><li><p>查询实例</p><blockquote><p>查询所有学生成绩降序排序，显示第二页数据，每页4条记录。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,class_id,name,score</span><br><span class="line">FROM student</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 4 OFFSET 4 ; -- (2-1)*4 = 4：0-3为第一页4条记录，第4条记录即是第二页第一条记录</span><br></pre></td></tr></table></figure><ul><li>显示第n页数据：<em>LIMIT <size>    OFFSET <n-1> * size</em></li></ul></li><li><p>查询结果</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562808570960.png" alt="1562808570960"></p></li></ul><h3 id="3-2-3-多表查询">3.2.3 多表查询</h3><p>多表查询：返回的是笛卡尔乘积，即一张有<em>n</em>记录表 &amp; 一张<em>m</em>记录表 —&gt; 查询结果 <em>m*n</em> 记录表。</p><ul><li><p>查询实例</p><blockquote><p>查询 <em>student</em> 表、<em>class</em> 表，显示笛卡尔乘积结果。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM student s, class c;</span><br></pre></td></tr></table></figure><blockquote><p>查询 <em>student</em> 表、<em>class</em> 表，1班男生成绩降序排序。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.id &#x27;学号&#x27;, c.id &#x27;班级号&#x27;,s.name &#x27;名字&#x27;,s.score &#x27;成绩&#x27;</span><br><span class="line">FROM student s, class c</span><br><span class="line">WHERE s.gender = &#x27;M&#x27; AND c.id = 1</span><br><span class="line">ORDER BY s.score DESC;</span><br></pre></td></tr></table></figure><ul><li><p><em>student</em> 表 &amp; <em>class</em> 表分别使用了别名 <em>s</em> 和 <em>c</em> ；查询结果列名也可以使用别名；</p></li><li><p>这样查询表，其实是在它们的 <u>笛卡尔乘积表中查询</u>。</p></li></ul></li><li><p>查询结果</p><center>笛卡尔乘积查询结果1</center><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562811506810.png" alt="1562811506810"></p><center>查询结果2</center><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--------+-----------+--------+--------+</span><br><span class="line">| 学号    | 班级号     | 名字    | 成绩   |</span><br><span class="line">+--------+-----------+--------+--------+</span><br><span class="line">|      3 |         1 | 小军    |     96 |</span><br><span class="line">|      1 |         1 | 小明    |     91 |</span><br><span class="line">|      9 |         1 | 小王    |     90 |</span><br><span class="line">|      7 |         1 | 小林    |     86 |</span><br><span class="line">|      6 |         1 | 小兵    |     56 |</span><br><span class="line">+--------+-----------+--------+--------+</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-4-连接查询">3.2.4 连接查询</h3><blockquote><p>查询 <em>student</em> 表中，显示学生信息[id、姓名、班级名、成绩]，要包含班级名称。</p></blockquote><p>这题难点在于，班级名(<em>name</em>)在 <em>class</em> 表中， <em>student</em> 表中只有 <em>class_id</em> 。</p><p>如果用上面<u>多表查询</u> 要生成笛卡尔积表效率太低，所以我们使用连接查询。</p><ul><li><p>内连接</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1246892164662976/l" alt="inner-join"></p><p>内连接中，没有主表，只分为左右表。</p><p>原理：用从左表中取出每一条记录，去与右表中所有记录匹配，满足ON &lt;连接条件&gt; 被保留。</p><p><u>没有 ON &lt;连接条件&gt;</u> ，将会生成成笛卡尔积表。</p><ul><li><p>查询实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.id,s.name,c.name,s.score</span><br><span class="line">FROM student s</span><br><span class="line">INNER JOIN class c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure><ul><li><p><em>INNER JOIN class c</em> ：使得可以 <em>SELECT</em> 使用 <em>class</em> 表中<em>name</em> ;</p></li><li><p>将左表记录N_i 与 右表记录 M_j 比较，如果字段 <em>s.class_id = <a href="http://c.id">c.id</a></em> ，那么记录N_i 保留。</p><p>也就是说，比较次数 = 左表记录数 * 右表记录数，这比直接生成笛卡尔表查询高效。</p></li></ul></li><li><p>查询结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+----+--------+--------+-------+</span><br><span class="line">| id | name   | name   | score |</span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">|  1 | 小明    | 一班   |    91 |</span><br><span class="line">|  2 | 小红    | 一班   |    96 |</span><br><span class="line">|  3 | 小军    | 一班   |    96 |</span><br><span class="line">|  4 | 小米    | 一班   |    74 |</span><br><span class="line">|  5 | 小白    | 二班   |    82 |</span><br><span class="line">|  6 | 小兵    | 二班   |    56 |</span><br><span class="line">|  7 | 小林    | 二班   |    86 |</span><br><span class="line">|  8 | 小新    | 三班   |    92 |</span><br><span class="line">|  9 | 小王    | 三班   |    90 |</span><br><span class="line">| 10 | 刘婷    | 三班   |    90 |</span><br><span class="line">+----+--------+--------+-------+</span><br></pre></td></tr></table></figure></li></ul></li><li><p>左外连接</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1246893588481376/l" alt="left-outer-join"></p><p>左外连接中，左表为主表。</p><p>原理：以左表为主表，从里面取每一条记录和右表进行连接，分两种情况</p><ul><li>满足<em>ON &lt;条件&gt;</em> 能匹配：保留该记录；</li><li>不满足<em>ON &lt;条件&gt;</em> 能匹配：保留该记录，但是其它字段置为NULL。</li></ul></li><li><p>右外连接</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1246893609222688/l" alt="right-outer-join"></p><p>右外连接中，右表为主表。</p><p>原理：同上。</p><ul><li><p>查询实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.id,s.name,c.name,s.score</span><br><span class="line">FROM student s</span><br><span class="line">RIGHT OUTER JOIN class c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure><ul><li>把右表当主表去匹配左表：满足ON条件，正确保存；不满足，其余字段置为 <em>NULL</em> 。</li></ul></li><li><p>查询结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+--------+-------+</span><br><span class="line">| id   | name   | name   | score |</span><br><span class="line">+------+--------+--------+-------+</span><br><span class="line">|    1 | 小明    | 一班   |    91 |</span><br><span class="line">|    2 | 小红    | 一班   |    96 |</span><br><span class="line">|    3 | 小军    | 一班   |    96 |</span><br><span class="line">|    4 | 小米    | 一班   |    74 |</span><br><span class="line">|    5 | 小白    | 二班   |    82 |</span><br><span class="line">|    6 | 小兵    | 二班   |    56 |</span><br><span class="line">|    7 | 小林    | 二班   |    86 |</span><br><span class="line">|    8 | 小新    | 三班   |    92 |</span><br><span class="line">|    9 | 小王    | 三班   |    90 |</span><br><span class="line">|   10 | 刘婷    | 三班   |    90 |</span><br><span class="line">| NULL | NULL   | 四班   |  NULL |</span><br><span class="line">+------+--------+--------+-------+</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-2-5-子查询">3.2.5 子查询</h3><ul><li><p>子查询分类</p><p>子查询按对返回结果集调用方法，可分为：</p><ul><li><strong>WHERE</strong> 子查询：把内层查询结果当做外层 <u>查询条件</u>；</li><li><strong>FROM</strong> 子查询：把内层查询结果当做外层 <u>查询集合</u>；</li><li><strong>EXISTS</strong> 子查询：把外层查询结果拿到内层，看内层查询是否成立。</li></ul></li><li><p>IN 、ANY、SOME、ALL</p><p>最典型的当 WHRER 子查询结果，不是标量（一行一列），而是一个集合（多行多列）。</p><p>此时，不能使用：<u>=   &gt;   &lt;   &gt;=   &lt;=   &lt;&gt;</u> 这些比较标量操作符；而用<u>IN、ANY（SOME）、ALL</u>  操作符。</p><ul><li>IN：判断查询的表达式是否在子查询列表中，返回满足in列表中的满足条件的记录。</li><li>ANY：ANY关键字必须在一个比较操作符后面，表示与子查询返回<u>任何值</u>比较为 TRUE ，则返回 TRUE ；</li><li>ALL：ALL关键字必须在一个比较操作符后面，表示与子查询返回<u>所有值</u>比较为 TRUE ，则返回 TRUE 。</li></ul></li><li><p>子查询实例</p><ul><li><p>查询实例1</p><blockquote><p>获取所有比刘婷成绩好的男同学，学号、姓名、成绩。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,name,score</span><br><span class="line">FROM student</span><br><span class="line">WHERE score &gt;  </span><br><span class="line">(</span><br><span class="line">    SELECT score </span><br><span class="line">    FROM student</span><br><span class="line">    WHERE name = &#x27;刘婷&#x27;  -- 这里没有 ;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>查询比刘婷成绩好的同学为父查询·····；由于刘婷成绩未知，所以还需要一个子查询查询刘婷成绩。</li><li>WHERE 子查询字段 == 父查询字段！（都只有 score）</li></ul></li><li><p>查询实例2</p><p>新建一个 <em>test_stu</em> 表查询：<a href="D:%5Chwh%5CuploadToGit%5Ccode%5Cmysql%5Ctest.sql">test.sql</a></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562848238275.png" alt="1562848238275"></p><blockquote><p>找出语文和数学都及格的同学名字。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT name </span><br><span class="line">FROM test_stu</span><br><span class="line">WHERE score &gt;= 60 AND project = &#x27;语文&#x27; AND name IN</span><br><span class="line">(</span><br><span class="line">        SELECT name</span><br><span class="line">        FROM test_stu</span><br><span class="line">        WHERE  score &gt;= 60 AND project = &#x27;数学&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>很明显要子查询，要查出语文成绩及格同学，可做父查询条件之一 ；然后把子查询查询数学结果做父查询条件之二。</li><li>一开始想用 FROM 子查询 限制查询集合，似乎并不太好用。</li></ul></li><li><p>查询结果2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--------+</span><br><span class="line">| name   |</span><br><span class="line">+--------+</span><br><span class="line">| 张三   |</span><br><span class="line">| 赵六   |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-2-6-聚合-：-分组-简单函数">3.2.6 聚合 ： 分组 &amp; 简单函数</h3><blockquote><p>函数只能在 SELECT 中使用？？</p></blockquote><ul><li><p>聚合 &amp; 简单函数</p><p>聚合配合函数：用来统计表中信息，如总人数、平均分、最高分等。</p><ul><li><p>聚合 &amp; <em>count()</em></p><blockquote><p>统计 <em>student</em> 表学生总人数。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) stu_num FROM student;</span><br></pre></td></tr></table></figure><ul><li><em>count(*)</em> : 参数 <code>*</code>  代表统计所有列；</li><li><em>stu_num</em> : 是设置的别名。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| stu_num |</span><br><span class="line">+---------+</span><br><span class="line">|      10 |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure></li><li><p>聚合 &amp; <em>SUM()、AVG()</em></p><p>注意，<em>SUM()、AVG()</em> 用来计算一列总和/平均值，必须要是 <u>数值类型</u> ( <em>count()</em> 是统计列，和类型无关) 。</p><blockquote><p>统计女生总分，和平均分。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(score),AVG(score) </span><br><span class="line">FROM student</span><br><span class="line">WHERE gender = &#x27;F&#x27;;</span><br></pre></td></tr></table></figure><ul><li><code>SELECT name ,SUM(s.score),AVG(s.score)</code>  不行，每个女生都有总分/平均分?</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------------+------------+</span><br><span class="line">| SUM(score) | AVG(score) |</span><br><span class="line">+------------+------------+</span><br><span class="line">|        434 |    86.8000 |</span><br><span class="line">+------------+------------+</span><br></pre></td></tr></table></figure></li><li><p>聚合 &amp; <em>MIN() 、MAX()</em></p><p><code>MAX()</code>和<code>MIN()</code><u>不限于数值类型</u>,如果是字符类型，<code>MAX()</code>和<code>MIN()</code>会返回排序最后和排序最前的字符。</p><blockquote><p>统计学生中最高分，并同时显示姓名、班级、分数。</p></blockquote><p>该题难点在于，由于还是显示班级，需要连接 <em>class</em> 表。</p><p>ON 条件：还想同时 <em>MAX()</em> 找出最高分，不太可行，用来给 <em>student</em> 表增加一列 <em><a href="http://c.name">c.name</a></em>就行。</p><p>WHERE 条件：然后给新连接表找出最高分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.name,c.name,s.score</span><br><span class="line">FROM student s</span><br><span class="line">INNER JOIN class c</span><br><span class="line">ON s.class_id = c.id</span><br><span class="line">WHERE s.score &gt;= ALL </span><br><span class="line">(</span><br><span class="line">    SELECT score</span><br><span class="line">    FROM student</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>进一步优化：利用 <em>MAX()</em> 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.name,c.name,s.score</span><br><span class="line">FROM student s</span><br><span class="line">INNER JOIN class c</span><br><span class="line">ON s.class_id = c.id</span><br><span class="line">WHERE s.score =  -- 尝试 WHERE s.score = MAX(score) 出错，只能在SELECT中使用？</span><br><span class="line">(</span><br><span class="line">    SELECT MAX(score) </span><br><span class="line">    FROM student</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>聚合 &amp; 分组</p><ul><li><p>单条件分组</p><p>在前面，我们利用 <em>coutn(*)</em> 函数，可以很快统计出学生总数，但是如果要分别统计出男/女生数呢？难道，分别用 <em>WHERE</em> 条件限制一下再统计吗？</p><p>如果，表可以分为两男、女两组，函数分别会分别统计两组信息再显示多好呀！</p><blockquote><p>分别统计出男/女平均分、学生总数。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT gender,AVG(score),COUNT(*)</span><br><span class="line">FROM student</span><br><span class="line">GROUP BY gender;</span><br></pre></td></tr></table></figure><ul><li><p>这也就相当于：表分为男女两组，<u>函数会分别计算两次</u> 。</p></li><li><p>我们可以 <em>SELECT gender</em> ，但是下列语句会出错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id,gender,AVG(score),COUNT(*) -- 第一句SELECT增加class_id</span><br></pre></td></tr></table></figure><p>因为，按性别分组，每个性别都要若干学生，自然对应多个班级 <em>class_id</em>  ,试问如何显示？</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--------+------------+----------+</span><br><span class="line">| gender | AVG(score) | COUNT(*) |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">| M      |    83.8000 |        5 |</span><br><span class="line">| F      |    86.8000 |        5 |</span><br><span class="line">+--------+------------+----------+</span><br></pre></td></tr></table></figure></li><li><p>多条件分组</p><p>在 <u>单条件分组</u> 我们说到，下面写法是错误的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id,gender,AVG(score),COUNT(*) -- 第一句SELECT增加class_id</span><br><span class="line">FROM student</span><br><span class="line">GROUP BY gender;</span><br></pre></td></tr></table></figure><p>原因是：按 <em>gender</em> 分组只能分为 <em>M/F</em> 两组，显示只有两行统计结果，而每一行<em>M/F</em>都包括多个<em>class_id</em> ，没法显示，也不合逻辑。现在思考一个问题：</p><blockquote><p>查询每个班级的男/女生平均分？</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id,gender,AVG(score)</span><br><span class="line">FROM student</span><br><span class="line">GROUP BY gender,class_id;</span><br></pre></td></tr></table></figure><p>为什么这里又可以显示了？其实整个逻辑如下：</p><ul><li>先按 <em>class_id</em> 分为 <strong>3</strong> 组，然后每组又按 <em>gender</em> 分为 <strong>2</strong> 组，所以总共是 <strong>6</strong> 组可以显示出来。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----------+--------+------------+</span><br><span class="line">| class_id | gender | AVG(score) |</span><br><span class="line">+----------+--------+------------+</span><br><span class="line">|        1 | M      |    93.5000 |</span><br><span class="line">|        1 | F      |    85.0000 |</span><br><span class="line">|        2 | F      |    82.0000 |</span><br><span class="line">|        2 | M      |    71.0000 |</span><br><span class="line">|        3 | F      |    91.0000 |</span><br><span class="line">|        3 | M      |    90.0000 |</span><br><span class="line">+----------+--------+------------+</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1>第四章：事务</h1><h2 id="4-1-事务简介">4.1 事务简介</h2><blockquote><p>简单来说，事务就是让多个操作要么全部执行，要么全不执行，保证数据统一性。</p></blockquote><p>比如，A向B进行转账必须保证，A 、B账户一方增，一方必须减。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 第一步：将id=1的A账户余额减去100</span><br><span class="line">UPDATE accounts SET balance = balance - 100 WHERE id = 1;</span><br><span class="line">-- 第二步：将id=2的B账户余额加上100</span><br><span class="line">UPDATE accounts SET balance = balance + 100 WHERE id = 2;</span><br></pre></td></tr></table></figure><p>显然，这两条语句必须全部执行，但上面语句无法保证，这就需要开启事务。</p><ul><li><p>隐式事务</p><p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<em>隐式事务</em>。</p></li><li><p>显示事务</p><p>手动把多条事务作为一个事务执行，使用 <code>BEGIN &lt;多条SQL语句操作&gt; COMMIT</code> 形式。比如上面转账：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN; -- 分号</span><br><span class="line">UPDATE accounts SET balance = balance - 100 WHERE id = 1;</span><br><span class="line">UPDATE accounts SET balance = balance + 100 WHERE id = 2;</span><br><span class="line">COMMIT; -- 分号</span><br></pre></td></tr></table></figure><ul><li><p><em>COMMIT &amp; ROLLBACK</em></p><p>上面最终选择提交更新，如果写完SQL语句但又不想提交更新呢？可以用 <em>ROLLBACK</em> 撤销操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN; -- 分号</span><br><span class="line">UPDATE accounts SET balance = balance - 100 WHERE id = 1;</span><br><span class="line">UPDATE accounts SET balance = balance + 100 WHERE id = 2;</span><br><span class="line">ROLLBACK; -- 分号</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="4-2-隔离级别">4.2 隔离级别</h2><blockquote><p>概况：避免多个并发执行事务，对 <u>同一条记录</u> 进行操作，带来的数据不一致问题。</p></blockquote><p>SQL 标准定义4种隔离级别，<u>不同程度</u> 的避免出现数据不一致情况。</p><p>同时，在<em>MySQL</em>中，使用 <em>innoDB</em> <u>默认隔离级别</u>是 <em>Repeatable Read</em> 。</p><table><thead><tr><th style="text-align:left"><em>Isolation Level</em></th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th><th style="text-align:center">隔离级别</th><th style="text-align:center">概括</th></tr></thead><tbody><tr><td style="text-align:left"><em>Read Uncommitted</em></td><td style="text-align:center"><em>Yes</em></td><td style="text-align:center"><em>Yes</em></td><td style="text-align:center"><em>Yes</em></td><td style="text-align:center">最低</td><td style="text-align:center"><u>脏读</u>：两次读，中间撤</td></tr><tr><td style="text-align:left"><em>Read Committed</em></td><td style="text-align:center"><em>-</em></td><td style="text-align:center"><em>Yes</em></td><td style="text-align:center"><em>Yes</em></td><td style="text-align:center">较低</td><td style="text-align:center"><u>不可重读</u>：两次读，中间更</td></tr><tr><td style="text-align:left"><em>Repeatable Read</em></td><td style="text-align:center"><em>-</em></td><td style="text-align:center"><em>-</em></td><td style="text-align:center"><em>Yes</em></td><td style="text-align:center">较高</td><td style="text-align:center"><u>幻读</u>：两次读，中间插</td></tr><tr><td style="text-align:left"><em>Serializable</em></td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">最高</td><td style="text-align:center"></td></tr></tbody></table><ul><li><p><em>Read Uncommitted</em></p><p>根据上表，我们知道，<em>Read Uncommitted</em> 可能出现脏读。</p><blockquote><p>什么是脏读？最终读取到已不在表中数据。</p></blockquote><p>多并发下，事务A进行了更新操作，在事务B进行连续两次读过程中，发生撤回更新操作，导致读取无效C。</p><center><u>两次读，中间撤</u></center><table><thead><tr><th style="text-align:left">时刻</th><th style="text-align:center">事务A</th><th style="text-align:center">事务B</th></tr></thead><tbody><tr><td style="text-align:left"><em>1</em></td><td style="text-align:center"><em>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</em></td><td style="text-align:center"><em>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</em></td></tr><tr><td style="text-align:left"><em>2</em></td><td style="text-align:center"><em>BEGIN;</em></td><td style="text-align:center"><em>BEGIN;</em></td></tr><tr><td style="text-align:left"><em>3</em></td><td style="text-align:center"><em>UPDATE student SET score= 65 WHERE id = 1;</em></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><em>4</em></td><td style="text-align:center"></td><td style="text-align:center"><em>SELECT * FROM student WHERE id = 1;</em></td></tr><tr><td style="text-align:left"><em>5</em></td><td style="text-align:center"><em>ROLLBACK;</em></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><em>6</em></td><td style="text-align:center"></td><td style="text-align:center"><em>SELECT * FROM student WHERE id = 1;</em></td></tr><tr><td style="text-align:left"><em>7</em></td><td style="text-align:center"></td><td style="text-align:center"><em>COMMIT;</em></td></tr></tbody></table><ul><li>时刻3：事务A，更新 <em>student</em> 表设置分数为65；</li><li>时刻4：事务B，读到刚刚更新的分数65；</li><li>时刻5：事务A取消更新分数操作，导致上一个分数实际不是正确分数；</li><li>时刻6：验证性操作，再次读取数据发现分数和时刻4读取的不一致。</li></ul></li><li><p><em>Read Committed</em></p><p>根据上表，我们知道，<em>Read committed</em> 可能出现不可重复读。</p><blockquote><p>什么是不可重复读？两次连续读取的数据不一致，但最终读取的数据在表中。</p></blockquote><p>在多并发下，事务B在进行<u>两次读</u>过程中，事务A恰好更新了数据，导致两次读取数据不一致。</p><center><u>两次读，中间更</u></center><table><thead><tr><th style="text-align:left">时刻</th><th style="text-align:center">事务A</th><th style="text-align:center">事务B</th></tr></thead><tbody><tr><td style="text-align:left"><em>1</em></td><td style="text-align:center"><em>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</em></td><td style="text-align:center"><em>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</em></td></tr><tr><td style="text-align:left"><em>2</em></td><td style="text-align:center"><em>BEGIN;</em></td><td style="text-align:center"><em>BEGIN;</em></td></tr><tr><td style="text-align:left"><em>3</em></td><td style="text-align:center"></td><td style="text-align:center"><em>SELECT * FROM studentWHERE id = 1;</em></td></tr><tr><td style="text-align:left"><em>4</em></td><td style="text-align:center"><em>UPDATE student SET score= 65 WHERE id = 1;</em></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><em>5</em></td><td style="text-align:center"><em>COMMIT;</em></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><em>6</em></td><td style="text-align:center"></td><td style="text-align:center"><em>SELECT * FROM student WHERE id = 1;</em></td></tr><tr><td style="text-align:left"><em>7</em></td><td style="text-align:center"></td><td style="text-align:center"><em>COMMIT;</em></td></tr></tbody></table><blockquote><p>:grey_question: <em>Read Committed</em>下为什么不会出现脏读呢？</p></blockquote><p>:thought_balloon: 我的理解是，<em>Read Committed</em> 下只能读取到已经 <em>COMMIT</em> 更新的数据，不能读取未 <em>COMMIT</em> 操作数据。</p><p>​      脏读是未 <em>COMMIT</em> 前更新操作然后撤回又读取导致，所以也就不会出现脏读。</p></li><li><p><em>Repeatable Read</em></p><p>根据上表，我们知道，<em>Repeatable Read</em> 可能出现幻读。</p><blockquote><p>什么是幻读？连续两次读，第一次不存在，但可以更新，<u>更新后再次读取竟然又存在</u>。</p></blockquote><center><u>两次读，中间插</u></center><table><thead><tr><th style="text-align:center">时刻</th><th style="text-align:center">事务A</th><th style="text-align:center">事务B</th></tr></thead><tbody><tr><td style="text-align:center"><em>1</em></td><td style="text-align:center"><em>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</em></td><td style="text-align:center"><em>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</em></td></tr><tr><td style="text-align:center"><em>2</em></td><td style="text-align:center"><em>BEGIN;</em></td><td style="text-align:center"><em>BEGIN;</em></td></tr><tr><td style="text-align:center"><em>3</em></td><td style="text-align:center"></td><td style="text-align:center"><em>SELECT * FROM student WHERE id = 99;</em></td></tr><tr><td style="text-align:center"><em>4</em></td><td style="text-align:center"><em>INSERT INTO student (id, name) VALUES (99, ‘Bob’);</em></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><em>5</em></td><td style="text-align:center"><em>COMMIT;</em></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><em>6</em></td><td style="text-align:center"></td><td style="text-align:center"><em>SELECT * FROM student WHERE id = 99;</em></td></tr><tr><td style="text-align:center"><em>7</em></td><td style="text-align:center"></td><td style="text-align:center"><em>UPDATE student SET name = ‘Alice’ WHERE id = 99;</em></td></tr><tr><td style="text-align:center"><em>8</em></td><td style="text-align:center"></td><td style="text-align:center"><em>SELECT * FROM student WHERE id = 99;</em></td></tr><tr><td style="text-align:center"><em>9</em></td><td style="text-align:center"></td><td style="text-align:center"><em>COMMIT;</em></td></tr></tbody></table><ul><li>第6时刻：:warning: 此时没有出现不可重复读，第6时刻读取到 id = 99 数据<strong>还是空</strong>。</li><li>第7时刻：但是发现可以更新数据，而且此时再去读取 id = 99 数据发现成功了！！<em>AMAZING!</em></li></ul><blockquote><p>:grey_question:  如果第 4 步是 <em>UPDATE</em> 操作 ，会出现不可重复读吗？</p></blockquote><p>:thought_balloon: 我猜测不会，因为 INSERT 操作也是更新，但是第6时刻读取数据为空？</p><p>:male_detective: <em>Repeatable Read</em> 在同一个事务内的查询与事务开始时刻一致，在B事务过程中不会读到期间A中更新值。</p></li><li><p><em>Serializable</em></p><p>Serializable是最严格的隔离级别，但是效率最低，一般不会设置。</p><p>在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。</p></li></ul><h1>第五章 ：存储过程和触发器</h1>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习（一）吴恩达笔记</title>
      <link href="/2021/11/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%B4%E6%81%A9%E8%BE%BE%E7%AC%94%E8%AE%B0%20/"/>
      <url>/2021/11/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%B4%E6%81%A9%E8%BE%BE%E7%AC%94%E8%AE%B0%20/</url>
      
        <content type="html"><![CDATA[<p>吴恩达的机器学习最重要的还是 <strong>课后的lab实验</strong>，后期会继续上传。这里先简单上传听课的笔记，略粗糙。</p><h2 id="一-、绪论">一 、绪论</h2><h3 id="1-1-监督学习">1.1 监督学习</h3><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1559957342693.png" alt="1559957342693"></p><h3 id="1-2-无监督学习">1.2 无监督学习</h3><p>只把数据交给算法，自动给事物分群。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1559958004823.png" alt="1559958004823"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1559958106526.png" alt="1559958106526"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1559958678329.png" alt="1559958678329"></p><p>（BC都是无监督学习）</p><h2 id="二、单变量线性回归">二、单变量线性回归</h2><h3 id="2-1-模型描述">2.1 模型描述</h3><ol><li><p>卖房子</p><p>卖房子预测，既是一个监督学习模型，也是一个回归模型。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560049205865.png" alt="1560049205865"></p></li><li><p>基本常识</p><ul><li><p>符号</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560049399859.png" alt="1560049399859"></p><ul><li>m：训练集</li><li>x &amp; y ：分别表示输入/输出变量</li></ul></li><li><p>监督学习流程</p></li></ul></li></ol><h3 id="2-2-代价函数">2.2 代价函数</h3><ul><li><p>平方误差代价函数</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560128930465.png" alt="1560128930465"></p></li><li><p>简化版平方代价函数</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560129076297.png" alt="1560129076297"></p></li><li><p>改变参数</p><ul><li><p>简化平代函数 ，改变一个参数θ1图像</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560129717654.png" alt="1560129717654"></p></li><li><p>平代函数，改变两个参数θ、θ1图像</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560130048907.png" alt="1560130048907"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560130125182.png" alt="1560130125182"></p><ul><li><p>用等高线图来表示（J(θ0,θ1)相同即等高）</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560130298220.png" alt="1560130298220"></p></li></ul></li></ul></li></ul><h3 id="2-3-梯度下降算法-—-自动寻找最小J-代价-算法">2.3 梯度下降算法 — 自动寻找最小J(代价)算法</h3><ul><li><p>问题描述</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560130706072.png" alt="1560130706072"></p></li><li><p>如何最快下山？</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560130901947.png" alt="1560130901947"></p><ul><li>不同下山点会得到不同下山路径，即局部最优解。</li></ul></li><li><p>梯度算法介绍</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560131210207.png" alt="1560131210207"></p><p>一定要同时更新，右边算法错误在于θ0更新值被用于 temp1，应该用旧值。</p><ul><li><p>梯度下降算法寻找最小代价过程</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560132406344.png" alt="1560132406344"></p><ul><li>如果斜率 == (d(J(θ))/dθ)θ &gt; 0 ，那么当前θ - α*斜率，就是使得θ减小，逼近函数底端</li><li>如果斜率 == (d(J(θ))/dθ)θ &gt; 0 ，那么当前θ - α*斜率，就是使得θ增大，逼近函数底端</li></ul></li><li><p>学习速率α</p><ul><li>学习速率大小影响</li></ul><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560133068276.png" alt="1560133068276"></p><ul><li>学习速率太小：逼近过程太慢</li><li>学习速度太大：可能会越过最低点（最小代价），甚至无法收敛</li></ul></li><li><p>梯度下降算法特点</p><ul><li><p>如果已经在局部最低点</p><p>此时，斜率为0，θ不会被更新，达到局部最优。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560133465037.png" alt="1560133465037"></p></li><li><p>自动减小θ变化程度</p><p>原因是因为，越逼近最低点，斜率会自动变小，α*斜率变小—&gt; θ变化程度降低。、</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560133692473.png" alt="1560133692473"></p></li></ul></li><li><p>总结</p><ol><li><p>基本方程了解</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560134078048.png" alt="1560134078048"></p></li><li><p>推导成偏微分项过程</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560134845193.png" alt="1560134845193"></p><ul><li>对θ0求导，结果如框1</li><li>对θ1求导，结果如框2</li></ul></li><li><p>梯度下降过程</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560136101991.png" alt="1560136101991"></p><ul><li><p>根据公式</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>θ</mi><mi>j</mi></msub><mo>=</mo><msub><mi>θ</mi><mi>j</mi></msub><mo>−</mo><mi>α</mi><mo>∗</mo><mfrac><mi mathvariant="normal">∂</mi><msub><mi mathvariant="normal">∂</mi><mi>θ</mi></msub></mfrac><mo>∗</mo><mi>J</mi><mo stretchy="false">(</mo><msub><mi>θ</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>θ</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta_j = \theta_j - \alpha*\frac{\partial}{\partial_\theta}*J(\theta_0,\theta_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.2074em;vertical-align:-0.836em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>不断减少 θ值，<strong>梯度下降</strong>使之达到局部最优。</p></li><li><p>不断拟合hθ，使得贴近数据，达到预测</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560135761297.png" alt="1560135761297"></p></li></ul></li></ol></li></ul></li></ul><h2 id="三-、多变量线性回归">三 、多变量线性回归</h2><h3 id="3-1-多功能">3.1 多功能</h3><ol><li><p>多变量预测房价</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560216164464.png" alt="1560216164464"></p></li><li><p>预测函数改进</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560216323707.png" alt="1560216323707"></p></li><li><p>写出矩阵表达形式</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560216620291.png" alt="1560216620291"></p></li></ol><h3 id="3-2-多元梯度下降法">3.2 多元梯度下降法</h3><p><strong>为什么假设的函数 h(θ)是一个线性形式？</strong></p><ul><li>通过大概预测数据分布</li><li>关键是让 最小代价函数 J会最小，拟合原数据。假设成线性形式方便推导，计算。</li></ul><ol><li><p>多元梯度下降计算最小代价</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560216753611.png" alt="1560216753611"></p></li><li><p>多元更新θ规则</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560217335389.png" alt="1560217335389"></p><ul><li><p>对θ更新的理解1</p><p>​       每一次更新θj都是，要利用到所有的数据集，计算出此时θj<strong>数据集所有不同特征{x1,x2,x3…xn}偏导数平均值</strong>，决定下一次θj的偏移值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开始迭代</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cnt=cnt+<span class="number">1</span></span><br><span class="line">    diff = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#梯度下降</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        diff[<span class="number">0</span>]+=h(x_train[i])-y[i]</span><br><span class="line">        diff[<span class="number">1</span>]+=(h(x_train[i])-y[i])*x_train[i]</span><br><span class="line">    theta0=theta0-alpha/m*diff[<span class="number">0</span>]</span><br><span class="line"> theta1=theta1-alpha/m*diff[<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="3-3-多元梯度实用技巧">3.3 多元梯度实用技巧</h3><p><strong>代价函数J是一个类似这种图形（多元更复杂）：</strong></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560130901947.png" alt="1560130901947"></p><ol><li><p>特征缩放：使得特征规模在一个相近范围</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560221138350.png" alt="1560221138350"></p><p>如果数据集{x1,x2,x3…xn}中特征xi过大，可能会使得J(θ)变得狭长，收敛慢、且震荡等：</p><ul><li>为什么会变这样？</li><li>改变{x1,x2,x3…xn}不会使得θ发生变化?</li></ul></li><li><p>更好的确定特征缩放范围</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mfrac><mrow><mi>X</mi><mo>−</mo><mi>u</mi></mrow><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">x_i = \frac{X - u}{max - min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1297em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">min</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560221603115.png" alt="1560221603115"></p></li><li><p>选择学习速率α</p><ul><li><p>观测是否收敛方法</p><ul><li><p>画出收敛过程图形（老师推荐）</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560222138878.png" alt="1560222138878"></p></li><li><p>设置某个限差</p><p>不推荐，因为一般难以判断。</p></li></ul></li><li><p>不收敛举例</p><ul><li><p>α过大</p><p>可能导致的情况：越过最低点，来回走；不断重复某个相似形状。</p><p>已经证明：只要α够小，代价函数J一定会减小。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560222542826.png" alt="1560222542826"></p></li><li><p>α过小</p><p>一定收敛，但是过程太慢。</p></li></ul></li><li><p>取α技巧（经验）</p><p>从一个较小合适值如0.001，每次是前一次3倍左右递增测试。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560222865949.png" alt="1560222865949"></p></li></ul></li></ol><h3 id="3-4-特征表达式和多项式回归">3.4 特征表达式和多项式回归</h3><p>D:\hwh\uploadToGit\cs_note\ML\assets\</p><ol><li><p>根据已知数据得出更好的特征</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560223454306.png" alt="1560223454306"></p><p>如，已知房子的长、宽特征，其实根据长*宽 这个新特征更好预测。</p></li><li><p>多元拟合举例（单一特征）</p><p>如下图房价是一个类似二次函数，那么可以选择多项式来拟合。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560223716759.png" alt="1560223716759"></p><p>为了更加精确，还可以增加开平方等（后面房价变化平缓）</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560223902314.png" alt="1560223902314"></p></li></ol><h3 id="3-5-正规方程解法">3.5 正规方程解法</h3><ol><li><p>方法1：求出偏微分置零—<strong>非线性</strong></p><p>这种方法，根据公式令所有的偏微分方程  == 0 ，然后解出 θ0，θ1…θn。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560240871197.png" alt="1560240871197"></p></li><li><p>方法2：公式解出—<strong>-线性</strong></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560241470307.png" alt="1560241470307"></p><p>简单来说就是求解：（不对，应该参考：<a href="https://blog.csdn.net/chenlin41204050/article/details/78220280">正规方程推导过程</a>）</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>Y</mi><mo>=</mo><mi>X</mi><mo>∗</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">Y = X*θ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>s</mi><mi>t</mi><mi>e</mi><mi>p</mi><mn>1</mn><mo>:</mo><msup><mi>X</mi><mi>T</mi></msup><mi>Y</mi><mo>=</mo><msup><mi>X</mi><mi>T</mi></msup><mi>X</mi><mo>∗</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">step1:X^TY = X^TX*θ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>s</mi><mi>t</mi><mi>e</mi><mi>p</mi><mn>2</mn><mo>:</mo><mtext>（</mtext><msup><mi>X</mi><mi>T</mi></msup><mi>X</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><msup><mi>X</mi><mi>T</mi></msup><mi>Y</mi><mo>=</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">step2:（X^TX)^{-1}X^TY = θ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span></span></p><ul><li><p>可是一般也不会是线性解啊？θ有n个，数据集有很多个如m，就X为m*（n+1）</p><p>m &gt;&gt; n，不一定有解啊？</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>s</mi><mi>t</mi><mi>e</mi><mi>p</mi><mn>1</mn><mo>:</mo><mi>y</mi><mo>=</mo><msub><mi>θ</mi><mn>0</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>2</mn></msub><mo>∗</mo><msub><mi>x</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>θ</mi><mi>n</mi></msub><mo>∗</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">step1: y = \theta_0 + \theta_1*x_1+ \theta_2*x_2.... \theta_n*x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">....</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p></li></ul></li><li><p>两种方法对比</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560242923616.png" alt="1560242923616"></p></li><li><p>如果正规方程，XTX不可逆（奇异矩阵）</p><p>一般不可逆情况很少。</p><ul><li><p>使用pinv求逆而非inv（即使不可逆也可求出）</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560244577724.png" alt="1560244577724"></p></li><li><p>改变特征值/正则化删除多余特征</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560244628225.png" alt="1560244628225"></p></li></ul></li></ol><h2 id="四、Octave-Matalab使用">四、Octave/ Matalab使用</h2><h3 id="4-1-基本操作">4.1 基本操作</h3><ul><li><p><strong>改变提示符号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">octave:1&gt; PS1(&#x27;&gt;&gt; &#x27;)  % 将octave：&lt;num&gt; &gt; &lt;命令&gt; 提示变成 &gt;&gt; &lt;命令&gt;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560389315896.png" alt="1560389315896"></p></li><li><p><strong>HELP 帮助</strong></p><ol><li><p>查看函数定义等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; help PS1</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560392475359.png" alt="1560392475359"></p></li></ol></li><li><p><strong>常规运算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; 1+2      % 加</span><br><span class="line">ans =  3    </span><br><span class="line">&gt;&gt; 1-2      % 减</span><br><span class="line">ans = -1</span><br><span class="line">&gt;&gt; 1*2      % 乘</span><br><span class="line">ans =  2</span><br><span class="line">&gt;&gt; 1/2      % 除</span><br><span class="line">ans =  0.50000</span><br><span class="line">&gt;&gt; 1^2      % 幂</span><br><span class="line">ans =  1</span><br><span class="line">&gt;&gt; 1%2      % 取余</span><br><span class="line">ans =  1</span><br></pre></td></tr></table></figure></li><li><p><strong>布尔运算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; 1 == 2    # equal</span><br><span class="line">ans = 0</span><br><span class="line">&gt;&gt; 1 ~= 2    # ...?</span><br><span class="line">ans = 1</span><br><span class="line">&gt;&gt;  1 &amp;&amp; 0   # AND</span><br><span class="line">ans = 0</span><br><span class="line">&gt;&gt; 1 || 0    # OR</span><br><span class="line">ans = 1</span><br></pre></td></tr></table></figure></li><li><p><strong>矩阵运算</strong></p><ol><li><p>加减</p><p><strong>A + 1 , A - 1 :</strong> 矩阵每一个数字都加减 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A = [1 2 3 ; 4 5 6 ; 7 8 9;];</span><br><span class="line"></span><br><span class="line">&gt;&gt; B = [1 2 3 ; 4 5 6 ; 7 8 9;];</span><br><span class="line"></span><br><span class="line">&gt;&gt; A + 1</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">    2    3    4</span><br><span class="line">    5    6    7</span><br><span class="line">    8    9   10</span><br></pre></td></tr></table></figure></li><li><p>乘除</p><p><strong>A*B</strong>  &amp; *<em>A .<em>B</em></em>  :  前者常规矩阵相乘，后者是用对应A(i,j) * B(i,j)</p><p>类似的还有：<strong>1 ./ A , A .^2</strong> ,  <Kbd>.</kbd>都是表示对矩阵每个元素的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A * B</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">    30    36    42</span><br><span class="line">    66    81    96</span><br><span class="line">   102   126   150</span><br><span class="line"></span><br><span class="line">&gt;&gt; A .*B</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">    1    4    9</span><br><span class="line">   16   25   36</span><br><span class="line">   49   64   81</span><br></pre></td></tr></table></figure></li><li><p>函数</p><p><strong>A '、pinv(A)abs(A)、log(A)、exp(A)、max(A)</strong>  &amp;</p><p><strong>ceil(A)、floor(A)</strong> 向上、下取整</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A = [1 2 3 ; 4 5 6 ; 7 8 9;]</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   1   2   3</span><br><span class="line">   4   5   6</span><br><span class="line">   7   8   9</span><br><span class="line">&gt;&gt; A&#x27;</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   1   4   7</span><br><span class="line">   2   5   8</span><br><span class="line">   3   6   9  </span><br></pre></td></tr></table></figure><p><strong>sum(A)</strong>、<strong>prod(a)</strong> 、<strong>max(A)</strong>：返回每行元素 <strong>和、乘积</strong>、<strong>最大值</strong>，以行向量表示。</p><p><strong>max(A,B)</strong>：比较A 和 B 对应位置元素，求最大，组成新矩阵</p><p><strong>max(A,[],1)</strong>、<strong>max(A,[],2)</strong>：分别获取每一列、行最大值</p><p><strong>sum(A,1)</strong>、<strong>sum(A,2)</strong>：分别获取每一列、行和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; sum(A)   % 默认获取的是每一列的最大值</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   12   15   18</span><br><span class="line"></span><br><span class="line">&gt;&gt; prod(A)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">    28    80   162</span><br><span class="line">    </span><br><span class="line">&gt;&gt; [r,c]= max(A)  % r 是每列最大数字 ； c是每列最大数字索引</span><br><span class="line">r =</span><br><span class="line"></span><br><span class="line">   7   8   9</span><br><span class="line"></span><br><span class="line">c =</span><br><span class="line"></span><br><span class="line">   3   3   3</span><br><span class="line">   </span><br><span class="line">&gt;&gt; max(A,[],2) % 返回每行最大</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">   6</span><br><span class="line">   9</span><br></pre></td></tr></table></figure><p><strong>find(A &lt; 3)</strong> ：返回矩阵所有小于3的元素，为一个<strong>列向量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; find(A &lt; 3)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   4</span><br></pre></td></tr></table></figure></li><li><p>布尔</p><p><strong>A &lt; 3 、 A &gt; 3</strong> : 相对矩阵每个元素都和3进行bool运算，返回 <strong>0</strong> 或者 <strong>1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A &lt; 3</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">  1  1  0</span><br><span class="line">  0  0  0</span><br><span class="line">  0  0  0</span><br></pre></td></tr></table></figure></li><li><p>补充</p><p><strong>A(:)</strong> ：将A所有元素组成一个列向量。配合 max(A)就可以求矩阵A的最大值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">B =</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   4</span><br><span class="line">   7</span><br><span class="line">   2</span><br><span class="line">   5</span><br><span class="line">   8</span><br><span class="line">   3</span><br><span class="line">   6</span><br><span class="line">   9</span><br><span class="line"></span><br><span class="line">&gt;&gt; max(B)   % max 默认求每列的最大值</span><br><span class="line">ans =  9</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>变量相关操作</strong></p><ol><li><p>定义变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = pi   % 变量会自动打印</span><br><span class="line">a =  3.1416</span><br><span class="line">&gt;&gt; a = pi;  % 让变量不打印</span><br></pre></td></tr></table></figure></li><li><p>display 打印变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = pi;</span><br><span class="line">&gt;&gt; display(a)  </span><br><span class="line">a =  3.1416</span><br><span class="line">&gt;&gt; display(sprintf(&#x27;%0.2f&#x27;,a))  % 以C语言格式打印出来</span><br></pre></td></tr></table></figure></li><li><p>format 打印变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; format long    </span><br><span class="line">&gt;&gt; a</span><br><span class="line">a =  3.141592653589793</span><br><span class="line"></span><br><span class="line">&gt;&gt; format short</span><br><span class="line">&gt;&gt; a</span><br><span class="line">a =  3.1416</span><br></pre></td></tr></table></figure></li><li><p>clear清除变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clear a  % 清除a变量</span><br><span class="line">clear    % 清除所有变量</span><br></pre></td></tr></table></figure></li><li><p>who,whos显示所有变量信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; who</span><br><span class="line">Variables in the current scope:</span><br><span class="line"></span><br><span class="line">A     a     ans   data</span><br><span class="line"> </span><br><span class="line">&gt;&gt; whos    % whos更加详细</span><br><span class="line">Variables in the current scope:</span><br><span class="line"></span><br><span class="line">   Attr Name        Size                     Bytes  Class</span><br><span class="line">   ==== ====        ====                     =====  =====</span><br><span class="line">        A          15x15                      1800  double</span><br><span class="line">        a           1x1                          8  double</span><br><span class="line">        ans         1x14                        14  char</span><br><span class="line">        data        3x3                         72  double</span><br><span class="line"></span><br><span class="line">Total is 249 elements using 1894 bytes</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>向量和矩阵</strong></p><ol><li><p>常规生成矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A = [1 2; 3 4 ; 5 6]  % 以；分隔矩阵行 ，以空格分隔每一行元素</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; A = [1 2;     %  另一种输入矩阵方法</span><br><span class="line">&gt; 3 4;</span><br><span class="line">&gt; 5 6]</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br></pre></td></tr></table></figure></li><li><p>快捷生成矩阵</p><p>**<int>:<double>:<int>**指定起始和结束生成一个 <strong>行向量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A = 1:0.2:2  % 同时指定步长为 0.2</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">    1.0000    1.2000    1.4000    1.6000    1.8000    2.0000</span><br><span class="line">&gt;&gt; A = 1 : 5    % 不指定步长（默认为1）</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   1   2   3   4   5    </span><br></pre></td></tr></table></figure><p>直接<strong>复制</strong>某矩阵指定多少元素，生成 <strong>行向量</strong>，<strong>从上至下，从左至右</strong>开始算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; w = rand(3,3)</span><br><span class="line">w =</span><br><span class="line"></span><br><span class="line">   0.920009   0.424680   0.795883</span><br><span class="line">   0.890070   0.048942   0.592416</span><br><span class="line">   0.748348   0.784034   0.366445</span><br><span class="line">   </span><br><span class="line">&gt;&gt; v = w(1:3)  % 1:3 表示第1 到 第3 个元素赋值给v行向量（第一列）</span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">   0.92001   0.89007   0.74835</span><br></pre></td></tr></table></figure><p>用<strong>ones</strong>、<strong>zeros</strong>、<strong>magic</strong>函数指定行列，生成元素为<strong>1、0</strong>矩阵 或者 <strong>幻方方阵</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; ones(2,2)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   1   1</span><br><span class="line">   1   1</span><br><span class="line"></span><br><span class="line">&gt;&gt; 2*ones(2,2) % 还可以指定倍数</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   2   2</span><br><span class="line">   2   2</span><br><span class="line">    </span><br><span class="line">&gt;&gt; magic(3)    % 每行、列、对角 相加相等</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   8   1   6</span><br><span class="line">   3   5   7</span><br><span class="line">   4   9   2</span><br></pre></td></tr></table></figure><p><strong>rand、randn</strong>生成随机矩阵（randn生成的矩阵符合高斯分布）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; rand(2,2)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   0.84394   0.39302</span><br><span class="line">   0.33943   0.18478</span><br><span class="line"></span><br><span class="line">&gt;&gt; randn(2,2)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">  -0.32139   0.19817</span><br><span class="line">   0.62788   0.42349</span><br></pre></td></tr></table></figure><p><strong>eye</strong> 生成单位矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; eye(3)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">Diagonal Matrix</span><br><span class="line"></span><br><span class="line">   1   0   0   </span><br><span class="line">   0   1   0   </span><br><span class="line">   0   0   1   </span><br></pre></td></tr></table></figure></li><li><p>图形显示矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A = rand(15,15);</span><br><span class="line">&gt;&gt; hist(A)</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560392261524.png" alt="1560392261524"></p></li><li><p>矩阵数据索引</p><p><strong>A(i,j)</strong>   显示矩阵A，i行j列元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A = [1 2 3 ; 4 5 6; 7 8 9]</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   1   2   3</span><br><span class="line">   4   5   6</span><br><span class="line">   7   8   9</span><br><span class="line">&gt;&gt; A(2,2)</span><br><span class="line">ans =  5</span><br></pre></td></tr></table></figure><p><strong>A(i,:) **  获取矩阵A，第</strong>i行**所有元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A(2,:)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   4   5   6</span><br></pre></td></tr></table></figure><p><strong>A(:,j) **  获取矩阵A，第</strong>j列**所有元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A(:,2)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   2</span><br><span class="line">   5</span><br><span class="line">   8</span><br></pre></td></tr></table></figure><p><strong>A([i,j],:) **   获取矩阵A，<strong>第i行</strong>和</strong>第j行**元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A([1,3],:)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   1   2   3</span><br><span class="line">   7   8   9</span><br></pre></td></tr></table></figure></li><li><p>修改矩阵</p><p><strong>A(:,j) = [column vector ]</strong> ： 修改矩阵<strong>第j列</strong>为新列向量</p><p><strong>A(i,:) = [column vector ]</strong> ： 修改矩阵<strong>第i行</strong>为新行向量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A(:,2) = [8 ; 8 ; 8]</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   1   8   3</span><br><span class="line">   4   8   6</span><br><span class="line">   7   8   9</span><br><span class="line"></span><br><span class="line">&gt;&gt; A(2,:) = [7 7 7]</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   1   8   3</span><br><span class="line">   7   7   7</span><br><span class="line">   7   8   9</span><br></pre></td></tr></table></figure></li><li><p>组合矩阵</p><p><strong>[A,B] &amp; [A B] :</strong> 将矩阵B作为矩阵A的<strong>扩展列</strong>，形成新矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A  = [1 1 1]</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   1   1   1</span><br><span class="line"></span><br><span class="line">&gt;&gt; B  = [2 2 2]</span><br><span class="line">B =</span><br><span class="line"></span><br><span class="line">   2   2   2</span><br><span class="line">&gt;&gt; [A,B]</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   1   1   1   2   2   2</span><br></pre></td></tr></table></figure><p><strong>[A;B]  :</strong> 将矩阵B作为矩阵A的<strong>扩展行</strong>，形成新矩阵，注意是<strong>分号；</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; [A;B]</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   1   1   1</span><br><span class="line">   2   2   2</span><br></pre></td></tr></table></figure></li><li><p>矩阵量度</p><p><strong>size</strong> 返回矩阵大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; size(A)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   15   15</span><br></pre></td></tr></table></figure><p><strong>length</strong> 返回行长</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; length(A)</span><br><span class="line">ans =  15</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="4-2-移动数据">4.2 移动数据</h3><ul><li><p><strong>路径相关</strong></p><p>pwd ：当前路径 ； cd  切换目录 ； ls 显示当前目录文件</p></li><li><p><strong>load 加载文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">load data.dat</span><br><span class="line">load(&#x27;data.dat&#x27;)</span><br><span class="line">&gt;&gt; data   % 特别注意不要输入:后缀名！！！</span><br><span class="line">data =</span><br><span class="line"></span><br><span class="line">   1   2   3</span><br><span class="line">   4   5   6</span><br><span class="line">   7   8   9</span><br></pre></td></tr></table></figure></li><li><p><strong>save 存储数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data =</span><br><span class="line"></span><br><span class="line">   1   2   3</span><br><span class="line">   4   5   6</span><br><span class="line">   7   8   9</span><br><span class="line"></span><br><span class="line">&gt;&gt; v = data(1:3)</span><br><span class="line">&gt;&gt; save v.dat v</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-数据绘制">4.3 数据绘制</h3><ol><li><p>设置横轴坐标 &amp; 函数（中间数字为什么不能改变成 0.1？？）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; t = [0:0.01:2*pi];</span><br><span class="line">&gt;&gt; y1 = sin(t); </span><br><span class="line">&gt;&gt; y2 = cos(t);</span><br></pre></td></tr></table></figure></li><li><p>绘制图形</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; plot(t,y1)</span><br><span class="line">hold on; % 保持正弦图形在基础上再绘制余弦函数</span><br><span class="line">&gt;&gt; plot(t,y2)</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560418225818.png" alt="1560418225818"></p><ol start="3"><li><p>添加信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; xlabel(&#x27;time&#x27;);  % 增加x坐标轴标签</span><br><span class="line">&gt;&gt; ylabel(&#x27;value&#x27;);  % 增加y坐标轴标签</span><br><span class="line">&gt;&gt; legend(&#x27;sin&#x27;,&#x27;cos&#x27;);  % 用显示两条线代表什么函数</span><br><span class="line">&gt;&gt; title(&#x27;simple plot&#x27;)    % 增加这幅图的标题</span><br></pre></td></tr></table></figure></li><li><p>保存图片</p><p>cd &lt;保存路径&gt; ；&lt;保存图片名&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; cd &#x27;C:\Users\Administrator\Desktop&#x27;;print -dpng &#x27;myPlot.png&#x27; </span><br></pre></td></tr></table></figure></li><li><p>同时显示两张图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; figure(1);plot(t,y1);</span><br><span class="line">&gt;&gt; figure(2);plot(t,y2);</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560418741380.png" alt="1560418741380"></p></li><li><p>显示框分隔成两块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; subplot(1,2,1);   % 把界面分成1x2，选中第一个格子</span><br><span class="line">&gt;&gt; plot(t,y1); </span><br><span class="line">&gt;&gt; subplot(1,2,2);    % 选中第二个格子</span><br><span class="line">&gt;&gt; plot(t,y2);</span><br><span class="line">&gt;&gt; axis([0.5 1 -1 1])   % 修改第二幅图的横坐标为[0.5,1],纵坐标为[-1,1]</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560418952275.png" alt="1560418952275"></p></li><li><p>绘制矩阵图像</p><p>矩阵中一个元素代表着一个色块，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A = magic(3)</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   8   1   6</span><br><span class="line">   3   5   7</span><br><span class="line">   4   9   2</span><br><span class="line">&gt;&gt; imagesc(A) % 生成不同色块矩阵</span><br><span class="line">&gt;&gt; imagesc(A),colorbar,colormap pink;  % 色块的颜色深浅由元素的数值决定。</span><br><span class="line">&gt;&gt; close  % 关闭所有打开的绘制图像框</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560419404275.png" alt="1560419404275"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560419367230.png" alt="1560419367230"></p></li></ol><h3 id="4-4-控制语句-for、while…">4.4 控制语句 for、while…</h3><ul><li><p><strong>for、while循环</strong></p><p>for : 变量i会自＋1</p><p>while：i不会自加，需要自己设置初始值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; rang = [1:3]</span><br><span class="line">rang =</span><br><span class="line"></span><br><span class="line">    1    2    3     </span><br><span class="line"></span><br><span class="line">&gt;&gt; for i = rang   % 等价于 ：  for i = [1:10]</span><br><span class="line">&gt;     disp(i);</span><br><span class="line">&gt;  end</span><br><span class="line"> 1</span><br><span class="line"> 2</span><br><span class="line"> 3</span><br><span class="line">&gt;&gt; i = 0</span><br><span class="line">&gt;&gt; while i &lt; 3</span><br><span class="line">&gt;    disp(i);</span><br><span class="line">&gt;    i = i+1;  % 加；，使得i不会输出</span><br><span class="line">&gt;  end;</span><br><span class="line"> 0</span><br><span class="line"> 1</span><br><span class="line"> 2</span><br></pre></td></tr></table></figure><h4 id=""></h4></li><li><p><strong>if</strong></p><p>注意 if也要有end配合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; i = 0 ;</span><br><span class="line">&gt;&gt; while true</span><br><span class="line">&gt;    i = i+1;</span><br><span class="line">&gt;    disp(i)</span><br><span class="line">&gt;    if i == 3</span><br><span class="line">&gt;       break;</span><br><span class="line">&gt;    else if</span><br><span class="line">&gt;       disp(&#x27;continue&#x27;)</span><br><span class="line">&gt;    end</span><br><span class="line">&gt;  end</span><br></pre></td></tr></table></figure></li><li><p><strong>调用自定义函数</strong></p><p>定义一个后缀名为 <strong>.m</strong>文件：<strong>square.m</strong>，写入函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function y = square(x)  % 函数头，函数名最好和文件名相同</span><br><span class="line">y = x^2; % 函数主体</span><br></pre></td></tr></table></figure><p>在octave中CIL中调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; cd C:\Users\86151\Desktop % 先切换到文件所在目录</span><br><span class="line">&gt;&gt; square(10)</span><br><span class="line">ans =  100</span><br></pre></td></tr></table></figure><p>也可返回多个值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function [a,b] = squareAndCube(x) </span><br><span class="line">a = x^2; </span><br><span class="line">b = y^3;</span><br><span class="line">&gt;&gt; % 在octave中调用 squareAndCube.m 中 squareAndCube函数</span><br><span class="line">&gt;&gt; [a,b] = squareAndCube(10)</span><br><span class="line">a =  100</span><br><span class="line">b =  1000</span><br></pre></td></tr></table></figure></li><li><p>计算代价函数实例</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560430477647.png" alt="1560430477647"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560430549776.png" alt="1560430549776"></p></li></ul><h3 id="4-5-矢量">4.5 矢量</h3><ul><li><p><strong>矩阵化两数相乘求和</strong></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560430871580.png" alt="1560430871580"></p></li><li><p><strong>更复杂的举例</strong></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560431476623.png" alt="1560431476623"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560431515515.png" alt="1560431515515"></p></li></ul><h2 id="五、Logistic回归">五、Logistic回归</h2><h3 id="5-1-分类">5.1 分类</h3><ul><li><p>线性回归预测分类问题</p><p>例如预测，肿瘤是否良性问题。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560500866677.png" alt="1560500866677"></p><p>我们将大于0.5的预测函数h肿瘤，预测为良性；小于0.5预测为恶性。</p><p>但是如果增加一个数据集，预测函数把原本属于恶性肿瘤预测为良性。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560501384545.png" alt="1560501384545"></p><p>另外一个问题，预测函数h(x)值可以超过[0,1]范围。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560501473281.png" alt="1560501473281"></p></li></ul><h3 id="5-2-假设陈述">5.2 假设陈述</h3><ul><li><p>Sigmoid函数 &amp; Logistic 函数</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>i</mi><mi>g</mi><mi>m</mi><mi>o</mi><mi>i</mi><mi>d</mi><mtext>函数：</mtext><mi>g</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>z</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">Sigmoid 函数：g(z) = \frac{1}{1+e^{-z}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord cjk_fallback">函数：</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0908em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6973em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>o</mi><mi>g</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>c</mi><mtext>函数</mtext><mo>:</mo><msub><mi>h</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><msup><mi>θ</mi><mi>T</mi></msup><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Logistic 函数 :h_\theta(x) = g(\theta^Tx)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord cjk_fallback">函数</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560501714042.png" alt="1560501714042"></p><p>预测病人有 70% 概率患有恶性肿瘤。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560501984032.png" alt="1560501984032"></p></li></ul><h3 id="5-3-决策界限">5.3 决策界限</h3><ul><li><p>再理解Logistic 函数</p><p>当 z &gt; 0 时，g（z）&gt; 0.5 -----&gt; θ’ &gt; 0 时，g（θ’）&gt; 0.5。</p><p>那么如果设置  阀值 = 0.5，只需判断 θ’ &gt; 0 ? 便可分类了。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560503133209.png" alt="1560503133209"></p></li><li><p>举例（一）</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560503313134.png" alt="1560503313134"></p><p>如果设定阀值= 0.5，按照前推论，预测 y = 1只需 ：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\theta_0+\theta_1x_1+\theta_2x_2 &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span></p><p>不妨假设，θ0 = 0 ，θ1 = θ2 = 1。那么便是推得：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo>≥</mo><mn>3</mn><mo separator="true">,</mo><mi>y</mi><mo>=</mo><mn>1</mn><mo separator="true">;</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo>&lt;</mo><mn>3</mn><mo separator="true">,</mo><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_1 + x_2 ≥  3 , y = 1 ; x_1 + x_2 &lt; 3 , y = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span></p><p>由此可以得到决策边界函数，如下图红色直线所示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">x_1 + x_2 = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span></span></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560504267347.png" alt="1560504267347"></p></li><li><p>举例（二）</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560503776240.png" alt="1560503776240"></p><p>基本推导过程同上，可以得到决策边界函数：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi>x</mi><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>x</mi><mn>2</mn><mn>2</mn></msubsup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x_1^2+x_2^2 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p>可能还有有更复杂的图形和参数：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560504537583.png" alt="1560504537583"></p></li></ul><h3 id="5-4-代价函数">5.4 代价函数</h3><ul><li><p>向量化 Logistic函数</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560505180168.png" alt="1560505180168"></p></li><li><p>选择新的代价函数</p><blockquote><p>为什么要构造新的代价函数？</p></blockquote><blockquote><p>线性回归代价函数的实际意义就是平方误差。而逻辑回归却不是，它的预测函数hθ(x)hθ(x)是非线性的。如果类比地使用线性回归的代价函数于逻辑回归，那J(θ)J(θ)很有可能就是非凸函数，即存在很多局部最优解，但不一定是全局最优解。我们希望构造一个凸函数，也就是一个碗型函数做为逻辑回归的代价函数。</p></blockquote></li></ul><blockquote><p>原文链接：<a href="https://blog.csdn.net/ljp1919/article/details/79120761">https://blog.csdn.net/ljp1919/article/details/79120761</a></p></blockquote><p>原先<strong>总体代价函数</strong>：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560506503237.png" alt="1560506503237"></p><p>将 左边 <code>1/2(h_θ(x) - y)^2</code> 替换成新的代价函数（<strong>不是总体代价函数！！</strong>）：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560506600510.png" alt="1560506600510"></p><p>对于新代价函数理解：</p><p>在 y = 1 ，即数据集实际分类为1，Cost图像如下：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560507155266.png" alt="1560507155266"></p><ul><li><p>如果预测函数h(θ) = 0 ，即分类到0，和实际 1偏差，则代价 --&gt;无穷，惩罚这个函数？</p><ul><li>相反，如果预测结果h(θ) = 1，那么代价为—&gt;0，符合实际数据集 = 1。</li></ul><p>同理，y = 0 时，实际分类为0，代价函数Cost图像如下：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560507435430.png" alt="1560507435430"></p><p><strong>但是，和前面代价函数相比怎么更新θ？？</strong></p></li></ul><h3 id="5-5-简化代价函数与梯度下降">5.5 简化代价函数与梯度下降</h3><ul><li><p>简化代价 &amp; 回归函数</p><p>将先前<strong>代价函数</strong>写成一项：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560564141466.png" alt="1560564141466"></p><p>那么新的<strong>总体代价函数</strong>是：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560564217942.png" alt="1560564217942"></p></li><li><p>梯度下降</p><ul><li><p>总体流程</p><p>不断调整θ，使得代价函数（总体）最小，最后得出回归预测函数。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560564415073.png" alt="1560564415073"></p></li><li><p>详细过程</p><p>更新θ，和前类似，关键在于计算导数。（<strong>没推导出求导怎么出来的</strong>）</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560565632106.png" alt="1560565632106"></p><p>其中 θTx 为线性时，h(x) = g(θ0 + θ2x1+θ3x3…+θnxn)为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><msup><mi>θ</mi><mi>T</mi></msup><mi>x</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">h_\theta(x) = \frac{1}{1+e^{-\theta^Tx}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1256em;vertical-align:-0.8042em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.2791em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8309em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7741em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8042em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li></ul></li></ul><h3 id="5-6-高级优化">5.6 高级优化</h3><ul><li><p>梯度算法简介</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560568159858.png" alt="1560568159858"></p></li><li><p>octave中调用梯度下降算法</p><ol><li><p>写好代价函数算法</p><p>注意这里好像没有数据集，实际上这就是单纯求这个代价函数的最小值。</p><p>然后把θ迭代，直至收敛。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560568981567.png" alt="1560568981567"></p><p>实际自己编写的 COSTFunction.m函数</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560569262099.png" alt="1560569262099"></p></li><li><p>调用梯度下降算法</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560569161544.png" alt="1560569161544"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560570152718.png" alt="1560570152718"></p></li></ol></li></ul><h3 id="5-7-多元分类：一对多">5.7 多元分类：一对多</h3><ul><li><p>问题</p><p>我们知道用Logistic 函数对类型进行二维分类，那么如何进行多元分类呢？</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560570704004.png" alt="1560570704004"></p></li><li><p>解决</p><p>采用“一对余”方法，简单来说。就是先n元分类变成2元分类，区分出一个。</p><p>然后循环上述，直至区分出所有。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560570888798.png" alt="1560570888798"></p></li></ul><h2 id="六、正则化">六、正则化</h2><h3 id="6-1-过拟合问题">6.1 过拟合问题</h3><ul><li><p>什么是过拟合</p><p>无论是之前的，线性回归和逻辑回归都有出现过度拟合。</p><ul><li><p>线性回归过拟合</p><p>如下图所示，图三虽然千方百计很好的拟合了数据，**保留了更多特征x3、x4…**但是很显然它并不能得到一条很好的预测函数。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560586484748.png" alt="1560586484748"></p></li><li><p>逻辑回归过拟合</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560586682837.png" alt="1560586682837"></p></li></ul></li><li><p>如何解决过拟合</p><ul><li><p>减少特征</p><p>减少特征分为人工或者模型选择算法来达到目的。但是减少特征会使得我们无视一些本该有用的特征变量。（比如房子是否明亮对预测价格也是有影响的）</p></li><li><p>正则化</p><p>保留所有特征，但是减少它们的量级。</p></li></ul></li></ul><h3 id="6-2-代价函数">6.2 代价函数</h3><ul><li><p>正则化举例</p><ul><li><p>引子</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560587982945.png" alt="1560587982945"></p><p>依旧是图二，虽然保留更多特征，但是图形过于浮夸，并不是一个好的预测函数。我们可以通过正则化，<strong>减少特征 x3、x4的影响</strong>。</p></li><li><p>正则化</p><p><strong>减少特征 x3、x4的影响，可以通过减少θ3、θ4来实现</strong>：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560588227832.png" alt="1560588227832"></p><p>在我们使得代价函数越来越小的过程中，θ3、θ4则会趋于0。使得预测函数好像不存在θ3^3、θ4^4这两项一样，–<strong>预测函数越简单越不会出现过度拟合</strong>–。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560588340205.png" alt="1560588340205"></p></li></ul></li><li><p>正则化标准过程</p><ol><li><p>确定特征 &amp; 参数</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560588558565.png" alt="1560588558565"></p></li><li><p>写出代价函数</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560588581358.png" alt="1560588581358"></p></li><li><p>加入正则新项</p><p>正则新项用来<strong>惩罚</strong>θ参数，注意一般不对θ0进入惩罚。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560588679349.png" alt="1560588679349"></p></li></ol></li><li><p>正则化不当后果</p><ul><li><p>惩罚过大</p><p>使得参数 θ 都趋于0，那么预测函数会趋近于一条水平直线。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560588932268.png" alt="1560588932268"></p></li></ul></li></ul><h3 id="6-3-线性回归正则化">6.3 线性回归正则化</h3><ul><li><p>流程</p><ol><li><p>列出代价函数正则表达式</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560589415655.png" alt="1560589415655"></p></li><li><p>进行梯度下降</p><p>根据以前的梯度下降公式可以得出：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560589482724.png" alt="1560589482724"></p><p>加上<strong>正则化</strong>进行的变形梯度下降公式：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560589654275.png" alt="1560589654275"></p><p>相比之前，每次更新都对θj<code>*</code>(1 - α<code>*</code>λ/m)，而 (1 - α*λ/m) 是一个<strong>比 1小一点的数</strong>，则相比未正则化前加<strong>快向0的方向趋近</strong>？？</p></li></ol></li><li><p>采用正规方程来解决(<strong>所有特征x都是一次，线性回归</strong>)</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560590313735.png" alt="1560590313735"></p><p>根据之前正规方程解出θ，<a href="https://blog.csdn.net/chenlin41204050/article/details/78220280">推导过程</a>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>θ</mi><mo>=</mo><mo stretchy="false">(</mo><msup><mi>X</mi><mi>T</mi></msup><mi>X</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><msup><mi>X</mi><mi>T</mi></msup><mi>y</mi></mrow><annotation encoding="application/x-tex">\theta = (X^TX)^{-1}X^Ty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></span></p><p>如果使用正则化则应该是：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560590414757.png" alt="1560590414757"></p><p>**注意：**只要λ&gt;0，上式（）中一定可逆。</p></li></ul><h3 id="6-4-Logistic-回归正则化">6.4 Logistic 回归正则化</h3><ul><li><p>流程</p><ol><li><p>列出代价函数正则表达式</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560564217942.png" alt="1560564217942"></p></li><li><p>梯度下降算法</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560592079668.png" alt="1560592079668"></p></li></ol></li><li><p>octave实现</p><ul><li><p>写出costFunction函数</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560592243350.png" alt="1560592243350"></p></li></ul></li></ul><h2 id="七、神经网络学习">七、神经网络学习</h2><h3 id="7-1-非线性假设">7.1 非线性假设</h3><p>​      在前面我们进行都是线性假设，如 ： h = θ0 + θ1x1 + θ2x2 ，而不会出现 x1x2、x1^2*x2…之类。</p><ul><li><p>多项特征处理</p><ul><li><p>两项特征时logistic回归</p><p>注意下面只有两个特征x1、x2，但是是非线性，进行回归分类。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560737625444.png" alt="1560737625444"></p></li><li><p>多个特征时</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560737719627.png" alt="1560737719627"></p></li></ul></li><li><p>举例识别汽车</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560738363402.png" alt="1560738363402"></p><ul><li><p>流程</p><ul><li><p>给每个样本集输入学习算法得出分类器</p><ul><li><p>给一辆汽车标记两个像素位置pixel1、pixel2，并记录它们像素强度坐标</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560738766383.png" alt="1560738766383"></p></li><li><p>然后再记录另一辆汽车**相同像素位置的？？？**像素强度坐标</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560738857388.png" alt="1560738857388"></p></li><li><p>重复以上得出更多左边对它们进行分类</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560739149161.png" alt="1560739149161"></p><p>但是，一张50*50图片都有2500个像素点位置，对应2500个像素强度。如果还要包含所有的二次项特征约有300万个。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560739335295.png" alt="1560739335295"></p></li></ul></li><li><p>让分类器去判断一个新样本是否是汽车</p></li></ul></li></ul></li></ul><h3 id="7-2-神经元与大脑">7.2 神经元与大脑</h3><p>略</p><h3 id="7-3-模型展示">7.3 模型展示</h3><h4 id="模型展示1">模型展示1</h4><ul><li><p>神经元</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560739935248.png" alt="1560739935248"></p></li><li><p>神经元模型</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560740258768.png" alt="1560740258768"></p></li><li><p>神经网络</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560740525215.png" alt="1560740525215"></p><ul><li><p>具体解释</p><ul><li><p>各个出现参数含义</p><p>ai^j ,第j 层“激活的神经元”用来计算前一层（j-1）输入x1、x2、x3的值；</p><p>θ^j，用来控制从第j 到 j +1层的映射权重。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560741588360.png" alt="1560741588360"></p></li><li><p>计算流程</p><p>​      第二层活动神经元ai^2 ，计算从第一层到第二层的映射，同时θ^1来控制映射权重。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560741831931.png" alt="1560741831931"></p><p>​    然后第三层，计算最终结果：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560741931830.png" alt="1560741931830"></p><p>在上面这个式中，<strong>非常类似于逻辑回归</strong>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>o</mi><mi>g</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>c</mi><mtext>函数</mtext><mo>:</mo><msub><mi>h</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><msup><mi>θ</mi><mi>T</mi></msup><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Logistic 函数 :h_\theta(x) = g(\theta^Tx)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord cjk_fallback">函数</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></p><p>​       只不过，它不是直接利用x1、x2、x3特征作为输入，而是先利用第二层“神经元”进行计算。得出a0（多添加的basic单元）、a1、a2、a3。</p></li><li><p>总结</p><p>​        第j层有sj个单元，第j+1层有sj+1个单元，那么控制从j层到j+1层映射权重θj的个数应该是，第j+1层单元数 * （第j层单元数 + 1），即：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>s</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>∗</mo><mtext>（</mtext><msub><mi>s</mi><mi>j</mi></msub><mo>+</mo><mn>1</mn><mtext>）</mtext><mo separator="true">,</mo><mtext>第</mtext><mi>j</mi><mtext>层会补一个</mtext><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_{j+1} * （s_j + 1）,第j层会补一个x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7514em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord cjk_fallback">）</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">第</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">层会补一个</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p></li></ul></li></ul></li></ul><h4 id="模型展示2">模型展示2</h4><ul><li><p>向量化神经网络公示</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560742991770.png" alt="1560742991770"></p></li><li><p>更复杂的神经网络举例</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560743755725.png" alt="1560743755725"></p></li></ul><h3 id="7-4-例子和直觉理解">7.4 例子和直觉理解</h3><h4 id="直觉理解1">直觉理解1</h4><ul><li><p>神经元函数计算 AND</p><p>如下图所示，有两个特征x1、x2只可能是 0 或者 1，同时给它们赋予<strong>权重 θ:</strong> -30、+20、+20（-30给增加的basic单元）。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560757127231.png" alt="1560757127231"></p><p>那么对应的h(x)，为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mo>−</mo><mn>30</mn><mo>+</mo><mn>20</mn><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mn>20</mn><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_\theta(x)=g(-30+20x_1+20x_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">−</span><span class="mord">30</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">20</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">20</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>对应函数图形为：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560757264642.png" alt="1560757264642"></p><p>那么输入x1、x2得出的特征值是</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560757331837.png" alt="1560757331837"></p><p>计算结果恰为 x1 &amp; x2，实现了神经网络逻辑AND运算。</p></li><li><p>神经网络计算OR</p><p>基本同上过程：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560757408530.png" alt="1560757408530"></p></li><li><p>神经网络计算NOT</p><p>​    <strong>由于权重θ1 = - 20</strong> ，当 x1 = 0 时， h = 1，趋近1 ； 反之 x2 = 1 ，h = 0 ，达到取反的效果。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560757856132.png" alt="1560757856132"></p><p>​       进一步还可以得到，计算 <strong>NOT x_1 AND NOT x_2</strong>。</p><p>​       只有当 x1 = x2 = 0，h = 1。那么只需 对应权重θ1 、θ2 为一个较大负数，θ0 为一个整数，只要 x1、x2有一个不为0，那么结果必为0。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560758444396.png" alt="1560758444396"></p></li></ul><h4 id="直觉理解2">直觉理解2</h4><ul><li><p>组合成更复杂的神经网络计算 <strong>x1 XNOR x2</strong></p><ul><li><p>基本神经网络逻辑计算</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560758551280.png" alt="1560758551280"></p></li><li><p>组合计算<strong>x1 XNOR x2</strong></p><p>​       x1 XNOR x2，即 x1、x2相同才会为1。而它们直接基本组合很难计算出来，抓住<strong>相同</strong>二字，我们可以联想用<strong>AND</strong>。在此之前一层：</p><ul><li><p>x1 = x2 = 0，要经过计算得出为1，显然要用<strong>NOT x_1 AND NOT x_2</strong></p></li><li><p>x1 = x2 = 1，要经过计算得出为1，显然要用 <strong>AND</strong> 即可</p><p>故有如下组合：</p></li></ul><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560758740736.png" alt="1560758740736"></p></li></ul></li><li><p>其他更复杂计算（<strong>手迹判别</strong>）</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560759144939.png" alt="1560759144939"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560759417704.png" alt="1560759417704"></p></li></ul><h3 id="7-5-多元分类-以识别汽车、人、摩托举例">7.5 多元分类----以识别汽车、人、摩托举例</h3><p>​        上节看到的识别手迹数字，就是一个多元分类问题（识别数字 0~9）。神经元网络实现多元分类，本质就是<strong>一对多</strong>法的扩展。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560759860986.png" alt="1560759860986"></p><ul><li><p>举例</p><p>​       简而言之，就是给出特征 x = {x1、x2、x3…}(如前面给出两个像素点像素强度x1、x2)，然后经过多层神经网络，输出预测最后的结果分类（一个4维向量）。</p><ul><li><p>给出数据集</p><p>如下图，给出多个图形，每个图形都是一组（x^(i)，y^(i)），其中</p><ul><li>x^(i) ：对应图像输入的特征，为一个n维向量</li><li>y^(i)：对应输出结果，用一个4维向量分别表示 行人、汽车、摩托车、货车。</li></ul><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560760454904.png" alt="1560760454904"></p></li><li><p>训练</p><p>？？？？？？？？下一章节分解。</p></li><li><p>预测结果</p><p>用上面训练好的神经网络来进行预测：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560760079321.png" alt="1560760079321"></p></li></ul></li></ul><h2 id="八-、神经网络的反向传播算法">八 、神经网络的反向传播算法</h2><h3 id="8-1-代价函数">8.1 代价函数</h3><ul><li><p>神经网络中字母记法</p><p><strong>L</strong> : 代表神经网络层数，如下图为 L = 4 ;</p><p><strong>S_l</strong> ：代表第 l 层的单元数，如下图S_L = 4 （最后一层，同时也可记为 <strong>K = 4</strong>）。</p><p>**K：**一般记录为最后一层输出单元数</p><p>**x^(i) 、y^(i) ：**是向量，y^(i)表示第 i个数据集的输出，由于有4个输出单元所以4维。</p><blockquote><p>如 第2个数据集，第一个输出单元是人，y^(i) = (1 0 0 0)T</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560845008473.png" alt="1560845008473"></p></li><li><p>代价函数</p><ul><li><p>Logistic 回归代价函数</p><p>Logistic代价函数 ： <strong>∑m组数据（h(x)预测代价偏差）</strong> * 1/m ，然后正则化。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560845360594.png" alt="1560845360594"></p></li><li><p>神经网络代价函数</p><ul><li><p>代价函数理解</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560846378936.png" alt="1560846378936"></p><p>​     <strong>∑m组数据（K个输出单元h(x)预测代价偏差和）</strong> * 1/m ，然后正则化。</p><p>​     也就是说对于每组数组，最后都有四个输出单元，四个预测结果(车、人、摩托车…)，对实际预测偏差代价求和。然后再对m数据产生的代价求和。</p></li><li><p>正则化项理解</p><p>在神经网络中，控制从第j 层到 第 j+1 层权重θ数是</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>s</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>∗</mo><mtext>（</mtext><msub><mi>s</mi><mi>j</mi></msub><mo>+</mo><mn>1</mn><mtext>）</mtext><mo separator="true">,</mo><mtext>第</mtext><mi>j</mi><mtext>层会补一个</mtext><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_{j+1} * （s_j + 1）,第j层会补一个x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7514em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord cjk_fallback">）</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">第</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">层会补一个</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>不考虑，第j层 basic θ0 ，那么应该是：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>s</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>∗</mo><msub><mi>s</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">s_{j+1} * s_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7514em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>所以<strong>不含输出层</strong>所有网络层的θ（取平方）累加便应该是</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>L</mi><mo>−</mo><mn>1</mn></mrow></munderover><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>s</mi><mn>1</mn></msub></munderover><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><msub><mi>s</mi><mi>l</mi></msub><mo>+</mo><mn>1</mn></mrow></munderover><mo stretchy="false">(</mo><msubsup><mi>θ</mi><mrow><mi>j</mi><mi>i</mi></mrow><mi>l</mi></msubsup><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sum_{l=1}^{L-1}\sum_{i=1}^{s_1}\sum_{j=1}^{s_l+1}(\theta_{ji}^l)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.2421em;vertical-align:-1.4138em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6625em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3111em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.818em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3169em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-2.453em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ji</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p></li></ul></li></ul></li></ul><h3 id="8-2-反向传播算法">8.2 反向传播算法</h3><ul><li><p>梯度下降计算流程</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560847995387.png" alt="1560847995387"></p><p>而现在的关键就是，如何计算<strong>偏导项</strong>，这利用到前向传播 &amp; 反向传播算法。</p></li><li><p>向量化前向传播算法流程</p><p>下图给定一个训练例子(x,y)，进行前向传播得出h(x)预测结果（4输出单元结果）过程</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560848032035.png" alt="1560848032035"></p><p>那么至此，可以计算出各层的激活单元输出值 a^(4)。</p></li><li><p>向量反向传播算法</p><p>根据 <em><strong>前向传播计算出的各单元激活值a^(4)</strong></em> ，可以 <em><strong>进一步计算出反向传播</strong></em>。</p><ul><li><p>计算输出层各激活单元单元激活值（预测值） 和 真实值误差</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560851107592.png" alt="1560851107592"></p><ul><li>$a_j^{(4)} $ 是最后一层单元输出值，也就是预测值；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 是实际的真实值，它们相减便是第4层第j个输出单元误差</li></ul><p>接着，我们可以利用下图公式计算其余各层单元误差（此时误差是向量，代表第L层所有单元误差向量，而不是某个具体单元）</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1569116361150.png" alt="1569116361150"></p><ul><li>不用计算第一层误差，第一层是实际输入</li><li>其中： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><msup><mi>z</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mo>=</mo><msup><mi>a</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>∗</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>a</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g&#x27;(z^{(i)}) = a^{(i)} * (1-a^{(i)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li></ul></li><li><p>流程汇总</p><ul><li><p>给定数据初始化</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560851772870.png" alt="1560851772870"></p><p>其中每个激活单元都有对应误差：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi mathvariant="normal">Δ</mi><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>:</mo><mtext>表示第</mtext><mi>i</mi><mtext>组数据，第</mtext><mi>l</mi><mtext>层，第</mtext><mi>j</mi><mtext>个激活单元</mtext></mrow><annotation encoding="application/x-tex">\Delta_{ij}^{(l)}:表示第i组数据，第l层，第j个激活单元</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4578em;vertical-align:-0.413em;"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.413em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback">表示第</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">组数据，第</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord cjk_fallback">层，第</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">个激活单元</span></span></span></span></span></p></li><li><p>计算所有数据神经网络误差和</p><p>在这个循环中 ：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi mathvariant="normal">Δ</mi><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>:</mo><mtext>第一次循环：是第一次神经网络所有单元误差值；</mtext><mspace linebreak="newline"></mspace><mtext>第二次循：第一次循环误差和</mtext><mo>+</mo><mtext>第二次循环误差和；</mtext><mspace linebreak="newline"></mspace><mtext>以此类推。</mtext></mrow><annotation encoding="application/x-tex">\Delta_{ij}^{(l)}:第一次循环：是第一次神经网络所有单元误差值；\\第二次循：第一次循环误差和 + 第二次循环误差和；\\以此类推。</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4578em;vertical-align:-0.413em;"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.413em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">第一次循环：是第一次神经网络所有单元误差值；</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">第二次循：第一次循环误差和</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">第二次循环误差和；</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">以此类推。</span></span></span></span></span></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560851947555.png" alt="1560851947555"></p><p><strong>上面 j 没有变化？？</strong></p></li><li><p>计算偏导项（跳出上诉循环后）</p><p>注意：第0个激活单元，不用加标准化项</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560852468938.png" alt="1560852468938"></p><p>经过数学证明可以得出，代价函数偏导项如下：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560852408920.png" alt="1560852408920"></p></li></ul></li></ul><h3 id="8-3-理解反向传播">8.3 理解反向传播</h3><ul><li><p>前向传播</p><p>注意如何计算出z，又进一步计算出a</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560865230780.png" alt="1560865230780"></p><ul><li>​</li><li></li></ul></li><li><p>反向传播</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560866390793.png" alt="1560866390793"></p><ul><li>把最大似然函数，当做代价函数？和逻辑回归差不多，勉强可以理解。</li></ul></li><li><p>误差 = 代价函数对 $z_j^{(l)} $ 导数？</p><blockquote><p>演示反向传播如何进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>δ</mi><mn>2</mn><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\delta_2^{(2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3111em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4337em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span></span></span></span> 的计算。</p></blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>δ</mi><mn>2</mn><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\delta_2^{(2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3111em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4337em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span></span></span></span> 根据箭头可知，第三层有两个箭头指向它，需要计算出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>δ</mi><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\delta_1^{(3)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3111em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4337em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">3</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span></span></span></span> 、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>δ</mi><mn>2</mn><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\delta_2^{(3)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3111em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4337em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">3</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span></span></span></span> ，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>δ</mi><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\delta_1^{(3)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3111em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4337em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">3</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span></span></span></span> 、$\delta_2^{(3)} $ 需要先计算第四层误差。</p><ul><li>首先计算出第四层误差：  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>δ</mi><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>−</mo><msubsup><mi>a</mi><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\delta_1^{(4)} = y^{(i)} - a_1^{(4)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3111em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4337em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">4</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.3111em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4337em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">4</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span></span></span></span></li><li>根据<em><strong>前一层单元误差 = 下一层对应单元（有箭头）* 权重</strong></em>   可计算出第三层单元误差：<ul><li>$\delta_1^{(3)} = \theta_{11}^{(3)} \delta_1^{(4)} $   $\delta_2^{(3)} = \theta_{12}^{(3)} \delta_1^{(4)} $</li></ul></li><li>则对应第二层单元误差：  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>δ</mi><mn>2</mn><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><msubsup><mi>θ</mi><mn>12</mn><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msubsup><msubsup><mi>δ</mi><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>+</mo><msubsup><mi>θ</mi><mn>22</mn><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msubsup><msubsup><mi>δ</mi><mn>2</mn><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\delta_2^{(2)} = \theta_{12}^{(2)} \delta_1^{(3)}  + \theta_{22}^{(2)} \delta_2^{(3)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3111em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4337em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3111em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4337em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4337em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">3</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.3111em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4337em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4337em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">3</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span></span></span></span></li></ul><p>但是前面不还是有后面那项吗？？？？</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560866449874.png" alt="1560866449874"></p></li></ul><h3 id="8-4-展开参数">8.4 展开参数</h3><ul><li><p>向量化</p><blockquote><p>θ为什么有三个??</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560945864552.png" alt="1560945864552"></p></li></ul><h3 id="8-5-梯度检测">8.5 梯度检测</h3><h3 id="8-6-随机初始化">8.6 随机初始化</h3><h3 id="8-7-组合">8.7 组合</h3><h3 id="8-8-无人驾驶举例">8.8 无人驾驶举例</h3><h1>九、应用机器学习的建议</h1><h2 id="9-1-评估假设">9.1 评估假设</h2><p>一部分数据（70%）用来训练模型，一部分数据（30%）用来测试验证。而验证通过计算误差方式来衡量数据集是否准确。常用方法有：</p><ol><li><p>计算测试数据集代价函数</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1569833418142.png" alt="1569833418142"></p></li><li><p>统计误差分类</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1569833449365.png" alt="1569833449365"></p></li></ol><h2 id="9-2-模型选择">9.2 模型选择</h2><p>对于一个模型如何选择拟合函数？</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570018553967.png" alt="1570018553967"></p><p>恰当的做法是把一个数据集分为：<em>训练集(60%)、交叉验证集(20%)、测试集(20%)</em>。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570018728270.png" alt="1570018728270"></p><ul><li>:warning: 注意这里定义的都是 <em>误差</em> ，真正的代价函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mi>θ</mi></msub></mrow><annotation encoding="application/x-tex">J_\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是可能会有正则项的！</li></ul><p>具体的训练过程为：</p><ol><li><p>训练模型</p><p>选择不同的模型（预测函数）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><msub><mi>θ</mi><mn>1</mn></msub></msub><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">h_{\theta_1}{(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0001em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><msub><mi>θ</mi><mn>2</mn></msub></msub><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">h_{\theta_2}{(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0001em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span> …<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><msub><mi>θ</mi><mi>i</mi></msub></msub><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">h_{\theta_i}{(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0001em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span>，用 <em>训练集</em> 训练出对应的参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\theta_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\theta_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> …<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\theta_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></li><li><p>选择模型</p><p>利用 <em>交叉验证集</em> 计算不同模型下的误差 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>c</mi><mi>v</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>θ</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">J_{cv}(\theta_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>c</mi><mi>v</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>θ</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">J_{cv}(\theta_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>… <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>c</mi><mi>v</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>θ</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">J_{cv}(\theta_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，选择误差最小对应的模型。</p></li><li><p>验证模型</p><p>最后利用 <em>测试集</em> 来对我们选择的模型进行最终验证。</p></li></ol><h2 id="9-3-诊断偏差和方差">9.3 诊断偏差和方差</h2><p>如何判断我们的模型出现了高偏差或者高方差？</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570020037231.png" alt="1570020037231"></p><ul><li><p>出现高偏差（欠拟合）</p><p>此时训练误差和交叉验证误差都很大（误差都大说明模型不够好）。</p></li><li><p>出现高方差（过拟合）</p><p>训练误差很小，而交叉验证误差很大。说明在新的数据拟合差，只在训练数据集集合好，则属于过拟合情况。</p></li></ul><h2 id="9-4-正则化偏差、方差">9.4 正则化偏差、方差</h2><p>在前我们知道选择模型可能会出现高偏差、方差问题：</p><ul><li>高偏差：接近直线，不能很好拟合数据</li><li>高方差：复杂曲线，多项式过度拟合数据，而没有很好的泛化能力</li></ul><p>因此我们可以通过 <em><strong>正则化参数使得拟合函数在简单直线和复杂曲线中变化</strong></em>，以下图例可以直观说明：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570021762115.png" alt="1570021762115"></p><ul><li>通过改变参数 $ \lambda $ 来修正参数 $\theta_1 、\theta_2 …\theta_n $  —&gt; 修正偏差和高方差。</li></ul><h3 id="9-4-1-如何选择正则参数">9.4.1 如何选择正则参数</h3><p>一般以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>步长</mtext><mo>=</mo><mn>0.02</mn></mrow><annotation encoding="application/x-tex">步长 = 0.02</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">步长</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.02</span></span></span></span> 递增来选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span>  进行炼丹 ：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570022947880.png" alt="1570022947880"></p><ul><li>通过选择合适的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span> ，我们找到使得 <em><strong>交叉验证误差 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>c</mi><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">J_{cv}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 最小的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span></strong></em>（红色曲线最低点）</li></ul><h2 id="9-5-学习曲线">9.5 学习曲线</h2><p>对于一个给定数据集，我们选择模型假设函数对其进行训练。可以通过学习曲线来帮助我们直观选择参数。</p><ul><li><p>出现高偏差</p><p>也就是出现欠拟合，如下图：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570024219626.png" alt="1570024219626"></p><ul><li>此时无论是 训练误差<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>c</mi><mi>v</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">J_{cv}{(\theta)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span>、交叉验证误差 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>i</mi><mi>n</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">J_{train}{(\theta)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">ain</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span> 都很大，这是由于我们选择的模型不当。</li><li>出现高偏差无论 <em>用再多的数据集也无法降低误差</em> 。</li></ul></li></ul><p>因此我们需要选择更复杂的多项式函数模型来拟合。</p><ul><li><p>出现高方差</p><p>这是因此选择的模型过于复杂出现欠拟合。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570024536058.png" alt="1570024536058"></p><ul><li>此时 训练误差<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>c</mi><mi>v</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">J_{cv}{(\theta)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span> 较小、交叉验证误差 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>i</mi><mi>n</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">J_{train}{(\theta)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">ain</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span> 较大。<em>但是可以通过增加数据集来减少<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>i</mi><mi>n</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">J_{train}{(\theta)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">ain</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span> 。</em></li></ul></li></ul><h2 id="9-6-总结：算法效果不好？">9.6 总结：算法效果不好？</h2><p>如果我们通过一个模型如下，进行训练：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570025122045.png" alt="1570025122045"></p><p>首先通过画出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>c</mi><mi>v</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">J_{cv}{(\theta)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span> 、 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>i</mi><mi>n</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">J_{train}{(\theta)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">ain</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span> 图像，来判断我们的算法出现什么问题。</p><blockquote><p>:dart: 我们最终目标都是使<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>i</mi><mi>n</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">J_{train}{(\theta)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">ain</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span> 误差最小。</p></blockquote><ul><li>出现高偏差<ul><li>增加更多特征：如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>3</mn></msub><mtext>、</mtext><msub><mi>x</mi><mn>4</mn></msub><mtext> </mtext><mi>e</mi><mi>t</mi><mi>c</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">x_3、x_4 \ etc.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mord">.</span></span></span></span></li><li>增加多项特征：如 $x_1^2、x_2^2、x_1x_2 $</li><li>减少正则化参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span> ：使得拟合函数更加复杂</li></ul></li><li>出现高方差<ul><li>获取更多数据：更多数据可以有效降低误差 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>i</mi><mi>n</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">J_{train}{(\theta)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">ain</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span></li><li>减少更多特征：可避免过拟合</li><li>增加正则化参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span> ：可降低 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> ，使得拟合曲线简单一点。</li></ul></li></ul><h3 id="9-6-1-关于神经网络">9.6.1 关于神经网络</h3><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570025893299.png" alt="1570025893299"></p><ul><li><p><em>choose</em>：小与大？</p><p>小型神经网络一般不容易出现过拟合，大型神经网络容易出现过拟合，但可以使用正则化参数来解决。</p><p>所以一般可以选择大神经网络更好。</p></li><li><p><em>choose</em>：隐藏层个数？</p><p>一般选择 <strong>1</strong> 个是比较合理的选项。</p><p>也可尝试多个，这样就需要根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>c</mi><mi>v</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">J_{cv}{(\theta)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span> 、 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>i</mi><mi>n</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">J_{train}{(\theta)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">ain</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span> 等误差来判断，多少隐藏层个数是最好的选择。</p></li></ul><h1>十、机器学习系统设计</h1><h2 id="10-1-误差分析">10.1 误差分析</h2><h3 id="10-1-1-建议措施">10.1.1 建议措施</h3><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570362582512.png" alt="1570362582512"></p><blockquote><p>以下是一个邮件分类具体实例提高机器学习分类正确率。</p></blockquote><p>先有一个邮件分类系统，它对500个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">CV</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 验证集进行了 100 次 错误分类。我们人工检查这100个错误：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570362845686.png" alt="1570362845686"></p><p>我们人工分类这是什么类型邮件，然后检查是什么原因（特征）导致分类错误:<br><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570362931817.png" alt="1570362931817"></p><ul><li><p>类型：这 100封错误分类邮件，有四种类型</p></li><li><p>分类错误原因：邮件故意拼写错误、不寻常的邮件路径等</p></li></ul><blockquote><p>使用数值分析，来决定是否做某些优化。</p></blockquote><p>比如，下面是否应该将 <em>discount / discounted / discounting</em> 等视作为一个单词？</p><p>又如，是否应该忽略首字母大小写，<em>mom / Mom</em> 视作一个单词？</p><p>我们应该尝试去进行优化前后 <em>数值分析错误率对比</em>，如果优化后分类错误更低那么就进行优化，反之则取消。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570363662628.png" alt="1570363662628"></p><h2 id="10-2-不对称性分类的误差评估">10.2 不对称性分类的误差评估</h2><p>假设我们预测：癌症（y=1）,非癌症（y≠1）。我们可以画出类似下面的四方格子：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570364887962.png" alt="1570364887962"></p><p>我们由此可以得出两个评估模型的数字概率：</p><ul><li>查准率 ： 在这个模型中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>查准率</mtext><mo>=</mo><mfrac><mrow><mtext>预测正确为癌症数</mtext><mo stretchy="false">(</mo><mi>y</mi><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mrow><mtext>所有预测为癌症数</mtext><mo stretchy="false">(</mo><mi>y</mi><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">查准率 = \frac{预测正确为癌症数(y=1)}{所有预测为癌症数(y=1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">查准率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">所有预测为癌症数</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">=</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">预测正确为癌症数</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">=</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>召回率： 在这个模型中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>召回率</mtext><mo>=</mo><mfrac><mrow><mtext>预测正确为癌症数</mtext><mo stretchy="false">(</mo><mi>y</mi><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mrow><mtext>实际为癌症数</mtext><mo stretchy="false">(</mo><mi>y</mi><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">召回率 = \frac{预测正确为癌症数(y=1)}{实际为癌症数(y=1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">召回率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">实际为癌症数</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">=</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">预测正确为癌症数</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">=</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul><p>查准率高说明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mtext>  </mtext><mi>p</mi><mi>o</mi><mi>s</mi><mtext> 低</mtext></mrow><annotation encoding="application/x-tex">False \  \ pos \ 低</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord mathnormal">p</span><span class="mord mathnormal">os</span><span class="mspace"> </span><span class="mord cjk_fallback">低</span></span></span></span> (错误预测为癌症数低) ；召回率高说明<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mtext>  </mtext><mi>n</mi><mi>e</mi><mi>g</mi><mtext> 低</mtext></mrow><annotation encoding="application/x-tex">False \  \ neg \ 低</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord cjk_fallback">低</span></span></span></span> （错误预测为非癌症数低）</p><h2 id="10-3-精确度和召回率的权衡">10.3 精确度和召回率的权衡</h2><p>依旧以之前那个预测癌症为例。我们知道预测函数 $ 0 ≤ h_\theta{(x)} ≤ 1$ ，且通常我们当 $h_\theta{(x)}  &gt; 0.5 $，预测 y =1，即是癌症。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570366203950.png" alt="1570366203950"></p><blockquote><p>提高查准率：谨慎告诉病人得了癌症。</p></blockquote><p>告诉病人得了癌症是一件需要谨慎判断的事情，所以我们可以通过提高 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">threshold</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">res</span><span class="mord mathnormal">h</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span></span></span></span> ，比如 $h_\theta{(x)}  &gt; 0.99 $ 时才判断为1告诉病人得了癌症。</p><p>但是这样做会导致：查准率(正确预测为癌症数提高)得到提高，而召回率下降？(判断正确为癌症数下降)。</p><blockquote><p>提高召回率：需要有可能患癌症病人及时得到治疗。</p></blockquote><p>同上，此时只要降低  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">threshold</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">res</span><span class="mord mathnormal">h</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span></span></span></span> ，比如 $h_\theta{(x)}  &gt; 0.01 $  即判断病人或有癌症。</p><p>同样的，这样做会导致：查准率降低，而召回率提高？(判断正确为癌症数上升，实际为癌症数不变)。</p><h3 id="10-3-1-如何综合评价算法查准率-召回率？">10.3.1 如何综合评价算法查准率/召回率？</h3><p>对于下面三个不同算法，有三个不同查准率/召回率，选择哪个算法？</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570367562135.png" alt="1570367562135"></p><p>如果不是希望：查准率/召回率 某个值更高，我们可以综合评价算法。但是，取平均值不是一个好的做法。我们采用一种叫做 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mtext> </mtext><mi>S</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">F\ Score</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">core</span></span></span></span> 综合评价算法。</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mtext> </mtext><mi>S</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">F\ Score</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">core</span></span></span></span> 越大则算法越好，比如极端情况：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>召回率</mtext><mo>=</mo><mtext>查准率</mtext><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">召回率=查准率 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">召回率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">查准率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mtext> </mtext><mi>S</mi><mi>c</mi><mi>o</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F\ Score_{max} = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.02778em;">cor</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li></ul><h2 id="10-4-机器学习数据">10.4 机器学习数据</h2><blockquote><p>最成功的的不是那些拥有最好的算法的人，而是那些拥有最多数据的。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570368446802.png" alt="1570368446802"></p><ul><li>降低偏差：使用带有众多参数的算法来降低偏差，比如拥有复杂隐藏层的神经网络。</li><li>降低方差：使用大数据集来降低方差，使得测试集误差也会相应很小。</li></ul><p><em>二者结合，机器学习，千秋万代，一统江湖。</em></p><h1>十一、支持向量机(SVM)</h1><h2 id="11-1-优化目标">11.1 优化目标</h2><p>我们对此前的 <em>logistic</em> 回归代价进行一些修改。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570419644543.png" alt="1570419644543"></p><ul><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mtext>时，代价函数</mtext><mo>=</mo><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo stretchy="false">(</mo><mo>−</mo><msup><mi>θ</mi><mi>T</mi></msup><mi>x</mi><mo stretchy="false">)</mo></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">y_i = 1 时，代价函数 = - log\frac{1}{1+e^{(-\theta^Tx)}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">时，代价函数</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4025em;vertical-align:-0.5574em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.5009em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9844em;"><span style="top:-2.9844em;margin-right:0.0714em;"><span class="pstrut" style="height:2.6981em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9773em;"><span style="top:-2.9773em;margin-right:0.1em;"><span class="pstrut" style="height:2.6833em;"></span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5574em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> ：如左图，我们想要此时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><msup><mi>θ</mi><mi>T</mi></msup><mi>x</mi><mo>&gt;</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">z = \theta^Tx &gt;&gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8804em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> ，如果满足则代价越小，不满足则代价则越大。</p><p>而支持向量机代价函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">cost_1(z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">cos</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> 则是一条折线，逼近于原本代价函数：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>&gt;</mo><mn>1</mn><mtext>时</mtext></mrow><annotation encoding="application/x-tex">z &gt;1 时</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">时</span></span></span></span>：此时代价为0，换言之 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>&gt;</mo><mn>1</mn><mo>−</mo><mo>&gt;</mo><msub><mi>h</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext>始终</mtext><mo>=</mo><mn>1</mn><mo>−</mo><mo>&gt;</mo><mtext>代价函数</mtext><mo>=</mo><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo stretchy="false">(</mo><mo>−</mo><msup><mi>θ</mi><mi>T</mi></msup><mi>x</mi><mo stretchy="false">)</mo></mrow></msup></mrow></mfrac><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">z &gt;1 -&gt; h_\theta (x) 始终= 1 -&gt; 代价函数 = - log\frac{1}{1+e^{(-\theta^Tx)}} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord cjk_fallback">始终</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">代价函数</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4025em;vertical-align:-0.5574em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.5009em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9844em;"><span style="top:-2.9844em;margin-right:0.0714em;"><span class="pstrut" style="height:2.6981em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9773em;"><span style="top:-2.9773em;margin-right:0.1em;"><span class="pstrut" style="height:2.6833em;"></span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5574em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></strong></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">z &lt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 时：此时代价函数近似原本 <em>logistics</em> 回归代价函数</li></ul></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mo>−</mo><mn>1</mn><mtext>时，代价函数</mtext><mo>=</mo><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo stretchy="false">(</mo><mo>−</mo><msup><mi>θ</mi><mi>T</mi></msup><mi>x</mi><mo stretchy="false">)</mo></mrow></msup></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y_i = -1 时，代价函数 = - log(1-\frac{1}{1+e^{(-\theta^Tx)}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord cjk_fallback">时，代价函数</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.4025em;vertical-align:-0.5574em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.5009em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9844em;"><span style="top:-2.9844em;margin-right:0.0714em;"><span class="pstrut" style="height:2.6981em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9773em;"><span style="top:-2.9773em;margin-right:0.1em;"><span class="pstrut" style="height:2.6833em;"></span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5574em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>  ：如右图，其余类似上，不再赘述。</p></li></ul><p>因此我们可以得到最终支持向量机的代价函数：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570421089409.png" alt="1570421089409"></p><ul><li><em>SVM</em> 代价函数是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>A</mi><mo>+</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">CA+B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 形式，而不是 <em>logistics</em> 代价函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>+</mo><mi>λ</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">A + \lambda B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 形式。这是因为我们更关注与第一项<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 的优化而不是第二项。</li><li>假设函数是否有误？ 应该是 $ \theta^Tx ≥ 1 ，h_\theta(x) = 1 ; \theta^Tx ≤ -1 ，h_\theta(x) = 0$  ？？</li></ul><h2 id="11-2-直观上对大间隔的理解">11.2 直观上对大间隔的理解</h2><p>再次回顾下此前支持向量机代价函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>S</mi><mi>V</mi><mi>M</mi></mrow></msub></mrow><annotation encoding="application/x-tex">J_{SVM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570434255658.png" alt="1570434255658"></p><h3 id="11-2-1-SVM：线性最大分隔">11.2.1 SVM：线性最大分隔</h3><p>对于一个样本我们有多种进行分隔直线进行分类，就像下面这种：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570434421574.png" alt="1570434421574"></p><ul><li>显然，黑色直线具有直观上最好的分类效果，因为它离正负样本都拥有 <em>最大间距</em> 。</li></ul><blockquote><p>进一步直观理解 SVM 中正则化系数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 的作用：防止过拟合。</p></blockquote><p>下面这张图展示不同情况下 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 可能导致的情况。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570434907452.png" alt="1570434907452"></p><ul><li><p><em>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 过大</em> 时：此时分隔直线是上面红色直线，显然它发生了过拟合。类似于 <em>logistics</em> 回归 <em><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span> 过小</em> 时，导致过拟合情况。</p></li><li><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 不是很大时：此时分隔直线显然具有更好的泛化能力，不会发生过拟合。</p></li></ul><h2 id="11-3-大间隔分类数学原理">11.3 大间隔分类数学原理</h2><blockquote><p>引子：对于两个向量 $ u = \begin{bmatrix} u_1\u_2 \end{bmatrix}$ 与  $  v= \begin{bmatrix} v_1\v_2 \end{bmatrix}$ ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>u</mi><mi>T</mi></msup><mi>v</mi></mrow><annotation encoding="application/x-tex">u^Tv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 的几何意义怎么理解？</p></blockquote><p>直接给结论：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>u</mi><mi>T</mi></msup><mi>v</mi></mrow><annotation encoding="application/x-tex">u^Tv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mn>1</mn></msub><msub><mi>v</mi><mn>1</mn></msub><mo>+</mo><msub><mi>u</mi><mn>2</mn></msub><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">u_1v_1 + u_2v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo separator="true">⋅</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>u</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">P·||u||</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣∣</span><span class="mord mathnormal">u</span><span class="mord">∣∣</span></span></span></span>  = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mtext>在</mtext><mi>u</mi><mtext>上的投影距离</mtext><mo>∗</mo><mi>u</mi><mtext>的长度</mtext></mrow><annotation encoding="application/x-tex">v 在u上的投影距离*u的长度</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord cjk_fallback">在</span><span class="mord mathnormal">u</span><span class="mord cjk_fallback">上的投影距离</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">u</span><span class="mord cjk_fallback">的长度</span></span></span></span></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570435992694.png" alt="1570435992694"></p><ul><li>注意：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 是有方向的，而范数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>u</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">||u||</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣∣</span><span class="mord mathnormal">u</span><span class="mord">∣∣</span></span></span></span> 是没有方向只有距离。</li></ul><h3 id="11-3-1-数学分析">11.3.1 数学分析</h3><blockquote><p>:dart: 我们的目标是最小代价函数。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570434255658.png" alt="1570434255658"></p><p>根据上面公式可知，等价为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mtext> </mtext><mfrac><mn>1</mn><mn>2</mn></mfrac><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msubsup><mi>θ</mi><mi>j</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">min \ \frac{1}{2} \sum_{j=1}^{n}\theta_j^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2809em;vertical-align:-0.4358em;"></span><span class="mord mathnormal">min</span><span class="mspace"> </span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4413em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span></span></span></span> （因为第一项可控？）：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570438776684.png" alt="1570438776684"></p><p>在根据 $ 引子数学公式$ 我们可以进一步表达如下：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570438863956.png" alt="1570438863956"></p><blockquote><p>直观观测SVM如何确定最大间隔。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570439158424.png" alt="1570439158424"></p><ul><li>绿色直线为决策直线 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msup><mi>θ</mi><mi>T</mi></msup><mi>x</mi></mrow><annotation encoding="application/x-tex">y = \theta^Tx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal">x</span></span></span></span>，蓝色直线为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 向量，<em>且它们互相垂直 ?</em></li><li>令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\theta_0 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 可以保证决策直线一定经过原点。</li></ul><p><em>图1：为什么SVM可以决策直线不好？</em></p><p>我们要使得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mtext> </mtext><mfrac><mn>1</mn><mn>2</mn></mfrac><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msubsup><mi>θ</mi><mi>j</mi><mn>2</mn></msubsup><mo>=</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">min \ \frac{1}{2} \sum_{j=1}^{n}\theta_j^2 == min|| \theta||^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2809em;vertical-align:-0.4358em;"></span><span class="mord mathnormal">min</span><span class="mspace"> </span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4413em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mord">∣∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>  ，同时还要满足条件：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msup><mi>p</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo separator="true">⋅</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo>≥</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>，正样本</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msup><mi>p</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo separator="true">⋅</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>，负样本</mtext></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}p^{(i)}·||\theta|| ≥1 &amp;，正样本\\p^{(i)}·||\theta|| ≤-1 &amp;，负样本\\\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">，正样本</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">，负样本</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>可以看到恰好使得等式成立的支持向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mtext>、</mtext><msup><mi>x</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">x^{(1)}、x^{(2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> 在向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 上的投影<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mtext>、</mtext><msup><mi>p</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">p^{(1)}、p^{(2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> 都很小。</p><p>而我们又要满足上述条件，那么自然 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">||\theta||</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣∣</span></span></span></span> 就要很大，这与我们的目标不符合，所以可判断决策直线不好。</p><p><em>图2：为什么SVM可以决策直线好？</em></p><p>同上，此时支持向量在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 向量上的投影 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mtext>、</mtext><msup><mi>p</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">p^{(1)}、p^{(2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> 最大 —&gt; 那么  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mi mathvariant="normal">∣</mi><msub><mi mathvariant="normal">∣</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">||\theta||_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>  。</p><h2 id="11-4-核函数">11.4 核函数</h2><h3 id="11-4-1-核函数（上）">11.4.1 核函数（上）</h3><blockquote><p>如何进行复杂非线性分类？</p></blockquote><p>在此前我们进行复杂非线性分类，是增加更多特征 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mtext>、</mtext><msubsup><mi>x</mi><mn>1</mn><mn>2</mn></msubsup><mtext>、</mtext><msubsup><mi>x</mi><mn>2</mn><mn>2</mn></msubsup><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">x_1x_2、x_1^2、x_2^2...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0622em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mord">...</span></span></span></span> 进行非线性分类：<br><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570450315745.png" alt="1570450315745"></p><ul><li>决策边界是： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>θ</mi><mi>T</mi></msup><mi>X</mi><mo>=</mo><msub><mi>θ</mi><mn>0</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>3</mn></msub><msub><mi>x</mi><mn>1</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\theta^TX = \theta_0+\theta_1x_1 +\theta_2x_2+\theta_3x_1x_2...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span></span></span></span> ，预测函数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><msup><mi>θ</mi><mi>T</mi></msup><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(\theta^Tx)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 。</li></ul><p>而现在我们可以利用相似度函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>  来产生更多特征，将上面特征 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mtext>、</mtext><msub><mi>x</mi><mn>2</mn></msub><mtext>、</mtext><msub><mi>x</mi><mn>1</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mtext>、</mtext><msubsup><mi>x</mi><mn>1</mn><mn>2</mn></msubsup><mtext>、</mtext><msubsup><mi>x</mi><mn>2</mn><mn>2</mn></msubsup><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">x_1、x_2、x_1x_2、x_1^2、x_2^2...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0622em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mord">...</span></span></span></span> 替换为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mtext>、</mtext><msub><mi>f</mi><mn>2</mn></msub><mtext>、</mtext><msub><mi>f</mi><mn>3</mn></msub><mtext>、</mtext><msub><mi>f</mi><mn>4</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">f_1、f_2、f_3、f_4..</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">..</span></span></span></span> 。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>θ</mi><mi>T</mi></msup><mi>f</mi><mo>=</mo><msub><mi>θ</mi><mn>0</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>1</mn></msub><msub><mi>f</mi><mn>1</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>2</mn></msub><msub><mi>f</mi><mn>2</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>3</mn></msub><msub><mi>f</mi><mn>3</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mspace linebreak="newline"></mspace><mtext>其中：</mtext><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mi>s</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo>−</mo><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta^Tf = \theta_0+\theta_1f_1 +\theta_2f_2+\theta_3f_3...\\其中： f_i = similarity(x,l^{(i)}) = exp(-\frac{||x-l^{(i)}||^2}{2\sigma^2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0858em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback">其中：</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">imi</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.251em;vertical-align:-0.686em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.565em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣∣</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">l^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> 即标记。</li></ul><blockquote><p>进一步理解相似度函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mtext>、</mtext><mi>σ</mi></mrow><annotation encoding="application/x-tex">l^{(i)} 、\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> 作用。</p></blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">l^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> 会标记对应产生的不同特征 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mtext>、</mtext><msub><mi>f</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">f_1、f_2 ...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span></span></span></span> ，它可用来描述和特征 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的偏离：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570451665002.png" alt="1570451665002"></p><ul><li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mtext>接近</mtext><mi>x</mi></mrow><annotation encoding="application/x-tex">l^{(i)} 接近 x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">接近</span><span class="mord mathnormal">x</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 输出为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ， 当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mtext>远离</mtext><mi>x</mi></mrow><annotation encoding="application/x-tex">l^{(i)} 远离 x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">远离</span><span class="mord mathnormal">x</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 输出为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>  。</li></ul><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> 可用来控制当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mtext>远离</mtext><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">x 远离 l^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord mathnormal">x</span><span class="mord cjk_fallback">远离</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> 时，函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 趋于0下降的速率。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570451965284.png" alt="1570451965284"></p><ul><li>初始 $ l^{(1)} = \begin{bmatrix} 3\ 5 \end{bmatrix}$</li><li>当 $ x = \begin{bmatrix} 3\ 5 \end{bmatrix}$ ，此时函数值 = 1 (顶峰处)。如果  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> 较大，可以看出当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mtext>偏离</mtext><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">x 偏离 l^{(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord mathnormal">x</span><span class="mord cjk_fallback">偏离</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> 越多，则此时函数值趋于0会相比较其它图更快。</li></ul><p>一张图进行总结如下：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570455251297.png" alt="1570455251297"></p><blockquote><p>一个实际计算实例。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570452725437.png" alt="1570452725437"></p><h3 id="11-4-1-核函数（下）">11.4.1 核函数（下）</h3><blockquote><p>如何获取标记 $ l^{(1)}、l^{(2)}、l^{(3)}…$ ？</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570455554968.png" alt="1570455554968"></p><ul><li><p>初始选择  $ l^{(1)} =  x^{(1)}、l^{(2)} =  x^{(2)}、l^{(3)} =  x^{(3)}…$ ？然后怎么更新 $ l^{(i)}$ ?</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>θ</mi><mi>T</mi></msup><mi>f</mi><mo>=</mo><msub><mi>θ</mi><mn>0</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>1</mn></msub><msub><mi>f</mi><mn>1</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>2</mn></msub><msub><mi>f</mi><mn>2</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>3</mn></msub><msub><mi>f</mi><mn>3</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>θ</mi><mi>m</mi></msub><msub><mi>f</mi><mi>m</mi></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mspace linebreak="newline"></mspace><mtext>其中：</mtext><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mi>s</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo>−</mo><msup><mi>x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta^Tf = \theta_0+\theta_1f_1 +\theta_2f_2+\theta_3f_3...+\theta_mf_m...\\其中： f_i = similarity(x,l^{(i)}) = exp(-\frac{||x-x^{(i)}||^2}{2\sigma^2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0858em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback">其中：</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">imi</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.251em;vertical-align:-0.686em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.565em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣∣</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p><ul><li>有多个样本就有多个核函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>？</li></ul></li></ul><blockquote><p>核函数版代价函数。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570456335984.png" alt="1570456335984"></p><h2 id="11-5-使用SVM">11.5 使用SVM</h2><blockquote><p>我们可以使用成熟的库来实现SVM算法的应用。</p></blockquote><p>那么，大量细节实现被隐藏了，我们仅需要选择参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>核函数</mtext><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">核函数f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback">核函数</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570456784444.png" alt="1570456784444"></p><ul><li>线性核函数，实际没有应用到核函数，但我们保持这么一个称呼以便统一。</li></ul><h3 id="11-5-1-多分类">11.5.1 多分类</h3><p>依旧是一对多，分类<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>个类别，训练 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 个线性 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>V</mi><mi>M</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">SVMs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">s</span></span></span></span> 。</p><p>给定一组特征<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X,Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span> ，K组训练权重<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><msup><mi>θ</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mi>T</mi></msup><mi>X</mi></mrow><annotation encoding="application/x-tex">{\theta^{(i)}}^TX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1192em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1192em;"><span style="top:-3.3409em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>对应概率最大则分类为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1570457473219.png" alt="1570457473219"></p><h3 id="11-5-3-logistics-回归-SVM">11.5.3 <em>logistics</em> 回归 &amp; <em>SVM</em></h3><blockquote><p>以下列举了对于特征 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 与样本数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 不同情况下，如何选择 <em>logistics</em> 回归 OR <em>SVM</em> 进行分类。</p></blockquote><h2 id="十二、无监督学习">十二、无监督学习</h2><h2 id="12-1-K-means-算法">12.1 K-means 算法</h2>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吴恩达 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔记</title>
      <link href="/2021/11/25/JAVA%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/25/JAVA%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>第一章：初识<em>java</em></h1><h2 id="1-0-快捷键">1.0 快捷键</h2><ul><li><code>Alt</code> + <code>\</code> : 查看本来所有方法，变量</li><li><code> Ctrl</code>+<code>Alt</code> ： 跳出虚拟机</li></ul><h2 id="1-1-JDK安装与配置">1.1 JDK安装与配置</h2><ol><li><p>JDK下载</p><p>下载地址：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk12-downloads-5295953.html">官网JDK下载</a></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561340917555.png" alt="1561340917555"></p><p>下载完毕后：</p><ul><li>下载是<code>exe</code>文件，<strong>安装</strong> 到 <code>D:/JDK</code> 文件夹下（没有自己新建JDK文件夹）</li><li>下载是压缩包，**解压 **到相应 <code>D:/JDK</code> 文件夹下即可。</li></ul></li><li><p>配置环境变量（win10）</p><p>首先打开 系统属性—&gt;高级----&gt;环境变量：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561341247893.png" alt="1561341247893"></p><p>如上图所示，新建一个系统变量JAVA_HOME:</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561341341032.png" alt="1561341341032"></p><p>接着选择编辑PATH变量：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561341548289.png" alt="1561341548289"></p><p>选择新建一个<code>%JAVA_HOME%\bin</code> ，并移动到最上方：</p><blockquote><p><em>%JAVA_HOME%</em> : 表示引入的 前一个 系统变量 <em>JAVA_HOME</em> 路径</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561341636843.png" alt="1561341636843"></p><p>记得依次点击确定保存，关闭环境变量设置。</p></li><li><p>验证是否成功</p><p><code>win + r ---&gt; cmd ----&gt; java -version</code> 查看，显示版本号则按照成功：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561341770850.png" alt="1561341770850"></p></li></ol><h2 id="1-2-IDE-intelliJ-IDEA">1.2 IDE : intelliJ IDEA</h2><ol><li><p>下载 &amp; 安装</p><p>官网地址：<a href="https://www.jetbrains.com/idea/download/#section=windows">官网下载IDEA</a></p><p>傻瓜似安装，注意安装过程选择64位。</p></li><li><p>注册激活</p><p>第一次打开IDEA时会要求你注册激活，选择输入激活代码，博客激活码地址：</p><p><a href="https://blog.csdn.net/zixiao217/article/details/82942476">激活地址，第二个可用</a></p></li></ol><h2 id="1-3-第一个项目-HELLOJAVA">1.3 第一个项目:HELLOJAVA</h2><ol><li><p>创建项目</p><p>选择 File–&gt;New–&gt;Project ,SDK 选择 安装 JDK 所在目录（同上）：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561346657818.png" alt="1561346657818"></p><p>下一步选择 <em>Project</em> 所在文件夹：</p><p>:warning: 先创建一个文件夹用来保存项目，该步<strong>不会自动创建一个<em>Projiect</em>对应文件夹</strong>！</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561348405542.png" alt="1561348405542"></p></li><li><p>第一个 <em>JAVA</em> 文件</p><p>为了方便管理，可以先创建一个 <em>Package</em>（类似 <em>C#</em> 命令空间）。</p><p>右键选择 <code>src---&gt; new ---&gt; package</code> ，比如新建 <em>package</em> 名为：<em>HELLOJAVA</em>；</p><p>右键选中 <em>HELLOJAVA</em> 包，<code>HELLOJAVA--&gt; new --&gt; class</code> ，新建类名为 <code>hello</code>：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561347064145.png" alt="1561347064145"></p></li><li><p>编辑<code>hello.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span>   //选择创建<span class="title">class</span>，会自动创建同名类名</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="comment">//里面参数不能少</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello JAVA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置</p><p>这个时候直接运行是运行不了的，还要设置一些东西，点击下图按钮添加配置信息：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561349225085.png" alt="1561349225085"></p><p>选择模板 &amp; 主函数位置：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561349369104.png" alt="1561349369104"></p></li><li><p>运行</p><p>选择 <code>hello.java</code>文件，右键选择 <code>run “hello.main()”</code> 即可。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561349534573.png" alt="1561349534573"></p></li></ol><h1>第二章 ：JAVA基本知识</h1><h2 id="2-1-面对对象">2.1 面对对象</h2><h3 id="实战">实战</h3><p>设计一个<em>Hero</em> 类对象VN，有一些属性；有加血函数等。</p><ul><li><p>在<code>Hero</code>类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//设计一些属性</span></span><br><span class="line">    String name; <span class="comment">//String 第一个S是大写</span></span><br><span class="line">    <span class="keyword">int</span> HP;</span><br><span class="line">    <span class="keyword">int</span> moveSpeed;</span><br><span class="line">    <span class="comment">//函数：加血</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addHP</span><span class="params">(<span class="keyword">int</span> blood)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HP += blood;</span><br><span class="line">        System.out.println(<span class="string">&quot;加血!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>Hello</code>类中</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello JAVA&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用item类，实例出一个对象</span></span><br><span class="line">        Hero i = <span class="keyword">new</span> Hero();</span><br><span class="line">        i.name = <span class="string">&quot;vn&quot;</span>;</span><br><span class="line">        i.HP = <span class="number">2000</span>;</span><br><span class="line">        i.addHP(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 输出结果：</span></span><br><span class="line"><span class="comment"> Hello JAVA</span></span><br><span class="line"><span class="comment"> 加血!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p><em>java</em> 面对对象和 <em>C#</em> 目前有以下区别：</p><ul><li><em>java</em> 每次 <em>new --&gt; class</em> ，在这个新类中只能写一个类，有多个类会报错</li><li><code>System.out.println</code> 还不太熟，官方文档语焉不详的，待摸索怎么读官方文档。</li></ul><h2 id="2-2-变量">2.2 变量</h2><h3 id="变量类型">变量类型</h3><ol><li><p>整型 <em>int</em>（4种）</p><table><thead><tr><th style="text-align:center">类型</th><th>缺省值</th><th>长度</th><th>范围</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td>0</td><td>8</td><td>-128 ~ 127</td></tr><tr><td style="text-align:center">short</td><td>0</td><td>16</td><td>-32768 ~ 32767</td></tr><tr><td style="text-align:center">int</td><td>0</td><td>32</td><td>-2147483648 ~ 2147483647</td></tr><tr><td style="text-align:center">long</td><td>0</td><td>65</td><td>-9223372036854775808  ~ 9223372036854775807</td></tr></tbody></table><ul><li><p>即使声明 <em>long</em> 类型，也要以 L或者l结尾，否则是int类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> val = <span class="number">1234567890</span>;  <span class="comment">// 报错，被当成int类型超出范围</span></span><br><span class="line"><span class="keyword">long</span> val = <span class="number">1234567890L</span>;   <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li><p><em>int</em> 类型 也可以表示 4种进制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> decVal = <span class="number">26</span>;       <span class="comment">//默认int型</span></span><br><span class="line"><span class="keyword">int</span> hexVal = <span class="number">0x1a</span>;     <span class="comment">//16进制</span></span><br><span class="line"><span class="keyword">int</span> oxVal = <span class="number">032</span>;       <span class="comment">//8进制</span></span><br><span class="line"><span class="keyword">int</span> binVal = <span class="number">0b11010</span>;  <span class="comment">//2进制</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>字符型 <em>char</em></p><p>可以用<em>char</em> 类型表示一些转义字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下是转义字符</span></span><br><span class="line"><span class="keyword">char</span> tab = <span class="string">&#x27;\t&#x27;</span>;               <span class="comment">// 制表符</span></span><br><span class="line"><span class="keyword">char</span> carriageReturn = <span class="string">&#x27;\r&#x27;</span>;    <span class="comment">// 回车</span></span><br><span class="line"><span class="keyword">char</span> newLine = <span class="string">&#x27;\n&#x27;</span>;           <span class="comment">// 换行</span></span><br><span class="line"><span class="keyword">char</span> doubleQuote = <span class="string">&#x27;\&quot;&#x27;</span>;       <span class="comment">// 双引号</span></span><br><span class="line"><span class="keyword">char</span> singleQuote = <span class="string">&#x27;\&#x27;&#x27;</span>;       <span class="comment">// 单引号</span></span><br><span class="line"><span class="keyword">char</span> backslash = <span class="string">&#x27;\\&#x27;</span>;         <span class="comment">// 反斜杠</span></span><br></pre></td></tr></table></figure></li><li><p>浮点型 <em>float、double</em></p><p><em>float</em> 类型表示浮点数（整数时不报错）时要加f ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">123.456</span>;    <span class="comment">//报错，一定要加f</span></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">123.456f</span>;   <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p><em>double</em> 类型表示浮点数不用加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">123.456</span>;   <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">double</span> d1 = <span class="number">1.23456e2</span> <span class="comment">// 科学技术法 = 1.23456 * 10^2</span></span><br></pre></td></tr></table></figure><p><u><em>2020-12-30 总结：</em></u> 在java中，long、float（double不用）类型，变量值还要+前/后缀对应，才能正确定义。</p></li><li><p>布尔型 <em>boolean</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></li><li><p>字符串 <em>String</em></p><blockquote><p><em>String</em> 类型其实<strong>并不是基本类型</strong> , 而是 <em>lmmutable</em> 类型 ；而且一旦创建不能别改变。</p></blockquote><p>这里一旦创建不能被改变，不能改变<strong>内容</strong>但是可以改变<strong>引用</strong>指向，比如下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str = <span class="string">&quot;hello world&quot;</span>;  <span class="comment">//改变成功，改变了引用</span></span><br></pre></td></tr></table></figure><p>实际上又成功改变了，因为改变了<em>str</em> 原来指向“<em>hello</em>”  —&gt; 转为指向 “<em>hello world</em>”</p></li></ol><h3 id="类型转换">类型转换</h3><ul><li><p>低精度向高精度转换</p><p>这种转换是不需要强制转换的，默认转换就可以。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561429988665.png" alt="1561429988665"></p></li><li><p>高精度向低精度转换</p><p>和以前学的无太大区别，注意以下几点：</p><ul><li><p><em>short &amp; char</em> 转换</p><p>虽然二者位数相同但是还是要强制转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">80</span>;</span><br><span class="line">c = (<span class="keyword">char</span>) s;  <span class="comment">// 强制转换</span></span><br></pre></td></tr></table></figure></li><li><p><em>int</em> 以下数据相加</p><p>在 java 世界里，如果<code>精度 &lt; int</code> 进行 数值运算会被自动提升到int类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> b = <span class="number">2</span>;</span><br><span class="line">System.out.println(getType(a+b)); <span class="comment">// int类型</span></span><br></pre></td></tr></table></figure><p>也就是说下面必须要强制转换 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> c = (<span class="keyword">short</span>)(a + b);  <span class="comment">// ※ ※ ※ 注意理解 ※ ※ ※</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="变量修饰-final">变量修饰 <em>final</em></h3><p>当一个变量被 <em>final</em> 修饰的时候，该变量<strong>只有一次赋值的机会</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i = <span class="number">5</span>  <span class="comment">// 出错，i已经被赋值过来</span></span><br></pre></td></tr></table></figure><p>特别的注意，当 <em>final</em> 修饰参数时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> j)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        j = <span class="number">5</span>; <span class="comment">//这个能否执行？</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时是不能执行的，因为调用方法是 实参<strong>赋值</strong>给形参，j = 5 不能再赋值了。</p><h2 id="2-3-输入、输出">2.3 输入、输出</h2><h3 id="输出">输出</h3><ul><li><p><em>Println</em></p><p>字符串直接可以**+**连接，涉及到复杂一般还是 <em>format</em> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>+<span class="string">&quot; world &quot;</span>); <span class="comment">// 输出：hello world</span></span><br></pre></td></tr></table></figure></li><li><p><em>format</em></p><ul><li><p>%s ：表示字符串</p></li><li><p>%n：表示换行符</p></li><li><p>%d：表示整数</p><ul><li><p><strong>%8d</strong>，（默认）右对齐，占8长度 ；<strong>%-8d</strong>，左对齐，8长度；<strong>%08d</strong>，长度8不够补0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.format(<span class="string">&quot;%08d，%n&quot;</span>,<span class="number">123</span>); <span class="comment">// 输出 00000123</span></span><br><span class="line">System.out.format(<span class="string">&quot;%08d&quot;</span>,<span class="number">123.45</span>); <span class="comment">// 出错，不能是浮点数</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>%f：表示浮点数</p><ul><li><p><strong>%.2f</strong>，表示保留两位小数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.format(<span class="string">&quot;%.1f&quot;</span>,<span class="number">123.456</span>);  <span class="comment">// 四舍五入，保留一位小数：123.5</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="输入">输入</h3><p>输入一般是用 <em>Scanner</em>类 来捕捉用户输入。</p><ul><li><p>基本使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;  <span class="comment">// 1. 引用Scanner类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(System.in);  <span class="comment">// 2. 实例化 Scanner对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个整数&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> a = s.nextInt();  <span class="comment">// 读入整数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;输入整数为 ：&quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一行字符串&quot;</span>);</span><br><span class="line">        String str1 = s.nextLine();  <span class="comment">// 3.读取回车键</span></span><br><span class="line">        String str1 = s.nextLine();  <span class="comment">//读入字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;输入字符串为 ：&quot;</span> + str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>读入输入数据首先需要引用 Scanner类 ，且实例化</li><li>整数、浮点数、字符串…都有对应 nextInt() 、nextFloat() 、nextLine()  等方法</li><li>特别注意 nextLine() 方法，前面有如 ：<strong>nextInt()读入数据 + 回车 ， 会读入回车~</strong></li></ul></li></ul><h2 id="2-4-控制流程">2.4 控制流程</h2><h3 id="switch"><em>switch</em></h3><p><em>switch</em> 可以使用 <em>byte,short,int,char,String,enum</em></p><h2 id="2-5-数组">2.5 数组</h2><h3 id="声明-创建">声明 &amp; 创建</h3><ul><li><p>一维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.声明一个引用</span></span><br><span class="line"><span class="keyword">int</span> a[]; <span class="keyword">int</span>[] a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.分配空间</span></span><br><span class="line">a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.分配空间 &amp; 赋值</span></span><br><span class="line">a = <span class="keyword">new</span>  <span class="keyword">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">a = <span class="keyword">new</span>  <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">// 省略：(1) [数组大小]</span></span><br><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;           <span class="comment">// 省略：(1) [数组大小] (2) new 分配符</span></span><br></pre></td></tr></table></figure></li><li><p>二维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.声明一个引用</span></span><br><span class="line"><span class="keyword">int</span>[][] a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.分配空间</span></span><br><span class="line"><span class="keyword">int</span>[][] a  = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];   <span class="comment">// 虽然一维数组长度被省略，但是要访问必须指定一维数组长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.分配空间 &amp; 赋值</span></span><br><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>&#125;, &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span>[][] a = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>&#125;, &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;; <span class="comment">// 省略：(1) [][] (2) new 分配符</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="增强型for循环">增强型for循环</h3><ul><li><p>举例</p><blockquote><p>循环打印数组内容。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> item : arr)   <span class="comment">// 类比C#：foreach(int item in arr)</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//输出</span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br></pre></td></tr></table></figure></li></ul><h3 id="常用数组操作">常用数组操作</h3><ul><li><p>复制</p><p>用 <em>Arrays 类</em> 实现：</p><blockquote><p>首先注意，需要引用：<code>import</code> <code>java.util.Arrays;</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  复制数组 :  Arrays.copyOfRange(int[] original, int from, int to)</span></span><br><span class="line"><span class="comment">            - original : 被复制的数组</span></span><br><span class="line"><span class="comment">            - from：复制起始位置</span></span><br><span class="line"><span class="comment">            - to： 复制结束位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] srcArr  = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] destArr ; <span class="comment">// 下面复制：自动给目标数组分配空间</span></span><br><span class="line">destArr = Arrays.copyOfRange(srcArr, <span class="number">0</span>, arr.length); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item : b)</span><br><span class="line">&#123;</span><br><span class="line">     System.out.print(item + <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>合并</p><p>以下利用<em>系统方法</em> 复制实现<em>合并两个数组</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  复制数组  : System.arraycopy(src, srcPos, dest, destPos, length)</span></span><br><span class="line"><span class="comment">            - src : 被复制的数组</span></span><br><span class="line"><span class="comment">            - srcPos：被复制数组起始位置</span></span><br><span class="line"><span class="comment">            - dest：目标数组</span></span><br><span class="line"><span class="comment">            - destPos：复制到目标数组的起始位置</span></span><br><span class="line"><span class="comment">            - length ：复制的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length + arr2.length];</span><br><span class="line">System.arraycopy(arr1, <span class="number">0</span>, arr3,<span class="number">0</span> ,arr1.length); <span class="comment">// 必须新数组长度容下前2个数组</span></span><br><span class="line">System.arraycopy(arr2, <span class="number">0</span>, arr3,arr1.length ,arr2.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item : arr3)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.print(item + <span class="string">&quot;&quot;</span>);  <span class="comment">// 最终输出： 1 2 3 4 5 6 7 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>转换成字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  转字符串  :Arrays.toString(src);</span></span><br><span class="line"><span class="comment">            - src : 被转换的数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] srcArr  = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">String content = Arrays.toString(srcArr);</span><br><span class="line">System.out.println(content); <span class="comment">// 输出：[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  排序  : Arrays.sort(src);</span></span><br><span class="line"><span class="comment">         - src : 被排序的数组</span></span><br><span class="line"><span class="comment">  返回值  : 无返回值！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span>[] srcArr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"> Arrays.sort(srcArr);  <span class="comment">// 无返回值</span></span><br><span class="line"> System.out.println(Arrays.toString(srcArr)); <span class="comment">// 输出：[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>二分查找（必须先<em>sort</em>排序！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  查找  : Arrays.binarySearch(src,elem);</span></span><br><span class="line"><span class="comment">         - src : 被搜索的数组</span></span><br><span class="line"><span class="comment">         - elem : 被搜索的元素</span></span><br><span class="line"><span class="comment">  返回值  : 被搜索元素的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span>[] srcArr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"> Arrays.sort(srcArr);  <span class="comment">// 无返回值</span></span><br><span class="line"> System.out.println(Arrays.binarySearch(srcArr, <span class="number">3</span>)); <span class="comment">// 输出：2（从0计数）</span></span><br></pre></td></tr></table></figure></li><li><p>判断是否相同</p><p><code>System.out.println(Arrays.equals(a, b));</code></p></li><li><p>填充</p><p>使用指定元素值，填充数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">Arrays.fill(a, <span class="number">6</span>);  </span><br><span class="line">System.out.println(Arrays.toString(a)); <span class="comment">// 输出：[6,6,6]</span></span><br></pre></td></tr></table></figure></li></ul><h1>第三章：类和对象</h1><h2 id="3-1-基本概念">3.1 基本概念</h2><h3 id="引用">引用</h3><blockquote><p>区分 <code>引用 与 =</code>  ?</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h = <span class="number">5</span>; <span class="comment">// 此时 = 表示赋值 ，h 是变量</span></span><br><span class="line">Hero h1 = <span class="keyword">new</span> Hero(); <span class="comment">// 此时 = 表示指向，h1 是引用</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>一个对象，有多个引用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hero h1 = <span class="keyword">new</span> Hero();</span><br><span class="line">Hero h2 = h1;  <span class="comment">//h2指向h1所指向的对象</span></span><br></pre></td></tr></table></figure></li><li><p><strong>一个引用，有多个对象</strong></p><p>下面 两次 <code>new Hero()</code> 产生了<strong>两</strong>个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hero garen =  <span class="keyword">new</span> Hero(); <span class="comment">// garen 指向Hero对象1</span></span><br><span class="line">garen =  <span class="keyword">new</span> Hero();     <span class="comment">// garen 指向Hero对象2</span></span><br></pre></td></tr></table></figure><p>但是，<strong>同一时间只能指向同一个对象</strong>，所以对象1没有引用指向。</p></li></ul><h3 id="继承">继承</h3><p>使用 <code>extends</code> 关键字来实现继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 物品类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 草鞋类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">shone</span> <span class="keyword">extends</span> <span class="title">Item</span>  </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> speed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数">参数</h3><ul><li><p>this参数</p><p><code>this</code> 代表当前对象。</p><ul><li>类函数参数 和  属性重名，<code>this.属性名</code> 访问属性</li><li>构造方法中调用另一个构造方法 ，<code>this(参数)</code></li></ul></li><li><p>传参（引用类型传参）</p><blockquote><p>尝试写出下面程序输出结果。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 写出下面输出结果 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span></span><br><span class="line"><span class="class"></span>&#123;      </span><br><span class="line">    String name; <span class="comment">//姓名    </span></span><br><span class="line">    <span class="keyword">float</span> hp; <span class="comment">//血量       </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String name,<span class="keyword">float</span> hp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.hp = hp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//复活</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revive</span><span class="params">(Hero h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        h = <span class="keyword">new</span> Hero(<span class="string">&quot;提莫&quot;</span>,<span class="number">383</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Hero teemo =  <span class="keyword">new</span> Hero(<span class="string">&quot;提莫&quot;</span>,<span class="number">383</span>);</span><br><span class="line">        teemo.hp = teemo.hp - <span class="number">400</span>;  <span class="comment">// 受到400伤害，挂了</span></span><br><span class="line">        teemo.revive(teemo);        <span class="comment">// 复活</span></span><br><span class="line">        System.out.println(teemo.hp);         </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>-17 , 即原来死去teemo血量</p></blockquote><ul><li><p>虽然是传递引用，但是在 <em>revive</em> 方法中，此时 hp = 383 ; 退出方法后，h 指向的临时对象被销毁。</p></li><li><p>执行<em>revive</em>方法前，引用<em>teemo</em>指向 死去teemo对象 ；</p></li><li><p>执行<em>revive</em>方法时，引用<em>teemo</em> 复制一份给形参 <em>h</em> ，<em>teemo</em>  和 <em>h</em> 都是指向同一个对象；但是，形参引用<em>h</em>  又new了份新内存，现在它指向的是新<em>Hero</em>对象(无名) 。</p><blockquote><p>参考这篇文章：<a href="https://blog.csdn.net/xiangwanpeng/article/details/52454479">对象传参</a></p></blockquote></li><li><p>执行<em>revive</em>方法后，引用<em>h</em> 指向对象被销毁，引用<em>teemo</em> 始终指向死去teemo对象。</p></li></ul></li></ul><h3 id="访问修饰符">访问修饰符</h3><p>似乎没有说，对象访问权限？</p><blockquote><p>下图，是类中属性、方法被修饰后各种情况访问权限。绿色表示可以访问；红色表示不可以。</p></blockquote><p><img src="http://stepimagewm.how2j.cn/612.png" alt="æ»ç»"></p><h3 id="静态方法和属性">静态方法和属性</h3><ul><li><p>静态属性<em>static</em></p><ul><li>什么时候使用？<ul><li>如果一个属性，每个英雄都不一样，比如<em>name</em>，这样的属性就应该设计为对象属性，因为它是<strong>跟着对象走的</strong>，每个对象的<em>name</em>都是不同的。</li><li>如果一个属性，<strong>所有的英雄都共享</strong>，都是一样的，那么就应该设计为<em>类属性</em> = <em>静态属性</em>。</li></ul></li></ul></li><li><p>静态方法<em>static</em></p><ul><li><p>什么时候使用？</p><ul><li><p>如果方法里访问了对象属性，那么这个方法，就必须设计为对象方法；</p></li><li><p>如果一个方法，没有调用<em>任何对象属性</em>，那么就可以考虑设计为类方法。</p><blockquote><p>比如取随机数 ：<em>Math.random()</em></p></blockquote></li></ul></li><li><p>其它特性</p><ul><li><p>静态方法不能调用非静态方法、成员 ；反之却可以。</p><blockquote><p>实例成员变量是属于某个对象的，而静态方法在执行时，并不一定存在对象。所以，不允许，静态方法调用实例成员变量。</p></blockquote></li></ul></li></ul></li></ul><h3 id="对象属性初始化">对象属性初始化</h3><ul><li><p>初始化方法</p><blockquote><p>注：静态属性初始化，除了第三种：不能在构造函数（*非静态函数不能调用静态属性？*可以！见前。）初始化，其余都可以！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.声明属性时</span></span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;first&quot;</span>; </span><br><span class="line">    <span class="comment">// 2.初始化块时</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;second&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 3.构造函数时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        name = <span class="string">&quot;third&quot;</span>;      </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化顺序</p><p>那么问题来了，上述代码 <em>name 最终被初始化</em> ？</p><blockquote><p>初始化属性： 静态变量 --&gt; 静态初始化块 --&gt; 变量 --&gt; 初始化块 --&gt; 构造器</p></blockquote><p>所以，答案是 ： <em>third</em>。</p></li></ul><h2 id="3-2-单例模式">3.2 单例模式</h2><blockquote><p><em><u>2020-12-23 总结：</u></em>  <a href="https://blog.csdn.net/BlackPlus28/article/details/82794376">单例模式应用场景 &amp; 特点</a></p><p>【场景】</p><ul><li>**例1：回收站。**在windows桌面上打开了一个回收站，当我们试图再次打开一个新的回收站时，Windows系统并不会为你弹出一个新的回收站窗口。也就是说，在整个系统运行的过程中，系统只维护一个回收站的实例。这就是一个典型的单例模式运用。</li><li><strong>例2：网站计数器。</strong> 网站的计数器，一般采用单例模式实现。如果存在多个计数器，每一个用户访问都刷新计数器值，计数值难以同步。</li><li><strong>例3：程序日志。</strong> web开发中读取配置文件都适合使用单例模式，如HttpApplication 就是单例的典型应用。</li></ul><p>【特点】</p><ul><li><p>**优点：**实现了对唯一实例访问的可控；对于一些需要频繁创建和销毁的对象来说可以提高系统的性能。</p></li><li><p><strong>缺点：</strong> 不适用于变化频繁的对象；</p><p>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</p><p><strong>如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失。</strong></p></li></ul></blockquote><ul><li><p>单例模式三元素</p><ol><li>构造方法私有化</li><li>静态属性指向实例</li><li>public static的 getInstance方法，返回第二步的静态属性</li></ol></li><li><p>饿汉单例模式</p><blockquote><p><em>饿汉式</em>  ：是立即加载的方式，无论是否会用到这个对象，都会加载</p><p><em>举例</em> ：数据库连接，构造立即初始化，启动时感觉会卡顿。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiantDragon</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造方法：类外无法 new 进行实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GiantDragon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.静态属性指向实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GiantDragon instance = <span class="keyword">new</span> GiantDragon();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 3.每次获取实例都是 2. 中实例，实现单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GiantDragon <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>懒汉单例模式</p><blockquote><p><em>饿汉式</em>  ：非立即加载的方式，使用时才会加载。</p><p><em>举例</em> ：业务上有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 部分代码略。同饿汉单例模式 ，不过将 2. &amp; 3.中进行一些改变 */</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 2.静态属性指向实例 ： 但不new！</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> GiantDragon instance = <span class="keyword">null</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 3.同前：不存在才创建一次，防止创建出不同对象。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GiantDragon <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(instance == <span class="keyword">null</span>)  </span><br><span class="line">           instance = <span class="keyword">new</span> GiantDragon();</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> instance;    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-3-枚举类型">3.3 枚举类型</h2><ul><li><p>枚举创建</p><blockquote><p>enum是特殊class，enum声明定义的类型就是一个类。</p><p><em>e.g.</em> 单独写一个颜色枚举类<em>Color.java</em>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  </span><br><span class="line">  RED(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), BLUE(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), BLACK(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), YELLOW(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// rgb三属性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> redValue; <span class="comment">// 自定义数据域，private为了封装。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> greenValue;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> blueValue;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 构造枚举值，比如RED(255,0,0)</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> g, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.redValue = r;</span><br><span class="line">    <span class="keyword">this</span>.greenValue = g;</span><br><span class="line">    <span class="keyword">this</span>.blueValue = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举 + <em>switch</em></p><p>可以更好限定范围 &amp; 指定各种类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举调用：类名.枚举颜色，创建对象</span></span><br><span class="line">Color color = Color.RED; <span class="comment">// 不用写后面参数</span></span><br><span class="line"><span class="keyword">switch</span> (color)  <span class="comment">// switch 判断是引用（或变量），switch (Season s) 是错误写法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// case break 判断代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举常用方法</p><ol><li><p><em>ordinal</em></p><p>返回枚举值在枚举类种的<strong>顺序</strong>。这个顺序根据枚举值声明的顺序而定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Color.RED.ordinal();  <span class="comment">//返回结果：0</span></span><br><span class="line">Color.BLUE.ordinal();  <span class="comment">//返回结果：1</span></span><br></pre></td></tr></table></figure></li><li><p><em>compareTo</em></p><p>Enum中的compareTo返回的是两个枚举值的顺序之差。当然，前提是两个枚举值必须属于同一个枚举类，否则会抛出ClassCastException()异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color.RED.compareTo(Color.BLUE);  <span class="comment">//返回结果 -1</span></span><br></pre></td></tr></table></figure></li><li><p>[静态]<em>values</em></p><p>静态方法，返回一个包含全部枚举值的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Color[] colors=Color.values();</span><br><span class="line"><span class="keyword">for</span>(Color c:colors)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(c+<span class="string">&quot;,&quot;</span>); </span><br><span class="line">&#125; <span class="comment">//返回结果：RED,BLUE,BLACK YELLOW,GREEN,</span></span><br></pre></td></tr></table></figure></li><li><p><em>toString</em></p><p>返回枚举常量的名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Color c=Color.RED;</span><br><span class="line">System.out.println(c);<span class="comment">//返回结果: RED</span></span><br></pre></td></tr></table></figure></li><li><p><em>valueOf</em></p><p>这个方法和<em>toString</em>方法是相对应的，返回带指定名称的指定枚举类型的枚举常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color.valueOf(<span class="string">&quot;BLUE&quot;</span>);   <span class="comment">//返回结果: Color.BLUE</span></span><br></pre></td></tr></table></figure></li><li><p><em>equals</em></p><p>比较两个枚举类对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK源代码：      </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>==other;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h1>第四章：接口与继承</h1><h2 id="4-1-接口">4.1 接口</h2><blockquote><p><em>JAVA</em>中使用接口，需要创建一个 <em>new --&gt; class —&gt; 下拉选择 Interface —&gt; IAD.java</em></p></blockquote><p>下面实现一个 <em>AD</em>英雄 <em>implements</em> <em>AD</em>接口。</p><ol><li><p>在 <em>IAD.java</em> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAD</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ADAttack</span><span class="params">()</span></span>;  <span class="comment">// 接口不能有体:&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <em>ADHero.java</em> 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ADHero</span> <span class="keyword">extends</span> <span class="title">Hero</span> <span class="keyword">implements</span> <span class="title">IAD</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">// 加上这句IDE自动显示可以继承的方法；但没有这句也可自己写方法覆写。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ADAttack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输出了物理伤害！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-2-对象转换">4.2 对象转换</h2><ul><li><p>基本概念</p><ul><li><p>引用类型 &amp; 对象类型</p><p>通常，引用类型 和 对象类型 是一致的，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADHero ad = <span class="keyword">new</span> ADHero();</span><br></pre></td></tr></table></figure><ul><li>引用<em>ad</em> 指向了<em>new</em>出的新对象，它们类型都是 <em>ADHero</em>。</li><li>如果 <em>引用类型 ≠ 对象类型</em>：则是下述的<em>类型转换</em>问题。</li></ul></li><li><p>向上转型 / 向下转型</p><p>“向上”、“向下”：是一种继承的概念，父类在子类上 ；类在继承的接口上。</p><p>向上转型：则指 子类转父类 ；类转为<em>继承</em>的接口。（<strong>可行</strong>）</p></li></ul></li><li><p>向上转型</p><blockquote><p>苹果手机 继承 手机，把苹果手机当做普通手机使用；<br>怡宝纯净水 继承 饮品， 把怡宝纯净水当做饮品来使用。</p></blockquote><p>总结：特殊可转一般，子转父、子转接口。</p><ul><li><p>子类转父类</p><p>下面 把物理英雄转普通英雄，显然是可行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hero h;   <span class="comment">// 不new！</span></span><br><span class="line">ADHero ad = <span class="keyword">new</span> ADHero();</span><br><span class="line">h = ad; <span class="comment">// 【注意】：h指向的是ADHero对象，但只能使用 Hero 类方法属性！</span></span><br></pre></td></tr></table></figure></li><li><p>子类转父接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADHero ad = <span class="keyword">new</span> ADHero();</span><br><span class="line">AD adi = ad;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>向下转型（强制）</p><blockquote><p>父类转子类，<em>有的时候行</em>，有的时候不行，所以必须进行强制转换。</p></blockquote><ul><li><p>父类转子类</p><p>下面，这种情况向下转型<strong>可行</strong>：因为第三行子类转父类，<em>h指向ADHero对象（但只能使用 Hero 类方法属性）</em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hero h = <span class="keyword">new</span> Hero();</span><br><span class="line">ADHero ad = <span class="keyword">new</span> ADHero();</span><br><span class="line">h = ad; <span class="comment">// 父类（基类）引用h 指向--&gt; ADHero对象</span></span><br><span class="line">ad = (ADHero) h;</span><br></pre></td></tr></table></figure><p>所以上面代码表现的好像是，父类转子类成功，其实是 <em>ADHero转换为ADHero</em>。</p></li><li><p>父接口转子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADHero ad = <span class="keyword">new</span> ADHero();</span><br><span class="line">AD Iad = ad; <span class="comment">// 引用Iad指向 ADHero对象</span></span><br><span class="line">ADHero adHero = (ADHero) Iad;  <span class="comment">// ADHero 转 ADHero ，可行</span></span><br><span class="line">ADAPHero adapHero = (ADAPHero) Iad; <span class="comment">// 不可行，ADHero 不能转 ADAPHero</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>没有继承关系转换</p><p>一定失败，不多言。</p></li><li><p><em>instanceof</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADHero ad = <span class="keyword">new</span> ADHero();</span><br><span class="line">Hero h1 = ad;</span><br><span class="line"><span class="comment">//判断引用h1指向的对象，是否是ADHero类型</span></span><br><span class="line">System.out.println(h1 <span class="keyword">instanceof</span> ADHero);  <span class="comment">// 输出：true</span></span><br><span class="line"><span class="comment">//判断引用h1指向的对象，是否是Hero的子类型</span></span><br><span class="line">System.out.println(h1 <span class="keyword">instanceof</span> Hero);   <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-3-重写-隐藏-重载">4.3 重写 &amp; 隐藏 &amp; 重载</h2><ul><li><p>重写</p><p>重写：是不改变父类的方法名字和参数个数和类型，简单点说就是实现跟父类不一样的功能。</p><p>关键字：继承、不同类，和父类方法只有方法体不一样。</p></li><li><p>隐藏</p><p>隐藏：是有一个跟父类一样的<strong>静态</strong>方法，调用的时候就直接用子类的静态方法了。</p><p>关键字：继承、不同类，和父类方法只有方法体不一样、<strong>静态</strong>。</p></li><li><p>重载</p><p>重载：是方法重载,方法签名完全一致,参数类型和个数不同,JVM就可以识别并调用重载方法。</p><p>关键字：同类、和同类同名方法参数类型、个数、方法体都不同。</p></li></ul><h2 id="4-4-多态">4.4 多态</h2><p>多态一般分为：操作符多态；类多态，由 <strong>类型向上转换 + 重写/重载</strong>  实现；</p><h3 id="操作符多态">操作符多态</h3><ul><li><p>概念</p><p>如：<strong>+</strong>  既可以表示 <em>数字相加</em> 也可表示 <em>字符串连接</em> 等，由<em>运算符重载</em>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> str = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>运算符重载</p></li></ul><h3 id="类多态">类多态</h3><p>类多态一般需满足两个条件：</p><ol><li><p>父类（接口）指向 子类对象</p><blockquote><p>因为所谓类多态，就是可以用 基/父类 指向子类</p></blockquote></li><li><p>调用方法有 <strong>重写</strong></p><blockquote><p>同前，父类虽然在 <strong>1.</strong> 指向子类对象，但只可以使用父类方法、属性；如果想调用子类方法，那么在父类和子类都声明同名方法，这样<em>父类.方法()—&gt; 执行 —&gt; 子类.方法()</em>。</p></blockquote></li></ol><ul><li><p>类多态作业1：重写 实现多态</p><blockquote><p>分别有以下两个类：</p><p><em>MagicPortion</em>类，*effec()*使用后回蓝；</p><p><em>LifePortion</em> 类，*effec()*使用后回血；</p><p>Hero类对象 VN，VN调用本身方法 <em>userItem(参数)</em> 即可实现回血、回蓝等物品使用。</p></blockquote><ul><li><p>实现父类接口 <em>Item</em></p><p>要实现多态，我们在外面使用<strong>一个父类</strong>引用指向<strong>不同子类</strong>对象，再用其调用子类方法。</p><p>这样，不必为不同子类对象生成不同对应引用，比如可使得<em>函数参数统一</em>等（见后）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">effect</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现 <em>MagicPortion、LifePortion</em> 类</p><p><em>MagicPortion</em>类，*effec()*使用后回蓝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicPortion</span> <span class="keyword">implements</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">effect</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用蓝瓶回蓝100！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>LifePortion</em> 类，*effec()*使用后回血：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifePortion</span> <span class="keyword">implements</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">effect</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用血瓶回血100！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>Hero</em>类表现多态</p><p>要表现多态，让父类指向子类对象，同时可以执行<em>子类同名</em>（重写）方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">useItem</span><span class="params">(Item i)</span> <span class="comment">//父类接口Item做参数，可以接收不同子类对象</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        i.effect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，统一了函数参数，一个方法（不必重载）就可以实现各种物品使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主函数main()中</span></span><br><span class="line">Hero VN = <span class="keyword">new</span> Hero();</span><br><span class="line">Item i1 = <span class="keyword">new</span> MagicPortion();</span><br><span class="line">Item i2 = <span class="keyword">new</span> LifePortion();</span><br><span class="line">VN.useItem(i1);  <span class="comment">// 输出：使用蓝瓶回蓝100！</span></span><br><span class="line">VN.useItem(i2);  <span class="comment">// 输出：使用血瓶回血100！</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>类多态作业2：隐藏<em>static</em>无法体现多态</p><p>如果将 <em>Item</em> 类改为以下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span>  // 1.接口--&gt;类，隐藏只支持类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">effect</span><span class="params">()</span>  <span class="comment">// 2.+static，关键字</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;物品产生一些效果&quot;</span>); <span class="comment">// 3.添加方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <em>MagicPortion &amp; LifePortion</em>  类 <em>effect()</em> 也加上<em>static</em>关键字实现同名隐藏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">effect</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>这个时候主函数输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主函数main()中</span></span><br><span class="line">Hero VN = <span class="keyword">new</span> Hero();</span><br><span class="line">Item i1 = <span class="keyword">new</span> MagicPortion();</span><br><span class="line">VN.useItem(i1);  <span class="comment">// 输出：物品产生一些效果</span></span><br></pre></td></tr></table></figure><p>原因如下：</p><blockquote><p><em>隐藏</em> 对方法都加上了<em>static</em>关键字，无法在 <code>Item i1 = new MagicPortion();</code> ，实现引用 <em>i1</em> <strong>动态绑定</strong> 静态方法，也就无法实现多态！</p></blockquote></li></ul><h2 id="4-5-super-final">4.5 <em>super &amp; final</em></h2><ul><li><p>利用<em>super</em>调用父类属性、方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ADHero</span> <span class="keyword">extends</span> <span class="title">Hero</span> <span class="keyword">implements</span> <span class="title">AD</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">   <span class="comment">//在某个方法中</span></span><br><span class="line">   <span class="keyword">super</span>.moveSpeed;  <span class="comment">// 1.调用父类属性</span></span><br><span class="line">   <span class="keyword">super</span>.useItem(i); <span class="comment">// 2.调用父类方法userItem</span></span><br><span class="line">   <span class="keyword">super</span>();          <span class="comment">// 3.调用父类无参构造函数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>final</em> 修饰</p><ul><li><p>修饰类：类无法被继承</p><blockquote><p>如，可用自定义类 <em>someString</em> 继承系统类 <em>String</em> ，结果如何？</p></blockquote><p>不能继承，因为 系统类 <em>String</em> ，是被 <em>final</em> 关键字修饰的。</p></li><li><p>修饰方法：方法不能被重写</p></li><li><p>修饰变量：只能被赋值<strong>1</strong>次</p><blockquote><p>如，可利用这点，设置一个常量。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> pi = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure></li><li><p>修饰引用：只有<strong>1</strong>次指向引用的机会</p></li></ul></li></ul><h2 id="4-6-抽象类">4.6 抽象类</h2><ul><li><p>基本概念</p><ul><li><p>类带有 abstract 关键字修饰就是抽象类；</p></li><li><p>含有抽象方法必须是抽象类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 抽象方法attack：[1] abstract修饰 [2] 无方法体</span></span><br><span class="line">    <span class="comment">// Hero的子类会被要求实现attack方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象类不能被实例化，专门用来继承的。</p></li></ul></li><li><p>抽象类 和 接口区别</p><ul><li><p>默认方法实现</p><p>抽象类可以有非抽象方法，有方法体 ； 接口不能有。</p><blockquote><p>抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。</p></blockquote><p>再精辟点总结：</p><blockquote><p>抽象类，既 1.非抽象类实现代码复用 2.又同时有抽象方法使得被继承类各自实现。</p><p>接口，是对类的行为进行约束，强制要求不同类实现相同行为。</p></blockquote></li><li><p>构造函数</p><p>抽象类有；接口没有。</p></li><li><p>修饰符</p><p>抽象类除private 都有（抽象类目的是被继承，抽象方法是为被重写）；接口only public。</p></li><li><p>继承个数 [<strong>接口优</strong>]</p><p>抽象类只能被继承一次；接口可以有多个。</p></li></ul></li></ul><h2 id="4-7-内部类">4.7 内部类</h2><blockquote><p>暂时不知道什么时候用得到，先不展开：<a href="http://how2j.cn/k/interface-inheritance/interface-inheritance-inner-class/322.html#nowhere">讲解内部类链接</a></p></blockquote><ul><li>非静态内部类</li><li>静态内部类</li><li>匿名类</li><li>本地类</li></ul><h2 id="4-8-默认方法">4.8 默认方法</h2><p>默认方法是指 ：接口的抽象方法，加上 <em>default</em> 关键字，可以有方法体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mortal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">die</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revive</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本英雄复活了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的好处：</p><blockquote><p>假设没有默认方法这种机制，那么如果要为<em>Mortal</em>增加一个新的方法<em>revive</em>,那么所有实现了<em>Mortal</em>接口的类，都需要做改动实现 <em>revive</em>。</p><p>但是引入了默认方法后，原来的类，不需要做任何改动，并且还能<strong>得到</strong>这个默认方法</p></blockquote><h2 id="4-9-UML图">4.9 UML图</h2><ul><li><p>类图解释</p><p><img src="http://stepimagewm.how2j.cn/2318.png" alt="è§£éUML-ç±»å¾"></p></li><li><p>接口图解释</p><p><img src="http://stepimagewm.how2j.cn/2319.png" alt="è§£éUML-æ¥å£å¾"></p></li><li><p>继承关系解释</p><p><em>实线</em>：表示继承类，如下图 <em>Spider</em> 类继承 <em>Animal</em> 类；</p><p><em>虚线</em>：表示继承接口，如下图 <em>Cat</em>类 继承 <em>Pet</em> 接口。</p><p><img src="http://stepimagewm.how2j.cn/2305.png" alt="UML å¾ ââ ç±»ä¹é´çå³ç³»"></p></li></ul><h1>第五章：数字 和 字符串</h1><h2 id="5-1-拆箱、装箱">5.1 拆箱、装箱</h2><ul><li><p>关于拆箱、装箱基本概念</p><blockquote><p>所有的<strong>基本类型</strong>，都有对应的<strong>类类型</strong> ，又称为<strong>封装类</strong>，也是 <strong>数值与包类型转换</strong>。</p></blockquote><p>下面是所有<em>数值</em> 基本类型，对应的类型型，它们又都是抽象类 <em>Number</em> 的子类。</p><p><img src="http://stepimagewm.how2j.cn/672.png" alt="Numberç±»"></p><ul><li>如：基本类型 <em>int</em> --&gt; 对应封装类 <em>Integer</em> ； <em>short</em> --&gt; 对应封装类 <em>Short</em> …</li></ul></li><li><p>装箱</p><blockquote><p>装箱，即将 <em>基本类型</em> <strong>自动</strong> 转换成<em>封装类型</em>，自动又是通过 <strong>=</strong> 号实现。</p></blockquote><p>先看一个<em>非装箱</em>，自己调用构造方法实现 基本类型–&gt; 封装类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非装箱转换成封装类</span></span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"> Integer it = <span class="keyword">new</span> Integer(i);</span><br></pre></td></tr></table></figure><p>如果 用 = 号 实现自动上述过程，则称为装箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// = 自动装箱</span></span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"> Integer it = i; <span class="comment">// = 自动实现类型转换，无需new</span></span><br></pre></td></tr></table></figure></li><li><p>拆箱</p><blockquote><p>和装箱类似，即将 <em>封装类型</em> <strong>自动</strong> 转换成 <em>基本类型</em>，自动又是通过 <strong>=</strong> 号实现。</p></blockquote><p><em>非拆箱</em>，自己调用构造函数实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非拆箱实现转换成基本类型</span></span><br><span class="line"> Integer it = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">int</span> i = it.intValue();</span><br></pre></td></tr></table></figure><p>拆箱实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// = 自动拆箱</span></span><br><span class="line"> Integer it = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">int</span> i = it; <span class="comment">// = 自动实现类型转换</span></span><br></pre></td></tr></table></figure></li><li><p>拆箱、装箱之惑</p><ul><li><p>存在的意义？</p><blockquote><p>为什么要有装箱、拆箱，它们的作用是什么？</p></blockquote><p><em>java</em> 是 面对对象编程，而基本数据类型不是对象，所有才有封装类 引用基本数据类型。</p><p>比如，下面打印出<em>int</em>型数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>；</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><p>其实，查看源码，实际经过以下几个过程：</p><ul><li>将 <em>i</em> 自动装箱成封装类 <em>Integer</em></li><li>然后调用 <em>Integer</em>中 <em>toString</em>() 方法，打印出字符串输出到控制台。</li></ul></li></ul></li></ul><h2 id="5-2-类型转换">5.2 类型转换</h2><h3 id="数值类型之间">数值类型之间</h3><ul><li><p>位数低—&gt;高</p><blockquote><p>低—&gt;高：<em>byte,char(1) --&gt; short(2)–&gt; int(4) --&gt; long(8) --&gt; float(8) --&gt; double(16)</em></p></blockquote></li><li><p>强制转换</p><p>如果是低位向高位转换，则自动转换；反之，则需要 <code>()</code> 强制转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> s = b; <span class="comment">// 可，自动转换。</span></span><br><span class="line">b = (<span class="keyword">byte</span>)s; <span class="comment">// 强制</span></span><br></pre></td></tr></table></figure></li><li><p>表达式类型提升</p><p>如果，数值类型参与运算，<strong>操作符两端类型要一致</strong>，有以下几个原则：</p><ul><li><p><em>byte、short</em>和<em>char</em> 自动提升int型；</p></li><li><p>操作数含<em>long</em>型，则整个表达式类型提升为<em>long</em>型；</p></li><li><p>操作数含 <em>float / double</em> 型，则整个表达式提升为 <em>float /double</em>型表示；</p></li><li><p><em>long、float、double</em>，同时出现，提升优先：<em>double &gt; float &gt; long</em> 。</p></li></ul></li></ul><h3 id="数值类型-char">数值类型 &amp; <em>char</em></h3><p>基本规则和数值类型直接按位数，是否强制转换很相似，但有一点不同：</p><ul><li><p><em>char &amp; byte  &amp; short</em>  之间, 除了 <em>byte</em> 转换成 <em>short</em> 都是强制转换；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="number">1</span>; <span class="keyword">short</span> s = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">s = (<span class="keyword">short</span>) c; <span class="comment">// 虽然short位数4，但是还是要强制转换</span></span><br><span class="line">c = (<span class="keyword">char</span>) b;</span><br><span class="line">b = (<span class="keyword">byte</span>) c;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数值类型-String">数值类型 &amp; <em>String</em></h3><ul><li><p>数值类型 &lt;— <em>String</em></p><p><em>String</em> 转为 数值类型，一般有如下三种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> String str = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：数值类型对应封装类.parse方法</span></span><br><span class="line"> <span class="keyword">int</span> a1 = Integer.parseInt(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：手动装箱 --&gt; 手动拆箱</span></span><br><span class="line"><span class="comment">// 等价自动拆箱：int a2 = Integer.valueOf(str);</span></span><br><span class="line"> Integer it2 = Integer.valueOf(str);</span><br><span class="line"> <span class="keyword">int</span> a2 = it2.intValue(); <span class="comment">// 可以更简单=自动拆箱：int a2 = it2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：手动装箱 --&gt; = 自动拆箱</span></span><br><span class="line"> <span class="keyword">int</span> a3 = <span class="keyword">new</span> Integer(str);</span><br></pre></td></tr></table></figure></li><li><p><em>String</em>  &lt;—  数值类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> i = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：数值类型对应封装类.toString方法</span></span><br><span class="line"> String str1 = Integer.toString(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：先装箱再拆箱：手动装箱--&gt; = 自动拆箱</span></span><br><span class="line"> String str2 = String.valueOf(i);</span><br></pre></td></tr></table></figure></li></ul><h3 id="int-String"><em>int[] &amp; String</em></h3><ul><li><p><em>int[]</em> 转换 <em>string</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  java.util.*；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.调用Arrays类方法</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">string s = Arrays.toString(arr)</span><br></pre></td></tr></table></figure></li></ul><h3 id="String-char-char"><em>String</em> &amp; <em>char</em> <em>&amp; char[]</em></h3><ul><li><p><em>String</em>转换为<em>char</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 和 char 之间转换</span></span><br><span class="line">String str = <span class="string">&quot;123&quot;</span>; </span><br><span class="line"><span class="keyword">char</span> c = str.charAt(<span class="number">0</span>);         <span class="comment">// 转换成字符</span></span><br><span class="line"><span class="keyword">char</span>[] c1 = str.toCharArray();  <span class="comment">// 转换成字符数组</span></span><br></pre></td></tr></table></figure></li><li><p><em>char</em> 转换成 <em>String</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">&#x27;1&#x27;</span>; String str1 ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：利用每种基本类型对应封装类都有的.toString方法</span></span><br><span class="line">str1 = Character.toString(c1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：valueOf装箱 --&gt; =自动拆箱</span></span><br><span class="line">str1 = String.valueOf(c1);</span><br></pre></td></tr></table></figure></li><li><p>char[] 转换为string</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.直接在构造String时建立。 </span></span><br><span class="line"><span class="keyword">char</span> data[] = &#123;<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;k&#x27;</span>&#125;; </span><br><span class="line">String str = <span class="keyword">new</span> String(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.String有方法可以直接转换。</span></span><br><span class="line"> <span class="keyword">char</span>[] cha = &#123;<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>&#125;; </span><br><span class="line">String n = String.valueOf(cha);</span><br></pre></td></tr></table></figure></li></ul><h3 id="String-byte"><em>String</em> &amp; <em>byte[]</em></h3><ul><li><p><em>String</em>转换为<em>byte[]</em></p><p>和转换成 <em>char</em> 类似，可以调用对象本身的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;123&quot;</span>; </span><br><span class="line"><span class="keyword">byte</span>[] bytes = str.getBytes();</span><br></pre></td></tr></table></figure></li><li><p><em>byte[]</em> 转换成 <em>String</em></p><p>也同 <em>char</em> 转 <em>String</em> 类似，利用装箱拆箱。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">String s = <span class="keyword">new</span> String(bytes);</span><br></pre></td></tr></table></figure></li></ul><h3 id="引用类型之间">引用类型之间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数中</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure><ul><li><p>向上转换，父类引用 &lt;— 子类引用，可转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = s； <span class="comment">// 子转父</span></span><br></pre></td></tr></table></figure><blockquote><p>其实，<strong>本质</strong> <em>p</em>指向了 <em>Student</em>对象，虽然只能使用<em>Person</em>方法，等价这种写法：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="keyword">new</span> Student(); <span class="comment">// Student对象无名引用，转换成父类 Person</span></span><br></pre></td></tr></table></figure></li><li><p>向下转换，子类引用 &lt;— 父类引用，<em>抛出异常</em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = (Student)p; <span class="comment">// 抛出异常</span></span><br></pre></td></tr></table></figure></li><li><p>如果无继承关系引用转换，<strong>编译错误</strong>！</p></li></ul><h2 id="5-3-数学方法">5.3 数学方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.四舍五入</span></span><br><span class="line">Math.round(<span class="number">5.5</span>);    <span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 2.随机数</span></span><br><span class="line">Math.random();      <span class="comment">// [0-1) 之间随机数</span></span><br><span class="line">Math.random()*<span class="number">10</span>;   <span class="comment">// [0-10) 之间随机数</span></span><br><span class="line"><span class="comment">// 3.开方</span></span><br><span class="line">Math.sqrt(<span class="number">9</span>)</span><br><span class="line"><span class="comment">// 4.次方</span></span><br><span class="line">Math.pow(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 5.常数</span></span><br><span class="line">Math.PI  <span class="comment">// π</span></span><br><span class="line">Math.E   <span class="comment">// 自然常数</span></span><br></pre></td></tr></table></figure><h2 id="5-4-Sting-常用方法">5.4 <em>Sting</em> 常用方法</h2><h3 id="单字符串操作">单字符串操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello java!&quot;</span>;</span><br></pre></td></tr></table></figure><p><em>常用方法见下：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.返回字符</span></span><br><span class="line">str.charAT(<span class="number">0</span>);         <span class="comment">// 返回str第一个字符</span></span><br><span class="line"><span class="comment">// 2.返回字符数组</span></span><br><span class="line">str.toCharArray();  </span><br><span class="line"><span class="comment">// 3.截取字符串</span></span><br><span class="line">str.substring(<span class="number">3</span>);    <span class="comment">// 从第3个字符开始截取</span></span><br><span class="line">str.substring(<span class="number">3</span>,<span class="number">5</span>);  <span class="comment">// [3,5):截取第3--&gt;第5字符，不含第5</span></span><br><span class="line"><span class="comment">// 4.分隔字符串</span></span><br><span class="line">str.split(<span class="string">&quot;,&quot;</span>);  </span><br><span class="line"><span class="comment">// 5.去除首尾空格</span></span><br><span class="line">str.trim();  </span><br><span class="line"><span class="comment">// 6.大小写</span></span><br><span class="line">str.toLowerCase()</span><br><span class="line">str.toUpperCase()</span><br><span class="line"><span class="comment">// 7.定位</span></span><br><span class="line">str.indexOf(<span class="string">&#x27;l&#x27;</span>);     <span class="comment">// 返回l第一次出现位置：2</span></span><br><span class="line">str.lastIndexOf(<span class="string">&#x27;l&#x27;</span>);  <span class="comment">// 返回l最后一次出现位置：3</span></span><br><span class="line"><span class="comment">// 8.包含</span></span><br><span class="line">str.contains(<span class="string">&quot;java&quot;</span>);  <span class="comment">// 返回：ture</span></span><br></pre></td></tr></table></figure><h3 id="多字符串操作">多字符串操作</h3><ul><li><p>比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;the light&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(str1); </span><br></pre></td></tr></table></figure><p><em>常用操作方法：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.是否同一对象</span></span><br><span class="line"> System.out.println( str1  ==  str2); <span class="comment">//虽然，内容相同但不是同一对象</span></span><br><span class="line"><span class="comment">// 2.是否内容相同</span></span><br><span class="line"> System.out.println(str1.equals(str2)); <span class="comment">//返回 ：ture</span></span><br><span class="line"> System.out.println(str1.equalsIgnoreCase(str3)); <span class="comment">// 忽略大小写，比较</span></span><br></pre></td></tr></table></figure></li><li><p>以特定字符结束/开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;the light&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;ht&quot;</span>;</span><br></pre></td></tr></table></figure><p><em>使用举例：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.判断以特定字符开始</span></span><br><span class="line">System.out.println(str1.startsWith(str2)); <span class="comment">// 返回false</span></span><br><span class="line"><span class="comment">// 2.判断以特定字符结束</span></span><br><span class="line">System.out.println(str1.endsWith(str2)); <span class="comment">// 返回ture</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="5-5-StringBuffer类">5.5 <em>StringBuffer</em>类</h2><p>比<em>String</em>基本类型，能更好操作字符串：追加、删除、插入、反转等，而且<u>性能佳</u>！</p><blockquote><p>为什么<em>StringBuffer</em>可以变长？</p><p>和<em>String</em> 和 <em>StringBuffer</em> 内部都维护了一个字符数组，但是<em>StringBuffer</em> 还有<strong>冗余长度</strong>。</p></blockquote><ul><li><p>声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;hello java!&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>常用操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.追加</span></span><br><span class="line">sb.append(<span class="string">&quot;啊，我死了！&quot;</span>);</span><br><span class="line">System.out.println(sb); <span class="comment">// hello java!啊，我死了！</span></span><br><span class="line"><span class="comment">// 2.删除</span></span><br><span class="line">sb.delete(<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line">System.out.println(sb); <span class="comment">// hello!啊，我死了！</span></span><br><span class="line"><span class="comment">// 3.插入</span></span><br><span class="line">sb.insert(<span class="number">5</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">System.out.println(sb); <span class="comment">// hello!!啊，我死了！</span></span><br><span class="line"><span class="comment">// 4.反转</span></span><br><span class="line">sb.reverse(); <span class="comment">//反转</span></span><br><span class="line">System.out.println(sb); <span class="comment">// ！了死我，啊!!olleh</span></span><br></pre></td></tr></table></figure></li><li><p>常用属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sb.length(); <span class="comment">//内容长度：13</span></span><br><span class="line">sb.capacity(); <span class="comment">//总容量：27（有冗余）</span></span><br></pre></td></tr></table></figure></li></ul><h1>第六章：日期</h1><h2 id="6-1-Date类">6.1 <em>Date</em>类</h2><blockquote><p>什么是时间原点？</p></blockquote><p>时间原点是：<em>1970/1/1 8:0:0</em> 。所有的日期，以此为基准，每过一毫秒，就+1。</p><blockquote><p>如何引进日期类库？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br></pre></td></tr></table></figure><ul><li><p>创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.不带参数，当前时间</span></span><br><span class="line">Date d = <span class="keyword">new</span>  Date();</span><br><span class="line">System.out.println(d);  <span class="comment">// 输出：Sat Jun 29 22:11:23 CST 2019</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.带参数(整数)，时间：原点+整数/1000(秒)</span></span><br><span class="line">Date d1 = <span class="keyword">new</span> Date(<span class="number">1000</span>);</span><br><span class="line">System.out.println(d1); <span class="comment">// 输出：Thu Jan 01 08:00:01 CST 1970</span></span><br></pre></td></tr></table></figure></li><li><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.getTime:获取 当前时间 - 原点 毫秒数</span></span><br><span class="line">System.out.println(d.getTime());</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-2-SimpelDateFormat-类">6.2 <em>SimpelDateFormat</em> 类</h2><p><em>SimpelDateFormat</em> 类 用来格式化日期输出。</p><blockquote><p>如何引用？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br></pre></td></tr></table></figure><ul><li><p>格式<em>Date</em>对象</p><p>:warning:注意，下面格式模式 <em>MM 、HH</em> 必须大写，否则出错！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">// 1.创建SimpleDateFormat对象，并指定格式模式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">// 2.利用format方法，格式Date对象，并返回String类型</span></span><br><span class="line">String str = sdf.format(d); <span class="comment">// 返回String类型</span></span><br><span class="line"><span class="comment">// 3.输出测试</span></span><br><span class="line">System.out.println(str); <span class="comment">// 输出：2019/06/29 22:53:00</span></span><br></pre></td></tr></table></figure></li><li><p>格式<em>String</em>对象</p><p>:warning:注意，<em>parse</em>方法，必须在一对 <em>try catch</em> 块中，否则编译错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;2019/01/01 00:00:00&quot;</span>;</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">// 1.创建SimpleDateFormat对象，并指定格式模式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">// 2.parse方法，格式String对象，并返回Date类型</span></span><br><span class="line"><span class="keyword">try</span> </span><br><span class="line">&#123;</span><br><span class="line">    d = sdf.parse(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ParseException e)</span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.输出测试</span></span><br><span class="line">System.out.println(d); <span class="comment">// 输出测试：Tue Jan 01 00:00:00 CST 2019</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="6-3-Calendar类">6.3 <em>Calendar</em>类</h2><p><em>Calendar</em> 类 和 <em>Date</em>类相比，更容易进行“翻日历“，进行月份/天等修改。</p><blockquote><p>如何引用？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br></pre></td></tr></table></figure><ul><li><p>创建对象</p><p>:warning: 只能利用<em>Calendar.getInstance()</em> 获取单例，<em>new</em>需要重写函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br></pre></td></tr></table></figure></li><li><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.getTime(),返回Date类型对象</span></span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">Date d = c.getTime()；</span><br><span class="line">System.out.println(c.getTime()); <span class="comment">// 输出：Sat Jun 29 23:08:53 CST 2019</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.setTime(Date d),设置时间，无返回</span></span><br><span class="line">Date d1 = <span class="keyword">new</span> Date(<span class="number">0</span>);</span><br><span class="line">c.setTime(d1);</span><br><span class="line">System.out.println(c.getTime()); <span class="comment">// 输出：Thu Jan 01 08:00:00 CST 1970</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.add，在原日期(2019/6/29)上增加 年/月/日</span></span><br><span class="line">c.add(c.YEAR, <span class="number">3</span>); <span class="comment">// 3年后</span></span><br><span class="line">c.add(c.MONTH, -<span class="number">1</span>); <span class="comment">// 前1个月</span></span><br><span class="line">c.add(c.DATE, <span class="number">1</span>);  <span class="comment">// 后1天</span></span><br><span class="line">System.out.println(c.getTime()); <span class="comment">// 输出：Sun May 30 23:29:06 CST 2022</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.set，可分别设置年月日，区分setTime</span></span><br><span class="line">c.add(c.YEAR, <span class="number">2019</span>); </span><br><span class="line">c.add(c.MONTH, <span class="number">9</span>); </span><br><span class="line">c.add(c.DATE, <span class="number">1</span>);  </span><br><span class="line">System.out.println(c.getTime()); <span class="comment">// 输出：Tue Oct 01 23:34:55 CST 2019</span></span><br></pre></td></tr></table></figure></li></ul><h1>第七章：异常</h1><h2 id="7-1-异常分类">7.1 异常分类</h2><p><img src="http://stepimagewm.how2j.cn/742.png" alt="Throwable"></p><ul><li>异常分为，<em>Error &amp; Exception</em>，它们都是 <em>Throwable</em> 子类；</li><li><em>Exception</em>，又分为运行时异常、可查异常。</li></ul><h2 id="7-2-异常处理">7.2 异常处理</h2><ul><li><p><em>try cacth</em></p><p>尝试打开 LOL，抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数中：</span></span><br><span class="line">File f= <span class="keyword">new</span> File(<span class="string">&quot;d:/LOL.exe&quot;</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;试图打开 d:/LOL.exe&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> FileInputStream(f);  <span class="comment">// (1) 执行到这出现异常 ---&gt; 执行catch块</span></span><br><span class="line">    System.out.println(<span class="string">&quot;成功打开&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span>(FileNotFoundException e) <span class="comment">// (2) 出现异常开始处理</span></span><br><span class="line"> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;d:/LOL.exe不存在&quot;</span>);</span><br><span class="line">    System.out.println(e.toString());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561884324970.png" alt="1561884324970"></p><blockquote><p>改进：如果不知道抛出异常类型？</p><p>可以用父类 <em>Exception</em>，甚至<em>Throwable</em> 进行<em>catch</em> 处理。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用父类进行catch(只修改catch块)</span></span><br><span class="line"><span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;d:/LOL.exe不存在&quot;</span>);</span><br><span class="line">   System.out.println(e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>改进：如果有多个错误？</p><p>可用多个 <em>catch</em> 块进行处理。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try&#123; // 程序代码 &#125;</span><br><span class="line">catch(异常类型1 异常的变量名1) &#123; // 处理程序 &#125;</span><br><span class="line">catch(异常类型2 异常的变量名2) &#123; // 处理程序 &#125;</span><br></pre></td></tr></table></figure></li><li><p><em>try cacth finally</em></p><p>有时候希望，无论是否出现异常，都希望有段代码被执行，也就是<em>finally</em>块。</p><p>但是有下面几个结合<em>return</em> 情况，值得深思：<a href="http://www.blogjava.net/fancydeepin/archive/2012/07/08/java_try-catch-finally.html"><em>java</em>异常捕获</a></p></li><li><p><em>throw try cacth</em></p><blockquote><p>理解不深，待实际操作补充。同时可见下：[自定义异常]</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561886405277.png" alt="1561886405277"></p></li></ul><h2 id="7-3-自定义异常">7.3 自定义异常</h2><blockquote><p>对 <em>throws</em> 作用理解不深，待补充。</p></blockquote><ul><li><p>自定义异常类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myException</span> <span class="keyword">extends</span> <span class="title">Exception</span> // 继承<span class="title">Exception</span>类</span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">myException</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;flag = 0，发生异常！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>捕获异常</p><p>在 try中抛出异常，然后catch接住异常进行出现(不处理会编译错误)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数中</span></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">try</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> myException(<span class="string">&quot;flag == 0 &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">catch</span> (myException e)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="comment">// 处理异常代码</span></span><br><span class="line">    System.out.println(<span class="string">&quot;catch中捕获到异常！&quot;</span> );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561887319791.png" alt="1561887319791"></p></li></ul><h1>第八章 ： IO流</h1><h2 id="8-1-文件对象">8.1 文件对象</h2><ul><li><p>创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以当前项目路径(相对路径)创建对象  </span></span><br><span class="line">File f  = <span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>); </span><br></pre></td></tr></table></figure></li><li><p>对象常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.重命名文件 -- 不会改变f的name属性</span></span><br><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">&quot;hwh.txt&quot;</span>);</span><br><span class="line">f.renameTo(f1); <span class="comment">// f.getName() 还是test.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建文件 -- 存在不会重新创建</span></span><br><span class="line">File f2  = <span class="keyword">new</span> File(<span class="string">&quot;lt.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    f2.createNewFile(); <span class="comment">// 创建了lt.txt文件 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) <span class="comment">// 必须处理异常</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(e.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建文件夹:不会覆盖</span></span><br><span class="line">File f3  = <span class="keyword">new</span> File(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">f3.mkdir();  <span class="comment">// 创建了 son 文件夹 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.返回目录下文件 &amp; 文件夹</span></span><br><span class="line"><span class="comment">// 以String数组返回</span></span><br><span class="line">String[] str = f3.list();</span><br><span class="line">System.out.println(str[<span class="number">0</span>]); <span class="comment">// 输出目录下第一个文件名字</span></span><br><span class="line"><span class="comment">// 以File数组返回</span></span><br><span class="line">File[] fs = f.listFiles();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.其它方法</span></span><br><span class="line">f.exists();      <span class="comment">// 判断文件是否存在</span></span><br><span class="line">f.isDirectory(); <span class="comment">// 判断是文件夹</span></span><br><span class="line">f.isFile();      <span class="comment">// 判断是文件</span></span><br><span class="line">f.length();      <span class="comment">// 文件长度</span></span><br><span class="line">f.delete();      <span class="comment">// 删除文件</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="8-2-文件流">8.2 文件流</h2><p>当需要对文件进行 <em>读取/写入</em> 时，要建立文件 <em>输出/输入</em> 流。</p><p>:warning: 字符流可以一个字符一个字符也可以一行一行读取 ；字节流不可以。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">字节流</th><th style="text-align:center">字符流</th></tr></thead><tbody><tr><td style="text-align:center">按行读取</td><td style="text-align:center">× 一次读取</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">读取中文</td><td style="text-align:center">√  更方便</td><td style="text-align:center">√</td></tr></tbody></table><p><img src="http://stepimagewm.how2j.cn/5678.png" alt="æµå³ç³»å¾"></p><h3 id="字节流读写">字节流读写</h3><p>以 <u>字节（ASCII）</u> 形式读取和写入数据：<em>InputStream</em>字节输入流  ；<em>OutputStream</em>字节输出流 。</p><p>都是 <u>抽象</u> 类，不提供具体实现，可用子类 <em>FileInputStream</em> &amp; <em>FileOutStream</em> 对文件进行读写。</p><blockquote><p>[读]文件输入流：不用 <em>try catch</em> 捕获异常会报错</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 1.创建文件对象</span></span><br><span class="line">   File f = <span class="keyword">new</span> File(<span class="string">&quot;lt.txt&quot;</span>); <span class="comment">// lt.txt 内容：lt</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 2.创建输入流对象</span></span><br><span class="line">   FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 3.文件读出数据</span></span><br><span class="line">   <span class="keyword">byte</span>[] all =<span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) f.length()];</span><br><span class="line">   fis.read(all);</span><br><span class="line">   <span class="comment">// 打印读取到byte数组文件内容</span></span><br><span class="line">   <span class="comment">// 直接打印打印出的 ASCII码，强制转换成char字符</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">byte</span> b : all)</span><br><span class="line">       System.out.print((<span class="keyword">char</span>)b); <span class="comment">// 输出： lt</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.流关闭</span></span><br><span class="line">    fis.close();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Exception e)</span><br><span class="line"> &#123;</span><br><span class="line">     System.out.println(e);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>[写]文件输出流：最后查看 <em>hwh.txt</em> 内容被写入 <u><em>hwh</em></u></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 1.创建文件对象</span></span><br><span class="line">   File f = <span class="keyword">new</span> File(<span class="string">&quot;hwh.txt&quot;</span>); <span class="comment">// hwh.txt 内容为空</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 2.创建输入流对象</span></span><br><span class="line">   FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 3.数据写入文件</span></span><br><span class="line">   <span class="keyword">byte</span>[] all = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">104</span>,<span class="number">119</span>,<span class="number">104</span>&#125;; <span class="comment">// ASCII 104——&gt;h ; ASCII 119——&gt;w</span></span><br><span class="line">   fos.write(all);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.流关闭</span></span><br><span class="line">    fos.close();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Exception e)</span><br><span class="line"> &#123;</span><br><span class="line">     System.out.println(e);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="字符流读写">字符流读写</h3><p>以 <u>字符</u> 对文件进行读写，<em>Reader</em> 字符输入流；<em>Writer</em> 字符输出流 ，同前都为 <em>抽象类</em> 。</p><p>用子类，<em>FileReader &amp; FileWriter</em>、对文件进行字符读写。</p><blockquote><p>[读] <em>FileReader</em> : 注意是用字符数组 char[] 进行读写，而不是 String</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 1.创建文件对象</span></span><br><span class="line">   File f = <span class="keyword">new</span> File(<span class="string">&quot;lt.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 2.创建字符流对象</span></span><br><span class="line">   FileReader fr = <span class="keyword">new</span> FileReader(f);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 3.读取流对象内容</span></span><br><span class="line">   <span class="comment">// String str = null; // 错误，应该是char[]数组</span></span><br><span class="line">   <span class="keyword">char</span> cArr[] = <span class="keyword">new</span> <span class="keyword">char</span>[(<span class="keyword">int</span>)f.length()];</span><br><span class="line">   fr.read(cArr);</span><br><span class="line">   <span class="comment">// 打印读取到char数组文件内容</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">char</span> c : cArr)</span><br><span class="line">       System.out.print(c); <span class="comment">// 输出： lt</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 4.流关闭</span></span><br><span class="line">   fr.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">   System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>[写] <em>FileWriter</em> ：同上注意char[]数组。最好 <em>hwh.txt</em> 文件内容为： <u><em>hwh is a pig</em></u></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 1.创建文件对象</span></span><br><span class="line">   File f = <span class="keyword">new</span> File(<span class="string">&quot;hwh.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 2.创建输入流对象</span></span><br><span class="line">   FileWriter fw = <span class="keyword">new</span> FileWriter(f);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 3.读取流对象内容</span></span><br><span class="line">   String str = <span class="string">&quot;hwh is a  pig&quot;</span>; </span><br><span class="line">   <span class="keyword">char</span> cArr[] = str.toCharArray() ;</span><br><span class="line">   fw.write(cArr);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 4.流关闭</span></span><br><span class="line">   fw.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">   System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存流读写">缓存流读写</h3><p>缓冲流是字符流的子类 ，用于解决：字符流 &amp; 字节流 每读写1字节要IO操作。</p><blockquote><p>[读]<em>BufferedReader</em></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建文件对象</span></span><br><span class="line">    <span class="comment">// hwh.txt内容(空格表示换行)：黄  旺辉  不喜欢西瓜</span></span><br><span class="line">     File f = <span class="keyword">new</span> File(<span class="string">&quot;hwh.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建字符流对象</span></span><br><span class="line">     FileReader fr = <span class="keyword">new</span> FileReader(f);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建缓存流：必须建立在一个存在流之上</span></span><br><span class="line">     BufferedReader br = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 4.读取流对象内容:一次一行</span></span><br><span class="line">       <span class="comment">// 输出：黄  旺辉  不喜欢西瓜</span></span><br><span class="line">     <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//一次读取一行，返回Sting类型</span></span><br><span class="line">         <span class="comment">// 比前面；设置好char[] 、byte[] ,然后f.read()有所不同</span></span><br><span class="line">         <span class="comment">// 比后面：不用考虑中文 char[] 、byte[] 转换成Sting类型</span></span><br><span class="line">         String line = br.readLine();</span><br><span class="line">         <span class="keyword">if</span>(line == <span class="keyword">null</span>)  <span class="keyword">break</span>;</span><br><span class="line">         System.out.println(line);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.流关闭</span></span><br><span class="line">     br.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">     System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>[写] <em>PrintWriter</em> ，基本同上差不多步骤，简略说明下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...基本同上</span></span><br><span class="line"><span class="comment">// 写操作，pw是PrintWriter对象，调用println方法读写即可。</span></span><br><span class="line">pw.println(<span class="string">&quot;刘婷是傻子&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="数据流-对象流">数据流&amp;对象流</h3><p>数据流 &amp; 对象流 都是字节流子类，建立数据流 &amp; 字符流必须要在一个存在的字节流之上。</p><blockquote><p>数据流：主要可以进行格式化  <u><em>顺序</em></u>  读写，有 <em>FileInputStream 、FileOutputStream</em></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 1.创建文件对象</span></span><br><span class="line">     File f = <span class="keyword">new</span> File(<span class="string">&quot;hwh.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2.创建字节流对象</span></span><br><span class="line">     FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">     FileInputStream  fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 3.创建数据流：必须建立在一个[字节流]之上</span></span><br><span class="line">     DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(fos);</span><br><span class="line">     DataInputStream  dis = <span class="keyword">new</span> DataInputStream(fis);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 4.数据流顺序写</span></span><br><span class="line">     dos.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">     dos.writeInt(<span class="number">1</span>);</span><br><span class="line">     dos.writeUTF(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 5.数据流顺序读</span></span><br><span class="line">     <span class="keyword">boolean</span> b = dis.readBoolean();</span><br><span class="line">     <span class="keyword">int</span> i = dis.readInt();</span><br><span class="line">     String s = dis.readUTF();</span><br><span class="line">       <span class="comment">// 输出：顺序读到：bool:true ; int：1；String：yes</span></span><br><span class="line">     System.out.format(<span class="string">&quot;顺序读到：bool:%b ; int：%d；String：%s &quot;</span>,b,i,s);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 6.流关闭</span></span><br><span class="line">     dos.close(); dis.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">     System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对象流：指的是可以直接把一个对象以流的形式传输给其他的介质，比如硬盘 。暂时不详写用    到再说吧：<a href="http://how2j.cn/k/io/io-objectstream/351.html#nowhere">对象流</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数中</span></span><br></pre></td></tr></table></figure><h2 id="8-3-中文读写问题">8.3 中文读写问题</h2><ul><li><p>常用编码格式</p><ul><li><em>IS0-8859-1、ASCII</em> ：数字 &amp; 西欧字母 ，<strong>IS0-8859-1包含 ASCII</strong>，<strong>1</strong>字节。</li><li><em>GBK、GB2312、BIG5</em>：中文简繁；中文 ；繁体中文，<strong>2</strong>字节 。</li><li><em>Unicode</em> ：统一码，万国码，字母、数字、中文都为 <strong>4</strong> 字节编码。</li><li><em>UTF-8</em>：对 Uincode 进行的一种<em>减肥子编码</em> ，字母、数字：<strong>1</strong>字节 ；中文：<strong>3</strong> 字节。</li></ul><p>特别的 <strong>ANSI</strong>  ：表示本地编码，中文OS则选用 GBK、英文 IS0。</p></li><li><p>中文编码读写</p><ul><li><p>写</p><ul><li>在记事本等中直接写中文：采用本地编码 ANSI保存。</li><li>在 java中写中文：执行后都会变为 Unicode（UTF-8?），然后字符流、字节流读写？</li></ul></li><li><p>读</p><blockquote><p>读：字节流 &amp; 字符流读文本中中文，字符流比较麻烦略。</p></blockquote><p>将<em>字节流</em>数组转换成 <em>Sting</em> 和对应字符编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 1.创建文件对象</span></span><br><span class="line">     File f = <span class="keyword">new</span> File(<span class="string">&quot;hwh.txt&quot;</span>); <span class="comment">// hwh.txt内容：黄</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2.创建输入流对象</span></span><br><span class="line">     FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 3.读取流对象内容</span></span><br><span class="line">     <span class="keyword">byte</span>[] all = <span class="keyword">new</span>  <span class="keyword">byte</span>[(<span class="keyword">int</span>)f.length()];</span><br><span class="line">     fis.read(all);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// [测试] 直接输出 byte数组</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">byte</span> b : all)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">            byte 1字节，直接打印对应二进制整数：-23 -69 -124(uft-8编码中文3字节)  </span></span><br><span class="line"><span class="comment">            为了打印出16进制，先转换成int --&gt; 再调用toHexString方法</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          System.out.println(b);</span><br><span class="line">          <span class="keyword">int</span> i = b;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             类型转换，输出：ffffffe9、ffffffbb、ffffff84</span></span><br><span class="line"><span class="comment">             对应-23 -69 -124 补码：e9、bb、84(int4字节，byte1字节，补码前3字节添1不看)</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          System.out.println(Integer.toHexString(i));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 4.类型转换：把字节数组转换成 Sting UTF-8编码</span></span><br><span class="line">       <span class="comment">// 类型转换第一种：new String装箱，= 自动拆箱</span></span><br><span class="line">       <span class="comment">// 第二种转换：调用对象类型都有的.toString方法：all.toString()</span></span><br><span class="line">     String str = <span class="keyword">new</span> String(all,<span class="string">&quot;UTF-8&quot;</span>); </span><br><span class="line">     System.out.println(str); <span class="comment">// 输出：黄</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 5.流关闭</span></span><br><span class="line">     fis.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">     System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1>第九章：集合框架</h1><p>常用集合框架有： <em>ArrayList、LinkedList、HashMap、HashSet</em> 等。</p><p><em>Tips：</em></p><ol><li><em>System.out.println(集合类型对象)</em>：可以直接装箱成<em>String</em>类型，然后拆箱输出，如[1,2,3]。</li></ol><h2 id="9-1-ArrayList">9.1 <em>ArrayList</em></h2><blockquote><p><em>ArrayList</em> 是实现了 <em>List</em> 接口子类。相比常规数组，容量会自动增长，是一个<em>动态数组</em>（非链表）。</p></blockquote><ul><li><p>声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">ArrayList array = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure></li><li><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. add -- 未泛型指定可添加不同类型对象</span></span><br><span class="line">Hero VN = <span class="keyword">new</span> Hero();</span><br><span class="line">array.add(VN); <span class="comment">// Hero类型对象</span></span><br><span class="line">array.add(<span class="string">&quot;pentaKill&quot;</span>); <span class="comment">// Sting类型对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.contains：判断对象是否存在</span></span><br><span class="line">System.out.println(<span class="string">&quot;VN对象是否存在：&quot;</span> + array.contains(VN));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.get ：获取指定位置对象 -- 从0计数</span></span><br><span class="line">System.out.println(<span class="string">&quot;第1个位置对象：&quot;</span> + array.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.indexof：判断对象所处位置</span></span><br><span class="line">System.out.println(<span class="string">&quot;VN所处位置：&quot;</span> + array.indexOf(VN));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.remove：可根据位置或者对象名删除</span></span><br><span class="line">array.remove(VN);</span><br><span class="line">array.remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.set: 只能替换指定位置对象,不能设置新元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;替换第1个位置对象：&quot;</span> + array.set(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.size：获取数组已存元素个数（大小）</span></span><br><span class="line">System.out.println(<span class="string">&quot;替换第1个位置对象：&quot;</span> + array.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.addAll:添加另外一个容器所有对象</span></span><br><span class="line">ArrayList array1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">array.addAll(array1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.toArray :ArrayList对象转换为数组</span></span><br><span class="line"><span class="comment">// 加了toSting无变化，因为返回Objiect数组</span></span><br><span class="line">System.out.println(<span class="string">&quot;转换为数组：&quot;</span> + array.toArray().toString()); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 10.clear：清空</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562205646731.png" alt="1562205646731"></p></li></ul><h2 id="9-2-LinkedList">9.2 <em>LinkedList</em></h2><blockquote><p><em>LinkedList</em> &amp; <em>ArrayList</em> 都实现了 <em>List</em>接口，都有 <em>add 、remove 、contains</em> 等方法。</p><p>但同时，<em>LinkedList</em> 还实现了 <em>Queue</em>（队列） 、<em>Deque</em>（双向队列）接口。</p></blockquote><ul><li><p>声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkList</span></span><br><span class="line"><span class="comment">// 普通声明</span></span><br><span class="line">LinkedList l = <span class="keyword">new</span> LinkedList();</span><br><span class="line"><span class="comment">// 多态：声明双端队列</span></span><br><span class="line">Deque d = <span class="keyword">new</span> LinkedList();</span><br><span class="line"><span class="comment">// 多态：声明队列</span></span><br><span class="line">Queue q = <span class="keyword">new</span> LinkedList();</span><br></pre></td></tr></table></figure></li><li><p>常用方法</p><blockquote><p><em>Deque</em> 暂未补充。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1. LinkList 在头部、尾部进行操作 */</span></span><br><span class="line"><span class="comment">// [查看]链表头尾元素</span></span><br><span class="line">l.getFirst(); l.getLast();</span><br><span class="line"><span class="comment">// [删除]链表头尾元素</span></span><br><span class="line">l.removeFirst(); l.removeLast();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. Queue 在头部、尾部进行操作 */</span></span><br><span class="line"><span class="comment">// [添加]队列尾元素 -- q.add?用List接口方法一样吗？</span></span><br><span class="line">q.offer(<span class="number">1</span>); q.offer(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// [查看]链表头尾元素</span></span><br><span class="line">q.peek();</span><br><span class="line"><span class="comment">// [取出]链表头尾元素，取出后会被删除</span></span><br><span class="line">q.poll(); </span><br></pre></td></tr></table></figure></li></ul><h2 id="9-3-HashMap">9.3 HashMap</h2><blockquote><p><em>HashMap</em> 可理解为一个字典，键值不能重复，不同键元素可重复（相同）。</p></blockquote><ul><li><p>声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line">HashMap dic = <span class="keyword">new</span> HashMap(); <span class="comment">// 也可泛型指定 Key ：Value 类型</span></span><br></pre></td></tr></table></figure></li><li><p>常用方法</p><blockquote><p>未详细列出，详细需查看：<a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/HashSet.html">HashMap官方文档</a>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用方法</span></span><br><span class="line"><span class="comment">// 1.put -- 插入数据</span></span><br><span class="line">dic.put(<span class="number">1</span>, <span class="string">&quot;啊我是1&quot;</span>); dic.put(<span class="number">2</span>, <span class="string">&quot;啊我竟然是2&quot;</span>); dic.put(<span class="number">3</span>, <span class="string">&quot;啊哈哈哈我是3&quot;</span>);</span><br><span class="line"><span class="comment">// 2.get -- 获取数据</span></span><br><span class="line">System.out.println(dic.get(<span class="number">2</span>)); <span class="comment">// 输出：啊我竟然是2</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="9-4-HashSet">9.4 HashSet</h2><blockquote><p><em>HashSet</em> 没有键值，只保存元素。且不提供 <em>get(index)</em> 方法读取指定位置元素，遍历可利用迭代器。</p></blockquote><p>类似的还有：<em>LinkedHashSet &amp; TreeSet</em> ，暂略。</p><ul><li><p>声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;  </span><br><span class="line"></span><br><span class="line">HashSet hs = <span class="keyword">new</span> HashSet();</span><br></pre></td></tr></table></figure></li><li><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用方法</span></span><br><span class="line"><span class="comment">// 1.add -- 插入数据</span></span><br><span class="line">hs.add(<span class="number">1</span>); hs.add(<span class="keyword">true</span>); hs.add(<span class="string">&quot;一&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.可直接打印所有数据，不是按添加顺序</span></span><br><span class="line">System.out.println(hs);  <span class="comment">// 输出：[一, 1, true]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.[迭代遍历] 由于未提供get方法，不能普通for循环，但可以迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span>(Iterator it = hs.iterator();it.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(it.next()); <span class="comment">// 输出：一 1 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="9-5-Collections类">9.5 Collections类</h2><blockquote><p><em>Collections</em> 类是专门用于处理集合类型的工具类，包含一系列诸如：<em>排序、反转、混淆、交换</em> 等方法。</p></blockquote><p>类似于：<em>Arrays</em> 是数组的工具类。但是，只能处理实现了 <em>List</em> 接口类。<a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Collections.html"><em>Collections</em> 类官方文档</a></p><ul><li><p>基本使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line">LinkedList&lt;Integer&gt; ll = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(); <span class="comment">// [注]：不是int类型</span></span><br><span class="line">ll.add(<span class="number">1</span>) ;  ll.add(<span class="number">2</span>) ;  ll.add(<span class="number">3</span>) ; ll.add(<span class="number">4</span>) ; ll.add(<span class="number">5</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用方法：更多查看官方文档</span></span><br><span class="line"><span class="comment">// 1.混淆</span></span><br><span class="line">Collections.shuffle(ll);  </span><br><span class="line"><span class="comment">// 2.排序</span></span><br><span class="line">Collections.sort(ll); System.out.println(ll); <span class="comment">// 输出：[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// 3.反转</span></span><br><span class="line">Collections.reverse(ll);</span><br><span class="line"><span class="comment">// 4.交换</span></span><br><span class="line">Collections.swap(ll,<span class="number">0</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure></li><li><p>比较器：<em>Comparable</em></p><blockquote><p><em>Comparable</em> 是一个接口，通过覆写实现它的 <em>compare</em> 方法，来比较非数值类型的 <em>sort</em> 排序等。</p></blockquote><p>如下，实现了通过比较 <em>Hero</em>类 <em>HP</em>属性来实现排序。</p><ul><li><p>在<em>Hero</em>类中</p><blockquote><p>也可在 <em>Hero</em>类中在覆写 <em>compareTo</em>方法，这样自带比较信息，而不用在主函数覆写<em>Comparator</em> 接口的 <em>compare</em>方法。</p></blockquote><p>:warning: 在 <em>Hero</em>类中覆写了 <em>toSting</em>方法，这样打印<em>Hero</em>对象不显示：<u>Hero@十六进制地址形式</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    String name; </span><br><span class="line">    <span class="keyword">int</span> HP;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法：构造函数</span></span><br><span class="line">    Hero(String name ,<span class="keyword">int</span> hp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.HP = hp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法：类中覆写函数toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;英雄名：&quot;</span> + name + <span class="string">&quot; 血量：&quot;</span> + HP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在主函数中</p><blockquote><p><em>Q : System.out.println(ll);</em> 如何实现打印出集合？</p><p>A:  首先，打印 <em>ll</em> 会将集合每个<em>Hero</em>对象装箱成<em>Sting</em>，然后调用 .<em>toString</em>()方法进行拆箱；</p><p>​     由于<em>Hero</em>类中覆写了 .<em>toString</em>()方法，此时返回的不是默认<u><em>Hero</em>@十六进制地址形式</u> 。</p><p>​     最后结合所有对象.toString() ,转换成<em>String</em>类型[…,…,…,…]打印出来。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.准备好一个集合类型 LinkList，插入十个Hero类型对象并设置不同随机hp</span></span><br><span class="line">LinkedList&lt;Hero&gt; heros = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">     String name = <span class="string">&quot;hero&quot;</span>+i;</span><br><span class="line">     <span class="keyword">int</span> hp = (<span class="keyword">int</span>)(Math.random()* <span class="number">1000</span>);</span><br><span class="line">     heros.add(<span class="keyword">new</span> Hero(name,hp)); <span class="comment">// 带int参数构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(heros);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.[匿名类]覆写比较器compare方法（比较规则）</span></span><br><span class="line">Comparator&lt;Hero&gt; comparable = <span class="keyword">new</span> Comparator&lt;Hero&gt;() </span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Hero h1,Hero h2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(h1.HP &gt; h2.HP)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 注意，别写0</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.工具栏Collections进行排序</span></span><br><span class="line">Collections.sort(heros,comparable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.直接打印输出查看</span></span><br><span class="line">System.out.println(heros);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="9-x-迭代器初使用">9.x 迭代器初使用</h2><blockquote><p>根据学习C++经验，迭代器要和这些集合类型如  <em>ArrayList</em> 结合才能用。</p></blockquote><ul><li><p>声明一个集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 List接口多态实现 </span></span><br><span class="line">List array = <span class="keyword">new</span> ArrayList();</span><br><span class="line">array.add(<span class="number">12345</span>); array.add(<span class="string">&quot;上山打老虎&quot;</span>); array.add(<span class="keyword">new</span> Hero());</span><br></pre></td></tr></table></figure></li><li><p>普通for循环遍历集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size();i++)</span><br><span class="line">    System.out.println(array.get(i));</span><br></pre></td></tr></table></figure></li><li><p>迭代for循环遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hasNext - 判断当前是否有下一个元素，有返回true</span></span><br><span class="line"><span class="comment">// next - 返回当前元素类型。</span></span><br><span class="line"><span class="keyword">for</span> (Iterator it = array.iterator();it.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">     System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562208720076.png" alt="1562208720076"></p></li></ul><h1>第十章：泛型</h1><h2 id="10-1-泛型分类及作用">10.1 泛型分类及作用</h2><ul><li><p>泛型集合</p><blockquote><p>通过，泛型集合指定集合接受类型，如<Hero>只能接受 <u><em>Hero</em>对象及其子类</u></p></blockquote><p>如下，声明了一个非泛型对象数组集合，可添加不同对象，但也许我们只想添加<em>Hero</em>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList heros = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">heros.add(<span class="keyword">new</span> Hero());</span><br><span class="line">heros.add(<span class="keyword">new</span> Item());<span class="comment">// 此时泛型还可以添加无关的 Item对象</span></span><br></pre></td></tr></table></figure><p>通过泛型指定只能添加 <u><em>Hero</em>对象及其子类</u>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line"></span><br><span class="line">heros.add(<span class="keyword">new</span> Hero());   </span><br><span class="line">heros.add(<span class="keyword">new</span> ADHero()); <span class="comment">// 子类也可以添加</span></span><br><span class="line">heros.add(<span class="keyword">new</span> Item());   <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure></li><li><p>泛型方法 &amp; 泛型类 &amp; 泛型接口</p><blockquote><p>这些泛型，可以接受不同参数实现代码精简。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类，类中定义了非泛型方法&amp;泛型方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.[非泛型方法] 因为用的是类定义泛型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">test</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.[泛型方法] 这才是泛型方法，&lt;T&gt;声明在返回类型前</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.[静态方法 &amp; 编译错误]下面编译错误，静态类不能用类定义的泛型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.[静态泛型方法] 用自己定义的泛型就不会出错</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型接口类似泛型类声明</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterDemo</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型转型</p><blockquote><p>暂时记住结论。</p></blockquote><p>我们知道，子类是可以转换成父类（多态），但是子类泛型和父类泛型不能互转！</p></li></ul><h2 id="10-2-泛型通配符">10.2 泛型通配符</h2><ul><li><p>通配符作用</p><ul><li><em>&lt; ? extends 类型名&gt;</em> ：只能取 <em>类型名、object</em>，不能插入；</li><li><em>&lt;?&gt;</em> : 只能取<em>object</em> ，不能插入；</li><li><em>&lt; ? super 类型名&gt;</em> ： 只能取<em>object</em> ，能插入满足通配符匹配所有类型的子类。</li></ul></li><li><p><em>&lt; ? extends 类型名&gt;</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 因为不能插入，所以先定义一个&lt;APHero&gt;泛型集合插入一些数据</span></span><br><span class="line">ArrayList&lt;APHero&gt; apHeroList = <span class="keyword">new</span> ArrayList&lt;APHero&gt;();</span><br><span class="line">apHeroList.add(<span class="keyword">new</span> APHero());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.定义&lt;? extends&gt;泛型集合：指向上面泛型集合</span></span><br><span class="line"> ArrayList&lt;? extends Hero&gt; heroList = apHeroList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.测试</span></span><br><span class="line"><span class="comment">// [取，可行] 因为&lt;? extends&gt;代表保存的都是 Hero及其子类，取出来都可以转换成Hero类型</span></span><br><span class="line">Hero h = herolist.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// [插，不可] 因为&lt;? extends&gt;可以是Hero及其子类，但只能确定为其中一个。</span></span><br><span class="line"><span class="comment">//  比如， &lt;? extends&gt;已经代表是&lt;Hero&gt;,根据泛型集合限定插入类型，此时插入APHero类型会失败。</span></span><br><span class="line">heroList.add(<span class="keyword">new</span> ADHero()); <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure></li><li><p><em>&lt;?&gt;</em></p><p>基本同*&lt; ? extends 类型名&gt;* ，由于少了 <em>extends</em> ，代表可以是指向任意泛型对象，而非某类及其子类。</p><p>但是，取数据也对应只能是 <em>Object</em> 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...同前</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.测试</span></span><br><span class="line"><span class="comment">// [取，可行]只能为object类型</span></span><br><span class="line">Object o = generalList.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// [插，不可]</span></span><br><span class="line">generalList.add(<span class="keyword">new</span> Item());  generalList.add(<span class="keyword">new</span> Hero()); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure></li><li><p><em>&lt; ? super 对象名&gt;</em></p><p>和*&lt; ? extends 对象名&gt;* 对象名不同，*&lt; ? super 对象名&gt;*代表可指向 对象名及父类。</p><p>如：<em>&lt; ? super Hero&gt;</em> ，代表可指向 <em>Hero</em>及其父类<em>Object</em> 。所以：</p><ul><li>可插入：<em>Hero</em> &amp; 子类<em>ADHero</em>等（父类泛型可以插入子类对象）</li><li>不可取：无法将父类泛型转换成子类（向下转换），<u>但是不可以像*&lt;?&gt;<em>取出来是</em>Object*类型吗？<strong>可行</strong></u></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.定义&lt;? super&gt;泛型</span></span><br><span class="line">ArrayList&lt;? <span class="keyword">super</span> Hero&gt; heroList = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.测试</span></span><br><span class="line"><span class="comment">// [取，不可] 无法向下转换，父类转换成子类</span></span><br><span class="line">Hero h = heroList.get(<span class="number">0</span>);  <span class="comment">// 不可，编译错误</span></span><br><span class="line">Object O = heroList.get(<span class="number">0</span>); <span class="comment">// 可行</span></span><br><span class="line"><span class="comment">// [插，可行]</span></span><br><span class="line">heroList.add(<span class="keyword">new</span> Hero()); </span><br><span class="line">heroList.add(<span class="keyword">new</span> ADHero()); <span class="comment">// 子类可插入</span></span><br></pre></td></tr></table></figure></li><li><p>通配符取出、插入总结</p><ul><li><p>取出</p><blockquote><p>无论是何种通配符，取出是只要满足 <u>向上转换</u> 规则即可。</p></blockquote><p>如：<em>&lt;? extends Hero&gt;</em> ,是 <em>Hero</em>及子类，只要<u>转换的对象类型是<strong>通配符匹配所有类型的父类（或同级）</strong></u>，即可插入。</p><p>显然，<em>Hero</em> 是*&lt;? extends Hero&gt;<em>所有类型父类，所以可以取出转换成</em>Hero*：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;? extends Hero&gt; heroList = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line"></span><br><span class="line">Hero h = heroList.get(<span class="number">0</span>); <span class="comment">// 可行</span></span><br></pre></td></tr></table></figure><p>但是， <? super Hero> & <?>  ，<em>Hero</em>不满足通配符所代表的所有类型类型父类，所以出错；</p><p>以此推论，向上转换成<em>Object</em>则行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;? <span class="keyword">super</span> Hero&gt; heroList = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line"></span><br><span class="line">Hero h = heroList.get(<span class="number">0</span>);  <span class="comment">// 编译错误</span></span><br><span class="line">Object O = heroList.get(<span class="number">0</span>); <span class="comment">// 可行</span></span><br></pre></td></tr></table></figure></li><li><p>插入</p><blockquote><p>插入即&quot;向下插入&quot;，插入对象是<strong>通配符匹配所有类型的子类（或同级）</strong>。</p></blockquote><p>如：<em><? extends Hero>* & *<?></em> ,它们的子类是不确定的，所以不能插入。</p><p>而：<em>&lt;? extends Hero&gt;</em> ，<em>ADHero、Hero</em> 显然满足符合<u>该通配符匹配的所有类型子类（同级）</u>，故可以插入。</p></li></ul></li></ul><h1>第十一章：<em>Lambda</em></h1><h2 id="11-1-匿名类">11.1 匿名类</h2><ul><li><p>使用时机</p><p>在<em>new</em>创建：一个类对象 、 一个接口子类对象、一个抽象类子类对象时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类|接口  名字 =  <span class="keyword">new</span> 类|接口()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    重写方法;</span><br><span class="line">&#125;；  </span><br></pre></td></tr></table></figure><p>如，下面 <em>new Runnable</em>接口实现了一个匿名类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runnable是一个接口</span></span><br><span class="line">Runnable x = <span class="keyword">new</span> Runnable()</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>我们知道，接口是不能被实例化的，上述代码实际是这么一个实现过程：</p><ul><li>{}相当于一个继承了<em>Runnable</em>接口  <strong>BUT</strong>  匿名的类实现了<em>Runnable</em>接口方法；</li><li>该匿名类则可以通过<u>多态</u> 转换成父类接口<em>Runnable</em>类型。</li></ul></li><li><p>总结</p><p>在实际开发中，我们可以看到有方法，用<u>抽象类、接口作参数实现多态</u>。</p><p>而我们实际需要的是一个子类对象，如果该方法仅仅调用 <strong>1</strong> 次，用匿名类简化格式，<u>不必特地实现一个类继承该接口、抽象类</u>。</p></li></ul><h2 id="11-2-Lambda-基本用法">11.2 <em>Lambda</em> 基本用法</h2><ul><li><p><em>Lambda</em> 语法</p><p>在 java中，其表达式格式语法一般是：<code>(parameters) -&gt; &#123; statements; &#125;</code> 。</p><p>在满足一定条件下，还可以进一步简写：</p><ul><li><em>参数类型可选</em> ：不需要声明参数类型，编译器可以统一识别参数值；</li><li><em>只有一个参数</em> ： 参数 ()可选</li><li><em>主体{}只有一条语句</em> ：此时 <em>return</em> 关键字 &amp; {} ，可不写。注意 ！<ul><li>主体{} 不省略时，哪怕只有一条语句，函数有返回值<em>return</em>关键字不可省！</li><li>主体{} 省略时，<em>return</em> 也必须省略！</li></ul></li></ul><p><em>以下是一些简单示例：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5  </span></span><br><span class="line">() -&gt; <span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">x -&gt; <span class="number">2</span> * x  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值  </span></span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 4. 接收2个int型整数,返回他们的和  </span></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure></li><li><p><em>Lambda</em> 用于简化匿名类</p><p>在 <em>9.5 Collections类</em>  一节，我们用 <em>Collections.sort(heros，Comparator)</em> 静态方法去比较 <em>Hero</em> 的HP属性，进而按HP大小打印<em>heros</em>数组中各<em>Hero</em>对象信息。</p><p>我们用到匿名类覆写实现了 <em>Comparator</em> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.[匿名类]覆写比较器compare方法（比较规则）</span></span><br><span class="line">Comparator&lt;Hero&gt; comparable = <span class="keyword">new</span> Comparator&lt;Hero&gt;() </span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Hero h1,Hero h2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(h1.HP &gt; h2.HP)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 注意，别写0</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Collections.sort(heros,comparable);</span><br><span class="line">System.out.println(heros);</span><br></pre></td></tr></table></figure><p>这里可以将匿名类简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Hero&gt; comparable = (Hero h1,Hero h2) -&gt; &#123; <span class="keyword">return</span>  h1.HP &gt; h2.HP ? <span class="number">1</span>:<span class="number">0</span>;&#125;;</span><br></pre></td></tr></table></figure><p>还可以进一步简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.去掉参数类型 </span></span><br><span class="line"><span class="comment">// 2.去掉&#123;&#125;(只有一条语句) </span></span><br><span class="line"><span class="comment">// 3.去掉return（只有一条语句 + 没有&#123;&#125;）</span></span><br><span class="line"></span><br><span class="line">Comparator&lt;Hero&gt; comparable = (h1,h2) -&gt; h1.HP &gt; h2.HP ? <span class="number">1</span>:<span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p><em>Lambda</em> 用于把方法作参数</p><p>在上面我们通过匿名类 或者 <em>lambda</em>简化，最终创建了<em>Comparator</em>对象comparable，然后调用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Hero&gt; comparable = (h1,h2) -&gt; h1.HP &gt; h2.HP ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">Collections.sort(heros,comparable);</span><br></pre></td></tr></table></figure><p>我们可以更进一步，直接传递 <em>lambda</em> 表达式作为参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(heros,(h1,h2) -&gt;  h1.HP &gt; h2.HP ? <span class="number">1</span>:<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>最终上面代码被成功简化成一行。</p><p>当然还有其它匿名方法例子，实现遍历输出：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(<span class="meta">@NotNull</span> java.util.function.Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个集合</span></span><br><span class="line">ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">array.add(<span class="number">4</span>);array.add(<span class="number">5</span>);array.add(<span class="number">3</span>);array.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach方法参数有一个Cosumer接口，通过lambda表达式创建一个继承Cosumer接口匿名对象</span></span><br><span class="line">array.forEach(n -&gt; System.out.println(n));</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-3-Lambda-聚合操作">11.3 <em>Lambda</em> 聚合操作</h2><p>在上面我们介绍了，如果方法参数是一个接口或者抽象类等，可利用<em>Lambda</em> 表达式作为方法参数。表达式创建一个继承该接口 |抽象类的匿名类，这种方法也叫做 <strong>匿名方法</strong>。</p><p>我们可以用同时使用多个匿名方法，实现聚合操作。</p><ul><li><p>实例介绍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Hero类型集合，准备多个对象指定HP</span></span><br><span class="line">ArrayList&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    String name = <span class="string">&quot;hero&quot;</span>+i;</span><br><span class="line">    <span class="keyword">int</span> hp = (<span class="keyword">int</span>)(Math.random()* <span class="number">1000</span>);</span><br><span class="line">    heros.add(<span class="keyword">new</span> Hero(name,hp)); <span class="comment">// 带int参数构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heros对象有多个方法，进行聚合操作</span></span><br><span class="line">heros</span><br><span class="line">      .stream()</span><br><span class="line">      .sorted((h1,h2) -&gt; h1.HP &gt; h2.HP ? <span class="number">1</span>:-<span class="number">1</span>) <span class="comment">// 比较器接口 </span></span><br><span class="line">      .forEach(n -&gt; System.out.println(n)); <span class="comment">// Cosumer接口</span></span><br></pre></td></tr></table></figure></li><li><p>更多操作</p><blockquote><p>实例参考，具体待用到补充：<a href="http://how2j.cn/k/lambda/lambda-stream/700.html#nowhere">聚合操作</a></p></blockquote><p>以 <u>源为 <em>List</em></u> 为例：</p><ul><li>中间操作方法<ul><li><em>filter</em> ：匹配</li><li><em>distinct</em>： 去除重复(根据equals判断)</li><li><em>sorted</em> ：自然排序</li><li><em>sorted(Comparator<T>)</em> ：指定排序</li><li><em>limit</em> ：保留</li><li><em>skip</em> ：忽略</li></ul></li><li>结束操作方法<ul><li><em>forEach()</em>：遍历每个元素</li><li><em>toArray()</em> ：转换为数组</li><li><em>min(Comparator<T>)</em> ： 取最小的元素</li><li><em>max(Comparator<T>)</em>： 取最大的元素</li><li><em>count()</em>： 总数</li><li><em>findFirst()</em>：第一个元素</li></ul></li></ul></li></ul><h1>第十二章：多线程</h1><h2 id="12-0-基本知识">12.0 基本知识</h2><h4 id="线程与进程介绍">线程与进程介绍</h4><ul><li><p><strong>什么是进程？</strong></p><blockquote><p>打开任务管理管理器，可以看到很多【正在运行】的应用程序，这就是对应进程。</p></blockquote><ul><li>正在运行的应用程序；</li><li>系统分配和调用资源的基本单位</li></ul></li><li><p><strong>线程？单线程与多线程？</strong></p><ul><li><p><strong>线程</strong>：是进程的单个顺序控制流，是执行的最小单位（执行路径）</p></li><li><p><strong>单线程</strong>：<em>e.g. 记事本程序</em></p><p>一个进程如果只有一条执行路径，则为单线程</p></li><li><p><strong>多线程</strong>：<em>e.g. 扫雷程序：计时、玩家扫雷</em></p><p>一个进程如果有多条执行路径，则为多线程程序</p></li></ul></li><li><p><strong>子线程设置名字 &amp; 源码分析</strong></p><ul><li><p><code>MyThread.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 必须要定义这个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 调用父类（Thread）构造函数（一个参数的方法）</span></span><br><span class="line">    <span class="comment">// 调用顺序看下截图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/27/maMfQbDJkK3LpnY.png" alt="image-20210427235215262"></p></li><li><p><code>MyThreadDemo.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima_01;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    方式1：继承Thread类</span></span><br><span class="line"><span class="comment">        1:定义一个类MyThread继承Thread类</span></span><br><span class="line"><span class="comment">        2:在MyThread类中重写run()方法</span></span><br><span class="line"><span class="comment">        3:创建MyThread类的对象</span></span><br><span class="line"><span class="comment">        4:启动线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread my1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread my2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        my1.setName(<span class="string">&quot;11&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        my1.run();</span></span><br><span class="line"><span class="comment">//        my2.run();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//void start​() 导致此线程开始执行; Java虚拟机调用此线程的run方法</span></span><br><span class="line">        my1.start();</span><br><span class="line">        my2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>获取Main方法进程名</strong></p><ul><li><p>不能使用<u>Thread对象方法</u>：getName()，因为没继承Thread</p></li><li><p>应该用<u>Thread静态方法</u>，<code>Thread.currentThread</code> 获取当前执行对象, 再调用<code>getName()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String mainTreadName = Thread.currentThread.getName()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="线程调度">线程调度</h4><p>线程主要有两种调度【模型】：</p><ul><li><p>**分时调度模型：**所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</p></li><li><p>**抢占式调度模型：**优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，<u>优先级高的线程</u>获取的 CPU 时间片相对多一些</p></li></ul><p>Java使用的是<u>抢占式调度模型</u> ，具有<strong>随机性</strong>。</p><ul><li><p><strong>随机性</strong> ：因为CPU在某个时刻只能执行一条命令，线程只有得到CPU时间片（使用权），才可以执行。而抢占式调度模型多线程执行具有随机性，谁抢到CPU是不确定的。</p></li><li><p><strong>线程优先级：</strong> 通过设置线程优先级，可以让某个线程得到CPU的<strong>概率</strong>变大。（但不意味着是绝对优先，<u>只是概率增大</u>）</p><table><thead><tr><th style="text-align:center"><strong>方法名</strong></th><th style="text-align:center"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:center">final int getPriority()</td><td style="text-align:center">返回此线程的优先级</td></tr><tr><td style="text-align:center">final void setPriority(int newPriority)</td><td style="text-align:center">更改此线程的优先级 线程默认优先级是5；线程优先级的范围1-10</td></tr></tbody></table></li></ul><h4 id="线程生命周期">线程生命周期</h4><blockquote><p>:notebook: 面试重点！</p></blockquote><p><img src="https://i.loli.net/2021/04/28/VCN8xckXHMdrl1R.png" alt="image-20210428164922743"></p><ul><li><strong>变为阻塞</strong> ：是由 <u>运行</u> 状态进入的， 且是被<code>sleep()</code> 一些阻塞式方法导致的</li><li><strong>变为就绪：</strong> 可能是 <u>新建</u> 状态获得资源，也可能是 <u>运行</u> 状态进入</li></ul><h2 id="12-1-多线程快速入门">12.1 多线程快速入门</h2><h3 id="不使用多线程">不使用多线程</h3><p>下面有一个 <em>Hero</em> 类，实现了<em>attack</em> 方法，用于模拟游戏人物进行攻击：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    String name; </span><br><span class="line">    <span class="keyword">int</span> HP;</span><br><span class="line"></span><br><span class="line">    Hero(String name ,<span class="keyword">int</span> hp) </span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">this</span>.name = name;  <span class="keyword">this</span>.HP = hp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数：攻击</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">attack</span><span class="params">(Hero h,<span class="keyword">int</span> damage)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        h.HP -= damage;</span><br><span class="line">        System.out.format(<span class="string">&quot;[%s]正在攻击[%s],[%s]血量为:[%d]..\n&quot;</span>, name,h.name,h.name,h.HP);</span><br><span class="line">        <span class="keyword">if</span> (h.isDead())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(h.name + <span class="string">&quot;--已经挂了！\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数：判断是否死亡</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &gt;= HP ? <span class="keyword">true</span> :<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在主函数中，实例化游戏人物<em>VN，garren</em> 各自分别攻击 <em>teemo、bh</em> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Hero VN = <span class="keyword">new</span> Hero(<span class="string">&quot;VN&quot;</span>,<span class="number">2500</span>);</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">&quot;teemo&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        Hero gareen = <span class="keyword">new</span> Hero(<span class="string">&quot;gareen&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Hero bh = <span class="keyword">new</span> Hero(<span class="string">&quot;bh&quot;</span>,<span class="number">2800</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 英雄开始攻击</span></span><br><span class="line">        <span class="keyword">while</span> (!teemo.isDead())</span><br><span class="line">            VN.attack(teemo,<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">while</span> (!bh.isDead())</span><br><span class="line">            gareen.attack(bh,<span class="number">100</span>);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为都在主函数中的主线程中，显然应该先是<em>VN</em> 攻击，然后<em>garren</em> 进行攻击，这样一种串行方式。</p><p>但是实际游戏中，<em>VN</em> 和 <em>garren</em> 是可以同时进行攻击的，如何实现呢？</p><h3 id="多线程实现并行攻击">多线程实现并行攻击</h3><p>根据上面思考，我们应该分别把 <em><u>VN攻击teemo</u></em> 和 <em><u>garren攻击bh</u></em> 放在不同线程中并行执行。</p><p>一般来说，实现多线程我们有三种方式：</p><ul><li>继承 <em>Thread</em> 类</li><li>实现 <em>Runnable</em> 接口</li><li>匿名类的方式</li></ul><h4 id="1-继承-Thread-类">1. 继承 <em>Thread</em> 类</h4><p>通过继承<em>Thread</em> 类，然后覆写<em>run()</em> 方法，<u>在<em>run()</em> 方法写上需要并发的操作</u> 。这样，在实例化对象后，执行对象方法 <em>start()</em> 启动后便会分配线程来执行 <em>run()</em> 中操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KillThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Hero h1;</span><br><span class="line">    <span class="keyword">private</span> Hero h2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KillThread</span><span class="params">(Hero h1,Hero h2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.h1 = h1;</span><br><span class="line">        <span class="keyword">this</span>.h2 = h2;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 覆写父类Thread中run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!h2.isDead()) <span class="comment">// 模拟不断攻击敌方英雄</span></span><br><span class="line">            h1.attack(h2,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在主函数，实例化 <em>KillThread</em> 对象，执行<em>start()</em> 方法来创建线程，然后执行方法<em>run()</em> 中操作。</p><p>显然，下面<em>KillThread</em> 对象<em>kh1、kh2</em>，分别创建了两个线程执行 <u>VN攻击Teemo</u>，<u>garren攻击bh</u>。</p><blockquote><p>:notebook: 创建两个线程，代码排版中是串行的，但是实际<strong>执行是并行</strong>的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Hero VN = <span class="keyword">new</span> Hero(<span class="string">&quot;VN&quot;</span>,<span class="number">2500</span>);</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">&quot;teemo&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        Hero gareen = <span class="keyword">new</span> Hero(<span class="string">&quot;gareen&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Hero bh = <span class="keyword">new</span> Hero(<span class="string">&quot;bh&quot;</span>,<span class="number">2800</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果执行 kt1.run()、kt2.run() 不会创建新线程,相当于串行操作</span></span><br><span class="line">        KillThread kt1 = <span class="keyword">new</span> KillThread(VN, teemo);</span><br><span class="line">        kt1.start();  </span><br><span class="line">        KillThread kt2 = <span class="keyword">new</span> KillThread(gareen, bh);</span><br><span class="line">        kt2.start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据下面部分输出截图，可以发现 <u>VN攻击Teemo</u>，<u>garren攻击bh</u> 可以并行执行：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1563157470532.png" alt="1563157470532"></p><h4 id="2-实现-Runnable-接口">2. 实现 <em>Runnable</em> 接口</h4><p>通过 实现 <em>Runnable</em> 接口 和 继承 <em>Thread</em> 类来实现多线程，大同小异。</p><blockquote><p><strong>相比继承Thread类，实现Runnable接口的好处：</strong></p><ul><li><p>避免了Java<strong>单继承</strong>的局限性</p></li><li><p>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</p></li></ul></blockquote><p>唯一需注意的是，<em>Runnable</em> 接口 虽然要求实现 <em>run()</em> 方法，但是：</p><blockquote><p>直接调用*run()*方法，并不会启动一个新的线程。**[面试]需要借助线程对象 *start()*方法，**才会启动一个新的线程。</p></blockquote><p>下面创建一个 <em>Battle</em> 类，实现<em>Runnable</em> 接口，可以看到：除了没有继承 <em>Thread</em> 类，<u>其余都一模一样</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Battle</span> <span class="keyword">implements</span> <span class="title">Runnable</span> // 以下和继承<span class="title">Thread</span>方式代码一样</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Hero h1;</span><br><span class="line">    <span class="keyword">private</span> Hero h2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KillThread</span><span class="params">(Hero h1,Hero h2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.h1 = h1;</span><br><span class="line">        <span class="keyword">this</span>.h2 = h2;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 覆写父类Thread中run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!h2.isDead()) <span class="comment">// 模拟不断攻击敌方英雄</span></span><br><span class="line">            h1.attack(h2,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主函数需要借助 <em>Thread</em> 对象 *start()*方法，启动一个新线程，这也是和直接继承 <em>Thread</em> 类不同地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Hero VN = <span class="keyword">new</span> Hero(<span class="string">&quot;VN&quot;</span>,<span class="number">2500</span>);</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">&quot;teemo&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        Hero gareen = <span class="keyword">new</span> Hero(<span class="string">&quot;gareen&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Hero bh = <span class="keyword">new</span> Hero(<span class="string">&quot;bh&quot;</span>,<span class="number">2800</span>);</span><br><span class="line">        </span><br><span class="line">        Battle battle1 = <span class="keyword">new</span> Battle(gareen,teemo);</span><br><span class="line">        <span class="keyword">new</span> Thread(battle1).start(); <span class="comment">// 把Battle对象当做Thread构造函数参数传递进去</span></span><br><span class="line">        Battle battle2 = <span class="keyword">new</span> Battle(bh,leesin);</span><br><span class="line">        <span class="keyword">new</span> Thread(battle2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-匿名类">3. 匿名类</h4><p>在 <u>2.实现 <em>Runnable</em> 接口</u> 中，我们难免会想到通过匿名类方式来实现，因为它满足：</p><ol><li>通过继承接口/类方式实现一个类(<em>Battle</em>)</li><li><strong>该类对象仅被调用一次</strong></li></ol><p>当然，在 <u>3.继承 <em>Thread</em> 类</u> 中也满足上述条件，可以通过匿名类实例<em>KillThread</em> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        Hero VN = <span class="keyword">new</span> Hero(<span class="string">&quot;VN&quot;</span>,<span class="number">2500</span>);</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">&quot;teemo&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        Hero gareen = <span class="keyword">new</span> Hero(<span class="string">&quot;gareen&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Hero bh = <span class="keyword">new</span> Hero(<span class="string">&quot;bh&quot;</span>,<span class="number">2800</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          // 匿名类生成本来的KillThread对象</span></span><br><span class="line"><span class="comment">           Thread t1= new Thread()&#123;  </span></span><br><span class="line"><span class="comment">            public void run()</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                while(!teemo.isDead())</span></span><br><span class="line"><span class="comment">                    gareen.attackHero(teemo);            </span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 匿名类实现生成Battlel类对象</span></span><br><span class="line">        Runnable battle1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!teemo.isDead()) </span><br><span class="line">                    VN.attack(teemo,<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; <span class="comment">// 注意要有 ; 分号</span></span><br><span class="line">        <span class="keyword">new</span> Thread(battle1).start();</span><br><span class="line"></span><br><span class="line">        Runnable battle2 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!bh.isDead()) </span><br><span class="line">                    gareen.attack(bh,<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(battle2).start();</span><br><span class="line">        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们还可以更进一步，使用 <em>lambada</em> 表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        Hero VN = <span class="keyword">new</span> Hero(<span class="string">&quot;VN&quot;</span>,<span class="number">2500</span>);</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">&quot;teemo&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        Hero gareen = <span class="keyword">new</span> Hero(<span class="string">&quot;gareen&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Hero bh = <span class="keyword">new</span> Hero(<span class="string">&quot;bh&quot;</span>,<span class="number">2800</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更进一步：通过lambada表达式</span></span><br><span class="line">        Runnable battle1 = () -&gt; &#123;<span class="keyword">while</span> (!teemo.isDead()) VN.attack(teemo,<span class="number">100</span>);&#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(battle1).start();</span><br><span class="line">        Runnable battle2 = () -&gt; &#123;<span class="keyword">while</span> (!bh.isDead()) gareen.attack(bh,<span class="number">100</span>);&#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(battle2).start();        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;               </span><br></pre></td></tr></table></figure><h2 id="12-2-多线程常用方法">12.2 多线程常用方法</h2><h3 id="sleep-方法"><em>sleep()</em> 方法</h3><p><em>sleep()</em> 是 <em>Thread</em> 类静态方法，可以使 <u>当前</u> 线程阻塞，并指定暂停时间，重点在于理解 <u>当前</u>：</p><blockquote><p>下面是 <strong>14.1</strong>中 <u>3.匿名类</u> 在主函数实现多线程代码，删减了 <em>garren</em> 攻击 <em>bh</em> 创建线程部分。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        Hero VN = <span class="keyword">new</span> Hero(<span class="string">&quot;VN&quot;</span>,<span class="number">2500</span>);</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">&quot;teemo&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        Hero gareen = <span class="keyword">new</span> Hero(<span class="string">&quot;gareen&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Hero bh = <span class="keyword">new</span> Hero(<span class="string">&quot;bh&quot;</span>,<span class="number">2800</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// [1]暂停1s</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// sleep要处理异常，为了方便直接在主函数throw</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名类实现</span></span><br><span class="line">        Runnable battle1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="comment">// [2]暂停2s</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">while</span> (!teemo.isDead()) </span><br><span class="line">                    VN.attack(teemo,<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; </span><br><span class="line">        <span class="keyword">new</span> Thread(battle1).start();       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面有两个位置发生暂停：</p><ul><li>[1]暂停1s：显然当前线程是主线程，所以会使得主线程暂停1s；</li><li>[2]暂停2s：执行完   <code>new Thread(battle1).start();</code>   启动新线程1，新线程1会执行 <em>run()</em> 方法。那么当前线程就是线程1，线程1被暂停2s。</li></ul><h3 id="yield-方法"><em>yield()</em> 方法</h3><p><em>yield()</em> 也是 <em>Thread</em> 类静态方法，<strong>使当前线程变为<u>就绪状态</u></strong> （<em>sleep()</em> 是阻塞），使得其他线程更多机会获取CPU。</p><p>但不能指定暂停时间，因为线程重新到<em>就绪状态</em> 后，执行<em>yield()<em>的线程<u>有可能在进入</em>就绪状态</em> 马上又被执行</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        Hero VN = <span class="keyword">new</span> Hero(<span class="string">&quot;VN&quot;</span>,<span class="number">2500</span>);</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">&quot;teemo&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        Hero gareen = <span class="keyword">new</span> Hero(<span class="string">&quot;gareen&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Hero bh = <span class="keyword">new</span> Hero(<span class="string">&quot;bh&quot;</span>,<span class="number">2800</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// [1]主线程从运行--&gt;就绪</span></span><br><span class="line">        Thread.yield(); <span class="comment">// 实际测试没有效果，后面代码还是执行主函数代码，主线程立马又被调度了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名类实现</span></span><br><span class="line">        Runnable battle1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!teemo.isDead()) </span><br><span class="line">                    VN.attack(teemo,<span class="number">100</span>);</span><br><span class="line">                <span class="comment">// [2]VN攻击teemo线程从运行--&gt;就绪</span></span><br><span class="line">                Thread.yield(); <span class="comment">// 让出CPU调度 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; </span><br><span class="line">        <span class="keyword">new</span> Thread(battle1).start();       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="join-方法"><em>join()</em> 方法</h3><blockquote><p>slepp()、yield()都是Thread类静态方法，但jion() 是Thread类实例对象方法。</p></blockquote><p>一种特殊的<em>wait</em>，<u>当前</u> 运行线程调用另一个线程的<em>join</em>方法。</p><p><u>当前线程进入阻塞状态直到<em>join</em>的线程运行结束</u> ，等待该线程终止。 注意该方法也需要捕捉异常。-</p><ul><li>:warning: 此时有其它子线程，也必须等到调用jion() 的线程先执行完毕。 ​</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    void join()：等待这个线程死亡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadJoin tj1 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line">        ThreadJoin tj2 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line">        ThreadJoin tj3 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line"></span><br><span class="line">        tj1.setName(<span class="string">&quot;康熙&quot;</span>);</span><br><span class="line">        tj2.setName(<span class="string">&quot;四阿哥&quot;</span>);</span><br><span class="line">        tj3.setName(<span class="string">&quot;八阿哥&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.启动主线程后，三个线程抢占执行，谁都可能执行</span></span><br><span class="line">        tj1.start();</span><br><span class="line">        tj2.start();</span><br><span class="line">        tj3.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.主线程继续往下执行，</span></span><br><span class="line">        <span class="comment">//   遇到设置康熙线程jion后，主线程和另外两个阿哥线程         //   【都阻塞】，等待康熙线程执行完</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tj1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoin</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="setPriority-方法"><em>setPriority()</em> 方法</h3><p><em>setPriority()</em> 用于设置优先级，优先级的高的线程更高几率获得 <em>CPU</em> 调度。有以下几个需要知道知识点：</p><ul><li><p>线程优先级表示</p><p>线程优先级表示用整数：1~10，也可以用<em>java</em> 内置的三种 <em>INT</em>  型常量表示：</p><ul><li>最低优先级 1：<em>Thread.MIN_PRIORITY</em></li><li>普通优先级 5：<em>Thread.MAX_PRIORITY</em></li><li>最高优先级10：<em>Thread.NORM_PRIORITY</em></li></ul></li><li><p>默认线程优先级</p><p><em>Java</em>默认的线程优先级是 <u>父线程的优先级</u>，而非普通优先级 <em>Thread.NORM_PRIORITY</em> 。</p></li></ul><p>详细参考 <u>操作系统</u> 一书，这里以一个简单实例说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        Hero VN = <span class="keyword">new</span> Hero(<span class="string">&quot;VN&quot;</span>,<span class="number">2500</span>);</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">&quot;teemo&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        Hero gareen = <span class="keyword">new</span> Hero(<span class="string">&quot;gareen&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Hero bh = <span class="keyword">new</span> Hero(<span class="string">&quot;bh&quot;</span>,<span class="number">2800</span>);</span><br><span class="line">        </span><br><span class="line">        Thread  t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!teemo.isDead())</span><br><span class="line">                    VN.attack(teemo,<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread  t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!bh.isDead())</span><br><span class="line">                    gareen.attack(bh,<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取线程优先级</span></span><br><span class="line">        System.out.format(<span class="string">&quot;t1优先级%d，t2优先级%d\n&quot;</span> ,t1.getPriority(),t2.getPriority());</span><br><span class="line">        <span class="comment">// 重新设置线程优先级</span></span><br><span class="line">        t1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        <span class="comment">// 获取优先级</span></span><br><span class="line">        System.out.format(<span class="string">&quot;t1优先级%d，t2优先级%d\n&quot;</span> ,t1.getPriority(),t2.getPriority());</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1563179771296.png" alt="1563179771296"></p><h3 id="setDaemon-方法"><em>setDaemon()</em> 方法</h3><p><em>setDaemon()</em> 用于设置守护线程。什么是守护线程？</p><p>简单理解，一个 <u>进程</u> 中用于守护其它线程的线程，如果其它线程结束，只剩下守护线程，那么<u>进程</u> 结束。</p><p>守护线程通常会被用来做：日志、性能统计等工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t1线程被设为当前进程的守护线程</span></span><br><span class="line"> t1.setDaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><blockquote><p>创建一个破解线程用穷举法匹配指定的某密码；创建一个日志守护线程，打印用过哪些密码匹配。</p></blockquote><ul><li>:key: 由于日志线程是守护线程，那么破解线程匹配成功结束，守护线程日志也就结束了；</li><li>:key: 设置一个公共容器 <em>LinkList</em></li></ul><p>答案查看：<a href="http://how2j.cn/k/thread/thread-methods/354.html#nowhere">多线程常用方法</a></p><blockquote><p>设置三个线程：“关羽”、“张飞”、“刘备” 。“刘备”为当前线程（也是主线程），“关羽”和“张飞”为守护线程。</p></blockquote><p>下面示例中，“刘备”线程挂了后，“关羽”、“张飞” 也马上停止了（但还是挣扎了会）。<img src="https://i.loli.net/2021/04/28/MlOCfaikYJmg2Uz.png" alt="image-20210428162833700"></p><h2 id="12-3-多线程同步">12.3 多线程同步</h2><p>多线程同步问题，指多线程同时修改一个数据时，导致数据不一致等。解决多线程问题，通常通过：</p><ol><li><em>volatile</em>关键字 ：可保证可见性；</li><li><em>synchronized</em>关键字 ：是一个同步锁，保证原子性和可见性；</li><li><em>Lock</em> 接口：保证原子性和可见性，详情暂略。</li></ol><p>在解释 <em>volatile</em> &amp; <em>synchronized</em> 同步锁前，先了解一些<strong>并发编程基本概念</strong>。</p><blockquote><p>思考下面售票案例：为什么控制台会：1. 输出相同票、2.出现负数票？</p></blockquote><ul><li><p>主函数类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建SellTicket类的对象</span></span><br><span class="line">        SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(st,<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(st,<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(st,<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SellTicket 线程类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在SellTicket类中重写run()方法实现卖票，代码步骤如下</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                tickets--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>解释</strong></p><ul><li><strong>相同票</strong>：打印出售票、 <code>tickets--</code> 两条语句共享tickets变量，导致没有及时更新<code>tickets</code>变量</li><li><strong>出现负数票：</strong> <code>if (tickets &gt; 0)</code> 语句判断和 <code>tickets--</code>共享tickets变量  ，没有及时更新tickets变量</li></ul></li></ul><h3 id="1-如何解决多线程">1.如何解决多线程</h3><ul><li><p><strong>安全问题出现的条件</strong></p><ul><li>是<u>多线程环境</u></li><li>有共享数据</li><li>有<u>多条语句操作（包含，读、写等）共享数据</u></li></ul><blockquote><p>为什么一定要求是<strong>一个线程有多条语句</strong>操作共享数据？</p></blockquote><p>如果两个线程，各只有一条语句操作数据，虽然线程执行具有随机性，但是无论哪个线程执行自己那条语句（是原子性语句）时，其它线程即使此刻抢占到CPU，修改了共享变量。但由于前一个线程不再会执行共享数据相关操作，因此实际是不影响的。</p><blockquote><p>:warning: 区分多线程中线程来源同一个类和不同类情况。</p></blockquote><ul><li><p>两个线程来自<strong>同一个线程类两个对象</strong> ，该<strong>类有<u>多条</u>语句修改共享类变量的操作</strong> ；<strong>锁住类的共享操作数据语句</strong>保证同一时候只有一个线程对共享变量进行修改</p></li><li><p>【<strong>消费生产问题</strong>】两个线程<strong>来自不同线程类</strong>，但<strong>各<u>有一条或多条</u>语句对共享变量进行修改</strong> ；<strong>使用P、V操作</strong>保证同一时候只有一个线程对共享变量进行修改。参考 ：<u>7.生产者消费者</u> 小节实例</p><blockquote><p>JAVA中使用 wait()、notifyAll() 来实现，但是和PV操作逻辑是不一样的。</p><p><img src="https://i.loli.net/2021/04/28/YuCTpjbHaI1BPki.jpg" alt="这里写图片描述"></p></blockquote></li></ul></li><li><p><strong>如何解决多线程安全？</strong></p><ul><li><p>把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可</p></li><li><p>Java提供了同步代码块的方式来解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(任意对象) </span><br><span class="line">&#123; </span><br><span class="line">     <span class="comment">// 多条语句操作共享数据的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><u>synchronized同步方式优缺点？</u></p><ul><li><p>好处：解决了多线程的数据安全问题</p></li><li><p>弊端：当线程很多时，因为<strong>每个线程都会去判断同步上的锁</strong>，这是很耗费资源的，无形中会降低程序的运行效率</p></li></ul></li></ul></li><li><p><strong>尝试synchronized解决售票问题</strong></p><blockquote><p>为什么下面这种方式，执行还是一样的问题？</p></blockquote><img src="https://i.loli.net/2021/04/28/RTd6tA1BcxoDGkQ.png" alt="image-20210428213154792" style="zoom:80%;" /><ul><li>因为每次创建线程对象，锁对象<code>new Object</code> 也是重新创建的，三个线程对象三把锁，所以锁不住</li></ul><p>因此，我们要定义一个公共的锁对象：</p><p><img src="https://i.loli.net/2021/04/28/4aIhloMyBYN9ctZ.png" alt="image-20210428213403318"></p></li></ul><h3 id="2-原子性、可见性、有序性">2.原子性、可见性、有序性</h3><ul><li><p><strong>原子性</strong></p><p>即一个或多个操作，要么全部执行，要么全部不执行，类似于数据库事务概念。</p><p>在 <em>java</em> 中，基本数据类型的变量的读取和赋值操作是原子性操作，其余不是，例如：</p><blockquote><p>【<strong>面试高频</strong>】判断：下面语句1~4，都是原子性操作吗？（即是否每条语句包含的操作要么都完成/要么都不完成）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;        <span class="comment">// 语句1</span></span><br><span class="line">y = x;         <span class="comment">// 语句2</span></span><br><span class="line">x++;           <span class="comment">// 语句3</span></span><br><span class="line">x = x + <span class="number">1</span>;     <span class="comment">// 语句4</span></span><br></pre></td></tr></table></figure><p>其实，除了第一条语句，其余都不是原子性操作。</p><ul><li>x = 10：线程执行该语句将10写入内存；</li><li>y = x：读取x值 --&gt; 然后将10写入内存，进行了两次操作；</li><li>x++ ：读取x值 --&gt; 进行+1操作 --&gt; 写入新值，进行了三次操作；</li><li>x = x + 1：同x++，三次操作。</li></ul><p>所以，只有x=10这种简单赋值操作是原子性语句。在 java中提供了 <em>synchronized</em> 关键字 和<em>Lock</em> 接口来实现。</p></li><li><p><strong>可见性</strong></p><p>对于可见性，<em>Java</em> 提供了<em>volatile</em> 关键字来保证可见性，当然<em>synchronized</em> 关键字 和<em>Lock</em> 接口也可以保证。</p><p>可见性，即指<strong>一个共享变量被<em>volatile</em> 修饰时，它会保证修改的值会立即被更新到主存</strong>。当有其他线程需要读取时，它会去内存中读取新值。</p></li><li><p><strong>有序性</strong></p><p>在Java内存模型中，允许编译器和处理器对指令进行重排序。但是<strong>重排序过程不会影响到 <u>单线程</u> 程序的执行，却会影响到 <u>多线程</u> 并发执行的正确性</strong>。</p><p>在<em>java</em> 中，也是通过 <em>volatile</em>关键字来保证一定的“有序性&quot;。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1  context初始化操作</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )</span><br><span class="line">&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(context);</span><br></pre></td></tr></table></figure><p>由于指令重新排序，可能导致语句2先于语句1执行。即相当于<em>inited = ture</em>被执行 ， <em>context = loadContext()</em>  未被执行。然后线程2 <u>错误判读已经初始化完毕</u> ，执行<em>System.out.println(context);</em>  打印出<em>context</em> 。</p><p>通过加上<em>volatile</em> 关键字对 <em>inited</em> 变量进行修饰，可以避免这种情况。</p><p>因为，<strong>程序执行到<em>volatile</em>修饰变量读/写操作时，保证在<u>其前面的操作肯定已经完成，后面操作未执行</u></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> inited = <span class="keyword">true</span>;  </span><br></pre></td></tr></table></figure></li></ul><h3 id="3-volatile-关键字">3.<em>volatile</em> 关键字</h3><p><em>volatile</em> 关键字主要有两个作用：<u>使被修饰变量具有可见性</u> &amp;  <u>禁止指令重排保证可见性</u>。</p><p>保证可见性，见前。这里结合实例保证被修饰变量具有可见性。</p><blockquote><p>设计一个线程1不断学狗叫，一个线程2过1秒结束这令人窒息的操作。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程类，有一个学狗叫操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> 多线程.test_Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test_Thread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag)</span><br><span class="line">            System.out.println(<span class="string">&quot;我在学狗叫：汪汪汪~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        test_Thread t1 = <span class="keyword">new</span> test_Thread();</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread()&#123;  <span class="comment">// 匿名类方式生成一个线程1s后结束t1线程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">               <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line">                t1.flag =<span class="keyword">false</span>; <span class="comment">// 把flag设置为flase，由于可见性，将结束线程t1中while循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();     </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际输出：过了大概1s，线程1停止了学狗叫。</p><h3 id="4-synchronized关键字">4.<em>synchronized</em>关键字</h3><p><strong><em>volatile</em> 关键字可以保证可见性，但是不能保证原子性</strong>，会导致多线程出现脏数据等问题。例如下面例子：</p><h4 id="1-一个DEMO">1. 一个DEMO</h4><blockquote><p>:warning: <em>java</em> 函数不能改变<em>int</em>类型实参，也不能加上<em>ref</em> 关键字改变！所以出此下策：把数组当做参数传递，组第一个元素是我们想通过函数改变的值。数组是引用类型，可以改变里面的值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程类IncreaseThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncreaseThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IncreaseThread</span><span class="params">(<span class="keyword">int</span>[] num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数使得num值被修改</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        num[<span class="number">0</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数中</span></span><br><span class="line"><span class="keyword">import</span> 多线程.IncreaseThread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        Thread addThreads[] = <span class="keyword">new</span> Thread[<span class="number">100000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100000</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">           IncreaseThread ih = <span class="keyword">new</span> IncreaseThread(num);</span><br><span class="line">           ih.start();</span><br><span class="line">           addThreads[i] = ih;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 所有增加子线程都加入主线程中，保证子线程都【先】执行完</span></span><br><span class="line">       <span class="comment">// *如果线程已经执行完，不会在执行吧？是</span></span><br><span class="line">       <span class="comment">// *如果没有这行代码，子线程也会在主线程执行完继续执行</span></span><br><span class="line">       <span class="keyword">for</span> (Thread t : addThreads)</span><br><span class="line">           t.join();</span><br><span class="line">       System.out.println(num[<span class="number">0</span>]); <span class="comment">// 输出有时候是：999995 / 99996 ..</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-分析结果">2. 分析结果</h4><blockquote><p>我们看到输出结果并非为100000，这是为什么？</p></blockquote><p>因为 <em>num[0]++;</em> 并非是原子性语句，它由三个操作：**取<em>num[0]<em>值 --&gt; +1 操作 --&gt; 写入 <em>num[0]</em></em></em> 三个操作组成。</p><p>在多线程这将导致一个问题，例如恰好某时刻 num[0] = 100，存在线程A、B：</p><ol><li>线程A，取出*num[0]*值 = 100，准备进行+1操作</li><li>线程B，恰好也取出*num[0]*值 = 100</li><li>线程A，执行<em>num[0]++</em> 操作，<em>num[0] = 101</em></li><li>线程B，也执行 <em>num[0]++</em> 操作，所以 <em>num[0] = 101</em>没有被改变</li><li>所以线程A、B写入值都是101，没有正确顺序执行++操作。</li></ol><p>这就是为什么每次运行结果都是 &lt;100000。</p><h4 id="3-synchronized-同步锁"><em>3. synchronized</em> 同步锁</h4><p>我们可以用<em>synchronized</em>  关键字保证同一时刻只有一个线程获取锁，然后执行同步代码。</p><blockquote><p>【面试】synchronized只能修饰：类、方法或代码块，<u>不能修饰变量</u>。</p></blockquote><p>在 <em>IncreaseThread</em> 类中给 <em>run()</em> 函数加上同步锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num[<span class="number">0</span>]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保证了  <em>num[0]++</em> 操作同一时刻只有一个线程可以执行。经过多次测试输出结果 == 100000。</p><p>:warning: 直接给 <em>run()</em> 加锁也许并不是一个好做法，这会使得里面所有需要并行操作都加锁。因为这里只有  <em>num[0]++</em> 这一条语句故这样写。更好的做法是，**单独设计一个函数包含++操作，然后给这个函数加锁，<em>在run()<em>中调用</em></em>。</p><h4 id="4-匿名类使用同步锁">4. 匿名类使用同步锁</h4><p>匿名类下就没法用<em>synchronized</em>关键字限定一个函数，然后<em>run()</em> 执行这个函数（当然你可以限定 <em>run()</em> …）</p><p>我们可以首先定义一个<em>object</em> 常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object someObject = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>然后在匿名类中，<code>synchronized (someObject)&#123; // 包含要原子性执行的语句 &#125;</code>，下面是示例。</p><blockquote><p>暂时不明白<em>synchronized (someObject)</em> 设置不同参数有何作用？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        Thread addThreads[] = <span class="keyword">new</span> Thread[<span class="number">100000</span>];</span><br><span class="line">        <span class="keyword">final</span> Object someObject = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100000</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread ih = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>  <span class="comment">// 不推荐：synchronized限定run()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    <span class="comment">// synchronized体&#123;&#125;代码被独占</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (someObject)</span><br><span class="line">                    &#123;</span><br><span class="line">                        num[<span class="number">0</span>]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            ih.start();</span><br><span class="line">            addThreads[i] = ih;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有增加子线程都加入主线程中，保证子线程都执行完</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : addThreads)</span><br><span class="line">            t.join();</span><br><span class="line">        System.out.println(num[<span class="number">0</span>]);   <span class="comment">// 多次测试输出是：100000</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-synchronized-同步方法">5. <em>synchronized</em> 同步方法</h4><ul><li><p><strong>同步对象方法</strong></p><blockquote><p>给上述卖票代码加个else语句：偶数执行if，奇数执行else。esle语句存在一个方法，给它加上锁。</p></blockquote><p>但是synchronized 关键字直接加到方法上会出问题：</p><ul><li><strong>同步对象方法的默认锁是<code>this</code></strong> （默认且不能指认），而前述if语句的是的锁是<code>obj</code> ，两把锁是不一样的！</li><li>因此要把锁改为<code>this</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// synchronized (obj) &#123; // 应该改为this</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                        tickets--;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sellTicket();</span><br><span class="line">            &#125;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private synchronized void sellTicket() &#123;</span></span><br><span class="line"><span class="comment">//        if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;        System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot;张票&quot;);</span></span><br><span class="line"><span class="comment">//            tickets--;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>同步静态方法</strong></p><ul><li><p><strong>同步静态方法默认锁是当前类</strong> ，因此不能用对象方法的锁<code>this</code></p></li><li><p>可以采用反射：<code>&lt;类名&gt;.class</code> 获取当前类的字节码</p></li></ul><p><img src="https://i.loli.net/2021/04/28/7ZiTS4De1289cpQ.png" alt="image-20210428220549403"></p></li></ul><h3 id="5-常见线程安全的类">5.常见线程安全的类</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">共同点</th><th style="text-align:center">不同点</th></tr></thead><tbody><tr><td style="text-align:center"><em>HashMap</em> &amp; <em>Hashtable</em>（安全）</td><td style="text-align:center">都实现了Map接口，按键值对保存数据。</td><td style="text-align:center">1.<em>HashMap</em>可以存null，<em>Hashtable</em>不可以。2. <em>Hashtable</em>是线程安全类，<strong><em>put()<em>方法用</em>synchronized</em> 关键字修饰。</strong></td></tr><tr><td style="text-align:center"><em>StringBuffer</em>（安全） &amp;<em>StringBuilder</em></td><td style="text-align:center">操作字符串，可以进行字符串拼接等操作。</td><td style="text-align:center">1.<em>StringBuilder</em> 是线程安全类，比如 <em>public synchronized StringBuilder append(int i)</em> 方法，<strong>用了<em>synchronized</em>关键字</strong></td></tr><tr><td style="text-align:center"><em>ArrayList</em> &amp; <em>Vector</em>（安全）</td><td style="text-align:center">都是可扩展动态数组</td><td style="text-align:center">1.同上查看源码得知，<strong><em>Vector</em> 是线程安全类</strong>。</td></tr></tbody></table><h4 id="把非线程安全集合转为线程安全">把非线程安全集合转为线程安全</h4><p>借助工具类 <em>Collections</em> 中静态方法 <em>Collections.synchronizedList()</em> 可以进行非安全集合到安全转换。</p><blockquote><p>注意：<em>StringBuffer</em>  不属于集合范畴，不能转换。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt; ();</span><br><span class="line"><span class="comment">// 错误写法：返回是list无法转换为 Arraylist</span></span><br><span class="line"><span class="comment">//ArrayList&lt;Integer&gt; list2 = Collections.synchronizedList(list1);</span></span><br><span class="line">List&lt;Integer&gt; list2 = Collections.synchronizedList(list1);</span><br><span class="line"></span><br><span class="line">HashMap&lt;Integer,String&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt; ();</span><br><span class="line">Map&lt;Integer,String&gt; map2 = Collections.synchronizedMap(map1);      </span><br></pre></td></tr></table></figure><h3 id="6-Lock锁">6.Lock锁</h3><p><img src="https://i.loli.net/2021/04/28/tSoiYbRl5kdA9my.png" alt="image-20210428222639476"></p><ul><li><p><strong>创建Lock锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mport java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();  <span class="comment">// 加锁</span></span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock(); <span class="comment">// Lock要手动释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-生产者消费者">7.生产者消费者</h3><ul><li><p><strong>生产者消费者问题</strong></p><p>生产者和消费者在<strong>同一时间段内共用同一存储空间</strong>，生产者向空间里生产数据，而消费者取走数据。</p></li><li><p><strong>常用方法</strong></p><p><img src="https://i.loli.net/2021/04/28/adoxFtOm7LNeb2n.png" alt="image-20210428223250219"></p><p><img src="https://i.loli.net/2021/04/28/YuCTpjbHaI1BPki.jpg" alt="这里写图片描述"></p></li><li><p><strong>案例分析</strong></p><blockquote><p>生产者消费者案例中包含的类：</p><ul><li><p><strong>奶箱类(Box)</strong>：<strong>存储一个共享成员变量mike</strong>，表示第x瓶奶，提供存储牛奶<code>put()</code>和获取牛奶<code>get()</code>的操作</p></li><li><p><strong>生产者类(Producer)</strong>：实现Runnable接口，重写run()方法，调用存储牛奶<code>put()</code>的操作，<u>循环放30瓶</u></p></li><li><p><strong>消费者类(Customer)</strong>：实现Runnable接口，重写run()方法，调用获取牛奶<code>get()</code>的操作，<u>死循环不断获取</u></p></li><li><p><strong>测试类(BoxDemo)</strong>：里面有main方法，main方法中的代码步骤如下:</p><ol><li>创建奶箱对象，这是共享数据区域</li><li>创建消费者创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作对象</li><li>把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作</li><li>创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递</li><li>启动线程</li></ol></li></ul></blockquote><blockquote><p><a href="https://blog.csdn.net/jpf254/article/details/79459560">为什么Object.wait(),Object.notify(),Object.notifyAll()必须在同步块synchronized中执行呢?</a></p></blockquote><p>:warning: <strong>重点看下面P、V逻辑和wait()、notify() 逻辑区分。</strong></p><blockquote><ul><li><p>在Java中，我们使用<code>wait()</code>和<code>nofify()</code>或<code>notifyAll()</code>来实现线程间通信。一个线程在测试条件不满足后进入等待状态;</p></li><li><p>在经典的生产者-消费者问题中，生产者线程因缓存区满而等待，消费者线程在消费了缓存区的一个元素后通知生产者线程。</p></li></ul></blockquote><p>调用<code>notify()</code>和<code>notifyAll()</code>方法来通知一个或多个线程一个条件已经改变了。<strong>一旦通知线程退出同步方法或同步块，所有等待的线程会争抢它们等待对象上的对象锁</strong>。</p><p>获取锁的线程会从等待状态返回并继续执行。</p><blockquote><p>下面只用synchronized关键字锁住put和get操作，由于消费者<code>while(true)</code>一直消费会导致控制台最后一直输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">用户拿到第30瓶奶</span><br><span class="line">用户拿到第30瓶奶</span><br><span class="line">用户拿到第30瓶奶</span><br><span class="line">用户拿到第30瓶奶</span><br><span class="line">用户拿到第30瓶奶</span><br></pre></td></tr></table></figure><p>必须要<strong>设置进程间通信</strong>，只用生产者<code>put()</code> 了一瓶奶，才能允许消费者取<code>get()</code> 牛奶 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建奶箱对象，这是共享数据区域</span></span><br><span class="line">        Box b = <span class="keyword">new</span> Box();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作</span></span><br><span class="line">        Producer p = <span class="keyword">new</span> Producer(b);</span><br><span class="line">      <span class="comment">//创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作</span></span><br><span class="line">        Customer c = <span class="keyword">new</span> Customer(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(p);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示第x瓶奶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> milk;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示奶箱的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> state = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供存储牛奶和获取牛奶的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> milk)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果有牛奶，等待消费</span></span><br><span class="line">        */</span><br><span class="line">        <span class="keyword">if</span>(state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有牛奶，就生产牛奶</span></span><br><span class="line">        <span class="keyword">this</span>.milk = milk;</span><br><span class="line">        System.out.println(<span class="string">&quot;送奶工将第&quot;</span> + <span class="keyword">this</span>.milk + <span class="string">&quot;瓶奶放入奶箱&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产完毕之后，修改奶箱状态</span></span><br><span class="line">        state = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒其他等待的线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果没有牛奶，等待生产</span></span><br><span class="line">        <span class="keyword">if</span>(!state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有牛奶，就消费牛奶</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户拿到第&quot;</span> + <span class="keyword">this</span>.milk + <span class="string">&quot;瓶奶&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费完毕之后，修改奶箱状态</span></span><br><span class="line">        state = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒其他等待的线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示第x瓶奶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> milk;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示奶箱的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> state = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供存储牛奶和获取牛奶的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> milk)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果有牛奶，等待消费</span></span><br><span class="line">        <span class="keyword">if</span>(state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有牛奶，就生产牛奶</span></span><br><span class="line">        <span class="keyword">this</span>.milk = milk;</span><br><span class="line">        System.out.println(<span class="string">&quot;送奶工将第&quot;</span> + <span class="keyword">this</span>.milk + <span class="string">&quot;瓶奶放入奶箱&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产完毕之后，修改奶箱状态</span></span><br><span class="line">        state = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒其他等待的线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果没有牛奶，等待生产</span></span><br><span class="line">        <span class="keyword">if</span>(!state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有牛奶，就消费牛奶</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户拿到第&quot;</span> + <span class="keyword">this</span>.milk + <span class="string">&quot;瓶奶&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费完毕之后，修改奶箱状态</span></span><br><span class="line">        state = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒其他等待的线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Box b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Box b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">30</span>; i++) &#123;</span><br><span class="line">            b.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="12-4-线程交互">12.4 线程交互</h2><blockquote><p>生成者、消费者问题：p = synchronized ，占有；v = this.wait 释放。</p></blockquote><table><thead><tr><th style="text-align:center">Sleep()方法</th><th style="text-align:center">Wait()方法</th></tr></thead><tbody><tr><td style="text-align:center">sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;</td><td style="text-align:center">wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问；</td></tr><tr><td style="text-align:center">sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁</td><td style="text-align:center">wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。</td></tr><tr><td style="text-align:center">在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。</td><td style="text-align:center">wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。</td></tr></tbody></table><p>:grey_question: 试着解释下面分别用 sleep(2000) 和 wait(2000)的输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            number += <span class="number">100</span>;  <span class="comment">// 执行到这number=110</span></span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">secondMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// synchronized 保证原子性，代码只能被全部执行或不执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * (休息2S,阻塞线程)</span></span><br><span class="line"><span class="comment">             * 以验证当前线程对象的机锁被占用时, 是否被可以访问其他同步代码块</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 输出 2100</span></span><br><span class="line">            <span class="comment">//this.wait(2000); // 输出 110</span></span><br><span class="line">            number *= <span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            firstMethod();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ThreadTest threadTest = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(threadTest);</span><br><span class="line">        thread.start();  <span class="comment">// 执行firstMethod()</span></span><br><span class="line">        threadTest.secondMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-5-线程池快速入门">12.5 线程池快速入门</h2><h4 id="创建一个线程池">创建一个线程池</h4><p>下面表示创建一个：拥有线程个数为10、最多可增长至15，允许线程空闲60s后被回收，线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数中</span></span><br><span class="line">ThreadPoolExecutor threadPool= <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">15</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure><p><em>ThreadPoolExecutor</em> 类用于实现线程池，其创建多线程的构造函数原型如下：</p><blockquote><p><em>ThreadPoolExecutor(int <u>corePoolSize</u>, int <u>maximumPoolSize</u>, long <u>keepAliveTime</u>, TimeUnit <u>unit</u>, BlockingQueue<Runnable> <u>workQueue</u>, RejectedExecutionHandler <u>handler</u>)</em></p></blockquote><ul><li><em>corePoolSize</em> ：表示线程池最低拥有的线程数</li><li><em>maximumPoolSize</em> ：表示线程池最多可增长到线程数</li><li><em>keepAliveTime</em> &amp; <em>unit</em>：表示线程空闲后的存活时间，超过后会被回收，最终保持池中10个线程</li><li><em>workQueue</em> ：存放任务的阻塞队列</li><li><em>handler</em>：当队列和最大线程池都满了之后的饱和策略</li></ul><h4 id="执行任务">执行任务</h4><p>通过 <em>ThreadPoolExecutor</em> 对象 <em>execute()</em> 方法执行任务，接受的参数为 <em>Runnable</em> 类型。</p><blockquote><p><em>public void execute( Runnable command )</em></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">threadPool.execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行任务&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="DEMO-遍历搜寻文件夹">DEMO : 遍历搜寻文件夹</h4><blockquote><p>:tada: 对指定文件夹进行遍历搜寻，如果找到文件含有“黄旺辉”字样，就分配一个线程对该文件进行处理。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        <span class="comment">// 1.创建线程池</span></span><br><span class="line">        ThreadPoolExecutor threadPool= <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">15</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        <span class="comment">// 2.搜寻指定文件</span></span><br><span class="line">         t.searchFile(<span class="string">&quot;D:/hwh/uploadToGit/本科&quot;</span>,threadPool);       </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 函数：搜寻指定文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchFile</span><span class="params">(String root, ThreadPoolExecutor threadPool)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(root);</span><br><span class="line">        <span class="comment">// 每个文件/文件夹都一定会被遍历到：所以可以在这里判断是否是文件</span></span><br><span class="line">        <span class="keyword">if</span> (f.getName().contains(<span class="string">&quot;黄旺辉&quot;</span>)) <span class="comment">// 找到满足条件文件开始分配任务</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">// 设定任务</span></span><br><span class="line">           Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程在对指定文件执行任务：&quot;</span> +  f.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">          <span class="comment">// 分配线程执行任务</span></span><br><span class="line">          threadPool.execute(task);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归搜寻</span></span><br><span class="line">        <span class="keyword">for</span>(File file : f.listFiles())</span><br><span class="line">                searchFile(file.getAbsolutePath(),threadPool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>第十三章：网络编程</h1><h2 id="13-1-基本知识">13.1 基本知识</h2><h3 id="服务器和客户端通信">服务器和客户端通信</h3><p><img src="http://stepimagewm.how2j.cn/881.png" alt="ç«¯å£"></p><p>上图表示，服务器IP：192.168.1.100 ，客户端IP：192.168.1.189，它们分别通过各自的端口 8080、1087 和对方进行通信。</p><h3 id="如何获取本机IP地址？">如何获取本机IP地址？</h3><ul><li><p>通过<em>java</em>自带<em>API</em></p><p>获取本机IP可以通过java自带的API，引用类：<code>java.net.InetAddress</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用getLocalHost()，必须处理异常UnknownHostException</span></span><br><span class="line">     InetAddress host = InetAddress.getLocalHost(); </span><br><span class="line">     String ip = host.getHostAddress();</span><br><span class="line">     System.out.println(<span class="string">&quot;本机IP地址是：&quot;</span> + ip);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UnknownHostException e)</span><br><span class="line">&#123;</span><br><span class="line">     System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562380334548.png" alt="1562380334548"></p></li><li><p><em>cmd</em>命令：<em>ipconfig</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\86151&gt; ipconfig </span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562380215050.png" alt="1562380215050"></p></li></ul><h3 id="ping-命令"><em>ping</em> 命令</h3><ul><li><p>通过<em>java</em>自带<em>API</em></p><blockquote><p>直接复制粘贴，需要时再看。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSocket</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Process p = Runtime.getRuntime().exec(<span class="string">&quot;ping &quot;</span> + <span class="string">&quot;192.168.2.106&quot;</span>);</span><br><span class="line">        <span class="comment">// 缓存流，建立在字符流之上</span></span><br><span class="line">        <span class="comment">// InputStreamReader类继承字符流类Reader，可使得字节流向字符流转换</span></span><br><span class="line">        <span class="comment">// 注意加上 &quot;gbk&quot;，否则执行的命令乱码</span></span><br><span class="line">        Reader reader = <span class="keyword">new</span> InputStreamReader(p.getInputStream(),<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.length() != <span class="number">0</span>)  sb.append(line + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;本次指令返回的消息是：&quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<em>cmd</em>命令<em>ping</em></p><p><em>ping</em>某个IP地址，这个IP是网关地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\86151&gt; ping 192.168.0.1 </span><br></pre></td></tr></table></figure><p><em>ping</em>一个主机名，如果能返回说明：DNS解析正确，且本机或本网和外部连接正确</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\86151&gt; ping baidu.com</span><br></pre></td></tr></table></figure></li></ul><h2 id="13-2-实战测试网络连通">13.2 实战测试网络连通</h2><ol><li><p>观察本地网络设置是否正确： <code>ipconfig /all</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562383275004.png" alt="1562383275004"></p></li><li><p>检测本地TCP/IP 协议：<code>Ping 127.0.0.1</code></p><blockquote><p>IP地址由两个部分组成，即<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80/9765459">网络地址</a>和<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80/9765500">主机地址</a> ，（IPV4）长<strong>4</strong>个字节，32位。根据网络地址占的字节数不同，分为A、B、C三类及特殊地址D、E。全0和全1的都保留不用。</p><ul><li>**A类：**第1个字节为网络号，后3个字节为<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>号。最前面为“0”，所以地址网络号取值于1~126之间 。而保留的<code>127（01111111）+ 0.0.1</code> 就是 <a href="https://baike.baidu.com/item/%E6%9C%AC%E5%9C%B0%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80">本地回送地址</a> ，一般用于测试。</li><li>本机回送地址（Loopback Address），即<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>IP<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88/1682032">堆栈</a>内部的<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80/150859">IP地址</a>，主要用于（1）<u>网络软件测试</u> 以及（2）本地机<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1235923">进程间通信</a>，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回，不进行任何网络传输。</li></ul></blockquote><p>有返回接收则配置正确。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562383378227.png" alt="1562383378227"></p></li><li><p>检查本地IP地址是否有误：<code>ping 本机IP</code></p><blockquote><p>参考：<a href="https://www.cnblogs.com/xiaolincoding/p/12571184.html">好文：ping到底做了什么？</a></p></blockquote><p>有返回接收则配置正确，否则要重新配置下。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562383507956.png" alt="1562383507956"></p></li><li><p>检查硬件问题 &amp; 本机与本地网络连接是否正常（非局域网可忽略）：<code>ping 本机网关IP</code></p><blockquote><p><a href="https://www.zhihu.com/question/21787311/answer/19316065">网关和路由器区别？</a></p><ul><li>**网关设备：**一个大概念，不具体特指一类产品，只要 <u>连接两个不同的网络的设备</u>都可以叫网关；</li><li>**路由器：**一般特指能够 <u>实现路由寻找和转发</u>的 特定类产品，路由器很显然能够实现网关的功能。</li><li>**默认网关：**不是一个产品而是一个网络层的概念，PC本身不具备路由寻址能力，所以PC要把所有的IP包发送到一个 <u>默认的中转地址</u> 上面进行转发，也就是默认网关。 可以在 <strong>路由器、三层交换机上，可以在防火墙上</strong>，可以在服务器上，所以和物理的设备无关。</li></ul></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562383725128.png" alt="1562383725128"></p></li><li><p>检查本网或本机与外部连接是否正常： <code>Ping  远程IP地址</code></p><blockquote><p>有些 IP是ping不通的，因为有防火墙或者其它设置，这里百度找了个能ping通的。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562384976509.png" alt="1562384976509"></p></li><li><p>在 <strong>5.</strong> 基础上检查DNS解析：<code>ping 域名</code></p><p>如果可以<em>ping</em>通，则说明域名解析可正常运行。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562384636345.png" alt="1562384636345"></p></li></ol><h2 id="13-3-网络编程通信实战">13.3 网络编程通信实战</h2><p>​        在 <strong>13.1</strong>中介绍了服务器和客户端通过各自端口进行简单通信。本节通过实战编程，实现服务端和客户端简单交流对话。</p><h3 id="如何编程实现通信？">如何编程实现通信？</h3><p>​         通过套接字：<em>{ IP地址，端口号 }</em> ，<em>Java</em> 有封装好类 <em>ServerSocket &amp; Socket</em> ，进而通过套接字输入、输出流 实现通信。</p><ul><li>服务端通过 <em>ServerSocket</em> 对象 <em>ss</em>打开端口；</li><li>客户端创建套接字 <em>Socket</em> 对象 <em>socket</em> 连接到服务端，并通过 套接字建立 <u>输出流</u>  进行数据传输；</li><li>服务端通过 <em>ServerSocket</em> 对象 <em>ss.accept()</em> 方法，返回 <em>Socket</em> 对象（客户端的？），通过 <u>输入流</u> 读数据；</li><li>服务端进行回应，并关闭服务。</li></ul><h3 id="编程实现">编程实现</h3><ul><li><p>客户端 - <em>Client</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> QQ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数：套接字初始化连接的主机和端口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host 指定连接的主机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> post 指定连接的端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(String host,<span class="keyword">int</span> post)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        socket = <span class="keyword">new</span> Socket(host,post);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端发送指定消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientMsg  要发送的消息内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msg</span><span class="params">(String clientMsg)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1.建立[套接字字节输出流]对象发生消息</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.客户端发消息</span></span><br><span class="line">        <span class="comment">// 注意String类型 --&gt; byte[]</span></span><br><span class="line">        os.write(clientMsg.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.注意：客户端套接字必须要关闭，才开始连接服务端</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Q1 : 为什么设计每个方法 t hrows IOException ？</em></p><p><em>A1:</em>  因为创建套接字对象<em>socket</em> | 调用对象方法 ，都要处理 <em>IOException</em> 异常，每个方法写 <em>try catch</em> 太麻   烦，不如先抛出异常，在主函数中统一处理。</p><p><em>Q2 : 为什么msg() 方法发送完消息立马关闭套接字 socket.close() ，而不是等服务器接收了再关闭 ？</em></p><p><em>A1:</em>  事实上，只有先关闭套接字<em>socket.close()</em> ，客户端才会开始连接服务端！</p></li><li><p>服务端 - <em>Server</em></p><blockquote><p>:warning:  <em>ServerSocket</em> 对象 <em>ss.accept()</em> 方法，必须客户端建立连接之后，否则会一直阻塞！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> QQ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ServerSocket ss;</span><br><span class="line">    Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开端口，建立套接字对象监听端口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> post 要打开的服务端端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">(<span class="keyword">int</span> post)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ss = <span class="keyword">new</span> ServerSocket(post);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭套接字连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ss.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端对客户发来的消息进行回应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1.注意：客户端必须已经连接，否则会一直阻塞</span></span><br><span class="line">        socket = ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.建立[套接字字节输入流]，读取客户端发过来的消息</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] all = is.readAllBytes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.类型转换: 将byte[] ---&gt; String</span></span><br><span class="line">        String clientMsg = <span class="keyword">new</span> String(all);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.回应客户端</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务端回复-小白兔回道：&quot;</span> + reMsg(clientMsg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reMsg</span><span class="params">(String clientMsg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(clientMsg.contains(<span class="string">&quot;你好&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你好！我是小白兔。&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (clientMsg.contains(<span class="string">&quot;沙雕&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你才是沙雕！你全家都是沙雕！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (clientMsg.contains(<span class="string">&quot;你叫什么&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;my name is dad&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (clientMsg.contains(<span class="string">&quot;我好烦呀~&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;放下得自在。&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;风太大，没听清！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主函数串联</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 服务端打开端口</span></span><br><span class="line">     Server server = <span class="keyword">new</span> Server(<span class="number">8886</span>);</span><br><span class="line">     <span class="comment">// 客户端连接端口</span></span><br><span class="line">     Client client = <span class="keyword">new</span> Client(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8886</span>);</span><br><span class="line">    </span><br><span class="line">     Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">     System.out.print(<span class="string">&quot;客户端-大灰狼说道：&quot;</span>);</span><br><span class="line">     String clientMsg = s.nextLine();</span><br><span class="line">     <span class="comment">// 客户端通过套接字输出流发生消息</span></span><br><span class="line">     client.msg(clientMsg);</span><br><span class="line">     <span class="comment">// 服务端通过套接字输入流进行回应</span></span><br><span class="line">     server.response();</span><br><span class="line">      </span><br><span class="line">     server.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">     System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562470443412.png" alt="1562470443412"></p></li></ul><h1>第十四章：<em>JDBC</em></h1><h2 id="14-1-JDBC-快速入门">14.1  JDBC 快速入门</h2><h3 id="什么是-JDBC？">什么是 JDBC？</h3><p><em>JDBC</em> 即  <em><u>Java DataBase Connection</u></em>  ，是<em>JAVA</em> 的一个 <em>API</em> 通过 <em>JAVA</em> 访问数据库。</p><p>其一般执行流程如下：</p><ul><li>连接数据源，如数据库</li><li>进行增删查改指令</li><li>处理响应并返回结果</li></ul><h3 id="下载-JDBC">下载 JDBC</h3><ol><li><p>官网下载驱动包</p><p>下载地址：<a href="https://dev.mysql.com/downloads/connector/j/"><em>Download Connector/J</em></a></p><p><img src="../JAVA_NOTE/note_image/1562987672708.png" alt="1562987672708"></p><p>选择：<em>Platform Independent</em> —&gt; <em>mysql-connector-java-8.0.16.zip</em> ，然后下载：</p><blockquote><p>坑：下面还有一个下载<em>MySQL Installer</em> ，是下载 <em>mysql</em> 全家桶 ！</p></blockquote><p><img src="../JAVA_NOTE/note_image/1562987944125.png" alt="1562987944125"></p></li><li><p>解压</p><p>解压之后会在下载目录出现：<em>mysql-connector-java-8.0.16</em> 文件夹，里面有我们要的 <em>jar</em> 包：</p><p><img src="../JAVA_NOTE/note_image/1562988107051.png" alt="1562988107051"></p></li><li><p>引用包</p><p>在工程目录下新建一个文件夹：<em>lib</em> ，然后将 <em>mysql-connector-java-8.0.16.jar</em> 包复制到该目录下。</p><p>在IDEA中，右键选择该<em>jar</em> 包 --&gt; <em>Add as Library</em> ，即可添加成功。</p><p>更好的添加包方法点击：<a href="https://blog.csdn.net/qq_26525215/article/details/53239123">IDEA导入包两种方法</a></p></li></ol><h3 id="简单-DEMO">简单 DEMO</h3><h4 id="mysqlDB-类"><em>mysqlDB</em> 类</h4><p>在 <em>mysqlDB</em> 类中主要有三个函数，负责执行操作数据库对应三个流程：</p><ul><li><p><em>mysqlDB()</em> 连接数据库</p><p>:speaker: 最新 <em>SQL</em> 驱动： <u>1.加载驱动程序</u> 这步可以省略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public mysqlDB(String url,String user,String passwd) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    this.URL = url;  this.USER = user; this.PASSWD = passwd;</span><br><span class="line">    // 1.加载驱动程序</span><br><span class="line">    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">    // 2.获取数据库连接</span><br><span class="line">    conn = DriverManager.getConnection(url,user,passwd);</span><br><span class="line">    System.out.println(&quot;成功连接数据库！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>crudDB()</em> <u>增删查改</u></p><p><em>crudBOY</em>  表演时刻：执行指定 <em>sql</em> 语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ResultSet  crudDB(String sql) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    // 3.操作数据库</span><br><span class="line">    Statement s = conn.createStatement();</span><br><span class="line">    ResultSet rs = s.executeQuery(sql);</span><br><span class="line">    return rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>exit()</em> 退出</p><blockquote><p><em>Statement</em> 对象应该也关闭，这里没。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void exit() throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="主函数中">主函数中</h4><p>在主函数中串接所有流程，和数据库进行 <em>Connection</em> 连接需提供 <em>url</em> ：</p><blockquote><p><em>url = “jdbc:mysql://&lt;地址&gt;:&lt;端口&gt;/&lt;数据库名&gt;?serverTimezone=UTC”</em></p></blockquote><ul><li>&lt;地址&gt;：这里选择本机地址，<em>127.0.0.1 / localhost</em></li><li>&lt;端口&gt;：<em>mysql</em> 专用端口，3360</li><li>&lt;数据库名&gt;：预先准备好的数据库，<em>test</em></li><li>:warning:<em>?serverTimezone=UTC</em> ：新版驱动器出现的问题，要指定 <em>time zone value</em> 。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import JDBC_demo.mysqlDB;</span><br><span class="line"></span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">public class hello</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">       try</span><br><span class="line">       &#123;</span><br><span class="line">           final String url = &quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;;</span><br><span class="line">           final String user = &quot;root&quot;;</span><br><span class="line">           final String passwd = &quot;123456&quot;;</span><br><span class="line">           String sql = &quot;SELECT * FROM student WHERE gender = &#x27;F&#x27;;&quot;;</span><br><span class="line">           </span><br><span class="line">           // 连接数据库--执行sql语句</span><br><span class="line">           mysqlDB mdb = new mysqlDB(url, user, passwd);</span><br><span class="line">           ResultSet rs = mdb.crudDB(sql);</span><br><span class="line">            </span><br><span class="line">           // 读取指定列名数据</span><br><span class="line">           while(rs.next())</span><br><span class="line">           &#123;</span><br><span class="line">               System.out.println(rs.getString(&quot;name&quot;) + rs.getInt(&quot;score&quot;));</span><br><span class="line">           &#125;</span><br><span class="line">           mdb.exit();</span><br><span class="line">       &#125;</span><br><span class="line">       catch (Exception e)</span><br><span class="line">       &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mysqlDB-类完整代码"><em>mysqlDB</em> 类完整代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package JDBC_demo;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">public class mysqlDB</span><br><span class="line">&#123;</span><br><span class="line">    final String URL ;</span><br><span class="line">    final String USER ;</span><br><span class="line">    final String PASSWD ;</span><br><span class="line">    Connection conn;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造函数：进行初始化和数据库连接</span><br><span class="line">     * @param url  jdbc:mysql://127.0.0.1:3306/&lt;数据库名&gt;</span><br><span class="line">     * @param user  mysql账号</span><br><span class="line">     * @param passwd   mysql密码</span><br><span class="line">     */</span><br><span class="line">    public mysqlDB(String url,String user,String passwd) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        this.URL = url;  this.USER = user; this.PASSWD = passwd;</span><br><span class="line">        // 1.加载驱动程序</span><br><span class="line">        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        // 2.获取数据库连接</span><br><span class="line">        conn = DriverManager.getConnection(url,user,passwd);</span><br><span class="line">        System.out.println(&quot;成功连接数据库！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行增删查改</span><br><span class="line">     * @param sql 要执行的sql语句</span><br><span class="line">     */</span><br><span class="line">    public ResultSet  crudDB(String sql) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        // 3.操作数据库</span><br><span class="line">        Statement s = conn.createStatement();</span><br><span class="line">        ResultSet rs = s.executeQuery(sql);</span><br><span class="line">        return rs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void exit() throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-2-查询技巧">14.2 查询技巧</h2><p>​        因为，增、删、改并不需要处理返回的数据，比较简单就是执行<em>sql</em> 语句即可。但是查询较为复杂，这里来通过几个查询实例，来进一步熟悉 <em>JDBC API</em>。</p><h3 id="验证用户登陆">验证用户登陆</h3><blockquote><p><em>student</em> 表中没有设置密码字段，所以下面只验证了名字，简单表达意思。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import JDBC_demo.mysqlDB;</span><br><span class="line"></span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">public class hello</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">       try</span><br><span class="line">       &#123;</span><br><span class="line">           final String url = &quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;;</span><br><span class="line">           final String user = &quot;root&quot;;</span><br><span class="line">           final String passwd = &quot;123456&quot;;</span><br><span class="line">           String sql = &quot;SELECT  * FROM student WHERE name = &#x27;&#x27;&quot; + &quot;刘婷&#x27;&quot;;</span><br><span class="line">           </span><br><span class="line">           // 连接数据库--执行sql语句</span><br><span class="line">           mysqlDB mdb = new mysqlDB(url, user, passwd);</span><br><span class="line">           ResultSet rs = mdb.crudDB(sql);</span><br><span class="line">            </span><br><span class="line">           // 进行判断</span><br><span class="line">            if(rs.next()) // re.next() 返回的是bool类型，没有找到数据返回false</span><br><span class="line">                System.out.println(&quot;账号密码正确&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.println(&quot;账号密码错误&quot;);</span><br><span class="line">           mdb.exit();</span><br><span class="line">       &#125;</span><br><span class="line">       catch (Exception e)</span><br><span class="line">       &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>拼接字符串有个坑，要注意给字符串类型&quot;刘婷&quot;加上单/双引号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT  * FROM student WHERE name = &#x27;&#x27;&quot;</span> + <span class="string">&quot;刘婷&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="获取总数">获取总数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import JDBC_demo.mysqlDB;</span><br><span class="line"></span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">public class hello</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">       try</span><br><span class="line">       &#123;</span><br><span class="line">           final String url = &quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;;</span><br><span class="line">           final String user = &quot;root&quot;;</span><br><span class="line">           final String passwd = &quot;123456&quot;;</span><br><span class="line">           String sql = &quot;SELECT count(*) FROM student WHERE gender = &#x27;F&#x27;&quot;;</span><br><span class="line">           </span><br><span class="line">           // 连接数据库--执行sql语句</span><br><span class="line">           mysqlDB mdb = new mysqlDB(url, user, passwd);</span><br><span class="line">           ResultSet rs = mdb.crudDB(sql);</span><br><span class="line">            </span><br><span class="line">           // 进行判断</span><br><span class="line">           rs.next(); // 读取下一行数据，这里是第一行</span><br><span class="line">           int girl_num = rs.getInt(1); // 获取第一列第一行数据</span><br><span class="line">           System.out.println(&quot;女生总数为：&quot; + girl_num );</span><br><span class="line">           </span><br><span class="line">           mdb.exit();</span><br><span class="line">       &#125;</span><br><span class="line">       catch (Exception e)</span><br><span class="line">       &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><em>rs.next()</em> : 读取下一行数据，如果下一行数据不存在返回 <em>false</em> ；</p></li><li><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功连接数据库！</span><br><span class="line">女生总数为：5</span><br></pre></td></tr></table></figure></li></ul><h2 id="14-3-再谈-Statement-eceute">14.3 再谈 Statement &amp; eceute()</h2><h3 id="预编译-Statement"><em>预编译 Statement</em></h3><h4 id="Statement-弊端"><em>Statement</em> 弊端</h4><p>在前面，我们知道 <em>Statement</em> 对象主要用于执行 <em>sql</em> 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ResultSet  crudDB(String sql) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    // 3.操作数据库</span><br><span class="line">    Statement s = conn.createStatement();</span><br><span class="line">    ResultSet rs = s.executeQuery(sql);</span><br><span class="line">    return rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，有以下几个弊端：</p><ol><li><p>只能执行完整<em>sql</em> 语句，不能对 <em>sql</em> 语句进行模板化修改；</p></li><li><p>易遭受 <em>sql</em> 注入攻击，比如在前面我们拼接查询，是否存在用户<em>sql</em> 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;SELECT  * FROM student WHERE name = &quot; + name; // name 由用户输入</span><br></pre></td></tr></table></figure><p>如果用户输入<u>‘刘婷’ OR 1=1</u> ,而非 <u>刘婷</u> ，那么拼接语句为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  * FROM student WHERE name = &#x27;刘婷&#x27; OR 1=1;</span><br></pre></td></tr></table></figure><p>如果用户表有100万条数据，那么显然会耗光内存，让数据库负载过高。</p></li></ol><h4 id="PreparedStatement"><em>PreparedStatement</em></h4><p><em>PreparedStatement</em> 和 <em>Statement</em> 都是用来执行 <em>sql</em> 语句。不同是<em>PreparedStatement</em> 可以通过 <code>？</code> 来预留<em>sql</em> 语句编辑位置，而非直接拼接。</p><p>下面展示重新封装<em>crubDB()</em> 方法为 *identityUser()*验证用户(同前只验证姓名)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;  <span class="comment">// 注意要引用PreparedStatement </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultSet  <span class="title">identityUser</span><span class="params">(String sql, String userName)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 3.操作数据库</span></span><br><span class="line">    PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">    ps.setString(<span class="number">1</span>, userName);</span><br><span class="line">    ResultSet rs = ps.executeQuery();</span><br><span class="line">    <span class="keyword">return</span> rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主函数中，调用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> JDBC_demo.mysqlDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> String url = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;</span>;</span><br><span class="line">           <span class="keyword">final</span> String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           <span class="keyword">final</span> String passwd = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">           String sql = <span class="string">&quot;SELECT * FROM student WHERE name = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 连接数据库--执行sql语句</span></span><br><span class="line">           mysqlDB mdb = <span class="keyword">new</span> mysqlDB(url, user, passwd);</span><br><span class="line">           ResultSet rs = mdb.identityUser(sql,<span class="string">&quot;刘婷&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 进行判断</span></span><br><span class="line">           <span class="keyword">if</span>(rs.next()) <span class="comment">// re.next() 返回的是bool类型，没有找到数据返回false</span></span><br><span class="line">               System.out.println(<span class="string">&quot;正在登陆...&quot;</span>);</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               System.out.println(<span class="string">&quot;用户不存在！&quot;</span>);</span><br><span class="line">           mdb.exit();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (Exception e)</span><br><span class="line">       &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<em>sql语句</em> 不用给 <code>？</code> 代表的字符串类似加上单/双引号，会出错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT * FROM student WHERE name = &#x27;?&#x27;&quot;</span>; <span class="comment">// 错误写法</span></span><br></pre></td></tr></table></figure><p>因为，<code>ps.setString(1, userName);</code> 方法会自动设置好。</p><h3 id="三种不同eceute">三种不同<em>eceute</em></h3><p>执行 <em>sql</em> 语句，通常头三种方法：<em>eceute() &amp; executeUpdate() &amp; executeQuery()</em> ，它们都是 <em>Statement</em> 对象方法，主要有以下区别。</p><h4 id="返回值不同">返回值不同</h4><p><em>eceute()</em>  用来执行 <em>sql</em> 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Statement s = conn.createStatement();</span><br><span class="line">boolean rs = s.execute(sql); // 返回bool类型，判断执行是否成功</span><br></pre></td></tr></table></figure><p><em>executeUpdate() &amp; executeQuery()</em> 相似，但是三者返回值不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int number = s.executeUpdate(sql); // 返回int类型，有多少语句被影响</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs = s.executeQuery(sql); // 返回ResultSet类型，可以查询返回数据</span><br></pre></td></tr></table></figure><h4 id="是否支持查询语句">是否支持查询语句</h4><p><em>executeUpdate()</em> 可以进行 <u>增、删、改</u>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.executeUpdate(sqlInsert); <span class="comment">// 执行INSERT插入数据</span></span><br><span class="line">s.executeUpdate(sqlDelete); <span class="comment">// 执行DELETE删除数据</span></span><br><span class="line">s.executeUpdate(sqlUpdate); <span class="comment">// 执行UPDATE更新数据</span></span><br></pre></td></tr></table></figure><p>但是不能查询表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.executeUpdate(sqlSelect); <span class="comment">// 出错：执行SELECT查询数据</span></span><br></pre></td></tr></table></figure><p><em>executeQuery()</em> 一般用于<u>查询语句</u> ，进行其它更新操作会报错：</p><blockquote><p><em>java.sql.SQLException: Can not issue data manipulation statements with executeQuery().</em></p></blockquote><p><em>execute()</em> 没有限制可以进行：<u>增、删、改、查</u> 。</p><h2 id="14-4-特殊操作-事务">14.4 特殊操作 &amp; 事务</h2><h3 id="特殊操作">特殊操作</h3><blockquote><p>未展开讲，用到可查询：<a href="http://how2j.cn/k/jdbc/jdbc-id/398.html#nowhere">特殊操作</a></p></blockquote><p>这里的特殊操作包括两种：</p><ul><li>获取自增长id：如果表中id为<em>AUTO_INCREMENT</em>，无论是*execute()<em>还是</em>executeUpdate()*都不会返回自增长id。</li><li>获取表元数据：诸如，数据库服务器版本，驱动版本，都有哪些数据库等等</li></ul><h3 id="事务">事务</h3><blockquote><p>为什么要使用事务，不在赘述，同 <em>MySQL笔记</em>，这里主要展示 <em>JDBC</em> 如何使用事务。</p></blockquote><p>:warning: 支持事务前提：当前<em>MySQL</em>服务器本身要支持<em>INNODB</em>, 同时表类型为 <em>INNODB</em> 。</p><h4 id="支持事务">支持事务</h4><p>在当发现无法执行事务时，再进行以下修改。</p><ul><li><p>设置表类型为 <em>INNODB</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE teble_name ENGINE  = innodb;</span><br></pre></td></tr></table></figure></li><li><p>设置服务器支持 <em>INNODB</em></p><blockquote><p><em>mysql</em> 从 <u>5.5</u> 版本已将 <em>innoDB</em> 作为默认存储引擎。</p></blockquote><p>点击查看： <a href="http://how2j.cn/k/mysql/mysql-innodb/1064.html">开启<em>MYSQL INNODB</em>的办法</a></p></li></ul><h4 id="事务实例">事务实例</h4><p>在事务中的多个操作，要么都成功，要么都失败。</p><p>在 <em>JDBC</em> 中，主要是取消<em>excute()</em> 等之后 <u>自动</u> 提交，改为 <u>手动</u> 提交所有操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> JDBC_demo.mysqlDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String url = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String passwd = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">        String sql = <span class="string">&quot;UPDATE student SET score = score + ? WHERE name = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接数据库</span></span><br><span class="line">        mysqlDB mdb = <span class="keyword">new</span> mysqlDB(url, user, passwd);</span><br><span class="line">        PreparedStatement ps = mdb.conn.prepareStatement(sql);</span><br><span class="line">        <span class="comment">// 事务：刘婷+10分，小白-10分</span></span><br><span class="line">        mdb.conn.setAutoCommit(<span class="keyword">false</span>);   <span class="comment">// 取消自动提交</span></span><br><span class="line">        </span><br><span class="line">        ps.setInt(<span class="number">1</span>, <span class="number">10</span>);ps.setString(<span class="number">2</span>, <span class="string">&quot;刘婷&quot;</span>);</span><br><span class="line">        ps.executeUpdate(); <span class="comment">// 看下面错误解析</span></span><br><span class="line">        </span><br><span class="line">        ps.setInt(<span class="number">1</span>, -<span class="number">10</span>);ps.setString(<span class="number">2</span>, <span class="string">&quot;小白&quot;</span>);</span><br><span class="line">        ps.executeUpdate();</span><br><span class="line">        </span><br><span class="line">        mdb.conn.commit(); <span class="comment">// 手动提交        </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:warning: 调试半小时犯的2个错误，有关： <code>ps.executeUpdate();</code></p><ol><li><p>用<em>ps.executeQuery()</em> ，提示 ：<u><em>Cannot issue data manipulation statements with executeQuery()</em></u></p><p>原因：<em>executeQuery()</em> 适用于 <em>SELECT</em> ，用户更新等操作会报错。</p></li><li><p>添加参数<em>sql</em>：<em>ps.executeQuery(sql)</em> ，在前面创建 <em>PreparedStatement</em> 对象已给参数 <em>sql</em> ，再添参数会出现解析错误。</p></li></ol><h2 id="14-5-数据库线程池-待">14.5 数据库线程池(待)</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础笔记</title>
      <link href="/2021/11/25/Git%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/11/25/Git%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Git-简介">一、Git 简介</h2><h3 id="1-1-安装">1.1 安装</h3><ul><li><p>安装地址</p><p>官网下载：<a href="https://git-scm.com/downloads">Git官网下载</a></p></li><li><p>设置用户信息</p><p>主要是设置 ： 名字 &amp; Email 地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;hwh&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;380141202@qq.com&quot;</span></span><br></pre></td></tr></table></figure><p><code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p></li></ul><h3 id="1-2-创建版本库">1.2 创建版本库</h3><ul><li><p>创建仓库</p><p>​       windows可以直接在桌面创建一个名为：&quot;Git&quot;文件夹，下有“test”子文件夹，子文件夹含有一个名为“<a href="http://readme.md">readme.md</a>”文件。</p><p>​       然后切换到其目录下（这里切换的是&quot;Git&quot;文件夹，而非“test”子文件夹）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> Git/</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/c/Users/86151/Desktop/Git</span><br></pre></td></tr></table></figure></li><li><p>初步提交过程</p><ul><li><p>初始化仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure></li><li><p>修改仓库文件</p><p>将“test”子文件夹，下readme.md文件，增加内容。</p></li><li><p>添加文件到仓库</p><p>注意：可以同时 一次添加<strong>多个</strong>文件到仓库！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure></li><li><p>提交文件</p><p>可以增加m参数：添加修改信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;第一次文件改动&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="二、时光机穿梭">二、时光机穿梭</h2><h3 id="2-0-更多控制修改提交">2.0 更多控制修改提交</h3><ul><li><p>概览</p><ul><li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li><li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff &lt;filepath&gt;</code>可以查看修改内容。</li></ul></li><li><p>实操</p><ul><li><p>再次修改文件</p><p>可以先清除原文件，再增添readme.md文档内容 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“i am  huitailang , here  is my first test word .“</span><br><span class="line"></span><br><span class="line"> “这是我第二次修改这个文件”</span><br></pre></td></tr></table></figure><p>使用 <code>git status</code>，查看状态发现readme.md文件已被修改但未提交（<strong>no changes</strong>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><p><img src="../../../../D:/hwh/uploadToGit/cs_note/Git/image/1560766427962.png" alt="1560766427962"></p></li><li><p>查看具体修改了什么内容</p><p><code>git diff &lt;filepath&gt;</code>查看文件具体修改，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560766437006.png" alt="1560766437006"></p></li><li><p>添加仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure><p>同时可用 <code>git status</code>，查看此时状态会显示，readme.md将要被提交修改。</p></li><li><p>提交仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;这是我第二次修改&quot;</span></span><br></pre></td></tr></table></figure><p>​     再用 <code>git status</code>，查看仓库当前状态，显示没有需要提交的修改，而且工作目录是干净的（working tree clean）。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560766449576.png" alt="1560766449576"></p></li></ul></li></ul><h3 id="2-1-版本回退">2.1 版本回退</h3><ul><li><p>概览</p><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本</li></ul></li><li><p>实操</p><ul><li><p>N次修改文件</p><p>先多修改几次文件提交，得到多个版本。</p></li><li><p>版本回退</p><ul><li><p>查看版本历史</p><p><code>git log </code>查看当前版本和之前的历史，<code>git relog</code> 查看所有版本历史</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span>  <span class="comment"># 可以加上 --pretty=oneline 参数使显示更简洁</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560778515569.png" alt="1560778515569"></p></li></ul></li><li><p>回退版本</p><p><code>git reset --hard &lt;指定版本&gt;</code>：可用于回到指定版本，**&lt;指定版本&gt;**方式：</p><ul><li><p>HEAD ^</p><p>HEAD ^ 回到上个版本；HEAD ^ ^  回到上上 个版本，依此类推。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^^  <span class="comment"># 回到上上个版本</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560779037449.png" alt="1560779037449"></p></li><li><p>HEAD~&lt;数字&gt;</p><p>回到前&lt;数字&gt;版本。如HEAD~100，回到前100个版本。</p></li><li><p><commit ID> :</p><p>commit ID 不用打全，一般打前面几个字符即可。如，如果回退第2版本，<code>git log</code>，只能看到第2版本及之前的版本信息。那么可用 <code>git reflog</code>查看所有版本ID，然后指定ID，回到第4版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560779323726.png" alt="1560779323726"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 3928d   <span class="comment"># 再次回到第四次修改版本</span></span><br><span class="line">HEAD is now at 3928d9f 第四次修改</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="2-2-工作区和暂存区">2.2 工作区和暂存区</h3><ul><li><p>概览</p><ul><li>理解工作区和暂存区的区别，暂存区是版本库的一个子集</li><li>比较文件有三个不同命令<ul><li>git diff   <filename></li><li>git diff  --cached <filename></li><li>git diff  --HEAD <filename></li></ul></li></ul></li><li><p>工作区</p><p>工作区就是我们能看到的目录，如我前面创建的<code>Git</code>文件夹就是一个工作区</p></li><li><p>版本库 &amp; 暂存区</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919020037470528/0" alt="git-repo"></p><p>工作区有一个隐藏目录<code>.git</code>，不属于工作区而是Git版本库，版本库包含</p><ul><li><p>Git自动创建的分支<code>master</code>&amp;指向<code>master</code>的指针<code>HEAD</code></p></li><li><p>stage（或叫index）暂存区</p></li></ul></li><li><p>暂存区工作</p><ul><li><p><strong>git add</strong></p><p>这一步实际上就是把文件修改（已存在被修改 OR 新文件）添加到暂存区，可以add多个文件，一次被提交。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919020074026336/0" alt="git-stage"></p></li><li><p><strong>git commit</strong></p><p>把暂存区的<strong>所有</strong>内容提交到当前分支。</p><p>但是注意，git commit 后<strong>暂存区文件不会消失</strong>，始终是上一次git add之后文件！</p></li><li><p><strong>git diff</strong>  &amp; <strong>git diff --cached</strong> &amp; <strong>git diff HEAD</strong></p><p>git diff  比较的是<strong>工作区文件和暂存区文件</strong>区别。</p><p>git diff --cached 比较的是<strong>暂存区文件和仓库分支文件</strong>区别。</p><p>git diff --HEAD 比较的是<strong>工作区文件和仓库分支最新版本</strong>区别。</p><ul><li><p>暂存区：就是 .git / index 这个文件，git add 会把工作区修改的文件添加到暂存区，即使 git commit 后也不会空，<strong>始终保存最近一次 git add后的内容</strong>。</p></li><li><p>仓库分支：<strong>始终保存上次git commit 内容</strong>。</p></li></ul></li></ul></li></ul><h3 id="2-3-管理修改">2.3 管理修改</h3><ul><li><p>概览</p><ul><li>git管理的是修改，而非文件</li></ul></li><li><p>实操</p><p>新建一个文件 readme1.txt，然后依次：</p><blockquote><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p></blockquote><p>​      用<code>git diff HEAD test/readme1.txt</code> 比较<strong>工作区和版本分支</strong>，会发现第二次修改没有被提交，说明git只把git add后暂存区内容提交了，而不管理文件。</p><p>如果要把第二次修改也提交了，需要进行以下操作：</p><blockquote><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改-&gt; <code>git add</code>  -&gt; <code>git commit</code></p></blockquote></li></ul><h3 id="2-4-撤销修改">2.4 撤销修改</h3><ul><li><p>概览</p><ul><li><p>场景1：改乱了工作区某个文件的内容，想直接丢弃工作区的修改时</p><p>用命令<code>git checkout -- file</code>。</p></li><li><p>场景2：不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改</p><ul><li>第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1</li><li>第二步按场景1操作。</li></ul></li><li><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交</p><p>参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p></li></ul></li><li><p>实操</p><ul><li><p>场景1</p><p>不小心在文件里增加了一句话：</p><blockquote><p>刘婷是傻子</p></blockquote><p>用 <code>git checkout</code>命令撤回工作区修改，有两种情况</p><ul><li><code>readme.txt</code>修改但未被放到暂存区，撤销修改就回到和版本库一样状态；</li><li><code>readme.txt</code>修改且添加到暂存区后，撤销修改就回到添加到暂存区后的状态。</li></ul><blockquote><p>:warning: 总之，就是让文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>:male_detective:所以，也可用于恢复误删的文件（撤销工作区删除操作）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560826918878.png" alt="1560826918878"></p></li><li><p>场景2</p><p>不小心在文件里增加了一句话，而且已经git add提交到暂存区</p><blockquote><p>刘婷是傻子哈哈哈</p></blockquote><p>命令<code>git reset </code> <strong>不仅可以回退版本 而且可以把暂存区的修改撤销</strong>。</p><p>:warning:之所以不直接 git checkout 是因为此时会用<strong>暂存区内容覆盖工作区</strong>，显然不行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD <span class="built_in">test</span>/readme.md <span class="comment"># HEAD表示最新版本</span></span><br></pre></td></tr></table></figure><p>然后此时再用git checkout ，暂存区内容覆盖工作区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure><p>再次查看文件发现，‘’刘婷是傻子哈哈哈‘’ 的胡话已经被没了，暂存区也没了。</p></li><li><p>场景3</p><p>又说胡话，不但 git add 且git  commit（暂存区和版本库<strong>HEAD</strong>都是修改后版本）</p><blockquote><p>刘婷是傻子哈哈哈哈哈哈</p></blockquote><p>这个时候只有回退版本了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog  <span class="comment"># 查看版本号</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard  3928</span><br><span class="line">HEAD is now at 3928d9f 第四次修改</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-5-删除文件">2.5 删除文件</h3><ul><li><p>rm 删除</p><ul><li><p>原理</p><p>rm 删除文件，只相当于删除了 工作区文件，如果要恢复文件撤销工作区修改即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure></li><li><p>恢复</p><p>用<code>git checkout -- &lt;file&gt;</code>，它会用最新版本库文件（如果已经git add 用最新暂存区内容，见前）覆盖工作区文件，则相当于撤销工作区修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure></li></ul></li><li><p>git rm 删除</p><ul><li><p>原理</p><p>git rm 删除文件，不但相当于 <strong>删除工作区文件 &amp;  而且git add添加到暂存区</strong>。</p><p>所以此时直接<code>git checkout </code>是用暂存区内容覆盖 工作区，显然是没用的。</p></li><li><p>恢复</p><ul><li><p>先恢复暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD <span class="built_in">test</span>/readme.md <span class="comment"># HEAD表示最新版本</span></span><br></pre></td></tr></table></figure></li><li><p>再用暂存区覆盖工作区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure></li></ul></li><li><p>彻底删除</p><p>如前所述，git rm 已经删除了 ①工作区文件 ② 添加到暂存区，那么此时只需要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --m <span class="string">&#x27;彻底删除&#x27;</span>  <span class="comment"># 将③版本库内容也修改</span></span><br></pre></td></tr></table></figure><p>那么文件就会从工作区、暂存区、版本库全部删除。</p></li><li><p>彻底删除恢复</p><p>如果已经commit，那么只能<code>git reset</code>回退版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard  3928</span><br><span class="line">HEAD is now at 3928d9f 第四次修改</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="三、远程仓库">三、远程仓库</h2><h3 id="3-1-添加远程库上传本地文件">3.1 添加远程库上传本地文件</h3><blockquote><p>以下操作基于默认你</p><ul><li>创建好 github 账号 &amp; 创建好一个仓库</li><li>设置好本地ssh -key 而且已经同时在github网页服务端账号设置里添加 ssh -key</li></ul></blockquote><ol><li><p>添加用户信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;hwh&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;380141202@qq.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>初始化本地仓库</p><blockquote><p>如果本地仓库从未被初始化才需要，初始化会创建一个隐藏的 .git 文件管理版本。</p></blockquote><ul><li><p>cd切换 + git init</p><p>cd命令切换到后本地仓库；</p><p>git init 初始化本地仓库，会为你创建一个 .git文件，已经初始化不用。</p></li><li><p>手动 bash</p><blockquote><p>:warning: 很奇怪的是，这样 git add . --&gt; git commit --&gt; git push后，会把整个父文件夹推送上去。</p><p>比如：地址 TEST 文件夹下有 <a href="http://README.md">README.md</a> ，推送后github上显示的 TEST文件夹，而不是我想的README.md文件。</p></blockquote><p>右击本地仓库，选择<code>Git Bash here</code></p></li></ul></li><li><p>把本地仓库添加到版本库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add .  <span class="comment"># add . 提交所有新建、修改文件</span></span><br><span class="line">$ git commit -m <span class="string">&#x27;第一次添加本地仓库到版本库&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>本地仓库关联远程库</p><p><code>git remote add &lt;远程库名设置&gt;  &lt;远程仓库地址&gt;</code></p><p>显然这里把<strong>远程仓库地址设置为 origin</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:huangwanghuiYY/gitTest.git</span><br></pre></td></tr></table></figure></li><li><p>推送到远程库</p><p>下面代码表示：将本地<code>master</code>分支推送到远程仓库<code>origin</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master  <span class="comment"># 第一次推送带 -u 参数</span></span><br></pre></td></tr></table></figure><p><code>-u</code>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2-从远程库克隆">3.2 从远程库克隆</h3><blockquote><p>​       当我们想多人协作时会用到克隆。比如有一个不错的开源项目，你可以克隆到<code>本地仓库</code>进行修改等。</p></blockquote><ol><li><p>确定要克隆的仓库</p><p>比如我的XSurvey项目。</p></li><li><p>git clone 进行克隆</p><p>克隆会在<code>当前文件夹</code>创建克隆的仓库，克隆仓库以XSuery为名，下含项目文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:huangwanghuiYY/XSurvey.git</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560943024969.png" alt="1560943024969"></p></li></ol><h2 id="四、分支管理">四、分支管理</h2><h3 id="4-1-创建和合并分支">4.1 创建和合并分支</h3><blockquote><p>这一节，涉及大量图形，<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424">廖雪峰教程</a>  讲的很好，这里尽量精简记录心得。</p></blockquote><ul><li><p>概述</p><ul><li><p>查看分支：<code>git branch</code></p></li><li><p>创建分支：<code>git branch &lt;name&gt;</code></p></li><li><p>切换分支：<code>git checkout &lt;name&gt;</code></p></li><li><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p></li><li><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p></li><li><p>删除分支：<code>git branch -d &lt;name&gt;</code></p></li></ul></li><li><p>实操记录</p><ul><li><p>主分支</p><p>​       <code>master</code>分支也是一条时间线，每次<strong>提交</strong> master 分支都会向前移动一步，随着不断提交 master分支也就越长。</p><p>:warning:下图有两个指针：<code>HEAD</code> &amp; <code>master</code> ，<code>HEAD</code>严格来说不是指向提交。HEAD指向master，master指向最新分支。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919022325462368/0" alt="git-br-initial"></p></li><li><p>新分支创建切换</p><ul><li><p>创建新分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev1   <span class="comment"># 新建分支</span></span><br><span class="line">$ git branch        <span class="comment"># 查看分支</span></span><br><span class="line">  dev1</span><br><span class="line">* master           <span class="comment"># * 表示当前所在的分支（master）</span></span><br></pre></td></tr></table></figure><p>​     当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>指向的提交。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560997582503.png" alt="1560997582503"></p></li><li><p>切换到当前分支</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev1</span><br></pre></td></tr></table></figure><p>如果checkout 加上 -b参数，表示 创建 &amp; 切换两个操作</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev1</span><br></pre></td></tr></table></figure><p>切换到当前分支，其实把head指向master所指向的提交。</p><p>:warning:这张图，还表示dev分支还执行了<strong>一次提交</strong>。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919022387118368/0" alt="git-br-dev-fd"></p></li></ul></li><li><p>合并分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master  <span class="comment"># 先切回master分支（即HEAD指向master）</span></span><br><span class="line">$ git merge dev1   <span class="comment"># 表示当前分支（master）合并 dev1分支</span></span><br></pre></td></tr></table></figure><p>根据上图我们可以看到：</p><p>​      <code>dev</code>分支向前走了一步，<code>dev</code>指向了<strong>当前最新</strong>提交，而<code>master</code>指针依然指向<strong>上次</strong>提交。</p><p>​      如果要合并，那么直接**让<code>master</code>指向<code>dev</code>指向的当前提交。**相当于，master也提交过一次。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919022412005504/0" alt="git-br-ff-merge"></p></li><li><p>删除分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure><p>​     删除分支，等价于删除创建分支后的提交记录（上图红色线），但由于master指向了最新提交，等价复制dev1的提交记录（蓝色线）。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919022479428512/0" alt="git-br-rm"></p><p>​</p></li></ul></li></ul><h3 id="4-2-解决同时修改冲突">4.2 解决同时修改冲突</h3><ul><li><p>产生冲突原因</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561001334904.png" alt="1561001334904"></p><ul><li><p>在master分支上</p><ul><li><p>在当前<code>master</code>分支上，创建一个新分支  <code>dev2</code></p></li><li><p>同时master分支上，对README.md文件增加一句话</p><blockquote><p>i said master</p></blockquote></li><li><p>:warning: 然后，<code>git add  --&gt; git commit</code></p></li></ul></li><li><p>在dev2分支上</p><ul><li><p>checkout切回master分支上，对README.md文件增加一句话</p><blockquote><p>i said dev2</p></blockquote></li><li><p>:warning: 然后，<code>git add  --&gt; git commit</code></p></li></ul></li><li><p>合并</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge dev2</span><br></pre></td></tr></table></figure><p>显示，README.md文件同时被修改，发生冲突（也可用 <code>git status</code> 查看）</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561001544117.png" alt="1561001544117"></p><p>vim 查看文件显示具体冲突：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim README.md <span class="comment">#当前HEAD指向master，所以下图显示HEAD</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561001684363.png" alt="1561001684363"></p></li></ul></li><li><p>解决冲突</p><p>:m:此时<strong>两</strong><a href="http://xn--README-ov7i.md">个README.md</a><strong>已经是一个文件了</strong>，文件内容就是上图vim查看的<strong>所有</strong>内容 。</p><p>我们再命令行端口也可以看到，提示我们在 master|MERGING 合并中。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561002765319.png" alt="1561002765319"></p><p>​     我们打开文件，修改文件内容为：（第一句话有误，此时实在master分支上，不用在意）</p><blockquote><p>这是的dev分支，我增加了一句话</p><p>修改冲突，这里变成这样。其实不修改直接提交也解决冲突，只是没解决同时修改。</p></blockquote><p>然后再提交，发现冲突已经解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add README.md </span><br><span class="line">$ git commit -m <span class="string">&#x27;解决冲突&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561002865426.png" alt="1561002865426"></p></li></ul><h3 id="4-3-分支管理策略-–-禁用Fast-forward">4.3 分支管理策略 – 禁用Fast forward</h3><ul><li><p>概览</p><blockquote><p>​      通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，则直接把 master 的指针直接指向了 dev 分支的最新提交，这样两个分支的最新提交的 commit id 就是一样的。但这种模式下，删除分支后，会丢掉分支信息。</p><p>​      **加上<code>--no-ff</code>参数，强制禁用<code>Fast forward</code>模式，使用普通模式。**Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p></blockquote></li><li><p>实操</p><blockquote><p>默认已经创建好分支 dev3，且修该了文，进行了一次<strong>commit</strong>。</p><p>然后下面都是在 master分支上尝试合并操作</p></blockquote><ol><li><p>切回master</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure></li><li><p>合并分支</p><p>–no–ff ： 普通模式合并。</p><p>-m ：由于本次合并<strong>dev</strong>要创建一个新的commit，所以加上<code>-m</code>参数，添加描述。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">&quot;merge with no-ff&quot;</span> dev</span><br></pre></td></tr></table></figure></li><li><p>查看历史</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure></li><li><p>Fast forward模式 &amp; 普通模式 对比</p><blockquote><p>FF模式不用<code>--no-ff</code>，实际上只是将master的指针update成dev分支而已。用的还是dev的commit ID。</p><p>普通模式用，则是重新commit一次，有了新的commit ID，<strong>保留了分支版本记录</strong>。</p></blockquote><ul><li><p>Fast forward模式</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919022412005504/0" alt="git-br-ff-merge"></p></li><li><p>普通模式</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919023225142304/0" alt="git-no-ff-mode"></p></li></ul></li></ol></li></ul><h3 id="4-4-BUG分支—git-stash">4.4 BUG分支—git stash</h3><ul><li><p>概览</p><blockquote><p>​      修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>​      当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p></blockquote></li><li><p>实操（应用场景）</p><ol><li><p>master 上面发布的是A的1.0版本</p></li><li><p>dev 上开发的是A的2.0版本 ，<strong>刚刚新建了test文件</strong> &amp; <strong><a href="http://xn--README-2g0js76l.md">修改README.md</a></strong>：</p><blockquote><p>这里是dev分支。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561019801527.png" alt="1561019801527"></p></li><li><p>这时，用户反映 1.0版本存在漏洞，有人利用这个漏洞开外挂</p></li><li><p>需要从dev切换到master去填这个漏洞，正常必须先提交dev目前的工作，才能切换。</p><ul><li><p>如果不commit切换分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master </span><br></pre></td></tr></table></figure><p>发现当前工作目录，是dev分支工作目录！</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561018815751.png" alt="1561018815751"></p></li><li><p>解释1</p><blockquote><p>一个本地的git repo只有一个工作区和暂存区，但是有多个分支的提交区，而我们的checkout只是将HEAD指针从一个分支切换到另一个分支。</p></blockquote><p>所以：</p><ol><li><p>切换后工作区内容是branch的工作内容</p></li><li><p>经过测试，如果切回dev分支，进行<code>add --&gt; commi</code>t 再切回master就回到       master工作区。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561019439523.png" alt="1561019439523"></p></li></ol></li></ul></li><li><p>而dev的工作还未完成，不想提交，所以先把dev的工作stash一下，然后切换到master：</p><ol><li><p>先git add test</p><blockquote><p>:warning:  为什么要先add test文件？</p><p>test文件是新建，还未被git管理！让git add <strong>追踪test文件</strong>，否则即使 git stash ，test文件也依然会出现在master工作目录中！</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li><li><p>git stash 然后切换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561021862083.png" alt="1561021862083"></p></li><li><p>恢复dev工作目录</p><p>简单恢复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop  <span class="comment"># 恢复的同时把stash内容也删了</span></span><br></pre></td></tr></table></figure><p>有多个因此目录，可以配合下面目录恢复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list  </span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br><span class="line">$ git stash apply stash@&#123;0&#125; <span class="comment"># 恢复不会删除stash内容</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>在master建立分支issue101并切换。</p></li><li><p>在issue101上修复漏洞。</p></li><li><p>修复后，在master上合并issue101  。</p></li><li><p>切回dev，恢复原本工作，继续工作。</p></li></ol></li></ul><h3 id="4-5-删除分支">4.5 删除分支</h3><p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h3 id="4-6-多人协作">4.6 多人协作</h3><ul><li><p><strong>查看分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v  <span class="comment"># 带-v参数查看更加详细</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561023498006.png" alt="1561023498006"></p></li><li><p><strong>push 推送分支</strong></p><p><code>git push &lt;远程库名&gt; &lt;要推送分支名&gt;</code></p><blockquote><p>​      推送本地主分支master到 origin master，相当用本地master版本覆盖远程origin master版本。</p><p>:warning: git push 只能用户该项目属于自己的情况，因为要输入账号密码！参与他人开源：</p><ul><li>成为该开源项目贡献者（由项目作者设置）</li><li>fork 该项目 ----&gt; clone到本地----&gt; 修改 ----&gt; 发起 pull requset —&gt; 讨论 &amp; 等待合并</li></ul><p>还有其他更多情况，如产生冲突等，查看：<a href="%5Bhttps://progit.bootcss.com/#_%E5%AF%B9%E9%A1%B9%E7%9B%AE%E5%81%9A%E5%87%BA%E8%B4%A1%E7%8C%AE%5D(https://progit.bootcss.com/#_%E5%AF%B9%E9%A1%B9%E7%9B%AE%E5%81%9A%E5%87%BA%E8%B4%A1%E7%8C%AE)">pro git 中文# 对项目做出贡献</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561024444763.png" alt="1561024444763"></p><blockquote><p>推送其他分支到远程库 ，也可以查看。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561024648502.png" alt="1561024648502"></p></li><li><p>clone 克隆分支工作</p><p>多人协作时，大家都会往<strong>远程库</strong><code>master</code>和<code>dev</code>分支上推送各自的修改。</p><ol><li><p>克隆主分支</p><blockquote><p>:warning: 克隆只能克隆master分支！！</p></blockquote><p>现在，模拟你的小伙伴，在另一台电脑（注意要把SSH Key添加到GitHub）克隆：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:michaelliao/Python-100-Days</span><br></pre></td></tr></table></figure></li><li><p>克隆远程dev分支开发</p><p>由于只能克隆master分支，而又要在远程dev分支开发，那么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>之后就可进行修改 —&gt; 提交 ：git push了</p></li></ol></li><li><p><code>git pull</code></p><blockquote><p>一种应用情况：A、B都克隆了项目，在远程分支dev上进行开发（分别在本地也克隆dev分支）</p><ol><li><p>A修改了文件 README，并进行了push提交 。</p></li><li><p>你也修改了README，进行提交修改，会出错，原因是</p><p>:warning:<strong>远程分支比你的本地更新！</strong></p></li><li><p>只有先 pull 最新分支你的分支合并 —&gt; 解决冲突—&gt;提交</p></li></ol></blockquote><p><code>git pull</code>命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并，它的完整格式稍稍有点复杂。</p><blockquote><p>在默认模式下，<code>git pull</code>是<code>git fetch</code>后跟<code>git merge FETCH_HEAD</code>的缩写。</p><p>git pull == git fetch+  git merge （默认是检索头部合并到当前分支）</p><p>:warning: 使用–rebase，它运行<code>git rebase</code>而不是<code>git merge</code>。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull&lt;可选参数&gt; &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span></span><br></pre></td></tr></table></figure><h2 id="示例">示例</h2><p>比如，要取回<code>origin</code>主机的<code>next</code>分支，与本地的<code>master</code>分支合并：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin next:master</span></span><br></pre></td></tr></table></figure><ul><li><p>省略当前分支名</p><p>如果远程分支(<code>next</code>)要与当前分支合并，则冒号后面的部分可以省略。上面命令可以简写为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin next</span></span><br></pre></td></tr></table></figure><p>上面命令表示，取回<code>origin/next</code>分支，再与当前分支合并。实质上，这等同于先做<code>git fetch</code>，再执行<code>git merge</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/next</span></span><br></pre></td></tr></table></figure></li><li><p>省略远程分支名</p><blockquote><p>某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在<code>git clone</code>的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的<code>master</code>分支自动”追踪”<code>origin/master</code>分支。</p><p>Git也允许手动建立追踪关系，指定<code>master</code>分支追踪<code>origin/next</code>分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream master origin/next</span></span><br></pre></td></tr></table></figure></blockquote><p>如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin</span></span><br></pre></td></tr></table></figure><p>上面命令表示，本地的当前分支自动与对应的<code>origin</code>主机”追踪分支”(remote-tracking branch)进行合并。</p></li><li><p>省略远程主机名</p><p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>git fetch和git pull的区别</strong></p><ol><li><em>git fetch</em>：相当于是从远程获取最新版本到本地，不会自动合并。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p master..origin/master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/master</span></span><br></pre></td></tr></table></figure><p>以上命令的含义：</p><ul><li>首先从远程的<code>origin</code>的<code>master</code>主分支下载最新的版本到<code>origin/master</code>分支上</li><li>然后比较本地的<code>master</code>分支和<code>origin/master</code>分支的差别</li><li>最后进行合并</li></ul><p>上述过程其实可以用以下更清晰的方式来进行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin master:tmp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff tmp</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge tmp</span></span><br></pre></td></tr></table></figure><ol start="2"><li><em>git pull</em>：相当于是从远程获取最新版本并<code>merge</code>到本地</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin maste</span><br></pre></td></tr></table></figure></li></ul><h2 id="五、标签管理">五、标签管理</h2><h3 id="5-1-创建标签">5.1 创建标签</h3><h3 id="5-2-操作标签">5.2 操作标签</h3><h2 id="六、使用Github">六、使用Github</h2><h3 id="6-1-简单上传">6.1 简单上传</h3><ol><li><p>设置用户信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;hwh&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;380141202@qq.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>git init 初始化仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></li><li><p>本地创建ssh key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;380141202@qq.com&quot;</span> <span class="comment"># 后面会要求设置密码可不设置</span></span><br></pre></td></tr></table></figure><p>然后会在：C:\Users\80651\.ssh 生成ssh key 文件，其下有一个公钥 <code>id_rsa.pub</code>，记事本打开复制。</p></li><li><p>打开github设置</p><p>打开github 在个人设置中添加 **2.**中ssh key。</p><p>可用 <code>ssh -T</code>查看是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></li><li><p>对文件一些操作</p><p>比如，这里以增加一个README文件，然后<strong>git commit 提交</strong>到版本库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add README   <span class="comment"># 也可add . 提交所有新建、修改文件</span></span><br><span class="line">$ git commit -m <span class="string">&#x27;增加readme&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>push 上传到版本库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><blockquote><p>Q : git push 出现错误 ‘’ error: failed to push some refs to git‘’</p><p>A : 一般是因为github中的<code>README.md</code>文件不在本地代码目录中</p><ul><li><p>添加 -f 参数强制覆盖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure></li><li><p>通过如下命令进行github与本地代码合并:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git pull --rebase origin master   <span class="comment"># 先和本地代码合并</span></span><br><span class="line">$ git push    <span class="comment"># 然后再上传</span></span><br></pre></td></tr></table></figure></li></ul></blockquote></li></ol><h3 id="6-2-参与开源项目">6.2 参与开源项目</h3><blockquote><p>可参考：<a href="https://www.zhihu.com/question/21682976/answer/79489643">GitHub的Pull Request 是指什么意思</a></p></blockquote><h2 id="七、自定义Git">七、自定义Git</h2><ol><li><p>服务器端安装Git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install git</span><br></pre></td></tr></table></figure></li><li><p>创建用户 &amp; 组 管理仓库目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ groupadd git</span><br><span class="line">$ useradd git -g git  <span class="comment"># -g 参数表示把用户gituser主组设置为 git</span></span><br></pre></td></tr></table></figure></li><li><p>创建目录</p><p>我们先创建一个目录<code>gitrepo</code>用来管理其下仓库，一般习惯在 /var下创建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var</span><br><span class="line">$ mkdir gitrepo</span><br></pre></td></tr></table></figure><p>给其设置好用户 &amp; 组，便于管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chown -R gituser:git gitrepo <span class="comment"># 把目录gitrepo 设置用户gituser &amp; 组 git</span></span><br></pre></td></tr></table></figure><p><code>ls -l</code> 查看是否设置成功：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561122220352.png" alt="1561122220352"></p></li><li><p>创建仓库</p><p>创建<code>hwhComputer2Backup.git</code>仓库，并初始化用来上传电脑备份。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> gitrepo  <span class="comment"># 注意先切换到git下</span></span><br><span class="line">$ git init --bare hwhComputer2Backup.git</span><br></pre></td></tr></table></figure></li><li><p>创建证书</p><ul><li><p>在本地电脑上</p><p>执行以下命令创建ssh 公钥。会在：<code>C:\Users\80651\\.ssh</code> 生成ssh key 文件，其下有一个公钥 <code>id_rsa.pub</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;380141202@qq.com&quot;</span> <span class="comment"># 后面会要求设置密码可不设置</span></span><br></pre></td></tr></table></figure></li><li><p>切回服务端</p><blockquote><p>裸机需创建<code>/home/git/.ssh/authorized_keys</code>文件。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> gitrepo/</span><br><span class="line">$ mkdir .ssh</span><br><span class="line">$ touch .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>然后把本地电脑上公钥复制导入，一行一个（？）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561123680464.png" alt="1561123680464"></p></li></ul></li><li><p>再次修改权限</p><blockquote><p>创建的子目录 用户 &amp; 组 默认是 root root</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561124160395.png" alt="1561124160395"></p><p>:warning:由于.ssh &amp; 仓库 hwhComputer2Backup.git 都不属于 gituser ，所有还需设置权限。否则进行 push pull 操作 没有足够权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var</span><br><span class="line">$ chown -R gituser:git gitrepo</span><br></pre></td></tr></table></figure></li><li><p>本地上传文件</p><ol><li><p>添加用户信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;hwh&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;380141202@qq.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>初始化本地仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> D:/hwh/uploadToGit</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure></li><li><p>把本地仓库添加到版本库</p><blockquote><p>错误：c#程序练习 does not have a commit checked out</p><p>解决：是因为 c#程序练习 这个文件夹已经被初始化，查看隐藏文件可以发现 .git文件删除其即可。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add .  <span class="comment"># add . 提交所有新建、修改文件</span></span><br><span class="line">$ git commit -m <span class="string">&#x27;第一次备份文件&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>本地仓库关联远程库</p><blockquote><p>移除当前远程连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin </span><br></pre></td></tr></table></figure></blockquote><p><code>git remote add origin &lt;服务端用户名&gt;@&lt;远程库名地址&gt;:&lt;远程仓库地址&gt;</code></p><p>:warning:<code>&lt;服务端用户名&gt; :</code> 是在服务端的用户！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin gituser@129.28.154.240:/var/gitrepo/hwhComputer2Backup.git</span><br></pre></td></tr></table></figure></li><li><p>推送到远程库</p><blockquote><p>似乎由于 <em>ssh key</em> 设置不对，<em>git push</em> 要输入用户 <em>gituser</em> 的密码 123456？</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master  <span class="comment"># 第一次推送带 -u 参数</span></span><br></pre></td></tr></table></figure><p>等待上传服务器(速度有点慢)：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561128011507.png" alt="1561128011507"></p></li></ol></li></ol><h2 id="八、debug-记录">八、<code>debug</code> 记录</h2><blockquote><p><strong>ERROR</strong>：由于存在 <code>&gt;100M</code> 文件，提交后报错，不允许提交超过<code>100M</code> 文件，进行如下操作：</p><ul><li>压缩并删除<code>&gt;100M</code>文件</li><li>将相应文件加入 <code>.gitignore</code></li><li>再次<code>commit</code>  --&gt; <code>push</code></li></ul><p>依旧报相同错误。</p></blockquote><p>解决办法如下，参考：<a href="https://medium.com/@marcosantonocito/fixing-the-gh001-large-files-detected-you-may-want-to-try-git-large-file-storage-43336b983272">Fixing the “GH001…</a></p><ol><li><p>删除文件</p><blockquote><p>建议可以先回退最近的<code>commit</code> 分支</p></blockquote><p>利用以下命令删除所有在仓库中  <code>&gt;100M</code> 的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --index-filter <span class="string">&#x27;git rm --cached --ignore-unmatch &lt;大于100M文件URL&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>例如，我的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --index-filter <span class="string">&#x27;git rm --cached --ignore-unmatch  Experiment/Ex4_CustomerForecast/src/train.csv&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>再次提交</p><p>为了保险，可以先：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached ./   <span class="comment"># 本地代码不会被删除</span></span><br></pre></td></tr></table></figure><p>接下来正常：<code>git add --&gt; git commit --&gt; git push</code> 即可</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习基础（三）OpenCV</title>
      <link href="/2021/11/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89OpenCV/"/>
      <url>/2021/11/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89OpenCV/</url>
      
        <content type="html"><![CDATA[<h1>OpenCV</h1><h2 id="一、初识OpenCV">一、初识OpenCV</h2><p>使用以下命令可以一键安装 <em>OpenCV</em> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c menpo opencv</span><br></pre></td></tr></table></figure><h3 id="1-1-环境搭建">1.1 环境搭建</h3><p><img src="https://i.loli.net/2021/11/25/bIr8YQXkGJ6gVqD.png" alt="1574252314095"></p><p>简单测试是否搭建成功OpenCV：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.测试打开图片</span></span><br><span class="line">src = cv.imread(<span class="string">&quot;C:/Users/86151/Pictures/1571142354306.png&quot;</span>)</span><br><span class="line"><span class="comment"># 打开一个名为“test”的窗口（不知道有什么用？）</span></span><br><span class="line">cv.namedWindow(<span class="string">&quot;test&quot;</span>,cv.WINDOW_AUTOSIZE) </span><br><span class="line"><span class="comment"># 打开指定路径图片</span></span><br><span class="line">cv.imshow(<span class="string">&quot;111&quot;</span>,src)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)    <span class="comment"># 等待用户输入关闭图片，这里好像任意键关闭</span></span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello opencv!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="1-2-图像加载和保存">1.2 图像加载和保存</h3><h4 id="1-2-1-图片：读取-基本属性">1.2.1 图片：读取+基本属性</h4><blockquote><p>显示图片同时打印一些基本信息。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2.读取图片：中文路径好像会报错</span></span><br><span class="line"></span><br><span class="line">imageSrc = <span class="string">r&quot;C:/Users/86151/Pictures/1571142354306.png&quot;</span></span><br><span class="line">image = cv.imread(imageSrc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图片和基本信息</span></span><br><span class="line">cv.imshow(<span class="string">&quot;hwh&quot;</span>,image)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(image))      <span class="comment"># &lt;class &#x27;numpy.ndarray&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(image.shape)      <span class="comment"># (278, 1068, 3),依次对应：宽、高、通道数</span></span><br><span class="line"><span class="built_in">print</span>(image.size)       <span class="comment"># 890712 = 278*1068*3</span></span><br><span class="line"><span class="built_in">print</span>(image.dtype)      <span class="comment"># uint8,每个像素基本单元？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存图片</span></span><br><span class="line">cv.imwrite(<span class="string">&quot;D:/result.png&quot;</span>,image)</span><br></pre></td></tr></table></figure><p>图片使用 <code>cv.imread</code> 读取后三位 <code>numpy</code> 数组，例如 <em>image[0,0,0]</em>  索引第一个像素值。</p><blockquote><p>栗子1：将图片RGB三通道进行拆分、合并分别展示。</p></blockquote><p>首先我们可以利用 <code>cv.split()</code> 将图片进行分隔：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">image = cv.imread(<span class="string">r&quot;C:\Users\86151\Pictures\standingCat.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># cv.split：将图片分割为BGR三通道</span></span><br><span class="line">b,g,r = cv.split(image)</span><br><span class="line">cv.imshow(<span class="string">&#x27;r&#x27;</span>,r)</span><br><span class="line">cv.imshow(<span class="string">&#x27;g&#x27;</span>,g)</span><br><span class="line">cv.imshow(<span class="string">&#x27;b&#x27;</span>,b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cv.merge：合并成RGB（不是BGR）图像</span></span><br><span class="line">rgb = cv.merge([r,g,b])</span><br><span class="line">cv.imshow(<span class="string">&#x27;rgb&#x27;</span>,rgb)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/25/V71ksgqUWHA9Cez.png" alt="1574600332445"></p><h5 id="其它：numpy创建图片">其它：numpy创建图片</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一张三通道黑色图片：255*255*3</span></span><br><span class="line"></span><br><span class="line">image = np.zeros((<span class="number">255</span>,<span class="number">255</span>,<span class="number">3</span>),np.uint8)  <span class="comment"># 每个像素值都占一个字节（0-255）</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;black&#x27;</span>,image)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/25/d8hWpZBnLGDTJmz.png" alt="1574604545562"></p><h4 id="1-2-2-视频：读取">1.2.2 视频：读取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3.视频</span></span><br><span class="line"><span class="comment"># VideoCapture：指定视频路径，不指定（参数=0）则是打开自带摄像头</span></span><br><span class="line">capture = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    ret,frame = capture.read()</span><br><span class="line">    <span class="comment"># cv.flip: 使图像镜像颠倒，恢复正常</span></span><br><span class="line">    frame = cv.flip(frame,<span class="number">1</span>)</span><br><span class="line">    cv.imshow(<span class="string">&quot;video&quot;</span>,frame)</span><br><span class="line">    <span class="comment"># cv.waitKey:每处理一帧都等待50ms，同时当按下ESC(ASCII=27)退出</span></span><br><span class="line">    c = cv.waitKey(<span class="number">50</span>)</span><br><span class="line">    <span class="keyword">if</span> c==<span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="1-3-色彩空间">1.3 色彩空间</h3><blockquote><p>该部分主要参考：<a href="https://blog.csdn.net/renhaofan/article/details/82632132">图像色彩空间总结</a></p></blockquote><h4 id="1-3-1-色彩空间初识">1.3.1 色彩空间初识</h4><ul><li><p>图像通道</p><p>从数学方式理解，一张图片是一个数值矩阵。如果有<code>n</code> 个通道，则指按*<u>不同方式</u>* 可分解成 <code>n</code> 个同大小、不同数值矩阵之和。</p><p>如下三通道<code>RGB</code> ，可将原始彩色图片 —&gt; 分解成 <code>RGB</code> 三通道：</p><p><img src="https://i.loli.net/2021/11/25/GUk5yzM9HCjRTJw.jpg" alt="è¿éåå¾çæè¿°"></p><ul><li><code>RGB</code> 三个分量 R、G、B取值大小在 <code>[0,255]</code> 之间。</li></ul></li></ul><p>常用色彩空间有：BGR、RGB、GRAY、RGB、HSV、YUV 等</p><h4 id="1-3-2-色彩空间转换">1.3.2 色彩空间转换</h4><p>简单使用如下代码可以进行不同色彩空间的转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4.色彩空间转换</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\Users\86151\Pictures\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&quot;standingCat&quot;</span>,image)</span><br><span class="line"><span class="comment"># 转换为GRAY</span></span><br><span class="line">gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line">cv.imshow(<span class="string">&quot;gray&quot;</span>,gray)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为RGB</span></span><br><span class="line">RGB = cv.cvtColor(image,cv.COLOR_BGR2RGB)</span><br><span class="line">cv.imshow(<span class="string">&quot;RGB&quot;</span>,RGB)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="HSV空间颜色三通道范围">HSV空间颜色三通道范围</h5><p><img src="https://i.loli.net/2021/11/25/SBized3gEqH15Db.png" alt="1574652309707"></p><blockquote><p>栗子 1：将视频中红色转换为 --&gt;白色突出显示，其余颜色都是黑色便于跟踪。</p></blockquote><p><img src="https://i.loli.net/2021/11/25/nP6tOK9l5bpaXWu.png" alt="1574652931443"></p><ul><li>在图像处理中，通常不会直接对<code>RGB</code>图像做处理，因为<code>RGB</code>和人类视觉相差较远。故下面代码将每一帧都转换到 <code>HSV</code> 色彩空间。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5.视频色彩空间转换</span></span><br><span class="line">capture = cv.VideoCapture(<span class="string">&quot;D:/hwh/uploadToGit/code/python/5_learn_pytorch/src/video1.mp4&quot;</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    ret,frame = capture.read()</span><br><span class="line">    <span class="keyword">if</span> ret == <span class="literal">False</span>:    <span class="comment"># 判断视频流是否读取完毕</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 转换到hsv色彩空间，返回hsv帧</span></span><br><span class="line">    hsv = cv.cvtColor(frame,cv.COLOR_BGR2HSV)</span><br><span class="line">    <span class="comment"># 设置黑色像素三通道值阀值范围</span></span><br><span class="line">    <span class="comment"># 将hsv帧转换为二值化mask帧</span></span><br><span class="line">    lower_hsv = np.array([<span class="number">0</span>,<span class="number">43</span> ,<span class="number">46</span>])     <span class="comment"># 设置红色最低三通道值（在hsv色彩空间）</span></span><br><span class="line">    upper_hsv = np.array([<span class="number">10</span>,<span class="number">255</span>,<span class="number">255</span>])   <span class="comment"># 设置红色最高三通道值（在hsv色彩空间）</span></span><br><span class="line">    mask = cv.inRange(hsv,lowerb=lower_hsv,upperb=upper_hsv)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示原始视频</span></span><br><span class="line">    cv.namedWindow(<span class="string">&quot;testVideo&quot;</span>,<span class="number">0</span>)        <span class="comment"># 第二参数不明</span></span><br><span class="line">    cv.resizeWindow(<span class="string">&quot;testVideo&quot;</span>,<span class="number">900</span>,<span class="number">600</span>) <span class="comment"># 设置窗口大小</span></span><br><span class="line">    cv.imshow(<span class="string">&quot;testVideo&quot;</span>,frame)         <span class="comment"># 显示当前读取的帧</span></span><br><span class="line">    <span class="comment"># 显示mask二值化视频</span></span><br><span class="line">    cv.namedWindow(<span class="string">&quot;mask&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    cv.resizeWindow(<span class="string">&quot;mask&quot;</span>, <span class="number">900</span>, <span class="number">600</span>)</span><br><span class="line">    cv.imshow(<span class="string">&quot;mask&quot;</span>,mask)</span><br><span class="line">    c = cv.waitKey(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">if</span> c == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="1-4-像素运算">1.4 像素运算</h3><h4 id="1-4-1-基本加减乘除">1.4.1 基本加减乘除</h4><blockquote><p>试分析，下面两张图片进行加减乘除得到的结果。</p></blockquote><p><img src="https://i.loli.net/2021/11/25/s5NJvd7C2w1XPUS.png" alt="1574602887982"></p><p>定义基本代码：</p><p><img src="https://i.loli.net/2021/11/25/fksyc5Xj7ziu6qt.png" alt="1574603004141"></p><p><em><u>加减操作：</u></em></p><p><img src="https://i.loli.net/2021/11/25/9Z5643YokhaizDt.png" alt="1574603303238"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图片相加</span></span><br><span class="line">add_image = cv.add(src1,src2);</span><br><span class="line"><span class="comment"># 图片相减</span></span><br><span class="line">substract_image = cv.substract(src1,src2);</span><br></pre></td></tr></table></figure><ul><li>图片相加：黑色=0，白色=255。所以src1黑色背景相加对src2没影响，而src1白色字体和src2相加会超过255被截断依旧显示Linux白色字体。</li><li>图片相减：背景是黑色？因为src1背景黑色-src2 &lt; 0，依旧取0故结果为黑色 ； 字体五颜六色？因为src中Linux字体是白色=255，减去src2值，变成其它颜色了。</li></ul><p><em><u>乘法操作：</u></em></p><p><img src="https://i.loli.net/2021/11/25/346tJMNpdylF2QB.png" alt="1574603542400"></p><ul><li>图片相乘：背景黑色？因为src1黑色=0 * 第二张图对应部分 == 0 ，还是显示黑色 ； <em><u>字体是白色周围又五颜六色？</u></em> 这是因为 src1中Linux字体周围有反锯齿，周围边缘有平滑有模糊，它周围像素值并不为0，和src2相乘后，所以最终像素值并不为0而相乘值变大了就容易显示出其它颜色。</li></ul><h4 id="14-2-MASK（掩膜）">14.2 MASK（掩膜）</h4><blockquote><p>MASK掩膜，即图和掩膜按位与进行运算，筛选出感兴趣的区域。</p></blockquote><p>由于mask和原图像素值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>255</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">∈[0,255]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">255</span><span class="mclose">]</span></span></span></span> ，所以定义逻辑与如下：</p><ul><li>mask和原图对应点像素值都 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> ，则为真，输出*<u>原图像素像素值</u>*</li><li>其中一个等于0，则为假，输出对于*<u>点像素值为0</u>*</li></ul><p>这样定义mask意义在于：</p><ul><li>对于自己敢兴趣的区域，mask=0，则按位与必为0（显示为黑色）</li><li>自己不感兴趣的区域设置 mask&gt;0 ,则依旧输出为原图像素像素值</li></ul><p>举个简单的例子：<a href="https://blog.csdn.net/yl_best/article/details/87877110">更多参考</a></p><p><img src="https://i.loli.net/2021/11/25/xZTi2sFX4A5K6rN.png" alt="1574654724727"></p><ul><li>mask只能是二维矩阵，与原图 <code>shape[:2]</code> 相同（<code>shape[:2]</code> 是 <code>1*3</code> 矩阵，当其是一维矩阵 <code>[:2]</code> 索引的是前两个数字，而非前两行！）</li></ul><h4 id="1-4-3-逻辑操作">1.4.3 逻辑操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">image1 = cv.imread(<span class="string">r&quot;C:\Users\86151\Pictures\test1.jpg&quot;</span>)</span><br><span class="line">image2 = cv.imread(<span class="string">r&quot;C:\Users\86151\Pictures\test2.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 逻辑与</span></span><br><span class="line">dst1 = cv.bitwise_and(image1,image2)</span><br><span class="line"><span class="comment"># 逻辑或</span></span><br><span class="line">dst2 = cv.bitwise_or(image1,image2)</span><br><span class="line"><span class="comment"># 取反 </span></span><br><span class="line">dst3 = cv.bitwise_not(image1)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/25/2TZqbKBXRCP1jn5.png" alt="1574651721471"></p><ul><li>上图是逻辑与结果</li></ul><h5 id="栗子1：inRang-mask">栗子1：inRang+mask</h5><blockquote><p>实例：结合上节利用将图像掩膜mask，突出显示某些指定颜色变化为白色（其余为黑色）。</p><p>我们可以通过 <code>bitwise_and</code> ，使得突出显示的颜色为原来颜色，而非白色。</p></blockquote><p><img src="https://i.loli.net/2021/11/25/czTDhy1HxiSaGMr.png" alt="1574653487779"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">capture = cv.VideoCapture(<span class="string">&quot;D:/hwh/uploadToGit/code/python/5_learn_pytorch/src/video1.mp4&quot;</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    ret,frame = capture.read()</span><br><span class="line">    <span class="keyword">if</span> ret == <span class="literal">False</span>:    <span class="comment"># 视频流读取完毕</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    hsv = cv.cvtColor(frame,cv.COLOR_BGR2HSV)</span><br><span class="line">    lower_hsv = np.array([<span class="number">0</span>,<span class="number">43</span> ,<span class="number">46</span>])</span><br><span class="line">    upper_hsv = np.array([<span class="number">10</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line">    <span class="comment"># 在这里mask∈&#123;0,255&#125;，只有两个数字</span></span><br><span class="line">    mask =  </span><br><span class="line">    <span class="comment"># 前面两个参数原图进行相加（逻辑与不变？），然后通过掩膜mask按位与实现输出原图像素值？</span></span><br><span class="line">    dst = cv.bitwise_and(frame,frame,mask=mask)</span><br><span class="line">    <span class="comment"># 显示原始视频1</span></span><br><span class="line">    cv.namedWindow(<span class="string">&quot;testVideo&quot;</span>,<span class="number">0</span>)</span><br><span class="line">    cv.resizeWindow(<span class="string">&quot;testVideo&quot;</span>,<span class="number">600</span>,<span class="number">400</span>)</span><br><span class="line">    cv.imshow(<span class="string">&quot;testVideo&quot;</span>,frame)</span><br><span class="line">    <span class="comment"># 显示mask二值化视频2</span></span><br><span class="line">    cv.namedWindow(<span class="string">&quot;mask&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    cv.resizeWindow(<span class="string">&quot;mask&quot;</span>, <span class="number">600</span>, <span class="number">400</span>)</span><br><span class="line">    cv.imshow(<span class="string">&quot;mask&quot;</span>,mask)</span><br><span class="line">    <span class="comment"># 显示逻辑与操作视频3</span></span><br><span class="line">    cv.namedWindow(<span class="string">&quot;dst&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    cv.resizeWindow(<span class="string">&quot;dst&quot;</span>, <span class="number">600</span>, <span class="number">400</span>)</span><br><span class="line">    cv.imshow(<span class="string">&quot;dst&quot;</span>,dst)</span><br><span class="line">    c = cv.waitKey(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">if</span> c == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><ul><li><em>实际上<code>原图 &amp; mask</code>输出非黑部分和 原图区别还是挺大的啊？</em></li></ul><h4 id="1-4-4-其它：对比度addWeight等">1.4.4 其它：对比度addWeight等</h4><blockquote><p>有点类是<code>add</code>，也是进行图像叠加不过会设置各种权重和参数。按下公式计算结果图：</p><p><img src="https://i.loli.net/2021/11/25/uElpqnDHbCGT8gS.png" alt="1574668213000"></p><ul><li><em>alpha</em> ： <em>src1</em> 矩阵元素权重 ； <em>beta</em> ： <em>src2</em> 矩阵权重；<em>gamma</em> 最后各元素再相加值。</li></ul></blockquote><blockquote><p>举例：可通过 <em>addWeighted</em> 调整图片的亮度、对比度等</p></blockquote><ul><li>生成一张纯0矩阵 <em>blank</em> ，那<em>beta</em>有什么用？乘上一个零矩阵不变？</li><li>此时 <em>alpha</em> 即可是认为是对比度（等比增大元素像素值，黑色还是黑，别的会等比变大），<em>gamma</em> 可调节亮度（值越大越白–&gt;越亮）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7.addWeight 调整对比度</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\Users\86151\Pictures\standingCat.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 创建一张和原图等大纯黑图</span></span><br><span class="line">h,w,c = image.shape</span><br><span class="line">blank = np.zeros([h,w,c],dtype=image.dtype)</span><br><span class="line"><span class="comment"># 增加对比度</span></span><br><span class="line">dst = cv.addWeighted(image,<span class="number">1.2</span>,blank,<span class="number">1</span>-<span class="number">1.2</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图片</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;image&#x27;</span>,image)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dst&#x27;</span>,dst)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/25/uOjUs86MFy1wbYl.png" alt="1574668803789"></p><blockquote><p>其它操作。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印出图片三个通道像素均值</span></span><br><span class="line">m1 = cv.mean(src1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出图片三个通道像素均值和方差</span></span><br><span class="line">m1,dev1 = cv.meanStdDev(m1)</span><br></pre></td></tr></table></figure><h3 id="1-5-绘图与鼠标事件">1.5 绘图与鼠标事件</h3><blockquote><p>该部分主要参照于：<a href="https://www.kancloud.cn/aollo/aolloopencv/260982">openCV-Python 中文教程</a></p></blockquote><h4 id="1-5-1-绘图">1.5.1 绘图</h4><blockquote><p>以下为简单实例，绘制矩形、多边形、圆、椭圆、添加文字等</p></blockquote><img src="https://i.loli.net/2021/11/25/9KDmslWZe3uNRBt.png" width = "450" height = "250" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 1.画线</span></span><br><span class="line"><span class="comment"># 参数依次意义：原图，起始点坐标，终点坐标，线颜色，线厚度</span></span><br><span class="line">cv.line(image,(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">250</span>,<span class="number">250</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.画矩形</span></span><br><span class="line"><span class="comment"># 参数依次意义：原图，左上角坐标，右下角坐标，边颜色，边厚度</span></span><br><span class="line">cv.rectangle(image,(<span class="number">50</span>,<span class="number">50</span>),(<span class="number">250</span>,<span class="number">250</span>),(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.画圆</span></span><br><span class="line"><span class="comment"># 参数依次意义：原图，圆心坐标，半径，边颜色，边厚度</span></span><br><span class="line"><span class="comment"># 指定边厚度=-1，则圆会向内填充</span></span><br><span class="line">cv.circle(image,(<span class="number">250</span>,<span class="number">250</span>),<span class="number">20</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.画椭圆</span></span><br><span class="line"><span class="comment"># 参数依次意义：原图，圆心坐标，(长轴，短轴)，旋转角度，椭圆弧起始角，椭圆弧终止角，颜色</span></span><br><span class="line">cv.ellipse(image,(<span class="number">250</span>,<span class="number">250</span>),(<span class="number">100</span>,<span class="number">50</span>),<span class="number">30</span>,<span class="number">70</span>,<span class="number">360</span>,<span class="number">255</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.画多边形</span></span><br><span class="line"><span class="comment"># 参数依次意义：原图，多边形各点坐标，是否闭合，边颜色</span></span><br><span class="line"><span class="comment"># 指定多边形各点左边，[必须是int32]</span></span><br><span class="line">pts=np.array([[<span class="number">100</span>,<span class="number">50</span>],[<span class="number">200</span>,<span class="number">300</span>],[<span class="number">400</span>,<span class="number">200</span>],[<span class="number">500</span>,<span class="number">100</span>]],np.int32)</span><br><span class="line">cv.polylines(image,[pts],<span class="literal">True</span>,(<span class="number">46.46</span>,<span class="number">46</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.添加文字</span></span><br><span class="line"><span class="comment"># 参数依次意义：原图，绘制位置，字体类型，大小，颜色，粗细，类型</span></span><br><span class="line">font = cv.FONT_HERSHEY_SCRIPT_SIMPLEX</span><br><span class="line">cv.putText(image,<span class="string">&#x27;HELLO OPENCV!&#x27;</span>,(<span class="number">100</span>,<span class="number">200</span>),font,<span class="number">2</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),cv.LINE_4)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;result&#x27;</span>,image)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="1-5-2-鼠标事件">1.5.2 鼠标事件</h4><blockquote><p>利用鼠标事件，实现对图片指定区域裁剪。</p></blockquote><p><img src="https://i.loli.net/2021/11/25/4dDLKWimfpQekrc.png" alt="1574739798120"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 9.鼠标事件</span></span><br><span class="line"><span class="comment"># 1.创建回调函数：draw_circle(event,x,y,flags,param)</span></span><br><span class="line"><span class="comment"># 2.绑定回调函数&amp;窗口：setMouseCallback(&#x27;window&#x27;,draw_circle)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_circle</span>(<span class="params">event,x,y,flags,param</span>):</span></span><br><span class="line">    <span class="keyword">global</span> ix,iy,drawing,mode</span><br><span class="line">    <span class="comment"># 触发左键按下事件：EVENT_LBUTTONDOWN</span></span><br><span class="line">    <span class="keyword">if</span> event == cv.EVENT_LBUTTONDOWN:</span><br><span class="line">        ix,iy = x,y      <span class="comment"># 获取左键按下初始坐标</span></span><br><span class="line">    <span class="keyword">elif</span> event == cv.EVENT_LBUTTONUP:</span><br><span class="line">        cv.rectangle(image,(ix,iy),(x,y),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">1</span>)</span><br><span class="line">        cv.imshow(<span class="string">&#x27;crop&#x27;</span>,image[iy:y,ix:x])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 未解决：用鼠标移动+拖拽事件来判断，会每次移动画一个矩形，最后出现很多矩形</span></span><br><span class="line">    <span class="comment"># 已画的矩形又无法清除</span></span><br><span class="line">    <span class="comment"># 触发鼠标移动 &amp; 左键拖拽事件</span></span><br><span class="line">    <span class="comment"># elif event==cv.EVENT_MOUSEMOVE and flags==cv.EVENT_FLAG_LBUTTON:</span></span><br><span class="line">        <span class="comment"># if drawing == True:</span></span><br><span class="line">    <span class="comment"># elif event==cv.EVENT_LBUTTONUP:</span></span><br><span class="line">        <span class="comment"># drawing = False</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.namedWindow(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">cv.setMouseCallback(<span class="string">&#x27;img&#x27;</span>,draw_circle)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 放在循环里，一直显示？</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;img&#x27;</span>, image)</span><br><span class="line">    k = cv.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="二、进击！openCV！">二、进击！openCV！</h2><h3 id="2-1-ROI与泛洪填充">2.1 ROI与泛洪填充</h3><p>简单来说：获取感兴趣区域ROI对它进行指定方式填充。</p><blockquote><p>例子：截取指定区域，转换为GRAY图像并覆盖原图相同区域</p></blockquote><img src='https://i.loli.net/2021/11/25/eMsYPv3uXV5mK7a.png' width='20%' hight='20%'/><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ROI与填充</span></span><br><span class="line"><span class="comment"># 该例子分为三个部分：</span></span><br><span class="line"><span class="comment"># 1.实现指定图片对其进行部分截图</span></span><br><span class="line"><span class="comment"># 2.将截图部分转换为灰色，并覆盖原图相同区域</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crop_trans_Img</span>(<span class="params">event,x,y,flags,param</span>):</span></span><br><span class="line">    <span class="keyword">global</span> x0,y0,x1,y1</span><br><span class="line">    <span class="comment"># 触发左键按下事件：EVENT_LBUTTONDOWN</span></span><br><span class="line">    <span class="keyword">if</span> event == cv.EVENT_LBUTTONDOWN:</span><br><span class="line">        x0,y0 = x,y      <span class="comment"># 获取左键按下时初始坐标</span></span><br><span class="line">    <span class="comment"># 触发左键抬起事件：EVENT_LBUTTONUP，裁剪指定区域图片并转换为灰度图</span></span><br><span class="line">    <span class="keyword">elif</span> event == cv.EVENT_LBUTTONUP:</span><br><span class="line">        x1,y1 = x, y</span><br><span class="line">        <span class="comment"># 指定裁剪区域</span></span><br><span class="line">        cv.rectangle(image,(x0,y0),(x1,y1),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 获取裁决区域图</span></span><br><span class="line">        crop = image[y0:y1,x0:x1]</span><br><span class="line">        <span class="comment"># 裁剪区域转换为灰度图Gray</span></span><br><span class="line">        gray_crop = cv.cvtColor(crop,cv.COLOR_BGR2GRAY)</span><br><span class="line">        <span class="comment"># 将[灰度图--&gt; BGR图] --&gt; 覆盖原图指定区域 </span></span><br><span class="line">        image[y0:y1, x0:x1] = cv.cvtColor(gray_crop,cv.COLOR_GRAY2BGR)</span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.namedWindow(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">cv.setMouseCallback(<span class="string">&#x27;img&#x27;</span>,crop_trans_Img)  <span class="comment"># img窗口绑定回调函数</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv.imshow(<span class="string">&#x27;img&#x27;</span>, image)</span><br><span class="line">    k = cv.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h4 id="2-1-1-FloodFill：泛洪填充">2.1.1 FloodFill：泛洪填充</h4><p>定义，<code>floodFill(image,mask,seePoint,newVal,rect,loDiff,upDiff,scalar,flags)</code> :</p><p><img src="https://i.loli.net/2021/11/25/uitUnyW7P4TkvcV.png" alt="1574757962010"></p><ul><li><p>mask：必须宽高比原图大2像素；对不想填充区域设置为<em><strong>非零值</strong></em>，则不被填充（为原像素值）</p><ul><li>即mask &gt; 0 区域依旧表现为原图像素值；mask = 0 ，则会被指定填充（前面讲mask=0，值=0，即黑色，和这有点不同的）</li></ul></li><li><p>loDiff、upDiff：定义指定视为连通可被填充像素值范围（彩色还要设置三通道这种低、高Diff）</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574758099832.png" alt="1574758099832"></p></li><li><p>flags：填充方法选择，一般彩色图片选择<code>cv.FLOODFILL_FIXED_RANGE</code> ；还有可以选择<code>cv.FLOODFILL_FIXED_MASK_ONLY</code> 好像是只填充mask=0区域？？？？</p></li></ul><blockquote><p>利用mask，实现对指定区域进行泛洪填充。</p></blockquote><img src='https://i.loli.net/2021/11/25/se3S61jqwY4OkrB.png' width='30%' hight='30%'/><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">copyImg = image.copy()</span><br><span class="line">h,w = copyImg.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 设置mask，对于想感兴趣的区域设置0</span></span><br><span class="line">mask = np.ones([h+<span class="number">2</span>,w+<span class="number">2</span>],np.uint8)</span><br><span class="line">mask[<span class="number">100</span>:<span class="number">800</span>,<span class="number">200</span>:<span class="number">700</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment"># 进行泛洪填充</span></span><br><span class="line">cv.floodFill(copyImg,mask,(<span class="number">250</span>,<span class="number">250</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>),cv.FLOODFILL_FIXED_RANGE)</span><br><span class="line">cv.imshow(<span class="string">&#x27;flood&#x27;</span>,copyImg)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-模糊操作">2.2 模糊操作</h3><h4 id="2-2-1-均值模糊、中值模糊">2.2.1 均值模糊、中值模糊</h4><ul><li><p>均值模糊</p><ul><li><p>作用：对随机噪声有很好去噪效果</p></li><li><p>实现：通过指定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">size=(h,w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>的全<code>1</code>卷积核，计算新像素值 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>h</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mtext>范围像素线性加权</mtext></mrow><mrow><mi>h</mi><mo>∗</mo><mi>w</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{(h,w)范围像素线性加权}{h*w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mclose mtight">)</span><span class="mord cjk_fallback mtight">范围像素线性加权</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></li><li><p><em>API</em>：<code>blur(src,dst,ksize,anchor=Point(-1,-1), borderType=BORDER_DEFAULT )</code></p><p><img src="https://i.loli.net/2021/11/25/RymJiOhBEF4GVnS.png" alt="1574773303111"></p></li></ul></li><li><p>中值模糊</p><ul><li><p>作用：对椒盐噪声有很好去噪效果</p></li><li><p>实现：指定长宽相同<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">size=(h,h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span>卷积核， 在对图像进行卷积过程中，将卷积核区域内像素值从小–&gt;大排序，取中值像素作为整个区域像素值。</p></li><li><p><em>API</em> : <code>medianBlur( src,dst,ksize )</code></p><p><img src="https://i.loli.net/2021/11/25/pkAMODVd8UByPI9.png" alt="1574773609673"></p></li></ul></li></ul><blockquote><p>实例1：调用openCV的API来实现均值模糊，中值模糊。</p></blockquote><p><u><em>注：实际上好像下面都没有指定参数 <code>dst</code> 啊？</em></u></p><p><img src="https://i.loli.net/2021/11/25/qv3oRngJF16sK7k.png" alt="1574773707893"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;orign&#x27;</span>,image)</span><br><span class="line"><span class="comment"># 均值模糊</span></span><br><span class="line">avgBlurImg = cv.blur(image,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">cv.imshow(<span class="string">&#x27;avgBlur&#x27;</span>,avgBlurImg)</span><br><span class="line"><span class="comment"># 中值模糊</span></span><br><span class="line">medianBlurImg = cv.medianBlur(image,<span class="number">5</span>)  <span class="comment"># 必须是方阵，只指定一个数字即可</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;medianBlur&#x27;</span>,medianBlurImg)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><p>实例2：自定义卷积核实现均值滤波。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义卷积核实现均值滤波</span></span><br><span class="line">kernel = np.ones([<span class="number">5</span>,<span class="number">5</span>],np.float32)/<span class="number">25</span></span><br><span class="line">autoAvgImg = cv.filter2D(image,-<span class="number">1</span>,kernel=kernel)</span><br><span class="line">cv.imshow(<span class="string">&#x27;aotuAvgImg&#x27;</span>,autoAvgImg)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>效果和调用<em>API</em> 一样。</p><h4 id="2-2-2-高斯模糊">2.2.2 高斯模糊</h4><blockquote><p>和前均值模糊一样，也是进行卷积。只不过高斯模糊的卷积核附和高斯分布而已。</p></blockquote><p>高斯分布（又为正态分布）：</p><p><img src="https://i.loli.net/2021/11/25/46ptzCUW2AfDGhN.png" alt="1574775578169"></p><p>高斯模糊</p><ul><li><p>作用：对高斯噪声有较好处理效果</p></li><li><p><em>API</em> :  <code>GaussianBlur(src,ksize,sigmaX,dst,sigmaY,borderType: Any = None)</code></p><p><img src="https://i.loli.net/2021/11/25/mWeGU7pEQR4Zwj6.png" alt="1574777588431"></p></li></ul><blockquote><p>实例1：简单调用接口实现对图片的高斯模糊。</p></blockquote><img src='https://i.loli.net/2021/11/25/bxfuykT3GnI95Jv.png' width='40%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 13.高斯模糊</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"><span class="comment"># GaussianBlur:调用高斯模糊</span></span><br><span class="line"><span class="comment"># x标准差=sigmax=15，卷积核大小设置为0则会根据sigmax自动计算</span></span><br><span class="line">GaussianImg = cv.GaussianBlur(image,(<span class="number">0</span>,<span class="number">0</span>),<span class="number">15</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;guassian image&#x27;</span>,GaussianImg)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><p>实例2：利用高斯模糊对高斯噪声进行处理。</p></blockquote><p>可发现高斯噪声对高斯模糊产生结果没什么影响。</p><img src='https://i.loli.net/2021/11/25/wdhTGjnM1vgut3K.png' width='60%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 14.高斯模糊对高斯噪声进行处理</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给图片加上高斯噪声</span></span><br><span class="line">h,w,c = image.shape</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">        <span class="comment"># 生成高斯随机噪声像素值</span></span><br><span class="line">        <span class="comment"># loc:概率分布的均值；scale：概率分布标准差；size：输出的shape，默认输出一个</span></span><br><span class="line">        <span class="comment"># 例如正态分布（μ=0,σ=1 ） == random.normal(loc=0, scale=1, size)</span></span><br><span class="line">        s = np.random.normal(loc=<span class="number">0</span>,scale=<span class="number">20</span>,size=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取BGR三个通道对应像素值</span></span><br><span class="line">        b = image[row,col,<span class="number">0</span>]</span><br><span class="line">        g = image[row,col,<span class="number">1</span>]</span><br><span class="line">        r = image[row,col,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 给每个像素点加上高斯噪声生成的像素值</span></span><br><span class="line">        image[row, col, <span class="number">0</span>] = (b + s[<span class="number">0</span>]) % <span class="number">255</span></span><br><span class="line">        image[row, col, <span class="number">1</span>] = (g + s[<span class="number">1</span>]) % <span class="number">255</span></span><br><span class="line">        image[row, col, <span class="number">2</span>] = (r + s[<span class="number">2</span>]) % <span class="number">255</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;Guassian noise&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高斯模糊对高斯噪声图片进行处理</span></span><br><span class="line">GaussianImg = cv.GaussianBlur(image,(<span class="number">0</span>,<span class="number">0</span>),<span class="number">15</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;GaussianImg&#x27;</span>,GaussianImg)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="2-2-3-EPF模糊：高斯双边、均值偏移">2.2.3  EPF模糊：高斯双边、均值偏移</h4><blockquote><p>EPF，即边缘保留滤波。常用有基于高斯双边和均值偏移。</p></blockquote><p>我们知道，在前 <em><u>高斯模糊</u></em>  只考虑了空间分布，而没有像素之间差异问题：</p><ul><li>如果像素差异很大，说明实现显著特征，我们应该将它进行平滑吗？</li></ul><p>显然是不应该的，而且往往在 <em><u>图像边缘</u></em> 出现像素差异变大。在openCV中提供了：<em><u>高斯双边、均值漂移</u></em>  来实现边缘保留。</p><h5 id="高斯双边模糊">高斯双边模糊</h5><blockquote><p>高斯双边美颜效果杠杠的。</p></blockquote><p><img src="https://i.loli.net/2021/11/25/B3WngPioprZ9cTz.png" alt="1574824190173"></p><ul><li><p>上述是高斯双边模糊原理图（没太明白）</p></li><li><p><em>API</em> : <code>cv.bilateralFilter(src, d, sigmaColor, sigmaSpace[, dst[, borderType]])</code></p><p><img src="https://i.loli.net/2021/11/25/jJrgBbRcvCSFeK3.png" alt="1574824773446"></p><ul><li><code>d</code> : 滤波器大小，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>&gt;</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">d&gt;5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 执行效率低，一般取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">d=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>； <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d≤0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时由 <em>sigmaSpace</em>确定且成正比</li><li><code>sigmaColor</code> ：值越大，交界处即边缘越模糊</li><li><code>sigmaSpace</code> ：值越大，即颜色平均的地方越模糊</li></ul></li></ul><blockquote><p>一个简单测试：利用高斯双边模糊把刘欣变得更美美的。</p></blockquote><img src='https://i.loli.net/2021/11/25/XDPjQeN7c2UTEfg.png' width = '30%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 15.高斯双边模糊</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\testlx.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># d=0,由sigamColor确定；sigamColor=100 ；sigamSpace=15</span></span><br><span class="line"><span class="comment"># 好像又略过了dst参数啊？？</span></span><br><span class="line">lx_beautiful = cv.bilateralFilter(image,<span class="number">0</span>,<span class="number">100</span>,<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&quot;lx_beautiful&quot;</span>,lx_beautiful)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="均值飘移模糊">均值飘移模糊</h5><blockquote><p>也能保留边缘，但是更类似于卡通效果。</p></blockquote><p>均值飘移模糊：</p><ul><li><p>原理：<a href="https://blog.csdn.net/dcrmg/article/details/52705087"><em><u>又是什么色彩聚类平滑滤波，结合泛洪填充可以进行图像分割？</u></em> </a></p><img src='https://i.loli.net/2021/11/25/sLeAD95YmkgiIBp.png' width='30%'></li><li><p><em>API</em> : <code>pyrMeanShiftFiltering(src, sp, sr[, dst[, maxLevel[, termcrit]]])</code></p><p><img src="https://i.loli.net/2021/11/25/BJUCYFaMWoPH6ke.png" alt="1574825777384"></p><ul><li><code>sp、sr</code> ： 值越大，则图像色彩平滑效果越好，但耗时也越多。</li></ul></li></ul><blockquote><p>简单测试：均值漂移把刘欣变得…</p></blockquote><img src='https://i.loli.net/2021/11/25/84XkwohlKcdUWFt.png' width = '30%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 15.均值漂移模糊</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\testlx.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line">lx_beautiful = cv.pyrMeanShiftFiltering(image,<span class="number">10</span>,<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&quot;lx_beautiful&quot;</span>,lx_beautiful)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="2-3-图像直方图">2.3 图像直方图</h3><p>图像直方图：</p><ul><li><p>意义：直方图是图像 <em><u>像素强度</u></em> 分布的图形表达方式，统计每一个强度值所具有的像素个数。</p><p>例如下列灰度直方图：</p><p><img src="https://upload-images.jianshu.io/upload_images/14312364-74ec7304573d1830.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 轴代表灰度值（0-255） ； <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 轴代表同一个灰度值点的数目。</li><li><em><strong><u>彩色图像如何设置直方图？</u></strong></em> 三个通道值还是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>255</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">∈[0,255]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">255</span><span class="mclose">]</span></span></span></span> ,那么分别统计各个不同通道相同像素值就好了。</li></ul></li></ul><p>常用一些术语：</p><ul><li><p><em>range</em>：每个特征空间的取值范围，例如 range=[0,255]</p></li><li><p><em>bin</em>：直条或组距，表示每个特征子空间的段的数目</p></li></ul><p><img src="https://i.loli.net/2021/11/25/AxFj3eKaPo4hYNV.png" alt="1574826886242"></p><ul><li><p><em><strong>下面图像14位是什么意思，为什么会有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup></mrow><annotation encoding="application/x-tex">2^{14}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span></span></span></span> 不同像素值，不是只会 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>255</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">∈[0,255]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">255</span><span class="mclose">]</span></span></span></span>  ?</strong></em></p><p>这里指得应该是图像大小=14，然后灰度图会有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>14</mn><mo>∗</mo><mn>14</mn></mrow><annotation encoding="application/x-tex">14*14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">14</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">14</span></span></span></span> 个像素点。</p></li></ul><h4 id="2-3-1-实例：直方图初应用">2.3.1 实例：直方图初应用</h4><p>下面我们分别介绍两个<em>API</em> 来计算图像 <em>直方图</em> 和 <em>直方折线图</em> ：</p><ul><li><p><code>matplotlib::plt.hist()</code> 计算直方图</p><p><img src="https://i.loli.net/2021/11/25/Ll3TWOYoNtjP9Ap.png" alt="1574857367339"></p><ul><li><code>x </code> ：数组，必须是(n,)数组，<u><em>所以图像要用 <code>image.ravel()</code> 函数进行降维</em></u></li><li><code>bins</code> ：指定bin个数</li><li><code>range</code> ： 显示的区间</li></ul></li><li><p><code>cv.calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate]])</code></p><p>返回的是一个数组(<em>histSize</em>,1)，统计了指定 <em>histSize</em> 的像素强度统计个数。</p><p><img src="https://i.loli.net/2021/11/25/rRIDA8Cq3jkWHM9.png" alt="1574859087175"></p></li></ul><blockquote><p>实例1：利用<code>matplotlib::plt.hist()</code>绘制出图像不同像素强度统计数直方图</p></blockquote><img src='https://i.loli.net/2021/11/25/wkhRQfCK8WI3oGX.png' width='50%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 16.直方图</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"><span class="comment"># 绘制直方图</span></span><br><span class="line"><span class="comment"># image.ravel()将原图640*640*3维度降为一维 2288000=640*640*3</span></span><br><span class="line"><span class="comment"># 注意这里是256不是255</span></span><br><span class="line">plt.hist(image.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.show()</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><p>实例2：利用 <em>cv.calcHist()</em> 统计指定图像和通道的各个像素强度个数。</p></blockquote><img src='https://i.loli.net/2021/11/25/xfe927VqhmoylNO.png' width='50%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 17.绘制直方折线图？</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line">color = (<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;red&#x27;</span>)  <span class="comment"># 三个通道各个像素统计折线不同颜色</span></span><br><span class="line"><span class="keyword">for</span> i,color <span class="keyword">in</span> <span class="built_in">enumerate</span>(color):</span><br><span class="line">    hist =cv.calcHist([image],[i],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">    plt.plot(hist,color=color)</span><br><span class="line">    plt.xlim([<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="2-3-3-直方图应用">2.3.3 直方图应用</h4><h5 id="直方图均衡化">直方图均衡化</h5><blockquote><p>直方图均衡化：利用图像直方图 <em><u>对比度进行调整</u></em> 的方法。可参考<a href="https://www.cnblogs.com/my-love-is-python/p/10405811.html">这篇文章</a></p></blockquote><ul><li><p>原理：待补充</p></li><li><p><em>API ：</em></p><p><em><u>直方图均衡化 ：</u></em> <em>cv.equalizeHist(src[, dst])</em></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574862327976.png" alt="1574862327976"></p><p><em><u>局部直方图均衡化：</u></em>  <em>cv2.createCLAHA(clipLimit=8.0, titleGridSize=(8, 8))</em></p><ul><li><em>clipLimit</em> ：颜色对比度的阈值</li><li><em>titleGridSize</em> ：进行像素均衡化的网格大小，即在多少网格下进行直方图的均衡化操作</li></ul></li></ul><blockquote><p>实例1：通过直方图均衡化提升图像质量。</p></blockquote><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574862416340.png' width='50%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 18.直方图均衡化</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将原图转换为灰度图</span></span><br><span class="line">gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin_gay&#x27;</span>,gray)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直方图均衡化只能是灰度图，如果是彩色图？不能？</span></span><br><span class="line">dst = cv.equalizeHist(gray)</span><br><span class="line">cv.imshow(<span class="string">&#x27;equalHistImg&#x27;</span>,dst)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><p>实例2：局部图直方图均衡化，解决全局的均衡化整体亮度提升使得局部图像的细节变得模糊。</p></blockquote><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574863177058.png' width='50%'><ul><li><p>好像这张图不能体现局部直方图均衡化可以保留更多细节？下面这张图最右侧局部均衡化显然保存的人脸更多细节：</p><img src='https://img2018.cnblogs.com/blog/1396837/201902/1396837-20190220120341669-1864417603.png' width='80%'></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 19.局部直方图均衡化</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将原图转换为灰度图</span></span><br><span class="line">gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 显示全局均衡化图像</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;hist&#x27;</span>,cv.equalizeHist(gray))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化自适应直方图均衡化系数</span></span><br><span class="line">clahe = cv.createCLAHE(<span class="number">5.0</span>,(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">dst = clahe.apply(gray)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;clahe&#x27;</span>,dst)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="直方图比较">直方图比较</h5><blockquote><p>手动创建图像直方图方法 <code>create_rgb_hist</code> 没有太明白？</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574865114095.png" alt="1574865114095"></p><h5 id="直方图反向投影">直方图反向投影</h5><blockquote><p>该小节例子使用的范围归一化到[0,255]，而不是一值归一化。可查看 <a href="https://blog.csdn.net/qq_37764129/article/details/82313507">OpenCV中矩阵的归一化</a></p></blockquote><ul><li><p>作用：用于图像分割或查找图像中感兴趣的对象</p></li><li><p>归一化:<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574910939514.png" alt="1574910939514"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574910983214.png" alt="1574910983214"></p></li><li><p>计算反向直方图：<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574911073204.png" alt="1574911073204"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574911113101.png" alt="1574911113101"></p></li></ul><blockquote><p>实例1：计算二维直方图并显示。</p></blockquote><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574913199543.png' width='30%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 20.显示hsv二维直方图</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"><span class="comment"># 计算直方图反向投影先转换到hsv色彩空间(?)</span></span><br><span class="line">hsv = cv.cvtColor(image,cv.COLOR_BGR2HSV)</span><br><span class="line"><span class="comment"># hsv，因为亮度(v)很容易受到外界影响，所以我们认为颜色本质是hsv，h∈[0,180],v∈[0,256]</span></span><br><span class="line">hist = cv.calcHist([hsv],[<span class="number">0</span>,<span class="number">1</span>],<span class="literal">None</span>,[<span class="number">180</span>,<span class="number">256</span>],[<span class="number">0</span>,<span class="number">180</span>,<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">cv.imshow(<span class="string">&#x27;hist2D&#x27;</span>,hist)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><p>实例2：提取刘欣头发为感兴趣区域，进行反向直方图投影。</p></blockquote><p>:warning: 经过测试感兴趣区域应该是一类颜色，而不应该是整个脸什么的？</p><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574912802828.png' width='50%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 21.直方图反向投影</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取roi图像并转换到hsv色彩空间</span></span><br><span class="line">roi = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\testlx_roi2.jpg&quot;</span>)</span><br><span class="line">roi_hsv = cv.cvtColor(roi,cv.COLOR_BGR2HSV)</span><br><span class="line">cv.imshow(<span class="string">&#x27;roi&#x27;</span>,roi)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取目标图像并转换到hsv色彩空间</span></span><br><span class="line">target = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\testlx.jpg&quot;</span>)</span><br><span class="line">target_hsv = cv.cvtColor(target,cv.COLOR_BGR2HSV)</span><br><span class="line">cv.imshow(<span class="string">&#x27;target&#x27;</span>,target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算roi图像直方图并[范围]归一化到[0,255]</span></span><br><span class="line"><span class="comment"># roi_hist.shape=(180,256)</span></span><br><span class="line"><span class="comment"># 如果想效果更好，可以把bin不那么细化，即bin数目调整少点：[180,256] --&gt; [32,64]</span></span><br><span class="line">roi_hist = cv.calcHist([roi_hsv],[<span class="number">0</span>,<span class="number">1</span>],<span class="literal">None</span>,[<span class="number">180</span>,<span class="number">256</span>],[<span class="number">0</span>,<span class="number">180</span>,<span class="number">0</span>,<span class="number">256</span>]) </span><br><span class="line"><span class="comment"># 归一化范围至0-256，cv.NORM_MINMAX常用的线性平移缩放归一化</span></span><br><span class="line">cv.normalize(roi_hist,roi_hist,<span class="number">0</span>,<span class="number">256</span>,cv.NORM_MINMAX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算反向直方图投影</span></span><br><span class="line">dst = cv.calcBackProject([target_hsv],[<span class="number">0</span>,<span class="number">1</span>],roi_hist,[<span class="number">0</span>,<span class="number">180</span>,<span class="number">0</span>,<span class="number">256</span>],<span class="number">1</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dst&#x27;</span>,dst)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="2-4-模板匹配">2.4 模板匹配</h3><p>模板匹配即给定模板（<em>template</em>）在目标（<em>target</em>）中进行搜索匹配，画出锚框。</p><h4 id="匹配：matchTemplate">匹配：matchTemplate</h4><ul><li><p>原理：利用模板在目标图像匹配（卷积），返回所有匹配结果矩阵<strong>A</strong></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574925776285.png" alt="1574925776285"></p><ul><li>对于<a href="https://docs.opencv.org/master/df/dfb/group__imgproc__object.html#gga3a7850640f1fe1f58fe91a2d7583695dab65c042ed62c9e9e095a1e7e41fe2773">TM_SQDIFF</a> 方法，结果矩阵<strong>A</strong> 中*<u>最小值位置</u>* 对应最佳匹配时模板图像*<u>左上角</u>* 位置</li><li>对于<a href="https://docs.opencv.org/master/df/dfb/group__imgproc__object.html#gga3a7850640f1fe1f58fe91a2d7583695da5be00b45a4d99b5e42625b4400bfde65">TM_CCORR</a> or <a href="https://docs.opencv.org/master/df/dfb/group__imgproc__object.html#gga3a7850640f1fe1f58fe91a2d7583695dac5babb7dfda59544e3e31ea928f8cb16">TM_CCOEFF</a> 方法，<strong>A</strong> 中*<u>最大值位置</u>* 对应最佳匹配模板图像*<u>左上角</u>* 位置</li></ul></li><li><p>原型：<em>cv.matchTemplate(image, templ, method[, result[, mask]])</em></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574925200085.png" alt="1574925200085"></p></li></ul><blockquote><p>例1：给定模板图像猫脸，在目标图像猫中画出对应模板图像位置红框。</p></blockquote><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574926159367.png' width='60%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 22.模板匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取模板图像（猫脸）</span></span><br><span class="line">template = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat_roi.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;template&#x27;</span>,template)</span><br><span class="line">th,tw = template.shape[:<span class="number">2</span>]   <span class="comment"># shape=(h,w,c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取目标图像（猫）</span></span><br><span class="line">target = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模板匹配的三种方法</span></span><br><span class="line">methods = [cv.TM_SQDIFF_NORMED,cv.TM_CCOEFF_NORMED,cv.TM_CCORR_NORMED]</span><br><span class="line"></span><br><span class="line">tl = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> md <span class="keyword">in</span> methods:</span><br><span class="line">    <span class="comment"># 采用指定方法md,进行模板匹配</span></span><br><span class="line">    result = cv.matchTemplate(target,template,md)</span><br><span class="line">    <span class="comment"># minMaxLoc：返回矩阵中最小值、最大值、最小值位置，最大值位置</span></span><br><span class="line">    minVal,maxVal,minLoc,maxLoc = cv.minMaxLoc(result)</span><br><span class="line">    <span class="keyword">if</span> md == cv.TM_SQDIFF_NORMED:</span><br><span class="line">        tl = minLoc</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tl = maxLoc</span><br><span class="line">    <span class="comment"># 注意右下角 = （左上角x+宽，左上角y+高）</span></span><br><span class="line">    cv.rectangle(target,tl,(tl[<span class="number">0</span>]+tw,tl[<span class="number">1</span>]+th),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br><span class="line">    cv.imshow(<span class="built_in">str</span>(md),target)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="2-5-图像二值化">2.5 图像二值化</h3><blockquote><p>什么是图像的二值化？该部分主要参考 : <a href="https://blog.csdn.net/qq_37385726/article/details/82015545">图像二值化</a></p></blockquote><p>一幅图像包括目标物体、背景还有噪声，要想*<u>从多值的数字图像中直接提取出目标物体</u>*，通过设定一个阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。这是研究灰度变换的最特殊的方法，称为图像的二值化（Binarization）。</p><p>例如：将图像上的像素点的灰度值设置为0或255，整个图像呈现出明显的只有黑和白的视觉效果。</p><h4 id="1-hsv二值化：-inRange">1 hsv二值化： <em>inRange</em></h4><p>在之前我们还接触过 <em>inRange</em> 将图像进行二值化 ：</p><ul><li>在 <em>hsv</em> 色彩空间中，对于指定 $h_{min}-h_{max} 、s_{min}-s_{max} 、v_{min}-v_{max} $ 范围内像素值设置为白色其余为黑色。</li></ul><p>这是针对在 <em>hsv</em> 色彩空间，而下面 <em>threshold</em> 是指对 <em><u>单通道灰度图</u></em> 进行二值化。</p><h4 id="2-gray二值化：threshold">2 gray二值化：<em>threshold</em></h4><p><em><u>相关API</u></em> :</p><ul><li><em>cv2.threshold(img, threshold, maxval,type)</em><ul><li><em>threshold</em> : 是设定的阈值</li><li><em>maxval</em>: 当灰度值大于（或小于）阈值时将该灰度值赋成的值</li><li><em>type</em> : 当前二值化的方式（<em><strong>保持原样指的是保持原图像像素值</strong></em>）</li></ul></li></ul><blockquote><p><em>threshold</em> 方法针对 <em><u>单通道灰度图</u></em> ，彩色图要先转换为灰度图。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574929809949.png" alt="1574929809949"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 23.图像二值化：threshold</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">image_gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin_gray&#x27;</span>,image_gray)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行二值化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># THRESH_BINARY: 大于阈值=127，被置为255，小于阈值=127，被置为0</span></span><br><span class="line"><span class="comment"># 这里maxVal=255，是大于阈值被设置的值，而不是默认就设置为255！</span></span><br><span class="line">ret1,binary1 = cv.threshold(image_gray,<span class="number">127</span>,<span class="number">255</span>,<span class="built_in">type</span>=cv.THRESH_BINARY)</span><br><span class="line">cv.imshow(<span class="string">&#x27;THRESH_BINARY&#x27;</span>,binary1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># THRESH_BINARY_INV: 和THRESH_BINARY设置相反</span></span><br><span class="line">ret2,binary2 = cv.threshold(image_gray,<span class="number">127</span>,<span class="number">255</span>,<span class="built_in">type</span>=cv.THRESH_BINARY_INV)</span><br><span class="line">cv.imshow(<span class="string">&#x27;THRESH_BINARY_INV&#x27;</span>,binary2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># THRESH_TRUNC：大于阈值部分被置为threshold，小于部分保持原样（原图像素值）</span></span><br><span class="line"><span class="comment"># 这里及下面maxVal（0）设置不起作用，大于阈值为原图像值</span></span><br><span class="line">ret3,binary3 = cv.threshold(image_gray,<span class="number">127</span>,<span class="number">0</span>,<span class="built_in">type</span>=cv.THRESH_TRUNC )</span><br><span class="line">cv.imshow(<span class="string">&#x27;THRESH_TRUNC&#x27;</span>,binary3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># THRESH_TOZERO：小于阈值部分被置为0，大于部分保持不变（原图像素值）</span></span><br><span class="line">ret4,binary4 = cv.threshold(image_gray,<span class="number">127</span>,<span class="number">0</span>,<span class="built_in">type</span>=cv.THRESH_TOZERO )</span><br><span class="line">cv.imshow(<span class="string">&#x27;THRESH_TOZERO&#x27;</span>,binary4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># THRESH_TOZERO_INV ：大于阈值部分被置为0，小于部分保持不变 （原图像素值）</span></span><br><span class="line">ret5,binary5 = cv.threshold(image_gray,<span class="number">127</span>,<span class="number">0</span>,<span class="built_in">type</span>=cv.THRESH_TOZERO_INV )</span><br><span class="line">cv.imshow(<span class="string">&#x27;THRESH_TOZERO_INV&#x27;</span>,binary5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [重要] cv.THRESH_OTSU：是最大间差法，按图像灰度特性将图像分为前景和背景两部分</span></span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="3-gray二值化：adaptiveThreshold">3 gray二值化：<em>adaptiveThreshold</em></h4><blockquote><p>该部分主要参考：<a href="https://www.cnblogs.com/GaloisY/p/11037350.html">自适应化阈值操作</a></p></blockquote><p>自适应阈值，则是根据像素的 <em><u>邻域块的像素值分布来确定该像素位置上的二值化阈值</u></em>  ：</p><ul><li>每个像素位置处的二值化阈值不是固定不变的，而是由其周围邻域像素的分布来决定的</li><li>亮度较高图像区域二值化阈值通常较高，而亮度低的图像区域的二值化阈值则会相适应变小</li><li>不同亮度、对比度、纹理的局部图像区域将会拥有相对应的局部二值化阈值</li></ul><p><em>每一个像素计算阈值过程：</em></p><ul><li>首先该像素点周围 B*B 区域内像素加权平均（对应方法有平均值法、高斯平均两种方法）</li><li>最后减去一个常数C，得到该像素点的阈值</li></ul><p><em><u>相关API</u></em> :</p><ul><li><p><em>cv.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst])</em></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574930068730.png" alt="1574930068730"></p><ul><li><p><em>maxValue</em> ：阈值？</p></li><li><p><em>adaptiveType</em> : 指自适应的阈值 <em>求平均值方法</em>，同上有两种可选</p><ul><li>ADAPTIVE_THRESH_MEAN_C ：先求出领域块中的均值，再减去常数C</li><li>ADAPTIVE_THRESH_GAUSSIAN_C：局部邻域块的高斯加权和，最后减去常数C</li></ul></li><li><p><em>thresholdType</em> ：阈值类型，有两种可选：THRESH_BINARY 或THRESH_BINARY_INV <em><strong>？</strong></em></p><p>同前，THRESH_BINARY 大于阈值置为阈值，小于阈值置为0；THRESH_BINARY_INV 相反。</p></li><li><p><em>blockSize</em>： 指定的领域块区域大小，通常为3、5、7</p></li><li><p><em>C</em> : 上面说的常数C</p></li></ul></li></ul><blockquote><p>实例：可以看到自适应阈值化很好的保留了 <em><u>边缘信息</u></em> 。</p></blockquote><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574931630972.png' width='50%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 24.自适应阈值：adaptiveThreshold</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">image_gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin_gray&#x27;</span>,image_gray)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自适应阈值</span></span><br><span class="line"><span class="comment"># 不知道为什么设置C=10,blockSize=5(区域大小为5*5=25)</span></span><br><span class="line">adaptive_binary = cv.adaptiveThreshold(image_gray,<span class="number">255</span>,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,<span class="number">25</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;adaptive_binary&#x27;</span>,adaptive_binary)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="4-超大图像二值化">4 超大图像二值化</h4><blockquote><p>该部分主要参考：<a href="https://www.cnblogs.com/ssyfj/p/9273116.html">超大图像二值化和空白过滤</a></p></blockquote><p>处理超大图像的思路其实就是分块思想：</p><ul><li>将图像分成一个个小块</li><li>对每个小块进行 <em>threshold</em> 、<em>adaptiveThreshold</em> 二值化操作，获取二值化图像</li><li>将原图（灰度图像）对应区域覆盖为上述的二值化图像</li></ul><blockquote><p>分别使用全局阈值/局部阈值对分块图像进行处理比较。</p></blockquote><p><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574943278597.png' width='50%'><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574943355871.png' width='50%'></p><ul><li>左侧全局阈值处理，导致每个分块之间的图像差距较大，<em><u>出现分块边界</u></em> 现象。</li><li>右侧局部阈值处理，就没有明显的分块现象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 25.超大图像二值化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">big_image_binary</span>(<span class="params">image</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(image.shape)  <span class="comment">#(4208, 2368, 3)　　</span></span><br><span class="line">    cw,ch = <span class="number">256</span>,<span class="number">256</span></span><br><span class="line">    h,w = image.shape[:<span class="number">2</span>]</span><br><span class="line">    <span class="comment">#要二值化图像，要先进行灰度化处理</span></span><br><span class="line">    gray = cv.cvtColor(image,cv.COLOR_RGB2GRAY)   </span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,h,ch):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,w,cw):</span><br><span class="line">            roi = gray[row:row+ch,col:col+cw]           <span class="comment">#获取分块</span></span><br><span class="line">        <span class="comment"># 全局阈值</span></span><br><span class="line">        <span class="comment"># ret,binary = cv.threshold(roi,0,255,cv.THRESH_BINARY|cv.THRESH_OTSU)</span></span><br><span class="line">        <span class="comment"># 局部阈值</span></span><br><span class="line">           binary = cv.adaptiveThreshold(roi,<span class="number">255</span>,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,<span class="number">127</span>,<span class="number">20</span>)　　</span><br><span class="line">            gray[row:row + ch, col:col + cw] = binary　　<span class="comment">#分块覆盖</span></span><br><span class="line">            <span class="built_in">print</span>(np.std(binary),np.mean(binary))</span><br><span class="line"></span><br><span class="line">    cv.imwrite(<span class="string">&quot;binary2.jpg&quot;</span>,gray)</span><br></pre></td></tr></table></figure><h5 id="空白区域过滤">空白区域过滤</h5><blockquote><p>简单来说就是我们认为该区域是空白图像，不进行二值化（但可全变为黑或者白）。</p></blockquote><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574943661293.png' width='40%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空白区域过滤</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">big_image_binary</span>(<span class="params">image</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(image.shape)  <span class="comment">#(4208, 2368, 3)</span></span><br><span class="line">    cw,ch = <span class="number">128</span>,<span class="number">128</span></span><br><span class="line">    h,w = image.shape[:<span class="number">2</span>]</span><br><span class="line">    gray = cv.cvtColor(image,cv.COLOR_RGB2GRAY)   <span class="comment"># 要二值化图像，要先进行灰度化处理</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,h,ch):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,w,cw):</span><br><span class="line">            roi = gray[row:row+ch,col:col+cw]     <span class="comment"># 获取分块</span></span><br><span class="line">            <span class="comment"># 通过获取分块区域的方差和平均值来判断是否是空白区域</span></span><br><span class="line">            dev = np.std(roi)</span><br><span class="line">            avg = np.mean(roi)</span><br><span class="line">            <span class="keyword">if</span> dev &lt; <span class="number">15</span> <span class="keyword">and</span> avg &gt; <span class="number">200</span>:　　<span class="comment"># 满足条件，接近空白区域，让他变黑</span></span><br><span class="line">                gray[row:row + ch, col:col + cw] = <span class="number">0</span>    <span class="comment">#全部都赋值为0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret,binary = cv.threshold(roi,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY|cv.THRESH_OTSU)</span><br><span class="line">                gray[row:row + ch, col:col + cw] = binary</span><br><span class="line">                <span class="built_in">print</span>(np.std(binary), np.mean(binary))</span><br><span class="line"></span><br><span class="line">    cv.imwrite(<span class="string">&quot;binary.jpg&quot;</span>,gray</span><br></pre></td></tr></table></figure><h3 id="2-6-图像缩放">2.6 图像缩放</h3><p>如果要进行对图像进行 <em><u>放大或缩小</u></em> 通常有以下几种方法（在openCV中提供）：</p><p>:warning: 以下方法都可以进行 <em><u>放大或缩小</u></em> （具体怎么实现<em><strong>缩小图像</strong></em>，还待理解）</p><ul><li>INTER_NEAREST ：最近邻插值法</li><li>INTER_LINEAR ： 双线性插值法（默认）</li><li>INTER_AREA ： 基于局部像素的重采样，<em><u>缩小图像通常选择</u></em></li><li>INTER_CUBIC ： 基于4x4像素邻域的3次插值法</li><li>INTER_LANCZOS4 ： 基于8x8像素邻域的Lanczos插值</li></ul><p>在 <em>openCV</em> 中可使用以下API实现对图像缩放：</p><ul><li>简单粗暴的 <em><u>resize</u></em> 函数 ：实现效率最高</li><li><em>cv::pyrUP</em>  、<em>cv::pyrDown</em> ：对图像进行上采样、下采样，常用于图像金字塔中，下详</li></ul><h4 id="2-6-1-缩放：resize">2.6.1  缩放：<em>resize</em></h4><p><em><u>函数原型：</u></em></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574994926873.png" alt="1574994926873"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574994942895.png" alt="1574994942895"></p><blockquote><p>实例：演示如何使用 <em>resize</em> 函数对图像进行缩放。</p></blockquote><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574995365395.png' width='50%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 26.resize</span></span><br><span class="line"><span class="comment"># image.shape = (640, 640, 3)</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(image.shape)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># resize到 512*512,采用双线性插值</span></span><br><span class="line"><span class="comment"># 彩色图虽然有三通道，但是只需指定长、宽就行</span></span><br><span class="line">resize_image = cv.resize(image,(<span class="number">512</span>,<span class="number">512</span>),interpolation=cv.INTER_LINEAR)</span><br><span class="line">cv.imshow(<span class="string">&#x27;resize_image&#x27;</span>,resize_image)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="2-6-2-图像金字塔：pyrUP-、pyrDown">2.6.2 图像金字塔：<em>pyrUP</em>  、<em>pyrDown</em></h4><p>图像金字塔是一系列图像的集合，所有图像来源于同一张原始图像，通过梯次向下采样获得。</p><p>通常有两种类型的图像金字塔 ：</p><ul><li>高斯金字塔(<em>Gaussian pyramid</em>)：用来向下采样</li><li>拉普拉斯金字塔(<em>Laplacian pyramid</em>)：用来从金字塔底层图像重建上层未采样图像，可以对图像进行最大程度的还原.</li></ul><h5 id="高斯金字塔">高斯金字塔</h5><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574996706325.png' width='30%'><p>高斯金字塔用于下采样过程可描述如下：</p><ul><li><p>对图像进行高斯内核卷积，其中高斯内核= <img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574996318946.png' width='15%'></p><p>:grey_question:<em>​ 这一步卷积不会缩小图像尺寸吗？</em></p></li><li><p>将所有偶数行、列去除，这样得到的图形长、宽是原图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 。</p></li></ul><p>在openCV中提供了<em>pyrDown</em> 函数来实现下采样：<br><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574996533783.png" alt="1574996533783"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574996587500.png" alt="1574996587500"></p><blockquote><p>实例：使用高斯金字塔来缩放图像。</p></blockquote><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574997397753.png' width='40%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 27.高斯金字塔</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># resize到 512*512</span></span><br><span class="line">image = cv.resize(image,(<span class="number">512</span>,<span class="number">512</span>),interpolation=cv.INTER_AREA)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line">level = <span class="number">3</span></span><br><span class="line">pyramid_imgs = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level):</span><br><span class="line">    dst = cv.pyrDown(image)</span><br><span class="line">    pyramid_imgs.append(dst)</span><br><span class="line">    image = dst</span><br><span class="line">    cv.imshow(<span class="string">&#x27;L&#x27;</span>+<span class="built_in">str</span>(i),dst)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="拉普拉斯金字塔">拉普拉斯金字塔</h5><p>拉普拉斯金字塔中使用了上采样，其上采样过程如下：</p><ul><li><p>将图像在每个方向上扩大为原来的两倍，新增的行和列以0填充</p></li><li><p>使用先前同样的内核(<em><u>乘以4</u></em>)与放大后的图像卷积，或得”新增像素”的近似值</p><p>:warning: 同上疑问，卷积这一步不会改变图像大小吗？那就不是放大2倍了？</p></li></ul><p>在openCV中提供了<em>pyrUp</em> 函数来实现上采样：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574997773700.png" alt="1574997773700"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574997844806.png" alt="1574997844806"></p><p>拉普拉斯金字塔图像可不仅仅通过对图像向上采样就得到，具体操作如下：</p><ol><li><p>通过高斯金字塔得到一系列不同层级(0-L)图像G</p></li><li><p>先对最高层级图像G[L]  --&gt; 上采样(<em>pyrUp</em>)得到EP[L-1] --&gt;  G[L-1] - EP[L-1] == 拉普拉斯图L[L-1]</p></li><li><p>对次高层图像G[L-1]  --&gt; 上采样(<em>pyrUp</em>)得到EP[L-2] --&gt;  G[L-2] - EP[L-2] == 拉普拉斯图像L[L-2]</p></li><li><p>重复步骤 2-3 ，直至高斯金字塔最低层（原图第一次下采样图）</p></li></ol><p>显然，根据上述步骤，拉普拉斯金字塔是通过 <em><strong>源图下采样对应层级 - 上采样相应层级</strong></em> 获取。保留的残差，为图像还原做准备（:slightly_smiling_face: 此处复原不是很清楚 ）。</p><blockquote><p>实例：获取拉普拉斯金字塔图像。</p></blockquote><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575000194347.png' width='100%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 28.拉普拉斯金字塔</span></span><br><span class="line"><span class="comment"># 下面 pyramid_imgs 表示高斯金字塔下采样获得图像集合</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>): <span class="comment"># 左闭右开从[2,-1)，递减选择步伐=-1</span></span><br><span class="line">    <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">        expand = cv.pyrUp(pyramid_imgs[i], dstsize=pyramid_imgs[i - <span class="number">1</span>].shape[:<span class="number">2</span>])</span><br><span class="line">        lpls = cv.subtract(pyramid_imgs[i - <span class="number">1</span>], expand)</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># 此时已经放大至原图大小</span></span><br><span class="line">        expand = cv.pyrUp(pyramid_imgs[i], dstsize=image.shape[:<span class="number">2</span>])</span><br><span class="line">        lpls = cv.subtract(image, expand)</span><br><span class="line"></span><br><span class="line">    cv.imshow(<span class="string">&#x27;lpls&#x27;</span>+<span class="built_in">str</span>(i),lpls)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="2-7-图像梯度">2.7 图像梯度</h3><blockquote><p>该部分主要参考清晰易懂的：<a href="https://blog.csdn.net/saltriver/article/details/78987096">图像梯度的基本原理</a></p></blockquote><p>我们知道用 <em>均值滤波器</em> 等 ，可以降低图像噪声，但是会使得图像变得<em><strong>模糊</strong></em>  。</p><p><em>Q1 : 那么模糊图像和清晰图像又是怎么区分定义的呢？</em></p><ul><li>图像模糊：因为图像轮廓不明显，换言之，<em>轮廓边缘灰度变化不强烈</em>   ，层次感不强。</li></ul><p>自然我们可以通过使得  <em>轮廓灰度变得强烈</em>   —&gt; 联系到 <em>图像梯度</em>  。</p><blockquote><p>那么梯度又是如何增强图像清晰度呢？</p></blockquote><p>首先我们了解下如何计算图像的梯度。</p><p>我们知道图像是一个离散二维函数，那么其 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mtext>、</mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">x、y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 方向梯度可定义如下：</p><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575017585561.png' width='70%'><ul><li>显然这就相当于 <u><em>梯度 = 2个相邻像素之间差值</em></u></li></ul><p>考虑下面这张图：左部分是图像某个X方向像素变化值，右侧部分是该像素X方向梯度值。</p><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575017975805.png' width='50%'><p>将 $ 原图X方向像素值 + 该X方向梯度 = 新图X方向像素值 $ 。</p><p>这样：<u>将有梯度值的相邻像素的灰度值变大了；而没有灰度值变换的像素值不变</u>。</p><p>特别的，我们还可以将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mtext>和</mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">x和y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord cjk_fallback">和</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>方向结合来计算新图像素值。计算公式如下：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575018332263.png" alt="1575018332263"></p><p>一般使用拟合公式，简化计算：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575018360804.png" alt="1575018360804"></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 即认为是梯度变化值，原图像像素加上该值便可获得最终新图像素值。</li></ul><h4 id="2-7-1-图像求导：Sobel、Scharr、Lapacian">2.7.1 图像求导：<em>Sobel、Scharr、Lapacian</em></h4><p>OpenCV提供三种不同梯度滤波器（高通滤波器）：<em>Sobel，Scharr和 Lapacian</em> ：</p><ul><li><em>Sobel、Scharr</em> ：用于求图像一阶导或二阶导</li><li><em>Lapacian</em> ：求图像二阶导，对 <em>Sobel</em> 的部分优化</li></ul><h5 id="Sobel-Scharr"><em>Sobel &amp; Scharr</em></h5><blockquote><p>感觉就是定义卷积核，然后进行卷积。但是不知道为什么这样可以求导。</p></blockquote><ul><li><p><em>Sobel</em> 算子 ：高斯平滑和微分操作的结合体，因此抗噪声能力很好</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575020343752.png" alt="1575020343752"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575020360960.png" alt="1575020360960"></p><ul><li><p>ddepth：指图像深度，目标图像深度必须 &gt;= 原图像深度。<code>-1</code> 表示和原图像深度一致。</p></li><li><p>dx、dy：表示求导的方向，<code>0</code> 表示这个方向不进行求导，<code>1</code> 表示有。</p></li><li><p>ksize：卷积核大小，当 <code>ksize=-1</code> ，会使用 <code>3*3</code> Scharr卷积核。它的效果比Sobel好</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575020943308.png" alt="1575020943308"></p></li></ul></li><li><p><em>Scharr</em> 算子：<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575020830027.png" alt="1575020830027"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575020845833.png" alt="1575020845833"></p></li></ul><blockquote><p>以<em>Scharr</em> 算子为例：实现计算图像指定方向的梯度。</p></blockquote><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575021141489.png' width='80%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 29.图像求导：Sobel、Scharr、Lapacian</span></span><br><span class="line"><span class="comment"># 演示Scharr算子求导梯度，Sobel同理</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Scharr算子对图像求导</span></span><br><span class="line"><span class="comment"># 为什么使用CV_32F？</span></span><br><span class="line"><span class="comment"># 因为Scharr算子求导后会有负值&amp;大于255值。而原图是unit8位，即8位无符号数。</span></span><br><span class="line"><span class="comment"># 所以scharr建立图像位置不够，需要使用32F有符号数据类型。</span></span><br><span class="line">grad_x = cv.Scharr(image,cv.CV_32F,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">grad_y = cv.Scharr(image,cv.CV_32F,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 经过处理后，别用convertScaleAbs()函数将其转回原来的uint8形式。</span></span><br><span class="line"><span class="comment"># 否则将无法显示图像，而只是一副灰色的窗口。</span></span><br><span class="line"><span class="comment"># dst = cv2.convertScaleAbs(src[, dst[, alpha[, beta]]])</span></span><br><span class="line"><span class="comment"># 可选参数alpha是伸缩系数，beta是加到结果上的一个值。结果返回uint8类型的图片</span></span><br><span class="line"></span><br><span class="line">grad_x = cv.convertScaleAbs(grad_x)</span><br><span class="line">grad_y = cv.convertScaleAbs(grad_y)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;gradx&#x27;</span>,grad_x)</span><br><span class="line">cv.imshow(<span class="string">&#x27;grady&#x27;</span>,grad_y)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>:warning: 上面图不适合演示增加图像清晰度，可看下面这张图：</p><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575022308411.png' width='60%'><ul><li>梯度图是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mtext>、</mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">x、y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 方向分别计算然后绝对值相加：<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575022388588.png" alt="1575022388588"></li></ul><h5 id="Laplacian-算子"><em>Laplacian</em> 算子</h5><ul><li><p>作用</p><p>对噪声敏感，会产生双边效果。不能检测出边的方向。通常不直接用边检测。一般用来检测一个像素是在边的亮的一边还是暗的一边利用零跨越，确定边的位置。</p></li><li><p>原理</p><p>图像中的边缘区域，像素值会发生“跳跃”，对这些像素求导，在其*<u>一阶导数极值处就是边缘</u>* 。</p></li><li><p>API</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575021975153.png" alt="1575021975153"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575021992549.png" alt="1575021992549"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575022025704.png" alt="1575022025704"></p></li></ul><blockquote><p>实例：利用 <em>Laplacian</em> 检测图像的边。</p></blockquote><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575021699095.png' width='60%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Lapacian</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line">dst = cv.Laplacian(image,cv.CV_32F,ksize=<span class="number">3</span>)</span><br><span class="line">dst = cv.convertScaleAbs(dst)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;Lapacian&#x27;</span>,dst)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="2-7-2-Canny边缘提取">2.7.2 Canny边缘提取</h4><blockquote><p>该部分主要参考：<a href="https://www.cnblogs.com/techyan1990/p/7291771.html">边缘检测之Canny</a></p></blockquote><ul><li><p>作用：提取图像边缘</p></li><li><p>流程：详细流程算法实现参考上述文章链接</p><ul><li>使用高斯滤波器，以平滑图像，滤除噪声</li><li>计算图像中每个像素点的梯度强度和方向</li><li>应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应</li><li>应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘</li><li>通过抑制孤立的弱边缘最终完成边缘检测</li></ul></li><li><p>API</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575024048101.png" alt="1575024048101"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575024063583.png" alt="1575024063583"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575024028630.png" alt="1575024028630"></p><ul><li><p>threshold1、threshold2即对应阈值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mtext>低</mtext></msub><mtext>、</mtext><msub><mi>T</mi><mtext>高</mtext></msub></mrow><annotation encoding="application/x-tex">T_低、T_高</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">低</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">高</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>像素值</mtext><mo>&gt;</mo><msub><mi>T</mi><mtext>高</mtext></msub></mrow><annotation encoding="application/x-tex">像素值&gt;T_高</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">像素值</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">高</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> : 被认为是边缘像素，保留</li><li>$ T_低&lt;像素值&lt;T_高$ :  当该像素和高于上限的像素点连接才保留</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>像素值</mtext><mo>&lt;</mo><msub><mi>T</mi><mtext>低</mtext></msub></mrow><annotation encoding="application/x-tex">像素值&lt;T_低</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">像素值</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">低</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> : 不认为是边缘像素，舍弃</li></ul><p>一般设置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mtext>高</mtext></msub><mi mathvariant="normal">/</mi><msub><mi>T</mi><mtext>低</mtext></msub><mo>=</mo><mn>3</mn><mo>:</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T_高/T_低 = 3:1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">高</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">低</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>  或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mtext>高</mtext></msub><mi mathvariant="normal">/</mi><msub><mi>T</mi><mtext>低</mtext></msub><mo>=</mo><mn>2</mn><mo>:</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T_高/T_低 = 2:1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">高</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">低</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p></li></ul></li></ul><blockquote><p>实例：利用Canny函数进行边缘检测。</p></blockquote><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575024808495.png' width='80%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 30.canny边缘检测</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># canny边缘检测，可以使用这种不用提供gradx、grady的API</span></span><br><span class="line">edge_detect = cv.Canny(image,<span class="number">50</span>,<span class="number">150</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;edge detect&#x27;</span>,edge_detect)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="2-8-直线、圆、轮廓检测">2.8 直线、圆、轮廓检测</h3><h4 id="2-8-1-直线检测：霍夫变换">2.8.1 直线检测：霍夫变换</h4><blockquote><p>给定一副图像（一般是二值图像，像素值对检测直线没有作用）如何检测是否存在直线？</p></blockquote><p>一种很直观的想法：任选一对点，决定一条线，然后测试所有其他点是否接近这条线，从而得出接近这条特殊线的所有点的子集。</p><p>但是这种方法比较复杂，我们通常使用的 <em>霍夫变换</em> 。</p><p>在了解霍夫变换，我们先来了解什么是 <em><u>对偶性</u></em> 。</p><h5 id="对偶性">对偶性</h5><blockquote><p>我所理解的对偶性：将直角坐标系的 <em><strong>点</strong></em>  对应 参数空间的 <em><strong>直线</strong></em>。</p></blockquote><p>在直角空间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，过点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(x_0,y_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 所有直线确定一簇直线，都满足方程：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>0</mn></msub><mo>=</mo><mi>k</mi><mo>∗</mo><msub><mi>x</mi><mn>0</mn></msub><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y_0=k*x_0+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 。</p><p>如果转换参数空间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">k-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> ，那么过点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(x_0,y_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>  <em><u>所有</u></em> 直线就可以描述为 <u><em>一条</em></u> 直线：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mo>−</mo><mi>k</mi><msub><mi>x</mi><mn>0</mn></msub><mo>+</mo><msub><mi>y</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">b=-kx_0+y_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>:</p><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575081721956.png' width='80%'><ul><li>在参数空间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">k-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> ，斜率是点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 横坐标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">-x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 截距是点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 纵坐标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">y_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ul><p>那么如果在直角坐标系存在多个点在同一直线<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mtext>斜率</mtext><mo>=</mo><msub><mi>k</mi><mn>1</mn></msub><mo separator="true">,</mo><mtext>截距</mtext><mo>=</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">l_1(斜率=k_1,截距=b_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord cjk_fallback">斜率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">截距</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>上，也就是说：它们在参数空间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">k-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 必然会交于一点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>k</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k_1,b_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。</p><p>如果有n个点在一条直线上，那么在参数空间就会存在对应交于n个点，<em><strong>那么在参数空间相交直线最多的点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> , 就是我们在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 直角坐标对应直线斜率和截距的解 。</strong></em></p><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575083039858.png' width='50%'><h5 id="霍夫变化-参数空间选择">霍夫变化&amp;参数空间选择</h5><p>上述参数空间是选择直角坐标系空间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">k-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> , 但是这样会带来一个问题：<em><u>无法检测垂直直线</u></em></p><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575083182037.png' width='50%'><p>因此我们考虑将参数空间转换到极坐标系 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>−</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">r-\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> :</p><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575083284237.png' width='60%'><ul><li><p>:warning:  <em>为什么映射到极坐标是曲线？</em> 为什么给定恒等式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi><mo>+</mo><mi>y</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>θ</mi><mo>=</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">xcos\theta+ysin\theta=p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal">cos</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ys</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 进行变换？</p></li><li><p>同前，在极坐标系相交最多的点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>θ</mi><mtext>，</mtext><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\theta，p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span> ，便可转换到直角坐标系求解对应斜率和截距。</p></li></ul><p>理论上，一个点会对应无数条直线，在参数空间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>−</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">p-\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 自然也是连续的。但事实上，我们会规定直线的数量，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 离散化为等间距离散值，相应<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 也离散为等间距离散值。</p><p>这样，参数空间就是一个等大小*<u>网格</u>* 。当参数空间有直线相交于这个点，则网格累加器+1：</p><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575084392206.png' width='60%'><h5 id="HoughLines">HoughLines()</h5><p>霍夫变换，利用openCV检测图像具体流程可总结如下：</p><ol><li><p>彩色图像-&gt;灰度图</p></li><li><p>去噪（高斯核）</p></li><li><p>边缘提取（canny、sobel）</p><p>:warning: <u><em>Canny方法中包含计算梯度，非最大信号抑制和双阈值输出</em></u></p></li><li><p>二值化（判断此处是否为边缘点，就看灰度值==255）</p></li><li><p>映射到霍夫空间</p></li><li><p>取局部极大值，设定阈值，过滤干扰直线</p></li><li><p>绘制直线、标定角点</p></li></ol><p><em><u>下面代码没有进行第三步二值化，是因为 canny自带二值化吗？</u></em> <em><strong>对的</strong></em></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575085636139.png" alt="1575085636139"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575085651422.png" alt="1575085651422"></p><ul><li>rho：生成极坐标像素扫描步长（离散化）</li><li>theta：生成极坐标时扫描角度步长（离散化）</li><li>threshold：只有足够交点的极坐标才被认为是直线</li></ul><blockquote><p>实例：利用openCV &amp; 霍夫变换来检测图像直线。</p></blockquote><p><em><u>为什么检测直线图像上面总是出现这些不正常直线？</u></em></p><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575087049506.png' width='80%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 31.霍夫变换</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\building.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 0.高斯滤波（效果也不好，最好取消这步了）</span></span><br><span class="line"><span class="comment"># image = cv.GaussianBlur(image,(3,3),0)</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.转换为灰度图</span></span><br><span class="line">gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.边缘检测canny</span></span><br><span class="line"><span class="comment"># 分别设定阈值像素为50、150，sobel算子大小=3</span></span><br><span class="line">edges = cv.Canny(gray,<span class="number">50</span>,<span class="number">150</span>,apertureSize=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.霍夫变换</span></span><br><span class="line"><span class="comment"># 生成极坐标扫描步长=1，角度=1°，至少有200个交点才认为是直线</span></span><br><span class="line">lines = cv.HoughLines(edges,<span class="number">1</span>,np.pi/<span class="number">180</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.画出直线</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    r,theta = line[<span class="number">0</span>]  <span class="comment"># 极坐标p、θ</span></span><br><span class="line">    <span class="comment"># 计算直线两端点</span></span><br><span class="line">    <span class="comment"># 为什么是这么计算也不清楚？</span></span><br><span class="line">    cos = np.cos(theta)</span><br><span class="line">    sin = np.sin(theta)</span><br><span class="line">    x0 = r*cos</span><br><span class="line">    y0 = r*sin</span><br><span class="line">    <span class="comment"># 计算直线最大点(x1,y1)</span></span><br><span class="line">    x1 = <span class="built_in">int</span>(x0 + <span class="number">1000</span> * (-sin))</span><br><span class="line">    y1 = <span class="built_in">int</span>(x0 + <span class="number">1000</span> * (cos))</span><br><span class="line">    <span class="comment"># 计算直线最小点(x2,y2)</span></span><br><span class="line">    x2 = <span class="built_in">int</span>(x0 - <span class="number">1000</span> * (-sin))</span><br><span class="line">    y2 = <span class="built_in">int</span>(x0 - <span class="number">1000</span> * (cos))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 画出直线</span></span><br><span class="line">    cv.line(image,(x1,y1),(x2,y2),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;detect line&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="HoughLinesP">HoughLinesP()</h5><p>霍夫概率变换是霍夫变换的加强版：</p><ul><li><p>原理：暂略，待补</p></li><li><p>API：<em><u>效果和API接口都比霍夫变换要好很多</u></em></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575085213285.png" alt="1575085213285"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575085268979.png" alt="1575085268979"></p></li></ul><blockquote><p>实例：利用openCV &amp; 霍夫变换来检测图像直线。</p></blockquote><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575120384392.png' width='80%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 32.霍夫概率变换</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\building.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.进行高斯模糊（实测效果变好）</span></span><br><span class="line"><span class="comment"># ksize和sigma可以互相计算，故指定sigmaX=0</span></span><br><span class="line">image = cv.GaussianBlur(image,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">0</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.转换为灰度图</span></span><br><span class="line">gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 2.边缘检测canny</span></span><br><span class="line">edges = cv.Canny(gray,<span class="number">50</span>,<span class="number">150</span>,apertureSize=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 3.霍夫概率变换</span></span><br><span class="line">lines = cv.HoughLinesP(edges,<span class="number">1</span>,np.pi/<span class="number">180</span>,<span class="number">200</span>,minLineLength=<span class="number">50</span>,maxLineGap=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    x1,y1,x2,y2 = line[<span class="number">0</span>]</span><br><span class="line">    cv.line(image, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;detect line&#x27;</span>,image)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="2-8-2-圆检测：霍夫变换">2.8.2 圆检测：霍夫变换</h4><p>在前，若干点在同一直线上，则它们必有一条直线<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>k</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y=k x+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 经过它们。为了解算出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mtext>、</mtext><mi>b</mi></mrow><annotation encoding="application/x-tex">k、b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">b</span></span></span></span> 我们将这 <em><u>若干点</u></em> 变换到极坐标参数空间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">k-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 得到对应 <em><u>若干曲线</u></em> , 这些曲线若存在交点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><msub><mi>k</mi><mi>a</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>a</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(k_a,b_a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 则说明存在一条直线 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>k</mi><mi>a</mi></msub><mi>x</mi><mo>+</mo><msub><mi>b</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">y=k_a x+b_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 使得它们在同一直线上。</p><p><em><u>那如何确定几个点是在同一圆上？</u></em></p><p>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 坐标系，圆表达式可写作：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>a</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><mi>b</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">(x-a)^2+(y-b)^2 = r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 。</p><p>同样将其映射到参数空间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">r-a-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 中。</p><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575122053546.png' width='80%'><p>:warning: 上有三个参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">rab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">ab</span></span></span></span>，在OpenCV中可通过设定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 范围，循环遍历<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 值，则只在二维空间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 寻找圆心<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> 即可。</p><p>那么，在二维空间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> , 圆<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>a</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><mi>b</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">(x-a)^2+(y-b)^2 = r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 被映射成什么样子？</p><p>显然也是个圆，此时圆心是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 已知 ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>−</mo><mi>x</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>y</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">(a-x)^2+(b-y)^2 = r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 。</p><ul><li>假设在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 坐标系存在三个点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mtext>、</mtext><mi>b</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mtext>、</mtext><mi>a</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a(x_1,y_1)、b(x_2,y_2)、a(x_2,y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。显然它们任意一个点，由于圆心<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> 不确定，在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 坐标系可以画出无数个圆。</li><li>三个点映射到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 二维空间，则为确定的一个圆，圆心分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mtext>、</mtext><mi>b</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mtext>、</mtext><mi>a</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a(x_1,y_1)、b(x_2,y_2)、a(x_2,y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>如果它们在同一个圆上，那么必然存在一个圆，圆心为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_1,b_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 半径为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> ，都经过这三个点。换言之，在参数空间这三个点对应的圆必然会交于一个点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_1,b_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。由于在假设半径<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 值情况遍历搜寻，那么此时半径已知。至此，圆就被确定下来了。</li></ul><p>当然，上述过程三个点在参数空间对应的圆交于一个点，就确定一个点还是太少了。实际可以指定更多点交于一个点才认为确实存在圆。</p><h5 id="HoughCircles"><em>HoughCircles()</em></h5><p>下面是基本API用法。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575124326462.png" alt="1575124326462"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575124353453.png" alt="1575124353453"></p><ul><li><em>method</em> : 检测圆方法，例如霍夫梯度法：CV_HOUGH_GRADIENT</li><li><em>dp</em>：检测圆心的累加器图像的分辨率于输入图像之比的倒数。dp= 1时，累加器和输入图像具有相同的分辨率。如果dp=2，累加器便有输入图像一半那么大的宽度和高度</li><li><em>minDist</em>：圆的圆心之间的最小距离。参数如果太小，多个相邻的圆可能被错误地检测成了一个重合的圆。反之，参数设置太大的话，某些圆就不能被检测出来了。</li><li><em>param1</em>：默认值100。是第三个参数method设置的检测方法的对应的参数，对于霍夫梯度法CV_HOUGH_GRADIENT，它表示传递给canny边缘检测算子的高阈值，低阈值为高阈值的一半。</li><li><em>param2</em>：默认值100。同上，对于霍夫梯度法CV_HOUGH_GRADIENT，它表示检测阶段圆心的累加器阈值。它越小的话，就可以检测到更多根本不存在的圆，而它越大的话，能通过检测的圆就更加接近完美的圆形了。</li><li><em>minRadius、maxRadius</em> ： 表示设置圆半径的最小值和最大值。</li></ul><blockquote><p>实例：使用<em>HoughCircles()</em> 检测图像中存在的圆形。</p></blockquote><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575125468745.png' width='50%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 33.霍夫变换圆检测</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\circles.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 霍夫变换易受噪声影响，先进行均值漂移滤波减少噪声</span></span><br><span class="line">dst = cv.pyrMeanShiftFiltering(image,<span class="number">10</span>,<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 转换为灰度图</span></span><br><span class="line">gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 霍夫变换圆检测</span></span><br><span class="line"><span class="comment"># param1、param2调参很重要。最开始param1=50，效果很差，canny的高阈值设置太低</span></span><br><span class="line">circles = cv.HoughCircles(gray,cv.HOUGH_GRADIENT,<span class="number">1</span>,<span class="number">20</span>,param1=<span class="number">100</span>,param2=<span class="number">30</span>,minRadius=<span class="number">0</span>,maxRadius=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画圆[注意维度问题]</span></span><br><span class="line"><span class="comment"># circles.shape=（1,3,3）,第一个维度不明。第二个维度是圆个数，第三个维度对应圆三个参数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> circles[<span class="number">0</span>,:]:</span><br><span class="line">    cv.circle(image,(i[<span class="number">0</span>],i[<span class="number">1</span>]),i[<span class="number">2</span>],(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;circles&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="2-8-3-轮廓检测">2.8.3 轮廓检测</h4><h5 id="原理">原理</h5><p>待补充</p><h5 id="findContours"><em>findContours</em></h5><blockquote><p>原理不懂，API看得也稀里糊涂的。参数意义可以参考 ：<a href="https://www.cnblogs.com/ssyfj/p/9276443.html">轮廓发现</a></p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575171018417.png" alt="1575171018417"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575172245949.png" alt="1575172245949"></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575175255172.png" alt="1575175255172"></p><p>整个API操作步骤可以总结如下：</p><ul><li><p>对图像进行高斯滤波，减少噪声</p></li><li><p>转换为二值图像：<em>threshold</em> 或者 <em>canny</em> 边缘提取都可</p></li><li><p>通过二值图像寻找轮廓：<em>findContours</em></p></li><li><p>描绘轮廓：<em>drawContours</em></p></li></ul><blockquote><p>实例1：寻找图像轮廓（通过threshold获取二值图像）</p></blockquote><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575174791805.png' width='80%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 34.轮廓发现（通过threshold获取二值图像）</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\circles.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.高斯滤波图像减少噪声</span></span><br><span class="line">GaussianImg = cv.GaussianBlur(image,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.转换为灰度图像</span></span><br><span class="line">grayImg = cv.cvtColor(GaussianImg,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.threshold 获取二值图像</span></span><br><span class="line"><span class="comment"># 如果选择二值方式是 cv.THRESH_BINARY，由于原图像素&gt;0,结果就是二值化图全白色</span></span><br><span class="line"><span class="comment"># cv.THRESH_OTSU：是最大间差法，按图像灰度特性将图像分为前景和背景两部分</span></span><br><span class="line">ret,binaryImg = cv.threshold(grayImg,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY|cv.THRESH_OTSU)</span><br><span class="line">cv.imshow(<span class="string">&#x27;binaryImg&#x27;</span>,binaryImg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.findContours 轮廓提取</span></span><br><span class="line"><span class="comment"># cv.RETR_EXTERNAL 获取外部轮廓 ； cv.CHAIN_APPROX_SIMPLE </span></span><br><span class="line">cloneImage,contours,heriachy= cv.findContours(binaryImg,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. drawContours 绘出轮廓</span></span><br><span class="line"><span class="keyword">for</span> i,contour <span class="keyword">in</span> <span class="built_in">enumerate</span>(contours):</span><br><span class="line">    <span class="comment"># 注意第二个参数是传递所有轮廓！</span></span><br><span class="line">    cv.drawContours(image,contours,i,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),-<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;detect contours&#x27;</span>,image)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><p>实例2：寻找图像轮廓（通过canny获取二值图像）</p></blockquote><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575175031143.png' width='80%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 35.轮廓发现（通过canny获取二值图像）</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\circles.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.高斯滤波图像减少噪声</span></span><br><span class="line">GaussianImg = cv.GaussianBlur(image,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.转换为灰度图像</span></span><br><span class="line">grayImg = cv.cvtColor(GaussianImg,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.canny 获取二值图像</span></span><br><span class="line">binaryImg = cv.Canny(grayImg,<span class="number">50</span>,<span class="number">150</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;binaryImg&#x27;</span>,binaryImg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.findContours 轮廓提取</span></span><br><span class="line">cloneImage,contours,heriachy= cv.findContours(binaryImg,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. drawContours 绘出轮廓</span></span><br><span class="line"><span class="keyword">for</span> i,contour <span class="keyword">in</span> <span class="built_in">enumerate</span>(contours):</span><br><span class="line">    cv.drawContours(image,contours,i,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;detect contours&#x27;</span>,image)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="2-9-对象测量">2.9 对象测量</h3><p>这部分对象测量主要包含两个部分：</p><ul><li>基于前<strong>2.8</strong> 节 <em><u>发现轮廓</u></em>  后对轮廓进行 <em><u>计算弧长和面积</u></em></li><li>对发现的轮廓进行多边形拟合</li></ul><h4 id="2-9-1-面积-多边形拟合…">2.9.1 面积&amp;多边形拟合…</h4><ul><li><p>原理</p><p>待补充</p></li><li><p>API</p><ul><li><em>cv.contourArea(contour)</em>       ：获取每个轮廓面积</li><li><em>cv.boundingRect(contour)</em>     ：获取轮廓的外接矩形</li><li><em>cv.moments(contour)</em>             ：求取轮廓的几何距</li><li><em>cv.arcLength(contour,True)</em>　：求取轮廓的周长，指定闭合</li><li><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575211802166.png" alt="1575211802166"></li></ul></li><li><p>过程总结</p><ul><li>获取灰度图像：<em>cvtColor</em></li><li>二值化图像：<em>threshold</em> 或 <em>canny</em></li><li>发现轮廓：<em>findContours</em></li><li>计算面积 / 周长/多边形拟合 等</li></ul></li></ul><blockquote><p>实例：获取图像面积、绘出外接矩形框、根据几何距计算轮廓中心（不明白原理）</p></blockquote><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575211694175.png' width='80%'><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 36.对象测量</span></span><br><span class="line"><span class="comment"># 计算面积、绘出外接矩形、根据几何距计算轮廓中心（不明白）</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\circles.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.转换为灰度图像</span></span><br><span class="line">grayImg = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.threshold 获取二值图像</span></span><br><span class="line">ret,binaryImg = cv.threshold(grayImg,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_OTSU)</span><br><span class="line">cv.imshow(<span class="string">&#x27;binaryImg&#x27;</span>,binaryImg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.发现轮廓</span></span><br><span class="line">cloneImage,contours,heriachy= cv.findContours(binaryImg,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.计算轮廓面积、外接矩形、求中心点</span></span><br><span class="line"><span class="comment"># debug：在二值图像化没反应？</span></span><br><span class="line"><span class="keyword">for</span> i,contour <span class="keyword">in</span> <span class="built_in">enumerate</span>(contours):</span><br><span class="line">    <span class="comment"># 计算轮廓面积</span></span><br><span class="line">    area = cv.contourArea(contour)</span><br><span class="line">    <span class="comment"># print(area)</span></span><br><span class="line">    <span class="comment"># 绘制外接矩形</span></span><br><span class="line">    x,y,w,h = cv.boundingRect(contour)</span><br><span class="line">    cv.rectangle(image,(x,y),(x+w,y+h),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 根据几何距获取中心点并绘制</span></span><br><span class="line">    m = cv.moments(contour)       <span class="comment"># 获取几何距</span></span><br><span class="line">    <span class="keyword">if</span> m[<span class="string">&#x27;m00&#x27;</span>] == <span class="number">0</span>:             <span class="comment"># 有可能出现 m[&#x27;m00&#x27;] == 0</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cx = m[<span class="string">&#x27;m10&#x27;</span>] / m[<span class="string">&#x27;m00&#x27;</span>]  <span class="comment"># 中心x</span></span><br><span class="line">        cy = m[<span class="string">&#x27;m01&#x27;</span>] / m[<span class="string">&#x27;m00&#x27;</span>]  <span class="comment"># 中心y</span></span><br><span class="line">    cv.circle(image,(np.<span class="built_in">int</span>(cx),np.<span class="built_in">int</span>(cy)),<span class="number">1</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 拟合多边形</span></span><br><span class="line">    <span class="comment"># 4是与阈值的间隔大小，越小越易找出，True是是否找闭合图像</span></span><br><span class="line">    <span class="comment"># 返回拟合曲线</span></span><br><span class="line">    approxCurve = cv.approxPolyDP(contour, <span class="number">4</span>, <span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 如果拟合曲线的边数大于4则绘出（三角形、四边形等&lt;=4就不会绘出）</span></span><br><span class="line">    <span class="keyword">if</span> approxCurve.shape[<span class="number">0</span>] &gt; <span class="number">4</span>:</span><br><span class="line">        cv.drawContours(image, contours, i, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">cv.imshow(<span class="string">&#x27;draw&#x27;</span>,image)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="2-10-图像形态学">2.10 图像形态学</h3>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习基础（二）Pytorch</title>
      <link href="/2021/11/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89Pytorch/"/>
      <url>/2021/11/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89Pytorch/</url>
      
        <content type="html"><![CDATA[<h1>PTboy：PyTorch</h1><h2 id="一、快速入门">一、快速入门</h2><blockquote><p>本笔记主要参考：<a href="https://pytorch.apachecn.org/docs/1.2/beginner/blitz/tensor_tutorial.html">pytorch中文教程</a>  、<a href="https://github.com/zergtant/pytorch-handbook/blob/master/chapter1/1.2-pytorch-installation.md">pytorch开源书籍中文教程</a></p></blockquote><h3 id="1-1-安装">1.1 安装</h3><p>进入 <a href="https://pytorch.org/get-started/locally/">PyTorch官网</a>  我们可以看到需要安装的软件和版本：</p><p><img src="https://i.loli.net/2021/11/25/fBHA6qsLgpb9t5O.png" alt="1571924345686"></p><ul><li><em>Package</em>：包管理软件，可以用 <code>pip</code> ，为了方便我们使用 <em>Conda</em></li><li><em>CUDA</em> : 显卡加速软件，<em>GPU</em> 跑一定要下载，<em>CPU</em> 不用。我们显卡是 <em>GTX 1650</em> ，<em>GPU</em> 勉强可以跑得动，故下载。</li></ul><p>下面依次详细记录安装 <em>Conda</em> &amp;  <em>CUDA</em> 。</p><h4 id="1-1-1-安装-AnaConda">1.1.1 安装 <em>AnaConda</em></h4><blockquote><p>安装参考 ： <a href="https://blog.csdn.net/ITLearnHall/article/details/81708148">Anaconda详细安装及使用教程</a></p></blockquote><p>官网下载： <a href="https://www.anaconda.com/distribution/#download-section">AnaConda最新版本</a> 。太慢了，选择 : <a href="https://pc.qq.com/search.html#!keyword=Anaconda">腾讯软件下载AnaConda</a> 。</p><p>下载完毕后开始安装，一直下一步就好 ，有两个地方需要说明：</p><ul><li>安装路径：安装路径需要英文懒得折腾，直接默认安装路径了</li><li>环境变量：在安装过程中可以勾选自动添加环境变量，记得勾选</li></ul><p>如果安装成功，且环境变量配置成功，在 <code>cmd</code> 输入 <code>conda -V</code> 可以看到如下版本信息：</p><p><img src="https://i.loli.net/2021/11/25/8owdTcqDSEFuykl.png" alt="1571973110341"></p><h5 id="Conda-使用初体验">Conda 使用初体验</h5><blockquote><p>以下操作都是命令行，在 <code>cmd</code> 环境中进行。</p></blockquote><p><em>创建虚拟环境：</em></p><ul><li>更新所有包：<code>conda upgrade --all</code></li><li>创建虚拟环境：<code>conda  create  --name  ptboy   python=3.7</code></li><li>切换环境 &amp; 查看已创建环境：<code>activate ptboy</code>  &amp; <code>conda env list</code></li><li>切换/退出  python 解释器：<code>python</code> 、<code>exit()</code></li></ul><p><em>包管理 ：</em></p><ul><li>安装 / 卸载 包 ： <code>conda install 要安装的包名</code>   、<code>conda remove 要卸载的包名</code></li></ul><p><em>和 <code>pycharm</code> 连接：</em></p><blockquote><p>下面略有不对，可参考这篇文章：<a href="https://www.jianshu.com/p/c958ead0fa13">Anaconda与pycharm连接</a></p></blockquote><ul><li><p><code>File --&gt; Settings --&gt; Project:你的项目名 ---&gt; Project Interpreter</code> ，然后 <code>Add</code> ：</p><p><img src="https://i.loli.net/2021/11/25/QpLxcbA3twhGiUV.png" alt="1571974895349"></p></li><li><p>设置虚拟环境python解释器：</p><p><img src="https://i.loli.net/2021/11/25/xTP2ZlcvnUoRMD1.png" alt="1571975414213"></p></li></ul><h4 id="1-1-2-安装-CUDA-cuDNN">1.1.2 安装 <em>CUDA</em>  &amp; <em>cuDNN</em></h4><h5 id="安装-CUDA">安装 <em>CUDA</em></h5><blockquote><p>:slightly_smiling_face: 狗日的fuck 中国移动网卡，浪费我一天时间检查网络，原来是你这:dog: 东西限我速！</p></blockquote><p>首先我们去官网下载 <em>CUDA</em> ：<a href="https://developer.nvidia.com/cuda-downloads?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exelocal">CUDA 10.1 下载</a></p><p><img src="https://i.loli.net/2021/11/25/l9cwqesz5HfU42W.png" alt="1571924806891"></p><p>点击右下角 <code>Download[2.5GB]</code> 下载即可。</p><ol><li><p>下载完毕后，解压默认会提取到临时目录，不用修改（临时目录会自动删除）</p></li><li><p>一直下一步 --&gt; 自定义安装 ，勾选以下：</p><p><img src="https://i.loli.net/2021/11/25/b9nZNElCxUdFk2o.png" alt="1571926415928"></p><ul><li><p>:warning: 一般安装出错都是由于 <code>Visual Studio Intergration</code> ，所以去除掉，实际我也用不到 VS 环境。</p><p>如果需要VS环境，可参考这篇文章：<a href="https://blog.csdn.net/zzpong/article/details/80282814">CUDA安装失败原因解决</a> 。</p></li></ul></li><li><p>下一步，<em>使用默认安装位置，不折腾了</em>：</p><p><img src="https://i.loli.net/2021/11/25/WqRvLnHYcoi9mJl.png" alt="1571927440985"></p></li></ol><p>一直下一步安装，很快便会显示安装完成了。</p><p>接着便是最重要容易出错的  <em>环境变量配置了</em> ：</p><p>:warning: 下面都是默认安装路径，如果需要自定义安装注意修改环境变量路径名。</p><ul><li>高级系统设置 --&gt; 环境变量  --&gt; 系统变量，添加以下几个环境变量：<ol><li><code>CUDA_SDK_PATH = C:\ProgramData\NVIDIA Corporation\CUDA Samples\v10.1</code></li><li><code>CUDA_LIB_PATH = %CUDA_PATH%\lib\x64</code></li><li><code>CUDA_BIN_PATH = %CUDA_PATH%\bin</code></li><li><code>CUDA_SDK_BIN_PATH = %CUDA_SDK_PATH%\bin\win64</code></li><li><code>CUDA_SDK_LIB_PATH = %CUDA_SDK_PATH%\common\lib\x64</code></li></ol></li><li>高级系统设置 --&gt; 环境变量  --&gt; 系统变量 --&gt; PATH , 添加：<ol><li><em>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.1\lib\x64</em></li><li><em>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.1\bin</em></li><li><em>C:\ProgramData\NVIDIA Corporation\CUDA Samples\v10.1\common\lib\x64</em></li><li><em>C:\ProgramData\NVIDIA Corporation\CUDA Samples\v10.1\bin\win64</em></li></ol></li></ul><p>在<code>cmd</code> 键入 <code>nvcc -V</code> 来查看是否正确安装：</p><p><img src="https://i.loli.net/2021/11/25/NY176sQzlvBaMoK.png" alt="1571928979917"></p><h5 id="安装-cuDNN">安装 <em>cuDNN</em></h5><p>我们继续开始安装 <em>cuDNN</em> ，下载<em>cuDNN</em> 地址：<a href="https://developer.nvidia.com/rdp/cudnn-download"><em>cuDNN 7.6.4</em> 下载</a></p><p>:warning: 下载前要先注册会员，选择 QQ登陆马上就注册好了？</p><p><img src="https://i.loli.net/2021/11/25/IuO5iLQyK2dnwrN.png" alt="1571925832156"></p><p>点击上述红框位置下载即可，解压文件复制下图所示3个文件：</p><p><img src="https://i.loli.net/2021/11/25/juxozgvkHWOnhEC.png" alt="1571929101766"></p><p>然后找到 <code>CUDA</code> 安装目录（我之前是默认），复制替换对应下面三个文件：</p><p><img src="https://i.loli.net/2021/11/25/u8LX4rVIUCPSKYf.png" alt="1571929211740"></p><h5 id="整体测试安装">整体测试安装</h5><p>切换到目录(默认) ：<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.1\extras\demo_suite</code></p><p><img src="https://i.loli.net/2021/11/25/dQIUFhY1eKzwPtq.png" alt="1571970802044"></p><p>可以看到上述两个程序：<code>bandwidthTest.exe</code> 、<code>deviceQuery.exe</code> 两个测试程序。</p><p>在 <code>cmd</code> 中运行这两个测试程序：</p><p><img src="https://i.loli.net/2021/11/25/GS2isUc65B8ClAJ.png" alt="1571970903897"></p><p><img src="https://i.loli.net/2021/11/25/XmCreFNqJaQ3HtR.png" alt="1571970948142"></p><p>出现以上信息则证明安装成功。</p><blockquote><p>第一次安装出错：原因是驱动版本跟不上 <code>CUDA</code> 版本。</p></blockquote><p>解决办法如下，下载 <code>NVIDIA GeForce Experience</code> ：<a href="https://pc.qq.com/detail/0/detail_11500.html">腾讯下载 NVIDIA GeForce Experience</a> 。</p><p>打开软件更新驱动，下载  <code>GeForce Game Ready Driver</code>：</p><p><img src="https://i.loli.net/2021/11/25/8w1zKqWmbs73GUR.png" alt="1571971153488"></p><p>安装，会提示你更新驱动，直接更新就好。再次运行便会发现可以正常运行测试信息了。</p><h4 id="1-1-3-安装-pytorch">1.1.3 安装 pytorch</h4><p>进入官网，我们可以看到安装命令：/</p><blockquote><p>…</p></blockquote><p>参数 <code>-c pytorch</code> 指的是 <code>pytorh</code> 官方仓库，由于速度太慢我们换成清华源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line"></span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure><p>:warning: 一开始好像没有引用 <code>pytorch</code> 清华源（第三个），一直官方安装不成功。</p><p>再执行安装命令即可快速安装了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision cudatoolkit=10.1</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/25/vGUserbgIdTVM6N.png" alt="1571986922540"></p><p>最后切换到 <code>python</code> 解释器，输入 <code>import torch</code> ，不报错则安装成功了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(ptboy) C:\Users\86151&gt;python</span><br><span class="line">&gt;&gt;&gt; import pytorch</span><br></pre></td></tr></table></figure><h5 id="补充">补充</h5><p>一开始由于安装太慢尝试各种办法，删除了 <code>.condarc文件(everything进行搜索)</code> 默认通道 <code>default</code> （最后一行）。最终文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">show_channel_urls: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="1-1-4-安装使用-jupyter">1.1.4 安装使用 <em>jupyter</em></h4><blockquote><p>该部分主要参考于 ：<a href="https://zhuanlan.zhihu.com/p/33105153">Jupyter Notebook介绍、安装及使用教程</a></p></blockquote><h5 id="快速启动">快速启动</h5><ol><li><p>安装</p><p>进入到 <code>cmd</code> 界面进行安装。我最开始想在指定环境 <code>activate ot</code>下安装，显示缺少依赖。</p><p>我想后面还可以设置引用环境为 <code>ot</code> ，就不管了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install jupyter</span><br></pre></td></tr></table></figure></li><li><p>启动</p><blockquote><p>启动后界面那一堆文件，其实是我们家目录中的文件。</p></blockquote><p>在 <code>cmd</code> 窗口输入下面命令，会自动在浏览器打开 <code>jupyter</code>。</p><p>:warning: 不要关闭 <code>cmd</code> 否则在 <code>Jupyter</code> 中也无法继续操作！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/25/Y9mb1jhGI45eK8R.png" alt="1576138744882"></p><p>如果想换个浏览器打开，可以查看到 <code>cmd</code> 中有 <code>token</code> 值：</p><p><img src="https://i.loli.net/2021/11/25/zETXUlyvQj4pk2S.png" alt="1576138873300"></p><p>输入 <code>http://localhost:8080</code>  在键入上述<code>token</code> 即可！</p><p>也可以使用 <code>jupyter notebook list</code> 查看<code>token</code> 值。</p></li><li><p>启动配置</p><p>指定端口启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --port &lt;port_number&gt;</span><br></pre></td></tr></table></figure><p>启动但不打开服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --no-browser</span><br></pre></td></tr></table></figure></li><li><p>设置文件保存路径</p><blockquote><p>仅说如何在 <code>windows</code> 设置，<code>linux</code> 参照最开始提到的教程。</p></blockquote><p>默认保存文档是在家目录，我们可以修改想要保存文件的目录。首先查询配置文件地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/25/NuF3HRY6Og87oQS.png" alt="1576139490927"></p><p>编辑该配置文件：找到 <code>c.NotebookApp.notebook_dir</code> 取消注释配置自己想保存的路径</p><p><img src="D:/hwh/images/1576140406053.png" alt="1576140406053"></p><ul><li><p>实际测试最好用 <code>\\</code>  , 成功后再启动就能看见一个清爽的界面</p><p><img src="https://i.loli.net/2021/11/25/vR8zOUrkqB5myKb.png" alt="1576140563010"></p></li></ul></li></ol><h5 id="基本使用">基本使用</h5><blockquote><p><em>主界面 &amp; 笔记本页面简介</em></p></blockquote><p><img src="https://i.loli.net/2021/11/25/XW6IzmFaD4rniPU.jpg" alt="preview"></p><p><img src="https://i.loli.net/2021/11/25/4eB3oOAsfhJG62g.jpg" alt="preview"></p><ul><li>根据上图我们创建一个<code>.ipynb</code> 文件，编辑上面测试代码 &amp; <code>md文字</code> 进行输出。</li><li><code>ESC</code> 进入命令模式 ：<ul><li><code>a</code> 在当前cell创建一个cell</li><li><code>b</code> 在当前cell之后创建一个cell</li><li><code>m</code> 进入 <code>markdown</code> 模式（单元格前面 <code>In[]</code> 没了）</li><li><code>y</code> 进入 <code>code</code>  （单元格前面 <code>In[]</code> 又出现了）</li><li><code>l</code> 显示 cell 中总行数</li><li><code>dd</code> 删除当前cell</li><li></li></ul></li></ul><h5 id="扩展功能">扩展功能</h5><blockquote><p>扩展功能1 ： 关联 <em>Jupyter Notebook</em>和 <em>conda</em> 环境。</p></blockquote><ol><li><p>安装 <code>nb_conda</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install nb_conda</span><br></pre></td></tr></table></figure><p>:warning: 出现报以下错误<img src="https://i.loli.net/2021/11/25/lMEk4fcpLraAoBu.png" alt="1576141764028"></p><p>摸不着头脑，我主要做了以下事就可以了：</p><ul><li><p><code>conda clean -- packages</code>  (好像没软用)</p></li><li><p>修改了下文件 <code>.condarc</code> 去除清华源换成别的源（？？）</p><p><img src="https://i.loli.net/2021/11/25/G5NCnWrPvwIToyS.png" alt="1576143102897"></p></li></ul></li><li><p>愉快查看环境</p><blockquote><p>此时在 <code>jupyter</code> 会增加一列 <code>Conda</code> 我们可以查看<code>Conda</code> 拥有的环境变量。</p><p>:warning: 但是此时不能直接点击切换环境，如 <code>ot</code></p></blockquote><p><img src="https://i.loli.net/2021/11/25/jYo2E75R81rDyVd.jpg" alt="preview"></p><p>查看环境又他娘报错：<br><img src="https://i.loli.net/2021/11/25/FYElc1Ltha2xHsV.png" alt="1576143237966"></p><p>解决报错：</p><p><img src="https://i.loli.net/2021/11/25/vXng1bdWBo58RUa.png" alt="1576143795333"></p></li><li><p>切换 <code>conda</code> 环境</p><p>如果想要指定 <code>conda</code> 指定环境，经过测试要先在<code>cmd</code> 激活指定环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activeta ot</span><br></pre></td></tr></table></figure><p>然后再启动 <code>Jupyter</code> ，即发现此时 <code>conda</code> 环境以及切换到 <code>ot</code> ：</p><p><img src="https://i.loli.net/2021/11/25/HuX2UJGa9MnzL7A.png" alt="1576157365347"></p></li></ol><blockquote><p>扩展2：在 <code>jupyter</code>  使用 <code>markdowm</code></p><p>:warning: 一开始报各种错误，又是 conda.exe 不存在 / 产生冲突。解决如下：</p><ol><li><p>卸载  <em>Anaconda</em></p><p>有些冲动了，感觉可以不卸载。</p></li><li><p>新建环境 <em>base0</em></p><p>:warning: 最开始安装 <code>3.7</code> 版本，后面安装扩展显示报错产生冲突。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name base0 --python=3.5</span><br></pre></td></tr></table></figure><p>接下来以下命令都能正常执行了。</p></li></ol></blockquote><blockquote><p>经过测试实际可行的安装扩展插件方法：</p><ol><li><p>用 <code>pip</code> 安装扩展</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install conda-forge jupyter_contrib_nbextensions</span><br></pre></td></tr></table></figure></li><li><p>解决安装的相关依赖</p><p>执行 <code>1.</code> 命令会显示要先安装 <code>lxml</code> 之类，为了速度先直接用<code>conda</code> 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install lxml</span><br></pre></td></tr></table></figure></li><li><p>安装扩展</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install conda-forge jupyter_contrib_nbextensions</span><br></pre></td></tr></table></figure><p>这样就可以快速安装好扩展了。</p><p>但是打开扩展可能出现下面问题：<br><img src="https://i.loli.net/2021/11/25/2fXtpUrSZjWsJGg.png" alt="1576595148296"></p><p>尝试执行下面命令即可解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter contrib nbextensions install --sys-prefix --skip-running-check</span><br></pre></td></tr></table></figure></li></ol></blockquote><ol><li><p>安装扩展</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c conda-forge jupyter_contrib_nbextensions</span><br></pre></td></tr></table></figure></li><li><p>开始使用 <code>markdown</code></p><p>点击导航栏多出来的 <code>Nbextensions</code> 类目，勾选  <code>Tableof Contents ⑵</code> 。</p><p>然后便可以在 <code>Jupyter</code> 中使用 <code>markdown</code> 了 ：</p><p><img src="https://i.loli.net/2021/11/25/yI4cGQNrLSvOtJ6.jpg" alt="img"></p></li><li><p>补充使用</p><ul><li></li></ul></li></ol><h5 id="加载各种">加载各种</h5><ol><li><p>加载指定网址源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%load URL</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/25/WzquYQd1aByPAJ9.gif" alt="img"></p></li><li><p>加载本地 <code>python</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%load Python文件的绝对路径</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/25/T2qbfp84Mg7JuAX.gif" alt="img"></p><blockquote><p>:slightly_smiling_face: 其实你不想加载 <code>python</code>  文件再运行，也可直接运行文件。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%run Python文件的绝对路径</span><br></pre></td></tr></table></figure></li></ol><h5 id="使用-shell-命令">使用 shell 命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!shell命令</span><br></pre></td></tr></table></figure><ul><li><code>!pwd</code> : 获取当前笔记本所在绝对路径位置</li></ul><p>也可在 <code>jupyter</code>  打开终端 ， <em>new —&gt; Terminal</em>  。</p><h5 id="快捷键">快捷键</h5><ul><li><p>按<code>esc</code>键进入命令模式，此时不能操作单元格</p><p><img src="https://i.loli.net/2021/11/25/iOuTaozw4HPZs5G.jpg" alt="img"></p></li><li><p>按<code>enter</code>或<code>return</code>键进入编辑模式，可编辑单元格</p></li></ul><h3 id="1-2-张量">1.2 张量</h3><h4 id="1-2-1-生成张量">1.2.1 生成张量</h4><blockquote><p>以下都需引入如下包。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure><h5 id="库函数生成">库函数生成</h5><blockquote><p>类似于 <code>numpy</code> 库函数生成<code>ndarray</code>，但有时候 <code>numpy</code> 传入有时是<code>triple</code>，而 <code>pytorch</code> 传入基本都是 <code>int</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># empty ： 没有初始化的张量（元素随机）</span></span><br><span class="line">torch.empty(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># rand：随机初始化张量</span></span><br><span class="line">torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># zeros：生成全零张量</span></span><br><span class="line">torch.zeros(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.long) <span class="comment"># 同时还指定元素类似为 long </span></span><br></pre></td></tr></table></figure><h5 id="直接构造">直接构造</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">5.5</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(x)Copy</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([<span class="number">5.5000</span>, <span class="number">3.0000</span>])</span><br></pre></td></tr></table></figure><h5 id="根据已有张量构造">根据已有张量构造</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X = torch.zeros(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据X实例方法 new_ones 生成全0张量，大小也可改变（那不等于直接库函数创建？）</span></span><br><span class="line">X1 = X.new_ones(<span class="number">2</span>,<span class="number">2</span>,dtype=torch.double)</span><br><span class="line"><span class="built_in">print</span>(X1)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>]], dtype=torch.float64)</span><br></pre></td></tr></table></figure><h4 id="1-2-2-常用张量方法">1.2.2 常用张量方法</h4><h5 id="形状相关">形状相关</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.查看形状</span></span><br><span class="line">X.size()  <span class="comment"># 输出：torch.Size([3, 3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.改变形状 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">torch.Size([<span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = x.view(<span class="number">16</span>)</span><br><span class="line">torch.Size([<span class="number">16</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = x.view(-<span class="number">1</span>, <span class="number">8</span>)  <span class="comment"># 参数为-1，指的是这个维度根据：元素个数/其它维度 ，自动计算出来</span></span><br><span class="line">torch.Size([<span class="number">2</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure><h5 id="索引操作">索引操作</h5><blockquote><p>类似 <code>numpy</code> 进行各种索引操作。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.rand(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">tensor([[<span class="number">0.3667</span>, <span class="number">0.7708</span>, <span class="number">0.9581</span>],</span><br><span class="line">        [<span class="number">0.0958</span>, <span class="number">0.6113</span>, <span class="number">0.3566</span>],</span><br><span class="line">        [<span class="number">0.6013</span>, <span class="number">0.0894</span>, <span class="number">0.2580</span>]])</span><br></pre></td></tr></table></figure><p>切片索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 索引第2列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[:,<span class="number">1</span>]</span><br><span class="line">tensor([<span class="number">0.7708</span>, <span class="number">0.6113</span>, <span class="number">0.0894</span>])</span><br></pre></td></tr></table></figure><p>不想写了…今天是 2019 / 11 / 12 16:58 ，我是青青草原带灰狼哈哈</p><h5 id="numpy数组-⇄-Torch-张量">numpy数组 ⇄ Torch 张量</h5><blockquote><p><code>ndarray</code> 数组每个元素之间是<code>空格</code> ，<code>Tensor</code> 是 <code>逗号</code> 。</p></blockquote><p><code>torch</code> 张量 → <code>numpy</code> 数组 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># numpy()</span></span><br><span class="line"></span><br><span class="line">a = torch.ones(<span class="number">5</span>)  <span class="comment"># 张量 : tensor([1., 1., 1., 1., 1.])</span></span><br><span class="line">b = a.numpy()      <span class="comment"># ndarray :[1. 1. 1. 1. 1.]</span></span><br></pre></td></tr></table></figure><p><code>torch</code> 张量 ← <code>numpy</code> 数组 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># torch.form_numpy()</span></span><br><span class="line"></span><br><span class="line">a = np.ones(<span class="number">5</span>)           <span class="comment"># ndarray：[1. 1. 1. 1. 1.]</span></span><br><span class="line">b = torch.from_numpy(a)  <span class="comment"># 张量： tensor([1., 1., 1., 1., 1.])</span></span><br></pre></td></tr></table></figure><h4 id="1-2-3-张量运算">1.2.3 张量运算</h4><h5 id="加减乘除">加减乘除</h5><blockquote><p>仅以加法为例，更多上百种运算参考：<a href="https://pytorch.org/docs/stable/torch.html">这里</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.直接相加</span></span><br><span class="line">y = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.库函数 torch.add</span></span><br><span class="line">torch.add(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.张量实例本身函数（in-place）</span></span><br><span class="line">y.add_(x)    <span class="comment"># adds x to y</span></span><br><span class="line"><span class="comment"># 其它in-place操作</span></span><br><span class="line">x.copy_(y)   <span class="comment"># 复制y到x </span></span><br></pre></td></tr></table></figure><h3 id="1-3-自动求导">1.3 自动求导</h3><p><code>pytorch</code> 在所有神经网络的核心是 <code>autograd</code> 包，而<code>autograd</code> 包核心类是 <code>torch.Tensor</code> <em>。</em></p><p><u><em>如何进行自动求导</em></u> ：</p><ul><li>给希望追踪对它进行求导的张量<code>x</code>，设置属性 <code>requires_grad = True</code></li><li>当完成计算后，通过调用 <code>backward(gradient)</code> 方法，自动计算所有的梯度（自动累加到 <code>grad</code> 属性）<ul><li>调用 <code>backward()</code> 方法需要指定一个参数<code>gradient</code>，<em><u><strong>该参数匹配张量形状</strong></u></em>  ？ 特别的，如果此时张量是标量，可不传入参数，等价此时 <code>gradient =  torch.tensor(1)</code> 。</li></ul></li><li>通过被追踪的张量 <code>x</code> 属性值 <code>grad</code> ，即 <code>x.grad</code> 便可求出它的梯度</li></ul><p><u><em>如果不希望跟踪历史记录</em></u> ：</p><ul><li>将代码块包装在 <code>with torch.no_grad()：</code> 中</li></ul><h4 id="1-3-1-关于-Function">1.3.1 关于 Function</h4><p><em>Function</em> 是自动求导另外一个非常重要的*<u>类</u>*  。<code>Tensor类</code> 和 <code>Function类</code>互相连接并生成一个非循环图，它表示和存储了完整的计算历史。</p><ul><li>每个张量都有一个<code>.grad_fn</code>属性，这个属性引用了一个创建了<code>Tensor</code>的<code>Function</code> （<em><u>没太明白</u></em> ？）</li></ul><h4 id="1-3-2-向量求导（没太整明白）">1.3.2 向量求导（没太整明白）</h4><blockquote><p>已知 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec y = f(\vec x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ， 其中 $\vec y $ 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span> 都是向量，那么 $\vec y $ 对 $\vec x $ 的梯度形式应该是？</p></blockquote><p>在数学上，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi>y</mi><mo>⃗</mo></mover></mrow><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi>x</mi><mo>⃗</mo></mover></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial \vec y}{\partial \vec x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2909em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9459em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight">x</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 应该是一个雅可比矩阵，可记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span> :</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>J</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><msub><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mn>1</mn></msub></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mn>1</mn></msub></mrow></mfrac><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mfrac><mrow><mi mathvariant="normal">∂</mi><msub><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mi>m</mi></msub></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mn>1</mn></msub></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><msub><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mn>1</mn></msub></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mi>n</mi></msub></mrow></mfrac><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mfrac><mrow><mi mathvariant="normal">∂</mi><msub><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mi>m</mi></msub></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mi>n</mi></msub></mrow></mfrac></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">J = \begin{bmatrix} \frac{\partial \vec y_1}{\partial \vec x_1} \ ... \  \frac{\partial \vec y_m}{\partial \vec x_1} \\... \\\frac{\partial \vec y_1}{\partial \vec x_n} \ ... \  \frac{\partial \vec y_m}{\partial \vec x_n} \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.982em;vertical-align:-1.741em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-3.397em;"><span class="pstrut" style="height:3.155em;"></span><span style="height:0.016em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='0.016em' style='width:0.6667em' viewBox='0 0 666.67 16' preserveAspectRatio='xMinYMin'><path d='M319 0 H403 V16 H319z M319 0 H403 V16 H319z'/></svg></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.241em;"><span style="top:-4.2951em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9459em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight">x</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace"> </span><span class="mord">...</span><span class="mspace"> </span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9459em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight">x</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">...</span></span></span><span style="top:-1.7041em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9459em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight">x</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace"> </span><span class="mord">...</span><span class="mspace"> </span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9459em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight">x</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.741em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-3.397em;"><span class="pstrut" style="height:3.155em;"></span><span style="height:0.016em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='0.016em' style='width:0.6667em' viewBox='0 0 666.67 16' preserveAspectRatio='xMinYMin'><path d='M263 0 H347 V16 H263z M263 0 H347 V16 H263z'/></svg></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>已知 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">l=g(\vec y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>  其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 为<strong>标量</strong> ，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>l</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi>y</mi><mo>⃗</mo></mover></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial l }{\partial \vec y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3612em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 梯度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 形式应该是？</p></blockquote><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mo>=</mo><msup><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>l</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>y</mi><mn>1</mn></msub></mrow></mfrac><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>l</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>y</mi><mi>m</mi></msub></mrow></mfrac></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">v = \begin{bmatrix} \frac{\partial l }{\partial y_1} \ ... \ \frac{\partial l }{\partial y_m} \end{bmatrix} ^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0313em;vertical-align:-0.65em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9306em;"><span style="top:-3.0505em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace"> </span><span class="mord">...</span><span class="mspace"> </span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">]</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.3812em;"><span style="top:-3.6029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>根据上述，我们已知 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi>y</mi><mo>⃗</mo></mover></mrow><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi>x</mi><mo>⃗</mo></mover></mrow></mfrac></mrow><annotation encoding="application/x-tex">J = \frac{\partial \vec y}{\partial \vec x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2909em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9459em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight">x</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>  ， $ v =\frac{\partial l }{\partial \vec y}$ , 那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>l</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi>x</mi><mo>⃗</mo></mover></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial l }{\partial \vec x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight">x</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> ?</p></blockquote><p>根据链式法则： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>l</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi>x</mi><mo>⃗</mo></mover></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial l }{\partial \vec x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight">x</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>l</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi>y</mi><mo>⃗</mo></mover></mrow></mfrac><mo separator="true">⋅</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi>y</mi><mo>⃗</mo></mover></mrow><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi>x</mi><mo>⃗</mo></mover></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial l }{\partial \vec y} · \frac{\partial \vec y}{\partial \vec x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.427em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9459em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight">x</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>l</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi>x</mi><mo>⃗</mo></mover></mrow></mfrac><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>l</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi>y</mi><mo>⃗</mo></mover></mrow></mfrac><mo separator="true">⋅</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi>y</mi><mo>⃗</mo></mover></mrow><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi>x</mi><mo>⃗</mo></mover></mrow></mfrac><mo>=</mo><mi>J</mi><mo separator="true">⋅</mo><mi>v</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><msub><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mn>1</mn></msub></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mn>1</mn></msub></mrow></mfrac><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mfrac><mrow><mi mathvariant="normal">∂</mi><msub><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mi>m</mi></msub></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mn>1</mn></msub></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><msub><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mn>1</mn></msub></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mi>n</mi></msub></mrow></mfrac><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mfrac><mrow><mi mathvariant="normal">∂</mi><msub><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mi>m</mi></msub></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mi>n</mi></msub></mrow></mfrac></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>l</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>y</mi><mn>1</mn></msub></mrow></mfrac></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>l</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>y</mi><mi>m</mi></msub></mrow></mfrac></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>l</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>x</mi><mn>1</mn></msub></mrow></mfrac></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>l</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>x</mi><mi>m</mi></msub></mrow></mfrac></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\frac{\partial l }{\partial \vec x} = \frac{\partial l }{\partial \vec y} · \frac{\partial \vec y}{\partial \vec x} = J·v =\begin{bmatrix} \frac{\partial \vec y_1}{\partial \vec x_1} \ ... \  \frac{\partial \vec y_m}{\partial \vec x_1} \\... \\\frac{\partial \vec y_1}{\partial \vec x_n} \ ... \  \frac{\partial \vec y_m}{\partial \vec x_n} \end{bmatrix}\begin{bmatrix} \frac{\partial l }{\partial y_1} \\ ... \\ \frac{\partial l }{\partial y_m} \end{bmatrix}=\begin{bmatrix} \frac{\partial l }{\partial x_1} \\ ... \\ \frac{\partial l }{\partial x_m} \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2714em;vertical-align:-0.8804em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.391em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.982em;vertical-align:-1.741em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-3.397em;"><span class="pstrut" style="height:3.155em;"></span><span style="height:0.016em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='0.016em' style='width:0.6667em' viewBox='0 0 666.67 16' preserveAspectRatio='xMinYMin'><path d='M319 0 H403 V16 H319z M319 0 H403 V16 H319z'/></svg></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.241em;"><span style="top:-4.2951em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9459em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight">x</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace"> </span><span class="mord">...</span><span class="mspace"> </span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9459em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight">x</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">...</span></span></span><span style="top:-1.7041em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9459em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight">x</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace"> </span><span class="mord">...</span><span class="mspace"> </span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9459em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight">x</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.741em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-3.397em;"><span class="pstrut" style="height:3.155em;"></span><span style="height:0.016em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='0.016em' style='width:0.6667em' viewBox='0 0 666.67 16' preserveAspectRatio='xMinYMin'><path d='M263 0 H347 V16 H263z M263 0 H347 V16 H263z'/></svg></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-3.397em;"><span class="pstrut" style="height:3.155em;"></span><span style="height:0.016em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='0.016em' style='width:0.6667em' viewBox='0 0 666.67 16' preserveAspectRatio='xMinYMin'><path d='M319 0 H403 V16 H319z M319 0 H403 V16 H319z'/></svg></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.2112em;"><span style="top:-4.3311em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">...</span></span></span><span style="top:-1.7699em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.7112em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-3.397em;"><span class="pstrut" style="height:3.155em;"></span><span style="height:0.016em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='0.016em' style='width:0.6667em' viewBox='0 0 666.67 16' preserveAspectRatio='xMinYMin'><path d='M263 0 H347 V16 H263z M263 0 H347 V16 H263z'/></svg></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.8504em;vertical-align:-1.6752em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-3.397em;"><span class="pstrut" style="height:3.155em;"></span><span style="height:0.016em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='0.016em' style='width:0.6667em' viewBox='0 0 666.67 16' preserveAspectRatio='xMinYMin'><path d='M319 0 H403 V16 H319z M319 0 H403 V16 H319z'/></svg></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.1752em;"><span style="top:-4.2951em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">...</span></span></span><span style="top:-1.7699em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.6752em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-3.397em;"><span class="pstrut" style="height:3.155em;"></span><span style="height:0.016em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='0.016em' style='width:0.6667em' viewBox='0 0 666.67 16' preserveAspectRatio='xMinYMin'><path d='M263 0 H347 V16 H263z M263 0 H347 V16 H263z'/></svg></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><h4 id="1-3-3-举个栗子">1.3.3 举个栗子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure><h5 id="栗子1">栗子1</h5><blockquote><p>以下过程可表示为 ：$out = \frac{1}{4} \sum_i z_i = \frac{1}{4} \sum_i 3(x_i+2)^2  $</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = torch.ones(<span class="number">2</span>,<span class="number">2</span>,requires_grad=<span class="literal">True</span>)  <span class="comment"># 追踪张量x</span></span><br><span class="line">y = x + <span class="number">2</span></span><br><span class="line">z = y * y * <span class="number">3</span></span><br><span class="line">out = z.mean()</span><br></pre></td></tr></table></figure><p><em>out</em> 调用方法 <code>backward</code> 进行反向传播，因为 <em>out</em> 是标量，所以可不用传参数： cvb n</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out.backward()</span><br></pre></td></tr></table></figure><p>由于 <em>x</em> 设置了 <code>requires_grad = True</code>  ，其梯度会被自动累加，我们可计算其梯度为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x.grad</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([[4.5000, 4.5000],</span></span><br><span class="line"><span class="comment">#        [4.5000, 4.5000]])</span></span><br></pre></td></tr></table></figure><p><em><strong>Q :</strong></em> 没明白，根据 <em><strong>1.3.2</strong></em>  节，此时输出不该是一个 <code>4*1</code> 大小张量吗？</p><p><em><strong>A:</strong></em> 非也，因为此时<code>x</code> 是 <code>2*2</code> 大小，而 <em><strong>1.3.2</strong></em>  节 <code>x</code> 是 <code>m*1</code> 大小</p><h5 id="栗子2">栗子2</h5><blockquote><p>以下过程可表示为： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∗</mo><mn>2</mn><msup><mo stretchy="false">)</mo><mrow><mn>2</mn><mo>∗</mo><mi>y</mi><mi mathvariant="normal">.</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi></mrow></msup></mrow><annotation encoding="application/x-tex">y = (x*2)^{2*y.data.norm}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">or</span><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></span></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = torch.randn(<span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">y = x * <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> y.data.norm() &lt; <span class="number">1000</span>:</span><br><span class="line">    y = y * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出y</span></span><br><span class="line"><span class="comment"># tensor([-920.6895, -115.7301, -867.6995], grad_fn=&lt;MulBackward&gt;)</span></span><br></pre></td></tr></table></figure><p>显然，此时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 是一个向量，那么此时调用 <code>backward</code> 进行反向传播需传递参数 <code>gradient</code> ：</p><p><em><strong>依然不太明白此时 <code>gradient</code> 参数意义？</strong></em></p><ul><li><p>大小和 <code>x</code> 保持一致，那么其中的列表值是什么意思呢？</p><blockquote><p>经过请教大师兄，解释如下：</p><ul><li><p><code>gradient</code> 参数表示学习速率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> ，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\alpha = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>  时 <code>x.grad</code>  = 512 ；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>0.1</mn></mrow><annotation encoding="application/x-tex">\alpha = 0.1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.1</span></span></span></span> ,那么 <code>x.grad</code>  = 51.2。</p><p>控制当前梯度变化速率，而且可对于每个不同样本 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 进行控制。</p></li></ul></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gradients = torch.tensor([<span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">0.0001</span>], dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">y.backward(gradients)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x.grad)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tensor([ 51.2000, 512.0000,   0.0512])</span></span><br></pre></td></tr></table></figure><h3 id="1-4-神经网络">1.4 神经网络</h3><blockquote><p>我的神经网络都是没有好好训练啊，做笔记还在胡思乱写，现在反向传播还来得及吗？</p></blockquote><p><img src="https://i.loli.net/2021/11/25/mXKvAwVLEQxqoBj.png" alt="img"></p><h4 id="14-1-快速入门">14.1 快速入门</h4><h5 id="定义网络">定义网络</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        <span class="comment"># class torch.nn.Conv1d(in_channels, out_channels, kernel_size, stride=1,                   padding=0, dilation=1, groups=1, bias=True)</span></span><br><span class="line">        <span class="comment"># 输入图像channels：1；输出channels：6；kernel = 5x5，方阵可只写一个数字5</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># class torch.nn.Linear(in_features, out_features, bias=True)</span></span><br><span class="line">        <span class="comment"># in_features ： 输入样本的大小</span></span><br><span class="line">        <span class="comment"># out_features： 输出样本的大小 </span></span><br><span class="line">        <span class="comment"># nn.Linear 传入相连两个layer各自大小，返回一个函数fc(x),可用来计算前向传播下一层layer值</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># torch.nn.functional.max_pool2d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False)</span></span><br><span class="line">        <span class="comment"># input：输入的张量。在这里激活函数为relu，会将神经元输入值映射到新值（输出值）</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv1(x)), (<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv2(x)), <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        x = x.view(-<span class="number">1</span>, self.num_flat_features(x)) <span class="comment"># 和全连接层相连先平铺</span></span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_flat_features</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        平铺卷积层图像特征向量：</span></span><br><span class="line"><span class="string">          因为输入图片size = (1,1,32,32),表示输入1张大小为1@32*32的特征图</span></span><br><span class="line"><span class="string">          显然第一个参数1，指图片个数，也就是一次批处理的数量</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        size = x.size()[<span class="number">1</span>:]  <span class="comment"># 除去批处理维度的其他所有维度，[1,16,5,5] --&gt; [16,5,5]</span></span><br><span class="line">        num_features = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> size:</span><br><span class="line">            num_features *= s</span><br><span class="line">        <span class="keyword">return</span> num_features</span><br><span class="line"></span><br><span class="line">net = Net()</span><br></pre></td></tr></table></figure><p>现在让我们进行前向传播和反向传播、更新权重等。下一节将会以实际例子来统合下面方法。</p><h5 id="前向传播">前向传播</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span> = torch.randn(<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>)  <span class="comment"># 随机输入一张图像</span></span><br><span class="line">out = net(<span class="built_in">input</span>)   <span class="comment"># 前向传播</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ 0.0399, -0.0856,  0.0668,  0.0915,  0.0453, -0.0680, -0.1024,  0.0493,</span><br><span class="line">         -0.1043, -0.1267]], grad_fn=&lt;AddmmBackward&gt;)</span><br></pre></td></tr></table></figure><h5 id="损失函数">损失函数</h5><p>一个损失函数接受一对 <em>(output, target)</em> 作为输入，<code>nn</code> 包多个不同损失函数。</p><p>例如：均方误差损失函数MSE，<code>nn.MSELoss()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output = net(<span class="built_in">input</span>)</span><br><span class="line">target = torch.randn(<span class="number">10</span>)          <span class="comment"># 本例子中使用模拟数据</span></span><br><span class="line">target = target.view(<span class="number">1</span>, -<span class="number">1</span>)       <span class="comment"># 使目标值与数据值形状一致,size=(1,10)</span></span><br><span class="line"></span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line">loss = criterion(output, target)  <span class="comment"># tensor(1.0263, grad_fn=&lt;MseLossBackward&gt;)</span></span><br></pre></td></tr></table></figure><h5 id="反向传播">反向传播</h5><blockquote><p><em><strong>Q :</strong></em> 传入一个随机梯度进行反向传播？</p></blockquote><p>有了 <code>loss</code> 函数我们便可以进行反向传播。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.zero_grad()                    <span class="comment"># 清除所有参数的梯度缓存</span></span><br><span class="line">loss.backward(torch.randn(<span class="number">1</span>, <span class="number">10</span>))  <span class="comment"># 传入一个随机梯度进行反向传播？</span></span><br></pre></td></tr></table></figure><p>同时我们还可以查看反向传播后 <em><strong>conv1</strong></em> 层 <em><strong>bias</strong></em> 梯度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; net.conv1.bias.grad</span><br><span class="line">tensor([ 0.0084,  0.0019, -0.0179, -0.0212,  0.0067, -0.0096])</span><br></pre></td></tr></table></figure><h4 id="1-4-2-举个栗子：训练分类器">1.4.2 举个栗子：训练分类器</h4><blockquote><p>这部分主要参考：<a href="https://www.jianshu.com/p/016a23bc6554">基于PyTorch的CIFAR10小记</a></p></blockquote><p>训练一个图像分类器可按照以下顺序进行：</p><ul><li>使用<code>torchvision</code>加载和归一化 <em>CIFAR10</em> 训练集和测试集</li><li>定义一个卷积神经网络</li><li>定义损失函数</li><li>在训练集上训练网络</li><li>在测试集上测试网络</li></ul><h5 id="1-加载数据">1 加载数据</h5><blockquote><p>该部分主要参考于 ： <a href="https://www.jianshu.com/p/016a23bc6554">基于PyTorch的CIFAR10小记</a></p></blockquote><p>测试数据集使用 <code>CIFAR10</code>，直接用<code>torchvision</code> 太慢，我们使用 <a href="http://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz">链接</a> 来进行下载。</p><p>下载完毕后，导入包和一些基本参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数设置</span></span><br><span class="line">EPOCHS = <span class="number">20</span></span><br><span class="line">BATCH_SIZE = <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.创建一个转换器，将torchvision数据集的输出范围[0,1]转换为归一化范围的张量[-1,1]</span></span><br><span class="line"><span class="comment"># 为什么需要转换？</span></span><br><span class="line">transform = transforms.Compose\</span><br><span class="line">([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.创建训练集</span></span><br><span class="line">trainset = torchvision.datasets.CIFAR10\</span><br><span class="line">(</span><br><span class="line">    root=<span class="string">&#x27;./data&#x27;</span>,         <span class="comment"># 存放的目录</span></span><br><span class="line">    train=<span class="literal">True</span>,            <span class="comment"># 是否训练集</span></span><br><span class="line">    download=<span class="literal">True</span>,         <span class="comment"># 是否需要下载</span></span><br><span class="line">    transform=transform    <span class="comment"># 是否进行转换</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.创建测试集</span></span><br><span class="line">testset = torchvision.datasets.CIFAR10\</span><br><span class="line">(</span><br><span class="line">    root=<span class="string">&#x27;./data&#x27;</span>,</span><br><span class="line">    train=<span class="literal">False</span>,</span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=transform</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.创建训练/测试加载器</span></span><br><span class="line"><span class="comment"># shuffle -- 是否打乱顺序</span></span><br><span class="line">trainloader = torch.utils.data.DataLoader(trainset, batch_size=BATCH_SIZE, shuffle=<span class="literal">True</span> )</span><br><span class="line"></span><br><span class="line">testloader = torch.utils.data.DataLoader (testset, batch_size=BATCH_SIZE, shuffle=<span class="literal">True</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.设置类别标签</span></span><br><span class="line">classes = (<span class="string">&#x27;plane&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;deer&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;frog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;ship&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面一些代码进行解释：</p><blockquote><p>转换器</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))])</span><br></pre></td></tr></table></figure><ul><li><p><code>ToTensor()</code>: 将一个取值是 [0,255]的<em>PI.Imag</em>e（或者 <em>shape=(H,W,C)</em> 的<em>ndarray</em>）  —&gt; 取值是[0,1,0]的<em>torch.FloadTensor</em>（同时 <em>shape=(C,H,W)</em>）</p></li><li><p><code>Normalize(mean, std)</code> ： 给定均值 <em>mean、std</em>，会将<em>Tensor</em>正则化，即：<em>Normalized_image=(image-mean)/std</em></p></li><li><p><code>transforms.Compose([ transforms.CenterCrop(10),transforms.ToTensor() ])</code></p><ul><li>将多个 <em>transform</em> 组合起来使用，比如上面是进行了 <em><u>中心裁剪</u></em> +  <em><u>ToTensor</u></em></li></ul></li></ul><h5 id="2-定义网络">2 定义网络</h5><blockquote><p>该网络定义在文件: <code>CNN1.py</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">LR = <span class="number">0.005</span>  <span class="comment"># 学习率</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义网络结构：3个卷积层 + 1个全连接层</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3个卷积层</span></span><br><span class="line">        <span class="comment"># 定义该卷积层依次经过： 3*3卷积核 --&gt; ReLU激活函数 --&gt; 池化层下采样</span></span><br><span class="line">        self.conv1 = torch.nn.Sequential\</span><br><span class="line">        (</span><br><span class="line"><span class="comment"># Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0,  dilation=1)</span></span><br><span class="line">            torch.nn.Conv2d(<span class="number">3</span>, <span class="number">16</span>, <span class="number">3</span>, padding=<span class="number">1</span>),  <span class="comment"># 3@32*32 -&gt; 16@32*32</span></span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            <span class="comment"># 第一个参数是卷积核大小2*2，第二个参数是stride</span></span><br><span class="line">            torch.nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)               <span class="comment"># 16*32*32 -&gt; 16*16*16</span></span><br><span class="line">        )</span><br><span class="line">        self.conv2 = torch.nn.Sequential\</span><br><span class="line">        (</span><br><span class="line">            torch.nn.Conv2d(<span class="number">16</span>, <span class="number">32</span>, <span class="number">3</span>, padding=<span class="number">1</span>),  <span class="comment"># 16*16*16 -&gt; 32*16*16</span></span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)                <span class="comment"># 32*16*16 -&gt; 32*8*8</span></span><br><span class="line">        )</span><br><span class="line">        self.conv3 = torch.nn.Sequential\</span><br><span class="line">        (</span><br><span class="line">            torch.nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">3</span>, padding=<span class="number">1</span>),  <span class="comment"># 32*8*8 -&gt; 64*8*8</span></span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)                <span class="comment"># 64*8*8 -&gt; 64*4*4</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1个全连接层（2个？）</span></span><br><span class="line">        self.fc1 = torch.nn.Sequential\</span><br><span class="line">        (</span><br><span class="line">            <span class="comment"># class torch.nn.Linear(in_features, out_features, bias=True)</span></span><br><span class="line">            torch.nn.Linear(<span class="number">64</span>*<span class="number">4</span>*<span class="number">4</span>, <span class="number">32</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            <span class="comment"># torch.nn.Dropout()</span></span><br><span class="line">        )</span><br><span class="line">        self.fc2 = torch.nn.Linear(<span class="number">32</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向传播</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = self.conv3(x)</span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">64</span>*<span class="number">4</span>*<span class="number">4</span>)  <span class="comment"># 和全连接层相连先扁平化 </span></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line">net.cuda()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失函数：使用交叉熵</span></span><br><span class="line">criterion = torch.nn.CrossEntropyLoss() </span><br><span class="line"><span class="comment"># 权重更新规则：使用Adam下降（optim.SGD,随机梯度下降）</span></span><br><span class="line">optimizer = torch.optim.Adam(net.parameters(), lr=LR)</span><br></pre></td></tr></table></figure><h5 id="3-训练函数-测试函数">3 训练函数 &amp;  测试函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5.训练函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">model, criterion, optimizer, trainloader, epochs=<span class="number">5</span>, interval=<span class="number">50</span></span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;----- Train Start -----&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        running_loss = <span class="number">0.0</span></span><br><span class="line">        <span class="comment"># 遍历数据迭代器：获取数据信息</span></span><br><span class="line">        <span class="keyword">for</span> step, (x,y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(trainloader):</span><br><span class="line">            <span class="comment"># 获取输入</span></span><br><span class="line">            <span class="comment"># [易错] 使用GPU训练，数据也需要设置cuda</span></span><br><span class="line">            inputs, labels = x.cuda(),y.cuda()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 下面其实就是梯度下降过程，参考：https://www.zhihu.com/question/305638940</span></span><br><span class="line">            <span class="comment"># 权重清零</span></span><br><span class="line">            optimizer.zero_grad() <span class="comment"># 一次bacth计算出的梯度g(loss对weigth导数）用于</span></span><br><span class="line">                                  <span class="comment"># 更新权重 w = w - α*g 后，下次g要清零重新计算</span></span><br><span class="line">            <span class="comment"># 计算loss反向传播</span></span><br><span class="line">            output = model(inputs)             <span class="comment"># 期望输出值</span></span><br><span class="line">            loss = criterion(output, labels)   <span class="comment"># 该次代价</span></span><br><span class="line">            loss.backward()                    <span class="comment"># 反向传播</span></span><br><span class="line">            optimizer.step()                   <span class="comment"># 更新权重</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 输出每log_interval=50次批次平均loss</span></span><br><span class="line">            <span class="comment"># loss是张量：tensor(2.3109, device=&#x27;cuda:0&#x27;, grad_fn=&lt;NllLossBackward&gt;)</span></span><br><span class="line">            running_loss += loss.item()</span><br><span class="line">            <span class="keyword">if</span> step % log_interval == (log_interval - <span class="number">1</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;[%d, %5d] loss: %.4f&#x27;</span> %(epoch+<span class="number">1</span>, step+<span class="number">1</span>, running_loss/ interval))</span><br><span class="line">                running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;----- Train Finished -----&#x27;</span>)</span><br></pre></td></tr></table></figure><p>现在我们来开始设置测试函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6.测试函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">model, testloader</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------ Test Start -----&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> test_x, test_y <span class="keyword">in</span> testloader:</span><br><span class="line">            <span class="comment"># 批处理数量，batch_size = 512: 一次输入512张图片</span></span><br><span class="line">            <span class="comment"># images.shape = torch.Size([512,3,32,32]) lable.shape = torch.Size([512])</span></span><br><span class="line">            images, labels = test_x.cuda(), test_y.cuda()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># output.shape = torch.Size([512,10])</span></span><br><span class="line">            output = model(images)        </span><br><span class="line"></span><br><span class="line">            <span class="comment"># predicted.shape = torch.Size([512])</span></span><br><span class="line">            <span class="comment"># torch.max : 返回每行最大值，如果[指定维度] 还会返回对应最大值索引</span></span><br><span class="line">            <span class="comment"># output.data : 获取张量数据，返回还是一个张量？</span></span><br><span class="line">            _, predicted = torch.<span class="built_in">max</span>(output.data, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># size() 方法：获取大小，返回一个张量如：torch.Size([3, 4])</span></span><br><span class="line">            <span class="comment"># sum()  方法：求张量所有元素和，返回一个张量如：tensor(3.2860)</span></span><br><span class="line">            <span class="comment"># item() 方法：把[1]个元素大小的张量，转换为 python数值类型</span></span><br><span class="line">            total += labels.size(<span class="number">0</span>)</span><br><span class="line">            correct += (predicted == labels).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">    accuracy = <span class="number">100</span> * correct / total</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Accuracy of the network is: %.4f %%&#x27;</span> % accuracy)</span><br><span class="line">    <span class="keyword">return</span> accuracy</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># train(CNN1.net, CNN1.criterion, CNN1.optimizer, trainloader, epochs=EPOCHS)</span></span><br><span class="line">    test(CNN1.net, testloader)</span><br></pre></td></tr></table></figure><p>最后测试准确率为：<code>71.3%</code> 左右。</p><h5 id="4-规范代码结构">4 规范代码结构</h5><blockquote><p>该部分主要参考： <a href="https://zhuanlan.zhihu.com/p/29024978">PyTorch实战指南</a></p></blockquote><p>定义文件结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├── checkpoints/</span><br><span class="line">├── data/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── dataset.py</span><br><span class="line">│   └── get_data.sh</span><br><span class="line">├── models/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── AlexNet.py</span><br><span class="line">│   ├── BasicModule.py</span><br><span class="line">│   └── ResNet34.py</span><br><span class="line">└── utils/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── visualize.py</span><br><span class="line">├── config.py</span><br><span class="line">├── main.py</span><br><span class="line">├── requirements.txt</span><br><span class="line">├── README.md</span><br></pre></td></tr></table></figure><h2 id="二、常用函数">二、常用函数</h2><h3 id="归一：BatchNorm2d">归一：<em>BatchNorm2d</em></h3><h4 id="中文文档解释">中文文档解释</h4><blockquote><ol><li><p>pytorch 中文文档 ：<a href="https://www.pytorchtutorial.com/docs/package_references/torch-nn/?query=BatchNorm2d#class-torchnnbatchnorm2dnum_features-eps1e-05-momentum01-affinetruesource">class torch.nn.BatchNorm2d</a></p></li><li><p><a href="https://www.zhihu.com/question/38102762/answer/391649040">知乎问答：BN为什么效果好?</a></p></li></ol></blockquote><p>:warning: 参数 <em>num_features</em> : 实际只传的是通道数！</p><p><img src="https://i.loli.net/2021/11/25/nFCWeRi5y1SLTBk.png" alt="1576833667384"></p><h4 id="实例补充">实例补充</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/yongjieShi/p/9332655.html">Pytorch中的Batch Normalization操作</a></p></blockquote><p>假设存在<code>4</code> 个 <em>batch</em> ，每个特征图大小为：<code>3*2*2</code>  ，即通道数为 <code>3</code> ，长宽为 <code>2*2</code> 。那么归一化如下：</p><ol><li><p>每个<em>batch</em> ，从相同通道（比如第一个<code>R</code>通道）取出特征图其大小为 <code>2*2</code></p></li><li><p>上述一共有 <code>4</code> 个 <code>2*2</code> 的特征图，对这<code>16</code> 个元素进行归一化操作</p><p><img src="https://i.loli.net/2021/11/25/GRiuVUk8r2Lcmnx.png" alt="1576834202406"></p></li><li><p>重复 <code>1 2</code> 两次 （一共3个通道），则对剩余两个通道的<code>16*2</code> 个元素也进行了归一化</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习基础（一）Numpy</title>
      <link href="/2021/11/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89Numpy/"/>
      <url>/2021/11/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89Numpy/</url>
      
        <content type="html"><![CDATA[<h1>矩阵，数组？Numpy</h1><h2 id="一、-常用方法">一、 常用方法</h2><h3 id="0-初次使用">0 初次使用</h3><p>安装：<code>pip install numpy</code></p><p>引用：<code>import numpy as np</code></p><h3 id="1-创建数组：np-arange、np-ones…">1 创建数组：np.arange、np.ones…</h3><h4 id="基本方式">基本方式</h4><p>基本创建数组的办法，注意以下创建的都是 <u><em>一维数组 (5,)</em></u> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])   <span class="comment"># &gt;&gt;&gt;[0 1 2 3 4]</span></span><br><span class="line">b = np.array((<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))   <span class="comment"># &gt;&gt;&gt;[0 1 2 3 4]</span></span><br><span class="line">c = np.arange(<span class="number">5</span>)                <span class="comment"># &gt;&gt;&gt;[0 1 2 3 4]</span></span><br><span class="line">d = np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi, <span class="number">5</span>)  <span class="comment"># 将[0,2π]等分为5份</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d) <span class="comment"># &gt;&gt;&gt;[ 0.          1.57079633  3.14159265  4.71238898  6.28318531]</span></span><br></pre></td></tr></table></figure><p>为了创建 <u><em>多维数组</em></u>  我们可以使用 <code>reshape()</code> 来改变数组维度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))  <span class="comment"># 2D:传入的是一个元组</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.arange(<span class="number">12</span>).reshape((<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>))  <span class="comment"># 3D:传入的是一个元组</span></span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>]],</span><br><span class="line">       [[ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]]])</span><br></pre></td></tr></table></figure><p>当然你也可以选择传入多维列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = np.array([[<span class="number">2</span>,<span class="number">1</span>,-<span class="number">2</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = np.array([[<span class="number">2</span>,<span class="number">1</span>,-<span class="number">2</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A</span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">1</span>, -<span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">0</span>,  <span class="number">1</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">1</span>, -<span class="number">1</span>]])</span><br></pre></td></tr></table></figure><h4 id="库函数生成">库函数生成</h4><p>最后可以使用基本库函数 <code>zeros、ones、eyes、empty、full、random</code>来创建。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1D 创建一维可以直接传递一个数字</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.zeros(<span class="number">6</span>)</span><br><span class="line">array([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.ones(<span class="number">6</span>)</span><br><span class="line">array([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.full(<span class="number">6</span>,<span class="number">3</span>)</span><br><span class="line">array([<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2D 除了 eyes方法，其余都传递一个元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.zeros((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.empty((<span class="number">2</span>,<span class="number">3</span>))  <span class="comment"># 不是空矩阵，而是内容随机</span></span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.full((<span class="number">2</span>,<span class="number">3</span>),<span class="number">6</span>)</span><br><span class="line">array([[<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>]])</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.eye(<span class="number">3</span>,<span class="number">3</span>)      <span class="comment"># 对角矩阵：传递不是元组，而是两个数字</span></span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.random((<span class="number">2</span>,<span class="number">3</span>)) <span class="comment"># 随机填充[0,1]之间的一个数值</span></span><br><span class="line">array([[<span class="number">0.91453011</span>, <span class="number">0.06663476</span>, <span class="number">0.18352908</span>],</span><br><span class="line">       [<span class="number">0.19449024</span>, <span class="number">0.06442752</span>, <span class="number">0.64491859</span>]])</span><br></pre></td></tr></table></figure><p>​</p><h3 id="2-索引：切片、列表索引、布尔屏蔽">2 索引：切片、列表索引、布尔屏蔽</h3><h4 id="基本索引">基本索引</h4><p>索引一个数字类似于 <em>python</em> 多维列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span> ,<span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>,<span class="number">4</span>] </span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><h4 id="切片索引">切片索引</h4><p><img src="https://i.loli.net/2021/11/25/F25HRL6gUwmi9Af.png" alt="1571885721547"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 索引第2列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:, <span class="number">1</span>]  </span><br><span class="line">[<span class="number">12</span> <span class="number">17</span> <span class="number">22</span> <span class="number">27</span> <span class="number">32</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 索引第1列，指定开始选中数值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">4</span>, <span class="number">0</span>] </span><br><span class="line">[<span class="number">16</span> <span class="number">21</span> <span class="number">26</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 索引第0行，指定开始选中数值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>, <span class="number">1</span>:<span class="number">4</span>] </span><br><span class="line">[<span class="number">12</span> <span class="number">13</span> <span class="number">14</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔2行，每隔2列进行索引</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::<span class="number">2</span>,::<span class="number">2</span>] </span><br><span class="line">[[<span class="number">11</span> <span class="number">13</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">21</span> <span class="number">23</span> <span class="number">25</span>]</span><br><span class="line"> [<span class="number">31</span> <span class="number">33</span> <span class="number">35</span>]]</span><br></pre></td></tr></table></figure><h4 id="列表索引">列表索引</h4><p>依旧使用上面矩阵，我们可以指定一个列表来索引指定位置元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">                  [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">                  [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">                  [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span> ,<span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">                  [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[L]  <span class="comment"># 索引第 1、3、5行</span></span><br><span class="line">array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">       [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">       [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br></pre></td></tr></table></figure><h4 id="布尔屏蔽">布尔屏蔽</h4><p>布尔屏蔽是一个有用的功能，它允许我们根据我们指定的条件检索数组中的元素。</p><p><img src="https://i.loli.net/2021/11/25/y2knujlXC85DNE6.png" alt="å¸å°æ©ç ç»æå¾"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 布尔屏蔽</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">a = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">50</span>)</span><br><span class="line">b = np.sin(a)</span><br><span class="line">plt.plot(a,b)</span><br><span class="line"><span class="comment"># 画出值大于0，且小于π/2的所有绿色点</span></span><br><span class="line">mask = (b &gt;= <span class="number">0</span>) &amp; (a &lt;= np.pi / <span class="number">2</span>)</span><br><span class="line">plt.plot(a[mask], b[mask], <span class="string">&#x27;go&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="3-插入：np-c-、np-r">3 插入：np.c_ 、np.r_</h3><blockquote><p>还有其它插入方式暂时不表，下面都仅限于插入 2D 数组，更高维暂未尝试。</p></blockquote><h4 id="按列插入：np-c">按列插入：np.c_</h4><p>按列插入则要求，被插入的数组和原数组 <em>行相同</em> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1D 数组，但是第一维度相同（虽然看起来是行向量？）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c0 = np.zeros((<span class="number">3</span>,))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.c_[c0,a]</span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2D 数组，第一维度相同</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c1 = np.ones((<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.c_[c1,a]</span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]])</span><br></pre></td></tr></table></figure><h4 id="按行插入：np-r">按行插入：np.r_</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按行插入：第2维度相等</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r0 = np.zeros((<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.r_[r0,a]</span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">       [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]])</span><br></pre></td></tr></table></figure><h2 id="二、Numpy-进阶">二、Numpy 进阶</h2><h3 id="2-1-广播">2.1 广播</h3><blockquote><p>以下整理自：<a href="https://www.cnblogs.com/jiaxin359/p/9021726.html">numpy中的广播机制</a></p></blockquote><p><em>什么是广播？</em></p><p>当两个数组的形状并不相同的时候，我们可以通过扩展数组的方法来实现相加、相减、相乘等操作。</p><p><em>广播的条件是什么？</em></p><ul><li>数组维度 <u>不同</u>，后缘维度的轴长相符</li><li>数组维度 <u>相同</u>，其中有个轴为1</li></ul><h4 id="2-1-1-维度不同进行广播">2.1.1 维度不同进行广播</h4><p><img src="https://i.loli.net/2021/11/25/ksK1th4qXL6dnP8.png" alt="image"></p><ul><li><code>(4,3)</code> 是 2D，<code>(3,)</code> 是 1D，但是它们后缘维度相同，因此可以扩展</li></ul><p><img src="https://i.loli.net/2021/11/25/SLkU6c7u8N1Ejrb.png" alt="image"></p><ul><li><code>(3,4,2)</code> 是 3D，<code>(4,2)</code> 是 1D，但是它们后缘维度相同</li></ul><p>同理，还有 <code>（4,2,3）</code>和<code>（2,3）</code>是兼容的，<code>（4,2,3）</code>还和<code>（3）</code>是兼容的。</p><h4 id="2-1-2-维度相同进行广播">2.1.2 维度相同进行广播</h4><p><img src="https://i.loli.net/2021/11/25/DmQKJ6Ziu5SzkNV.png" alt="image"></p><ul><li>虽然维度相同，但有一个为1，也可以进行广播。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> Numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（二）_计算机基础</title>
      <link href="/2021/11/25/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/11/25/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1>二、Linux &amp; Git</h1><h2 id="2-1-Linux">2.1 Linux</h2><h3 id="2-1-1-常用命令">2.1.1 常用命令</h3><ol><li><p><strong>查看80端口状态</strong>？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntulp | grep 80</span><br></pre></td></tr></table></figure><ul><li><p><code>-t</code> : 指明显示TCP端口</p></li><li><p><code>-u</code> : 指明显示UDP端口</p></li><li><p><code>-l</code> : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)</p></li><li><p><code>-p</code> : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序</p></li><li><p><code>-n</code> : 不进行DNS轮询，显示IP(可以加速操作)</p></li></ul></li><li><p><strong>查看进程状态？怎么退出？怎么搜索进程？怎么查看某一个进程的内存和CPU使用情况？</strong></p><ul><li><p>所有进程状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -aux  <span class="comment"># 内存中进程信息</span></span><br><span class="line">ps -l    <span class="comment"># 本次登陆所有的进程信息</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/19/ayQRIA8FcqBjtlV.png" alt="image-20210519183338193"></p></li><li><p>退出进程：</p><p><code>exit</code></p></li><li><p>搜索进程：</p><p><code>ps -ef </code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep &lt;进程名&gt;</span><br></pre></td></tr></table></figure><ul><li><code>-e</code>相当于<code>-a</code>是全部列出，<code>-f</code>是显示UID等；</li></ul></li><li><p>查看指定进程（如kalfa）CPU和内存占用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep java</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/23/r5vaDgo4sYGfA8c.png" alt="image-20210523171131744"></p><ul><li>1.3是<strong>CPU占用率</strong>，12.7是<strong>内存占用率</strong>，943100是<strong>物理内存使用量</strong></li></ul><p>还可以使用 top命令查看指定进程（PID）的内存和CPU使用率：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p 2913</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>查看占用指定端口的进程</strong> ？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :8040</span><br></pre></td></tr></table></figure><p>这一步只<u>能获取进程名</u>，还要<code>ps</code> 命令进一步获取进程<code>id</code></p><p>如果要杀死相应进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 &lt;进程id&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>任务管理器</strong>（cpu占用率、内存占用率、进程）？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p>（<strong>总忘</strong>）还可以使用 top命令查看<strong>指定进程（PID）的内存和CPU使用率：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p</span><br></pre></td></tr></table></figure></li><li><p><strong>内存使用情况 和 磁盘使用情况？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m  <span class="comment"># 内存使用情况</span></span><br></pre></td></tr></table></figure><p>磁盘使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -m</span><br></pre></td></tr></table></figure><p><code>-m</code> : 以Mb为单位显示磁盘使用量和占用率</p></li><li><p><strong>统计单词个数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -o &lt;单词&gt; &lt;文件地址&gt; ｜ wc -l   <span class="comment"># -l表示统计行数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>修改用户权限及常用参数？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod &lt;参数(可选)&gt; &lt;模式&gt; &lt;文件/文件夹&gt;</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li><code>-R</code> ：递归的修改文件夹下所有子文件/文件夹的所属用户</li></ul><blockquote><p>【示例】如何修改 <code>/test5/5.txt</code> ，权限从<code>rw-r--r--</code> —&gt; <code>r--rwxrwx </code> ？</p><p><img src="https://camo.githubusercontent.com/fc3e66b1514a14614059e9423b7393b39d9a79db57cdcf11f0efd07fd95d32ca/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30392f31372f527a664d625165377471756b786c452e706e67" alt="1580875509098"></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户（U）权限[减去写]权限</span></span><br><span class="line">chmod u-w /test5/5.txt</span><br><span class="line"><span class="comment"># 组（G）/其他用户（O）权限[加上写、执行]</span></span><br><span class="line">chmod go+wx /test5/5.txt</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/20/3wrFPWplI47MTbO.png" alt="1580875689076"></p></li><li><p><strong>查看文件的命令有哪些？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi 文件名   <span class="comment">#编辑方式查看，可修改</span></span><br><span class="line">cat 文件名  <span class="comment">#显示全部文件内容</span></span><br><span class="line">more 文件名 <span class="comment">#分页显示文件内容</span></span><br><span class="line">less 文件名 <span class="comment">#与 more 相似，更好的是可以往前翻页</span></span><br><span class="line">tail 文件名 <span class="comment">#仅查看尾部，还可以指定行数</span></span><br><span class="line">head 文件名 <span class="comment">#仅查看头部,还可以指定行数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>你平时怎么查看日志的？</strong></p><p>Linux查看日志的命令有多种: tail、cat、tac、head、echo等，本文只介绍几种常用的方法。</p><ul><li><p><strong>tail（最常使用）</strong></p><p>命令格式: <code>tail[必要参数][选择参数][文件]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail -n 10 test.log 查询日志尾部最后10行的日志;</span><br><span class="line">tail -n +10 test.log 查询10行之后的所有日志;</span><br><span class="line">tail -fn 10 test.log 循环实时查看最后10行记录(最常用的)</span><br></pre></td></tr></table></figure><p>一般还会配合着grep搜索用，例如 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -fn 1000 test.log | grep <span class="string">&#x27;关键字&#x27;</span></span><br></pre></td></tr></table></figure><p>如果一次性查询的数据量太大,可以进行翻页查看，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 4700 aa.log |more -1000 可以进行多屏显示(ctrl + f 或者 空格键可以快捷键)</span><br></pre></td></tr></table></figure></li><li><p><strong>其它配合的命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span>              <span class="comment"># 所有的历史记录</span></span><br><span class="line"><span class="built_in">history</span> | grep XXX   <span class="comment"># 历史记录中包含某些指令的记录</span></span><br><span class="line"><span class="built_in">history</span> | more       <span class="comment"># 分页查看记录</span></span><br><span class="line"><span class="built_in">history</span> -c           <span class="comment"># 清空所有的历史记录</span></span><br><span class="line">!! 重复执行上一个命令</span><br><span class="line">查询出来记录后选中 : !323</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>怎么让进程后台运行？</strong></p><ol><li><p>命令后面加上**&amp;**即可，实际上，这样是将命令放入到一个作业队列中了；</p><p>通常配合<strong>nohup</strong> ，忽略发送给子命令的挂断SIGHUP信号（<strong>终端关闭</strong>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup subcommand &amp;</span><br></pre></td></tr></table></figure></li><li><p>ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程；</p><blockquote><p>ctrl + c 是进程终止。</p></blockquote></li><li><p>运行指令前面 <strong>+ setsid</strong>，使其父进程编程init进程，<strong>不受SIGHUP信号的影响</strong>。</p></li></ol></li></ol><h3 id="2-1-2-其它问题">2.1.2 其它问题</h3><h4 id="1-请问-proc-目录有什么用？">1. <strong>请问<code>/proc</code> 目录有什么用？</strong></h4><p>Linux系统上的/proc目录是一种文件系统，即proc文件系统。 /proc是一种伪文件系统（也即虚拟文件系统），存储的是<strong>当前内核运行状态</strong>的一系列特殊文件，用户可以通过这些文件：</p><ul><li><strong>查看系统有关（1）硬件及当前（2）正在运行进程</strong>的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。</li></ul><h4 id="2-Linux的软-硬链接是什么？有什么区别？">2. <strong>Linux的软/硬链接是什么？有什么区别？</strong></h4><blockquote><p>参考：<a href="https://www.linuxprobe.com/soft-and-hard-links.html">“软链接”和“硬链接”的区别</a></p></blockquote><ul><li><p><strong>什么是链接</strong> ？</p><p>文件在Linux上被分成两部分：<strong>用户数据 (user data) 与元数据 (metadata)</strong> 。</p><ul><li><strong>用户数据</strong>：即文件数据块，保留记录文件真实内容的地方</li><li><strong>元数据：</strong>  是文件的附加属性，如创建大小、时间，所有信息等。其中<strong>inode号</strong> ，是文件的唯一标识。</li></ul><p>系统通过inode号快速找到文件，有一种方式可以<strong>快速寻找到数据元信息</strong>，那就是软/硬链接。</p><p>现在我们创建一个新文件<code>myfile</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch myfile &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;This is a plain text file.&quot;</span> &gt; myfile</span><br><span class="line">$ cat myfile</span><br><span class="line"></span><br><span class="line">This is a plain text file.</span><br></pre></td></tr></table></figure><p>来展示二者区别。</p></li><li><p><strong>硬链接</strong></p><p>建立 <code>myfile</code> 的一个硬链接 <code>hard</code> ，可以看到二者的<code>inode</code>  是一致的，也就是说<strong>指向了同一个物理区块</strong>。</p><blockquote><p>硬链接inode ：指向文件的地址 &amp; 维护了一个引用计数，只要有文件还指向这个区块，它就不会从硬盘消失。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ln myfile hard  <span class="comment"># 建立硬链接hard</span></span><br><span class="line">$ ls -li</span><br><span class="line"></span><br><span class="line">25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 hard</span><br><span class="line">25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 myfile</span><br></pre></td></tr></table></figure><ul><li><p><strong>操作硬链接更新文件，等价更新原文件</strong></p><p>使用hard硬链接修改文件，发现原文件也被修改了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;New line&quot;</span> &gt;&gt; hard</span><br><span class="line">$ cat myfile</span><br><span class="line"></span><br><span class="line">This is a plain text file.</span><br><span class="line">New line</span><br></pre></td></tr></table></figure></li><li><p><strong>删除原文件，使用硬链接依旧可以显示</strong></p><p>因为<strong>磁盘块还有硬链接在引用，所以不会消失</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rm myfile  <span class="comment"># 删除原文件</span></span><br><span class="line">$ cat hard   <span class="comment"># 硬链接依旧可以显示</span></span><br><span class="line"></span><br><span class="line">This is a plain text file.</span><br><span class="line">New line</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>软链接</strong></p><p>建立一个<code>soft</code>软链接如下，可以看到二者的inode号是不一样的。</p><blockquote><p>软连接的inode ：保存真实的文件的<strong>绝对路径地址</strong>，找到软链接，还<strong>要根据inode号找到真实文件路径</strong>。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s myfile soft <span class="comment"># 建立软连接soft</span></span><br><span class="line">$ ls -li</span><br><span class="line"></span><br><span class="line">25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 myfile</span><br><span class="line">25869216 lrwxr-xr-x 1 unixzii staff 6 7 8 17:47 soft -&gt; myfile</span><br></pre></td></tr></table></figure><ul><li><p><strong>操作软链接更新文件，等价更新原文件</strong></p><p>因为软链接就是相当个快捷方式，当然更新原文件。</p></li><li><p><strong>删除原文件，使用软链接不会显示</strong></p><p>因为软件inode指向的绝对地址，已经不存在文件了，所以当然不存在文件了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rm myfile</span><br><span class="line">$ cat soft</span><br><span class="line"></span><br><span class="line">cat: soft: No such file or directory</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>软硬连接区别总结</strong></p><ol><li><p>**inode号不同。**硬链接原文件/链接文件公用一个inode号，说明他们是同一个文件，而软链接原文件/链接文件拥有不同的inode号，表明他们是两个不同的文件；</p></li><li><p><strong>链接数目不同。</strong> 软链接的链接数目不会增加；硬链接每多一个链接就会+1。</p></li><li><p>**文件大小不同。 **硬链接文件显示的大小是跟原文件是一样 ；软链接显示的大小与原文件就不同了，BBB大小是95B，而BBBsoft是3B，因为BBB共有3个字符。</p></li><li><p><strong>文件系统限制。</strong> 软链接没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。</p><blockquote><p><strong>建立软链接就是建立了一个新文件</strong>：当访问链接文件时，系统就会发现他是个链接文件，它读取链接文件找到真正要访问的文件。</p></blockquote></li></ol></li></ul><h3 id="3-查询日志的top10-IP">3. 查询日志的top10 IP?</h3><p>命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="built_in">log</span> | cut -d <span class="string">&#x27; &#x27;</span> -f 1 | sort | uniq -c | sort -nr | awk <span class="string">&#x27;&#123;print $0&#125;&#x27;</span> | head -n 10</span><br></pre></td></tr></table></figure><ol><li><p><code>cat *.log</code>  ：将文本内容打印到屏幕</p></li><li><p><code>cut</code>：截取指定IP那一列</p></li><li><p><code>sort </code>，按IP ASCII码排序：进行排序，默认是按照ascii码进行排序的</p></li><li><p><code>uniq -c  </code> ，统计重复的IP ：统计<strong>相邻的行</strong>的重复数量，结果是类似 <code>3 127.13.13.13</code> ，前面的数字代码重复的行数</p><p><code>sort|uniq -c</code>  统计重复的行数</p></li><li><p><code>sort -n</code>，再次排序 ：是按照数值进行由小到大进行排序， -r是表示逆序，-t是指定分割符，-k是执行按照第几列进行排序</p></li><li><p><code>awk</code> ，只显示IP：按照分割符将一行分割为多个列，第一列用1表示，第二列用​2表示，依次类推</p><p><code>awk -F&quot; &quot; '&#123;print $2&#125;</code>   ，表示用空格作为分隔符进行分割，打印出第2列</p></li><li><p><code>head -n ：</code>表示取前n个</p></li></ol><h2 id="2-2-Git">2.2 Git</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/96631135">讲git原理的的一篇不错文章</a></p></blockquote><h3 id="2-2-1-常问命令">2.2.1 常问命令</h3><h4 id="1-什么是Git？-是用什么语言编写的？">1.<strong>什么是Git？</strong> <strong>是用什么语言编写的？</strong></h4><ul><li>Git是一个 <u>分布式</u> <u>代码控制系统</u> ；</li><li>Git使用 C 语言编写：<u>使得 GIT 很快，C 语言减少运行时开销</u>来做到这一点。</li></ul><h4 id="2-如何在Git中创建存储库？">2. <strong>如何在Git中创建存储库？</strong></h4><ol><li>如果项目不存在，创建</li><li>然后运行 <code>git init</code> ，会在目录下创建一个 <code>.git</code> 目录</li></ol><h4 id="3-列举工作中常用的几个git命令？">3. <strong>列举工作中常用的几个git命令？</strong></h4><ul><li><code>git add</code> : 增加文件</li><li><code>git commit -m</code> ：提交文件</li><li><code>git status</code> ：拉取远程分支</li><li><code>git push</code> ：合并当前分支和主分支</li><li><code>git pull</code> OR <code>git fetch/git merge</code> ：拉取远程分支</li></ul><h4 id="4-讲讲Git-commit-基本参数？">4. <strong>讲讲Git commit 基本参数？</strong></h4><blockquote><p>参考：<a href="https://www.cnblogs.com/qianqiannian/p/6005628.html">https://www.cnblogs.com/qianqiannian/p/6005628.html</a></p></blockquote><ul><li><code>git commit -m “message”</code> ：简要说明这次提交的语句</li><li><code>git commit -a</code> ：即使没有经过 <code>git add</code> ，也可以将所有 <u>修改</u> 或 <u>删除</u> 的文件提交到本地仓库，<strong>但新建的文件不会提交</strong></li><li><code>git commit --amend</code> ：追加提交，它可以在<u>不增加一个新的commit-id</u> 的情况下将新修改的代码追加到前一次的commit-id中，</li></ul><h4 id="5-在Git中，你如何还原已经-push-并公开的提交？">5. <strong>在Git中，你如何还原已经 push 并公开的提交？</strong></h4><ul><li><p>删除或修复新提交中的错误文件，并将其<strong>覆盖</strong>推送到远程存储库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;commit message&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>创建一个新的提交，<strong>撤消</strong>在错误提交中所做的所有更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;name of bad commit&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-git-pull-和-git-fetch-有什么区别？">6. <strong>git pull 和 git fetch 有什么区别？</strong></h4><ul><li><p><code>git pull</code></p><p>取回远程主机某个分支的更新，<strong>再与本地的指定分支合并</strong> （可能要解决冲突）。</p></li><li><p><code>git fetch</code></p><p>从远程获取最新版本到本地，<strong>不会自动合并</strong> ，需要手动执行 <code>git merge</code></p></li></ul><h4 id="7-什么是-git-stash-你一般什么情况下会使用它？">7. <strong>什么是 git stash?你一般什么情况下会使用它？</strong></h4><blockquote><p>经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是<code>git stash</code>命令。储藏(stash)可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用</p></blockquote><ul><li><strong>使用情况：</strong> 当前分支还没处理完，不能去commit提交，但是要去处理一个紧急开发项目，使用 <code>git stash</code></li><li>处理完后<code>git stash pop</code> 继续处理工作</li></ul><h4 id="8-如果本次提交误操作，如何撤销？">8. <strong>如果本次提交误操作，如何撤销？</strong></h4><ul><li><p>**场景1：**改乱了（包括删除等）工作区某个文件的内容（<code>git add 之前</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure><p>丢弃之前所有的修改。</p></li><li><p>**场景2：**撤销提交到索引区的文件 （<code>git add 之后</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure><p>此时回到了场景1，然后再使用 <code>git checkout</code></p></li><li><p><strong>场景3：</strong> 撤销已经提交之后的文件（<code>git commit之后</code>）：</p><p>回退版本号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog  <span class="comment"># 查看版本</span></span><br><span class="line">$ git reset --hard  3928   <span class="comment"># 回退版本</span></span><br></pre></td></tr></table></figure></li><li><p><strong>场景4：</strong> 撤销已经push到远程分支之后的文件（<code>git push之后</code>）</p><ul><li><p>创建一个新的提交，<strong>撤消</strong>在错误提交中所做的所有更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;name of bad commit&gt;</span><br></pre></td></tr></table></figure></li><li><p>删除或修复新提交中的错误文件，并将其<strong>覆盖</strong>推送到远程存储库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;commit message&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="9-使用过git-merge和git-rebase吗？它们之间有什么区别？">9. <strong>使用过git merge和git rebase吗？它们之间有什么区别？</strong></h4><p>都是用来合并分支的，但是：</p><ul><li><p><code>git merge &lt;当前分支要合并的分支&gt;</code> ： 在当前分支合并&lt;指定要合并的分支&gt;，会自动在当前分支（下图为master）创建一个commit节点，保留了要合并的分支（下图为branch1）的提交记录</p><p><img src="https://i.loli.net/2021/05/02/oLOVlIs7yNazKnJ.png" alt="preview"></p></li><li><p><code>git rebase &lt;当前分支变基的基点分支&gt;</code> ：相当将当前分支（下图为branch1）的分支节点（5,6） 依次提交到基点分支（master）的4节点之后，保留了更干净的历史记录，没有生成行的commit 节点</p><p><img src="https://i.loli.net/2021/05/02/ebDoLAUMSd13QRI.png" alt="image-20210502231023075"></p></li></ul><h1>三、计算机网络</h1><h2 id="3-1-ISO-OSI模型-和-TCP-IP-模型">3.1 ISO/OSI模型  和 TCP/IP 模型</h2><h4 id="1-请你简要介绍一下TCP-IP-五层协议-和-ISO-OSI七层协议？">1. <strong>请你简要介绍一下TCP/IP 五层协议 和 ISO/OSI七层协议？</strong></h4><p><img src="https://uploadfiles.nowcoder.com/images/20190814/980266035_1565787665824_1ABB2DC3D76311944FFDBE9980FBAADD" alt="img"></p><ul><li><p><strong>应用层：<strong>为用户的</strong>应用程序</strong>（如：电子邮件、文件传输和仿真终端）<u><strong>*提供网络服务</strong></u>；</p></li><li><p><strong>表示层：</strong> 可以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取；</p></li><li><p><strong>会话层：</strong>  通过运输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求；</p></li><li><p><strong>运输层：</strong> 任务是为两台主机中<strong>进程之间的通信</strong>提供通用的<u><strong>*数据传输服务</strong></u>，传输的是<strong>报文段（tcp）/用户数据报（udp）</strong>；</p><blockquote><p>复用：多个应用层进程可同时使用下面运输层的服务。<br>分用：运输层把收到的信息分别交付上面应用层中的相应进程。</p></blockquote></li><li><p><strong>网络层：</strong> 为主机间<u><strong>*提供通信服务</strong></u>。在发送数据时，网络层把运输层的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为<strong>数据报</strong></p></li><li><p><strong>数据链路层（忘）：</strong> 两台主机通信，总是在<strong>一段一段的链路</strong>上传送的，这就需要需要专门的链路层的协议。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的<u><strong>*IP数据报组装成帧</strong></u>，在两个相邻结点间的链路上传送帧。每一帧包括数据和必要的控制信息。</p></li><li><p>**物理层：**主要作用是<u>传入比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0）</u>，定义物理设备标准（例如网线的接口类型、光线的接口类型、各种传输介质的传输速率）。</p></li></ul><h4 id="2-请你简要介绍一下各层的协议？">2. <strong>请你简要介绍一下各层的协议？</strong></h4><ul><li><p><strong>物理层</strong>：暂无</p></li><li><p><strong>（<u>快手</u>）数据链路层</strong>：数据链路层主要是负责传输数据，</p><ul><li><p><strong>PPP（点到点协议</strong>）：在<strong>点对点</strong>连接上传输多协议数据包提供了一个标准方法，PPP 最初设计是为<strong>两个对等节点</strong>之间的 IP <strong>流量传输</strong>提供一种封装协议。这种链路提供<strong>全双工</strong>操作，并按照顺序传递数据包。</p><blockquote><p>设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。</p></blockquote></li><li><p><strong>以太网（Ethernet)：</strong></p></li><li><p><strong>CSMA/CD 协议：</strong> 冲突检测的载波监听多路访问技术(载波监听多点接入/碰撞检测)。</p><blockquote><p>许多计算机以<strong>多点接入</strong>的方式连接<strong>在一根总线</strong>上，每个主机都必须不停地监听信道。发送前监听，如果忙则等待，如果空闲则发送。</p><p>若检测到信道有干扰信号，则表示产生了碰撞，于是就要停止发送数据，计算出退避等待时间，然后使用 CSMA 方法继续尝试发送。</p></blockquote></li></ul></li><li><p><strong>网络层：</strong> <a href="https://www.hhcycj.com/post/item/491.html">可参考</a></p><p><strong>IP</strong>：网络协议，非常重要的中间层协议，TCP和UDP必须基于IP工作</p><p><strong>ICMP</strong>：非常重要的中间层协议，用于在 <u>IP主机、路由器</u> 之间传递控制消息</p><p><strong>IGMP</strong>：网络组消息协议，用来在<u>IP主机</u>和与其**直接相邻的<u>组播路由器</u>**之间建立、维护组播组成员</p><p><strong>ARP</strong>：地址解析协议，建立<code>IP→MAC</code>地址映射表</p><p><strong>RARP</strong>：反向地址解析协议，某个网络设备的MAC物理地址转换为IP地址</p></li><li><p><strong>运输层：</strong></p><p>**TCP(Transmission Control Protocol)：**面向连接的，数据传输的单位是<u><strong>报文段</strong></u>，能够提供可靠的交付。</p><p><strong>UDP(User Datagram Protocol)</strong> ：无连接的，数据传输的单位是**<u>用户数据报</u>**，不保证提供可靠的交付，只能提供“尽最大努力交付”</p></li><li><p><strong>应用层：<strong>如支持万维网应用的</strong>HTTP</strong>协议，支持电子邮件的<strong>SMTP</strong>协议，支持文件传送的<strong>FTP</strong>协议，DNS，POP3，SNMP，Telnet等等。</p></li></ul><h5 id="2-1-RARP-工作原理？">2.1 RARP 工作原理？</h5><p>RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。</p><blockquote><p>网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。</p></blockquote><ol><li>主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包；</li><li><strong>RARP服务器</strong>收到了<strong>RARP请求数据包</strong>，<strong>为其分配IP地址</strong>，并将<strong>RARP回应发送</strong>给主机；</li><li>主机收到RARP回应后，就使用得到的IP地址进行通讯。</li></ol><h4 id="3-端口在哪一层？有效端口范围？">3. 端口在哪一层？有效端口范围？</h4><p>端口在<strong>传输层</strong>。传输层以下的包封装过程：</p><ul><li>数据报在传输层：加源端口号和目的端口号；</li><li>在网络层加上：源ip和目的ip ；</li><li>在数据链路层转化成：数据桢进行校验；</li><li>在物理层变成信号（电、光、等信号）发送出去。</li></ul><p>UDP和TCP报头使用<strong>两个字节存放端口号</strong>，端口一共有一共有<strong>65535</strong>个。</p><ul><li>知名端口号从0~1023，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口） ；</li><li>动态端口的范围是从1024~65535。</li></ul><h2 id="3-2-运输层">3.2 运输层</h2><h4 id="0-TCP报文头？UDP报文头？">0. TCP报文头？UDP报文头？</h4><blockquote><p>参考：<a href="http://st233.com/blog.php?id=30">IP、TCP、UDP报文头说明</a></p></blockquote><ul><li><p><strong>TCP报文头</strong></p><p><img src="https://i.loli.net/2021/06/11/RtnwTmysWBvVlPD.png" alt="img"></p><ul><li><p><strong>来源端口</strong>：向目标主机指明接入他的主机所使用的端口号 用于目标主机回应</p></li><li><p><strong>目标端口</strong>：指明要连接的目标主机的端口号</p><blockquote><p>从这也可以看书，端口占16bit，故范围是0~65535。</p></blockquote></li><li><p><strong>顺序号</strong>：<strong>数据包编号</strong>， 表明发送的数据包的顺序 。其值通常应该为<code>上次发送包中的顺序号+1</code> ，若该数据包是整个TCP连接中的第一个包(SYN包) 则该值随意(通常随机)</p></li><li><p><strong>确认号</strong>：通常该值是<code>接受到的顺序号+1</code> ，若该数据包是整个TCP连接中的第一个数据包(SYN包) 则该值随意(通常为0)</p></li><li><p><strong>首部长度</strong>：TCP头长度 。表明包好多少个32Bit 包括可选头(如果有) 值为TCP头大小除以4 ：</p><ul><li>如：没有可选头TCP头为20字节 则该值为5</li></ul></li><li><p><strong>标志位</strong>：</p></li><li><ul><li>紧急标志位(URG)：开启时表明此数据包处于紧急状态应该优先处理</li><li>确认标志位(ACK)：开启时表明确认号有效 否则忽略确认号</li><li>推送标志位(PSH)：开启时表明应该尽快交付给应用进程 而不必等到缓存区填满才推送</li><li>复位标志位(RST)：开启时表明TCP连接出现连接出现错误 数据包非法拒绝连接</li><li>同步标志位(SYN)：开启时表明一个连接的请求或者接受报文</li><li>终止标志位(FIN)：开启时表明释放一个连接</li></ul></li><li><p><strong>窗口大小</strong>：表示期望接受到的每个数据包字节数</p></li><li><p><strong>校验和</strong>：该值为TCP报文头括数据部分中每16Bit的二进制反码求和</p></li><li><p><strong>紧急指针</strong>：若指定该值 他应该是一个偏移量 该值加上顺序号表示紧急数据最后一个字节的顺序号</p></li><li><p><strong>可选字段</strong>：包含最大载荷与窗口比例等信息 注：若使用该字段则长度必须为32Bit的倍数 不足则填充0</p></li></ul></li><li><p><strong>UDP报文</strong></p><p><img src="https://i.loli.net/2021/06/11/Bfh3THSLgzZCUAu.png" alt="img"></p><ul><li><p><strong>来源端口</strong>：向目标主机指明接入他的主机所使用的端口号 用于目标主机回应</p></li><li><p><strong>目标端口</strong>：指明要连接的目标主机的端口号</p></li><li><p><strong>数据包长度</strong>：UDP头和数据总长度字节数</p></li><li><p><strong>检验和</strong>：该值为UDP报文头括数据部分中每16Bit的二进制反码求和</p></li><li><ul><li><strong>注：UDP检验和不是必须的</strong></li></ul></li></ul></li></ul><h4 id="1-请你说明一下，TCP协议的3次握手（进行连接）？">1. 请你说明一下，TCP协议的3次握手（进行连接）？</h4><blockquote><p>参考：<a href="https://juejin.cn/post/6844903834708344840">三次握手与四次挥手面试官想考我们什么？</a></p></blockquote><blockquote><p>TCP中，对<strong>确认ACK报文是不需要发送确认</strong>的 。</p></blockquote><ul><li><p><strong>简略过程</strong></p><blockquote><p>:warning: SYN 和ACK报文是一起发的！！</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a074b331fb0d85?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>1、第一次握手</strong>：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 <strong>ISN©</strong>。此时客户端处于 <strong>SYN_Send</strong> 状态。</p><p><strong>2、第二次握手</strong>：（:warning: <strong>SYN+ACK是在一个包里发的！（字节一面）</strong> ）服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 <strong>ISN(s)</strong>，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <strong>SYN_REVD</strong> 的状态。</p><p><strong>3、第三次握手</strong>：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <strong>establised</strong> 状态。</p><p>服务器收到 ACK 报文之后，也处于 <strong>establised 状态</strong>，此时，双方以建立起了链接。</p></li></ul><h5 id="1-1-ISN-（Initial-Sequence-Number）是固定的吗？">1.1 ISN （Initial Sequence Number）是固定的吗？</h5><ul><li><p><strong>ISN作用</strong></p><p>三次握手，其中一个重要功能是客户端和服务端交换 ISN，以便让对方知道<strong>接下来接收数据的时候如何按序列号组装数据</strong>。</p></li><li><p><strong>ISN为什么不固定</strong>（还是不太理解）</p><blockquote><p>ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个<strong>32比特</strong>的计数器，<strong>每4ms加1</strong> 。</p></blockquote><ul><li><strong>防止在网络中被延迟的分组在以后被重复传输</strong>，而导致某个连接的一端对它作错误的判断；</li><li>如果 ISN 是固定的，攻击者很<strong>容易猜出后续的确认号</strong>，因此 ISN 是动态生成的。</li></ul></li></ul><h4 id="2-为什么要三次握手？">2. <strong>为什么要三次握手？</strong></h4><p>1**.用来确定服务端和客户端的发送能力是否正常；**</p><ul><li>**第一次握手：**客户端发送网络包，服务端收到了。这样服务端就能得出结论：<u>客户端的发送能力、服务端的接收能力是正常的。</u></li><li><strong>第二次握手</strong>：服务端发包，客户端收到了。这样客户端就能得出结论：<u>服务端的接收、发送能力，客户端的接收、发送能力是正常的</u>。<strong>不过此时服务器并不能确认客户端的接收能力是否正常</strong>。</li><li>**第三次握手：**客户端发包，服务端收到了。这样服务端就能得出结论：<u>客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</u></li></ul><p>2.<strong>指定自己的初始化序列号，为后面的可靠传送做准备；</strong></p><ul><li>如果只有两次握手，那么客户端的起始序列号可以确认，<u>服务端的起始序列号</u>将得不到确认。</li></ul><ol start="3"><li><strong>如果是 https 协议的话，三次握手这个过程，还会进行数字<u>证书的验证以及加密密钥</u>的生成。</strong></li></ol><h5 id="2-1-三次握手可以携带数据吗？">2.1 三次握手可以携带数据吗？</h5><p><strong>第一次、第二次握手不可以携带数据 ，</strong> 第三次可以携带数据：</p><ul><li><strong>对于第一次握手</strong>，不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。<ul><li>如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，<strong>消耗服务器空间来接收数据</strong>；</li></ul></li><li><strong>对于第三次握手</strong>，客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，<strong>已经知道服务器的接收、发送能力正常</strong>，所以能携带数据。</li></ul><h4 id="3-请你说明一下，TCP协议的4次挥手（断开连接）？">3. <strong>请你说明一下，TCP协议的4次挥手（断开连接）？</strong></h4><blockquote><p><a href="https://www.zhihu.com/question/63264012">为什么不像三次握手一样执行三次即可？</a></p><p>因为第二次和第三次对于被动方来说，意义是不一样的。<br>第二次是为了让主动方闭嘴（不再发挥手请求），自己该干嘛还是干嘛（但是自己可能还有数据美处理完）。<br>第三次是为了表示“我的活儿干完了，可以结束了”。<br>通常server接收到挥手的时候，手里还有活儿没做完。</p></blockquote><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。</p><p><u>收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据</u>。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p>TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a074b855ad3850?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>（1）客户端A发送一个FIN，<u>报文中会指定一个序列号</u>M，用来关闭客户A到服务器B的数据传送，此时客户端处于<strong>FIN_WAIT1</strong>状态；</p><p>（2）服务器B收到这个FIN，它发回一个ACK，<u>确认序号为收到的序号M+1</u>。和SYN一样，一个FIN将占用一个序号，此时服务端处于 <strong>CLOSE_WAIT</strong>状态；</p><p>（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A和序列号N，此时服务端处于 <strong>LAST_ACK</strong> 的状态；</p><p>（4）客户端A发回ACK报文确认，并将确认序号设置为收到序N+1，此时客户端处于 <strong>TIME_WAIT</strong> 状态，需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 <strong>CLOSED</strong> 状态；服务端收到 ACK 报文之后，就处于关闭连接了，处于 <strong>CLOSED</strong> 状态。</p><h5 id="3-1-为什么TCP四次挥手要基于全双工，不基于半双工呢？基于半双工可以改为三次挥手吗？">3.1 为什么TCP四次挥手要基于全双工，不基于半双工呢？基于半双工可以改为三次挥手吗？</h5><blockquote><p>半双工：同时只能有一端发送消息 ； 全双工：两端都可以随机接受/发送。</p></blockquote><p>在四次挥手过程中，似乎C/S两端都是等待对方发送FIN/ACK，才会发送对应的ACK/FIN版本。同一时刻只有一方在发送消息，满足半双工。</p><p>但是，半双工模式效率会更低：比如C端（客户端）发送FIN报文请求关闭，但是S端（<strong>服务端</strong>）依旧<strong>可以同时发生数据</strong> ，这个时候效率更高。</p><h5 id="3-2（重点）-服务器出现大量close-wait的连接的原因是什么？有什么解决方法？">3.2（重点） 服务器出现大量close_wait的连接的原因是什么？有什么解决方法？</h5><p>close_wait状态是在，TCP四次挥手的时候<strong>服务器收到FIN，但是没有发送自己的FIN时出现的</strong>。服务器出现大量close_wait状态的原因有两种：</p><ul><li><strong>服务器内部业务处理占用了过多时间</strong>，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li><li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候<strong>子进程处理但父进程没有处理该信号</strong>，导致socket的引用不为0无法回收</li></ul><p>处理方法：</p><ul><li>停止应用程序</li><li>修改程序里的bug</li></ul><h4 id="4-为什么要有TIME-WAIT-状态？为什么等待是2MSL？">4. 为什么要有TIME_WAIT 状态？为什么等待是2MSL？</h4><ul><li><p><strong>要确保服务器是否已经收到了客户端最后的ACK 报文</strong>，如果没有收到的话，<u>服务器会重新发 FIN + ACK报文给客户端</u>，客户端再次收到 FIN + ACK 报文之后，就知道之前的 ACK 报文丢失了，然后<u>再次发送 ACK 报文。</u></p></li><li><p><strong>确保之前连接的一些数据不在滞留在网络中</strong>：确保已经失效连接请求报文段不会再出现在本连接中，<strong>客户端发完最后一个ACK报文段后</strong>，再经过<strong>2MSL</strong>可以使得本连接中所有的报文段都从网络中消失。客户端就可以放心地<strong>释放</strong>TCP占用的资源、端口号，连接任何服务器。</p><blockquote><p>如果<strong>客户端</strong>直接CLOSED，然后又再次向服务器<strong>发起一个新连接</strong>，有可能<strong>新、老连接的端口号一样</strong>的。假设新、老连接端口号一致，若老连接的一些数据仍滞留在网络中，这些滞留数据在新连接建立后才到达服务器，鉴于前后端口号一致，TCP协议就默认这些数据属于新连接，于是数据就这样乱成一锅粥了。</p></blockquote></li></ul><h5 id="4-1-为什么是2MSL">4.1 为什么是2MSL?</h5><p>MSL是报文在网络中最长生存时间，这是一个工程值(经验值)，不同的系统中可能不同 。</p><p>考虑最坏 情况，客户端A最后一次挥手发送给服务端B的ACK报文丢失了：</p><ol><li>ACK从最多经过1MSL会到达服务端，<strong>超过1MSL服务端会重发FIN</strong></li><li>服务端重发的FIN最多经过1MSL到达A</li></ol><p>所以为了确保，客户端能<strong>接收到服务端重发的FIN报文</strong>。</p><h4 id="5-【重点】请问TCP为什么要更可靠？哪种场景会有所应用？">5. 【重点】<strong>请问TCP为什么要更可靠？哪种场景会有所应用？</strong></h4><ol><li><p><strong>超时重传</strong>：当 TCP 发出⼀个报文段后，它启动⼀个定时器，等待⽬的端确认收到这个报⽂段。如果不能及时收到⼀个确认，将重发这个报⽂段；</p></li><li><p><strong>数据排序</strong>：TCP有专门的序列号<strong>ISN字段</strong>，可提供数据re-order；</p></li><li><p><strong>流量控制</strong>：滑动窗口和计时器的使用。TCP窗口中会指明双方能够<u>发送接收的最大数据量；</u></p><blockquote><p><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待对方确认。在收到确认后再发下⼀个分组。</p></blockquote></li><li><p><strong>拥塞控制</strong>：TCP的拥塞控制由4个核心算法组成。“慢启动”（Slow Start）、<u>“拥塞避免”</u>（Congestion avoidance）、“快重传 ”（Fast Retransmit）、“快恢复”（Fast Recovery）；</p></li><li><p><strong>校验和：</strong> TCP 将保持它⾸部和数据的检验和。这是⼀个端到端的检验和，⽬的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将<strong>丢弃这个报⽂段和不确认收到此报⽂段</strong>。</p></li></ol><p>【<strong>应用场景</strong>】</p><p><u>当对网络通讯质量有要求的时候，</u>比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用</p><ul><li>比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议</li></ul><h5 id="5-1-超时重传机制原理？">5.1 超时重传机制原理？</h5><p>基本原理：在发送一个数据之后，就开启一个<strong>定时器</strong>，若是在这个时间内<strong>没有收到发送数据的ACK确认报文</strong>，则对该报文进行<strong>重传</strong>，在达到一定次数还没有成功时放弃并发送一个复位信号。</p><p>TCP中有四种计时器（Timer），分别为：</p><ol><li><p><strong>重传计时器</strong>：在<strong>滑动窗口协议</strong>中，接受窗口会在<strong>连续收到的包序列（连续ARQ）<strong>中的</strong>最后一个包</strong>向接收端发送一个ACK。当网络拥堵的时候，发送端的数据包和接收端的ACK包都有可能丢失。TCP为了保证数据可靠传输，就规定在<strong>重传的“时间片”<strong>到了以后，如果还没有收到对方的ACK，就</strong>重发此包</strong>，以避免陷入无限等待中。</p></li><li><p><strong>坚持计时器</strong>：在<strong>滑动窗口协议</strong>中，当发送TCP收到<strong>窗口大小为0</strong>的确认ACK时，就坚持启动计时器。当坚持计时器期限到时，发送TCP就发送一个特殊的报文段，叫做探测报文。这个报文段只有一个字节的数据。他有一个序号，但他的序号永远不需要确认；甚至在计算机对其他部分的数据的确认时该序号也被忽略。探测报文段提醒接受TCP：确认已丢失，必须重传。</p></li><li><p><strong>保活计时器</strong>：保活计时器使用在某些实现中，用来<strong>防止在两个TCP之间的连接出现长时间的空闲</strong>。假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远的处于打开状态。</p><p>通常设置为两小时。若服务器过了两小时还没有收到客户的信息，他就发送探测报文段。若<strong>发送了10个探测报文段</strong>（每一个像个75秒）还没有响应，就假定客户除了故障，因而就终止了该连接。</p></li><li><p><strong>时间等待计时器</strong>：四次挥收后time waiter状态中使用。</p></li></ol><h5 id="5-2-介绍一下ARQ协议-？">5.2 介绍一下ARQ协议 ？</h5><p>⾃动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之⼀。它通过使用<strong>确认和超时</strong>这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。</p><p>ARQ包括<strong>停⽌等待ARQ协议</strong>和<strong>连续ARQ协议</strong>。</p><ul><li><strong>停⽌等待ARQ协议。</strong> 停⽌等待协议是为了实现可靠传输的，它的基本原理就是每发完⼀个<strong>分组</strong>就停⽌发送，等待对方确认（回复ACK）。如果过了⼀段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下⼀个分组；在停⽌等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。<ul><li>**优点：**简单</li><li>**缺点：**信道利用低，等待时间长</li></ul></li><li><strong>连续ARQ协议。<strong>连续 ARQ 协议可提高信道利用率。发送方维持⼀</strong>个发送窗口</strong>，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方⼀般采用<strong>累计确认</strong>，对按序到达的<strong>最后⼀个分组发送确</strong>认，表明到这个分组为⽌的所有分组都已经正确收到了。<ul><li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li><li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 ⽐如：发送方发送了 5条 消息，<strong>中间第三条丢失（3号）</strong>，这时接收方<strong>只能对前两个发送确认</strong>。发送方无法知道后三个分组的下落，而只好把后<strong>三个全部重传</strong>⼀次。这也叫 <strong>Go-Back-N</strong>（回退 N），表示需要退回来重传已经发送过的N 个消息。</li></ul></li></ul><h5 id="5-2-介绍一下连续ARQ协议滑动窗口和流量控制？">5.2 介绍一下连续ARQ协议滑动窗口和流量控制？</h5><p>TCP 利用滑动窗口实现流量控制。流量控制是为了<strong>控制发送方发送速率，保证接收方来得及接收</strong>。 接收方发送的确认报⽂中的窗口字段可以用来控制<strong>发送方窗口</strong>大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h5 id="5-3-介绍一下拥塞控制？">5.3 介绍一下拥塞控制？</h5><p>为了进行拥塞控制，TCP 发送方要维持⼀个 <u>拥塞窗口(cwnd)</u> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让⾃⼰的<strong>发送窗口 == 取为拥塞窗口和接收方的接受窗口中较小的⼀个</strong>。</p><p>TCP的拥塞控制采用了四种算法：</p><ul><li><p><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果⽴即把大量数据字节注⼊到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测⼀下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，<strong>每经过⼀个传播轮次RTT，cwnd加倍</strong>；</p></li><li><p><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗⼝cwnd缓慢增大，即每经过<strong>⼀个往返时间RTT，就把发送放的cwnd加1</strong>；</p></li><li><p><strong>快重传/快恢复：</strong></p><blockquote><p>区分快重传，连续ARQ中间丢失是Go back n。</p></blockquote><p>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是⼀种拥塞控制算法，<u>它能快速恢复丢失的数据包。</u>如果<strong>接收机</strong>接收到⼀个**【不按顺序】的数据段，它会⽴即给发送机发送⼀个重复确认（而不是等到自己发送数据时才捎带确认）。如果发送机接收到三个重复确认**，它会假定确认指出的数据段丢失了，并⽴即重传这些丢失的数据段（<strong>而不必继续等待为该报文段设置的重传计时器的超时</strong>）。</p><p><img src="https://img-blog.csdn.net/20170823152124856?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5NTMxMzU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p></li></ul><h5 id="5-4-如何区分流量控制和拥塞控制？">5.4 如何区分流量控制和拥塞控制？</h5><ul><li><strong>流量控制属于通信双方协商，拥塞控制涉及通信链路全局；</strong></li><li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，<strong>接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定</strong>；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</li></ul><h4 id="6-如何提高客户端并发数？">6. <strong>如何提高客户端并发数？</strong></h4><p>客户端建立的tcp数量受限于最大文件句柄数，一个连接就会建一个文件句柄，在linux 上默认是<strong>1024</strong>。</p><ul><li>使用<code>ulimit</code> 可以修改最大进程数（<strong>最大为65535</strong>）</li></ul><h4 id="7-说说HTTP、TCP、Socket-的关系是什么？">7. <strong>说说HTTP、TCP</strong>、Socket 的关系是什么？</h4><ul><li><strong>TCP/IP</strong> 代表传输控制协议/网际协议，指的是一系列协议族；</li><li><strong>HTTP</strong> 本身就是一个协议，是从 <u>Web 服务器和本地浏览器</u>的超文本传送协议；</li><li><strong>Socket</strong> 是 TCP/IP 网络的 <strong>API</strong> ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</li></ul><h4 id="8-什么是半连接队列？泛洪攻击（DDos攻击的一种），以及解决策略-？">8. 什么是半连接队列？<strong>泛洪攻击（DDos攻击的一种），以及解决策略</strong> ？</h4><ul><li><p><strong>半连接队列</strong></p><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个<strong>队列</strong>里，我们把这种队列称之为<strong>半连接队列</strong>。</p><blockquote><p>已经完成三次握手，建立起连接的就会放在<strong>全连接队列</strong>中。如果队列满了就有可能会出现丢包现象。</p></blockquote></li><li><p><strong>泛洪攻击</strong></p><p>在 TCP 的三次握手机制的第一步中，客户端会向服务器发送 SYN 报文段。</p><ol><li>服务器接收到 SYN 报文段后会为该 <u>TCP分配<strong>缓存和变量</strong></u>，如果<u>攻击分子<strong>伪造大量不存在的IP地址</strong>，大量地往服务器发送 SYN 报文段</u>，服务器的连接资源终将被耗尽，导致<strong>内存溢出</strong>无法继续服务。</li><li>当服务端接收到 SYN 后进入 SYN-RECV 状态，此时的连接称为<strong>半连接</strong>，同时会被服务端写入一个 <strong>半连接队列</strong>。<br>想象一下，如果攻击者在短时间内不断的向服务端发送大量的 SYN 包而不响应，那么服务器的 <strong>半连接队列很快会被写满</strong>，从而导致无法工作。</li></ol></li><li><p><strong>解决策略</strong></p><p><strong>设置验证机制：<strong>当服务器接受到 SYN 报文段时，<strong>不直接为该 TCP 分配资源</strong>，而只是打开一个<u>半开的套接字</u>。接着会使用 SYN 报文段的<u>源 Id，目的 Id，端口号</u>以及只有服务器自己知道的一个<u>秘密函数生成一个 cookie，并</strong>把 cookie作为序列号响应</strong></u> 给客户端。</p><p>如果客户端是正常建立连接，将会返回一个确认字段为 <strong>cookie + 1 的报文段</strong>。接下来服务器会根据确认报文的源 Id，目的 Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1 等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源 。</p><p><strong>防火墙过滤：</strong> 暂不了解具体</p></li></ul><h4 id="9-为什么DNS（域名解析）用UDP，而区域传送用TCP">9. <strong>为什么DNS（域名解析）用UDP，而区域传送用TCP?</strong></h4><ul><li>**DNS用UDP：**客户端向DNS服务器查询域名，一<u>般返回的内容都不超过512字节，用UDP传输即可</u>。不用经过TCP三次握手，这样<u>DNS服务器负载更低，响应更快</u>。</li><li><strong>区域传送用TCP：</strong> TCP协议可靠性好，<u>TCP协议传输的内容大，而UDP最大只能传512字节</u>。</li></ul><h4 id="10-说一下-TCP-粘包是怎么产生的？怎么解决粘包？">10. <strong>说一下 TCP 粘包是怎么产生的？怎么解决粘包？</strong></h4><p><strong>TCP粘包</strong></p><p><strong>TCP粘包</strong>是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><p>客户端要发送原信息是A和B两个数据包，服务端接收到之后，可能出现如下情况：</p><ul><li><strong>正常情况</strong>：读取到了A和B两个数据包；</li><li><strong>粘包</strong>：A和B两个数据包一起读取了；</li><li><strong>拆包</strong>：读取了A数据包的一部分，A的另一部分和B数据包一起读取了。</li></ul><p><strong>TCP粘包原因</strong></p><ul><li><strong>【发送方】TCP默认使用Nagle算法。<strong>客户端通过socket给服务端发送数据，为了传输更有效率，会将</strong>多次间隔较小的且数据量小的数据</strong>，通过<strong>nagle</strong>算法，合并成一个大的数据块，然后进行封包。这样做提高了效率，缺点就是你发送到服务端的数据，服务端不知道是不是完整的，不知道哪几小块数据拼起来才是原来的数据；</li><li><strong>【接收方】来不及接收缓存区的包</strong>，导致多个包接收；</li><li>TCP<strong>连接复用</strong>造成的粘包问题；</li><li>流量控制，<strong>拥塞控制</strong>也可能导致粘包。</li></ul><p><strong>解决粘包</strong></p><p>解决问题的关键在于如何给<strong>每个数据包添加边界信息</strong>：</p><ol><li><strong>Nagle算法</strong>问题导致的，需要结合应用场景适当关闭该算法；</li><li><strong>发送端给每个数据包添加包 <u>首部</u> <strong>，首部中应该至少包含数据包的</strong>长度</strong>，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了；</li><li><strong>数据包之间设置边界</strong>，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开 ；</li><li><strong>发送端将每个数据包封装为固定长度</strong>（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li></ol><h4 id="11-TCP-UDP的区别？">11. TCP, UDP的区别？</h4><ul><li>UDP 在<strong>传送数据之前不需要先建立连接</strong>。远地主机在收到 UDP 报⽂后，不需要给出任何确认。虽然UDP 不提供可靠交付，但在某些情况下 UDP 确是⼀种最有效的⼯作方式（⼀般用于即时通信）<ul><li>⽐如： <u>QQ 语⾳、 QQ 视频 、直播</u>等等</li></ul></li><li>TCP <strong>提供面向连接的服务</strong>。在传送数据之前必须先建⽴连接，数据传送结束后要释放连接。 TCP 不提供⼴播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握⼿来建⽴连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这⼀难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的⾸部增大很多，还要占用许多处理机资源。<ul><li>TCP ⼀般用于<u>⽂件传输、发送和接收邮件、远程登录</u>等场景。</li></ul></li><li><strong>数据包：</strong> TCP是<strong>报文段</strong>，UDP是<strong>用户数据报</strong>。</li><li><strong>应用场景</strong> ： TCP用于一些需要可靠传输的场景； UDP则应用一些即时通信场景，不需要可靠传输的场景。</li><li>**长度：**UDP在DNS最长只能是512字节，TCP会更长。</li></ul><h2 id="3-3-网络层">3.3 网络层</h2><h4 id="1-请简单解释一下，ARP协议和ARP攻击">1. <strong>请简单解释一下，ARP协议和ARP攻击?</strong></h4><ul><li>ARP协议：地址解析协议，建立<code>IP/MAC</code>地址映射表</li><li>ARP攻击：</li></ul><h4 id="2-什么是ICMP协议，它的作用是什么？">2. <strong>什么是ICMP协议，它的作用是什么？</strong></h4><p>用于在**<u>IP主机、路由器**之间传递控制消息。</u></p><blockquote><p>控制消息是指：<strong>网络通不通、主机是否可达、路由是否可用</strong>等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p></blockquote><h4 id="3-请你讲一下路由器和交换机的区别？">3. <strong>请你讲一下路由器和交换机的区别？</strong></h4><ol><li><p>（忘）<strong>动态IP：</strong><u>路由器可以给你的局域网自动分配IP</u>，虚拟拨号，就像一个交通警察，指挥着你的电脑该往哪走，你自己不用操心那么多了。<u>交换机只是用来分配网络数据的</u>。</p><p><u>路由器可以把一个IP分配给很多个主机使用，这些主机对外只表现出一个IP</u>。交换机可以把很多主机连起来，这些主机对外各有各的IP。</p></li><li><p><strong>寻址方式：<strong>路由器在</strong>网络层</strong>，<u>路由器根据IP地址寻址</u>，路由器可以处理TCP/IP协议，交换机不可以；交换机在<strong>中继层</strong>，<u>交换机根据MAC地址</u>寻址。</p></li><li><p>**防火墙：**路由器提供防火墙的服务，交换机不能提供该功能。集线器、交换机都是做端口扩展的，就是扩大局域网(通常都是以太网)的接入点，也就是能让局域网可以连进来更多的电脑。路由器是用来做网间连接，也就是用来连接不同的网络。</p></li></ol><h4 id="4-请解释ping命令过程？">4. <strong>请解释<code>ping</code>命令过程？</strong></h4><ol><li>域名在DNS服务器查找IP地址；</li><li>通过Ping程序发送<strong>ICMP包；</strong></li><li>同一网段的情况下，调用IP层的<strong>ARP协议</strong>请求<strong>广播</strong>（不同网段的情况下，交给路由器处理），<strong>查找目标主机的MAC地址</strong>；</li><li>目标主机ARP协议收到请求后，将本机<strong>MAC地址填充</strong>并<strong>发送ARP应答</strong>回到请求发送方；</li><li>请求发送方发送<strong>ICMP数据</strong>到目标主机；</li><li>（:triangular_flag_on_post:*1）目标主机<strong>响应ICMP包</strong>；</li><li>请求主机收到目标主机的<strong>ICMP响应包</strong>。</li></ol><h4 id="5-（补充介绍）介绍一下IPV6？一共多少位？">5. （补充介绍）介绍一下IPV6？一共多少位？</h4><p><img src="https://i.loli.net/2021/05/17/i5Nz6lF9RXYsShw.png" alt="IPv6 协议基础_果子哥丶的博客-CSDN博客"></p><p>源IP和目的IP地址都是，128（4*32）位（图中标识不清晰）！</p><h4 id="6-介绍一下IP地址分类？C类哪些是保留地址？网络号全-0-全-1-，主机号全-0-全1-分别什么含义？">6. 介绍一下IP地址分类？C类哪些是保留地址？网络号全 0 全 1   ，主机号全 0 全1 分别什么含义？</h4><ul><li><p><strong>IP地址分类</strong></p><p><code>IP地址 == &#123;&lt;网络号&gt;，&lt;主机号&gt;&#125;</code></p><p><img src="https://i.loli.net/2021/05/17/ZINJCj9l8WM7qhf.jpg" alt="img"></p><ul><li><p><strong>A类：</strong> 第1位固定为0，网络号只有7位 。0（0000 0000）的IP地址是<strong>保留地址</strong>，意思是“本网络” ； 127（0111 1111）的IP地址也是<strong>保留地址</strong>，作为本地环回软件测试 。</p><blockquote><p>特别的，<strong>主机号全1</strong>的是<a href="https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80">广播地址</a>，它代表了网络全部的<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA">主机</a>。</p></blockquote></li><li><p><strong>B类：</strong> 第1、2位固定为10，网络号有14位可以使用 。</p><blockquote><p>B类地址网络号为128.0（1000 000  0000 0000）的IP地址是不指派的，所以可指派的网络号需要减一。</p></blockquote></li><li><p><strong>C类：</strong> 第1、2、3位固定为110，网络号有21位可以使用 。</p><blockquote><p>（快手问）C类IP地址包含<strong>私有C类地址</strong>，范围从192.0.0.0 到223.255.255.255，其中私有C类地址范围从<strong>192.168.0.0 到192.168.255.255。</strong></p></blockquote></li></ul></li><li><p><strong>全0或者全1的含义</strong></p><ul><li><p><strong>网络号全0：</strong>（1）如果主机号也为全0，那么此类ip地址可以当源端但不可以做目的端 （2）如果主机号不全为0，那么此类ip地址的使用和（1)相同，只是它代表的是网络上特定的主机</p></li><li><p><strong>网络号全1：<strong>全1的网络号和</strong>任意的主机号</strong>组合当做<strong>回环地址</strong>来使用。</p><blockquote><p>例如：127（0111 1111）的IP地址</p></blockquote></li><li><p><strong>主机号全0：</strong> 全为0，所得到的地址就是192.168.100.0，它是一个网络地址，代表的是一个<strong>网段</strong>；</p></li><li><p><strong>主机号全1：</strong> 机号全1 代表的是<strong>广播地址</strong>，广播地址是不可以做源端的，但是可以做目的端。</p></li></ul></li></ul><h2 id="3-4-应用层">3.4 应用层</h2><h4 id="1-请你谈谈DNS的寻址过程？">1. <strong>请你谈谈DNS的寻址过程？</strong></h4><p>（1）检查<strong>浏览器缓存、检查本地hosts文</strong>件：是否有这个网址的映射，如果有，就调用这个IP地址映射，解析完成。</p><p>（2）如果没有，则查找<strong>本地DNS解析器缓存</strong>：是否有这个网址的映射，如果有，返回映射，解析完成。</p><blockquote><p><strong>本地dns服务器一般都是你的网络接入服务器商提供</strong>，比如中国电信，中国移动等。</p></blockquote><p>（3）如果没有，则查找填写或分配的<strong>首选DNS服务器</strong>：称为本地DNS服务器。服务器接收到查询时：</p><ul><li><p>如果要查询的域名包含在本地配置区域资源中，返回解析结果，查询结束，此解析具有权威性。</p></li><li><p>如果要查询的域名不由本地DNS服务器区域解析，但服务器缓存了此网址的映射关系，返回解析结果，查询结束，此解析不具有权威性。</p></li></ul><p>（4）如果本地DNS服务器也失效：</p><ul><li>如果未采用<u>转发模式</u>（<strong>迭代</strong>，从上至下）（1）<strong>本地DNS服务器</strong>就把<strong>请求发至13台根DNS</strong>，根DNS服务器收到请求后，会判断这个域名（<a href="http://xn--bvs.com">如.com</a>）是谁来授权管理，<u>并返回一个负责该顶级域名服务器的IP</u>，（2）本地DNS服务器收到顶级域名服务器IP信息后，继续向该<strong>顶级域名</strong>服务器IP发送请求，（3）该服务器如果无法解析，则会找到负责这个域名的下一级DNS服务器（如http://baidu.com）的IP给本地DNS服务器，循环往复直至查询到映射，（4）将解析结果返回**<u>本地DNS服务器</u>**，<strong>再由本地DNS服务器</strong>返回解析结果，查询完成。</li><li>如果采用<u>转发模式</u>（<strong>递归</strong>，从下至上）（1）则此DNS服务器就会把请求转<strong>发至上一级DNS服务器</strong>，（2）如果上一级DNS服务器不能解析，则继续向上请求，（3）最终将解析结果依次<u>返回本地DNS服务器</u>，本地DNS服务器再返回给客户机，查询完成。</li></ul><h5 id="1-1-怎么获取13台根服务器？">1.1 怎么获取13台根服务器？</h5><p>ping -R ? 抓包？</p><h5 id="1-2-解释一下DNS劫持和DNS污染？">1.2 <strong>解释一下DNS劫持和DNS污染？</strong></h5><blockquote><p>参考：<a href="https://juejin.cn/post/6844903991764058126">什么是http劫持 ? </a></p></blockquote><p><strong>一、DNS劫持</strong></p><p>DNS劫持某些手段取得<strong>某域名的解析记录控制权</strong>，进而修改此域名的解析结果，返回给用户一个错误的查询结果。</p><ul><li><p><strong>劫持过程</strong></p><ol><li><p>客户端发起域名请求到DNS解析服务器（一般是LocalDNS），<u>但此时DNS解析服务器被攻击篡改</u>；</p></li><li><p>被攻击篡改后的DNS解析服务器将请求转发给虚假服务器；</p><blockquote><p>DNS查询没有任何认证机制且基于UDP不可靠连接，因此很容易被篡改。</p></blockquote></li><li><p>虚假服务器返回<u>响应虚假信息</u>给被攻击篡改后的DNS解析服务器（也可能直接不响应）；</p></li></ol></li><li><p><strong>解决办法</strong></p><p>DNS劫持的本质是<strong>运营商的DNS解析服务器被攻击篡改</strong></p><ul><li>使用国外免费公用的DNS服务器解决。例如OpenDNS（208.67.222.222）或GoogleDNS（8.8.8.8）</li><li>直接使用ip进行访问</li></ul></li></ul><p><strong>二、DNS污染</strong></p><p>DNS污染是一种让一般用户由于<strong>得到虚假目标主机IP</strong>而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。因为是不是<u>劫持单个DNS服务器，而是监听所有的，所以个人比较难防范。</u></p><ul><li><p><strong>污染原理</strong></p><ol><li><p>通过对UDP端口53上的<strong>DNS查询进行入侵检测</strong>；</p><blockquote><p>由于通常的DNS查询没有任何认证机制，而且DNS查询通常基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改。</p></blockquote></li><li><p>一经发现与关键词相匹配的请求则<u><strong>立即伪装成目标域名的解析服务器</strong></u>（NS，Name Server）给查询者返回虚假结果。</p></li></ol></li><li><p><strong>解决办法</strong></p><ol><li>VPN代理或者域名远程解析的方法解决</li><li>通过修改Hosts，手动设置<u>域名正确的IP地址</u></li></ol></li></ul><h4 id="2-Forward-和-Redirect-的区别？">2. <strong>Forward</strong> <strong>和</strong> <strong>Redirect</strong> <strong>的区别？</strong></h4><ul><li><p><strong>浏览器 URL 地址</strong>：Forward 是服务器<u>内部的重定向</u>，服务器<strong>内部请求某个 servlet</strong>，然后获取响应的内容，<strong>浏览器的 URL 地址不会变化</strong>；Redirect 是客户端请求服务器，然后服务器给客户端返回了一个 <strong>302</strong> 状态码和<strong>新的 location</strong>，客户端<u><strong>重新发起 HTTP 请求</strong></u>，服务器给客户端响<u>应 location 对应的 URL 地址，</u>浏览器的 <strong>URL 地址发生了变化</strong>。</p></li><li><p><strong>数据的共享</strong>：Forward 是服务器内部的重定向，request 在整个重定向过程中是不变的，<strong>request 中的信息在 servlet 间是共享</strong>的。Redirect 发起了<strong>两次 HTTP 请求</strong>分别使用<strong>不同的request</strong>。</p></li><li><p><strong>请求的次数</strong>：Forward 只有一次请求；Redirect 有两次请求。</p></li></ul><h4 id="3-请你简单讲解一下，负载均衡反向代理模式的优点、缺点？">3. <strong>请你简单讲解一下，负载均衡反向代理模式的优点、缺点？</strong></h4><blockquote><p>联系实际：<a href="https://server.zol.com.cn/633/6339623_all.html">正反向代理、科学上网、VPN之间的关系</a> 和<a href="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">翻墙基本原理（看他的其他文章补充）</a></p></blockquote><p>【基本介绍】</p><ol><li><p><strong>反向代理</strong>（Reverse Proxy）：方式是指<u>以代理服务器来接受internet上的连接请求</u>，然后将请求转发给内部网络上的服务器，并将从<strong>服务器上得到的结果返回给internet上请求连接的客户端</strong>，此时代理服务器对外就表现为一个服务器；</p><ul><li><p><strong>优点：</strong> 网络络外部用户不能直接访问真实的服务器，具备额外的安全性</p></li><li><p><strong>缺点：</strong> 反向代理是处于OSI参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反向代理服务器；限制了应用范围；</p><p><u><strong>针对每一次代理，代理服务器就必须打开两个连接</strong></u>，一个对外，一个对内，因此在并发连接请求数量非常大的时候，<strong>代理服务器的负载也就非常大了</strong>，在最后代理服务器本身会成为服务的瓶颈。</p></li></ul></li><li><p><strong>反向代理负载均衡技术：<strong>是把将来自internet上的连接请求以反向代理的方式动态地</strong>转发</strong>给内部网络上的<strong>多台服务器</strong>进行处理，从而达到负载均衡的目的。</p><ul><li>**实现：**apache mod_proxy、netscape proxy等，也可以在高速缓存器、负载均衡器等硬件设备上实现。</li><li>**优点：**可以将优化的 <u>负载均衡策略和代理服务器的高速缓存技术</u>结合在一起，提升静态网页的访问速度，提供有益的性能</li><li><strong>缺点：</strong></li></ul></li></ol><h5 id="3-1-请解释下负载均衡的相关算法？">3.1 请解释下负载均衡的相关算法？</h5><p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。</p><ul><li>给配置高、负载低的机器配置更高的权重，让其处理更多的请求；</li><li>给配置低、负载高的机器分配较低的权重，降低系统负载。</li></ul><p>下面是几种比较相关的算法。</p><ul><li><p><strong>加权轮询算法</strong></p><blockquote><p>参考：<a href="https://www.fanhaobai.com/2018/11/load-balance-round-robin.html">加权轮询算法</a></p></blockquote><ul><li><p>基本定义</p><ol><li>假设有 N 台实例 S = {S1, S2, …, Sn}，权重 W = {W1, W2, …, Wn}</li><li>currentPos 表示当前选择的实例 ID，初始化为 -1；</li><li>currentWeight 表示当前权重，初始值为 max(S)；</li><li>max(S) 表示 N 台实例的最大权重值，gcd(S) 表示 N 台实例权重的最大公约数。</li></ol></li><li><p>算法过程</p><ol><li>从上一次调度实例起，<strong>遍历后面</strong>的每个实例；</li><li>若所有实例已被遍历过一次，则减小 currentWeight 为 currentWeight - gcd(S)，并从头开始遍历；若 currentWeight 小于等于 0，则重置为 max(S)；</li><li><strong>直到</strong> 遍历的实例的权重 &gt;= currentWeight 时结束，<strong>此时实例为需调度的实例</strong>；</li><li>每次调度重复步骤 1、2、3；</li></ol></li><li><p>算法实例</p><p><img src="https://i.loli.net/2021/05/30/YCVDN4miMvPy7sJ.png" alt="image-20210529232315965"></p><p>例如，上述 4 个服务，最大权重 max(S) 为 4，最大公约数 gcd(S) 为 1。其调度过程如下：</p><p><img src="https://i.loli.net/2021/05/30/7A4s6i3opra8LWR.png" alt="image-20210529232350799"></p></li><li><p>算法优缺点</p><ul><li><p><strong>优点：</strong> 相比 <u>简单轮询</u> 方式，通过权重进行分配，更加均匀</p></li><li><p>**缺点：**如下一个极端情况</p><blockquote><p>服务实例 S = {a, b, c}，权重 W = {5, 1, 1}，使用加权轮询调度生成的实例序列为 {a, a, a, a, a, b, c}，那么就会存在连续 5 个请求都被调度到实例 a。</p></blockquote><p>关于这点，可以采用  <a href="https://www.fanhaobai.com/2018/11/load-balance-round-robin.html#">平滑加权轮询</a> 调度算法 。</p></li></ul></li></ul></li><li><p><strong>一致性哈希算法</strong></p><p>负载均衡算法中的哈希算法，就是根据某个值生成一个哈希值，然后对应到某台服务器上去，即<strong>哈希环</strong>。</p><p><img src="https://i.loli.net/2021/05/30/fAa2jzXxGZ7lVq1.png" alt="image-20210529232953082"></p><p>但是可能出现一种，<strong>哈希倾斜</strong>的情况：A负责的区域太大，B，C负责的小。这个时候采用虚拟节点去解决，这里不表。</p></li></ul><h5 id="3-2-DNS-负载均衡是什么策略？">3.2 DNS 负载均衡是什么策略？</h5><blockquote><p>参考：<a href=""></a></p></blockquote><ul><li><strong>原理：</strong> 还是不太明白，DNS递归查询本身就是个负载均衡策略吧？多台服务器满足同一个查询服务？</li></ul><h4 id="4-请说明一下http和https的区别？">4. <strong>请说明一下http和https的区别？</strong></h4><ol><li>https协议要申请证书到ca，需要一定<u>经济成本</u>；</li><li>http是明文传输，https是加密的安全传输；</li><li>（:triangular_flag_on_post:*1）连接的端口不一样，http是<strong>80</strong>，https是<strong>443</strong>；</li><li>http连接很简单，没有状态；</li><li>https是ssl加密的传输，身份认证的网络协议，相对http明文传输比较安全。</li></ol><h5 id="4-1-讲一讲http的请求报文和响应报文？协议？">4.1 讲一讲http的请求报文和响应报文？协议？</h5><ul><li><p><strong>请求报文和协议</strong></p><p>一个HTTP请求报文由<strong>请求行（request line）</strong>、<strong>请求头部（header）</strong>、<strong>空行</strong>和<strong>请求数据</strong>4个部分组成，下图给出了请求报文的一般格式。</p><p><img src="https://i.loli.net/2021/05/17/uxX1gbcnhTsS9td.png" alt="img"></p><ul><li><p><strong>请求行</strong> ：由请求方法字段、URL字段和HTTP协议版本字段3个字段组成。</p><blockquote><p><strong>HTTP协议</strong> :  的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</p></blockquote></li><li><p><strong>请求头部：</strong> 请求头部由<strong>关键字/值</strong>对组成，每行一对，关键字和值用英文冒号“:”分隔 。 请求头部<strong>通知服务器有关于客户端请求的信息</strong>。</p><blockquote><p>User-Agent：产生请求的浏览器类型。</p><p>Accept：客户端可识别的内容类型列表。</p><p><strong>Host</strong>：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</p></blockquote></li><li><p><strong>请求数据 :</strong> 请求数据<strong>不在GET方法中使用，而是在POST方法</strong>中使用。POST方法适用于需要客户填写表单的场合。</p></li></ul></li><li><p><strong>响应报文和协议</strong></p><p>HTTP响应也由四个部分组成，分别是：<strong>状态行、响应头、空格、响应数据</strong>。</p><p><img src="https://i.loli.net/2021/05/17/QNIRoY5f7jk6sHv.jpg" alt="img"></p><ul><li><strong>状态行</strong> ： 状态行（status line）通过提供一个状态码来说明所请求的资源情况。如<strong>404</strong>等</li></ul></li></ul><h5 id="4-2-一个TCP连接中多个HTTP请求发生可以【同时】一起发生吗？">4.2  一个TCP连接中多个HTTP请求发生可以【同时】一起发生吗？</h5><ul><li><strong>HTTP/1.1单个 TCP 连接在同一时刻只能处理一个请求</strong>。意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠；</li><li><strong>Pipelining 技术 &amp; Multiplexing。</strong> Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行；</li></ul><blockquote><p>那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？</p></blockquote><ul><li>维持和服务器已经建立的 TCP 连接，在同一连接上<strong>顺序处理多个请求</strong>；</li><li><strong>和服务器建立多个 TCP 连接</strong>。</li></ul><h4 id="5-请说明一下http1-0-和https1-1-区别？">5. <strong>请说明一下http1.0 和https1.1 区别？</strong></h4><ul><li><strong>长连接</strong><ul><li>HTTP1.0默认使用短连接，每次HTTP请求都需要建立新的TCP连接，连接不能复用；</li><li>HTTP1.1支持<strong>持久连接和请求的流水线处理（但不是并发！！）</strong>，在<strong>一个TCP连接上可以传送多个HTTP请求和响应</strong>，<u>减少建立和关闭TCP连接的消耗和延迟，提高效率</u></li></ul></li><li><strong>host字段</strong><ul><li>在<strong>HTTP1.0中为每台服务器绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名</strong>（hostname）</li><li>HTTP1.1的请求消息和响应消息都应支持Host头域（<u>补充：F12 抓包可以看到</u>），且请求消息中如果<strong>没有Host头域</strong>，会<strong>报400 Bad Request错误</strong></li></ul></li><li><strong>缓存处理</strong><ul><li>HTTP1.1则引入了更多的缓存控制策略</li></ul></li><li><strong>带宽优化及网络连接的使用</strong><ul><li>HTTP1.0中存在浪费带宽现象，例如：（1）客户端只需要某个对象的一部分，而服务器却<u>将整个对象发送过来</u>；(2) 下载大文件不支持断点续传功能，在发生断连后需要重新下载完整的包；</li><li>HTTP1.1则在请求头中引入range头域，它允许<strong>只请求资源的某个部分(因此也支持断点重传)</strong>，即返回码是206；</li></ul></li><li><strong>新增一些错误通知状态码</strong><ul><li>如：409（Conflict）表示请求的资源与资源的当前状态发生冲突 。</li></ul></li></ul><h4 id="6-请说明一下http1-0-和https2-0-区别？">6. <strong>请说明一下http1.0 和https2.0 区别？</strong></h4><h4 id="7-请讲一下浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程？">7. <strong>请讲一下浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程？</strong></h4><ol><li><p>在浏览器地址栏中输入URL；</p></li><li><p>DNS域名解析，获得域名相对应的IP地址（详见：<u>应用层DNS寻址过程</u>）；</p><blockquote><p>浏览器首先会从（1）本地浏览器缓存、hosts文件是否存在相应的域名、IP对应关系，如果有则向这个IP地址发送请求，如果没有则向（2）本地DNS<strong>解析器</strong>缓存中查找，如果都没有，（3）再去DNS<strong>服务器</strong>中找IP。</p></blockquote></li><li><p>浏览器向服务器发起TCP连接，与浏览器建立TCP三次握手；然后 <u><strong>向服务器发送HTTP请求</strong></u>，请求数据包</p><blockquote><p><strong>HTTP请求是由三部分组成：请求行、请求报头和请求正文。</strong></p><p>与服务器建立了连接后，就可以向服务器发起请求了。发送HTTP请求的过程就是<u>构建HTTP请求报文</u>，并通过TCP协议发送到服务器指定端口（<u>HTTP协议80/8080，HTTPS协议443</u>）。</p></blockquote></li><li><p>服务端（由web服务器）处理收到的请求</p><blockquote><p>服务器端收到请求后，由web服务器（准确来说应该是HTTP服务器）处理请求，诸如Apache、Ngnix、IIS 。</p></blockquote></li><li><p>服务器返回相应结果（响应报文）至浏览器</p><blockquote><p>HTTP响应报文也是由三部分组成：<strong>状态码、响应报头和响应报文。</strong></p><p>状态码是由三位数组成，<u>第一个数字定义了响应的类别</u>：</p><ul><li><strong>1XX</strong>：指示信息，表示请求已接受，继续处理；</li><li><strong>2XX</strong>：成功，表示请求已被成功接收、理解、接受；</li><li><strong>3XX</strong>：重定向，要完成请求必须进行更进一步的操作；</li><li><strong>4XX</strong>：客户端错误，请求有语法错误或无法实现；</li><li><strong>5XX</strong>：服务器端错误，服务器未能实现合法的请求。</li></ul></blockquote></li><li><p>四次挥手关闭TCP连接</p><blockquote><p>四次挥手，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。</p></blockquote></li><li><p>（:triangular_flag_on_post:*1）浏览器解析渲染页面</p><blockquote><p>浏览器在 <u>收到HTML、CSS、JS文件</u>后，就需要进行渲染。</p><p>（1）浏览器解析HTML文件构建<u>DOM树</u>，（2）然后解析CSS文件构建<u>渲染树</u>，（3）等到渲染树构建完成后，浏览器开始布局渲染树并将其<u>绘制到屏幕</u>上</p></blockquote></li></ol><h4 id="8-请解释一下SSL工作过程（Https传输过程）？">8. <strong>请解释一下SSL工作过程（Https传输过程）？</strong></h4><blockquote><p>https是http的扩展，在传输层使用了安全协议：<strong>安全套接字层SSL(Secure Socket Layer)</strong>。</p><p>参考：<a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p></blockquote><blockquote><p><strong>公钥</strong>通常用于加密会话密钥、验证数字签名，或加密可以用相应的私钥解密的数据。公钥和私钥是通过一种算法得到的一个密钥对(即一个公钥和一个私钥)。</p><ul><li>通过这种算法得到的密钥对能保证在世界范围内是唯一的。</li><li>使用这个密钥对的时候,如果用其中一个密钥加密一段数据，必须用另一个密钥解密。</li></ul></blockquote><p>SSL/TLS协议的基本思路是采用<a href="http://en.wikipedia.org/wiki/Public-key_cryptography">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p><img src="https://i.loli.net/2021/04/21/aH6gjc5UT9Xu2io.png" alt="image-20210421171336262"></p><p>所以基本过程是：</p><blockquote><p>（1） 客户端向服务器端索要并验证公钥。</p><p>（2） 双方协商生成&quot;对话密钥&quot;。</p><p>（3） 双方采用&quot;对话密钥&quot;进行加密通信。</p></blockquote><ol><li><p>**协商加密算法。**客户端（通常是浏览器）先向服务器发出<u>加密通信的请求</u>，这被叫做ClientHello请求；</p><blockquote><p>（1） 支持的协议版本，比如TLS 1.0版。</p><p>（2） <u>一个客户端生成的随机数</u>，来生成&quot;对话密钥&quot;。</p><p>（3） 支持的加密方法，比如RSA公钥加密。</p><p>（4） 支持的压缩方法。</p></blockquote></li><li><p>**服务器回应。**服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello；</p><blockquote><p>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</p><p>（2） <u>一个服务器生成的随机数</u>，稍后用于生成&quot;对话密钥&quot;。</p><p>（3） 确认使用的加密方法，比如RSA公钥加密。</p><p>（4） 服务器证书。</p></blockquote></li><li><p>**客户端鉴别。**客户端收到服务器回应以后，（1）<u>首先验证服务器证书</u>：如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p><p>（2）<u>如果证书没有问题，客户端就会从证书中取出服务器的公钥</u>。然后，向服务器发送下面三项信息：</p><blockquote><p>（1） <u>一个随机数</u>。该随机数用服务器公钥加密，防止被窃听。</p><p>（2） <u>编码改变通知</u>，表示随后的信息都将用双方商定的加密方法和密钥发送。</p><p>（3） <u>客户端握手结束通知</u>，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p></blockquote></li><li><p><strong>会话秘钥计算。</strong> 服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的&quot;会话密钥&quot;（使用3个随机数生成更安全）；</p><blockquote><p>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p><p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p></blockquote></li><li><p>**安全数据传输。**双方用会话秘钥加密和解密之间传送的数据。</p></li></ol><h5 id="8-1-公钥如何保证不被篡改？说一说证书。">8.1 公钥如何保证不被篡改？说一说证书。</h5><p>将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p><ul><li><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p></li><li><p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，<strong>会对已申请的公开密钥做数字签名</strong>，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p></li><li><p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过（<strong>证书不可信浏览器会提示</strong>），就可以开始通信了。</p></li></ul><h5 id="8-2-公钥加密计算量太大，如何减少耗用的时间？">8.2 公钥加密计算量太大，如何减少耗用的时间？</h5><p>每一次对话（session），客户端和服务器端都生成一个&quot;对话密钥&quot;（session key），用它来加密信息。由于**&quot;对话密钥&quot;是对称加密**，所以<strong>运算速度非常快</strong>，而服务器公钥只用于加密&quot;对话密钥&quot;本身，这样就减少了加密运算的消耗时间。</p><h5 id="8-3-为什么有的时候刷新页面不需要重新建立-SSL-连接？">8.3 为什么有的时候刷新页面不需要重新建立 SSL 连接？</h5><p>TCP 连接有的时候会被浏览器和服务端维持一段时间，<strong>TCP 不需要重新建立，SSL 自然也会用之前的</strong>。</p><h4 id="9-介绍一下常见的几种非对称加密算法？-优缺点？">9. **介绍一下常见的几种非对称加密算法？**优缺点？</h4><ul><li><p><strong>非对称加密</strong></p><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，<strong>通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密</strong>，<strong>接收方收到通信内容后使用私有密钥解密</strong>。</p></li><li><p><strong>常用非对称加密算法</strong></p><p><img src="https://i.loli.net/2021/04/21/8cmyAzUZYDw5vJt.png" alt="面试题——对称加密和非对称加密3"></p><ul><li>RSA：由 RSA 公司发明，是一个支持<strong>变长密钥</strong>的公共密钥算法，需要加密的文件块的长度也是可变的</li><li>DSA（Digital Signature Algorithm）：<strong>数字签名</strong>算法，是一种标准的 DSS（数字签名标准）</li><li>ECC（Elliptic Curves Cryptography）：<strong>椭圆曲线加密</strong></li></ul></li><li><p><strong>非对称加密优缺点</strong></p><ul><li><strong>优点：</strong> 可以更安全地将公开密钥传输给通信发送方；</li><li><strong>缺点：</strong> 运算速度慢。</li></ul></li></ul><h4 id="10-公钥加密–私钥解密与公钥解密–私钥加密有什么区别">10. <strong>公钥加密–私钥解密与公钥解密–私钥加密有什么区别?</strong></h4><p>主要是应用场景不同。</p><ul><li><p>加解密：公钥加密，私钥解密</p><blockquote><p>不希望别人知道我的消息，<u>所以只有我才能解密</u>，所以可得出公钥负责加密，私钥负责解密</p></blockquote></li><li><p>签名：私钥签名，公钥验签</p><blockquote><p>是不希望有人冒充我发消息，只有<u>我才能发布这个签名</u>，所以可得出私钥负责签名，公钥负责验证</p></blockquote></li><li><p><strong>https可以只有非对称加密吗?</strong></p><p>https<u>验证证书阶段是非对称加密</u>，但是在数据传输阶段是对称加密。<strong>https不可以只有非对称加密：</strong></p><ul><li><strong>非对称加密</strong>的加解密<strong>效率是非常低</strong>的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的；</li><li>在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。</li></ul></li></ul><h4 id="11-HTTPS-为什么安全？为什么需要CA证书？只有认证机构可以生成证书吗？HTTPS-绝对安全吗？">11. <strong>HTTPS 为什么安全？为什么需要CA证书？只有认证机构可以生成证书吗？HTTPS 绝对安全吗？</strong></h4><ul><li><p>**安全：**因为 HTTPS 保证了传输安全，防止传输过程被监听、防止数据被窃取，可以确认网站的真实性；</p></li><li><p><strong>CA证书：</strong> <u>HTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器</u>，而 HTTPS 协议主要解决的便是网络传输的安全性问题，所以需要CA证书</p></li><li><p><strong>证书生成：</strong> 如果需要浏览器不提示安全风险，那只能使用认证机构签发的证书。但<strong>浏览器通常只是提示安全风险，并不限制网站不能访问</strong>，所以从技术上<strong>谁都可以生成证书</strong>，只要有证书就可以完成网站的 HTTPS 传输。</p></li><li><p><strong>不绝对安全：</strong> 不是绝对安全的，可以通过中间人攻击。</p><blockquote><p>CA证书不是可以解决“中间人”吗？</p></blockquote><p>过程原理：</p><ol><li>本地请求被劫持（<u>如DNS劫持等</u>），所有请求均发送到中间人的服务器</li><li>中间人服务器返回中间人自己的证书（<strong>但是这一步服务器不是会对服务器证书进行验证吗？</strong>）</li><li>客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输</li><li>中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密</li><li>中间人以客户端的请求内容再向官方网站发起请求</li><li>因为中间人与服务器的通信过程是合法的，官方网站通过建立的安全通道返回加密后的数据</li><li>中间人凭借与官方网站建立的对称加密算法对内容进行解密</li><li>中间人通过与客户端建立的对称加密算法对官方内容返回的数据进行加密传输</li><li>客户端通过与中间人建立的对称加密算法对返回结果数据进行解密</li></ol></li></ul><h4 id="12-http应答码中的301-2-4、500、502、503、504状态码进行解释？">12. <strong>http应答码中的301/2/4、500、502、503、504状态码进行解释？</strong></h4><ul><li><p><strong>200：</strong>  请求成功。</p></li><li><p><img src="https://i.loli.net/2021/04/21/MRi5Oy9Ltd3v8uA.png" alt="image-20210421150625709"></p></li><li><p><strong>500：</strong> 500 (<strong>服务器内部错误</strong>) 服务器遇到错误，无法完成请求。 例如，服务器<strong>无法识别请求方法</strong>时可能会返回此代码。</p></li><li><p><strong>501：<strong>服务器</strong>不支持请求的功能</strong>，无法完成请求</p></li><li><p><strong>502：</strong> 作为<strong>网关或者代理工作的服务器</strong>尝试执行请求时，从<u>上游服务器</u>接收到<strong>无效</strong>的响应。</p></li><li><p><strong>503：</strong> 由于超载或系统维护，服务器暂时的<strong>无法处理客户端</strong>的请求。</p></li><li><p>**504(及时)：**作为网关或者代理工作的服务器尝试执行请求时，<strong>未能及时</strong>从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。</p></li></ul><h4 id="13-介绍一下http请求get、post等？">13. <strong>介绍一下http请求get、post等？</strong></h4><p><img src="https://i.loli.net/2021/04/21/WRLspE4fvjdKq8F.png" alt="image-20210421140204266"></p><p><strong>重点区分一下get和post：</strong></p><ul><li><p><code>get</code> ：GET方法用于使用给定的URI从给定服务器中<u>检索信息</u>，即从指定资源中请求数据。</p><ul><li>**GET请求是可以缓存的，**浏览器历史记录中查找到GET请求；<strong>长度有限制</strong>；不安全，<strong>url会暴露请求的参数</strong></li></ul></li><li><p><code>post</code>：POST方法用于将数据发送到服务器以<u>创建或更新资源</u> 。</p><ul><li><strong>POST请求不会被缓存</strong>；<strong>长度无限制</strong>；更安全</li></ul></li><li><p><strong>特别的：<code>GET产生一个TCP数据包;POST产生两个TCP数据包。</code></strong></p><ul><li><p>get：http header和body一并发送出去 ；</p></li><li><p>post：浏览器先发送header，服务器响应100 continue，浏览器再发送body 。</p><blockquote><p>:warning: post是不一定会发生两个的。</p><ul><li>HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送；</li><li>header 和 body 分开发送<strong>是部分浏览器或框架的请求方法</strong>，不属于 post 必然行为。</li></ul></blockquote></li></ul></li></ul><h5 id="13-1-Get方法长度有限制是怎么回事？">13.1 Get方法长度有限制是怎么回事？</h5><p>HTTP 协议没有 Body 和 URL 的长度限制，<strong>对 URL 限制的大多是浏览器 / 服务器的原因</strong>。</p><ul><li>服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制；</li><li>浏览器也会设置url有限。</li></ul><h5 id="13-2-POST-方法相比GET方法是绝对安全吗？">13.2 POST 方法相比GET方法是绝对安全吗？</h5><ul><li>POST 比 GET 安全，因为数据在地址栏上不可见；</li><li><strong>POST不是绝对安全</strong>，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。</li></ul><p>想要安全，只有使用<strong>HTTPS</strong>。</p><h4 id="14-HTTP是不保存状态的协议-如何保存用户状态">14.  HTTP是不保存状态的协议,如何保存用户状态?</h4><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太⼀样。</p><ul><li><strong>Cookie ⼀般用来保存用户<u>信息</u></strong><ul><li>我们在 Cookie 中<strong>保存已经登录过得用户信息</strong>，下次访问网站的时候页面可以⾃动帮你登录的⼀些基本信息给填了；</li><li>⼀般的网站都会有<strong>保持登录</strong>也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以<strong>存放了⼀个 Token 在 Cookie</strong>中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录⼀般要将 Token<br>重写)；</li><li>登录⼀次网站后访问网站其他页面不需要重新登录。</li></ul></li><li><strong>Session 的主要作用就是通过服务端记录用户的<u>状态</strong></u>。<ul><li><strong>典型的场景是购物⻋</strong>，当你要添加商品到购物⻋的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</li><li>**既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？**大部分情况下，我们都是通过在Cookie 中附加⼀个 Session ID 来方式来跟踪。</li></ul></li></ul><h4 id="15-cookie-、session的作用和区别？">15. <strong>cookie 、session的作用和区别？</strong></h4><ul><li><p>**Cookie **</p><ul><li><p><strong>作用：</strong> 服务器发送到用户浏览器并保存在本地的一小块数据，它会在<u>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</u>。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。</p><blockquote><p>Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p></blockquote></li></ul></li><li><p><strong>Session</strong></p><ul><li><strong>作用：</strong> Session 代表着服务器和客户端<strong>一次会话的过程</strong>，Session <u>对象存储特定用户会话所需的属性及配置信息</u>。</li></ul></li><li><p><strong>二者区别</strong></p><ul><li><strong>作用范围不同</strong>，Cookie 保存在客户端（浏览器），Session 保存在服务器端；</li><li>**有效期不同，**Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效；</li><li><strong>安全性：</strong> Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些；</li><li><strong>存储大小不同：</strong>  <u>单个 Cookie 保存的数据不能超过 4K</u>，Session 可存储数据远高于 Cookie；</li><li><strong>存取类型的不同</strong>，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li></ul></li></ul><h5 id="15-1-Session的共享方式？（好未来问过）">15.1 Session的共享方式？（好未来问过）</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/jing99/p/11785070.html">Session如何共享</a></p></blockquote><ul><li><p><strong>问题描述</strong></p><ol><li>在集群环境中，假设客户端第一次访问服务A，服务A响应返回了一个sessionId并且存入了本地Cookie中。第二次不访问服务A了，转去访问服务B；</li><li>访问服务B的时候，会将sessionId加入到请求头中，而服务B因为通过sessionId没有找到相对应的数据，因此它就会<strong>创建一个新的sessionId并且响应返回给客户端</strong></li></ol><p>这样就造成了不能共享Session的问题。</p></li><li><p><strong>解决方案</strong></p><ol><li><strong>使用Cookie实现</strong>。 将系统用户的Session信息加密、序列化后，以Cookie的方式， 统一种植在根域名下（如：.host.com），利用浏览器访问该根域名下的所有二级域名站点时，会传递与之域名对应的所有Cookie内容的特性，从而实现用户的Cookie化Session在多服务间的共享访问。</li><li><strong>数据库同步session。</strong>  每次将session数据存到数据库中。这个方案还是比较可行的。<ul><li><strong>缺点：</strong> Session的并发读写能力取决于MySQL数据库的性能，对数据库的压力大，同时需要自己实现Session淘汰逻辑，以便定时从数据表中更新、删除 Session记录，当并发过高时容易出现表锁。</li></ul></li><li><strong>使用token代替session。</strong> 就是Token方式替代了，但是还是没解决。</li><li><strong>Spring-Sesion实现</strong> 。将原本需要由Web服务器创建会话的过程转交给Spring-Session进行创建。Spring-Session会将原本应该保存在Web服务器内存的Session存放到Redis中。然后<strong>Web服务器之间通过连接Redis来共享数据</strong>，达到Sesson共享的目的。</li></ol></li></ul><h4 id="16-Cookie-和-Session有什么关联？（问过）token有什么作用，优点，（JWT）结构是什么？">16.  Cookie 和 Session有什么关联？（问过）token有什么作用，优点，（JWT）结构是什么？</h4><blockquote><p>参考：[一文彻底搞懂Cookie、Session、Token到底是什么](<a href="https://juejin.cn/post/6844904009061367821">一文彻底搞懂Cookie、Session、Token到底是什么 (juejin.cn)</a>)</p></blockquote><ul><li><p><strong>为什么需要session？</strong></p><blockquote><p>既然浏览器已经通过<code>Cookie</code>实现了有状态这一需求，那么为什么又来了一个<code>Session</code>呢？</p></blockquote><p>如果将账户的一些重要信息都存入<code>Cookie</code>中的话，一旦<strong>被拦截</strong>，那么我们所有的账户信息都会丢失掉。所以就出现了<code>Session</code>，在一次会话中将重要信息保存在<code>Session</code>中，浏览器只记录<code>SessionId</code>一个<code>SessionId</code>对应一次会话请求。</p></li><li><p><strong>session和cookie二者关联</strong></p><p><img src="https://i.loli.net/2021/05/04/jNerb9CXZ6Jpgs2.jpg" alt="img"></p><blockquote><p>以用户一次登录为例。</p></blockquote><ol><li>用户第一次请求服务器的时候，用户提交包含<strong>用户名和密码</strong>的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 <strong>Redis</strong> 中，它在 Redis 中的 Key 称为 Session ID；并将此 Session 的唯一标识信息 SessionID 返回给浏览器；</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名；</li><li>当用户第二次访问服务器的时候，请求会自动判断<u>此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端</u>；</li><li>服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 <u>Session 信息，如果没有找到说明用户没有登录或者登录失效</u>，如果找到 Session 证明用户已经登录可执行后面操作。</li></ol></li><li><p><strong>什么是Token？</strong></p><blockquote><p><code>Session</code>是将要验证的信息存储在服务端，并以<code>SessionId</code>和数据进行对应，<code>SessionId</code>由客户端存储，在请求时将<code>SessionId</code>也带过去，因此实现了状态的对应。</p></blockquote><p>但是，而<code>Token</code>是在服务端将<strong>用户信息经过Base64Url【编码，不是加密】过后传给在客户端</strong>，每次用户请求的时候都会带上这一段信息，因此服务端拿到此信息进行解密后就知道此用户是谁了。</p><p>这个方法叫做<strong>JWT(Json Web Token)</strong>。</p><blockquote><p>一个例子理解：基于Token的身份验证流程，在服务端不需要存储用户的登录记录 。</p><ol><li><p>客户端<strong>使用用户名跟密</strong>码请求登录</p></li><li><p>服务端收到请求，去验证用户名与密码</p></li><li><p>验证成功后，服务端会<strong>签发一个 Token</strong>，再把这个 Token 发送给客户端</p><blockquote><p>Token在服务器端，可以保存在Redis缓存中。</p></blockquote></li><li><p>客户端收到 Token 以后可以把它存储起来，比如<strong>放在 Cookie 里或者 Local Storage</strong> 里</p></li><li><p>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p></li></ol></blockquote></li></ul><blockquote><ol start="6"><li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li></ol></blockquote><ul><li><p><strong>Token的优点</strong></p><ol><li><strong>无状态，可扩展和解耦：</strong> 使用 token 而不是 cookie 的最大优点应该就是无状态，<strong>后端不需要保持对 token 的记录，每个 token 都是独立的</strong>，包含了检查其有效性的所有数据，并通过申明传达了用户信息。</li><li><strong>在 JWT 中存储数据</strong> ： 当使用 cookie 进行验证时，你是将 session id 存储到 cookie 里，JWT 允许你存储任何类型的元数据，只要是合法的 JSON。</li><li>*自包含：**由于串包含了用户所需要的信息，避免了多次查询数据库 **</li></ol></li><li><p><strong>JWT介绍</strong></p><p>JWT有三部分组成：Header，Payload，Signature。</p><p><img src="https://i.loli.net/2021/05/26/AC6ULh5293HQngE.png" alt="image-20210526214555872"></p><ul><li><p><strong>Header：</strong> 一个Json对象，描述JWT的元数据，通常是下面这样子的。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>, # 签名的算法为HS256</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>    # Token类型为JWT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Payload：</strong> 也是一个Json对象，用来存放实际需要传输的数据，也可以自己定义一些私有字段，如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xiaoMing&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Signature ：</strong>  <strong>对前面的两部分的数据进行签名</strong>，<strong>防止数据篡改</strong> 。</p><blockquote><p>首先需要定义一个<strong>秘钥</strong>，这个秘钥只有服务器才知道，不能泄露给用户，然后使用<strong>Header中指定的签名算法</strong>(默认情况是HMAC SHA256)。算出签名以后将Header、Payload、Signature三部分拼成一个字符串，<strong>每个部分用<code>.</code>分割开来</strong>，就可以返给用户了。</p></blockquote></li></ul></li></ul><h5 id="16-1-session和cookie应该如何去选择（适用场景）？">16.1 session和cookie应该如何去选择（适用场景）？</h5><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在<strong>考虑数据复杂性时首选 Session</strong>；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；<strong>考虑安全考虑session</strong></li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此<strong>不建议将所有的用户信息都存储到 Session 中，一般是cookie和session配合使用的</strong>。</li></ul><h4 id="17-说说HTTP、TCP、Socket-的关系是什么？">17. <strong>说说HTTP、TCP、Socket 的关系是什么？</strong></h4><ul><li>TCP/IP 代表<u>传输控制协议/网际协议</u>，指的是一系列协议族；</li><li>HTTP 本身就是一个协议，是<u>从 Web 服务器传输超文本到本地浏览器</u>的传送协议；</li><li><strong>Socket 是 TCP/IP 网络的 API</strong> ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</li></ul><h2 id="3-5-其它">3.5 其它</h2><h4 id="1-介绍一下CDN-？-CDN分发节点各个数据都一样吗？">1. 介绍一下CDN ？ <strong>CDN</strong>分发节点各个数据都一样吗？</h4><ul><li><p><strong>CDN，即内容分发网络</strong></p><ul><li><p><strong>解决静态网页加载</strong></p><p>不同地区用户访问服务器速度不同，<strong>可以把静态网页放在不同地区的服务器，这样用户可以就近去连接</strong>，大大提升体验；</p></li><li><p>发展转换成，<strong>就近接入解决访问网络资源</strong></p><ol><li>如一个电信用户送请求，进入解析系统，会<strong>让用户连接到最近的边缘节点</strong>，然后请求数据；</li><li>如果边缘节点没有数据，则去访问<strong>源节点</strong>；</li><li>源节点也没有，就会去访问<strong>主干节点，去联通服务器中查找；</strong></li><li>最后返回数据。</li></ol></li></ul></li><li><p><strong>CDN分发节点各个数据不一样</strong></p><p>不一样，就相当于DNS服务器<strong>缓存</strong>了些域名→ip数据，如果没有的话还要向上级查询，最终把源站数据拉下来。</p></li></ul><h4 id="2-什么是CDN三级溯源？">2.  什么是CDN三级溯源？</h4><ul><li><strong>CDN目的</strong>。CDN 系统设计的首要目标是<strong>尽量减少用户的访问响应时间</strong></li><li><strong>CDN实现思路。<strong>为达到这一目标，CDN 系统应该</strong>尽量将用户所需要的内容存放在距离用户最近的位置</strong>。也就是说，负责为用户提供内容服务的 <strong>Cache设备应部署在物理上的网络边缘位置</strong>，我们称这一层为 CDN边缘层 。</li><li>**CDN系统架构。**CDN 系统中负责全局性管理和控制的设备组成 中心层 ，<strong>中心层同时保存着最多的内容副本</strong>，当边缘层设备未命中时，会向中心层请求，如果在中心层仍未命中，则需要中心层向源站回源。</li></ul><p><img src="D:/hwh/images/image-20210813124031742.png" alt="image-20210813124031742"></p><h1>四、操场系统</h1><h2 id="4-1-操作系统基础">4.1 操作系统基础</h2><h4 id="0-（百度安全一面）-冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？">0. （百度安全一面） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？</h4><ul><li>存储器：内存</li><li><strong>控制器：南桥北桥</strong></li><li>运算器：CPU</li><li>输入设备：键盘</li><li>输出设备：显示器、网卡</li></ul><h4 id="1-什么是操作系统？">1. 什么是操作系统？</h4><ol><li>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基⽯；</li><li>操作系统本质上是运行在计算机上的软件程序 ；</li><li>操作系统为用户提供⼀个与系统交互的操作界面 ；</li><li>操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。</li></ol><h4 id="2-什么是系统调用呢？-能不能详细介绍⼀下？">2. 什么是系统调用呢？ 能不能详细介绍⼀下？</h4><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ol><li><strong>用户态(user mode) :</strong> 用户态运行的进程或可以直接读取用户程序的数据。</li><li>**系统态(kernel mode)：**可以简单的理解系统态运行的进程或程序⼏乎可以访问计算机的任何资源，不受限制。</li></ol><p>我们运行的程序基本都是运行在<strong>用户态</strong>，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p><p>这些系统调用按功能大致可分为如下⼏类：</p><ul><li><strong>设备管理</strong>。完成设备的请求或释放，以及设备启动等功能。</li><li><strong>⽂件管理</strong>。完成⽂件的读、写、创建及删除等功能。</li><li><strong>进程控制</strong>。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li><strong>进程通信</strong>。完成进程之间的消息传递或信号传递等功能。</li><li><strong>内存管理</strong>。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li></ul><h4 id="3-CentOS-和-Linux的关系？">3. <strong>CentOS 和 Linux的关系？</strong></h4><p>Linux意思较广广义的范围，多指是Linux内核。CentOS是RedHat的一个分支，RedHat是Linux的一个发行版本，RedHat与CentOS的区别在于，RedHat收费，CentOS免费。</p><h4 id="4-什么是分布式，优缺点？集群？">4. 什么是分布式，优缺点？集群？</h4><ul><li><p><strong>分布式</strong></p><p>根据业务需求进行拆<strong>分成N个子系统</strong>，多个子系统相互协作才能完成业务流程<strong>子系统之间通讯</strong>使用<strong>RPC</strong>远程通讯技术。</p></li><li><p><strong>集群</strong></p><p>同一个工程部署在多个不同的服务器上。</p></li><li><p><strong>分布式优点</strong></p><p>1.把模块拆分，使用接口通信，降低模块之间的耦合度。</p><p>2.把项目拆分成若干个子项目，不同的团队负责不同的子项目。</p><p>3.增加功能时只需要再增加一个子项目，调用其它系统的接口就可以。</p><p>4.可以灵活的进行分布式部署。</p></li><li><p><strong>分布式缺点</strong></p><p>1.系统之间交互需要使用远程通信，接口开发增加工作量。</p><p>2.各个模块有一些通用的业务逻辑无法共用。</p></li></ul><h4 id="5-在Linux-windows栈空间的大小？">5. 在Linux/windows栈空间的大小？</h4><ul><li><p><strong>Linux环境下由操作系统决定</strong>，一般是<code>8KB</code> ， 通过ulimit命令查看以及修改</p><blockquote><p>在Linux下通过如下命令可查看和设置栈的大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">ulimit</span> -a            <span class="comment"># 显示当前栈的大小 （ulimit为系统命令，非编译器命令）</span></span>       </span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">ulimit</span> -s 32768      <span class="comment"># 设置当前栈的大小为32MCopy to clipboardErrorCopied</span></span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>Windows环境下由编译器决定</strong>，VC++6.0一般是<code>1M</code> \</p><blockquote><p>Windows平台下栈的大小是被记录在可执行文件中的（由编译器来设置)，即：windows下可以由编译器决定栈大小，而在Linux下是由系统环境变量来控制栈的大小的。</p></blockquote></li></ul><h4 id="6-ASCII、Unicode和UTF-8编码的区别？">6. ASCII、Unicode和UTF-8编码的区别？</h4><ul><li><p><strong>ASCII :</strong>  ASCII 只有127个字符，表示英文字母的大小写、数字和一些符号 ；</p><blockquote><p>常用中文需要两个字节，且不能和ASCII冲突，中国定制了<code>GB2312</code>编码格式。</p></blockquote></li><li><p><strong>Unicode：</strong> Unicode就是将<strong>不同语言统一到一套编码格式中</strong>，通常<strong>两个</strong>字节表示一个字符，而<strong>ASCII是一个</strong>字节表示一个字符 ；</p><blockquote><p>如果你编译的文本是全英文的，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p></blockquote></li><li><p><strong>UTF-8 :</strong>  把Unicode编码转化为 “<strong>可变长编码</strong>” UTF-8编码，UTF-8编码将Unicode字符按数字大小编码为<strong>1-6</strong>个字节，英文字母被编码成<strong>1</strong>个字节，常用汉字被编码成<strong>2</strong>个字节。</p></li></ul><h5 id="6-1-三者区别和联系">6.1 三者区别和联系</h5><ul><li><p>在<strong>计算机内存</strong>中，统一使用<strong>Unicode</strong>编码 ；</p></li><li><p>当需要<strong>保存到硬盘或者需要传输</strong>的时候，就转换为<strong>UTF-8</strong>编码</p></li></ul><p>举例说明：</p><blockquote><p>例1 ：记事本编辑（内存）→保存（磁盘）。</p></blockquote><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。</p><p><img src="https://i.loli.net/2021/06/11/9IjWniLHqrwRd2s.png" alt="image-20210611131935690"></p><blockquote><p>例2：网络传输服务器→浏览器。</p></blockquote><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。</p><p><img src="https://i.loli.net/2021/06/11/hZFaKbezvQEsxko.png" alt="image-20210611132058826"></p><h4 id="7-什么是并发和并行？">7. 什么是并发和并行？</h4><ul><li><strong>并发：</strong> 是指宏观上在<strong>一段时间</strong>内能同时运行多个<strong>程序</strong>；</li><li><strong>并行</strong> ：则指<strong>同一时刻</strong>能运行多个<strong>指令</strong>。</li></ul><h4 id="8-什么是共享？">8. 什么是共享？</h4><ul><li><p><strong>共享定义：</strong> 系统中的资源可以被多个并发进程共同使用 ；</p></li><li><p><strong>共享方式</strong>：<u>互斥</u>共享和<u>同时</u>共享：</p><ul><li><strong>互斥共享：</strong> 在<strong>同一时刻只允许一个进程访问</strong>，需要用同步机制来实现互斥访问 ，如：打印机。</li></ul></li></ul><h2 id="4-2-进程和线程">4.2 进程和线程</h2><h4 id="1-请问64位和32位的区别？">1. <strong>请问64位和32位的区别？</strong></h4><ol><li>**运行能力不同。**64位可以一次性可以处理8个字节的数据量，而32位一次性只可以处理4个字节的数据量，因此64位比32位的运行能力提高了一倍。</li><li><strong>内存寻址不同</strong>。64位最大寻址空间为2的64次方，理论值直接达到了16TB，而32位的最大寻址空间为2的32次方，为4GB，换而言之，就是说32位系统的处理器最大只支持到4G内存，而64位系统最大支持的内存高达亿位数。</li><li>**运行软件不同。**由于32位和64位<u>CPU的指令集是不同</u>的。所以需要区分32位和64位版本的软件。<br>为了保证兼容性，64位CPU上也能运行老的32位指令，但反过来32位系统不可以运行64位的软件。</li></ol><h4 id="2-介绍一下线程和进程的区别？">2. <strong>介绍一下线程和进程的区别？</strong></h4><ol><li><p><strong>根本区别：<strong>进程是操作系统</strong>资源分配</strong>的基本单位，而线程是处理器<strong>任务调度</strong>和执行的基本单位</p></li><li><p><strong>资源开销：每个进程都有独立的代码和数据空间（程序上下文）</strong>，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，<strong>每个线程都有自己独立的运行栈和程序计数器</strong>（PC），线程之间切换的开销小</p></li><li><p>**包含关系：**如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</p></li><li><p><strong>内存分配：<strong>同一进程的线程</strong>共享本进程的【地址空间和资源】</strong>，而进程之间的地址空间和资源是相互独立的</p></li><li><p>**影响关系：**一个进程崩溃后，在保护模式下不会对其他进程产生影响，<strong>但是一个线程崩溃整个进程都死掉</strong>，<strong>所以多进程要比多线程健壮</strong>。</p><blockquote><p>线程没有独立的地址空间，如果崩溃，会发信号，如果没有错误处理的handler，OS一般直接杀死进程。</p></blockquote></li><li><p>**能否独立：**每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p></li></ol><h5 id="2-1-线程和协程之间的区别？">2.1 线程和协程之间的区别？</h5><blockquote><p><strong>进程是资源调度的基本单位</strong>，<strong>运行一个可执行程序会创建一个或多个进程</strong>，进程就是运行起来的可执行程序 ;</p><p><strong>线程是程序执行的基本单位</strong>，是轻量级的进程。<strong>每个进程中都有唯一的主线程，和多个线程</strong>，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束；</p><p><strong>协程</strong>是用户态的<strong>轻量级线程</strong>，<strong>也是线程内部调度的基本单位</strong> 。</p></blockquote><p>协程和线程的区别如下（补充了和进程的区别，方便对比）。</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">进程</th><th style="text-align:left">线程</th><th>协程</th></tr></thead><tbody><tr><td style="text-align:left">定义</td><td style="text-align:left">资源分配和拥有的基本单位</td><td style="text-align:left">程序执行的基本单位</td><td>用户态的轻量级线程，线程内部调度的基本单位</td></tr><tr><td style="text-align:left">切换情况</td><td style="text-align:left">进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td><td style="text-align:left">保存和设置程序计数器、少量寄存器和栈的内容</td><td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td></tr><tr><td style="text-align:left">切换者</td><td style="text-align:left">操作系统</td><td style="text-align:left">操作系统</td><td>用户</td></tr><tr><td style="text-align:left">切换过程</td><td style="text-align:left">用户态-&gt;内核态-&gt;用户态</td><td style="text-align:left">用户态-&gt;内核态-&gt;用户态</td><td>用户态(没有陷入内核)</td></tr><tr><td style="text-align:left">调用栈</td><td style="text-align:left">内核栈</td><td style="text-align:left">内核栈</td><td>用户栈</td></tr><tr><td style="text-align:left">拥有资源</td><td style="text-align:left"><strong>CPU资源、内存资源、文件资源和句柄等</strong></td><td style="text-align:left"><strong>程序计数器、寄存器、栈和状态字</strong></td><td><strong>拥有自己的寄存器上下文和栈</strong></td></tr><tr><td style="text-align:left">并发性</td><td style="text-align:left">不同进程之间切换实现并发，各自占有CPU实现并行</td><td style="text-align:left">一个进程内部的多个线程并发执行</td><td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td></tr><tr><td style="text-align:left">系统开销</td><td style="text-align:left">切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td><td style="text-align:left">切换时只需保存和设置少量寄存器内容，因此开销很小</td><td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td></tr><tr><td style="text-align:left">通信方面</td><td style="text-align:left">进程间通信需要借助操作系统</td><td style="text-align:left">线程间可以直接读写进程数据段(如全局变量)来进行通信</td><td>共享内存、消息队列</td></tr></tbody></table><h5 id="2-2-一个进程可以创建多少个线程，和什么有关？">2.2 一个进程可以创建多少个线程，和什么有关？</h5><p>一个进程可用虚拟空间是（C++）2G，默认情况下，（假设）<strong>线程的栈的大小是1MB</strong>（Linux是8kb），则理论上最多只能创建2048个线程。如果要创建多于2048的话，必须修改编译器的设置。</p><h5 id="2-3-进程之间的同步方式？（区分通信方式）">2.3 进程之间的同步方式？（区分通信方式）</h5><ol><li><p><strong>临界区。</strong> 对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p></li><li><p><strong>同步和互斥。</strong></p><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻<strong>只有一个进程</strong>能进入临界区。</li></ul></li><li><p><strong>信号量。</strong> 常见的 P 和 V 操作。</p><ul><li>特别的，<u>如果信号量的取值只能为 0 或者 1</u>，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</li></ul></li><li><p><strong>条件变量。</strong></p><blockquote><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p></blockquote><p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程：解决生产者、消费者问题</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function">procedure <span class="title">insert</span><span class="params">(item: integer)</span></span>;</span><br><span class="line">    begin</span><br><span class="line">        <span class="keyword">if</span> count = N then wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> then signal(empty);</span><br><span class="line">    end;</span><br><span class="line"></span><br><span class="line">    function remove: integer;</span><br><span class="line">    begin</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> then wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N <span class="number">-1</span> then signal(full);</span><br><span class="line">    end;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line">procedure producer</span><br><span class="line">begin</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    begin</span><br><span class="line">        item = produce_item;</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    end</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line">procedure consumer</span><br><span class="line">begin</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    begin</span><br><span class="line">        item = ProducerConsumer.remove;</span><br><span class="line">        consume_item(item);</span><br><span class="line">    end</span><br><span class="line">end;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-请问【进程】之间如何进行通信？">3. <strong>请问【进程】之间如何进行通信？</strong></h4><p>可以分为如下两个方面：</p><ol><li>本地进程之间的通信方式</li><li>远程进程之间的通信方式</li></ol><p><strong>1. 本地进程之间的通信方式（没有同步互斥！！）</strong></p><ul><li><p><strong>无名管道</strong> ：半双工通信方式，<strong>数据(消息)单向流动</strong>，只能是字节流格式的消息。</p><ul><li><p>**优点：**简单方便</p><ul><li>**缺点：<strong>单向通信、只能用于</strong>具有亲缘关系（一般指父子）**的进程之间、<strong>缓冲区有限</strong></li></ul></li></ul></li><li><p><strong>有名管道：半双工通信</strong>方式，数据也称为命名管道：是一种文件类型，以一种特殊设备文件形式存在于文件系统中。</p><ul><li><strong>优点</strong>：可以实现<strong>任意关系的进程</strong>间的通信（无法同步）</li><li><strong>缺点：</strong> 长期存于系统中，使用不当容易出错、<strong>缓冲区有限</strong></li></ul></li><li><p><strong>消息队列</strong>：消息队列是消息的<strong>链表</strong>,存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少,管道只能承载无格式字节流以及缓冲区大小受限等特点。</p><ul><li><strong>优点</strong>：<u>可以实现任意进程间的通信</u>，并通过系统调用函数来实现消息发送和接收之间的同步<u>，无需考虑同步</u>问题</li><li><strong>缺点</strong>：信息的复制需要<u>额外消耗CPU的时间</u>，不适宜于信息量大或操作频繁的场合</li></ul></li><li><p><strong>共享内存</strong></p><p>直接对内存存取，<u>通信快</u>，但是多个进程可以同时操作，<u>需要用信号量进行同步</u>。</p></li><li><p><strong>信号量</strong></p><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><ul><li><p><strong>优点</strong>：可以同步进程；</p></li><li><p><strong>缺点</strong>：信号量有限</p><blockquote><p>注解：P操作就是对S减一，V操作就是对S加一</p></blockquote><ul><li>**同步：**S = 0，进程A执行完进行V操作，进程B执行前执行P操作，这样B就可以等A执行完再执行；</li><li>**互斥：**S = 1，进程执行前进行P操作，执行后进行V操作。</li></ul></li></ul></li></ul><p><strong>2.远程进程之间的通信方式</strong></p><p>首要解决的问题是如何唯一标识一个进程？本地上采用PID即可，但是网络中 <u>TCP/IP五层网络模型中传输层的 “<strong>套接字：IP+端口</strong>”</u></p><ul><li><p><strong>套接字交互</strong></p><ul><li><strong>优点</strong>：1）传输数据为字节级，传输数据可自定义，数据量小效率高；2）传输数据时间短，性能高；3) 适合于客户端和服务器端之间信息实时交互；4) 可以加密,数据安全性强</li><li><strong>缺点</strong>：1) 需对传输的数据进行解析，转化成应用级的数据。</li></ul></li><li><p><strong>远程过程调用（RPC）</strong></p></li></ul><h4 id="4-请问【线程】间同步方式（通信方式）？">4. 请问【线程】间同步方式（通信方式）？</h4><p><img src="https://i.loli.net/2021/06/11/38AqLbJEZnhSPC9.png" alt="image-20210611000107784"></p><p>【<strong>1. Linux下线程通知方式</strong>】</p><ol><li>**互斥量(Mutex)：**采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有⼀个，所以可以保证公共资源不会被多个线程同时访问。<ul><li>⽐如 Java 中的<strong>synchronized 关键词和各种 Lock锁</strong> 都是这种机制。</li></ul></li><li><strong>信号量(Semphares)</strong> ：它允许同⼀时刻多个线程访问同⼀资源，但是需要控制同⼀时刻访问此资源的最大线程数量</li><li><strong>条件变量</strong> : 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级<ul><li>比如Wait/Notify</li></ul></li></ol><p>【<strong>2. Windows下线程通知方式</strong>】</p><ol><li>**全局变量：**需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防编译器对此变量进行优化 ；</li><li><strong>CEvent对象</strong>：CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法；</li><li>**Message消息机制：**常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。</li></ol><h4 id="5-什么时候用多线程-多进程？">5. <strong>什么时候用多线程 / 多进程？</strong></h4><ul><li><strong>需要<u>频繁创建销毁</u>的优先用线程</strong> ：创建和销毁的代价是很难承受的 ；</li><li><strong>需要进行<u>大量计算</u>的优先使用线程</strong> ：此时<strong>耗费很多CPU，切换频繁</strong>，用线程更轻量；</li><li><strong>任务间相关性比较强的用多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单；</li></ul><p>考虑多进程：</p><ul><li>扩展到<strong>多机分布</strong>的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong> ；</li><li>其它一般用多线程比较好</li></ul><h4 id="6-【线程】调度算法？">6. <strong>【线程】调度算法？</strong></h4><p>在资源一定的情况下，调度算法需要在<strong>吞吐量（Throughput）</strong>、<strong>平均响应时间（延迟，Average Response Time）</strong>、<strong>公平性</strong>、**调度引起的额外开销（overhead）**等几个方面做权衡。</p><ol><li><p><strong>先进先出算法（FIFO，First-In-First-Out）</strong></p><ul><li><strong>优点：</strong><ul><li>（:triangular_flag_on_post:*1）<strong>最少的任务切换开销</strong>（因为没有在任务执行过程中发生切换，故任务切换开销为0）</li><li><strong>最大的吞吐量</strong>（因没有任务切换开销，在其他一定的情况下，吞吐量肯定是最大的）</li><li><strong>最朴实的公平性</strong>（先来先做）</li></ul></li><li><strong>缺点：</strong><ul><li>**平均响应时间高：**耗时只需10毫秒的任务若恰巧在耗时1000毫秒的任务后到来，他则需要1010毫秒才能执行完成，绝大部分时间都花在等待被调度。</li></ul></li></ul></li><li><p><strong>最短耗时任务优先算法</strong></p><p>优先调度耗时短的任务，需要预先知道每个任务的耗时情况，这在实际情况中是不大现实的。</p><ul><li>（<strong>优点</strong>）**平均响应时间较低：**这里有一点，因为将时间长的任务无限往后推移，实际计算的平均响应时间的任务都是执行较快的任务，统计出来的平均响应时间必然较低的。</li><li><strong>（缺点</strong>）**耗时长任务饥饿：**耗时长的任务迟迟得不到调度，不公平，容易形成饥饿 。</li><li><strong>（缺点</strong>）<strong>开销大：</strong><u>频繁的任务切换</u>，调度的额外开销大。</li></ul></li><li><p><strong>时间片轮转算法</strong></p><p>给队列中的每个任务一个时间片，第一个任务先执行，时间片到了之后，将此任务放到队列尾部，切换到下个任务执行，<u>解决最短耗时任务优先算法中耗时长任务饥饿的问题</u> 。</p><ul><li><strong>（特点）时间片设置问题：</strong> 算法介于FIFO和SJF之间，若时间片足够<strong>大</strong>，则退化到FIFO ；若分片足够小（假设不考虑任务切换的开销），则任务的完成时间顺序是以耗时从小到大排列。</li><li>（<strong>优点）公平调度</strong>：每个任务都能够得到公平的调度<ul><li>（**优点）不会饥饿：**耗时短的任务即使落在耗时长的任务后面，也能够较快的得到调度执行</li></ul></li><li><strong>（缺点）开销大：</strong><u>任务切换引起的调度开销较大</u>，需要多次切换任务上下文<ul><li><strong>（缺点</strong>）时间片不太好设置</li></ul></li></ul></li><li><p>（:triangular_flag_on_post:*1）<strong>最大最小公平算法</strong></p></li></ol><h4 id="7-【进程】调度算法？">7.<strong>【进程】调度算法？</strong></h4><ul><li>先来先服务调度算法</li><li>短作业(进程)优先调度算法</li><li>时间片轮转法</li><li><strong>多级反馈队列调度算法</strong></li><li>优先权调度算法</li></ul><h4 id="8-CPU上下文切换？有什么类型？线程发生在什么地方？">8. <strong>CPU上下文切换？有什么类型？线程发生在什么地方？</strong></h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/52845869">https://zhuanlan.zhihu.com/p/52845869</a></p></blockquote><ul><li><p><strong>什么是 CPU 上下文</strong> ？</p><p><u>CPU 寄存器和程序计数器</u> 就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前，<strong>必须的依赖环境</strong>。</p><blockquote><ul><li><u>CPU 寄存器</u> 是 CPU 内置的容量小、但速度极快的内存。</li></ul></blockquote></li><li><p><strong>什么是 CPU 上下文切换?</strong></p><p>通常指以下过程：</p><ol><li>前一个任务的 CPU 上下文（也就是 <strong>CPU 寄存器和程序计数器</strong>）保存起来;</li><li>然后加载新任务的上下文到这些寄存器和程序计数器;</li><li>最后再跳转到程序计数器所指的新位置，运行新任务。</li></ol></li><li><p><strong>CPU 上下文切换的类型？</strong></p><p>根据任务的不同，可以分为以下三种类型 :  <strong>进程上下文切换 - 线程上下文切换 - 中断上下文切换</strong> 。</p><ol><li><p><strong>进程上下文切换</strong></p><p>进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。</p><blockquote><ul><li><p>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</p></li><li><p>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</p></li></ul></blockquote><p>从用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成，在<u>这个过程中就发生了 <strong>CPU</strong> 上下文切换（<strong>两</strong>次，用户态-内核态-用户态））</u>。</p><blockquote><p><strong>系统调用</strong> : 查看文件时read()、wirte() 操作就发生了系统调用。</p><p>但是，系统调用过程中，<strong>并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程</strong>。</p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-440bb1699b2fa0f0340b38eabcbd7452_720w.jpg" alt="img"></p><p>而<u><strong>进程</strong>上下文切换</u> ，比系统调用时多了一步：在<strong>保存内核态资源</strong>（当前进程的<u>内核状态和 CPU 寄存器</u>）之前，需要先把该进程的<strong>用户态资源</strong>（<u>虚拟内存、栈等</u>）保存下来。</p></li><li><p><strong>线程上下文调用</strong></p><p>线程是调度的基本单位，而进程则是资源拥有的基本单位。</p><p>【面试高频】发生线程上下文切换的场景</p><ul><li>**前后两个线程属于不同进程。**此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。</li><li>**前后两个线程属于同一个进程。<strong>此时，因为虚拟内存是共享的，所以在切换时，<u>虚拟内存</u>这些资源就保持不动，只需要切换</strong>线程的私有数据（栈、寄存器等)**不共享的数据</li></ul></li><li><p><strong>中断上下文切换</strong></p></li></ol></li></ul><h4 id="9-如何杀死一个进程？-进程终止的方式？">9. <strong>如何杀死一个进程？</strong> 进程终止的方式？</h4><ol><li>linux命令：<code>kill -9 &lt;pid&gt;</code></li><li>接受能导致进程终止的信号：ctrl+c (^C)、SIGINT(SIGINT中断进程)</li><li>main函数的自然返回，<code>return</code></li><li>调用<code>exit</code>函数，属于c的函数库 3、调用<code>_exit</code>函数，属于系统调用</li><li>调用<code>abort</code>函数，异常程序终止，同时发送SIGABRT信号给调用进程</li></ol><h5 id="9-1-终端退出，终端运行的进程会怎么样？">9.1 终端退出，终端运行的进程会怎么样？</h5><ol><li><p>终端在退出时会发送<code>SIGHUP</code>给对应的bash进程，</p></li><li><p>bash进程收到这个信号后首先将它发给session下面的进程</p><blockquote><p>一个session就是一个shell终端会话窗口。</p></blockquote></li><li><p>如果程序没有对SIGHUP信号做特殊处理，那么进程就会随着终端关闭而退出</p></li></ol><h5 id="9-2-怎么让进程后台运行？">9.2 怎么让进程后台运行？</h5><ol><li><code>命令 + &amp;</code> 即可，实际上，这样是将命令放入到一个作业队列中了</li><li><code>ctrl + z</code> 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程</li><li><code>nohup + &amp;</code>，将标准输出和标准错误缺省会被重定向到 nohup.out 文件中，忽略所有挂断（SIGHUP）信号</li><li><code>setsid + 命令</code>，使其父进程编程init进程，不受HUP信号的影响</li><li>将<code>命令+ &amp;</code>放在()括号中，也可以是进程不受HUP信号的影响</li></ol><h4 id="10-外中断和异常的区别？">10. 外中断和异常的区别？</h4><ul><li><p><strong>外中断是指由 CPU 执行指令以外的事件引起</strong>，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p></li><li><p><strong>异常时由 CPU 执行指令的内部事件引起</strong>，如非法操作码、地址越界、算术溢出等。</p></li></ul><h4 id="11-什么是父进程、子进程、进程组、作业和会话？">11. 什么是父进程、子进程、进程组、作业和会话？</h4><ul><li><p><strong>父进程：</strong> 已创建一个或多个子进程的进程 ；</p></li><li><p><strong>子进程：</strong> 由<strong>fork</strong>创建的新进程被称为子进程（child process），函数被调用一次，但返回两次；</p><p>fork之后，操作系统会<strong>复制一个与父进程完全相同的子进程</strong>，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系：</p><ul><li>（1）它们共<strong>享代码空间</strong>，（2）<strong>数据空间是互相独立</strong>的，但<strong>子进程数据空间中的内容是父进程的完整拷贝</strong>，（3）<strong>指令指针也完全相同</strong>，（4）子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同）。</li></ul><p>除了：fork成功，<strong>子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号pid</strong> 。</p></li><li><p><strong>进程组：</strong> 进程组就是多个进程的集合，其中肯定有一个组长，其进程PID等于进程组的PGID ；</p></li><li><p><strong>作业：</strong> shell<strong>分前后台</strong>来控制的不是进程而是作业（job）或者进程组（Process Group）。</p><blockquote><p>一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，shell可以运行一个前台作业和任意多个后台作业，这称为作业控制。、</p></blockquote></li><li><p><strong>会话。</strong> 一个或多个<strong>进程组的集合</strong>，<strong>一个会话可以有一个控制终端</strong>。在xshell或者WinSCP中打开一个窗口就是新建一个会话。</p></li></ul><h4 id="12-什么是守护进程、僵尸进程、孤儿进程？">12. 什么是守护进程、僵尸进程、孤儿进程？</h4><blockquote><p>参考：<a href="https://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/">Linux 之守护进程、僵死进程与孤儿进程</a></p></blockquote><ul><li><p><strong>守护进程</strong></p><p><strong>在后台运行的，没有控制终端与之相连</strong>的进程。它<strong>独立于控制终端</strong>，周期性地执行某种任务。它不需要用户输入就能运行而且提供某种服务，不是<strong>对整个系统就是对某个用户程序</strong>提供服务。</p><ul><li>举例：常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。</li></ul><p>一个守护进程的父进程是init进程，也是一个<u>孤儿进程</u> ，一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。</p></li><li><p><strong>孤儿进程</strong></p><p>一个<strong>父进程退出，而它的一个或多个子进程还在运行</strong>，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p></li><li><p><strong>僵尸进程</strong></p><p>一个进程使用fork创建子进程，如果<strong>子进程退出</strong>，而父进程并没有调用wait或waitpid获取子进程的状态信息（子进程必须<strong>等到父进程捕获到了子进程的退出状态才真正结束</strong>），那么<strong>子进程的进程描述符仍然保存在系统中</strong>。这种进程称之为僵死进程。</p></li></ul><h5 id="11-1-如何避免僵尸进程？">11.1 如何避免僵尸进程？</h5><ul><li><p>通过**signal(SIGCHLD, SIG_IGN)**通知内核对子进程的结束不关心，由内核回收；</p><blockquote><p>如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN); 表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。</p></blockquote></li><li><p>父进程调用wait/waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞；</p><blockquote><p>waitpid可以通过传递WNOHANG使父进程不阻塞立即返回。</p></blockquote></li><li><p>如果父进程很忙可以用signal注册信号处理函数，在信号处理函数调用wait/waitpid等待子进程退出;</p></li><li><p>通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等待回收。</p></li></ul><h2 id="4-3-socket编程">4.3 socket编程</h2><p>暂略</p><h2 id="4-4-内存管理">4.4 内存管理</h2><h4 id="1-介绍一下操作系统的堆和栈？">1. <strong>介绍一下操作系统的堆和栈？</strong></h4><ul><li><p>**栈内存：**栈内存首先是一片内存区域，存储的都是<u>局部变量</u>，栈内存的<u>更新速度很快</u>，因为局部变量的生命周期都很短。</p><blockquote><p>局部变量：方法内的变量，for循环内部定义的也是局部变量等。</p></blockquote></li><li><p><strong>堆内存：<strong>存储的是<u><strong>数组</strong></u>和</strong>对象</strong>（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象）。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</p></li></ul><h5 id="1-1-什么时候会栈溢出？">1.1 什么时候会栈溢出？</h5><p>栈能使用的内存是有限的，一般是 1M~8M，这在编译时就已经决定了，程序运行期间不能再改变。</p><ul><li>如果程序使用的栈内存超出最大值，就会发生栈溢出（Stack Overflow）错误，程序就崩溃了；</li><li>一般常见的情况，如<strong>递归过深</strong></li></ul><h4 id="2-介绍一下什么内存管理？常用的内存管理机制？">2. 介绍一下什么内存管理？常用的内存管理机制？</h4><ul><li><p><strong>内存管理</strong></p><p>操作系统的内存管理主要负责内存的（1）<strong>分配与回收（<strong>malloc 函数：申请内存，free 函数：释放内存），（2）另外地址转换也就是将</strong>逻辑地址转换成相应的物理地址</strong>等功能也是操作系统内存管理做的事情。</p></li><li><p><strong>常用内存管理机制</strong></p><p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为⼀个用户程序分配⼀个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许⼀个程序使用的内存分在离散或者说不相邻的内存中，常见的如<strong>页式管理 和 段式管理</strong>。</p><ol><li><p><strong>块式管理</strong> ： 远古时代的计算机操系统的内存管理方式。<strong>将内存分为⼏个固定大小的块</strong>，每个块中只包含⼀个进程。如果程序运行需要内存的话，操作系统就分配给它⼀块，如果程序运行只需<br>要很小的空间的话，分配的这块内存很大⼀部分⼏乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</p></li><li><p><strong>页式管理</strong> ：把主存分为大小相等且固定的⼀页⼀页的形式，<strong>页较小，相对相⽐于块式管理的划分⼒度更大</strong>，提高了内存利用率，减少了碎片。页式管理通过<u>页表对应逻辑地址和物理地址</u>。</p></li><li><p><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。段式管理把主存分为⼀段段的，<strong>每⼀段的空间⼜要⽐⼀页的空间小很多</strong> 。</p></li></ol><blockquote><p>但是，最重要的是段是有实际意义的，每个段定义了⼀组逻辑信息，例如，有主程段 MAIN、子程序段 X、数据段 D及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</p></blockquote><ol start="4"><li><strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲页，也就是说 段页式管理机制中段与段之间以及段的内部的都是离散的。</li></ol></li></ul><h5 id="2-1-介绍一下逻辑地址和物理地址？">2.1 介绍一下逻辑地址和物理地址？</h5><ul><li>我们编程⼀般只有可能和逻辑地址打交道，⽐如在 C 语⾔中，指针⾥面存储的数值就可以理解成为<strong>内存⾥的⼀个地址</strong>，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。</li><li>物理地址指的是<strong>真实物理内存中地址</strong>，更具体⼀点来说就是内存地址寄存器中的地址。</li></ul><h5 id="2-2-操作系统在内存管理需要做什么？">2.2 操作系统在内存管理需要做什么？</h5><ul><li>内存空间的分配与回收；</li><li>从逻辑上对内存空间进行扩充；</li><li>逻辑地址与物理地址的转换；</li><li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。</li></ul><h4 id="3-介绍一下快表和多级页表？">3. 介绍一下快表和多级页表？</h4><p>在分页内存管理中，很重要的两点是：</p><ol><li>虚拟地址到物理地址的转换要快。</li><li>解决虚拟地址空间大，<strong>页表也会很大</strong>的问题。</li></ol><h5 id="快表介绍">快表介绍</h5><p>快表理解为⼀种<strong>特殊的高速缓冲存储器</strong>（Cache），其中的<strong>内容是页表的⼀部分或者全部内容</strong>。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。</p><blockquote><p>但有时快表不命中要访问两次缓存，不过总体还是提高了性能。</p></blockquote><h5 id="多级页表介绍">多级页表介绍</h5><p>引⼊多级页表的主要⽬的是为了 <u><strong>避免把全部页表⼀直放在内存中占用过多空间</strong></u>，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表<strong>属于时间换空间</strong>的典型场景。</p><h4 id="4-分页机制和分段机制的共同点和区别-？">4. 分页机制和分段机制的共同点和区别 ？</h4><ol><li>共同点 ：<ul><li>分页机制和分段机制都是为了<strong>提高内存利用率，较少内存碎片</strong>。</li><li>页和段都是<strong>离散存储</strong>的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li></ul></li><li>区别 ：<ul><li><strong>页的大小是固定的</strong>，由操作系统决定；<strong>而段的大小不固定</strong>，取决于我们当前运行的程序。</li><li>分页仅仅是为了<strong>满⾜操作系统内存管理</strong>的需求，而<strong>段是逻辑信息的单位，在程序中可以体现为代码段，数据段</strong>，能够更好满⾜用户的需要。</li></ul></li></ol><h4 id="5-【待扩充】CPU-寻址了解吗-为什么需要虚拟地址空间">5. 【待扩充】CPU 寻址了解吗?为什么需要虚拟地址空间?</h4><ul><li><p>现代处理器使用的是⼀种称为 虚拟寻址(Virtual Addressing) 的寻址⽅式。使用虚拟寻址，<strong>CPU 需要虚拟地址翻译成物理地址</strong>，这样才能访问到真实的物理内存。</p><blockquote><p>实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有⼀个被称为 内存管理单元（Memory Management Unit, MMU） 的硬件。</p></blockquote></li><li><p><strong>如果直接把物理地址暴露出来的话会带来严重问题</strong>，⽐如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</p></li></ul><h4 id="6-如果系统中具有快表后，那么地址的转换过程变成什么样了？">6. 如果系统中具有快表后，那么地址的转换过程变成什么样了？</h4><blockquote><p>简单来说：cup计算页号 → 快表查询是否有该页号 → 否则页表查询</p></blockquote><ol><li><strong>计算页号和页偏移量。</strong> CPU给出逻辑地址，由某个硬件算得页号、页内偏移量；</li><li><strong>快表中查找内存块号。</strong> 将页号与快表中的所有页号进行比较，如果找到匹配的页号，则直接从中取出该页对应的内存块号，再<strong>将内存块号与页内偏移量拼接形成物理地址</strong>；</li><li><strong>页表中查找内存块号。</strong> 如果快表中查找不存在，访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。</li></ol><h4 id="7-进程内存分配动态分区算法？">7. 进程内存分配动态分区算法？</h4><ol><li><p><strong>首次适应法。</strong></p><ul><li><p><strong>算法思想</strong>：每次都从低地址开始查找，找到第一个能满足大小的空闲分区；</p></li><li><p><strong>实现方式</strong>：空闲分区以<strong>地址递增</strong>的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分[表)，找到大小能满足要求的第-一个空闲分区。</p></li><li><p><strong>优点：</strong> 综合性能最好，开销小。</p><p><img src="https://i.loli.net/2021/06/10/PEpjmDW52eqGl4f.png" alt="image-20210610231604639"></p></li></ul></li><li><p><strong>最佳适应法。</strong></p><ul><li>**算法思想：**为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区；</li><li><strong>实现方式：</strong> 空闲分区按<strong>容量递增</strong>次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</li><li><strong>优点：</strong> 会有更多的大分区被保留下来，<u>更能满足大进程需求</u></li><li><strong>缺点：</strong> 产生很多太小的、难以利用的碎片，算法开销大</li></ul></li><li><p><strong>最坏适应法。</strong></p><ul><li><strong>算法思想：</strong> 为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</li><li><strong>实现方式：<strong>空闲分区按</strong>容量递减</strong>次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</li><li><strong>优点：</strong> 可以减少难以利用的小碎片</li><li><strong>缺点：</strong> 大分区容易被用完，不利于大进程，算法开销大</li></ul></li><li><p><strong>领近适应法。</strong></p><ul><li><strong>算法思想：</strong> 首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。</li><li><strong>实现方式：<strong>空闲分区以</strong>地址递增</strong>的顺序排列(可排成一个<strong>循环链表</strong>)。每次分配内存时<u>从上次查找结束的位置开始</u> ，查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</li><li><strong>优点：</strong> 算法开销小</li></ul></li></ol><h4 id="8-什么是内存覆盖和内存交换？">8. 什么是内存覆盖和内存交换？</h4><ul><li><strong>内存覆盖</strong><ul><li><strong>思想：</strong> 把用户空间分成为一个<strong>固定区</strong>和<strong>若干个覆盖区</strong>。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。</li><li><strong>特点：</strong> <strong>打破</strong>了必须将<strong>一个进程的全部信息装入内存后才能运行</strong>的限制 。</li></ul></li><li><strong>内存交换</strong><ul><li><strong>思想：</strong> <u>内存空间紧张</u> 时，系统将内存中<strong>某些进程暂时换出外存</strong>，把外存中某些已<strong>具备运行条件的进程换入内存</strong>。</li></ul></li></ul><h2 id="4-5-虚拟内存">4.5 虚拟内存</h2><h4 id="0-什么是虚拟技术-？从时间和空间两方面来说。">0. 什么是虚拟技术 ？从时间和空间两方面来说。</h4><p>虚拟技术<strong>把一个物理实体转换为多个逻辑实体</strong> ：</p><ul><li><strong>时分复用技术</strong> ： 如多个进程能在同一个处理器上并发执行使用了时分复用技术，让<u>每个进程轮流占用处理器，每次只执行一小个时间片并快速切换</u> ；</li><li>**空分复用技术： ** <u>物理内存抽象为地址空间，每个进程都有各自的地址空间</u>。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</li></ul><h4 id="1-介绍一下局部性原理吧？">1. 介绍一下局部性原理吧？</h4><p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装⼊部分程序到内存就开始运行。</p><p>局部性原理表现在以下两个⽅面：</p><ol><li><strong>时间局部性 ：<strong>如果程序中的</strong>某条指令</strong>⼀旦执行，不久以后<strong>该指令可能再次执</strong>行；如果某数据被访问过，不久以后该数据可能再次被访问。产⽣时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li></ol><blockquote><p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。</p></blockquote><ol start="2"><li><strong>空间局部性 ：<strong>⼀旦程序访问了</strong>某个存储单元</strong>，在不久之后，其<strong>附近的存储单</strong>元也将被访问，即程序在⼀段时间内所访问的地址，可能集中在⼀定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也⼀般是以向量、数组、表等形式簇聚存储的。</li></ol><blockquote><p>空间局部性通常是使用教大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。</p></blockquote><p>虚拟内存技术实际上就是建⽴了 “内存⼀外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p><h4 id="2-介绍一下，什么是虚拟内存？页式存储？">2. <strong>介绍一下，什么是虚拟内存？页式存储？</strong></h4><ul><li><p><strong>虚拟内存</strong></p><p>虚拟内存是一种存储机制，可为用户提供一个拥有很大主内存的错觉。<strong>通过将辅存的一部分作为主存</strong>来完成。在虚拟内存中，用户可以存储比可用主内存更大的进程。</p><blockquote><p>每个进程创建加载的时候，会被分配一个大小为4G的连续的虚拟地址空间，仅仅是每个进程“认为”自己拥有4G的内存。等到进程真正运行的时候，<strong>需要某些数据并且数据不在物理内存中，才会触发缺页异常，进行磁盘数据拷贝到物理内存中</strong></p></blockquote><p><img src="https://i.loli.net/2021/04/20/NO5zyG824P9FSHs.jpg" alt="img"></p></li><li><p><strong>页式存储</strong></p><p>大部分虚拟存储系统采用的是一种称为**分页（paging）**的技术。这种方式叫做虚拟页式存储管理。</p><ul><li><p>物理内存空间划分为固定大小的内存块，称为物理页面，或者是<strong>页框</strong>（page frame）</p></li><li><p>虚拟地址空间也划分成大小相同的块，称为虚拟页面，或者简称<strong>页面</strong>（page）</p><blockquote><p>页表：将<strong>虚拟页面映射为</strong>相应的<strong>物理页面</strong>。</p></blockquote></li></ul></li></ul><h4 id="3-虚拟内存的技术实现-？">3. 虚拟内存的技术实现 ？</h4><p>虚拟内存的实现需要建⽴在离散分配的内存管理⽅式的基础上。 虚拟内存的实现有以下三种⽅式：</p><ol><li><strong>请求分页存储管理</strong> ：建⽴在分页管理之上，为了支持虚拟存储器功能而增加了<strong>请求调页功能和页面置换功能</strong>。请求分页是⽬前最常用的⼀种实现虚拟存储器的⽅法。请求分页存储管理系统中，在作业开始运行之前，仅装⼊当前要执行的部分页即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调⼊到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li><li><strong>请求分段存储管理 ：<strong>建⽴在分段存储管理之上，增加了</strong>请求调段功能、分段置换功能</strong>。请求分段储存管理⽅式就如同请求分页储存管理⽅式⼀样，在作业开始运行之前，仅装⼊当前要执行的部分段即可运行；在执行过程中，可使用请求调⼊中断动态装⼊要访问但⼜不在内存的程序段；当内存空间已满，而⼜需要装⼊新的段时，根据置换功能适当调出某个段，以便腾出空间而装⼊新的段。</li><li><strong>请求段页式存储管理</strong></li></ol><h4 id="4-请你介绍一下页面置换算法？">4. 请你介绍一下页面置换算法？</h4><p>当发⽣缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择⼀个页面将其移出内存，以便为即将调⼊的页面让出空间。用来选择淘汰哪⼀页的规则叫做页面置换算法，我们可以把页<br>⾯置换算法看成是淘汰页面的规则。</p><ul><li><p>**OPT （最佳页面置换算法） ：**最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最⻓时间内不再被访问的页面,这样可以保证获得最低的缺页率。</p><blockquote><p>但由于⼈们⽬前无法预知进程在内存下的若千页面中哪个是未来最⻓时间内不再被访问的，因⽽该算法无法实现。⼀般作为衡量其他置换算法的⽅法。</p></blockquote></li><li><p><strong>FIFO（First In First Out） （先进先出页面置换算法）</strong> : 总是淘汰最先进⼊内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</p></li><li><p><strong>LRU （Least Currently Used）（最近最久未使用页面置换算法）</strong> ：LRU算法赋予每个页面⼀个访问字段，用来记录⼀个页面⾃上次被访问以来所经历的时间 T，当须淘汰⼀个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</p></li><li><p><strong>LFU （Least Frequently Used）（最少使用页面置换算法）</strong> : 该置换算法选择在前时期使用最少的页面作为淘汰页。</p></li></ul><h4 id="5-你怎么理解操作系统里的内存碎片，有什么解决办法？">5. <strong>你怎么理解操作系统里的内存碎片，有什么解决办法？</strong></h4><p>内存碎片分为：内部碎片和外部碎片。</p><ul><li><p><strong>内部碎片：</strong> 已经<strong>被分配</strong>出去（能明确指出属于哪个进程）却<strong>不能被利用</strong>的内存空间；</p><blockquote><p><strong>内存泄漏</strong>：不再会被使用的<strong>对象</strong>的内存不能被<strong>回收</strong> 。</p></blockquote></li><li><p><strong>外部碎片：</strong> 还<strong>没有被分配</strong>出去（不属于任何进程），但由于<strong>太小了无法分配</strong>，给申请内存空间的新进程的内存空闲区域。</p></li></ul><h4 id="6-什么是内存抖动？">6. 什么是内存抖动？</h4><ul><li><strong>现象：<strong>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种</strong>频繁的页面调度行为</strong>称为抖动，或颠簸；</li><li><strong>原因：</strong> 程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够) ；</li><li><strong>解决：</strong> 分配更多的物理块</li></ul><h2 id="4-6-并发和死锁">4.6 并发和死锁</h2><h4 id="0-介绍几种典型的锁？">0. 介绍几种典型的锁？</h4><ol><li><strong>读写锁。</strong> 可以同时读，但写必须互斥，只允许一个写；</li><li><strong>互斥锁。</strong> 一次只能一个线程拥有锁，其它只能等待；</li><li><strong>条件变量：</strong>  互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定；而条件变量<strong>通过允许线程阻塞和等待另一个线程发送信号</strong>的方法弥补了互斥锁的不足；</li><li><strong>自旋锁。</strong> 如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。</li></ol><h4 id="1-【重点】什么是线程死锁？什么情况下会发生死锁？解决死锁的策略有哪些？">1. 【<strong>重点</strong>】<strong>什么是线程死锁？什么情况下会发生死锁？解决死锁的策略有哪些？</strong></h4><ul><li><p><strong>什么是死锁</strong></p><p>死锁是指<u>两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</u>，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p></li><li><p><strong>发生死锁的条件</strong></p><ol><li>**互斥：**一个资源只能给一个进程使用；</li><li><strong>占有并等待</strong>：进程持有资源并申请新资源，在申请到需要的资源之前，<u>已有的资源不释放</u>；</li><li><strong>不可剥夺</strong>：进程申请到的资源在使用完之前，不可以被其他进程使用；</li><li>**循环等待：**各个进程的资源请求形成首尾连接循环等待。</li></ol></li><li><p><strong>解决方法：预防，避免，检测与恢复三种</strong></p><ol><li><strong>预防：破坏死锁会发生的四个条件</strong><ul><li>破坏互斥：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的</li><li>**<u>破坏请求和保持</u>：**实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源；</li><li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进⼀步申请其他资源时，<strong>如果申请不到</strong>，可以<strong>主动释放它占有的资源</strong>。</li><li><strong><u>破坏循环等待：</u></strong> <strong>资源分类标号，进行有序分配</strong></li></ul></li><li><strong>避免：</strong> <u>它不限制进程有关申请资源的命令</u>，而是对进程所发出的每一个申请资源命令加以<strong>动态地检查</strong>，并根据检查结果决定是否进行资源分配<ul><li><strong>安全序列</strong>：找到一种能让进程安全执行完的有序序列<code>&#123;P1，P2，...，Pn&#125;</code></li><li>**银行家算法：（待补充）**系统在为进程分配资源之前，首先计算此次资源分配的安全性，<strong>如果是安全的，则进行分配</strong>；如果这次分配会导致进入不安全状态，不进行分配。</li></ul></li><li><strong>恢复：</strong> 用<u>资源分配图、进程等待图</u>来协助这种检测出死锁，然后进行恢复。<ul><li>系统重新启动，但代价很大</li><li><strong>撤消参与死锁的全部或部分进程，剥夺资源</strong></li></ul></li></ol></li></ul><h4 id="2-（待补充）请你解释一下，通常系统CPU比较高是什么原因？">2. （待补充）<strong>请你解释一下，通常系统CPU比较高是什么原因？</strong></h4><ol><li>首先查看是哪些进程的CPU占用率最高</li></ol><h4 id="3-说一下NIO，BIO，AIO区别">3. <strong>说一下NIO，BIO，AIO区别?</strong></h4><blockquote><p>参考：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/basis/IO%E6%A8%A1%E5%9E%8B.md">JAVaGuide</a></p></blockquote><p>【<strong>BIO（同步阻塞）</strong>】</p><ul><li><p><strong>BIO</strong>：同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把<u> </u>。</p><img src="https://i.loli.net/2021/05/06/HqJyg2Ykxtm6Wba.png" alt="图源：《深入拆解Tomcat & Jetty》" style="zoom: 67%;" /></li></ul><p>【<strong>NIO（同步非阻塞）</strong>】</p><p>NIO 本身是基于 <u>事件驱动</u> 的思想来实现的，其目的就是解决 BIO 的大并发问题：</p><ul><li>BIO 模型中，<strong>如果需要并发处理多个 I/O 请求，那就需要多线程来支持</strong>；</li><li><strong>IO 多路复用模型</strong>中，线程首先发起 <u>select 调用，询问内核数据是否准备就绪</u>，等内核把数据准备好了，用户线程再发起 <strong>read 调用</strong>。<strong>read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</strong></li></ul><img src="https://i.loli.net/2021/05/06/9iJE3IaVOW2xAwh.png" alt="img" style="zoom:67%;" /><p>【<strong>AIO（异步非阻塞）</strong>】</p><blockquote><p>Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型 。</p></blockquote><p><strong>AIO：</strong> 异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。</p><blockquote><p>异步 IO 是基于事件和<strong>回调机制</strong>实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p></blockquote><p><img src="https://i.loli.net/2021/05/06/uIcCQeBUliqT2gk.png" alt="img" style="zoom:67%;" />0.</p><h4 id="4-【重点】介绍一下select，poll，epoll-原理？">4. 【重点】<strong>介绍一下select，poll，epoll 原理？</strong></h4><blockquote><p><strong>参考</strong></p><ol><li><a href="https://blog.csdn.net/jiejiemcu/article/details/107083724">select、poll、epoll的原理与区别</a></li></ol></blockquote><h5 id="4-1-从阻塞I-O-非阻塞I-O说起">4.1 从阻塞I/O &amp; 非阻塞I/O说起</h5><ul><li><p><strong>阻塞I/O</strong></p><blockquote><p>在linux中，默认情况下所有的socket都是阻塞的。</p></blockquote><p><img src="https://i.loli.net/2021/05/17/aJFOtPvy4xiMKkI.png" alt="image-20210517125922790"></p><ol><li>当用户进程调用了<code>read()/recvfrom()</code>等系统调用函数，它会进入内核空间中；</li><li>当这个网络I/O没有数据的时候，内核就要等待数据的到来，此时<strong>用户进程被阻塞</strong>；</li><li>当内核空间的数据准备好了，它就会将数据从<strong>内核空间中拷贝到用户空间</strong>；</li><li>用户进程才解除阻塞的的状态，重新运行读取数据。</li></ol></li><li><p><strong>非阻塞I/O</strong></p><blockquote><p>linux下，可以通过设置socket使其变为非阻塞模式，这种情况下，当内核空间并无数据的时候，它会<u>马上返回结果而不会阻塞</u>。</p></blockquote><p><img src="https://i.loli.net/2021/05/17/hW2DtsGBiU8AnHN.png" alt="image-20210517130232559"></p><ol><li>当用户进程调用了<code>read()/recvfrom()</code>等系统调用函数，它会进入内核空间中；</li><li>如果内核空间中的数据还没有准备好，那么它并不会阻塞用户进程，而是<strong>立刻返回一个error</strong>；</li><li>对于应用进程来说，它发起一个<code>read()</code>操作后，并不需要等待，那么它可以再次调用read()/recvfrom()等函数；</li><li>当内核空间的数据准备好了，它就会将数据从内核空间中拷贝到用户空间；</li><li>用户进程才解除阻塞的的状态，重新运行读取数据。</li></ol></li></ul><blockquote><p>多路复用I/O就是我们说的<code>select，poll，epoll</code>等操作，复用的好处就在于<strong>单个进程</strong>就可以同时处理<strong>多个</strong>网络连接的I/O，能实现这种功能的原理就是<code>select、poll、epoll</code>等函数会不断的<strong>轮询</strong>它们所负责的所有<code>socket</code>，当某个<code>socket</code>有数据到达了，就通知用户进程。</p></blockquote><h5 id="4-2-select原理">4.2 select原理</h5><blockquote><p>更加深刻对比理解：<a href="https://www.cnblogs.com/skyfsm/p/7079458.html">Linux编程之select</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>select函数监视的文件socket描述符分3类，分别是writefds、readfds、和exceptfds；</li><li>调用后select<strong>函数会阻塞（不是线程）</strong>，直到有描述符就绪（有数据 <u>可read、可write、except、超时timeout</u>），函数返回。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">select(socket);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">sockets = select(); <span class="comment">// 还是要从内核拷贝到用户</span></span><br><span class="line"><span class="keyword">for</span>(socket in sockets) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(can_read(socket)) </span><br><span class="line">&#123;</span><br><span class="line">read(socket, buffer);</span><br><span class="line">process(buffer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细执行原理如下：</p><ol><li><p>用户首先将需要进行IO操作的<strong>socket添加到select</strong>中，然后<strong>阻塞函数select（不是线程）等待系统调用返回</strong>；</p></li><li><p><strong>当数据到达时，socket被激活，select函数返回</strong>，会唤醒其等待队列上睡眠的内核进程，即在<strong>socket可读写时唤醒</strong>，或者在<strong>超时</strong>后唤醒；</p><blockquote><p>每次调用<code>select</code>查看fd，都需要把fd集合拷贝进行系统调用<strong>陷入内核态</strong> 。</p></blockquote></li><li><p>返回<code>select()</code>函数的调用结果给用户进程，<strong>返回就绪socket描述符的数目</strong>，超时返回0，出错返回-1；</p></li><li><p>在select()函数返回后<strong>还是需要轮询</strong>去找到就绪的socket描述符的（<u>将此前传入内核空间的<code>fd_set</code>拷贝到用户空间</u>），此时用户进程才可以去操作socket；</p></li><li><p>进程调用<code>read() / recvfrom()</code> 读取数据 。</p></li></ol><p><strong>select优点 ：</strong></p><blockquote><p>从流程上来看，使用select函数进行IO请求和<strong>同步阻塞模型</strong>没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。</p><p><strong>那为什么还要使用select？</strong></p></blockquote><ul><li>使用select以后最大的优势是用户可以在一<strong>个线程内同时处理多个socket</strong>的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的；</li><li>而在<strong>同步阻塞模型</strong>中，必须通过<strong>多线程的方式才能达到这个目的</strong>。</li></ul><p><strong>select缺点 ：</strong></p><ol><li><p><strong>描述符数量：</strong><code>select</code>支持的文件描述符数量太小了，默认是<code>1024</code>  ；</p></li><li><p><strong>系统开销：<strong>每次调用<code>select</code>都需要把fd集合拷贝进行系统调用</strong>陷入内核态</strong>，这个开销在fd很多时会很大 ；</p></li><li><p><strong>二次轮询：</strong><code>select</code>需要二次查询拷贝所有文件描述fd_set进行遍历查看是否有描述符准备就绪。</p></li></ol><h5 id="4-3-poll原理">4.3 poll原理</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 <strong>pollfd指针</strong>实现。</p><blockquote><p>poll使用<strong>链表</strong>维护这些socket描述符，而select使用的是<strong>数组</strong>（位图）。</p></blockquote><p>其他的都差不多和select()函数一样，poll()函数返回后，需要轮询pollfd来获取就绪的描述符，根据描述符的状态进行处理，<u>但是poll没有最大文件描述符数量的限制</u>。</p><p><strong>poll缺点 ：</strong></p><p>解决了selec第一个缺点（文件描述符数量太少），但是依旧存在后面两个缺点。</p><ol start="2"><li><p><strong>系统开销：<strong>每次调用<code>poll</code>都需要把fd集合拷贝进行系统调用</strong>陷入内核态</strong>，这个开销在fd很多时会很大 ；</p></li><li><p><strong>二次轮询：</strong><code>poll</code>需要二次查询拷贝所有文件描述fd_set进行遍历查看是否有描述符准备就绪。</p></li></ol><h5 id="4-3-epoll原理">4.3 epoll原理</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll只有epoll_create()、epoll_ctl()、epoll_wait() 3个系统调用函数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>epoll_create</code></p><p>创建一个epoll文件描述符的epfd（或者称之为句柄）, <strong>epoll使用一个epfd文件描述符管理多个socket描述符。</strong></p><blockquote><p>当创建好epoll句柄后，它就是会占用一个fd值，必须调用close()关闭，否则可能导致fd被耗尽 。</p></blockquote></li><li><p><code>epoll_ctl</code></p><p>该函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，以及删除事件。相关参数：</p><blockquote><p>使用<strong>红黑树</strong>对监视的文件描述符进行：添加、修改、删除等。</p></blockquote><ul><li><p><code>epdf</code>：由epoll_create()函数返回的epoll文件描述符（句柄）；</p></li><li><p><code>op</code> ： op是操作的选项，注册要监听的目标socket描述符fd到epoll句柄中 ；修改epoll句柄已经注册的fd的监听事件；从epoll句柄删除已经注册的socket描述符 ；</p></li><li><p><code>fd</code>：指定监听的socket描述符；</p></li><li><p><code>event</code>：事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>        *ptr;</span><br><span class="line">    <span class="keyword">int</span>          fd;</span><br><span class="line">    <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>epoll_wait()</code></p><p>epoll_wait()函数的作用就是等待监听的事件的发生，<strong>类似于调用select()函数。</strong> 相关参数如下：</p><blockquote><p>函数的返回值表示需要处理的事件数目，如返回0表示已超时。</p></blockquote><ul><li><code>events</code>：用来从内核得到事件的集合。</li><li><code>maxevents</code> ：告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的指定的size。</li><li><code>timeout</code>：超时时间。</li></ul></li></ul><p><strong>epoll高效运行过程</strong></p><blockquote><p>参考：<a href="https://www.jianshu.com/p/31cdfd6f5a48">彻底搞懂epoll高效运行的原理</a></p></blockquote><ol><li><p>执行<code>epoll_create</code>会在内核的高速cache区中建立一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。接着用户执行<code>epoll_ctl</code> 函数添加文件描述符会在红黑树上增加相应的结点。</p><blockquote><p>select：创建3个文件描述符集并<u>拷贝到内核</u>中 ; poll：将传入的struct pollfd结构体数组<u>拷贝到内核</u>中进行监听。</p></blockquote></li><li><p>调用<code>epoll_wait</code>  <strong>阻塞，等待可读事件</strong>；</p></li><li><p>内核在检测到满足条件的socket描述符会调用<strong>回调函数</strong> ，回调函数将文件描述符<strong>放在就绪链表</strong>中 ；</p><blockquote><p>而select/poll 都需要 ，遍历所有文件描述符fd_set 。</p><p>而执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，只需调用回调函数。</p></blockquote></li><li><p>epoll_wait只用观察就绪链表中有无数据即可，最后将链表的数据<strong>返回给读写事件数组events</strong> &amp;<strong>返回就绪的数量</strong>，只用<strong>遍历events</strong>依次处理即可。</p><blockquote><p>这里返回的文件描述符是通过<strong>mmap让内核和用户空间共享同一块内存</strong>实现传递的，减少了不必要的拷贝。</p><p>而select/poll <u>只返回socket就绪数目</u>， 还需要将<strong>所有的文件描述符再次从内核→用户</strong>，遍历就绪的socket文件描述符。</p></blockquote></li></ol><h5 id="4-4-select，poll，epoll-各自区别？">4.4 select，poll，epoll 各自区别？</h5><blockquote><p>不错的文章：<a href="https://www.codenong.com/cs105364662/">https://www.codenong.com/cs105364662/</a></p></blockquote><p><strong>相同点：</strong></p><ul><li><p>select，poll，epoll 都是 IO 多路复用的机制（NIO？yes）；</p><blockquote><p>IO 多路复用的本质是通过一种机制，让<strong>单个进程可以监视多个描述符</strong>，当发现某个描述符就绪之后，能够通知程序进行相应的操作。</p></blockquote></li><li><p>select，poll，epoll 都是同步 IO 。</p></li></ul><p><strong>不同点：</strong></p><img src="https://i.loli.net/2021/05/17/xj2ncf8VLbAGrwh.png" alt="image-20210517125057917" style="zoom: 80%;" /><ol><li><strong>IO 效率：</strong>（1）select 只知道<u>有 IO 事件发生，却不知道是哪几个流</u>，只能采取轮询所有流（ fd_set 集合）的方式，故其具有 O(n) 的无差别轮询复杂度，处理的流越多，无差别轮询时间就越长；（2）poll 与 select 并无区别，它的时间复杂度也是O(n)；（3）epoll 会将哪个流发生了怎样的 IO 事件通知我们（当描述符就绪时，<u>系统注册的回调函数会被调用</u>，将就绪描述符放到 readyList 里面），<strong>它是事件驱动的</strong>，其时间复杂度为 O(1)；</li><li>**操作方式：**select 和 poll 都是采取遍历的方式，而 epoll 则是采取了回调的方式；</li><li>**底层实现：**select 的底层实现为数组，poll 的底层实现为链表；而 epoll 的底层实现为红黑树；</li><li>**最大连接数：**select 的最大连接数为 1024 或 2048；而 poll 和 epoll 是无上限的；</li><li>**对描述符的拷贝：**select 和 poll 每次被调用时都会把描述符集合从用户态拷贝到内核态，而 epoll 在调用 epoll_ctl 时会拷贝进内核并保存，之后每次 epoll_wait 时不会拷贝；</li><li><strong>性能：</strong><u>epoll 在绝大多数情况下性能远超 select 和 poll</u>，但在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，因为 epoll 的通知机制需要很多函数回调 。</li></ol><h5 id="4-5-ET-LT-模式介绍？各自优缺点？">4.5 ET , LT 模式介绍？各自优缺点？</h5><blockquote><p>参考：<a href="https://cloud.tencent.com/developer/article/1636224">https://cloud.tencent.com/developer/article/1636224</a></p></blockquote><ul><li><p><strong>边缘触发模式</strong>（<strong>E</strong>dge <strong>T</strong>rigger，ET），只有一个事件从无到有才会触发；</p><blockquote><ol><li>低电平 =&gt; 高电平 。</li></ol></blockquote></li><li><p><strong>水平触发模式</strong>（<strong>L</strong>evel <strong>T</strong>rigger，LT），一个事件只要有，就会一直触发。</p><blockquote><ol><li>低电平 =&gt; 高电平 ; 2. 处于高电平状态</li></ol></blockquote></li><li><p><strong>举例说明</strong></p><ul><li><strong>socket 的读事件</strong><ul><li><strong>LT模式</strong>，只要 socket 上有未读完的数据，就会一直产生 EPOLLIN 事件；</li><li><strong>ET模式</strong>，socket 上每新来一次数据就会触发一次，如果上一次触发后，<strong>未将 socket 上的数据读完，也不会再触发</strong>，除非再新来一次数据。</li></ul></li><li><strong>对于 socket 写事件</strong><ul><li>**LT模式，**如果 socket 的 TCP 窗口一直不饱和，会一直触发 EPOLLOUT 事件；</li><li>**ET模式，**只会触发一次，除非 TCP 窗口由不饱和变成饱和再一次变成不饱和，才会再次触发 EPOLLOUT 事件。</li></ul></li></ul></li><li><p><strong>优缺点</strong></p><ul><li>使用 LT 模式，我们可以自由决定<strong>每次收取多少字节（对于普通 socket）或何时接收连接</strong>（对于侦听 socket），但是可能会<strong>导致多次触发</strong>；</li><li>使用 ET 模式，我们必须<strong>每次都要将数据收完</strong>（对于普通 socket）或必须理解调用 accept 接收连接（对于侦听socket），其<strong>优点是触发次数少</strong>。</li></ul></li></ul><h4 id="5-操作系统底层是怎么实现原子操作的？">5. 操作系统底层是怎么实现原子操作的？</h4><p>处理器使用基于对<strong>缓存加锁</strong>或<strong>总线加锁</strong>的方式，来实现多处理器之间的原子操作。</p><ol><li><p><strong>总线锁：</strong> 处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器<strong>可以独占共享内存</strong>；</p><blockquote><p><strong>总线锁定把CPU和内存之间的通信锁住了</strong>，这使得锁定期间，其他处理器不能操作其他内存地址的数据</p></blockquote></li><li><p>**缓存锁：**相比总线锁，缓存锁即降低了锁的力度。核心机制是基于<u>缓存一致性协议</u>来实现的。</p><blockquote><p>详细参考：<a href="https://www.jianshu.com/p/06717ac8312c">JMM基础（总线锁、缓存锁、MESI缓存一致性协议、CPU 层面的内存屏障）</a></p></blockquote></li></ol><h2 id="4-7-其它">4.7 其它</h2><h4 id="1-常见的磁盘调度算法？">1. 常见的磁盘调度算法？</h4><p>读写一个磁盘块的时间的影响因素有：</p><ul><li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li><li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li><li>实际的数据传输时间</li></ul><p>其中，<strong>寻道时间最长</strong>，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><ol><li><p><strong>先来先服务。</strong> 按照磁盘请求的顺序进行调度。</p><ul><li>**优点 ：**公平、简单；</li><li>**缺点：**未对寻道做任何优化，使平均寻道时间可能较长。</li></ul></li><li><p><strong>最短寻道优先</strong>。 优先调度与当前磁头所在磁道距离最近的磁道。</p><ul><li><strong>优点：</strong> 平均寻道时间比较低；</li><li>**缺点：**不公平，如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去。</li></ul></li><li><p><strong>电梯扫描算法。</strong> 电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p><ul><li><strong>优点：</strong> 性能较好，同时不会存在饥饿现象。</li></ul></li></ol><h4 id="2-服务器高并发的解决方案你知道多少？">2. 服务器高并发的解决方案你知道多少？</h4><ul><li><strong>应用数据与静态资源分离 ：<strong>将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从</strong>静态资源服务器中返回静态资源</strong>，从<strong>主服务器中返回应用数据</strong>；</li><li><strong>客户端缓存</strong> ：例如先生成静态页面，然后用ajax异步请求获取动态数据；</li><li><strong>集群和分布式</strong> ：使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度；</li><li><strong>反向代理：</strong> 在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</li></ul><h1>五、MySQL</h1><h2 id="5-1-MySQL基本">5.1 MySQL基本</h2><h4 id="0-关系型数据库和非关系数据库的区别？">0. 关系型数据库和非关系数据库的区别？</h4><ul><li><strong>关系型数据库的优点</strong><ul><li>容易理解，因为它采用了关系模型来组织数据；</li><li>可以<strong>保持数据的一致性</strong>；</li><li>数据<strong>更新的开销比较小</strong>；</li><li><strong>支持复杂查询</strong>（带where子句的查询）。</li></ul></li><li><strong>非关系型数据库的优点</strong><ul><li>不需要经过SQL层的解析，<strong>读写效率高</strong>；</li><li><strong>基于键值对</strong>，数据的扩展性很好；</li><li><strong>支持多种类型数据的存储</strong>，如图片，文档等等。</li></ul></li></ul><h4 id="1-介绍一下数据库三范式？">1. <strong>介绍一下数据库三范式？</strong></h4><blockquote><p>参考：<a href="https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html">https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html</a></p></blockquote><ul><li><p><strong>第一范式：</strong> 数据库表中的<u>所有字段值都是不可分解的原子值</u> 。</p><blockquote><p>数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要<u>将“地址”这个属性重新拆分为省份、城市、详细地址</u>等多个部分进行存储。</p><p><img src="https://i.loli.net/2021/05/03/NiPm9KajxLXpRQf.png" alt="img"></p></blockquote></li><li><p><strong>第二范式：</strong> 第二范式基于第一范式，且要求：<u>数据库表中的每一列都和主键相关，且不能只与主键的某一部分相关</u>（主要针对联合主键而言）, 即<strong>不存在部分依赖</strong>；</p><blockquote><p>下表是以：<u>订单编号&amp;商品编号</u>作为联合主键。这样在该<strong>表中商品名称、单位、商品价格等信息不与该表的订单编号相关</strong>，而仅仅是与商品编号相关。</p><p><img src="https://i.loli.net/2021/05/03/RoCLmOBcgJKhvyx.png" alt="img"></p><p>所以根据第二范式，将它进行拆分三个表：</p><p><img src="https://i.loli.net/2021/05/03/TnN8t5k3lrWxIgp.png" alt="img"></p></blockquote></li><li><p><strong>第三范式：</strong> 基于第二范式，数据表中的每一列数据都和主键<strong>直接相关</strong>，即<strong>不存在传递依赖</strong>；</p><blockquote><p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p><p><img src="https://pic002.cnblogs.com/images/2012/270324/2012040114105477.png" alt="img"></p></blockquote></li></ul><h4 id="2-MySQL数据库引擎有哪些？">2. <strong>MySQL数据库引擎有哪些？</strong></h4><blockquote><p>MySQL查看所有的数据引擎：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engines;</span><br></pre></td></tr></table></figure></blockquote><p>MySQL常用引擎包括：<code>MYISAM</code>、<code>Innodb</code>、<code>Memory</code>、<code>MERGE</code>，</p><ul><li><p><strong><code>MYISAM</code></strong> （读：my+i+son）</p><p>以select、insert为主的应用基本上可以使用这引擎。</p><ul><li><strong>优点：</strong> <strong>全表锁</strong>，拥有较高的执行速度，占用空间小；</li><li><strong>缺点</strong> ：不支持事务，不支持外键，并发性能差。</li></ul></li><li><p>**<code>Innodb</code> **</p><p>Innodb引擎提供了对数据库ACID<strong>事务</strong>的支持，并且实现了SQL标准的四种隔离级别，它的设计目标是<u>处理大容量数据库系统</u>。</p><ul><li><strong>优点：</strong> <strong>行级锁</strong>，<strong>支持事务</strong>，支持<u><strong>自动增长列</strong></u>，支持外键约束，<strong>并发能力强</strong></li><li><strong>缺点：</strong> 占用空间是MYISAM的2倍，处理效率相对也更低</li></ul></li><li><p><strong><code>Memory</code></strong></p><p>主要用于<strong>内容变化不频繁的</strong>代码表。</p><ul><li><strong>优点：</strong> <strong>全表锁</strong>，<u>存储在内存中，默认使用Hash，检索效率非常高</u></li><li><strong>缺点：</strong> 会占用和数据量成正比的内存空间且，mysql重启时会丢失，不适合精确查找</li></ul></li><li><p><strong><code>MERGE</code></strong></p><p>是一组MYISAM表的组合。</p></li></ul><h5 id="2-1-InnoDB、MyISAM、Memory-【索引】（按数据结构分）">2.1 InnoDB、MyISAM、Memory 【索引】（按数据结构分）</h5><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000037683781">https://segmentfault.com/a/1190000037683781</a></p></blockquote><p><img src="D:/hwh/images/image-20210820194526488.png" alt="image-20210820194526488"></p><h5 id="2-2-为什么Innodb使用自增id作为主键？">2.2 为什么Innodb使用自增id作为主键？</h5><ul><li><strong>如果不使用自增主键</strong>， 如身份证号、学号，每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置（<strong>涉及到B+树分裂等</strong>）， 频繁的移动、分页操作造成了大量的碎片；</li><li><strong>如果使用自增主键，</strong> 那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。</li></ul><h4 id="3-说说InnoDB与MyISAM的区别？">3. <strong>说说InnoDB与MyISAM的区别？</strong></h4><p>见前。</p><h5 id="3-1-说说InnoDB与MyISAM在B-数索引方式区别？">3.1 说说InnoDB与MyISAM在B+数索引方式区别？</h5><ul><li><p><strong>MyISAm</strong> , B+Tree叶节点的data域存放的是数据<strong>记录的地址</strong>，在索引检索的时候，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引” ；</p></li><li><p><strong>InnoDB，</strong> 树的节点data域保存了完整的数据记录，这个索引的<strong>key是数据表的主键（自增id）</strong> ；而<strong>其它索引都叫做辅助索引</strong>， 助索引的data域存储相应记录<strong>主键的值</strong>而不是记录地址。</p><blockquote><ul><li>在根据主索引搜索时，直接找到key所在的节点即可取出数据；</li><li>在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</li></ul></blockquote></li></ul><h5 id="3-2-【百度】说说InnoDB与MyISAM在适用场景上的区别？">3.2 【百度】说说InnoDB与MyISAM在适用场景上的区别？</h5><ul><li><strong>MyISAM</strong> ，没有事务， 适合<strong>插入不频繁，查询非常频繁</strong>；</li><li><strong>Innodb：</strong> 有事务，适合<strong>可靠性要求比较高</strong>，或者<strong>更新和查询比较频繁</strong>。</li></ul><h4 id="4-为什么-SELECT-COUNT-FROM-table-在-InnoDB-比MyISAM-慢？-3">4. **为什么 SELECT COUNT(*) FROM table 在 InnoDB 比MyISAM 慢？**3</h4><p>对于 SELECT COUNT(*) FROM table 语句，在没有 WHERE 条件的情况下，InnoDB 比 MyISAM 可能会慢很多，尤其在大表的情况下。</p><ul><li>InnoDB 是去实时统计结果，会<strong>全表扫描</strong>；</li><li>而 MyISAM内部维持了一个<u><strong>计数器</strong></u>，<strong>预存了结果</strong>，所以直接返回即可。</li></ul><h4 id="5-简单说一说drop、delete与truncate的区别？">5. <strong>简单说一说drop、delete与truncate的区别？</strong></h4><p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别：</p><ul><li><strong>删除类型：</strong> drop删除表结构；delete、truncate删除表内容。</li><li><strong>删除速度：</strong>  <strong>drop</strong>&gt; truncate &gt;delete</li><li><strong>生效速度：</strong> drop和truncate ，操作立即生效，不能回滚也不触发触发器；<strong>delete事务提交后才生效，会触发相应触发器</strong>。</li></ul><h4 id="6-什么是视图？-游标？">6. <strong>什么是视图？</strong> 游标？</h4><p>视图是一种虚拟的表，通常是一个表或者多个表的行或列的子集，具有和物理表相同的功能。</p><ul><li>可以对视图进行增，改，查，操作，但<strong>对视图的修改不影响基本表</strong>；</li><li>相比多表查询，获取数据速度更容易。</li></ul><p>游标，是对<strong>查询出来的结果集</strong>作为一个单元来有效的处理。</p><ul><li>一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</li></ul><h4 id="7-什么是内联接、左外联接、右外联接？">7. <strong>什么是内联接、左外联接、右外联接？</strong></h4><ul><li><p><strong>内联接（Inner Join）</strong>：两个表（或连接）中某一数据项相等的连接称为内连接。 连接的结果是形成一个新的数据表。 内连接中参与连接的表（或连接）的地位是相等的；</p></li><li><p><strong>左外联接（Left Outer Join</strong>）：除了匹配2张表中相关联的记录外，<u>还会匹配左表中剩余的记录</u>，<u>右表中未匹配到的字段用NULL表示</u>；</p></li><li><p><strong>右外联接（Right Outer Join）</strong>：除了匹配2张表中相关联的记录外，还会<u>匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示</u>。</p></li></ul><h4 id="8-说说在-MySQL-中一条查询-SQL-是如何执行的？">8. <strong>说说在 MySQL 中一条查询 SQL 是如何执行的？</strong></h4><p>例如：<code>select name from t_user where id=1</code></p><ol><li><p><strong>取得链接</strong>，使用使用到 MySQL 中的<strong>连接器</strong>；</p></li><li><p><strong>查询缓存</strong>，key 为 SQL 语句，value 为查询结果，如果查到就直接返回；</p><blockquote><p>在 MySQL 8.0 版本已经将查询缓存删除，也就是说 MySQL 8.0 版本后不存在此功能。</p></blockquote></li><li><p><strong>分析器</strong>，分为词法分析和语法分析。此阶段只是做一些 SQL 解析，语法校验。所以一般语法错误在此阶段；</p></li><li><p><strong>优化器</strong>，是在表里<strong>有多个索引的时候，决定使用哪个索引</strong>；或者一个语句中存在多表关联的时候（join），决定<strong>各个表的连接顺序</strong>；</p></li><li><p><strong>执行器</strong>，开始执行语句。执行语句的时候还要判断是否具备此权限，如果有权限：（1）根据表的引擎定义，使用引擎提供的接口，获取表的第一行，判断id是否等于1 ；（2）如果不是则继续调用引擎接口去获取下一行，继续判断；（3）直至取到这个表的最后一行</p></li></ol><h4 id="9-MySQL-中-varchar-与-char-的区别？-int-3-呢？">9. <strong>MySQL 中 varchar 与 char 的区别？</strong> int(3) 呢？</h4><ul><li><p>char 是一种固定长度的类型，varchar 则是一种可变长度的类型。</p><p><img src="https://i.loli.net/2021/05/03/SoHv6lyhp94TwWP.png" alt="image-20210503214113219"></p></li><li><p><strong>float(3,2) 和 int(3)</strong></p><ul><li><code>float(3,2)</code> : &quot;浮点型&quot;的长度是用来<strong>限制数字存储范围</strong>的。比如 float(3,2) 只能够写入 <code>0.00~999.99</code>。</li><li><code>int(3)</code> ：&quot;整型&quot;的长度并<strong>不会限制存储的数字范围</strong>，都是<code>-2147483648 ~ 2147483647</code> 。只<strong>限制显示长度</strong>。</li></ul></li></ul><h4 id="10-超键、主键、候选键和外键有什么区别？">10. <strong>超键、主键、候选键和外键有什么区别？</strong></h4><ul><li><strong>超键(super key)</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键；</li><li>**候选键(candidate key)：**不含有多余属性的超键称为候选键，<u>是超键的子集</u>；</li><li>**主键(primary key)：**用户选作元组标识的一个候选键程序主键，<u>是候选键的子集</u> ；</li><li><strong>外键</strong>：如果关系模式<strong>R中属性K是其它模式的主键</strong>，那么<strong>k在模式R中称为外键</strong>。</li></ul><p>下面举例说明（<strong>假设姓名不重复唯一</strong>）：</p><table><thead><tr><th style="text-align:center">身份证</th><th style="text-align:center">姓名</th><th style="text-align:center">性别</th><th style="text-align:center">年龄</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><ul><li><u>超键：</u> 身份证、姓名、（姓名、性别）、（姓名、性别、年龄）都可以作为超键；</li><li><u>候选键</u> ：身份证、姓名 都唯一，都可以作为候选键；</li><li><u>主键：</u> 在候选键选一个作为主键，例如：身份证。</li></ul><h4 id="11-解释⼀下什么是池化设计思想。什么是数据库连接池-为什么需要数据库连接池">11.  解释⼀下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?</h4><ul><li><p><strong>池化设计思想</strong></p><p>我们常⻅的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会<u>初始预设资源</u>，<strong>解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销</strong>等。</p></li><li><p><strong>数据库连接池</strong></p><p>数据库连接本质就是⼀个 <strong>socket</strong> 的连接。数据库服务端还要维护⼀些缓存和⽤户权限信息之类的所以<strong>占⽤了⼀些内存</strong>。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以<strong>重⽤这些连接</strong>。</p></li><li><p><strong>为什么要用数据库连接池？</strong></p><p>为每个⽤户打开和维护数据库连接，尤其是对动态数据库驱动的网站应⽤程序的请求，既昂贵⼜浪费资源。在连接池中，创建连接后，将其放置在池中，并再次使⽤它，因此不必建⽴新的连接。如果使⽤了所有连接，则会建⽴⼀个新连接并将其添加到池中。</p></li></ul><h4 id="12-如果数据不存储在磁盘而是在内存，用什么数据结构？为什么Mysql不使用hash？">12. 如果数据不存储在磁盘而是在内存，用什么数据结构？为什么Mysql不使用hash？</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/wangtao_20/p/3643994.html">为什么hash作为内存使用的经典数据结构?</a></p></blockquote><p>数据放在磁盘，使用<strong>B+树</strong>，<strong>核心是为了减少磁盘IO</strong>，因为磁盘IO的代价很大（是内存的十万倍）。</p><p>我们使用<strong>hash</strong>寻找数据的时候，<strong>数据随机分散到各个物理位置</strong>，不是有序的数据。而<strong>内存设备也是随机访问设备</strong>，内存很适合用hash方式来读取数据。</p><ul><li><p><strong>随机访问：<strong>存储器单元的内容可以根据需要自由取出或存储，而且</strong>访问的速度与存储器单元的位置</strong>无关 。(通过行，列地址总线就可以快速定位存储的数据)</p><blockquote><p>但是磁盘，每次访问数据，是需要先定位，然后<strong>顺序</strong>移动；如果下个数据不在磁头附近，又要重新定位。</p><p>如果Hash索引磁盘数据，（1）每次访问都要IO<strong>不能范围</strong>（2）数据太多，Hash索引保存不了键值，而<strong>高度为3的B+数就能保存千万级别的数据</strong>（3）当数据量很大时，<strong>hash冲突</strong>的概率也会非常大（4）组合索引可以支持部分索引查询，如(a,b,c)的组合索引，查询中只用到了阿和b也可以查询的，如果使用hash表，组合索引会将几个字段合并hash，<strong>没办法支持部分索引</strong> （5）当需要按照索引进行order by时，hash值<strong>没办法支持排序</strong> 。</p></blockquote></li></ul><h4 id="13-【字节】Mysql-Join的原理？">13.【字节】Mysql Join的原理？</h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/54275505">https://zhuanlan.zhihu.com/p/54275505</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user tb1 left join level tb2 on tb1.id=tb2.user_id</span><br></pre></td></tr></table></figure><ol><li><p><strong>简单嵌套循环</strong></p><p><strong>双层for 循环</strong> ，通过循环外层表的行数据，逐个与内层表的所有行数据进行比较来获取结果。</p><img src="https://i.loli.net/2021/09/04/u3LJnMgZsIV6Atd.png" alt="image-20210904063419237" style="zoom:50%;" /></li><li><p><strong>索引嵌套循环连接</strong></p><p>通过外层表匹配条件 <strong>直接与内层表索引进行匹配</strong>，避免和内层表的每条记录去进行比较， 这样极大的减少了对内层表的匹配次数。</p><ul><li>从原来的匹配次数=外层表行数 * 内层表行数,变成了 外层表的行数 * 内层表索引的高度，极大的提升了 join的性能；</li><li>注意，<strong>要为表user_level 去建立索引</strong></li></ul><img src="https://i.loli.net/2021/09/04/1gkP9upMosUtYS4.png" alt="image-20210904063546011" style="zoom:80%;" /></li><li><p><strong>缓存块嵌套循环连接</strong></p><p>其优化思路是<strong>减少内层表的扫表次数</strong>。</p><ul><li>通过简单的嵌套循环查询的图，我们可以看到，左表的每一条记录都会对右表进行一次扫表，扫表的过程其实也就是<strong>从内存读取数据</strong>的过程，那么这个过程其实是比较消耗性能的。</li></ul><p><img src="https://i.loli.net/2021/09/04/s1nE7IzYZ6TGlkK.jpg" alt="img"></p><p>所以缓存块嵌套循环连接算法意在通过<strong>一次性缓存外层表的多条数据</strong>，以此来减少内层表的扫表次数，从而达到提升性能的目的。如果无法使用<strong>Index Nested-Loop Join</strong>的时候，数据库是默认使用的是<strong>Block Nested-Loop Join算法的</strong>。</p><ul><li><strong>当level 表的 user_id 不为索引</strong>的时候，默认会使用Block Nested-Loop Join算法。</li></ul><p><img src="https://i.loli.net/2021/09/04/iP9o6OpU8ZxcIwF.jpg" alt="img"></p></li></ol><h2 id="5-2-分布式数据库">5.2 分布式数据库</h2><h4 id="0-【字节】分布式数据库锁如何实现？">0. 【字节】分布式数据库锁如何实现？</h4><ul><li><strong>什么时候用到分布式数据库？</strong><ol><li><strong>水平拆分</strong> ：<strong>数据量大到单机数据库已存储不下</strong>时， 可以对数据进行拆分，化整为零，将数据均匀分布到多个数据库节点中。</li><li><strong>读写分离：<strong>主要用在</strong>数据量并不大</strong>，单机数据库能够hold得住，<strong>但读请求很高</strong>的情况下。此时，可以配置多个只读数据库节点，来分担主节点的读请求。通过数据复制机制，<strong>在主节点和只读节点之间进行数据的实时同步</strong>，保证主从节点的数据一致性。</li></ol></li><li><strong>分布式数据库锁？</strong><ol><li><strong>直接锁表</strong>，代价比较大</li><li><strong>加入排它锁</strong>，查询语句后面增加<strong>for update</strong>（这里我们希望使用行级锁，就要给method_name添加索引）</li><li><strong>Zookeeper实现分布式锁</strong></li></ol></li></ul><h4 id="1-请说说-MySQL-数据库的锁？">1. <strong>请说说</strong> <strong>MySQL</strong> <strong>数据库的锁？</strong></h4><p><img src="https://i.loli.net/2021/05/24/S7HoKh8EcpXT1Mz.png" alt="img"></p><p>MySQL 中常见锁如下：</p><p>【<u>按使用方式划分</u>】</p><ul><li><p><strong>共享锁：<strong>不堵塞，多个用户可以同一时刻</strong>读取</strong>同一个资源，相互之间没有影响；</p></li><li><p><strong>排它锁（写锁）：</strong><u>一个写操作阻塞其他的读锁和写锁</u>，<strong>只允许一个用户进行写入</strong>，<strong>防止其他用户读取正在写入的资源</strong>。</p></li></ul><p>【<u>按锁粒度划分</u>】</p><ul><li><p>**表锁：**系统开销最小，会锁定整张表，<u>不会出现死锁</u>；但是由于粒度太大，因此造成锁的冲突几率大，并发性能低。<strong>MyISAM 使用表锁。</strong></p></li><li><p><strong>行锁：</strong><u>容易出现死锁</u>，发生冲突概率低，并发性能高。<strong>InnoDB 支持行锁</strong>。</p><blockquote><p><strong>必须有索引才能实现</strong>，否则会自动锁全表，那么就不是行锁。</p></blockquote></li></ul><p>【<u>按思想划分</u>】</p><ul><li><strong>乐观锁</strong></li><li><strong>悲观锁</strong></li></ul><h4 id="2-说说什么是锁升级？什么情况发生锁升级？">2. <strong>说说什么是锁升级？什么情况发生锁升级？</strong></h4><blockquote><p>区分一下sycronized锁升级。</p></blockquote><p>锁升级是指将当前锁的粒度降低：<code>行锁→页锁→表锁</code>。</p><p>发生锁升级的情况：</p><ol><li>当一条SQL语句对<u>同一个对象</u>上持有的锁数量超锁了阈值，默认这个阈值为5000，<strong>但是对于不同对象不会发生锁升级</strong></li><li>锁资源占用的内存超过<u>激活内存</u>的百分之40 就会发生锁升级</li></ol><h5 id="2-1-为什么说innoDB-引擎不存在锁升级的问题-？">2.1 为什么说innoDB 引擎不存在锁升级的问题 ？</h5><p>待补充。</p><h5 id="2-2-什么时候触发行锁和表级锁？">2.2 什么时候触发行锁和表级锁？</h5><p>mysql默认存储引擎都是<strong>innodb</strong>，默认是使用<strong>行锁</strong> 。</p><ul><li><p>触发行级锁 ，<strong>行级锁锁的是索引记录</strong> ，使用了索引所以就会触发行级锁。</p></li><li><p>触发表级锁，有以下三种情况</p><blockquote><p>其实不管是读操作(select)还是写操作(update,delete,insert),只要涉及到带有筛选条件的语句，<strong>如果筛选条件中没有用到索引</strong>，就会触发全表扫描。</p></blockquote><ol><li><strong>全表更新</strong>：事务<strong>需要更新大部分数据或全部数</strong>据，如果使用行级锁，会导致事务执行效率低，从而导致其他事务长时间等待锁和更多的锁冲突</li><li><strong>多表级联：事务涉及多张表</strong>，比较复杂的关联查询，很可能造成死锁，这种情况若能一次性锁住事务涉及的表，从而避免死锁，减少数据库事务回滚所带来的开销</li><li><strong>筛选条件中未用到索引</strong>： 全表扫描</li><li><strong>用到索引，但区分度程度不高</strong> ：innodb认为全表扫描比走索引效率更高导致索引失效，这个时候就要通过explain去查看下查询计划，看下查询语句是否真的用到了索引</li></ol></li></ul><h5 id="2-3-行锁适合的场景？">2.3 行锁适合的场景？</h5><p>A用户消费，service层先查询该用户的账户余额，若余额足够，则进行后续的扣款操作；这种情况查询的时候应该对该记录进行加锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for update # 操作该记录时加上</span><br></pre></td></tr></table></figure><p>否则，B用户在A用户查询后消费前先一步将A用户账号上的钱转走，而此时A用户已经进行了用户余额是否足够的判断，则可能会出现余额已经不足但却扣款成功的情况。</p><h4 id="3-怎样尽量避免死锁的出现？">3. <strong>怎样尽量避免死锁的出现？</strong></h4><ol><li><p><strong>设置获取锁的超时时间</strong>，至少能保证最差情况下，可以退出程序，不至于一直等待导致死锁；</p></li><li><p><strong>设置按照同一顺序访问资源</strong>，类似于串行执行；</p></li><li><p><strong>避免事务中的用户交叉</strong>；</p></li><li><p>保持事务简短并在一个批处理中；</p></li><li><p>使用<strong>低隔离级别</strong>。</p></li></ol><h4 id="4-解释一下悲观锁和乐观锁？">4. <strong>解释一下悲观锁和乐观锁？</strong></h4><ul><li><p><strong>悲观锁：</strong> 悲观锁是基于一种悲观的态度类来防止一切数据冲突。它是以一种预防的姿态 <u>在修改数据之前把数据锁住</u>，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作。一般数据库本身锁的机制都是基于悲观锁的机制实现的。</p><ul><li><p><strong>特点：</strong> 完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁；但是造成性能消耗</p></li><li><p><strong>实现</strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 加读锁</span><br><span class="line">LOCK tables test_db READ </span><br><span class="line"># 释放锁</span><br><span class="line">UNLOCK TABLES</span><br><span class="line"># 加写锁</span><br><span class="line">LOCK tables test_db WRITE </span><br><span class="line"># 释放锁</span><br><span class="line">UNLOCK TABLES</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>乐观锁：</strong> 对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁，使得<u>多个任务可并行对数据操作</u>。但是<u>使用一种验证机制来避免数据冲突</u> （一般通过加版本后对比来实现）。</p><ul><li><p><strong>特点：</strong> 并发类型的锁，<u>本身不加锁但通过业务实现锁的功能</u> ，没有锁操作因此性能更高。</p></li><li><p><strong>实现形式：</strong></p><p>（1）两个请求同时操作操作标Name字段，二者查询需检索的数据都是一样的：</p><p><img src="https://i.loli.net/2021/04/20/H6wyLdqZN8BJipx.png" alt="img"></p><p>（2）请求1修改字段数据<code>“zhangsan”→“lisi”</code> ，并将版本号增加+1 ，验证版本号一直后提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update A set Name=lisi,version=version+1 where ID=#&#123;id&#125; and version=#&#123;version&#125;</span><br></pre></td></tr></table></figure><p>（3）请求2也想修改<code>“zhangsan”→“liming”</code>  ，但是提交时由于 <u>版本号不一致，无法提交成功</u></p></li></ul></li></ul><h4 id="5-介绍一下分布式数据库全局ID唯一且自增，如何生成？-（或者问分库分表之后，id-主键如何处理？）">5. <strong>介绍一下分布式数据库全局ID唯一且自增，如何生成？</strong> （<strong>或者问分库分表之后，id 主键如何处理？</strong>）</h4><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要⼀个全局唯⼀的 id来支持。</p><ol><li><p>**UUID：**不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。</p></li><li><p>ID自增量为<u>分布式数据库个数</u>，缺点是扩展性不好；</p></li><li><p><a href="https://www.cnblogs.com/jiangxinlingdu/p/8440413.html">snow flake算法</a>：snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。</p><p><img src="https://pic3.zhimg.com/80/v2-b3a91b9e3f6468be39f3dc3345e9f4f2_720w.jpg" alt="img"></p><ul><li><strong>核心思想：</strong> 使用41bit作为毫秒数，10bit作为机器的ID（<strong>5个bit是数据中心，5个bit的机器ID</strong>），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 <u>不同ID</u>），最后还有一个符号位，永远是0。</li></ul></li><li><p><a href="https://blog.csdn.net/minkeyto/article/details/104943883">Leaf算法</a>：分号段</p></li></ol><h4 id="8-介绍一下哈希算法？和一致性哈希算法？">8. <strong>介绍一下哈希算法？和一致性哈希算法？</strong></h4><ul><li><p><strong>哈希算法</strong></p><ul><li><strong>介绍：</strong> 哈希算法<u>将任意长度的二进制值映射为较短的固定长度的二进制值</u>，这个小的二进制值称为<strong>哈希值</strong>。哈希值是一段数据唯一且<strong>极其紧凑的数值表示形式</strong>。</li><li><strong>分布式应用中缺点：</strong> 在分布式的存储系统中，<u>要将数据存储到具体的节点上</u>。如果采用哈希算法：<code>key%N</code>（key是数据的key，N是机器节点数） 。出现机器加入或退出集群（<strong>N变了，映射值不一样了</strong>），所有的数据映射都无效了。</li></ul></li><li><p><strong>一致性哈希算法</strong></p><ul><li><p><strong>介绍：<strong>解决普通哈希算法造成负载均衡时，在</strong>服务节点数量变动</strong>时出现 <strong><u>哈希失效</u></strong> 问题</p></li><li><p><strong>实现：</strong></p><ol><li><p><strong>构建环：<strong>按照常用的hash算法来将对应的key哈希到一个具有</strong>2^32</strong>次方个节点的空间中（即0 ~ (2^32)-1）。</p><blockquote><p>Note: 节点的个数可以自定义, hash环我们可以用TreeMap来实现, 因为treeMap是排序的，我们刚好可以利用上。</p></blockquote><img src="https://i.loli.net/2021/04/20/Al6k3ZmHJO2qbe9.jpg" alt="img" style="zoom:50%;" /></li><li><p><strong>映射服务器节点：</strong> 将各个服务器使用Hash进行一个哈希，确定每台机器其在哈希环上的位置。</p><blockquote><p>一般用服务器ip或唯一主机名进行哈希。</p></blockquote><img src="https://i.loli.net/2021/04/20/1ZKalnT9CStVc8s.jpg" alt="img" style="zoom:50%;" /></li><li><p><strong>映射数据。</strong> 对于要存储的数据：<code>ojectA、objectB、objectC、objectD</code> ，首先通过特定哈希函数计算出<code>hash</code>值 ，散列到环上。然后从数据所在位置<u>沿环顺时针“行走”</u>，第一台遇到的服务器就是其应该定位到的服务器。</p><img src="https://i.loli.net/2021/04/20/SwUijYkyJPp34v1.jpg" alt="img" style="zoom:50%;" /></li><li><p><strong>出现服务器变动。</strong> 如果此时NodeC宕机了，此时Object A、B、D不会受到影响，只有Object C会重新分配到Node D。<u>避免了大量数据迁移，减小了服务器的的压力</u> 。</p></li></ol></li></ul></li></ul><h4 id="9-（再理解）介绍一下MVVC？">9. （再理解）<strong>介绍一下MVVC？</strong></h4><p>MVCC（Multi-Version Concurrency Control）多版本并发控制，是</p><p>数据库控制并发访问的一种手段。</p><blockquote><ul><li>特别要注意<strong>MVCC</strong>只在 <strong>读已提交(RC)</strong> 和 <strong>可重复读（RR）</strong> 这两种事务隔离级别下才有效</li><li>是 <strong>数据库引擎（InnoDB）</strong> 层面实现的，用来处理读写冲突的手段（不用加锁），提高访问性能</li></ul></blockquote><ul><li><p>MVCC协议中，事务提交不会覆盖原数据，而是产生新版本数据，<strong>每个数据有多个历史版本</strong>，但同一时刻只有最新的版本有效；</p></li><li><p>MVCC是在并发访问数据库时，通过对数据做多版本管理，避免<u>【<strong>因为写锁的阻塞而造成读数据的并发阻塞</strong>】</u>问题。可以让<strong>读取数据同时修改，【修改数据时同时可读取】</strong>。简单来说，就是<strong>不对数据库加上读写锁！</strong></p></li></ul><h5 id="9-1-MVCC-如何实现-？">9.1 MVCC 如何实现 ？</h5><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/52977862">Innodb MVCC实现原理</a></p></blockquote><ul><li><p><strong>总结性回答</strong></p><p>MVCC是以一个多版本并发控制系统，它主要通过以下两个部分实现：</p><ul><li>每行记录：记录最近操作该行记录的事务ID，和上一版本数据的指针（指向undo log）</li><li>readview：每次<strong>读（写不可以）</strong> 可以获取一个readview，记录当前活跃的事务ID ，可以在<strong>写的过程进行读</strong></li></ul><p>写的时候并发读，通过比较当前行记录的事务ID和readview活跃的事务ID，来决定是否读取该行记录还是上一版本的数据。</p></li></ul><p>MVCC实现的核心部分为：</p><ol><li><p><strong>事务版本号</strong>：每次<strong>事务开启前</strong>都会从数据库获得一个自增长的<strong>事务ID</strong>，可以从事务ID判断事务的执行先后顺序。</p></li><li><p><strong>表的隐藏列</strong> ：<strong>每一行</strong> 有如下三个重要字段属性：</p><table><thead><tr><th style="text-align:center">隐藏列</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>DB_TRX_ID</strong></td><td style="text-align:center">记录操作该行事务的ID</td></tr><tr><td style="text-align:center"><strong>DB_ROLL_PTR</strong></td><td style="text-align:center">指向上一个版本的数据（在undo log）的指针</td></tr><tr><td style="text-align:center"><strong>DB_ROW_ID</strong></td><td style="text-align:center">隐藏ID，当表没有合适的索引作为聚簇索引时，会用该ID创建聚簇索引</td></tr></tbody></table></li><li><p><strong>undo log</strong> ：每一行记录被修改之前的日志。</p><blockquote><p>当事务被回滚时，可以用通过undo log日志对数据进行还原。</p></blockquote><p>一个小例子：修改某行记录name从 <code>“张三→李四”</code></p><p><img src="https://pic1.zhimg.com/v2-1daaeab59495ff3378dae24ea21dc158_r.jpg" alt="preview"></p></li><li><p><strong>read view</strong>。在innodb 中<strong>每个SQL语句执行前</strong>都会得到一个read_view，保存了当前数据库系统中正**处于活跃（没有提交）**的事务的ID号。</p><blockquote><p>根据事务的隔离性，这些事务ID列表不会被其它事务看到。</p></blockquote><p>其相关重要属性如下：</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>trx_ids</strong></td><td style="text-align:center">当前系统：活跃<code>（未提交）事务版本号集合</code></td></tr><tr><td style="text-align:center"><strong>low_limit_id</strong></td><td style="text-align:center">当前系统：<code>最大版本事务号+1</code></td></tr><tr><td style="text-align:center"><strong>up_limit_id</strong></td><td style="text-align:center">当前系统：<code>活跃的最小事务版本号</code></td></tr><tr><td style="text-align:center"><strong>creator_trx_id</strong></td><td style="text-align:center">当前read view：<code>事务版本号</code></td></tr></tbody></table></li></ol><p>具体原理可以描述如下：</p><blockquote><p>举个例子，假设有一个user_info表，初始数据如下：</p><p><img src="https://i.loli.net/2021/05/30/ATDHgI7sKeziOxE.png" alt="image-20210529211818428"></p><p>现在有事务A，B<strong>同时对<code>id=1</code> 这行数据进行操作</strong>，先开启事务A（未提交），此时执行事务B，最后返回什么结果呢？</p></blockquote><ol><li><p>事务A（写），执行 <code>update user_info set name =”李四”</code></p><ul><li><p>获得事务编号：102</p></li><li><p>当前事务A的视图为：<strong>（写）不会获得read view！</strong></p></li></ul></li><li><p>事务B（读），执行 <code>select * fom user_info where id=1</code></p><ul><li><p>获得事务B编号：103</p></li><li><p>当前事务B的视图为：</p><table><thead><tr><th style="text-align:center"><strong>trx_ids</strong></th><th style="text-align:center">当前活跃的事务：102,103</th></tr></thead><tbody><tr><td style="text-align:center"><strong>low_limit_id</strong></td><td style="text-align:center">当前最大事务id+1:<strong>104</strong></td></tr><tr><td style="text-align:center"><strong>up_limit_id</strong></td><td style="text-align:center">当前最小事务id：<strong>102</strong></td></tr><tr><td style="text-align:center"><strong>creator_trx_id</strong></td><td style="text-align:center">当前事务id：<strong>103</strong></td></tr></tbody></table></li></ul><blockquote><p><strong>不同隔离级别下，read view的工作方式：</strong></p><ol><li><p><strong>读未提交</strong>：不会获得read view的副本（等于没有并发控制所以会出现脏读）</p></li><li><p>**读提交：**每一次select都会获得一个read view的副本，所以会造成【不可重复读】</p><p><img src="https://i.loli.net/2021/05/30/EQSJBYZMeUljA3g.png" alt="image-20210529222746175"></p></li><li><p>**可重复读：**同一个事务select只会获得一次read view副本（select的时候不允许修改），所以不会出现不可重复读。</p><p><img src="https://i.loli.net/2021/05/30/ITXb5OukhL1EJ4N.png" alt="image-20210529222905837"></p></li></ol></blockquote></li><li><p>事务A（写），开始执行update语句：（1）把原数据拷贝到undo log，（2）然后进行修改name字段：<code>“张三→李四”</code>，（3）并设置DB_TRX_ID 隐藏字段：<code>99→102</code> （4）设置DB_ROLL_PTR隐藏字段：<code>执行上个事务版本地址</code></p><p><img src="https://i.loli.net/2021/05/30/zjCi4AeRQsbHaPO.png" alt="image-20210529213739125"></p><p>此时，<strong>事务A还并未提交</strong>，依旧是处于活跃状态。</p></li><li><p>事务B（读），开始执行select语句，<strong>查询到是事务A修改后的语句</strong></p><p><img src="https://i.loli.net/2021/05/30/xspAhSDXbOGroqC.png" alt="image-20210529214159799"></p><p>把<strong>数据和read view （视图）匹配</strong>： <u>保证</u>（1）<strong>数据已提交，没有其他事物修改，否则去找上一版本的数据</strong>。</p><blockquote><ol><li><code>当前数据记录的事务id &lt; 事务B视图中最小活跃事务id</code> : 说明<strong>数据</strong>，是在<strong>事务B的read view 创建前</strong>就存在，所以可以显示。</li><li><code>当前数据记录的事务id &gt; 事务B视图中最大活跃事务id</code> ：说明<strong>数据</strong>，是在<strong>事务B的read view 创建后</strong>才存在，此时不应该显示。</li><li><code>事务B视图中最小活跃事务id&lt;= 当前数据记录的事务id &lt;= 事务B视图中最大活跃事务id</code> ： 说明有<strong>其它事务在修改这行记录数据</strong>，但可能还没有提交。把id和事务B的read view的活跃事务集合trx_ids进行匹配：<ul><li>如果数据记录的ID不存在trx_ids，说明已经提交了事务，可以显示</li><li>如果存在trx_ids，说明<strong>数据还没提交，此时事务B查询到数据不能显示</strong>（除非此时数据记录的事务id == 事务B的id，由于是自己的当然可以显示）</li></ul></li></ol></blockquote></li><li><p>事务B（读），根据上述匹配规则，<strong>此时不能读</strong>，应该去undo log中找到上一版本数据。</p><blockquote><p>此时<code>事务B的id=103，数据记录的事务id=102</code> ：满足条件3，且此时trx_ids存在事务id=102，说明事务A（id=102）还没提交，因此<strong>不能显示。</strong></p></blockquote><p>故，最终查找的数据为：</p><img src="https://i.loli.net/2021/05/30/ATDHgI7sKeziOxE.png" alt="image-20210529211818428" style="zoom:80%;" /></li></ol><p>可以看到，整个过程MVCC<strong>事务A【写】没有加锁</strong>，只是进行版本号控制 &amp; undo log，可以进行<strong>并发【读】</strong>。</p><h5 id="9-2-MVCC-版本号如何变化的？更新的数据如何确定版本的？【幻读】又是怎么解决的呢？">9.2 MVCC 版本号如何变化的？更新的数据如何确定版本的？【幻读】又是怎么解决的呢？</h5><ul><li><p><strong>版本号变化</strong></p><p>每条记录有三个隐藏列：（1）<strong>DB_TRX_ID</strong> （2）<strong>DB_ROLL_PTR</strong> （3）<strong>DB_ROW_ID</strong></p><p>每一次新事务，<strong>update更新语句</strong>，都会将（1）拷贝数据到undo log（2）DB_ROLL_PTR指向上个数据的版本undo log（3）DB_TRX_ID修改为新事务的id 。</p></li><li><p><strong>为什么MVCC可解决幻读</strong></p><p><strong>在RR（可重复读级别下）不会出现幻读</strong>。例如：</p><ol><li>开启事务1，获得事务ID为1；</li><li>事务1执行查询，得到readview；</li><li>开始事务2；</li><li>执行insert；</li><li>提交事务2；</li><li>执行事务1的第二次查询 (因为这里是RR级别，所以<strong>不会再去获得readview，<strong>还是使用第一次获得的readview，所以</strong>当前read view 事务的ID不会更新</strong>，即不会加入插入事务2)；</li><li>最后得到的结果是，插入的数据不会显示，因为<strong>插入的数据事务ID &gt; readview里的最大活跃事务ID</strong>。</li></ol></li></ul><h5 id="9-3-mvvc-和-for-update的区别">9.3 mvvc 和 for update的区别</h5><ol><li><strong>是否加锁：</strong>  mvvc不加锁，只通过多版本来进行并发控制；for update会加锁（<strong>即X/写锁</strong>）。</li></ol><h5 id="9-4-（快手）MVCC作用，如何实现RC，RR">9.4 <strong>（快手）MVCC作用，如何实现RC，RR?</strong></h5><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/73078137">https://zhuanlan.zhihu.com/p/73078137</a></p></blockquote><p><strong>作用如下：</strong></p><ol><li>最简单的描述，<strong>读写不阻塞，读的时候可以写</strong></li><li>提高性能</li></ol><p><strong>实现RC，RR两个隔离级别：</strong></p><blockquote><p>MVCC <strong>读</strong>某一个数据时，<strong>根据隔离级别</strong>，事务选择要读取哪个版本的数据，过程中完全不需要加锁。</p></blockquote><ol><li><p><strong>Read Committed</strong> ：一个事务读取数据时总是读这个数据<strong>最近一次被commit</strong>的版本 ，<strong>所以可以避免脏读（快手）</strong>；</p></li><li><p><strong>Repeatable Read</strong> ： 一个事务读取数据时总是读取当前**【事务开始之前】最后一次被commit**的版本（所以底层实现时需要比较当前事务和数据被commit的版本号），<strong>所以避免了幻读（快手）</strong>。</p></li></ol><p><strong>举个简单的例子：</strong></p><ol><li><strong>一个事务A（txnId=100）修改了数据X，使得X=1，并且commit了</strong></li><li><strong>另外一个事务B（txnId=101）开始尝试读取X，但是还X=1。但B没有提交。</strong></li><li><strong>第三个事务C（txnId=102）修改了数据X，使得X=2。并且提交了</strong></li><li><strong>事务B又一次读取了X。这时</strong><ul><li><strong>如果事务B是Read Committed。那么就读取X的最新commit的版本，也就是X=2</strong></li><li><strong>如果事务B是Repeatable Read。那么读取的就是当前事务（txnId=101）之前X的最新版本，也就是X被txnId=100提交的版本，即X=1。</strong></li></ul></li></ol><p>注意，这里B不论是Read Committed，还是Repeatable Read**，都不会被锁**，都能立刻拿到结果。这也就是MVCC存在的意义。</p><h2 id="5-3-索引相关">5.3 索引相关</h2><blockquote><p>:artificial_satellite: 强烈建议对索引更深刻理解，先看完美团这篇技术文章：<a href="https://tech.meituan.com/2014/06/30/mysql-index.html">MySQL索引原理及慢查询优化</a></p></blockquote><h4 id="0-MySQL索引原理及慢查询优化">0. <a href="https://tech.meituan.com/2014/06/30/mysql-index.html">MySQL索引原理及慢查询优化</a></h4><h5 id="0-1-为什么要需要索引">0.1 为什么要需要索引</h5><blockquote><p>答到：遍历磁盘开销太大这个关键。</p></blockquote><p>数据库实现比较复杂，数据保存在<strong>磁盘</strong>上，而为了提高性能，每次又可以把<strong>部分读入内存</strong>来计算 。</p><p>磁盘的成本大概是访问内存的<strong>十万倍</strong>左右 ， 每次去遍历磁盘找到数据再读入内存，是难以接受的。因此需要一种快速找到磁盘数据的方式，就像字典通过<strong>字母索引→快速定位单词</strong>。因此索引由此而出现。</p><h5 id="0-2-局部性原理（磁盘IO一次读取大小）">0.2 局部性原理（磁盘IO一次读取大小）</h5><blockquote><p>在继续往下讲之前，先来讲讲磁盘读取局部性原理。</p></blockquote><p>局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与<strong>其相邻的数据也会很快被访问到</strong>。</p><ul><li>因此，当<strong>一次</strong>IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内。</li></ul><p>每次IO读取的数据，分为下面情况：</p><ul><li>Linux：上以<strong>页</strong>为单位，一次一页（<strong>4K</strong>）</li><li>数据库：mysql（InnoDB引擎）一页（<strong>16K</strong>）; SQL Server/ Oracle，默认<strong>块</strong>，大小都是<strong>8KB</strong></li></ul><h5 id="0-3-索引→B-树">0.3 索引→B+树</h5><p>相比二叉树，平衡树等，<strong>B+树</strong> 作为<strong>高度可控的多路搜索树</strong> ，可以很好的满足要求。（详细选择原因，可以参考：<u>5.3 索引相关–问答6</u>）</p><ul><li><p><strong>B+树基本结构</strong></p><p><img src="https://i.loli.net/2021/05/23/xXQFuqgEfpreHdG.jpg" alt="b+树"></p><p>浅蓝色是一个磁盘块，数据项就是被组织索引那<strong>列</strong>的字段值。</p><blockquote><p>如果是Innodb引擎，使用聚簇索引就是按照每张表的 <strong>主键</strong> 构造索引，那么此时<strong>数据项就是主键值</strong>。</p></blockquote><ul><li><p>蓝色部分（如17,35）是数据项；黄色部分（如P1,P2,P3）是指针，指向<strong>下个磁盘块（页地址）</strong>。</p></li><li><p><strong>1. 为什么B+树非叶子节点不存放数据？</strong></p><p>IO次数取决于b+数的高度h，每个磁盘块大小也是一定（一页）的。<strong>如果数据项占的空间越小，一个磁盘块数据项的数量越多，树的高度越低，B+可以更高阶（指针占用先忽略）</strong>。</p><p>所以磁盘<strong>非叶子</strong>节点不保存数据，是为了保存更多的数据项和指针，这样一颗B+树<strong>叶子</strong>节点就能存储更多的数据。</p></li><li><p><strong>2. 数据查找过程？</strong></p><p>以查找<code>数据项=28</code> ，过程为例：<br>（1） 先 <u>加载（一般常驻内存）</u> 根页面1（磁盘块1），因为<code>17&lt;28&lt;35</code> 所以使用<code>P2</code>指针 ， 找到磁盘块3（页面3）<strong>地址</strong></p><p>（2）在 <u>IO加载</u> 磁盘块3，因为 <code>26&lt;28&lt;30</code>  ，因此根据此时的<code>P2</code> 指针，找到磁盘块8所在的地址</p><p>（3） <u>IO加载</u> 磁盘块8，因为此时是叶子节点，可以得到<code>数据项=28</code>对应的<strong>那行记录</strong> 。</p><p>仅仅最多<strong>3</strong>次磁盘IO就找到了数据，这提升是巨大的。</p></li><li><p><strong>3. 高度为3的B+数可以存储多少数据？</strong></p><ul><li><p><strong>叶子节点一页存储的记录数</strong></p><p>mysql一页16K，所以一页存储<code>16K/1K = 16条</code> 记录。（实际真实业务场景一条记录一般就是1K）</p></li><li><p><strong>非叶子节点一页存储的指针数</strong></p><p>由于数据项也要占用空间，其和指针只相差1，按<strong>成对</strong>算。</p><p>假设主键ID（数据项）为bigint类型，长度为<code>8</code>字节，而<code>指针大小</code>在InnoDB源码中设置为<code>6字节</code> 。那么一共<code>14</code>字节。</p><p>所以一页可以存储：<code>16K / 14B ≈ 1K</code> 个指向页面的指针。</p></li><li><p><strong>计算可以存储多少页</strong></p><p>高度为3的B+树，第3层叶子节点存储真实<strong>数据页</strong>，前2层是存储<strong>数据项+指针</strong>。<strong>第二层指针</strong>==叶子节点存储的页面数。</p><ol><li>第一层：根页面可以存储1K个指针，每个指针指向一个新的页面</li><li>第二层：存储 <code>1K*1K = 1M</code> ，约一百万个指针，指向一百万个叶子数据页面</li></ol><p>所以一共存储：<code>1M*16≈16M</code> ，即千万级别的数据。</p></li></ul></li></ul></li></ul><h5 id="0-4-慢查询优化">0.4 慢查询优化</h5><p>（暂略）</p><h4 id="1-MySQ索引的原理和数据结构能介绍一下吗？-索引的缺点？">1. <strong>MySQ索引的原理和数据结构能介绍一下吗？</strong> <strong>索引的缺点？</strong></h4><ul><li><p><strong>索引原理：</strong> 本质是用来优化查询速度。<u>用一个数据结构组织某一列的数据</u>，然后如果你要根据那一列的数据查询的时候，就可以<u>不用全表扫描</u>，只要根据那个特定的数据结构快速去找到那一列的值。</p></li><li><p><strong>数据结构：</strong> MySQL索引通过B+树来实现（按数据结构分也有hash索引、fulltext索引）。</p></li><li><p><strong>索引缺点：</strong> （1）占用磁盘存储空间 （2）降低表更新速度，表发生变化，索引也要发生变化</p></li></ul><h4 id="2-MySQL-索引类型有哪些？">2. <strong>MySQL 索引类型有哪些？</strong></h4><p>按数据结构分类可分为：<strong>B+tree索引、Hash索引、Full-text索引</strong>。<br>按物理存储分类可分为：<strong>聚簇索引、二级索引（辅助索引）</strong>。<br>按字段特性分类可分为：<strong>主键索引、普通索引、前缀索引</strong>。<br>按字段个数分类可分为：<strong>单列索引、联合索引（复合索引、组合索引）</strong>。</p><ul><li><p><strong>主键索引</strong>：索引列中的值必须是唯一的，不允许有空值；</p></li><li><p><strong>唯一索引</strong>：索引列中的值必须是唯一的，但是允许为空值；</p></li><li><p><strong>普通索引</strong>：MySQL中<u>基本索引类型</u>，没有什么限制，允许在定义索引的列中插入重复值和空值；</p></li><li><p><strong>全文索引</strong>：只能在<strong>文本类型CHAR,VARCHAR,TEXT</strong>类型字段上创建全文索引；</p><blockquote><p>字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引；</p><p>MyISAM和InnoDB中都可以使用全文索引。</p></blockquote></li><li><p><strong>前缀索引</strong>：在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定；</p></li><li><p><strong>空间索引</strong>： MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。</p><blockquote><p>MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。</p></blockquote></li></ul><h5 id="2-1-什么是覆盖索引？">2.1 什么是覆盖索引？</h5><p>我们在<u>非聚簇索</u>引一般只获得了，记录的key值（Innodb引擎），还需要回到聚簇索引中<strong>再次查询</strong>。</p><ul><li><strong>覆盖索引：</strong> 从<strong>非主键索引中就能查到的记录</strong>，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。</li></ul><blockquote><p>一个小例子。</p></blockquote><p>以name和age两个字段建立<strong>联合索引</strong>，sql命令与建立后的索引树结构如下：</p><img src="https://i.loli.net/2021/05/28/V2ApYvt9zWGFhcf.png" alt="image-20210526230732546" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student DROP INDEX I_name;</span><br><span class="line">ALTER TABLE student ADD INDEX I_name_age(name, age);</span><br></pre></td></tr></table></figure><p>此时执行如下sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT age FROM student WHERE name = &#x27;小李&#x27;；</span><br></pre></td></tr></table></figure><p>在<strong>非聚簇索引中包含了age信息</strong>，那么直接返回12，不需要再到聚簇索引中查询。</p><h4 id="【重点】3-什么时候使用索引比较好？-什么时候不要使用索引？">【重点】3. **什么时候使用索引比较好？**什么时候不要使用索引？</h4><h5 id="3-1-什么时候用索引">3.1 什么时候用索引</h5><blockquote><p>特别的，主键自动建立唯一索引。</p></blockquote><ol><li><p><strong>频繁</strong>作为查询条件的字段应该创建索引 ；</p></li><li><p><strong>查询中与其他表关联的字段</strong>，外键关系建立索引；</p></li><li><p><strong>查询中排序的字段</strong>，排序字段若通过索引去访问将大大提高排序速度（<strong>索引就是排序加快速查找</strong>）；</p></li><li><p><strong>查询中统计或者分组字段</strong>。</p></li></ol><h5 id="3-2-什么时候不用索引">3.2 什么时候不用索引</h5><ol><li><p><strong>经常增删改</strong>的列不要建立索引（因为每次更新不单单是更新记录，还会更新索引，保存索引文件）；</p></li><li><p><strong>表记录太少</strong>不要建立索引；</p></li><li><p>（被CSIG问过）**区分度低，**数据重复且分布平均的字段不适合做索引；</p><blockquote><p>例如性别字段，只有男女，不适合建立索引。</p><ul><li>因为从索引中拿到的只是地址，要想真正访问到数据还是要对表进行一次IO；</li><li>假如你要从表的100万行数据中取几个数据，那么利用索引迅速定位，访问索引的这IO开销就非常值了；</li><li>但如果你是从100万行数据中取50万行数据，就比如性别字段，那你相对需要 <u>访问50万次索引，再访问50万次表</u>，加起来的开销并不会比直接对表进行一次完整扫描小。</li></ul></blockquote></li><li><p><strong>text，image</strong>等类型不应该建立索引，<strong>这些列的数据量大</strong>；</p></li><li><p><strong>多个单列索引并不是最佳选择</strong> MySQL 只能使用一个索引，会从多个索引中选择一个限制最为严格的索引 ；</p></li><li><p><strong>参加运算 或 作为函数参值等字段</strong>，不要建立索引，这会使得索引失效而全表扫描 。</p></li></ol><h4 id="4-主键与唯一索引有什么区别？">4. <strong>主键与唯一索引有什么区别？</strong></h4><ul><li><p>主键一<strong>定会创建一个唯一索引，但是有唯一索引的列不一定是主键；</strong></p></li><li><p>主键不允许为空值，唯一索引列允许空值；</p></li><li><p>一个表只能有一个主键，但是可以有多个唯一索引；</p></li><li><p>主键可以被<strong>其他表引用为外键，唯一索引列不可以；</strong></p></li><li><p>主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本质差别。</p></li></ul><h4 id="5-b-树和b树有什么区别？">5. <strong>b+树和b树有什么区别？</strong></h4><p>B树：</p><p><img src="https://i.loli.net/2021/04/21/YsAxSctJ1wKUm3g.png" alt="clip_image002"></p><ul><li>索引与数据存储在每个节点中（增加了IO次数）；</li><li>搜索过程有可能在非叶子节点结束（最好情况下<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>）。</li></ul><p>B+树：</p><p><img src="https://i.loli.net/2021/04/21/ihT3SbqwodNUvPe.png" alt="clip_image039"></p><ul><li>所有数据<strong>按顺序</strong>存储在叶子节点中；</li><li>所有叶子节点被<strong>双向链连接</strong>；</li><li>搜索过程固定时间复杂度（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>）；</li><li>（优点易忘）<u>适合范围查找，降低磁盘IO次数</u>。</li></ul><h4 id="6-为什么MySQL使用B-树作为索引？而不是平衡二叉树、红黑树、B树、或者Hash？">6. <strong>为什么MySQL使用B+树作为索引？而不是平衡二叉树、红黑树、B树、或者Hash？</strong></h4><ul><li><p><strong>不用平衡二叉树或者红黑树：</strong> 树的查询时间和树的结构有关，B+树是一颗多路搜索数，可以降低树的高度提高查询速度。</p></li><li><p><strong>不用B树：</strong> （1）无法范围查询，而<strong>B+树所有叶子节点形成有序链表便于范围查询</strong>；（2）N阶B+数，B树，B+数可以存储n个关键字，而B树是n个。</p></li><li><p><strong>不用Hash：</strong> （1）B+树允许分配加载节点，如果内存数据太大B+树更好（2）B+树更适合范围查询</p><blockquote><p>用Hash需要把数据全部<strong>加载到内存中</strong>，如果数据量大，是一件很<strong>消耗内存</strong>的事，而采用B+树，是基于<strong>按照节点分段加载，由此减少内存消耗</strong>。</p></blockquote></li></ul><h5 id="6-1-无限增加树的路数是不是可以有最优的查找效率？">6.1 <strong>无限增加树的路数是不是可以有最优的查找效率？</strong></h5><ul><li><p>这样会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，<u>不一定能一次性加载到内存中</u>。</p></li><li><p><strong>有序数组没法一次性加载进内存</strong>，这时候B+树的多路存储威力就出来了，<strong>可以每次加载B+树的一个结点，然后一步步往下找</strong>。</p></li></ul><h4 id="7-B-树怎么进行分裂、合并的？知道具体步骤吗？">7. <strong>B+树怎么进行分裂、合并的？知道具体步骤吗？</strong></h4><blockquote><p>参考：<a href="https://www.cnblogs.com/nullzx/p/8729425.htm">https://www.cnblogs.com/nullzx/p/8729425.htm</a></p></blockquote><p><img src="https://i.loli.net/2021/04/21/aejwRD2WxNb7slY.png" alt="image-20210421124006795"></p><h4 id="8-MySQL聚簇索引和非聚簇索引的区别是什么？">8. <strong>MySQL聚簇索引和非聚簇索引的区别是什么？</strong></h4><ul><li><p><strong>主要区别</strong></p><ul><li><p><strong>聚簇索引</strong> ： 找到索引就找到了需要的数据，那么这个索引就是聚簇索引;</p><blockquote><p>所以Innodb主键就是<strong>聚簇索引</strong>，修改聚簇索引其实就是修改主键；但在<u>Myisam下主键索引是非聚集索引</u>。</p><p>InnoDB 会<strong>隐式定义一个主键</strong>来作为聚簇索引（但是这个主键如果更改代价较高，<u>故建表时要考虑自增ID不能频繁update</u>这点）。</p></blockquote><p><img src="https://i.loli.net/2021/05/03/mzwGgCjxuIpaeA7.png" alt="img"></p></li><li><p><strong>非聚簇索引：<strong>索引的存储和数据的存储是分离的 , 找到了索引但没找到数据，需要根<u>据</strong>索引上的值(主键/地址)再次回表查询</strong></u>，<strong>也叫做辅助索引</strong>。</p><blockquote><p>MyISM使用的是非聚簇索引 ，下图叶节点的<strong>data域存放的是数据记录的地址</strong> 。</p></blockquote><p><img src="https://i.loli.net/2021/05/03/A1X5aOY6qkuEol9.png" alt="img"></p></li></ul></li><li><p><strong>聚簇索引查找过程</strong></p><blockquote><p>首先澄清一个概念，聚簇索引和和辅助索引。</p><p>Innodb存储引擎的B+树分为，聚簇索引保存的是放着一整行的数据；辅助索引都引用<u>主键作为data域</u>。</p><p>例如，下图以Col3建立一个<strong>Innodb辅助索引</strong> ：</p><p><img src="https://i.loli.net/2021/05/03/l1IHbpgGAYr73sT.png" alt="img"></p><p>对于MyISAM，主索引和辅助索引（Secondary key）在结构上没有任何区别。<strong>只是主索引要求key是唯一的，而辅助索引的key可以重复</strong>。</p><p>例如，下图以Col2建立一个<strong>MyISAM的辅助索引</strong>：</p><p><img src="https://i.loli.net/2021/05/03/9jpKvRbIWFwucLT.png" alt="img"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * Where name=‘Alice’</span><br></pre></td></tr></table></figure><p>首先根据<u>辅助索引</u> ，在叶子节点找到**0X56对应主键值<code>18</code> ；**然后在<u>聚簇索引</u>，根据<code>18</code> 找到对应行数据。</p></li></ul><h5 id="8-1-看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B-树查找，这不是多此一举吗？聚簇索引的优势在哪？">8.1 <strong>看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，这不是多此一举吗？聚簇索引的优势在哪？</strong></h5><ul><li><p>**重复访问同一页更快：**由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，<strong>已经把页加载到了Buffer中</strong>，<strong>再次访问的时候，会在内存中完成访问</strong>，不必访问磁盘；</p><blockquote><p>B+树的每个节点的数量都是一个mysql分区页的大小(阿里面试) 。</p></blockquote></li><li><p><strong>辅助索引使用主键值作为指针：</strong> 辅助索引使用主键作为&quot;指针&quot;而不是使用地址值作为指针（MyISAM） ，<strong>减少了当出现【行移动】或者数据页分裂时（<u>地址值变化</u>）辅助索引的维护工作</strong> 。</p></li></ul><h5 id="8-2-为什么name-age这些字段不适合做索引？">8.2 为什么name,age这些字段不适合做索引？</h5><p>在InnoDB中每一个表都会有聚集索引，如果表定义了主键，则（默认）主键就是聚簇索引。</p><p>一个表只有一个聚集索引，其余为普通索引。所以name，age就是普通索引，也就是作为辅助索引。</p><p>在使用普通索引name查询时，会先加载普通索引：</p><p>（1）通过普通索引查询到实际行的主键</p><p>（2）再使用主键通过聚集索引查询相应的行</p><p>（3）以此<strong>循环查询所有的行</strong><br>若直接全量搜索聚集索引，则不需要在普通索引和聚集索引中来回切换。相比两种操作的总开销可能扫描全表效率更高。</p><h4 id="9-MySQL联合索引如何使用？-什么是最左匹配原则？">9. <strong>MySQL联合索引如何使用？</strong> <strong>什么是最左匹配原则？</strong></h4><blockquote><p>参考：<a href="https://blog.csdn.net/Abysscarry/article/details/80792876">https://blog.csdn.net/Abysscarry/article/details/80792876</a></p></blockquote><p>对多个字段同时建立的索引(有顺序，ABC，ACB是完全不同的两种联合索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test` (</span><br><span class="line">  `id` int(4) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `a` varchar(10) NOT NULL,</span><br><span class="line">  `b` varchar(10) NOT NULL,</span><br><span class="line">  `c` varchar(10) NOT NULL,</span><br><span class="line">  `d` varchar(10) NOT NULL,</span><br><span class="line">  `e` varchar(10) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  # 联合索引(a,b,c)</span><br><span class="line">  UNIQUE KEY `idx_a_b_c` (`a`,`b`,`c`) USING BTREE </span><br><span class="line">) ENGINE=I</span><br></pre></td></tr></table></figure><p>以联合索引(a,b,c)为例：</p><ul><li><p><strong>建立这样的索引相当于建立了索引a、ab、abc三个索引</strong>。一个索引顶三个索引当然是好事，毕竟每多一个索引，都会增加写操作的开销和磁盘空间的开销。</p><blockquote><p>**a,c **组合也可以但不是为他建立了索引，但实际上只用到了a的索引，c并没有用到！</p></blockquote></li><li><p><strong>最左匹配原则</strong></p><p>最左优先，在检索数据时从联合索引的最左边开始匹配，<strong>即是where条件必须有联合索引的第一个字段。</strong></p><ul><li><p>不包含第一个字段</p><p>不会走索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  * from test where  b = &#x27;333&#x27; and c = &#x27;333&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>where和索引顺序不一样</p><p>会走索引，<u>和顺序无关</u>。</p><blockquote><p>where 后面列的顺序是被<strong>优化器</strong>优化了的，所以才会觉得无影响，你可以查看一下优化器优化后的语句，会帮你调整为满足最左前缀的顺序。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  * from test where c = &#x27;333&#x27; and b = &#x27;333&#x27; and a = &#x27;333&#x27;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="9-1-联合索引的好处？">9.1 联合索引的好处？</h5><h4 id="10-（还要补充）介绍一下索引失效的原因？">10. （还要补充）介绍一下索引失效的原因？</h4><blockquote><p>很不错的一篇文章：<a href="https://cloud.tencent.com/developer/article/1704743">索引失效原理，终于有人讲明白了</a></p><p>结合这篇文章：<a href="https://juejin.cn/post/6844904073955639304">https://juejin.cn/post/6844904073955639304</a></p></blockquote><p>假设mysql 存在联合索引（a,b），显然也是一颗B+树:</p><p><img src="https://i.loli.net/2021/05/24/GlDckpZzWTnodIf.png" alt="image-20210524114029113"></p><ul><li><p><strong>不符合最左匹配失效</strong></p><ol><li><p>情况1 ：<code>select * from testTable where b=2</code></p><p>联合索引是通过第一个索引<code>a</code> 来构建B+树，进行定位二分查找的，不能直接通过<code>b</code> 来进行二分查找。</p></li><li><p>情况2：<code>like</code>查询失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">where name like &quot;a%&quot;  # 会有效，因为可以匹配到首字母</span><br><span class="line"></span><br><span class="line">where name like &quot;%a%&quot; # 首字母是任意匹配的，所以索引用不上</span><br><span class="line"></span><br><span class="line">where name like &quot;%a&quot; # 同上，不能根据尾字母来索引</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>范围查询失效</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from testTable where a&gt;1 and b=2</span><br></pre></td></tr></table></figure><p>首先<strong>a字段在B+树上是有序</strong>的，所以可以用二分查找法定位到1，然后将所有大于1的数据取出来，a可以用到索引。</p><p><strong>b有序的前提是a是确定的值</strong>，那么现在a的值是取大于1的，可能有10个大于1的a，也可能有一百个a。</p><p>大于1的a那部分的B+树里，b字段是无序的（开局一张图），所以b不能在无序的B+树里用二分查找来查询，b用不到索引。</p></li><li><p><strong>多个单列索引</strong></p><p>我们首先建立了三个单列索引：userid，mobile，billMonth。然后使用以下查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE  userid=&#x27;2222&#x27; AND mobile=&#x27;13281899972&#x27; AND billMonth=&#x27;2018-04&#x27;</span><br></pre></td></tr></table></figure><ul><li><p><code>explain</code> 结果分析，最终只有<code>userid</code> 这<strong>一个索引有效</strong>。</p><blockquote><p>此处<code>userid 、mobile 、billMonth</code>这三个索引列都能用，只不过<strong>优化器判断使用<code>userid</code>这一个索引能最高效完成本次查询</strong>，故最终explain展示的key为userid。</p></blockquote></li></ul><p>特别的，如果改为 <code>or</code> 进行判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE  userid=&#x27;2222&#x27; OR mobile=&#x27;13281899972&#x27; </span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/24/UDQxsm7YIrglvu8.png" alt="这里写图片描述"></p><ul><li><p><strong>此时两个索引 userid &amp; mobile都用上了</strong>。</p><blockquote><p>mysql <u>5.0 版本之前</u> 使用or<strong>只会用到一个索引</strong>, 自从<u>5.0版本开始</u> ，引入了index_merge索引合并优化！也就是说，我们现在可以利用上多个索引去优化or查询了。</p></blockquote></li></ul></li><li><p><strong>或者索引加上了运算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c - 1 = 1000;</span><br></pre></td></tr></table></figure><p>这种情况不会有效，应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c = 1000 + 1;</span><br></pre></td></tr></table></figure><p>又比如用了函数操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where pow(c,2) = 1000;</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-【-warning-新增】索引实战篇">11. 【:warning: 新增】索引实战篇</h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/115778804">https://zhuanlan.zhihu.com/p/115778804</a></p></blockquote><ol><li><p><code>where a=xxx and b=xxx order by c</code>  ，如何建立索引？</p><p>建立联合索引<code>（a,b,c）</code> ，因为这样的话<strong>无需做一次额外的排序操作</strong>。</p><p>因为建立联合索引时，根据最左匹配原则，先按<code>a</code>排序，再按<code>b</code>排序，最后按<code>c</code> 排序。根据联合索引检索到，<code>a=xxx and b=xxx</code>条件时，再去检索<code>c</code>本身已排序的。那么不用 <code>order by c</code> ，不用进行文件排序。</p><ul><li>注意，建立联合索引 <code>（a,b）</code> , 则是走不到 sort的！</li></ul></li><li><p><code>where a=xxx  order by b,c</code>  ，如何建立索引？</p><p>道理同上，建立<code>（a,b,c）</code> 。</p></li><li><p><code>where a &gt; 1 ORDER BY b</code>，怎么建立索引？</p><p>建立索引（a）即可，因为a是范围查询：</p><ul><li>建立（a,b）的 话b也用不上，因为是a是范围查询；</li><li>建立（b,a）, <strong>b按索引排好序，a&gt;1可以用上？错误，因为先where筛选才会order by！</strong></li></ul></li><li><p><code>where a=1 and b=2 and c&gt;3 and d=4</code> ，如何建立索引？</p><p>建立联合索引，<code>(a,b,d,c)</code>  即可。</p><ul><li>但是对于建立<code>(a,b,c,d)</code> ，<strong>a,b,c三个字段能用到索引，而d就匹配不到</strong>，因为遇到了<strong>范围查询，在c&gt;3这个范围内，d不是有序的；但是c=3，这个范围内，d是有序的</strong>！</li></ul></li><li><p><code>where a &gt; 1 and b = 2 and c &gt; 3</code>，如何建立索引？</p><p>建立（b,c）或者（b,a）即可，但至少有一个索引要失效（遇上范围查询）。</p></li><li><p><code>WHERE a IN (1,2,3) and b &gt; 1</code>，怎么建立索引？</p><p>还是对(a，b)建立索引，因为IN在这里可以视为等值引用，不会中止索引匹配，所以还是(a,b)！</p></li></ol><h4 id="12-order-by-怎么进行排序的？怎么优化？">12. order by 怎么进行排序的？怎么优化？</h4><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000040357292">https://segmentfault.com/a/1190000040357292</a></p></blockquote><p>假设存在以下数据：</p><p><img src="https://i.loli.net/2021/09/04/cudfwqEHGmn3Ppt.png" alt="image-20210904013336980"></p><p>此时进行如下查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select city, order_num, user_code from `order` where city=&#x27;广州&#x27; order by order_num limit 1000;</span><br></pre></td></tr></table></figure><ol><li><p><strong>建立索引(city)：order by过程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `order` ADD INDEX city_index ( `city` );</span><br></pre></td></tr></table></figure><img src="D:/hwh/images/image-20210904013506155.png" alt="image-20210904013506155" style="zoom:80%;" /><ul><li><p><strong>用 explain 看看执行情况</strong></p><p><img src="https://i.loli.net/2021/09/04/lv3uyaxWkKPtqjd.png" alt="img"></p><p>注意到最后一个 extra 字段的结果是：<strong>Using filesort</strong>，表示需要排序。<strong>其实 MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer</strong>。</p></li><li><p><strong>完整执行过程</strong></p><img src="https://i.loli.net/2021/09/04/Pm7eJ1vQFg8l2xA.png" alt="image-20210904013732363" style="zoom:80%;" /><ol><li><p>初始化 <strong>sort_buffer</strong>，放入 <code>city、order_num、user_code</code> 这三个字段；</p></li><li><p>从索引 city 找到第一个满足 city=’ 广州’条件的主键 id，也就是图中的 ID_3；</p></li><li><p><strong>到主键 id 索引取出整行</strong>，取 city、order_num、user_code 三个字段的值，存入 sort_buffer 中；</p></li><li><p>从索引 city 取下一个记录的主键 id；</p></li><li><p>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_X；</p></li><li><p>对 sort_buffer 中的数据按照字段 <strong>order_num 做快速排序</strong>；</p><blockquote><p>其中，<strong>按 order_num 排序</strong>这个步骤，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 <strong>sort_buffer_size</strong>。</p></blockquote></li><li><p>按照排序结果取前 1000 行返回给客户端。</p></li></ol></li></ul></li><li><p><strong>优化1：使用rowid</strong></p><p>上面的全字段排序其实会有很大的问题，你可能发现了。<strong>我们需要查询的字段都要放到 sort_buffer 中，如果查询的字段多了起来，内存占用升高，就会很容易打满 sort_buffer</strong> 。</p><ul><li><p><strong>sort_buffer 只存 order_num 和 id 字段</strong>。</p><img src="https://i.loli.net/2021/09/04/PRwrO4ae3BJLciH.png" alt="img" style="zoom:80%;" /><ol><li>初始化 sort_buffer，确定放入两个字段，即 order_num 和 id；</li><li>从索引 city 找到第一个满足 city=’ 广州’条件的主键 id，也就是图中的 ID_3；</li><li><strong>回表</strong>，取 order_num、id 这两个字段，存入 sort_buffer 中；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到不满足 city=’ 广州’条件为止，也就是图中的 ID_X；</li><li>对 sort_buffer 中的数据按照字段 order_num 进行排序；</li><li>遍历排序结果，取前 1000 行，再次回表取出 city、order_num 和 user_code 三个字段返回给客户端。</li></ol></li></ul></li><li><p><strong>优化2：建立联合索引</strong></p><p>参见索引部分解释，不再赘述。</p><img src="https://segmentfault.com/img/remote/1460000040357304" alt="img" style="zoom:80%;" /><ol><li><p>从索引 (city,order_num) 找到第一个满足 city=’ 广州’条件的主键 id；</p></li><li><p>回表，取 city、order_num、user_code 三个字段的值，作为结果集的一部分直接返回；</p></li><li><p>从索引 (city,order_num) 取下一个记录主键 id；</p></li><li><p>重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’ 广州’条件时循环结束。</p></li></ol></li></ol><h2 id="5-3-事务相关">5.3 事务相关</h2><h4 id="1-请介绍一下数据库事务？和-u-事务特性-u-（ACID）？">1. <strong>请介绍一下数据库事务？和<u>事务特性</u>（ACID）？</strong></h4><ul><li><p><strong>数据库事务：</strong> 数据库事务指的是一组数据操作，事务内的操作要么就是全部成功，要么就是全部失败。</p><blockquote><p><em>e.g.</em>  假设一个网购付款的操作，用户付款后要涉及到订单状态更新、扣库存以及其他一系列动作，这就是一个事务，如果一切正常那就相安无事，一旦中间有某个环节异常，那整个事务就要回滚，总不能更新了订单状态但是不扣库存吧。</p></blockquote></li><li><p><strong>事务特性：</strong>（1） 原子性（Atomicity）：一个事务必须视为一个不可分割的最小工作单元，要么都成功要么都失败（2）一致性（Consistency）：数据库总能从一个<strong>一致性的状态转换到另一个一致性的状态</strong>（3）隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的（4）持久性（Durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中</p></li></ul><h5 id="1-1-四大特性得不到保障会出现什么情况？">1.1 四大特性得不到保障会出现什么情况？</h5><blockquote><p>们以从A账户转账50元到B账户为例进行说明一下ACID这四大特性。</p></blockquote><ul><li><p><strong>原子性</strong> : 原子性是指一个事务是一个不可分割的工作单位，<strong>其中的操作要么都做，要么都不做</strong>。即要么转账成功，要么转账失败，是不存在中间的状态。</p><blockquote><p><strong>如果无法保证原子性会怎么样？</strong></p></blockquote><p>会出现数据不一致的情形，A账户减去50元，而B账户增加50元操作失败。系统将无故丢失50元~</p></li><li><p><strong>一致性</strong> ：一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的。 那什么是合法的数据状态呢？这个状态是满足预定的约束就叫做合法的状态，再通俗一点，这状态是由你自己来定义的。<strong>满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的。</strong></p><blockquote><p><strong>如果无法保证一致性会怎么样？</strong></p></blockquote><ul><li><p>例一: A账户有200元，转账300元出去，此时A账户余额为-100元。</p><p>你自然就发现了此时数据是不一致的，为什么呢？因为你定义了一个状态，<strong>余额这列必须大于0</strong>。</p></li><li><p>例二：A账户200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。</p><p>你也知道此时数据是不一致的，为什么呢？因为你定义了一个状态，<strong>要求A+B的余额必须不变</strong>。</p></li></ul></li><li><p><strong>隔离性</strong> ：隔离性是指<strong>多个事务并发执行的时候，事务内部的操作与其他事务是隔离的</strong>，并发执行的各个事务之间不能互相干扰。</p><blockquote><p><strong>如果无法保证隔离性会怎么样</strong>？</p></blockquote><p>假设A账户有200元，B账户0元。A账户往B账户转账两次，金额为50元，分别在两个事务中执行。</p><p>如果无法保证隔离性，A可能就会出现扣款两次的情形，而B只加款一次，凭空消失了50元，依然出现了数据不一致的情形！</p></li><li><p><strong>持久性</strong> : 根据定义，<strong>持久性是指事务一旦提交，它对数据库的改变就应该是永久性的</strong>。接下来的其他操作或故障不应该对其有任何影响。</p><blockquote><p><strong>如果无法保证持久性会怎么样？</strong></p></blockquote><p>在MySQL中，为了解决CPU和磁盘速度不一致问题，MySQL是将磁盘上的数据加载到内存，对内存进行操作，然后再回写磁盘。好，假设此时宕机了，在内存中修改的数据全部丢失了，持久性就无法保证。</p><p>设想一下，系统提示你转账成功。但是你发现金额没有发生任何改变，此时数据出现了不合法的数据状态，我们将这种状态认为是<strong>数据不一致</strong>的情形。</p></li></ul><h5 id="1-2-数据库如何保证四大特性？">1.2 数据库如何保证四大特性？</h5><ul><li><p><strong>保证原子性</strong> ：主要是利用 Innodb 的<strong>undo log</strong>。 <strong>undo log</strong>名为回滚日志，是实现原子性的关键，当<strong>事务回滚时能够撤销所有已经成功执行的 SQL语句</strong>，他需要记录你要回滚的相应日志信息 。</p><blockquote><ul><li>当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据</li><li>当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作</li><li>…</li></ul></blockquote></li><li><p><strong>保证一致性：</strong> 分为以下两个方面阐述。</p><ul><li><strong>从数据库层面</strong>，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。<strong>数据库必须要实现AID三大特性，才有可能实现一致性</strong>；</li><li><strong>从应用层面</strong>，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据。</li></ul></li><li><p><strong>保证隔离性：</strong></p></li><li><p><strong>保证持久性：</strong> 主要是利用Innodb的<strong>redo log</strong>，重写日志。</p><blockquote><p>正如之前说的，MySQL是先把磁盘上的数据（加载一页16kb）加载到内存中，在内存中对数据进行修改，再写回到磁盘上。如果此时突然宕机，内存中的数据就会丢失。 怎么解决这个问题？</p></blockquote><ul><li><p><strong>事务提交前直接写入磁盘不经过内存：</strong>  但是有以下缺点</p><ol><li>只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了；</li><li>一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。</li></ol></li><li><p><strong>采用redo log（推荐）：</strong>   当做数据修改的时候，不仅在内存中操作，还会在<strong>redo log</strong>中记录这次操作。</p><ol><li>当事务提交的时候，会将<strong>redo log</strong>日志进行<strong>刷盘</strong>(<strong>redo log</strong>一部分在内存中，一部分在磁盘上)；</li><li>当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据<strong>undo log</strong>和<strong>binlog</strong>内容决定回滚数据还是提交数据。</li></ol><p>redo log的优点：</p><ol><li><p><strong>redo log</strong>体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快；</p></li><li><p><strong>redo log</strong>是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。</p></li></ol></li></ul></li></ul><h4 id="2-介绍一下（并发）事务不同隔离级别？-对应可能出现的问题？">2. <strong>介绍一下（并发）事务不同隔离级别？</strong> <strong>对应可能出现的问题？</strong></h4><blockquote><p>参考：<a href="https://www.cnblogs.com/shan-kylin/p/9543294.html">https://www.cnblogs.com/shan-kylin/p/9543294.html</a></p></blockquote><p>下面<strong>排它锁和共享锁</strong>都是<strong>行锁</strong>，锁住一行。</p><ul><li><p><strong>Read uncommitted：</strong> 顾名思义，就是一个事务可以读取另一个未提交事务的数据。但这种情况会出现<strong>脏读：</strong> 因为<strong>写</strong>数据的时候添加一个<strong>X锁（排他锁，拿到锁的事务可以写，其它事务只能等待阻塞）</strong>；但<strong>读</strong>不受限制，读不加锁。</p><blockquote><p>由于读不加锁，读的是可能是修改前（未提交）的数据，也就是<strong>脏读</strong>。</p></blockquote></li><li><p><strong>Read Committed ：写</strong>数据的时候加上<strong>X锁（排他锁）</strong>，<strong>读</strong>数据的时候添加<strong>S锁（共享锁，拿到锁的事务可以查看但无法修改和删除，其它事务【只能加S锁】【不能加其它锁】如X锁）</strong>。解决脏读，但会导致出现<strong>不可重复读</strong>的问题。</p><blockquote><ol><li>初始x=100,；</li><li>事务A<strong>读</strong>x，加上<strong>S锁</strong>，读到x=<strong>100</strong>，<strong>立即释放S锁且未提交</strong>；</li><li>事务B<strong>修改</strong>x，加上<strong>X锁</strong>，修改x=50，提交 ；</li><li>事务A再次<strong>读取x</strong>，加上<strong>S锁</strong>，读取x=<strong>50</strong>，发现和第一次读取不一致，提交事务。</li></ol><p>上述过程，事务A在提交前读取两次不一样的x值，为<strong>不可重复读</strong>。</p></blockquote></li><li><p><strong>Repeatable read</strong> ：<strong>MySQL 默认隔离界别</strong> , 开始<strong>读取</strong>数据（事务开启）时，<strong>【S】锁不再立即释放，其它事务就不能加上【X】锁修改数据</strong>。解决了脏读、不可重复读，但是可能会出现<strong>幻读：</strong>-</p><ul><li>Mysql官方给出的幻读解释是：<strong>只要在一个事务中，第二次select（读）多出了row就算幻读</strong>。</li></ul><blockquote><p>现在做如下修改：</p><ul><li>写：X锁保持不变</li><li>读：S锁，<strong>读完不再立即释放</strong>，而是<strong>在提交的时候再释放</strong>。</li></ul><p>这样的话，保证事务A在<u>提交前</u>，读取的x是一致的。解决了<strong>不可重复读</strong>，但依旧可能出现<strong>幻读</strong>。例如，<strong>X锁不能阻止（表中其它记录）插入操作，因为只锁住了当前记录，是行级锁</strong>。</p><ol><li>事务A加上X锁，更新了<strong>所有用户</strong>年龄从<code>20→18</code>；</li><li>过一会儿再读发现<strong>还有一个用户没修改</strong>，还是20岁？出现幻觉了吗？</li></ol><p>这是因为，其它事务B同时插入了一行新数据，年龄就是20岁。所以再读发现没修改。</p></blockquote></li><li><p><strong>Serializable ：</strong> 序列化，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。耗费性能，一般不用。</p></li></ul><h5 id="2-1【猿辅导】-怎么解决幻读？">2.1【猿辅导】 怎么解决幻读？</h5><p>解决幻读使用两种方式：</p><ol><li><p><strong>间隙锁</strong></p><ul><li><p><strong>间隙锁（Gap Lock）</strong>：<strong>当我们用【范围条件】而不是相等条件检索数据，并请求共享或排他锁时</strong>，InnoDB会给<strong>符合条件的已有数据记录的索引项加锁</strong>；对于键值在<strong>条件范围内但并不存在的记录，叫做“间隙（GAP)”</strong>，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁；</p></li><li><p><strong>举例：</strong> 假如user表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  <span class="keyword">user</span> <span class="keyword">where</span> user_id <span class="operator">&gt;</span> <span class="number">99</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><p>是一个范围条件的检索，InnoDB不仅会对（1）<strong>符合条件的user_id值（100、101）的记录加锁</strong>，也会对（2）user_id大于101（这些<strong>记录并不存在）的“间隙”加锁</strong>。</p></li><li><p><strong>如何解决幻读？</strong> 产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”，导致下次读取产生幻读。如果锁住了间隙，自然也就没锁的问题了。</p></li></ul></li><li><p><strong>mvvc</strong></p><p>在RR（可重复读级别下）不会出现幻读。例如：</p><ol><li><p>开启事务1，获得事务ID为1。</p></li><li><p>事务1执行查询，得到readview。</p></li><li><p>开始事务2。</p></li><li><p>执行insert。</p></li><li><p>提交事务2。</p></li><li><p>执行事务1的第二次查询 (因为这里是RR级别，所以<strong>不会再去获得readview，<strong>还是使用第一次获得的readview，所以</strong>当前read view 事务的ID不会更新</strong>，即不会加入插入事务2)</p></li><li><p>最后得到的结果是，插入的数据不会被读取显示，因为<strong>插入的数据事务ID &gt; readview里的最大活跃事务ID</strong>。</p></li></ol></li></ol><h4 id="3-Mysql怎么保证事务的原子性？持久性？">3. Mysql怎么保证事务的原子性？持久性？</h4><blockquote><p>参考：<a href="https://cloud.tencent.com/developer/article/1600883">https://cloud.tencent.com/developer/article/1600883</a></p></blockquote><ul><li><p><strong>原子性</strong></p><p>是利用Innodb的<strong>undo log</strong>。</p><p>undo log名为回滚日志，是实现原子性的关键，当<strong>事务回滚时能够撤销所有已经成功执行的sql语句</strong>，他需要记录你要回滚的相应日志信息。</p><p>例如</p><ul><li>(1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据</li><li>(2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作</li><li>(3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操</li></ul><p>undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p></li><li><p><strong>持久性</strong></p><p>利用Innodb的<strong>redo log</strong>，为什么要使用redo log，请看下面：</p><ul><li>正如之前说的，Mysql是把磁盘上的数据<strong>先加载到内存</strong>中，在内存中对数据进行修改，再刷回磁盘上。<strong>如果此时突然宕机，内存中的数据就会丢失；</strong></li><li><strong>如果事务提交前直接把数据写入磁盘，只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了</strong>。</li></ul><p><strong>redo log解决方案：</strong></p><ul><li>当做数据修改的时候，<strong>不仅在内存中操作，还会在redo log中记录这次操作</strong>；</li><li>当事务提交的时候，<strong>会将redo log日志进行刷盘</strong>(redo log一部分在内存中，一部分在磁盘上)；</li><li><strong>当数据库宕机重启</strong>的时候，会将redo log中的内容恢复到数据库中，<strong>再根据undo log和binlog内容决定回滚数据</strong>还是提交数据。</li></ul></li></ul><h2 id="5-4-MySQ优化">5.4 MySQ优化</h2><h4 id="0-分页查询慢的原因？如何优化？">0. 分页查询慢的原因？如何优化？</h4><blockquote><p>参考：<a href="https://juejin.cn/post/6844904141878214664">https://juejin.cn/post/6844904141878214664</a></p></blockquote><p>在偏移量非常大的时候，也就是翻页到很靠后的页面时，查询速度会变得越来越慢，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_order order by id limit 1000000000, 10;</span><br></pre></td></tr></table></figure><p>这是因为，需要查询 100000000010 (100000000000 + 10) 条记录，然后只返回最后 10 条，并将前面的 100000000000 条记录抛弃，这样当翻页越靠后时，代价就变得越来越高。</p><p><strong>优化方法：</strong></p><ol><li><p><strong>最大id法</strong></p><ul><li><p>举例：查询第一页的时候是limit 400000,10 查询到的最后一条id是4000000，那么下一页的查询只需要查询id大于400000的10条数据即可。</p></li><li><p>语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from user where id &gt; 4000000  limit 10;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>BETWEEN … AND</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id BETWEEN 4000000 and 4000010</span><br></pre></td></tr></table></figure></li><li><p><strong>分表查询</strong></p><p>mysql推荐一张表的存储不要超过500w数据，查询400w不到1秒对于一般的查询来说已经可以了，如果还要更快的话，我建议使用分表存储，分表又分两种情况，水平分表于垂直分表。</p></li><li><p><strong>延迟关联（个人推荐）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table a,(select id from table limit 100000,20) b on a.id=b.id</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-SQL优化手段有哪些？">1. <strong>SQL优化手段有哪些？</strong></h4><ol><li><p>**查询语句中不要使用select ***</p></li><li><p><strong>尽量减少子查询，使用关联查询</strong>（left join,right join,inner join）替代</p></li><li><p><strong>减少使用IN或者NOT IN ,使用exists，not exists</strong>或者关联查询语句替代(在确认没有重复数据或者不用剔除重复数据时，union all会更好)</p></li><li><p><strong>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符</strong>，否则将引擎放弃使用索引而进行全表扫描。</p></li><li><p><strong>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</strong>，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0</p></li></ol><h4 id="2-请问如何防止SQL被注入？">2. <strong>请问如何防止SQL被注入？</strong></h4><ul><li><p><strong>什么是SQL注入？</strong></p><p>攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。</p><ul><li><p>例如：用户登录，攻击者输入：<code>用户名 = liangzone</code>，<code>密码 = ‘ or ‘1’=’1</code>  ，那么拼接后的语句是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name = ‘lianggzone’ and password = ‘’ or ‘1’=‘1’ </span><br></pre></td></tr></table></figure><p>攻击者就可以<strong>查询出所有的用户表信息</strong>！</p></li></ul></li><li><p><strong>如何防范SQL注入？</strong></p><ul><li>Web端：1）有效性检验； 2）限制字符串输入的长度</li><li>服务器端：1）不用拼接SQL字符串， 2）使用预编译的PrepareStatement， 3）有效性检验，4）<strong>过滤SQL需要的参数中的特殊字符，比如单引号、双引号</strong>。</li></ul></li></ul><h4 id="3-MySQL-如何做到高并发解决方案？">3. <strong>MySQL 如何做到高并发解决方案？</strong></h4><ol><li><strong>在web服务框架中加入缓存</strong>。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li><li><strong>增加数据库索引，进而提高查询速度</strong>。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li><li><strong>主从读写分离分库</strong>，让主服务器负责写，从服务器负责读。</li><li><strong>将数据库表进行拆分表</strong>，使得数据库的表尽可能小，提高查询的速度。</li><li><strong>使用分布式架构</strong>，分散计算压力。</li></ol><h4 id="4-大表如何进行优化？">4. 大表如何进行优化？</h4><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，⼀些常⻅的优化措施如下。</p><ul><li><p><strong>限定数据的范围</strong>：务必禁⽌不带任何限制数据范围条件的查询语句。⽐如：我们当⽤户在查询订单历史的时候，我们可以控制在⼀个⽉的范围内；</p></li><li><p>**读/写分离：**经典的数据库拆分⽅案，主库负责写，从库负责读；</p></li><li><p>**垂直分区：**根据数据库⾥⾯数据表的相关性进行拆分。</p><blockquote><p>例如，⽤户表中既有⽤户的登录信息⼜有⽤户的基本信息，可以将⽤户表拆分成两个单独的表，甚⾄放到单独的库做分库。</p><ul><li><p>简单来说垂直拆分是指数据表列的拆分，把⼀张列⽐较多的表拆分为多张表。</p><p><img src="https://i.loli.net/2021/05/16/25HtBIuXygCUVrq.png" alt="image-20210516234359675"></p></li></ul></blockquote></li><li><p><strong>水平分区 :</strong> 保持数据表结构不变，通过某种策略存储数据分⽚。这样每⼀⽚数据分散到不同的表或者库中，<strong>达到了分布式的⽬的</strong>。 ⽔平拆分可以支撑⾮常大的数据量。</p></li></ul><p>其它数据库结构方面优化：</p><ul><li><strong>范式优化</strong>： 比如消除冗余（节省空间。。）</li><li><strong>反范式优化</strong>：比如适当加冗余等（减少join）</li></ul><h4 id="5-数据库如何去重？">5. 数据库如何去重？</h4><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000002508404">MySQL数据库行去重复和列去重复</a></p></blockquote><h5 id="5-1-行去重">5.1 行去重</h5><blockquote><p>存在行重复，则无法建立 <u>唯一索引</u> 等。</p></blockquote><blockquote><p>用<code>distinct</code> 得到我们要保留的数据也是可以的。</p></blockquote><p>下面假设的是email字段重复。</p><ol><li><p>查看我们的分组后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *,count(id) from demo_table group by email having count(id)&gt;1 order by id;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----+------+--------------+-----------+</span><br><span class="line">| id | name | email        | count(id) |</span><br><span class="line">+----+------+--------------+-----------+</span><br><span class="line">|  1 | u1   | u1@email.com |         4 |</span><br><span class="line">|  2 | u2   | u2@email.com |         4 |</span><br><span class="line">|  3 | u3   | u3@email.com |         3 |</span><br><span class="line">|  4 | u4   | u4@email.com |         2 |</span><br><span class="line">|  5 | u5   | u5@email.com |         2 |</span><br><span class="line">+----+------+--------------+-----------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>保留每个分组<strong>最小的id</strong>，表中其余都删除</p><p>在表中删除不符合要求的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from demo_table where id not in (select min(id) from demo_table group by email);</span><br></pre></td></tr></table></figure><p>但是似乎有保护机制，无法直接删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1093 (HY000): You can&#x27;t specify target table &#x27;demo_table&#x27; for update in FROM clause</span><br></pre></td></tr></table></figure></li><li><p>创建临时表再删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建临时表保存每个分组中最小的那个id</span><br><span class="line">create table tmp_table as select min(id) from demo_table group by email;</span><br><span class="line"></span><br><span class="line"># 删除表中数据</span><br><span class="line">delete from demo_table where id not in (select * from tmp_table);</span><br><span class="line"></span><br><span class="line"># 删除临时表</span><br><span class="line">drop table tmp_table;</span><br></pre></td></tr></table></figure></li></ol><h5 id="5-2-列重复">5.2 列重复</h5><ol><li><p>先找到重复字段的<strong>行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from demo_table as a, demo_table as b where a.id=b.id and a.name=b.email;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----+--------------+--------------+----+--------------+--------------+</span><br><span class="line">| id | name         | email        | id | name         | email        |</span><br><span class="line">+----+--------------+--------------+----+--------------+--------------+</span><br><span class="line">| 31 | 31@email.com | 31@email.com | 31 | 31@email.com | 31@email.com |</span><br><span class="line">| 32 | 32@email.com | 32@email.com | 32 | 32@email.com | 32@email.com |</span><br><span class="line">| 33 | 33@email.com | 33@email.com | 33 | 33@email.com | 33@email.com |</span><br><span class="line">| 34 | 34@email.com | 34@email.com | 34 | 34@email.com | 34@email.com |</span><br><span class="line">| 35 | 35@email.com | 35@email.com | 35 | 35@email.com | 35@email.com |</span><br><span class="line">+----+--------------+--------------+----+--------------+--------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>重复记录的id都已经找出来了，删除就参考上述方式处理了。</p></li></ol><h4 id="6-select慢的原因？慢查询的优化策略？">6. select慢的原因？慢查询的优化策略？</h4><h5 id="6-1-select-很慢的原因">6.1 select 很慢的原因</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/kubidemanong/p/10734045.html">腾讯面试：一条SQL语句执行得很慢的原因有哪些?</a></p></blockquote><ul><li><p><strong>如果是偶尔很慢</strong></p><p>针对这种情况，这条SQL语句的书写本身是没什么问题的。可能是其它原因导致：</p><ol><li><strong>被加锁。</strong> 要执行的这条语句，刚好这条语句涉及到的<strong>表</strong>，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了；或者，表没有加锁，但要使用到的某个一<strong>行</strong>被加锁了 。</li><li>数据库在刷新脏页 ？ 看链接，不太明白流程。</li></ol></li><li><p><strong>如果是经常很慢</strong></p><ol><li><p><strong>没用到索引</strong></p></li><li><p><strong>索引失效了</strong> ：</p><p>（1）联合索引不满足最左匹配（不包含第一个索引）；</p><p>（2）like语句不满足最左匹配（不包含第一个索引）</p><p>（3）或者索引加上了运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c - 1 = 1000;</span><br></pre></td></tr></table></figure><p>这种情况不会有效，应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c = 1000 + 1;</span><br></pre></td></tr></table></figure><p>（4）或者函数操作用上索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where pow(c,2) = 1000;</span><br></pre></td></tr></table></figure></li><li><p><strong>数据库使用非聚簇索引</strong></p><p>我们在进行查询操作的时候，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where 100 &lt; c and c &lt; 100000;</span><br></pre></td></tr></table></figure><p>此时使用的非聚簇索引（辅助索引），只是存储了<strong>主键的key</strong> ，还是要再次通过聚簇索引去查找。效率可能不必全表扫描高。</p></li></ol></li></ul><h4 id="7-select…for-update用法？">7. select…for update用法？</h4><blockquote><p><a href="https://segmentfault.com/a/1190000023045909">数据库-MySQL中for update的作用和用法</a></p></blockquote><p><code>for update</code>是一种<code>行级锁</code>，又叫<code>排它锁</code>。</p><p>一旦用户对某个行施加了行级加锁，则<strong>该用户可以查询也可以更新</strong>被加锁的数据行，<strong>其它用户只能查询</strong>但不能更新被加锁的数据行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 开启事务</span><br><span class="line">begin;</span><br><span class="line">SELECT * FROM user WHERE id=3 FOR UPDATE;</span><br><span class="line">SELECT * FROM user WHERE id=3 and name=&#x27;Tom&#x27; FOR UPDATE;</span><br><span class="line">-- 提交事务</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><h4 id="8-场景题：假如选择MySQL数据库，一天五万条增量，运维三年，有哪些优化手段？">8. 场景题：假如选择MySQL数据库，一天五万条增量，运维三年，有哪些优化手段？</h4><ol><li><strong>设计良好的数据库结构</strong>，允许部分数据冗余，尽量避免join查询，提高效率；</li><li>选择合适的表字段数据类型和存储引擎，适当的<strong>添加索引</strong>；</li><li>MySQL库主从<strong>分库读写分离</strong>；</li><li>找规律<strong>分表</strong>，减少单表中的数据量提高查询速度；</li><li><strong>添加缓存机制</strong>，比如Memcached，Apc等；</li><li><strong>书写高效率的SQL</strong>。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE。</li></ol><h1>六、Redis</h1><h2 id="6-1-Redis基本">6.1 Redis基本</h2><h4 id="1-什么是-Redis？">1. <strong>什么是</strong> <strong>Redis？</strong></h4><p>（:triangular_flag_on_post:*1）Redis 是一个开源（BSD 许可）、基于<u>内存（读写快）</u>、支持多种数据结构的存储系统，可以作为<u>数据库、缓存和消息中间件</u>。</p><ul><li>支持的数据结构有<strong>5</strong>种：字符串（String）、哈希（hash）、列表（list）、集合（set）、有序集合（sorted set）。</li></ul><h5 id="1-1-有MySQL不就够用了吗？为什么要用Redis这种新的数据库？">1.1 有MySQL不就够用了吗？为什么要用Redis这种新的数据库？</h5><p>主要是因为 Redis <strong>具备高性能和高并发</strong>两种特性。</p><ul><li><strong>高性能</strong>：除了第一次读取硬盘比较慢，后面加载到缓存，读取速度都相关快，性能高；</li><li><strong>高并发</strong>：直接<strong>操作缓存能够承受的并发请求是远远大于直接访问数据库</strong>的，所以我们可以考虑把数据库中的<strong>部分热点数据</strong>转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</li></ul><h5 id="1-2-C-JAVA-中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？">1.2 C++ / JAVA 中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？</h5><p>缓存分为本地缓存和分布式缓存 。</p><ul><li><strong>本地缓存不具一致性。<strong>以Java为例 ，使用自带的map或者guava实现的是本地缓存，最主要的特点是</strong>轻量以及快速</strong>，生命周期<strong>随着jvm的销毁而结束</strong>，并且在多实例的情况下，<strong>每个实例都需要各自保存一份缓存</strong>，缓存不具有一致性；</li><li><strong>Redis分布式缓存具有一致性。</strong> 使用redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性；</li><li><strong>Redis可以使用更大内存作为缓存。</strong> Redis可以使用几十G内存作为缓存，Map不行，比如JVM最多使用几个G ；</li><li><strong>Redis可以持久化。</strong> Redis可以实现持久化，而Map是内存对象，程序重启就没了；</li><li><strong>Redis可以处理百万级别并发；</strong></li><li><strong>Redis有丰富的API &amp; 缓存过期等机制。</strong></li></ul><h4 id="2-【重点】-redis的数据类型，以及每种数据类型的使用场景？">2. 【<strong>重点</strong>】**redis的数据类型，以及每种数据类型的使用场景？ **</h4><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">使用场景</th></tr></thead><tbody><tr><td style="text-align:center">String</td><td style="text-align:center">存储key-value键值对，注意redis中String可修改。统计在线人数；也可以存储<strong>视频、图片</strong>等</td></tr><tr><td style="text-align:center">hash（:triangular_flag_on_post:*1）</td><td style="text-align:center">购物车：<code>hset [key] [field] [value]</code> 命令， 存放键值对，一般可以用来存某个对象的基本属性信息，例如，用户信息，商品信息等</td></tr><tr><td style="text-align:center">set</td><td style="text-align:center">全局去重，JVM自带的set不适合分布式集群情况</td></tr><tr><td style="text-align:center">zset</td><td style="text-align:center">排行榜，比如微信运动排行榜</td></tr><tr><td style="text-align:center">list</td><td style="text-align:center">分页功能，lrange做基于redis的分页功能，性能很好；模仿一个消息队列</td></tr></tbody></table><h4 id="3-说一下-Redis-有什么优点和缺点-？">3. <strong>说一下</strong> <strong>Redis</strong> <strong>有什么优点和缺点</strong> ？</h4><table><thead><tr><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center"><strong>速度快</strong>：因为在内存中</td><td style="text-align:center"><strong>存储有限</strong>：因为Redis是内存数据库，大小和机器本身内存有关</td></tr><tr><td style="text-align:center"><strong>支持多种数据结构：</strong> String，List，Set，Hash，Sorted Set等</td><td style="text-align:center">完成重同步耗费CPU资源和带宽</td></tr><tr><td style="text-align:center"><strong>持久化存储</strong>：RDB和AOF</td><td style="text-align:center"><strong>当Redis重启后</strong>通过把硬盘文件重新加载到内存，速度比较慢，这个时候redis做不了其它事。</td></tr><tr><td style="text-align:center"><strong>高可用</strong>：内置 <u>Redis Sentinel</u> （哨兵），实现主从故障自动转移。 内置 <u>Redis Cluster</u> ，提供集群方案。</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>丰富特性</strong>：Key过期、计数、分布式锁</td><td style="text-align:center"></td></tr></tbody></table><h4 id="4-Redis的数据结构？key是怎么存储的？">4. Redis的数据结构？key是怎么存储的？</h4><blockquote><p>参考：<a href="https://juejin.cn/post/6862291064624152583">【大课堂】Redis底层数据存储原理</a></p></blockquote><ul><li><p><strong>概述</strong></p><p>Redis底层采用 <strong>数组</strong>， key就是对应数组的<strong>索引</strong> ，采用Hash(key)映射到数组上。解决冲突采用<strong>链地址法</strong>。</p><p>具体可看参考下文。</p></li><li><p><strong>底层存储原理</strong></p><p>redis 中以<code>redisDb</code>作为整个缓存存储的核心，保存着我们<strong>客户端需要的缓存</strong>数据。</p><p>其结构如下：</p><p><img src="https://i.loli.net/2021/05/26/tbGEW3eV986aRkj.png" alt="RedisDB主体数据结构"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span>    </span><br><span class="line">       dict *dict;           <span class="comment">// 最重要--字典类型，保存数据库的键值对</span></span><br><span class="line">       dict *expires;        <span class="comment">// 重要--字典类型，保存过期的时间          </span></span><br><span class="line">       dict *blocking_keys;  <span class="comment">// 和ready_key 实现BLPOP等阻塞命令         </span></span><br><span class="line">       dict *ready_keys;     <span class="comment">// 同上      </span></span><br><span class="line">       dict *watched_keys;   <span class="comment">// 实现watch命令，记录正在被watch的key         </span></span><br><span class="line">       <span class="keyword">int</span> id;    <span class="comment">// 数据库id，默认16个，支持单个                      </span></span><br><span class="line">       <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;    <span class="comment">/* Average TTL, just for stats */</span>      </span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>现在我们来查看，<strong>dict</strong> 的结构。</p><ul><li><p><strong>dict的结构</strong></p><p><img src="https://i.loli.net/2021/05/26/kV1JhcrUwFHLznG.png" alt="image-20210526111544663"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  字典 : 每个字典使用两个哈希表，用于实现渐进式 rehash */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span>    </span><br><span class="line">       <span class="comment">// type存储了hash函数，key和value的复制函数等，比较以及销毁函数</span></span><br><span class="line">      dictType *type;   </span><br><span class="line">      <span class="comment">// privdata保存一些私有数据，决定了*type保存的函数，实现了【多态】</span></span><br><span class="line">      <span class="keyword">void</span> *privdata;     </span><br><span class="line">      dictht ht[<span class="number">2</span>];      <span class="comment">// 哈希表（2 个）,  正常使用ht[0],rehash就会扩容使用ht[1]</span></span><br><span class="line">      <span class="keyword">int</span> rehashidx;     <span class="comment">// 记录 rehash 进度的标志，值为 -1 表示 rehash 未进</span></span><br><span class="line">      <span class="keyword">int</span> iterators;    <span class="comment">// 当前正在运作的安全迭代器数量</span></span><br><span class="line">&#125; dict;  </span><br></pre></td></tr></table></figure><p>上述<code>dictht</code>就是个hash表，包含：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span>    </span><br><span class="line">   <span class="comment">// 哈希表节点指针数组（俗称桶，bucket）    </span></span><br><span class="line">   dictEntry **table;    </span><br><span class="line">   <span class="comment">// 指针数组的大小   </span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> size;    </span><br><span class="line">   <span class="comment">// 指针数组的长度掩码，用于计算索引值，其实永远都是size-1    </span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;   </span><br><span class="line">   <span class="comment">// 哈希表现有的节点数量   </span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><ul><li><p>**dictEntry 指针数组（table）。**key 的哈希值最终映射到这个数组的某个位置上（对应一个 bucket）。如果多个 key 映射到同一个位置，就发生了冲突，那么就拉出一个 dictEntry 链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表节点dictEntry</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span>     </span><br><span class="line">    <span class="keyword">void</span> *key;    <span class="comment">// redis的键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>        </span><br><span class="line">    <span class="keyword">void</span> *val;    <span class="comment">// 存储了对应string/set/list/hash/zset的数据     </span></span><br><span class="line">    <span class="keyword">uint64_t</span> u64;        </span><br><span class="line">    <span class="keyword">int64_t</span> s64; </span><br><span class="line">    &#125; v;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  <span class="comment">//链表后续节点</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure></li><li><p><em><strong>size</strong></em>：标识 dictEntry 指针数组的长度。它总是 2 的指数次幂。</p></li></ul><p>上面<code>dictEntry</code> 的<strong>value</strong> 最终指向了<code>redisObject</code>对象，我们来观察下其结构。</p></li><li><p><strong>Redis Object</strong></p><p><img src="https://i.loli.net/2021/05/26/kvhZQdtOuJjE6gY.png" alt="image-20210526112251563"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span>    </span><br><span class="line">     <span class="keyword">unsigned</span> type:<span class="number">4</span>;     <span class="comment">// 类型 ，比如string，set等，才能确定是哪种数据结构使用什么API操作   </span></span><br><span class="line">     <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// encoding 表示 ptr 指向的具体数据结构,这个对象使用什么数据结构实现   </span></span><br><span class="line">     <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS;  <span class="comment">// 对象最后一次被访问的时</span></span><br><span class="line">     <span class="keyword">int</span> refcount;    <span class="comment">// 引用计数         </span></span><br><span class="line">     <span class="keyword">void</span> *ptr;  <span class="comment">// 指向底层数据结构的指针 </span></span><br><span class="line"> robj;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="4-1-String、list、hash、set、zset的底层结构是什么？">4.1 String、list、hash、set、zset的底层结构是什么？</h5><blockquote><p>参考：<a href="https://i6448038.github.io/2019/12/01/redis-data-struct/">图解redis五种数据结构底层实现(动图哦)</a></p><p>版本：redis 3.0.6中版本各种数据结构的实现</p></blockquote><ol><li><p><strong>String</strong></p><ul><li>embstr和raw都是由SDS动态字符串构成的 ，底层结构应该都是<strong>char数组</strong>吧 ；</li><li>int ，就是指<strong>int类型</strong>。</li></ul><p><img src="https://i.loli.net/2021/05/26/h4mzJvU9I5BEj1o.png" alt="img"></p></li><li><p><strong>list</strong></p><p><img src="https://i.loli.net/2021/05/26/QSgDl39yIA5uXN2.png" alt="img"></p></li><li><p><strong>hash</strong></p><p><img src="https://i.loli.net/2021/05/26/9X8gPmG6MeDb4V3.png" alt="img"></p></li><li><p><strong>set</strong></p><p>intset是集合键的底层实现方式之一，是int类型数组。</p><p><img src="https://i.loli.net/2021/05/26/KXD9yHLewkIFGha.png" alt="img"></p><img src="https://i.loli.net/2021/05/26/rn3BfhLOT8dsRCH.png" alt="img" style="zoom:67%;" /></li><li><p><strong>zest</strong></p><p><img src="https://i6448038.github.io/img/redis-data-struct/object_zset.png" alt="img"></p></li></ol><h5 id="4-2-讲讲redis的hash表扩容方式？">4.2 讲讲redis的hash表扩容方式？</h5><blockquote><p>参考：<a href="https://luoming1224.github.io/2018/11/12/%5Bredis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Dredis%E6%B8%90%E8%BF%9B%E5%BC%8Frehash%E6%9C%BA%E5%88%B6/">[redis学习笔记]redis渐进式rehash机制</a></p></blockquote><ul><li><p><strong>扩容条件</strong></p><ul><li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 （<strong>保存的key超过哈希表大小</strong>）；</li><li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；</li></ul></li><li><p><strong>渐进式rehash</strong></p><ol><li><p>新建一个哈希表大小，为<code>2^N</code> 次方，并分配内存，此时字典<strong>同时持有：ht[0] 和 ht[1] 两个哈希表</strong></p><blockquote><p>同hashmap：哈希表掩码sizemask为size-1，当size满足2的n次方时，计算每个key的索引值时只需要用key的hash值与掩码sizemask进行位与操作，替代求余操作，计算更快。</p></blockquote></li><li><p>哈希表赋值给字典的ht[1]，然后将rehashidx赋值为0，表示rehash工作开始</p><blockquote><p>rehashidx也标识了，当前rehash<strong>进行到了哪个槽</strong></p></blockquote></li><li><p>在 rehash 进行期间，：每次对字典执行<strong>添加、删除、查找或者更新操作</strong>时， 程序除了执行指定的操作以外， 还会顺带将 <strong>ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]</strong> 。</p><p>当 rehash 工作完成之后， 程序将 rehashidx 属性的值**+1**</p></li><li><p>随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] 。此时<code>rehashidx=-1</code>，表示rehash完成。</p></li></ol><p>采取分而治之的方式， 将 rehash 键值对所需的计算工作<strong>均摊</strong>到对字典的每个添加、删除、查找和更新操作上， 从而<strong>避免了集中式 rehash 而带来的庞大计算量</strong>。</p></li><li><p><strong>渐进式rehas优缺点</strong></p><ul><li>优点：避免redis阻塞</li><li>缺点：rehash需要分配一个新的hash表，会使得<strong>内存爆增，使得大量key被驱逐</strong></li></ul></li></ul><h5 id="4-3-rehash过程中增删查改怎么操作呢？">4.3 rehash过程中增删查改怎么操作呢？</h5><ul><li><p><strong>增加：</strong> 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作</p></li><li><p><strong>删除（delete）、查找（find）、更新（update）等</strong>： 同时在ht[0] &amp; ht[1]两个表进行。</p><blockquote><p>比如：要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找。</p></blockquote></li></ul><h4 id="5-说说Redis有序集合zset的底层结构？">5. 说说Redis有序集合zset的底层结构？</h4><p>zset底层的存储结构包括<u>ziplist</u>或<u> skiplist &amp; dic</u> ，<strong>当满足以下两个条件的时候使用ziplist</strong>：</p><ul><li>有序集合保存的元素数量小于128个</li><li>有序集合保存的所有元素的长度小于64字节</li></ul><p>其余情况用skiplist。</p><ul><li><p><strong><a href="https://www.cnblogs.com/exceptioneye/p/7040815.html">什么是ziplist？</a></strong></p><p>ziplist是一个经过特殊编码的<u>双向链表</u>，以O(1)的时间复杂度在表的两端提供push和pop操作。</p><p>ziplist将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。</p><ul><li><p><strong>使用原因：<strong>一个普通的<u>双向链表</u>，链表中每一项都<u>占用独立的一块内存</u>，各项之间用地址指针（或引用）连接起来；这种方式会带来大量的</strong>内存碎片</strong>，而且<strong>地址指针也会占用额外的内存</strong>。</p></li><li><p><strong>具体结构</strong></p><p><img src="https://i.loli.net/2021/05/04/zYwG2PtCZq84hgV.jpg" alt="img"></p><ul><li>entry：表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构。</li></ul></li></ul></li><li><p><a href="https://segmentfault.com/a/1190000037473381"><strong>什么是skiplist ?</strong></a></p><p>跳表是在单链表上实现多级索引，<strong>可以实现 <u>二分查找</u> 的有序链表</strong>。</p><blockquote><p>跳表插入、删除、查找元素的时间复杂度跟红黑树都是一样量级的，时间复杂度都是O(logn)。</p></blockquote><ul><li><p>主要形式</p><p>在单链表上进行多级索引。</p><p><img src="https://i.loli.net/2021/05/28/Rc6tAuOmELHz5nN.png" alt="image-20210528143426041"></p></li><li><p>构建过程</p><blockquote><p>上面链表是如何构建的呢，请见下图。</p></blockquote><p>:warning: skiplist为了避免上下两层出现<strong>严格1:2</strong>数量对应关系后，新插入节点会打乱这种关系，而需要<strong>把新插入节点后所以节点都进行调整</strong>。</p><p><strong>它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)</strong>。</p><img src="https://i.loli.net/2021/05/28/sEy7B6gUHuIfbd3.png" alt="preview" style="zoom: 67%;" /></li><li><p>查找过程</p><blockquote><p>zset : <code>&lt;key&gt; &lt;score&gt; &lt;member&gt;</code></p></blockquote><p>在上图中，我们没有区分member和score，但是实际上链表是<strong>按score进行排序，查找也是在比较score</strong>。</p><blockquote><p>以查找 和 插入23为例。</p></blockquote><ol><li>从最高层（第4）层开始查找，因为<code>7&lt;23</code> ,本应该继续往后查找，但是后继节点为null，所以往下一层进行查找</li><li>此时第3层，满足<code>7&lt;23&lt;37</code> ，继续往下一层继续查找</li><li>此时第2层，<code>7&lt;23 &amp; 19&lt;23</code> ，往下第二层的下一个节点（19）查找；此时满足<code>19&lt;23&lt;37</code> ，继续往下一层</li><li>此时第1层，一直往后遍历到22，发现<code>22&lt;23&lt;26</code> ：<ul><li>如果此时是<strong>查询23</strong>：返回null，不存在</li><li>此时是<strong>插入23</strong>：生成新节点 &amp; 随机生成层数，（1）将新节点各层指针指向对应层的<strong>下一个节点</strong>（不存在则指向null）（2）将新节点节点各层<strong>前一个节点</strong>对应层数的指针指向新节点</li></ul></li></ol></li></ul></li></ul><h5 id="5-1-Redis为什么不用红黑树">5.1 Redis为什么不用红黑树</h5><blockquote><p>参考 ： <a href="https://www.zhihu.com/question/20202931">知乎回答</a></p></blockquote><p>虽然跳表操作<strong>时间复杂度和红黑树相同</strong> ，但是：</p><ol><li><p>**实现简单：**跳表代码实现更易读</p></li><li><p>**区间查找：**跳表区间查找效率更高</p></li></ol><h4 id="6-Redis-持久化方式有哪些？以及有什么区别？">6. <strong>Redis</strong> <strong>持久化方式有哪些？以及有什么区别？</strong></h4><p><code>Redis</code> 提供两种持久化机制 <code>RDB</code> 和 <code>AOF</code> 机制。</p><ul><li><p><strong>各自优点</strong></p><table><thead><tr><th style="text-align:center">RDB</th><th style="text-align:center">AOF</th></tr></thead><tbody><tr><td style="text-align:center">【<strong>方便</strong>】只有一个文件 <code>dump.rdb</code> ，方便持久化</td><td style="text-align:center">【<strong>数据安全</strong>】 AOF 持久化有 <code>always</code>，每进行一次命令操作就记录到 AOF 文件中一次。</td></tr><tr><td style="text-align:center">【<strong>容灾性好</strong>】一个文件可以保存到安全的磁盘</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">【<strong>性能</strong>】最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">【<strong>启动效率高</strong>】相对于数据集大时，比 AOF 的<strong>启动效率</strong>更高</td><td style="text-align:center"></td></tr></tbody></table></li><li><p><strong>各自缺点</strong></p><table><thead><tr><th style="text-align:center">RDB</th><th style="text-align:center">AOF</th></tr></thead><tbody><tr><td style="text-align:center">【<strong>安全性低</strong>】 <code>RDB</code> 是间隔一段时间进行持久化</td><td style="text-align:center">【<strong>启动效率低</strong>】数据集大的时候，比 RDB 启动效率低。</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">【<strong>恢复慢</strong>】<code>AOF</code> 文件比 <code>RDB</code> 文件大，且恢复速度慢。</td></tr></tbody></table></li></ul><h5 id="6-1-AOF-重写了解吗？">6.1 AOF 重写了解吗？</h5><p>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，<strong>但体积更小</strong>。</p><blockquote><p>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的<strong>键值</strong>对来实现的，程序<strong>无须对现有AOF文件进行</strong>任伺读入、分析或者写入操作。</p></blockquote><p>具体过程如下：</p><ol><li>在执行 <code>BGREWRITEAOF</code> 命令，开始重写；</li><li>Redis 服务器会维护一个 AOF <strong>重写缓冲区</strong>，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令；</li><li>当子进程完成创建新AOF文件的工作之后，服务器会将重写<strong>缓冲区中的所有内容追加到新AOF文件的末尾</strong> ；</li><li>最后，服务器用新的AOF文件替换旧的 AOF文件，以此来完成AOF文件重写操作。</li></ol><h4 id="7-Redis持久化有两种，那应该怎么选择呢？">7. Redis持久化有两种，那应该怎么选择呢？</h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/39412293">https://zhuanlan.zhihu.com/p/39412293</a></p></blockquote><ol><li><strong>如果Redis中的数据完全丢弃也没有关系</strong>（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化；</li><li><strong>单机环境：</strong> 如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF；</li><li><strong>主从架构：</strong><ul><li>**master：**完全关闭持久化（包括RDB和AOF），这样可以让master的性能达到最好；</li><li><strong>slave</strong>：<strong>关闭RDB，开启AOF</strong>（如果对数据安全要求不高，开启RDB关闭AOF也可以），并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；然后关闭AOF的自动重写，然后添加定时任务，在每天Redis闲时（如凌晨12点）调bgrewriteaof。</li></ul></li></ol><h4 id="8-（-u-不太理解-u-）pipeline-有什么好处，为什么要用-pipeline？">8. （<u>不太理解</u>）<strong>pipeline</strong> <strong>有什么好处，为什么要用</strong> <strong>pipeline？</strong></h4><ul><li><p>使用 pipeline（管道）的好处在于可以将多次 I/O 往返的时间缩短为一次，但是要求管道中执行的指令间没有因果关系；</p></li><li><p>用 pipeline 的原因在于可以实现请求/响应服务器的功能，当客户端尚未读取旧响应时，它也可以处理新的请求。如果客户端存在多个命令发送到服务器时，那么客户端无需等待服务端的每次响应才能执行下个命令，只需最后一步从服务端读取回复即可。</p></li></ul><h4 id="9-怎么使用-Redis-实现消息队列？-如何实现延时队列？">9. <strong>怎么使用</strong> <strong>Redis</strong> <strong>实现消息队列？ 如何实现延时队列？</strong></h4><ul><li><p>**消息队列：**一般使用 <code>list</code> 结构作为队列， <code>rpush</code> 生产消息， <code>lpop</code> 消费消息。当 <code>lpop</code> 没有消息的时候，要适当<code>sleep</code> 一会再重试；</p></li><li><p><strong>延时队列：</strong> ：使用<code>sortedset</code> ，拿<u>时间戳</u>作为 <code>score</code> ，消息内容作为 <code>key</code> 调用 <code>zadd</code> 来生产消息，消费者用<code>zrangebyscore</code> 指令获取符合条件的数据轮询进行处理。</p><blockquote><p>什么是延时队列？</p><p>当用户发送一个消息请求给服务器后台的时候，服务器会检测这条消息是否需要进行延时处理：</p><ul><li>如果需要就放入到延时队列中，由延时任务检测器进行检测和处理；</li><li>如果不需要进行延时处理的任务，服务器会立马对消息进行处理，并把处理后的结果返会给用户。</li></ul><p>【举个例子】</p><ul><li>点外卖时，下单后不会立即安排配送，而是等待一段时间让商户接单才正式安排配送，否则超时取消</li></ul></blockquote></li></ul><h2 id="6-2-Redis单线程模型">6.2 Redis单线程模型</h2><h4 id="1-（-triangular-flag-on-post-1）为什么-Redis-使用单线程模型？单线程模型效率也能那么高？">1. （:triangular_flag_on_post:*1）<strong>为什么</strong> <strong>Redis 使用单线程模型？单线程模型效率也能那么高？</strong></h4><ol><li><p>采用单线程，避免了不要的上下文切换和竞争条件；</p></li><li><p><strong>其次 CPU 不是 Redis 的瓶颈</strong>，Redis 的瓶颈最有可能是机器内存或者网络带宽。</p></li></ol><p>【<strong>效率高的原因</strong>】</p><p>. 1. <strong>C语言</strong>实现，效率高</p><ol start="2"><li><p>纯<strong>内存</strong>操作</p></li><li><p><strong>基于非阻塞的IO复用模型机制</strong>（可能会跟自己挖坑）</p></li><li><p>单线程的话就能避免多线程的频繁上下文切换问题（为什么单线程效率高）</p></li><li><p>丰富的数据结构（<u>全程采用hash结构，读取速度非常快</u>，对数据存储进行了一些优化，<u>比如zset压缩表，跳表等</u>）</p></li></ol><h4 id="2-（新，易忘）说说-Redis-的单线程模型-？">2. <strong>（新，易忘）说说 Redis 的单线程模型</strong> ？</h4><blockquote><p>这问题是因为前面回答问题的时候提到了 Redis 是基于非阻塞的IO复用模型。如果这个问题回答不上来，就相当于前面的回答是给自己挖坑了。</p></blockquote><p>redis 内部使⽤⽂件事件处理器 file event handler ，这个⽂件事件处理器是单线程的，所以redis 才叫做单线程的模型。它采⽤ IO 多路复⽤机制一个线程同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进⾏处理。<br>⽂件事件处理器的结构包含 4 个部分：</p><ol><li>多个 socket</li><li>IO 多路复⽤程序</li><li>⽂件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ol><p>（1） IO 多路复⽤程序会监听多个 socket，（2）会将 socket 产⽣的事件<strong>放⼊队列中排</strong>队，（3）事件分派器每次从队列中取出⼀个事件，（4）把该事件交给对应的事件处理器进⾏处理。</p><h4 id="3-你说Redis是单线程的，那如何处理高并发？比如1000个并发请求同时发生？">3. 你说Redis是单线程的，那如何处理高并发？比如1000个并发请求同时发生？</h4><ul><li><p>Redis采用了<strong>IO多路复用机制</strong>，使其在网络IO操作中能并发处理大量的客户端请求。</p><blockquote><p>详见上一个问题。</p></blockquote></li><li><p>Redis可以采用<strong>主从架构</strong>，master负责写，slave负责读。</p></li></ul><h4 id="4-说说你对Redis事务的理解-？">4. <strong>说说你对Redis事务的理解</strong> ？</h4><p>Redis 中的事务是<strong>一组命令的集合</strong>，是 Redis 的最小执行单位。</p><blockquote><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的 Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p></blockquote><ul><li><p><strong>需要注意的地方</strong></p><ol><li><p>**Redis 事务不支持回滚：**不像 MySQL 的事务一样，要么都执行要么都不执行；</p><blockquote><p>因为回滚需要增加很多工作，而不支持回滚则可以保持简单、快速的特性。</p></blockquote></li><li><p>（:triangular_flag_on_post:*1）Redis 服务端在执行事务的过程中，<u><strong>不会被其他客户端发送来的命令请求打断</strong></u>，直到事务命令全部执行完毕才会执行其他客户端的命令。</p></li></ol></li></ul><h4 id="5-为什么Redis的操作是原子性的，怎么保证原子性的？">5. <strong>为什么Redis的操作是原子性的，怎么保证原子性的？</strong></h4><ul><li><strong>原子性。</strong> 因为Redis是单线程的， Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。</li><li><strong>事务性。</strong> Redis中的事务其实是要保证<u>批量操作</u>的原子性。</li></ul><h2 id="6-3-Redis缓存">6.3 Redis缓存</h2><h4 id="1-为什么要用缓存-？怎么提高缓存命中率？">1. <strong>为什么要用缓存</strong> ？<strong>怎么提高缓存命中率？</strong></h4><ul><li><p><strong>为什么用缓存？</strong></p><p>把热点数据存入内存中，提高读写性能。</p></li><li><p><strong>提高命中率？</strong></p><ol><li>增加缓存空间</li><li>（:triangular_flag_on_post:*1）提升缓存更新频率</li><li>提前加载数据到缓存中</li></ol></li></ul><h4 id="2-缓存雪崩、缓存穿透、缓存击透、缓存预热、缓存更新、缓存降级等？">2. <strong>缓存雪崩、缓存穿透、缓存击透、缓存预热、缓存更新、缓存降级等？</strong></h4><blockquote><p>参考：<a href="https://juejin.cn/post/6844904173725548557">https://juejin.cn/post/6844904173725548557</a></p></blockquote><ul><li><p><strong>缓存雪崩</strong></p><blockquote><p>简而言之：<strong>Redis 挂掉了</strong>，请求全部走数据库 。</p></blockquote><ul><li><p><strong>例如：</strong> 对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库；</p><ul><li><strong>key过期解决：</strong> 在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。</li></ul><p>更通用情况的做法：</p><ul><li><strong>事发前：<strong>实现 Redis 的</strong>高可用 (主从架构 + Redis Cluster)</strong>，尽量避免 Redis 挂掉这种情况发生；</li><li><strong>事发中：<strong>万一 Redis 真的挂了，我们可以设置</strong>本地缓存 (ehcache)+ 限流 (hystrix)</strong>，尽量避免我们的数据库被干掉；</li><li><strong>事发后：<strong>redis <strong>持久化</strong>，重启后</strong>自动</strong>从磁盘上加载数据，<strong>快速恢复缓存数据</strong>。</li></ul></li></ul></li><li><p><strong>缓存穿透</strong></p><blockquote><p>查询一个一定<strong>不存在的数据</strong> ，导致<strong>每次请求都要到数据库去查询</strong>，失去了缓存的意义 。</p></blockquote><ul><li><strong>解决1：</strong> 使用布隆过滤器 (BloomFilter)  <strong>提前拦截</strong>，不合法就不让这个请求到数据库层；</li><li><strong>解决2：<strong>当我们从数据库找不到的时候，我们也将这个</strong>空对象设置到缓存里边去</strong>，下次再请求的时候，就可以从缓存里边获取了。</li></ul></li><li><p><strong>缓存击穿</strong></p><p>在平常高并发的系统中，大量的请求同时查询一个key时，此时这个<strong>高热key</strong>正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为缓存击穿。</p><ul><li><p><strong>解决1：使用互斥锁(mutex key) 。</strong> 是只让一个线程构建缓存，<strong>其他线程等待构建缓存</strong>的线程执行完，重新从缓存获取数据就行。</p><blockquote><p>如果是单机，可以用synchronized或者lock来处理，如果是**【淘特】分布式环境可以用分布式锁**就可以了。</p><p><img src="https://i.loli.net/2021/05/06/4oRvz638eOiEFTf.png" alt="image-20210506115517283"></p></blockquote></li><li><p><strong>解决2：</strong> <strong>key永不过期。</strong> 把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建。</p><p><img src="https://i.loli.net/2021/05/06/jZ9v47kthTmADqg.png" alt="image-20210506115748032"></p></li></ul></li><li><p><strong>缓存预热</strong></p><blockquote><p>系统上线后，将相关的缓存数据直接加载到缓存系统。</p></blockquote><p>这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。</p></li><li><p><strong>缓存更新</strong></p><ul><li><code>LRU</code>(访问时间最旧淘汰)/<code>LFU</code>(把频次低的淘汰掉)</li><li>超时剔除：设置key过期时间</li><li>主动更新：开发设置生命周期</li></ul></li><li><p><strong>缓存降级</strong></p><p>降级的情况，<u>就是<strong>缓存失效或者缓存服务挂掉</strong>的情况下，我们也不去访问数据库</u>。我们<strong>直接访问内存部分数据缓存</strong>或者直接返回默认数据。</p><blockquote><p>对于应用的首页，一般是访问量非常大的地方，首页里面往往包含了部分推荐商品的展示信息。这些推荐商品都会放到缓存中进行存储，同时我们为了避免缓存的异常情况，对<strong>热点商品数据</strong>也存储到了<strong>内存</strong>中。同时内存中还保留了一些默认的商品信息。</p><p>如下图所示：</p></blockquote><p><img src="https://i.loli.net/2021/05/06/a1XZHWCterV3uR2.png" alt="image-20210506115200276"></p></li></ul><h4 id="3-Redis-设置key过期后如何处理？Redis-缓存刷新策略（内存淘汰机制）有哪些？">3. Redis 设置key过期后如何处理？<strong>Redis</strong> <strong>缓存刷新策略（内存淘汰机制）有哪些？</strong></h4><ul><li><p><strong>Redis 设置过期时间</strong></p><p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置⼀个过期时间。</p><ul><li>如我们⼀般项⽬中的 <strong>token</strong> 或者⼀些登录信息，尤其是短信验证码都是有时间限制的，过期后基本不会使用</li></ul></li><li><p><strong>过期后采用什么策略进行删除？</strong></p><ul><li><strong>定期删除：<strong>redis默认是</strong>每隔 100ms</strong> 就<strong>随机抽取</strong>⼀些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这⾥是随机抽取的。**为什么要随机呢？**你想⼀想假如 redis 存了⼏⼗万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li></ul></li><li><p><strong>惰性删除 ：</strong><u><strong>定期删除可能会导致很多过期 key 到了时间并没有被删除掉</strong></u>，所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存⾥，除⾮你的系统去查⼀下那个 key，才会被redis给删除掉。</p><ul><li><strong>内存淘汰策略</strong> ：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没⾛惰性删除，此时会怎么样？如果大量过期key堆积在内存⾥，导致redis内存块耗尽了。所以有内存淘汰策略。</li><li><strong>volatile-lru</strong>：从已设置过期时间的数据中挑选最近最少使⽤的数据淘汰<ul><li><p><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选<strong>将要过期的数据</strong>淘汰</p></li><li><p><strong>volatile-random</strong>：从已设置过期时间的数据中任意选择数据淘汰</p></li><li><p><strong>allkeys-lru</strong>：当内存不⾜以容纳新写⼊数据时，在键空间中，移除最近最少使⽤的key（这个是最常⽤的）</p></li><li><p><strong>allkeys-random</strong>：从数据集中任意选择数据淘汰</p></li><li><p><strong>no-eviction</strong>：禁⽌驱逐数据，也就是说当内存不⾜以容纳新写⼊数据时，新写⼊操作会报错。这个应该没⼈使⽤吧！</p></li></ul></li></ul></li></ul><h4 id="4-Redis-报内存不足怎么处理？">4. <strong>Redis</strong> <strong>报内存不足怎么处理？</strong></h4><ul><li>增加 Redis 可用内存：<ol><li>修改件 <code>redis.conf</code> 的 <code>maxmemory</code> 参数；</li><li>使用分布式集群，提高存储量；</li></ol></li><li><strong>设置缓存淘汰策略</strong>：提高内存的使用效率；</li></ul><h4 id="5-【重点】缓存和数据库谁先更新呢？-（保持缓存和数据库一致性）">5. 【<strong>重点</strong>】<strong>缓存和数据库谁先更新呢？</strong>  <strong>（保持缓存和数据库一致性）</strong></h4><blockquote><p>参考：<a href="https://learnku.com/articles/22363">https://learnku.com/articles/22363</a></p></blockquote><ul><li><p><strong>对于读（查询）操作</strong></p><p>一般我们对<strong>读操作</strong>的时候有这么一个固定的套路：</p><ol><li>如果我们的数据在缓存里边有，那么就直接取缓存的；</li><li>如果缓存里没有我们想要的数据，我们会先去查询数据库，<u>然后将数据库查出来的数据写到缓存中</u>；</li><li>最后将数据返回给请求。</li></ol><p><strong>不用更新（写）数据库，只用更新（写）缓存</strong>。</p></li><li><p><strong>对于写操作导致双写问题</strong></p><blockquote><p><a href="https://developer.aliyun.com/article/712285">如何保证缓存(redis)与数据库(MySQL)的一致性</a></p></blockquote><p>写操作会更新数据库，那么缓存也要进行更新，此时会发生数据库和缓存不一致的问题。</p><blockquote><p>**键的过期时间：**能保证缓存和数据库的数据最终是一致的。</p><p><u>因为只要缓存数据过期了，就会被删除</u>。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据<strong>重新写入到缓存</strong>中。<br>除了设置过期时间，我们还需要做更多的措施来尽量避免数据库与缓存处于不一致的情况发生。</p></blockquote><p>直接看结论：</p><blockquote><p>不考虑更新缓存而是<strong>直接删除缓存</strong>，因为更新逻辑较为复杂涉及到其它数据，更新cache消耗会比较大。</p></blockquote><ul><li><strong>先删除缓存，再更新数据库</strong><ul><li>在高并发下可能<strong>会导致数据长时间不一致</strong></li><li>采用<u>异步更新缓存</u>的策略，不会导致数据不一致，但在数据库更新完成之前，都需要到数据库层面去读取数据，读的效率不太好**——保证了数据的一致性，适用于对一致性要求高的业务**</li></ul></li><li><strong>先更新数据库，再删除缓存</strong> (<strong>Cache Aside Pattern 设计模式</strong>)<ul><li>在高并发下不会导致数据长时间不一致</li><li>在<strong>更新数据库期间，cache中的旧数据会被读取</strong>，可能会有一段时间的数据不一致，但读的效率很好。<strong>——保证了数据读取的效率，如果业务对一致性要求不是很高，这种方案最合适</strong></li></ul></li></ul></li><li><p><strong>先删除缓存，再更新数据库</strong></p><blockquote><p>:warning: <strong>只有读才会更新缓存！！</strong></p></blockquote><ul><li><p><u>正常情况</u></p><ol><li>A线程进行写操作，先淘汰缓存，再更新数据库</li><li>B线程进行读操作，发现缓存中没有想要的数据，从数据库中读取更新后的新数据 ，并更新缓存</li></ol></li><li><p><u>高并发异常</u></p><ol><li>A线程进行<strong>写</strong>操作，先淘汰缓存，但由于<u>网络原因等未及时更新数据库</u></li><li>B线程<strong>读</strong>取缓存失败，去<u>读取数据库的是旧值</u> ，并将<u>旧数据放入缓存</u></li><li>A线程再更新数据库成功（<strong>同步情况下写操作不更新redis而读操作更新redis</strong>），<u>此时缓存（旧）和数据库（新）不一致</u></li></ol><p>而且没有设置键过期，会保持很长时间的数据不一致。</p></li><li><p>（:triangular_flag_on_post:*1）<u>解决方案</u></p><ul><li><strong>异步更新缓存</strong> ：B线程读操作不更新缓存，而是由<u>A线程写操作更新数据库成功后，通过binlog异步更新缓存</u></li><li><strong>延时双删：</strong> A线程<u>休眠M秒（确保事务都已提交）</u>，再更新数据库成功后，<strong>再次删除缓存</strong>。其它线程进行<strong>读</strong>操作时，缓存中无数据，从数据库中读取的是更新后的新数据，<u>又再次一致了</u>。</li></ul></li></ul></li><li><p><strong>先更新数据库，再删除缓存</strong></p><ul><li><p><u>正常情况</u></p><ol><li>A线程进行<strong>写</strong>操作，先更新数据库，再删除缓存</li><li>B线程进行<strong>读</strong>操作，发现缓存中没有想要的数据，从数据库中读取更新后的新数据 ，并更新缓存</li></ol></li><li><p><u>高并发异常</u></p><ol><li><p>A线程进行<strong>写</strong>操作，先更新数据库，<u>但未来得及删除缓存</u></p></li><li><p>B线程进行<strong>读</strong>操作，<u><strong>读取缓存的旧数据</strong>（背错一次），此时数据不一致</u></p></li><li><p>A线程再删缓存</p></li></ol><p>但其它线程进行读数据的时候更新缓存，更新缓存又一致了，<u>不一致的时间很短。</u></p><p>（:triangular_flag_on_post:*1）但是还可能会考虑：<strong>3. A线程删除缓存失败</strong> ，此后读取的一直都是旧数据了。</p></li><li><p><u>解决方案</u></p><ul><li><strong>消息队列进行删除补偿</strong>。如果Redis删除发现报错，将Redis的key作为消息发送到消息队列中，系统收到消息队列再次对Redis进行删除操作。</li></ul></li></ul></li></ul><h2 id="6-4-集群相关">6.4 集群相关</h2><h4 id="1-Redis-的同步机制了解是什么？">1. <strong>Redis</strong> <strong>的同步机制了解是什么？</strong></h4><p>Redis主从复制可以根据是否是全量分为：<u>全量同步</u>和<u>增量同步</u>。</p><blockquote><p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。</p></blockquote><ul><li><p><strong>全量同步</strong></p><p>Redis全量复制一般发生在Slave初始化阶段，这时<strong>Slave需要将Master上的所有数据都复制一份</strong>：</p><p>​       1）从服务器连接主服务器，发送<code>SYNC</code>命令；<br>　　2）主服务器接收到SYNC命名后，开始执行<code>BGSAVE</code>命令（1）生成<u>RDB文件</u>  （2）并使用<u>缓冲区记录</u>此后执行的所有<strong>写</strong>命令；<br>　　3）主服务器<code>BGSAVE</code>执行完后，向所有从服务器发送RDB快照文件，并在发送期间继续记录被执行的写命令；<br>　　4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；<br>　　5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</p></li><li><p>（:triangular_flag_on_post:*1）<strong>增量同步</strong></p><p>Slave初始化后开始正常工作时：<strong>主服务器发生的写操作同步到从服务器的过程。</strong></p><ol><li>主服务器每执行一个<strong>写命令</strong>就会向从服务器发送相同的写命令；</li><li>从服务器接收并执行收到的写命令。</li></ol></li></ul><h4 id="2-【新补充】-Redis-集群架构模式有哪几种？-集群的原理是什么？">2.【新补充】 <strong>Redis</strong> <strong>集群架构模式有哪几种？</strong> <strong>集群的原理是什么？</strong></h4><blockquote><p>待补充：<a href="https://blog.csdn.net/zzhongcy/article/details/108446687">Redis 架构模式详解（单机、主从、哨兵、集群模式）</a></p></blockquote><ul><li><p><strong>1. 单机模式</strong></p><blockquote><p>QPS（每秒查询速度）大约在几万左右。</p></blockquote><p>安装一个 Redis，启动起来，业务调用即可。</p><p><img src="https://i.loli.net/2021/05/25/m5euvrDF1UOtYbn.png" alt="image-20210525232444113"></p><ul><li><strong>优点：</strong> 部署简单；成本低；高性能</li><li><strong>缺点：</strong> 单节点宕机风险 ;  单机高性能受限于 CPU 的处理能力</li></ul></li><li><p><strong>2. 主从复制</strong></p><p><img src="https://i.loli.net/2021/05/25/tGy6WCzmKpS4Mfr.png" alt="image-20210525232806643"></p><p>Redis 的复制（Replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品。</p><ul><li>被复制的服务器为主服务器（Master），而通过复制创建出来的复制品则为从服务器（Slave）。</li></ul><p>主要优缺点：</p><ul><li><strong>优点：</strong> Master/Slave 角色方便水平扩展，降低 Master <strong>读</strong>压力，转交给 Slave 节点；</li><li><strong>缺点：</strong> 可靠性保证不是很好，主节点故障便无法提供写入服务；没有解决主节点<strong>写的压力</strong> ；主节点宕机，需要人为干预。</li></ul></li><li><p><strong>3. 哨兵模式</strong></p><blockquote><p>Redis 2.8版本后引入了哨兵的概念。</p></blockquote><p><img src="https://i.loli.net/2021/05/01/81lKSUu7skhM2Yr.png" alt="img"></p><p>主从模式中，当主节点宕机之后，<strong>从节点是可以作为主节点顶上来继续提供服务</strong>，<u>但是需要修改应用方的主节点地址</u>，还需要命令所有从节点去复制新的主节点数据，整个过程需要<strong>人工干预</strong>。</p><p>为此，引入了哨兵（Sentinel）这个概念，在<strong>主从复制的基础</strong>上，哨兵实现了<strong>自动化故障恢复</strong>。哨兵模式由两部分组成，哨兵节点和数据节点：</p><ul><li><p><strong>哨兵节点</strong>：哨兵节点是特殊的 Redis 节点，不存储数据；</p></li><li><p><strong>数据节点</strong>：主节点和从节点都是数据节点。</p></li></ul><p><strong>哨兵工作原理：</strong></p><ol><li>每个 Sentinel 以每秒一次的频率向它所知的 <strong>Master，Slave 以及其他 Sentinel</strong> 节点发送一个 <code>PING</code> 命令；</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间<strong>超过配置文件 <code>own-after-milliseconds</code> 选项所指定的值</strong>，则这个实例会被 Sentinel 标记为<strong>主观下线</strong>；</li><li>如果一个 Master 被标记为主观下线，那么正在监视这个 Master 的所有 Sentinel 要以<strong>每秒一次</strong>的频率确认 Master 是否真的进入主观下线状态；</li><li>当有<strong>足够数量的 Sentinel</strong>（大于等于配置文件指定的值）在<strong>指定的时间范围内确认</strong> Master 的确进入了主观下线状态，则 Master 会被标记为<strong>客观下线</strong>；</li><li>如果 Master 处于 <strong>ODOWN 状态</strong>，则投票自动选出新的主节点;将剩余的从节点指向新的主节点继续进行数据复制；</li><li>若没有足够数量的 Sentinel 同意 Master 已经下线，Master 的客观下线状态就会被移除。<u>若 Master 重新向 Sentinel 的 PING 命令返回有效回复</u>，Master 的主观下线状态就会被移除。</li></ol><p><u><strong>哨兵模式优缺点</strong></u>：</p><ul><li><strong>优点：</strong>（1）主从自动切换，更加健壮</li><li><strong>缺点：</strong> （1）主从切换需要时间还是会丢失数据；（2）没有解决主节点<strong>写</strong>压力 （3）动态扩容复杂</li></ul></li><li><p><strong>4. 集群模式</strong></p><blockquote><p>Redis 3.0 版本引入了Redis Cluster集群模式。</p></blockquote><img src="https://i.loli.net/2021/05/25/yfskJDK3vrzUoWp.png" alt="img" style="zoom:80%;" /><ul><li>如上图所示：该集群中包含 6 个 Redis 节点，3 主 3 从，分别为 M1，M2，M3，S1，S2，S3。除了主从 Redis 节点之间进行数据复制外，所有 Redis 节点之间采用 <strong>Gossip</strong> 协议进行通信，交换维护节点元数据信息</li></ul><p>Redis Cluster 采用<strong>无中心</strong>结构，<strong>每个节点都可以保存数据</strong>和整个集群状态，每个节点<strong>都</strong>和其他所有节点<strong>连接</strong>。</p><ul><li>Cluster 一般由多个节点组成，节点数量至少为 6 个才能保证组成完整高可用的集群，其中3个为<strong>主</strong>节点，3个为<strong>从</strong>节点；</li></ul><p><strong>4.1 Redis 集群分片概念</strong></p><blockquote><p>单机、主从、哨兵的模式数据都是存储在<strong>一个master节点</strong>上，<strong>其他节点进行数据的复制</strong>。</p><p>集群模式就是把数据进行<strong>分片</strong>存储，当一个分片数据达到上限的时候，还可以分成多个分片。</p></blockquote><p>Redis Cluster 采用<strong>虚拟哈希槽分区</strong>，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式：</p><ul><li><code>HASH_SLOT = CRC16(key) % 16384</code></li></ul><p><strong>每一个主</strong>节点负责维护一部分<strong>槽</strong>以<strong>及</strong>槽所<strong>映射的键值数据</strong>。</p><ul><li><p><strong>举例说明</strong>：</p><blockquote><p>有 3 个节点的集群环境如下</p><ul><li>节点 A 哈希槽范围为 0 ~ 5500；</li><li>节点 B 哈希槽范围为 5501 ~ 11000；</li><li>节点 C 哈希槽范围为 11001 ~ 16383。</li></ul></blockquote><p><strong>增加数据：</strong> （1）根据上述公式计算<strong>新增的key存储</strong> ，映射到相应节点（假设为B）</p><p><strong>增加节点：</strong> （1）从各个节点拿出一部分哈希槽分配到新增的D节点上即可</p><p><strong>删除节点：</strong> （1）删除A节点，只需将A节点的哈希槽移动到其它节点接口</p></li></ul><p><strong>4.2 Reids集群的主从模式</strong></p><p>Redis Cluster 为了保证数据的高可用性，加入了主从模式，<strong>一个主节点对应一个或多个从节点</strong>，主节点提供数据存取，从节点复制主节点数据备份，当这个主节点挂掉后，就会通过这个主节点的从节点选取一个来充当主节点，从而保证集群的高可用。</p><p><strong>4.3 优缺点总结</strong></p><ul><li><strong>优点：</strong> （1）无中心结构 ，<strong>多</strong>节点<strong>存储</strong>数据；（2）节点动态<strong>删除、移动</strong>数据分布方便；（3）<strong>部分节点不可用</strong>，集群依旧可用（哈希槽 + 从节点备份并故障晋升主节点）；</li><li><strong>缺点：</strong> （1）<strong>异步</strong>复制，<strong>无法保证数据一致性</strong>（2）集群搭建<strong>复杂</strong>（3） <strong><code>mget</code>,<code>pipeline</code><strong>等命令。它们需要把请求</strong>分散到多个节点执行</strong>、再聚合。节点越多，性能越低</li></ul></li></ul><h4 id="3-说说-Redis-哈希槽的概念？-什么情况下会导致整个集群不可用？">3. <strong>说说</strong> <strong>Redis</strong> <strong>哈希槽的概念？</strong> <strong>什么情况下会导致整个集群不可用？</strong></h4><blockquote><p>Redis 没有使用哈希一致性算法，而是使用哈希槽。Redis 中的哈希槽一共有 16384 个，计算给定密钥的哈希槽，我们只需要对密钥的 CRC16 取摸 16384。</p></blockquote><p>假设集群中有 A、B、C 三个集群节点，<strong>不存在复制模式</strong>下，每个集群的节点包含的哈希槽如下：</p><ul><li><p>节点 A 包含从 0 到 5500 的哈希槽；</p></li><li><p>节点 B 包含从 5501 到 11000 的哈希槽；</p></li><li><p>节点 C 包含从 11001 到 16383 的哈希槽；</p></li></ul><p>这时，如果<strong>节点 B 出现故障</strong>，<u>整个集群就会出现缺少 5501 到 11000</u> 的哈希槽范围而不可用。</p><h4 id="4-Redis-常见性能问题和解决方案有哪些？">4. <strong>Redis 常见性能问题和解决方案有哪些？</strong></h4><p>Redis 常见性能问题和解决方案如下：</p><ul><li>**Master不做持久化，   Slave 做 AOF：**Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件；如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次；</li><li>**同局域网：**为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内；</li><li>尽量避免在压力很大的主库上增加从库；</li><li><strong>主从复制不要用图状结构</strong>，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;-Slave3….；这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变</li></ul><h2 id="6-5-Redis-Key相关">6.5 Redis Key相关</h2><h4 id="1-假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如果将它们全部找出来？">1. <strong>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某</strong>个固定的已知的前缀开头的，如果将它们全部找出来？</h4><p>我们可以使用 keys 命令和 scan 命令，但是会发现使用 scan 更好。</p><ul><li><p><strong>keys命令</strong></p><p>虽然可以查询但不太推荐：</p><ul><li><strong>时间长且会导致线程阻塞：</strong> 时间长是因为O(N)遍历 ； 阻塞是因为Redis单线程，要等遍历完，这使得Redis要等keys执行完毕才能恢复生产（在生成环境中这是不被允许的）。</li><li><strong>没有分页功能：</strong> 一次查找所有的结果</li></ul></li><li><p><strong>scan命令</strong></p><p>推荐：</p><ul><li><p>不会阻塞，但查找出的元素可能重复，需要客户端去重下</p><blockquote><p><strong>为什么不会阻塞？</strong></p><p>因为 scan 是通过游标方式查询的 ，查询过程中会把游标返回给客户端，单次返回空值且游标不为 0，则说明遍历还没结束，客户端继续遍历查询。</p></blockquote></li></ul></li></ul><h4 id="2-如果有大量的-key-需要设置同一时间过期，一般需要注意什么？">2. <strong>如果有大量的 key 需要设置同一时间过期，一般需要注意什</strong>么？</h4><p>如果有大量的 key 在同一时间过期，那么可能同一秒都从数据库获取数据，给数据库造成很大的压力，导致<strong>缓存雪崩</strong>。</p><ul><li><strong>解决方案：</strong> 最好给数据的过期时间加一个<strong>随机值</strong>，让过期时间更加分散</li></ul><h4 id="3-什么是-bigkey？会存在什么影响？">3. <strong>什么是</strong> <strong>bigkey？会存在什么影响？</strong></h4><p>bigkey 是指键值占用内存空间非常大的 key。例如一个字符串 a 存储了 200M 的数据。</p><p><strong>bigkey 的主要影响有：</strong></p><ul><li><p><strong>网络阻塞</strong>：获取 bigkey 时，传输的数据量比较大，会增加带宽的压力；</p></li><li><p>超时阻塞：因为 bigkey 占用的空间比较大，所以<u>操作起来效率会比较低</u>，导致出现阻塞的可能性增加。</p></li></ul><h4 id="4-Redis-如何解决-key-冲突？">4. <strong>Redis</strong> <strong>如何解决</strong> <strong>key</strong> <strong>冲突？</strong></h4><blockquote><p>Redis 如果 key 相同，后一个 key 会覆盖前一个 key。</p></blockquote><p>如果要解决 key 冲突，最好给 <strong>key 取好名</strong>区分开，可以按业务名和参数区分开取名，避免重复 key 导致的冲突。</p><h4 id="5-如何解决Redis的并发竞争Key问题-？">5. 如何解决Redis的并发竞争Key问题 ？</h4><blockquote><p>多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同。</p></blockquote><ul><li><p>解决方案：<strong>分布式锁</strong>（zookeeper 和 Redis 都可以实现分布式锁）。</p><ul><li><p><strong>zookeeper分布式锁</strong>：（1）每个客户端对某个方法加锁时，在zookeeper上的 与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点；（2）判断是否获取锁的方式很简单，只需要判断有 序节点中序号最小的一个；（3）当释放锁的时候，只需将这个瞬时节点删除即可。</p><blockquote><p>同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p></blockquote></li></ul></li></ul><h4 id="6-Redis删除key的底层原理实现？">6. Redis删除key的底层原理实现？</h4><blockquote><p>参考：<a href="https://www.hoohack.me/2019/06/24/redis-expire-strategy">https://www.hoohack.me/2019/06/24/redis-expire-strategy</a></p></blockquote><p>Redis在启动的时候，会注册两种事件：</p><ol><li><strong>时间事件：</strong> Redis处理后台操作的一类事件，比如客户端超时、删除过期key</li><li><strong>文件事件：</strong> redis注册的回调函数是serverCron，在**定时任务（惰性删除）**回调函数中，通过调用databasesCron清理部分过期key</li></ol><p><strong>定时删除</strong></p><p>对于每一个设置了过期时间的key都会创建一个<strong>定时器</strong>，一旦到达过期时间就立即删除：</p><ul><li>缺点：占用了大量的CPU资源去处理过期的数据，会影响Redis的吞吐量和响应时间。</li></ul><p><strong>惰性删除</strong></p><p><strong>每次访问key的时候</strong>，都会调用<code>expireIfNeeded</code>函数判断key是否过期，如果是，清理key：</p><ul><li>缺点：大量的过期key没有被再次访问，因此不会被清除，导致占用了大量的内存。</li></ul><p><strong>定期删除</strong></p><p>每隔一段时间，扫描Redis中过期key字典，并清除部分过期的key：</p><ul><li>缺点：折中方案</li></ul><p><strong>Redis单线程清理key的时机</strong></p><p>Redis是以**单线程运行的，在清理key是不能占用过多的时间和CPU，**需要在尽量不影响正常的服务情况下，进行过期key的清理。</p><ul><li><p><strong>以随机删除为例</strong></p><ol><li><p>server.hz配置了serverCron任务的执行周期，默认是10，<strong>即CPU空闲时每秒执行十次</strong>；</p></li><li><p><strong>每次清理过期key的时间不能超过CPU时间的25%</strong> ；</p></li><li><p>如果是快速清理模式（在beforeSleep函数调用），则一次清理的最大时间是1ms；</p></li><li><p>依次遍历所有的DB；</p></li><li><p>从db的过期列表中随机取20个key，判断是否过期，如果过期，则清理；</p></li><li><p>如果有5个以上的key过期，则重复步骤5，否则继续处理下一个db ；</p></li><li><p>在清理过程中，如果达到CPU的25%时间，退出清理过程。</p></li></ol></li><li><p><strong>Redis4.0使用BIO处理</strong></p><p>Redis4.0以前，删除指令是del，del会直接释放对象的内存，但是，如果删除的key是一个<strong>非常大的对象</strong>，那么删除操作就会导致单线程卡顿，Redis的响应就慢了。</p><ul><li>在Redis4.0版本引入了unlink指令，能对删除操作进行“懒”处理，<strong>将删除操作丢给后台线程，由后台线程BIO来异步回收内存</strong>。</li></ul></li></ul><p><strong>内存淘汰策略</strong></p><p>Redis的内存淘汰策略，是指内存达到maxmemory极限时，使用某种算法来决定清理掉哪些数据，以保证新数据的存入。</p><h1>七、数据结构和算法</h1><h4 id="1-如何对快排进行优化？">1. 如何对快排进行优化？</h4><p>(1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot）</p><p><strong>1.三数取中法和随机交换法</strong></p><blockquote><p>快排将选取的基准点经过调整放到合适的位置，之后将这个基准点左右两边的区间分别递归的进行快排，如果基准点的数据比较小，将会导致调整后基准点处于靠近两侧的位置，那么两边的区间长度将会严重失去平衡.</p><p><strong>三数取中法：指的是选取基准点之前</strong>我们可以拿出数列中间位置元素的值，将它和首尾的元素进行比较，之后将这三个数中的<strong>中间数</strong>交换到<strong>数列首位</strong>的位置，之后将这个数作为基准点，<u>尽量减小之后的分区后左右两边的区间长度之差</u>。</p></blockquote><p>2.（:triangular_flag_on_post:*1）分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大</p><blockquote><p><u><strong>3路法同样是针对含有大量【重复数列】的优化</strong></u>，不同于之前的快排方法，3路法的思想是将数列分成3个区间，分别是小于、等于和大于基准点的区间，那么分区之后，对于等于基准点的区间内的元素，我们就不需要对其做任何处理了，只需要递归的处理小于和大于基准点的元素即可。</p></blockquote><p>3.（:triangular_flag_on_post:*1）递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。</p><blockquote><p>当待排序序列的长度分割到一定大小后，使用插入排序。</p><p>原因：<strong>对于很小和部分有序的数组，快排不如插排好</strong>。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排</p></blockquote><h4 id="2-快排和堆排的区别？-什么时候使用快排和堆排？">2. <strong>快排和堆排的区别？</strong> <strong>什么时候使用快排和堆排？</strong></h4><p>二者区别：</p><ul><li><p>**综合性能：**实际应用中，虽然（:triangular_flag_on_post:）<u>堆排序的时间复杂度要比快速排序稳定</u>（快排最差退化成O(N^2)） ，但是统计意义上这种情况较少，所以综合性能还是快排更优；</p></li><li><p>（:triangular_flag_on_post:*1）<strong>交换次数：</strong> 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序；</p></li><li><p><strong>访问友好：</strong> 堆排序数据访问的方式没有快速排序友好。</p><blockquote><p><strong>对于快速排序来说，数据是顺序访问的；而堆排序来说，数据是跳着访问的。<strong>比如，堆排序中，最重要的一个操作就是数据的堆化。对堆顶节点进行堆化，会一次访问</strong>数组下标1，2，4，8</strong>的元素，而不是像快排那样，局部顺序访问，<u>所以对<strong>CPU缓存</strong>是不友好的</u>。</p></blockquote></li></ul><p>快排和堆排：</p><ul><li><p><strong>快排：</strong> 绝大多数场合</p></li><li><p><strong>堆排：</strong> topK问题、优先队列（需要在一组不停更新的数据中不停地找最大/小元素）</p><blockquote><p>在N个元素中找到top K，时间复杂度是O(N log K)，空间复杂的是O(K)，而快速排序的空间复杂度是O(N)，</p></blockquote></li></ul><h4 id="3-【面试重点】-有哪些排序算法，各算法的时间复杂度-哪些是稳定的？为什么是稳定的？">3. **【面试重点】**有哪些<a href="">排序</a><a href="">算法</a>，各<a href="">算法</a>的时间复杂度 ? 哪些是稳定的？为什么是稳定的？</h4><p><img src="https://i.loli.net/2021/05/01/K3s7DFEvyhHkwI9.png" alt="image-20210501224258097"></p><h5 id="3-1-如果数据大致有序的，用什么排序比较好？">3.1 如果数据大致有序的，用什么排序比较好？</h5><p>如果是<strong>大致有序</strong>，用 <u>插入排序</u> 比较好：</p><ul><li><u>直接插入排序</u>是将第i个元素插入到已经排序好的前i-1个元素中 ，当元素基本有序时。和前i-1个元素<strong>末尾比较一次</strong>就可以直接插入。</li></ul><p>在相比使用其它排序：</p><ul><li><p><u>归并排序：</u> 归并排序和数组是否有序无关，都是O(nlgn)。</p><blockquote><p>归并排序是把一个有n个记录的无序文件看成由<strong>n个长度为1</strong>的有序子文件组成的文件，然后进行两两归并，得到[n/2]个长度为2或1的有序文件，再两两归并 。</p></blockquote></li><li><p><u>快速排序：</u> 数组基本有序时，此时如果使用基点是最后一个元素，划分的两个子数组极为不平衡，每次划分比较次数都很多。所以不推荐。</p></li></ul><h4 id="4-二叉查找树，红黑树和平衡二叉树的区别？（有了二叉查找树、平衡树（AVL）为啥还需要红黑树？）">4. <strong>二叉查找树，<a href="">红黑树</a>和<a href="">平衡二叉树</a>的区别？（有了二叉查找树、平衡树（AVL）为啥还需要红黑树？）</strong></h4><blockquote><p>总结来说：平衡树是为了解决二叉查找树退化为链表的情况；而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。</p></blockquote><ul><li><p><strong>二叉查找树退化成单链表</strong></p><p>正常使用二叉查找树是类似于<u>二分查找 O（logn）</u>，但是极端情况：</p><ul><li><p>构建的二叉树所有节点都只有右子树或左子树，此时时间复杂度退化成O(N)</p><p><img src="https://i.loli.net/2021/05/01/38TASb1DB7sYN5k.jpg" alt="preview"></p></li></ul></li><li><p><strong>平衡二叉树频繁左右旋</strong></p><p>平衡二叉树就是为了解决二叉查找树退化成一颗链表而诞生了，平衡树具有如下特点：</p><ol><li><p>具有二叉查找树的全部特性；</p></li><li><p><strong>每个节点的左子树和右子树的高度差至多等于1</strong>。</p></li></ol><p>避免了二叉查找树极端情况产生，但是：</p><ul><li>每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过<strong>左旋</strong>和<strong>右旋</strong>来进行调整，使之再次成为一颗符合要求的平衡树。</li></ul><p>平衡树性能大打折扣。</p></li><li><p><strong>红黑树规不需要频繁着调整</strong></p><p>红黑树具有如下特点：</p><blockquote><p>最坏情况下，也能在 O(logn) 的时间复杂度查找到某个节点。</p><ul><li>与平衡树不同的是，红黑树在插入、删除等操作，（:triangular_flag_on_post:*1）<strong>不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整</strong>，这也是我们为什么大多数情况下使用红黑树的原因；</li><li>但是，单单在查找方面的效率的话，平衡树比红黑树快。</li></ul></blockquote><p><img src="https://i.loli.net/2021/05/01/sFSaG9POEi73hdo.jpg" alt="img"></p><ol><li>具有二叉查找树的特点；</li></ol></li></ul><ol start="2"><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据；</li><li>（:triangular_flag_on_post:*1）<strong>任何相邻的节点都不能同时为红色</strong>，也就是说，红色节点是被黑色节点隔开的；</li><li>每个节点，<strong>从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点</strong>。</li></ol><h5 id="4-1-为什么红黑树不需要频繁调整？">4.1 为什么红黑树不需要频繁调整？</h5><blockquote><p>详细理解红黑树一篇不错的文章：<a href="https://zhuanlan.zhihu.com/p/97523789">百图详解红黑树，想不理解都难</a></p></blockquote><p>平衡二叉树这种高度差为 1 的要求太严格了，尤其是对于频繁删除、插入的场景非常浪费时间。</p><p>但是由于红黑树：</p><ul><li>具有二叉树所有特点。</li><li>每个节点只能是红色或者是黑色。</li><li><strong>根节点只能是黑色</strong>，且黑色根节点不存储数据。</li><li><strong>任何相邻的节点都不能同时为红色</strong>。</li><li>红色的节点，它的子节点只能是黑色。</li><li>从任一节点到其每个叶子的所有路径都包含<strong>相同数目的黑色节点</strong>。</li></ul><p><strong>不追求插入、删除等操作绝对平衡</strong>，只需满足上述条件即可。它的旋转次数少，<strong>插入最多两次旋转</strong>，<strong>删除最多三次旋转</strong>。</p><p>所以在搜索、插入、删除操作较多的情况下，红黑树的效率是优于平衡二叉树的。</p><h4 id="5-快速排序的过程-？">5. <strong>快速<a href="">排序</a>的过程 ？</strong></h4><ul><li><p>手撕一个<a href="">二分查找</a> 和快排？</p><ul><li><p><strong>二分查找</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binary search</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid ;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right) <span class="comment">//*&lt;= 而不是&lt; </span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(value == arr[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid; <span class="comment">// 如果数组存在待查找元素，按照逻辑一定会是mid</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span>(value &lt; arr[mid])</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// value &gt; arr[mid]</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>快速排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] quick_sort(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;=left)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择基准：数组最右数字</span></span><br><span class="line">        <span class="comment">// *如果选择最左，思考交换过程</span></span><br><span class="line">        <span class="comment">// *partition 左侧始终是比pivot小的数</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[right];</span><br><span class="line">        <span class="keyword">int</span> partition = left;</span><br><span class="line">        <span class="comment">// 遍历分区元素</span></span><br><span class="line">        <span class="comment">// 小于基准的放基准左边，大于的放基准右边</span></span><br><span class="line">        <span class="comment">// * 终止条件：i &lt; right 而非 right-1！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt; right;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;pivot) <span class="comment">// 实际只交换小于到左边即可</span></span><br><span class="line">            &#123;</span><br><span class="line">                swap(arr,i,partition);</span><br><span class="line">                partition++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// *基准插入位置partition位置</span></span><br><span class="line">        swap(arr,partition,right);</span><br><span class="line">        <span class="comment">//递归的排序</span></span><br><span class="line">        quick_sort(arr,left,partition-<span class="number">1</span>);</span><br><span class="line">        quick_sort(arr,partition+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-【重点】-红黑树结构？自旋过程？大致原理。">6.【重点】 红黑树结构？自旋过程？大致原理。</h4><p><a href="https://www.huaweicloud.com/articles/efc3f84541cd50fc4988048d4c0f68b3.html">https://www.huaweicloud.com/articles/efc3f84541cd50fc4988048d4c0f68b3.html</a></p><p><img src="https://i.loli.net/2021/05/22/psc7jdzmoDbZgGv.png" alt="image-20210522100743169"></p><p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html">https://tech.meituan.com/2014/06/30/mysql-index.html</a>  <a href="https://tech.meituan.com/2014/06/30/mysql-index.html">MySQL索引原理及慢查询优化</a></p><h4 id="7-布隆过滤器原理？为什么使用多个哈希函数？其它相关应用？">7. 布隆过滤器原理？为什么使用多个哈希函数？其它相关应用？</h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/43263751">详解布隆过滤器的原理，使用场景和注意事项</a></p></blockquote><blockquote><p>“布隆说：<strong>不存在</strong>的那么<strong>一定不存在</strong>”</p><p>“布隆说：<strong>存在</strong>的那么<strong>只是可能存在</strong>”</p></blockquote><h5 id="7-1-从HashMap说起—当你判断某个元素时候你在想什么？">7.1 从HashMap说起—当你判断某个元素时候你在想什么？</h5><blockquote><p>通常我们怎么判断一个数组，是否存在某个元素呢？</p></blockquote><p>聪明的你一定想到HashMap：（1）HashMap将数组所有元素使用哈希函数，映射到HashMap上（HashMap本身也是一个数组）（2）然后就可以在O(1)级别判断某个元素是否存在。</p><p>但是这种做法通常会导致以下问题：</p><ol><li><strong>一旦数组很大</strong>，比如上亿，HashMap将会占据非常大的内存；</li><li>数组很大，不大可能一次性能在内存构建HashMap；</li><li>而且HashMap，通常存在负载因子，是不能充分利用内存的。</li></ol><p>为此，我们可以从以下方向优化：</p><ul><li><p><strong>只存储key。<strong>但是，因为我们</strong>只要判断某个元素（key）是否存在</strong>， 不需要取出对应key的value—也就是<strong>不需要存储value</strong>。</p></li><li><p><strong>key映射为bit数组索引。<strong>key映射为<code>bit</code>数组索引，即</strong>位图对应索引</strong>，  索引对应数值用 <code>0/1</code> 就可以标识为是否存在该key。</p></li></ul><p>为此，我们可以【第一阶段优化】如下：</p><p><img src="https://i.loli.net/2021/05/28/acoknPGdU3DVMEw.png" alt="img"></p><p>看样子似乎是满足我们要求了，但是依旧存在以下问题：</p><ol><li>只使用一个<code>hash</code>函数，<strong>空间利用率低</strong>。</li></ol><p>一个<code>hash</code>函数只能<strong>将key散列到一个位置</strong> ，虽然hash尽量优良映射均匀，但是空间利用率依然不算高。</p><p>因此，我们可以多个函数，将<strong>key同时映射到多个位置</strong>，即使发生哈希冲突，某个位置被覆盖，其它依旧存在，<strong>变相的降低了哈希冲突</strong>。</p><h5 id="7-2-数据结构及原理">7.2 数据结构及原理</h5><p>布隆过滤器，最终结构如下：一个<code>bit</code>数组，采用<strong>多个hash函数</strong>进行映射。</p><p><img src="https://i.loli.net/2021/05/28/zIxX9WcwUoT2lGK.png" alt="img"></p><h5 id="7-3-布隆函数优缺点">7.3 布隆函数优缺点</h5><ul><li><strong>优点</strong><ol><li><code>存储/插入/查询</code>时间复杂度，都是常数级别<code>O(1)</code></li><li><strong>保密性好</strong>，因为不需要存储数据本身</li><li><strong>存储数据大</strong>，可以存储非常大的数据本身</li></ol></li><li><strong>缺点</strong><ol><li>随着元素数量增加，<strong>误算率</strong>会增加</li><li><strong>不能删除</strong>元素，因为删除某个元素，要把其对应所有hash函数散列的位置如A,B，置为<code>0</code> 。其它元素的可能散列到位置A，再去判断这个元素是否存在就会出现<strong>误判</strong>。</li></ol></li></ul><h5 id="7-4-应用场景">7.4 应用场景</h5><ol><li><p><strong>解决缓存穿透</strong>，防止<strong>不存在</strong>的元素去查询数据库</p></li><li><p><strong>防止重复被攻击</strong>，用户第一次请求，将请求参数放入布隆过滤器中，当第二次请求时，先判断请求参数是否被布隆过滤器命中。可以提高缓存命中率</p></li><li><p><strong>判断用户是否阅读过某视频或文章</strong>， 比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。</p></li></ol><h1>八、场景题&amp;智力题</h1><h2 id="8-1-场景题">8.1 场景题</h2><h4 id="1-设计一个微信运动排行榜？（Redis）">1. <strong>设计一个微信运动排行榜？（Redis）</strong></h4><ul><li><p><strong>被CSIG伤过的的心还可以爱谁（第一次回答）</strong></p><blockquote><p>“可以使用mysql, 将用户的好友列表关联的运动记录查询出来，然后通过order by 来进行排序，就可以实现了。”</p></blockquote><p>一旦数据量大达到千万级别的时候，不可避免地会出现慢查询，效率就会降低。所以<u>这不是面试官想听到的回答！</u></p></li><li><p><strong>Redis–高效</strong></p><p>使用Redis的有序集合 zset（<strong>有序且不重复</strong>） 。因为 zset 排序的下标从0 开始，自带一个score 值，该值可以当作排行的标准 。</p><ul><li><strong>添加用户和步数：</strong> <code>zadd key score member</code></li><li><strong>查询指定排名范围内用户：</strong> （从小到大）<code>zrange key start stop withscores </code>or （从大到小）<code>zrevrange key start stop withscores</code></li></ul><p>根据上面，所以用户按score从小到大排序完毕了，如果还要获取排名也可以使用下面命令：</p><ul><li><strong>查询指定用户排名</strong> ： <code>zrank key member</code> or <code>zrevrank key member</code></li></ul><p>一个简单的排行榜就设计完成了。</p><blockquote><p>如果面试官进一步问：一周排行榜怎么设计？</p></blockquote><p>一周的数据其实就是7天数据的累加，累加完后再排序，一个月的数据原理也是一样。可以使用 ：</p><ul><li><p><code>ZINTERSTORE</code> ： 计算给定一个或多个有序集的交集并将结果放到一个新的有序集合destination中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</span><br></pre></td></tr></table></figure><p>默认情况使用的函数是求和。</p></li></ul><p>所以可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zunionstore last_seven_days 7 20210315  20210316 20210317 20210318 20210319 20210320 20210321</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-海量数据问题">2. <strong>海量数据问题</strong></h4><blockquote><p>参考：<a href="https://blog.csdn.net/v_JULY_v/article/details/6279498">https://blog.csdn.net/v_JULY_v/article/details/6279498</a></p></blockquote><p>在海量数据中，针对top K类问题，通常比较好的方案是：</p><ul><li><p><strong>Top数问题：小根堆</strong></p><blockquote><p><strong>有1亿个浮点数，如何找出其最大的10000个？</strong></p></blockquote><p>直接进行排序，大约需要10^8*4字节 = 400M ，如果内存够可以直接进行排序；如果内存不够采用：</p><ol><li><strong>最小堆法</strong> ：（1）先读入10000个数来创建大小为10000的<strong>最小堆</strong>（假设这10000个数是最大的10000个，然后每次和这10000中最小的比较）（2）遍历后续数字，和堆顶最小数字比较：如果小于堆顶数字，继续；如果大于堆顶数字，则替换堆顶并重新调整为最小堆（3）整个过程直至1亿个数全部遍历完为止</li><li><strong>分治法。</strong> （1）1亿分为100份，每份100万个数据，找到每份的<strong>最大的1万</strong>个 （2）在剩下的100*1万个数据找到最大的1万个</li><li><strong>哈希法。</strong> <u>如果这1亿个书里面有很多重复的数</u>，先通过Hash法，把这1亿个数字去重复。 然后再采用方法 1 或 2 。</li></ol></li><li><p><strong>最多重复（频率最高）：Hash映射+HashMap频率计算</strong></p><blockquote><p><strong>【最多重复】海量日志数据，提取出某日访问百度次数最多的那个IP。</strong></p></blockquote><ul><li><strong>分治法（基于Hash）。</strong> （1）按照IP地址的<code>Hash(IP)%1024</code>值，把海量IP日志分别存储到1024个小文件中 （2）对于每一个小文件，可以构建一个IP为key，出现次数为value的<strong>Hash map</strong> （3）可以得到1024个小文件中的出现次数最多的IP ，再根据常规排序得到。</li></ul><p><u>:warning: 使用Hash分散ip可以保证相同ip都在同一个文件夹</u>，如果只是简单均分是不行的。</p><blockquote><p><strong>【最多重复】有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</strong></p></blockquote><ul><li>同上，<strong>分治法（基于Hash）。</strong> 首先计算下：1G / 1M = 1000个小文件，为保险分为2000个（1）<code>Hash(词)%2000</code> 映射到2000个文件中（2）分别计算2000个文件频率最高的那个单词，然后常规排序即可（2000个单词占：2k*16B=32KB&lt;&lt;1M）</li></ul><blockquote><p><strong>【最多重复】有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</strong></p></blockquote><ul><li>同上，<strong>分治法（基于Hash）。</strong> 顺序读取10个文件，然后将query重新映射到若干个文件中，保证相同query都在同一个文件。其余同上。</li></ul></li><li><p><strong>不重复数：位图</strong></p><blockquote><p>【<strong>不重复</strong>】 <strong>在2.5亿个整数中找出不重复的整数。注，内存不足以容纳这2.5亿个整数。</strong></p></blockquote><ul><li><p><strong>采用2位图（<a href="https://www.cnblogs.com/54chensongxia/p/11591979.html">BitMap</a>）</strong>。00表示不存在，01表示出现一次，10表示多次，11无意义，需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2.5</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mi>b</mi><mo>=</mo><mn>2.5</mn><mo>∗</mo><mn>0.1</mn><mi>G</mi><mi>b</mi><mo>=</mo><mn>0.25</mn><mi>G</mi><mi>b</mi><mo>=</mo><mn>25</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2.5*10^8b = 2.5*0.1Gb=0.25Gb=25MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2.5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2.5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">0.1</span><span class="mord mathnormal">G</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">0.25</span><span class="mord mathnormal">G</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">25</span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span></span></span></span>。但是我们<strong>需要把所有的整数都表示出来</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><msup><mn>2</mn><mn>32</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi><mo>=</mo><mn>1</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2*2^{32}bit=1GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span></span></span></span>（1）扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变（2）查看bitmap，<u>把对应位是<strong>01</strong></u> 的整数输出即可。</p><p>注，int类型占32个字节，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span> 表示其能表示的整数个数。</p></li></ul><blockquote><p>【<strong>不重复·腾讯</strong>】<strong>给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</strong></p></blockquote><ul><li><strong>采用2位图（<a href="https://www.cnblogs.com/54chensongxia/p/11591979.html">BitMap</a>）</strong>。 需要40亿bit，大约500M，但实际是要表示所有整数，故还是1GB。其余同上。</li></ul></li><li><p><strong>共同数</strong></p><blockquote><p>【<strong>相同数</strong>】 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</p></blockquote><ul><li><strong>分治法（基于Hash）。</strong> （1）分别将a，b两个大文件各自映射为10000个小文件，这样相同url会映射到a,b相同哈希值小文件中。（2）在a,b每一对小文件找到相同的url。</li></ul></li></ul><h4 id="3-分布式相关">3. <strong>分布式相关</strong></h4><blockquote><p><strong>谈一谈，分布式集群中如何保证线程安全？</strong></p></blockquote><ul><li><p>对于单一服务来说，只要保证一台机器上的对于共享资源的访问是同步进行的就能保证线程安全了；但是对于分布式系统而已，保证一台服务器的同步，并不能保证访问共享资源是同步的；</p></li><li><p>所以可以考虑使用<strong>分布式锁</strong>的方式来保证分布式中的线程的安全线，这样不同的服务不同的线程通过竞争分布式锁来获取共享资源的操作权限；</p></li><li><p>例如<u><strong>redis的分布式锁、zookeeper锁</strong></u>，都可以作为分布式线程安全的手段。</p></li></ul><blockquote><p><strong>在淘宝购物，这个场景下，你会怎样来设计消息队列？</strong></p></blockquote><ul><li><p><a href="https://juejin.cn/post/6844903817348136968">什么是消息队列？</a></p><p>消息队列（MQ）可以简单理解为：<strong>把要传输的数据放在队列中</strong>，一种先进先出的结构。</p></li><li><p><strong>怎么去设计淘宝消息队列？</strong></p><p>待补充。</p></li></ul><h4 id="4-微信抢红包">4. <strong>微信抢红包</strong></h4><blockquote><p><a href="https://www.cnblogs.com/alimayun/p/12795698.html">例如一个人在群里发了100块钱的红包，群里有10个人一起来抢红包，每人抢到的金额随机分配。</a></p><ol><li><p>所有人抢到的金额之和要等于红包金额，不能多也不能少。</p></li><li><p>每个人至少抢到1分钱。</p></li><li><p>要保证红包拆分的金额尽可能分布均衡，不要出现两极分化太严重的情况。</p></li></ol></blockquote><p><strong>二倍均值法</strong>：假设剩余红包金额为m元，剩余人数为n，那么有如下公式：</p><ul><li><p><strong>每次抢到的金额 =  [0.01，m /n × 2 - 0.01]</strong></p></li><li><p>这个公式，保证了每次随机金额的平均值是相等的，不会因为抢红包的先后顺序而造成不公平。</p></li></ul><p>举例说明：</p><ul><li><p>假设有5个人，红包总额100元。100÷5×2 = 40，所以第1个人抢到的金额随机范围是[0.01，39.99]元，在正常情况下，平均可以抢到20元。假设第1个人随机抢到了20元，那么剩余金额是80元。80÷4×2 = 40，所以第2个人抢到的金额的随机范围同样是[0.01，</p><p>39.99]元，在正常的情况下，还是平均可以抢到20元。假设第2个人随机抢到了20元，那么剩余金额是60元。60÷3×2 = 40，所以第3个人抢到的金额的随机范围同样是[0.01，39.99]元，平均可以抢到20元。以此类推，每一次抢到金额随机范围的均值是相等的。</p></li></ul><h2 id="8-2-智力题">8.2 智力题</h2><h4 id="1-厉害了我的杯">1. <strong>厉害了我的杯</strong></h4><blockquote><p>有一种玻璃杯质量确定但未知，需要检测。 有一栋100层的大楼，该种玻璃杯从某一层楼扔下，刚好会碎。 现给你两个杯子，问怎样检测出这个杯子的质量，即找到在哪一层楼刚好会碎？</p></blockquote><p>参考：<a href="https://cloud.tencent.com/developer/article/1497944">https://cloud.tencent.com/developer/article/1497944</a></p><h4 id="2-赛马问题">2. <strong>赛马问题</strong></h4><blockquote><p>64匹马，8个跑道，问最少比赛多少场，可以选出跑得最快的4匹马。</p><ul><li>Assumptions：每场比赛每个跑道只允许一匹马，且不存在并列情形。</li></ul></blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/103572219">https://zhuanlan.zhihu.com/p/103572219</a></p><h1>九、框架相关</h1><h2 id="9-1-（要扩充）设计模式">9.1 （要扩充）设计模式</h2><blockquote><p>没有足够实际代码经验，只好先写这些应付下面试。</p></blockquote><h4 id="1-说说什么是单例模式-手写一个？">1. <strong>说说什么是单例模式 ?</strong> <strong>手写一个？</strong></h4><p>单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。</p><ul><li><p><strong>手写单例模式</strong></p><blockquote><p>参考：<a href="https://www.runoob.com/design-pattern/singleton-pattern.html">https://www.runoob.com/design-pattern/singleton-pattern.html</a></p></blockquote><blockquote><p>记忆：“2private + 1public ”</p></blockquote><ol><li><p><strong>饿汉式</strong></p><p>线程安全 ， 但：类加载时就初始化，浪费内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建 SingleObject 的一个对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingleObject();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// *让构造函数为 private，这样该类就不会被实例化</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 获取唯一可用的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>懒汉式（不加锁）</strong></p><p>只有真正调用获取实例对象时，才会创建一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 调用时才判断</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) </span><br><span class="line">    &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>懒汉式（加锁）</strong></p><p>线程安全，但加锁性能不够高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="comment">// 就是多了个synchronized关键字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>双检锁式</strong></p><p>懒汉式（加锁）虽然可以保证只创建一个单例，但其性能不高，因为每次访问<strong>整个方法都加锁</strong>。</p><p>因此出现双检索式，在<code>instance=new DoubleCheckSingleton();</code> 进行加锁 ， <code>return instance;</code> <strong>不加锁</strong>！</p><blockquote><p><strong>为什么要进行两次检查instance==null？</strong></p><ol><li><p>第一层检查作用</p><p>主要为了提高性能。如果没有第一层，上来就要加锁比较耗费性能</p></li><li><p>第二层检查作用</p><p>解决多线程并发问题。假设是第一次开始执行<code>getInstance</code>方法：</p><ol><li>A，B两个线程，此时<code>instance==null</code> ，A，B都通过了第一层检查。</li><li>假设A先拿到锁，往下执行创建一个实例，然后释放了锁；</li><li>此时B也拿到了锁，<strong>如果没有第二层检查，B会进行重新new一个实例</strong>，违背单例模式！</li></ol></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckSingleton</span></span></span><br><span class="line"><span class="class"></span>&#123;      </span><br><span class="line">     <span class="comment">// volitale 关键字修饰，避免指令重排，因为初始化操作是不原子化的 ：</span></span><br><span class="line">    <span class="comment">//  (1) 给DoubleCheckSingleton类的实例instance分配内存</span></span><br><span class="line">    <span class="comment">//  (2) 调用实例instance的构造函数来初始化成员变量</span></span><br><span class="line">    <span class="comment">//  (3) 将instance指向分配的内存地址</span></span><br><span class="line">    <span class="comment">//  在多线程中，A可能是 1→3→2的顺序，执行到1→3，此时另外一个线程看到instance不为null（因为前面线程执行了3）就直接返回实例。而此时并没有被分配内存故可能出现问题。</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123; <span class="comment">//第一层检查，是否存在实例</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckSingleton.class)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123; <span class="comment">//第二层检查，防止出现另外一个线程阻塞在synchronized，获得锁后重复创建实例</span></span><br><span class="line"></span><br><span class="line">                    instance=<span class="keyword">new</span> DoubleCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="2-说说你对代理模式的理解？">2. <strong>说说你对代理模式的理解？</strong></h4><p>代理模式是给某一个对象提供一个代理，并由<strong>代理对象控制对原对象的引用</strong>。</p><ul><li><strong>优点</strong>：代理模式能够协调调用者和被调用者，<u>在一定程度上降低了系统的<strong>耦合度</strong></u>；可以<u>灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务</u>。</li><li><strong>缺点</strong>：由于使用了代理模式，因此程序的性能<u>没有直接调用性能高</u>；使用代理模式<u>提高了代码的复杂度</u>。</li></ul><h4 id="3-说说简单工厂模式？">3. <strong>说说简单工厂模式？</strong></h4><p>简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，<strong>对实现了同一接口的一些类进行实例的创建</strong>。</p><ul><li><p>比如，一台咖啡机就可以理解为一个工厂模式，你只需要按下想喝的咖啡品类的按钮（摩卡或拿铁），它就会给你生产一杯相应的咖啡，你不需要管它内部的具体实现，只要告诉它你的需求即可；</p></li><li><p>【<strong>优点</strong>】<strong>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例</strong>，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；</p></li><li><p>【<strong>缺点</strong>】 不易拓展，<u>一旦添加新的产品类型，就不得不修改工厂的创建逻辑</u>； 产品类型较多时，工厂的创建逻辑可能过于复杂，一旦出错可能造成所有产品的创建失败，不利于系统的维护。</p></li></ul><h4 id="4-说说抽象工厂模式？">4. <strong>说说抽象工厂模式？</strong></h4><p>抽象工厂模式是在简单工厂的基础上将未来<strong>可能需要修改的代码抽象出来</strong>，通过继承的方式让子类去做决定。</p><ul><li>【<strong>简单工厂模式缺点</strong>】以上面的咖啡工厂为例，某天我的口味突然变了，<u>不想喝咖啡了想喝啤酒，这个时候如果直接修改简单工厂里面的代码</u>，这种做法不但不够优雅，也不符合软件设计的“开闭原则”，因为每次新增品类都要修改原来的代码。</li><li>【<strong>抽象工厂</strong>】 <strong>抽象工厂里只声明方法，具体的实现交给子类（子工厂）去实现</strong>，这个时候再有新增品类的需求，只需要新创建代码即可。如，创建一个啤酒工厂而不是咖啡工厂。</li></ul><h4 id="5-装饰器模式是什么？">5. <strong>装饰器模式是什么？</strong></h4><blockquote><p>不够深入。</p></blockquote><p>装饰器模式是指<u>动态地给一个对象增加一些额外的功能</u>，同时<strong>又不改变其结构</strong>。</p><h2 id="9-2-分布式问题【校招必问】">9.2 分布式问题【校招必问】</h2><blockquote><p>非常系统的总结文档：<a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/03%20%20%E9%9D%A2%E8%AF%95%E5%AE%98%E5%A6%82%E4%BD%95%E8%80%83%E5%AF%9F%E4%B8%8E%20CAP%20%E6%9C%89%E5%85%B3%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%EF%BC%9F.md">分布式相关：第一页</a></p></blockquote><p>CAP 理论指的是什么：C（Consistency）是数据一致性、A（Availability）是服务可用性、P（Partition tolerance）是分区容错性。</p><ul><li><p><strong>问题引入</strong></p><p>现在有一个分布式系统 A，它有一个副本 A1，在正常情况下，客户端 Client 写数据到系统 A，然后数据从 A 节点同步到 A1 节点，再返回给 Client 成功状态。</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/assets/CgqCHl_-eW2ALOs5AAFBvaYD4f8199.png" alt="6.png"></p><p>但由于网络是不可靠的，节点 A 和 A1 的网络随时会因为中断而出现分区。所谓网络分区就是由于网络不通导致节点 A 和 A1 被隔离在不同的网络子集中，此时节点 A 的数据就不能及时同步到节点 A1 中了。</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/assets/Ciqc1F_-eXaAcu6nAAE3Pk18sD8666.png" alt="7.png"></p></li></ul><h4 id="9-1-1-在CAP基础上讲讲BASE？举实例说说？">9.1.1 在CAP基础上讲讲BASE？举实例说说？</h4><p>BASE 理论，它是 CAP 理论的延伸。BASE 是 Basically Available（基本可用）、Soft State（软状态）和 Eventually Consistent（最终一致性）三个单词的简写，作用是保证系统的可用性，然后通过<strong>最终一致性来代替强一致性</strong>，它是目前分布式系统设计中最具指导意义的经验总结。</p><p>其实是做了“可用性”方面的妥协，比如：</p><ul><li>电商网站在双十一大促等访问压力较大的时候，关闭商品排行榜等次要功能的展示，从而保证商品交易主流程的可用性，这也是我们常说的<strong>服务降级；</strong></li><li>为了错开双十一高峰期，电商网站会将<strong>预售商品的支付时间</strong>延后十到二十分钟，这就是<strong>流量削峰</strong>；</li><li>在你抢购商品的时候，往往会在队列中等待处理，这也是常用的<strong>延迟队列</strong>。</li></ul><p>软状态和最终一致性指的是允许系统中的数据存在中间状态，这同样是<strong>为了系统可用性而牺牲一段时间窗内的数据一致性</strong>，从而保证最终的数据一致性的做法。</p><h4 id="9-1-2-亿级商品分布式存储问题？">9.1.2 亿级商品分布式存储问题？</h4><h5 id="1-如何设计一个支持海量商品存储的高扩展性架构？">1.如何设计一个支持海量商品存储的高扩展性架构？</h5><p><strong>从这一点出发会考察你Hash（哈希）分片的具体实现原理。</strong></p><ol><li>以商品 ID 作为关键字进行分片，系统会通过一个 Hash 函数计算商品 ID 的 Hash 值，然后取模，就能得到对应的分片；</li></ol><h5 id="2-在做分库分表时，基于-Hash-取模和一致性-Hash-的数据分片是如何实现的？">2.在做分库分表时，基于 Hash 取模和一致性 Hash 的数据分片是如何实现的？</h5><ol><li><strong>解决 Hash 分片的缺点，既保证数据均匀分布，又保证扩展性</strong> ，最终采用一致性 Hash ：它是指将存储节点和数据都映射到一个首尾相连的哈希环上。</li><li>具体见前，一致性哈希相关算法描述</li></ol><h5 id="3-在电商大促时期，如何对热点商品数据做存储策略-？">3.在电商大促时期，如何对热点商品数据做存储策略 ？</h5><ul><li><p><strong>问题</strong></p><p>一致性 Hash 提升了稳定性，使节点的加入和退出不会造成大规模的数据迁移，但<strong>本质上 Hash 分片是一种静态的分片方式</strong>，必须要提前设定分片的最大规模，<strong>而且无法避免单一热点问题，</strong> 某一数据被海量并发请求后，不论如何进行 Hash，数据也只能存在一个节点上，这势必会带来热点请求问题。</p></li><li><p><strong>解决</strong></p><p><strong>做 Range（范围）分片</strong>。 与 Hash 分片不同的是，Range 分片能结合业务逻辑规则，例如，我们用 “Category（商品类目）” 作为关键字进行<strong>动态分片时</strong>，不是以统一的商品一级类目为标准，而是可以按照一、二、三级类目进行灵活分片。例如，对于京东强势的 3C 品类，可以按照 3C 的三级品类设置分片；对于弱势品类，可以先按照一级品类进行分片，这样会让分片间的数据更加平衡。</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/assets/CgpVE1_-ed6AfUBMAAFtDc6PlH4881.png" alt="15.png"></p></li></ul><p><strong>4.强一致性和最终一致性的数据共识算法是如何实现的 ？</strong></p><h4 id="9-1-3-海量并发，分布式事务一致性问题？">9.1.3 海量并发，分布式事务一致性问题？</h4><ul><li><p><strong>什么是分布式事务问题？</strong></p><p>一次大的操作由多个小操作组成，这些<strong>小的操作分布在不同的服务器上</strong>，分布式事务需要<strong>保证这些小操作要么全部成功，要么全部失败</strong>。</p><p>举一个实例：</p><ul><li>京东旅行系统，拆分成多个子系统，如商品系统、促销系统、订单系统。用户下单时，<strong>订单系统生成订单，商品系统扣减库存，促销系统扣减优惠券</strong>，<strong>只有当三个系统的事务都提交之后，才认为此次下单成功</strong>，否则失败。</li></ul></li><li><p><strong>解决方案</strong></p><p>有两阶段提交协议（Two-Phase Commit，2PC）、3PC 、TCC 和基于消息队列的实现方式。</p><ul><li><p><strong>错误回答</strong>：方案很多，可以选择 2PC ，2PC 实现的流程是…</p></li><li><p><strong>错误原因：</strong> 因为在实际工作中，<strong>很少采用前几种方案（互联网中落地方案代价大）</strong>，基本都是基于 MQ 的可靠消息投递的方式来实现。</p></li><li><p>**正确回答：**先介绍目前主流实现分布式系统事务一致性的方案（也就是基于 MQ 的可靠消息投递的机制）然后回答出可实现方案和关键知识点。另外，<strong>为了和面试官进一步交流，你可以提出 2PC 或 TCC</strong> （这是一种交流方案）。</p></li><li><p><strong>回答一、基于 MQ 的可靠消息投递方案</strong></p><ul><li><p><strong>什么是MQ</strong></p><p>核心的五个概念：</p><ol><li><strong>Queue</strong>: 真正存储数据的地方</li><li><strong>Exchange</strong>: 接收请求，转存数据</li><li><strong>Bind:</strong> 收到请求后存储到哪里</li><li><strong>消息生产者</strong>:发送数据的应用</li><li><strong>消息消费者</strong>: 取出数据处理的应用</li></ol></li><li><p><strong>场景实例</strong></p><blockquote><p><strong>订单系统（1）完成订单后，（2）购物车系统减购物车中的商品。</strong></p></blockquote><p><img src="https://i.loli.net/2021/09/05/B2uKDL8cyfhplis.png" alt="img"></p><ol><li><p>订单系统在<strong>消息队列上</strong>开启一个事务（没有创建订单）；</p></li><li><p>订单系统给消息服务器发送一个“半消息”；</p><blockquote><p>这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，<strong>在事务提交之前，对于消费者来说，这个消息是不可见的。</strong></p></blockquote></li><li><p>半消息发送成功后，<strong>订单系统就可以执行本地事务了</strong>，在订单库中创建一条订单记录，并提交订单库的数据库事务。</p></li><li><p>然后<strong>根据本地事务的执行结果决定提交或者回滚事务消息</strong>。</p><blockquote><p>如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。</p></blockquote></li><li><p>购物系统消费这条拿到的订单系统消息（<strong>确认了订单系统事务执行完毕</strong>），这样就可以继续下一步购物操作</p></li></ol></li></ul></li></ul></li></ul><h4 id="9-1-4-分布式锁问题">9.1.4 分布式锁问题</h4><blockquote><p><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/06%20%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F.md">06 分布式系统中，如何回答锁的实现原理？</a></p></blockquote><p>分布式锁是解决协调分布式系统之间，同步访问共享资源的一种方式。详细来讲：在分布式环境下，<strong>多个系统在同时操作共享资源</strong>（如写数据）时，发起操作的系统通常会通过一种方式去协调其他系统，然后获取访问权限，得到访问权限后才可以写入数据，其他系统必须等待权限释放。</p><img src="https://i.loli.net/2021/09/05/f7Fh83wrnqvH6PK.png" alt="image-20210905232542573" style="zoom:80%;" /><ul><li><p><strong>基于redis的分布式锁</strong></p><p><strong>使用setnx命令加锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongGetLock1</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 第一步：加锁</span></span><br><span class="line">    Long result = jedis.setnx(lockKey, requestId);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 第二步：设置过期时间</span></span><br><span class="line">        jedis.expire(lockKey, expireTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>setnx命令，意思就是 set if not exist，<strong>如果lockKey不存在，把key存入Redis</strong>，保存成功后如果result返回1，表示设置成功，如果非1，表示失败，别的线程已经设置过了。</p></li><li><p>expire()，设置过期时间，防止死锁，假设，如果一个锁set后，一直不删掉，那这个锁相当于一直存在，产生死锁。</p></li></ul></li></ul><p><strong>解决setnx与expire不是一个原子操作</strong></p><ul><li><p>加锁总共分两步，第一步jedis.setnx，第二步jedis.expire设置过期时间，setnx与expire不是一个原子操作，如果程序执行完第一步后异常了，第二步jedis.expire(lockKey, expireTime)没有得到执行，<strong>相当于这个锁没有过期时间，有产生死锁的可能</strong>。</p></li><li><p>解决方案为：一步操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockDemo</span> </span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">&quot;NX&quot;</span>;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">&quot;PX&quot;</span>;   </span><br><span class="line">        <span class="comment">/**     </span></span><br><span class="line"><span class="comment">        * 获取分布式锁    </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> jedis Redis客户端     </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> lockKey 锁    </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> requestId 请求标识     </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> expireTime 超期时间     </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> 是否获取功     */</span>   </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span></span></span><br><span class="line"><span class="function">   </span>&#123;    </span><br><span class="line">           <span class="comment">// 两步合二为一，一行代码加锁并设置 + 过期时间。       </span></span><br><span class="line">     <span class="keyword">if</span> (<span class="number">1</span> == jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime))</span><br><span class="line">      &#123;           </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//加锁成功        </span></span><br><span class="line">      &#125;       </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//加锁失败   </span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 解锁：对应del删除key即可</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;           </span><br><span class="line">      <span class="comment">// 第一步： 使用 requestId 判断加锁与解锁是不是同一个客户端    </span></span><br><span class="line">      <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) </span><br><span class="line">      &#123;       </span><br><span class="line">          <span class="comment">// 第二步： 若在此时，这把锁突然不是这个客户端的，则会误解锁     </span></span><br><span class="line">          jedis.del(lockKey);    </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​</p><ul><li><p><strong>基于Zoopkeeper的分布式锁</strong></p><blockquote><p>sync，lock也只能保证你当前机器线程安全，这样分布式访问还是有问题。</p><p>建议参考：<a href="https://www.cnblogs.com/aobing/p/12650036.html">https://www.cnblogs.com/aobing/p/12650036.html</a></p></blockquote><p>一个机器接收到了请求之后，先获取 zookeeper 上的一把分布式锁（zk会创建一个 znode），执行操作；然后另外一个机器也<strong>尝试去创建</strong>那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等待，等第一个机器执行完了方可拿到锁。</p><p>下面是创建临时顺序节点的情况：</p><ol><li><p>客户端调用create()方法创建名为“/dlm-locks/lockname/lock-”的临时顺序节点。</p></li><li><p>客户端调用getChildren(“lockname”)方法来获取所有已经创建的子节点。</p></li><li><p>客户端获取到所有子节点path之后，如果发现<strong>自己在步骤1中创建的节点是所有节点中序号最小</strong>的，就是看自己创建的序列号是否排第一，如果是第一，那么<strong>就认为这个客户端获得了锁</strong>，在它前面没有别的客户端拿到锁。</p></li><li><p>如果创建的节点不是所有节点中需要最小的，那么则<strong>监视比自己创建节点的序列号小的最大的节点，进入等待</strong>。直到下次监视的<strong>子节点变更的时候</strong>，再进行子节点的获取，判断是否获取锁。</p></li></ol></li><li><p><strong>基于关系型数据库 MySQL 实现分布式锁</strong></p><blockquote><p>参考：<a href="https://juejin.cn/post/6844904137172189198">https://juejin.cn/post/6844904137172189198</a></p></blockquote><p>利用 Mysql 的锁表，创建一张表，设置一个 UNIQUE KEY（如，<strong>利用主键ID的唯一性</strong>） 这个 KEY 就是要锁的 KEY，所以同一个 KEY 在mysql表里只能插入一次了。</p><blockquote><p>这样对锁的竞争就交给了数据库，处理同一个 KEY 数据库保证了只有一个节点能插入成功，其他节点都会插入失败。</p></blockquote><p>定义加锁、解锁代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lock</span> ：  </span></span><br><span class="line"><span class="function">    <span class="title">exec</span> <span class="title">sql</span>:</span> insert into lockedtable (xxx) values (xxx)    </span><br><span class="line">    <span class="keyword">if</span> result == true :       </span><br><span class="line">         <span class="keyword">return</span> true    </span><br><span class="line">    <span class="keyword">else</span> :        </span><br><span class="line">         <span class="keyword">return</span> falsedef </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">unlock</span> ：   # 解锁就是删除</span></span><br><span class="line"><span class="function"> <span class="title">exec</span> <span class="title">sql</span>:</span> delete <span class="keyword">from</span> lockedOrder where order_id=<span class="string">&#x27;order_id&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="9-3-其它问题">9.3 其它问题</h2><h4 id="1-【字节-懂车帝】什么是跨域？">1. 【字节-懂车帝】什么是跨域？</h4><blockquote><p>参考：<a href="https://www.jianshu.com/p/f049ac7e2220">https://www.jianshu.com/p/f049ac7e2220</a></p></blockquote><p>跨域，是指浏览器不能执行其他网站的脚本。它是由<strong>浏览器的同源策略</strong>造成的，是浏览器对JavaScript实施的安全限制。</p><p>同源策略限制了一下行为：</p><ol><li><p>Cookie、LocalStorage 和 IndexDB 无法读取</p></li><li><p>DOM 和 JS 对象无法获取</p></li><li><p>Ajax请求发送不出去</p></li></ol><p>具体的一些实例：</p><ol><li><p><strong>非跨域</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.yyy.cn/index.html 调用 http://www.xxxyyy.cn/server.php 非跨域</span><br></pre></td></tr></table></figure></li><li><p><strong>跨域：主域不同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxxyyy.cn/index.html 调用  http://www.xxx.cn/server.php</span><br></pre></td></tr></table></figure></li><li><p><strong>跨域：子域名不同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://abc.xxxyyy.cn/index.html 调用  http://def.xxx.cn/server.php</span><br></pre></td></tr></table></figure></li><li><p><strong>跨域：端口不同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.cn:**8080**/index.html 调用  http://www.xxx.cn/server.php</span><br></pre></td></tr></table></figure></li><li><p><strong>跨域：协议不同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**https**://www.xxx.cn/index.html 调用  **http**://www.xxx.cn/server.php</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（一）_JAVA</title>
      <link href="/2021/11/25/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89_JAVA/"/>
      <url>/2021/11/25/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89_JAVA/</url>
      
        <content type="html"><![CDATA[<h1><strong>一、JAVA</strong></h1><h2 id="1-1-JAVA入门">1.1  JAVA入门</h2><h3 id="1-1-1-JAVA基本">1.1.1 JAVA基本</h3><h4 id="1-介绍一下JVM-JRE-JDK？-JAVA语言有什么特点？">1. <strong>介绍一下JVM&amp;JRE&amp;JDK？</strong> JAVA语言有什么特点？</h4><ul><li><strong>JVM&amp;JRE&amp;JDK</strong><ul><li><strong>JVM:</strong>  即java虚拟机，针对不同操作系统，JVM把Java代码翻译成<u>对应操作系统可以识别的内容，实现跨平台</u> ；</li><li><strong>JRE</strong> : <u>JVM + 核心类库 = JRE</u> ， 即Java运行时环境。只有JVM不能运行，它还<strong>需要核心类库，才能保证Java运行</strong> ；</li><li><strong>JDK:</strong> <u>JRE + <strong>java开发工具</strong>（编译器等) = JDK</u> ，Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具。</li></ul></li><li><strong>Java语言特点</strong><ol><li><p>简单易学；</p></li><li><p>面向对象（封装，继承，多态）；</p></li><li><p><strong>平台无关性</strong>（ Java 虚拟机实现平台无关性）；</p></li><li><p>可靠性；</p></li><li><p>安全性；</p></li><li><p><strong>支持多线程</strong>（ <u>C++ 语⾔没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计</u>，而 Java 语⾔却提供了多线程支持）；</p></li></ol></li></ul><h4 id="2-什么是Java虚拟机？为什么Java被称为平台无关的编程语言？">2. <strong>什么是Java虚拟机？为什么Java被称为平台无关的编程语言？</strong></h4><p><img src="https://i.loli.net/2021/05/12/b4HUYmVo6P5uFCi.png" alt="image-20210512104311616"></p><ul><li><p>java虚拟机，是**执行字节码文件（.class）**的<u>虚拟机进程</u>；</p><blockquote><p>在 Java 中，<strong>JVM 可以理解的代码就叫做 字节码</strong> （即扩展名为 .class 的⽂件），它不面向任 何特定的处理器，<strong>只面向虚拟机</strong>。</p></blockquote></li><li><p>java源程序（.java）被编译器编译成字节码文件（.class）。然后字节码文件，将由<u>java虚拟机，解释成机器码（<strong>不同平台的机器码不同</strong>）</u>。</p></li></ul><h4 id="3-请你谈谈Java中是如何支持正则表达式操作的？（补充实例）">3. 请你谈谈Java中是如何支持正则表达式操作的？（补充实例）</h4><p>Java中的String类提供了支持正则表达式操作的方法，包括：</p><ul><li><code>matches()、replaceAll()、replaceFirst()、split()</code></li></ul><p>此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegExpTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;成都市(成华区)(武侯区)(高新区)&quot;</span>;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;.*?(?=\\()&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(str);</span><br><span class="line">        <span class="keyword">if</span>(m.find()) &#123;</span><br><span class="line">            System.out.println(m.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实例示范（PCG问过）">实例示范（PCG问过）</h5><blockquote><p>参考：<a href="https://www.runoob.com/regexp/regexp-syntax.html">https://www.runoob.com/regexp/regexp-syntax.html</a></p></blockquote><ul><li><p><strong>特殊字符</strong></p><img src="https://i.loli.net/2021/05/12/9IBVheAOz5aGnxC.png" alt="image-20210512110705420" style="zoom:80%;" /></li><li><p><strong>普通字符</strong></p><p><img src="https://i.loli.net/2021/05/12/QcjTKqEJZwx7LdM.png" alt="image-20210512111050519"></p></li><li><p><strong>实例示范</strong></p><ol><li><p>匹配邮箱</p><p><img src="https://i.loli.net/2021/05/12/Lvo56GHie2Qqla1.png" alt="img"></p></li><li><p>匹配电话号码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配电话号码</span></span><br><span class="line">String phone = <span class="string">&quot;18637866964&quot;</span>;</span><br><span class="line">String reg = <span class="string">&quot;^1[3,5,7,8,9]\\d&#123;9&#125;$&quot;</span>;</span><br><span class="line">System.out.println(phone.matches(reg));</span><br></pre></td></tr></table></figure></li><li><p>匹配第一个出现的数字</p><p>下面好像是不对的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String phone = <span class="string">&quot;avss1sdp22&quot;</span>;</span><br><span class="line">String reg = <span class="string">&quot;\d?&quot;</span>;</span><br><span class="line">System.out.println(phone.matches(reg));</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="4-（补充例子）请你简单描述一下正则表达式及其用途。">4. <strong>（补充例子）请你简单描述一下正则表达式及其用途。</strong></h4><p>在编写处理字符串的程序时，经常会有查找 <u>符合某些复杂规则的字符串</u> 的需要。</p><ul><li>计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具；</li><li>绝大多数语言都提供了对正则表达式的支持。</li></ul><h4 id="5-和-区分？">5. <strong>&amp;和&amp;&amp;区分？</strong></h4><ul><li>**共同点：**都要求运算符左右两端的布尔值 <u>都是true</u> 整个表达式的值才是true</li><li>区别：&amp;&amp;之称为短路运算，<u>如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算</u>。 好处：<ul><li><em>e.g.</em> ：右边判别式有如果有空指针<code>NullPointerException</code>异常判断风险，可以避免。</li></ul></li></ul><h4 id="6-值传递和引用传递区分？">6. <strong>值传递和引用传递区分？</strong></h4><ul><li><p>值传递是<strong>该变量</strong>的一个<u>副本</u>， 改变副本<u>不影响</u>原变量；</p></li><li><p>引用传递是<strong>对象地址</strong>的<u>副本</u>，引用对象进行操作会同时<u>改变</u>原对象。</p></li></ul><h4 id="7-十进制与二进制？">7. <strong>十进制与二进制？</strong></h4><ul><li><p><strong>请你讲讲一个十进制的数在内存中是怎么存的？</strong></p><p>补码形式。</p></li><li><p><strong>为什么会出现4.0-3.6=0.40000001这种现象？</strong></p><p>2进制的小数无法精确的表达10进制小数，计算机在 <u>计算10进制小数的过程中要先转换为2进制进行计算</u> ，这个过程中出现了误差。</p></li></ul><h4 id="8-（重要）equals与-的区别">8. <strong>（重要）equals与==的区别</strong></h4><blockquote><p>很清晰严谨的一篇文章：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p></blockquote><ul><li><p><strong>==</strong></p><ol><li>基本类型：比较的是值是否相同；</li><li>引用类型：比较的是**引用（对象地址）**是否相同；</li></ol></li><li><p><strong>equals</strong></p><p>要看<strong>类是否覆盖equals()方法</strong>，将它分为两种情况：</p><ol><li><p>若某个类没有覆盖equals()方法，当它的通过<strong>equals()比较两个对象</strong>时，实际上是比较两个对象（地址）是不是同一个对象。这时，<u>等价于通过“==”去比较这两个对象</u>；</p></li><li><p>我们可以覆盖类的equals()方法，来让equals()通过其它方式比较两个对象的内容（<strong>而不是地址</strong>）是否相等。</p><blockquote><p>String 中的 equals 方法是被重写过的：</p><ul><li>因为 object 的 equals 方法是⽐教的对象的内存地址</li><li>而 <strong>String 的 equals 方法（1）先比较对象地址是否相等 ，相同则ture，否则（2）再比较值是否相等</strong></li></ul></blockquote></li></ol></li></ul><h4 id="7-请解释hashCode-和equals-方法有什么联系？">7. <strong>请解释hashCode()和equals()方法有什么联系？</strong></h4><blockquote><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode方法？”</p><ul><li>建议看文中例子理解：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html">https://www.cnblogs.com/skywang12345/p/3324958.html</a></li></ul></blockquote><ul><li><p><strong>hashCode()介绍</strong></p><p>hashCode() 的作用是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个int整数。这个<strong>哈希码的作用</strong>是确定该 <u>对象在哈希表中的索引位置</u>。</p><blockquote><p>我们仅在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。  其它情况下hashCode() 则根本没有任何作用，所以，不用理会hashCode()。</p><ul><li>在这种情况下对象相等，hashcode值也会不相等。</li></ul></blockquote></li><li><p><strong>为什么要有hashcode()</strong></p><p>hashCode() 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回⼀个 int整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。 <strong>hashCode()</strong> <strong><u>在散列表中</u>才有用，在其它情况下没用</strong>。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><p><strong>先判断hashcode，而不是直接遍历O(n)复杂度用equals()判断，减少判断时间。</strong></p><blockquote><p><strong>如果hashcode一样，会调用equals()去比较。</strong></p><ul><li><strong>HashSet</strong> 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加⼊操作成功。如果不同的话，就会重新散列到其他位置。</li></ul></blockquote></li></ul><h5 id="7-1-为什么重写了equals-一定要重写hashcode-方法？">7.1 为什么重写了equals()一定要重写hashcode()方法？</h5><blockquote><p>参考：<a href="https://blog.csdn.net/xyh269/article/details/69171545">为什么重写了equals()，还要重写hashCode()？</a></p></blockquote><p>在Hashmap / Hashset中，通过计算hash = hash(key.hashcode) 然后进行取余操作，快速定位到数组中。</p><p>因为<strong>map中是不允许重复key</strong>的，所以对内部get()/add()方法：对于散列到数组同一位置的对象来说，<strong>如果hash相等 &amp;&amp; equals()判断相等</strong> ，是要进行<strong>覆盖</strong>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用 equals 方法判断key是否相等，若相等，该key对应的键值对已经存在，用新的value取代旧的value</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;    </span><br></pre></td></tr></table></figure><p>如果我们只重写了equals方法：用来判断两个对象是否相等。但是依旧可能出现：两个相同对象<strong>equals相等，但hashcode不等，被散列到不同桶上，map中依旧出现了重复键值对！</strong></p><p><img src="https://i.loli.net/2021/05/26/v5aHJGt8qErx6P9.png" alt="hashcode"></p><p>所以，需要重写hashcode方法，保证<strong>相同对象一定是散列到同一个位置（具有同样的hash值）</strong>。</p><h5 id="7-2-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，该说法是否正确，为什么？">7.2 <strong>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么？</strong></h5><p>不一定正确，<u>如果在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中</u>，两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。</p><p>其它情况下可能会出现题目描述的情况。</p><h4 id="8-自动拆箱和装箱？">8. 自动拆箱和装箱？</h4><ul><li><p><strong>介绍一下int&amp;Integer？</strong></p><p>Java为了编程的方便还是引入了基本数据类型，但是 <u>为了能够将这些基本数据类型当成对象操作</u>，Java为每一个基本数据类型都引入了对应的<strong>包装类型</strong>（wrapper class）</p><ul><li><p>int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e.g. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">        Integer b = <span class="number">3</span>;          <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">        System.out.println(a == b);  </span><br><span class="line">        <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">        System.out.println(a == c);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>Java 为<u>每个原始类型</u>提供了包装类型：</p><ul><li>（<strong>8种基本类型</strong>）原始类型: boolean，char，byte，short，int，long，float，double</li><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li></ul></li></ul></li><li><p><strong>拆箱、装箱存在的意义？</strong></p><blockquote><p>为什么要有装箱、拆箱，它们的作用是什么？</p></blockquote><p><em>java</em> 是 面对对象编程，而基本数据类型不是对象，<strong>所有才有封装类 引用基本数据类型进行操作</strong>。比如，下面打印出<em>int</em>型数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>； </span><br><span class="line">System.out.println(i); <span class="comment">// 自动装箱</span></span><br></pre></td></tr></table></figure><p>其实，查看源码，实际经过以下几个过程：</p><ul><li>将 <em>i</em> 自动装箱成封装类 <em>Integer</em></li><li>然后调用 <em>Integer</em>中 <em>toString</em>() 方法，打印出字符串输出到控制台。</li></ul><blockquote><p>自动装箱和拆箱？</p></blockquote><ul><li>自动装箱：就是自动将基本数据类型转换为包装器类型</li><li>自动拆箱：就是自动将包装器类型转换为基本数据类型</li></ul></li></ul><h4 id="9-String-StringBuffer-StringBuilder-区别？为什么String不可变">9.  String &amp; StringBuffer&amp; StringBuilder 区别？为什么String不可变?</h4><ul><li><p><strong>请解释String &amp; StringBuffer区别？</strong></p><ul><li><p><strong>共同点</strong>：它们可以<strong>储存和操作</strong>字符串，即包含多个字符的字符数据；</p></li><li><p><strong>可否修改</strong>：String类提供了数值不可改变的字符，StringBuffer可以修改字符串，需要 <u>字符数据要改变</u> 时用。</p></li></ul><p>典型地，你可以使用StringBuffers来动态构造字符数据。</p></li><li><p><strong>请解释 StringBuilder&amp; StringBuffer 区别？</strong></p><ul><li><p><strong>共同点：</strong> <code>AbstractStringBuilder</code> 是 StringBuilder 与 StringBuffer 的公共⽗类。都可以修<u>改字符串，操作字符串方法丰富</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value is used for character storage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">char</span>[] value;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The count is the number of characters used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> count;</span><br><span class="line"> AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line"> value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><u><strong>线程安全</strong>：</u>单线程且操作大量字符串用StringBuilder,速度快，但线程不安全，可修改；在多线程且操作大量字符串用<strong>StringBuffer，线程安全，可修改。</strong></p><blockquote><p>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p></blockquote></li></ul></li><li><p><strong>为什么String 不可变？</strong></p><p>String 类中使用 final 关键字修饰字符数组来保存字符串， 所以 String 对象是不可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[]</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-说说深拷贝和浅拷贝？">10. <strong>说说深拷贝和浅拷贝？</strong></h4><ul><li><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址；</p><blockquote><p>因此，可能会出现出现浅拷贝时释放同一个内存的错误。</p></blockquote></li><li><p>深拷贝（deepCopy）是增加了一个指针<strong>并且申请了一个新的内存</strong>，使这个增加的指针指向这个新的内存。</p></li></ul><h4 id="11-【新增】介绍一下JDK1-8的新特性？">11. 【新增】介绍一下JDK1.8的新特性？</h4><p>JDK1.8新增了非常多的特性，如：</p><ul><li><strong>Lambda表达式</strong>：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li><li><strong>方法引用</strong>：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li><li><strong>默认方法</strong>：默认方法就是一个<strong>在接口里面有了一个实现的方法</strong>。</li><li><strong>新工具</strong>：新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li><li><strong>Stream API</strong>：新添加的Stream API（java.util.stream） 把真正的<strong>函数式编程风格</strong>引入到Java中。</li><li><strong>Date Time API</strong>：加强对日期与时间的处理。</li><li><strong>Optional类</strong>：Optional 类已经成为 Java 8 类库的一部分，用来解决<strong>空指针异常</strong>。</li><li><strong>Nashorn，JavaScript引擎</strong>：JDK1.8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li></ul><h4 id="12-【新增】java一个程序能不能有多个main方法？一个类里呢？">12. 【新增】java一个程序能不能有多个main方法？一个类里呢？</h4><ul><li><p><strong>一个程序里，多个class都有main方法</strong></p><p>可以，默认第一个为入口，其余为普通函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>一个类有多个main方法</strong></p><p>可以，其余就相当是重载。但是具有以下sigature（签名）的主要方法将被视为app入口点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-1-2-关键字">1.1.2 关键字</h3><h4 id="1-请你讲讲Java里面的final关键字是怎么用的？">1. <strong>请你讲讲Java里面的final关键字是怎么用的？</strong></h4><ul><li><p><strong>修饰类</strong>：表示不能被继承，final类 <u>成员变量</u> 可以设为final；但final类<u>所有方法</u> ，都被隐式指定为final方法；</p></li><li><p><strong>修饰方法</strong>：防任何继承类修改它的含义 ； 在早期的Java实现版本中，会将final方法转为内嵌调用，效率会更高；</p></li><li><p><strong>修饰变量、引用</strong>：<u>基本类型</u>的话一旦初始化不能修改；<u>引用类型</u>，不能指定其他对象 。</p></li></ul><h4 id="2-【重点】请你谈谈关于Synchronized和lock-？">2. 【<strong>重点</strong>】<strong>请你谈谈关于Synchronized和lock ？</strong></h4><ul><li><p><strong>Synchronized</strong>：是一个关键字，修饰<u>类、方法 </u> 或 <u>代码块</u> ，保证在同一时刻最<strong>多只有一个线程</strong>执行该段代码；</p><blockquote><p>作用范围：</p><ol><li>修饰一个类/静态方法， <strong>作用的对象是这个类的所有对象</strong>。</li><li>修饰一个方法/代码块， <strong>作用的对象是调用这个方法/代码块的对象</strong>。</li></ol></blockquote></li><li><p>Lock： <strong>是一个接口</strong>，Lock能完成synchronized所实现的所有功能。</p><blockquote><p>Lock接口是不能直接实例化的，需要靠它的实现类ReentrantLock来进行实例化。</p></blockquote><ul><li><p>区别：</p><ul><li><u>锁释放：</u><strong>synchronized在发生异常时，会自动释放线程占有的锁</strong>，因此不会导致死锁现象发生；Lock不会主动适应 <code>unLock()</code> 释放，必须手动在f<code>inally</code>释放。；</li><li><u>线程等待：</u> <u>Lock可以让<strong>等待锁的线程可以响应中断</strong></u>，线程可以中断去干别的事务；而synchronized却不行，使用synchronized时，等待的线程会一直等待下去；</li><li><u>成功获取锁：</u> 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li></ul></li></ul></li></ul><h4 id="3-instanceof-关键字的作用-？">3. <strong>instanceof</strong> <strong>关键字的作用</strong> ？</h4><p>instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Integer);<span class="comment">//编译不通过 i必须是引用类型，不能是基本类型</span></span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Object);<span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(integer <span class="keyword">instanceof</span> Integer);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="4-final有哪些用法">4. <strong>final有哪些用法?</strong></h4><ul><li><p>被final修饰的类不可以被继承 ；</p></li><li><p>被final修饰的方法<strong>不可以被重写</strong>，<u>而且JVM会尝试将其内联，以提高运行效率</u>；</p></li><li><p>被final修饰的<u>变量</u>不可以被改变；</p><ul><li><p>被final修饰的<u>引用</u>，那么表示引用不可变，<u>引用指向的内容可变</u>；</p></li><li><p>被final修饰的<u>常量</u>，在编译阶段会存入常量池中。</p></li></ul></li></ul><h4 id="5-static都有哪些用法">5. <strong>static都有哪些用法 ?</strong></h4><ul><li><p><strong>修饰静态变量和静态方法</strong> ：都属于类的静态资源，类实例所共享 ；</p></li><li><p><strong>修饰静态块</strong>：用于初始化操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss PreCache&#123;</span><br><span class="line"> <span class="keyword">static</span>&#123;</span><br><span class="line"> <span class="comment">//执行相关操作</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>修饰静态包：</strong> 在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且<strong>不需要使用类名,<strong>可以直接</strong>使用方法名</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(Math.sin(20));传统做法</span></span><br><span class="line">        System.out.println(sin(<span class="number">20</span>));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-谈一谈transient关键字？">6. 谈一谈transient关键字？</h4><blockquote><p><strong>参考</strong> : <a href="https://www.cnblogs.com/chenpi/p/6185773.html">Java中的关键字 transient</a></p></blockquote><ul><li><p><strong>Java中序列化操作</strong></p><p>Java中对象的序列化指的是将<strong>对象转换成以【字节序列】的形式来表示</strong>，这些字节序列<strong>包含了对象的数据和信息</strong>。</p><blockquote><p>当然，序列化后的最终目的是为了反序列化，恢复成原先的Java对象，要不然序列化后干嘛呢，所以序列化后的字节序列都是可以恢复成Java对象的，这个过程就是反序列化。</p></blockquote><ul><li><u>一个序列化后的对象可以<strong>被写到数据库或文件</strong>中</u>，也可用于<strong>网络传输</strong>，一般当我们使用缓存cache（内存空间不够有可能会本地存储到硬盘）或远程调用rpc（网络传输）的时候，经常需要让我们的实体类实现Serializable接口，目的就是为了让其可序列化。</li></ul></li><li><p><strong>关于transient关键字</strong></p><p>Java中transient关键字的作用，向虚拟机表明: <strong><code>transient</code>变量不是对象的<u>持久状态</u>的一部分。</strong></p><p>简单地说，就是让某些被修饰的成员属性变量不被序列化，例如：</p><ol><li><p>类中的字段值可以根据其它字段推导出来，如一个长方形类有三个属性：长度、宽度、面积（示例而已，一般不会这样设计），那么在序列化的时候，面积这个属性就没必要被序列化了；</p></li><li><p>其它，看具体业务需求吧，哪些字段不想被序列化；</p></li></ol></li></ul><h5 id="7-1-HashMap中源码modCount为什么用tranisent修饰？">7.1 HashMap中源码modCount为什么用tranisent修饰？</h5><p>modCount主要用于判断HashMap是否被修改（像put、remove操作的时候，modCount都会自增）。</p><p>对于这种变量，一开始可以为任何值，0当然也是可以（new出来、反序列化出来、或者克隆clone出来的时候都是为0的），没必要持久化其值。</p><h3 id="1-1-3-Java异常">1.1.3 Java异常</h3><h4 id="1-Java常见异常和分类？">1. Java常见异常和分类？</h4><p><img src="https://i.loli.net/2021/05/26/1ctoGfDdrj6Wapv.png" alt="Java异常的分类和类结构图1"></p><p>常见分为两类，Error和Exception ：</p><ul><li><strong>Error</strong> ：指程序无法恢复的异常情况，对于其所有类型，都不要求程序处理。<ul><li>常见错误：Stackoverflow，outOfMemory</li></ul></li><li><strong>Exception：</strong> 程序有可能恢复的错误，又分为IOException &amp; RuntimeException ，常见错误：<ul><li><strong>IOException</strong>：FileNotFoundExcepetion</li><li><strong>RuntimeException</strong>  : 空指针，参数不合法，类未找到等</li></ul></li></ul><h4 id="2-OOM产生原因和分析？">2. OOM产生原因和分析？</h4><blockquote><p>OOM，全称“Out Of Memory”，翻译成中文就是“内存用完了”，来源于java.lang.OutOfMemoryError 。</p></blockquote><ol><li><p><strong>java.lang.OutOfMemoryError: Java heap space</strong> （堆溢出）</p><ul><li><p><strong>产生原因</strong></p><ol><li><strong>内存泄漏</strong>；</li><li>堆分配太小；</li></ol></li><li><p><strong>解决办法</strong></p><ol><li><strong>内存泄漏要手动去释放内存</strong>，比如数据库连接池，单例模式</li><li>通过虚拟机参数**-Xms,-Xmx**等修改，对内存大小</li></ol></li></ul></li><li><p><strong>java.lang.OutOfMemoryError: PermGen space</strong> （永久代（方法区）溢出）</p><ul><li><p><strong>产生原因</strong></p><p>即方法区溢出了：</p><ol><li>一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生<strong>大量的Class信息存储于方法区</strong> ；</li><li><strong>过多的常量</strong>尤其是字符串也会导致方法区溢出。</li></ol></li><li><p><strong>解决办法</strong></p><ol><li>永久代的内存分配增大 ：-XX:PermSize和-XX:MaxPermSize</li></ol></li></ul></li><li><p><strong>java.lang.StackOverflowError ------&gt; 不会抛OOM error，但也是比较常见的Java内存溢出。</strong></p><p>线程栈相关的内存异常有两个：</p><ul><li>StackOverflowError(方法调用层次太深，内存不够新建栈帧)</li><li>OutOfMemoryError（线程太多，内存不够新建线程）</li></ul></li><li><p><strong>java.lang.OutOfMemoryError: Metaspace</strong></p><blockquote><p>Java中<strong>普通I/O</strong>采用<strong>输入/输出流</strong>方式实现，输入流InputStream（  终端—&gt;直接内存-&gt;JVM），输出流（JVM-&gt;直接内存-&gt;终端），这一过程中有kenel与JVM之间的拷贝（很多次）。</p></blockquote><p>为了使用<strong>直接内存</strong>，Java是有一块区域叫<strong>DirectBuffer</strong>，不是JavaHeap而是<strong>cHeap</strong>的一部分。</p><p>但由于直接内存没有被java虚机完全托管，若使用不当，也容易触发溢出，导致宕机。</p></li></ol><h4 id="3-try-catch-finally，try里有return，finally还执行么？"><strong>3. try catch finally，try里有return，finally还执行么？</strong></h4><p>执行，并且finally的执行早于try里面的return ：</p><ol><li>不管有木有出现异常，finally块中代码都会执行；</li><li>当try和catch中有return时，finally仍然会执行；</li><li>finally是<strong>在return后面的表达式运算后执行</strong>的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以<strong>函数返回值是在finally执行前确定</strong>的。</li></ol><h4 id="4-说说你是怎么处理异常的？">4. <strong>说说你是怎么处理异常的？</strong></h4><p><em><strong>try-catch-finally</strong></em></p><p><img src="https://i.loli.net/2021/05/05/JfavipzFPb6GI2t.png" alt="image-20210505154833171"></p><ul><li><p>try 块负责监控可能出现异常的代码</p></li><li><p>catch 块负责捕获可能出现的异常，并进行处理</p></li><li><p>finally 块负责清理各种资源，不管是否出现异常都会执行</p></li><li><p>其中 try 块是必须的，<strong>catch 和 finally 至少存在一个标准异常处理流程</strong></p></li></ul><h2 id="1-2-面对对象">1.2 面对对象</h2><h3 id="1-2-1-基本问题">1.2.1 基本问题</h3><h4 id="1-介绍一下面对对象七大原则？三大特性？">1. <strong>介绍一下面对对象七大原则？三大特性？</strong></h4><h5 id="七大原则">七大原则</h5><ul><li><p><strong>单一职责原则：</strong> 就一个类来说，应该仅有一个引起它变化的原因。也就是说，<strong>一个类应该只有一个职责</strong>。</p><blockquote><p>如果有多个职责，那么就相当于把这些指责耦合在起，一个职责的变化就可能削弱或抑制了这个类完成其他职责的能力，引起类的变化的原因就会有多个。所以在构造一个类时， 将类的不同职责分离至两个或多个类中(或者接口中)，确保引起该类变化的原因只有一个。</p></blockquote></li><li><p><strong>开闭原则(OCP)：</strong> 软件组成实体应该是可扩展的，但是不可修改。开放-封闭原则认为应该试图设计永远也不需要改变的模块。可以添加新代码来打展系统的行为，不能对已有的代码进行修改。</p><blockquote><p>这个原则很好的实现了面向对象的封装性和可重用性。</p></blockquote></li><li><p><strong>李氏替换原则(LSP)：</strong> 子类应当可以替换父类并出现在父类能够出现的任何地方。</p><blockquote><p>以圆和椭圆为例，圆是椭圆的一一个特殊子类。因此任何出现椭圆的地方，圆均可以出现。</p></blockquote></li><li><p><strong>依赖倒置原则(DIP)：</strong> 在进行业务设计时，与<u>特定业务有关的依赖</u>关系应该尽量依赖<strong>接口和抽象类</strong>，<strong>而不是依赖于具体类</strong>。具体类只负责相关业务的实现，修改具体类不影响与特定业务有关的依赖关系。</p><blockquote><p>为此，在进行业务设计时，应尽量在接口或抽象类中定义业务方法的原型，并通过具体的实现类(子类)来实现该业务方法，业务方法内容的修改将不会影响到运行时业务方法的调用。</p></blockquote></li><li><p><strong>接口分离原则(ISP)：</strong>  <u>采用多个与特定客户类有关的接口</u> 比采用一个通用的涵盖多个业务方法的接口要好。</p><blockquote><p>举例：如果拥有一个针对多个客户的类，为每一个客户创建特定业务接口，然后使该客户类继承多个特定业务接口将<u>比直接加载客户所需所有方法有效</u>。</p></blockquote></li><li><p><strong>组合重用原则</strong> ：能用组合实现的地方，<strong>尽量用组合来</strong>实现，而<strong>不要使用继承</strong>来扩展功能。</p></li></ul><blockquote><p>097因为组合能更好地实现封装，比继承具有更大的灵活性和更稳定的结构。</p></blockquote><ul><li><strong>迪米特原则 :</strong> <u>一个对象应该对于其他对象有最少的了解</u>，这样做的好处就是可以有效地降低类之间的耦合要求。</li></ul><h5 id="三大特性">三大特性</h5><ul><li><p><strong>封装。</strong><u>封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的方法</u>，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果⼀个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p></li><li><p><strong>继承。</strong> <u>继承是使用已存在的类的定义作为基础建⽴新类的技术，新类的定义可以增加新的数据或新的功能</u>，也可以用⽗类的功能，但不能选择性地继承⽗类。通过使用继承我们能够非常方便地<strong>复用</strong>以前的代码。</p><blockquote><ol><li>子类拥有⽗类对象所有的属性和方法（包括私有属性和私有方法），但是⽗类中的私有属性和方法子类是无法访问，只是拥有。</li><li>子类可以拥有⾃⼰属性和方法，即子类可以对⽗类进行扩展。</li><li>子类可以用⾃⼰的方式实现⽗类的方法。</li></ol></blockquote></li><li><p><strong>多态。</strong>（1）<strong>静态多态：重载</strong> （2）<strong>动态多态</strong>：所谓多态就是指程序中定义的**<u>引用变量所指向的具体类型</u><strong>和<u>通过该</strong>引用变量发出的方法调用**</u>在<strong>编程时并不确定</strong>，而是在**【程序运行期间】才确定**。即⼀个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><blockquote><p>在 Java 中有<strong>两种形式可以实现多态</strong>：<strong>继承</strong>（多个子类对同⼀方法的重写）和<strong>接口</strong>（实现接口并覆盖接口中同⼀方法）。</p></blockquote></li></ul><h5 id="1-1-java多态的原理？【阿里-待重写】">1.1 java多态的原理？【阿里&amp;待重写】</h5><p>多态分两种：（1）【编译】时多态（静态多态）（2）运行时多态（动态多态）。</p><ol><li><p><strong>静态多态</strong></p><p><strong>重载</strong>（overload）就是编译时多态的一个例子，<strong>编译时</strong>多态在编译时就已经<strong>确定</strong>。</p><p>运行时运行的时候调用的是确定的方法。</p></li><li><p><strong>动态多态</strong></p><blockquote><p>我们通常所说的多态指的都是运行时多态，也就是<strong>编译时不确定究竟调用哪个具体方法</strong>，一直延迟到运行时（<strong>链接过程</strong>）才能确定。</p></blockquote><p>通常动态多态的实现方法：</p><ol><li>子类继承父类（extends）</li><li>类实现接口（implements）</li></ol><p>核心之处就在于<strong>对父类方法的改写或对接口方法的实现</strong>，以取得在运行时不同的执行效果。</p></li><li><p><strong>多态运行的原理</strong></p><blockquote><p>详细建议查看：<a href="https://zhuanlan.zhihu.com/p/94086109">深入理解Java多态的实现原理</a></p></blockquote><ul><li><p><strong>背景介绍</strong></p><p><img src="https://i.loli.net/2021/04/21/m1Ot3nQcMGq2YfW.jpg" alt="img"></p><p><u>类加载</u> 时会将<strong>类的元数据信息</strong>（<strong>类的方法代码、类变量、成员变量的定义</strong>等等）保存到方法区，<strong>方法区</strong>主要分为两部分：</p><ol><li><strong>常量池</strong>：Java 类引用的一些常量信息，比如<strong>类的符号引用信息</strong></li><li><strong>方法区其它部分：</strong> 保存<strong>方法表</strong>等</li></ol><p><u>链接过程</u> <strong>类的多态就发生在 <u>链接的解析</u></strong> 过程，将 <u>符号引用替换为直接引用</u>。</p></li><li><p><strong>原理简述（子类方法继承）</strong></p><blockquote><p>参考：<a href="https://www.huaweicloud.com/articles/9b805c24ab31a65f5883c0dfeaf5a39b.html">https://www.huaweicloud.com/articles/9b805c24ab31a65f5883c0dfeaf5a39b.html</a></p></blockquote></li></ul></li></ol><h4 id="2-请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？">2. <strong>请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</strong></h4><ul><li><strong>构造函数：</strong> 每一个类都有构造函数，程序员没有创建时，编译器会默认创建一个构造函数；<strong>对象被创建时，构造函数被调用</strong>；</li><li><strong>构造函数重载：</strong> 和方法重载类似，一个类可以创建多个构造函数，每个构造函数都有<strong>唯一参数列表</strong>；</li><li><strong>复制构造函数：</strong> Java不支持像C++中那样的复制构造函数。</li></ul><h4 id="3-请说明Java中的方法重写-Overriding-和方法重载-Overloading-是什么意思？构造函数能否被重写？">3. <strong>请说明Java中的方法重写(Overriding)和方法重载(Overloading)是什么意思？构造函数能否被重写？</strong></h4><ul><li><p>Overriding ： 方法重写是说<u>子类重新定义了父类的方法</u>，有<u>相同的方法名，参数列表和返回类型</u> ；</p></li><li><p>Overloading： 同一个类里面两个或者是多个方法<u>同名</u> ，但 <u>参数列表不同</u>不同。</p><blockquote><p>特别的重写要求返回类型一致，但<strong>重载不要求返回类型一致</strong>！</p></blockquote></li></ul><p>**构造函数不能被 override（重写）！**但是可以 overload（重载）,所以你可以看到⼀个类中有多个构造函数的情况。</p><h5 id="3-1-f（List-String-l）-f（List-Integer-l）是重载么？">3.1 f（List&lt;String&gt; l） f（List&lt;Integer&gt; l）是重载么？</h5><p>不是重载。</p><p>静态类型一致，并<strong>不会因为泛型而改变</strong>。因为<strong>编译</strong>期间，会对泛型进行<strong>擦除</strong>。</p><h4 id="4-介绍一下接口和抽象类的区别？">4. <strong>介绍一下接口和抽象类的区别？</strong></h4><ul><li><p><strong>设计层面</strong></p><p>接口，是对类的行为进行约束**，强制要求<strong>不同类实现相同行为 ； 抽象类，既 1.<strong>非抽象类实现代码复用</strong> 2.又同时有</strong>抽象方法使得被继承类各自实现。**</p></li><li><p><strong>方法实现</strong></p><p>抽象类可以<strong>有非抽象方法，有方法体</strong> ； 接口不能有。</p><blockquote><p><strong>抽象类中添加新的方法，你可以给它提供默认的实现</strong>。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。</p></blockquote></li><li><p><strong>构造函数</strong></p><p>抽象类有；接口没有。</p></li><li><p><strong>修饰符</strong></p><p>抽象类除private 都有（抽象类目的是被继承，所以<strong>抽象方法是为被重写，不能私有</strong>）；接口<strong>默认public</strong>。</p></li><li><p><strong>继承个数 [接口优]</strong></p><p>抽象类只能被继承一次；接口可以有多个。</p></li></ul><h4 id="5-Java的四种引用？强软弱虚-？">5. <strong>Java的四种引用？强软弱虚</strong> ？</h4><ul><li><p><strong>强引用</strong> ：强引用是平常中使用最多的引用，强引用**在程序内存不足（OOM）**的时候也不会被回收，使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure></li><li><p><strong>软引用：</strong> 软引用<strong>在程序内存不足时，会被回收（“软”，没钱用了第一个被打劫）</strong>，使用方式：</p><blockquote><p>可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收<u>早先创建的对象</u>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，</span></span><br><span class="line"><span class="comment">// 这里的软引用指的是指向new String(&quot;str&quot;)的引用，也就是SoftReference类中T</span></span><br><span class="line">SoftReference&lt;String&gt; wrf = <span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>弱引用：<strong>是只要</strong><u>JVM垃圾回收器发现了弱引用</u>，就会将之回收</strong>，使用方式：</p><blockquote><p><strong>可用场景：</strong>  Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用。一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; wrf = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure></li><li><p><strong>虚引用：无法通过虚引用来获取对一个对象的真实引用</strong>； 虚引用必须与ReferenceQueue一起使用，当GC准备回收一个<strong>对象</strong>，如果发现<strong>它还有虚引用</strong>，就会在回收之前，把这个虚引用加入到与之关联的ReferenceQueue中。</p><blockquote><p>可用场景： 对象销毁前的一些操作，比如说资源释放等。 Object.finalize() 虽然也可以做这类动作，但是这个方式即不安全又低效。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; prf = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>),</span><br><span class="line"><span class="keyword">new</span> ReferenceQueue&lt;&gt;());</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-JAVA创建对象的机制？">6. <strong>JAVA创建对象的机制？</strong></h4><ul><li><p>new创建新对象</p></li><li><p>通过反射机制</p></li><li><p>采用clone机制</p></li><li><p>通过序列化机制</p></li></ul><h4 id="7-简述Java的对象结构？">7. <strong>简述Java的对象结构？</strong></h4><p>Java对象由三个部分组成：对象头、实例数据、<u>对齐填充</u>。</p><ol><li><p><strong>对象头。</strong> 在JVM中，对象在内存中除了本身的数据外还会有个对象头，对于普通对象而言，其对象头中有两类信息：<strong><code>mark word</code>和类型指针</strong>。 如果是数组对象，还有数组长度。</p><ol><li><u><code>mark word(32位)</code></u></li></ol><p><img src="https://i.loli.net/2021/05/16/PjXkchreF9sSEKG.png" alt="image-20210516131559341"></p><ul><li>具体的内容包含对象的hashcode、分代年龄、轻量级锁指针、重量级锁指针、GC标记（分代年龄）、偏向锁线程ID、偏向锁时间戳。</li><li>当对象状态为偏向锁时，<code>mark word</code>存储的是偏向的线程ID；当状态为轻量级锁（lightweight locked）时，<code>mark word</code>存储的是指向线程栈中<code>Lock Record</code>的指针；<strong>当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针</strong>。</li></ul><ol start="2"><li><p><u>存储类型指针</u>，也就是指向类的元数据的指针，通过这个指针才能确定对象是<strong>属于哪个类的实例</strong>；</p></li><li><p><u>数组长度：</u>另外对于数组而言还会有一份记录数组长度的数据。</p></li></ol></li><li><p><strong>实例数据。</strong> 来存储对象真正的有效信息（包括父类继承下来的和自己定义的）；</p></li><li><p>**对齐填充。**JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）。</p></li></ol><h4 id="8-Object-有哪些常用方法？">8. <strong>Object</strong> <strong>有哪些常用方法？</strong></h4><ul><li><strong>equals</strong> <strong>方法</strong></li><li><strong>hashCode</strong> <strong>方法</strong></li><li><strong>wait</strong> <strong>方法</strong></li><li><strong>notify</strong> <strong>方法</strong></li><li><strong>notifyAll</strong> <strong>方法</strong></li></ul><h3 id="1-2-2-反射">1.2.2 反射</h3><h4 id="1-请说明一下JAVA中反射的实现过程和作用分别是什么？-（快手）优缺点？">1. <strong>请说明一下JAVA中反射的实现过程和作用分别是什么？</strong> （快手）优缺点？</h4><ul><li><p><strong>定义</strong></p><p>反射机制是<strong>在运行时</strong>，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p><blockquote><p>jdbc就是典型的反射 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&#x27;com.mysql.jdbc.Driver.class&#x27;</span>);<span class="comment">//加载MySQL的驱动类</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>实现和作用</strong></p><p>JAVA语言编译之后会生成一个<code>.class</code>文件，反射就是通过<strong>字节码</strong>文件<strong>找到某一个类、类中的方法以及属性</strong>等。</p><ul><li><p><strong>实现：</strong> （1）<strong>代码会编译成一个.class文件</strong> （2） <strong>类加载器加载进JVM的内存中，在方法区创建了Object类的Class对象</strong></p><blockquote><p>不是new出来的对象，而是类的类型对象，每个类都只有一个Class对象，作为方法区类的数据结构的接口。</p></blockquote><p>我们便是通过这个class对象来进行反射获取类的信息。</p></li><li><p><strong>作用：</strong></p><ol><li>反射机制指的是程序在运行时能够获取自身的信息。在JAVA中，<strong><u>只要给定类的名字</u></strong>，那么就可以通过反射机制来获取类的所有信息。</li><li>根据类名在<strong>运行时创建实例</strong>（类名可以从配置文件读取，不用new）</li></ol></li></ul></li><li><p><strong>反射优缺点</strong></p><ul><li><strong>优点</strong>：（1）对于任意一个类，都能够知道这个类的所有属性和方法；（2）对于任意一个对象，都能够调用它的任意一个方法</li><li><strong>缺点：</strong><ul><li><strong>性能降低</strong> ： 反射包括了一些<strong>动态类型</strong>，所以JVM<strong>无法对这些代码进行优化</strong></li><li><strong>安全限制：</strong> 使用反射技术要求程序必须在一个<strong>没有安全限制的环境</strong>中运行</li><li><strong>内部暴露</strong>：由于反射允许代码执行一些在正常情况下不被允许的操作（比如<strong>访问私有的属性和方法</strong>），所以使用反射可能会导致意料之外的副作用</li></ul></li></ul></li></ul><h4 id="2-（未）解释一下JAVA代理模式？动态代理的原理？">2. （未）<strong>解释一下JAVA代理模式？动态代理的原理？</strong></h4><blockquote><p>参考这个：<a href="https://zhuanlan.zhihu.com/p/54733692">JAVA面试50讲之9：动态代理的原理是什么？</a></p></blockquote><p>代理模式是给某一个对象提供一个代理，并由**【代理对象】控制对【原对象】的引用(使用)**。</p><ul><li><strong>优点</strong>：代理模式能够协调调用者和被调用者，<u>在一定程度上降低了系统的<strong>耦合度</strong></u>；可以<u>灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务</u>。</li><li><strong>缺点</strong>：由于使用了代理模式，因此程序的性能<u>没有直接调用性能高</u>；使用代理模式<u>提高了代码的复杂度</u>。</li></ul><p>根据代理模式又可以分为：静态代理和动态代理。</p><h5 id="2-1-静态代理">2.1 静态代理</h5><blockquote><p>静态代理：由程序员创建或特定工具自动生成源代码，也就是在<strong>编译时</strong>就已经将接口、被代理类、代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。</p></blockquote><p>代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。</p><ul><li><p>一个班的同学（Student）要向老师交班费，但是都是通过班长（StudentProxy）把自己的钱转交给老师。这里，班长就是代理学生上交班费，班长就是学生的代理。</p></li><li><p><strong>公共Person接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Student实现Person接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;上交班费50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>StudentsProxy实现Person接口</strong></p><p>实现了Peson接口，<strong>同时持有一个Student对象</strong>，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为。</p><blockquote><p>:warning: 自己实现的giveMoney，调用的是<strong>被代理的学生对象.giveMoney()</strong> 方法！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsProxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentsProxy</span><span class="params">(Person stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理上交班费，调用被【代理学生的上交班费】行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用实例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//被代理的学生张三，他的班费上交有代理对象monitor（班长）完成</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成代理对象，并将张三传给代理对象</span></span><br><span class="line">        Person monitor = <span class="keyword">new</span> StudentsProxy(zhangsan);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//班长代理上交班费，实际上是调用被代理对象的giveMoney方法</span></span><br><span class="line">        monitor.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>**使用实例2：**扩充增强原对象方法</p><p>班长在帮张三上交班费之前，想要先反映一下<strong>张三最近学习有很大进步</strong>，通过代理模式很轻松就能办到 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsProxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentsProxy</span><span class="params">(Person stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张三最近学习有进步！&quot;</span>);</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-2-动态代理">2.2 动态代理</h5><blockquote><p>上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就<strong>已经编译</strong>完成 。</p></blockquote><p>然而动态代理，代理类<strong>并不是在Java代码中定义</strong>的，而是在运行时根据我们在Java代码中的“指示”<strong>动态生成</strong>“的 。</p><ul><li><p><strong>优点：</strong> 可以很方便的对代理类的函数进行统一的处理，<strong>而不用修改每个代理类中的方法 。</strong> 比如说，想要在每个代理的方法前<u>都加上</u>一个处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="comment">//调用被代理方法前加入处理方法</span></span><br><span class="line">        beforeMethod();</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 代理类其它方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveHomework</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//调用被代理方法前加入处理方法</span></span><br><span class="line">        beforeMethod();</span><br><span class="line">        stu.giveHomework();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>除了giveMonney还有很多其他的方法（giveHomework），那就需要写很多次beforeMethod方法，麻烦。</p></li><li><p><strong>简单实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">  InvocationHandler stuHandler = <span class="keyword">new</span> MyInvocationHandler&lt;Person&gt;(stu);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">  Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler);</span><br></pre></td></tr></table></figure></li><li><p><strong>公共Person接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Student实现Person接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//假设数钱花了一秒时间</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;上交班费50元&quot;</span>);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>增加一个计算方法执行时间的检测方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tl.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束时打印耗时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> finishTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(methodName + <span class="string">&quot;方法耗时&quot;</span> + (finishTime - tl.get()) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>StuInvocationHandler 实现 InvocationHandler接口</strong></p><blockquote><p>并没有像之前一样：用一个代理类 StudentsProxy实现公共<strong>Person</strong>接口，而是代理类StuInvocationHandler 实现<strong>InvocationHandler</strong>接口。</p><p>但二者<strong>都是持有被代理的对象Student引用</strong>。</p></blockquote><p>InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。</p><ul><li>通过<strong>反射</strong>，可以执行被代理对象Student的相应方法giveMoney()。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StuInvocationHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">   <span class="comment">//invocationHandler持有的被代理对象</span></span><br><span class="line">    T target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StuInvocationHandler</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxy:代表动态代理对象</span></span><br><span class="line"><span class="comment">     * method：代表正在执行的方法</span></span><br><span class="line"><span class="comment">     * args：代表调用目标方法时传入的实参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理执行&quot;</span> +method.getName() + <span class="string">&quot;方法&quot;</span>);</span><br><span class="line">     */   </span><br><span class="line">        <span class="comment">//代理过程中插入监测方法,计算该方法耗时</span></span><br><span class="line">        MonitorUtil.start();</span><br><span class="line">        <span class="comment">// 原来的代理对象Student中的方法</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        MonitorUtil.finish(method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>具体实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个实例对象，这个对象是被代理的对象</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">        InvocationHandler stuHandler = <span class="keyword">new</span> StuInvocationHandler&lt;Person&gt;(zhangsan);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)；</span><br><span class="line"></span><br><span class="line">       <span class="comment">//代理执行上交班费的方法</span></span><br><span class="line">        stuProxy.giveMoney();</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/26/bIVRJdO5vKX36nQ.jpg" alt="img"></p></li></ul><h5 id="2-3-动态代理的原理">2.3 动态代理的原理</h5><p>从 JVM 角度来说，动态代理是在运行时<u>，通过<strong>反射</strong>动态生成类<strong>字节码</strong>，</u>并加载到 JVM 中的。</p><h2 id="1-3-集合">1.3 集合</h2><h3 id="1-3-1-集合类">1.3.1 集合类</h3><h4 id="1-请说明Java集合类框架的基本接口有哪些？">1. <strong>请说明Java集合类框架的基本接口有哪些？</strong></h4><ul><li><code>Collection</code>：代表一组对象，每一个对象都是它的子元素。</li><li><code>Set</code>：不包含重复元素的Collection。</li><li><code>List</code>：有顺序的collection，并且可以包含重复元素。</li><li><code>Map</code>：可以把键(key)映射到值(value)的对象，键不能重复。</li></ul><h4 id="2-（补充：举例说明）说说什么是fail-fast？">2. <strong>（补充：举例说明）说说什么是fail-fast？</strong></h4><p>fail-fast 机制是 Java 集合（Collection）中的一种错误<strong>快速反馈</strong>机制。当<strong>多个线程对同一个集合的内容进行操作时</strong>，就可能会产生 fail-fast 事件。</p><blockquote><p>例如：当某一个线程 A 通过 iterator 去遍历某集合的过程中，<strong>若该集合的内容被其他线程所改变了，那么线程 A 访问集合时，就会抛出 ConcurrentModifificationException 异常</strong>，产生 fail-fast 事件。这里的操作主要是指 add、remove 和 clear，对集合元素个数进行修改。</p></blockquote><h4 id="3-请说明List、Map、Set三个接口区分？">3. <strong>请说明List、Map、Set三个接口区分？</strong></h4><ul><li>**重复元素：**List以特定索引来存取元素，可以有重复元素；Map以键值对映射，不能有重复key；Set元素不能重复</li><li><strong>继承collection：</strong> List、Set继承于collection；Map和前二者明显区分，不继承collection</li><li><strong>实现方式：</strong> List是线性结构的容器 ，典型实现有<u>ArrayList 、LinkedList、Vector</u>； Map、Set都有 <u>基于哈希存储和排序树</u> 的两种实现版本，前者实现有 <u>HashMap和Hashtable</u> ，后者有<u>HashSet</u></li></ul><h4 id="4-请讲讲你所知道的常用集合类以及主要方法？">4. <strong>请讲讲你所知道的常用集合类以及主要方法？</strong></h4><p>最常用的集合类是List 和 Map。</p><ul><li>**List：**典型实现有<u>ArrayList 、LinkedList、Vector</u> ，大小可变，适合用于按数值索引元素类型；</li><li><strong>Map：</strong> 其中每个键映射到一个值，实现有 <u>HashMap和Hashtable</u> 。</li></ul><h3 id="1-3-2-Map-Set">1.3.2 <strong>Map &amp; Set</strong></h3><h4 id="1-请你介绍一下map的分类和常见的情况？">1. <strong>请你介绍一下map的分类和常见的情况？</strong></h4><p>java为数据结构中的映射定义了一个接口<code>java.util.Map</code>  ， 它有四个实现类,分别是<code>HashMap、 Hashtable、 LinkedHashMap、 和TreeMap</code>.</p><ul><li><p><strong>Hashmap</strong>  ：根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度。</p><ul><li>遍历：访问快，遍历时取得的<u>数据随机</u></li><li>线程：不支持线程同步（但可以用Collections的synchronizedMap 实现同步）</li><li>key和记录：<strong>HashMap允许键和值是null</strong></li></ul></li><li><p><strong>Hashtable</strong> ：和Hashmap类似，是其子类。但其：</p></li><li><p>线程： 支持线程同步，也导致写入比较慢（一个时候只能一个线程写入）</p></li><li><p>key和记录：不允许记录的键或者值为空 ；</p></li><li><p><strong>LinkedHashMap</strong> ：HashMap的一个子类，<u>保存了记录插入顺序</u>：</p></li><li><p>遍历：<strong>遍历</strong>先得到的记录是先插入、一般情况比HashMap慢。</p></li><li><p><strong>TreeMap</strong> ： 实现SortMap接口，默认是按键值的升序排序，</p></li><li><p>遍历：当用<strong>遍历</strong>TreeMap时，得到的记录是<u>排过序</u>的</p><ul><li>线程：线程安全</li></ul></li></ul><p>一般情况下，我们用的最多的是HashMap, 在Map 中插入、删除和定位元素，HashMap 是最好的选择。但<u>如果您要按自然顺序或自定义顺序遍历键</u>，那么TreeMap会更好。如果需要<u>输出的顺序和输入的相同</u>,那么用LinkedHashMap 可以实现,它还<strong>可以按读取顺序来排列。</strong></p><h5 id="1-1-【百度】-TreeMap的底层实现">1.1 【百度】 TreeMap的底层实现</h5><h4 id="2-请问HashMap和Hashtable区别？">2. <strong>请问HashMap和Hashtable区别？</strong></h4><ul><li><strong>共同点</strong>：都实现Map接口</li><li><strong>不同点：</strong><ol><li>**对Null key 和Null value的支持：**HashMap<u>允许键和值是null</u>，而Hashtable不允许键或者值是null；</li><li>**线程安全：**Hashtable是同步的线程安全，而HashMap不是；</li><li><strong>初始容量大小和每次扩充容量大小不同：</strong>  （1）创建时如果不指定容量初始值，Hashtable 默认的初始大小为<strong>11</strong>，之后每次扩充，容量变为原来的<strong>2n+1</strong>。HashMap 默认的初始化大小为<strong>16</strong>，之后每次扩充，容量变为原来的<strong>2</strong>倍 ；（2）创建时如果给定了容量初始值，那么 Hashtable 会直接使用<strong>你给定的大小</strong>，而 HashMap 会将其<strong>扩充为2的幂次方大小</strong>，也就是说 <u>HashMap 总是使用2的幂作为哈希表的大小</u>；</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表⻓度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有转换为红黑树这样的机制；</li><li>**继承父类：**HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。</li></ol></li></ul><h4 id="3-请问Map接口实现：HashMap、Hashtable和ConcurrentHashMap区别？">3. <strong>请问Map接口实现：HashMap、Hashtable和ConcurrentHashMap区别？</strong></h4><p>都是key-value存储形式。</p><ul><li><p><strong>底层数据结构</strong>：<code>HashMap</code>与<code>ConcurrentHashMap</code>底层数据结构相似（数组+链表+红黑树），<code>Hashtable</code>没有红黑树；</p></li><li><p><strong>线程安全</strong>：<code>Hashtable</code>的<code>synchronized</code>修饰在方法，是对象级的加锁，同一时间只有一个线程能对数据进行操作；<code>ConcurrentHashMap</code>使用了修饰具体对象的<code>synchronized</code>（锁一个桶）和CAS机制，实现了更细粒度的锁；</p></li><li><p><strong>地址计算</strong>：</p></li></ul><ul><li><code>HashMap</code>使用<code>key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16)</code>；-<ul><li><code>Hashtable</code>使用<code>(key.hashCode() &amp; 0x7fffffff) % tab.length()</code></li></ul></li><li><code>ConcurrentHashMap</code>使用<code>(key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16)) &amp; 0x7fffffff</code>。</li></ul><h4 id="4-说一说红黑树特征？">4. <strong>说一说红黑树特征？</strong></h4><blockquote><p>紧接上个问题，面试官很有可能会问红黑树。</p></blockquote><ul><li>每个节点是黑色是红色</li><li><strong>根节点和叶子节点是黑色</strong></li><li>红色节点不能相邻</li><li>从一个节点到子孙节点路径上相同数目的黑节点</li></ul><p><img src="https://i.loli.net/2021/05/05/yismA9xYt5MEeFw.png" alt="image-20210505132113159"></p><h4 id="5-hashmap的基本原理，扩容方式（rehash）？">5. <strong>hashmap的基本原理，扩容方式（rehash）？</strong></h4><blockquote><p>很棒的一篇文章：<a href="https://www.jianshu.com/p/dde9b12343c1">https://www.jianshu.com/p/dde9b12343c1</a></p><p>更棒的一篇文章：<a href="https://zhuanlan.zhihu.com/p/81587796">https://zhuanlan.zhihu.com/p/81587796</a></p></blockquote><ul><li><p><code>HashMap定义</code></p><p>HashMap继承了Map端口，实现了Serializable等接口。存储HashMap的是一个Entry[]数组，Entry是一个单向链表：</p><blockquote><p>所以我们说HashMap实现的是一个<code>数组+链表</code> 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li><li><p><code>Entry类</code></p><p>Entry在HashMap中实现为一个静态内部类，封装了key和value，还有<u>类型为Entry的next指向下一个Entry引用</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       V value;</span><br><span class="line">       Entry&lt;K,V&gt; next;</span><br><span class="line">       <span class="keyword">int</span> hash;</span><br></pre></td></tr></table></figure></li><li><p><code>图解HashMap</code></p><p>根据前面所知，我们可以得到HashMap的实现如下（默认初始化容量为16）：</p><p><img src="https://upload-images.jianshu.io/upload_images/4843132-05b3a55bd2686dd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp" alt="img"></p></li><li><p><code>put方法实现</code></p><ol><li><p>输入的<code>key</code>根据<code>hash(key)</code> 计算出hash值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 对key为null的处理</span></span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="comment">// 根据key算出hash值</span></span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br></pre></td></tr></table></figure><ul><li><p><strong>hash方法如下（JDK1.8版本）</strong></p><p>下面这段代码也叫 <strong>“扰动函数”</strong> ，参考：<a href="https://www.zhihu.com/question/20733617">JDK 源码中 HashMap 的 hash 方法原理是什么？</a></p><p><img src="https://i.loli.net/2021/05/15/OZT8G6PdxkAtQVi.png" alt="img"></p><p>混合原始哈希码的高位和低位，以此来加大低位的随机性 。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"><span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line"><span class="comment">// ^ ：按位异或</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt;⽆符号右移，忽略符号位，空位都以0补⻬</span></span><br><span class="line"><span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相⽐于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差⼀点点，因为毕竟扰动了 4 次。</p></li><li><p><strong>Object类HashCode实现</strong></p><blockquote><p>详细源码分析参考 ：<a href="https://juejin.cn/post/6844903487432556551">Java Object.hashCode()返回的是对象内存地址？</a></p></blockquote><p>JDK8 的<strong>默认</strong>hashCode的计算方法是通过和当前线程有关的<strong>一个随机数+三个确定值</strong>，运用Marsaglia’s xorshift scheme随机数算法得到的一个随机数 。</p><p>可以通过在JVM启动参数中添加**-XX:hashCode=4**，<u>改变默认的hashCode计算方式</u>：</p><ul><li>hashCode == 0 ：返回一个Park-Miller伪随机数生成器生成的随机数 ，OpenJdk 6 &amp;7的默认实现；</li><li>hashCode == 1：此类方案将对象的内存地址，做移位运算后与一个随机数进行异或得到结果 ；</li><li>hashCode == 2：此类方案返回固定的1；</li><li>hashCode == 3：此类方案返回一个自增序列的当前值；</li><li>hashCode == 4：此类方案返回当前对象的内存地址。</li></ul></li></ul></li><li><p>根据<code>indexFor(hash, table.length)</code> ，计算在table中下标</p><p><code>key.hashcode得到hash → 经过高低16异或扰动得到行hash →  indexFor计算下标</code></p><blockquote><p><code>indexFor()</code>  实际就是hash值取余：<code>hash%(table.lenght-1)</code> 。但在具体实现中通过位运算实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><strong>计算原理。</strong> 顺便说一下，这也正好解释了<strong>为什么HashMap的数组长度要取2的整次幂</strong>。因为这样（数组长度-1）正好相当于一个**“低位掩码”<strong>。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是</strong>截取了最低的四位值**。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">          10100101 11000100 00100101</span><br><span class="line">&amp;         00000000 00000000 00001111 （16）</span><br><span class="line">------------------------------------------</span><br><span class="line">          00000000 00000000 000000101</span><br></pre></td></tr></table></figure></li><li><p><strong>位运算要求<code>length</code> 一定是偶数。</strong><code>length-1</code>则一定是奇数。 这样<code>h &amp; (length-1)</code>进行位运算出现的结果可奇可偶，不会一直是偶数，浪费奇数空间。而length为2的幂次，可以保证length一定是偶数，<strong>这也是扩容为什么要求一定是2的幂次</strong>。</p></li></ul></li><li><p><u>遍历table中下标为i的Entry单向链表</u>，找是否有相同的key已经在HashMap中，如果有，就替换value为最新的值；没有就直接插入。所以HashMap中只能存储唯一的key。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="comment">// 先判断hash值是否一样，如果一样，再判断key是否一样</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果是第一次put上面<code>for</code>循环不会执行，而是<code>addEntry</code>方法直接把key和value封装成Entry，然后加入到table中的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modCount++;</span><br><span class="line">addEntry(hash, key, value, i);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>这涉及到HashMap的<strong>扩容机制</strong>。</p></li></ol></li><li><p><code>扩容机制</code></p><blockquote><p>当HashMap中存储的元素个数达到扩容的阀值 ，那如何进行扩容？</p></blockquote><blockquote><p>:warning: 在jdk1.8版本以后，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><img src="https://i.loli.net/2021/05/04/PoScN7yntJRhFvd.png" alt="在这里插入图片描述" style="zoom: 50%;" /></blockquote><p>我们再来看看addEntry方法中的扩容相关代码：</p><ul><li>扩容就是通过<code>resize()</code>方法创建一个长度为原来<strong>2</strong>倍的新table ；</li><li><code>resize()</code>方法内部通过遍历的方式，将老table的数据，重新计算hash并存储到新table的适当位置，最后使用新的table，并重新计HashMap的扩容阀值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">      <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">      <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">          threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">     <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">     transfer(newTable);     </span><br><span class="line">     <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">     table = newTable;  </span><br><span class="line">     <span class="comment">//修改阈值</span></span><br><span class="line">     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure><p>transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">      Entry[] src = table;                   </span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                  <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                  <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">                 e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                 newTable[i] = e; <span class="comment">//将元素放在数组上</span></span><br><span class="line">                 e = next; <span class="comment">//访问下一个Entry链上元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式 。下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p><p><img src="https://i.loli.net/2021/05/15/nCYJf3KPqBdEU4G.png" alt="image-20210515115619336"></p></li><li><p><code>get方法实现</code></p><p>用key的hash值算出key对应的Entry所在链表在在table的下标，然后遍历下标即可。</p><img src="4843132-9b5f706433247a6c.webp" alt="img" style="zoom:80%;" /></li></ul><h5 id="5-1-为什么HashMap默认链表长度超过8转为红黑树，而不是6、7或9？">5.1 为什么HashMap默认链表长度超过8转为红黑树，而不是6、7或9？</h5><ul><li><p>在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为 8 的时候，概率仅为 0.00000006。源码中注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line"><span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line"><span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line"><span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line"><span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line"><span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line"><span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line"><span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line"><span class="number">8</span>:    <span class="number">0.00000006</span></span><br><span class="line">more: less than <span class="number">1</span> in ten million</span><br></pre></td></tr></table></figure><p>这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。</p></li><li><p>特别的，默认是链表长度达到 8 就转成红黑树，而当长度降到 6 就转换回去，这体现了时间和空间平衡的思想。<strong>长度较小时，使用链<u>表空间占用少</u>，时间也不会长（因为链表短）。</strong></p></li></ul><h5 id="5-2-HashMap-多线程操作导致死循环问题？">5.2  HashMap 多线程操作导致死循环问题？</h5><p><strong>总结：</strong> HashMap之所以在并发下的扩容造成死循环，是因为，多个线程并发进行时，<strong>因为一个线程先期完成了扩容</strong>，将原的链表重新散列到自己的表中，并且链表变成了<strong>倒序</strong>，后一个线程再扩容时，又进行自己的散列，再次将<strong>倒序链表变为正序链表</strong>，于是形成了一个环形链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">      Entry[] src = table;                   </span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              src[j] = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                  Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                  <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">               <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">               e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">               newTable[i] = e;    <span class="comment">//将元素放在数组上</span></span><br><span class="line">                e = next;    <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li><p>map初始化为一个长度为2的数组，loadFactor=0.75，<code>threshold=2*0.75</code>=1，也就是说当put第二个key的时候，map就需要进行resize。</p></li><li><p>设置断点让线程1和线程2同时debug到transfer方法的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p><p><img src="https://i.loli.net/2021/05/15/9wiAnOHdBe7hjLs.png" alt="image-20210515120319361"></p></li><li><p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，<strong>指向了线程二重组后的新链表</strong>。</p></li><li><p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p><p><img src="https://i.loli.net/2021/05/15/NFfwAOguQmsyeWh.png" alt="image-20210515120436107"></p></li><li><p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p><p><img src="https://i.loli.net/2021/05/15/ApClYedO6JTWmnx.png" alt="image-20210515120503570"></p></li></ol><h5 id="5-3-说说HashMap的put方法？">5.3 说说HashMap的put方法？</h5><p>根据key值计算在数组中的位置：</p><ul><li>如果定位到的数组位置没有元素 就直接插入；</li><li>如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，<u>依次和插入的 key 比较，如果 <strong>hash值&amp;equals对象相同</strong>就直接<strong>覆盖</strong>，<strong>不同</strong>就采用<strong>头插法</strong>插入元素</u>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//table[i]的位置已经存在元素，遍历链表</span></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;    </span><br><span class="line">    Object k;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用 equals 方法判断key是否相等，若相等，该key对应的键值对已经存在，用新的value取代旧的value</span></span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;    </span><br><span class="line">        V oldValue = e.value;    </span><br><span class="line">        e.value = value;    </span><br><span class="line">        e.recordAccess(<span class="keyword">this</span>);    </span><br><span class="line">        <span class="keyword">return</span> oldValue;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h5 id="5-4-说说HashMap的get方法？"><strong>5.4 说说HashMap的get方法？</strong></h5><p>根据key值计算在数组中的位置：</p><ul><li>遍历链表或者在红黑树，比较key来获取value</li></ul><h5 id="5-5-【百度】rehash扩容时机？在插入前还是插入后？">5.5 【百度】rehash扩容时机？在插入前还是插入后？</h5><p>rehash过程在put函数中，其大致扩容时机如下：</p><ol><li><p>计算hash，定位到桶；且遍历桶外挂链表，如果有相同key则覆盖；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)  <span class="comment">// 【百度】怎么处理key或value为NULL的情况？</span></span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);<span class="comment">//计算键的hash值</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//通过hash值对应到桶位置</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;<span class="comment">//顺序遍历桶外挂的单链表</span></span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;/</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);<span class="comment">//遍历单链表完毕，没有找到与键相对的Entry，需新建一个Entry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>【如果没有找到相同key，说明要插入一个新entry】</strong> ，执行addEntry，<strong>插入前</strong>先验证下是否扩容；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * table.length);<span class="comment">//将容量扩容为原来的2倍</span></span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);<span class="comment">//扩容后的，该hash值对应的新的桶位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);<span class="comment">//在指定的桶位置上，创建一个新的Entry</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);<span class="comment">//链表的头插法插入新建的Entry</span></span><br><span class="line">        size++;<span class="comment">//更新size</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>因此总结扩容时机如下：</p><ul><li>在执行put时，如果遍历指定桶外挂链表<strong>没有找到相同key</strong>的节点时，说明需要<strong>新建一个entry</strong>，这个时候在<strong>插入前</strong>验证下是否要扩容。</li></ul><h5 id="5-6-hashmap在1-7版本之前为什么使用头插法？">5.6 hashmap在1.7版本之前为什么使用头插法？</h5><blockquote><p>1.7版本之前采用头插法，1.8之后采用尾插法。</p></blockquote><p><strong>头插法</strong>会改变链表中元素原本的顺序，以至于在并发场景下<strong>导致链表成环</strong>的问题；而<strong>尾插法</strong>，在扩容时<strong>会保持链表元素原本的顺序</strong>，就不会出现链表成环的问题 。</p><blockquote><p>既然有多线程并发问题，那为什么1.8之前还要使用头插法？</p></blockquote><ol><li><strong>局部性原理：</strong> 最近访问过的数据下次大概率会再次访问，把刚访问过的元素<strong>放在链表最前面</strong>可以直接被查询到，减少查找次数</li><li><strong>不是为了适应多线程而设计：</strong>　只有在并发情况下，头插法才会出现链表成环的问题，多线程情况下，HashMap 本就非线程安全，这就<strong>相当于你在它的规则之外</strong>出了问题。</li></ol><h5 id="5-7-Hashmap-怎么处理key和value为null的情况？">5.7 Hashmap 怎么处理key和value为null的情况？</h5><h4 id="6-Hashtable-源码分析">6. Hashtable 源码分析</h4><blockquote><p>参考：<a href="https://juejin.cn/post/6844903509725282317">Java集合之Hashtable源码解析</a></p></blockquote><ul><li><p><strong>构造函数</strong></p><p>和HashMap还是挺相似的，但是默认初始容量是11（HashMap是16）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;<span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;<span class="comment">//键值对的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;<span class="comment">//阀值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> loadFactor;<span class="comment">//加载因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;<span class="comment">//修改次数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;<span class="comment">//下面的三个构造函数都是调用这个函数，来进行相关的初始化</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">            initialCapacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[initialCapacity];<span class="comment">//这里是与HashMap的区别之一，HashMap中table</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">        initHashSeedAsNeeded(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;<span class="comment">//指定初始数组长度</span></span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;<span class="comment">//从这里可以看出容量的默认值为16，加载因子为0.75f.</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">        putAll(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>put方法</strong></p><p>和HashMap整体过程依旧很像，但有4点注意：</p><ol><li><p>put方法是加锁synchronized，所以线程安全</p></li><li><p>Hashtable计算hash值的hash(key)，不允许为null，所以会抛出异常</p></li><li><p>获取数组散列的下标 <code>(hash &amp; 0x7FFFFFFF) % tab.length</code> 和HashMap <code>hash &amp; length-1</code> 不同</p><blockquote><ul><li><code>(hash &amp; 0x7FFFFFFF) % tab.length</code>  是（1）<code>hash &amp; 0x7FFFFFFF</code>  保证hash是正数 （2）然后取余</li><li>相比之下，HashMap是位运算进行了优化，更高效</li></ul></blockquote></li><li><p>Hashtable没有链表转红黑树的机制</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;<span class="comment">//这里方法修饰符为synchronized,所以是线程安全的。</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();<span class="comment">//value如果为Null,抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        Entry tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);<span class="comment">//hash里面的代码是hashSeed^key.hashcode（）,null.hashCode（）会抛出异常，所以这就解释了Hashtable的key和value不能为null的原因。</span></span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;<span class="comment">//获取数组元素下标,先对hash值取正，然后取余。</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                V old = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;<span class="comment">//修改次数。</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;<span class="comment">//键值对的总数大于其阀值</span></span><br><span class="line">            rehash();<span class="comment">//在rehash里进行扩容处理</span></span><br><span class="line"></span><br><span class="line">            tab = table;</span><br><span class="line">            hash = hash(key);</span><br><span class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>rehash方法（扩容）</strong></p><p>和HashMap依旧很像，但是扩容每次是 <code>old*2+1</code> 。</p></li><li><p><strong>get方法</strong></p><p>也是相比Hashmap直接加了 synchronized 进行修饰，保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;<span class="comment">//没有什么特殊性，就是加了一个synchronized，就是根据index来遍历索引处的单链表。</span></span><br><span class="line">       Entry tab[] = table;</span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">               <span class="keyword">return</span> e.value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="6-1-（容易忘）HashMap-和-Hashtable-的区别-？">6.1 （容易忘）HashMap <strong>和</strong> Hashtable <strong>的区别</strong> ？</h5><ol><li><p><strong>关于null</strong>，HashMap允许key和value都可以为null，而Hashtable则不接受key为null或value为null的键值对。</p></li><li><p><strong>关于线程安全</strong>，HashMap是线程不安全的，Hashtable是线程安全的，因为Hashtable的许多操作函数都用synchronized修饰。</p></li><li><p><strong>Hashtable与HashMap实现的接口不一致</strong>，但Hashtable继承Dictionary，而HashMap继承自AbstractMap，即父类不同</p></li><li><p><strong>默认初始容量不同</strong>，扩容大小不同。HashMap的hash数组的默认大小是16，而且一定是2 的指数<code>old*2</code>；Hashtable中hash数组默认大小是11，增加的方式是<code>old*2+1</code>。</p></li></ol><h5 id="6-2-ConcurrentHashMap-和-Hashtable-的区别-？">6.2 ConcurrentHashMap <strong>和</strong> Hashtable <strong>的区别</strong> ？</h5><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构⼀样，数组+链表/红黑⼆叉树。Hashtable 和 JDK1.8 之前的HashMap 的底层数据结构类似都是采用 <strong>数组+链表/红黑树</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在JDK1.7</strong>的时候ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和CAS 来操作</strong>。（JDK1.6以后 对 synchronized锁做了很多优化） <u>整个看起来就像是优化过且线程安全的 HashMap</u>，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同⼀把锁，全表锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当⼀个线程访问同步方法时，其他线程也访问同步方法，可能会进⼊阻塞或轮询状态，如使用 put 添加元素，另⼀个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><h4 id="7-ConcurrentHashMap线程安全的具体实现方式-底层具体实现-？">7.  ConcurrentHashMap<strong>线程安全的具体实现方式</strong>/<strong>底层具体实现</strong> ？</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/huangjuncong/p/9478505.html">https://www.cnblogs.com/huangjuncong/p/9478505.html</a></p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ConcurrentHashMap%E6%BA%90%E7%A0%81%2B%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.md">javaGuide</a></p></blockquote><p>Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p><p>Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p><ul><li><p><strong>JDK 1.7 实现</strong></p><p>Java 7 中 ConcurrentHashMap 的存储结构如下图。</p><img src="https://i.loli.net/2021/05/15/iT9npPGIdazS4vw.png" alt="img" style="zoom:150%;" /><ul><li><p><strong>存储结构</strong></p><p>ConcurrentHashMap 为了提高本身的并发能力，在内部采用了一个叫做 Segment 的结构，<strong>一个 Segment 其实就是一个类 HashTable 的结构</strong>，Segment 内部维护了一个链表数组。</p><blockquote><p>**两次Hash。**ConcurrentHashMap 定位一个元素的过程需要进行两次Hash操作，第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部。</p><p>因此，这一种结构的带来的副作用是 Hash 的过程要比普通的 HashMap 要长，但是带来的好处是写操作的时候可以只对元素所在的 Segment 进行操作即可，不会影响到其他的 Segment。</p></blockquote><p><strong>1. ConcurrentHashMap的成员变量和构造函数</strong></p><blockquote><p><strong>ConcurrentHashMap扩容：</strong> 元素数量增加导致ConrruentHashMap需要扩容，ConcurrentHashMap不会增加Segment的数量，而<strong>只会增加Segment中链表数组的容量大小</strong>。 需要对整个ConcurrentHashMap做rehash，而只需要对Segment里面的元素做一次rehash就可以了。</p></blockquote><p>核心初始化函数逻辑如下：</p><blockquote><p>2的指数是为了可以使用移位操作加快hash计算过程。</p></blockquote><ol><li><p>计算出Segment的数量<code>ssize</code>，是不大于concurrencyLevel的最大的2的指数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">          ++sshift; </span><br><span class="line">           ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据intialCapacity确定Segment的容量的大小，每一个Segment的容量大小也是2的指数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">      ++c;</span><br><span class="line">      <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">      <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ol><p>下面是完整代码：</p><blockquote><ul><li>segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到 。<strong>默认是 32 - sshift = 28</strong></li><li>segmentMask，默认是 ssize - 1 = 16 -1 = 15</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 默认segment层级</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// segment最小容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 一个segment最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 锁之前重试次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数：无参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数：指定初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数：指定初始容量，负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数：指定初始容量，负载因子，并发级别</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">        <span class="comment">// 找到两种大小的最匹配参数</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// segment数组的长度是由concurrentLevel计算来的，segment数组的长度是2的N次方，</span></span><br><span class="line">        <span class="comment">// 默认concurrencyLevel = 16, 所以ssize在默认情况下也是16,此时 sshift = 4</span></span><br><span class="line">        <span class="comment">// sshift相当于ssize从1向左移的次数</span></span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift; </span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 段偏移量，默认值情况下此时segmentShift = 28</span></span><br><span class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">        <span class="comment">// 散列算法的掩码，默认值情况下segmentMask = 15</span></span><br><span class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// create segments and segments[0]</span></span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">            <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                             (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">        <span class="comment">// 创建ssize长度的Segment数组</span></span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">        <span class="keyword">this</span>.segments = ss;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>2.来查看具体代码定义，Segment的成员变量：</strong></p><blockquote><p>Segment 继承于 ReentrantLock，不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;    <span class="comment">//Segment中元素的数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;      <span class="comment">//对table的大小造成影响的操作的数量(比如put或者remove操作)</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;    <span class="comment">//阈值,Segment里面元素的数量超过这个值那么就会对Segment进行扩容</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;   <span class="comment">//负载因子,用于确定threshold</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;    <span class="comment">//链表数组,数组中的每一个元素代表了一个链表的头部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 继续查看HashEntry组成：</strong></p><blockquote><p>和 HashMap 非常类似，唯一的区别就是其中的核心数据如 <strong>value ，以及链表都是 volatile 修饰的</strong>，保证了获取时的可见性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    　<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ConcurrentHashMap列表Entry。注意，这不会作为用户可见的Map.Entry导出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">    </span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置具有volatile写语义的next字段。</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(HashEntry&lt;K,V&gt; n)</span> </span>&#123;</span><br><span class="line">      UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面不太重要，略。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>put() 方法实现</strong></p><blockquote><p>相比Hashtable，1.7版本concurrentHashmap的更加细粒度，只有定位到段，才会锁住。也就是段锁！</p><p>而Hashtable直接锁住整个方法。</p></blockquote><ol><li><p>计算key的hash值 ;</p></li><li><p>根据<strong>hash值，segmentShift，segmentMask定位到哪个Segment</strong>；</p></li><li><p>如果指定位置的 Segment 为空，则初始化这个 Segment；</p></li><li><p>在对应的 Segment 中进行具体的 put。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span></span><br><span class="line">    <span class="comment">// 其实也就是把高4位与segmentMask（1111）做与运算</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        <span class="comment">// 如果查找到的 Segment 为空，初始化</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Segment 中进行具体的 put的源码如下：</p><blockquote><p>判断元素个数是否超过了阈值或者segment中数组的长度超过了MAXIMUM_CAPACITY，如果满足条件则rehash扩容！</p></blockquote><p>由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p><ol><li><p>tryLock() 获取锁，获取不到使用 <strong><code>scanAndLockForPut</code></strong> 方法继续获取；</p><blockquote><p>这里面的第一步中的 scanAndLockForPut 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。</p></blockquote></li><li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry ；</p></li><li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待；</p><p>如果这个位置上的 <strong>HashEntry 不存在</strong>：</p><ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接<strong>头插法</strong>插入。</li></ol><p>如果这个位置上的 <strong>HashEntry 存在</strong>：</p><ol><li>判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致，<strong>一致则替换值</strong></li><li>不一致，<u>获取链表下一个节点</u>，直到发现相同进行值替换，或者链表表里完毕没有相同的。<ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接链表<strong>头插法</strong>插入。</li></ol></li></ol></li><li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 计算要put的数据位置</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// CAS 获取 index 坐标的值</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>扩容 rehash</strong></p><blockquote><p>rehash在put()内部被触发。</p></blockquote><p>ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，<strong>位置要么不变，要么变为 index+ oldSize</strong>，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> idx = e.hash &amp; sizeMask;  <span class="comment">// 新位置计算</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="comment">// 老容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 新容量，扩大两倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 新的扩容阀值 </span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新的数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历老数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算新的位置，新的位置只可能是不变或者是：老的位置+老的容量。</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                <span class="comment">// 如果当前位置还不是链表，只是一个元素，直接赋值</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// 如果是链表了</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">// 新的位置只可能是不变或者是：老的位置+老的容量。</span></span><br><span class="line">                <span class="comment">// 遍历结束后，lastRun 后面的元素位置都是相同的</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="keyword">null</span>; last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    <span class="comment">// 遍历剩余元素，头插法到指定 k 位置。</span></span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头插法插入新的节点</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>get方法</strong></p><blockquote><p>注意，Hashtable 会使用Synchronized进行修饰，所以不支持并发。但是ConcurrentHashmap <strong>没有使用同步机制</strong>：</p><ul><li>1.7版本 。<strong>使用unsafe方法（）等方式直接操作来保证并发处理的安全性</strong>，使用的是硬件的安全机制。</li><li>1.8版本。没有使用同步，也没有使用unsafe方式。所以<strong>是并发</strong>的。</li></ul></blockquote><ul><li><p>到这里就很简单了，get 方法只需要两步即可。</p><ol><li>计算得到segment的位置 u</li><li><strong>CAS方式获取segment数组对象 segment[u]</strong></li><li>计算HashEntry数组的下标 i</li><li><strong>CAS方式获取HashEntry[i]，即数组首节点</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 计算得到 key 的存放位置</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="comment">// 如果是链表，遍历查找到相同 key 的 value。</span></span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>JDK 1.8 实现</strong></p><blockquote><p>1.8版本分析，建议参考：<a href="https://www.cnblogs.com/zerotomax/p/8687425.html">https://www.cnblogs.com/zerotomax/p/8687425.html</a> 。</p></blockquote><p><img src="https://i.loli.net/2021/05/15/F6UhuXNQGKnldVk.png" alt="image-20210515224441806"></p><p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p><blockquote><p>和JDK1.8的HashMap是很相似 , 抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p></blockquote><ul><li><p><strong>存储结构和属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>; <span class="comment">// hashmap也是16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">// 超过8扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">// 超过64红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// 表示正在转移</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 表示已经转换成树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Node数组存储元素</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;<span class="comment">//默认没初始化的数组，用来保存元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<span class="comment">//转移的时候用的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来控制表初始化和扩容的，默认值为0，当在初始化的时候指定了大小，这会将这个大小保存在sizeCtl中，大小为数组的0.75</span></span><br><span class="line"><span class="comment">     * 当为负的时候，说明表正在初始化或扩张，</span></span><br><span class="line"><span class="comment">     *     -1表示初始化</span></span><br><span class="line"><span class="comment">     *     -(1+n) n:表示活动的扩张线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在ConcurrentHashMap中使用了unSafe方法，通过直接操作内存的方式来保证并发处理的安全性，使用的是硬件的安全机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用来返回节点数组的指定位置的节点的原子操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * cas原子操作，在指定位置设定值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 原子操作，在指定位置设定值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">        U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMapDebug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果在实例化对象的时候指定了容量，则初始化sizeCtl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMapDebug</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当出入一个Map的时候，先设定sizeCtl为默认容量，在添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMapDebug</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>put方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>再来看putVal ：</p><blockquote><p>可以发现相比HashTable直接对方法进行加锁synchronized / 1.7版本的ConcurrentHashMap 进入的开头尝试获取锁，1.8版本的ConcurrentHashMap 锁更加细粒度化。</p><ul><li>只有：（1）table不为初始化 （2）定位到table位置<code>i</code>不存在元素（此时会用CAS方式进行添加）（3）数组也没有在进行扩张（MOVED=-1）</li></ul><p>此时才会进行synchronized 添加元素（不会锁住rehash方法，最后才判断是否扩容）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当添加一对键值对的时候，首先会去判断保存这些键值对的数组是不是初始化了，</span></span><br><span class="line"><span class="comment">     * 如果没有的话就初始化数组</span></span><br><span class="line"><span class="comment">     *  然后通过计算hash值来确定放在数组的哪个位置</span></span><br><span class="line"><span class="comment">     * 如果这个位置为空则直接添加，如果不为空的话，则取出这个节点来</span></span><br><span class="line"><span class="comment">     * 如果取出来的节点的hash值是MOVED(-1)的话，则表示当前正在对这个数组进行扩容，复制到新的数组，则当前线程也去帮助复制</span></span><br><span class="line"><span class="comment">     * 最后一种情况就是，如果这个节点，不为空，也不在扩容，则通过synchronized来加锁，进行添加操作</span></span><br><span class="line"><span class="comment">     *    然后判断当前取出的节点位置存放的是链表还是树</span></span><br><span class="line"><span class="comment">     *    如果是链表的话，则遍历整个链表，直到取出来的节点的key来个要放的key进行比较，如果key相等，并且key的hash值也相等的话，</span></span><br><span class="line"><span class="comment">     *          则说明是同一个key，则覆盖掉value，否则的话则添加到链表的末尾</span></span><br><span class="line"><span class="comment">     *    如果是树的话，则调用putTreeVal方法把这个元素添加到树中去</span></span><br><span class="line"><span class="comment">     *  最后在添加完成之后，会判断在该节点处共有多少个节点（注意是添加前的个数），如果达到8个以上了的话，</span></span><br><span class="line"><span class="comment">     *  则调用treeifyBin方法来尝试将处的链表转为树，或者扩容数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();<span class="comment">//K,V都不能为空，否则的话跑出异常</span></span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());    <span class="comment">//取得key的hash值</span></span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;    <span class="comment">//用来计算在这个节点总共有多少个元素，用来控制扩容或者转移为树</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;    <span class="comment">//</span></span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)    </span><br><span class="line">                tab = initTable();    <span class="comment">//第一次put的时候table没有初始化，则初始化table</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;    <span class="comment">//通过哈希计算出一个表中的位置因为n是数组的长度，所以(n-1)&amp;hash肯定不会出现数组越界</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,        <span class="comment">//如果这个位置没有元素的话，则通过cas的方式尝试添加，注意这个时候是没有加锁的</span></span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))        <span class="comment">//创建一个Node添加到数组中区，null表示的是下一个节点为空</span></span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果检测到某个节点的hash值是MOVED，则表示正在进行数组扩张的数据复制阶段，</span></span><br><span class="line"><span class="comment">             * 则当前线程也会参与去复制，通过允许多线程复制的功能，一次来减少数组的复制所带来的性能损失</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)    </span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果在这个位置有元素的话，就采用synchronized的方式加锁，</span></span><br><span class="line"><span class="comment">                 *     如果是链表的话(hash大于0)，就对这个链表的所有元素进行遍历，</span></span><br><span class="line"><span class="comment">                 *         如果找到了key和key的hash值都一样的节点，则把它的值替换到</span></span><br><span class="line"><span class="comment">                 *         如果没找到的话，则添加在链表的最后面</span></span><br><span class="line"><span class="comment">                 *  否则，是树的话，则调用putTreeVal方法添加到树中去</span></span><br><span class="line"><span class="comment">                 *  </span></span><br><span class="line"><span class="comment">                 *  在添加完之后，会对该节点上关联的的数目进行判断，</span></span><br><span class="line"><span class="comment">                 *  如果在8个以上的话，则会调用treeifyBin方法，来尝试转化为树，或者是扩容</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;        <span class="comment">//再次取出要存储的位置的元素，跟前面取出来的比较</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;                <span class="comment">//取出来的元素的hash值大于0，当转换为树之后，hash值为-2</span></span><br><span class="line">                            binCount = <span class="number">1</span>;            </span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;    <span class="comment">//遍历这个链表</span></span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;        <span class="comment">//要存的元素的hash，key跟要存储的位置的节点的相同的时候，替换掉该节点的value即可</span></span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)        <span class="comment">//当使用putIfAbsent的时候，只有在这个key没有设置值得时候才设置</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;    <span class="comment">//如果不是同样的hash，同样的key的时候，则判断该节点的下一个节点是否为空，</span></span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,        <span class="comment">//为空的话把这个要加入的节点设置为当前节点的下一个节点</span></span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;    <span class="comment">//表示已经转化成红黑树类型了</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,    <span class="comment">//调用putTreeVal方法，将该元素添加到树中去</span></span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)    <span class="comment">//当在同一个节点的数目达到8个的时候，则扩张数组或将给节点的数据转为tree</span></span><br><span class="line">                        treeifyBin(tab, i);    </span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);    <span class="comment">//计数，可能也会触发扩容</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>扩容<code>transfer</code></p><blockquote><p>扩容主要是通过transfer方法来进行的。</p><ul><li>只有在往map中添加元素的时候，在某一个节点的数目已经超过了8个，调用<strong>treeifyBin()</strong> 触发数组的扩容/转换为数；</li><li>使用**addCount()**添加元素数组元素，会进行判断达到了sizeCtl的数量的时候，则会调用transfer方法来进行扩容</li></ul></blockquote><ul><li><p><strong>treeifyBin()</strong></p><p>某一个节点的数目已经超过了8个，执行treeifyBin() 。</p><ol><li><p>当需要扩容的时候，调用的时候tryPresize方法</p><p>（1）<strong>tryPresize方法并没有加锁</strong>，允许多个线程进入，如果数组正在扩张，则当前线程也去帮助扩容使用<strong>transfer</strong>方法</p><p>（2）<u>transfer比较复杂还没有详细看，它里面使用的synchronized 进行单个节点处理扩容</u>  （查看上面看transfer源码）</p></li><li><p>否则synchronized进行链表转换为树</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当数组长度小于64的时候，扩张数组长度一倍，否则的话把链表转为树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;treeifyBin方\t==&gt;数组长：&quot;</span>+tab.length);</span><br><span class="line">            <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)    <span class="comment">//MIN_TREEIFY_CAPACITY 64</span></span><br><span class="line">                tryPresize(n &lt;&lt; <span class="number">1</span>);        <span class="comment">// 数组扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;    <span class="comment">//使用synchronized同步器，将该节点出的链表转为树</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;    <span class="comment">//hd：树的头(head)</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p =</span><br><span class="line">                                <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)        <span class="comment">//把Node组成的链表，转化为TreeNode的链表，头结点任然放在相同的位置</span></span><br><span class="line">                                hd = p;    <span class="comment">//设置head</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                tl.next = p;</span><br><span class="line">                            tl = p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));<span class="comment">//把TreeNode的链表放入容器TreeBin中</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>addCount()</strong></p><p>addCount也主要是调用transfer，这里主要还是寄一下transfer的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Moves and/or copies the nodes in each bin to new table. See</span></span><br><span class="line"><span class="comment">     * above for explanation.</span></span><br><span class="line"><span class="comment">     * 把数组中的节点复制到新的数组的相同位置，或者移动到扩张部分的相同位置</span></span><br><span class="line"><span class="comment">     * 在这里首先会计算一个步长，表示一个线程处理的数组长度，用来控制对CPU的使用，</span></span><br><span class="line"><span class="comment">     * 每个CPU最少处理16个长度的数组元素,也就是说，如果一个数组的长度只有16，那只有一个线程会对其进行扩容的复制移动操作</span></span><br><span class="line"><span class="comment">     * 扩容的时候会一直遍历，知道复制完所有节点，没处理一个节点的时候会在链表的头部设置一个fwd节点，这样其他线程就会跳过他，</span></span><br><span class="line"><span class="comment">     * 复制后在新数组中的链表不是绝对的反序的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)    <span class="comment">//MIN_TRANSFER_STRIDE 用来控制不要占用太多CPU</span></span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range    //MIN_TRANSFER_STRIDE=16</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果复制的目标nextTab为null的话，则初始化一个table两倍长的nextTab</span></span><br><span class="line"><span class="comment">         * 此时nextTable被设置值了(在初始情况下是为null的)</span></span><br><span class="line"><span class="comment">         * 因为如果有一个线程开始了表的扩张的时候，其他线程也会进来帮忙扩张，</span></span><br><span class="line"><span class="comment">         * 而只是第一个开始扩张的线程需要初始化下目标数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 创建一个fwd节点，这个是用来控制并发的，当一个节点为空或已经被转移之后，就设置为fwd节点</span></span><br><span class="line"><span class="comment">         * 这是一个空的标志节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">        <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;    <span class="comment">//是否继续向前查找的标志位</span></span><br><span class="line">        <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep(清扫) before committing nextTab,在完成之前重新在扫描一遍数组，看看有没完成的没</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing) &#123;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                         (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="keyword">int</span> sc;</span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;        <span class="comment">//已经完成转移</span></span><br><span class="line">                    nextTable = <span class="keyword">null</span>;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);    <span class="comment">//设置sizeCtl为扩容后的0.75</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)            <span class="comment">//数组中把null的元素设置为ForwardingNode节点(hash值为MOVED[-1])</span></span><br><span class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;                <span class="comment">//加锁操作</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;        <span class="comment">//该节点的hash值大于等于0，说明是一个Node节点</span></span><br><span class="line">                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                 * 因为n的值为数组的长度，且是power(2,x)的，所以，在&amp;操作的结果只可能是0或者n</span></span><br><span class="line"><span class="comment">                                 * 根据这个规则</span></span><br><span class="line"><span class="comment">                                 *         0--&gt;  放在新表的相同位置</span></span><br><span class="line"><span class="comment">                                 *         n--&gt;  放在新表的（n+原来位置）</span></span><br><span class="line"><span class="comment">                                 */</span></span><br><span class="line">                            <span class="keyword">int</span> runBit = fh &amp; n; </span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * lastRun 表示的是需要复制的最后一个节点</span></span><br><span class="line"><span class="comment">                             * 每当新节点的hash&amp;n -&gt; b 发生变化的时候，就把runBit设置为这个结果b</span></span><br><span class="line"><span class="comment">                             * 这样for循环之后，runBit的值就是最后不变的hash&amp;n的值</span></span><br><span class="line"><span class="comment">                             * 而lastRun的值就是最后一次导致hash&amp;n 发生变化的节点(假设为p节点)</span></span><br><span class="line"><span class="comment">                             * 为什么要这么做呢？因为p节点后面的节点的hash&amp;n 值跟p节点是一样的，</span></span><br><span class="line"><span class="comment">                             * 所以在复制到新的table的时候，它肯定还是跟p节点在同一个位置</span></span><br><span class="line"><span class="comment">                             * 在复制完p节点之后，p节点的next节点还是指向它原来的节点，就不需要进行复制了，自己就被带过去了</span></span><br><span class="line"><span class="comment">                             * 这也就导致了一个问题就是复制后的链表的顺序并不一定是原来的倒序</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> b = p.hash &amp; n;    <span class="comment">//n的值为扩张前的数组的长度</span></span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 构造两个链表，顺序大部分和原来是反的</span></span><br><span class="line"><span class="comment">                             * 分别放到原来的位置和新增加的长度的相同位置(i/n+i)</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                         * 假设runBit的值为0，</span></span><br><span class="line"><span class="comment">                                         * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同为0的节点)设置到旧的table的第一个hash计算后为0的节点下一个节点</span></span><br><span class="line"><span class="comment">                                         * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">                                    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                         * 假设runBit的值不为0，</span></span><br><span class="line"><span class="comment">                                         * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同不为0的节点)设置到旧的table的第一个hash计算后不为0的节点下一个节点</span></span><br><span class="line"><span class="comment">                                         * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);    </span><br><span class="line">                            &#125;</span><br><span class="line">                            setTabAt(nextTab, i, ln);    </span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;    <span class="comment">//否则的话是一个树节点</span></span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 在复制完树节点之后，判断该节点处构成的树还有几个节点，</span></span><br><span class="line"><span class="comment">                             * 如果≤6个的话，就转回为一个链表</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>get方法</strong></p><p>get操作中，根本没有使用同步机制，<strong>也没有使用unsafe方法</strong>，所以读（get）操作是支持并发操作的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 相比put方法，get就很单纯了，支持并发操作，</span></span><br><span class="line"><span class="comment">     * 当key为null的时候回抛出NullPointerException的异常</span></span><br><span class="line"><span class="comment">     * get操作通过首先计算key的hash值来确定该元素放在数组的哪个位置</span></span><br><span class="line"><span class="comment">     * 然后遍历该位置的所有节点</span></span><br><span class="line"><span class="comment">     * 如果不存在的话返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">        <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="7-1-你知道-ConcurrentHashMap-的工作原理吗？">7.1 你知道 ConcurrentHashMap 的工作原理吗？</h5><ul><li>Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。<ul><li><strong>主要采用锁机制</strong>，在对某个Segment进行操作时，将该Segment锁定，不允许对其进行非查询操作</li></ul></li><li>Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。<ul><li><strong>CAS无锁算法</strong>，这种乐观操作在完成前进行判断，如果符合预期结果才给予执行</li></ul></li></ul><h5 id="7-2-请问ConcurrentHashMap中变量使用final和volatile修饰有什么用呢？其中链表是final的next属性，那么发生删除某个元素，如何实现的？">7.2 请问ConcurrentHashMap中变量使用final和volatile修饰有什么用呢？其中链表是final的next属性，那么发生删除某个元素，如何实现的？</h5><p>ConcurrentHashMap被final修饰的变量，（部分）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 默认segment层级</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// segment最小容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 一个segment最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 锁之前重试次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>HashEntry中被volatile修饰的部分变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="keyword">volatile</span> V value;  <span class="comment">// 保证可见性</span></span><br><span class="line">       <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure><ul><li>**使用final 。**用来实现不变模式（immutable），他是多线程安全里最简单的一种保障方式。因为你拿他没有办法，想改变它也没有机会。不变模式主要通过final关键字来限定的。在JMM中final关键字还有特殊的语义。Final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让不可变形对象不需要同步就能自由地被访问和共享。</li><li>**使用volatile。**保证某个变量内存的改变对其他线程即时可见，在配合CAS可以实现不加锁对并发操作的支持。</li></ul><h5 id="7-3-HashTable与ConcurrentHashMap有什么区别，描述锁分段技术。">7.3 HashTable与ConcurrentHashMap有什么区别，描述锁分段技术。</h5><ul><li><strong>锁机制。</strong> 所有访问HashTable的线程都必须竞争同一把锁，效率更低；ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li><li><strong>底层数据结构。</strong> 1.8之后很相似，都是数组+链表/红黑树 ； 1.8之前，ConcurrentHashMap是Segement数组 + HashEntry数组 + 链表。</li></ul><h5 id="7-4-（阿里·淘特）ConcurrentHashMap1-8为什么不使用分段锁？">7.4 （阿里·淘特）ConcurrentHashMap1.8为什么不使用分段锁？</h5><p>先说分段锁的优点：</p><ol><li>保证在<strong>操作不同段 map</strong> 的时候<strong>可以并发执行</strong>；操作<strong>同段 map</strong> 的时候，进行<strong>锁的竞争和等待</strong>。这相<strong>对于直接对整个map同步synchronized</strong>是有优势的。</li></ol><p>但是分段锁也有一些不可忽视的缺点：</p><ol><li>分成很多段时会比较<strong>浪费内存空间</strong>(不连续，碎片化)；</li><li>**操作map时竞争同一个分段锁的概率非常小（段散列比较好的时候）**时，分段锁反而会造成更新等操作的长时间等待；</li><li>当某个段很大时，分段锁的性能会下降。</li></ol><p>综上考虑1.8不再使用分段锁。</p><h5 id="7-5-为什么1-8中-get-方法不加锁？">7.5 为什么1.8中 get() 方法不加锁？</h5><p>因为链表每个节点的val和next都使用volatile修饰，保证了可见性。</p><h5 id="7-6-为什么1-8不使用lock而是使用sync？">7.6 为什么1.8不使用lock而是使用sync？</h5><ol><li>因为sync加入锁升级机制（jdk1.6之后），已经优化的不错了；</li><li>lock通过reentranclock实现，reentranlock是通过AQS实现，需要增加额外内存开销（CLH双向队列）。</li></ol><h4 id="8-HashMap-和-HashSet区别-？">8. HashMap <strong>和</strong> HashSet<strong>区别</strong> ？</h4><blockquote><p>如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了clone() 、 writeObject() 、 readObject() 是 HashSet ⾃⼰不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p></blockquote><table><thead><tr><th style="text-align:center"><strong>HashMap</strong></th><th style="text-align:center"><strong>HashSet</strong></th></tr></thead><tbody><tr><td style="text-align:center">实现了Map接⼝</td><td style="text-align:center">实现Set接⼝</td></tr><tr><td style="text-align:center">存储键值对</td><td style="text-align:center">仅存储对象</td></tr><tr><td style="text-align:center">调⽤ <code>put()</code> 向map中添加元素</td><td style="text-align:center">调⽤ <code>add()</code> ⽅法向Set中添加元素</td></tr><tr><td style="text-align:center">HashMap使⽤键（Key）计算Hashcode：<code>int hash = hash(key);</code></td><td style="text-align:center">HashSet使⽤成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()⽅法⽤来判断对象的相等性。</td></tr></tbody></table><h4 id="9-说说HashSet的基本原理？">9. 说说HashSet的基本原理？</h4><ul><li><p><strong>底层结构</strong></p><p><code>HashSet</code>底层原理完全就是包装了一下<code>HashMap</code> ，只不过存储的时候<code>value</code>是默认存储了一个<code>Object</code>的静态常量，取的时候也是只返回<code>key</code>，所以看起来就像<code>List</code>一样。</p></li><li><p><strong>初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>add()方法</strong></p><p>可以看到这三个方法都是直接调用的<code>HashMap</code>的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>add其实就是调用HashMap的put方法，那么如何保证<strong>唯一性</strong>？</p></blockquote><p><strong>如果<code>哈希值</code>和<code>key</code>都一样</strong>，就会直接拿新值<strong>覆盖旧值</strong>，而<code>HashSet</code>就是利用这个特性来保证唯一性。</p><p>其实和HashMap就是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br></pre></td></tr></table></figure></li><li><p><strong>contains方法</strong>（<s>Get()方法</s> ）</p><p><strong>hashset没有get方法</strong>，因为没有意义：不需要获取某个键值对应的value。</p><p>具体实现直接调用hashmap的containsKey()方法：</p><blockquote><p>过程和hashmap的get方法过程差不多，返回为null则是不存在。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="9-1-HashSet如何检查重复-？">9. 1 HashSet<strong>如何检查重复</strong> ？</h5><ol><li>把对象加⼊ HashSet 时，HashSet先计算对象的hashcode 值；</li><li>根据hashcode值计算出要加⼊的位置，同时也会与其他加⼊的对象的hashcode值作⽐教；</li><li>如果没有相符的hashcode，HashSet会假设对象没有重复出现；</li><li><strong>如果发现有相同hashcode值的对象，这时会调用 equals()</strong> 方法来检查hashcode相等的对象是否真的相同，如果两者相同，HashSet就不会让加⼊操作成功。</li></ol><h5 id="9-2-【新】contains-方法在HashSet和ArrayList的实现区别？">9.2 【新】contains()方法在HashSet和ArrayList的实现区别？</h5><ul><li><p><strong>Arraylist</strong></p><p>因为底层是object数组，判断某个对象是否存在，其实是通过遍历来进行判断的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;<span class="comment">//#1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回指定元素在列表中第一次出现的索引，如果该列表不包含该元素，则返回-1。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Hashset</strong></p><p>Hashset是<strong>hash值 &amp;&amp; 遍历链表equals()</strong> 都相等，来判断的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-comparable-和-Comparator-的区别-？">10. comparable <strong>和</strong> Comparator**的区别 **？</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/xujian2014/p/5215082.html">https://www.cnblogs.com/xujian2014/p/5215082.html</a></p></blockquote><ul><li><p>Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。</p><blockquote><p>例如Person类，实现Comparable接口，使得所有Person类对象可以按照各自年龄大小进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.age-p.getAge();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p><blockquote><p>Person类没有实现Comparable接口，该如何比较大小呢？我们可以新建一个类，让其实现Comparator接口，从而构造一个“比较器&quot;。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。。</p></li></ul><h4 id="11-如何选用集合">11.  <strong>如何选用集合</strong>?</h4><p><img src="https://img-blog.csdn.net/20140630092900390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaml1cWl5dWxpYW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p><strong>需要存储键值对</strong>：</p><ul><li><strong>Map接口的集合</strong><ul><li>需要排序时选择TreeMap</li><li>不需要排序时就选择HashMap</li><li>需要保证线程安全就选⽤ConcurrentHashMap</li></ul></li></ul><p><strong>只需要存储元素，实现collection接口的集合，又分为：</strong></p><ul><li><strong>需要保证元素唯一–Set接口的集合</strong><ul><li>HashSet</li></ul></li><li><strong>不需要元素唯一–List接口结合</strong><ul><li>查找比较多：ArrayList</li><li>增删比较多：LinkedList</li></ul></li></ul><h3 id="1-3-3-List">1.3.3 <strong>List</strong></h3><h4 id="1-用过-ArrayList-吗？说一下它有什么特点？">1. <strong>用过 ArrayList 吗？说一下它有什么特点？</strong></h4><ul><li><strong>自动扩容：</strong> 当加入数据达到一定程度后，会实行自动扩容，即扩大数组大小 ；</li><li><strong>底层实现：</strong> <strong>底层是使用数组实现</strong> <strong>，add(int,o)，添加到某个位置，那么可能会挪动大量的数组元素，并且可能会触发扩容机制</strong>；</li><li><strong>线程不安全</strong></li></ul><h4 id="2-ArrayList-与-Vector-区别呢-为什么要用Arraylist取代Vector呢？">2. ArrayList <strong>与</strong> Vector <strong>区别呢</strong>?<strong>为什么要用</strong>Arraylist<strong>取代</strong>Vector<strong>呢？</strong></h4><ul><li><p><strong>线程安全：</strong> Vector线程安全，ArrayList 不是；</p></li><li><p>**Vector耗时：**Vector 类的所有方法都是同步的。可以由两个线程安全地访问⼀个Vector对象、但是⼀个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p></li></ul><h4 id="3-Array-ArrayList不同点">3. Array &amp; ArrayList不同点?</h4><ol><li><strong>Array可以包含基本类型和对象类型</strong>，<strong>ArrayList只能包含对象类型</strong> ；</li><li>Array大小是固定的，ArrayList的大小是 <u>动态变化</u> 的 ；</li><li>ArrayList提供了更多的方法和特性: addAll()，removeAll()，iterator()。</li></ol><h4 id="4-Arraylist-与-LinkedList-区别">4. Arraylist <strong>与</strong> LinkedList <strong>区别</strong>?</h4><ul><li><p>**索引/插入：**ArrayList按序号索引，索引快插入慢；LinkedList不是，索引慢，插入快；</p></li><li><p><strong>内存方面：</strong> Arraylist 是线性连续存储， 内存利用更低；LinkedList 是链表，内存利用更高（将内存零散空间串联），但也更占有内存（每个节点存储了两个引用）；</p></li><li><p><strong>线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是<strong>都不</strong>保证线程安全；</p></li><li><p><strong>底层数据结构：</strong> Arraylist 底层使用的是 <strong>Object</strong> <strong>数组</strong>； LinkedList  底层使用的是 <strong>双向链表</strong> 数据结构 ；</p></li></ul><blockquote><p>JDK1.6之前为循环链表，JDK1.7取消了循环。</p></blockquote><h4 id="5-【-u-源码解读-u-】说说ArrayList的扩容机制吧-？为什么是扩容1-5倍？默认大小是多少。">5. 【<u>源码解读</u>】说说ArrayList的扩容机制吧 ？为什么是扩容1.5倍？默认大小是多少。</h4><blockquote><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81%2B%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90.md">逐源码分析扩容机制</a></p></blockquote><p>先把回答写在下面：</p><blockquote><p><strong>ArrayList/vector默认大小都是10，但vectot扩容是2倍。</strong></p></blockquote><p><strong>1. 扩容机制：</strong></p><p>使用无参构造函数创建的数组长度为0，当第一次add后数组长度为10 ； 如果继续add超过10后，也就是不满足**<code>minCapacity（最小需要容量） - elementData.length &gt; 0</code>** 会触发扩容机制。 将新容量更新为旧容量的1.5倍 ，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】。</p><p>最后检查设置的新容量是否大于最大容量MAX_ARRAY_SIZE ，进入<code>hugeCapacity()</code> :</p><ul><li>如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code> 。</li></ul><p><strong>2. 为什么是1.5倍？</strong></p><p>因为，<strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)，所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同。</p><p>比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数。</p><ul><li><p><strong>ArrayList总览</strong></p><p><code>ArrayList</code>继承于 <strong><code>AbstractList</code></strong> ，实现了 <strong><code>List</code></strong>, <strong><code>RandomAccess</code></strong>, <strong><code>Cloneable</code></strong>, <strong><code>java.io.Serializable</code></strong> 这些接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问；</li><li><code>ArrayList</code> 实现了 <strong><code>Cloneable</code> 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆；</li><li><code>ArrayList</code> 实现了 <code>java.io.Serializable </code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li></ul></li><li><p><strong>ArrayList 核心源码解读（先耐心看一遍）</strong></p><p>直接点击上面链接 <a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81%2B%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90.md">逐源码分析扩容机制</a> 查看。</p></li><li><p><strong>【重点】JDK8 <u>扩容机制</u> 解读</strong></p><ol><li><p><strong>从构造函数说起</strong></p><p>（JDK8）ArrayList 有三种方式来初始化 :</p><ul><li>以<strong>无参数构造方法</strong>创建 ArrayList 时，实际上初始化赋值的是一个<strong>空数组</strong>。<u>当真正对数组进行添加元素操作时，才真正分配容量</u>。即向数组中添加第一个元素时，数组容量扩为 10。</li><li>jdk8中的ArrayList的对象的创建<strong>类似于单例的懒汉式</strong>。JDK8的内存优化也值得我们在平时开发中学习。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 默认初始容量大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 空数组（用于空实例）。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">     </span><br><span class="line">  <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">   <span class="comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 保存ArrayList数据的数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * ArrayList 所包含的元素个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment"> /**</span></span><br><span class="line"><span class="comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">         <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">         <span class="comment">//创建空数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">     elementData = c.toArray();</span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// replace with empty array.</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>再看<code>add</code>方法</strong></p><blockquote><p>这里<u>以无参构造函数创建的 ArrayList</u> 为例分析 。</p></blockquote><blockquote><p>JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">      ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">      <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">      elementData[size++] = e;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>再看 <code>ensureCapacityInternal()</code> 方法</strong></p><p>第2步（JDK7）可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code> 。</p><ul><li><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></li><li>然后开始调用 <code>ensureExplicitCapacity()</code> 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">          minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">      ensureExplicitCapacity(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>调用 <code>ensureCapacityInternal()</code> 进入<code>ensureExplicitCapacity()</code>这个方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们来仔细分析一下：</p><ul><li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，<strong>所以 minCapacity 此时为 10</strong>。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li><li>当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>添加第 3、4···到第 9 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li></ul><p>直到添加第 10 个元素，<code>minCapacity &lt; elementData.length</code><strong>不成立</strong>。进入 grow 方法进行扩容。</p></li><li><p><strong>elementData.length（实际容量）&gt;= minCapacity（最小需要容量）  , 执行 grow()</strong></p><blockquote><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数。</p></blockquote><p>将新容量更新为旧容量的1.5倍 ，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】。</p><ul><li>最后检查设置的新容量是否大于最大容量MAX_ARRAY_SIZE ，进入<code>hugeCapacity()</code> :<ul><li>如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code> 。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">     </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ArrayList扩容的核心方法grow。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">       <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】，</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">      <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">      <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br></pre></td></tr></table></figure></li><li><p><strong>设置完新容量 newCapacity ，进行<code>Arrays.copyOf</code></strong></p><p>Arrays的copyOf()方法传回的数组是新的数组对象，改变传回数组中的元素值，不会影响原来的数组。</p><ul><li><u>第二个自变量指定要建立的新数组长度</u>，如果新数组的长度超过原数组的长度，则保留数组默认值，例如：</li></ul><p>使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容。</p></li></ol></li><li><p><strong>contains()方法</strong></p><p>就是遍历数组看是否存在该元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;<span class="comment">//#1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回指定元素在列表中第一次出现的索引，如果该列表不包含该元素，则返回-1。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="5-1-多线程操作ArrayList会出现什么错误？">5.1 多线程操作ArrayList会出现什么错误？</h5><p>从ArrayList的（1）添加元素（<code>add</code>/<code>addAll</code>）和（2）获取元素（<code>get</code>）  两个角度来说：</p><ol><li><p><strong>多线程添加元素</strong></p><p>假设此时<code>minCapacity（最小需要容量）= 10</code> ，此时数组容量是10。A,B两个线程各需要添加若干元素，<strong>同时</strong> 判断此时不需要扩容，后续可能就会发生<strong>数组越界</strong>。</p></li><li><p><strong>多线程获取元素</strong></p><p>一个线程正在修改某个元素，另外一个线程此时正在读，那么读到的就是修改前的元素，也就是<strong>脏数据</strong>。</p></li></ol><h4 id="6-说一下LinkedList底层原理？">6. 说一下LinkedList底层原理？</h4><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000021433760">Java集合系列之三：LinkedList底层原理</a></p></blockquote><p>LinkedList实现了<strong>List</strong>接口和<strong>Deque</strong>接口的，底层的<strong>双端链表</strong>结构使它支持高效的插入和删除操作，<u>也具有队列的特性</u>，非线程安全的。</p><p><img src="https://upload-images.jianshu.io/upload_images/2192701-9c26f117619ad840.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/919/format/webp" alt="img"></p><blockquote><p>相比ArrayList要简单很多，主要是双向链表那些操作。</p></blockquote><ul><li><p><strong>底层结构</strong></p><p>核心属性、构造方法和Node定义如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;<span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;   <span class="comment">//LinkedList中存放的元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;  <span class="comment">//头节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;   <span class="comment">//尾节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，创建一个空的列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个指定的集合添加到LinkedList中，先完成初始化，在调用添加操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span>     </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node节点    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     E item;</span><br><span class="line">     Node&lt;E&gt; next;</span><br><span class="line">     Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">     Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">         <span class="keyword">this</span>.item = element;</span><br><span class="line">         <span class="keyword">this</span>.next = next;</span><br><span class="line">         <span class="keyword">this</span>.prev = prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>add() 方法</strong></p><p>**朴实无华的双向链表尾插法。**获得当前最后一个节点最为当前节点的前置节点，同样把当前节点设置为前置节点的后置节点，然后把当前节点作为最后一个节点，因为只需要创建一个节点与前一个节点建立前后关系即可，时间复杂度是O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得当前最后一个节点作为前置节点，可能为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 初始化当前节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 把当前节点作为最后的节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 第一次添加设置为第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 把当前节点设置为前置节点的后置节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>add(int index,E e)</strong></p><p>按索引插入元素，首先判断是不是第一个添加的元素，如果是的话，直接使用add()方法添加就可以了，如果不是则需要根据索引来遍历寻找链表上对应位置。</p><ul><li>这里用了个小技巧，<strong>判断索引是在前半段还是在后半段</strong>，从短的那头开始遍历，找到之后，新建一个节点，建立新的前置节点和后置节点的关系。时间复杂度是O(n)，n为size/2。</li></ul></li><li><p><strong>get(int index)方法</strong></p><p>get()方法是用的上面介绍过的node()方法，时间复杂度是O(n)，n为size/2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 判断数组越界</span></span><br><span class="line">     checkElementIndex(index);</span><br><span class="line">     <span class="comment">// 遍历寻找节点</span></span><br><span class="line">     <span class="keyword">return</span> node(index).item;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得被插入索引上的元素</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"><span class="comment">// 如果索引是在链表的前半段</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="comment">// 获得第一个节点</span></span><br><span class="line">    Node&lt;E&gt; x = first;</span><br><span class="line">    <span class="comment">// 往后找到插入索引位置上的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        x = x.next;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果索引是在链表的前半段</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获得最后个节点</span></span><br><span class="line">    Node&lt;E&gt; x = last;</span><br><span class="line">    <span class="comment">// 往前找到插入索引位置上的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">        x = x.prev;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-4-迭代器">1.3.4 迭代器</h3><h4 id="1-请简单说明一下什么是迭代器？">1. <strong>请简单说明一下什么是迭代器？</strong></h4><p>Iterator提供了统一遍历操作集合元素的统一接口, <strong>Collection接口实现Iterable接口</strong>。</p><ul><li>每个集合<strong>都通过实现Iterable接口中iterator()方法</strong>返回Iterator接口的实例, 然后对集合的元素进行迭代操作；</li><li>在<u><strong>迭代元素的时候不能通过集合的方法删除元素</strong></u>, 否则会抛出ConcurrentModificationException 异常. 但是可以通过Iterator接口中的remove()方法进行删除。</li></ul><h4 id="2-请你说说Iterator和ListIterator的区别？">2. <strong>请你说说Iterator和ListIterator的区别？</strong></h4><ul><li><strong>遍历类型：</strong><code>Iterator</code>可用来遍历Set和List集合，但是<code>ListIterator</code>只能用来遍历List；</li><li><strong>遍历方向：</strong><code>Iterator</code>对集合只能是前向遍历，<code>ListIterator</code>既可以前向也可以后向；</li><li><strong>功能区别：</strong><code>ListIterator</code>实现了Iterator接口，并包含其他的功能</li></ul><h2 id="1-4-多线程">1.4 多线程</h2><h4 id="0-三个线程，如何让他们按顺序打印A、B、C？如果是循环打印10次呢？依次打印1-100呢？交替打印奇偶10次呢？">0. <strong>三个线程，如何让他们按顺序打印A、B、C？如果是循环打印10次呢？依次打印1~100呢？交替打印奇偶10次呢？</strong></h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/370130458">https://zhuanlan.zhihu.com/p/370130458</a></p></blockquote><h5 id="0-1-synchronized-条件变量">0.1 <strong>synchronized + 条件变量</strong></h5><ol><li><p><strong>synchronized + 条件变量</strong>（循环打印1次）</p><p>思路如下：</p><ul><li>新建三个线程1、2、3 ，分别负责打印A、B、C；同时，每个线程对应一个条件变量：<code>num%3==当前线程条件变量?</code> ；</li><li>把打印的代码用synchronized 加锁，每个线程拿到锁后，<strong>while循环判断</strong>是否满足当前线程的条件变量 ；</li><li><strong>如果满足</strong> ，便执行后续逻辑打印当前线程，之后<strong>notifyall()唤醒其它线程</strong>；</li><li><strong>如果不满足</strong>，执行wait等待释放锁；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wait_Notify_ACB</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">// targetNum ： 每个线程应该满足的对应条件变量</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) </span><br><span class="line">                &#123;   <span class="comment">// while ：线程阻塞在wait(),再次被唤醒应该先检查下是否满足条件，因为这个时候未必轮到当前线程执行；用if会导致直接往下执行。</span></span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Wait_Notify_ACB  wait_notify_acb = <span class="keyword">new</span> Wait_Notify_ACB ();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>synchronized + 条件变量</strong>（循环打印10次）</p><p>打印10次，只需让三个线程，尝试去竞争10次锁即可。所以在<strong>synchronized前加上for循环</strong>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wait_Notify_ACB</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">// targetNum ： 每个线程应该满足的对应条件变量</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">10</span> ;i++)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) </span><br><span class="line">                &#123;   <span class="comment">// while ：线程阻塞在wait(),再次被唤醒应该先检查下是否满足条件，因为这个时候未必轮到当前线程执行；用if会导致直接往下执行。</span></span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Wait_Notify_ACB  wait_notify_acb = <span class="keyword">new</span> Wait_Notify_ACB ();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>synchronized + 条件变量</strong>（打印1~100)</p><p>设置一个全局变量，synchronized 中加锁函数对num+1，保证只要每次只有一个线程能执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wait_Notify_100</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxnum = <span class="number">10</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) &#123; <span class="comment">//想想这里为什么不能用if代替，想不起来可以看公众号上一篇文章</span></span><br><span class="line">                    <span class="keyword">if</span>(num &gt;= maxnum)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(num &gt;= maxnum)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + num);</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wait_Notify_100  wait_notify_100 = <span class="keyword">new</span> Wait_Notify_100 ();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread3&quot;</span>).start();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>synchronized + 条件变量</strong>（奇偶打印10次）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Wait_Notify_Odd_Even</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object monitor = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line">    Wait_Notify_Odd_Even(<span class="keyword">int</span> initCount) &#123;</span><br><span class="line">        <span class="keyword">this</span>.count = initCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printOddEven</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> <span class="comment">// 这里不用while循环判断，是因为下次notifyAll的一定是奇数或偶数</span></span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print( Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span>);</span><br><span class="line">                    System.out.println(++count);</span><br><span class="line">                    monitor.notifyAll();</span><br><span class="line">                    monitor.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//防止count=10后，while()循环不再执行，有子线程被阻塞未被唤醒，导致主线程不能退出</span></span><br><span class="line">            monitor.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Wait_Notify_Odd_Even waitNotifyOddEven = <span class="keyword">new</span> Wait_Notify_Odd_Even(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(waitNotifyOddEven::printOddEven, <span class="string">&quot;odd&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>); <span class="comment">//为了保证线程odd先拿到锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread(waitNotifyOddEven::printOddEven, <span class="string">&quot;even&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="0-2-join">0.2 join</h5><p><code>join()</code>方法：<strong>在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行</strong>。</p><p>基于这个原理，我们使得三个线程按顺序执行，然后循环多次即可。无论线程1、线程2、线程3哪个先执行，最后执行的顺序都是线程1——&gt;线程2——&gt;线程3。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Join_ABC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> printABC(<span class="keyword">null</span>),<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> printABC(t1),<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> printABC(t2),<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t3.start();</span><br><span class="line">            Thread.sleep(<span class="number">10</span>); <span class="comment">//这里是要保证只有t1、t2、t3为一组，进行执行才能保证t1-&gt;t2-&gt;t3的执行顺序。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">printABC</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread beforeThread;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">printABC</span><span class="params">(Thread beforeThread)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.beforeThread = beforeThread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(beforeThread!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeThread.join(); </span><br><span class="line">                    System.out.print(Thread.currentThread().getName());</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="0-3-Lock">0.3 Lock</h5><p>该方法很容易理解，不管哪个线程拿到锁，<strong>只有符合条件的才能打印</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Lock_ABC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;   <span class="comment">// 当前状态值：保证三个线程之间交替打印</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">3</span> == targetNum) &#123;</span><br><span class="line">                num++;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock(); <span class="comment">// 不符合要求直接释放锁，不会像sync一样阻塞在sync或wait处</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock_ABC lockABC = <span class="keyword">new</span> Lock_ABC();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="0-4-Semaphore">0.4 <strong>Semaphore</strong></h5><p>Semaphore：用来控制同时访问某个特定资源的操作数量，或者同时执行某个制定操作的数量。Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。</p><ul><li>一个线程要访问共享资源，先使用<code>acquire()</code>方法获得信号量，如果信号量的计数器值大于等于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。如果计数器值为0,线程进入休眠；</li><li>当某个线程使用完共享资源后，使用<code>release()</code>释放信号量，<strong>并将信号量内部的计数器加1</strong>，之前进入休眠的线程将被唤醒并再次试图获得信号量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SemaphoreABC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s1 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>); <span class="comment">//因为先执行线程A，所以这里设s1的计数器为1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s2 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s3 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(Semaphore currentThread, Semaphore nextThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentThread.acquire();       <span class="comment">//阻塞当前线程，即信号量的计数器减1为0</span></span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                nextThread.release();          <span class="comment">//唤醒下一个线程，即信号量的计数器加1</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SemaphoreABC printer = <span class="keyword">new</span> SemaphoreABC();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s1, s2);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s2, s3);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s3, s1);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-1-线程基本">1.4.1 线程基本</h3><h4 id="1-什么是线程和进程？-如何保证线程安全？">1. 什么是线程和进程？ <strong>如何保证线程安全？</strong></h4><h5 id="1-1-什么是线程和进程？">1.1 什么是线程和进程？</h5><ul><li><p><strong>什么是进程？</strong></p><p><strong>进程是程序的⼀次执行过程，是系统运行程序的基本单位</strong>，因此进程是<strong>动态</strong>的。系统运行⼀个程序即是⼀个进程从创建，运行到消亡的过程。</p><blockquote><p>如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe ⽂件的运行）。在Windows操作系统中，一个程序只对应一个进程，里面可以有一个或多个线程。</p><p><img src="https://i.loli.net/2021/05/16/cxYPKI1LnR4V3Mt.png" alt="image-20210516101110229"></p></blockquote></li><li><p><strong>什么是线程？</strong></p><p><strong>线程与进程相似，但线程是⼀个⽐进程更小的执行单位</strong>。⼀个进程在其执行的过程中可以产⽣多个线程。</p><ul><li>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有⾃⼰的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></li></ul><p>所以系统在产⽣⼀个线程，或是在各个线程之间作<u>切换⼯作</u>时，<strong>负担要⽐进程小得多</strong>，也正因为如此，线程也被称为轻量级进程。</p><blockquote><p>⼀个 Java 程序的运行是 main 线程和多个其他线程同时运行。</p></blockquote></li></ul><h5 id="1-2-如何保证线程安全？">1.2 如何保证线程安全？</h5><ol><li><strong>原子性</strong>，简单说就是<u>相关操作不会中途被其他线程干扰，一般通过同步机制实现</u>；</li><li><strong>可见性</strong>，<u>是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓</u>，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的；</li><li><strong>有序性</strong>，<u>是保证线程内串行语义，避免指令重排</u>等。</li></ol><h5 id="1-3-为什么-程序计数器、-虚拟机栈和本地方法栈是-u-线程-u-私有的">1.3 为什么**程序计数器、**虚拟机栈和本地方法栈是<u>线程</u>私有的?</h5><ul><li><p><strong>程序计数器为什么是私有</strong></p><p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪⼉了。</p><p>所以，程序计数器<u>私有</u>主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p></li><li><p><strong>虚拟机栈和本地方法栈为什么私有</strong></p><ul><li><p><strong>虚拟机栈：</strong> <u>每个 Java 方法在执行的同时会创建⼀个栈帧用于存储局部变量表、操作数栈、常量池引用等信息</u>。从方法调用直⾄执行完成的过程，就对应着⼀个栈帧在 Java 虚拟机栈中<strong>⼊栈和出栈</strong>的过程。</p></li><li><p><strong>本地方法法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行</strong> <strong>Java</strong> 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 <strong>Native</strong> <strong>方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合⼆为⼀。</p></li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p></li></ul><h4 id="2-创建线程的方式（非线程池）？-哪种最好？">2. <strong>创建线程的方式（非线程池）？ 哪种最好？</strong></h4><p>一般有三种方式来进行创建：</p><ol><li><p><strong>继承Thread类：</strong>（1）定义Thread类的子类，并重写该类的run方法（2）创建Thread子类的实例对象 （3）调用对象start()方法</p><blockquote><ul><li>优点：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用this即可获取当前线程；</li><li>缺点：因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了。</li></ul></blockquote></li><li><p><strong>实现Runnable接口：</strong>（1）定义runnable接口的<strong>实现类</strong>，并重写该接口的run()方法 （2）创建实现类的实例对象（3）调用线程对象的start()方法来启动该线程</p></li><li><p><strong>通过Callable和Future创建线程：</strong>（1）创建Callable接口的实现类，<strong>并实现call()方法</strong>（2）创建Callable实现类的实例，并使用FutureTask类来包装Callable对象（3）使用FutureTask对象作为Thread对象的target创建并启动新线程（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p></li></ol><p>其中 <u>实现Runnalbe接口更好</u>  ，使用实现Runnable接口的方式创建的线程<strong>可以处理同一资源</strong>，从而实现资源的共享。</p><h4 id="3-如何停止一个正在运行的线程？">3. <strong>如何停止一个正在运行的线程？</strong></h4><ol><li><p>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止；</p></li><li><p>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法；</p></li><li><p>使用interrupt方法中断线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">     <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">           sleep(<span class="number">1000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;week up from blcok...&quot;</span>);</span><br><span class="line">            stop = <span class="keyword">true</span>; <span class="comment">// 在异常处理代码中修改共享变量的状态</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    System.out.println(getName() + <span class="string">&quot; is exiting...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterruptThreadDemo3</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>          InterruptedException </span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">          MyThread m1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">          System.out.println(<span class="string">&quot;Starting thread...&quot;</span>);</span><br><span class="line">          m1.start();</span><br><span class="line">          Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;Interrupt thread...: &quot;</span> +           m1.getName());</span><br><span class="line">          m1.stop = <span class="keyword">true</span>; <span class="comment">// 设置共享变量为true</span></span><br><span class="line">          m1.interrupt(); <span class="comment">// 阻塞时退出阻塞状态</span></span><br><span class="line">          Thread.sleep(<span class="number">3000</span>); <span class="comment">// 主线程休眠3秒以便观察线程m1的中断情况</span></span><br><span class="line">          System.out.println(<span class="string">&quot;Stopping application...&quot;</span>);</span><br><span class="line">       &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-什么是Daemon线程？它有什么意义？">4. <strong>什么是Daemon线程？它有什么意义？</strong></h4><p>所谓后台(daemon)线程，也叫守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。</p><ul><li>**意义：**JVM的垃圾回收线程就是Daemon线程，Finalizer也是守护线程。</li></ul><h4 id="5-说说CyclicBarrier和CountDownLatch的区别？">5. <strong>说说CyclicBarrier和CountDownLatch的区别？</strong></h4><p>两个看上去有点像的类，都在<code>java.util.concurrent</code>下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><ol><li>CyclicBarrier的某个线程运行到某个点上之后，<strong>该线程即停止运行</strong>，<strong>直到所有的线程都到达了这个点</strong>，所有线程才重新运行CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值**-1**而已，该线程继续运行；</li><li>CyclicBarrier<strong>只能唤起一个任务</strong>，CountDownLatch可以唤起多个任务</li><li>CyclicBarrier可重用，<strong>CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</strong></li></ol><h4 id="6-请你简要说明一下线程的基本状态以及状态之间的关系？">6. <strong>请你简要说明一下线程的基本状态以及状态之间的关系？</strong></h4><p><img src="https://i.loli.net/2021/04/28/VCN8xckXHMdrl1R.png" alt="image-20210428164922743"></p><ol><li><strong>新建状态</strong>：<strong>new语</strong>句创建的线程对象处于新建状态，仅被<strong>分配了内存</strong></li><li><strong>等待状态：</strong> 当线程在new之后，并且<u>在调用start方法前</u>，线程处于等待状态 ;</li><li><strong>就绪状态：</strong> 其他线程调用它的**start()**方法，该线程就进入就绪状态，<u>只差等待cpu的使用权 </u> ;</li><li><strong>运行状态：</strong> <u>线程占用CPU，执行程序代码</u>  ;</li><li><strong>阻塞状态：</strong> 阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。<u>阻塞状态分为三种：</u><ul><li><u>等待阻塞:</u> 运行的线程执行**wait()**方法，JVM会把该线程放入等待池中；</li><li><u>同步阻塞:</u> 运行的线程在获取<strong>对象同步锁</strong>时，若该同步锁被别的线程占用，则JVM会把线程放入锁池中；</li><li><u>其他阻塞:</u> 运行的线程执行Sleep()方法，或者发出I/O请求时，JVM会把线程设为阻塞状态。</li></ul></li><li><strong>死亡状态：</strong> 线程执行完<strong>run()方法中的代码</strong>，或者遇到了未捕获的异常，就会退出run()方法，结束生命周期</li></ol><h4 id="7-notify-和notifyAll-有什么区别？">7. <strong>notify()和notifyAll()有什么区别？</strong></h4><ul><li><strong>notify可能会导致死锁（why？）</strong>，而notifyAll则不会；</li><li>使用notifyall,可以唤醒 所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。</li></ul><h4 id="8-sleep-和wait-有什么区别？">8. <strong>sleep()和wait() 有什么区别？</strong></h4><ul><li><p>**继承的类：**sleep()方法，我们首先要知道该方法是属于Thread类中的；而wait()方法，则是属于Object类中的；</p><blockquote><p><em>sleep()</em> 是 <em>Thread</em> 类静态方法，可以使 <u>当前</u> 线程阻塞，并指定暂停时间，重点在于理解 <u>当前</u>。休眠时间期满后，该线程不一定会立即执行被CPU调度，只是到了就绪状态。</p></blockquote></li><li><p>**是否释放锁：**sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。<strong>在调用sleep()方法的过程中，线程不会释放对象锁；当调用wait()方法的时候，线程会放弃对象锁</strong>，进入等待此对象的等待锁定池；</p></li><li><p><strong>用处：</strong> <strong>Wait 通常被用于线程间交互/通信</strong>，sleep 通常被用于暂停执行；</p></li><li><p><strong>再次唤醒：</strong> wait() 方法被调用后，线程不会⾃动苏醒，需要别的线程调用同⼀个对象上的 notify() 或者notifyAll() 方法。sleep() 方法执行完成后，线程会⾃动苏醒。</p></li></ul><h5 id="8-1-Thread类中的yield方法有什么作用？">8.1 <strong>Thread类中的yield方法有什么作用？</strong></h5><p><em>yield()</em> 也是 <em>Thread</em> 类静态方法，<strong>使当前线程变为<u>就绪状态</u></strong> （<em>sleep()</em> 是阻塞），使得其他线程更多机会获取CPU。执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p><h5 id="8-2-java-中Wait、Sleep和Yield方法的区别？">8.2 <strong>java 中Wait、Sleep和Yield方法的区别？</strong></h5><p><a href="https://www.jianshu.com/p/25e959037eed">https://www.jianshu.com/p/25e959037eed</a></p><h4 id="9-volatile-是什么-可以保证有序性吗">9. <strong>volatile 是什么?可以保证有序性吗?</strong></h4><ol><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存；</li><li>禁止进行指令重排序。</li></ol><p><strong>能保证有序性</strong>，因为禁止指令重排。</p><h4 id="10-（要深入了解wait方法，这里先跳过）为什么wait-notify-和-notifyAll这些方法不在thread类里面？">10. （要深入了解wait方法，这里先跳过）<strong>为什么wait, notify 和 notifyAll这些方法不在thread类里面？</strong></h4><p><a href="https://www.zhihu.com/question/321674476">https://www.zhihu.com/question/321674476</a></p><p>明显的原因是<strong>JAVA提供的锁是对象级的而不是线程级的</strong>，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。<u>如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了</u>。</p><ul><li>简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</li></ul><h4 id="11-为什么wait和notify方法要在同步块中调用？">11. <strong>为什么wait和notify方法要在同步块中调用？</strong></h4><ul><li><u>wait()方法<strong>强制当前线程释放对象锁</strong></u>。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法；</li><li>在调用对象的notify()和notifyAll()方法之前，<u>调用线程必须<strong>已经得到该对象的锁</strong></u>。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。</li></ul><h4 id="12-（没细看）Java中interrupted-和-isInterruptedd方法的区别？">12. （没细看）<strong>Java中interrupted 和 isInterruptedd方法的区别？</strong></h4><p>interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法。</p><h3 id="1-4-2-线程池">1.4.2 线程池</h3><h4 id="1-请你解释一下什么是线程池（thread-pool）？">1. <strong>请你解释一下什么是线程池（thread pool）？</strong></h4><p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，<u>使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销</u>。 除此之外：</p><ul><li>提高性能，利用多线程压榨CPU算力；</li><li>提高线程的可管理性，限制线程数量并可以进行统一的分配、调优和监控。</li></ul><h5 id="1-1-请介绍一下使用线程池任务执行过程？"><strong>1.1 请介绍一下使用线程池任务执行过程？</strong></h5><p>**核心参数：**其中<code>corePool</code>是核心线程池（保活线程），<code>maximumPool</code>是总线程池（保活线程+工作线程），<code>blockQueue </code>是等待任务队列，<code>rejectedExecutionHandler</code>是拒绝策略：</p><p><img src="https://i.loli.net/2021/04/19/Pn4wc5621hqIXpl.png" alt="image-20210419235537833" style="zoom: 33%;" /><img src="https://segmentfault.com/img/remote/1460000038860133" alt="iShot2021-01-03 20.18.23.png" style="zoom: 67%;" /></p><p><strong>流程：corePoolSize→队列→maximumPool→拒绝策略</strong></p><ol><li>未达到corePoolSize时，核心线程池会开辟新线程运行任务（<u>可以使用已有线程吗？</u>），<strong>任务结束后线程不销毁</strong>；</li><li>达到corePoolSize，而任务队列未满时，新任务提交到等待队列，<strong>线程空闲时间超过keepAliveTime时被销毁；</strong></li><li>任务队列也满了，但未超过最大线程数，新建工作线程执行任务；</li><li>超过最大线程数时，<strong>按拒绝策略处理</strong>，包括：<u>抛出异常、使用调用者线程运行任务、丢弃新任务、丢弃队列头任务</u>等。</li></ol><h5 id="1-2-线程池会回收核心线程吗？">1.2 线程池会回收核心线程吗？</h5><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000038836285">线程池是怎么回收空闲线程的</a></p></blockquote><p>会，可以通过allowCoreThreadTimeOut参数来进行设置。</p><ul><li><p>先回忆一下整体线程池流程</p><img src="https://segmentfault.com/img/remote/1460000038860133" alt="iShot2021-01-03 20.18.23.png" style="zoom:67%;" /></li><li><p><strong>excute方法</strong></p><p>我们的任务放到线程池后，是从调用execute执行开始的。<br><img src="https://i.loli.net/2021/05/26/hc4w6ZIbm57CpOQ.png" alt="image-20210526234652655" style="zoom: 67%;" /></p><ul><li><p>核心是addWorker办法， 里面最最重要的就是初始化Worker同时启动thread。</p></li><li><p>Worker实现了Runnable接口，我们直接看它的run方法，看截图的③处标记，抽离出来一个runWorker方法：</p><p><img src="https://i.loli.net/2021/05/26/39woAvIR4QjNfxd.png" alt="iShot2021-01-03 20.39.22.png"></p><p>也就是说：①处是一个while循环，<strong>getTask</strong>方法就是从线程池队列取任务，<strong>如果取不到任务</strong>就会执行</p><p>​                   ②<strong>一旦跳出while循环，即进入到processWorkExit方法，这就是回收Worker</strong></p></li></ul></li><li><p><strong>getTask方法</strong></p><p>可以看到，①判断是否回收线程的条件，<strong>timed</strong> ，有两种情况要回收线程：</p><ol><li><strong>wc&gt;corePoolSize</strong> ，当前线程数大于核心线程数</li><li><strong>allowCoreThreadTimeOut</strong>，核心线程超时，所以<strong>核心线程是会被回收</strong>的</li></ol><p>然后②处就是从任务队列取任务了，<strong>带了timeOut参数的poll方法超时</strong> ，未能从任务队列获取任务即返回null，从而实现最终的<strong>线程回收</strong>。</p><blockquote><p>不是processWorkExit处理吗，怎么在getTask处理，还是得好好看看。</p></blockquote><p><img src="https://i.loli.net/2021/05/26/hxJerXAo16msf38.png" alt="image-20210526235850331"></p></li></ul><h4 id="2-请介绍一下什么是生产者消费者模式？">2. <strong>请介绍一下什么是生产者消费者模式？</strong></h4><p><img src="https://uploadfiles.nowcoder.com/images/20180925/308572_1537880635592_7142B8354CA8A352B2B805F997C71549" alt="img"></p><p>生产者消费者问题是线程模型中的经典问题：</p><ul><li>生产者和消费者在<strong>同一时间段内共用同一存储空间</strong>，生产者向空间里生产数据，而消费者取走数据。</li></ul><h4 id="3-线程池的拒绝策略有哪些？">3. <strong>线程池的拒绝策略有哪些？</strong></h4><p>主要有4种拒绝策略：</p><ol><li>AbortPolicy：直接丢弃任务，抛出异常，这是默认策略</li><li><strong>CallerRunsPolicy</strong>：只用调用者所在的线程来处理任务</li><li>DiscardOldestPolicy：<strong>丢弃等待队列中最旧</strong>的任务，并执行当前任务</li><li>DiscardPolicy：直接丢弃任务，也不抛出异常</li></ol><h4 id="4-如何创建一个线程池（四大方法）？相关参数（七大参数）是什么">4. <strong>如何创建一个线程池（四大方法）？相关参数（七大参数）是什么?</strong></h4><p>java通过Executors提供<strong>四大方法</strong>：</p><ol><li>**newCachedThreadPool：**创建一个可缓存线程池，如果线程池长度超过处理需要，<strong>可灵活回收空闲线程，若无可回收，则新建线程</strong>；</li><li>**newFixedThreadPool ：**创建一个定长线程池，<u>可控制线程最大并发数</u>，<strong>超出的线程会在<u>队列中等待</u></strong>；</li><li>**newScheduledThreadPool ：**创建一个定长线程池，<u>支持定时及周期性任务执行</u>；</li><li><strong>newSingleThreadExecutor：</strong> 创建一个<u>单线程化的线程池</u>，它只会用<strong>唯一的工作线程</strong>来执行任务，保证<u>所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</u>。</li></ol><p><strong>七大参数设置：</strong></p><ol><li><p><strong>corePoolSize</strong>：当使用了<code>LinkedBlockingQueue = new LinkedBlockQueue</code>的时候，<strong>队列长度默认无限长</strong>，会导致线程数量永远等于<code>corePoolSize</code>，任务激增时任务响应时间也激增；</p></li><li><p><strong>maximumPoolSize</strong>：线程池中线程个数，增加线程的公式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>任务数</mtext><mo>−</mo><mi>q</mi><mi>u</mi><mi>e</mi><mi>u</mi><mi>e</mi><mi>C</mi><mi>a</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mtext>原线程数</mtext><mo>÷</mo><mtext>原任务数</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(任务数-queueCapacity) \times (原线程数 \div 原任务数)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">任务数</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">原线程数</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">原任务数</span><span class="mclose">)</span></span></span></span>；</p></li><li><p><strong>keepAliveTime</strong>：线程最大（空闲）存活时间；</p></li><li><p><strong>rejectedExecutionHandler</strong>：线程被拒绝的解决方案，可以自己重写；</p></li><li><p><strong>workQueue</strong> ： 阻塞队列；</p></li><li><p>**unit：**keepAliveTime的单位 ；</p></li><li><p>**threadFactory：**表示生成线程池中工作线程的线程工厂，用于创建线程一般默认即可</p></li></ol><h4 id="5-线程池核心线程数corePoolSize怎么设置呢？">5. <strong>线程池核心线程数corePoolSize怎么设置呢？</strong></h4><p>分为CPU密集型和IO密集型来考虑：</p><ul><li><p>**CPU密集型。**这种任务消耗的主要是 CPU 资源，可以将线程数设置为 <code>N（CPU 核心数）+1</code>。</p><blockquote><p><u>比 CPU 核心数多出来的一个线程</u> ：是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p></blockquote></li><li><p>**IO密集型。**这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，<strong>而线程在处理 I/O 的时间段内不会占用 CPU 来处理</strong>，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 ： <code>核心线程数=CPU核心数量*2</code></p></li></ul><h4 id="6-（不熟悉）Java线程池中队列常用类型有哪些？">6. <strong>（不熟悉）Java线程池中队列常用类型有哪些？</strong></h4><ul><li><code>ArrayBlockingQueue</code> ：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序；</li><li><code>LinkedBlockingQueue</code> :一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于 ArrayBlockingQueue ；</li><li><code>SynchronousQueue</code> : 一个不存储元素的阻塞队列；</li><li><code>PriorityBlockingQueue</code>： 一个具有优先级的无限阻塞队列，PriorityBlockingQueue 也是基于最小二叉堆实现。</li></ul><h4 id="7-有三个线程T1-T2-T3-如何保证顺序执行？">7. <strong>有三个线程T1,T2,T3,如何保证顺序执行？</strong></h4><p>因为在每个线程的run方法中用join()方法限定了三个线程的执行顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="comment">// 1.现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() </span><br><span class="line">         &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">               </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         <span class="keyword">final</span> Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// t2线程内run方法最开始，引用t1.join，等待t1线程执行完</span></span><br><span class="line">                   t1.join();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">                   System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// t3线程内run方法最开始，引用t2.join，等待t2线程执行完</span></span><br><span class="line">                        t2.join();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                          &#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                          &#125;</span><br><span class="line">                         System.out.println(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">                         &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//这里三个线程的启动顺序可以任意，大家可以试下！</span></span><br><span class="line">         t3.start();</span><br><span class="line">         t2.start();</span><br><span class="line">         t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-3-多线程">1.4.3 多线程</h3><h4 id="1-请简述一下实现多线程同步的方法？-为什么需要使用多线程？使用多线程会带来什么问题？">1. <strong>请简述一下实现多线程同步的方法？</strong> 为什么需要使用多线程？使用多线程会带来什么问题？</h4><ul><li><p>**同步方法：**可以使用synchronized、lock、volatile和ThreadLocal来实现同步。</p></li><li><p><strong>为什么需要使用多线程？</strong></p><ul><li>减少<strong>上下文切换开销</strong>（共享进程的堆和方法区 ，注意，减少≠没有）</li><li>利用好多线程机制可以大大提<strong>高系统整体的并发能⼒</strong>以及性能</li><li><strong>多核时代</strong> ：多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算⼀个复杂的任务，我们只用⼀个线程的话，CPU <strong>只会⼀个 CPU 核⼼</strong>被利用到，而创建多个线程就可以让多个 CPU 核⼼被利用到，这样就提高了 CPU 的利用率。****</li></ul></li><li><p><strong>带来的问题？</strong></p><ul><li><u>内存泄漏、上下⽂切换、死锁</u>还有受限于硬件和软件的资源闲置问题。</li></ul></li></ul><h4 id="2-什么是线程安全？-如何保证线程安全？">2. **什么是线程安全？**如何保证线程安全？</h4><blockquote><p>好文：<a href="https://zhuanlan.zhihu.com/p/94762520">一文搞懂CAS</a></p></blockquote><ul><li><p><strong>什么是线程安全？</strong></p><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。<u>如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的</u>，就是线程安全的。</p></li><li><p><strong>如何保证线程安全？</strong></p><ol><li><strong>使用 synchronized 关键字</strong> 。开销比较大</li><li><strong>使用Lock 锁</strong> 。高并发场景下，使用 Lock 锁要比使用synchronized 关键字，在性能上得到极大的提高。因为 Lock 底层是通过 AQS + CAS 机制来实现的。</li><li><strong>使用 Atomic 原子类</strong> 。使用 Lock 方式，一旦 unlock() 方法使用不规范，可能导致死锁。 Atomic 原子类，因为其底层基于 CAS 乐观锁来实现的，性能较高。</li><li><strong>使用Volatile？不可行！</strong> 因为无法保证原子性。</li></ol></li></ul><h4 id="3-线程安全需要保证几个基本特征？">3. <strong>线程安全需要保证几个基本特征？</strong></h4><ul><li><strong>原子性</strong>，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</li><li>**可见性，**是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将<br>线程本地状态反映到主内存上，volatile 就是负责保证可见性的。</li><li><strong>有序性</strong>，是保证线程内串行语义，避免指令重排等。</li></ul><h4 id="4-【待补充】如何在线程安全的情况下实现一个计数器？">4. 【待补充】<strong>如何在线程安全的情况下实现一个计数器？</strong></h4><p>可以使用加锁，比如synchronized或者lock。也可以使用Concurrent包下的原子类。</p><h4 id="5-多线程中的i-线程安全吗？请简述一下原因？">5. <strong>多线程中的i++线程安全吗？请简述一下原因？</strong></h4><p>不安全，因为<strong>i++不是原子性操作</strong>。i++分为读取i值，对i值加一，再赋值给i++，执行期中任何一步都是有可能被其他线程抢占的。</p><h4 id="6-介绍一下ThreadLocal原理？">6. <strong>介绍一下ThreadLocal原理？</strong></h4><blockquote><p>一篇讲的不错的文章：<a href="https://www.cnblogs.com/wupeixuan/p/12638203.html">https://www.cnblogs.com/wupeixuan/p/12638203.html</a></p></blockquote><p>当多线程访问共享可变数据时，涉及到线程间同步的问题，<u><strong>并不是</strong>所有时候，都要用到共享数据</u>，所以就需要线程封闭出场了。<strong>数据都被封闭在各自的线程之中</strong>，就不需要同步，这种通过将数据封闭在线程中而避免使用同步的技术称为<strong>线程封闭</strong>。</p><p>ThreadLocal 是 Java 里一种特殊变量，它是一个线程级别变量，<u>每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量</u>，竞态条件被彻底消除了，在并发模式下是绝对安全的变量。</p><ul><li><p><strong>使用示例</strong></p><p>在下面例子中，TreadLocal 做到多个线程对同一对象 set 操作，但是 get 获取的值还都是每个线程 set 的值，体现了线程的封闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadLocal变量，每个线程都有一个副本，互不干扰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; THREAD_LOCAL = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadLocalDemo().threadLocalTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadLocalTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 主线程设置值</span></span><br><span class="line">        THREAD_LOCAL.set(<span class="string">&quot;wupx&quot;</span>);</span><br><span class="line">        String v = THREAD_LOCAL.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread-0线程执行之前，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程取到的值：&quot;</span> + v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String v = THREAD_LOCAL.get();</span><br><span class="line">                <span class="comment">// 此时新建线程Thread-0取到的是null，意味着不同线程取到的值不同的</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程取到的值：&quot;</span> + v);</span><br><span class="line">                <span class="comment">// 设置 threadLocal</span></span><br><span class="line">                THREAD_LOCAL.set(<span class="string">&quot;huxy&quot;</span>);</span><br><span class="line">                v = THREAD_LOCAL.get();</span><br><span class="line">                System.out.println(<span class="string">&quot;重新设置之后，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程取到的值为：&quot;</span> + v);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 等待所有线程执行结束</span></span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        v = THREAD_LOCAL.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread-0线程执行之后，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程取到的值：&quot;</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  输出结果 */</span></span><br><span class="line"><span class="comment">// 虽然Thread-0已经改变了值，但是main取到的值依旧是一样的。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thread-0线程执行之前，main线程取到的值：wupx</span></span><br><span class="line"><span class="comment">Thread-0线程取到的值：null</span></span><br><span class="line"><span class="comment">重新设置之后Thread-0线程取到的值为：huxy</span></span><br><span class="line"><span class="comment">Thread-0线程执行结束</span></span><br><span class="line"><span class="comment">Thread-0线程执行之后，main线程取到的值：wupx</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>ThreadLocal原理</strong></p><p>ThreadLocal有一个<strong>静态内部类ThreadLocalMap，ThreadLocalMap又包含了一个Entry数组</strong>，Entry本身是一个弱引用，他的key是指向ThreadLocal的弱引用，Entry具备了保存key value键值对的能力。</p><p><img src="https://i.loli.net/2021/05/16/MXKyQxYDjWdOku2.png" alt="image-20210516142348550"></p><ul><li><p><strong>ThreadLocalMap</strong></p><blockquote><p>ThreadLocalMap 是 ThreadLocal 的静态内部类，当一个<strong>线程有多个 ThreadLocal 对象时</strong>时，需要一个容器来管理多 ThreadLocal，ThreadLocalMap 的作用就是管理线程中多个 ThreadLocal。</p></blockquote><p>从源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构，底层是数组，有初始化大小，也有扩容阈值大小，数组的元素是 Entry，<strong>Entry 的 key 就是 ThreadLocal 的引用，value 是 ThreadLocal 的值</strong>。ThreadLocalMap 解决 hash 冲突的方式采用的是<strong>线性探测法</strong>，如果发生冲突会继续寻找下一个空的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 键值对实体的存储结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 当前线程关联的 value，这个 value 并没有用弱引用追踪</span></span><br><span class="line">Object value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造键值对</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k k 作 key,作为 key 的 ThreadLocal 会被包装为一个弱引用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v v 作 value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line"><span class="keyword">super</span>(k);</span><br><span class="line">value = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始容量，必须为 2 的幂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储 ThreadLocal 的键值对实体数组，长度必须为 2 的幂</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadLocalMap 元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容的阈值，默认是数组大小的三分之二</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Set方法</strong></p><blockquote><p>调用 ThreadLocal对象.set(value)，实际在调用当前线程的ThreadLocalMap对象.set(this,value) ，会把当前 <code>threadLocal</code> 对象作为 key，想要保存的对象作为 value，存入 map。</p></blockquote><p>set 方法的流程主要是：</p><ul><li>先获取到当前线程的引用</li><li>利用这个引用来获返回当前线程到 ThreadLocalMap</li><li>如果 map 为空，则去创建一个 ThreadLocalMap</li><li>如果 map 不为空，就利用 ThreadLocalMap 的 <code>set (this当前对象，value)</code> 添加键值对</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为当前 ThreadLocal 对象关联 value 值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要存储在此线程的线程副本的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 返回当前ThreadLocal所在的线程</span></span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line"><span class="comment">// 返回当前线程持有的map</span></span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line"><span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果 ThreadLocalMap 不为空，则直接存储&lt;ThreadLocal, T&gt;键值对</span></span><br><span class="line">        <span class="comment">// 此时this是ThreadLocal对象，这是在ThreadLocal类中</span></span><br><span class="line">map.set(<span class="keyword">this</span>, value);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 否则，需要为当前线程初始化 ThreadLocalMap，并存储键值对 &lt;this, firstValue&gt;</span></span><br><span class="line">createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程 thread 持有的 ThreadLocalMap对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Get方法</strong></p><blockquote><p>调用ThreadLocal对象.get() 方式时，实际在调用ThreadLocalMap对象.getEntry(this) 方法。this是当前ThreadLocal对象。</p></blockquote><p>get 方法的主要流程为：</p><ul><li>先获取到当前线程的引用</li><li>获取当前线程内部的 ThreadLocalMap对象</li><li>如果 map 存在，则获取当前 ThreadLocal 对应的 value 值</li><li>如果 map 不存在或者找不到 value 值，则调用 setInitialValue() 进行初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前 ThreadLocal 对象关联的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 返回当前 ThreadLocal 所在的线程</span></span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line"><span class="comment">// 从线程中拿到 ThreadLocalMap</span></span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line"><span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 从 map 中拿到 entry</span></span><br><span class="line">ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 如果不为空，读取当前 ThreadLocal 中保存的值</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">T result = (T) e.value;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若 map 为空，则对当前线程的 ThreadLocal 进行初始化，最后返回当前的 ThreadLocal 对象关联的初值，即 value</span></span><br><span class="line"><span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>resize 方法</strong></p></li></ul><p>当前线程的 ThreadLocalMap 中的 ThreadLocal 的个数超过容量阈值时，ThreadLocalMap 就要开始扩容了。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 略</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="7-为什么ThreadLocal造成内存泄漏？">7. <strong>为什么<code>ThreadLocal</code>造成内存泄漏？</strong></h4><p>ThreadLocalMap 是 ThreadLocal 的静态内部类，当一个线程有多 个ThreadLocal 时，需要一个容器来管理多个 ThreadLocal，ThreadLocalMap 的作用就是管理线程中多个 ThreadLocal。</p><blockquote><p>源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构：</p><p>底层是数组<code>Entry[] table</code>，数组的元素是 Entry类：<strong>Entry 的两个属性， key 是 ThreadLocal类型的引用，value 是 ThreadLocal 的值</strong>。</p></blockquote><ul><li><strong>原因：</strong><code>ThreadLocalMap</code>的key为<strong>弱引用</strong>（有用但非必需，下一次GC会被回收），value为<strong>强引用</strong>（GC过程不会被回收），<u>有可能造成key被GC，value没被G</u>C，<code>ThreadLocalMap</code>中出现<code>null</code>为key的<code>Entry</code>，产生<u>内存泄漏</u>（<strong>软引用</strong>：有用但非必需，内存溢出之前被回收）；</li><li><strong>解决：</strong> 调用<code>set()</code>、<code>get()</code>和<code>remove()</code>方法时，会自动清理掉key为<code>null</code>的记录，但使用<code>ThreadLocal</code>方法后<strong>手动<code>remove()</code></strong>。</li></ul><h4 id="8-什么是多线程中的上下文切换？">8. <strong>什么是多线程中的上下文切换？</strong></h4><p><u>一个线程<strong>让出处理器使用权</strong>，就是“切出”；另外一个线程获取处理器使用权，就是“切入”。</u>在这个切入切出的过程中，操作系统会保存和恢复相关的进度信息，这个进度信息就是我们常说的“上下文”，上下文中一般包含了寄存器的存储内容以及程序计数器存储的指令内容。</p><h4 id="9-请问什么是死锁-deadlock">9. <strong>请问什么是死锁(deadlock)?</strong></h4><p>死锁是指<u>两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</u>，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p><h4 id="10-JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？">10. <strong>JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？</strong></h4><p><u>最简单方法：<strong>指定获取锁的顺序，并强制线程按照指定的顺序获取锁</strong>。</u></p><p>因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。或者通过破坏死锁的四个条件：</p><ul><li><strong>互斥</strong> ： 不可能破坏。</li><li><strong>破坏请求和保持条件：<strong>进程必须 <u>等所有要请求的资源都空闲时才能申请资源</u>， 这种方法会使</strong>资源浪费严重</strong> 。允许进程获取初期所需资源后，便开始运行，运行过程中再逐步释放自己占有的资源。</li><li><strong>破坏不可抢占条件：</strong> 方法代价大，实现复杂。</li><li><strong>破坏循坏等待条件</strong> ：对各进程请求资源的顺序做一个规定，避免相互等待。这种方法对<u>资源的利用率比前两种都高</u>，但是前期要为设备指定序号，新设备加入会有一个问题，其次对用户编程也有限制。</li></ul><h2 id="1-5-锁-重点记忆部分">1.5 锁(重点记忆部分)</h2><h4 id="0-【新增，但不够完善】-java常用的并发工具类？">0.【新增，但不够完善】 java常用的并发工具类？</h4><blockquote><p>这篇不错：<a href="https://zhuanlan.zhihu.com/p/163654320">《今天面试了吗》- 并发编程之AQS同步工具类</a></p></blockquote><p>JUC就是java.util.concurrent包，这个包俗称JUC，里面都是<strong>解决并发问题</strong>。</p><p>常用四大并发工具包（以下都是基于<strong>AQS</strong>实现的）：</p><ol><li><p><strong>CountDownLatch</strong>： CyclicBarrier描述的是“允许一组线程相互等待，直到<strong>到达某个公共屏障点</strong>，才会进行后续任务”。</p><p>而<strong>CountDownLatch</strong>所描述的是“在<strong>完成一组正在其他线程中</strong>执行的操作之前，它允 一个或多个线程一直等待”。</p><p>在API中是这样描述的：用给定的计数初始CountDownLatch。由于调用了countDown方法，所以在当前计数到达零之前，await方法会一直受阻塞。之后，会释放所有等待的线程，await的所有后续调用都将立即返回。这种现象只出现一次（计数无法被重置。如果需要重置计数，请考虑使CyclicBarrier）。</p></li><li><p><strong>CyclicBarrier</strong>：CyclicBarrier是一个同步辅助类。它允许<strong>一组线程互相等待</strong>，<strong>直到到达某个公共屏障点</strong>。在涉及一组固定大小的线程的程序里，这些线程必须不时的互相等待，此时CyclicBarrier 很有用。因为CyclicBarrier在释放等待线程后可以重用，因此成为循环的屏障。</p><blockquote><p>使用**await()**方法，每个线程调用await()方法告诉CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。当所有线程都到达了屏障，结束阻塞，所有线程可继续执行后续逻辑。</p></blockquote></li><li><p><strong>Semaphore</strong>：信号量Semaphore是一个控制访问<strong>多个共享资源的计数器</strong>，和CountDownLatch一样，其本质上是一个“共享锁”。在API是这么介绍信号量的：一个计数信号量，从概念上讲，信号量维护了一个许可集。</p></li><li><p><strong>ExChanger</strong> ：Exchanger是一个同步器，字面上就可以看出这个类的主要作用是交换数据。Exchanger有点<strong>类似CyclicBarrier</strong>，前面说到CyclicBarrier是一个栅栏，到达栅栏的 线程需要等待一定数量的线程到达后，才能通过栅栏。Exchanger可以看成是一个双向的栅栏。线程1到达栅栏后，会首先观察有没有其他线程已经到达栅栏，如果没有就会等待。如果已经有其他线程（比如线程2）到达了，就会<strong>以成对的方式交换各自携带的信息</strong>，因此Exchanger非常适合<strong>两个线程</strong>之间的<strong>数据交换</strong>。</p></li></ol><h4 id="15-1-synchronized-相关">15.1 synchronized 相关</h4><h5 id="1-1-重点-说一说自己对于-synchronized-关键字的了解-synchronized-底层原理">1.1 [重点]<strong>说一说自己对于 synchronized 关键字的了解? synchronized 底层原理</strong> ?</h5><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/356010805">Java面试常见问题：Monitor对象是什么？</a></p><p><a href="https://www.cnblogs.com/aspirant/p/11470858.html">深入分析Synchronized原理(阿里面试题)</a></p></blockquote><ul><li><p><strong>基本了解</strong></p><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><ul><li>synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是<strong>依赖于底层的操作系统的<u>Mutex Lock</u></strong> 来实现的；</li><li>Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，<strong>而操作系统实现线程之间的切换</strong>时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。</li></ul></li><li><p><strong>moniter介绍</strong></p><blockquote><p><strong>Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用。</strong></p></blockquote><p>在HotSpot虚拟机中，Monitor是基于C++的<strong>ObjectMonitor类</strong>实现的，其主要成员包括：</p><ul><li>_owner：指向持有ObjectMonitor对象的线程</li><li>_WaitSet：存放处于wait状态的线程队列，即调用wait()方法的线程</li><li>EntryList：存放处于等待锁block状态的线程队列</li><li>_count：约为_WaitSet 和 _EntryList 的节点数之和</li><li>_cxq: 多个线程争抢锁，会先存入这个单向链表</li><li>_recursions: 记录重入次数</li></ul></li><li><p><strong>底层原理</strong></p><p>synchronized 关键字底层原理属于 JVM 层面。</p><p><strong>① synchronized</strong> <strong>同步语句块的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 JDK ⾃带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：</p><ul><li><p>⾸先切换到类的对应⽬录执行 javac SynchronizedDemo.java 命令⽣成编译后的 .class ⽂件，然后执行 <code>javap -c -s-v -l SynchronizedDemo.class</code></p></li><li><p><img src="https://i.loli.net/2021/05/16/DTSB86Z2GcRy9XC.png" alt="image-20210516130259067"></p></li></ul><p><strong>synchronized</strong> <strong>同步语句块的实现使用的是</strong> <strong>monitorenter</strong> <strong>和</strong> <strong>monitorexit</strong> <strong>指令，其中</strong> <strong>monitorenter指令指向同步代码块的开始位置，monitorexit</strong> <strong>指令则指明同步代码块的结束位置。</strong></p><ol><li><p>当执行monitorenter 指令时，线程试图获取锁也就是获取 monitor的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1 ;</p><blockquote><p>monitor对象存在于每个Java对象的对象头中 synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因。</p></blockquote></li><li><p>相应的在执行monitorexit 指令后，<strong>将锁计数器设为0</strong>，表明锁被释放；</p></li><li><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外⼀个线程释放为⽌。</p></li></ol></li></ul><p><strong>② synchronized</strong> <strong>修饰方法的的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/16/oElScfCHI978Qtw.png" alt="image-20210516131938787"></p><ul><li><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是<code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是⼀个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问。</p><blockquote><p>当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。<strong>在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</strong></p></blockquote><p>两种同步方式<strong>本质上没有区别</strong>，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。两个指令的执行是JVM通过调用操作系统的<strong>互斥原语mutex</strong>来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p></li></ul><h5 id="1-2-请你谈谈关于Synchronized和ReentrantLock？">1.2 <strong>请你谈谈关于Synchronized和ReentrantLock？</strong></h5><ul><li><p><strong>相似点</strong></p><ul><li><p>**都是阻塞式同步：**一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待；</p><blockquote><p>线程阻塞和唤醒的代价是比较高的（操作系统需要在用户态与内核态之间来回切换，代价很高，不过可以通过对锁优化进行改善）。</p></blockquote></li><li><p><strong>都是可重入锁：</strong> 是同一个线程可重复获得锁，每获得一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p></li></ul></li><li><p><strong>不同点</strong></p><ul><li><p><strong>实现原理：</strong> Synchronized是java语言的关键字，是原生语法层面的互斥， JVM 层面；ReentrantLock是JDK 1.5后的API层面的互斥锁，需要<u>lock()和unlock()方法配合try/finally语句块来完成</u>；</p><blockquote><p><img src="https://i.loli.net/2021/04/28/tSoiYbRl5kdA9my.png" alt="image-20210428222639476"></p></blockquote></li><li><p><strong>是否避免死锁</strong>： synchronized<strong>在发生异常时</strong>，会自动释放线程占有的锁，<strong>因此不会导致死锁现象</strong>发生；Lock不会主动适应 <code>unLock()</code> 释放，必须手动在f<code>inally</code>释放；相⽐synchronized，ReentrantLock增加了⼀些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</p></li><li><p><u><strong>线程等待可中断：</strong></u> Lock可以让等待锁的线程响应中断，线程可以中断去干别的事务；而synchronized却不行，使用synchronized时，等待的线程会一直等待下去；</p></li><li><p><strong>公平锁：</strong> synchronized的锁是非公平锁，ReentrantLock默认情况下也是非公平锁，但可以通过带布尔值的构造函数要求使用公平锁；</p><ul><li><strong>选择性通知：</strong> synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。<br>Condition是JDK1.5之后才有的，它具有很好的灵活性，⽐如可以实现多路通知功能也就是在⼀个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使⽤notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，⽤ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有⼀个Condition实例，所有的线程都注册在它⼀个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，<u>而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程</u>。</li></ul></li></ul></li></ul><h5 id="1-3-synchronized锁住的是什么，在项目中遇到了吗？">1.3 <strong>synchronized锁住的是什么，在项目中遇到了吗？</strong></h5><p>synchronized本身并不是锁，锁本身是一个对象，synchronized最多相当于“加锁”操作，所以synchronized并不是锁住代码块。</p><p>（<strong>重点</strong>）Java中的每一个对象都可以作为锁，具体表示有三种形式：</p><p><img src="https://i.loli.net/2021/05/04/LzjeqdIi5rbM819.png" alt="image-20210504232344320"></p><blockquote><p>面试中面试官经常会说：“单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁方式实现单例模式的原理呗！”</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton       <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码</span></span><br><span class="line">       <span class="keyword">if</span> (uniqueInstance WX <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//类对象加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance WX <span class="keyword">null</span>) &#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure><p>这段代码其实是分为三步执行：</p><ol><li><p>为 uniqueInstance 分配内存空间</p></li><li><p>初始化 uniqueInstance</p></li><li><p>将 uniqueInstance 指向分配的内存地址</p></li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致⼀个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回uniqueInstance，<u>但此时 uniqueInstance 还未被初始化</u>。</p><h5 id="1-4-synchronized锁的优化机制了解吗？">1.4 <strong>synchronized锁的优化机制了解吗？</strong></h5><blockquote><p>参考：<a href="https://juejin.cn/post/6844903726545633287">死磕Synchronized底层实现</a></p><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html">美团技术团队</a></p></blockquote><p>synchronized本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括：</p><ul><li>自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁；</li><li>锁的状态从低到高依次为：<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong>。</li></ul><p><img src="https://i.loli.net/2021/05/16/PjXkchreF9sSEKG.png" alt="image-20210516131559341"></p><p>常见的锁：</p><ul><li><p><strong>无锁：</strong> 无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，<strong>但同时只有一个线程能修改成功</strong>。</p><blockquote><p>锁到底存在哪里呢？答案就是对象头中。</p><p>对象头主要又包括了两部分数据：Mark Word（标记字段）、Class Point（类型指针）。</p></blockquote><ol start="0"><li><p>初始mark word 将是可偏向状态，此时的 <u>是否偏向锁</u> 为 0，表示当前没有任何一个线程持有该锁。</p><p><img src="https://i.loli.net/2021/05/21/bNepQwU6scYXCv5.png" alt="image-20210521210754337"></p></li></ol></li><li><p>**偏向锁：**在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><blockquote><p>JDK1.6 中为了提高一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能，引入了偏向锁。在<strong>第一次</strong>获得锁时，会有一个 CAS 操作（见下）；<strong>之后</strong>该线程再获取锁，只会执行几个简单的命令，而不是开销相对较大的 CAS 命令。</p></blockquote><ol><li><p><strong>CASE 1 :</strong> 线程<strong>第一次</strong>获得锁，如果<strong>未偏向</strong>，通过 <strong>CAS</strong> 指令：</p><p><img src="https://i.loli.net/2021/05/21/fwEX4OAMFnyWrbJ.png" alt="image-20210521210949942"></p><ul><li><strong>插入线程ID :</strong> 向mark word插入线程ID</li><li>**偏向锁标识：**将 mark word 中的偏向锁标识从<code>0→1</code></li><li><s>**锁标志位：**不修改！因为不变！</s></li></ul><p>如果操作成功：，则说明获得了偏向锁，以后当前<u>线程等于owner</u>就可以<strong>零成本</strong>的直接获得锁；</p><p>如果操作失败，说明有其它线程获取了锁：</p><ul><li>**如果偏向线程还存在：**直接进行升级为轻量级锁；</li><li><strong>如果偏向线程不存在：</strong> <strong>先修改锁标识为01→00</strong> ，再升级为轻量级锁。</li></ul></li><li><p><strong>CASE 2 :</strong>  这是<strong>一次可重入</strong>，偏向线程是自己。</p><p>在<u>当前线程栈</u>中找到一个可用的 <strong>Lock Record</strong> ：<strong>并将其 obj 指向锁对象 &amp; Displaced Mark Word 置为null</strong></p><img src="https://i.loli.net/2021/05/18/LXj2NZi7fVOzpox.png" alt="img" style="zoom:50%;" /></li></ol></li><li><p><strong>轻量级锁</strong>：当发现多线程竞争时，偏向锁会升级为轻量级锁，一般来说，会在 safepoint（此时用户代码不会执行）中去查看<u>偏向的线程是否还存活</u>。</p><p><img src="https://i.loli.net/2021/05/18/anN1S6AD7MI9gK8.jpg" alt="img"></p><ol><li>如果偏向的线程已经不存活或者不在同步块中，则将对象头的 mark word 改为无锁状态（unlocked），<strong>重新偏向新的线程</strong>；</li><li>如果存活且还在<strong>同步块</strong>中，原偏向的线程继续拥有锁，当前线程则走入到轻量级锁的加锁逻辑中；</li></ol><p>轻量级锁的处理流程 ：</p><ol start="3"><li>发现已经有偏向的线程了，则会**<u>先 撤 销</u>偏向锁，然后升级为轻量锁** 。通过<strong>CAS命令更新</strong>：</li></ol><p><img src="https://i.loli.net/2021/06/02/BMyh36f2OPCGkKe.png" alt="image-20210602161303534"></p><ul><li><p><strong>修改此前 <u>当前线程栈帧Lock Record</u>：</strong> （1）Displaced Mark Word 复制 mark word （此时<strong>无锁</strong>状态）中的现有内容</p></li><li><p><strong>修改mark word ：</strong><u>mark word 指向 <strong>当前线程栈帧Lock Record的</strong> <strong>Displaced Mark Word</strong>的地址</u>，见上图；</p></li><li><p><strong>修改锁标志位</strong>： <code>01 → 00</code></p><p><img src="https://i.loli.net/2021/05/21/QNDEreAK6Ulohvg.png" alt="image-20210521214141329"></p></li></ul><ol start="4"><li><p>上述CAS更新成功，则<strong>当前线程获得了对象的锁</strong>  ；</p><p>如果不成功：</p><ul><li><p>检查Mark Word是否指向当前线程的栈帧的Lock Record ，是则是一次<strong>可重入</strong></p><blockquote><p>设置<code>Lock Record</code>第一部分（<code>Displaced Mark Word</code>）为null，起到了一个重入计数器的作用。然后结束。</p></blockquote></li><li><p>如果不是则是进行<strong>自旋等待</strong></p></li></ul></li><li><p>当**（1）自旋超过一定的次数**（默认10），或者**（2）一个线程在持有锁，一个在自旋，又有第三个来访时**，轻量级锁升级为重量级锁。</p></li></ol></li><li><p><strong>重量级锁：<strong>内置锁在Java中被抽象为</strong>监视器锁（monitor）</strong>。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种<strong>同步方式的成本非常高</strong>，<u>包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等</u>。</p><blockquote><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。<strong>每一个Java对象就有一把看不见的锁Monitor</strong>，称为内部锁或者Monitor锁。</p><p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个<strong>Owner</strong>字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p></blockquote><p>如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。<u>线程去获取重量级锁，其实就是就尝试获取对象的monitor锁。</u></p><blockquote><p>即将 monitor锁的 <strong>Owner字段修改为当前线程ID</strong> 。</p></blockquote><p>如果获取成功，此时线程获得了锁，<strong>CAS修改</strong> ：</p><ol start="2"><li><p><strong>修改mark word</strong> ：然后将对象头mark word 改为<strong>指向该 monitor 的指针</strong>。</p></li><li><p><strong>锁标志位</strong>：<code>00 → 10</code></p><p><img src="https://i.loli.net/2021/05/21/NLFv3fKIh14RlzY.png" alt="image-20210521214213205"></p></li></ol></li></ul><h5 id="1-5-为什么说Synchronized是非公平锁，这样的优缺点是什么？">1.5 <strong>为什么说Synchronized是非公平锁，这样的优缺点是什么？</strong></h5><p>并非是按照申请锁的时间前后给等待线程分配锁的，<strong>每当锁被释放后，任何一个线程都有机会竞争到锁</strong>。</p><ul><li>**优点：**这样做的目的是为了提高执行性能；</li><li>**缺点：**是可能产生线程饥饿现象。</li></ul><h5 id="1-6-为什么说synchronized是一个悲观锁？乐观锁的实现原理又是什么？">1.6  <strong>为什么说synchronized是一个悲观锁？乐观锁的实现原理又是什么？</strong></h5><blockquote><p>没看完，了解了下核心问题：<a href="https://www.cnblogs.com/jojop/p/14022029.html">https://www.cnblogs.com/jojop/p/14022029.html</a></p></blockquote><ul><li><p><strong>synchronized悲观锁</strong></p><p>Synchronized显然是一个悲观锁，因为它的并发策略是悲观的：</p><ul><li><strong>不管是否会产生竞争，任何的数据都必须加锁</strong>。</li></ul></li><li><p><strong>synchronized原理</strong></p><p>Synchronized是通过**获取对象内部的一个叫做监视器锁（monitor）**来实现的，每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权。</p><blockquote><p>监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。</p></blockquote><ol><li><p>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</p></li><li><p>如果线程已经占有该monitor，<u>只是重新进入</u>，则进入monitor的进入数加1；</p></li><li><p>如果<u>其他线程已经占用了monitor，则该线程进入阻塞状态</u>，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p></li></ol></li><li><p><strong>乐观锁实现原理：CAS</strong></p><blockquote><p>参考好文：<a href="https://zhuanlan.zhihu.com/p/94762520">一文彻底搞懂CAS实现原理</a></p></blockquote></li></ul><h5 id="1-7-（CAS原理重点）什么是CAS？CAS的缺点？说说CAS源码实现？">1.7 （CAS原理重点）什么是CAS？CAS的缺点？说说CAS源码实现？</h5><p>乐观锁的核心算法是CAS（Compared And Swap，比较并交换）：</p><ul><li><p><strong>关键逻辑：</strong> CAS，有几个重要的参数：</p><p>（1）<strong>this</strong>，Unsafe 对象本身，需要通过这个类来获取 value 的内存偏移地址。</p><p>（2）<strong>valueOffset</strong>，value 变量的内存偏移地址。</p><p>（3）<strong>expect</strong>，期望更新的值。</p><p>（4）<strong>update</strong>，要更新的最新值。</p><p>如果原子变量中的 <strong>value 值等于 expect</strong>，则使用 update 值更新该值并返回 true，否则返回 false。</p></li><li><p><strong>CAS特性：</strong> CAS具有原子性，它的原子性由CPU硬件指令实现保证。</p><ul><li>【<strong>缺点1</strong>】<strong>ABA问题：</strong> 如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。<ul><li><strong>解决ABA：</strong> 在变量前面加上版本号，每次变量更新的时候变量的<strong>版本号都<code>+1</code></strong>，即<code>A-&gt;B-&gt;A</code>就变成了<code>1A-&gt;2B-&gt;3A</code></li></ul></li><li>【<strong>缺点2】只能保证一个共享变量的原子操作</strong>：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</li><li>【<strong>缺点3</strong>】**循环时间长开销大：**对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li></ul></li><li><p><strong>CAS源码分析</strong></p><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000014858404?utm_source=sf-similar-article">Java CAS 原理分析</a></p></blockquote><blockquote><p>CAS 全称是 compare and swap，是一种用于在<strong>多线程环境下实现同步</strong>功能的机制。</p></blockquote><p>CAS 操作包含三个操作数 – 内存位置、预期数值和新值。CAS 的实现逻辑是将内存位置处的数值与预期数值想比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。</p><p>Java 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的，下面是具体分析。</p><ul><li><p><strong>背景介绍</strong></p><p>在多核心时代下，<strong>多个核心通过同一条总线和内存以及其他硬件进行通信</strong>。</p><p><img src="https://segmentfault.com/img/remote/1460000014858409?w=1598&amp;h=710" alt="img"></p><p><strong>CPU 的多个核心同时对同一片内存进行操作</strong>，会导致错误。例如，递增指令<code>inc dword ptr [...]</code>，等价于<code>DEST = DEST + 1</code>。该指令包含三个操作<code>读-&gt;改-&gt;写</code>，涉及两次访存。</p><ol><li>核心1,2从内存读取数据<code>1</code>，并写到各自寄存器中</li><li>核心1将寄存器中数据<code>1→2</code></li><li>核心2将寄存器中数据<code>1→2</code></li><li>然后都写回主存，此时为<code>2</code></li></ol><p>可以看到，由于核心2在核心1<strong>写入主存操作完成前进行读取</strong>，导致并不是我们期望的<code>3</code> 。</p><p>通过在递增<code>inc</code> 指令前添加 lock 前缀，可以让核心独占某个内存区域，由此可以避免上面问题。lock 前缀保证核心独占某片内存区域，有两种方式：</p><ol><li><strong>总线锁</strong>。总线被锁定后，其他核心就不能访问内存了，可能会导致其他核心短时内停止工作；</li><li><strong>缓存锁</strong>。若<strong>某处</strong>内存数据被缓存在处理器缓存中，处理器发出的 LOCK# 信号不会锁定总线，而是<strong>锁定缓存对应的内存区域</strong>。其他处理器在这片内存区域锁定期间，无法对这片内存区域进行相关操作。（<strong>不是乐观机制都可以操作吗？不能写入内存？</strong>）</li></ol></li><li><p><strong>源码分析</strong></p><blockquote><p>我们分析，<code>java.util.concurrent.atomic</code> 包下的原子类 <code>AtomicInteger</code> 中的 <code>compareAndSet</code> 方法 。</p></blockquote><ol><li><p>AtomicInteger具体实现中，compareAndSet 实际上只是一个壳子，主要的逻辑封装在 Unsafe 的 compareAndSwapInt 方法中；</p></li><li><p>compareAndSwapInt是一个native方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,<span class="keyword">int</span> expected,<span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 计算变量 value 在类对象中的偏移</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * compareAndSet 实际上只是一个壳子，主要的逻辑封装在 Unsafe的compareAndSwapInt 方法中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    <span class="comment">// compareAndSwapInt 是 native 类型的方法，继续往下看</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们进入unsafe.cpp（compareAndSwapInt是native方法）具体实现中，看看调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unsafe.cpp</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个看起来好像不像一个函数，不过不用担心，不是重点。UNSAFE_ENTRY 和 UNSAFE_END 都是宏，</span></span><br><span class="line"><span class="comment"> * 在预编译期间会被替换成真正的代码。下面的 jboolean、jlong 和 jint 等是一些类型定义（typedef）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);</span><br><span class="line">  <span class="comment">// 根据偏移量，计算 value 的地址。这里的 offset 就是 AtomaicInteger 中的 valueOffset</span></span><br><span class="line">  jint* addr = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>(p, offset);</span><br><span class="line">  <span class="comment">// 调用 Atomic 中的函数 cmpxchg，该函数声明于 Atomic.hpp 中</span></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::<span class="built_in">cmpxchg</span>(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br><span class="line"></span><br><span class="line"><span class="comment">// atomic.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">Atomic::cmpxchg</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> exchange_value, <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>* dest, <span class="keyword">unsigned</span> <span class="keyword">int</span> compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) == <span class="built_in"><span class="keyword">sizeof</span></span>(jint), <span class="string">&quot;more work to do&quot;</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载</span></span><br><span class="line"><span class="comment">   * 接下来分析 atomic_windows_x86.inline.hpp 中的 cmpxchg 函数实现</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)Atomic::<span class="built_in">cmpxchg</span>((jint)exchange_value, (<span class="keyword">volatile</span> jint*)dest,</span><br><span class="line">                                       (jint)compare_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析 Windows 平台下的 Atomic::cmpxchg 函数为例，看看具体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// atomic_windows_x86.inline.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) __asm cmp mp, 0  \</span></span><br><span class="line"><span class="meta">                       __asm je L0      \</span></span><br><span class="line"><span class="meta">                       __asm _emit 0xF0 \</span></span><br><span class="line"><span class="meta">                       __asm L0:</span></span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">inline</span> jint <span class="title">Atomic::cmpxchg</span> <span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否是多核 CPU</span></span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    <span class="comment">// 将参数值放入寄存器中</span></span><br><span class="line">    mov edx, dest  <span class="comment">// 注意: dest 是指针类型，这里是把内存地址存入 edx 寄存器中</span></span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, <span class="function">compare_value</span></span><br><span class="line"><span class="function">    <span class="title">LOCK_IF_MP</span><span class="params">(mp)</span>  <span class="comment">// 核心比较写入操作</span></span></span><br><span class="line"><span class="function">    cmpxchg dword ptr [edx], ecx</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>其中LOCK_IF_MP实际内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// LOCK_IF_MP</span></span><br><span class="line">    cmp mp, <span class="number">0</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 mp = 0，表明是线程运行在单核 CPU 环境下。此时 je 会跳转到 L0 标记处，</span></span><br><span class="line"><span class="comment">     * 也就是越过 _emit 0xF0 指令，直接执行 cmpxchg 指令。也就是不在下面的 cmpxchg 指令前加 lock 前缀。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    je L0</span><br><span class="line">     <span class="comment">/* 0xF0 是 lock 前缀的机器码，这里没有使用 lock，而是直接使用了机器码的形式。*/</span></span><br><span class="line">    _emit <span class="number">0xF0</span></span><br><span class="line">L0:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 比较并交换。简单解释一下下面这条指令，熟悉汇编的朋友可以略过下面的解释:</span></span><br><span class="line"><span class="comment">     *   cmpxchg: 即“比较并交换”指令</span></span><br><span class="line"><span class="comment">     *   dword: 全称是 double word，在 x86/x64 体系中，一个</span></span><br><span class="line"><span class="comment">     *          word = 2 byte，dword = 4 byte = 32 bit</span></span><br><span class="line"><span class="comment">     *   ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元</span></span><br><span class="line"><span class="comment">     *   [edx]: [...] 表示一个内存单元，edx 是寄存器，dest 指针值存放在 edx 中。</span></span><br><span class="line"><span class="comment">     *          那么 [edx] 表示内存地址为 dest 的内存单元</span></span><br><span class="line"><span class="comment">     *        </span></span><br><span class="line"><span class="comment">     * 这一条指令的意思就是，将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值</span></span><br><span class="line"><span class="comment">     * 进行对比，如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实际举例说明</strong></p><p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile</strong> 来保证原子操作。AtomicInteger 的主要方法都是通过调用Unsafe类方法去实现，如 compareAndSet 实际是调用AtomicInteger 的compareAndSwapInt方法。</p><blockquote><p>下面以 getAndIncrement实现来说明。</p></blockquote><ol><li><p>getAndIncrement调用了 Unsafe的getAndAddInt方法，传递了（1）当前this对象，（2）value偏移量，用来计算得到value值（3）要加上的值，由于是递增所以是1</p><blockquote><p>:warning: <strong>为什么不传value的值，而是偏移量？</strong> 传偏移量是为了计算value所在的内存地址，进而获取最新的value值。</p></blockquote></li><li><p>getAndAddInt采用CAS方式进行更新，还需要进行当前期望值的计算</p><ul><li>通过<code>getIntVolatile</code>获取到<strong>线程此时内存value值</strong>（期望值），也就是记录<strong>执行CAS前</strong>的内存最新value值；</li></ul></li><li><p>然后开始执行Unsafe的 <code>compareAndSwapInt</code> ，主要是通过<code>Atomic::cmpxchg</code> 逻辑来实现</p><p>（1）将要dest（value内存地址），compareValue（期望值），exchange_value（要更新的值）写入寄存器中</p><p>（2）线程如果是运行多核CPU，上<strong>LOCK#锁，将dest内存区域锁住</strong> ；否则不上LOCK#锁</p><p>（3）执行cmpxchg（比较并交换命令），如果dest的value值（<strong>执行CAS中</strong>的最新value值） == compareValue，则写入exchange_value ；</p><p>（4）否则写入失败，通过不断自旋（循环）期望得到执行</p></li></ol></li></ul></li></ul><h5 id="1-8-请说明一下synchronized的-u-可重入-u-怎么实现？">1.8 <strong>请说明一下synchronized的<u>可重入</u>怎么实现？</strong></h5><p>每个锁关联一个线程持有者对象和一个计数器。</p><ol><li>当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁（即monitor对象）而调用相应方法。</li><li>当一个线程请求成功后，JVM对象头会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。</li><li>而该持有锁的线程如果<strong>再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增</strong>。</li><li>当线程退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁。</li></ol><h5 id="1-9-在synchronized偏向锁过程中，调用hashcode方法，markword会发生什么？">1.9 在synchronized偏向锁过程中，调用hashcode方法，markword会发生什么？</h5><p>第一次调用Hashcode：当<u>对象的hashCode()方法</u>（非用户自定义）第一次被调用时，JVM会生成对应的<strong>identity hash code</strong>值，并将该值<u>存储到Mark Word</u>中 。</p><blockquote><p>后续如果该对象的hashCode()方法再次被调用则不会再通过JVM进行计算得到，<strong>而是直接从Mark Word中获取，保证唯一相同。</strong></p></blockquote><ul><li><strong>无锁状态</strong>：在无锁状态下，Mark Word中可以存储对象的identity hash code值 ；</li><li><strong>偏向锁状态：</strong> 需要计算其identity hash code的话，则它的偏向锁会被撤销（因为没有保存的位置），并且锁会膨胀为轻量级锁或者重量锁 ；</li><li><strong>轻量锁状态：</strong> <u>线程栈帧</u>的Lock Recode可以记录存储Displaced Mark Word ，所以轻量级锁可以和identity hash code <strong>共存</strong> ；</li><li><strong>重量级锁状态： ** <strong><u>ObjectMonitor</u>类里有字段HashCode</strong>可以记录</strong>非加锁状态<strong>下的mark word，所以重量级锁也可以和identity hash code</strong>共存** ；</li></ul><h5 id="1-10-Synchronized-确定不可中断吗？如果一个线程访问Synchronized-代码，其它线程可以能否中断？比如使用Stop？是在中断前还是中断后获取锁？">1.10 Synchronized 确定不可中断吗？如果一个线程访问Synchronized 代码，其它线程可以能否中断？比如使用Stop？是在中断前还是中断后获取锁？</h5><blockquote><p>参考：<a href="https://blog.csdn.net/deel_feel/article/details/105771902">https://blog.csdn.net/deel_feel/article/details/105771902</a></p></blockquote><p>正确说法时：<strong>只有获取到锁之后才能中断，等待锁时不可中断。</strong></p><h4 id="15-2-Reetrantlock-相关">15.2 Reetrantlock 相关</h4><p>ReentrantLock意思为可重入锁 。</p><h5 id="2-1-非公平锁和公平锁在reetrantlock里的实现过程是怎样的？">2.1  <strong>非公平锁和公平锁在reetrantlock里的实现过程是怎样的？</strong></h5><blockquote><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html">美团技术文章-java-lock</a></p></blockquote><ul><li><p>公平锁：那么锁的 <u>获取顺序</u> 就应该符合请求的 <u>绝对时间顺序</u>，FIFO</p></li><li><p>非公平锁：只要<strong>CAS</strong>设置同步状态成功state，则表示当前线程获取了锁</p><blockquote><p>但公平锁还需要判断当前节点是否有前驱节点，如果有，则表示有线程比当前线程更早请求获取锁，因此需要等待。</p></blockquote></li></ul><p>【<strong>源码分析</strong>】</p><ul><li><p><strong>基本结构</strong></p><p>根据代码可知，ReentrantLock里面有一个内部类<strong>Sync</strong>，Sync继承AQS，添加锁和释放锁的大部分操作实际上都是在Sync中实现的。</p><ul><li>Sync有公平锁FairSync和非公平锁NonfairSync两个子类；</li><li>ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</li></ul><p><img src="https://i.loli.net/2021/05/21/YDAreyBEImxQfj2.png" alt="img"></p></li><li><p><strong>公平和非公平锁区分</strong></p><p><img src="https://i.loli.net/2021/05/21/zsPnT7qrXN5ovKZ.png" alt="img"></p><p>公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在<strong>CAS获取同步状态时</strong>，多了一个限制条件：<strong>hasQueuedPredecessors()</strong>。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/bd0036bb.png" alt="img"></p><ul><li>**该方法主要做一件事情：**主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</li></ul></li></ul><h5 id="2-2-ReentrantLock的实现原理？">2.2 ReentrantLock的实现原理？</h5><p>ReentrantLock的实现基于队列同步（AbstractQueuedSynchronizer，后面简称AQS）。关于AQS的实现原理见下。</p><p>ReentrantLock的核心，是通过修改AQS中state的值来同步锁的状态。</p><h5 id="2-3-希望等待一段时间锁没有获取，可以自动放弃用哪种锁？">2.3 希望等待一段时间锁没有获取，可以自动放弃用哪种锁？</h5><p>Lock（ReentranLock）</p><p>但是基于AQS的源码哪里体现了？ 应该Lock锁的代码里自己的实现吧。</p><h4 id="15-3-AQS-相关">15.3 AQS 相关</h4><h5 id="3-1-什么是AQS请你简单介绍一下？">3.1 什么是AQS请你简单介绍一下？</h5><p>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。</p><p><img src="https://i.loli.net/2021/05/16/QhJg8pnTv3zWj4w.png" alt="image-20210516144436982"></p><p><strong>AQS是⼀个用来构建锁和同步器的框架</strong>，使⽤AQS能简单且高效地构造出应用⼴泛的大量的同步器。</p><ul><li>例如：ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue等等皆是基于AQS的。当然，我们⾃⼰也能利⽤AQS非常轻松容易地构造出符合我们⾃⼰需求的同步器。</li></ul><h5 id="3-2-请介绍一下AQS原理？">3.2 请介绍一下AQS原理？</h5><blockquote><p>后续建议研读：<a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用</a></p></blockquote><p>先带着问题来进行看下面内容：</p><blockquote><p>Q：某个线程获取锁失败的后续流程是什么呢？</p><p>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p><p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p><p>A：是CLH变体的FIFO双端队列。</p><p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p><p>A：可以详细看下2.3.1.3小节。</p><p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</p><p>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。</p><p>Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p><p>A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。</p></blockquote><ul><li><p><strong>核心原理概览</strong></p><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。</p><p>如果被请求的共享资源被占用，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，<u>这个机制AQS是⽤CLH队列锁实现的</u>，即将暂时获取不到锁的线程加⼊到队列中。</p><blockquote><p>CLH(Craig,Landin,and Hagersten)队列是⼀个<strong>虚拟的双向队列</strong>（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成⼀个CLH锁队列的⼀个结点（Node）来实现锁的分配。</p></blockquote><p><img src="https://i.loli.net/2021/05/16/XqshLCnMYKbB7Ip.png" alt="image-20210516145134124"></p><p>AQS使用⼀个int成员变量<code>state</code>来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队⼯作。<strong>AQS使⽤CAS对该同步状态进行原子操作实现对其值的修改</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state; <span class="comment">//共享变量，使⽤volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure><p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作 。</p><img src="https://i.loli.net/2021/05/28/g7GORpXKhuo8aS4.png" alt="image-20210526122910138" style="zoom:67%;" /></li><li><p><strong>AQS 对资源的共享方式</strong><br>AQS定义两种资源共享方式，可以通过修改state字段来实现多线程的独占（经典如ReentranLock）和共享模式。</p><p><img src="https://i.loli.net/2021/05/26/YdcSGMs5jgiFnmk.png" alt="img"></p><ul><li><strong>Exclusive（独占）</strong>：只有⼀个线程能执行，如ReentrantLock。⼜可分为公平锁和非公平锁：<ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><strong>Share（共享）</strong>：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li></ul></li><li><p><strong>AQS详细原理</strong></p><blockquote><p>最终参考：<a href="https://zhuanlan.zhihu.com/p/90851418">从源码角度彻底理解ReentrantLock(重入锁)</a></p></blockquote><blockquote><p>以下是基于ReentractLock语境下进行分析。</p></blockquote><ul><li><p><strong>加锁过程：非公平锁</strong></p><blockquote><p>简单来说：<strong>新建线程→CAS尝试快速获取锁→tryAcquire()CAS修改state→addWaiter() 获取失败CAS尝试插入队尾入队→acquireQueued等待前驱线程唤醒继续CAS获取锁</strong></p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-28c16752466cd95dfe0504f0306d6352_720w.jpg" alt="img"></p><p>加锁流程从<code>lock.lock()</code>开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入该源码,正确找到sycn的实现类后可以看到真正有内容的入口方法：</p></li></ul><ol><li><strong>CAS尝试快速加锁</strong>，在ReentranLock只有state=0，才能更新成功（因为是非多线程共享资源）</li><li>获取锁失败执行acquire方法</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 加锁流程真正意义上的入口</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//以cas方式尝试将AQS中的state从0更新为1</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">          setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//获取锁成功则将当前线程标记为持有锁的线程,然后直接返回</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          acquire(<span class="number">1</span>);<span class="comment">//获取锁失败则执行该方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquire</code> 在主要的逻辑都在if判断条件中,这里面有3个重要的方法tryAcquire()，addWaiter() 和 acquireQueued() 。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">          selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>acquire流程1：tryAcquire()</strong></p><p>tryAcquire()在公平和非公平下获取的方式不一样，这里<strong>只说非公平</strong>实现。</p><ol><li>如果<strong>state==0（未被其它线程持有）</strong>，<strong>CAS</strong>尝试获取锁,</li></ol></li><li><p>如果当前线程==持有锁的线程，<strong>可重入</strong> ，<strong>state+1</strong></p></li><li><p>否则 reture false获取锁失败，加入等待队列</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Thread current = Thread.currentThread();<span class="comment">//获取当前线程实例</span></span><br><span class="line">     <span class="keyword">int</span> c = getState();<span class="comment">//获取state变量的值,即当前锁被重入的次数</span></span><br><span class="line">     <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;   <span class="comment">//state为0,说明当前锁未被任何线程持有</span></span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//以cas方式获取锁</span></span><br><span class="line">             setExclusiveOwnerThread(current);  <span class="comment">//将当前线程标记为持有锁的线程</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//获取锁成功,非重入</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">//当前线程就是持有锁的线程,说明该锁被重入了</span></span><br><span class="line">         <span class="keyword">int</span> nextc = c + acquires;<span class="comment">//计算state变量要更新的值</span></span><br><span class="line">         <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">         setState(nextc);<span class="comment">//非同步方式更新state值</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//获取锁成功,重入</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;     <span class="comment">//走到这里说明尝试获取锁失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>acquire流程2：addWaiter()</strong></p><ol><li><p>首先通过new Node()创建一个空结点；</p></li><li><p><strong>如果队列不空，<strong>以</strong>CAS</strong>方式让新节点插入到队尾；</p></li><li><p>如果队列为空，执行<code>enq(node)</code> 逻辑</p></li></ol></li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">         Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);<span class="comment">//首先创建一个新节点,并将当前线程实例封装在内部,mode这里为null</span></span><br><span class="line">         <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">         Node pred = tail;</span><br><span class="line">         <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">             node.prev = pred;</span><br><span class="line">             <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                 pred.next = node;</span><br><span class="line">                 <span class="keyword">return</span> node;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         enq(node);<span class="comment">//入队的逻辑这里都有</span></span><br><span class="line">         <span class="keyword">return</span> node;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​     </span><br><span class="line">     <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             Node t = tail;<span class="comment">//t指向当前队列的最后一个节点,队列为空则为null</span></span><br><span class="line">             <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize  //队列为空</span></span><br><span class="line">                 <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">//构造新结点,CAS方式设置为队列首元素,当head==null时更新成功</span></span><br><span class="line">                     tail = head;<span class="comment">//尾指针指向首结点</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;  <span class="comment">//队列不为空</span></span><br><span class="line">                 node.prev = t;</span><br><span class="line">                 <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">//CAS将尾指针指向当前结点,当t(原来的尾指针)==tail(当前真实的尾指针)时执行成功</span></span><br><span class="line">                     t.next = node;    <span class="comment">//原尾结点的next指针指向当前结点</span></span><br><span class="line">                     <span class="keyword">return</span> t;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>acquire流程3：acquireQueued()</strong></p><blockquote><p><strong>线程加入同步队列后，获取锁的流程是什么呢？</strong></p><p>简单来说，就是不断判断当前是否是老二，并尝试去获取锁。</p></blockquote> <img src="https://pic4.zhimg.com/v2-f83b087a039a8de3f9815d9018e2273f_b.jpg" alt="img" style="zoom:80%;" /><ul><li><code>SIGNAL ：</code>意味着线程释放锁后会唤醒后面阻塞的线程。毕竟，只有确保能够被唤醒，当前线程才能放心的阻塞</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//死循环,正常情况下线程只有获得锁才能跳出循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//获得当前线程所在结点的前驱结点</span></span><br><span class="line">            <span class="comment">//第一个if分句</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; </span><br><span class="line">                setHead(node); <span class="comment">//将当前结点设置为队列头结点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;<span class="comment">//正常情况下死循环唯一的出口</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第二个if分句</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  <span class="comment">//判断是否要阻塞当前线程</span></span><br><span class="line">                parkAndCheckInterrupt())      <span class="comment">//阻塞当前线程</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>解锁：非公平锁</strong></p><img src="https://i.loli.net/2021/05/26/sSQZlA2paTcNKXi.png" alt="image-20210526170709280" style="zoom:67%;" /></li><li><p><strong>加锁：公平锁</strong></p><blockquote><p>简单来说：<strong>新来线程→【必须】先CAS加入等待队列→等待前驱节点释放锁（state=0），如果是老二则获取锁</strong>。</p></blockquote><p>公平锁加锁入口加锁从：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finally void lock() &#123;</span><br><span class="line">    acqiuire();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前非公平锁的逻辑中，线程有三次机会获取锁：</p><ol><li><strong>新创建时</strong>，CAS尝试修改state=1，去获取</li><li><strong>可重入</strong>，当前获取锁线程为自己</li><li><strong>前驱节点释放锁</strong>，自己作为老二被唤醒</li></ol><p>而<strong>公平锁</strong>，只能按加入队列的<u>先后次序 &amp; 可重入</u>获得锁 ：</p><pre><code>1. 所有线程在获取锁前**必须先加入同步队列** 2. 如果state=0，`hasQueuedPredecessors`判断当前是头节点，则获取锁 </code></pre><p><img src="https://i.loli.net/2021/05/26/wZSLYOP4bTGEqRJ.jpg" alt="img"></p></li></ul></li></ul><h5 id="3-3-为什么基于FIFO的同步队列可以实现非公平锁？">3.3 为什么基于FIFO的同步队列可以实现非公平锁？</h5><p>因为非公平锁，除了等 <strong>前驱节点唤醒去获取锁</strong> ，还有以下三种方式获取锁：</p><ol><li><p><strong>新创建时</strong>，CAS尝试修改state=1，去获取</p><blockquote><p>公平锁：进来先执行<code>hasQueuedPredecessors()</code> , 看等待队列是否有有效节点，有的话不能获取锁！</p></blockquote></li><li><p><strong>可重入</strong>，当前获取锁线程为自己</p><blockquote><p>公平锁：也可以</p></blockquote></li><li><p><strong>同步队列等待</strong>，等待唤醒获取锁</p><blockquote><p>公平锁：也可以</p></blockquote></li></ol><p>并且在锁释放时：是<strong>先释放锁（修改state=-1），再去唤醒后继节点</strong></p><ol><li>会导致新来的线程，可能在<strong>后继节点被唤醒前</strong>就获取了锁，这就不会公平</li></ol><h5 id="3-4-【易忘】为什么非公平锁性能好？">3.4 【易忘】为什么非公平锁性能好？</h5><ol><li>.线程不必加入等待队列就可以获得锁,不仅<strong>免去了构造结点并加入队列的繁琐操作</strong> ，<strong>节省了线程阻塞、唤醒</strong>的开销（这涉及到上下文的切换）；</li><li><strong>减少CAS竞争</strong>。如果<strong>线程必须要加入阻塞队列才能获取锁</strong>,那<strong>0</strong>将变得异常激烈,CAS操作虽然不会导致失败线程挂起,但不断失败重试导致的对CPU的浪费也不能忽视</li></ol><h5 id="3-4-AQS-有哪些组件，请简单介绍一下？介绍一下CountDownLatch的应用场景-？">3.4 AQS 有哪些组件，请简单介绍一下？介绍一下CountDownLatch的应用场景 ？</h5><p><img src="https://i.loli.net/2021/05/26/OWhD4Hu3GkBP2vc.png" alt="image-20210526215800096"></p><ul><li><p><strong>Semaphore(信号量)：<strong>Semaphore(信号量)可以指定</strong>多个</strong>线程<strong>同时</strong>访问某个资源； <strong>synchronized 和 ReentrantLock</strong> 都是⼀次只允许<strong>⼀个</strong>线程访问<strong>同时</strong>某个资源。</p><blockquote><p>计数信号量具备两种操作动作，称为V（signal()）与P（wait()）（即部分参考书常称的“PV操作”）。V操作会增加信号标S的数值，P操作会减少它。</p><p>运行P（wait()），信号标S的值将被减少。企图进入临界区段的进程，需要先运行P（wait()）。当信号标<strong>S减为负值</strong>时，进程会被挡住，不能继续；当<strong>信号标S不为负值</strong>时，进程可以获准进入临界区段。</p></blockquote></li><li><p><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch是⼀个同步⼯具类，用来协调多个线程之间的同步。这个⼯具通常用来控制线程等待，<u>它可以让<strong>某⼀个线程等待直到倒计时结束</strong></u>，再开始执行。</p></li><li><p><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能⽐ CountDownLatch 更加复杂和强大。主要应用场景和CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让⼀组线程到达⼀个屏障（也可以叫同步点）时被阻塞，直到最后⼀个线程到达屏障时，屏障才会开⻔，所有被屏障拦截的线程才会继续⼲活。</p><blockquote><p>CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程<u>调⽤**await()**方法告诉 CyclicBarrier 我已经到达了屏障</u>，然后当前线程被阻塞。</p></blockquote></li></ul><p><strong>CountDownLatch的应用场景</strong></p><p>我们要读取处理<strong>6</strong>个⽂件，这6个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这6个⽂件的处理的结果进行统计整理。</p><p>为此我们定义了⼀个线程池和<strong>count为6的 CountDownLatch 对象</strong> 。使用线程池处理读取任务，每⼀个线程处理完之后就将count-1，调用 CountDownLatch 对象的 await() 方法，直到所有⽂件读取完之后，才会接着执行后面的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理⽂件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">6</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建⼀个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">     ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">     <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span></span><br><span class="line">CountDownLatch(threadCount);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> threadnum = i;</span><br><span class="line">         threadPool.execute(() → &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//处理⽂件的业务操作</span></span><br><span class="line">                ......</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//表示⼀个⽂件已经被完成</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       countDownLatch.await();</span><br><span class="line">       threadPool.shutdown();</span><br><span class="line">       System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-4-Volatile-关键字">15.4 Volatile 关键字</h4><h5 id="4-0-JMM-是什么-？-缓存一致性协议MESI-CPU内存屏障？JAVA内存屏障？">4.0 JMM 是什么 ？ 缓存一致性协议MESI ? CPU内存屏障？JAVA内存屏障？</h5><blockquote><p>参考：<a href="https://www.jianshu.com/p/06717ac8312c">并发编程-（4）-JMM基础（总线锁、缓存锁、MESI缓存一致性协议、CPU 层面的内存屏障）</a></p></blockquote><ul><li><p><strong>JMM定义</strong></p><p>全称Java Memory Model（java内存模型）是一系列的Java虚拟机平台对开发者提供的多线程环境下的内存可见性、是否可以重排序等问题的无关具体平台的统一的保证。</p></li><li><p><strong>MESI 缓存一致性协议协议</strong></p><ul><li><p><strong>缓存不一致问题</strong></p><p>CPU处理速度，远大于I/O设备（磁盘），为了解决了处理器与内存的速度矛盾，引入了<strong>高速缓存</strong>。但是由此也带来了缓存不一致的问题。</p><ul><li><strong>每个线程都会缓存内存的数据在各自寄存器中</strong>，在<strong>不同 CPU 中运行的不同线程看到同一份内存的缓存值不一样</strong>就会存在缓存不一致的问题。</li></ul></li><li><p><strong>MESI协议内容</strong></p><p>为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，<strong>最常见的就是 MESI 协议</strong>：<br>MESI 表示缓存行的四种状态，分别是：</p><blockquote><p>在 MESI 协议中，每个缓存的缓存控制器不仅知道自己的 读写操作，而且<strong>也监听(snoop)其它 Cache 的读写操作</strong>。</p></blockquote><ul><li><strong>M(Modify)</strong> 表示共享<strong>数据</strong>只缓存在<strong>当前 CPU 缓存</strong>中， 并且是被修改状态，也就是缓存的数据和主内存中的<strong>数据不一致</strong>。</li><li><strong>E(Exclusive)</strong> 表示缓存的独占状态，<strong>数据</strong>只缓存在<strong>当前 CPU 缓存</strong>中，并且<strong>没有被修改</strong>。</li><li><strong>S(Shared)</strong> 表示<strong>数据</strong>可能被<strong>多个 CPU 缓存</strong>，并且各个缓存中的<strong>数据和主内存数据一致</strong>。</li><li><strong>I(Invalid)</strong> 表示缓存已经<strong>失效</strong>。</li></ul><p>对于 MESI 协议，从 CPU 读写角度来说会遵循以下原则：</p><p><img src="https://i.loli.net/2021/06/11/YbfKoySNDMX5swn.png" alt="image-20210611200929872"></p><ul><li>**CPU 读请求：**缓存处于 M、E、S 状态都可以被读取，I 状 态 CPU 只能从主存中读取数据；</li><li><strong>CPU 写请求：<strong>缓存处于 M、E 状态才可以被写。对于 S 状 态的写，需要将</strong>其他 CPU 中缓存行置为无效</strong>才可写。</li></ul></li><li><p><strong>Store Bufferes（存储缓存）</strong></p><blockquote><p>CPU 缓存行的状态是通过消息传递来进行的，如果 CPU0 要对一个在缓存中<strong>共享的变量</strong>进行<strong>写入</strong>，首先发送一个失效的消息给到其他缓存了该数据的 CPU。并且要<strong>等到他们的确认回执</strong>。CPU0 在这段时间内都会处于<strong>阻塞状态</strong>。</p></blockquote><p>为了避免阻塞带来的资源浪费。在 cpu 中引入 了 Store Bufferes（存储缓存） 和 Invalidate Queue（无效队列）。</p><ul><li>CPU0 写入共享数据时，<strong>直接把数据写入到 store bufferes 中，同时发送 invalidate 消息，然后继续去处理其他指令</strong>；</li><li>收到其他所有 CPU 发送了 invalidate ACK消息时**，再将 store bufferes 中的数据数据存储至 cache 中**；</li><li>最后再从<strong>本地Cache同步到主内存</strong>。</li></ul></li><li><p><strong>CPU层面内存屏障</strong></p><blockquote><p>内存屏障就是<strong>将 Store Bufferes 中的指令写入到内存</strong>，从而使得其他访问同一共享内存的线程的可见性。</p></blockquote><p>硬件层的内存屏障分为两种：<strong>Load Barrier （读屏障）</strong> 和 <strong>Store Barrier（写屏障）及 Full Barrier（全屏障）</strong> 是读屏障和写屏障的合集。</p><ul><li><strong>写屏障</strong>：强制<strong>把写缓冲区/高速缓存</strong>中的脏数据等<strong>写回主内存</strong></li><li><strong>读屏障</strong>：将缓冲区/高速缓存中相应的<strong>数据失效</strong>。</li></ul></li><li><p><strong>JAVA 内存屏障</strong></p><p>java的内存屏障通常所谓的四种，**LoadLoad（LL）, StoreStore（SS）, LoadStore（LS）, StoreLoad（SL）**实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</p><ul><li><strong>LoadLoad（LL）屏障</strong>：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li><strong>StoreStore（SS）屏障</strong>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li><strong>LoadStore（LS）屏障</strong>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li><strong>StoreLoad（SL）屏障</strong>：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li></ul></li></ul></li></ul><h5 id="4-1-什么是HappenBefore原则？">4.1 什么是HappenBefore原则？</h5><p>在 JMM 中，<strong>如果一个操作执行的结果需要对另一个操作【可见】，那么这两个操作必须要存在 happens-before 关系</strong>。这两个操作可以是同一个线程，也可以是不同的线程。</p><p><strong>它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</strong> 。</p><ul><li><p><strong>HappenBefore原则</strong></p><ul><li><p><strong>as-if-serial 规则（程序顺序执行）</strong>：单个线程中的代码顺序不管怎么重排序，对于结果来说是不变的。</p></li><li><p><strong>volatile 变量规则</strong>，对于 volatile 修饰的变量的<strong>写操作</strong>， 一定 happen-before 后续对于 volatile 变量的<strong>读操作</strong>;</p></li><li><p><strong>监视器锁规则（monitor lock rule）</strong>：对一个监视器的解锁，happens-before于随后对这个监视器的加锁。</p></li><li><p><strong>传递性规则</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</p></li><li><p><strong>start 规则</strong>：如果线程 A 执行操作 ThreadB.start(),那么线程 A 的 ThreadB.start()操作 happens-before 线程 B 中的任意操作。</p></li><li><p><strong>join 规则</strong>：如果线程 A 执行操作 ThreadB.join()并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join()操作成功返回。</p></li></ul></li><li><p><strong>举例说明：什么是指令重排序？</strong></p><p>请看下面代码：</p><blockquote><p><strong>假设</strong> 线程A执行writer()方法之<strong>后</strong>，线程B执行reader()方法，那么线程B执行4的时候一定能看到线程A写入的值吗？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;           <span class="comment">//1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;     <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;       <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> i = a;    <span class="comment">//4</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是<strong>肯定的</strong>。因为根据happens-before规则，我们可以得到如下关系：</p><ol><li>根据<strong>程序顺序规则</strong>，1 happens-before 2；3 happens-before 4</li><li>根据<strong>volatile规则</strong>，2 happens-before 3；</li><li>根据<strong>传递性规则</strong>，1 happens-before 4 。</li></ol><p>因此，综合运用<strong>程序顺序规则、volatile规则及传递性规则</strong>，我们可以得到1 happens-before 4，即线程B在执行4的时候一定能看到A写入的值。</p></li></ul><h5 id="4-2-Volatile-关键字原理">4.2 Volatile 关键字原理</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/paddix/p/5428507.html">https://www.cnblogs.com/paddix/p/5428507.html</a> 。</p></blockquote><p>此题考察的是<code>volatile</code>这个关键字。可以从<code>volatile</code>的作用和<code>volatile</code>的原理这三个方面来进行回答。<strong>volatile只能保证变量的可见性、有序性，但是不能保证原子性。</strong></p><ul><li><strong>可见性实现原理</strong></li></ul><blockquote><p>为了实现<strong>volatile可见性</strong>和<strong>happen-befor</strong>的语义。JVM底层是通过一个叫做“<strong>内存屏障（基于MESI）</strong>”的东西来完成（也实现了<strong>有序性</strong> ？）。</p></blockquote><p><strong>线程本身并不直接与主内存进行数据的交互</strong>，而是通过线程的工作内存来完成相应的操作。这也是导致线程间数据不可见的本质原因。</p><p>使用<strong>MESI</strong> 协议，使得<strong>任意一个线程修改了 volatile 修饰的变量，其他线程可以马上识别到最新值</strong>。</p><blockquote><p>最终目标：保证了<strong>缓存的一致性</strong>。</p><p>具体的话，下面是用<strong>内存屏障</strong>来实现的。</p></blockquote><ol><li>修改本地工作内存，强制刷回主内存；</li></ol><p><img src="https://i.loli.net/2021/06/11/JTFaYRu13pfQg9d.png" alt="image-20210611204633903"></p><ol start="2"><li><p>强制让其他线程的工作内存失效过期；</p><p><img src="https://i.loli.net/2021/06/11/2kphvOoJu4K65Hb.png" alt="image-20210611204715422"></p></li><li><p>其他线程重新从主内存加载最新值；</p><p><img src="https://i.loli.net/2021/06/11/rvo58ueDB6CPyMa.png" alt="image-20210611204743839"></p></li></ol><ul><li><p><strong>有序性实现原理</strong></p><blockquote><p>参考：<a href="https://blog.csdn.net/qq_42764468/article/details/106898608">https://blog.csdn.net/qq_42764468/article/details/106898608</a></p></blockquote><p>从源代码到最终执行的指令，可能会经过三种重排序：</p><p><img src="https:////upload-images.jianshu.io/upload_images/2845835-8fc217f556cd34f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680/format/webp" alt="img"></p></li><li><p><strong>【指令】重排序</strong>，<strong>JMM</strong> 会要求编译器生成指令时，会<strong>插入内存屏障</strong>来禁止处理器重排序。</p></li></ul><blockquote><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止：①特定类型的编译器重排序和②处理器重排序，为程序员提供一致的内存可见性保证。</p></blockquote><ul><li><p><strong>编译器重排序</strong>，<strong>JMM</strong>  <strong>禁止了特定类型的编译器</strong>重排序（不是所有的编译器重排序都要禁止）。</p></li><li><p><strong>内存重排序</strong>：由于处理器会使用读/写缓冲区，出于性能的原因，内存会对读/写进行重排序</p></li></ul><p>JVM 是<strong>使用内存屏障来禁止【指令】重排，从而达到：可见性 + 部分有序性</strong>效果。</p><blockquote><p><strong>lock前缀指令实际相当于一个内存屏障</strong>？ 下面不是可见性吗？？？</p></blockquote><p>对volatile变量的<strong>写</strong>操作与普通变量的主要区别有两点：</p><ol><li><p>修改volatile变量<strong>前</strong>，<strong>会强制将修改后的值刷新的主内存中</strong>。</p><blockquote><p>每个volatile写操作前插入<strong>StoreStore（SS）屏障</strong></p></blockquote></li><li><p>修改volatile变量<strong>后</strong>，<strong>会导致其他线程工作内存中对应的变量值失效</strong>，因此，再读取该变量值的时候就需要重新从读取主内存中的值。</p><blockquote><p>在写操作后插入StoreLoad屏障；</p></blockquote></li></ol><pre><code>对volatile变量的**读**操作类似：</code></pre><ol><li><p>在每个volatile读操作前插入<strong>LoadLoad（LL）屏障</strong>；</p><blockquote><p>确保Load2及后续Load指令加载数据之前能访问到Load1加载的数据。</p></blockquote></li><li><p>在读操作后插入**LoadStore（LS）**屏障。</p><blockquote><p>确保Store2和后续Store指令执行前，可以访问到Load1加载的数据。</p></blockquote></li></ol><h5 id="4-3-volatile为什么不能保证原子性？">4.3 volatile为什么不能保证原子性？</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/simpleDi/p/11517150.html">为什么volatile能保证有序性不能保证原子性</a></p></blockquote><p>对于i++这种复合操作，即使使用volatile关键字修饰也不能保证操作的原子性，可能会引发数据不一致问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure><p>上述<code>i++</code>操作，其实分为三个操作：</p><ol><li><p>线程读取i</p></li><li><p>temp = i + 1</p></li><li><p>i = temp</p></li></ol><p>A,B两个线程多线程操作时：</p><ol><li><p>A线程读取i并执行了 temp = i + 1的操作， 此时的 i（0） 的值还没有变化</p></li><li><p>此时B也读入i并执行temp = i + 1操作，此时i（0）也没变化</p><blockquote><p>:warning: 虽然有MESI协议，但是<code>temp</code>不保存变量<code>i</code>所在内存区域，<strong>是cpu内部的计算</strong>，不会被立马刷新内存！</p></blockquote></li><li><p>当A写入i = temp（1）时，由于可见性立马在主存被刷新了值 i=1</p></li><li><p>当B也写入i = temp时，<strong>此时A依旧是1，而不是2</strong></p></li></ol><h5 id="4-4-并发编程的三个重要特性-？">4.4  <strong>并发编程的三个重要特性</strong> ？</h5><ol><li><strong>原子性 :</strong> ⼀个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的⼲扰而中断，<strong>要么所有的操作都执行，要么都不执行</strong>。 <code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性 ：<strong>当</strong>⼀个变量对共享变量进行了修改，那么另外的线程都是⽴即可以看到修改后的最新值</strong>。 volatile 关键字可以保证共享变量的可见性。</li><li>**有序性 ：**代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。 <code>volatile</code> 关键字可以禁⽌指令进行重排序优化。</li></ol><h5 id="4-5-说说-synchronized-关键字和-volatile-关键字的区别？">4.5 <strong>说说</strong> synchronized <strong>关键字和</strong> volatile <strong>关键字的区别</strong>？</h5><p>synchronized关键字和volatile关键字比较：</p><ul><li><p><strong>volatile关键字是线程同步的轻量级实现</strong>，所以volatile性能肯定⽐synchronized关键字要好。</p></li><li><p><strong>volatile关键字只能用于变量</strong>，而synchronized关键字可以修饰方法以及代码块。</p><blockquote><p>synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引⼊的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用<br>synchronized 关键字的场景还是更多⼀些。</p></blockquote></li><li><p><strong>volatile关键字只能保证数据的可见性</strong>，但不能保证数据的原子性。synchronized关键字两者都能保证。</p></li><li><p><strong>多线程访问volatile关键字不会发生阻塞</strong>，而synchronized关键字可能会发⽣阻塞</p></li></ul><h4 id="15-5-Atomic-原子类">15.5 Atomic 原子类</h4><h5 id="5-1-什么是Atomic-原子类？">5.1 什么是Atomic 原子类？</h5><p>所以，所谓原子类说简单点就是<strong>具有原子/原子操作特征的类</strong>。</p><blockquote><p>在我们这⾥ Atomic 是指⼀个操作是不可中断的。即使是在多个线程⼀起执行的时候，⼀个操作⼀旦开始，就不会被其他线程⼲扰。</p></blockquote><h5 id="5-2-JUC-包中的原子类是哪4类">5.2 JUC <strong>包中的原子类是哪</strong>4<strong>类</strong>?</h5><p><img src="https://i.loli.net/2021/05/16/vS4DHpKCN9bjnTF.png" alt="image-20210516152124223"></p><h5 id="5-3-Volatile-和-atomic-变量区别？">5.3 Volatile 和  atomic  变量区别？</h5><ul><li>Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。</li><li>而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</li></ul><h5 id="5-4-讲讲-AtomicInteger-的使用-？">5.4 讲讲 AtomicInteger 的使用 ？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并⾃增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并⾃减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输⼊的数值等于预期值，则以原子方式将该值设置为输⼊值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet设置之后可能导致其他线程在之后的⼀小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 基本类型也要是原子类</span></span><br><span class="line">       <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">       <span class="comment">//使⽤AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-5（重点提问）-AtomicInteger-原理？">5.5（重点提问） AtomicInteger 原理？</h5><p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile</strong> 和 <strong>native</strong> 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>我们以自增方法为例： <code>getAndIncrement</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，本质是在调用 unsafe中的 <code>getAndAddInt</code></p><blockquote><p>unsafe中的compareAndSwapInt方法参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compareAndSwapInt(Object o, <span class="keyword">long</span> offset,<span class="keyword">int</span> expected,<span class="keyword">int</span> x);  <span class="comment">// x是准备更新的值</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.<span class="built_in">getAndAddInt</span>(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unsafe中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="comment">// getIntVolatile方法获取到期望值value后去调用compareAndSwapInt方法，失败则进行重试</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// var5是计算得到的期望值，获取此时内存的最新值（因为value是votilate修饰，修改总是被能及时看到）</span></span><br><span class="line">        var5 = <span class="keyword">this</span>.<span class="built_in">getIntVolatile</span>(var1, var2);</span><br><span class="line">    <span class="comment">// 计算传入compareAndSwapInt的四个参数</span></span><br><span class="line">    <span class="comment">// var1：传入的this对象；var2：value内存偏移值；var5：期望值，希望和【var2】一致； var5+var4：var5+var4（1），递增</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.<span class="built_in">compareAndSwapInt</span>(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最终总结如下</strong></p><p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile</strong> 来保证原子操作。AtomicInteger 的主要方法都是通过调用Unsafe类方法去实现，如 compareAndSet 实际是调用AtomicInteger 的compareAndSwapInt方法。</p><p>下面以 getAndIncrement实现来说明。</p><ol><li><p>getAndIncrement调用了 Unsafe的getAndAddInt方法，传递了（1）当前this对象，（2）value偏移量valueoffset，用来计算得到value值（3）要加上的值，由于是递增所以是1</p><blockquote><p>:warning: <strong>为什么不传value的值，而是偏移量？</strong> 传偏移量是为了计算value所在的内存地址，进而获取最新的value值。</p></blockquote></li><li><p>getAndAddInt采用CAS方式进行更新，还需要进行当前期望值的计算</p><ul><li>通过<code>getIntVolatile</code>获取到<strong>线程此时内存value值</strong>（期望值），也就是记录<strong>执行CAS前</strong>的内存最新value值；</li></ul></li><li><p>然后开始执行Unsafe的 <code>compareAndSwapInt</code> ，主要是通过<code>Atomic::cmpxchg</code> 逻辑来实现</p><p>（1）将要dest（value内存地址），compareValue（期望值），exchange_value（要更新的值）写入寄存器中</p><p>（2）线程如果是运行多核CPU，上<strong>LOCK#锁，将dest内存区域锁住</strong> ；否则不上LOCK#锁</p><p>（3）执行cmpxchg（比较并交换命令），如果dest的value值（<strong>执行CAS中</strong>的最新value值） == compareValue，则写入exchange_value ；</p><p>（4）否则写入失败，通过不断**自旋（循环）**期望得到执行</p></li></ol><h2 id="1-6-JVM相关">1.6 JVM相关</h2><h4 id="1-（被问过）JVM启动的基本配置参数有哪些？（或者说调优参数）">1. （被问过）<strong>JVM启动的基本配置参数有哪些？</strong>（或者说调优参数）</h4><p><strong>「堆栈内存相关」</strong></p><ul><li><p>-Xms： 设置初始堆的大小</p></li><li><p>-Xmx： 设置最大堆的大小</p></li><li><p>-Xmn ：设置年轻代大小，相当于同时配置-XX:NewSize和-XX:MaxNewSize为一样的值</p></li><li><p>-Xss： 每个线程的堆栈大小</p></li><li><p>-XX:NewSize 设置年轻代大小(for 1.3/1.4)</p></li><li><p>-XX:MaxNewSize 年轻代最大值(for 1.3/1.4)</p></li><li><p>-XX:NewRatio 年轻代与年老代的比值(除去持久代)</p></li><li><p>-XX:SurvivorRatio Eden区与Survivor区的的比值</p></li><li><p>-XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。</p></li><li><p>-XX:MaxTenuringThreshold设定对象在Survivor复制的最大年龄阈值，超过阈值转移到老年代</p></li></ul><p><strong>「垃圾收集器相关」</strong></p><p>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。</p><ul><li><p>-XX:ParallelGCThreads=20：配置并行收集器的线程数</p></li><li><p>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。</p></li><li><p>-XX:CMSFullGCsBeforeCompaction=5 由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行5次GC以后对内存空间进行压缩、整理。</p></li><li><p>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</p></li></ul><p><strong>「辅助信息相关」</strong></p><ul><li><p>-XX:+PrintGCDetails 打印GC详细信息</p></li><li><p>-XX:+HeapDumpOnOutOfMemoryError让JVM在发生内存溢出的时候自动生成内存快照,排查问题用</p></li><li><p>-XX:+DisableExplicitGC禁止系统System.gc()，防止手动误触发FGC造成问题.</p></li><li><p>-XX:+PrintTLAB 查看TLAB空间的使用情况</p></li></ul><h4 id="2-说说堆和栈的区别？">2.<strong>说说堆和栈的区别？</strong></h4><ol><li><p>**功能不同：**栈内存用来存储<u>局部变量和方法调用</u>，而堆内存用<u>来存储Java中的对象</u>；</p><blockquote><p>注：无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p></blockquote></li><li><p>**共享性不同：**栈内存是线程私有的； 堆内存是所有线程共有的；</p></li><li><p>**异常错误不同：**如果栈内存或者堆内存不足，都会抛出异常但不同；</p><blockquote><p>栈空间不足：<code>java.lang.StackOverFlowError</code>。 堆空间不足：<code>java.lang.OutOfMemoryError</code>；</p></blockquote></li><li><p>**空间大小：**栈的空间大小远远小于堆的。</p></li></ol><h4 id="3-【重点】请问JVM运行时内存布局分布？-哪些是线程共享的？">3. <strong>【重点】请问JVM运行时内存布局分布？ 哪些是线程共享的？</strong></h4><p>从概念上大致分为 6 个（逻辑）区域，参考下图。注：Method Area 中还有一个常量池区，图中未明确标出。</p><ul><li>总的来看，JVM 把内存划分为<u>“栈(stack)”与“堆(heap)”</u>两大类</li></ul><p><img src="https://static001.infoq.cn/resource/image/dd/a9/dd614bf56417939aa0e0694fedf2caa9.png" alt="img"></p><p><u>线程私有的：</u></p><ul><li><p><strong>程序计数器</strong>：当同时进行的线程数超过CPU数或其内核数时，就要通过时间片轮询分派CPU的时间资源，不免发生线程切换。这时，<u>每个线程就需要一个属于自己的计数器来记录下一条要运行的指令</u>；</p></li><li><p><strong>虚拟机栈：</strong> <u>每个java方法执行时都会创建一个<strong>桢栈</strong></u>来存储方法的：</p><ul><li><p>变量表、操作数栈、动态链接方法、返回值、返回地址等信息；</p></li><li><p>栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法），“<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">栈帧参考</a>” ；</p></li></ul></li><li><p><strong>本地方法栈 ：</strong> 与虚拟机栈作用相似。但它不是为Java方法服务的，而是调用操作系统原生本地方法时，所需要的内存区域。</p><ul><li>本地方法被执行的时候，在本地方法栈也会创建⼀个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</li></ul></li></ul><p><u>线程共享的：</u></p><ul><li><p>**堆：**GC 垃圾回收的主站场，用于<u>存放类的实例对象及 数组实例</u>等；</p><p><img src="https://i.loli.net/2021/05/05/6Ri9BzxGtLpFemP.png" alt="img"></p></li><li><p><strong>方法区：</strong> 线程共享的，用于存放被虚拟机加载的<strong>类的元数据信息</strong>：</p><ul><li>如 <u><strong>常量</strong>、<strong>静态变量</strong></u>和 <u> 即时<strong>编译器编译后的代码</strong></u><strong>；</strong></li><li><strong>运行时常量池</strong> ：<strong>字符串</strong>，int -128~127 范围的值等，它是 <u>方法区</u> 中的一部分。</li></ul></li></ul><h4 id="4-（新）说一下Java创建对象的过程？">4. （新）说一下Java创建对象的过程？</h4><p><img src="https://i.loli.net/2021/05/16/EBIujUDhkF9VRtg.png" alt="image-20210516205754856"></p><ol><li><p><strong>类加载检查：</strong> 虚拟机遇到⼀条 new 指令时，⾸先将去检查这个指令的参数是否能在<strong>常量池中定位到这个类的符号引用</strong>，并且检查这个符号引用代表的<strong>类是否已被加载过、解析和初始化过</strong>。如果没有，那必须先执行相应的类加载过程。</p></li><li><p><strong>分配内存：</strong> 在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把⼀块确定大小的内存从 <u>Java 堆中划分出来</u>。</p><blockquote><p><strong>（重要）分配方式有 “指针碰撞” 和 “空闲列表” 两种</strong>，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整⼜由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p><img src="https://i.loli.net/2021/05/16/S27KdREVrpGqt5I.png" alt="image-20210516210222497"></p></blockquote></li><li><p><strong>初始化对象字段零值。</strong> 内存分配完成后，进行对象初始化操作。</p><blockquote><p>例如给**对象中（区分类加载过程，初始化类变量）**所有的基本数据变量赋上初始化值， 当我们没有对它们进行赋值操作时就可以使用对象了。</p></blockquote></li><li><p><strong>设置对象头：</strong> 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是<u>哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息</u>。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用<u>偏向锁</u>等，对象头会有不同的设置方式。</p></li><li><p>**执行init() &amp; 构造函数。**然后执行对象内部生成的init方法，然后执行构造器方法（程序员设置的）。</p></li><li><p><strong>内存地址赋给引用：</strong> 在虚拟机会将刚创建好对象的内存地址赋给引用对象。完成此操作后，便可以在程序中通过引用访问对象的实例数据。</p></li></ol><h5 id="4-1-什么是指针碰撞？-空闲列表？TLAB">4.1 **什么是指针碰撞？**空闲列表？TLAB?</h5><p>三种虚拟机<strong>划分堆内存</strong>区域的方法，TLAB也可用来给堆内存分配空间。</p><ul><li><p><strong>指针碰撞</strong></p><p>一般情况下，JVM的对象都放在堆内存中（发生逃逸分析除外）。当类加载检查通过后，Java虚拟机开始为新生对象分配内存。</p><ul><li>如果Java堆中内存是绝对规整的，所有被<strong>使用过的的内存都被放到一边，空闲的内存放到另外一边</strong>，中间放着一个<strong>指针作为分界点</strong>的指示器，<u>所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例</u>，这种分配方式就是指针碰撞。</li></ul></li><li><p><strong>空闲列表</strong></p><p><u>如果Java堆内存中的内存并不是规整的</u>，已被使用的内存和空闲的内存相互交错在一起，<u>不可以进行指针碰撞</u>。</p><ul><li>虚拟机必须维护一个列表，<strong>记录哪些内存是可用的</strong>，在分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表。</li></ul></li><li><p><strong>TLAB</strong></p><p>TLAB 是虚拟机在内存的<u><strong>eden 区</strong>划分出来的一块专用空间，是线程专属的</u>。 在启用TLAB 的情况下，当线程被创建时，虚拟机会为每个线程分配一块TLAB 空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提高分配效率。</p><blockquote><p>虚拟机通过 -XX:UseTLAB 设定它的。</p></blockquote></li></ul><h5 id="4-2-JVM如何保证对象分配的线程安全问题？">4.2 JVM如何保证对象分配的线程安全问题？</h5><p>因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>TLAB</strong>： 为<strong>每⼀个线程预先在Eden区分配⼀块⼉内存TLAB</strong>，JVM在<strong>给线程中的对象分配内存时，⾸先在TLAB分配</strong>，当<u>对象大于TLAB中的剩余内存或TLAB的内存已用尽时</u>，再采用的CAS进行内存分配。</li><li><strong>CAS+失败重试</strong>： CAS 是乐观锁的⼀种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为⽌。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li></ul><h4 id="5-描述一下对象分配【原则】？（区分前面new对象【过程】）">5. <strong>描述一下对象分配【原则】？（区分前面new对象【过程】）</strong></h4><p>JVM 中的堆可划分为两大部分，<u>新生代和老年代</u>，大小比例为1:2：</p><ul><li>新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to 区</li></ul><p><img src="https://i.loli.net/2021/05/05/6Ri9BzxGtLpFemP.png" alt="img"></p><p>具体回收过程：</p><p><img src="https://i.loli.net/2021/04/19/p2LqRv6krQnbga4.png" alt="image-20210419224230046"></p><p>对象的正常流程：<em>Eden 区 -&gt; Survivor 区 -&gt; 老年代</em>。</p><ol><li>新的对象<strong>优先在 Eden 区分配</strong>（<em>大对象直接进入老年区，避免在Eden区及两个Survivor区之间发生大量的内存复制</em>） , <strong>当 Eden 区没有足够空间时</strong>，会发起一次 <em><strong>Minor GC</strong></em>；</li><li><em><strong>Minor GC</strong></em>采用<strong>复制回收算法</strong>的改进版本回收Eden中对象：<ul><li>先将Eden存活对象迁移到 to 区，然后清空Eden</li><li>最后交换to和from区域<strong>标签</strong></li></ul></li><li>每经过一次 <em><strong>Minor GC</strong></em>  （在交换区）后对象年龄加1，对象年龄达到<em><strong>15次</strong></em>后将会晋升到老年代；</li><li>对象提前晋升到老年代，动态年龄判定：如果在 Survivor 区中相<u>同年龄所有对象大小总和大于 Survivor 区大小的一半</u>， 年龄大于或等于该年龄的对象就可以直接进入老年代；</li><li>老年代空间不够时进行 <em><strong>Full GC</strong></em>。</li></ol><h5 id="5-1-对象一定分配到堆上吗？">5.1 对象一定分配到堆上吗？</h5><blockquote><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTQxOTc5NQ==&amp;mid=2650500024&amp;idx=1&amp;sn=0997c486387bf56bbe8ca909d55a7edf&amp;chksm=83c88c44b4bf05521d66f6a396550cd9c8379c3fdddee1ee198968f6a9ddd172550d3329a94d&amp;scene=21#wechat_redirect">面试官：是不是所有的对象和数组都会在堆内存分配空间</a></p></blockquote><blockquote><p>小伙，来给我讲一下是不是<strong>所有的对象和数组</strong>都会在堆内存分配空间？</p></blockquote><p>并不是，这涉及到<strong>对象逃逸</strong>。请看下面的代码：</p><p>StringBuffer对象，最终会被return，也就是<strong>会被该方法之外的给利用</strong>。 发生了对象逃逸。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9AGZ6gT0cFLwmz482FwbF4R7uGG2DMh1obk7hibSE9b98w24vTAOy5Z3sGlGAOvJMvaCPuybNa3q0ibo63rzry3w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><strong>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。</strong> 但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一<strong>个对象并没有逃逸出方法的话</strong>，那么就可能被<strong>优化成栈上分配</strong>。</p><h4 id="6-对象的访问定位有哪两种方式">6. <strong>对象的访问定位有哪两种方式</strong>?</h4><p>建⽴对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，⽬前主流的访问方式有：<strong>①使用句柄和 ②直接指针两种。</strong></p><ol><li><strong>句柄：</strong> 如果使用句柄的话，那么Java堆中将会划分出⼀块内存来作为句柄池，reference 中存储的就是<strong>对象的句柄地址</strong>，而句柄中包含了<strong>对象实例数据</strong>与**类型数据（存放在方法区）**各⾃的具体地址信息；</li></ol><blockquote><p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p></blockquote><p><img src="https://i.loli.net/2021/05/16/4XShu2w1nRbZl5x.png" alt="image-20210516211902118"></p><ol start="2"><li><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，<strong>而reference 中存储的直接就是对象的地址</strong>。</li></ol><blockquote><p>使用直接指针访问方式最大的好处就是速度快，它节省了⼀次指针定位的时间开销。</p></blockquote><p><img src="https://i.loli.net/2021/05/16/lTvrqnOFu5X9VJk.png" alt="image-20210516212141885"></p><h4 id="7-如何判断对象是否需要回收（死亡）？">7. <strong>如何判断对象是否需要回收（死亡）？</strong></h4><ul><li><strong>可达性分析</strong>：根据引用的关系构造引用链（有向图），在图中不可达的对象就是要被回收的；</li><li><strong>引用计数</strong>：有地方引用该对象，计数器++，引用失效，计数器–，有循环引用的问题。</li></ul><h4 id="8-如何判断一个常量是废弃变量？如何判断一个类是无用类？">8. 如何判断一个常量是废弃变量？如何判断一个类是无用类？</h4><ul><li><p><strong>判断常量是废弃变量</strong></p><p>运行时常量池主要回收的是废弃的常量。</p><p>假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量&quot;abc&quot; 就是废弃常量，如果这时发⽣内存回收的话而且有必要的话，“abc” 就会被系统清理出常量池。</p></li><li><p><strong>判断类是无用类？</strong></p><p>虚拟机可以对满足下面3个条件的无用类进行回收，这⾥说的仅仅是“可以”，而并不是和对象⼀样不使用了就会必然被回收。</p><ul><li><p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例；</p></li><li><p>加载该类的 ClassLoader 已经被回收；</p></li><li><p>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ul></li></ul><h3 id="1-6-1-GC相关">1.6.1 GC相关</h3><blockquote><p>不错的GC介绍文章：<a href="https://www.infoq.cn/article/3wyretkqrhivtw4frmr3">一文看懂 JVM 内存布局及 GC 原理</a></p></blockquote><h4 id="1-请介绍GC基本原理？有什么优点？GC可以马上回收内存吗？如何主动让虚拟机回收？">1. <strong>请介绍GC基本原理？有什么优点？GC可以马上回收内存吗？如何主动让虚拟机回收？</strong></h4><p>当程序员创建对象时，GC就开始监控这个对象的<u>地址、大小</u>及<u>使用情况</u> ，当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间 ：</p><ul><li><p><strong>基本原理</strong>： GC采用<u><strong>有向图</strong></u>的方式记录和管理 **堆(heap)**中的所有对象 ，并确定对象 <strong>是否“可达”</strong></p></li><li><p><strong>GC优点：</strong>（1）使得程序员不用考虑内存管理 （2）Java中的对象不再有&quot;作用域&quot;的概念，只有对象的引用才有&quot;作用域&quot; （3）有效防止内存泄漏</p></li><li><p><strong>马上回收：</strong> 程序员<strong>不能实时</strong>的调用垃圾回收器对某个对象或所有对象进行垃圾回收。</p></li><li><p><strong>主动回收：</strong> 手动执行<code>System.gc()</code> ，但是Java语言规范 <u>并不保证</u> GC一定会执行。</p></li></ul><h4 id="2-什么是GC-Root？可以作为GC-Root的对象？">2. <strong>什么是GC Root？可以作为GC Root的对象？</strong></h4><ul><li><p><strong>GC Root ：</strong>  判断对象是通过可达性分析，所以所有的可达性算法<strong>都会有起点</strong> ，这就是 GC Root。</p><ul><li><strong>特点：</strong> <strong>当前时刻存活的对象</strong>！</li></ul><p>通过GC Root 找出所有活的对象，那么剩下所有的没有标记的对象就是需要回收的对象。</p><p><img src="https://pic1.zhimg.com/80/v2-38552a00d9bfb53f0c780e26a0d4b078_720w.jpg" alt="img"></p></li><li><p><strong>GC Root对象：</strong> （1）虚拟机栈中<strong>引用</strong>的<strong>对象</strong>；（2）方法区中的<strong>静态</strong>变量、<strong>常量</strong>对象；（3）本地方法<strong>引用</strong>的<strong>对象</strong>；（4）被<code>synchronized</code>修饰的对象等。</p></li></ul><h4 id="3-哪些内存区域需要GC">3. <strong>哪些内存区域需要GC?</strong></h4><ul><li><p><strong>（无需）线程独享区域</strong>：<code>PC Regiester、JVM Stack、Native Method Stack</code>，其生命周期都与线程相同（即：与线程共生死），所以无需 GC;</p></li><li><p><strong>（需）线程共享</strong>的 Heap 区、Method Area 则是 GC 关注的重点对象。</p></li></ul><p><img src="https://static001.infoq.cn/resource/image/e3/71/e36c624e8b4300775123f95a34b86571.png" alt="img"></p><h4 id="4-什么时候会触发Full-GC？">4. <strong>什么时候会触发Full GC？</strong></h4><ol><li><p><strong>调用 System.gc()</strong> ；</p></li><li><p><strong>老年代空间不足</strong>；</p></li><li><p><strong>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</strong>；</p><blockquote><p>如果发现<strong>统计之前Minor GC的平均晋升大小比目前old gen剩余的空间大</strong>，则不会触发Minor GC而是转为触发full GC。</p></blockquote></li><li><p><strong>方法区空间不足</strong>。</p><blockquote><p>JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中存放的为一些<u><strong>class的信息、常量、静态变量等数据</strong></u>，当系统中<strong>要加载的类、反射的类和调用的方法较多</strong>时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：<code>java.lang.OutOfMemoryError: PermGen space</code> 。<br>为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p></blockquote></li></ol><h4 id="5-什么时候触发-Minor-GC-什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？">5. <strong>什么时候触发 Minor GC ? 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？</strong></h4><ul><li><p><strong>什么时候触发Minor GC ?</strong></p><p><strong>当Eden区不足时</strong>就会触发 Minor GC 。</p></li><li><p><strong>minor gc运行频繁</strong></p></li></ul><ol><li><p>产生了太多朝生夕灭的对象导致需要频繁minor gc</p></li><li><p>新生代空间设置太小</p></li></ol><ul><li><p><strong>minor gc运行很慢</strong></p><ol><li><u>新生代空间设置过大</u>；</li><li><u>对象引用链较长</u>，进行可达性分析时间较长；</li><li><u>新生代survivor区设置的比较小</u>，清理后剩余的对象不能装进去需要移动到老年代，造成移动开销；</li><li><u>内存分配担保失败</u>，由minor gc转化为full gc；</li><li><u>采用的垃圾收集器效率较低</u>，比如新生代使用serial收集器。</li></ol></li></ul><h4 id="6-描述一下GC算法？">6. <strong>描述一下GC算法？</strong></h4><p>GC算法包含：引用计数法，标记清除，标记复制，标记压缩。</p><ul><li>**引用计数：**对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用；</li><li><strong>标记清除：</strong> 垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象；然后，在清除阶段，<u>清除所有未被标记的对象，<strong>但会产生很多垃圾碎片</strong></u> ；</li><li><strong>标记复制：</strong> 将内存对半分，总是<strong>保留一块空着</strong>（上图中的右侧），将左侧存活的对象（浅灰色区域）复制到右侧。<strong>避免了内存碎片问题，但是内存浪费很严重</strong>，<u>相当于只能使用 50%的内存</u>；</li><li><strong>标记压缩（标记整理）：<strong>标记过程仍然与<u>“标记-清除”</u>算法一样，但后续步骤</strong>不是直接对可回收对象进行清理</strong>，而是让<strong>所有存活的对象都向一端移动</strong>，然后<strong>直接清理掉端边界以外的内存</strong>（类似于 windows 的磁盘碎片整理），避免垃圾碎片。</li></ul><h4 id="7-什么是Stop-The-World-什么是安全点？安全区域？">7. <strong>什么是Stop The World ?</strong> 什么是安全点？安全区域？</h4><ul><li><p><strong>Stop The World</strong></p><p>进行<strong>垃圾回收</strong>的过程中，<u>会<strong>涉及对象的移动。为了保证对象引用更新的正确性</strong>，必须暂停所有的用户线程</u>，像这样的停顿，虚拟机设计者形象描述为「Stop The World」。也简称为STW。JVM在暂停的时候，需要选准一个时机。</p><p>由于JVM系统运行期间的复杂性，不可能做到随时暂停，因此引入了<strong>安全点</strong>的概念。</p></li><li><p><strong>安全点</strong></p><blockquote><p>安全点，即程序（非GC先）执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。</p></blockquote><p>安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，<strong>Java虚拟机的堆栈不会发生变化</strong>。这么一来，<strong>垃圾回收器便能够“安全”地执行可达性分析</strong>。只要不离开这个安全点，Java虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。</p></li><li><p><strong>如何保证中断时所有线程都在安全点</strong></p><ul><li><p><strong>抢先式中断（Preemptive Suspension）</strong><br>抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，<strong>如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上</strong>。现在几乎没有虚拟机采用这种方式来暂停线程从而响应GC事件。</p></li><li><p><strong>主动式中断（Voluntary Suspension）</strong><br>主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。<strong>轮询标志的地方和安全点是重合的</strong>，另外再加上创建对象需要分配内存的地方。</p></li></ul></li></ul><h4 id="8-常见的垃圾回收器有哪些（比如G1）？">8. 常见的垃圾回收器有哪些（比如G1）？</h4><p><img src="https://i.loli.net/2021/05/16/ypmn6LRB5trC3Dl.png" alt="image-20210516215006746"></p><ul><li><p><strong>Serial收集器 。</strong> Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是⼀个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用⼀条垃圾收集线程去完成垃圾收集⼯作，更重要的是它在进行垃圾收集⼯作的时候必须<strong>暂停其他所有的⼯作线程（ “Stop The World”）</strong>，直到它收集结束。</p></li><li><p><strong>ParNew收集器。</strong> ParNew收集器其实就是<strong>Serial收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全⼀样。</p><ul><li>新⽣代采用<u><strong>标记-复制</strong>算法，⽼年代采用<strong>标记-整理</strong>算法</u>。</li></ul></li><li><p><strong>Parallel Scavenge收集器。</strong> Parallel Scavenge 收集器类似于ParNew 收集器。 那么它有什么特别之处呢？ Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量。</p><blockquote><p>如果对于收集器运作不太了解的话，⼿⼯优化存在的话可以选择把内存管理优化交给虚拟机去完成也是⼀个不错的选择。-</p></blockquote><ul><li><u>新⽣代采用<strong>标记-复制</strong>算法，⽼年代采用<strong>标记-整理</strong>算法</u>。</li></ul></li><li><p><strong>（重点）CMS收集器。<strong>CMS（Concurrent Mark Sweep）收集器是一种以</strong>获取最短回收停顿时间</strong>为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以<code>并发</code>执行，以此来达到降低收集停顿时间的目的。</p><ul><li>CMS收集器仅作用于<strong>老年代</strong>的收集，基于 <u>“<strong>标记-清除</strong>”</u> 。</li><li><strong>优点：</strong> 并发收集、低停顿。</li><li><strong>缺点（快手）：</strong> CMS收集器<strong>对CPU资源非常敏感</strong>；CMS收集器<strong>无法处理浮动垃圾</strong>（Floating Garbage）。</li></ul></li><li><p><strong>（重点）G1收集器。</strong> G1重新定义了堆空间，<strong>打破了原有的分代模型，将堆划分为一个个区域</strong>。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。区域划分的好处就是带来了<strong>停顿时间可预测的收集模型</strong>：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</p><ul><li>**并行与并发：**G1能充分利⽤CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核⼼）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li><li>**分代收集：**虽然G1可以不需要其他收集器配合就能独⽴管理整个GC堆，但是还是保留了分代的概念。</li><li><strong>空间整合：<strong>与CMS的<u>“标记–清除”</u>算法不同，G1从整体来看是基于</strong>“标记-整理”<strong>算法实现的收集器；从局部上来看是</strong>基于<u>“标记-复制”</u>算法</strong>实现的。</li><li>**可预测的停顿：**这是G1相对于CMS的另⼀个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建⽴可预测的停顿时间模型，能让使用者明确指定在⼀个⻓度为M毫秒的时间片段内。</li></ul></li></ul><h5 id="8-1-介绍一下CMS-和-G1-垃圾回收器原理？">8.1 介绍一下CMS 和 G1 垃圾回收器原理？</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/heyonggang/p/11718170.html">弄明白CMS和G1，就靠这一篇了</a></p></blockquote><ul><li><p><strong>CMS收集器</strong></p><p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的。</p><p>CMS收集器仅作用于老年代的收集，是基于<u>标记-清除</u>算法的，它的运作过程分为4个步骤：</p><ol><li><strong>初始标记（CMS initial mark） :</strong> 需要<strong>STW</strong>，标记一下GC Roots能<strong>直接</strong>关联到的对象 ；</li><li><strong>并发标记（CMS concurrent mark）：<strong>从GC Roots开始堆中对象进</strong>行可达性分析</strong>，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行；</li><li><strong>重新标记（CMS remark）：<strong>需要</strong>STW</strong> ，<strong>修正并发标记期间</strong>因用户程序继续运作而导致<strong>标记产生变动</strong>的那一部分对象的标记记录 ；</li><li><strong>并发清除（CMS concurrent sweep）：</strong> 清除对象。</li></ol></li><li><p><strong>G1收集器</strong></p><p>在堆的结构设计时，G1打破了以往将收集范围固定在新生代或老年代的模式，G1将堆分成许多<strong>相同大小</strong>的区域单元，每个单元称为<strong>Region</strong>。Region是一块地址连续的内存空间，G1模块的组成如下图所示：</p><blockquote><p>区域划分的好处就是带来了<strong>停顿时间可预测的收集模型</strong>：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</p></blockquote><p>和CMS挺像的。</p><ol><li>初始标记（Initial Marking）：仅仅只是标记一下GC Roots能<strong>直接关联</strong>到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</li><li>并发标记（Concurrent Marking）：是从GC Roots开始堆中对象进行<strong>可达性分</strong>析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</li><li>最终标记（Final Marking）：是为了修正并发标记期间因用户程序继续运作而导致<strong>标记产生变动</strong>的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</li><li><strong>筛选回收</strong>（Live Data Counting and Evacuation）：首先<strong>对各个Region的回收价值和成本进行排序</strong>，根据用户<strong>所期望的GC停顿时间来制定回收计划</strong>。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li></ol></li></ul><h5 id="8-2-为什么CMS不用标记-压缩算法？">8.2 为什么CMS不用标记-压缩算法？</h5><p>CMS主要关注<strong>低延迟</strong>，因而采用并发方式。</p><p>在<strong>并发清理垃圾</strong>时，如果采用压缩算法，这<strong>涉及到移动存活的对象。如果不进行停顿会很难处理</strong>，违背了CMS初衷，所以采用<strong>标记-清除</strong>算法。</p><h4 id="9-什么是内存泄漏？">9. <strong>什么是内存泄漏？</strong></h4><p>广义并通俗的说，就是：<u>不再会被使用的<strong>对象</strong>的内存不能被回收</u>，就是内存泄漏。</p><p><strong>内存泄漏场景：</strong></p><ul><li><p>静态集合类、数组<strong>添加对象以后遗漏了对于他们的处理</strong>，例如HashMap和Vector；</p></li><li><p>各种连接，如数据库连接、网络连接、IO连接；</p></li><li><p>单例模式；</p></li><li><p>变量不合理的作用域。</p></li></ul><h3 id="1-6-2-类加载">1.6.2 类加载</h3><h4 id="1-（没记）介绍一下类文件结构？">1. （没记）介绍一下类文件结构？</h4><p>Class⽂件字节码结构组织示意图 。</p><p><img src="https://i.loli.net/2021/05/16/VkMjgwfFb9NGr2L.png" alt="image-20210516220600929"></p><ol><li><strong>魔数:</strong> 确定这个⽂件是否为⼀个能被虚拟机接收的 Class ⽂件。</li><li>**Class ⽂件版本 ：**Class ⽂件的版本号，保证编译正常执行。</li><li><strong>常量池</strong> ：常量池主要存放两大常量：字面量和符号引用。</li><li>**访问标志 ：**标志用于识别⼀些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</li><li><strong>当前类索引,⽗类索引</strong> ：类索引用于确定这个类的全限定名，⽗类索引用于确定这个类的⽗类的全限定名，由于 Java 语⾔的单继承，所以⽗类索引只有⼀个，除了 java.lang.Object 之外，所有的 java 类都有⽗类，因此除了 java.lang.Object 外，所有 Java 类的⽗类索引<br>都不为 0。</li><li>**接口索引集合 ：**接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 implents (如果这个类本身是接口的话则是 extends ) 后的接口顺序从左到右排列在接口索引集合中。</li><li>**字段表集合 ：**描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</li><li><strong>方法表集合</strong> ：类中的方法。</li><li><strong>属性表集合 ：</strong> 在 Class ⽂件，字段表，方法表中都可以携带⾃⼰的属性表集合。</li></ol><h4 id="2-什么是类加载器？请你解释一下java程序运行的过程？">2. 什么是类加载器？请你解释一下java程序运行的过程？</h4><blockquote><p>参考 ： <a href="https://cloud.tencent.com/developer/article/1350078">一个简单java程序的运行全过程</a></p></blockquote><p><u>类加载器是一个用来加载类文件的<strong>类</strong></u> 。</p><p>我们所说的类加载过程即是指<strong>JVM虚拟机把.class文件中类信息加载</strong>进内存。主要分为以下3大步、5小步：</p><p><img src="https://i.loli.net/2021/04/21/m1Ot3nQcMGq2YfW.jpg" alt="img"></p><ol><li><p><strong>编译。</strong> 将编译的<code>.java</code> 文件编译为<code>.class</code>字节码文件，然后交给JVM运行；</p></li><li><p><strong>加载</strong> ：class字节码文件从各个来源通过**<u>类加载器</u>**装载入<u>内存</u>中 。</p><blockquote><ul><li><strong>来源</strong>：包本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译</li><li><strong>类加载器</strong> ：一般包括<strong>启动类加载器</strong>，<strong>扩展类加载器</strong>，<strong>系统类加载器</strong>，以及用户的<u><strong>自定义类加载器</strong> （代码加密防止反编译）</u>。</li></ul></blockquote></li><li><p><strong>链接：</strong> 分为，验证、准备、解析（”正-中-准-心“）三阶段</p><ul><li><p><strong>验证：</strong> 保证加载进来的<u>字节流符合虚拟机规范</u>；</p><blockquote><p><strong>文件格式的验证</strong>，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</p><p><strong>元数据的验证</strong>，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</p><p><strong>字节码的验证</strong>，保证程序语义的合理性，比如要保证<u>类型转换的合理性</u>。</p><p><strong>符号引用的验证</strong>，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p></blockquote></li><li><p><strong>准备：<strong>类变量（<strong>注意，不是实例变量</strong> ）分配内存，并且赋予</strong>初值</strong>（虚拟机根据不同类型设定的初始值）；</p><blockquote><p>这些变量所使用的内存都将在<strong>方法区</strong>中进行分配 ，进行<strong>零初始化</strong>：</p><ul><li>即数字类型初始化为 0 ，boolean 初始化为 false，引用类型初始化为 null 等</li></ul></blockquote></li><li><p>**解析：**将常量池内的 <u>符号引用</u> 替换为 <u>直接引用</u> 的过程。</p><blockquote><p><u>符号引用：</u>即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。<br><u>直接引用：</u>可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量。</p><p>:ear_of_rice: 实例： 调用方法hello()，方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。</p></blockquote></li></ul></li><li><p><strong>初始化。</strong> 初始化就是执行类的<code> cinit</code>()的过程。</p><blockquote><p>:grey_question: 和准备阶段那个初始化看得我有点迷糊？</p><ul><li><strong>在编译阶段</strong>，编译器收集所有的<strong>静态字段的赋值语句及静态代码块</strong>，并按 <u>语句出现的顺序</u> 拼接出一个类初始化方法 <code>&lt;clinit&gt;()</code>。此时，执行引擎会调用这个方法对静态字段进行代码中编写的初始化操作。</li></ul></blockquote></li></ol><h5 id="2-1-（C-版本）一个程序从开始到完整结束的过程？">2.1 （C++版本）一个程序从开始到完整结束的过程？</h5><ol><li><p><strong>预编译。</strong> 主要处理源代码文件中的以“#”开头的预编译指令 ；</p><blockquote><ol><li>删除所有的#define，展开所有的宏定义 ;</li><li>处理所有的条件预编译指令，如 “#if”、“#endif”、“#ifdef”、“#elif” 和 “#else” ;</li><li>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件 ；</li><li>删除所有的注释，“//”和“/**/” ；</li><li>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用；</li><li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告 能够显示行号。</li></ol></blockquote></li><li><p><strong>编译。</strong> 把预编译之后生成的xxx.i或xxx.ii文件，进行一系列<strong>词法分析、语法分析、语义分析及优化</strong>后，生成相应的汇编代码文件 ；</p></li><li><p><strong>汇编。</strong> 将汇编代码转变成机器可以执行的指令(机器码文件)；</p><blockquote><p>经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux 下)、xxx.obj(Windows下)。</p></blockquote></li><li><p><strong>链接</strong> 。将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序：</p><ol><li><p><strong>静态链接：</strong> 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来，创建最终的可执行文件。</p><blockquote><ul><li><strong>执行速度快：</strong><u>可执行程序中已经具备了所有执行程序所需要的任何东西</u>， 在执行的时候运行速度快；</li><li>**空间浪费：**因为<u>每个可执行程序中对所有需要的目标文件都要有一份副本，</u>所以如果多个程序对同一个 目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</li><li>**更新困难：**每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</li></ul></blockquote></li><li><p><strong>动态链接：</strong> 把程序按照模块拆分成各个相对独立部分**，在程序运行时才将它们链接在一起形成一个完整的程序**。</p><blockquote><ul><li><strong>性能损耗</strong>：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失；</li><li>**共享库：**就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</li><li>**更新简单：**更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。</li></ul></blockquote></li></ol></li></ol><h4 id="3-知道类的生命周期吗？">3. <strong>知道类的生命周期吗？</strong></h4><p><strong>在类加载的过程</strong>再加上：</p><ol start="4"><li>**使用。**new出对象程序中使用</li><li>**卸载。**执行垃圾回收</li></ol><h4 id="4-请你介绍一下类加载器？">4. <strong>请你介绍一下类加载器？</strong></h4><img src="https://upload-images.jianshu.io/upload_images/7634245-7b7882e1f4ea5d7d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom:50%;" /><p>JVM预定义的三种类型类加载器：</p><ul><li><strong>启动类加载器（BootstrapClassLoader）</strong>：是一般用本地代码实现，负责将 <code>&lt;Java_Runtime_Home&gt;/lib</code>下面的类库加载到内存中；</li><li><strong>标准扩展类加载器（ExtensionClassLoader）</strong>：<code>&lt; Java_Runtime_Home &gt;/lib/ext</code>或者由系统变量 <code>java.ext.dir</code>指定位置中的类库加载到内存中；</li><li><strong>系统类加载器（AppClassLoader）</strong>：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从<u>环境变量或者系统属性<code>java.class.path</code></u>所指定的目录中加载类，是<strong>用户自定义加载器的默认父加载器</strong>。</li></ul><h4 id="5-请你介绍一下双亲委派机制？为什么要这么做？">5. <strong>请你介绍一下双亲委派机制？为什么要这么做？</strong></h4><ul><li><p><strong>双亲委派机制。<strong>某个特定的类加载器在接到加载类的请求时，首先将加载任务</strong>委托给父类加载器</strong>，<strong>依次递归</strong>，如果父类加载器可以完成类加载任务，就成功返回；<strong>只有父类加载器无法完成此加载任务时，才自己去加载</strong>；</p></li><li><p><strong>为什么要这么做？</strong>  <strong>防止内存中出现多份同样的字节码</strong> 。</p><blockquote><p>比如两个类A和类B都要加载System类：</p><ul><li>如果不用委托：而是自己加载自己的，那么类A就会加载一份System字节码，然后类B又会加载一份System字节码，<strong>这样内存中就出现了两份System字节码。</strong></li><li>如果使用委托机制：会递归的向父类查找，也就是<strong>首选用Bootstrap尝试加载</strong>，如果找不到再向下。这里的System就能在Bootstrap中找到然后加载，如果此时类B也要加载System，也从Bootstrap开始，此时<strong>Bootstrap发现已经加载过了System那么直接返回内存中的System即可而不需要重新加载</strong>，这样内存中就只有一份System的字节码了。</li></ul></blockquote></li></ul><h2 id="1-7-面经补充">1.7 面经补充</h2><h3 id="1-7-1-美团买菜专场">1.7.1 美团买菜专场</h3><ol><li><p><strong>怎么查看指定端口是否开放</strong></p><p>通过 netstat 命令，注意加上-a参数，看是否有<code>0.0.0.0:22</code> 在被监听。</p><p><img src="D:/hwh/images/image-20210906215822732.png" alt="image-20210906215822732"></p><p>通过lsof命令，如果没有任何显示，则端口没有被打开。</p><p><img src="D:/hwh/images/image-20210906215941036.png" alt="image-20210906215941036"></p></li><li><p><strong>join和left join区别</strong></p><p><strong>join相当于我们平时用的where</strong>，就是把两张表中同时满足a.id=b.id的数据找出来；left join是以左表（a）为参考对象，相当于做一个for循环，把a表的数据一条一条的读取出来，然后根据a.id=b.id的条件到b表中查找数据。</p></li><li><p><strong>unio和unio all的区别</strong></p><p>如果我们需要将<strong>两个select语句的结果作为一个整体显示出来</strong>，我们就需要用到union或者union all关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select employee_id,job_id from employees union select employee_id,job_id from job_history</span><br></pre></td></tr></table></figure><p><strong>union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来</strong>，不管是不是重复。</p></li><li><p><strong>unio 和 join的区别</strong></p><blockquote><p>参考：<a href="https://www.jb51.net/article/30975.htm">https://www.jb51.net/article/30975.htm</a></p></blockquote><p>join是对两个表进行联合，相当于where，满足条件的行会被选出，<strong>其中列会被扩充！</strong>  但unio是连接结果集，需要满足列个数相同，<strong>只会保存第一个表列个数，列个数不会被扩充！</strong></p></li><li><p>.<strong>数据库的事务如何实现的？</strong></p><blockquote><p><a href="https://draveness.me/mysql-transaction/">https://draveness.me/mysql-transaction/</a></p></blockquote><p>数据库事务的 ACID 四大特性是事务的基础，了解了 ACID 是如何实现的，我们也就清楚了事务的实现，接下来我们将依次介绍数据库是如何实现这四个特性的。</p><ul><li><p><strong>原子性</strong></p><p>想要保证<strong>事务的原子性</strong>，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，而在 MySQL 中，恢复机制是通过**回滚日志（undo log）**实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。</p></li><li><p><strong>持久性</strong></p><p>与原子性一样，事务的持久性也是通过日志来实现的，MySQL 使用重做日志（redo log）实现事务的持久性，重做日志由两部分组成，一是内存中的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。</p><p>当我们在一个事务中尝试对数据进行修改时，它会先将数<strong>据从磁盘读入内存，并更新内存中缓存的数据</strong>，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，<strong>MySQL 会将重做日志缓存中的内容刷新到重做日志文件</strong>，再将内存中的数据更新到磁盘上，图中的第 4、5 步就是在事务提交时执行的。</p></li><li><p><strong>隔离性</strong></p><p>在 SQL 标准中定义了四种数据库的事务的隔离级别：<code>READ UNCOMMITED</code>、<code>READ COMMITED</code>、<code>REPEATABLE READ</code> 和 <code>SERIALIZABLE</code>；</p><p>数据库对于隔离级别的实现就是使用<strong>并发控制机制</strong>对在同一时间执行的事务进行控制：</p><ol><li><p><strong>锁</strong>： MySQL 和常见数据库中的锁都分为两种，共享锁（Shared）和互斥锁（Exclusive），前者也叫读锁，后者叫写锁。</p></li><li><p><strong>mvcc实现</strong>：实现RC和RR。</p></li></ol></li><li><p><strong>一致性</strong></p><p>数据库对于 ACID 中的一致性的定义是这样的：<strong>如果一个事务原子地在一个一致地数据库中独立运行，那么在它执行之后，数据库的状态一定是一致的</strong>。</p><ul><li>它的第一层意思就是对<strong>于数据完整性的约束</strong>，包括主键约束、引用约束以及一些约束检查等等，在事务的执行的前后以及过程中不会违背对数据完整性的约束，所有对数据库写入的操作都应该是合法的，并不能产生不合法的数据状态。</li><li>第二层意思其实是指逻辑上的对<strong>于开发者的要求</strong>，我们要在代码中写出正确的事务逻辑，比如银行转账，事务中的逻辑不可能只扣钱或者只加钱，这是应用层面上对于数据库一致性的要求。</li></ul></li></ul></li><li><p><strong>binlog日志是做什么的？</strong></p><blockquote><p>参考：<a href="https://www.cnblogs.com/kevingrace/p/5907254.html">https://www.cnblogs.com/kevingrace/p/5907254.html</a></p></blockquote><p>MySQL的二进制日志binlog可以说是MySQL最重要的日志，<strong>它记录了所有的DDL和DML语句（除了数据查询语句select）</strong>，以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。</p><blockquote><p>DDL<br>- Data Definition Language 数据库定义语言<br>主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。</p><p>DML<br>- Data Manipulation Language 数据操纵语言<br>主要的命令是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言</p></blockquote><p>binlog日志有两个最重要的使用场景<br>1）<strong>MySQL主从复制</strong>：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves来达到<br>master-slave数据一致的目的。<br>2）<strong>自然就是数据恢复了</strong>，通过使用mysqlbinlog工具来使恢复数据。</p></li><li><p><strong>arraylist可以存多少数据</strong></p><p>Integer.MAX_VALUE 2147483647 。arraylist底层是一个数组对象Object[] arr = new Object[10]; 数组的大小只能设置int类型。</p></li><li><p><strong>如何自定义类加载器 ，如何打破双亲委派机制</strong></p><p>在实现自己的ClassLoader之前，我们先看一下JDK中的ClassLoader是怎么实现的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> 1 protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line"> 2     throws ClassNotFoundException</span><br><span class="line"> 3     &#123;</span><br><span class="line"> 4     // First, check if the class has already been loaded</span><br><span class="line"> 5     Class c = findLoadedClass(name);</span><br><span class="line"> 6     if (c == null) &#123;</span><br><span class="line"> 7         try &#123;</span><br><span class="line"> 8         if (parent != null) &#123;</span><br><span class="line"> 9             c = parent.loadClass(name, false);</span><br><span class="line">10         &#125; else &#123;</span><br><span class="line">11             c = findBootstrapClass0(name);</span><br><span class="line">12         &#125;</span><br><span class="line">13         &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">14             // If still not found, then invoke findClass in order</span><br><span class="line">15             // to find the class.</span><br><span class="line">16             c = findClass(name);</span><br><span class="line">17         &#125;</span><br><span class="line">18     &#125;</span><br><span class="line">19     if (resolve) &#123;</span><br><span class="line">20         resolveClass(c);</span><br><span class="line">21     &#125;</span><br><span class="line">22     return c;</span><br><span class="line">23     &#125;</span><br></pre></td></tr></table></figure><p>1、<strong>如果不想打破双亲委派模型，那么只需要重写findClass方法即可</strong></p><p><strong>（1）继承ClassLoader</strong></p><p><strong>（2）重写findClass()方法</strong></p><p>2、<strong>如果想打破双亲委派模型，那么就重写整个loadClass方法</strong></p><p><strong>（1）继承ClassLoader</strong></p><p><strong>（2）重写findClass()方法</strong>6</p><p><strong>（3）调用defineClass()方法</strong></p><p>tomcat 为什么要违背双亲委托机制</p><blockquote><p>1） 双亲委托机制不能满足tomcat的业务需求</p></blockquote></li></ol><blockquote><p>2） Webapp类加载器需要独立加载自身的class以及依赖的jar</p><ol start="3"><li>例如，<strong>webapp1</strong>依赖的spring版本为4.x，另一个<strong>webapp2</strong>依赖的spring版本为5.x. 如果使用双亲委托，那么spring的版本只能存在一个，没法满足这个需求</li></ol></blockquote><ol start="9"><li><p><strong>syn锁静态和非静态</strong></p><p><strong>锁静态方法的是当前类；锁方法是当前对象，锁代码块就是（）中配置的对象。</strong></p><ol><li>直接作用于实例方法，相当于给当前对象加锁，进入同步代码前要获得当前实例的锁。这个锁称为对象锁，加锁的对象是当前实例，<strong>两个线程使用的是同一个对象</strong>。其他同步方法需要等待其执行结束并释放锁后才能执行。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pulbic class Something()&#123;</span><br><span class="line">    public synchronized void isSyncA()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public synchronized void isSyncB()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static synchronized void cSyncA()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static synchronized void cSyncB()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">现又Something的两个实例，x和y</span><br><span class="line"></span><br><span class="line">x.isSyncA()与 x.isSyncB()--------------------互斥（同一个实例）</span><br><span class="line"></span><br><span class="line">x.isSyncA()与 y.isSyncA()--------------------互相不影响（不同实例）</span><br><span class="line"></span><br><span class="line">x.cSyncA()与 y.cSyncB()----------------------互相不影响（不同实例之间不会被限制）</span><br><span class="line"></span><br><span class="line">x.isSyncA()与 Something.cSyncA()--------互相不影响（锁不同）</span><br><span class="line">Something.cSyncA() 和 Something.cSyncB() 应该是锁住了，同一个类调用</span><br></pre></td></tr></table></figure></li><li><p><strong>本地java程序默认启动的是什么垃圾回收器？</strong></p><p>cmd执行命令：</p><p>java -XX:+PrintCommandLineFlags -version。</p><p>输出：<a href="http://codewenda.com/xx%EF%BC%9Auseparallelgc%E5%92%8C-xx%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A-useparnewgc/">-XX：UseParallelGC</a>，</p></li><li><p><strong>分布式锁和分布式事务？</strong></p><p>见之前总结。</p></li><li><p><strong>什么时候需要使用分布式锁？</strong></p><ul><li>在<strong>单体应用的</strong>时候，如果<strong>多个线程要访问共享资源的时候，我们通常线程间加锁的机制</strong>，在某一个时刻，只有一个线程可以对这个资源进行操作，其他线程需要等待锁的释放，Java中也有一些处理锁的机制，比如synchronized。</li><li>而到了<strong>分布式的环境</strong>中，当<strong>某个资源可以被多个系统访问使用到的时候（例如，有多个客户端需要访问并操作同一个资源，还需要保持这个资源一致性的时候，就需要使用【分布式锁）</strong>，为了保证大家访问这个数据是一致性的，那么就要求再同一个时刻，只能被一个系统使用，这时候<strong>线程之间的锁机制就无法起到作用</strong>了，因为分布式环境中，系统是会部署到不同的机器上面的，那么就需要【分布式锁】了。</li></ul></li><li><p><strong>JVM 堆中又怎么分的？为什么要这么划分？为什么要取消永久代用元空间代替？</strong></p><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/111809384">https://zhuanlan.zhihu.com/p/111809384</a></p></blockquote><ul><li><p>**堆划分：**堆又被划分为，新生代，老年代。新生代又被划分为eden和survivor区。</p></li><li><p><strong>为什么划分新生代、老年代？</strong></p><p>因为有的对象寿命长，有的对象寿命短**。应该将寿命长的对象放在一个区，寿命短的对象放在一个区**。<strong>不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率</strong>。</p></li><li><p><strong>代替：</strong> 在java7版本前，堆和方法区连在了一起，但这并不能说堆和方法区是一起的，它们在逻辑上依旧是分开的。<strong>但在物理上来说，它们又是连续的一块内存。</strong></p><img src="D:/hwh/images/image-20210906224656302.png" alt="image-20210906224656302" style="zoom:50%;" /><p><strong>也就是说，方法区和前面讲到的Eden和老年代是连续的。</strong></p><p><strong>永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。</strong></p><img src="D:/hwh/images/image-20210906224744446.png" alt="image-20210906224744446" style="zoom:50%;" /><p>在Java8中，元空间(Metaspace)登上舞台，<strong>方法区存在于元空间(Metaspace)</strong>。同时，元空间不再与堆连续，<strong>而且是存在于本地内存（Native memory）。本地内存（Native memory），也称为C-Heap</strong>，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。</p><img src="D:/hwh/images/image-20210906224848120.png" alt="image-20210906224848120" style="zoom:50%;" /><p><strong>元空间存在于本地内存，意味着只要本地内存足够，它不会出现像永久代中“java.lang.OutOfMemoryError: PermGen space”这种错误。看上图中的方法区，是不是“膨胀”了。</strong></p></li></ul></li><li><p><strong>新生代和老年代用哪些<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>？stw问题会发生在新生代吗？</strong></p><ul><li><p><strong>针对新生代，采用标记复制算法</strong>。</p><blockquote><p>参考：<a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">https://tech.meituan.com/2017/12/29/jvm-optimize.html</a></p></blockquote><p>大多数对象在新生代中被创建，其中很多对象的生命周期很短。<strong>每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活</strong>，所以选用复制算法，只需要<strong>少量的复制成本</strong>就可以完成回收。</p><p>HotSpot实现的<strong>复制算法流程</strong>如下:</p><p>1. 当Eden区满的时候,<strong>会触发第一次Minor gc,把【还活着的对象】拷贝到Survivor From区</strong>；当Eden区**【再次触发Minor gc】<strong>的时候,会扫描Eden区和From区域,<strong>对两个区域进行垃圾回收,经过这次回收后还存活的对象,则直接复制到To区域</strong>,并将Eden和From区域清空。<br> 2. 当后续Eden又发生Minor gc的时候,会对</strong>Eden和To区域进行垃圾回收**,存活的对象复制到From区域,并将Eden和To区域清空。<br> 3. 部分对象会在From和To区域中复制来复制去**,如此交换15次**(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代。</p></li><li><p><strong>针对老年代对象存活率高的特点</strong></p><p>在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，<strong>该区域中对象存活率高</strong>。老年代的垃圾回收（又称Major GC）通常使用**“标记-清理”或“标记-整理”算法**。<strong>整堆包括新生代和老年代的垃圾回收称为Full GC</strong>（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。</p></li></ul></li><li><p><strong>程序计数器存哪些东西？能为空吗？</strong></p><p>程序计数器是用于存放下一条指令所在单元的地址的地方，如果正在执行的是Native方法，这个计数器值为空（Ubdifined）。</p></li><li><p><strong>为什么 HashMap 的负载因子设置成 0.75，而不是 1 也不是 0.5？</strong></p><p><strong>在 HashMap 中，临界值（threshold） = 负载因子（loadFactor） * 容量（capacity）。</strong></p><p><strong>那么如何能有效的避免哈希碰撞呢？</strong></p><p>我们先反向思维一下，你认为什么情况会导致 HashMap 的哈希碰撞比较多？</p><p>无外乎两种情况：</p><p>1、容量太小。容量小，碰撞的概率就高了。狼多肉少，就会发生争抢。</p><p>2、hash 算法不够好。算法不合理，就可能都分到同一个或几个桶中。分配不均，也会发生争抢。</p><p><strong>为了避免哈希碰撞，HashMap 需要在合适的时候进行扩容</strong>。那就是当其中的元素个数达到临界值的时候（<strong>【等全满了再扩容，那么在此之前容量太少，导致碰撞的概率过高】</strong>），而这个临界值前面说过和 loadFactor 有关，换句话说，<strong>设置一个合理的 loadFactor</strong>，可以有效的避免哈希冲突。</p><blockquote><p>JVM中原话：</p><p><strong>一般来说，默认的负载因子 (0.75) 在时间和空间成本之间提供了很好的权衡。更高的值减少了空间开销，但增加了查找成本(反映在 HashMap 类的大多数操作中，包括 get 和 put)。</strong></p><p>另一方面，<strong>为了保证负载因子（loadFactor） * 容量（capacity）的结果是一个整数，这个值是 0.75(3/4) 比较合理，因为这个数和任何 2 的幂乘积结果都是整数。</strong></p></blockquote></li><li><p><strong>ConcurrenthashMap使用的时候有可能出现不安全的情况？</strong></p><blockquote><p>参考：<a href="https://blog.csdn.net/luzhensmart/article/details/108133560">https://blog.csdn.net/luzhensmart/article/details/108133560</a></p></blockquote><p>查了一些资料后发现，**原来ConcurrentHashMap的线程安全指的是，它的【每个方法】单独调用（即原子操作）都是线程安全的，但是代码总体的互斥性并不受控制。**以上面的代码为例，最后一行中的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            this.addup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void addup() &#123;</span><br><span class="line">        if (!map.containsKey(KEY)) &#123;</span><br><span class="line">            map.put(KEY, 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.put(KEY, map.get(KEY) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>在上面一个线程内部进行了100次加法，但是其实加1在线程内部本身也并不是原子操作。</strong></p><p>实际上并不是原子操作，它包含了三步：</p><ol><li>map.get</li><li>加1</li><li>map.put</li></ol><p>是由于在上面的代码中，map本身是一个共享变量。<strong>当线程A执行map.get的时候，其它线程可能正在执行map.put</strong>，这样一来当线程A执行到map.put的时候，线程A的值就已经是脏数据了，然后脏数据覆盖了真值，导致线程不安全。</p></li><li><p><strong>同步和异步的区别？</strong></p><ul><li><p>同步，可以理解为在执行完一个函数或方法之后，<strong>一直等待系统返回值或消息，这时程序是出于阻塞的</strong>，只有接收到返回的值或消息后才往下执行其他的命令。</p></li><li><p>异步，执行完函数或方法后，<strong>不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程</strong>，那么当系统接收到返回值或消息时，系统会<strong>自动触发委托的异步过程</strong>，从而完成一个完整的流程。</p></li></ul></li><li><p><strong>wait和notify为什么要放在同步锁里？</strong></p><p>结合多线程循环打印的例子来看，不放在同步块里，要唤醒等待对象是哪个锁就不够明显。</p></li><li><p><strong>说说Treemap的底层原理？</strong></p><p>TreeMap实现了SotredMap接口，它是有序的集合。<strong>而且是一个红黑树结构，每个key-value都作为一个红黑树的节点。<strong>如果在调用</strong>TreeMap的构造函数时没有指定比较器，则根据key执行自然排序</strong>。这点会在接下来的代码中做说明，如<strong>果指定了比较器则按照比较器来进行排序</strong>。</p><ul><li>自然排序：TreeMap的所有key必须实现Comparable接口，所有的key都是同一个类的对象</li><li>定制排序：创建TreeMap对象传入了一个Comparator对象，该对象负责对TreeMap中所有的key进行排序，采用定制排序不要求Map的key实现Comparable接口。等下面分析到比较方法的时候在分析这两种比较有何不同。</li></ul></li></ol><h3 id="1-7-2-Shoope-SG专场"><strong>1.7.2 Shoope SG专场</strong></h3><ol><li><p><strong>char和byte的区别 ， 能否强制转换？</strong></p><p>区别：</p><ul><li>Char是无符号型的，可以表示一个整数，不能表示负数，大小范围 是0—65535；而byte是有符号型的，可以表示-128—127 的数</li><li>char可以表中英文字符，byte不可以</li></ul><p>强制转换：</p><p>可以，但是会出现精度丢失。</p></li><li><p><strong><a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a><a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>哪些是稳定的，稳定性体现在哪？</strong></p><p><a href="https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a>、<a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a>、<a href="https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a>、<a href="https://baike.baidu.com/item/%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">直接选择排序</a>是不稳定的排序算法，而<a href="https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a>、<a href="https://baike.baidu.com/item/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">直接插入排序</a>、<a href="https://baike.baidu.com/item/%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">折半插入排序</a>、<a href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a>是稳定的排序算法。</p><ul><li><strong>稳定性</strong>：<strong>2个相等的数其在序列的前后位置顺序</strong>，和排序后它们两个的前后位置顺序<strong>相同</strong></li></ul></li><li><p><strong>数据库乐观锁和悲观锁，如何实现</strong></p><p>乐观锁：</p><ol><li>版本号</li><li>时间戳：乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</li></ol><p>悲观锁：</p><p>直接加上读锁或者写锁，SELECT … FOR UPDATE</p></li><li><p><strong>如何以UDP为基础设计实现TCP协议优点的新协议</strong></p></li><li><p><strong>web网页卡怎么排查？cpu100%怎么排查？OOM怎么排查？</strong></p><p>web卡：</p><ol><li>**用户端：**硬件配置低、资源不足；CPU 或者内存资源不足, 比如用户是否使用了 Chrome 这种 “吃内存大户” 的浏览器并且打开了很多网页?</li><li><strong>网络分析：</strong> <strong>DNS 解析慢</strong>；<strong>未设置 CDN</strong>，如果没有设置 CDN, 在跨线路访问(比如用户是铁通, 但是服务器部署在联通, 这种情况就是跨线路), 地理位置相差很远 等情况 ；用户端的带宽不足或所处环境网络不佳；</li><li><strong>服务端：</strong> 服务端响应慢，性能比较差</li></ol><p>cpu100%：</p><blockquote><p>参考：<a href="https://www.cnblogs.com/dennyzhangdd/p/11585971.html">https://www.cnblogs.com/dennyzhangdd/p/11585971.html</a></p></blockquote><ol><li><p><strong>执行“top”命令</strong><code>：查看所有进程占系统CPU的排序。极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。</code></p></li><li><p>执行“<strong>top -Hp 进程号</strong>”命令：查看java进程下的<strong>所有线程占CPU的情况</strong>。</p></li><li><p>执行“printf &quot;%x\n 10&quot;命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，咱们需要把线程号转成16进制。例如,printf &quot;%x\n 10-》打印：a，那么在jstack中线程号就是0xa.</p></li><li><p>执行 <strong>“jstack 进程号 | grep 线程ID” 查找某进程下</strong>-》线程ID（jstack堆栈信息中的nid）=0xa的<strong>线程状态</strong>。如果““VM Thread” os_prio=0 tid=0x00007f871806e000 nid=0xa runnable”，第一个双引号圈起来的就是线程名，如果是“VM Thread”这就是虚拟机GC回收线程了。</p><p>代码中有大量消耗CPU的操作，导致CPU过高，系统运行缓慢,</p><blockquote><ol><li><p>jstack，可直接定位到代码行。例如某些复杂算法，甚至算法BUG，无限循环递归等等。</p></li><li><p>如果有死锁，会直接提示关键字：deadlock。步骤4，会打印出业务死锁的位置。</p></li></ol></blockquote></li><li><p>执行“jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一致统计）”，<strong>查看某进程GC持续变化情况</strong>，<strong>如果发现返回中FGC很大且一直增大-》确认Full GC!</strong> 也可以使用“<strong>jmap -heap 进程ID”查看一下进程的堆内从是不是要溢出了</strong>，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。</p><blockquote><p>jstat命令监控GC情况，可以看到Full GC次数非常多，并且次数在不断增加</p></blockquote></li><li><p>执行“jmap -dump:format=b,file=filename 进程ID”，导出某进程下内存heap输出到文件中。可以通过eclipse的mat工具查看内存中有哪些对象比较多</p></li></ol><p>OOM排查：</p><blockquote><p><a href="https://www.cnblogs.com/valjeanshaw/p/13130102.html">https://www.cnblogs.com/valjeanshaw/p/13130102.html</a></p></blockquote><p>先通过内存映像工具对Dump出来的堆转储快照进行分析，<strong>重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=$java_pid.hprof     #java_pid为java进程ID</span><br></pre></td></tr></table></figure><p>然后看具体是报什么错：很明显下面是堆溢出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to oom.out ...</span><br><span class="line">Heap dump file created [3196858 bytes in 0.016 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">        at java.util.Arrays.copyOf(Arrays.java:3332)</span><br><span class="line">        at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)</span><br><span class="line">        at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:700)</span><br><span class="line">        at java.lang.StringBuilder.append(StringBuilder.java:214)</span><br><span class="line">        at jvm.OomDemo.main(OomDemo.java:13)</span><br></pre></td></tr></table></figure></li><li><p><strong>如何利用反射创建一个对象？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 得到Stu类的运行时Class描述符</span></span><br><span class="line">            <span class="comment">//简单理解为你现在有了这个类，可以调用相应的方法进行实例化了</span></span><br><span class="line">            Class&lt;?&gt; stu = Class.forName(<span class="string">&quot;Stu&quot;</span>);</span><br><span class="line">            <span class="comment">//2.从getDeclaredConstructor()的字面意思就能理解，得到所有声明的构造器</span></span><br><span class="line">            <span class="comment">//这里得到的是所有声明的构造器，getConstructor()则只能得到被public修饰的构造器</span></span><br><span class="line">            Constructor&lt;?&gt; declaredConstructor = stu.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;String.class, <span class="keyword">int</span>.class&#125;);</span><br><span class="line">            <span class="comment">//3. 使用newInstance()方法创建对象并传入参数</span></span><br><span class="line">            <span class="comment">//简单的理解为Stu o = new Stu(&quot;zhangsan&quot;, 01)</span></span><br><span class="line">            Stu o = (Stu) declaredConstructor.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="number">01</span>&#125;);</span><br><span class="line">            <span class="comment">//4.调用Stu这个类里面的方法</span></span><br><span class="line">            <span class="comment">// getDeclaredMethod()方法能调用到所有声明的方法</span></span><br><span class="line">            Method method = stu.getDeclaredMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line">            <span class="comment">//5. 简单的理解为o.toStirng()</span></span><br><span class="line">            String invoke = (String)method.invoke(o, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">            System.out.println(invoke);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>加密了解的<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a> 说说具体怎么实现的 ？</strong></p></li><li><p><strong>我现在有个字段比如，它的值可能正，可能负（形容方向），而我的sql查询该字段时要计算它的绝对值，这样因为计算了索引会失效，你会怎么优化？</strong></p><ol><li>拆成两列1列只存绝对值，另起一列tinyint来表示正负或者方向；</li><li>先查询到结果，然后再查询的结果上进行操作（取绝对值）？</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（二）Redis基础</title>
      <link href="/2021/11/25/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89Redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/11/25/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89Redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Redis">一、Redis</h2><h3 id="1-1概述">1.1概述</h3><p>redis是一款高性能的<u>NOSQL</u>系列的非关系型数据库 。</p><ul><li><p><strong>NoSQL(NoSQL = Not Only SQL) :</strong>  “不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。为了<strong>解决大规模数据集合多重数据、高性能查询数据</strong>带来的挑战，尤其是<u>大数据</u>应用难题。</p><p><img src="https://i.loli.net/2021/04/29/RjP9o4cDUdnvw2K.png" alt="image-20210429230948481"></p></li></ul><blockquote><p>由缓存到redis解释。</p></blockquote><ul><li><p><strong>缓存思想</strong></p><p>直接操作数据库通常是很费时的，我们可以把在内存开辟一块区域作为<u>缓存，存储经常访问的数据。</u></p></li><li><p><strong>缓存具体实现</strong></p><p>缓存的实现有多种，比如开辟一块内存空间使用map集合。但是：</p><ul><li>map是运行到JVM中，只能固定分配一些内存，比较小</li><li>map集合如果涉及分布式，没法部署</li></ul></li><li><p><strong>redis</strong></p><ul><li>整台机器内存都可以被redis数据库分配</li><li>可以部署分布式</li></ul></li></ul><h4 id="NOSQL和关系型">NOSQL和关系型</h4><ul><li><p><strong>各自优势对比</strong></p><table><thead><tr><th style="text-align:center">NOSQL</th><th style="text-align:center">关系型</th></tr></thead><tbody><tr><td style="text-align:center">【<strong>性能</strong>】：NOSQL是基于键值对的，（1）<u>不需要经过SQL层的解析</u>，所以性能非常高（2）NOSQL数据库将数据<u>存储于缓存</u>之中，而不是硬盘，查询快</td><td style="text-align:center">【<strong>复杂查询</strong>】：复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询</td></tr><tr><td style="text-align:center">【<strong>存储格式</strong>】：NOSQL的存储格式是key,value形式，可以<u>存储基础类型以及对象或者是集合等各种格式</u>，而<u>数据库则只支持基础类型</u></td><td style="text-align:center">【<strong>安全性&amp;事务</strong>】：事务支持使得对于安全性能很高的数据访问要求得以实现</td></tr><tr><td style="text-align:center">【<strong>扩展性</strong>】：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难；NOSQL基于键值对，<u>数据之间没有关联关系</u>，所以非常容易水平扩展</td><td style="text-align:center"></td></tr></tbody></table></li><li><p><strong>总结</strong></p><p>关系型数据库与NoSQL数据库<strong>并非对立而是互补</strong>的关系：</p><ul><li><strong>关系数据库：</strong> 所有数据存储的位置</li><li><strong>NoSQL：</strong> 备份（缓存）关系数据库的（常用？）数据</li></ul></li><li><p><strong>redis的应用场景</strong></p><ul><li><strong>缓存（最重要）</strong></li><li>聊天室的在线好友列表</li><li><strong>任务队列</strong>。（秒杀、抢购、12306等等）</li><li><strong>应用排行榜</strong></li><li>网站访问统计</li><li>数据过期处理（可以精确到毫秒</li><li>分布式集群架构中的session分离</li></ul></li></ul><h4 id="下载-安装">下载&amp;安装</h4><ol><li><p>下载</p><p>下载地址：<a href="https://github.com/tporadowski/redis/releases/">https://github.com/tporadowski/redis/releases/</a></p><p><img src="https://i.loli.net/2021/04/29/xdhgX2A7VNeLGvW.png" alt="image-20210429233653126"></p></li><li><p>启动</p><p>解压后分别启动：</p><ol><li><p>启动服务端：<code>redis-server.exe</code> （不要关闭！！）</p></li><li><p>启动服务端：<code>redis-cli.exe</code></p><p><img src="https://i.loli.net/2021/04/29/oX45EalqtdYLPbf.png" alt="image-20210429234624925"></p></li></ol></li></ol><p>安装完成开始愉快使用了。</p><h3 id="1-2-数据结构">1.2 数据结构</h3><h4 id="基本操作">基本操作</h4><p>redis存储的是：<code>&lt;key,value&gt;</code>格式的数据，其中<code>key</code>都是字符串，<strong><code>value</code>有5种不同的数据结构</strong> :</p><ol><li><p>字符串类型： <code>string</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.存储 : set &lt;key&gt; &lt;value&gt;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> username zhangsan </span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.获取: get &lt;key&gt; </span></span><br><span class="line">127.0.0.1:6379&gt; get username </span><br><span class="line"><span class="string">&quot;zhangsan&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.删除 </span></span><br><span class="line">127.0.0.1:6379&gt; del username </span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure></li><li><p>哈希类型 <code>hash</code> ： <code>map</code>格式</p></li></ol>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.存储：hset &lt;key&gt; &lt;field&gt; &lt;value&gt;</span></span><br><span class="line">127.0.0.1:6379&gt; hset myhash username lisi</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.获取: hget &lt;key&gt; &lt;field&gt;</span></span><br><span class="line">127.0.0.1:6379&gt; hget myhash username </span><br><span class="line"><span class="string">&quot;lisi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash  <span class="comment"># 获取所有键值对</span></span><br><span class="line">1) <span class="string">&quot;username&quot;</span> </span><br><span class="line">2) <span class="string">&quot;lisi&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.删除:  hdel &lt;key&gt; &lt;field&gt;</span></span><br><span class="line">127.0.0.1:6379&gt; hdel myhash username </span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><ol start="3"><li><p>列表类型 <code>list</code> ： <code>linkedlist</code>格式。支持重复元素</p><p>其实更<strong>相当一个队列</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.存储 </span></span><br><span class="line"><span class="comment"># lpush &lt;key&gt; &lt;value1&gt;: 将元素加入列表头部</span></span><br><span class="line"><span class="comment"># rpush &lt;key&gt; &lt;value1&gt;: 将元素加入列表尾部</span></span><br><span class="line">127.0.0.1:6379&gt; lpush myList a</span><br><span class="line">(<span class="built_in">integer</span>) 1 </span><br><span class="line">127.0.0.1:6379&gt; lpush myList b </span><br><span class="line">(<span class="built_in">integer</span>) 2 </span><br><span class="line">127.0.0.1:6379&gt; rpush myList c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.获取 ：lrange &lt;key&gt; &lt;start&gt; &lt;end&gt;  范围获取</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 -1 </span><br><span class="line">1) <span class="string">&quot;b&quot;</span> </span><br><span class="line">2) <span class="string">&quot;a&quot;</span> </span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.删除：</span></span><br><span class="line"><span class="comment"># lpop key： 删除列表最左边的元素，并将元素返回 </span></span><br><span class="line"><span class="comment"># rpop key： 删除列表最右边的元素，并将元素返回</span></span><br></pre></td></tr></table></figure></li><li><p>集合类型 <code>set</code> ： 不允许重复元素</p></li></ol>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 存储：sadd &lt;key&gt; &lt;value1&gt; &lt;value2&gt; ...</span></span><br><span class="line">127.0.0.1:6379&gt; sadd myset a b</span><br><span class="line">(<span class="built_in">integer</span>) 2 </span><br><span class="line">127.0.0.1:6379&gt; sadd myset a</span><br><span class="line">(<span class="built_in">integer</span>) 0  <span class="comment"># 没有更新成功！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 获取所有元素：smembers &lt;key&gt;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers myset </span><br><span class="line">1) <span class="string">&quot;a&quot;</span> </span><br><span class="line">2) <span class="string">&quot;b&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 删除：srem &lt;key&gt; &lt;value&gt;  </span></span><br><span class="line">127.0.0.1:6379&gt; srem myset a </span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><ol start="5"><li><p>有序集合类型 <code>zset</code>：不允许重复元素，且元素有顺序</p><p>每个元素都会<u>关联一个double类型的分数</u>。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.存储：zadd &lt;key&gt; &lt;score&gt; &lt;value&gt; </span></span><br><span class="line">127.0.0.1:6379&gt; zadd mysort 60 zhangsan </span><br><span class="line">(<span class="built_in">integer</span>) 1 </span><br><span class="line">127.0.0.1:6379&gt; zadd mysort 50 lisi </span><br><span class="line">(<span class="built_in">integer</span>) 1 </span><br><span class="line">127.0.0.1:6379&gt; zadd mysort 80 wangwu </span><br><span class="line">(<span class="built_in">integer</span>) 1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 获取：zrange  &lt;key&gt; &lt;start&gt; &lt;end&gt; &lt;withscores&gt;（有序）</span></span><br><span class="line">127.0.0.1:6379&gt; zrange mysort 0 -1 </span><br><span class="line">1) <span class="string">&quot;lisi&quot;</span> </span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span> </span><br><span class="line">3) <span class="string">&quot;wangwu&quot;</span> </span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrange mysort 0 -1  </span><br><span class="line">1) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">2) <span class="string">&quot;60&quot;</span> </span><br><span class="line">3) <span class="string">&quot;wangwu&quot;</span> </span><br><span class="line">4) <span class="string">&quot;80&quot;</span> </span><br><span class="line">5) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">6) <span class="string">&quot;500&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.删除：zrem &lt;key&gt;  &lt;value&gt; </span></span><br><span class="line">127.0.0.1:6379&gt; zrem mysort lisi </span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure></li></ol><h4 id="通用命令">通用命令</h4><ol><li><p>**keys *** : 查询所有的键</p><p>如果<u>不知道自己以前存储的键</u>，可以用这个命令获取：</p><p><img src="https://i.loli.net/2021/04/30/HGz7yiaY25T3jBw.png" alt="image-20210430110218600"></p></li><li><p>**type <key> ** ： 获取键对应的value的类型</p><p>但是如果想知道，<code>“myset”</code>对应是什么类型呢？</p><p><img src="https://i.loli.net/2021/04/30/3hFUf1wKP5ZlaBH.png" alt="image-20210430110328939"></p></li><li><p>**del <key> **：删除指定的key value</p><p>区分具体数据结构，如<code>hashmap</code> ，删除某个数据。<code>del &lt;key&gt; </code> 直接将存储的<code>hashmap</code>都删了。</p></li></ol><h3 id="1-3-持久化">1.3 持久化</h3><p>redis是一个<strong>内存</strong>数据库，当redis<u>服务器重启 / 电脑重启</u>，<strong>数据会丢失</strong>，我们可以将redis内存中的数据<strong>持久化保存到硬盘</strong>的文件中。</p><h4 id="RDB（默认）">RDB（默认）</h4><p>在<strong>一定间隔时间</strong>中，<u>检测key的变化</u>情况，然后持久化数据 。</p><ol><li>编辑<code>redis.windwos.conf</code>文件</li></ol>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># after 900 sec (15 min) if at least 1 key changed </span></span><br><span class="line">save 900 1 </span><br><span class="line"><span class="comment"># after 300 sec (5 min) if at least 10 keys changed </span></span><br><span class="line">save 300 10 </span><br><span class="line"><span class="comment"># after 60 sec if at least 10000 keys changed</span></span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><ol start="2"><li><p>（测试）设置每10s检测一下，如果至少有5个key发生改变就保存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># after 60 sec if at least 10000 keys changed</span></span><br><span class="line">save 10 5</span><br></pre></td></tr></table></figure><p>然后我们修改<code>set</code> 类型myset集合键<code>name</code> 5次：</p><p><img src="https://i.loli.net/2021/04/30/KzplDecmRdxTQ8I.png" alt="image-20210430112644970"></p><p>关闭服务器，和客户端。但是可以看见在<code>redis</code>目录下生成了<code>dump.rdb</code> 文件：</p><p><img src="https://i.loli.net/2021/04/30/WbwrjMhoVsPpXEB.png" alt="image-20210430112750575"></p><p>再次启动服务器和客户端，发生<code>name</code> 依旧在：</p><p><img src="https://i.loli.net/2021/04/30/XDYRlS4PUmV5nFt.png" alt="image-20210430112912830"></p></li></ol><h4 id="AOF">AOF</h4><p><strong>日志记录</strong>的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据。</p><ol><li><p>编辑<code>redis.windwos.conf</code>文件</p><p>首先开启AOF :  将下面修改为 <code>appendonly yes</code></p><p><img src="https://i.loli.net/2021/04/30/gPwenHdqQJWDK7m.png" alt="image-20210430114133701"></p></li><li><p>修改AOF模式</p><p>默认是  <code>appendfsync everysec</code> （每秒进行记录）</p><p><img src="https://i.loli.net/2021/04/30/xHPtkj3TwgZSlfM.png" alt="image-20210430114310240"></p><ul><li><code>appendfsync always</code>  ： <u>每次操作</u>都持久化</li><li><code>appendfsync no</code> ： 不进行持久化，<strong>此时redis==相当大map集合</strong></li></ul></li><li><p>（测试）重启服务端、客户端</p><p>首先可以发现，多了个<code>appendonly .aof</code> 文件</p><p><img src="https://i.loli.net/2021/04/30/eCgxkw2HFtpqiJD.png" alt="image-20210430114736307"></p><p>随意保存一些数据，重启数据库可以发现数据依旧存在。</p></li></ol><h3 id="1-4-Jedis快速入门">1.4 Jedis快速入门</h3><p>Jedis是 一款java操作redis数据库的工具。</p><p>快速实践：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 获取连接 </span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>); </span><br><span class="line"><span class="comment">//2. 操作 </span></span><br><span class="line">jedis.set(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>); </span><br><span class="line"><span class="comment">//3. 关闭连接 </span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><h4 id="Jedis操作">Jedis操作</h4><blockquote><p>下面是API相关调用，先不学了。</p></blockquote><h3 id="1-5-连接池">1.5 连接池</h3><h4 id="介绍">介绍</h4><h4 id="工具栏">工具栏</h4><h3 id="1-6-案例分析">1.6 案例分析</h3><p>先从sql数据库查询，然后可使用redis<strong>缓存一些不经常发生变化的数据</strong> 。</p><h4 id="环境搭建">环境搭建</h4><h4 id="查询数据库">查询数据库</h4><h4 id="redis缓存优化">redis缓存优化</h4>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
