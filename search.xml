<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++从零开始（二）：基础语法（上）之快速入门</title>
      <link href="/p/52463/"/>
      <url>/p/52463/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码不正确，请重试.." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0fcd223a4421b8c262f41149f0fa3fb34c652fdbb76b4a535977b728ae9acd8b">10d79030e8222445804370796b90fca14b3382df4730eb0fe3a9f1aa6acbfdf977f308135c251cf4014cb9472e5eb4c74c686d76752dbbe94ba3f69cf8b56fccce0b6d03e83f93189a71b67d05f4dbf54cba5ee819dc1b6d55811c290f69fe8176eda4eea983382076725f2c5e66d3dae75e05d45c454e836953ccc0feca1164c86854f300edf714a15efc77ed893ba2c37407262592ad84cd232705eb08c266828b8a0da602b10db78cc9119003bb818fb3d71c42accdfeee17bdd144b9ec13cc89e7d71fb2ff8c6a914dd0209ac136c4786c0bff26b10adfcb5d2bf084a25f33a9d9aa332d48d3c4b64b27daaa06b54c7f20047e2417ec58bc19ed07213e262226c8176a1ab62b53ee54320aabdd2efff1655d83ebf772b3f819cd9098866b323f2586a5d8a9a6942a3e830db907a4283a427c68ac0a8b0274bb2b60f60c246d9f21d3cedffb1e59ccb758e649ccf27a756befd1af677c27377f5fdd36bb0c834820a92d54a3197740f81c66b692af8fbb171c9033e9a06e2418bdac2e287210b0db287dc7f93bcd1fdc38fe718dc76b450d2a8ca192bace2000207c556641a48f2e4764aaf6f89110b7e64c3978c81bcc07b61e9c1f01336c97aca0a2df9cd43b5d7fd58ea8390f8c83f32ac22268a33bfe27bf288212cbdd9e047a608471d089f3198ff94fef07658a0d252476480092a47e5b7aaa476fef88f751c1783f5273967f8f490f4e1376249ae16fe91b1a15ecd138eef5e020174ec78bef2b9f7d81bfcfdcf8ebccc7ceec3729315bfc6942c6400dca925583af3a9441a9d353c3c6028e40d6d29401e39f8901878d7faaf912c83ccfbf8a01a5276c9143a3dd29ead699862495eae327d03c529424eee2876afab283d8fe9175179090776ca18ea259210ce82931bbbd83eee4e9921354e31391d92d8035dff8aa717a7eddc55148974be0aa99deefef3d9ef4dae4e1a4a307482bb6e659132fa8b63098615afb597c4cf4bb8cdcbb812b55387145ee6343fe8c2b892b8b8615483dd1e953382412ababfe18af2b9e75cd0c052f1464d55ca2ace40a104e48af9a6bf36d2cdf4806e951a7da0c45a79eeede215789f5f7585aacf4b433b3e84b907d00555d3cd4e86ed87d8e06df4238f66c8a4723aaa052310060e6359d8a09c090b0721b080b16bfcb1c8aa31923cb8448d21fc3c8a906490c274e7b66c0bae9fca89613498806eb0363372307fff2275d2e9d0e64a4da004da38ec915fe0a469423a30cf1c18610c257e7a7ed042754dfcc9a5ab07368c9382458afcc20d371d39ada08e76a914f424344c53b449daa19823a52f15eb5248244728148d67d966aa281f8f68ff754f4c2a8f110bdc2767d197cfd31a6a113b1523d51e9b2730a9396d61bbddc0f6575e367fa9d99155f5f47ad7ded4be76cd814cc5122b0d449699e4ea755c6b3a4c469d57bcaf08cb976e45b4609d06dda9a9441e4e7523ec13a825a5dea81d77614cc8e618a223c456cd69c2953f69e2cf1dbc69aafaa6b9bf8d7a172e2d1a3f2018701f0adbf92f01fbb591955ebb093a05fd543b4a7490ddc0e9d6dc27cc91f42aef16c98986fb90db26b497655969163e9fd53ed863a5c89a420e7b9c99f359e5acc8327cc91bd3ec3ce0a99136bfaf4b7b6480f491ab6ffc149e81aff2e65b0a6f7b7afb771eab5b1e92f4e4a994e7f9cebb94bf6a2d010f24ee299415d72d1f40c31e7f769340ad1d42bf8e5b1300f5438265960d0d85cabd0f270ddb3a93edb4cdf8b78a0ca5fc04cc36ff7a3d0eeb9da4d8316107f9e8989c16d83503909d4c2e1dea3ef978179df9b0b3a52ffbe5f9b81e5e1a6dfbcf1bd36835c55e9c79944fc61d56f6dcd7d71b7f468141f460164401d867186b973f67105645e6fa767ec2c400e045ff2a48c9efcafba589389f2fc7febe544827dd0060d327951e1fb9046c979cb9b8f5b23cd7bf796abfd8f8a789d02ab41ff245c4e583a514de2c10c2d681e73371bbf6e4aa355147182a229aa6a9ad7d0cdc1fbf75d16b3778a96ad75f0031871b03a9f767dc8b66741b2ce4be253af3b16d44fa1fb36edd49e76282dc077963cc9ab297d0df8232b926bdd4cc5c810bf6be3a61d1a63a59af99278bf61141189a2edb9c03de53911e35a1e9854599f4b49d8431a7fc5d77f24ddb413976411e35f6a13a82fac2307a2bcbc3f0f8ec0a8debd18603119ba087d64e3db7eb264e8e6a7085cecf5a39fbf52e8672abf30e914024546e54020a5520e0ecade30fe70cafa28ce6dd2546fadcd44732000b225de2e7bd5597e63c234cd92fc30224b14568d65d96552adb71336afe090f39c6578ba5d30a1f2aff4bae272453341d7a5210c40b6a17773e1b2257d3d3a438cc117cf18af67fe4604c64923c80b546942ffcc377b923a2304e38fd299adebdbc31e57a33ead5adaa452a5c7b5ee2e5d8ed88bc464afc0619c4cbb3afec6909a8c31809a7c4d15134e02df4024da1722c52677d21d5293fb76b063b768de7abffa5dd5976f0d62bab4be1e28651a7123d0f4112c31246f6be514ff6cde5b1dcff96c68491dedabc6f1b12edbdc8fae8b7b012a85891f27f5c702e11727cd787e91225c8382c1f2a4e306477097d6cd5b85faacb52f7acd2f701479fc38056d2ad32bffef96cd75803c4094aaef498a0fb1d46562bfe6e96395b5533a86b52ee38a9a7aa6162b6c99cef073c62be636a3e74c4a76fa29ae3087c0ba4cf93dc06d94d91717c274108c16dfe87aa8118b92b931553b6adc8c7af35eb63366bd86e534312e69aa5e45a5ec5a50a85558a2d711160e5b257fb38541a2d93bc4b3264e31a0f04204294299f6eca6652e68919806a1c3a941437c72a44b279b41377bd84ea521bfb593b4e53a29d4622cd18172dcb784f17f4fc2ae6a9db6706a86321743b5ad1b045987cf41a437781a1dc62a106aef0d7d7e32625308436d8d62c12bcf594893415fa3400fc9c0c091d9881e89e19bcdca779be444d47a3650731ab6e245d452ac0d3fad25793a3e427d896bdab156bfa87ddb0ed8f3bc7bb732e3e937098f63b5177f9761cfbff9d766cfc53974ba64fb1e3d542712bed5880aae29fd6c4decd8005175165921bb8a72bf729cdb5a478654df7831dbd911d1fa0c5753d73d09e9ade4ba75b7436e1e76ccd17d5a3044aaaa390d9c25df252860772bf64009a20a82cc0c431543336579226fcb62610d004f59d8cdac9b0809219312abd7eb0189ac88108501b602d22210d0fc635c18e99632e3c3d4c724171b35c1984584d91a5c00652ca5a8a318910dcd0d88947080d2ca25005540f0285dfd2d21a5916bc93accea558c7e976390028a3075086a23596c66136cd0d996427a0964fcbfd47f3784649f51d83d2b25d411b61b033b231613a02fef82f6fe377889a1aff4f3c9f77168b8c7df484c4da96265920044d5057433f2bef721b2fa74bdb0920f743f1c747c42ac49ac1007e758da71138ca38b7ce16bd63071489f27914c18f43817dfef509dcb0c5ce36d826faf8f4c1062b46747538619b13ce164614a863f9a2816962206fdc3a5394241d2a5a7d3a2037d8dd45a0cdf00a1fa96d0b36da7dea1f2337bbb6a90d6a25975a985664c9a893ad8fcfabd9b5391a7b5955dd869ea8bbeca4e933eb3efd7b35069199949d1d370a9276fa405454693c72ad15fb006a3984c151d47ac38b895fd4262c9921e93f4302970fc2f89c1b8c7362b630872b18b817f0e3c3b053979e4ef52c8e745bdb19fdffbee0aead4f119347f587f5b23ea6c88a1844c196c3e6bdedea85515758ea8df8062d2767744927e5af873b701f7fc88ba358d5009b27448c3485619f3f3821ec5248cdc53235aae81ce92aa52b8c6aea77ea1bc027822c3b3c0f3fdb4953be0a2417f8fc362b9c5d43373f77a9260d842142ca00514f3e9ce71bff69430d06992626f3a99e45b9b11147b84dbe87d97b11cbf62743f000122b452787e17fa3bc6415666b29190747aed5437fb70226b8cc464b958ba4382e37470488630db26bef174c1eb89bfe09f08f2711fc557896448cc0d1c1d9bd47dca4423e1d0c532c089654909896bd5461d18030f58fa062ae99d943a1a25fb85205b99216b2b1148cd59ef5e6bb0c90e90bce644e1470ebabd0307ee92c1a9855b7a79248bff334cc3264d24f450712ffd0520eddaea4877ee3fe77fb6a17b0778a00e955d976f9afdee60b2357393bec204a40c564eaeccc224a02e399be58ca5262fed971963db8f26edb36f98d2f128eeacaab971fed8fd31cb9782729a3307d62cef4f55382cdbf357092e3b4f10451ce865bcb78b372791bc7c8bb197925c3ee9616cf74b5fa61d8648d25e718388c651641cf15a0e6bc573ea901d3422c00f7a9d0143391a2f59d0af7ec4c35495cf10def3f20c3c03606f9d8c4913c136f594617cf13c174b79b18cc08d5b31817a4d4efb3aeb362831a2a161c35f26b6568b7e37b7c97ed30ef981a9b066676a3f65ded4d4cedc4dcbdf8e76e9d7b25e78fc45075389543f39b6e21b2fbfa3282bd882d002b1886472fe35d9c5c5c49f089b54cb7e57ec79312cbf2aa681716d50c4633f88ece05961b08bba5a867e23f31fb688bd5c3cabd30e6f9a769e387ce28e53be4152ff25d2cfda926da04cc1b3406873a8ec91ed9b40da3f35ba7040737aa4e1ddcea153c15ae34f6ed2db96978ecc8331ff310ebad959f19deb5b6198bb776addbbcb642d6cee7d3db32a8370b04b3588280e2e0cc20c41566854cca26ed15d14e32f69718c29d9be8164e1eb58566fa3e9c210a5fdd7e2e40d61833b7ad7253b5151028c1ee520fe47e9a35a9a14cb80032a85cdaf0af4efe6b6779316a7b7906e3acea361abfa061580fcd70c5cb1628a87ee7fcb4312fb510f25eb409b40d2ed05932d6e1e51f16ed6a7131a99172d05f3f24e0c1d07552a763659b53c6c2a66a19543485a87d257ed0b34c0a835f61fb9bebb888ca23c8bc1a0663995562f5f0f2a5deb82037a4b4ac1ff2676ccb8d476ccf987a45067ad2fdfa9689ec3858e6759c12fee5fab6b1668fa44b9e740a729c21ca3e7b6db45580ed12a4b93f144826b4ecf76d74b48c4713fc57ecc070ce72b12fd30713b9e62cd03b11b175c8e9a94854528d28ee9ef83b48baab199c063b0029be6078fb3d1fd92c065256d742eb1d8e541f31a8f9ea47625bb9a251623a79312a952a73522cb55a416adc593d1c2520a3f3be942e025662df25591e01ba947cee3360c7d57b49cf1c4bbe6dd6f77593812e3534602938438e21385b4d9a7540823030904abaf3f015095ba3247f11eabc1a5862d1e8a13fd810cfa308e492c0d0b722657c2fff28dde38ec1cebd291e2a30bdb78ccda1476b45aab3662cbbfa70bf10c09b493bd5d95806e4bb0635e383be9ddb305f581163e10349825a40ac3b41a7b9dd37d25c1387c503e81de15abd58936362936ed4268f4bd8ccbc350dfe3270d082e5d83754a0a7b9699c36340d8cc67c4e49346cc34f25aef0e22eae8f17201a74c81789b580648b57ff4e4a323d9e0c20bb22a1466190fcb79dad263e80dab661f0498ce1d3b0cb85ca322010e73684e7a246881cdf18ba80ce2750ee89c91ad110c2303c7e6d549445ce66684e7330fe3a968012e0aba6e37817108055209a8ba6707b01e680d5efd6f7b655b9614505bb844680cecca7646eb1b598e39e616cf87376906b10aa6ed3c6fc9d9a67069f750e83c0b3ea77b28c6f2f1560d6fb505f15ed66b16971edc3c69d07c359fa731923671705dd84b9471f53811aac5f189faf7d8c581e65905cfc8dea9ff331ef33b60cf7d907f8d6f5912486b58640b1dded8fb705a57b8ec6b3234ed3c1d5f159c22db47ac39af0b4a60a9c32aece693f38cdf10425a2f30db438a60d0be5236c6d29119cb69becb65b93e626db3f5958d21800a2da467a45d0198db69c6c80c13ae6618ee9972732496bb16e67a1d07e3b41ed1676224a19ff5804570de143bb65b9756dbb1ca489f28ba53fa3cc6713d89edb19b75f511c891ec1150e075ae9818a0696d0ccab0489a4027309eb709a791e650358fcb3b8c350fa02d214d5a76cf7bc28a65ae69f6f2ce435958e589f8e625771418a0578b3198b08d99d6848e6a6f2e367b1b705aced894aad178bf32c66c63a5e30a384d737ee779891a51997047ec9ade13fbdc34a462a29971680981f7c2247517016d6c2bd7462aa8801b3782cb0eb5c06d4a42aded5c7204af346704632aabd69412ffcfae3d8349544350eb75071199af8c48a841816ad3b8fc77f74ba3592c9a3b2758c3be8c76461596ddcc3414f6a22d9f8008025bb9ff55fc48e89cf2b4ecb1379b8fe52d80351f1715cf9ebf20d4c784dc790e619d44b9adae75081af1567941d2885a663b028f098a08cd0317f5409a816d76d699a7b4186283db47c66509377791075db8d830bcea3b3334457e9299404623ab5257a5e02df8303b15546a4f140e3c0a0bdf99dd2b44e0974333765a2b1458552168001e3face54dd032c889101fa0017cd4f69e3ad214d2a39b29334b48fecf3dcf47e34e1b9901fa25af7a3a2f2de6c14ebdfddc5b8657c5b683e30b971be203c42a47d15224b64c699ca16eba9caa88d3105752a19098410c1a16ea59af761681d262488d37d86932e93da377861e1721ce0a7b04828ca671bc80be310b78c1fb9d1bd44f82a918f5fdb4ec4a72e1c9c8e6f392a4170096788efbcf97680955f36ee3edd3874de407080c7335c5f407ef85d25062476cf6f1850a141a50bf3f7aa470f3835130281abb219cfff0d59d2e886793ef24886f2991d25f0d7e5df4b103694d0532a60f8b1e283eeba199ce4e0bd1975820e81bf8033a9fa47b0f179043b8993e2a83d3390dea82cfef018636725596a4bc93648036a9d25a0375ea67739cb218c3e412515eb2ab28ffb449ea268275a36df52a93c0f78af36e41aeb20d590c57567e4ceaea0c001bae5631f2ecb96f8e25a11e1012f18ada380395977b0423b41b36537c2316fbc36c49558e698a3178730f3f8f8621117c846bc740179b4d06a029ebaae6bde2aed27faeae7c043c1d14ee0d1941577fc193f8d26dd097798861f5e41035812e5c62e76f30bf851f20cfa840ba7d024bf78ab32f1640e671b4b418ab89141c82cb40155064f34e08c4e5c464183dc6d6002bb428672230be3a49426512462014bb78fd9566554cf781a03e3c93855189e961ea2dcc17c6e98d741ea4e54266c2a692611a83cadd05d84ab842648805763c6395875162284b311054b9a267a39067f1be22e6fa580cab75cc12208ae990e53b28c073194b08426b75571e09f3100f7d57460f4299d9bdbcfea62bac23630cce6eb85d24a96198d422b755602eafb1a2209ff53f230acb068bf46fc8815321c3ac691a73862446dc086345541942b7966b9ff0f9a108d9219e8874a4d9c3600b1eb2c793ba0afa4c11af4667db8e4f99ae17e715841caa4a5e0102335add4c544005fa97f0698ef9249ff7bd83c06cb22b0e9a63afc437d923a2b2cab70deb65ca9e995432bfd938c4fb864c9c439ba4b3de8c2726b319e68648992abbb8983bccdf13f48f4c5c8d2776cf42490e210ff08df0538a35703c2467e0b84dc600b7e01e12fd0ba1d63d973c5152ff27d8f5e0e7e130f4ea9723a7caeeb2f48af163a2104610bd568ba67ccc72b827e1d897af10c381bf1b98349b3aa47028401a1a92e533cd19f44e162a8a8c8f4b1a3ddb47db57c6e1da89aa8417016a7c8c64d93c1087bc45a486685277709ecff0d76bec6a36c06b384b6088c4e6d29e854166880aa2bf67ee7561b4648bf4a168b005fa4c73fe80144379e92ecf8dc17d6a0c3d10292ae9870a6ca0bf85971334383d62842f7e11ba3f4ea8515c496413cb47ccf4a532f44b7b59909e801329085df76d635ce79b5935d326ecb2760e677db2822a3d6b4a7baea913b8a043fce027cd1de6e029a45b2f84d159d6a83edf735dc2c8db6ee8ab838b887c6e609e8638391d05fc3c32463af7ba333df23edfa791068b72240b3669117899676ed16b511241b205414e0b091655af18da1cbdeea57b2e83cd11819843c4d0b3b9defd9a33a571dafde2a52c9e155deb5dd91c7c128b937d8f8b9ff8b136b055b50f36d498193bf29bbf35d4d592c4fb7062a360e0f04a20055300ffb87d7573f71120be90a3a8ae581b77d55d64b97b7b664aadfda62c6856bf57abb578702782586f5d3afc06f479ac7af1ea31fd5d3d7962f8ee21309bee0c53570037432de5c0e0049d1877105074e02cd06abc31c6f032a04a69fc70ef3e154c700f52927e7a854d805e11d6045fcbb101fafb4217c7f6e3507f9b855327c4b89bcf9069ca5598eca93663b611e17d3ef945a84a7de44cac332935109f205b0e2d9a65e72314717ec4ff9fd25df90796c335071afa54f26a23c21e841daa06d0a41566586a8f117874aa6e16f53511914c1a4de82ca79dfe94c83109b9c709e2304072259c7a814a3e5dc5c6f7e8ecbb4111d1a4e3d76ffa637a2217497469e27f37de38b0082483b398f1ee997e4a80e2fd68ef531c086ecf078291b97b6806a4da47a3a65ba838e106a56b9c9185cdd93bd4a778592ceb418792ae028c4e82bc8a11faf8416d1d5a96075a0e11cbaac351aa847d3d17e9cd91f06bbda66363adc7225166cdedc738cda057ccb62942a643572869ab6e84225877b1c211c98a27c9e2af8dc09d1aa085a1d486a41d2d53c66149fde84de28ff8e7997f6c1e73f51bd403b7fd37b19930d538c2030d9118404f015aed8217076ba228b42e01ab7afa2b50508223441b2668657d9f23b8fd6a781cae61b8f546efe155ebe302d952f325c94bd1e2cf58efcb2ce23d505074ba61da23bbee781e7656a73d5b8fa08051a2904f6561a8c17799714141e13687cee9c2174d5ca64a99a0d3d5c53938c6a0862fe712819f4c603ee3f248fd888893c8c4812d06457e9d19c361f58d0ae5234feb0e3f972e78aeac8a56a060052154393b22a5cacd8fb8a6e0513b2572ee8a221073e2c3b52d4a3104fe9986d8f5abfe461a7642fe917b9f14b8d30f54772a570f946476f127aa94ea7391b63a46937470c34d8a3cdc89ed7b4c98bd5ea2a060043dbc46b3f289f1872e932bdf110315551971bda1d45138bac26fc72b8bb821639f91f1e5d75fbca6bfa59c3c6f6f6d2ab5bb1830aa6afaa30aa3a32f93860a81481cd35019a04b01c4f64232baa264a04ecef8604bd2fc05b7c90c7ae3195759e8fbc0f66d991f4f94bfadd7bd6f0c1af0e721bd0b19e13e12eb006f7c79581e3c4d64e85dd2fe269e36232770e00f554286ea89bbddf5c30865448d1c33930214570d5585b24af51c764211fd3ae232aa006e7e9fdd70a88d4e045a0ab1e06a0ffb2c4f1c5dcef73f368265ff6eb57207e969c70fd6f6ec18d6815f983f52ec3178b477b356ff75bad56e7fb8c9083e222c93fd519177776f39d8b661b2a30231675cb87860b4aef5a5a5e1a9396e60ace74515c2c70896473c2bfec47039e393e5efb6ae6c3cc47007861bc070d9fc027e61f66b060d0c247129c56c569fdbae6300e3c41be77ac807eef98ca001cbdcc6d75c0824e3d7a16f6018e4f27559de602169aaa77eaf8693055c6db75af52b416278b633dee2f14691efed2b00f57d565ff88cb1eeb73f328fa09b52c45a7b1ce1658cb66a68324f1f8187cce354746e139090c087d42058bf0d582524cf751db3607221473a0f7e19f3bda9c9ec1981cd9c761961edc81c3804d79fb2dc49793b9727cb98da88eea030f23585373399644523481341270f7bd48cb73da2f89d2334a4eee88bef18c1b8e5bf2ea34f5a69312409f0bde8c1a005d3cd187b8b467758d298499e9bfafa9f910654ac05a607aa2ec074ce7cf7ec96082e8364aad1f3d4ac65d4de6d4a2b580d9f7899b740e5f98da2a3770180d6dee050c172f6ea2d36c3590766f41dca3ce6c14797474e2170b293679b39cd82709df99f2b16fac4610108b997bdf940930d9a5bbadb0acdb4d47f63e8b285212b433d03d75b022e844c8cbee66af2e2853dbd2840c3a85ea0b2fe2c9cff480d885099d59b5b64ccabee174e6f36d40874b2460f4a03f1f590dfc936c952a86e186d4967301b2d892a56350172df623a052a8e2deba34d8b4b3ad24310c6c476980d8ad4bd74b4f0a81773a51e93d8c445e1fc5300788475400595987caaf357ef7c5237a0563e871cf60d65695f3fece44fc14d978573db37bd041c4398fa72c632fb3eb67faacf57f98a16c6c27c5976e2deff6bd17c178b0d25f615b11682147c57a6ab97bb087914d08b125a331ea51f4e56e02a2adc439e4ef7c34b675e3cfae1cb463a481f41de5afc4067950f04aec4bb0630fada8ceb40196cb609aaefd592e320308ec8e74ea92bdcf18d774704fa447891153d24d227cc51630ace31f0c9eaf96228eb6481ee103c1751539bf421b71f3e44a6f66666591de7d46f9268f8cb1acc03536e08fb9339074ce008678e4aeac5daf0665a0c80697f95a5fd038b3732cf8dc64f3b81ef938eb8b10dbc1841bc893ed078b92dcd5a5ce7aa031e337867452fa2a50f3ed5c54a1e0a46ef562c73cc8061f9f24c4c0488af11b790a1b5dd2adf80d7e66902ebbfdd048b78971f5edefe8c4e3756075a1552098e260ad3fd89511fdaf6ddf0bb7fa7c3bd6c8314fcea09b51eca7727ec7356052a68993d3aef6c3fc80129367fd29e41d24c6bf28eff6454767ee1a53bc79e916da9d96e2ea99e9688cef8a2299ab6810d7e73974473ae8af59ae3cf124bbcd4326651f5d24ba0711627f830a0bcfec9aeeb9c3c20b23ac73ca4305568b4b28390901c81d09d833accdf1982187466bbdbc0088e1993ed60783f3e57300e86cf4d1614a8fcc642a58955f6a1d1195f262241cf04b8d917915c02d8c0f6c51679d2d54e7f52c9e9dcbf086402a38332e900d0d45580e8c875abce158cd4c7eb7bcfae77f4f2d4191cf4f6d59bf370d673b53b3dae6c2fec95a7494d7aae7821fad4bbc089f6a707a5e56d83ac766f639de5b53a9ccb7135f7ca256da63b0e6a80162f442612f476169dfd598a009767b01c360b838b8924178edb60435c9af843c459e3c00c6a75814e2490bea9c7998555ec47d11b7ee7a915d5023450fceddd7aaa51d6d3b49e4890ccbf64920b823a36f9d03def0935a468605588afa9a119cd26e0b3731008b1c4c9a8e1d6d08bc1a93c2de091e3efb34c1becd002070bf5cc26277923e5bee8b3e0daf857a2e899067651bdfd4f64a874f3480f488efc831f12104af35b2dde5aaecafc840886204d0398f79ebf9a892604d6cb4ea3886a05506b1b2ee6282d8b9b499fe60cb587ddf40b1f1240c9ed73f5ef3bb1c281e574127935e0b9a6c5baf39a39a364de8d94e11fa5b2f4fddbb02844f6210d6843b76cc39b9538dcb616906a0c69d658d0a12d708aa4ffc673f867ed0720b236aebd25bc413053358f9dc9f96b8ed74221a6406eaffda2e6f40ce35989f60fdfa0565d9be3c4da81e95b64971739d3114a298708580369b65c04edf2aaa608762acb20594c2abb0ad1aa817defc6ffdee9f045b192601c30bcbdfafa7ce4c4cecc5af8d8e92313f4886bbf632bccf29e53ee63422d69ef8664642cb1b7cba19c2afba1b75e0aeef47a8dc87580d7dafa725923fb1fe37a3b9b051919192597e46d3c6c9c6001f9b991c0c6047e810139037cc687a2f2af30dfa7ecae126abbf1e52b14b719982b0186b52f4ba49b30b84b3fb73ca114bc68651f32c444e9191da47f4ce8847fdbf4ce3721646bead7404ed8832559197333b7dd0d88a7ee724b00ca132892f9f587e81789d5b4af71f107ea449f29fc2e8e157dbf84ad998009ae65ca69ec1c2f6c03d6d2d457ca63f472c422db0388063f2fd1cf0c80a2362545faad63e6c9ce6638e21dc88e3d8cc89aa70371ac1e1f204d6005b21ff1838715fb6c08183ed3628defcd0a130f41641042b339ab96baee7a06e8edffe6ed4ecf9055567fe0fdd423adf4034f6310e6ae11c523840d2d865e501e99642134f3dda41439930b7cca873ecb2b43c6365684bbebd088c057b4d3ce800f61a82c1e343f82f50463885909d97b25f30e020da88b2c712ac8ea7039bc083cb1dd0f50f69801f2de93a43ce6fd1d404497975b47688b4378ffe0e66f8eebd089cfcf26280c938f86e8f984b23d0680386320dfed25ad6c5d59af363a4cf6e3d6b8f401586520b3d2ed4b708503fdf7503b1726d714c124d80bac237b597b62072066250a0509158c50219c3ed4cb34976f198b6ab387733e8eebad4c8550aa1c63cb5643ecb6c56bcb62061364424040bc9f37f5f65ccc2eb95eaefafbecdbf91dc9b15d0c5e8165a3d8bac63f507aab6e776eae4e381a42ca30b03cb41e2036eabd02e9e68e9d3f80f6668927519e3a538f1ca7030016c2aff28035483781e2eedf43525545f4e6d1cb607d4929b89f25e6c6c02ad5a0d540bb8a006218745f15304fd72e72d210dc6ef4bba6ed0cc085f05a2f74a61b23f3e13771d67a7130693e4a8bb48d424b6d88f8a50d6b5519737f256bd20cd6b47e2c1e96e37995a69253e37f0154e3939fd51877e63956b7f73d58958bf734aecfe1d48aa4faea2923f20aa84e6a6ae902c0630cdc35a5ff5cb5d8be4f3cf530df8abe66f10fdfd5817e2ff1f3e6b8c7ade08903abdc788f83c00588b1dd4a00fcbb170df34393bfefffffcee7636e3b4262303ef6b3056c32f1b004badd20afb15acc6b35998d143dc045982dbc4436d1a6120a3d85425bbdbbe0328d35ae0defe1db82c6f6c51f83948497db506182701ffc30e01a94a61034818e2e86712d3351371cc30ea6e95b4ce7cae271b1ef510190c07eb58fd1d883881b195024e25baa2aecfc62bc74624fa39992ebc0b465ee1a26e6d8ac2d5f2e8bb81b2b5354e9b1eebbffb28bee1353f317e2b2422155425ec184f6df3b4fc8acf023ff64ad6a26d5476f3c7376271ccec34a7b69721d46c3c69437f1a50b1bccc1860cf749e182d232c3a0d32b04ed279b7edd1658c6e306e81f9c2aa2280ef13ea94707767abf9c9f70a9bb3c4de4c21e275cf2f4cc1bed6a99eacb79898a621221470a00d6b4ce80f9d306f53e1147d822010def5cbf83185c6b0e016124813a2107b671125b828461bf0fd91358307e94254f8091fd92082d288e65a6f29e34261592eb8fbd172c34a41c470a56e12f6c8ede5dd6769d425f2e743f028e8beb4164af257a25f6707297926c2064274b2cb0698198be5186fde7acb19bfeabb99071002ffa8c2e97ba3e40b0a1bd582ed716388df3227989287704b2e10f2de1992f0c94a7b4f3115683ecdaabf3a3805fb248a5e7a21b3f10fbe3d02733322939f593a750b08a1a7b13429198954a727cd1085e717e9e7b13a1ab9a022336f8995c2ef63afa311794c531047a4e2877d67289463a3be10e48930fd1b5f40e8c82c13fb7505169a9902607649f938b414741e5cc611a918bebcfcbf1a9baf5d6b56d4edc6bc209b362c834bd898d1196856b242c1a8a25ba657ee4a7c570b590fd3ac37a6a1cf30551f0c64ef82eeb87c8c02e220f1bb7fa2cdfa7d74d544f359e48d4948e9368085587fd7c9bae3612768b2eb9d35c56370754d9915e4e37910f82b40c36f14bcad618293ce77061390ec82c82435ed0376a688f3dc19ec2c8aa476df5983bb3caf3253f7c3fc5c2f760e023f8e4ae17817611849869d0e05349d9a04d371dd2e13a881e094b98c6faefd2a578af3dbeef4ce97fdaa10acceaf9094f55bf308772282645a2f6ca5f6c2ec62385779a1df410a34e10496711cf0cfb3b3bc9c9346ced60e727508462472e13541e8cc12981bfacd43c4ba14e01411fa98353f72437f67a8d092dca16d5ce59ce625100f2e0480259cf5f0b375507a2fcf7dbd29bb931336d4d9f94d0ae31d93d04be818a00a7bceb5c2e0eb21dbaa0591a95d9e7eb2bc090159d3c38135e4d0b16f3c62affaaf5bb187ec157223b991e43d48f1544933fdf61f1e7e2902aa9bdfefe4e8ea82ac5cd686aa406b96a032b29be5d75c9bd013b13401b72309442a37274c346d5a578067fb30acb8a3085d942938ccf2b42cad8001f6717a22bc1bddb781a47bdfc03d2866e789274e5577d05293bc5677d37bd20a2fa5b8efa928e1bf5bdee5626253b392fb10f47ac13f538d5e956860ad8b20cef2ab9c4661e98a12e4d0e41cb063ac7fd3483ccfb7d4394695616bde52fb9f8013b2771dfd3f2c6bec672a4656f5c327e9dd21561afb57bdb0c62196c94e38eb6b2da5e9fbc51e9bf12e0ba2e92c1d0b000055860741fcbced5b594b37f341e9299659c18f9373049569ed1ffaf3051e8af80928c7470e60ca1456ebfbceb8442f1f51f5919678a58aacf795cfea84242c166148ede8cec99bae677c6d832097a667bb026602a88f93cdeb6d8da1b967e63d2c98acadc90f2ed05f9dad1137e0424b7f133b2455297c4d47588067d2066a207210f4a3e14253681464a77e7122b95882d3df25fdd3f5d7763e0447cb1566627ad80cb3767019cdc9a53ff69a0755eeb8cad6f30a66c1e80271662a36e3012123df610e1885d62542ac3d2ede3ace4e1ae57f8d996ef32d3d46c25647269fc1a401327a76a68779429d683d30c32aece3ab330fdeb3908cb26472e128d4046e88fcf11e9ad23784b122f4f58c43dbd47bc1795be01cc9414fa7d3e29c468af4f59514aa91e6e8bfb782e5f806f6d6bb84f01d3f44c0f9733e6c8320bb87dd403fb7cc7010db2aa8b3b65c79b9c1b92ab2df87d6a2a11f9cebe716c46fd85a38d9af6be537ea848921cc923a3439fedde7a38341c99adc5d5e98fe034eb8e3a8ebdc29fabf892407ab26e86ac175514a734584c84ad5a4728753f5c2f910c93a8063eee5cedb79b4e0b259408c012a1195fc9e224c91cf704e9c5e4c65a12e9eb9680ee30cc52d4906dc9cbed563414ba959ecc149d21225bb9fe58eddb2c4d720cbd09f0fe84fc96a275b81af7b45dca544d0a620014e05911de0e2a55ac68ccc6bf7ba8787ab45d8a16a4765b418fa25526ed28e01917d3db222288f3cad1f6b94131bc87b527dfcd6c6f1163d5b03602138d797fe7d43fb7e08fd1f8bf6be62034a22c734ae3b562dc69b1f1a63930cc53019dc0cbd6e3cd2661d037015cfc6423c4aea82d7573168e8878b29fea6e0efafd8e3957134e134d9a58e2db0eb886940521e24d6e4f83a38c6c56467d2097b0c68c86b60005631fa00ecf0bca546c32931d4345d699d05c5f995471fcc3fb5f28998828821c6734cfc7649a49cb2139f28c3859f762272a09f4ef78ecd331922c87f9816ccc06143c09fa568f5184ecbaac529dab470acecc0271735ae0333b8b08265f16d9e0d7602e9b260d004356fc71486553cadb9cdb6f487b892bf2c1606564da714310ccede4e96b64c4da462a995b9058f3428f51261cb706b8da235a4d787840e59734f2a684397de226d0953233016904b6b7236d99ee118d1cb265470cc2b8396d9ad9601d63d84c3d37f8d48cf75de1bf06f1e43f5df42e3365af223c0d9312bb40393e0de069f34d16683dfd4dfcfe8311628d9a53e924d08df76712719b0b3bef2fa5a68bf1ccfea14834c5de0854c9c79335c5d9b618830434b4333a4aab5fd86c8b7275f98a2df1f4502b552acd7651f9e119a4b6f7b1735785406241757a98afb21f92f8b53ef96b2bbf767bedf546630361deaa9c74d84b210b1482ea5c227c16524643c80006e1ba93f8f9600a5a99c9bedc1bbc275d9a31450f3e153fb1ab1f07c65177bcc476b370dd2bfda7551cc237b3f39f4936e961666a9b3f3f47437fb1873e161b736060cff853204cbd537529c4ad114fd6f1a40566f56852d77d2bc509d6f618bb3f5932e59806f6ec12e6143fd39d50c1af9930b206a925ccdb1755b857f2b6d5d5d2ef24589906eb22057d874b6263473448e3c2f020c0a1e9448daeb614fc67353e4580f768302e1222af4e481d45b50b91e9bf5db0033db619c3da286efed1b8c18165a3ff4fd9e5e2a749fb9b22111b70e3d0b9c05017ad1878a3e96ef78749e6dec15b7c4a5fcad741c3a806b251e5cd4977c04019490e79921c1a9e7458554fa6600b6ca8827f6651bb96efd70d07a07f67e0725aa6cd4fe33d3ee4c27abe03b8b656cc76a220635a5ad8ea8f9c78d9a0a7b023cb785131a280b77c82ecc58030e5ed65d18c490b285ecf48a275988c32a7eaf0117a9bb2cfacefcb66ce21fb46d842dcb36196496d2061527d4ab9c799409ed463133080b72fe298ff9aabf400ff918942c5d271e2c0871c1fc4546cc5652b0ce8b12ccd5de476aaf979cc510cbdf77555c6cbf29299937791bfde727b7d1b466a525898d34948ce405efa7202a06b2a32a80588260e7b1aa3a736b5b03ab07249b4218c22e9c3bbcacef42250645ab67c0d43d3a750098fc0ec8212f9304779d1344511d5aba0c19d8fddf8a513c51f00903ae17957867cc1741019723c3450c0e61ca005d743ba40041d6c72a3b8d83fab165b0309265bbf4ce369c3e93681e4cd0fa6af9d31b380579d31b7da243fbf2671b4efc7e6575a622c9c69a255f34a6781913b5bf5a3a19b399175b69647f2454e6fad3643a4f88a56d1ecff331ed0c93b9bc618897113dc2b97547a0b4fdf05ea3358c5ce4fae9a78e6d93f091c3463ab1e87c0353ead15c3773e074fc3c1f9146831dd9c39cef1cfd9e0d3bf03fd11fbc49e4dfe9ea7021715dcef5d165a4d750dbb662d9a1a33edbc4855d4af313ae26e71e9b1200de570214f1de6e9fa962f45ff50445ea730028e6b6d09883cbc5e8e62a57c7a344ea1bf761a05d884c51b896d30f35c1d9aefd14a79d5e76b20544cdcf637dc3cbd9b95fefd3de6774c2a6cfe5af2c0c4f4a37cf356ed0e1a8eb5e34260a0150b5bc2c0a531d46a23a9f6ba42988a0fa12bdc0c7497c0000dbf470ebaad36dc18f2c9456f8a497b762f849518e11f004b0699468f58f4004e358f2ddea0d6692d0c1afbdce123477100f07ee4112f980012d1c2e565dc2732c22422648123feefd45626634732638d492d84bd2b73d5e95daac9fa5ef391c881158f38bbf60afd1293ad1ccef99bd5a1d72788ef2ed3c1679788a0fbc75c1e97785d83d575ca565a846bab3121c8e7439604bd4444bf652768eddb2476b694ed7c76a0076838997b08b0f0c93b84a4f60758ed20fda8f36802cfe1b0838baf547b9f170a2f4c205284fd0815ea08325b2f05732ea53f4fa282a4887267152aa12bc33c370959aace6368c17a060c854e193ca5cedc69c3943190d0a1481aa96e5a0a2ffb075d414db9f28bdac717585198cd6d1e5ea2d79284c66c05b9c93ac3e307a8373aa2eb1f74ff5f1eb6bdbe316607dc91e5c67e7a8f6ca2b538beccd799e400d911e085f253b167666073dfbdca9c601afe751c3177a88c0130c43c4f4a1330ff210a428a0cf03222876a7f1d5cac02e5bdba9bd4db24df3418ddac8129457f8fe9515a4283d4e2cce11b26e6574774ba54f02533534e9b0b7ab2dc70d1646d99b0c7d675606fa7c1adad86d6fd6b172c8e97a28194f610e50663c7ec64c23aef2f5f3a647d083b8207c2b0a9eec03d1e3db303c18dce92e7dee2c1a2b70d3e2bc5a62335f85d25c3e4b86bec626e8d23cbb7e9d927400b28c2e489b12eb35ab8c3a19d0721f3fcb11917ed596d095e9d4653ad857c4cd6ce154488ff77e606f802b9f78b440a34974dab61b6cd39f2a4592b2aa6ccb08d2e53d27cb29b1d879596a1ff766a78ded7dc4e4bfada5d73b5a9509b104a3933772c80e0968997e8f5fbab4a94c13734d7d91f718106622bb968876f310747612a373780b947a8cba67152441436a55b50c4a90fe959c119b8261427eeb61470a199601d90a1c60ef16a029528a9c8fae2c6f356a62836d19494fd40a24c34d6973b3ca53c65997a60e98c13edcbb6ee1aa294c53db42789ac1ad7465515ee4ffd2b3f33eb734fd9f4f9c294276afe298d22697fec8b77e64c33452a49c306a0b1c2d5fb6aac38bed2edefc50e3ffe7855f065dca8bc0f8271f358268c021c8e807800d670578191a5c30a5ab40ab6d56e79d1302afd00a281b25117de1de2656c1509576d982a65209d2d510ece44b30986f77005c6264ac6eef7620501f426238756b188bac44bbfb64a230a9735987d9e1bf100bf759722c8439e0a10c1ad99efad9f3dc34e4a933e71240c924106d8d76975409bf3d70cbd1c50ee238e19e5ac2188c2d7dba0d474edfdff129f6bd7c672e927b792aad7409c88a6423de38a395503b5d6f18c4224a34e0ee5760fec2f85a8ce9066c7f5156fabd620286dd94c1a74b098a02fa36193306fc2c41df9fcdd93dc9bb8acc4b2ef094a5a693d550fba647e66f229dadf17c25c78e8286b105ea92e43a0fb1b5c6f88d2539e6425b7555cd4256779ebe88c33e26abb086192b21c28b2b614265c598b10cc2d8d4f2c26e068327ff9cb606b22bae5831d5618d6a3d2942d1a80b714aabbb9737cb77c877a9a21ce721ce7303d12903aa411d2c8d8c4d9e456254702d12622140558d2173b671133c0c9cc932c73fe1fd372b9706f3782475b697914d5d8adc8451d84692674a65fe6ad8269b271fb54a564e75da706771af8a2cbd4b4bea9d46f9125171a0d68452fc4c613a0ce5587c18d00ad65c177b67f13896ad60d076f5333c9302d30b5f8734476f5eb5a66cb7f24c2852186668097150913fdcecf888be3ebb0a345ca8a5075d240f35c97ee421ae7a33590f5608d1bd247a0b417d91db4d0f9b4c4ffda5ae85d3b891c619538a7dda74db1851cebdea11e0729d3f5745a1d9b83940a0fabffcf8a2f96b8a731ad57bdcc63d547af14b79a8bc1b83c8c2cdf96ff8567e0784ae7a5b951c9b6865647e51989b5b2ae2ea49eaf929b0b37b9470cd35bda9289195e1c1bc083a29b0f381fee42c9ac3901b7a471747e4491d4a3fee7b2145aedbac0c657e4fe04097433ec038103ce8994ff03b133929857d5cf63ccf04bf8c4d511f3f5b23d650d58ce384f135edb08e90fd9a4eb2edcff0b0789cbc38b2c0e4732b07cad19901a0b8231dc9477bd649ad89f9f624edcfc400396a7557539bce7d6779be9fbe6bca912cdc7f0ba213cefa167051d84e7a106ba24addbf0d32a6ca77a7d98db3a94039b8ea3328e2bbfb43e4e1fb6f9c97758cd43c07b426fe0ab553a6488deef88fcad59cc388e923820b47b56bafe962ebc7a25783aab36cfd1fcd50eb679dba2b33bda3889708a239303f981b2b48ac68f2cf9c43e974195d901cbc674263ce299cdfe64d68a36f0d373d088be90976c9b52b8bc514e66db3dcd5e87d910b2e9ee80276750dc198b4a58e89166010c4b90847b01ba163db87ddada59f62484c8393d57624a4948f5bc04a429516bd629efe79f968873a49ee93cd6596d7aafcc3d4f5936ff63dc095fdc8c113ea1f90f845e90e951e745f89c842324ab1fd9be36f6c435775fc06346034d2269fb5be0911ca9c357203947414a2a8ad8f67bbf96ca84f127042c0960bd55fa7af4a7fd5cbedb07027abd50d41cfbd80c381f032778b85cb98a15feddc4e29f93b39bde7a15dab3fd7808b934d2631d3fe71e419b20ecf514b3e874fed8f337953e824c2dc537aa70bffd4996bcdf02cb0c8cbff45ac3427f6fefdad80ca2530ae71f9ffe43d72197c3f4d2e6e89386d6628acaca009d45ca917dea7c196ee172a8f15dcbdcdd3fc86b994afa53a5838609531db257dad5b6dea83182eaaf71f91cd59d24f3168f4bd4f95d341d7ed16388a1a4abcf1fdbc5f7873f7775c8b3712ff2d4f662b57df3dc0e17133c5dc00c5ea4e0e39e87859a09bb9480df352cadab4b8242b2b4d58fd8dba92eca2e7a0acd2afd6b058d9af46b4dff5898d3471249022b00fed031b4a0be84f9af49ea8cd36f3bc1581e9356464e960dc2c15bf18fcb0b558f220ce27cf9ced0747c36621e5a1da488f85e144ee34f4c8bf5192d03224e2954fdaf98219514597a2957b63d15eaf56a0e9a7cdc8a69f93e705b9887cfd2e1b774d29e6c9570a403310cb16a7ff289b27a2d99e3fb911584e8d9833fdb7c2b8e8a4299b6b0205eee662f560ced2744d967c5171b63f5b8a96607cd499002f65d2fe5a44e68643cbb9250984fbb185cc900b49453a93d452a920490a593c0f2ae1e9c872d6c7410cc6dfcd7449b61d3abb84ee512b8f6497ad75e5d660121606e9bdc20a917a85a4eb691a17a83721535dfb7b3876f2470b882c14aaa25db3c7d906950f1afd8e5992bd578be01efd5f35609b1c0e178a0b2214b620afa5c93c9239b3ea6428a1cf156d51e3774a78185ea1fd28b788b04675f34c3957f1bb0e30c597bd13cf20c5418090d7993919994dafce85ba01df43d8010cf228e35d6b4b78bd099cc812dec3c67c6495ee500ba9369efbf0d77590c341bb0995d01f33ce7bdfa2b9270974c581590b740f33481cfbb5811dd7d91239a0900f23e476b5c96b6b87b60966a71b31c2cef0b0b8fa94eb6121073f57a5ec71ed2616d4c0a8fed1f0343f7eb4987dfd7d5bb384c358f3631c368dd4d9159e4d14144bdd11d24dcad6540c8326f6eb800db5ffeb1e8ecc10635b8ada7eb4139bc9676d6bf72db71b5c4e0aebef5668c999304d184b34a468ba393023251c8e5c415be8bc7293704375a658bb1d200131d065aa0836d2685565d397c1d41de2cf33800f9f7f26737bd040d28ede2abd01d48497a5204c5c57d79a74debf8164fe6719ec52a31271ca531bba85193268028fa0cff1f19ca98a24674b1af305609d6ba050cd46fbd8ef28f12ba61b6a930d590828bbd29441c41c3e8656b0805364c4bda34aa471eb0b56dbbfdcad7dfdcfb6a73009a270b41b2a455ab2ac3c0a8744b828c12fc8491a89d4caf8a4036409f36e33d763faac5016bd1c91d3528ddf993a434b1f666e240370324d8d53217d216d09ca2aaccc407f7d3896e21fdf903aff1a8f0105691c702ae81c9aca3faa0f48a1f3102f035903de36cd1c1630ef13a28b11bc8bce0ce0d00eeb137c6fd360b4bf5dacdb987a09147a357678c396efeaf64583bf29b71d265df820b0f284aef5f3950dba80fdcbe1aeba269eca8a8f78d394f04e8d6a900887a098d97abee3d2149ecc0c0fac1b65955a54013728f64efa401ad38ad92f2d05292ad1c9f92fc71ad28871f8f77ea1dc24d20a419c3a6b1dd4aca0a41fd8c8d41d69e4b2b0d0892e8a917f5bfa6de4d2d8a54d7def2f9907c07c4fae44badfae175778ff9e12f1b0fab165dc17a025a4fb714cd70240e8369a21a01a494bd259450d0e1ae737d6ab2ac0ad402550d93618f11baedb0e6539dafb44d1716321f487518d5b785a34509de8afec91d56f604bb9b0be0ee69a5ea24c062c1700ac13adcb06db4fa76898138082d7c2cf18a28f2e4f1cf907dc2819d937daa985d757c83b64ed5f7116a381dafdda6cf062d81faec376ac13a49c81fcd48d758b987f4224309aab54c1ef4508909b53dcc6d9bc367abf1b1fcbf8515db3e52c9c077620f31cf688d4a14bf4d0ed998596a62c578eaf8f6b6a866738e562b1d303ee0693563c9612602a7f04ae5a6728a829c0a308d7b0d38c44efa164d40671ae150743e7d099dc11407d5b93c003ea48be01034621f7d56b33f76a39e1cc2015789816be3341c058e2fd895d72a27114244ec41df59a93b88379ffc360a763adf40252cdadeb34c2815efd68ab4dcad30b81f7843d92de4a43cb5712485a875f402833b4280d28dca13db4f593973bbe6de67492fb7baea39107ec7857a26201898a204084d4fa51e46d64db629aa1c492a55460643a268198888258a8d7b6e59b35be1e0adb43e5141bce695a892a4cd20b9220daabb86846ad860d6227a2d9de344b08f42bc0f155e47e3741bb2ceb5a48081077d068260e418d7b946a89960a99ade4a625cb06f628b10b18458acd02d6169f8c3ec42d6f040bc8a48087c2aff0f7b59e03fe1c4800eda6c5ad34b77f8f39a617f51da7dab4901321e24300bb4a399ff2369f282a7da4b87edbf16ee41a0cdf313870f3d67ec268cfdfff35e3284547e5138277fbc0c6e5c46c48c54327ebdef39b24fd979374b53b3646c9bb9d493e1d86ce85ebac5f6560fbb17f15fdcdac4a2049068fa12ffbe1ded35f39417e91b5c6d6964dc5b8d73efdba92f8f4f88ec6d39928d9ac642b62fce7be317fee06516970c4c9e8a6e124be6017e81bc92f34f196933c77f260bc06a9d4d483c496cc809ed07c3204e44db1ff7efe41eba9e6ef15e3adc3aacb0d9b8a1dc424bdd26721b0018438902074e2c9ab4d6130ca9748e754dc6d169a099f194b030af07b4c48ba1018c427b70d059647800de2611a45d062a28221e8a847b2e63b088e1bea722948412694eca73af4a8bece879031e562607cfb3d2514656aa58765cc734ec03f89b286fb75d2c0911d8056dc447fa6c136a579a7fe66ca82ef38cb9b83b0cfe5a5b76016c9075ce9add032834e09c9c82e62153276d0126862482fc5d33b67fc2ccea6bcb420bfccbca9736ba3df14024d0cecf7e12ec07a1189c5ab7c249259543b2f9eb85059af4c133c218a0e2de710a857dc920dcf7781cc2ecf3cb35b98511c40830fc57a286ac9f4c8b88d7da6d410c14366890c8b3c9e616cdea7736e78b51f0b23a9954856c4cc6ca55390e2638a1406d893d579788630fcd3be10fcf8f36332e70ed48bf9ae140011d5d5523497c5af61778cd4bcd1967b902ede3ce723811ac675f7dff98ada8064104d0a390a4f00c3ac84de2d14b8f286938ec3665f36e38267f73590a59d4f88b2e910e44e4c3286d0d639161f389c0cad0e7ea7eb95c0e7b84b796eadf5b29f6fbf1b8bc313ce97aee25677806fc8bfe9e1eedc282db49eea48ec7059983605986b647f2b695c13e9178f9b99641dcfef912194b4407e4c2d884cddf921262957929192826b198232b7a7f2b853ea1cd71c46f042c7cbeb2f3d97d6687f053f3b2b1ea85bcf1313d0ae62282d62177a6b4f15917d7e82350281e89bde5eb90977753102608cdf7b7081f3a1b67dfcfed33f23307432cab6abed248dde581a7ca324087bf69878e7bc2e69ebfa1e9531541ecedbc6f540bd511ef8404a8da8f29358873784e596ab6d0fd417d474837547d8bccb3710dd5efbd05992b443e633a128c49cd4a92cb30944cdbde571c4b2103ee5732f7a0cce4917903d5a332cb3f37cbcd3735347f8396f92c8ffa24a58e9f4fcaee08e07ccd85bb7bf0b00444e90ef814d21ada4c05a312213aeef98ae1eee534ca0b55cbf1d27cd718e89f2f5a4251fd106c44fd837bdfe2c40a23365fda02f34c314c83e9025250060c855cae21509690119582a7100c276bd80222a43e063cda5f8a6ea26e1e431a43bf98474437fc99ec70e65711cd58beebd02ac98311c7159bb65c0f4e4e8a64aed29b4054febd88229baf5a8e5f1b1cd33dd17c7f365306792957b3e0a285901af21958a1a3bacc74530cb964a440a0fb43dedae4bbed42266d0916619228814b9e412fce8c4f291f31f29892adbc785c7a1dfef114fbec6c90d26cbcfbe5e5a8c14ba0469fdec3a55fcab39eab36e51a94cb62bd0aba42519de9a92cfd40242269cbb9ddc6fa01c7c6d22637d7cc6109efccebf105436df56ecc1dcfb111411080e7c09aac90923668be2c3b6ea7e20b7f2666e82236482b5221c49c3bc1fc5ba70bb015eb07f79954dc5da18e44eda18a5c2b602f373dfd53a6a822969ee8aa962b4adbb68309bc61210c2eba0130864947e1bf250474a4ee296df6c1392123ccdc104f4c61b68c664ac6411101a00c75a2ca19c3891eb8a1fbd0d1c2e45d54639a5ed4dc108ba3841d7379994d6fc3db8a7117ec9154900c9aacf942414ce99e8251d4089d99cd258618a9d4eda24af5a10c6fef8805aac613a0032598b8fb9d34a544b291055b6869649a83a507171cae8af8a804b3e51c0ebfe29fce8dc3a327dd1e69d6f50f3c48c5be1341ded19a718252bb82bb662b03e4fa21c2bacfba9cbb3348fc8fe4e4f059b13999bb52ee5ef46ee8b8b291e8dd8dc63938808c0db6b19073436e6c62036eba121cc53d9c5a91a294f6e6db42c0894b5bff85a0d2b08b52ab0a8585ce05041390d38654c02ed5ee172533d08b49729096438d3f1b96f489c4a824398fa9c8cfd3a5bf6ebb1df1a39941e85632c060317af9ddefa700797c53f364b079385e6d54ff393206098d0fadb589bbdff5eb94b32a087cee0676b85859a1ac0f303b92fcda3079d3ebd995ca1bb123f4bc3ecc808f371eab3347cd96c57a05504cdb039329654a172eb443578a4a6f2938036baa7c3dbf3f58d9d8821b4012bf4605eee62c0054602154044177c73098d4c4efda7cfb7b434562572325f80bfd41c78c2ac81a6a54d1567186de21ee29560c43662b279658a20a37d93f4f7ac036302b16ee23fbfc3afcc06c293404b3ac152ce267b6cd9e508e9337c2cd040ec012803e45378fda61fc7aa111a0f7921b6bbc87a2461c9c1670739c5c8b90d7b6d816af8d852ccaef3279ba66dfec390cbf69e3c5582575858cd826b0ffdc90072da6177d0d0da94a6074fbabcd052babfd1a357228b8006b01973e2b6ca94e6833233b3c471c2490f350f6aed4e7d646b6e6b973bfda9eb9ec3673480d99b7a833d854ee948e156ae955a245705dec927dd823bbdb3719fd09bf856e7095c136d59452db873e04885c56e0841489fd17ef19dc1c1adb433d094f437786bae1648717edcf22a69d8545da258741f5083460648d74eaec158c7b4a9a51b5a5e4f1e9ffa1819ba4179cbcf89a12e8042c7c133ec49e5de9f47682858de6bfba34fc3ea9dc336d2f625b9bd390b15c5b2ee9ef4a6f30146e6a3794bf0df78fbd35939bcc6ec020e175536d2ed7b5e694622cbcb86fbde416ed7915c8140ad8979f49bf681871bb37c99234fd6cda853f4bdbdf9cf23f0ead68a0bfed77cca255a98603336ef8ea3d787ba4e69c4da22411653a6ebd46027084f7c6f445914fcb7e9c979ad7e32b64a1708359bee563c2f8f5277fd94bd8ed59e0d1d593a78eb59ef5db8a21a2c79fcc2feab769f0a40dcf92dffcaa7f8ffc95d6c1930579488e2b94be6e0d91feebe56f2105fe4af7de6a39037860bd61a610ffcfcaf2ba621247d94c8ad09e725b221756cd93834847032764000794c8dde4fb7a4dd0e182fd268101db604c54e45451f65836d8b9386bfbb288d22f8b86bf6bf3551df178d6e7c12d95cd3abbb9245c1f8e03d98e6b7a5e5e3816b7bf68b90e3c5f1471613728354fe4c82d958704ba5495177efb246e627ad9dc95a45f85df7090f1794f597f70c6bbc195f25fdbc03a2f51c5ddff6c5b8169ccbdd6a599df919defabb6797e9dd83096a32ca4e3c7e4427d9deab487e1c4109dda7fc2389a3ab2d763f57e2cd57ed47841f795a78c0f48a4695640dbf355927cf50bd37382a5634499f290ae726855d1a42d3c76f4a5b3ee52acb9193016d2bc81b4a03db4cffb4a743769a2641ee275dd58e36f09c62ade1391c259f81a9b4d823cda636594510ccda8ba5a8cd6ffaf3430466b1e99867d7f136150c40933eab20fde0ec6b2d97c1ead1f0b6b9dd9e733eb9340ae06655ebf23ab065df5443f1fb026523386524099a8c1658e754c6e321ee12bc41bb8269474e4d73d935677270b95dc19c3fffa6f625588556d016d49c8c7bce8ec32a67675e36e028adf540a40b128d40e5cfc6074608a5231284ce0601b0b1744557187808366dbc4c05af36a8a1f076598998aa6e3f60c3e5a0861bcf3a16a6c203f223baa67918d4f2ac988b5b46dc3c77af90b3bd558821bff81df06c45ab67765e09066af1e339f1347b3330a31eec12d6abc42edf8b3137c311cbac209d6fb69d8c0906e6dff068e6112295b457585b6abb140c1b4153a6635078d5823b40df121b177967a0274559f6c1ae9d1d1a5c90404569f7e06e0edf60e7e9bb2847700742448077b6c04708b46f5641e27538ece2a4d634052c315c5910d8c33156d406b7cb6abc64111e1e1edaec827b3240bacfaa2cab14fe5d11c2d7867ffce8ca75e7ab5f8ebf7173ef6b3aadd3b375489b8c4c059c354b62388287995411e582174ddbef729f1a727b56fca2ef9887d1ed47c4abde9e5d3f9f76ddda20403568178edb33858eeb65ec7237a34813cf0220d8dd5edfeae7db9d7819f775edba0b251924d61ed96141a2e6bd194ba9037341f8db11bfee285122a1fde97f8fc5213e92fa608432f4735e5e030cd804c6d033363bd788e890602e0543facbb5f4845575cf156758b4c81efc9f5176b7dc750b8c6ff98db98756e02530423e7dfbfe73f2a8fcf8061796c7bff729f467e407e66c6b9fdb444c475e7a7784630ceef2d76ce0105e0dc6548095313875b598e41886e7486f6ec4868493c0caa15032be993cbf7130fb1da63777c30e717aca3794e331df2131ee2983334e69675d7b2e746949cc4ee9d0189e077e74aed270f4cb6d45264bbf0ff433237746058d0c7114e4556bd0a2bc22d814256d86ec09abf032caf60fce692bd9b0ff67f417a0da9e550bd8890e0a1ac2da4f44c76517b446b1b2b51378c656bd66f3ccd7c8b0cd88d9dad1e189de917bc9f914f18f232e3eb16e4cb0a0da597b70ef449ded183b74cbce3fa6b9f5c4009a5440c3ff5c2f5820d06337d6da022970cfd0003c950464615dfc2da498dd3ea82c1a8ea67b609e72b4208d32f676bd47c73b9bd81012d877d3a235c0180397a64b80a150d3b88e57c0e6ffc548fd52ec8ea878f45d54da42b338f5cb287a90e740b33f9faa4a4e8229d3d9defade6ff5345da3e0e8d6e33b60a0dc449e36c4acfb7ea22a7afe3c5ad4a989ee5344198234b090b9554dfebe0734ccd66547bb939f8b4538496ab524f59d9fc9cf3ff89c2e8b7fd702fc31c04c295737c4b91ff4cc5667c78604816fb51a9c3d6fceb853bfab369bb1c028be3c04cf2738f6b7555cea90987d5879963bf28a59827327a057084607ce3b4c392fffe6fa5f5e993455f553005897f8781782da4d38630aa411252a13a61aefd0e0816a854835d02a431cef7fd23d61160bf59ff4a1723db07f6ff792959c2427d2f1b07eda374c496cf7d3d1a5d5624049b19d11010a7c75630ba22ed2e16666ad5ba82e849d5813335dd9bfb1ccf4417d8410762707bcc6b002740a2dc89e40845c5d6bddef03d4dff014548b84ce2e8581a8eeaaf3329694cd86c2d036752bd153ec0d8d15a2ff7c5cb07188940850f44bdddfa87d321d380cd3eac8e9cba9573fc73c0562cccc8c197e6720e7480ba4bd62653c3dd64d0a9ecb48c716ca5e2cf327fe4584f356686bf91ff1aab3ed3f6027e18c6ad61ab4ab4757ec1c0dd34dee8e24eb97cce890a87f0b52c991ce0ee7ae49c60bc16b0b1ba2260255ad133978161576a8273e8e7ea87931cb23063a4601bb97a03c346e6ad8098e690a7e5861342fff8bbcfb9c8f792e6f2b30bffc4a9402887f9275ddfcb3cbb1241b94f4b21c7c5371a4a5ffffb652c231a4ab6cdc99e2deddcac93099853e86dc6d6866d3d45e9deb5a819486beef807b4711965c4a2b048f892288ca4848843decbf3ed3cf55538b9a2d8230268c8b5a209adf4e994d0718530a377589d68f3ba6f79fb284d6ac4d3aeaba0475ce7663a12cb0aa825388230e5a83e528d9c79fe6fa3f390902531f9b409394f90f53dbed8366c5da3fde72560351890b456d41ca6ea7247b4f473ca315825194f0b647092c0b30be436a08ec8f7d69ac3dfacaaf5b5bfc999c62d6411a2233fa22dbc1e80b6a98b933d738e2dc69c94181e1eafc5b1d4bf3a39c532ddd09ac5d601d1d1499f7d2978b22b271a88325cd40c55dc61cbbfd3729916439cc6ba74251f4b3ef56ca9e970b5d0744b36bd05b16e6ad1b316805d1dd08ec0a72baff9810319386020a0f777f3e63085a617d1978633f62cc1687ae40a124fe01cecce22ad238c032d58641ae96a3738f571e2fb23ffd022c11a4f557d3c0e2390aa1a602ef372b619a3647cb17480c9323f89d39d50e730e60b55a05b7dedd6518a94d8347901dd57f74cef9429856e5d1bc1b47f7e39fff2f560e3b5c4e28bad77635d25589780d0b7f1232d39029ef3435491fcb46f167af7ac054cb8d822ede06f59b10ad599c5082db6cca11f14d64fe898232b684ab272e74b8f0998a323cdf07ecce51ef90a01ff1abd6839bba0f88cc6b2e928cdb0b00af9b9b60b56f4c4d2450a1388c452f7133a88bb115adae559753df9f3a39561269cb5a3386abfab815562a10a75dda12b3b32c474cd96c32c5e63840f441385bc7e69a601dd0dde5bc9f2141db675dac3d23fc629a3cc89d29a1b882627255229b9706cd6e0d1d015cb87c47605182cc1c22ca79043f2ca4295ee16f653267f57c96555e9f1eb4582f429a17eb4d1365b428e32ed47804b5093869fe3edc7ede8fd46d927253771b5f2e7dc0e7af7172e54f8fd45fbfa6d8e8e2e10e6176f1d8aa3550904c594b0502dad17a9025ea5840355adfa33ce44f1f011e76515fb8fb81443104c5a9499977e35d648d7ff792e315c155a8b8aebd5aff2b28eb1fa99353ec53142a8973417ba0288e174c6d96be2fa249b6d7550eb3e521046298f324b5f02a3556e56f5f264be603320f0d4c4f8e357dbcd9a9b8b0605d699b52f1b25557fdce15bba7a0d4adbd182f3bd08f16d55c4c96bb9f3c9a497382ea5483aa99473e21a481235e984e0307c79a92064b9eede28048deb0dae5e33bda304f9ab46fa3dcbf37d053fbe4bde0cad8a4473bd261cb6386ef050c308222c39886afd32a939d27bde976bcb2967c3f45dc36d66e2da738efff2851f7b6120d5d5114c91c7b95677dbd74b40edc0b9d2fe44de6f9ce71ec02b938cf9576bcca02c6759b08e9fa8db072675b28cf337f37ae319fe465d18bb45d5add0c0f649cf53a57fec8f52a1b8478bef7949032a8b58d84d7464602b4fa8d261d25bf6c4da66829a23a7b5cdcce52a43afa97b14de5e7adabd87032b30080b6f39ddf9561f4b00aec7926c3971708e3e075f820c2bad6059035f8cb6657e1f3fb9112f5c6c848c17e1b32d205ed87e24e32aa1c81b484e37cd96dc87f5e6e93f457dbaa5a4c924e7cf825ed853da426e7b6d979c0a1e39defd0b759b09e10ad373848179db7410a583067ff362c5a83ef1fd56e2a886a5444e88b2fe4fcb0e5da9f464b72dec3f57f2511c8bbad44006a16cc08bc03acaadb2a5680edecacded9967ae92bd8216b7633ae5f447a09ea71c977c438cbe5b2725a4c4b3ae90eb5bb0a722f9dd92b2c955f3bd75e8460109f070d8c0f22b003bef6380e981c7cd98ddd8fc97243cadbdf0f5bcc98dcedc9e6a5df4cdfecf866be6e4ff355f01f90ecb341881f3d911978414766179fdd540cff293a8af1b2c16be06fb540e007a04188a33ac832364fbbef232c45ad6600d415bba997efe2c0b217a813e73173c9e7a237ada973a3c2782b19828bd8aca439d130bfb8f7b05d49a564727e525ab96903bb32af3a00194c3c9f6624bb4f7bae8ec475b0bb5cfbf361266cac7ce98d61e0754547445b561e3d3ed8bb98167cab803956b41efeafaa806c263cd572635d06fe1dfc5172cf1ba6c75c8b3d032c5e600a5490492cf32343acb167a9103869829f8343695712be8e9f329027a83f9b0d0895ba5766861d469fab26683eeb35c34c9e13f733e91c98d88668abaca608f11d4cb3ac32e9e43a1c18d6f69bd3f7df9fdf83343c874be30fec350b2304c75de7d825991aa58946f87f611cc13edf1fe87e70cced91fad1da5d19aed39482ae6704bd8c01a6d19f9ea7de00e5ba8d557e8512fe26d9b896fcb6f4ffa9bb45e8e055c42f1e1850745ebc01c022c4ca89acbd7ffaf1a0cd039402a3de3da813821b032fc74f803050404fcfe2f9539dd874fb995e321361588901091a1421e93694e7d3fd45068343a33ed3629bdc88e43a9c61f344ec1aa8763714cb0204d40246e3f359ebf5384536f9a17ef59915b7bb0dc9e9c0df16f5f795ac65aceb28733341165e2ad040b9cd2ef13180a8bd64a8ed82850a9110cde90eeddb4ad4affccd4fb4b3e66ec279b15fbec794dc3aae3cd33a625ec65f1a72fdbd4871c0e2018e5d6a66312770cbccdca48fafbc083657b1fe26072579eb587772144e2ad0536ee41e42bf1b520651e636fac3835a37101b3a0107016bae7fdb5254d4ce2d4fb6df25eef3f831301ec73d780960358643972923b52fc1cf196bbc3e1b78223c6fc94fa5de3963cb86f78006a6813e4b2a9d1adf2d5278ed377c37010e3ab18bf3d0d330f92e489643d899836af4f7730274819f26ba7fbf1a9a3d8233f23f30e59154507839da39e3b4f1d8430b7e1713a574264215ea06346a5a9507ed46d71fd40f51af03adbbb8fd2da018017a32ff105c8459e7edd7747351880025a3bab5d519288b404c97671d12297ca34c22134413bb87d05134905d6e7162f76634c131e599d19dd94aa71c12c89860954ba6ca574f5525c5a9c4665df375a5cc934e02a53f48ce38d5cf6b9ade9790929e148f4af9ec9b1c4d19c9cf213c96ec22d816d0e814436bb2edc693748a9e167367f100c87aee002e22291e7600e48e78e3b8ffe320774b097fb878118dd30d951a9d8e5a83d6b91ab3cc9916a32e6c6b4fb0c35dad86400d62e27bc8f736dae5116f2134427c10614924a02bef62d7c01eb9aaf785900a16b62589b391f9eb16b8dbeee09a10e3e87e352f03617effafe8ebde50c4efe99800d253247d5233e0f4d932e9b5897dba522187b959b29e9ac1bccff6813136961c10b174e17081b42606e1f8565189a4f1ac6ea2ec8ac2daf9e7b63e98840e846509411ed78d7932a7703ddc109bf5db03e90fc0a2bb785f60aaed18d31f88d935b350bd23ebfc069ebb1411289fac882361d956a627e0396bb9d799c89276985dbd8323cbca47b1c611b8d9399bb869afed3fb746a8dff5e724fe6dcf6262fe3a433a5753664732d025ab85df20daba0da94925b61a7910da2db5272b887dcf9a49b3b225b13b7d640ed96cbe93036912d980297fd1cbfd3ccb37792e11b5ecd5f829ac9330366e968533f790af19c2e5f21b34c2b6a929ca946fd8f165e926e30df601df55ab5152820cd12867c45a87e48f9134bcd232317d1a586ec72bfd17df6b0ce50a68cb7c993c515d1a913cdd034c0c63156b83e0115da6a3edbb485bc7d28cf536df223cad72f714923091695d348a26bad3df141e17ff0e6053c950cb8d42d95fb239809da6c1d4efec8dd809635474da3ccd04f880d3ca15e0dda67cc39f9b05b5c193fea82cb95c53cd710f9050c48d231778d298f95e94c199959dc22e591f92c4181b8a2bf48a996ab1f1f3066ec979f7111866cb362152e7d6764880d9c6d67588ed9bcf694e29f3a0cb937d78766a2340ac5fb2c77503a453fd575b55a4617799647ef6955da2b25794cb576d31c990a1bd4ccb87629fb4e4d6da3102cd3e99cc9c9bd7db299547f66be4a9f59febc8eaefaec7aa7e9e64a669fb66f7f3cf87a1dfdba42bee0b943b7847f89850eda21d5f65af182f05d7a4633df554cb24ac5154e21c42928ad2e672efb397e881b6051dca53ab139482b67e701aef05c94707bbb57bb8e12ee3780ac994cbb90993854de023c9a62048ff81fbee44c0350405fdb53681393edee100ec93745721ce305971071067be1c20ee2fec44c2372839b865eb23222c0a7534285d62d27a2ade1839001440b015cf32a67279eb07c19a46ab256c5cf294bff01883cdd7d032da68d5f1fbe9f84114361be419c3501de49da6aa5987f2b9cff3411a54fd9e37a498bd856ae669aee2d59c4f96a2e26e7e094fdf42b6fb220136f336309c75029ad6460cda704a829619e7d43df268467406b291720a6ce047088fc68ad8e6cf7cb71990906963ecc2b8c2d59309d94f646210b1a79467ce6e33e3af6f50c12277d281194932e86d43c15c536563e5fc6a31925fe3e149a044805f7cd3155e7d59ad15e00af9b212002d7fb973c45d29140b8bc2137b803b558504be4b6c0adde8820a223205285b5fde6c1b6b6ec0bbbf91eed85525bc862e0b60ee75b834aea74a3e13737fbdcb653c9cf46a95a13db13b8be760ae765e2a753200bc0b1fe1e3eb57ea041a821792802930ca86c649577aec9f2f90873cd901601d7a288032e9525a509476edf91fa351ff0bf91ed86f1dab99157af1eb6fea932e1b03e33342b182d3b9b39bc636149d0a8c7ce7d8a30b5f84c9426d30855307d71e308ea9e7c54245e0c7c2fc5b1648e92b2faf0d0b1194c8442134d2d9e825b3196f76143ebfa56083600f656884eafe8e239f291448748bd667e41dfc7ab5100653f3fe70e4f3efac5af1f0274f9556064b4aa34e65f931988a2aa79ff0df5c3360fdcff7168acbaf869b7b75cfe51ce08b3bbb0b9ad7aa56768ecb433e470a7815783cdc04d59144549b8484e5fcb1b7586d9b29a4b1bf1287c0e78d86971ea65b47a985a31e190c2875cb10383dcb04e56dc4e98549ee0d5299eff797b7be1ab57beee3f35ad70b3b0d4731a9fe236ebaced04f722a5b34c2c6f69649dcf275ccdc0f664b6764c0d777401809287f3e59b67e70824084d5a9042b0c0711bc315648bc4080cbef50a505b9c3ddc3a24e0913e2e40d051dd6daccdd712da638d825bafc570153501bb0ebd4c228b43501e2af5c8380ef42f9ded97053cf94cc5731c6ee64b685318f24c33ff9c98367c88aa11db7ff1eddc83fdcc43b91ba098da8ba2133fd2ac6e739e828b7a16bba9b7e7f7c184351f2d9899d16e8b8634eca09ecd0188c45c80e625e694f5d935ae1b0d0c22bf4af1ed2611f8b98023fca99cdd9b37690faaa261a8cb150ad4eb28a613d25828cf298883b7a75704fb6188d12e48e56bc274f3a1c037993c5bd047b8011cc25fb9d0aa207c37b8016f8c6caa03cf3e7681d1bbda68c81a6072f3fb3537d309370fcc92081c7999596345b882f7ea6576c11cd2a6d59511ec35d74b2a49877c5138d4535c5bbaa2a19abc95296cc146e5ff11e2c47bf39a94da29d921bfe2600565567259d469aaba1a2db7774a6731f1d42c0b0cea16326c07d8982ef4833a5103899c407931dece68542e94084f9b186883fe889a920471ae04f4a38a2e20761e2dcece9e19c82bea9c3bc6953bf209909ba7accb9f5b0d5fb81987c886547f035f01ad485e29464a7bd568fdfbcf058c7fc4480ccda52b793d233540cb9a6abe5858060494b1473fadfd2a2f910ebd7bf414c70530355d1472c63f5e537e1cf78adc4346477eb9c77fac49ab919d18c698db465b34e8d8c4806c02ef0d33b4bcbd1c6306b3e39b6069525c2e77c3bebc5246d58c2460347a14162ad9f6b313ced600a8cff0656bed1708c25bbd81614b2d4a793deab4eb2e1c05569266f2da8bbb5779607066b9d358586b06c36f9bd1053e8e1bf369193c52645a238a7de142c5dc87c6d6c3c743ad4113048f7038ba0cd3474c0ee4c2094c5ef6510b6a6c64b9fda472f04d5d48ddbc8b6ee51f6b6f9c2a554aed7e2d83c36f01171556ed3d953a3ad3bee127043ba27a59ebb350992292e7c4ba5e7fe68b337316f2aa6533ca05d827d80f31cc73f91764c41827cd177c39365ecd3ac46254f8783baed751872e5e1272917d307ab61ba2904a4680bf621a8ef631a97c936dd6a7545bdf05b550b5a8b4427b36a04e35e78a0f47afb183331dedf289569775260e1a2287256c8d33988428c430b3cc220bf0b3fbeaf9d436f7218c4b715a5ace3d7110df443e191e07a9a99fd444aaf3beac353f2fbe940dee9dd3102a4b0c9682d94171adf83c1886127d95296fd96df81b21ab75c0c7e3ee84d017477cbef6cd0f38c7f2037a10585fd4ffdaf0c49868973c209a3d9e5836dd7c2233d2e1ba09f155dc62d873062d2818734f1b0e4a403f90f57476ded5ff77917b1db72c2ffcdbab918977ec7592c20d87b1a851a60ccb443f227b87b55c010446be2c82c60b685a72db37d26bc61634e96343e646d5f61fef86c331323b585daa948735bea00c9c8582f634a1ddeefb49cedd7a466b96e4c9d200ba1f4d71fd523e0694dbc8ed7b661b88165b2b09802b3b5ca62a47c126c33102ae6891c634724df63222235f4ad37f3ff4f682d11f65e0387c2f254363818b68ba4a3e765b3ae5b11d6d0d9add1e5dee6c315e873ff976f6bdba3414e6ffa96bd0f287592fecc0ae77c829309a10ad0cff4efd7b673bd7aec63c2a6d0e71888c46e39fec07f602732bb13de938bc6e9e0304103bb580f9e258973c0a732120fc24c6e91d84309b23e3561fcdf06907088f77a0b5b9de09fff437eecdc56c08b4ae1d327cd58f3da2b2a6e016e99c19fc0ae9dde1c7694d3147662e07c6496745c99c06164d3ac047f019ac140dbf5286e8d90f560878443fdea5fa7cfe510dcb0342f6a7e940b6e28a75ebd75a0911bef83aad6db53dc776505687afe9cf30d251246ef3f523fe76132adc0ce4ce954cf66e00d9c31797638d1726ff8c04822c70516f4c7a2b051703755a345b7f4be906bd1dc4650f3581e121da6f22d8839a594bdadd5e964050d302e15433577f8bed03c68c3db3c2f64029de75d2c2861a4f059d039c082e0a4c031685807ee733b99e799594cb2e6a5c660e42479a694e53c0b3684bb2cc5a4956eda8728484f81bc8c652b783e7e41c4a0f43b28c5133255c766d74b8ee9f9e6105e9e413d85535e921e3d6acdd510feb68bbae0a387b7f2ab648b62d7ba4a06079c320bf71838dcc4bf25b5720b6658aaedafa0afe517f76c12f573f37fbbf477a8f7e29a99d24b9471d1964af14889707b97d52103d3ad85a318dad10368f555ea75e5bcb25e9c6c084f4c1d80bdd8b6ee15c63861a40a9e923c8d4c334a4c823da21e47a42eaeddcdd892f78e8b206cdbbb42127c72e4fc12486941f0d53eb892c7affa74ec76b697d1816f73ae556c23c2fc18418f54632fe874bf2b541805f4e0d27eb41d7f1fda4aeb1a8c1f71ba638de8a1bf1d7fb5edc94fe6bdb5e851fca64efbd9a698170fb1c4cb28a8518352913f3e301a3168fe12b553c34c0a89b36c66266642aac5d50d50ec80b754ee0d1b42cec5831b9433ecbfab471f6afd0b0f77370016fecb3d746f197de3add1bad8714f5a14b88e01c0f68ebe4f3cac4725f2614a1f0a40f6be580736c1ee116f18c5ba6ba8ec2cf179d6a29604d2df5640cd2cec96ca86d5e3d460ead484edfd0d21acfa3c029b6b7a76b5bdda2ebc23fdbdfea0e845fc09d4330ef7ecf9018466be83a34d407db000854414ca821f9476ced808ff05ec4682dfdb0f3b1f63823b94215b0f7d4d12de082208c4038b9e408eff0d3a348bb4e2868074254f46ba302039cf277d2b348162ae83b4149ec56163ba2543a4d4bdd6bcee2981ab746fdebbad867c1e7f841a42f28f842bba4a6b4c3d0cf87839e173b66c43f1a06429a5727e9878eedd4bb96eb4231529fc3e88211d2b8eda0a89ac177f98550c0014f5f9014ecc9cd667d03c38de156d9110117a6aca58567b57711d826d0c42a9cec75d2a9b913dac3354ce03c957b96c00a709ab6722ad3b5aa58260e5c9dae8c87a17451b6e2856ca37b32f2f186b108499deed9f75ae6b61d9044a6e4793a590790a08ebd10c514b04a388a299574d4b4ffe3d27edcda430f0d7965a8d5eebd13e8fc795b8b61530f922d9aa0987348a9a9140c4bad2d3995e3759495dbefe29e85cb071592ee0e05c9d7c982c719c9274294b6a44bd991d52dd7c3fb28aac52824b1a6cd51e001542c06ef3cd7165471504d4e774269cdb79ac5e9d03248c67db11ee4e8d10eabac8422246d2c7fcd47a1f066a7e8923fae66c4a45674b736a9432463ad830102256102afbeaa7e61a4b94c0a57850bee67680ca93fa5dde40664071ae3b74b5db2649405a49283879a7f277cc92bc7fe8c4dbc16eeec582857a63a49bc2e0f01de3f9d02a2e9e03e0115cd0d1d72577cbd74d2405d070e70b6032512043aa6dca61788c06819228841d6f81d5ca0d35967a2c3cffd3759b0571672d56bd77213bdab32eb8c0a869dd85457e038f29732b2f258b14c94cd1539b84011f81d5bccbca28a1ba6da44ef3d44592ff33e53e685ea88575d5a1888f88725843aafcac21b22f30e80e1b2e852647433854f3b54d927b569709ae084e2d3f48e5a1851ad560f7394d42515987959411c327ecb8ed0ec7975ac65f8e497746f780dc219ae5fc0dfc1e88f590cc752909c7f400787b1f4a9ba584451ba1409ca6cd88faf0d9911801658064bcc3f88e72ab5bdeaee963080b0fd18554b7b10c15058c9dfb5477bebd3b6b5d51d02d6143bbc0ab83398d74627a068f7b3b5fe0396fc9901576fe31deb30f5459db27fff276e30fef0228bb17c156f5f8d42202af37c10a72964dac125e8d419bf5a4ae414780672b554e8df152c0889202d6e27e70720c677822a4716f57bb210e5e7687aadfb737d84c0055edc893c68a6431f61d62429ca4a4a4754d9875a58507df72c1e759e1749e07875a61d9684ab24bc21503223f8e996d1f17c888b80e75e5bea3358c37c80ed50070d952fae876131d297048c11f395302cd6019e246440385b1d2fdfdcc45fc69e3daec22cfa0225d58cff1cdd013ddd6a069ab1fb40bdcd9c55e10a2d418d2f3060bcf8f8c7c5a002e7513a9889bf3108efcf910118c0865b7ee721d00c96893b8634434957af98a00b6f82b264346beb30cc5db7f3ac3a9ed5796db013abe10c79ea1990afd5e9ca5694d233d98a5048706e685f8d467cbd4a6b82d3cf004d76aaf7cc30706638fe101810f7b0653173df18f0ef21cb69881656ddce9969af374fba0e8f9bcd97909e839a13d485091a5b276c09a7db120e1f7c341bbe2619b4a090b2576adbd31f981963be343d535aaee3c07f138ac1d09dc8f9c9a10801684adca2aede49f1451db7053e27bd9be0995c7c8fcc22c0f0a73b11ee2902973c022f8065377c3d818cfc86c8d49a013513dd3b8a3ca6a91b10b5071be85dfb2374a96ad62c64202bc004e37c9c200b8e454c0a23392367f72444e7b041c75ebbc28bc74bddb26d8d351dbbbf59a25d27ae303bb5e737f11d6f39e6ed57008dd43c9bd97df5d6e8eae8c4dd6b3b79faa3f3d8b76dc68488686efd1e6c5de3fba5e178643d75f5673e6090a1aa4cb1f93e278f0fb0b52406ac9737fd78d1c1964d075e025c74c3eab33a874ea4d41cb466e5f747247d3ac4460d8c65de5dc97232e916660efada5b05bc2ab461de6dbe09b0a43b4177451e66092604602fe7b38598f52af6920b94b3ccc18b7aedfaff014903607ff0947dc4396e20915d128168a56cebae7355cfd4e789eec8eff3e0db1548458bfeabca847bfa8a10366b12047157d76538b88880645f9fb6dd05bef09f58727188560728f19d7f0be730fed068e1470b9216507f1b39998f0c9c212b26273a6a9d30d300dba5e718b6fa29736cfcaebd5a283f2029935030084fd5b963b3a99ac34620246839a7b8ea89ad579c16d6e23e89ea8263683c09e54a4cf6871442ea020cb30dde133284bdb5a8a7ee1df349dc5748c1c54d405ee2783227b2aa6a7e7e9810b252ab514a382524ef70db07b784264100d89a790e09a004d38f5a9aa46a7978d26915c446a23ec657b79390038cb8be80499c28eb81044d2aed592f2e4ac991a4cc0edcca4d616a7c9d17683230a7e02d8049d6bd52e7ac5fe138240ce722d07f255897abadec2715c3b04942bffcb98089101d43afb971fa6cdcfceab2d786e3bbfcc3b753f935ad7f24a519ecf34141873190b74262c1dd5ccfdc6b83babe4eebd9702eba4d14bedb88f55f6b43f877418be7ec2ed873a2073950287b039de5ae1018bf3274fd83b357adeadbaf87a032d1dc8173b6a4ba5e303d71ca7a6f9ab1b9e7a2fdec0c84a2a239d2a8d9e71d7074b633703032de99f8c2642b294db9c245f441d6132c25753bd0a60bfe5f4561ed50f5b5e2bcece0dbb4a6db9b34a6088f82fe785b9e742bdb47c5ec0a5716bd876670b4d9896114a6fb4b114d701d81293ed2cb1e17148c560f6e8198a428552c3d4264fe8cbab7a8df03e0b86fd59e3234d11ea9505bdc8fec5bce7bd56f6f6c5de88a41866045c6e5edea64cec07dd622f6e60106975825e9539f39bb58afffc43faf40081be702e805db2cbdc6d4587caff3a613898090ecdb5f5cba0cf4a8a3820fcdfd738d5370a83d0ca03301f510b99e92faf23b4b75a2e4670221203ccea7ef27459778d11b3c3455be9f904902e47a2dca23d68127bd052beb65d4f20319eeccd0cf71b32d87469d5290835bc76e843f4980e6a587d5703b4ed32a5fb80ec60435ae92407c78a1f114badff93232e6e75271c43b97ca2381f592801385dadbf11596ab9331eb43209ca37c4c071370ebd356ccda21b7e72c5a2e7cf7d16498366c05eca341ceb045fb10cce4fa726e257d9922df62fdb4fe62ddbf12473023d6ef9b4cf6000af375ed2dcc164ff0eac224ab7f399ea97eda160cc2d1151c0d28ee20fefe08508857d9199be7526d8aaadba491dd33dcb54f58d4dc7b3a4127d7027201e328f78922873e928605afecfadffcd7087c3cd3b4c28267164095246d2265864226abad5cdedc28b74cab08948eef96e9152d34a163967bdf21274047ea94a2f7bd3f4acf1590b3808f2322c88a5b317062031b65c2be68e621a2bfb0960bfc3a09121508ac51efe990c304a17a1c24e6913e3725c8757b5b15f13d1cab33bc13ad6a8181d6c968a4db37e0e3401f9842b592eacd2a5da8750e7a6d24df1156cb0297bbb67eec75b153101f7bdd1843c815c23ea02b2ed9eaa07027247c596d59915d60e8c350476b2517012a5e9760e90b4ad4d9c25f5a84afd17b7b39424ed02c3722c403b42d0ad1739b156befd09f5e756976e3e640fdc337d56a0b322aea9a4d4d1803f5933a76db1c56449eafc7b58bb738fddb396b1546947517678818ecf58331138573df136c711ef5c3e751c716ba417d3eae19cfe24a4bf3ca25afe099e2095a2208aa35306e956cdf5083ed79ce34ead4f19f244537564761902552b9619cf755da5b2cb0a891a6384e9da60b4c18a0ed41ac90bb2c8d793839d0b552f41d82b271c2cfca62f1d75fd04a991deb0290221c8f9288f2886496ed2ff25e8b6b624e8563dd36e7f63ca4a4cb93c36998c7531d8c738b572360eec59d812d9f54d320a00bb5ab9820e5651725fe1bb3faeac265dcae1b76bc36d0350a56c7e995553ed573d54548eb70c4b590ac33aa8cebf0780bad5540556b9dec98fe50cdb5a1c517ec8489a2dfee4fce81fd63e30d6480ef92356095f3a458fea7a7bcfe71393c3e63ce3b011744788a3d1159191796eec3537726799c1e299d21b8da9157cd1b78e74441bf2463c6151303ab952cb19e363226f32af8031242cd318233344185cc867bd6e3050e83ccd53face09642ed2abf7a456de7bfccac692e4c16e8d513ee861eabd306bfd7b32b5c49d3c5a46395d29594f2a44e4f99d92b31704c49bbb42601584a5609d0f3c6934781b126bf0141a14a729a8fd04c16746a2c888313ab48f5ff6219f02e1f8bc65dbdc902276ff9c491b6937f4a250a20ca05e0ddf069d5e6ae6f4c0ec7421a594b9c6a3de9922f5725d2d7a25a2be3ff5d63ab90b1dbc61c513aee975081f46b46b40373442c2b77dbdd90da7edcb4f9cb9fb76984ff4d9f51412e2da0ee3dcd79dacdb24a2d73cad1531874f38cf47ed7b6bbf7a89dbb55c4395b2c975a1484a989f2eacc2c80f0090587a8f2fef3e172a34b453e0dfe921ba1350cd6bfc7375cc29b5c11b6e3312b99ad941194d733d669b3bf0e854e1201a59e7381c6875d0934622c13b6bd0ee18c5ed14a2d71e9aa41de60f18d5496d939af8b910a0587f17eef7fb645c03fe38ee36b15b525d251f3b97e3efb7eb602643c0ad47eb967342bb642013e8b5ee89cc0461073ade780762850b978e2b8bebc2f5d668ca89197d5c0474e621145a1130ece24d2d07a01ea168008c89e8a061ce2a90e03ebeb1223843af625893336bb8c3fbb62cb884397e83887c02ce3a328f7f530e27b689dd3c528376ced6772070fe1e0d98a057d9d5c2aef59191e54697d1558baaabaa906f2ee896b16498824349b99a783253b69bcc82ada455480ff0a6eff51259c8fb99db8389b16de29b0239bea963a066eb92fa5ad51dcb4d45ebfd8cbe68760870e8165113e4740b651f489500ac53feea6e1ba1c4de0ef04392a101bf863b0a025dc4a8fbe7d5cf51ea2b21328356907974f7a8552ddd5a2757df848c3564df6ed1e36f1b1e05b4a4579545359bc4e388ce8341d2792714215e119d4d481da13192697423048948abf39729d9196e194f37f7670d6248c554b9fe548820716f52f469590650381a343174655ec5394b31c417a9096a232ec6839ac109645b70c30242868bff1ad6260e2eba2b6642f066dd4caf757b4b46043a03b46cef89a3bff287a38cbc07f7af7143ba70bbe9ed10b5f18ebfd445957b64c7074363fbf1a2e7a6076fd0332bedd5a52e097350301865c54cd3575eb713edb985e0ec5fd6e742f50fe22b92d3bf45d38c85ce0964f25d48288291968058f6b9d86c8e067b3a1a3bfbae4bcfc77fed0b566b6075a4a7c850e389a958f9b6405d400938379dfc8e469d6f2f50bf7d0124f0e5c0e6c0a2fd18b005a862c94090d909622ef6d0dc3c554cc519268012be690fe7979bf30a9185915ca375f7db6eb6341c34c5763b7acb36932ba955e9c624f3b9fa9fd0ea860f54b49d70a9386ddf376833d2330bec031e64e23b6e32c162ab7f0f5f3006f8cacb001e3fa202712146b5fe3cee41a577c5fb5ea740618adb13de79118f4f5e6bc7da1812869ca739b2ee4c9937d3ebf2621b42b810995dd5d674abef17342d05f79cf3458800a4fd0b0e8ff1384bf9454761b488f8b6031bb6cb1ad32f241a8575bc4f338ed7261fda0f83b5702377a97d2e729d839d257c594cfc58578a31c317630b66f2c8cce8acb1e41cf22f24e5074a185425c98058f6c33b5909ed98e1fe4d52935606ac43e9a1b14a37ee501f351509e3293e64468dc91583cce7e19caacb1fb965f0cdd39199dd9525dd1ea68d903f9eb9a59cb184b43e6c4619704d3dccc6dba65dfca53554beb62c21b3aef1c0174db649887eea03451244824289020d0a3f6e34c6d3180e74f1e8cda02d3910396bc74062755f11d70340e2679076a2434de1a8437a2a0bf4605e62ccd444e1fb63be09af03b04b58a9378029e6fb61813beb3cdfc1a59f0b6e6bbd3767d26788a7217e65c2d7a6bc2ed933cf6e8fe658edeeae6a3cfeec38dd8236c9c396bb57b84a3c17641949c2764c208d529ef102293b840e015bcef78e336da4dca775fffa873a639e2871627f61a41c1b3c2bb1a5a0029b7f6896dce2bd8ffff08b9a1aba15683cf1055a5b9c6f1aa68b623b0bc8734cc4ae39122d52c7c96c3ffde3875a9ba7ca47cb8e7f93663e7dcea406e19fdbb6eb8280f5d69e483b84a4533a802132522f7dda8e557a9c9bb681233f1b6a6a5c21fdf8c6fb7aa90a7115795583b1effe53a0862a80c775f685f81117896bf8903ce50e2353f82a6587978561c19b8f5e8f071a0556b7c6aa03e4893bb962f892fc701850577ec358454e2c976bd7323d57d83670d152ea96de888343835006d6ebdcce5d3ffd719ccf7b48fde23fd935ad31a3e4bf120c035b184d6cdd98e548073f3f6ea41731909140ea8314001222ea039fe07b6b9a43e8c49a699b3003f43dc7f119c6417dc5842671865be537c2344ef4f352bed5bd87646ce51d53a109eb86526c638cd41ad61aad45988b4be7b69d2ee82f95f3d893fb7ab8e1ee88cff0b7fabce1de900f0f549875d6b1c3c2f6338a52b4aad0ca47922927f574d76fc3e19fb98f4789967cee9d724f8e6939b486eae6b5656c6b309f5f92473e32e3f1b39b94a7de10cfc1e109c0e4526a90d118e5ed4dc4875de999be060f902f38acb22c330c281dbe5fa477998637cfb09df40a325249277b0216d3e859754ab3e95d15e901d79e770dbbf3cca3d3584e40accad8f146db688e621329d76c93ba138b509085371ebd1f613ef6ef60bd1c6f0d4a567068f58d8237e8ce4dcd061d0a63bdae262587ed6690fbf8b88ba8374c8b309c8ef1baaaf25ac8837908c8837a7d6e64895adf081e2612877df8de671a75500f03ac2cbfab96d8287ef5f58b9f532a8379db90cfdc7435808c3c4fc7d6767b0ccc810c527161ab5d01343534af680e36db2b86cd264860e99fe16553159e05025b5ee1390b2c82497cfee999b18a06347ab21f60f046afb4e4ae51b440ab68fdfb702c326071c3acd19b3c8a3940a97f3da02917a1bf420de4cf4e82d6ce2384be76e874076dd7a94945afea66d291ac709b54bffc3261dce4fbf554629b1194dc01b1118c370587faf02384c55025fb5f143dbe8272560935029db29814d7ac5fbe90e3307dc89e2db11796a3d4aadebd1f470f0c4a7b24f58f6bf5874293579953a75d3320dd2566a47c6fb7a0c5d75489eb2df5b05297782f84db57057eaf6dbe42650ba40b5673f03c5b7eb3038eb0daa5336c8221ecdaa0f48c080cd348f5b8e2a51d27c1dcc0fe034d2b8420d2e793da1788a6e81a7c95333dc2afc31630526da1b8d4bab56fcb89dc145d64ddd789e99e4dcd540510bb7f18e6877ba394cef5270e264f769aa45f373a3c00d46efa6fccfddfd30141bf56c96b88567040ca7fb1a650017e9ea7ae0a2a80511e9c34ea565bc6676771f9393aa813b711be96172043f4177c604e01d66780f31360a7359255a77f1d18dc323aa495b9c6b30eff74a3cd95cbb1b5f6021dcdbea4c4b40d8487f256a0e66404b975740b787ce55e36deb974278e570c37145afde615453f0d02cf7136d071d594d04ea97aa9f2ee1dea7a5c9c75a16b9ee63b8aeba0450f15257aec278b39ff4b4bc91bee1736f40cfa5852a4e28f1f7f16e35c9b9565180fda0113880c5e2adcff68f0d90730c4f9aec5167eac90bf7f293207911d969f4ec6f296d6a7124bbd29e042cb8d198c86e1ddcf6670d35e21ef0c13bd0e3311241897022be582b77e1015b42bfec2636a3a1af1391dcb7a31e945895d0e8a464757934a0f728b552a4ae18386c4aaea10d4067d97fbbfbaf8a2e478bdaae043d4d089976a8794ef159a20ce673e155760d3160ab0b69c244d34c0bc328084d0d9841c00434e358426d1872edd56bfa765aa7f34975691f40b3028152296da88494ed2469833c418117e633fc48782ba40d929276e3db366f148330568ac13ef6fe6850b53f6f88a2095648e6e75179af01467e49106b08bb0e5731f556aeb7d42ae4c2faa23d5a8ae83061cc37da3c85ab688bbf19926a9f060b0fa342b1e7efc4cee659dab30f15cf9db9fb1dcca66c4c3d36f7b7991ba528ce4334065c29975202c0e446ad5c4ac50914c1ddbe7d0d536cd98801ff9d26674eaeaf1cf190a706db93e2436249910f9d09597aee158a2de0f9c77b1ac2af13982d659753a8e7f580d786603a8956163ecb1d2b34188ec3b2d19d8d63666904fab9cd595be47ed834b785e9dc1346b775ff1f8c4d1983131c12a395d93b655842f37a024fe4c0eabc1c851131b8c7ca5a364b2224c2ed3534ea6868307030e216602535f58ee9817b265e6d2b9f5fe9c8f0c7494f116901cd9d51fe47eb7bafcf61a23afd4c418725b60c65cf691f067daa5ab23de6697c80164025026007d5e0b0abe8054f62cee9c9e7df5ba2f1b8d03c24a6a2588c7403a576fd463ac81f7be80b743fee33bcac3edebacb69f40dd85f05d34ecc55c8ea935b4faa68ad8b89346d406c21d5ba3ad3af5d9b033c6affb2a0704ec703c66c74c7365dbe6d16517f2e745a84d818a13fbf96a557316abbfdd77233608a596d6e922bcbe60603df42a16db7890f19952aff76c89d02f0e244620515550fe994af4710897c573808db595cfcbb03f2e1a8f596497724afb979cc99ff27e39f56b384b374ba18f250f6b4fda57a0b0237174bb1fa093cfb25f042d3efeb412345436db183b95ac7ba4d53951a1a019a1a0ab711465913b6b5348c5d83ea9decb977ba13e49c6f9e24cfee9f62f6ef51f47d7fb9a1e781ef96d1118b6f79703f0518e05fbe8d304d923dc5e5f8fc4482958287da9331a8cb871c0194badacd140e16b93bb73098706db2d5220a55943d024f58b90b2bb23bdbe646e1146b928425275c8fa4b5401d23598cafefc3e50aa41bb285fa4b4359a3f0afd7180a274adf09a1bbb875691b55708135cc77abf606fd29b551825f2b37f4e7e9e43045ace63608e2d5c87933a8eefb444ddcc3cda4a7c5bf7a6b1fd176d0ce1f6bbb078d69090b9c42fd47a28772b91fe531458c529634d0dff2fccd77cc45ecc3cf8c711cd6062819b01d81068c6b18af3027d0d5312ca258abfbc521f103980cac30b5fe15dae12361d945784f7695af57b57bd297910cbd4254b618229d479d530457c33db378d12c7e613a1d2b8ec079e2381c2767cbe2002f929323b6dd19fb3cea26f82dfa926377ba75a7b5b827f28bdc0b46f3b53144ca8929370c99507b864829beeb49dc30ee5f3d731327eb09d3055e6c8bf84a5a1c9802474be0b6503a0065de4585036e17313c85bdcf3acf63cbb75f5fae80ca1924f59949e98c5c18145600f965d5b9836ddaea306f61db7c0f72ef8ae082081c5eee1236580558c377a58f192f80d1fd9c7b4f6f6293d332fe87f6b94a46ab14d4e4462a8bbebcfb089ae12f6f0ea16d8ecad9a737e3c13f5589f3933e05134ea7ca3b7599e96ad578dc483929440b554e1a1a7534c83f539ab78ff373e4a6a5f3a193f42c4f83061d6977af369099f1fb8fa9e67e6435dead1dacf2116d669125ef7e90bad31b30f529b982585bc8c1b6e96338566e721db6ea045e0c3f9c77c0398f5812afad55d29d66b21fbe7ef0b00bd63e0da44e9eeffa165476ac65135bb5d7ec99cf2f3295b65790f329e6f4001bc8dc5cb2edee98ad26d678ffcdbc095af8af0896613c233326c8b657e36ef5f88de9b6244b0fe244e37f858695ca48936970ec1056b147fd3aaab9da6159de725c74f2cf1c1c572ec61ac178635e258ab94620d6c43fe0b9ab43d239ede804775d465cce8c2745d0be098bf05cc95d4002aedac29a560fa0037ca67c9b1f9ef3dedfa33d7fe1fe51ff305e13c30c744289795af310817a7e6815d725989582bea84098adc839256d24dcc19838afaa10b9905a07c2335b1fdafedc47c56f5158a9a9583c433223adf3dc36325d1239eab4422974724b715a34223633ea10452a81fb057cd2aa483a753efba075bb6a8f62919b7e18f16c695664ec5c14712a48d44606aa1117d8bd07f75aeb73f77c7de6bf47fa7e39e84dfdcbb452f42e3338c51401419c81568cd5e814f0d779d2788c75342daada1f41bd9965b2bd1416b5a0a79bf9d3ca39f693afde6049dc36eedfe7cf241128473f3a8c5098767a29e0c0111cd57f3bfeb321357837bac737310d1f1c4d00f27fa0d276eabd729de12a0113e405330fd41640380f48ccb098e674a5e53b719593af992d0ee613bb6bb37ce5308475484096291974b5c07676e4dddbafbc2270a02e915002ca34bbb99615d3c2f78bc9d8b4c48a8fb0793f5b3c546c128cc99963a4fd7353d83ec7d39530fa5b176d54f4d67068e33092f4e2f04af818c8716d61a33453cd756f1eea964b4f532464bc17b3eaed827aab717243f86c52000b5887698d22ffcc792170513e930b978744578b76dd54bc20f388b828adf6138c69a449315e481ff3ae907388054ba582113fc3c4502187c6d5ec0ac8cec63a6f4387ab1cfb1cba78adc326a4f96813db121a3a18ba1540cb36543bbae68ab9defd5387d17cb4b95558efcf634318c1c9d546f8adce5ca92b099155a9d30a20933c71b2668eecc338b6457194dff2ce5bc785059a90d653dcc3b4700f266bafbefa1200611f923242a4cf49c2a1221b327485b46ede4a2ec796c6ec1f0807f4ecfa90113fe23ee45cdecc807523f3a463e4785a8b3c95a357c27213ae4f02276ee9a1834c0e4aa417f90b5fc672985581b9beed5262f7abc6d9cf1fcae6373a3ebd4358be6d368301165831950d4283697d8c01fffa4fe9db0c987d3f5fc2cf00ecb9c719568b0612ffdb19c9ce3e6df21464bd99aea5046ef7b6063f822acdc757d733febeb1b81a8346ec6f9ace421999c3e023f3203a4b4335da190a722f73a69d6777e21b2b764d2a278162202946553365f0b30231e88baa857f35f2fc7cdbddaf9ab2cf2dbd6f3f3bde15f99ce830178b47e80c9f31fee0dd7ab45dfebb0ffab9a79945fe0b38255a7ca3246bcb724cb4dc2ec1eba9f2eb543beda1e5e3d3594a4d8a652cc695fbe69974d2ea99743608255e44a69f7f8973bb2208a4d2f7049e144895a27eb49eae348b740fea497bc7225ec2bbf5eb6c683460992ac84d0f00c3a47aeb343ed889a6bbd18bd465e0db7a0d546dc3445422a5de7a56b5befd8475ceff809a5b6046d13a69783460af86abf441a1f0d5fb1462746f3a980cc130e687da0c61d40a687521ec0c1754ca0f5ff3730b98db7bf4f18cbead37aa536da14bbfa28260e2f076cdbf7e7ca6adc63f4dd65c1e2720fc152cbff1c88ad96f612842ae7364212c0d192592142aa1be3e3ef9412dcf6574e7bfc5b9733e42022865cce4e82f80ef39abcb72a6f66536b7dc1fb632f618d8ab0a18c89e3d3550e306a421d269feba7cc844eb81e9f3e7cd8e9e0516af134a45a21675f4f43bea9b688eabbc5b31a0a81525ddda74f2232f4377dcb6667dff3d38a1a569e37b6af239942b30cb2ba6daf78106faf64372e899cbf569aa2cc4494d194e90760f19f1a57807dc842c1478aa643d8dd3a04ca2cddab44437441db89c0e3e5538d7017c494ee37004c44a2140b4858b818aca79f461d8499642e06955ea2512842f66d282c49677d72a39ea889e46a8b42d97beca196914d2d9e330b1665b87f90bb2521f28375b7a5d1b82ca2b7ba068ee85d3367b0b0d4882ca47b8fcf27ff619c52af35f565c6a5409dde7e96d7f3c2b263174beafc99709467aef385c2d686bddd5cb80c6d43fe00b7a590944770280acc30406d458010cf66ac463a81b26ba62ac786e1f3d64525ad457979074077d98cf4ec23ed4d38bac0a44173d97d75a1017a95078bdd6e1e74eec54fadb7aaeb07357895313c9a25969a7a38faaacb08607cf3e1afe3b2c40f41f5127115940935e65169a55ee1a415fa6319f4c1ff9992d037b31bd568b6a899f7371683d63923730a7bb1bf268b9777d13b7174247e4aa92e11d935313288d27701d8a5bdc0e588a7c3d14f0269cbf1a6c59814ea78c37e88b5506dd63304010c93c88f551d5a9530c55e6b2adccb97dd33cb132fe3ba90faf16f586ce6bc7ad853580cc1869dd3d8620299cbd920b39bb997c91a0e6bce8379c70ceb60a2506b97c48409e8760359f32bf335029b92a762a303fe790fdaba2f8e4d3f09a48bbe5e3935cf1ce58b68da9a376be674e2b13a2cc4d1510b50b696f3a6ac87c99f86616be606539951318a426defdbb8bfc367526e889e7a2de8636374f7ae990e0c2e5291861ccb03d625d6680e8d43c2e177194a975097b15a56e65aec1307a1fda84057c72a22dce03235ad69bc140d198d0fac9931f7f1c26901485c5ef318d9df885dfeed2955f9ed48da0e87fc258f39881f8191e4c9299d5699832d7e14f1f1e2dc597e1f2dc1a264a3795db34f9ad6c9aa89ace677a870b1d9655dd17ea9cfde7359ccedea457f26ffec85a415001731a231db3366a5d2865fb24f81729db9a52d72a1745447f23b88efa868031b82e55465692818226c40d49b83c4f1611dc57adfa56dc8eb3e72b0d6235fc5c775377ee7bfb6c7aebefc4a5182c3958049cc0df3e06c92250df72d56789e584502a67a5089a96bc21c88fbc6b15b4a4e65fad12dba8d777127c11528bfbaa43945a857ad88f65e6a338be5ce66b6d203a7d4466382add663121ed851550e187bbe7be4311d6c293a881ceb866d9ae3d73833e171a7acfbe227579647c764a82e51f22ff027dfd4a527e161066616a0f59c01791e73be0053efa8a9cf0b922c143bfc73937a156ce62983ab3879244da03b04259028ab5e96739b6b16d23ecacb83aa3dd001b21baff98f87f6df38f8da1c2fc86e3097283085867206421847e4a6953e11f1ea72fefa20640e653adc5ff208dd7db31964c3701ca67c065df0cfd539754faf9a9496a53819bc9694885c4167fcdfaffcd982c84a36a9feb0672d99a3879da53bd023020c23965666625117e190796c4275dd40b5746d6c65fd977233d690cb40221e1bc0d53543bc4d9dced426552aaebbd02adb88fab9e9e0f0e4fcb3e0aa1db12c0f415dcfaf662ff5b68cdfa658575c099e412207963c03d84b0bc7276fb0654413545669dd445ddb157d89b2affea73d19d1dec23abccffe9d2fd9ca4ea4cceb727528f2a79267be574a076d323255bad2de86c6646648c2d9ef0e01f7464d06819e3c8f87ced797141952cd16c7dc67d22708ac53c14a6d02eb2239964039aff4d021ad69ab163149d938aa3aadb198f162a85ee0f42264b762accf0f970d85ff8dab97e40986758d17836f01be777e7cf291dd7b1a8bebe6314c8574f720ac27c0d8d37520d140ec4cfb86434e40e9b9f02af5a7273381683a811a90ce44c87f1df8f8b6547bf2d71357d9a5db6211b8ba971a5d15b7be9d4f51febb5f0d498f001d8163562af1ade9a781369d3231857c5133c3c2a9c9ea8504a61ac9371eb61f82747d1cc4d51021fc34aab196629534d2dc413833cdcc1e78f494557da493687b98bcd004f17fbc701411f4d242d38e3a9e75aff3cd39f80ec4bb5ba95a0a87b6fe3b1d3dc7f3a1daa6d0eb3a7e6ce7c8940f05db38aa1d2e6601b66222379ee83a0cb2d0a56edde3810c79bcfcb6aeb84c8124d1acc8e4c0921d574006b4af7304925d5c13e716482c3a906aa1faf34838cb7798a331ecbdee91012e03bf32e2f81e3087e40163dbe98084f5c605452085214c9f70b302e7646fca4fe63ecbbb340d8b07b4e84dc647a8c2e003fb7e5fd5af65aa80e255562e76511cff26d90bcf77ff0dcce4b79a5d835807c592c630f5eacda04ffcbf73f4c2b16e951b9c764f46c3b2b97cb49fb1e35090d97c34289087567230c08b23ee0bf22e72422e063f7be68d365409842598af9c4baae57167cb21056a8f633d943ebb6ae15129d8a45c02250cddb8713a216d3a3dcce65a9560e4532c39873d246d9815e4f8b210b0676be9cf5c90035e55e7386680399d8043164056553cad5efbdefbc6281109c5ac8b0a454f27ee5a7e41fef26570fbcbf516e67858bc50f3a637296b96d09c2a7bd2b10319e5c426fb96771f62f4090d02d41cec8470f95c5d5aed8be4e6f66872e968cb0bb43a780ef5e5fd7a0787d28cd6c9ada9d457165b06e027f00880c27dc8e57f164df92a93c7aa95adbd4377202d9c9df88edd8cb5a3335db4c8fdf356d7cb3b66677ab885082ead1b85019c00d20459bc649e4217ccb4255dcf42bc491fa77a6e41a7b4f0f6c3352e135f0bab1f34640f3417779e45cbd1a6f05cca300907936d03c7e6f8436f06b587719d555dc1ff68dd6d8b15c8945f94db49c7513c62ddb2382c72adb3f1f821492e2ec85ae888c53bb49f97797731b2dc59aa908b9e94852fe92450fa20bb64b74647af31483dd3e401acc968b1299c27eab805b5917d9887f97d5dd37fd1337ec42c8f6308ae662928b0f39b075e51f76660653d658019035eafeb0d4a30903983f39082fe51bce1ddad6edac501412ea92f383e4af28e6a1fa9d761d41b38c1d034721f02a2dca133bdbb37cebabc38d5df62d86357a0ff3c5d8aff5473d93cc2089b4a5dca64d4db2699312210b97ddbfd8d94b2e07c88685902a52831772cee0e095162072e9532ac7d0494865d1bad40ece151a13cba86e4cd13281d3f28660e1feb2bca95079576d1b459f41286fec32dea9dda176327d18fce804ddf8df0596e7d9dc534d7c265348ab39a21a03ffc1fc5ebbfb62d9534a31098863a0fcdf55e320fb1856d4dc478763d792eeac009366243cc2cd97f32e07b7dbe103f8650eb4c6c6dd787fef6319e8f3bd06aab42324f2137161b353d48b7b29ddf50b4bd0e4431ccb4d5b113ec95ab94eb8925ecb39e10cc06b2ac91faaba401f6b2477bab5f4d0dd916d493bfeadc53150e854c98deca449318dbcd8195d226e62ba18b0e17c0fbb79e5cfc8080b15ef051d3d2934a15db207326768ae38dd85ec385ee3ef26f9da2adb3fcb070f577376017f02328a60657f1923038290f657113ab27863069ef2da48ccb967f1a329bc9da9811c11c0ce04203d13d55d46d37e04f3e28794504024d07084746ffee262ccef854c0c9767a420da157e595dfccfcd945bad8b84c9511dafbdb4caaa1734a927e34325182eb946a6b2c6b770300e3bb89c62ed26016ae448fd69a2ae1f4ca1478e1fe88a01772338c47769738266938fa4fda4ff74c6e4c4fe4d8696b94895e4eadb529c5211a1fa37086416311b4fcb15ae6ac9d49ce8e88fdda3ce8a1384e7b11ab3fc5198c2456028315fb47336c247b660467898e0785d4d6cd721d247cfd55921a92c6d2188c07d35f409053f0e12fe59cc7ea488840200f96bdb552e36623de7d440cb4ed8a5621626cfb87b4cd23d961429ffe32722d32bc9e287b6ec68a844d94c1f55b708be798efe4ef5d797cc239b3b7aa36d1b6f6eb2a38ca2cb38b34f797deb2c4f2955844122bab0d8572a34e33d042a14c3bb322c4f32051b82f83ea8e9e4c936a6f87624a07067548eb23d522c49cd90fdeaa4ef369c58467ab94dac222d586d82b981b5069b08012b77b831fce8bd219d8699f7d9a7886a34374a1c6935c670493ed928cc85cb3415f2856219a0ba2e3caa999e4e2079db1ad115de6f15862af2c4c664f66363940e85670f3169a83c0eb4b93696f9f8262a07f5a361228f44262e23612bc6c2b7e915e1d5909e4ffd3ee2cc7b2881e0db12ac0e1d8000adc53c9c6d08e1527eee41375cc2f24793c7742c08865c90be8615f9b445e8bc1683ac8570de2550752febfac380d75b9b17c2d1ba8894e600a2811584fe64e392d7d92841e854120609d72d97aefcd95db5187b6fb9ad7786bd134ac853ff8c19ed7c9a58686d654b5633b6b5c60c93e1bea9c93d59c073a8c6ddb5c8869473f7fda5c665932043b0474b9641964a79241f1857ec178c8c3a4f5b6e209825fa8c250cfbee7e2ec8be777caf6099973e4dcf02c6c31d33bbf4f25c615f309c6db72e39981882fc7e22b9d349ff26f91b4168ee4fbdcb9064175b82a949959e141136c65bd210cc9d2905a2638d332e1cd866f8877bfb47495c6c356abe0c9e607d85de64c4c8da600b1abf0e5734d5e6ff39963045fa151304884785cfcb64cca8a150966ef8d523d3f24a082ad8989f7d14db2bc2536ec665f409f9eaadb6d119b7e54eccf0fa6a49e26bf4ddbf3a438677f3cc1de1a38a3ceeebc8957b7e496de9299a3ca8debbf40fe339401b878f04af0d01f1a47ce8b520f808acecddc990cec5e939fe8535e5d27f916cbba4e074bf4dd94411edf9b38cde9d2b004bca4f1539236b2e736d5cecefe210a9b8f1e0bbc3ad6734172d4f835543ae8e757d0f812b028fab49b8b13b83db824787746e6d1bc3ae4bd2114dc56483066a7a5f729a47cb6e311a6d4fbe0c6dbf0ad88bb0bd05aeed1de9e827c35a127542018d077574118f3c4efad56be7aacfeea8710ba799a6115f6b1981a74d7150bf54e043eb8eee70768c2b476cd6aa5d8261c53f6e6e2c6e721f206213043d0fde205377befef3dcb731d1ad5fd498d371505e2b7074782a20b8cc7168f13dd4f2d94e75feb03b4cd42bce5e9afca0a95587b151483e9f93151b7be6d9da3f447b6f32815f6e920e4b95f7e2cfe9ff7fd2a74d66b9604e3304ed4711bfb9ee4438b630e2efa35b746cded4dcffdcc99f79ba4a07739e14b4f6815b7fc3bef9851a7e6a3eb9833c8d40e1ebc5caec18f42086d3c3133a5de204f6603605e7976b19e043a6a67e6bb4ce491daf2863f7529a1a6adb9ef7d502f35933bc132990b3bf22de0a1e748bd63bd2de43f053933f0fa4dedd0e057e26c06dd88c0c1ee9d8382847c4fc0a2b33a5ee332bd1f8ae1344a2a0050a9d751cb762a4b1e1c0c5f9df386f9228efb1bf76b2e5c68b6b4d97ed452c9e82e96d738fedda3e6df31381a23ba6b84acd75c0643f140c28fbac057fef8ff4a4e489badf1252b7a747d86f5d588fa7a831ca34d62bc2d8f599f31f3e2561b4e330c124a60351600903ea554b52f58f26c618a6bb679230a18eaadf014e9dbd4a2d2bfa988b4992791d4c1a5756ad37b9301ea5859e9133dd3fa9449fafcd3cc29528f038d14898728c2495915df9f47f6c43541c02d7fbdbc20146d84d0189aecf348eeef9ed91dc6f89ea1374de38f9ff7b2351ac589e00ab0c9685879f8cfa8d2668e1beda826376a5b0858dc5796f10b5508abd36031f53126f7e63f0a869b8ef9b8d593c9d31a76293ca2f67f7f5235c8bfa9c6b9be1e2122b82ac5a767818ac2795d12da1f0ac2c79b4eb01ea85cb87a568ecb9a8ebe52438c1757f27831da8ab8dde61a8880ae3b048f6d2d04b86a21b727937627d7aa120a46f61fb7b9c47fdb8ea33d1ae5eb62292e8ee479996009360b0be6966d3d11dfb5a0ff416d4286be89ef0bc9e04605ab81a01892154a14e8a75613a62241075fe21cf4704bff472e00b20f52a5a88589cf9fd188bb7265725505262f6f62d1eb6a83b344c40c1918922d755aad7de165c2ff42fda68c3d4ab75ce51f3ab916eb1f108181fa81d0729308291f36ea25ebff62a8bd6666ca20edca8c65c035ced91b74dd848caf6998a4cb7b5f331f05e6455b3dd9169fd500659c629e1fbe176874dfd6efa8528bb1cecc0adc0348588974401b1e808c2db5ac89a4e0c9e8209800eff9dce71d6a6bed94e123941fe1a6e61a57c9eb27aa21b98f51731bb5fb7adf1f7695591fa1075815efa798a3db0513fff8ae13771057778095cfa709416b05b3805b8c949decbeca5e0b54d8072af5bec382e092cca9abfa3ff3faa8d7b76a11eb8fb1b21d084d7ac57433493299329972bd3a72de596b04b759f7cac9b479358eff12f960bd9d5d1d357a6beedd5dcac06d688d911246fe6e8afc074ad5448343122fb95256c5796258ba73f6f1cc8689f5da8f2f176441adcb2c7b763effbb918d7d97527b06f06f57fb8c0af5d187db12ac03b4581e029263db506d35820058e04fa573de8005e2723a16c6ba2727d7c631944daa436497fd801d7f114b87508a40305ae4dc09167b4346056ddab04a1f9d30e583b4feb6749641adb5015f80bdf4d2e5fc0b54f9f3cfe6a14c7190137b3fee2e24d8a88b6e63c07e99bb2d7f2cb0958f5f53fdeaafcc7a801300f7eb557360665bbeba087f1e6314ed0bc15cdb6b167a205c307705c833275c9b9b6e7ad764e44d34d66a881859a99831feaae924929bdfe4ce29aa54eed917180cfff3b5273a8218e1690f7d96d6e1aebb644f25ce229dcb4c36ee47b8670084524ed23ed39aa69183069b4a934c3fb0a1a3c0f8051a6cc67b68449b0372ac559a5b8f1d7ccee394315f1c4c16d514c700b3f9da3a41bd6b54340d2487083144accf351eb72748aec87c83106d3320c027fa7a53713ad47d94323a749c4210149427252cfc896d4d97c422476f10e9260b1884e9058cd29212a06a8db880bac632ee9dc3ac242cc5a011166107a25ba0427362d0b03a7c4538e84c02ab8c06842e2d53b9823d5c59971a2afd7f24ecf4a60a65ba55c7125e26c263fbbabdb6b3662375ac61ad71625776badaee18f7d72cce8831df1f75561c4a988d0965fa0cdf5df5e528c9f25c1ad07444bf223dc092d4d25b04829f962cfc6c4d33aeef5924877515dce56d5fdd5e2d53be82376bd084bb4934426b10455bb09bcd2cc75ff57994c676ce85ce2ceb6f85eb5c7b4b797c8f230eb82d3a3ed147ecc0134b2a1cae9da5243d6e02b1b44905b31e74a5da7f58c48318a1f14744ad15db27cd3dde7c139742401af73e56f88584dd853f2ca0a5c100372d5878728b75712d1c39095a3699905c5dcfdee815dd773acab4d2c5b054673e1c3d98a40af02673fa88ca6975e63235fea3b3f84e93b663edbb8d0b476ec9aa404f54da003fb4f967b276522928307e01e84f4e80b50488b8062839af06da492cd13f17e9c6e2cc1726433c86afb1871f3f0031843e545b345488a57d2812bc3faf0b0d387a3cd69aaa4a589a9f9f0794bfb0bef883569631d05fd2e210170a940fa3f2b10d85754e0393034a7bf29c09e420d54124901c5e27aae3960cc1ac23f6fbe7a9ef8e0abf3810cd10622507bcecdbb446f70a901eb65e4e286ad6d4b43d4485a756d46cba514e4ea0a76472fc5b1d47d402832167378c0481853bc6bd56e84509c13f2b1da0e9413ee38dbc1f9dc00c8985563f81a299843458d03552cea753aff5f7f9d67bb66841fffb342b0f196c8fc293ba3166d2cd1d7ff04df32d3ca4ed6f594c0e9f4e100f3eae8b89aa04c079f7197b0164d6a8b34b4092aa1bd9481db9800f2d7da8b05bf67e514818ce30042bf0181c9cf6dc01383cbd2fefbf2abd6548691c77e4cee1768333b26cc326a191664419ca2b2f61cfedabea0cc513c1a59f199058bb3262b586f958051677d412060f86ea708e97055f55e6047d1278ae06c5aae3521fa10e0e472b5bf439b7ffe6b5469ba5b271547bb79741d1d7085b390c8c9a9d647cd9f8e39f9c3c681ff4daea24690f47f01d2a73bfb7cd6b567aca3bcd1d6a8ffcc619624920f4b8041c7f13181fb57968330e709cc0cd5a2481806086eff290f7c8a05f632ff12c375de38d9e4859e3629aa9ce7cfefbb635f17c8ba088183af992f600fa38a01e72ac57a89828f1bb088f3793e76347fd8a82118d214cebfecc605e00b08655fdff56e6b8fc932b0150e160c995b2bbb1490e879d736afe2f1af9481c50a29a06304c3529d895cb3b68ebcc728ceff149eee0c1c6aadb882e05d9d3323dac755e142fa27dce05a515804feb3ee1b78fe4c90abae300c396cacde0d18ed4ecf3092625bfbbd5e2041df69a9b516486790c92c185be2d4e5fde27422377e03c95dde3821ddf18200a5d0bc110c20ce35d3b051851a3b52e2f03a97f953e0d6c017de705a46eccaa931bf8a71c582a9f6121c44df4ecd421c205ee76ec76db6f98293dcf7005227aac0bbeb8f7105aee93ed374563bb1204bbf47c1f6dcc6a565ab8a0528fd1794a88df76f801687a9993da279d2d4af762050ddf838ab40adbf4ef05b3df4e66cab6a440b8a73c1ceaca754a2d27b1c9bf151759255b73b1e3fe9f5f89daf9ea99a03209f169afd8a27e61b42b107e633ad8b2206e656ff11acf306bd0964ae3cd90633b3e865ddb789a07c9d7672fcd97f00f9e43f5dfe3d3482a07ac3f300c93cac7b1b42978cbd97ad61fe365575ed19c2b4975e36ecaa0bc950a92a23d26e4bae6e52b1410b1358ac454c9be44fe8950ff7a69d305043672026bb67a28f7e60bf99894e076e1483e4fc929347ed98fcca737a0824e8e12fe65b8e09da570c3000f2cfd86c233c1eeff370d7b05e76efa07e0bcbcf474f338ba65e3fbc9bf7f4a45698ba76ddb17178a90787e976fbd3122aa49520b5634b758917a1815fb5dcc2cd30609e846d34def14a0af93d0d653471a3c91a96d563d5ad5222840665a3b963db60b10bbe72c8b619c78c141b49eb59f8ca5ced326aacf8a18188c7323068504a5a19bf1bb8d3072e70ec84065c2d4c67e49808949593b7fc62cf3d0cb066da978a752a0e8e3fcc9947f22b7a83f82064270e68101d64ad36e89b27db65c50f82ffc8179a680716a5febf96757a633462e5af31ce39ddc2b6bff154d512bdcc7694e12d3c6fcccacd6d4a8b65e695698f8e9ab9090d725570691e871f7030a359fbd30e5d4cdd7168581fd30c3b87b61043905e1b112c083bdc26b206d652c79e06da1e09a81767520a658709f5d5b7f1ba981dde94e8699498df11c6dcdc384321d8e2f1e51abcbeedbbe5f6f0183a2cc72c976fceefdbd63d92985fdf371c607f2a45d11091ccd676c158d18d9a47a0b4b39f4e1c0663ab7d1606d917f2e96843ffa5ad231877cf7111d98df53bb5895227eb1c49cd8f509929b2fb5fde7c3dbb9487df93dde2ddaa152eb0952d44a6bdf6e2e77be2b4cf77d0a5110f6aeafec7d414eaed91883d53f5a0df5e929a92172aa2665eb24599bfe7097500dcf2e20a25a72b3e925617a8b75a3975ec26a3282f2ea8a5b3fb1323a0de87801ff3c66c6431b2fe195295189e5c4264adf1055be4a902fef3f24bf4818320d774894dfdd8d0024f71a5d57dcfb2780467ac907a3dba53120ce1605420ad7aade4b4e46091231a22637327229a1345e15ff3724aef355c9cb9759ea6ee18450a0b481a66ab109f7f2f8156ee7a8c4af869ff2fcda92c7f3bc3ad08a30e1076a5cdd751d178214783be13e0227233db8bbf26820f031e7ee462d6176c72171b03956b38391faab52b40c50961c7e523956968c95b5ad59ac3f06f7746a8924e8ab7877b4d4aa73f15bf079daaf67a838cdd2d453f0abd2ff45bbe56e68c0c74e619647ea2c264c3660de59fa2e0b50754f734e1c4b9dfb872f6316c34ba0a594b44d1919df36fbcbf5024d03697bec5d1670ecc6eec91f36178396a8adfc25b0fb3c08238c2cf5afcad9de012afa7840ea673d6c2225c1e4b0bf01371692cec2517ea471bca838f95debcaf6b90801b9b1f63a5123668cb7c0f3bf00c0071444049eed687aafa357384b8e18aed78f515fd9dd2ee7e5beeb935402026915d4a671bb232f046fae690a2f1a94182c9778d946b3f02e734c03e958487c358800ff5d7f705d02277354ee77d8877ad77c9ddddc35b6e00bbac13c65c222eaceb1bffdbeaf498742f2e6ec01fea822a42e3a1e34568224d101315fe385eb104745b5b4d740cca686d4d35ef59caeb1917c7b19536f97141e48511ee31ebbee250a93b4355c9d691ef4fe7a54892d3705c69252d2f59debe20927386c9d5ce18280072511a82fb0cce68d5bc5b96cdbd0ed92b12c8106f22611cd94ea39a9b23974e5d6a0e80b5df0106260b27a7a5aa71646bedda74b2dbb87b0bd5c4c6946a52eaa131de453fd0aa1fd1b24e08acf5310782d30b3e4fa09139ee87edeabfe30ffb034cd499b03d38f36a037de9747773ce0768f63c53aa747867b857536d4e6c1307c3f2e4306ed8a424093aa10f605a350203cca4fb1800c1630eb19612771e539ae634d2e61b23f22b85811f8fec2e7abfaed04e2a537f350b4dfdc8eed0cec0c9a8e6d239a3b1da5a7d92a286321f403a7cd09963d81cea6cb79720a8056a282224d6a301c428fb92300ee31d6b8cc6711f67163390d9f1d06e3b46c9e0df721c347239484260b45bed89873fb643455bd5c88804334226cf958e5cd93fe057af1140fea0efba93d0d425c23a7cd4e517d4d98ba4e56e70e72b316c05f118c5b8dc5e3fe04935cffd81cb76b9770df6fb06a6f39ce27f5e624f7eff5db3a9c38f151005266ab2ebe5d714582be0cb3ae3b2224b09308fd43a0a36929bdefa7d7369c51827004c52ba60f72682cb78a186ffdc3598ed113719908e2637af91b7dcb2eb9ef16ebb1f9ea219f4467750394b4a0e50073305bf3e8e57ee202fe3e962234fbf766c77a3992169e83a0ccad44b7257759d75453655e1c51247ce7062b54c178ed0bc84eb8c58ac386f3af30f19d00e57181a5728579991efa8e330a590c8c9b172090fe0e486658d503b0ce31db582cd738bf9a6015d1f5b234329ffbbeea4a0b8b52fc1743555cd8b5cfc508410606657bbc44b7dfacdad349f9d353a507e5aef063cb99f6932f5099d21bb5dcf01415ab731a60caecaaaa55c9d579ec841fee464f54dda73347df358a87763303a549e85b5ded270fce1b3b346f5270c7696f59dce61e034b1aa61b6c7f08e318dd84297974fd234131714ff78d355e3482a6dcc9feac05d1c884739da53d0138a75d9933ba0a13c7b0241f8bf9a2e323d0bb12ddf03999cf5d7f6978aff3e5fffed2db5646a8dbf5c4f6452dc815f64cf5424cab5ce961b6f29304697aaebb974b3d3aa7e502f1813d2e6e999ecc3f61cb5b110ef3af2719cfc5aaa248b0444e6bce27fd84a610f3a0fd31f421c24a67632c9b8519bc119532b19475e2dea02e76c6b7bd230b26ff1f7c8f66251a7fe5a89e65ef44de49e945dd472d213f9a49d935e59347fcf1eec2db5f7c037d4aca5c8075c084ef3b45544700dcc58fb6d7072d1209f604e889cdc7c79962ece721078a3e0b9dfa02fd24235f1c0e23a8f0bdec8871981f221da5da76f443aa31561eee943d830677b9d3ce56d9bcd767a869a553669999c08505e5a3af158ee72b1965c9110cb261d0388aac6a79203c2d3aea553700dede990f7aad11addfe23bab7cb3e48b9247bb14f6900d4c08980f2ea1d1785e2cefd6f4d4be48c8b3ba792bb6d9097f4a1cd51edf5cd154ccfb4086b33c77a0328cffd8fc98d51c594cebe9d57a0d0ce73a25a9fdb4b8f189f2c117c90f57a55078adaccde170fb7fff8575f7f971feb1b5c4e4b54fa221d2fc55bfb3a94985b7e89d3431a4090047c9230d3e7c6441bdeed815077a16e8e2373179b37af857adde7b71432141ba207f15eb07dd74d92d68bc2bbdf4f560ac7aef1f8a1b04059f7a52b6d16864e3d097718f480beb1bbf2203faf9d44e7c5fdd449a77a0d407e776650a928463f45c7ee69ccc28c2e6f48a91e36e3ac62a53000e87c012ce803d378653eebae83b4c523336f22aa463de797ee1b668c754276ea2cbe09ef33f429c701c4cb2f36c69519b491197811e99c9365506bae9a74dba1478b5921bac007fb0c4f6dc7770d1d3d0e9592f03fcbaf318cc4bbd1cbf1a95074f0e65b95f3a908b2907b174689d6c912b2db653f311d2691fc21f7e99ed1364b204a7413ba4bcc43c8438cfa8b01e674565e7f1d8e26254ca1c3594d42d7621185386afc7126138c81d7795bb4294151da82aeb243cf3b8a021d7ef17a0a147d83d1a8a7b8beead00eec182ddbb49fc737d58bd6797986a83d891f186a6efd95e3af7263f5da6ab0b409827c33be1aa6d2bf71be4fe3749e037f4469059930c421bf2af113dccde776c991e1078d4a61e9148fdadeddb8827dfba46d23d3d8db6af79ef6cbf73cc110f46a5b380ee440414c99e403eaf787daaf4bafb02b43e92fda42a80549a34db5fed74e2d98c2d5041a4ce8f8c24463b55487c0e5a7a00a025c05a0e01c349d79ad978f41e1fdfce177a9092821eaa3368327ca6c5b9f6e7be27507b0026f7a46998a5ad0ef38a9d04c4a47426946996b6d970474293e49ba7df6cd65d47ac509c328254112af4087d76dd1eedda98b20da42dcc4f7319cac4a42f41eab034e2f2771bee49a469c95f226b453a39ba793e6d819bcb4baeffb99d4707c000883bfd9cf39098d9904d817c29959769e983832bde890e976bd754303532ea66873499f1edf758cf16be2266558a6a4a4eab0bccbe2d9ab3f975e59463806869ed7de1be97ff1278894244f083133c5d2571e5657e6cd4fed0473cd7f675d1eece58f208c313d6b1b64d38f48b8cf85dd0ef21de9de47c3dce560c8fef233222e8ad4f09c0d433cd16a8fdd34d8a14a42867688fe255508f3db5ccb7b9c33d5a05c027fab248cf2629d09222b1d5e9c86d69b20774abc1acdb5088347bc07f924a98a60eaa8efdfc9ba44fec6dc8d4a27fd2f58e7f8fd1dfc80b6e04e60c737b51158f0ac4be4253ec2a4864f6d07264520ca486670952d0d491e7691949cfb5c691ab450ad78648b59099ed5c7b93ff7dddab865dcd325cc6a3e11cb090664aef36520d91ac1ea92356d49d41670da3dd15dcd479984fd6ecc88f8483019109162a9de41c3fa2b75919be5714984f12db7bb0a02cc8897de3668473e398483a60c7772078ae41b2ca586a2fddf7fd80a221f72c86d04eda1776a67775eb8f70441588729dbd651b1212ebc9c97bf183d7f6836a573a6a30342d09277e516090d62cff13884d46c29f1bbe9298cf0f992346d0d775437fce33c04e56195df629e38203f721120d962ab4a9f8e980e3d365686b30236324f34bd0867f0da232d2400232e39ba5e9a7f321c055334e121d638a83abae0edefaf180561d1e9406d69fa5b5ed5e770f924c151cdd750404a219a35efb8095c7f2e48daca17311a83b9d41965151e24838b6a539557c239b85ee8d8a583c03100ccc550709f7f3d0bb7452c97c430abe1a93220579088e89d13fd8bc02302d9d45397cd90416a01ec151585dbed83d87b266ad3333f293abebba1ac94eeeeda1f3421a30abe277684b161b14ba61c1550035ef22ecbb5043b1bf8ff528723ebe7f842851c9190b092c3446fe93ac0272ca985184c90e784aeb46d72f33e45d5fce010b06c65f5a97e580030564c0d4fc7fa8dfd09fe63e5154e7d45fffc54ef7e63853283feb99f0ca5d165aad704aef0c4c2651a7459d8dd9c49da6f331bf5cc690cd8a89bd5d514dba2e4c1d916b089781ee544762ff908720f1164046627902c46e16ff2ea8ea7d80d83e38161e7bab8d7067796240aa23bf4870a7b5048fcef7ccfa34589f0c82adbbf7dafe9765e961f9b3a5e09283d29340f37ef693a067717b2e5d6ff6d45fff12ecf10cb6f2804e48605f3e6e839748ba5ecc723256318862dea87989a9ec0f1bba0c4dc28d9f554ee2568880ed64a342c6a7b140a54ddbc41338c0aec451b72efeffbc2c1745b2d2621b0e83e0ae8087b654bf36d2e8415f829fd96910a38a9ce23295419162443e131ae8ad2ac296bb122aadb0f02463ed8b8d035665c119f18ef2dd8b64681fb53a9fab6c2c2cf1fe4563129f2e83d7301f46b97fa1f467b423317917a1d15a9e54428389b6bf2ed12bbead67b05f2fc143e608510e5cde5a420e7e738433b61ba14ad29810e00c71cbd23c529401b02f7215770c28fb0f8c69094f2a02c35fac37a1dd8a8c0490b355efbc4434f6420311626b88a4870f2b2b0424a6aa743b70444b271001ab34c814583c658ae476667217cbe36ab70f635eaba807b029b5bc71fec7cd91292e337eb2520c2aba89d3b8a838254a850e6393ce65c951f8f65a5129ac2a430ba6ff338b7298221b19c6d4ada34544d5207de5a9ea5a79c65a0ccd4a75778b6d36f0c826724b54bb2ecfc96845d5d3bd938e839d8de3688c1c21276e5d2317eec5ce6ea818758e83426b6a47f494dafee77e32c4e05068066b76e616ac9ca32f4022753a5806556d0fd6d0eca107dbcd677cd71eeae1ea5b00abb24ebd4237a56ac1ca505433eece1dd39b52bac0311ca8d5aba2f1ee7b52d502645aa00f28788023e0d3adb6bb31953ba402293e5dbafb0a76a045df237bb05873cda58dba012c15db8204aefadf6c4f790f263d49a588aba6eaefd3d8bd73e81055d32e7953c9d7e05894afd0e732204975e4c0f20e799f7f83bccd98955ecfab295d53ca7a29fabccec3798bbbf93a3a3e43041cdc4a55ec34292927784eb45bc720f80de4f630c34f1a9a789f2811b5f2a0d4703533e1998a15eb8faba06e7ca61c9e91aeddbd68f0499616ef43087e212be362fe182f28c97ec5530a7ceb2d31d484585604eb19e7df0089dbc63e1f20cf107e2105dc56c669ecf7df7c76647300b340738361eeb443e676a8a9fd015f99a7940df593c6fe2c751472497c33bbaea56b71699cb4e210eecb4e01e5b664811ae1dc1ac88f271ecf4ead413c1bb686a9b5b3642197c04ac64f064ed931e61d58164f3697736198de31ac2cc719d566b15f4f9760b29c4ee069d2f638cfbcef309e475fd0b4e99ef39db4f052c60dd6bff9d9ac1b95d68b7dbed6f8f0637ab476764e8bf6648c54b044aa28daeb5f47ef6ad026e10f3ad73ad3b4f1b8d75f948c89834419128c42cbd82eaa3bb1f86771304d16ec41d50d3f3f816746b28432e36249092768d242a3b7e93c2c0adc38e13b717999a840da6f5e15d4b8849aeed9c4ce2a48381cc44a449365f47ca0c8153db7434af383ef421e3168d64bc54ab2d9248330d275590dd5c28b70d1109df0805646b918c7877cda5ed50977408de7ed69696e023894ab1d471cd414fb6709a572dae1257021c0039c48a34e61e500614721272b63509ebbd92db75d61a59e4f1b1a15e3283dfa743f8436d4e956244e4cdc9303bacec87a35eb58debe48739cf08d90961cd71bb2fa0336353bc76c499fee715179e17693e042f87117c0c04a758aa958ba25830617fa467fabf7e20e9d8ab568759b8bd947ac4c70beb60d3a354d066532adbd8217c704a895359f15a52cb7d63757bb260738bc13420d9520bfc4245f337a7a4827eaeba8c63b969371042d2eb07c64d5e5ba27640511cbeac9e8efc3242ed2c6cff72c04f43885b38e8760aea01bc52efb8637d50e698566cc69f54b0174c2c942d0d37d509d3fae7a5e409474a9132fccb86eb38e5e5fdd73e18a07b23255a8b9e5ea64c6257cb006eec44a76f6ab48bba1ea6fd53d97de37d58b12e6276d505ee36357cf4eebd52b0afb18ffadde88ecdbed277caf99d95fc148e210bad7945b14c29c4d1f4f6c4df43e2dfdee0a4bae16e2f11b5b6afb509bbc6bbcec276ba286325f7cacc465e0b4e074de987b2d6fdc11c684817730b999bac7d1fdecce2c48be2b4d1d26e66f6e0387d1ac262da1e404081fb6869f45a80f1e9a05e478544c2da0da35144bfbbfeaac6c7b93d226195b495c81769449ad210b5452ad36588b7f61d8be95aa13722004e9a820cd7ef84be5883de33f9a07283c337c34f8407ff7a3c99ffa6d3f6d790ac3d7ee9cb3c4cf617365efccc6ba470e64a09a9af28bb34153c35c9ab26e3d8dfd141edbe8cb8ae3d5482013c09cc747a4fba2a548eb93bce86cd2bd4e7b99adca664692c292f327381fcb26407d84be8b1b3b26b54ddf4d4a8a9c3b2572466a572f2cd9af4c0ed0cc9246075b3957dc6b794a1f18522816e084001231515285ebd4472a361726142ddb68680d6574fb701a2b842c1bb2bb2ae596063be566445296093e512b98d40ee694d25b72d2cbdce5cae0a9023fff70caf4dc5e4833e1a0187e1735157eaacb745940f219a1de0c9e8ae8151110e716db40acf5dfd40862be379cc3efc423801b2c5ec9c2f6d3a3b4c9d600b4e75339887bcd762aa78a6b47185d1bcc4cdaef4c070384177426e8c405d96046c81c9d5150424496885ceb9e0dad44cae9abd5f55f66a41b18fc60e4d2b01c62166004e047a3c11d7e584c989c3318489440575c096434b4288f6af3df19aca3414f661b136884a7ee9afd1029b728df7c261e7e9f5c0b9e1fefa1ed892e9968b70356b99b07e946148cf207c6ef936c92a2740e0dc3e6a21ab7f547f6cfaef16a23dd7e049a0bad897b53ad5ddb647b1259d6b6decb6413c3976067e7c77a6f5e6ffbf95d68007d50d7fd691347050fcb863a903131995e4c05566206096675af6e6c89f491808cfc5c7f3e54f31a7c40e00ced9582222b5d9ac1edd3e58e54b6a8aec17f37a3e7d1528daee1a6c7e46e471f0d5bb80f9a41215044c1074c9f51bb6c73907b9623daf1b1d685f6fa563d765814f542f8a745f0d3076bd03c57f20f16b3950760ae5c3dbf18e53104e62bd9001e652adb9a1341c87205fe071f0ea2acb7680bfbcb05cb770dd6a1a54de5f1519148c92b5354cca87f48365026ba17f1b2ef516dcb89e651e1ec75f17afd4cce6ca860f562f4157a22cb0b7b0837b989296c179e0f58c27558e165074212064740ff4e00f3fd261828f624e68a15d7235ec039d5d5a951b7a543a1bad85e8ff03f09291f19f47ef93ca45b2ed6e321022e40da72cbcad3f6b60b2b5e9e9f666a70d28e6446b472425e997b55aedda4646d5522971b91bb191e6459bf1e81811c58a546d910bb3efe950b632d9da528ad2fa7c355645e72f706b742a07bb5763c3141b69e620b96d20c70bfc0544aa49d32929cdce09f51e965404bb2f9f384e8c5a5e444ec174f3797386bc36dd66f09bffb84c4afb0544a447bf4f71f5c9965a3da4761b96c151b805faf326c97ecfda73d016bacc075288643b3dd9a8acab5b54f6673e1082d181b6ece1a2346db4095dc61c7dd0ff45c69dd9e5c8a417ee903539497fd2f21dff0a4c651d7daa50cc3cc88d2fffb03e278e2a5187d2b82181b87be20c31ae208034d78b6cb29c174aeeb37e26b3dbf2e3b6e442d43dc5e52aef80dcdb7999ec856b7a771a193d2e41519288300684316fc0fe75d472900c4fded94defbe98c1bf7b40dbba116ce2558c83a2781194e37a2877f29511b248e71dacc3ae4df7193ffe19556def75fe299cfebabe8c19835592d8c7ee6a5d01149b2065b9d84c1268f85c975e72803f540203d1698df4e51c0f02966248eb61ce998c604362c616c01b33e0f88dcfeb0c14bfc1e5feb8c4ec155da898e728b262bd407ada43215581ae4648c4d2e1fbc2b1f234505718eabea366d6200b5d3a9bbd9b2544d24dc5d62cd40d7a2cdcd3a8ee42332cf8d213cfbb4b71c27729262a2e87ce1276e3ef4bed787eff51ca35e458d62261c25925f02a59a4c7906b2fc6d3b05aeab96ec4e8da9b624bab647f7f113f9a82b08ba80fbe7c397df10c5cca83cf86ac10615bf9a49ab0dd367681d48ca41dd819a9f80dbee563209f6e65a02ad105dc353ef90ddf5e2eb67e25b9d08dbe8c28ac67de1976737eecca03365b664cbfbe33f81afc67868ba9dd0d0d54e1743de74f110707e00a591c12d77abe2ad5bf9ed4dfe1adb47ac045cc3b8fb030ca7703dabef5a3b8704042438ce27f74b576a181dfa3fe8081772a82a6834be8d0f69ad8868651f20ca2182b0be8bad12a1134c6fd519777f3f47631deffed4fac2cdaa7eab646963e56abaf2aae778f73ceceb6097ae7017ed3ea3302ed424235c9fca7b3028fe15bfe5704b205d403dbb23eba6a5a483b2a233d5cebde1263b25272ecc60569112d25760429d77eac46de613283f41f80af01edae419c8d9cb4632249dc318aa61334b0bcd0e971df68351c863ebc7d9af761a13b5682af9de7cdf794e5efa735abd599578ebfa49e2d847a0016bdff01dac87afec4a2fee059eb9575e706ce2c19a990939ed63846a04e4579a181969857b13e594372386f68387d22b3149e1086a62dbecbf443e2cb113d8b3690f0c51ba7bd6b18647695ce45049512de7f926ee8b05747ad4495b0c6b1b4a521e24fcc304cbd29985838ef380b25455fdf7ed09db5229d9bdb5714dd134bd62c8416f9623f9c397d36e4130ee81c762573df54211b4c33f89436247ae8c70fcfc4e645ddc0d589dc9cd6a0807abe74d2b050a295082fc89a416ffb9fa040af954ea8ffe469651ed502422f1654571b2a0b5c742b162efba06f52a5a3def17d4d58c89c8499e454d246a52bbc12f7bcdc5a8d63ffed0d6e0f960ec0838de2afd804cd52b9ab6370c0cf2c5dacccca3df535b9ddb4fa788bfd185c87f2690efed1ad4408744adfa110f985acf0f8a100f78919683fe7c4ff4d91858bf063deac15d25dd5ae22be57b1035e4a5764728c84f26bfd008e9a03d83ab9b1a3b17ffa46cd250cdc6a260d857e09155ec49b7b1963e2e4d0dcc5a5f49f198bce9e4131778ce12fff1241a3abe902d69e7781d1431b88db12f28cdffcf8d792dd0ae716ce6c2ab6e2ee9029209351bb9c525e7304ad4445e55501779f6cd671e36fb4fb8c90ec7fa0a4d89ee027f8acdc18d889bf8902f759588df44f4288bc285efba4a90d3f37d80d13d9414b84a8c90824181a7a9f1007df7b657a5a544372629f1effeba9d13ddf6a5f721bc2336c7f4b87a08b790457c93d6b9564940c0685f2d4b0958ee0136f8cd1075711f47ce5671d3827901eadafb4b43214aa117f127dd7803fdcaa617c4ab70d4545b27b08dee472473a2c78730d39293afeb023cdbe9e29f61d6bab4ccd2070568a43921cfd4e3b31818f63f38cbd7887453c88a021c4f43b87d893e0ffad98a13ec11fc20fd6649e5c80186ce33544ac8f5780768ee18422b1cc92c230cddfa375e4ab4d7f204eaa0351fa1a26dfdb94ffbe6dad57849188d06afd61b8572be4286b4bc3762867ac6336de1ea91c1bbe124dd4682c5e253452a3ef3fd33438e2040db94a3d9fc769d47a33714cda93e65f1074e49f870d68a19e6308d18b67a2250df1ee7b4d7009738505c4068ba596ab5a3341533ba027b0d78dd94e007f64e556b449eaafa134cb60769ae12dcd5cfe66767c4c84ec3973c5811b549d16467a3ad8def655dd5ee666a73d7441c843ecdd296f22449e99410b384dc47137f19296e4ef7efd430739993ba523b080e8706be05ad386d18795f9d85375dbae71d4a01fe9bf33947163d4a6c27d96ad4e10dde8b56d9ceb7cd1e9d8587389960fc07406d855711aea87a912244b2735969fbd9e5ffab76dd6a6bd4425e46c11838421043954b7e64c6ddee9f303f7ce15d0bf7e503a40ffe912222dce2c8ff732ba55ed428cdf685ffd8163fe008c9af32d1a56c0ef9886c64455ffe63d98852927792fcec7719ddcbf74ae266ef6a6746dca36fc1050035be9b525f45593034d89816507d52111c5b54de504d8aa81add26857576412c400f652c2cc457fd5638547af90abe925939594ab8358b514099fa29eaa0aa4c35c86f4ecfd7ed10496b48e9d6fb1d482317d4a073962c0822d87e41e88b32d92f40d01f016f80f288772dcec8efd4e6616faa0c06e3f04a5d6780bffa26cf01cac2da669e2162bafb230189d2fd5362ad3ec1eadb6902dbfe6706e867e4d2488277d4703b439bb85c3212c46ad2c160c18995dfa47fc592a9fcc04325897a58b2916275da4eaf5f19223762adccf1bd049a15a1472ec3a307e54c674d43d5fecdc058e5437db3cd01cf5d5ccff7236c9fb270dd388ecfd92ea3667762da19b93a91c51a8e5a36dae8d6060c8b7f9793e9cac69b235108ec8f98378a8d2040e92cb444ef40a3343aa45387c4576c2d54dfb9885895b03920b10367da3539d685d43384c05fda4882a763c3de3a3ae51248ca087e23fff36a0eb9cc3ddf2d409b5669ce7201b1f9b3185f7565c1b9cf243b7792ba3bafd90a126bfacaa02cff4ee2c6aa659adbec68af83f1e7ad8bf3d04ff090054c3e7581b33a59133d3c7bf44b1e634e5d04ca4b80482b952a6601a57c3f697bdaad4666c65cf60a015fe63ce955e550beaee0c8d943f260a3feecf794b035d59aef4f630012edfe01de30f8ed5dad4087193c022eb5a58b43d0ead9c86ae9692bbb392988b91ad92f5a1dd4a50294d0a48efb912905ee110870b0eb133f0eec20307db746edfd1fbfdc775ffb7d7d78df8e7f4f2223d27ae2ef3a85ef81bc3a138d6329e0eff5b8683982d968b748cebf5488fe336554d8feb0dc896c1c3129ad5ad7fde4e231aa096fb76afa1a1eae4a7ab2fd82ed4a96c5e3a5666965179cb490b3ebfcefcdf296a527cb502dd18ca16721e75b328d45fc68d3190a69bcbfe5631cb3aaea6fb4c9596646cc9739196881a8491fcb92d00dbf56e810d97213e71f5ea9746dab9c1e84f69aad7cb6500aa80b82d8f0d9c10a778b3135d5436001eac692d74b57fd7a105bbce043076b4e5ac87edd2c74359a18af7ce989ab30348b843bd251bb6835e098ab51da9ce50482abca9e10be915ab48a5a8de873cf375ab7e9ae1a8ecb7dee8a77825abee358b6c2c7e3ff9ddb2bb7485bd9b00a7d7e543b7f371e8a9bfb99cf4df3e1b0ee7c5373b0db9218895cf7f32cca90b528663a7afc439de4f5da57a1f687e43805a1b57772f72ece793c30fec8f6bd065626dfaf1d76c0a35024fe3e469d7ca838970d2258c5661299a452420e3a4eba9dd3faf3d7a48feeaa03405248ed296016fbb23175b575393094adbb2c59e13f70bc244493f8dd2949d6f4375b5fb4f716304f64c614a35065eccd3e7bb646b89d7bd00f00796d7f8fe75d5964d1ff2574883b8c01b00dccb3971d2c62ee0b717a5928bb52a13b51467e51911605fc93be7cd533fd04d74891087e2b55a4bffedc063abc1b1c9472e02f3947109a7ed9289bbaf4c143cbbc1d6b98fbf0e35ea414ec0446fdef7457fd6d06b7d4883f63c1c07855aca9a4c9c4193288d16b6cb5b0d6d7ba86687f2152b4be2a5ce212a7793506f1b75d0e9bf17560e0433ae288e43518321600ccec6107eeb0caf811e5b507b1179fa020941943117887180113adfedcef78bd523ca6b549ae0ca3d82907a6fa661ae9b973034ff4876885b0cbe3373e844a736231b9b1ae92a685bc1ad9b5b6b94f6fd023e96deb773f2f1d0e648d7bf20afefcf2436ecdf379b3579bcd521f315cd0d031a3b4eb5af2279c916436f32a8fe4f29fe51eeff427c12e0f74cff7e26a676d892b995be010bf290ce489da5fc2eebfd909d26af633e66fd8e9e8abad5be376e0603d5a0fa35941ab55e51b8444e8ec990662e40677265ae87ed96afb263809d3c950738a36232ad2d76054f320d993002bf0021a03dc6032d9826515fbc9fe8fcd47590af71380d7ae5a91e1c52be488b0a28445a118b1b6b1d792b40b049575e34594a289fc85f6a4cfa2f11148540b460c92b9efb5579d683d9490b9bdd02ced5f4e7bbd01db94df29e9da6544b3198e6f3dfa718cf1e44ccd9a88eba833875fc2b7cdd135f616b7b5d185321f1d9b5192f78356b99eed9ad6b3fe9bf44711a7769eb29d77ebedc93f8c2a3cfabb65528967c434b27a81375b8c0b9d3a7782cd589a1efae0ae53bb0cbfe9b6b972cc463bc217e5ec333f2897a66036accf4b1aeb10493c3cb7db605bbafc0f2ae2b425ac19b187f6b8be73a91615b9e692b36b42758cd1fec7ecc4c476e2514a726eabc6f0e0bba8179b5850f94aec409667f19e163b084a637e4d58f35dab33e2da0e9a396b5ffa4cac05f190d215c45caa7ee2790dc67f452f3c121dce6a25133a020f3b66924953ed75241869c4e6bc50a83fb3af9a1e8809caa30319d12a16bd691acf0c2ed984852c92855ab78d278b28999ab52335dff01672432188ec4842b336cbf4fa1b14715e593b2dbfe672b88dad44bcd80258912358b72f2650aee6a3d6210bec9da850b1ad99d64ae626fdd93bd7e534241e0ab1915da948bb6c3ef79626c29ab5d2e9a0569e42a0e4e460701984a60c3d20bbf3a0085e8032fe8b21fd75595fde3bf9680a3740339dd7b28fffd11de15768afd998566af6141ded8b5333c7e12e3c1d43471d77be8a19af78e0e8e9694cf56b68e61b30c54ceb90e546749ee05eb08ac78623d129601259d33eb64b45cb609a08c949cc235c9f9e04c57bff33aaa71a5a20900ecf615e13fde93a8375859b412ea8f0c8f38bc258423829c39004c1e85dd77c05425ddafa8041f48ace49c963d4fc0249f1106a54b103ece2bad27f7e630b36603a2982bf59f2585fad9f149034c3898e3db02dd3d82c406de77851c7b340bb9305f9154a3dcaa78c5a27e58b23bb91759634d6be2874105004e48f3a2fa6eb48be18230920f2cdff7bbd31ea585a584403add28bcb7aeb3bf13c230372c73880a3f42881c37a74d852ca192b275bff0bb6bf234c843c717674cd6d711fdb8e8c11924879e88148559171dc4519a3ff408e3e66e04b7d5038faecf1c854503a0e50b688ff0d8fdfb1d64cf602b4688d401abc6e5863ec8702b1358b8b11ed7ee452f9c546df650144038453f3fe65c4559b7833ae3cf84315af0e44386c89ddab1c9aa6cbe4b0d18878092c976853b5e6a764d9cdaa64aca88c479fce8512fe7c595c44dc093b8d773c5193dc1d480b60594d6b021605ec627a7d291558cd3f8c159f624d1802e26ef9bcdca8c4f33966e717f56d92779efa3f8297b7e355e87069fcdc22935e675d7643e27ea8b611f22e2113106704dcc8bd1bfb99278b3509a556a547f36a98d6f293f4121eb0c5d3bd02e3ad213da1aec1a8fc0e3544126b1242b18262ad6367b437e075a6c7874ddcc3ba5c65399ba4b3840b044d4c39c08d59c76a226b7bf107d904c3998003c56cb52cc76128bb8faf4216fde5b26aa76c28aa5e97d3fbee2d7a2a37b9ed5df3e3543b4b3014c7c550dea55cbbf2ff66f96ed31ea58686016cd7fd5f22410e1de55000ee62de1814665beba6822dbafb2e8e190829918a48df49da22bf67dbc66c6b99a128685ee7e948391496d58516f6fc650f1b156b2d8c30bf0dd1dc12cabc1173afd7671b7491f5d2943a6a21c9829aa6d6b18a7d4dee95783dac3c38ac3f9e0752d139ce9dff19a249f4fa90cae68ea5cceeab4aa020206c4599add441af884c20943ea3536c651784c5a006584681d85f9f9adb89601fc696e2ef502857ee5742e931c7b4d85c1dc43d27531a23635bc012a1cdba734e27683bc7edbcae862d49ba4862e5016ef85c3818759eb59bb43eb52db4670a520529a1413b3ab1c1233547e3355ed2e69bb96a2c0b93d83b126573efa1449da834a73dfa55ea0799d2da5e4887ba0943d13bf94cf90373c48bc54b09ddb1950a484a86dab549160463aadaa37f6e0eb0c24bf22cd3356095bb901095ed4833c1ac5aea5b90ec2768e4f40b27b47498b1f7c9c950a180e5c4f3fed94804b554d4de6278d7e2145f711d3e33ac48381aed4aad8e7489395f6d14e997ced67502c35b0c48b39919e3f17b86213837d1e3fd29fe1c1cb0122f4f6ed89adf8a8925ed02899b56ac3ea0103856cc4a7b2bdc1bd0b43b616a78dee348190fdf4743089e40385efe64a5f5cd6fe6d71e1a96f5051145345ea9083c2a9425732ef961498bc11a9cd2ac71e41360fc5fef444c656c8446d203769ded1782d2effa11550094e5923760e74083596287c107fd75db2b606d572e9aca85b9c7c2d7e13ed54952aca59cbd0b08a38ef3c36c25d7a27095eb718d436c8fe634cb4c65be066570fd0ee278d5ddb3408133d735f8aa7913ceadb75ed75dc78ade07134f56f3d76e353e0d7fc559ac53a6326c824ea19f6496ba59a9d5ca9cf94eda8b169e836e9f2ba6ec410c298b5398aef9906b9577ac59fa6a23157fcb73559566713f856198626b4990ca0dd8373c751c78c21bc465d7b386b04ef52bdff3503dc0139086e2584c60332bc35c336b1e42344e36255bd0e8022e796584572e79d6fbec7ef251ad02f85963cf3033e6b330fa80e29e9e8822aafc5937278d6ea5630babf976a8835fe9d287af8bbf2c9a5125cf5bf9a87ecefb6507414be8d63ef1c2a4d8293e0d7fd43f9fe33e37a4ad3425cfd5144b644490da37ad8bd8ac75aaf4496717fa3093c4b37b383425eebbcc01764d11558b87d1eb94940f49f8eff6756f3cf11d21d1bd6732c546288abf0a131820639c2399e3a36b1148038f0534a3815a55e19d72e431af6fd7d793ebf0d430f8ab4c7e7a315fe782e3a45d9a3f5ca01dc471c226011206f090f151e2d1b65d7a72c6b36b21b6628668b8e6a0fa3f7d22d065fa87a5cfd0c57787db8a1248d9128aa5709edf9e86b4f265f82317dec123f4ae2012594a03fdeba8839befc2f08338b62a0997144d3224c3ea87750e7cc8fff35228cdad5538e12b355ae1183845a73b326af450441da6a49afc3b9d786b66c27d7c724bb12febe8805a7e1055696cededf0de4f13abbade807d89c3564be1cfb44ed79cf67eb9d780fcd6a9171bb12312c58c8c23d1e3770d4bb4796625bf63ee9f03823c5a8c24ff743cb342f8ab43876b8876e53c18d7d97498c0a7aae14b4dab2b69d3d8dccbfac62ea54faf791c387808c16e328a41bf527cda6a15e10d8ceb999a843947700a22184e27b3fcbd133cb625d25da7d9a27079c488b52ed194540a51ce5a1f4aa921193f4fa5e0a8613d94e8967ae9c10add3cef2e491cb11c15a71281b7ef9a3569ece277618c1ab0bb0345c7540da42b6b81cdb0feb62512d09edd38838c0c8d2150b955a501bfc5d3362b3a1025c7ed760385f8929ea809d85ae6d69e2525ccd6cd4e922b48e6296777cfcf06a274b0a2c00486cdc66ad72256bc4b0597af9f53f09ff13573426e6e734b3f3523488b492791187c927a3d426a701c50ac8bce3d9b779933652b055b57ece3d65b6980999cd19bd0404ade4ce0784985272192f36196e67fe370bdaf2ab3cd3710a5f4d9088ca6329016130cea319d7fbda73c939020ff21cd333be0b598bbda1b4b9fe07b3b1c687ef27ad15892cda12927a2321bb70c93b35e03141e6825ba2bf18c889b3505e27a8db9822a62bb79dce187d8d4aef7d04b227f228dc577cf7bf071c612380a79785a6ff191b2edba1919baa64c6e74a72e0433bf1411801e0b8ea1955785d6dc70eaceb913b353a952662928bf916c561c6285ea9bca838ff202934815c2b7ede45cae70d039cb0d7a20b0cdc3d9bf3b95ca4325782f8ce37c638c0fcf35fce31c455842bc83d9e054f3950e90c5f602c5854f0341a05a39b59c8eb260c3422a59867c1217f62ac63f9083743daa233266a22cc88b8dfbb67deca12ff3dbeff9c95e944ac7c53f4172fa9194728b40ac45ec61402e00bfc746f063d02e2a68537906806302da858dd0c0f324bfc96c6490536ead8772377fd1f875d6f83f70a70dc407c2aa21d48287d81e6f9158d374df60b7f6072f9c865cb9dda281143028e91e074eafa7e3a8d5bb6042244e358367503bd6ba0258c128462832ab6e30c851fb087a4c9665f02d24280f85821abb493e5dc5aab97feaa93744ca31637dd5691d0bd5fd152a81144d17b7c894a9f7537c2843e1e2e87ba65f6d925e84083143d58a0f33c375dd8ae03f5a8bfba6fd1b8b5f1386454a5c9d540329a77d8cfdeb8605978beca582723be40e4db482dfe2dde98311a1b68e2df72f63741560520c4f8878229375110c3a5a232ff2ce08a616f2bef26821eb6dbbb70a8bd3ddb11fda1bccbe170d397d4f061175f03e059b1e007078b4711387346a596c5ed4f1df807354fcf07b1556df72ce7e832a14cb58be8db59d53ce123f7915a9979db37db7c64b26671e53749753b21ea33679a473bcee9dd99693764adf69540f3df077365a97b7d9e202eccb4183ecd3cb39587a0f26f82c7b3ec41d78773e756c3ab7dfc241bf5f31a3f849b548f4b035a098ff35824a305f1ca02ddb962d305f88f53467e0a2b61222ce6a3425e7740f624d9e441bb8e846f805422b354fa39ab9223bd86e55768920bf24fe50b4d586853a62499c34c72900fcc109d5b7b96c0f87897345b5f9bfe800a665acea30a1bec38402364d94776119f18e4d54088bc807e33e3e0cee20b6ce2358bddcdcb5a82a6e3473806cd46d2418d73c317706e178790ab21f8f1628c65827a3a1052cca997b1d54370ca1d11b0c48547cba2da2003d8f5abb57a8c8d7d9365f617a54e7cc59808d7b836456013acd3621a3040a9b77273c02a3a73d36e312463a698dbfac043b497e61ed13d48a6a353b4a1ca92c7ee24bfd9408177a6ef5e4ab68e9c061371a74e4f744d3854394f8e1a8bc5a937fb3749fd3d874ec2558b541495516872ceba95e245ec1675a0c887c28cddf3c7da6c8394e75c570e1b12ae95c38b671b68923c7842f9ba8d831b814004b0c23df5a86c65a3f6d5ae0626a57e522dd730bc2509a2e4dcdfe5e9ebd894256b1811a72f19953a06bd3df491ada7970ea39e48dee0b50572020a15142267785aa630a9ae9877d4e9943b0a65345b07e9244b39328cb8806eb6505a55350fb302fe17a2b3f71906d4a89ad19cca2206f2a66efe4433ac957ed9ede4f6d3e639411edd82b2f1ee69db364668691c895606353694b9f34c82d363c4f6ef0a9df1b36bc2ea2e353fcdb23491817a7647c34668380448eae464d277fac2841622d0645bffabeb199b6dc031977dc6fdf9661bbff125b8246a794155bc16a50de2c98fc1ebb888afb535bc21438399de0510110da75e5f17f9421a5f1a52e29ccbe70b30c6ac9e3e9e889cf1cc173525a89fb6917f1b0254b5c74cf7acccdaa8703a46de82e9f2bff769ebd8130d47f6d7ec530fc2822e24bdfca3dd22bb10bcee51ed67209dadcc6e63602f47169206104619b6e23c6137864ea0cd26245c49d6f99ce360a74e22e9505850fa65c97262878f18e1d10e2104c87b58cabe90331456d043243082acc27d0e3accb99bf733a4c8ea8e0c5fbf7a23c38fe05063e1f0d52275a09d5ca2d78836cd43f71cd4ed5849a9bf185a613339e34417237cc2d126760d39a5350e59581c0c8c3a1c2637cad16db2b4d34b4c3b00f984d9bf3f7da10e1f5cf1b6c5613d77b5281e925f85b2ada449f7830fd6060d5033ec39610c1275585b1fa511236c492902daece672c45010fbce8df0a15dff2c4a0a243bcae1c3a5abaafcfb1bfdfab6150490cf15f34c82b42419b334ad8df70c5d9466e6ad8fd6f36755ede12eebb9ff2651b593dbd93adb2c1bdfc32e503d82d5a02ce5f078c9874d708b205a4ca6889077b1addedf551054b7e4cda971b45c5a9f0e96983abc261b5fd8847656685450cf6106c6a3a0f510f75083b3af8fbef83962ac8a7f82e24f6ead873c5df8b4e7cc3ae1879febd97a66d3ee5e75722ddebbb5e01c4862f15b5e7a76b08f7955d362243685da3d576394a359a21bb71e70a322a546d17d5a7e7b5e7517b6c6246460406ce8bbbb9d04006fce8579ef57aa6aee4ac4f5748c2c71aa1cc92525b0370122e19add9ca4137b9bb09ea4a3a06abc7df9e956f58fa128b3f9a88e1d6de09579600a2e95d3da8bf9e1de73d05d7f2d56787cec1dd6d198d06e2ae920f2ec0d0f5ca0cf1521743232d16753dc9b6a1c92622cb7748a591c81309a6f67e53874a7ce267d4a6b9e2056a7d20e17fa1dd03500ecfaaaa1bdde2f2353a647136260eaaf5c20443107653e2209728f45c4d8227560f79794a25007e0d039aaff8079e192f315d425090529f6a6d94b8b8765a8265814d4b0abca531ce160e77d0cf6f82cf08527a495a5349a1ae64f7353617ab9318ce6a5ad11d0d47581e8a5a359d508444d7141fa91268478d79e9c8ccfdb7636deb4168810d332e271f40197a583a1d5e032c9613822e68b2249d061849b0a8f643bb776be183b1a07e03086d1552f027ce16fb4193755fdbe0a4387e78be262133c94be06597cb0759c4e2080048314df2dfbc783970187e40b3d34fa24158ad69a3cf2dd7e6887ab36b19227616eccb4115870fec248498280367162754205a7561ba4b50d5d632fefd1525107b0b617e31121f26aa5f64636c399d3553b0c36128ff693eed6592b7a1da0fc180ec8346d82f70e9ac51f05492b1df35b5495250f7ecda3ab0fca9498c78fadfbd0544f44cd0b05bef0d98a1e01fd659b4b0762846105317ce3c28c0dea65c2a1bfb4d5c12a26945d3ef378130c42d4bb7c3585b43d3244d5d2cefb9a3e3feec1d75f73829dafa746d19e2b2b8efafd11b602215a39adaa4ce4911f8fc9948406ae5a624d09154df61f3a3bb2463ef759db4a6a8cf94903e8fa75b6003011e34c05cff26c1f26353e1061f79b5a80844f9343d87986281a9b18f69878547c067f6cc0513f73c7943d5648b8e1ae30a9c6b775e7000337de19082f9bcf3856285bfd40283ab87113f892e9d5e20527f24d021c02f1cba84a7c1bbdd1b0cc9933317a985b803a8c01667994672501b0496097a2c907fa24092247b49f3ac03e21cf53dd0e5e020965657d85d0699255744ae2d9ac90f7dc6ea3bd693a71a8db1a13633028c017a1dc200e30e10c1f456c0cd968f899f0fcdd915c05319c83096c2a7623f8c511c71300dad962fa7a88f5a966156530a35ef9bac2e7ea35827832cefe3cd8b5854db8cae91a39ed66a7ecff8333f3fd7bd6b1c1e7a6add210b5ef8925d6c389e099c31800f8f701660997c8c4e091af1f3a9244abfb4e46fb2d6edbddde36e31a4ff4e8fc71330a816a7a5f30e39d4f7418c3f1f9d1e7e8a2c1ac4faecdfcc689f4168f4a5525a54ea9d2fd091a78e5544c8d51e9fa00d8850f86a6fe2f0c57c936b40b3644771c4f7e99452a9693b50adb70280d5da586f93088b596464430ecbdae3a88be5b8024b2e3b219cdeba7483078612e98b7d3ed689f08315519a7684f2012159a9ec3da2fe53b16e00aba6322f65e0ab7fc94ec34aee27e4e3efc14f30190cb1c2136bbc6a4d73dd9edeef3ed1d599a8b493c249f0b1f6dbfbe427cb374dac674befd2eda2a47dce619d639cd80591a6b144a0a0e1932067c220e6951a3dcd013a020a2eb5a2e6b4fedcf82f65218421151ae0bb71d502a79abcf2550c9c6bd70f2a2e6cc6664c50c3191cdfaed281c4974ba0227c3e3afda38475ca900d27ebbcf825260fa0bc67bf5a0333eebd2ca0664747adeae1c65b60c50e555b4b1d863dd54ba16f9660f421f0bd9af202d5a169d61cc42b9ea0570c360e1e11ccaf1dba8df8bace14592a03937612b04198c06330692f704bb8f3a1583794846af6303483437bda0c0e5253bb8633cb6a67bd4848d92d93700faaba2f8e7ac750c3d9e780c067f1312e5ad8b9af32f57b992c7f9d36c78be252c9e38b91dc26d8949357903b5f95339545c74ccfcfe3cdd64f89375c2e455f2a228c9276c23c2aade63b698160266f522b06328c459c92128f8ffc84ea6d80a26145b70af996ac7dd1fe214b11e7062951c0474c920a936345afeb9c15056c85bea0e9e3ce6cf49372f6c420ef410f559cd1e87383396d5396f96888f6ee1ccb46783636b76ac0b673629e9beffd0975a0389c5c0228541021981df7e3d1e98737004fee1210d34ace0fa7c3cf4915036b1f9e86704248ed687431612c3392945565e21e195efbbce30cb932ec7547e1d183c7874eb1788939185c42ca08aeb68f40aab53109cd19f2b4f8c00ca628972330544721a8edd318b30ed32b3784e4b0adc4a19bc4b50cb36bfcb872620e5aebb58d7edaf931c2b70bac2ca6ad8a19d895cacb698dc61cab42cfc589c2e18461a1d70ca3bc5d19378fd8559feedb9048a0ed9bcb60bcea33aaa90e00417224bc144f595664c06e3682f11e2414734332bc67db68a349ff2b6817c80815f4eeedeb446dea96f17d271176eed702ec3b2def2fca2e6e325cd725a3132ed0a6a6847b86e48bd551791870d13287a1a992e3aefcbf8632e9fda73ad76ca5d0feeb505451a8f8dd4b1ad18bdd4916759ea7c7aa65a72eba6441a223c7c0fc919d5846ddb51e16764f613fc7f8f18aab73a66658d383779d8bfa84d08ff1013771f3710d3fdb0251c6a365ffb26e2988553688c8d41e27d5a5f7d32f4439e3b3225e3f69f071cd842a29b8c8585d57a664fe652e33d48ee4d9f8bb08241e12d44467d58c22d39863c87ef7f1d7073cea0b0e0318b3a541306aafd101004e56ea1fa123eea87f95df566c2157fd2ea578682ef0a4eae365c3332aca864a239c0a93a729ce74be7e9cbd1752cd5895ed7914206c71ec7d0eb7355cbab98765340f7a61bef4b707a9efdb546f0c66aab336db52c3206bd38984297fe6deda04874a2652b0cf7eeae8e7a1db747757718acd0e5dfcc90154b4a22806a01a0644dac8c2ddeddd4284ae891199a13625635514c16103c1e35d9cc2cfa1d54ca87afacc522b4a215f23386d17d3af8a23578f7f0f0bf40a641be9a5ed675d3ba2f36b3a378f23817b663167aefbc247cf74c7ffbc31f781023852e79e18d0c27ee289dca3d231553e41bc8ef23daf8c328bdbe28ba6af5213c71dad25d0ef19828bff13448a86001c2f84414af261c2179015d442cd283543d55b18a2a14a9c4d2d3a26855d7147a9761e56e1adfae56b5621c8d8899e05214525b5beb269fac36138c8a01a6686a451787760caee460d330c67390a5b15ea85f26b71166bbf0dcf91b6271c673387713cfaec04429987aab7154eb264f672111d8222eabd7798da7c04f8a13e9527749c4d88d73c70bbdc8b0c3593efcd0e69e382120bdf7c44259b0ed91bb9206e6ac26e4fa301ae1faee3ab52632924a8138f319f0321e71e17b0ab478609aeec7513dacc434281d8c64ec8f1d5a3e14a5aaf32745503eedea55e2dd834954e8f60d37c9b8debd4af86b2631b68bf328a4b09c26776f44a652cfa0ae9cc423ddfdf7e3e8e548d75abb70be4d1c1bd9052d015669aeefc853e1d46c6ea5a816ab43e47e3353cd2b49635f0507f1218eedf4486c4b5d1dab2051fda35091cd6e62e0ebcd373c73359edb23a7eb81cd3337df9d6affeaad31b17a564468acf5cc4fdb743d7de68c05488d87f92416cae76f162193699f01486d80081031076e5d8bdd8de15548563f037e81604a582c9c9e7d81af3efb7c0e9e87efe28bcae0883aab81385ea17718793a0576c4e3407a442f3e1bf5f67eb1d3468895327d1344f07691049ae8bce78c89b9022e06cca815dc448c084989b3d7e57784e85e4ef52061edbcb31d4e3a09a42fe3cb58a0a00b83e6ed68ea1700d8e76333ce58ab280dc56bd02f28c60d3f2f39632925b49c1d146e56c5ee0d136c0c1c8b37c43604133dc1095bd26da17db306271047f4a3a24b173261078e7e4f6b0677e60e82c93b132876f9ea88507c23593f82a59a4a21aae3933bbc0bff179e771781cd8379d1c6335d2547af1652c6f679b5050421bf79d3455e5fa76dc79af1f6226ac3402c2d9358cb39567f2affef0db4f74765e6e873962a7a1773ebb355dddbf6d60c0610976777de7d9f40b7255833bacae0b2bef0ee2cffa4ebb0791475100f859eb4cdad67342ba47f9ad421647e77909a4555bd6b1f438bc7a986bb3560277f658e1d2bbcc6ae55248588fb5b45b79228ad757027ae98a86ce2b499381e78dccab95577fc84e7de2513ad3a2df373b9f9b0996d0c996328e9d5cf1f003146176ddf4b6f343dc0048e54a34a947ed5467af75f9b0b2b5afe6148246e4b9f6cf155379bcbac79f04b777bfd1c6371611043e04f357b5c6c4adb597ed7381dfd62c2c27e49fd408f80c63cba1158d74e96ee9228242e8d43be1ff7a5a10a26c63f8c8254eecc456109fe643384fb5b9d9984564f9917291935f912e4be57614f61a0e81142a474e7132594bac59b47ada9967fa5bcae0fd4eed8a829f7ff8654f652e37a638cf348a7bb072086df3a7b432d7ececc0162a4a0c97adadca332f0978bc7a65a8b086351ee9a083b76c5826e5de7c07712e43f3b126dbb10e308690a228f01ad4037ebadb4f10691ebbac30eebce97f4adb8870951ed0cdeb48cab6aab38a0bd7d6df8131429dcc899f62cce4633491bd41964ac200625aa5cf758bfd7034fa996252ddd2fa742151870c69fa28ee9ac61b0a83f0a850096ceed4b03a5dbe56ea536b3a9827e065044ab6a95e0bbc016f8bb34fdeaea6a7cb338966326fb5f108517abcfe987efa66599628e27ba0cd67128ddc3261397d224112d04e60f31171624f2b57a5239b495835c2d857ffd9154f2e2124deee4d723bd587f9996002092570f79d2a64c6f2897f231d29654e0f90cf62005c4c33f52689f7717f47dbdca90f5a18c10925ad431dc39ccd949d95365d2cead09e79dcad22392bee093fac4ff0c944d355852550f3704073d5924fc11daeed9badbf3d5c3048e7f85a2b6f48cd8f5c24f48b4ee3c1c9e07fa181077c8e8875e60a618c12ccd4b6504da0380d68e94cafac2dcb6cc6a6d42647c31d7d7023ea4ce0e79d3f3ce818ad6b2203accbe04722f2761b280e482f2290b0f5496a68387b516d86820de9fa1e3812e2df65ebf43573d20f17e8826932417a5a9e136049532b7b33472c5bb0848b8861cd9e1f6b2838267f6bf999dc2138009435714a4c2eb6ee8fe35207aeb1f2e70feed55097af3285e24aff346f00b70e51abd890bc30885421bb605fccca8781954df755271e0387b8bddbd96361241cce71dcada0e438a6f65d09bb29033d6540347b69d057c2affd354a3befa0acd4c23b493057b0b81f298ca5654a226765cd743c49929ec6d265e5204249c86f733a48b052aed8baf618f31f12dfb4d8b9e264f8b41a9affe6087d56e29d0b92ab0ec571d81d1fc719ffee009126dd66673ffe0d1b6dd1e0d555900beb04444db5161915692ba16968e673ae0276dafd8a330db5e1feed968afdb0c1a308b3694d0a84ab4bbab19354cc21b78a24de05c73740147ab00002a97a1f07583be9a072660abfc61414503dd0cf17a39cac5788cda53f8fde476b1e53942973406902009f3ecb75472ced1ff06621c6bc5f8e8a80437340315d351e59ce64d96d5efd2b0f88cc35636b33a20a83307c6956ab26325aedc88742970d8d93bcecaf354fb2576c205ffb6004c854365079a806b51f7ffafa3206874b5a3f22b8e014aa463352e2b4a988a7e095bea7699a4f9a337ced84611890c6667b715014c449d70e291eaf4a7f80ce835e6184127f29b1c75859991c60f2d4e061af85ed1b9cba022eccc50c3bb030b7922f63167aacc685f27c2606e688bd8e483934bb37b00787ff3efa9bff679255c3a6c5fd6e9a02fbfc5f719a01ae5034787a1e9fca911fcc4517e29b1636850197b3ab8f93bd52f0e0a83c1f8cb432ce7a2245d2fac25fc7fcc14c07ae876321860e1ae44db517c5d6b3245195e38ca1bfbd60cb2f44dce8f112e5831e7399a95971dbd2fd09ca565cd503b59854b74135e9e4bd5482ad0d672a61ca391bd30666433150ae837ba2b2b6f2d8b203145c3adc1a4a0970f51f420acfa989993ebf283b619b941e7eab6e1185cce8682bf8b0be49e2bf8b111fb703b560bc22a6b81ab9d69b2e7763c630b76de19cb5accec344c913a96f9d3d0d77f1beff0b45265b369c17f70b47ff5a729132e355eaf46527709d1afb37e7f920d740edced597adecc3ce84f80d0c03ecb4570789ee7515ba83fb47db97d0289f10dbeedb83a0e25fb9a706d3c719b991589936ed001200f874f4183ff2855d7ee20c3213b9206b31dbcd843aee61658365b95799bb557dd1582ebb51675bcaccf242ff143493d35ff71a7f7e4d4ff920fd09984d0d0747f0189f225f51e204b38faec62b7cda3c44633673d3ff646691ea5bfaadc0a3e656f167534bde2230b1f7744b0145da698a1caa2a14c4075d88e2f84054371b14fdf2835e9c9f9f71d03ec8207370a5bf7e85f79305dfbc93ffb5f58792ee6811259e410e98eec7d84468d96ff6f95f3e32a7bbef198688975d3ce9c595d7133f574702386e1f43f9159a6d19983a5d205dfabab3e61323498440754f2de8bb9b8b668d50990bef1bdbf41a91c886b2c4c9f704a85334620ff50b4093af28d1fac0fbbd31b53927a174eb9d6495aec028efed7e7c81a5a1fd65aa654a794c5d0f2e4ac1658acd3d7ac765c2d29f5713a87ab33d43b0f5c6b4479d98d54feea7b22460f4bc0f76d5b797ed45de0077c4ff404a5215b89d0e4af1ebf3a97587bb1206faa024008069dbfd68536ae827b037e67b46b2e0c68b89513009edb115a4f6e1ba9d830e1d3c22fa80428b641e65df67acbf2c6cf45820ce37769d200dcded0b5bd0b4357e1b6fb3383b3a4400eeaebe8bf2b183bab47d533b874f3702c7d50f42ccda2a711abbb6ba84256f19aa40d8459b6c44646a8f494c59aa64775b750cfe7d63c7fcfd772a130e69bddefd47f5d96d064a47474031fd64bc1534e9a6db6e5ad11fd74281da500a9b564c6e33105c9f18fcb2fff53687a8658644944227098518b78655285ca2f69d9d67918eb0bf24c5c0fdf5c1a121bbbd69833ca12da61e9edc7ee596f557429b1aa4aeb6ca6232ed141aaa6793c1d9bfd46c414de410a2ec06d3c203df9804c79b855e8b4a7658953bd539a261ccbffda3438c872ce0d8c0228da84b11abf45925ebba47ba858722225ec1b589a20d60cb2ff79c568db9a22c7bf178a0dd651a1128454cdea93745bda5090b28d4040dbb90e99b2ab28b63ba812270811c803dcbb0f0dcb27be4d07c80c268de0e27d9ac95421d9e294e7c5573494d57472e5f0cf8881c318e8e5f6ddd6402bc98b43636ff6aeb60373552c89c4ce7fc36bd234180c446401316d9d9203f3e895e73d81996be7f0dc4c7027ccd0a4df98ba30de70ab268e871850aae650f03550d3035c6fd7959eadc1972cd679670c036b744dc429a1d92e613c7e95ac76f30099b60e3241282162ec070023f9a4a7bd85225ddc5132408049208f4c3e2b569ecec312130594f1b49985e2093d1dfc6dfc40c84bd3756b139f4b78cbe8b880405500033c9bb557cc59164f99a311fa72738df80e152dd8859058ca1a69d457640d497d30b05db950f40c7816bb6e61f623d4bae59281ffa515c1c7e01734ba6476a249b850600a73c80d9add10ed52e1b20926919b7014f6a2ca80636d1274620d77206ba700e17e6afd72f442b51f90b43083b6f1f2a69cb1a593ec95b64397810c5dfa671cec2290944afd67edcf49f61a1bcbb4a4a3fa7bb2447315abda6b1c7e70e128188a83458e769b25be7efec5e475d66cb227db5ee45b7e46a43f250885fa5c7725a6f7318df5df461988952d79d688072af0431e140d90cbf4e057a30c4cb5646149f4e0a18a0094e0c9411e5af39d063c471b4e8c74ba641d034342de8c1cb4790d52d39d1550fc754e8d7dc44d3f710509b5b030886186d72aabd398b719cd9b766cf179cb97159831d0bb17bf5cd6d711ee4b2a8b163590f84fb080d9b4ad78a045b05a8d9c3132feb7fa8d54043a9cca565689a6f6cdf0a5ecca17bc27da15d847fb91f2a466073c296d32f705d76e7365a61d79b98281687ee2b14949c7abdfbb42c802e4149fb1ebe942c50b1c198cca6c70e9a7c6f52a105640e096dcd966b1e27c4acf171eec8071429af2ce9546b48d2e88cac8499a70ef5c4b3469f397c4391da674174fbea680a1da14c8cfa9b25def06b29c7d9e357c60b209927f575fe1522007ed6ef0e844227cbb129523e188a7a8c032109975d403484a5c54efac2198e8127c8329fb3efa588491da83b5387fa790d31573c212db3c716edb54dae072547c6c3c43821e2965691d9c7cb7e5d171dc67ebf91afbf23b3b933068c193c40afe3cfd5fa24171b3218dbc720cc13088e572c8a57d59dec872eaf32a50b09de9372abd22fb8afeeb133e8b5ddc12ff8843b3f5a03226c34150cf9de19538dafce514351af92089fcfe6a1a582a75b78117de67130e11fbdacfb07281ab5d1404d1c83f88bc03ff895924344dcf1a8fc51a165cf36d696265e53f7d9a3500bf8567708605b01a3c2bf11d7dcdb937c53e17324214c31398c72cf614afe0b6f51f2f252d5923c5ebd562c74dd96479ec70bad0bb1bd52a57086ac2e2ea0f75359881232d365aac8ae3bea4c3a04d2e240642880f495341e5530449720d711ce7d6b6bd248d21dc17fc552725cb75b81d5651ba31c07502c8856a3401cef3132c5e4be058ed6394d8ce6a9b7b6ecba8969522201d075e75bfea0f965ef4837e5dae38f8edd87506f447f239b128a1c3ff87778d571b2b493854cd212cbca01fc7f15460f2dab71f6d67ab96801caee192e3315a946f24fb05ac4e03a49ee27f8e66909734ebee60b71421f7a469dcd836faedfabdee56f1d431738ddda3a3470ca838e1ba8d17c82821ce88eb03d12935037c5e6f30bf3b41243c7884312e6a88cbba7dedbe1a12f60061472afdea1c8ee81439b064a9331a4d2384d32135a831bfe722610c02653a4ffb2815df4f0f24c419cd8fa695555980acedfb69609977d8e8dc1e84da464ff4b26910ea4cbff9aef0452c157ae1f33e3645233a15ff8b5b6b9ddd23344e5898be9f1388e21262eeab01628f74b651b93518ebc27c0b3c7c3315bcda03289874bb7dc6be648d0c677fc61458d04574d193c3da8937dc0199b2eefff21c4e9f67fbebf7dc5aa2549c0d41c64742f19d4049a663a0c8e0f203e8530f82bde440204b38941678aa8f3a05a0f62cf63db803cd1d254824aa700027af74cf6c32b312e8d8895cda9b98b0e9ddfd09cf23cb08be786fa19de4f2e1228b21391cc08a24416f3acb43b3176ea0b93cd1b162da6a0411c791b7865876569d1d8f1f345bd264a32f266c817c39e5c3475489c2e90dbc95967e17faf870dc4cc3ec32d9ece823f288dc4c9b1e34c0702715dea71676d3de8252c7134cc82858cf8a292ca171e30cfbc732bda81b7b742c74d0c7563bcc4ca2974f439b8dea3a53ef9e5e3bb502c5a355323d21cb19825e767929cd05584da0f3d561be79f063533c28cc90b0f72d0333f28a03161028f86fc54e886fc72765cfc00361304f4ec7c9f535e3be57269b0a5bab3126391fa01f0e88141ed906459aa543b765a91c4605d236adb01e3166d3e107cb0c447bdf0c0539d2cdcca6284c148bf018f5fbd415c3e34566a74818de16f230639be7c55a7b2302077e8268373e3dd1345e2a0f7d3ff8201cb5f909c7405395c64968aa5e9d281dda2c8d01f337ef3bd93ec590d75ed7b4978ce6d0ee54cbc17442e409eeed1103858cb65fb4bb5e9a4ed8f8f5e1d7a8ea13784271cc0aeb55d451f5377099a1aa0c9cec308b784d27cd1ef5158b558a3db820b4f252f86784a20e0c9c75550442e39cb5f15e7fd640ef8ca17ef6793aa5da55be1c0460dc0a3143118e0f194b294cf03c1192b4dced96315dc4b0c29c357d5092bf4159187a698281a091b8488a929572807f66424f5825fa00ee6b12bbe2594f698032a3aa825a08547e152e1dd264e02edb0c03c49cc226309e2ad4be50ac83794073d02a828ea71fc76d23d540ca7e3790805e81ee3b70ed5d7a99f54a85e276564fcb8e619182d7d1267a1cb890bb9456194c4854fadef36c79757623dd75001b06df9ebb6752acffc787453ac32c4a5b913e93e3a781a0cee0c99bb01fbf6e328742235dfcd191191f6e5a77fd220f9a7022ca8860d097526b3fde15f20300bc3bb3f138ea5da3220d44be203f3a4711e346362c5b79b077def8a390681c9fa7f1a5205eb18cacaf3b40cfeceb7072e5ff40401fa42946e886f29eeb4c86c6ca4b0a9137b1612eb450bd7ddfdb369e09cf1a0843912899548bc2fd7cabbe395430d06e0df46312dfa5d4023a1bb62d34a2533a91ef1443f085783c2230826474c21cf7b2e983b4a911763e66173d71589bb33120cc7e070f5b00f0318261258a68f833ca45adc76c1433fced4fd3934d48c76f7dfac52754924698216b5e725401deb1e5002232032c079e28876fa3f5535d98df94e94ec2752c17a833fd41366610caf4a8dc910fd601a1275c67c1b73cc842e31b3118884c656305a0f27043fc6b9e64b04d70e1f1fab4c978841aab130c876c35848db7d2ca2d0d7661686e90729cd1c30cb0f7fa128e75c2705f9d6c97c72718a333fede3f44e243a467a3071b0c21d3aa635aab576d260bc2fbc25dc6dd7c35cd56215b88feaaed33789d93e8044c15458b4fd588c453e4bbd0469e0b83512d758205bf34eb9e32ea80f87c2c9e820109edc941fd19f6c26a0f1f7cf0e7ac0995c1f93173c469bef8cf2a64247899d797c8bd5dfe1d67c50c050503af4cb4f88bc57ad976c27ac4fda372c7864d36050b35954dffcd2918c838aa2b7f15b89e4059657ada3310a3e7748080a4eaad32055f00a4a3c67de52145517781c5630b4b5d67b1de100945fd781a00a8bc24be802518fb7fafca1711093a25f52a338db1fd19c6978ebc84196a1cb512658223f0fb50309ae0902ab395f4dd5fb54a06e7b026d0e162c7be060955a9def55d3670d3270b676ff443340d134f4135a192d96d936cc3827f5a881d4a5adb38351c205bc45c8924aeb310054fba199d42084dd8dc2bc716007a03020aa47702f3109ba8053df4e5bb79eddb88e8a2b49008df6f8d77eac5b9f0cda73053d7cd231f3902190493df3a06aba7fb3bdec7277a5dee3182070ff1e7a26c1ea4568251fdfbe1ec07eb62a31e86f5945333f8dfdec9ac5d0313dee0a3a8a28d3f711da6af1586ae16e7193cd518edef6d76025e2f0d993e1f57d06001d29fe5e86b0c0b61e3e01b1583973d6a80c23cd655a220c56a911e39e71e1932fa76e9d9dd5e30ed52533b68768affd7d7d3ac0672303cebfca0f83e80542f94b49fdc436f5ebd4a20f1e83697e93aaeeb8395e4b5c19aec53c9eb5f0476d6fcb52195c5c859a9950a4472812dde845d4f65c21e240b4383fa7141b82dd44f1a6d8c4c12e71e0ed6332df0ff8037e33d5628302ddbb1219be5114d1f72e452fd7141552481c061cf11df92a8aebced49af7ae7cb99854220d96fd0903b14965dddcdf92b6e33242dcf2f4c4430a764b6f075428e914d52dc27a1fb6e92fc4182d7ab41562892d962cda9f69af984b2e1e23c188955d9597a2af1a3de5ed2a7e8e11b7942de6c55c3d534f594791db1c196a1e5c92bedcadf6100d9dbb543895ddff6a4f2cff4f7753fc97e37ffa529e864910d45264ff18626b7fd75d157c12d9782f6cea6ccfca805920bc78dc6a470b0fb8cdcca18a38700ac8cb1d7023ae5deb489da4a79446b70051dffe1a38be9390fe8953fbc53d6305975f5e97189707e430c94144952380493ab616ecf1a6ce8a0c8f4ac56d5af935aa7641e406c97c8052e90bfd4d6f8741cee720afc04e9515cc0b2167d4443ea309c41c6c72a39455edea60277477531ac3b32ffa2cd6c2a7cd3681fbfdebe7ca430b16545135fdf427602da8c15b4de30af940f07158b79306e610b9a60936803228780a2691b4d5ca37d43e6b66fd9633598d7fbc21333179ed872c02f5badb083844688d056768dc56a9c2093b4dc2e374f7f099006a574678f51734572d01eaccf083f51e0105eb66eebccf5403fc5fd1a97cadd1f7d3fa422d72f177a7d333b5356f13352429d9281d3bc5509a915e499646cfa00d5ec09fce676b3f04b01e3ee954f51ec4ba0761a0d724d3642ee2ec92d7e695a537869f816f8e5b701b5121309b3c6bdf53c8fbe5e47f4f9433aaf3f694aca1bf0e55316a799416c42f1274d544b1857d892c078efd55018ff50f61be57e606ca5e62c4e9053944b54812a50429cf0e81a71c96d1c8046baa1b263e852511ad3dba0f3b34b4493f4147fc2fca47ca91a9f869a984bf1823eec3c3f6421d9d0babda3765c9e8490ba8da3140af40485e978297040615fd04d1b4ab4d25bd8123712f7d545902e387107cb6e6a4ef87ad71743267e33ab0a94b374eb28469955651aab55cf360ac6da6d579a21de6dfb7290741075ba90e41cf2388d4fb0f5919f0c0da2eb389597b5a45e6089b13017510f53c2729c0975d4d813d83263872a3f350436a3cbb7acc52c728cc67135b1e10f721a37fb650034958b129f971e541d570cc2a6292f6b0b0c7317a6c9c1552ae53f7a44e20ba28fc221246c5f02442800bcd4c46de8f0c6dd55a307e96270f914bd3c2800c1e079a3b23e80168c1c1013bd9c04c003beaba1736a279bbd914895f2623c7154e150b72daa7b7b76e59772a3e77c1123d183923bde88b1e1b56bf7be23a287686e216befa122c017b73e5b4c750d46eadbc369cd7437531ca805aa6fbe5c160f9e077c50b93c60e976e77ccca3327cd6d0548d79ae04aa43cedb7f093104c80293012afbcb9076baea73330b69f45317f76ff1cb764e097c21fd56da45b1713ea8b4fda546cefe7adda239d2dfd1dcbe0ee21d97e5ebe2796cfc6a402ea2b1fa3b5eaf15ead1c8f865ef907e989b6177bae9bc5b7d42545a401fc3d37cf7d2c9911bdf8b3cedfe4bcff09bdad38e28553f7cca0c8a8caebf7f232b49397906deada0e532ba6d676e3bfba6041df3d6d60e57fddaa9d35e7af2985931bc91bbd5748c701ccdb1ce4079a9c033d21d966eedb2c174825b9e8f983f92be7109fbe86af91ad79e6ec12a502348eae38a31996cad239aed3f64e99a20645108a9c8f7725a6a32b76cf6cebbdf7a5b86136c6b384876aac3b0cf082da5b5fb8ae03e81d929ccd703c9bfbba96b4733b502f6e0a2631daff332ceb297775ef5bf2d2793593bd0f259ee57e33e645ea2d2d9721302e34e308aa7143ce4ecb23a782af2039436fea25566ac13fd1864e145eb07e45375fc059d3fbe815b5530e0e57a27636cb9160853f64a23c27d7622addb48af0dbb2c14f0e9e941eabedf8dceb183d654fc29e436368698ae094abd1d39be184c9a2f3864d80de2107dc97b685814d699fda7dabfa7dff5f7a929be72040cfd77069ceddb4562ce16cc52ca4922ab9feb12351e63d1b78a9f920d8f0dc452e3fd410935f20717796af63517151c377e4770f212964cce2d29cd491b8f7004b25f4a9aed1afc469a87bdd34219e49cdcd41aa69297dd47839323facd4b156708b0d5f5674326254f32a563ab616d34780ca9b6d7f75b857807849d432f4985f0e97d25ec258b4918e245a237ceef7c432415517c4ab710a6e067d5f7b0fdaedd9ac17fa7938be821653d44728320c3f2f9ab81c1bede384974cb0e23fd47d8934025aacdd7feb737cb2b669a74745d60621385a1061bae543310ecdc407710ca235a58deb3cf5b98c32c0b08c64bb016315941060645d7fa2b7cc133e9ba9d62c6c5df39a4533b5cad6126285d6a9fca69955359bd764d824e7d8ec1fdd8322d0bbd804f1d720106e628fd0b07911e3fafe9565c5a4a475fcca994896c654cfd17ab06719ef36a2ed6cf58c0e95891a40db6df0f806139fdfb9944c3a38c1e953d582b9ae334aec86f1761cf84182c2dbf8b2f32d0ed24d8ea1d056452fd1477d60ab7dea8161a303ef9bf2c5f015b10901c3128a4ca31b17f304ca71ca80f787f92372e2b508927eed6cc993b22aa8610f9d117d7a5075424b56ecff6cbc7e36bace86a9b734acf5be5247216e0ba53c8ab4f5f2dc535c777844d49378c05ec403f1d3c41138e67d87499bc6eef78d7aab26cde1db68c654b384b4c23018ce166a1912b32d6f6152bb584e98b24bb1cad83e4bada8a1f1ebcde2dadb69d1ea131342a68654b6952489ac4c0698a0ee3ffab1a17ade92d0cf59e7c873bd2a546a4adebb43326f542d3008fbac94d1f394c2a981784ec48cf289630894bb7ef38356eec2f74264a7898df87493e87584362c97b66560bd9770fec0470f5a7929b7c891be57e2d7eb79615e928ebe6d9bd75fe823837700e5450f68e8da7d6c9d27a5c2d26382a6ebedb7400540aab40284b0edae69f6db2afbfb1c6dcd3b950b716840333b1382fb10604a2dac2a48ff12e86dc3b7c743dcf435e3db687b633e53e996d4fa6669963e9d1c5fa6c8e368f0cf6f9e930b26b46972eca255ef4487525756eee048114a785e4738d12aefb567add96d737ec8414857c2e4c4d15775941fa37d830a38058dd440ddee07169b1b98226e4226ab638932d0d7100df3642af737a81a0469948a6d2ce19b09a8ed58ce7157afb29420d2b7817c627bf2a7e0527d6f780ecb2ba9b1c5e709e1d462cad61b45365fa0b12598be7fb53b262b92d023dd1cd45423f038c1528174eee0174c1cd5399f57d4c70d51a2265ace548ddae9753773c7e74bbede677e35a2dfa5b7996fa92d5ef650ee5f9c00d2088afb54778de316092ab351bb832b597367716008d63dd0b8a41c56c889cf8601de99ddb761a7557dab10965f33927b8ebcc7d12548fb6bd0dd7188b9ad86a8553c327a62ad352cf37d4fa8eeea4f4c5c935579417f1338bfecaee01f4162a3d902002e6cd42d2264022179242ff8ee90bdfa192c41af82b05bbac2be5686bfdcf7578644a61cbde996f03c5b049da680e0b86df9cbe1beb6f37a2231a13f2bb96129974eea7f936c5ddcc79380f308fd00a75a3419703b1d01b7520cb483b5d914070b1a82de1e1d7fc81757e5ff3b73c7c10775b43396d475d1f80a0928ed2144e9e8749a1d082f53aa31a78748a2ef34eed1c28be4797d18ec292f49697bb29b98c72ca8c0da8780fb9b584a85543308adf7e8eb7c4521f46c90190f1af09cfd9753ef506bd5f1bed690f42b4b77a1f7362b0c473c86bf24d819d52a5437e8740ae0b44c9ea3252f0ed3ffc5dc73c220bb902cdf52ab947d921de0fc847999be2987fbe29505d13b33870b910ab1c7e271a4d78b090c06f36951cf9809fc3f034cbfbc468f8b218d8bcfc67ed5a30b7ce0f0824d69cd18e17f2ae4c290432be91e598fe01f3786528a192581c71ce0281bb96cc5289e102a3ce26b37467834d3c859f22da24fcdba2d7da6a2a11076d4d8a06b8663a79cc6a82cca32a440048b7846853365ea30344a35305813fe75936d3dda9af7319a8fa872c87dac0da65007fc6ef1ffb3ffd91714da643d7ea6c534c0f401b078d0562e55a98aeecfbfc7e0d8b3c22e3c7136d3d0e37d85d2969cb68bf2323876be7d24afd6becd939a8fda2f424f5da8d80af94cb138a4f4d5cb57547f20ea14196fc31a38dc60362fb13b91ff94b8adb3540722318871187c76dc3ec50fc90afd4685816a8549acc42d35e66afbbdc66e9c0308c3552516cc85fc41b83dc44dfc57cfd4b3deb9c0810ae8e2034556949080f9da02ca086d0ba22f7896fda3cf0400fb4f5dc11a43187345040acdfcf24a9b72a278d8cad1edc35fe53f11f0d801a830ff9c8f561d9dcecaf7863da9627af7de2cb552cd3eb5aade5fded1526c26110913fb59b3a332a692d14a38d07c388a7909f8ffc48d923b28f94f0871b29549b66accbdd6a4578dd6022e60f955b405bc359552611c95448deac2b3619baefa6f116bd6f19f15f1f97079f49b7e67b3263aa09b351b5b19333d96669b129ec80912ccb989c89d9ea749e237f3763695befae0dbc9b6c9829f8ad0db1cd6228ffe1b418fbf6792c92f45f7b17360f98989548410a35038ba1fafd4914c51a3d5dddb2ebd6e2ac1e0027cb545347b39ddcb3984b712e118ed4db80b7ea2f293a76b3efc8ac5f33441e2466d3a88ae1872fd1800156b3a1bdbee6fe0f0168b868ba3f5764b52f80755e8265df3c55569dd467ef520dc33880b2122754997a7be4cf98844e0f1d47f4401dece01680388c66408072cd24f7c9d68b8982d5d1c0b1305b4af8f49b3a7a315499e05d39ea72266446fd82988a9c0395f11447b8f89c514888afae1726723299b89e53e2092c212baeafed02bb67bd14b8618a663d8dde46c9bcc3c4a76a7af52c55cbbb22df4ab687984e22c3a3a25c67142362d9d9738979eeb9738004f3a2f4eb8a81dd20a3eccf23afc88ef48288b3799053aa43a0da78c6a71bbda67788fb2ac26dfeb4d8889802c98f2da482bd23b1cb908674701193bbfae286e67710aef5a9fb9a5dd576e0d6821788bbe1b4ecd6c30ef7349aaafd7d7dc7ded9e53f37e9c50246ea947a7151456d7dd0ebd0f29e0861bc09e0700db79f2ff1cb2c909b025fdc75d5f93dfd84b75061e998317fa9838ff7eee1f72ca943a52d036ef87a378fa2e2a8c68146a5bd8e214a0daf3be64b5264d79ca5f23d6115bcd830796f95b833a45e5200a0e3b7650baa35fb6d2599675c627ffb676655570d05a4b83ecdbd2472444f4d22c6b978718d7a07256c0383a2fa9baf99f604ad262f041036f47ad2ea9ff9e580023b851c69f6c27b1da42015082c58179d8ad5718efb22a8f54afad77639520be9a664fc1c07f416f828a9677e60f11dcf20b25683f43ee96df49891352124f2849e512d6c71ebadaca6ee33ee9c6c103c4a4cc5ab55094d2e7a8317c49fef146c52df16146519b88fd1a7261c6e02baedcf4710a076837e65e03f16eaf28c4aa515b44847030d024577dbe83b9038a0ce41eef0f28b15dd919b0449d792f88b89493393d96f58e61f313f5273c85640877f7e8960538a7012a3bbe7432cd3be364626ed1f325af1c3b1971e76f2c2ccc733cf1de17805bff4c268186997c3f9ac7e6b773514d8d442f5f979f9297e6f06778e4def21f5a7a476dfbfb57f821cfb7601daf11a0e127bc1593f6c086b12e09460e77e66837126b612a97bbaa2de0876bea598e2ad37469528a4a9812ee686c6bad8a3a0691ebebd192231a5cdcf37e85fab10219cc0ac0cfc5abe6fedc1641bcb8200aa9644e990986014d693cf6e8e35394ff728dca0da8cca9cd8d309f93910df1f8ad2d7f81fd8131f2b67b14d83a5c15c505eb5348bae8b2ff2ffdc32e14f48b7e1179a2acf016e22fbcab5f5489981809ec32d17c8a7bd70cca43e9d3ca8d455c48427a60a8aec56f93239857d91c130aef68f86f460c4ca60c41f765e85a5c5fde044b911b49462f4381cceff77333932bfa68a553878eca298a29be9209a510854ba92c26f87eb5ee0029d4cd491880a26b00905d1b18e844d733344d46a1a9965d4618ab3cc41aec4c60edacd694c3d956aae213df32d81c83cf41a1ea5e00437d6720ea0fbef8fc4d4bedb5dc8444cdded8231ea96b066449528520dd86d0bd7b485a102271fb50fbe7c9506f37cb0bf8d4bfcca5d851a3ce913a6dec0a76703af7ca811a1d380c21252bec8af832fc624086c1bd959229e2f5300685b61937aba2c1a3eb989b1154f3eef3fff9c0617ca866c91b6886f7f645002ff36ea51907ebcb8c543c4e2c641280df5266bb4e592bc07200d7defcd9cd532917c236e41aa79f3fcc5c0baebed0571b89a75371e3ddf6ce206e4d26a748215faa479b512044c3e1683747dfd77ed2df76dc889ab82c96e72c1f7e77225636d28d7b8aa45bfb117f3f8193f5d77541f4f585767eeb8930186138874d1f9e1aff763a4f423b22d3751d63388a2a6f6cab1a9b945c9fcebad50115073fc8074ba4100ef39577b8b7a5a5daa9b210a48fc3571f9993bab9eeca1472c34155f89aeaaaf4f2ede313f60c65b57c1874b89e00203e8013c6d29df25604489a9cc19d33bfae7fe829f363b65920696a715f6724a098cda4b15133103a30366b4f946f51fe6288a72b23d6e19b3331d21b2b9226149b06da6a84c3940454d3ba9de9f1bf22f332434e539ab142964827cb0fad6bd213376cb4d84c29859072b41b61dc37b386f8f24633738f763a27d0391b4537a9ddedb9bc871300519697516db339db9f08dda0d24bc6bcf17bbd28ea80aaec6de4969345bd3fe2e653e970b2b79b64d558efcd83a943d7784fbde77ce13bee6b3eb926a8afde289f6f11bd90c2b5ec029452d6c981b74ff309358d0fef3529c5f2511c16b489c6056ddd00bb942a49302cd5848b4e288a17eaec8dfc275c5041c635a2c8ff39de39877e2134ffcda52a15d4264f6c52d1c4b15970fe6df7db04d3384ef4eaef794b930e0859db839f0ab6f509114887431a527719005fdbbd266667bc887396a7af1a426cd0650399773239b2e957198c2c08a71c954e046821c5410d975ee3f7c9cda38c67b99ca35b462ef47ecb947a8bd6da6a378ba1b078e05586ff997c783a9393315e3e30e3576f25c11bdb2f5879b1d41b127accd9c5e0e7b3ceab5e34afd4bd173781fa814667ca0a45b1ec82b6bce4b66ee1cda917a8c4d28726b7f303d9be6071cb153b73ee8f3cfdf7b11c62b53f34fb198c2adf3e828cb55cfdc32365d908ea8524d71638eb1955ad791d47c47de42b3abf9aa5a939ed08bc30ce5ce6718c8b2722fd10041409d18af87baece6530060f5b4995a0318273dc950fdf5bc550ebb309c338c6548855f7311eee20fae2e86b7d117caf57f62cbb838d4a031be7fe6fe23d13ea79dc0b768416f8c397afbf7044b4767ba792382c7b89bb11d945feec795c65d3795b5f5346f47f5010a4b18d667baf3570f9fe0d4ae93763c23dc4c778a6c547dfcd6da464fc752a5a9587cd2d5e9863b6acb005277c8bffd394ad4068574a27bd73a314c9d6b16d0546435df54ac29fc9453f1cd25a5ff16b45ed4a27b84e9f366e7d6721e2a10ca6157824b9d2bf0831a9cfa6dbdf4bc52b25680888cdf9f116d7f9d5732411c7a953526eedbd5597fc47d478603b2867f527b0b08bba22548350c955e8cf68fd8e10f5ce640127d257c24d27c9db0e4bd6f8e009ea8ea6654b4b01f6af761cfdfdd9d7eca68cfd1e781f71d64fb10a5bc632ff22c02eda556359889f4929930402287c2bcea164e940e04cd1b5d51522b7c0222230121f54fdfdfab03404a215502a2881968a31cf5ed963fe87ab7694ec56afb31781e24bead7a4cbd6581e4857d5737cf95a85e331b6320574b3bca321119ff29c9d4905f20c489f4d55ccdd3f452ffc219a67e26ad3f6905cf4e4a63f16bf613742274359003380a3b9d62ff9f9b8607065b5a91d895b2e5e2922bee2f08a95b6aaf692675d723d9c8f4a7b296e0450f32f39a9c0a3fcccdaccc2cfc78f31fb73e7d44b06462bd98867e63bdf0fec43b09ebd457461299741c041cf8bc23cfb55f37b01e026f56134e0e8055f2caa65f38709a3b6c4119a1f2cf730a2ce641073a81748547f344eea85dae38530a8f2507d1107cf6c59c3c7fd08f9af6800e11ae9e432c8d287667139f55fe05419fb3e5f6d00e9dca6da3aa17de36fd916949f3f5a576c21ed66b449a80fd90654095a5c4c825cf8a993844ad3e409b0daaca72eb470693688621a53ed1ac6f2549e27cbf2493608a0fa0f6a142b67f17c8e4d96ceb29ff54fa051879227312ce916ff8467d2bd2b31e1e20479ccf1c0405c0b382b39120cd55ffda887387067c0c22156b601dcd85450bc4c93355f8d83c068ee049ce453284d0c1389e9df1571d17de65e8e0f1de276ee77f3ca953172df131fb3afdf82430ac5dc18cd846ece59c43abf59bd4f4a81cfc452f5b0b2ce13ed102df3933d0a2b25dc9a529d8032639c995a5730332b161dccc03969496e1450e86158dff3584fdc56c081bf125b2fda336a1ab0d707def306502935f5580e91f0232045bb74c9397e36219c1602716ce217fb40086104f5e8b1db98f3e87284233e646cbf69189218b51f585920ad6563b1be4f85d3b22623c7ada4e16671d24cf9340827a8f83a0ec6c33ea54aeb24f2bb23eb370530ab9ab07789fd35447d23ce579450037a992e78352bee65aa4cc63ec0bb98c8bd58385813ad217079cc66f3dff21dda0202a4b82a9951626e6b5d5c02dc9ab982960d8351bbeb81e43f19336b05e8e98a5a0221c5cde3ed96e92756b0a403b6c357f098f78cfdd1e054f1db43470b7c468f1b5f4c11abdde2acbc5bc2f6d822f9b5e2665dc9b06da87f54bf63a6fc0fb6fe600a634da24edc3cdd8f16e84945251fa2446ce4af9a7f1cdbe9630ae67512a4ccee36408dceaca8e260a80fcfd1f0eb573ba64ad7706d1497aa8760cc524b4593093435bc0fa073a6eac455ea7909949c5e4cf5626e12af5fe1ce46f8cae67a2521bce72478f83b0e6d91c9f3f64480a2348314cdf63e0196f9cf9f718bbfc3e4d50bee87f547f2815a38bd431e30186dc3d2cd2218d77359400fd948fcfcc6fc7778ab95c2b1e36fdf602279b1815dcf76890bfb3ea98164973d543724e95c2873d6e6b893d2e71f7b6e2518f45971e1c68e5d91a5f152c67112402a3759f2cf4e9fc57de932e214c8fe8fdcf2b495c4809417ed9a8f4eb48fa67ec9de3e3c0869c1993a2d30650e30435be5d760d419d457565cbb31eceda99fe59ecd83ecea736ec2ae1030bdb38d0170e23c1a8bcea6db50f8a1c813a00d564a7fb756347f0059c06810a0dbd7e34cceb639af41433def5c83ae6211cccfce11e8b75c4b292648700eaba6451417d493a058424d827bf579d4d2d085f0b7c78a4198d3be7da894676b71808b36d6126ba117c108fbf259533cc8ebafb705b0f695a4112a94e75ea80c758a8bbeb15fe0548716f710c0751ac6977fc692943cf00836afcf49bf8e8025c1d5bbaf0164a6077d0b3d5fb8d2db5a617f5be3978ecd6dd039b1dd8f7c48210324d558542bd3c413e43416f742f8569e2f72822a7319a0c397ff99ec0bfc54a7c2ee3f6a9ae1c774963a92b63d4f50a7c8abf11bf9cb5fa9819a8bd51932423df66ee949cbebc2186588315fd2ce69edb7c7bcfb452002b48b2578c8c080d176c9d648b0b45b35232228c291492a73472b27ba4350e4764b972f123704990000de0d1f889d1b269774dabf4bf6138db11a49b0e23c2bc69a0ac0769328d95fddd7eae9137a028ec3e70ea7f66216565abc08342176f893155c4ad26919058c2f334bb1f39b9f1ce51f73507ca4e9d470c3a239a96971190fa1fde9f4d9411eff1a7cfaeb3f01071943418b99c42b118452b179441bd58fcec88ccdb2a87d0065b5f1002b752c45a46b0ac0adfc3074445d5425adbe11320422817253d8cdb910959d6d89b675085531e649190746cf76482e9f81b7e411b7893e5fe6f0dec52f4ff1fc41a89f53e576a9640ba5ba7c736f493c8d7cfac1fab0aa441c27db7741bc11cf886b2f3fee167f58bf61f2acdd002bc499ce7243bcc3fe3ee31eac50d86de45f92228ded61d54058ff1cf0dcfe8b6c989384842848e60d729c9387b0e8dbc818b96dfb9a8726028df8d4ee86ae06fd28e9b8a50391191c0db899f126037d881f425b1f70398dc61bc7a55061c3b7b4e4b590e3009ec841debac313243ce9006b821809087eba4f4a4e8c60ad0f05d116ed4efc6d92170b4007d2757547370e2be72fba2ecfbacc388fa7f968ab6defec856c6ee3eda2e0cbe36201029abd5902961a7d05beace075b0e11a0368d1a100c733efadc014c60a6a678276aabebe4a57de7353af1658fa6271db8613f724148224ec5c18d158ec7c2b0b67fbc744dcee4b6f33804e81e963bd9bc0c92997914e08186555e522fb46409f2535c889d564de4d8bcf4c62ec55b7e32ee4f3b1c3d511903e6cb04c3a19f92a9f6379065fac30632602cc0786f5daaae0f207df818153791fc0bc83d0e162f048deb844511e2ef1b44d3a8e0a57bb3c7c45e2e521785edbb1f0a419ba596d5a0e16329fca616547a4fb625a7a963aa2bf17e3a17e236827341be129d20f62f88042109dca306a7036d81378dc73d9c5a532fef69b7d8a2a385ba9dcdd65f27dfb35c58ece05be0e5f864913a39037dbc6e36dfed510568fe2bc729b6bc820d2d601de2ae2d7cd7f828ec7aa79f1534586116b8827fed9f32166f9e76a320567051f96d60f5f3d508ac0b886b15fdca175fedb325bb7b8d1a53f9682321d7d51ff159c511ac75ba945cb979788a37c3ba3b97bf1908459c262670a97c366c5a482d6c2ad3484aa907c24e6769e736118214db37d47034d718d2b515b3c73ceca4184b1c088802b25634fc489b946637a42d531f6d1718d95af30fbc2855a1ede2b7782e0c21a3f8f38f44f751d959ba29dd4c13c8e4d29dda3d73581025d553fcfedac052fd345f3ee9a8153c191c26d0ac3541a56c01be9cee94a98dbb6ab71468d89b99bd2b941ace6dffed0629ae76c883a12b49d816cb61d390bfabc2ad61eb37ff8d2eaf6b7037370d237afdd8b37987d00ca85ee662a87f3c996a68659fdfd2324e28e2a384d5263848ce5a831514afcefba029370616ccb90cc5971d5e0a6abfb06b4cdf6f922d5c65d44a936e3354512c78655a25ed841d2fa06b148c899d82a7606b11880915416d43987a4b51d731eb43a569e20196dcef76290cbf5140fbed440da6dea7baeac2f91914e16fd0e8ed2d6ab8dbaf84aa14181941da0d985e11372a20fc20ac6ab63642bbd8488eafe23fdde6f898c1afb0c7e4fd30a2ae096ca5537078d5a9224129d5d799b0cf5b33ef13a22d3828ebbf340b78736b4188d58b6987e419bed3a3109b7b95e732e764410476f94da22e91b63ab3b0e0fc92ae88493be8824bb4ffc305fe8aca52e7a9ee0b3ebdf7474348ec8702850d1648334a4e547ffb7f75b56774dc16881a2cde2c8c42abb0abfb06e4098bb4e242bee1afc87dd87fef8d4084933b1220f57cf45185c25203b5066f6c1d5405be3209e76f11a1ad652cdbe0246ce6e0481e107fe000b9948eb6e38915a39c834849c84257d46e54326d99b199021a7c88a8cb5739f9cde0d2f2000f08438c0067df73526aa34c06287ec31e1b321145ceef2741556ff8756e23585bb10d778273f0e657d6e6080f7b43e712bdb1c1cb111ed8b78864940a6f3c059c5d23a2247e523988a413a52364bb75d565f3ba92c96e33e8dae60b1c80f443bd3463752863c5424cfc7e4c6efd2fc69b34713ac07dea675d9325c5cfc7529e672c420d5367097588837080c9400957b66b8c9ce078ca87e33140c07d0647a7881a2e9da0f8acc6e66ee05287f8059ad080d4e6c594657737cb3a603b4e5b117eefbf9e2231ebd8d5562117efe34d7cd824168304f4278f1a696cb808f0b61bb608b4bca2829513d58077442d214046bbb17a36220d9507fd69c0df345c035d57feb0e4cf3dc24b8d28aceb6b0e67a3a9456b3bce84fcf669e373e30ef1b3bcbe3cfa1b55c828eade90036fd9c6430fb49ba3441cd63f207e910b8472a3eff01c5df622c91c79579f43c0d324148932ea293c369df501ce865faa67d1224c05761e1ce177468ba6f8b4e3f49b5c7bc13d7586b3b86c77b29e01d0e7c51c09f255325e96995107b158f7ed3c7643bda83cc99c3ee61a81f26677bf023f7d524674b0f8130c78d5d05e4cf56fc60fc8d39e8ddde9f6de02369af7484cc59809b877cc4eddb10e18f532180ac13ea6453a85d97960ed445d01d1a076b4ab5db327a56dfb36989107bea54211337b8ff4097d0032ae17df6edba1cfeab87c31839b189edc84c465fbe869b9996b80f763db20b956b283d0367250daefa811895362eb5c879d7f2b909c541e00d133f0f83b087def5a2df69e25e17dbfc66357fb6f932d2cc7687eda65de7184cce343f64dec85520bb2407723bd4d97195335bd278c6634cf743709167c449617d46d4c4e5cbe0186f2552be4c2687cb59e4e7b2a0daa14e02d9fffa3ebc1fa56bd48264e930e99b94f2f6b5eb15f5e822e1cc15f12ca986ca948fd47a7d4a1710770655741d97f96719638acf97dd962501c94bce7a913c288a078fae42546447d1b7226b3612848d1bb56ee06874e6fce4b40458581866d9b121d5ada72aacd607ad12cfd50f0cf887f915fa4b729a0c6678e0b834642f8459a964932e65624ac0de2ac4886fd46dfca7aaba4e07111f4184c0cc63f8f6d5745aa2eece7a7f79c009a884eb57e0b5459b414cc6d32bcda23011cef52ce91b9ff31d77b82582f01769f06f279d8e737c48dfda6a9cf5b76eae202ee3a1dd56cd93204c5f85ab15a8a0f0b2903f6b010d15f0bc1c8d6797e13ab5f787fbb1ecaad728dba3b9a809580a20173a6a6b0d96e28e42b0ecaa009fd02a8534a77cc42cc995d42f50ea5fbbe86669441a7c4521ee392a42951d04c29785119788b02557833af9778f700c7a9c47baecb6fcb38780706e1bfc65719f3219ee19ccf3aa2880766527a210d2a324db84342fc36bebdf2841166ceca37c8e58b187dfe4a52ff8cea563ff6571a14421de423054632a56f70a8ab4673a7feb62137637c8cc6a906909dd8376d26fc672f5f3d24374c30d543ae24fdf15d12c4f3f98ab4dc95690f200b9cf5d1ec6c674e4b4ef40df77540e20fd4e66a00c1b6e91d811c7a33dc2d6ceb056605a346dffa4cd73c756cb69300f090d2a207779a12e338a71ffbb319d30e92f9cf4cdf117facb77817cd8b2e9b13811514ea68b0759a822d6902705fefc47b1e8893619c275fff645e69362dab3f70797c569b30e7d50a8a4872be3d3dd3ff58bfc57850fd0906d4e60a9e27f81ff9fca13cb50ec16e4499395f9fd8e0e34459da3511bc7d8461f488f3f1e43fe34093c3143c84faf8f367e335111b64c02f843a75c66cf2b0150c5db2ac4d49a15bdab67d66231293d28813fc026f4270ac538c1bade454a1d139cdd600d318f338eacc0c062ee0cf5ff18a1d9e9717f6127623d622e2e14a0e20edaf92645497055ec722d81edd091a7df630fb33e83eab94257231ab62a94a1ec33b8b36f96402a7e84154ce1336ad8f21405de7a1c290cdff625116df7a08c4613088be9223ad517f992e1f622f9080439f1825e617a6a036c57a71e4cb45fb6a5d35e7b200339562a68174b7159c87e15beb102ae5cf5ca50da2a72e3983067027307f09baa38871c59f25a3942f3e70ddd8efc6ce43650dc2ae33c82369734756f826ff4fdf4b722dbdca78d4b50a262146fc8004243663b69737176956ff147ac1bffd825319d3bc7c41f24010f309cb253fd266c02ee4d0d0e9e290b5a0aef672bf88de84b8bd4d9e41ac2457bed599a657ae75a589a596557af32063c32e2c85b152edfc4f838d7191343d23a908156dbb983fddae46149b26d6344eecd2b806447e3069fac0276301252ed5428dc4c41b0d12bc4a25a0b18172971d0b181f689f75dff228b7eb386ea9b7e163d21aa3438783572b3bdbdc3bc8229a418b4ba7896f92b7707eb80b39365f64405e51670db58c856cdc517d1d98e80caa3816a0b083ca23d76b85359dc71be0fbb6958fdf309c7a70c9d937f5149a02b44c7d9e374cae2419e04caf64f400e65e648656fb23427044b04b0c4e975e32f1d33b73d0f9b24ee7f993a67f9edcc888c989d80bb52d1a0bc54f4de477c3936aaad762b29bbd882d1a39a6dae764b5588eafdfdaa2a10fac53926fbc610a4071fda878424bd83c003e98aec43ba3174c7ea37f9ccd90996efd8fab0197f23f76a3511200246716825c80662e52886f1a468ac11fd41f536116a2b7c7a48bf385ee5072efc167fbf08577863ad8881759f8d5494278789311f15cb5d7c7ec9413b09dc049a0bb8ede92bc97b823e5a9e585815032e027e76ac51f4c5a18f09202e5432dbe88f962c5d5c27e840b880f6fabf569fd6cd6d3df5790acb72167da11f9b9b5eeb3b7fbbe02676f06700ed371db3fa3fabbf17e0b993f06337c9f734358a7f92c3fe4d1cf3ae7eed06f2b8ce081b1679fba69d5091ce546e3b9499a55c6457046a765552aad32f837c88a006e77fde66c8d7442ec209191936c59ec689d65d07a20d6152379622910403abcc91351bd7ad697d3548af3dc3017fc44e611f8fe3c08e3a17beefa23dee1135e829224d8ea46131de5f09088e8213db69975df340c45c526a8fe6255d378f172e2f7149b995e9a009ebf23f7ae92fedcb6ba31ca27383f9338215d09c52b80a9462b17e990cb5080bc03d26dbe4b4ef59e54a1cb8101b48cfcb49ddd32c9efd26ca18db2f5f62798970610c1497c74155bc46da6bea0f376ac34a7dcabeb4ee453d8ace8d953d742dcd2daba7dd290d7a23c0fa9a81ba08ddd71e220507dd44d39b8211328d32231a14a425465640f040c9af19ae1cf05341214c247f788c80ce5c21213ba9872b1c87135aea8c430737474ad4f209b178abda22e5b557c1692ee2c0f02bb05e3a95a67b5d28fc257eb38d19c369f520dd9e9266fb021665cbc84a6314cfe5b520517eb3cb6f0c7a186d0c880b74ad742c58c09c596e3534c88c5f55e5fbee2ebaafb62e28ae9bd9644968e5bc78f90fc1edfc580c778b5e0ee3a7e251164badee91144b1c802d9a2e56096813bdf8160e2feed68ed995f417d97cd9b21858f19d089beed8ac6a2bfcd2e254290a501101136d7b7d2c81adf9c28343ff115c33469082bf03e7b7ae22f71818318da492b9376156de6f3b4f4a01ed380db09b78e772c1df0be715eba853374c7ac27d046b34eb60aa1f3c60cfe93adadec0cc3345a9886f3b8b4b77712b469c96e8c139158ea9b76e2476adc116a6c898da3e10e0f701d3bed3b4192a38928e56372b28c9b76faf0179fd9b6c03e92f240a33172e39a41876a484fc5ac13e15ee23e7b29767eb3c777abb5d78665190d2b47df250ac1b8d6243748fa2efe093bfad662ab1db5c62d9363cd99067080dce934ae51ab85c8158750cadabaee8ad21f28673ef7fddfb63fbc6cdf40187dc2b4dd938651793575cf7856f2722dea68fd03632dd52530c709d366013eb3a5eabbb8c9056a10b40b78908d46980f4de3b103321aadd83dd8f553f38c053586c47981fbd6b8b18283e11745ba540b7776766c6af53d04b51283576a171476b40ae354d610fd87a523af0b8dc5bcd7450c85bf1d11c8cded3f1d37ba88975dba9f566429d5b89081a72f2c25814824482e64c91231be18167eadadbadae341e41c68182b1e21581c5aafc94aa1c3355bf85b648fc2b067970bcadb12f170fa60761cb943567373516c6844cc86b852d2547770a5f759fdbcd86a5ae24dca7b5f9120fba58084230140202230d983a6ccce85a2038e0fe11219dcd98de5bde702bacdef16e18aa679a697e907a0346019ab13cb06d6ca3ace266913d51039dabdd6f0d9a753fbf56aadef1c588b6e74eaf657a1fc6605c698d98695ddf3f37eabec43af2877d4908e1fa165187e31c2730824ae429b92d276a9c246c60af393354410b45bb575c7b74a26b34abecd92c6e1e4f02543d02e627ec821424f04d087dacd5a2b16b2ee1c250d8ce358835c66556955fafc77a0cc4a1b28868e3c78b428f927de7300d75b065947b7ba71424de05988eb88478c304d129ebf15645c791be7d3e4fb35cf1015d11d9b05987b5e4f1a337ddfcad1e3f3ceb5d5d24384d680e637e369b3ed8839cffb35237f76fa21016b27a060d5f400e0898033ac20bc1fdcdd2b24fad3ca00c606a43a3db5b75156a04c08ab96e3bb930c48f1dbd453336c9c36d552e0602ab0ebbd3c06e0a526a01850e2914eb1948c11ab0fc10b65f1841401a96d39d7d46e50020c94cfb3e09877608555bbc2ab945a80e107ba59273895f2cdee562a858108fadbb2ab21900f3a3f143b7212cfc1744ded75466d331c63fb0e03a60c854c7e2c45015adf0bfbdcd89f48a6f184bdfbc5c24007544b5bddc13056fd5b829e3a9918b16ad98da4bed50c496e082cee8b13a072d2d1f567ac216351cfa75d8be580eeca4a11a4973a270d1c3d8670fb2bd0ce9a029a2e67b2b4c102a6c31ed4925e4d097d4414f1621e8886164ff808ce64ac55871932d582f5ac3966d4f62b249fba42b2957d2a005c8951c94a514712962e0c2371692ddc4d3c344f0c01b7d91ef2e66da08aa0cc4e53faf2f6314cced57050b9c924f8ccaf78b8da50693ee9e45eb7f1ee9436e62d942fb7ba5b020c6fa37dd8b4e7266f3e900812ed603251f8b64d1d44778ec5b3304848a8b2a8e41833d30f813999124d4e303dfd23d49b8152b98ec812eeef5db793983971cd2b17474cce8122ccf1802d67052d052f5a8e55e31240c0a9e6ecc7d46f82a3587110a0408e359875533bc95e2e17b1e338a5b6cd499dc108c5c242394bfea8e96b34edc715584d05ec1bf58c1345b5b000ddc6b1115fde2a99b1514c1440ec766596483ded6127efd4e5d823b60fdbb97b50d4bfd4ec14116bbec6a0f8e2a3a9c75294ccf9ebca1f365ba4c371964c8a010721706c897dc86c9e9c8ae6f8a464c29049f4899a1f0ea286907dd5c7dacb0c1a24553abb596828bae5ce539187fb0a5edf20646b6a77dbdf7955bce9bf2c9f2f841dbdde5f0e163475acdb5e6f64afb8a72b2963e622036a292e815dc5f8d90aed34f000d022a8882144cd0978b050f17cee740f0faf944b8c65ac2087a9934d92ea01920cfd67c612dbcac63c229052406c1d8d29a98c821a4974bc73bab63cb3e00740a4edae015f1ddeed4864611ae81bac6ed0ab56f2fab4e7752af9d097732fc92dc8e502de8978877d2802a5c721ca1d70afbf465fff2a4814d513bbf9ebc814cfdb9d13ab51865dab1d69dcd0d183380b521c050c18904692fd7c5d5c0a455bbc6fcab04d618059b159307fe46fa54aeac8be120d9425507d2e0f94477578c2ebe1c116821fef19d782637d04645b41b1af6ce881322402186fbededa333ae48bd7476a6f1549caf31eb3b520bfae90fccbdee3c13562242f800c7f6190cb6a9765191c5ae3399bda8f1cafa5d5c8a51d3fdf31013f0050f1ecf142b1f317979a370ff5cabc2bc652eea52c334bcb6131b1fc4997f39e1075a6a8ed4b1196a87951657fafce7f4e05429dc841334f17d8298a6d85ea942e737ce92587d2cfa343292047aaa73e4fff81fbd7ac1f154fa4d82799c93422d8e5b060acd5ed4a89d3efa690b28d55370cb3127ae756fee9e2cc18d8902b0ca8c35156d6c1b91be9122b6655753bf3237b65b30b402972cbc397f7e43596182848e3bd12da8b729bc7ac62578b1d4f6ba5b776eab307ce70095710e2f97fb4b62578a33950882d65f1d05df24d6b7aa16a6c25a51c5265e225d69b83515379bcdcf4b25ab983ced2cb91606b2bc1fe94dc2f390e458ac1c7975ce97249bc282e91a7b89fa04a83d90611afeea99a2c64d0031fbd15dd193e44f3536e5ac4b176a4a638f914a1ee2c2035b0980b7ab2ca80cffe180149bd163993819dc6fb5950e12fa40d54f7ea52b54cddebccb3a6b80f07fd9fcabea2306f9b67014b723239b504eba92f472f37155849b44990f4ff52b7deb50c03976538fb8c5ca1a90455273f80972e6f073aceb493054ec0401eb2bb8c0debac9f939a8f9fcaf425d388c86cdf1cdacf57a82000d0458e26428e6962cb1ab44be95a8788ac6999b82a50bd081e2fa0b9bac4c46b5f90990288db31d38df2c9fa5fc357f50545d0591b9a51e83ec3708f721da585e36b87e90596ec6cc22b85f84b5b27da934a00ed46f02617ddc9323563a99a0ea88eca977c3f151789466494b36c5eece3129f67ec6919f1a954762dcf9b04d02ac6ecd360894e0486b03d0735614fa3c08490f2471171038b5c3b3f3e7d5042b623e8c75be5f2a55a3bdfba5aa787fe9b4c56e529719585619f749e30722f63b874e76460f4125a2d015b2c5b30e205a63f2166b901e0e34843222f13d80174110c7a88f8f15b61eddb3ed48d45781a694972cb503e2ddc9d837575d570c7e4cfe7aaf1e8f50286bb0cff22b6460b61164b1ad8c0da27c235aaf5633cca08905404c58ef6ccf6c6d9cf1821c8368fc37519126bbc3db0ee415aaa23a639ac4cb80324df6753b45ff59edb288db69ccd55c93866e4870609e1d03e20b0dc587230fab90b8eb3e3595a7266188419e49674e74b4f4fe25af76ed9b302adb7205c145b389b3b32988c8e0c63fe4b05040ce19e815f3ec4e427c738684256d4ec9037e1e6f1f3e2be06c4ee83b2ab361644355215fb13b2dc71f78daca995693d52f082d872a91930130723a433ef46df1ab98218219684393fa7437f8cebb07e81bb17bbd57811dd484ea8bf1faddb392e66e49a539bd4718caa297afa6ca55f5304c3c9a9ea8057f52ae73d4af136a8ce19f97d7d8353063a0055b3d8608a8727fbb0526e6d8b5a5a2465572213cc178202ac1286af49b6afdffab4fb8abd04a7964ec4bc2b69ddbd63c2f9c92a04cc0687fe6a2b7986ecf3d8182126a24405b871a818bcfc68041ee1b41fc4c3ce1715ede555dff5c2ec20e75e5fc7ca08c3fd9854b3ba593e8a17208a8a51ed45a4acc5043924a1de0e542fefb31eb32d3f519e62f4de4bc3f8dd5312e4e97b465fcb4d102a32aaeef22ab1537a6a1fd0a58c587fcd09866f8f13506fc2acefb56dbf606b40cb30f69b4c37bf640d562b2568cbcda444fc7f09f8c2b103a9bb18f0513379f3b7b320b275e094161118efee20e35278f18756b6bc6173c5396db08008b6a745a2d5c6c0029822a1bdfa919839e717d29d497b6ae9852a32be304d85872f75297f4cbfe1eee1dccde4fda964416ab94626fcacb9205dc3ec6d9ae36f7ecd8b3a2c07d8453052eb0d0152271640ee8a32671f84061933be7b1766b3e28aee2e10062a9f9bacc8fbce9737c2226cb4f3b694508b5da5a293f83bef9b33ef1559c65b25f9a8e445bfb73d0acdc2b379632593059adad1111241ce80c743dd79fb1c19e9b8a35571592b9c06b4c0d224da23eeea503da4aadae2a3759859a79140e4ce045d52a4571568775c73f1549c3c26dcbc2b7ca2455f121979054759a42d86456c1f1a6ef758e681cbb6fd68d50620756948332c7cce7390ab032c9c5dfbbc4d0c14f65e350f050721337d44856d3f8b9b2126ae957059c2bc6c34004db974d052c6153ec26c3febc4cbb08dab4032a83a755bcf162a6ea28c2cca3571e64421ca8b09f687211af97575601f3276e5a6fb9abc1472d9e9da88ef5b1dec66772be7996ce487ad8ebce66844c694b85bc057143a0ee27bb13083bd5c9956735f8bbebb7e021aecf85f88e07e468d98a1e674147791afd2ef9bac89aff237f6d8a3e6a3ac89ca038de209b768dd711bcb67196bfdae4f65788b5a68940554759c6ec8f6cb7edf63f850eae28c50d8a1753e96186e1019148d00dfb5acd4783e089146d4dda529ced4122e2d99dfc1c1a63782ba305bf6c944c279da2693113b27f098229856199b1274cdb46710add0d42a3b09350a574d36671215a20dbaee54e28b7656a82a69b7d666e3febac46ec5745dff05a7dc452f02ccb452890483392e09fbe4507d9adc7ff30100a167097fe23d70111303b660f0dd841aac53836f0c35122c2079d41bed39982eba1388e47a986649df2b3439968d9f6033a4763538a5585b666d679d1a8fab3f3ff6d83b267ae31cf49f678912c77336383a97885ae132f0629477a41a46db61a3bd7a5185ee55d6adc92e26380147ee5204d8c06d351f5653b54cd1766612ab3678db32ae916c52f14509f1a89d2ede34bbee8586e304cc95ff8b448b8049d3d2e3df68fae02ae6505d84b6b006e1b989118c262da82508146fc73cd3541da29f9056344a902a9fda3c8943f3612ed5cc55f23e20d14fa599fa7617e2d20f2bd69eecc16663e10ec9420ddc7225c25d946d33339a4270f3dc2e88c15c3bfa661b0b2e1a89e974f437762449e727a361cc2e5c162f8c0a027295e00b778489b8f8685cbd629d3a4186dbb8cb8b7cadd64c083817fe2c99a8b18ffc23595d50bc723a9987bedafb000a3472b62d2d6fae40c32910f011343975eeb96c99e5bbf26422d04d6690658ba49f55422582e25ca16e07f32e9d415064c22cfb6e88e3106fa31a666e78685a66289a1d6da065b006d16bdaaf597233c61e9d69de93ce7bf67b1d49fe9f20e8a4abf7d8a91f920397513f0ea322fbf447c34b7414046c4df6601bed94325ebbdec31114735e2f72ea978850c0ed26ac39866ee373ff294b5bf2df1558c1fd21cbc84adfc94b4d8b043fa61b5b688b70f469aea042cf8307299b640c8cadd56d9e49ca19dd3c7c763474b7df0195bb51e31ff0b743ef9461052637efec50299a52699d0d360e56be880b76a1de504bbebef4d3d1e9a18fa1d83470343ec7aa7ec317879dd066abc65baf31b96683045f24809bf688def8447af13e26a58b3feffddb421f811fd414e73dcaf6139c163d3df023390d54d26e32a02736be103e1cfd808b20687d6dcfba674913e5b865732d05779ae1f3c4a3f4f5b72247f5b32f652c3a6e321434869088f26b7749471847e7971ce7eb5c43bc5780b385278f3c2936ca361052fc3c8ae2c47295aa79324124f135b8262e0d7bdd477b92080578a4a78849d9f4fc34f4961b76ccdc9c55b91f7d8a9444544c6eb15230289b55599e164fe1246c132864783bc477a04f8d9d3ef3557ac20017fc38dab01889eda4676aa8d8cd51e729354e7245f31d17d61fad2f7279cc10ce5689f140bd6e282806846a04610a2d3ca7028005a0e7f9bf5bc033cda498975b642615e798ecc1223ec6b04af1a00d85fbf11759b822d5f9f768f729766315d7ffc0aabc0cc966a597ca17c7f12eefaad7f6f2a94a41497dcf2c5555d108172301bcce40245b994f1c0cc2b70f476e6005fe6f60b8e200939148e2d0dc8072bfbf686f69a583bd3ddd840111e7871eb6560bcaee14b31fda41e220351924830f08239c2fffb6d2f7e15a0ab579605424ab145585858704fd2ae28b7ebb637b18ae30004a0cef5ff76e0f35f39e372c16f071dd9905cf46c2a059406db37343a47f5299de26af4462008d92f67676fad506a64a6342c6a1ba2b463427689169e88e4b40064091913f24292170c21486fb9ff0f143ac1948f23dd81b677cb47fdce88f397a0dfbe04bf4979100db07f1ec6eb361fef8d1929f9b9a46242cfb773fe6e060cdfb6212b2133b6aa7f84c9c2b2709867e4d1236613cad02fb2969de5e6a1893e7c3c6f3ee0c1e2c818e5f806fe4653be6535f205819b8571bcdff49e7ec45c5c4ac7d6ac57c7705416b3732977f5b9143e1413b33238597f511f985d983e668284478ed6cdf1c560b1e4cd0d84d4ae61bf381c0fe30694af12b42f3979b88bda7193db3e989220c6928b454adf3f5fe3311446282a5fd30a116307669b06c05d52c740c7b8dc64559ca9a4551ac7ff329338b39a50793fe29089c5051460ddadf0a0828d4b09eb61f3dae2e51ca1f9cb7ce6584a127cd974c5f1fe87f79d19ac1dc2df27a046cc2a4002a0d7713133e1f8ff3e968aa3687c77508bd54b42a1aa95547bae4ad63fa474e6c1b8e13bb55c69bd36e9ec933f4bf57b9c84a8fdb1738e3cb7ed9f757f3c2cff448cce9853b5ef9d2813932796d841d459c218371e0e0278565683436e50f46f64c313889899a2c3227eaa71d75b3763ccbcfa953127480611de2e8f89fd8f1e653f1b5c236b4f11058217206bff97f25b247c1ef89cacb2b158b7be7deade5919ed825816cd1af7af3aa6c062408cb41978d6c006ff2c8250931bfc9d4fd2d8e093e8cc2cc541133c730706d02a20667ce0aed48fa9a2c983c1cc091a0b0e990086fb3d6e396ef1e2a0416c8f035e76e7b7654811b9f2f1fab3595caf3f37e4f282989e80ee096b77ab9f671b6bdd4db75aeb4208a4e3a2a6b6b9314bf2afa7b3eba4ccaf078289c32da19c06f9c6362ba49689be1a1855d17cfbe74d7243f307ce80d570b8bcea7ad5f694c4ef471f79d4fd663e3f8f4a7fb1130a8d76c64a4b50d4388bc124e7af633198298210877edf7b590b8d4e0d52d3c6320ff78f7cfc19422791c53848005e82f26c5f59d7b1fbaa6999fc1caa97c06928dd095fa59062c4343f16e6d9f24bad16127c5f06951c6b8d864346aef4f84e757ef98cb435216e0aa27e246fcc9d506159adf80593007f9f8c112da41145321fde0ffe3f212d2009833fe5333337484c53f674e4386dc9c469486f7be5b61cce99a890560333af72645b64a8125761c685f849b3d6c2eae5732a67931843e028590b8ba2a830696634798078fb3ce1b4604a09d6c8a9cba7c87ad3fc61fc58b1d66928c02bae10c2698adebff3c89fc9bfc6c652061c7129c5bd9ed07d0702747d3f1011aa950889109ecdcdc394143b3cf1d4bde8a789fd7872f4449eb4c0ff2b296cac65bb94871cc323e6ba7f53bcfcd358cdf067c20a92c339d112f4a3d817bde13fbfc942b85079c118e3f0903132d93d364ef9beb25815043ae4db0da3d6ff82e240dc0bc4fc3c7517a317fc2a870841e6193e886585f81c50bf857682b58bd0257badcdd5650a657d5abc1a789cd55e3dbee3d9846532bc5ed2e14f1c281fe7c602d8bbea60f4b699c6c6f214477ba690e3a26fb086cd702a8a0ea102446c16b3c72b68f1bcae2da2d537ded5f5389f4d5793ee73e4cdc27e181b36dae00d5d94efdb3cc7289109706b8eb6648cfdb4024edb5ab6666f3b85299315c549350d9a69c8599282c67363271936562ab8cc3eabf5cc514bfffd77da7a8a9b32b63e180d64dd14d116b3f1899598aafc8b027f9a25510bfbb89ea64d76efdc9004732c2c12e07e089dbc1bb5d6429cdbd5cabae07c825b8b2631e4803fd890f33aa39b05b69a5b147143320a2bd3f2b051fbb07014754edc58093687f41b73551db99db5356e3386bc673dda7560022001500b39f77b454b7a34b66e47504828fcd2fc758f45f4c1d1835e389675d643d233488cd9dec622b23f6f3907868b286c65f52007cc8372dd75c9689e2dc9052a4769b98fa7ec23a16669adc285814011b1db58eb62609ba484cd258d423980428c72ec702207091f0cd44af3099a8386fe29258cfe8ca7a69d2f8a3ba4aedf5d3a556e019a1b7857b19380dc79d6bc37115d12370f921606a24ccb567420a3effdc4b2ea2e54842ad0e6b973730740a35400ad06529233a1d7f7b8c2d11975b1cc73815710e3ab8c7d3280f2516fca5c8bb94c5d3d568e5177b58494436a487fdd15406d9eea171954b00bbd899c001bf6451d13292142fe73ff1cdf88dbfa5664d3713c549cb80bfe8fe027c0e6c6e8a851b2ab5e3a8242775c45b11a6d131bac7bcb8e247576d0d7e2e4250a17c2f1e97684513d52e8ebf3d4247b85e1e0dfa75e2f1de0ffd296a7a2159f7c02c15be8961c966406babf57596f005d4efc7fecb159f4c0cb5e5e20ab6b61c8ff9a8ecaaa910322cbe0295d8c67df594964cb2b53083bb6afdf3975bd5c526f0defda1e1cb3f683f01b52baa903814ba43bb1c41cb851b6c5fa02f7788753d9734d2afad646883e2e85062a589d53cea352d2b1f07b8f9d9892be0612249758b8dd2253f6ab7ee41c9ff465384b3c6658d77b5eb84d0c8b285c85ffb2a6b55dcdd31016a5064eaaca0d89e491b77454a11c32ae027a40cbfa1505540a98f802176226aa63b691bcbe7558aae14309248db7ad2a516485541df8d5db77811a51b74c89eb05a0fa8796cb5545d72dd8b99f0322eb196080b3b4147cc806a9f7e72ce790916512aa7e66d5e5a2e0cb1162300213dd656c30310e1d0e158193c1ef452b5daf258563c37ee9d9ba0b6a9bcf812dbc12c4fd75cdade49de8fff3c7645683e5fba6188b146667f83b8571c9eb576250ab51367e5aca3c4b13eff52113da517521906fb576af1dceeb376003a2b16842f2292f94da682ee24e824c0295ce7507d780f94a530ba66dd51d1c0c6610f7511f4c637f3d820022bdd6983ae722f9d0584ce91903a203d907b5b51fa0f2be1107edc5dfde7bee65cdc4eafd8441a57db5591c8c43aed4915f154448e98c542ffb68264e11e9f05e2c0671d2160e95ec1ffb78ba34e5b4d084f7d9db62396fc81e3e2e21a774e4d9f4e9542cbef27d959ed5bea3c3f8d18886fcb77bcf7bb6218c9681c3cde1e2848fa71dd28ce7450969916f5f4519e0b1b9f703ab20474bf9e28424f9edd06014eec787a597b9b5e3a33cf96b00731837ad48025daa5d02550dc598e4988b82d2738d16a4f46d06b51bbe7dc5d8d1cc6f1cdd12b4c8197ef782deee2398ee7698f9f8fd6bce22c43b815046f31ed5e399533d3cfb5f443ab33a6e9c435cdbf7c6341d6266e59a12550cae09b8b01a196f1a7d8ff28d7809e5140fa9df387fef3305113bc17a20df182e8207e55677a738dd2cd0c0c3c5c258949061680bc4b226bc42c62f3916f61f83a5134004ce71a9a22729d4ab342e78f86a8de8a922108d6d68879263e77b062730bcc3b9d543dbedc25547f028bd8e9a138f9a61ee00dbc3691777b280d2ad24e166ec8ed2f6684ea5be3f3720645d1053802350edb520ceb5ebea8409bf8d499bd82ab46023f7a28d441edbb7085527b4637d8c06a57fc7e817d1ed67dd04c879278d19ee5441026f4fb7d95f2995465dd1e86d931463d0311c793d759235e00acfdc84ab93630c74235e6beb4360f63c6f27a373a50ef974231ad2c4029de91e3d4af2f1365ba4c577e77140facfe199959b28da09b1affb6b4abcbd69583ed71e05517ab539c00dcd6c841f045bc05999ac20734f5515dcab6a00eab2943f13832f6c4a418a621648e220fa6c9d1ac45751f0f8d08cd1132a8cd00af45577e38444c93eb7f195317baf86d10aac45adaf57f2007791602f2dc9349d0967c6e5e7fd3474df13d63a60eb4834e3a1008a027b4baa9d4600a0dd00de59ce342b06a0df5f604b6e0945d6dfc6c882af08db45b98da5f477b23240a97919ac48e7c0e3abd924e075abc0bbd1f4b1e8ec6f20177fe11d9414c4f2e4fc5eba301a6836866bfd8041e4ce9c569da30671824d896dd3beb66641f3abafcdaee8d3f80f9c1d297cd9d50e58413ea203147624f6b698d35ecf61b49422542c5dbf2ce0eb7bba1d49bd74ef682666dba1cdc32bc5ece39a79aa5a0a9381b745362938311a7a2042d4d793f789641b056034aa528c3d63c63cdb36ed111c9ee097d3d1fc335eb5a5858c73ac5a25195472b92745aef679a81014b94967810656e6e8fc88333ebcff28da19dbb9147fe51ac168648e2a4cee54fe6dcaf6ff624158c18508e5b564edb86942dfc69f12acd6067dba0501e070e6a0437cc10a57d0887468e0a11b1131b18629c4adec51e403ed8eec00820c995eed2ed5ceff3c8fd1605779cb2c1823c651444d37338f92a89b2fa796f956f3ad45c7dfaa491366d260dfb8cc07b5bdf5a2fbf6dd91bd9d7ba82ad5e1bbb2adec3750ccd685f303bf7ac6cb433751d0ee619a5c996d95cb5a18db4b92fdd487b6e727dab75f637f147a02094850c383861655f807cdba9588eee39e14919d12c64408805afbd04720117ba0c25403780ba7c160ee4699ca4d9a6fe48715daecd3958bc24e6c031ab616926674718e980059a1c6b82408998e9682297fa3861fdaa9bd6d1dc4f3472df91b8533f20072a8c2a579a78c14c7a921158c34bca40764055a5ddc426cac50dcf34c3ffb6082dc103c2453396d87bc9a816f650e6c7f71e56c568ac9deb036f8ba72e2d46399b7bb261278e388d1c93af9fa5bfa57fd9261e0bb5e0e5d6fff76a501d6a29f6ed10422b4813e3b35cf9893860ce461d369f9794a7fd3bcdca5ac04e4f061df4ee9f646dc866d7a45cc98d9402d5ef8489de6bfe3b475cc4a36cb7ff842e50cbf74c4225a52341d68bf00b39c0378ae2afce46ed61258b4ec503350d5962d1641fa5ea40d36c49456921b7ba0524615044a0e4bed1fb659adfc75a8fbf205c7ec1c2ab456233e5bd4308697064c5911f6c33e3c455996713959a806e2f5b334da60334288d475bfe95a32cc7e3802270db447731e357ecbb04d3e171b3ccb03d5cabe2594279b6c2f50cec042b9dda3b2ac4005a25f083f7f7fd14baf39d22f1dea6c192d476081f1f961e43696696133b4cca961fbcc252621fa94ba419d7d9c766d3c9f36a916bd33c0a2aed2b13072be3258c352529cd2f031d9785fb853bfadc5c3c2eac28131eae0e2e3aae44e27aeb7939cf6af1ba70e05906be029a6a1ce3f7258c6babe90045b7ce278b093e6834f14c27137c4a1dc77b7dfe6063eddb3b4334d2a53be3205dace5ff7b1c68478387ea5a6dc6e3812cedb46168f59561d24debda476d9b4d000593f5dc511e5c02459cd74f761aa2e9be0efb20adf4ff0503d44e82dbff2de0c11552f0d529994175200ef41dcecbefd8ef26898fecf421e6c6b77341b4c39ca367425d4dedc9d9a7525f95bf623872c7ffab18310ed5005f506cb82422c20584596fbaed37f8b048becf7c7f1b984c9eb676d65e03b9a733e843c2aeda330d1e1b46eef68de8c7ccd9ec0cbed521efe5214b23aa8859da71e77d8cfd56f62d88f0abaacaba1dfcb95548385acc4f4f1a5eb0898e81501e48efc94eb220e4f4bb9dafaf0f192d4fbee5cb6bc607af0cc26553be25820f42d7a2ddeb07c68c0cea5b7cbf541790562e5d652b7925fb30564f7e7865bdf16be8b839c617c0827348bc5757cc871ce02f75ba58ef83264463c64c04374543aff984982dd2ca4e673f36bb1321c89724bd690f85f79fe3b924a0103bed55cc86d7563914fd4448d81ae1ad5578201573d941f253e61a55f88ed8cb14d00d5ac792441c8ce5b661774340e142628824817df8635525943fdd6b6de4bddc3af9e808647360bba6a3e096c74f5bc08977da5015df24d9cb9e10e7bed451348188c3f5ba3cdc7aa2c74b197585757175c07ece71d6d0c3c17aeb2eacf7fb339286b44a0aef1d986a770ec01804ae1d1621000d41a56efe4fd0874d639f3b4c90d1e416daff05a23ac8fbef13fd31323bf8d7abedce68c4f517b3ef014b81d42b3434b428c2f24e1c9bf5c9a71ef17710c1e5e85bf79e1e19f62c48402968e7fb592fea6bba64dadea5e3c55044da5c4b40e09036ed79615f0eddc6f9580387e0bf6ebdecf0122ce478c5e30223cd03ee69da54730f1f2e28b6b7adbef99d989dfd7e5ee6159250571caf4e34e4ebd8976f8e71ced8e7acbbf6ff0ec34375fd393f5cfe456f4333879aaf9d447f9b3b7ac25553d43a24364dac9e2e74456703b3c4ca7662539aeb64adb9622b8f4ef96f1c26c3f7c38fafbd64844fafd50aced4c3257306bec9f02d6a8c051ab7fc20d3e833ad5188e9fd4e86224f9aaf97a36e0b456f20c30be3718bd3d7cde0b6d761026e7e0534dc49d3824be20cca2fd71a452d6d32b1487a640635940b1f981c521aad9c51dd05329cdf3bdba93240659c59f87ec12f625b4ff7e2689dc8b211a23a007828c6d77bed57c6269c6007c84cb28cb5ce537b5bbc7988d2de9f378ee84bfff4604f0f8730f9f3f2b948bc7788238959b1bd4e9c8b84047322a13701f9a21bef29f58fcbe17f2170dae05ca153339c4dcb1466f84cf04e8e075b2aa1e8052929e6cc86755e00b581a5530785667da496314c5e7b97ab59d6410567feeda72bcd545ed8f9eadd77ccea1c20af419140993bcda448a27e39ac6221154e8a5f66d045f38f96acff7bbe743d701d07bbb0dc0d78893844c6914f9310bbc070ced3ee7646517e86da0d7293a442f2b69787821764f159626e6008b05f2bd2824ee429d474661e98585a020a620957f37342fb95ee2e5d9a5e03c8b3beee29bed0203055c9ca7cbf0ececd4c2ea816f1bc236ed2b733971c0f301af37e71315557bc9d8c8bcf6f420c63a3409697212852a8bcd468c683da24c4a72e505641739cb5cf7fc0a99c538c9faf1ffe966d82f8bbc19a4db9eaa03bd4909d699696fb9d7c44e0446e52b7e6096f811907a2ef7bdfa80827a0c0de1d71a58deb9cbec8316a381861220acba6ddc0620a4a249031325f5ce83bfb811e3fe97338dc100d01ae4e3c3c0c9be9c0866d38d49ecf9b0f2321845af69baf5c132e8971f98ce52b3f83e30e68ff994849a877d27a01272b6a74bdb505620acf04200ce6cacc7a697ab2b960606f65598af5b64b80146cd2aa427193b800187dba9f67fc189a3256fd1a1be19b329b825704d51f694174716aeef97a3982a16463e5c1d05f2d980dfb2c522e284dc23ec43d44af278a30ef48f1c1f3079b7a9fbf9cc3f95f13d767b882aa970c10a0d24e9f0c60038e28cc1ff9f979544d7812824d6f26fe97799c940a5f5fa4cd3885a2c88877c06ef77260b9243758495b765e13915cab49ae5a21c5b9d74c997db1c6763ca0d145622c25a64d93c2d4a6dc92b8ea6379de6749178dbf260804a52278dab96c7fa7225bb2378c4562ee873aea42725c624aebe032a67304b70ab81fe0707e596bc87a4dc61dfa4784087b006d29ea34c3e2c23b3cf26556906414ee496c886b02a1e0b98fb7b499a6895bbf929ea458ef8c580dd5957e91b84e2d500b06314bf259ea7397fd2caa237a28ce6c66f527bf0e7c916352c5f14bedeafde5e6b66cbd7c563a6c5e0ec59b66767a8c68e9b92d5525d72d0a17036550e85afc01f74dfaf2b45b057632ca3417ca2baa757e1905a11ce4b3f967eafdc1217749cca5d269c5bd61f9000a1f2f6643f866aa5b337f9c6087100fa9d7db41bca27578b736cdec71b1dbdb3f612d6c4956a00c8aa1c7ad378a57580c6d2b02530f59f17bbf8647eaa1073727105c4f399380558d05b6ad29c5075cdc8327ca9c7a1e591348cad37ad7eaf1e524b0b8e22598d79461bb0c1692e30d4ae63703d670672514e08cd765dede5ead32648ba0d4feaefa3fd60669e3ba66bb23bdba6caa09437dd0eaa23fc7a77e6615f4d49840b70ec06c09d69d1cb61816a6024f950d6f2c1465f3dc119c62db481614b56d2ef4986367f5e984d291ab96656a86ad26a106b068c95ab8f2f1d8787b16bc4dce59754dd728789386818522e138de85f993b064c2caae787d61ba7b71818416c9fe698a425d78e86817c8d3596222ee7455a348be1da690b2ac416db0e89deafd0e42da43b7c88e087fd5fa8383cf220389f0a17d37dd1fab500d60aa9769ba35ae6a377d44571ac4259554235e511365230fbb25543e84a691ca4b6d9e780a6272b25b81538f1f5f1a8501daf5f00dd7edd65b44e32ee0cb1a306e2d6e50b64def122e182d7a61bc99e33f9a40373325ff676e523ac277f3e24701f2e3cb4b02816e77d0d55032d39abd6879cedd4a939f464d994c39a7fc7ccc41bdaef82829079ef419affc0e3b003ed614331af88f8d235c97a74e2ff01dc859eaeb42e5bb11d9228255f20a208c8ea748ee24ed26b0fca0585dfddc1f739f40caeef7252d3229363ccdd8a6809da0fb504745bd1ddb71fe460ad311df8b6b87e23ef751a84486f887112ebaf371efeb112d1fba0d2b411a8aed0a896302688f59f6e3646530835a8bdb8423a2e2336eca449da845530a5aaa52b584fb8b0a8ad5a0566ced6755906e303c1c950ae5a7ba6d420e493327b217995407f4cfeaf964700303158f77170ac890717639d2faae6cf9f873f92d121030d622385ced4056c213774f808c15187ee4f17c87c7508aac15183573ba795aba9b9437903e860d6d556cc586d3a3d102ec5d2f102e29f2b603de99a4170a411ae902dcacda919819bf79b8d13767dc881508c25406425f088d79f993552a1a70cd36b19eb7b718dd4b873969c3e6dcb1332f2841596fd927755aa9b2ed276aa94397753311e199b9e7b4f50a609407d731eeabf5d79b8c901ddef2ffde04859f19d73a3dcdf7310e5dd8ce8d27516aa08f9e33747c5555dfdc9a7b119dd193936fab2af2afab108e6eadeb7472db16e3b0f63a574c6eeaa15914f6c213cae8c80e86d3b5afa0d829efd438de14ab37232d00106cffce99bd86d96630ca62d18ed6d98f88bdd354d88a3314277b1f13fd470a972e2d50fe69cd99dfd73d9764992e8db72fc3253b301f3ab87216076b7904d9d1906ec4a3172a2078d681076fb4b7c1182b21ba6401742d09f6de3a656806bae872d751a523af7c3087fba23704fb0def9276c2324f1ad1ad96441a8d1e5324e8fda8c137e8c7148b2a7fdb0df0f37b3221780619a747e0bd194ec27cca35b1e8ea9e86bca18e159c5599fc5c453582a47ff8a6f39126de1e412150209ab882d52229e4be33c06942f2006edb0179825c211f29a93a8ba89df076510264f48d16e28a5e6797253b7fc8ff6cf40e699c136acb6e6ef9d3b12561304baa0cc7ec027b6cdaf1bd569545ad8ee10ead79195436cc3fb73047be1af2e64fdc81e9cd652633089a6198c8d4418f44b3a73600ad9c9eee8cc0477f468827c6d216a34c558d9542885bebf6e45557dd983dda8b7768930efca2f074d9975159444a0a5d735a0e4283a22e8181e59770244dbe3af28a13fefe523c5ed5370cfcdaaddd5da3ec52ed27e6c42b668f71c576ff9aaec86e2b68f6b85e3807fe9a145bd5d6b960e3c57989f8eb93b0a760c6045a94c10972db62b6e85048a4395816ac668dd3c7db02827a5ecc520edfaa0d2c2b9f8f891523e6eaee6e2b625a916d6697872b7dfe646c4563f327ffe68f77eaccc323c35f54f83270d758aa3c63d6316266fce8ee30ee728f879cabd0d062b7a11bc454c1f4f9a84ab874ea965d48c5a8e5d1de9362bb0de0152e6d1b2dc73a126f9076cdf8bf303cd0e87db5b9abd3fa7f58cc8cdbff787a63e3a47e6f13731c9bcaf941054a87a83eb84d1ebf18529870ace44fac74d6b12bfde0a2d4cd4495490a1df89744b1f2a5d02dfd3b29c31a84148b7004b571720dcea53a8f868332ebfdb9e9af20317ed388aded27fd3672daa5c98d017bccfe940e59b32fed9589a4c7bb50c3e9bb34d00c5b9fbd02141b6b6918126bbfe952f06d0051e37181403094368a9fa10ae9a7b7c1b0c9728649ef348f9008e6d054fcd43fd9272ae013588989ca9730c667d2808f3dd6770cba26edfd8b16411c861691175e091097ca8cd6229c33dabc50237c2e68dabe9e573164bdb0ac08d3bb532121b155b1788195cfff0e14ec4c52e4ccaf4de45758d7cac9417b463da32f77c16500bc36b94439ac0e9955285ca3e170dfe85544436bd955a9adf94f1cc17da7e7f882fb15c7b0ab3e49abf34060241159f17ab7d4a166f20a441bd33bea27c667181a8839855b0afbdbe0e0fe5505d2806fa0071d48892b35eecde96a72610930b654326059b54462a072847c672c824575a6ee195c819751001dd3010656b8554600144d56ecdd31e1fcf3d1727908ab2c61aaae189158a187c8c3262b87fc9dcd01c257b31ea1252beb706d0228817056db2606a795920f67b30bc4e01b2150d9a985261c3f518f00e0c6076c1f7182be1785f7e0299740419664c15dadc772b40a942b272817539f4d11ca42dde5a435232b928e26bf1b4fbe2d5bc3945fe76accacf6b3121561e7c42e57d6e1eb92bf5d1799b575f740a2cc65177070851b6170621b823df3c6d813a1b1a76952213db6cdc3419f3dacf53e3bdc7cafc9860d15ba7e16d4da5ed73984029853fb8da19fdeda5960d2799cb2f0d9907ff16af09e5d3f099a329fa01ccd15941cec9eef2547512af1d0d9723ab97999ba2b73092263a08342102496f2e1a136710851f53f7c47a6eb5e61ea24d50cdf8a727c89f871d7ea503cb1141af6d78dd5a513b78e0915d047c4d535d385a9fb939ff18f4034847c1a3908a5aa0abc1bcd18dce4e1d0cccda0051d31105616eb6738c12abbf90df74c66d16085bbfe70c91fbe08cb1780c52190e0caaa97c22cfe7cb8beda999d2354ce8fe737f6e61b1069ca10012ebb643570d177c377644fcb1070d6f24246090a388d9515517ba27819b0d3a3b8073671c721644e5a6a70288c6e8b13464583904660cd1f4bf21e9cf357af141df57f638dc683a0ec3ca1fe4917fc048ce1f2775ab1b7f638a1e2271cf48ce67c2732b9a925062a75783c5c0f8349b14d30b74638fc06436325fce5f51e21c40cbfa03afb7b4adff8553ad372707ef5b073bbdac205da151cf3b531551cf653df1cee7263ac9aff87f2551fa745d29f29dcb8cab2f802fdcf44af6019ee14e8867cc2b6811e919e4b93c3740479472ad0cf4173b408d3b5e5016fdd5985b0d2405201655020dc36cf12cf4d089186c82c00032262d19f89d3c195e76ef06db9bccd1a95580b03a8a2266e838b5b2790cceccf66a29c8ee7316545473c411eb4e4206087338036512274908b05fbdc0f39730f5b46d7202f8f7df4f4e9acc76cfc8e202dc17cbbe95bf5e935a98a151c3d88800204ce1116bedee21faee10bbff6957604a10a5fbe1d467781ad734c406d4603b4aee2cf4d007d2caff6f87752f7a835bf8fd07d629f450c5f396e216bd4f3ce1d18fd4b386f73ae1308642b4aa0ac25afa7f17b7d5ecda7cc6c4414d5f5ac8ba16ee4f3b46ef93ad2d42085a1447ba9d402296c83211bc08a1b00a1ffe0b9aed2e85e77ef9be6d760d8223d16f99b97bb8c658e2cb478664c9ee01705a8e27ac3e3bdce49239a9c14589fa25e91ba56854343325cb4b00e4a728a4567b5169fbf4c4091fab2ee6cdc77577b0ebee4d6b124b58d86564c4e0437f10b162e1309f17db204b4dce4fe03f7ad9fff82efea66abb1b83de917ed5edef9533b25b0904956b320bdf6f712290e0b5f8344a706e0cdf8b0cf3d716067ca34ee76d2fb2505e45e1432a36584ed92cf58e24f5be3080484d2fef3151fa9b8393846b8b641c521b15581664a32bc2f8195edfd7299b373d23b7cb12bf42def5581ecd69e094bacb5bbaaa7c546e4cefb0b51cab5fd7150e2700de0b9e9e6b467380135556e6e67d7461d8199ce70ce5e9dc48270f54ea26eb7c5e46762fb63ccbf5699cc6df4bb4c05eddf16317b2953285a1d9fc012e063791509a1d17cde0f953358d2939132f24984c333acc4cf269b068ccad0ca9b1f8ea550f40896a0c02b817b82cba035ca1cfe0d95d5b45bfe84077559b03b4438119b9719203081af4c4c2a4c37c4e4dca3111b16255c29267aca0683fb11c15d15ad4eeea7759b45bb2f8f9d63fc2c7e700018f226b05e811423046d494d4fd126dfdf03cb1f59f48f86ad96450471bea67fad87d7062d8993a78efdc5f0a06cf48b26915df89b7ced21799296155ed465ee1464c87253390559add98501d539ebfa2b07e7deaf34edee16c6da1600d852e9e38a121ff905d113702e4bef4b437ed790fd4a11dd8343737a67e30f83091b83c0c66a9d4a1aad3e9f7742df8aac54d4bf3d79450514667ea5be6e3e0da32758f2cf5a8cb727acd48a293ab79551eac0a7f4b3534e17e38782460cbd87628a0d49e8b9033cf992b702ccb330a56196744771bd43ddb1eeab59ceec72230882a6d66daae847589b97d901ace0d1ff25e7721906e6bf01a32b76eb1599e30c227ba95ca911cf2303c82be9ec59acbedd9092afc9559717557296765774b75ed29640fd76866f23ecba2f23a78c5e9787d244d6720332ed0bde51107c6fc26ecc7032a2404ea0e4a50538626aa7bbaed36c07f70b5aeba2432071c4283ddfccdb61006aafe5cd3972d089d7dd930dbcbae7430dbc5dc5f32b457fc37f7af9c97478a20cf88da9f60484f5a2cc3b15ab62181210dfd49cc2269d6639a87bcc91f1e9b40a54db6e83fd8a69b067f2f3431fc4ac8e99219e85405bf0285ebefdd922abe932f948d0894384b5bf6a4168ec643c3184552b2ae23c0857f37cd6046cd6cb72c977df58334e1c5a3e9307233010d689dec7ebc04260bbf84c7d130cb8389f37754c58bc2f35314667f8ac7b2f529e327b8b7debcddfbc9de5422fa85552b30c1ef3b7fbc28070f346fc954df1821456905c63e4fac682e7698a7c7be378deffda608d478a10da22a60f5be78d86f174f8374d55425fdcb7e66f37a736e54d624c6f2564f2384fa15b50cb7b3e7cb591023e8f75bd50d8da3fd45f08926b8bcfd16b87011093f10484e7d558cf1e4e05f14186fb61680bade5c908da2bfb7c50d559787208bfeb177205b55ab4e486645c1df453b94d585ba413997795617a44025f0db9a70d94061d4db48c34a3a9ff539843568ddd485ad5cc284e477090710ac12d5ab569fe4f87f3e494cb043c84f8612fa43e62a386d22b3acac56d083061528367351bfd7b25e28464731dc815fe0638f502ce2405465146156cb0a6c74f35be5b03a49407f9121eda02311f022d33856095451fb57e899ec58236616be91a8c474b7d42e6494f1e28e377f4cebeb0eacae853ef23244bfadf7f920aae0313157f203d04214de3043fbf75f26df2b3102298b28a80bd855c82e751626ec3f33cae4886f214ba118fc1c8bee304759a4b2a7ad33f9492a98ee13ec60fbb4957d13b7b0b158f1d5028d0501c0c7e1044ca2b0010412e1f086f0904eeda719d161b01dc7601de97ad62c9450e106fd28f4eb80df2ae50056f4e4510348454d016b95e3f1f38743723ef21111e703198a70e8cbe70a572559fa9e118ad6876d159f6526f9d9439652de04b17c6f745c3e388c5479e6000b33a6f11a1d39c730db506ec2b79b16f133415a4277f6783a7b4719be146007e8959603f919498debc94a0224ea6920363c4dd7de0b1314b69f22ffc5ece0030d5e5a3ef43fd80e6c4769411b9e9ec1259f980c2ec7a10397490e166b151bb45d08f14cc2af39b0113355860e3b8c07280e0a5c2b73caeff0351a0e0e8424fef4eb5bd90cf63b2c1aa58225e89d04edc08adff4741da474e26e7fba481c7fcd8f647003e3b14d3ebab7bdd6900742ff389a7e9de5ce163df0ed1fe74d7461e2a2e8595dace40670cf5da64d21f3c873ab6d79d727d9fc1e92ca4668d7faf3b849343a2bf4e2a36194a392977b3e4b4bce368519f86e394e24f347c3febe8e03f2677c4f99304911fe6d070c2804ecace3ccc7a5b4d9de840208ed1d3b33eec2b3ccc8a74fdd2ce2c6ea1a39c35c3786838ae62f2499a2f6d52f1f7bd66da6d84c47094a4a48b739d54ab1c0c620f7ac0f230c3c41b651a3ea1409f2de3b674e34018929da45604cd68a074af5d9e48d581fee328df8e7ddd0338daea815841326d4b38ad08606bb202df8643108f022d171176a17b3d08e1d156021e2e3969fe394aedc254cb78f3fcd9c6f44603c41886d6bfa243a34193be308e76412f523b9727b92692fc0da77d5c5a89c11326fd481e06e786458bd2b26f46ccb905ce9176f975a291b2acbdd5afdba23effe1e2d1b3b57645a2aea40a225d304854b8184e49356e2d3c35be78fdccc230e65425bfe25cc2b27fbe5076f07838656b598014f1dfaefdc1a6721e7721de70c45429d3ffbbaa7fd13faf25fb70166b9ccc5044bf1ee9c5c89e84abbe2a4b5c7aa55a7f93dfcab313d05759ba0f3c32034b3c695a4c458fe906853973e07d1ea3f1055a6b4b43c794361d3403d72fbfaae369255c42156b52d451a573cb6a977b499f6ef849246f246b7ce0f876bf7591d855acd0f3aca0742488e8418581e8a92765d06c2f6bd352423ab60c9b6e2ccc6d2a3719b8ce1877c9def4d88367ed7bdb1433b995ee1bf67e911938133e1821c697f35654eafa1aecf0f8b972e565918a85318e26d730bf8d63d06234ead772ef2a9b124b495ba125e4e63fcc637ad15ba747b27714fe3091179b498e902f2fcedc8c7dee8f4abc9c17654866eca8240239a49ba592a543e65b4e6c56f4605cc2648fc3aa14cb4b10342ef4e523b7849fdee8542678a806b6f363b99b72353fa3e916ecfe53372491b55ce268117f3f1e3aa13884a874c30c3221ce8ededed075396d02fce6bd59bd7e965efcb7192187284b94505a05c4399452f1fdbb258118c5e022ade6e91adf20246dc88af3fed64bf86bdc5c8948e67a54ae1f6010798cc52f6b3c10bf45705f83ef45064993a3a727350d94beba3f7375bf5eacc4bd97b84848109bedb1046d9b5aeb45c56f31f6cb071117293f172608866ae06d966b8e9c625b924d1c0c9e9814b228f3018543f84acc4c1824face591848f8abd4337b16ac78cd46cda1f51a442993e083da73816e4aa1babd584f780a1f292fc5b96c4040d073438a1485015317202b28c08006c08688b86429b9999108264fcd50e8c1f2f8dba992e53dff39eb041e485fb386db78ef260b46c483ce915fbf24af9dc03a0e94af33ac585828d9c0c88651e422bd3a174329263e1b12e1db52d14ac18141fa2e4bfed974aa408f17bdf7c80449581ab1572df1806e3fd7e8a6897753d0f929d57ba60ccc67c78b961a0efc6d379642d3ca30fd54c251f4cf9b459dc20a8a8f5a7aaac62386cc731df04ce14c2d82356da1cf8362f72ec35a3c921f4cd351f3acfe0b72ad3b4ac37bda52557c4aaabb057f34b2b28c12d69e9ef525091d96a59657e93452d9e8bfccea4e6866e4bb1f7e574be8d9f40c5652541d9b180725b484e71ebafd50690204357015cdfe9fd729b527efcae87b8dc6277ec80bc0551ebe86a1b43bce7f2edd5c9e1dc59f89cc1117ee1b5a9ed39c3116f051bb6611b66ab94163b886e2ae09ddce0ad5323624a094320d7f85a4bb1f8d3f45fab680d36add5081e800ba7707529c27b43f87c9bd15fcfa1f59b5b551ffb2a64712c9c86df825996890a7337df003ed4fa339181f66eeb9b560b51c1359e9ac5f3b8a6df29910506cf3b2dda1b8bac9874eb44cbbb4b1ad0c8111d2cf79c05e890547f92a7ace38949e994a1b18e122f395681d2b3b205adaf1e6cf38ed5db5af9d47fe7196ad81a79ac23844f5fbc859459c8c55a36c0dcc03adb34ced980aa1cba231e320ebd1be50b851bfeff923d3cbd2559b70ab244a63faf7821b83c97a31d3cdd1e2ccbefc722dda4b3dcb5804f74647fc2914d940739281ff6b1c3d114dc4137d561bafed46fae57497f1a495a3dfbb2f3d0f4a58757b8b0b9e627f56082ef83368f0b619d3641fb77e43bfb13c2163864cae53745679bbf39715798d082d81102c9004f339bfda05b5444b558a8dd8a32f6986e9202de32a7521903cec1d10b1073e596772020a40ae51d058cb6ceea8dda61546cc2ae80ecba995551458807aa60e9b5baf897c346a41a0256d635a5dfb6c39e83ccf7daed6e3d389e8924ef70495bfe3ab670a8fd04ff2cc87783b5175abb11ea13a2f654637baf19f0a08513801777a30bcc941c963bd6906af6d3f583d416ae51901fd617dca6fb563494f7d867a8e93cffbf0775d716f3d7578d667f6ca07e37bbbcb05a312f6451cdc784569671fd5cc78071f4d6917ef84a4db6a34fd066b02445e788d60fe546c46a452d85ed4c08d4c205b2bcc80b2a686f9a8a733e5c08c52bd8b757de016163986f3a0f52cef1e36953922faa8a969d45184045caf49b841fbea36eeea07d8998c784750e6b874a28295e795fc1846d732f02430bdcbe97d38b42742e2d20d192a2e5c993eefc9ba8417d86417bf30b567e69d08e4cc52c8d21fc8d22688e33650113bf6ce96da28b505562fad584307c50d33421add8c9cd35d11ac87eebf54725d40360eb2b43e026aec80fa6be3662214a3ab32bf5bf8d6066ec044345ab1a6645abe954e962ca443dfd9fead63bc38bd8efe84ec97a722b654f94d71eddbe1d1e341ee8ff50cdb88ccb2647d380fab47400695b46b567f48f62290b69d32f1fa33e3dd8b14ee1493d73f039a9b7fdef7856559fe86f1e8321e3c8e00442e32e4d0ef526c6b8dd1156597e0fa4b85e264da8d950deb22734658b45e2784c0e95057458b4282fb04585b6d9a9cfd68765beae015e83661031a0a5d8fb17aa493232b89677c33e7f76d97d403e1017c81f9a0304a1a117e65fdade47ee69a07c352b16da832053865a8351ec96d25b02daa68d89add588a26155a53d58b6b72ae4080d69c7bf9a7251b9d0c61e6cb3c1d44754c38d5f911e829b3e059fd74c3efb14baf03892f252bb073be03061b8a11097e85383cae75891588d96d22e2ee61a426eb71bfee9f3a2e3da4b4f8fe106fb46db112b49d45d7a0c776ad0ff9b6b200b0fb60c81bb9949e7272deb37173d66bfae25757b39cf645984d0712d24c7916a374a5db6f95aca66a549bb55bdd8f0da70a821ded88d4826cb1cb289991fb3c00ef893af8564d4f7b24f830ff4fb01363053bff300f318dcc7b1a853f7088387a667d6b2c46d97bde09368216e4c3870fb63f3ec93c873cf81e1e36bfa0a2fed500d542b9611f34fc097393681236cb9961cd18ede881492c946d99a2ef9ca8e7d445e5becc917a0acaf4771cb78478ca7b11caf04e403c28b984731e18125aa29fea8ec73d548e838189f027113da4df3e0d239cac0a720ded4e9594bb2166d65adaefd204e64e4c65cd8c223cd20f58c739ca7d72a1a480cffac1280d52782ca10d455192891011a822af61751c58af5655125e53de2a4eacccaab0f5dffb3f672650fd2f738182d9a3b586f0bc679e41b239bb4815a9462408faf491f495fa00d2b7371c9aab71255a8797c5181932ec76fdb4dc690cb04ee57149b5a9fa2eb63c14928c7735a435645f8b00b3f19b19d774da9422691a80455c054b2c8b9c8c3db766047bda90dd97cdd9472be7a983408dd040788e9da23e4c57f7e4273a9f7c965c91f700354e0dd82e329416547df5d802e1b9074833bf7bd8d3ff1b1da759a0b19f20ec4695dcfe6a3bd2f53b91a16ac494afb241494a3b9aaf35c15dd8de6ef38c83383fdc37c4ccceb86b8f3e426ee4f1174e9266e4b5ffbeab61c9e9322571236f30f84946afc30c31becc3de8f8b80144e545f421abfb60ebceac3889b23e17f7bab586aae19b6ddae2cda0ef55cdc6cc8195b09b53c0094bc01fadca4283929c41a0764b9516ad2d87a201931d1e14b28c41907d14ddc45c08eb919e77e77d046cc708a4a58f976fcce2ba7068965482073598cd4d394b5eb0d0cf05cfd865923f03bcf8905fc58684013c4ffa49698bd6f1eec6dda0a72295fa65f40c1f7e3f3993a95e783a50ed31192a3f1107649cb8843e6f0ee1d6ea556a7c4fe3048993967ad2a0ffa7421a50f3190341e0a0635c8e0e329503c1368d5fe4bda45e6dd45b187ba59c32c87ae3571aeff0a2e6a2cef06cb536393a210fea225a3fdafc604b70d35dea68fb956fd51218bb32ea7bb9a2cd806e4f5eea1ec5726bc86fd5e4da16cc157e448b747206e36bb9542f6a2dfd572a2dc1286e8cc8e2546ff4248b825eda529fc1f59dd71426c4ff491607ec48016c23ac4eb65f8621a0b688c365de3077c943ba9c412d95b8e9d8308881a34193e372b566cdd8e8106e9c1049c093a5bc626e52dc7c3a2139de093639b93bd8a17ec5a21f43a4789f3d57b1968a03f35690d7d6a0a7f8e40213ecd502feee39a75e40d1b796405dd2b2eaa0f90a21830e7c3174b0826d77034555d4602a711f161408c114e2863244f5fcf86b679422b14007fc90a50f4ce750546fa66667825df374e1ba06ac0ecdaa0a6b7b0c75571e7746750d6c9701d86db637fabe07a14195aaa0f1d3f0fe564f80bf435e4c7449d3340e8f5ae7454664aeb03a42f3344e62b0e47815396b143ff7047b94ca7ea55f0b2745acd4dfdbb2120f84b949096472a7d773bd50827de98a4ed80dc0c41a3d0566af8fe47511e9923067f2a46286598b6314c637754f20a5721bb0ccddfd3b484bcd30103327382a55d73da1dd7c0ae66e5efb385e9dbf42cd2b3bec8422c32e8428bbf37cbf190362e61392b3bf1ef489a298a3a7a80d6485c62c7b087ec04d0a3a7df66e2e2d91dd9e27a98635b341f8652f2dbd824ac7f2bcc32c705717dee66be25c7bfac919df4899f370e1b7571e72698833dfcc69b77f1c9c0eb35cecb9876ad2a83d81684129be876a309945a455ae400e58166a2cc2f59333842e5cec385a5c4765b892a575823f48024d0bec9599b9ff7fff2b206f70f22db68d9aa5992f8e0931bd1ee20b786cc6faaf2fca16c1a78ed984237684c1630248a2ad0062a258c9dd708705c22cc558ee47033dbb309d0b1d0a426e511819e64f4d03c92f4c5a5372c9b562e76243d7d9741f8ad6b7b35e435d0b44e88e91906422829c361472300d8c741189aba9cd0aa0d5c08118b0d139041016a33b6fd618025ce51d05b8c709325abca4f76f858b5ef6100b5025518260d9bae1bd09d7908d4c8143ce79de960f7bbb1abd958c799b8ef14fb6844ed90fbe33ddf7e649c187544af4b682d4a0deee9cede1cab767d5e9bf85193860b911c1db807a850fbb7713cc7e773e13fe893ba15fde5ae9feb282d2907a67fd4f68e8851515fc2f3e203a2b85e2b0f642ba59f5f426188c5a06c1ad1fe3baa3d8b073cbbe530bc5a4363f35078303346bcc3eacaf742c76493e92214413daf898cdf7df5438144f4eaf84fb3b37542d9a04076eed97915df39dc640e88f3f5f63ae0571021c22cf540a030f5e68b511a8f0234b857aad509af8e4e0b6ef003b0a1ff43fb6a97fd9599786ab73a4c4807d8b99c819c83a393e5f6d9e79fd7f8c547793f93b7bb58699b10e2d05c8954a6ae8ec0720429c4a18df3df0dd2431d175a18b4a1d6044e39901a09d54a3d163294d0b5c6b94921a68a71e29d1ee6375c14d4a9d1392d5e6f6d00d44499c34821e8bfb8eeb77e2eeaa4e932dc0d33b89eaacfe9c448c2da9d76e9cb34e610530b76a41dedc0643994f10a1649f0cdf4348862690aa5c1ca5860e672212e175d13f06d214552aafd0719b29e41a6dd8b67d15dc2d4d32dfb0271733470afc98ac48b2e01c316b2694eba087f207070043aadd8a49cf347b0dbc23fddb913eca636dbbc358fccbb429f1416c9aadd275d4d4cb0adb3a95ffe82fdc49b6e6963ccb20b7bc402382e5eeced82408b8427fc4a37e731ba848f77d70e6cdf80702bdd24ac70b080fea8239a2f45e5e6e819ca9216416afd0067db3ed1a1558c05eb3280910f8607485bc2330c3cb89b8b947b6670b7b71647563db6206685205030d6b9907ca91083dec90778ffeb483bb8b395487d7d37daaf8bd606b57717d95b631c9b7e508112678aac5c060a889bbc9b67f6a917fd5da07bbb84d5bac76f4f6e90fee39e0a8f0828fdeaba110b6623f90aad550defb96c33ba9511dcee570513a3fc75e44553298d0800a5750306dd8043c5060c9c8e4fc69576c3047b306e5c357cad9efdbe0b507f46c665204480df24cd7e1e2c34e0152bf75f5373e1885f6809fee8eb3b6ea67edca6ee128e9cda6bbb5724286cc4365b3a07a4d445006b4af72364ad03b25e22552e68fe834c4a286e07a27df38798f24f062564332684605bec7abaecb8c8e3f73cbfff6e4f39e87f535d7d14edba9b61e3c13f3b720d0055f3f649a0098b6c5fdd6d1ee100a583a8494a6b11cfa2851071ccfded896e1a9b46d76d81b219f6e1681a79037fdeb5654530150c14e8d0be60e2fa800ac2d395afea7ededbe77ef7e41212a4c43b2e0dec1be9876de7cb8cbff242d58cb2dd98a7e2b0d0dd1241d86c20a8fbd9c27d2784cde231b7e91ef775fde1c8ea4abc950737f2aa419d6173693716cc39d7b6476d0a650f2994fe37eb1f604cd9ae5b78ac70b0dd1ab43bd7dfb36adf2ff7fec5914a97bdfc35b565767774a7eb41f33e31635ffff93822c0bedfffea3504972fab8240cf79f524cc22af1b41d3dc961812939467f20b9697973a466e82253502c7c529d1b67156523311fa5171caf3086cbbefa47e1bc384c3261736d6241f9b922ac7f529d5886cbb0eee136cb3d39263bbe581a14807706e3aed0f02cbde7fa80b0f928d5b98c66890b238ad8697455cc9481868f082bae169b36974da2c6961c124ead7cf5d0583cf9a9cd844dfe2e36f0cdf9dacafee199399408196a0888e5f8a14734f9117229d1388041f4b2b719e98dd2d2ea4f9913e127092cc2bdb5e0eae410531903859f507711d72c6b60c6f5570adeb041a4519e59e5ecdfc92a58622c161d723bead2047b974223174ec221eeac6e5c6a07be31f5e9c425608bff25bbffa21a52ad504a221898adc514a236e33e9869f1d45a20cd313ce1b185a15c95f1441386c93a5c773351a705c0d610b83ab94c21b41e58a1d2a4fc89610405d002b5665e8cb130138fab630ece7c25c8d40f8b35d220aca644af6e81f8314f28a5475ddc9c0311b5b0abd43ec5569dcbd3598d8eebe8435c2877b4b64290b4f841ca8e141de6980083e8223371d7b25a69185ecb2088fd89fef6dbc269077f39db5574c259acd9313fdc24e832dff8215423bbe72bcdd31aa7a431f00d811e9c23b04b866a42e231726e2c0f89364e52c34f2d8728771d2c814c8f486cf2b75981eee30f11b344c44e0d8d31acafaefd6b3e5d15b79843b9e899fc9582a6873867ca6037e52dfa8bc651fb53304779d00f27586cf3bc4ddf2122fa6b36448a334879789d93b5aa4b36f5e3bf4697b8cb95de41b7b3cde65b21ccda2458effcfc2e68f75d30d16cbb20d8c71f3c3d0cf8f7ebefc6c3515cee3d780acf33f47f9cc94d9957e5ed8fc5b19d88c78152347abb56e2ec3d4471c85310c9728c0949a3f2239c884b214913c09f3c13922ac62bd9c790d0b7d3411e0352544dab6a72fe1eac417bad018d4c2cfd771e863009e3cac3a68efd9b878a4a4052dc0d7bf529d3b56fa02bad3b1bc9e7824c8f50caea164515c4c6781a6eb7a916561c6e67c958958ba126bbef3d8e6c4ef4880fd43d48324ba46cbaea7dfe82bd218062252f076bbc6c6589e7281a3ece45f5cf75e10c1ba9751fbcfc56696bcda689667f532377103ba3f99fbdfa1f581b080de7107dce95b57ee0233903e471177b3195f7b0bffaa6965813087975f7970c1e812c1e7ccc7d2e4761ee6364e179ffe8b29cf7b23004583a3c3b8d1a2dbdfb027f26fa25e8148aa9b95ae55af69fe6a8b2885a3b4a133b4b6a5e0cdc2fc4012e4da28253d63d283d8514e7db355e837bab9fbed82cbcc3737b70293c3fe31c81a3fd945e321dedc913f64bb14c126d822c521ede4ca222db47334803af753530f51f7e915054369038a7f6907ec00283d84be1d4aa266b9e6ea10b4a3a1fe77ef83539a87074f83aa67a49bfa466f021df5e7c242c2b379cf86e25918fdb0cad6e01d057dc52745af5c97ac1a14f44afd6d0ef30549c859c4586dd544904d59a553af566c54f459eb250e1e915185c0a83e242cbbbf468bbd3a0b830fb6773bf53c8583ad17dc66ac014dc82877ba97a663f9b2e6cd484ffe25cef65aa63de3190c47377b66927d1a38fcb244b5ceebff208bcafa3e072cc0df3603fb482371c69228183f10e7283880dd92b881a0cd06b9ab466bf741a3da0fa5bfadcc3be953e7db7cb43abf940c0ef590b217e2f1a479aad30cd13188219fdcca5330e50add2b569a4fabb6ea9743d021f968ab9b5cb8517d95d1be1e7a5a6bcd9569208fa8e64c44d652b1c4592d85417110a1895fd4d03fd89e55ce6b282f99b32379340befb66a035881f51476f954b09a60b62a24e3b20683916726b1558c817f2f43bbba1ba4ca84f0efbed1862f767e3353fb57f37f067ac0f92fc9eb1dc9d1f1ee34bce856540559516f9bbaa4b4ffd072d2d55e5dc6f30ab71dfdcf1843eec48874f253c6b645f66d9f57884a72306941e3c25d7a196003ea576e5647cf6c60a191f08c775cc853214b97fa436b168a704fe422cbc586024d6582d31c7b208708a44668ca9687e0381d4c2ef672867d3b64042b4c9ccbc6571da8595961e08216dd0d2c2ec4c776a11fbdfe7e9fbddb8085695931cf2188c202948bb8162a6fa87deabb91ee291a4d85564aa9c5565d0772d3281d8e57ad808d872d897575247b91e345a6b4076eee43387b138069ea94250d6806e794d1776274b762a2e5abfeb70b67c2ec96db92c09b004f22daa3d21b8bcfb93710fbebab40c2abbbf0f4fa5e46d0961579a81a3bdcefda84c421b8fa52ca6b01a5dca361273d11c9cafeb778b9a994c2e47e2040d45834b1a89bbb8dd429990e5e1b7520f50f71483765b36e3fb70fcdd6b1e3fde634aa68aee1eb53f5be2a273c08dd73385353c3efeecca53a3a6964a0993b933005f84c1c5167893978c31ddc9760575a05a4ef22bd602e91903235b5d982f68f09f486656de35e991267327ec09adac9438c1523fef0115f190372fda7f4b9f3c7801661df18a3664be0a295b84e4db6cb0737bab99778124b54f0ce252a43e25da3f50f4e132d4a54575f7b37748d0fc66d9d02c80b0ad985389e36601e2fd28c467ed4f629c9861cdd637715a8a2ac5b6c81153df436c74141466b56e88f9ca44427a24594f67e0865b3fe6dc8f2c571d14edf26b16d1c2cdb3deef89bd5c39af6366b13af3330e40e725a52bee17e0b0306fd936a690bd80408f1290554ffc0c22b7931067b1aa4e7fd70fe5c9a13e7330b82fe2ca07f2851c55e8894b0a131b01cd2410c219960d0cbe7a1621bf36794378c43a1a68deb58bd61dff7c0567ed31e16c3d0eb2bd5a240d8180581d9c5b932e992b1348184c6c5e3f385b1c07e746fe017e226b4c25870586fe9200546690784e9ddbc54bdaac19ff6df8379fa726b3f0ab8abf9fded63f27357fa061a25f0128ed8b30e130caefa2f4c14bbe984b00e47aed12ade06f8b3f3a80400ce675fcdec36463fdcc0ad09f80cf177ea227f01353da55cc87ad94b3006642b755089c1703df341cbd2c6413f9a2a87b9a457c1be14362b7d90aa73f1fda659e7545b01e27070ec52f1de29711735b824f6c18e39e1f4422ca4b887bc6f8fd74f698dfe6626b403965b6b5dd10db46a04a9704c26b681bb2073a1dcd20be191bb62f8334b9265579d77f2a871e26a796ac7797059afbe46579058b5440072e2439071871f7771902c317b173f17b0720b9b7dd03fbb1a6ce2302cd301cd140b1736c6d79cc75f7528c583fd1d1e45ced30d9463be4fd002ad0a25a7e7baf6a9180c99dfe13e0ef749465b7eeedbb3ae4631d0a56dc049e402d3ceb9d28ef0b21a5bfcf44f40e7b7c236fe8fd03924ed8f2f01720330c7c124eb69e45e8875924d6eefdb0834981d4c17be97fbc167bf44cfb35e02f560b338d12c7ddcc8a84ef3faca795fc5e63254a90cd99ac4703cec943cbe9c9a4eca5cf6c125ab53d11e9587517301beafcd9312e266025e850ce1682cee59a61f71751ec86247ebc328f326fa23f37f3fed31d271d4ef9f9944ae76bf324e5561c8e1baa673ea9d3f201bbc95a99cfc5646482c88e7d229b2f744f4e19b8f6e066c81ee769ce99c884c5089bb93ba901437c2fb0d8469db749baa20f94df2f978ea121ba2d88e4484f1cfe4960d1b9ab770d333778df0010ac375841e42ba6a3efe55fb839a043f8b2aa4f86efc62a246464da802b8ff8dbc179dc69a64c92e109d474c7f983050fff4470aec01b147f9862a9ae0c327f1dacd9f28da5cbf28a4b8160e0e8413e9acf9fa21ecdbf54c1ae553a2bc7b1ae46205e52ef81f7b222a011f52861d43c9502def62b8be1bcc4c3c387bec868923ed8c645d08beac52dc0b389893f476751af6988d87bad476f376212607c6b8b7e615596a531e2c932594b44efb87fa7c911aaf0bde3b6aa11d1d113c3c8bc37d49b48f9919a178feea35140ef75f48b9f250404159ab4f4f6ca248266f0f47410eeffef5ab199b9015daf6ce2ded507621c86c1421f4fd659996cf9ba2329edb1e39b933afcdf1de610097429730f09d6bdad5df4e3f513aec9a525644bd1909e7c33566184d299e18ee823772a772ba2788614a20e2a523cebd672112c3339a083d0f1d3c6a448e6cf7db86414f01641f657adaaae8b609fa0436bf86aa8aab0716d179e5a2b582cc1d7a1c0fb81b1d80f7d5e96630772e1784f0d91616c020171a971924c3afaf4a1bf317228b9a841b90eda6436a49ea98ce33b3c67590ee9d375a5dd3bca9f4b4616a9e5c9094d6b762c8758ffdb67bb7d00a0ca804b2b28c3e423c6ffa7db8cedfaa00ae628cc7cb319e9ed443b7b701b0b6c6e34ee3c2e41fef47dc4ccaec40c9c0604e80753aa98a461f93f0e0cbfe92c9d79d73b5d8a142b40f432c2c06cd7129d042b359ebdc7040c0fd76db25a0cb6b5b4b6ea31bffad3b3c212b52b9851dddfd0260f5ee203ec76bdc791c4bf1dfd08e2bcfa83bf6d2d859c70ea9a9f3195f776d03b9e9861d2e5fd95dc23f791504efb4d77f2143edc8bf09e4ebaf86e658c72da547555999ed2916814e49d23f3397c357ac894baba87b72d4f5a08e4cc9bc49912824b348f2904a699691a8771c75e3e378a67868c698f2a567ea3f922521399c0d91d9485ebe0bde909ad1a55ee968f32ca7957a9f7044769803c128c1bd39fd11328dbf4882b22441c2712cd9a0f3edd21f20df7fb674b61f625a329ef5a1c57e2f2e225185a47b10a77ceb63d1ba24beb507289945ca81ff0c06694e447cfa58d7ce098f57f82f48d9deba726a5b0c8df96f83b372314c5a2293bd9cd3e29e937c4db315f6c706342fb6614f1067c5712a5ac931ca7ee34877d9e2276e54fc5c0eebe669eb18f79bfb35d8e9c5386baba430ed5c154fbeea7b7ca1a66e1308a5fb03237b642456ce67e5cdb62f6c4f457c7c2a158cbe26921a2fe8789bcd7e6c1f6e206aa110b57d03612c89db2c313d561dd94aca17465df802c8ae1e6acc9697a04d1dab058ac7fc71964e3dd859850d09dfdc4a753027f941ce9dba1f72cc77c3ebb82eb36cf5a347af50501a59937d7e769e7820ff6c822a96d39852924eb002e96bcf436bb26ffe4205809e3be4aef6322b8974fa2d87945228f4fc1a21d5c3626f8c370ac7b4f70bf77bafba322a025ee253d38136b3550c894f4fd1ebcd969f547c3af207a6c3c1667ca117991d6d5226d9514977057bbb8c6ab229fcd8393116340eb316292c173e592a418066fb33bec264e9134b71519bec8d1acaed4b3a02a9d9354cc48e781e3a92728db936fdce30eab2a593d560d2a9f270a304e705022fe24fd4d5d5e27f728776f34e1bfb8e92d5d72fc3a9205ba5f64cfdc716917e5fe211e4bc6f3beb0f7f7ea636fb806a900620605940511986e126504bdf0305d6a1eaf9c6a0e363cca1d1c5f02c1962a1cd246d1cc19ab2fb74b553c5ed41087d07028603de31e2db170e007186063a20dcfef832e444a48a923e0c8d44c17485d627b2e0dac7f157d4117c1f97fe8d3bf4f19de3943fdb32685ee82c7faf5fb9a94b0f7dcf44fd7181a6bfad707d64cbc336ff4382559dcafe91a76a43883de672fa292b20c5fe4f14fec7d6c8456721b41d6f2b4a001fe87d487218bf1157a88063df53cfcb28c41109ba032d8980ed87eaed84c657ff5621a8c345f6d9560a77664b5c0643a43df152497d5401b51c729fbd116cb474c86c18428b4a9b1a34aeab8c657702cb80c781f74612e3b57736089c99914dc0df27ec0c46b1a28876b023ee1bcc464a62300ee93676aa8ab716e99211a3993b83c3b4dac9a07a75a90a3e17ff7944b8e8a5ec04268f6d95b914e0aaf0b92835c8aad5d6b4d9caec42515a8e73185985f7ba6330fe4b9b1fe974bef628dcd6c55b24b52f504fefad90e543b7e0962bcf62b138ebaa0eec9f4a3540709e4e42a98e60e505b7f451df5b221036031abbd3c1cb17507b3d381dc6b51f291d383b15a3fa2b12728b8d188e334a98afc553267c0d007426a89bd41f6db76600bc7e6e63c9b6e0ca353a1ec4ca3d092796dab7683c6ba81cb4971fa9cf9a12a78d2b2a7e039c94da9f025cbbd34667fc4bccc9f3950f97a0cb3724bc22bbd2db7f55acd8c2117d0ea5d4f6cf1f807f09aea657d6562a3379beb066d83d043e2c9517bd77e09c8e96b335955d254165e82177add1991ba985c310310825ff9f6b504cbec15601b752ad499581c751d51a26c70ec0c23a6a36725e7e426a8cd73b2ca7d77002a4ec7b2ebd60be92e1c7cb002bb76c8adb38a85cbf86f78c29e1f8a54f36b709d482a9aaef9d56d8ed0970ae98d3c047c77f68be1d29ad08e85bd6fcb5597bc2bbc38e75556c2c45b0b76885ae4885441af461ff8d840a46e68cfdf2bdad8f382f0108e6ec41758f221b7230d48e4093ec0b6d692cd231d3bb3f367e881410bb7499ee2b867eb746d9ab13405a63cfb68589182f302aebc8944de1a0fff0561a57a47c15dc096df546f52c46fb0b13ae1f59382caaaa2099623b731dd774f8180eea3815c715f6f320e8af058957e8648b1b3d4623a75b0fbbec3f52d344005d2b253b9fcf2f4ba3ea3bb758e8cc5bd4c1bf6484478ad74552421bb22cfa166e1e6168b20e39ba443fdade458b4aa7cfdde926b029702ebf3312e459f0a2342763b97e114e502fb9a4fce20f6b8c2179352d00ec8062b547caa3e1c4c691ce0c075dfc6d7696778d9f79f31de3547483da6caa6bc349754e8409b896aed96ac6b9aec31bc082e092112720d62432bfae99423798e8cd4858f84b7acfdc25d7b17e314315669ed5f5d99cffc627a9f0d26e67eee1254bdd1b8ea315a0179f5823093e04bf7af213218f557434a64c347616cb49e97614a14069eb1daaea06a075a8cff46e558183f177f381250afbd5377651957bd5115fd2773b69a78f5be22c6db78cb853c11ccc21087f34767f51a0e25a70f3446e009f56302035c05f45a335455c9112160d3e5bcae84cb1fd96517abbd8ed8772d5480d9eaaa5c2e76a619247d5a36a812827cbc19319fe5fcdd9b32ca5af879a0639b8f3abe9d6a8437a91f9291b93465b38cc35867111cd127213229f489956e4dc075e4cb126834fb58a30eb5b297225ead27d817ca8b8978a9030821c683340bb94aae814ea64a3baa50c749b8c635284ac3d33cd7d7f90b9c3ec3f412e0b25e34d1e940daa8adec8b9576ab72d44c86c8f22487772eb46f6c4563f309a219e486e06740701b26208d7f5995a48d6a6d2910a0d6fa5853ddec621ba30ac0b56d41f89a9f6186efbd28b3c7ac1de55360aed3fb94efe25e19540d8bac7f808a61d3356f044ade36c3502c1a4fe1faccf5aa8568c2820bfef8140479dd259207375fc8d7a2c09c002fafc661bd7d9fbea7d92e3d8858b1550cb4b70ae28bcc039ccf250c5f13aa6592c911f6c6089854f44f4a87275edc94d5d53c092f0a114c44ec92b40b09384db47f348a9162b471acf3b97c306ed24d306061792e911cc7de46fd8bd8b9e5c1cd6ac9f2648a0f2fe345ea796ac63bff5fc80534788d4da8fb4980f0245f99ccdd89cc4439a6d4b9801acb5d8bf0cb1f7e179e9b5b074b036a2a189337737a12d025e1c525e85e6135fbeaf05b0866e3da816e62257a71b81365dac636fb330410bc1104e5fc93ef258f9949a94520493a02db82cd757246f6bda21a69df76da8c7fa0ee46a45bf49ea66ea69136e353ab44e0d9f0d5e3b828c5a784b13303252bf35f61f79e7cb934e216f97c2157c92be6fa5ad8b68c58a240f808711def9bb39c11c8876372e4ed7341d2b174a814c82837f91c91799dbea49dc25b5a02ced0b3505c727524dfe1b03faee1d0158d50fade0afba3edb60f0450134a929b868c36b588d5e6bbb027b907975e0fd59b628e455fb23237c92d36abd47e4b605214ba5496a0a75bd6fd1b0fbf77c539a11cb10ccf1c9c47904c3e13bb73184c75edd559001c70f1281ce76db2e83d71c585ad2ecb65048c1cd7afd143266882e139cf3f200bef5d6c4d98f3caf537820071ab56c40c874f37e9d726531f510a7d799a4d29b68fea9a24edc4df3f1dac46eaed215f14dfc7820df34112d1705407cd419de4b3bafa11fd0d82f9b11547b115ccc76084cd9170f2e5e7d0035aa33677f891080a4022904d71b309fd0dce3d672d6aa3556a53ce55b99f6a0d6406d8bd91fc14463d917ce0ea3913c44ef8ac29add874296eb278014a3eb774e4e1b89c6355d6324ced496bc383b3f869717c6d8361f6b1a77206740a6ab5f394173470f4accb6793b505d7c164b9ff553e2c6fecbdfaeb0373375a57ea793c37737dd1074758ed3a136e8338a12fdbfb063216247b7f6d7acfbe9d37eacbe0f7fe7efe9b10362a54056b2848003ff6600011955c8f4b882f1db28b3a4733e9834f607ced04819a559f46895b370b7d1c03a429cd1e4660c9e3c23b013372238fd5b4799e2d744a867d82cae9a9ad5f54067ec14137133497f70bc48b2055f357b23fc8d5c3a7a53732182102c6611b744d584f448880dff35abb34bcd3b227b12a39d817299343313391b154c650fa80c8221421f5345181756272d28b6ad0f40616a266609384c22efc45338f1afb75685f696733b17cc0c6de3b1a7601d4c97cbed18dc2ac97b278e56e6b05126f94b0075b56359ca699cce406a99ea472023964e9802c5df05e63a2effd9f2954e6a3fd8bd6b6a9aa8e286d4e40a8452467e3a75e144fcd4d38b91e43513098888b2ee217252a65d59b42e384c3af3633465a4e04cb2375f137038dcd6c6786d2485f3c82ad40b1a2c807b5903b4d14bcc4953288534687f2d96fac1196293e9266a0e6994a9e0d4b0bc93f15b3df31d859d892bf0aa214cef4c86ca517bf0deb57d1ab69d2adf655a812096470aae6108eb23d68f21ab72c5c318f2f3532495ad18d5b4f6273e2420a708cb6b6149417c482e57cd15eb92ad4c83b1b025c883558887a1572dd19dac6a2d5a30f7fa6d8d8a1780c97408442ab78fa5d64083638e64d663f14bf7703ce7bc786a612ddd36e62a2ebfd1bb11ba5359be76ce33236219dafc0049276fc7087d7be156f4f5474ab19815fe37d1ce9b51341feff3e83c33f022c53103a0c19697b531d66f1ccbae40fed366a5b5618c3f3236db9623ec9a08e0e7502189f0cbbb5e8775373d1976cb74aa82c525b15be2c5ff78547848e688738a67ced500208489a38d57dfc400c9277117d614fed004585e89477df14e53eb2040ea396b36873c8831d3b6953231575bdb85670bef2c9897346449e9dab56011ffe58105c0810c7fac05ddc6d11cde9ccc5b59a9315370b86f62c9b235efb066fd21073ab8e5bd902dc93b81249b802bdd17a30c62ec1b3ab380512a7583a66e0097c308b06f0d8ec8e91638da8d82da51242297f8e4068a94f8942132e1bb640918d0d89a4978a6272243cf5d0e1a90dfd687698378d798e8fd1b0c677b32080b0afaa4397c8281635d42e240f47f520ba598ec540989925fc903b7909aad14f18f3e3a67cfc56aa00ce1b9ea091999db41eb2024c2ec025f6a554852276609e898491638672ef05f94d34987b3804cc883ba71db1e970323a844063d9227a7547f982fcd01eef7988d0133c3e8b46bea7f9cc4836ff0c2772154a84db889a8612b6e744db8564c848e254753ad6266766048f87c49f35632dbba4a978c6abff1d2ff7ceff7b01fc98956e53c640c01cf88b95a8dc7c714a1458c9c51dc66ba287dd30976133e75e11776a7be1eac696dc8453cb9555c77bc706c1c4913ddef84037dffd3eb8814a411815d6b57ebc2c41165ef78396e2f048aa615068312e05c2fb174dd7e03646d7f689d7a7b19b4794ef5b6e3f6037bde3531caea8c5828981f3512f43849ff2871c6fa5c6874750c605deab8e617bebb0c4301d2c86effd9c3894f11e1f41db0386f9e685bb29c03a0ec503d90d3c2ccc85df9297952bf59a9f0468088bf87667cc473d3dcf2f73dd6f1083ddd15168977cde1e30b5746be54f713e001f159deb9faa357af207ca99d25ee1e5af38b581256d62eaed9d93c50ceeb7a82a770c95c8c4876a15a41780269dcb186fc4a33a0cd83087c0564f5476a5abad842efcf727c422d3f73cc1d7d6fd40cac045f2564819a83e0e4973f308031f328391c39ad0951b3c8fe67cc36d1f6d4aac2c305100d359fa1a4de28b66a904d7859e46ff7f85ecaf21aa815819c7b46e443bda9c4e04bc2a87522a59bbff6f7e034643f00cb8cc2522958bd3dfce2c1c7966328d445dcaf17e9331ca1b37f4cbff02cb8673f2f8d1b8678284e265f3e0ec2e9fb3b3f5bebed626f148df869d86de4834edb42b0189f8c0f6de8072827965a37c5961fdb157deae3e35ac7c765b418d8e531a6046e2951ea0877ebb3437471c19b5a76ac72886e85336a9149d4368a9c7ee14757e5da5246ab8582a570fe45d256c014e14b831b43b3e5cd0b7b0bf7d74dbee12db48436a94c9c5a225b9c4a9d9a1860622db93e052c176582999a4f623993a40f457f4fa551e250bf56beaaadc67f2b1a8b4cc4639990a83b2f0e9b2adebf9002127e02609d96c4cb68ab794f12f3107a70fe88da26bb7acf07196ff4332695fb82558978e6731b417229acf4ae1a2d9971ef79a3460bed1a1e0e6dd5eb705b1737e7d1883d093979117feed8f56c2316fd2c0ea882b0e758e7d6a64303c99e086cafe8c5b10d5e27729ed99ad4ab957b630b6d36ae9aa16734a5dd45c28c66926a04b2f4e1a039d5b6fd3e7540eafd4bbba18ba37aaab45cc9dd68df89083e38097ddac2bd27f8a90eb4993db94ef4a48c15d2ea239ddd6a42bd05930a4c0e11e895a46c0de7497b3fac3398e98a4e25dc82d3517e53367f817361b2e99b07856aa7f20b3a0f53527b8e50abaaccc3b4394005238381c77afc5c898c69b5098b5c1501695ac4efebcf49a41b23611b68e7ac5bcf7148efed8a504da44e607be4413fa5b21f4bb55ae96a0a1c70757b7ba90e1ef3493a8df78a8c5fcaad6c165af827a5f4f0b242e418c7dd331e911a840a92163921a936ce0a2df474585367e6a9c0f8f6ee7c5f0efc9d7b22b84fb6e0a0711500e31b04be1438a33f4451a2bf852a4862ca6bc7bc8afe4609859e1a5d5b07ffa258abea9d6b156bbff7ecba1b48f1ce032d9a155ab0edc74782f0ecab64553fee009dc747e5b75fef3be115ce856121c53b401e4f6114e9942ac0c85afda993e0e60cac6cfbea175cbb768f7b726ec172122e6606b3aa41b8f94cb00f994c4889c68233820a3621396f18a3c97549b764ffbdeed1e65673622ab9b986544dc96139a9377faba68a81b0001c43909b3b074247dd9ad522b9112fea4620d55807ffd176dd9425c994bfc80c8b2cb2213833f6779ffebe5e46f74bae6aab12aa9acdb22d0bfac2462160d604b3c986ae44ebb53ea5318bba65ed2920b0ea4d4586460185c7416708df77a62e4963916b01981a2d684e5bc91cab9421055596462992c932c089b56668b1b696328239e428ea42f6b405ba5cad026be6c763d1bf7ee65d889548e909ad0b6804e3223e57ffc958cb00abffa1e591cc531e93c562a92065f8569d25beeb46837cf00e4156035d5e8468584c9888e2e2885c68703fa3a2f230bc4a971c34cf19b5f794d06f4739cb4e1c812779090298e7f4c87acd4c11adebfbb4b1b8b0735c0887b917faf0af0e79107f356af7b5a9f5601517ac22664bed2c3de777008e614e335e8bfecc41acf437138bf617515f9d770704189523f28c16d4537fc1c3db347db62b9ee7f8e9f3d47650714ca3875863059f1ab9cdf6736d26474a624c5456f06b16e20bfe420b9e471465abc083ef9bb04ea68b4bdc17fce693bc20d6b40a0bb90949b3b25e14de47d29498342bdf9c1fb9b627495d91e2ae33506298bb8d536be8dbf7dd87284c3f1b7b0c4a7106ca809b581be0015d2e9ff328e991e92956b8dffd4cf2e1f73869c8ecad2c5d93c630a3770bb1b832045b09e01d77f5d031edb358ec5fc665644a9d629e6c48082ff3ee9680b796a1033e0a69c0fa9eb3f753154b7b3c3228239024c14c9b2e832eeb196b14abbbc20999ec52798164b9a5d0eac6e4d30afd04fdab73dc84a11683238dc86ca4b7cc84e9c5e82a95b38d6da99867c6567fd2cb5f134850544963931f1e8a2193624ad6569e4fd2bd3a7821b3c1270006b7fc86b17b32a94bd590ceccb5bcec95cc2483d01fc3e784d7ba29f9fb5a70892f02efb6513fee1feead9e003274b7f6ba9947e1d14ad4b81f3de438c36aebb8d3a37b32f3ea1b71c8968fdd02fb3b74d799bec7a4059ddea2026db90445c5e34ef0d259b21834a077d973c06d885c458c902d32e481729028311e63ef761d646edd447dcd74c9ce9e3652d0c2eeb7f3f2deb48a8ebb4380aad110899656bf45641f178af48019d14c546146dce34a6351483c0e3b9f03c4e796a632241d627fbe4e8a17868836f038a04b4415e7b23370a3a341956c8d80597a1c0b8058b25d622826a11b0c3ed382869a3e272f7945bedc0ead2dca51267eeac19fc2d46eb54243699e839d8d6d7db748d6f02fe93ce62a58e639f44260444da9e578a774f1126624fc375c91f97acc3d4813b0a5aa66d793eeb15aea5d22835b0063af4dabc5a663d054e2a6208f307c219660635045be57a7f6a165801c313959801063f28bd3a5b8cf129e00d2ed4f9ddc857b50e967c1ed065b84d2d4a7e8b7528d18fc565d849edb661d9090ced86d67956ea6b270570366bd914a7afe78c1ba1f4ef162ca4b3e974625e88354efcf8ce888f706915741dbc772d57f0182b8cbc9e6d2be30060457478ad34e1289b52e3025c55cb0e7b1a36185de7fbec32b354040b9af566d7a07f9821d3a7e89ad49ded58ee0d173a72e1f2eeb0e5d1f2b6ca9d6cf49d078b9f60fb875b1959d85524b86fc892345bf60c9354afa655a482eb86e79d759bee365b489668dc26b41b2c89e923213b9eb8c35a79fb7a4b4e176129fa28bcc52c9937a47447ef51dd6527a51b756cf3639198c185ee13565090b2916bf3bf26b7eab3c1455d79a91700710560a707775908534a01198b66f6b9e89527eca94268e2d0b298a0f92405cfc98c05403bb0238125f0696e77515d82ed9718309c81b028e10acba3bdc18b84e6533cafd5dfa6589a75a12642f999cbb8d21dc73a5434d294995e0e962324786cd6e43f9f807419774b7ef9c81c29d646cd2b78ccdaa97d27a6ba562536ab229d05741f04b7df9933b37be83de2f69d2eb0166bb8609897379aa716839c59ea70ac30c7742a59ec99c9b87eb94203b48d2305ec4bab524aef07b626febe5b303c794b0f46f246721e395ae40feb28b21f55d45b3cc84712a1977aa03d6f3ccb5ad8c0e79fe5761725c6c6db31b666d77a584fb3f94c41b3de072a30de809ca8217e29fe7b84b6bf0ec8966706d876c032d222881c85f84fb90d068aae9547fd49453da4382638f61b867f827a48efe1c937dec12353c15993815f85f97a0ee09b58da949299120ca65133d336818e7b2c1eab7b0d2a556da4f33b1137cd8bf7f6ed8306fdc1aa5f033d408445ff2649d2dd11d4f37f18550f886e40cf57a7b91b16d127a58e82fe901cc7f242378c9af5aba11ef7e183a2e49d8ca3221dd714627ff99a7ac14db6e74ef3c2607ce33c799bd9aaad6e3afd98df655fc2be81568cab27552140d245cebe8c53e9f947b6e1ec61c37c674267b6815087b8f3c26ec430697f658021942a15a80e49d868a18cab73e48a366007acb904543a58b2fb727a6c86bd9296e882cad8ff649ec0a6f2574fa44fd27efc2b29fe7de748af35e8b28cd612ab12a44eb82f8bac65b8b9932582874214e832ab229d6f1925e5b76b69dd39e881367472cb021e3b345e409f8fd97b7df7b765fec923be3dd9ff2bbb87c191a041725e94b0a67a4812ca465e3a6a3619f15c3683757311720ada094b1f374c7c930fab2863df96657f1c7b4659945c4ba2479ba1c4cebeacaeee8395f7e0bd868197e73c76843e554d99f15bb4c8ed9785d366b9a8d5e788bf7981d7ee9a1cf473f6d7ffa77d43c77b14a5dbe662eb065c795cdc92d4f0c62668b5358a5ca3d1953eb0a496dc486ec1644920c5a509b1bf6c0321b0f9a7c667f952665661e2484e5171e28d7a45c403731b0c05c1e6241794ce178780a0397de48fdd47579e88691d9266e40035066eca15d4a6b37ff22b5b905d8f10588ed5a544426fea5388b42c67811f992082debe08703ba4b50bf44c985c8c5fdbd6868e15ac07e0ff1031549dc75ec3d4e26a574b11959ff83c8e4b5f94ddf67ee86b9001024e9849455ca3b0cb1c4a9c7b7e3b795a17fd646ae7283c8937362f31244f1808e6fb1a674b3ddce639e7469960ab7fc2bb060ba6c3fef60aef4ed5bae78075eabb69e05b24e7582704ad1c3ca03d2aaeca0314f326e2c463f6783bfd7dc8ccfff9418a6199d25e410c692eedfc867c80cde3d18f3ae33bd1cb2be7353821278977722d26bf21075466e819c6cf4a3613f3041a52b734f765fa1df4dedcf9bc2005faf03a2cd6e7aa2b9a3a61cf36121304f6f68442fff8c5c1e70708d5af993eed8c866853c5b263c14f97e47f2f85e58970f7ea6a62c2c171acfbcefacc47f61769ff7b889df9393364f525a194cca3c242a1f7207d013f3284ee6e7d11f06de08ab0dc17db1ed50a3f90637938fbd915e1945e1040496b0db28accbb375d911e1baacd53c426d8289a44c51f9cd8f63f8a453c8267625186e3729c81442b62a1721a9db1c29ae1236feaabbd444d17a9a39f73511dcb2e4612e695057bcb948a18afd016b6919799ea0d222387d1ebe45d3ae92042a9a84bed05a4e73b62e474804be15ff6f52d4e33c67f42822f78626c67df0abb4aebe18e34f58a8a9836a3a998f22b47951a1af891dfcf3333b1fc2f08fb93017ef17960dad25a0f218cccdb1bfb98062fb3cb8f4baec728c6a47f727a9bed117f5056c361b73c528023e9816d0a6e4d0f3c84264a79a8a4651d81e8f232b85f599e5c9e1cb39b63a6ce8709f015b4fe184e81d19d6eca9cff843afde49390b108e2824c703fe453c2c3017b375cb10450c25c2a38ab18c3230d2a6ae9295b17db35bb7a438f1e7aaffdc5c70660e1a6a8e4d8b5bdac374b5a3bb15d1a69e4155633b3f560ad6cdd530c3d1633b62fb1fff9213969633b80a0a0acfac3236e5e5010f46ab0548b07523b5e6d6cef2dbbcbfd6389498f14849245d5df576485bd4a459fc7c68166648498862dce2b7b30a9f0a987f673cfef9e96373448dbf0b0984288d8aa1ecb345130bb6ce857a64cb623294656185c7aee1d844b4eafcb42e55a6f62f8f0795294bd3d4f2152ab6703122aebc2a9c467f572efb85192d5417f1ee322a394d8b5bb1468c9d8adac218be0ddd884e404039736c8689f8e9cf64beba093a09392ae41ab03d83809f959134e0b78c576133e8037e499af1deeb749db05f098e42761ac8a19af764f96438180ef854bf748000b3679934273c3882091794d0266bd9e59084c4b51dc3774cb79ab5e8087d3d686c88c57dee2addb3673e87891b77ab3b7b02924066d432bf6b0d51c3cc4b646620401cc035436fc50ac5d8b09f92440e1813b6b53ce36230864cccfbd03195910265b6b78a9d7cd8430373d9532cb8cea1e309ee62a79a7ada1a5b45692b1ab4aa78e185703ed86aedbd020b2b4c24b94bfcea67c132c79000ec19e1c97185452655eba2634d7bb997bf690c561668024ceefca690f9aeb812e90dd8b34b3114f7a520efe160bc5cdbeab9a7c5fd1e399c5f9d26d77b35cd11cfce2e14677b10240707beb4f5210b559eec17f5d32095bcef31de19b881665ee097d55ec8aa5033c8d8861444d0f614d17e362ce1426491b6f3c4f497fcbf122d62324247a3b31f41a9138ad96511c17c493a11ffdbe19129978f70ffebb68171650a09842cb9308158b8193db12ebae225eb35a78fa92ee1f770c859b62714fb41652e2e06fa88e2de59205ba17ef658504aea158709ba0bcd249d51939544c8883d7712f86c71fa195036fde68f07b309f5d6e86b53806b96646e58ee898ebe535aa9a05e53e937122014d4f5c7d0cfcc2678f87b5bd0892794dcabebdf696db3d7aede047fd8abf34342ff97c1055279dd7eee08097ec1993b5b580629324ccc63def760d746ff1e8e342f061dca92638a3c0540b30a572f4dd94ed02e78cc19889d6254c4890f7b0338f5d6f6a22232344767fd8b37e27de0307252c225bb90a792d6d234b7020eef64d4c384d366209579fa7f011ab8376d15daadbe88cdfb1bf1e4c82370f67686b5f9d6f8c33ae10c9aa04e43a97c151ed1eaaddccb61aaffd1cd2e60bb7eb11eed2a9ca1a831d794014fc7836256058d72b7008b2f835e0d6ec26a024a1c7e720388d353dbb3a24e84bacc6fccbdb5186a8a5e613db68a81e4868e60eecfffe7e773bdad4ef4e2b600da3e09fd5362026289b6cd4a795b91fabfd628bbec24b98b4e7215b671b6c78c1bc8ae826429da051436656e40e00615529d568c1141649e46a956fd6dfd93cf6d1c50085a7108769d3f27d96785a0037f5e7704807a75a84ce91bd69c118bc6eaf2a47b549698af6cc5989828ac4c460657384b22021b91ec7f0bc69e0ee9899925bbdb1cd9f540f96244c4aa5113446e282ffa1f9812f0d2cd7afb0a4f9d2f61fae53c57cc937b9708a25a0edae2fbb4f1560b2076b5073fadd9aa47773000611695aea1833a8d9f5ae054ab2cf7c3af466d8a9ade23bc913f6a7469650985f50586322765a804d0c8fa65eb91fc4e46311e4f8246319503217feab8172dd0dfddd4b88ac69141bd2c8273401fb4919cd687da4f192835600a5dff3cc6dd121edfd084b9687f31ad705f143733269a52567f5103e06db76057d285642053bd670195f71f0ab983ca738725cd3efe3fbb6118185b4bdecb6ebbc6607355bc40159a121ae0501887135d6d1596360833e10a55ba53455e8ac62eb7b29f219924295258003b4ecd47520925e9d42b53b0970b7083bb9da5b28a5d946a5ff5ca0a6233f8523aae437a7776f862e26a3803153d3ea60ee08b7264adcd49dca1600c737d7a8379e0188ce026ed84d3c64de4af08fbc2a67f4918cde99018ef2251181bba95179a6e73b557c0d0c63d306f8293860f281cae196acafab9e01361c7cd32376c49e62be126ac44c147686b6d792e020591efd0729eb8371f173404ee2399c692400cea4b883e037cd78d298167920a5d5a8a8df9af1e7d59c84b4c3c87b79752ea0196ec89bfbc729b73f7bd31019cf952a1d63366fcba414546347bf358b5557f3b42da070070c53a1b3722eb3d125cf9a13812c8e3c2c9bfdfb9fe097e45e909a1a898a4b12ee8b7b87d6e5db2b4ed0f88a6abb91eeff3e204fe99e73ebfc8d74081b71b3355179d7d5cd613e803732178ac61d3fd47d2f8c70fbef282624622b256d3af0dc91ad879b3a6090b9f8fd5bcc349692a5f6f7e5738434689f1ebe1d76ea6177b3b695bf61a4930a2a96fbec80eaeb75526d6d6a02df67e4d690a2eab1afc8da715cae331b75939b7d9e28f06d367e6330f4640c24f84455071971cf1091496b88da54d3009219d648b21e5c99bffb148cc365a7662cfc9ede329b5dfd77e89b7d80d1ab4d0455368e93ec68c7ddad0851b79d96f83d5459044ee452de4a6becd35bffcc19b1b38076374c7d2c753e4d7ce39e839c2fd608a3bb20986229f26b40dd446d09441736038085905c66ee3b5b794eb69b216f6ce9ae45516aaba204faf78fb6f8ffb0b396785622be2599915800d33e211fad8769c8e3893eab07a36a4e2ba57b82326b3d3a17079086a1b348aa603a2beadcff68973479d16466c688553c507d8dbaa1691d1816620fa413d0045ae587e4a28ffddf8cbcd248275b254bf2843fe8d5b9279046d37650b513bd7a7394121f8cba01402407c6cec5e71e784f332d2d233e5fc74e5d25de3b703935929e49286e53b2a9bbcb0d140a13f373aff58c558cf88c7095580f77041d00bd4bf0328c950c17acb5a40b0e0556805435e80a34fc2800e5d0b02dd1f2b85f088e391fdb881d05a74770414728db1b98b5d3787bd491822bbc5c8b2a266f40982294cedb2021342e404dafaebbe40bdcdce6fd7581127bbebfebf8846330cf06fe268bdd6688e9f3f3d092e4f12be5ecb341450777a612013bd5905c09067dc458ee5061ef243930e8679e29f0b4f8f77f1598f2da382143677fac2eaa3cabaa915a0eb183571e4b563da8609d1824e4a63b37ab93e9fdc55c4c6bbde818e88f1e09ebebc346f11e1d85e7a5f0317492a79e00f09c155b7cffc046ae4e1fa9637a72448f1c2864d3258c71c00b2f4ed60d82bcd0977899cca8ed99fe194d6a70ca45157c2d43adf3fbcf4c47bfcb33aca55b2dbe3830db05b535a65e15b5ebed3a7c937eaf9c05816dc0679c874a5f9b42665c76eac0a40763fc216e9f5efdd063f70c2bc2360d835ab7f0fc23c9df7c15a927db53a4ca79b42e268658cfc3ed8fa9052f99396b1301f142601e0ad226937258c978da68a946c04a0735f0fa1f31293919f158e20975d7e8f4fd3c173dcc85904c01c8c59b3a31a0ec3bdabc634908b969d21d608c611412307b8e1e571f3207a9a976b34f1baf94c99fb0bc242497dea10dcdffad67590844b69494310340ddd5614fd4d5c8f5c1a0a4b3fac27b89dd44ca9a646a4e5177f14cfa200b9a65900a2cf10ad8016db1800d5fe9d336c7e91f61294ef244c2fad6f871b620727bf559c8a59b361155151785cca5dc7a063b1b1c0018698d553e84fc3cd4cc82ba0d9bd883892eeb3e07fcacc05eb2ee60fd5fbf61a2b672fc0557feb116385332e81e00a0563738f669d7243ce55fcf9e585e8ad87e30f065b34ea42e93003cbf2e51a7166685115eefcc22ea2ccccad4022f96003f40b60ef04665f9e3959ba35ebfead404da753e30cd77ac7aba907c7e561d146eafe5de8ac430773c67929877ce363297c1d1f58728ad46107714e79683de1e270098a562fa93970f8b762e2bd45ab9d4be59dc0fac0885359bce5a3cb7db969bc40d9a891a2bfd6cc50ef4824668a696fea7a39e681646ea88e7714d822358fdaaef971f5a9394d5382b365f4f0638743a8cdf0cf84abda1b71e9f9f6a0d30eb734c444cb190bcf93dc51147cdce0d5ef5477930e7df16ac096979040b0f947599f7d61e91b6fbad711892651df0f118494fda9cce0c46cca4ee7eee3e2e4c7105996853233a395ae279b6b0b8add65aebadaa9a3239c42c8501bffbd88d240e72bda0eb854e76935c9527b7fa5d997b8c186cdc55fc9194735fc86729060d4dad60f46d098791da9e9f81cf314caf043aa3c359f4805cf4da4ef6efae2227cf1cd1d0ec1c7114f6346fe43b74674954696a63eb8460111868525be8bf1c0b9d31b3ceefc3ed8a3599b05c0c704c48f6104319eaca810711a7388445648fd614324b53499391307927569017be0ed384474b13a6856ae95cb9b31452380b01b8b983b9cfc7b6238956b528614c1958eb375c83b35bae119305693ecbb0ddcd93b938689dc9623d85e0e2480fad4a2054601f97bea179806f1de643ade369ba5234048bfc9a333d972078572f1b0cc5496c25752837d4d30a75139db5758b2dd5cc6d181b1e2e13aa6fcaea5218ac6f5f5fa3fa00f822222315a017edeb4adddf0264e8c33d2b7c6c7c6c1fb62966c0625ddf366b43d839f0ab82f5e1355d29f0206f2616aa76aec9b59918658962efb2c25a9cc27237357185c7646c4fe91e0ddec7222aef84b776aea128a71185b34e09db1e02c6fb40c3020760f2d5d3086acb1787058856d952cecb123c0efd08b68f4c50e62d334e56a80768547772494920279d4a119fd48f5c1e92b350c393f901592901c8b5611f0000828de9b1b4222b9afd592913a175b3c8fc82b699c0870497bb1956f590bd12babf5f6b1c2696ddc698c7f8cc149e1d00fe2f2c01ac2ea65d869a8896289cde410bacb00d823b062cfb3f494650e6b09dbdd4c0bf32b1cfe02a0b61b310b9ed0ba62ba306525f5cff48133f2a27e354fad7d52a99243203e499c082d053a1a54537606779fcb36599881ffcb2da3e2f2dd4582a631bb0e08e121f936d98b565e7b9c2c2a4ef32616ca2ab13f69d931729424c67182a0caa4b72a90d4ea1782b60c514fdce5229111c4fa3ec2c8bd8ee45158d1aa2235324a1f4c96ccb3bc228ac24e8aa243b2bc54dc18d093b1245c12c273de56b6fa0521c6ae0e530ae905f75fdbcaba195873219e816bced5f2de01f6eb82c0d58609165e6843dd2892c7a1e9d6b7c8cce356363f954a48e1bade7e2f5d61f83594dc75b365a0eb6684173db7dbc437af2061cb2f07f95b4ea40f9118a37534bb7cf3ea84ecbfce0523bdd9d59f679107c21b54b3b0c2a6391938bf93138aef57df574d274ff350330df871d2844fdb39480ae11e51bd6354188d005bffa7b1b6af4960e653257434ff8734d2e079126e1297a3c35720084bae349e9358bfe2b25f71b41ac711bede462866303c1cfb649832c3e79840266b54cbb0ab1b3d62667935fe38ff96e8c01461c0b996fc9e5749770b10bdb5440903164700eb0311431daf2be486741396069d87710552aa6f1d79d8d52e90f313192a8e7b88cf05d3b0e6ba34e0a788f6718e9b2bfdf09ea5932e4be9f0a709204d9dc6938be2cde5c89ae0323f4aa1170646093312d52a3dfede5fa5a94ef80a744a7111b30c500202e087681d5ecd453f33ee1654e71f5487c518a915f0d687ecd0cda08dc4a3d1bfb8010383a22278e89563f2d2c2a5006796d0353de30482cfa8e481d7e3b64775442a267d8d44fb9d830785bef8676b8ea97441a414dd5992c212be215c0f2f63e6faea84195677707171b8a212e80a829a7d4235c08abef297e263f507d40311684cb54816d16faf8c717e747d39fc3a55928370a73206283e99dd0f2eaecae0855f4155ca51346ba2999c073c8ad3cc0935eaa65d9eb4de8681f7dc889c0e861a8452066ab85e7cc3c39aa024eb837d4c597471f2d6691e2038f9d643057d0280720b8de682efe4268027c5f9080182eb551536c6fdcd7b771728c443f4c55192d795c0503b61f640018d66f00173e2211615b57da4b1e294502b8fcbd901f48e52078a194ad0a356234172727c5fbdd0f8b6483efa8e426e34d98e173861836512759e1231e5ff54813f1c2c6a3941940cb45439109ed3396f68e04426310a0625261e1e6ebf08a79b5f32fdb99de8c7667ba6977f2df58ff150a8e91e3a1183a4cfc25ffd218a6c10157e040a838116fd31db5271778ca402ac72b2ce6a715a0fe3e063237f95ae0cd2ee815f1ae77b1b5cd7302901646b9c6111ffd011c2511770a7b1eab816fd72504958c8dd7508d4372901cd93341dbeff46055e4c8c9ece44c6a8ffe95b3b5101d2bb97921fdfa9405f42911c1ba460fb0e71c28d995d72f09cf7b028702abeef92e4236a2cda1704461e89a301c1cc18d1db4f742777b398bc653cc69c933aeae1106d8750b0078bd13db11863483fe1a8c2f29a969184243c8bfb4983390b993882220cc7f72eb19c4b1d829691cf2911fe7910f3b265c2c74d6f6087d9848af466bcb73a6bb2d7547a37ef855543fcefd3b638678aabae56a001c7ed78fd018f216d9cacf01a1263456ea931214e13aeb79fa6350862ac77e9b8641080e95df71d2965b3962668d9e16fade0a6350304758d364c441a4da8aff1219927a29138b41cbdc95ab385c8005a2fc7a78dd6695cf4a4b8fffef01f960852685b731b5af085e7c7b8110e36e6b71796cd2219987ee2b768c7c92b5729ccd5ec70daeedc51eb1c64d6360504da5f42a29b029aaccb0d445f3c73b1f482324530e7c7cc771aab632897d6fb3bc7716f85a774c98022b109f09be09b4bb9c5a81ba077aecb2d00a9503a9f62b9b2e53e2d8a03ab55ac8191fc462497fa97f637d91db264c5a98ee0dff21030ddc40a8f9d14f2c025466feb0d2f1a3bf0c1899e14303683945641f8b131f060b92a69222ffdf97a66b2c8d31cae1b971bd4597110f37c6ab669e5ed1478417daed53d80a6568b6a577fa84e5a5584418828c2c304b4156c74823775f1311501c6233f3e70faa1c20b8a474d7ca05a968e3836cc32d3ed7ab6be2ba84ad541851b97170f46a29b968fc5dffeaf466cdb02639f471f6fd8facc505e6782012acc65ccc53aca3ebe3f762b31dba848a3a734841ecc6065e8a0137cce29e2949bb3a545a59146296a96ea3e377c790863ed4c963b53c9ac24d21fcb133e9725cabdba2c9189550137a6b98137f15a4cb0be27a1499f05aba619a97877ea2a7b4cf61bcee109790c133fa8a4925f15d076f9053dee1ecf91a15dbbfddc32d420c9d971aa42f2b4bda345d5297b5eec84191f4122bb9d7cbe11e130e1fd4ebbe0697fa4d3b5576c8fd181976a7b6c1bb29114a7b9f98f90b5371c3e0fabff690527d92354e15bed7d62883fd4c4fa866b87ab312b7c1c27b89954267a28684c3e743078497fe69c5b05fb720b49997e4e04c6c5493ac53ecda4867956ab55ec065f12dc4d885d2b4e997c37cefad25474df0f52245d02e14d1705bd7d984857f8587ba349891554468b15f5b5a2375df8365a9a559ee3f13f591943d4d4fd42466b592ae02927ae8e221e5a9c1f6a117f02e5009f183c77b48acd6c5431592a14b27f5a211019ca9f5502b2c18f75c48591d6215a500cf223fb0281366abff9b5a71f718142f2124ce3115f3d3ebce8ff5d44969e5869e4cd07ffdc8bb6f36b52c1a8415f6df1dbaa085882bbecc0a3ba1f76bfdda9080ca3b0a333e8bba8a547faef1e6f669f120cccdeabafcd1314918411aa65a5c5da0034188be264798372a3a22104405369805d93236ba354195b527ff1bc81e50dbe6e8ef9413e81289c1267a52110438baf9fd27bbf8f620874277ff8393e21da31a68c7be00fb8c84a07e4229b743e41444b138f8b625aa7eae0c31cc0fa552b256915995770d5f24cfabf40ae28cdf40d3265f4f2ac5a460937c825d5578015c7dbfba95ac39a40f2308c5f29848e4f22b2262b0e854cdfe24aa1b16e2117647594aa7e35451d15a2a1a8f54c2ef5ce7b923344914836757436e7c8a5a9077610302ba4421dd27468927d500c0b16eab80842b56db7408126eea127c466beb671a6d97282835f464cbe451deb9a3ceed5d242b31d02147877c6a2c46f8bfaaf48bbaaa725152fefefb52b2bce3fcc4380ce889a5c958529c099789186aa99fea890e862c1ed5fc326f444ac5cf2ddb617e2a5bfbac715430276a301c5719c98c0347f9bb11dd333372fc8c8998389d841f128e2abe20d05c1151dabbf587f90593435e0f235e374c65b039e2e237318b6a10bc0b19eec037f4a5f0b9776e1dee6dc50bd8e5403241205b1d3bd47d61c0dc5af675d2e020687d43b278da86b47b9647c19bcef444556290fc962733d394a7b25f3a5cd363d43ecacacf1c4fc0bb048ba846cc908dc52827cd17819901e671f59782ce924fa05664686f3cddac081e1ab2074d37b974f8235657c829670334963ff14fc3eefbba11448cc5e7348cbe3743958c1c3b1ce852ea699f02888a6ebd4908e5409867a0a4fd2234020941cbd869bcc3ff36e91b30db80e94dff10c85dc8751c0369e05f599ef268bc2df413454e16c0ba12aae4115c3a9217dd2b3467773a44cfb224b919ef29f340aafc6ced46e7d3914c871400abcac99e0e9e14b74dd80f28e78be838e2a4e1afee85200272f8b0f6e16eb7c52673e622a25cb81605538a2bd9f3243ab31f43ca9cc9d7d368a15109b6dd1ef5c17f0096504c5dcbc1fd042578d363bf31f2a036937f2067cc046fe807e35ed110d345e0b0f04a22f4bd321363591e5ced6d467bccab1046f55874875ddc28f16189c024ed5ef4b7e61b978d3a20970824736d625c672c75e7523669cd4e146fd1faa9adb962948787521a8804b2f43a2e0e46c91806b60b28784b394a40aff5de273233d552f7f05f63094de0a3dd1683f49381ee482662ba1ad0d6b00bdff993c771a4b8e65c68ebbed6e4183fbe6f80e929ee6ac47501644aa0ed2e576bbb6da7a86fb7052954afcb857dbff501f1287a8977ec2613e5ee27f2ec0ab7e483d2c135fa18d82347762c7ee3055d3e0cb9c7301abb5d453d29e4bffa4605f1410e1028c3c2b4dcada083ae42eff6faac83106b4f71f29911d018750e3671716b0e8883f7d44e234172dc44aeaaec58f15c954bed891036da198bddcdf93a714d0cea4c0cf14dc911f07e69f26df17d22a5683b55c8c2fa26918422bb67dd6e2706158b5ddb9441b5112324352897ff650b5a38f7d51f51f99a374572f835b0b52596c9aaf7dad47db93d21d28aae5f5500c5446b8f0ca97f4ff72302302860723a9ecdca44f435eaffc3a27b005f2876e11c44d3c76e2826b3706ce6e182c7b5268ef5f7e6f98e56d3451d2d649b79591a6002e8a22437cdd7c00173e51b3a50c53c5db1f4550a3e228b224b28533c36e9cc1ba51a9acc8ed459739e7f956f76228088e7a594314d168769261d5676ea6f338b611a6337e510db25e08ab1c82c67a0d0dc4db12f846546ef39b5540cab5c2bd421b5e2734ad4a0d307c6480553ac34c9c48a4c22d65847aadafe09e03b101553fc8f308ea703360b60da064a86e5b250aecf4f7850b3383baf5bc7fa8c49cdfc055e5445a4140b404a76f4ac1fe20abdde122c5433499d5181f398e2ae1ffca66891e502a3b742a4b001e54439eb9708b7d17961bead32c24e98f614e3b7a981962f2d49316cf6fe75b1cb0a3d29afc77572e0dfdee63762d141f60a31fac72f96f704174f2dc5e675960e29e1d1b3ca18f5b513d8ec53a367a747e41cbe5adf3fd9f8b9ff4237ea0a08dd30723c3eb6cd6ab4ca0fe16e4ed345ed43935d8ed3f2848ebd6704f929aca7e4f60610d290947c131905fff01480571183857c38676ba779deefef149111b06ec7b1453328ecd7f0c636dceabdbe5afaea8d9384504efa948561d6338460dfced76d8b628fe7ed51dc669f93ef9b03104e2138f1463c00357c498e06c4ed04bdc56564c450f2645374d2aad45895dcde4620f8d56858fea988fbb0e88a81c756ccf39499d6755124804cc54568549dd7687a166d02f1371f982603aa59ef5348489af0d00bc969868a1eb9e52d14bddbe721967a7361386e0236d79b3e13ff7c72fac7e17f3fca69ba7c78868e94084f2231159e16057daff90c4f55482723480f4d9bcfbc8efe95f990f00ffb1454f800817db93ac21143b9e870ae3e839c1781e4b43de9620b266133b839ccfd4e4372015c041b977149a00697467ba2cb61812819b85d55527193d2f7a7436596daca419b4b3954c7b60dc74387fea75032b0f797b1d9d95b551f31db6bbaddb318c3bef325733a11883eea7fb30a17b9327b8581fd6a31d2c37f8b245454f70157b6bd1f006e2ce5da88c27415de1057b2ff84ef9a6855865bbd4d336670956e82666a5386903e49ff4cc09aefd082e947287770fea4678a7d8f6ff9266628f24e8d5cd0c3f4dea9d19382e36024cbf58e050df272622570b84b18d7f084cf96b6144bb3a2eb83c84385e0862feac11e7b0a6c48fa0522322a7134ac15fe565785e257393722b6d63c2f86d254dda4afb0ef8ded4c1b7dd3d21bb49c7b42003e2a08d84941d72ded4931a70e82b067485a25500035ccf791543f27484293491431b0f951ff49ff90e86066ca29719cb0cab86061421d6fdda98ceefcee4aa961aa3077025ee04060731add44c6b7f24f273f8ad7ac97600c8ce949f584d370815af3a1c86484e231aa32c4adf1ef8c33a16a09572c83519f0d4e64383c54f731d815d74d5bcdb06cc9fca29e5027a3b9e80f9e432a9659be698aad49bafe8d57b5ae17afca65e11f3912bad83282617a08ee366bd49e6a0882d2669bdd121ce37b070e03a3d13ced625aeca962a959111afb6911854b85bc99b2129901b1506217a3cbd2bbb4e182b24d209db343e92e19f923bc0b385d276920d3162f3b1d384d2b7ff6684a9908cc30ab3e69c5a3e279a9fa5386469d658ae279b5b56792638fce1cc9d5c39feec7356bfafda04c3e18d6878a70b6e76abd44bcbbd70204bbf9e5f2824c910aac01a906cdde3d36ab9e58e2e7ce9bef4615305437431132ed630aedc74c43eb42f292d7775c1979e3b12c4917aec50bdba78dd3d6e78efc2774a725a03e7ce0d169a6fb8d88c8ef941b49c954e52b674420f6ba0af1a0cebe08384d6536f6ab689322797f9237f0485cad71813e22e783a05191021cfe8214f9f9b0051ab6342cc737232c4638bb120ee43e2d0119fab9f49fd0120f4eabda03dbfbcb9f7bdccd122f10c6ff49c6741e5449a0d55635300c94cd0f111898177bb7d56783bdf4112a8d267abc31164ac49f7d33541ba61908a8830f4cd85d0156d78781d98c9d0a4e367227f356963e3f2ae235e9026d2db3d33a3339b94d9ac84fb99a6d27eff20babaa470463a3e7dbfd5e9a1d52143bbb1901b1b37f666e2074c84a95d043a693c8ec7e4fecd893703cf3dec237c4289abdd5b056fa6f9ce9b5fde3ed648fc0f43fd8c7d18869f12e062e3d0523525a0c6b38242f8cacf32839121a4ce836296769780e9c5fd8e1419badbf07c6867dbf28d2e82e4ec9483aac63550f6feef205247b6ecbbce5a2b1d83affbe176353d920f28eea487eaafbd2dc2b4de834179fc34c45e9f71eb9699d24b23cb76d23d3ce918fdc77ee0ca99caf4be59a5680f602e98bc929a3616838ef39fee2e579a3c8ff9acab76679ab4a3bac111cb66fe7022f58285d40f582f3d7ae3da8d62d447f7f500a681bbc85a5d5dc50f750805d8247e4ad4e8e628a31416c2c56d8758dfc06b0f6a6c4d8c24e8dcc428365b9724209dc96d4bfb183bc8ea5cc72b10de19150c880ac8a0496c364da759e72bfac476f776f4d8925457294ff5eef9b9182952f7995a04186e68592328e8be5b6093e9914004055103333d80400a64743000d3223f4e47370a9edb5abd176261e9239465d135fbc3cbc5b9b97f79b7cda344c6ed85c60ce606ebe2bbf1bdf32c776837ee2a74c28c9e5f4336dbe1e026ff688718a5474bec256f44d93839088034795f0b2e19b9c8ecf5aab43463b939480734b70aedb3424ed637a26b5b301259aa955315f2abf9c70b20d835029de12ffdc41a816ddefa12114b1a4da6433828ff7775fd325261d458e9a25a134483e7f7162df27cd945a5c70db9fc77812f690495d56b331cc4ba71f5f15e0fb6d97e9bf81acbbc1ac874a9de87b3e9caa46457a9e703601332d2161d7d83574446a3a77eebf880dfcc277f677002f86cfcc280a9c9081a4981b56f596b1b8c5f9328a0e745afe314b78e78246abdb1b5fd15b7b6ba3137f1fd4903e37da6f4962e3db1613ccdcbda642bb19bcb3f699d0d8b2220f9a71b4a8be224a6d0102f6c58a1ac24b9d87443e2cb4d02ad023e44e648503bb2bc0d2cb37db7d6c1f93554fec099f092255328e1c7ae57cbeca99c61a7206c22e54a4a09830614199412911a0a3e84bb876dc244bf3464a70ce6ea91c18dd94cc40d5b03141e2f0656c8686edcec5d904bdceaac7466692c08e8c6123607f0a88e31658f24da1ba0a52bb5f1be17fbf86976fe02ef9b069a2ed7a9cb7328bce50d9b0329cbede385c0def6e4c077fcf47fe28798b4dde6e17e7afd9c6e1d470e909ccdefc3c6ffe3a7b2d94f079dd4a2be0ffab0d4ff5fc2693255dfc5b8a958c8db8fbcad90dd568143f5ac1859dd8cd96f39144ccfd92cb95db6477a16c9ebee0ecdb8146112ce5477931fdfbeb441e21d0f142168ecd6f12bfce1ffc76223080d7b822066a5b4a072b39b17094fabb5be78e6691ff37a20434c1709300338810dc042efc6164bd553d33df7881886e9f92216440e83970bcd8fee6030e65d22625b16b6951d38fbd033a56fa062c694ca1577b16c6ad47d5dc293a24ad250c04c5a94a32d81113a100066df3e47d8ab7337475cab055e65696b6e4ab12173e9128eb054691e9902b118dc530cf88d3a125c23f5b415a164edb02eba70601283c092c14e9c6db137ab6043506aed5e009c2fbda9d01495abc9330ef42aecd3d14628f68aecc703c9f4570da0d59e52cf1f3ead38b52f08eb42bd7e78752eed94766b735705abc82c2ae387627e2a41be6aefc395af8ab56e471c357c2fe934f11a8f1619d41dd4657e1d660b57b626c8fe99eb305ba5b9c812d954efc536793ead8c29f075d095038957b27567be94db3fc0174d83a0a90f007dff1d63854bf9487ed9794f2bbc92002beda79f6628fae6407fddc77ba3ab1f54b89e0608c39c8ecf3a0e468bf382920cd53ed3be7c2ba7fefe647c6422002bb86187f1cfffe52819d4e31ff478689868050c4df514f619b290d461289a6f2c4baeb429ee833c97d2ef85ef3541e560deefe2c956d57248b811d844cecd1cb831158c12be9abc2fc9c7b4c66d2530149a28800ac31036a97f7cdf0ced8b2863e5b8602617be96e8099b06fc9d99f180a51dc5ea71aea87319e7d63d13e3e82c011d6e446fc44befa9772bf72e24dc3a88e578683369dcd5fbc0883bac7eff8c42c44d669a8d427139e205ea208b44511f36caf18e5fdf27f9686b7d6bc82cfea293a6f90df7516d04e5f9b36083465e6cb7352657f7b8190fd462a333b268870f15ee18549dd09160d59402dfea81109d6b234d2f889cbab8d29dd315b63e17ccd8f98f65df05e720f9468f62c679b2023f15a0c9bd38cd342bc84826a1291379d4391c73564204da0030ed57e1d0f14ba71b034aa38d390ec2c9ccf682aba8d64e650dcd127013f0366920d23a56f14b04ffed94d281f9bb23a95ce632daf22f8ba3b4857dfb5403fc6e70a74be914786272f304c513904f4462c9868ec8cb182906eb7570ef59247e961347724253971eed1efc44b2729ed689095067959121bc00ebefd2cfb9d5f82866d9a9682416ea6285f0cd66843a5f58b1917361df283ad2bcb2ef672b285b96fea52a0a44a129b1314cd11e6d5a8b61df40dce0b73615dcbbd49389fa3c001b6717c40d2f018c522c08de7d64b988ff0260fc908412c0bdea966fc15ded83fe9650a715a90e8a82b7f188d9a228937916d5d75c9ea56874607e1a48c0a77cd4ad5e7f5e09cad313cb65db41c5f36b1ffbe77137b0db35705bc1593f16301752b5c824b87d1e9ff42c7812d7fd0d8ddc13c42b657ac59b11fb7ef1625524f856865c10d41c8ec73f22bb18f78f09117964e9b9a36b8e78dd69a4a62316a5397d35418ec24ba44b65bd3f61d81432ae11fb5e2812808853e999ff43c66fb3b87921f6ba470b4f225abdde927041cc0e1190bc350fb4fea83917c6b215b5c0478cfeeeb608e32094426ef2d9df5fd0fb621cc080b3e3eefaedae65cff829749695c3e9ce7767e066a651bde4a7b44ce41d828b2c034cee4a81344f55f7e4e33cc61aca5e141b11072114f66759119fdc5eac7a240ae55c1626ba9cd9145a6456bcecb280ed4f9fe2f222e16308b92f5395c9f6daf4d16d1d5fb5aeda91c995d48267612225e7410ca97a4bb5ac28ec08270f632a3c42cd4af5f557605b1dc8409d8599f402b1eb59681767026bc6ff8bd2e2e9117c12365ae7acb0869af818ce87f6e5ccad9000ddb48caad3e510396b3c6aa47af465fa78a963fd247fccfbda2b9f0860c757a6a8d8b08dbd6c9b385231f1b99c6ac07fae42d35e90b5223918f039e4f1aa3eb93a6fe546351fbca7c48260369ee21d5a51cb0a9dcda0aef411dcd8fb24e4146993f3209ae086627a5ac4361b1e870884f810478687df8e47ff570f7028565548627a6b5f3e1a7211bbdd3c4c4d028410c5dc2d973fc2a1a869a1c3e2bcb8c5c50e4f4575ce760b6ec66dd59c2390b03ab241744edeaabb6657fcfc9d84d3641ad7cf5630c43a536809ad17978513629429baad45ee5f39045b3da7971dd417a8243ad36f342336225bebf0202efac4b144b7975b3ddae676c417b802829ecedaf3bb22017643fb0be9808dc6a96fc77a631eaed0f7dfbf6c95d607e49fc0a6376c7d9beeaba34285660150265a6d21fe011eee9395e81652759d925681b0e8ac790fa055e466843ed456c0db6294a078f2d72786a3d43f22321ff88e57059157223cd5c0644a67bfcd14ec0cc6d910cf5c07e7bc8bc313ec18fe4f66b805fb40bc0d9ccfa010eac19d81849a5ac68f4ce0eb879f673742cc32077c847eb919ec31ed9443b07e8ec1aa366644c62aafaeaa1bda58e428a791fb147c8ba623bfccce35a6dcb8a53490f2651d4832450785b3b82e879d05ed3a2abe5cde8d5f74142674adff4a4087e8593a066064570757913238c5720940706ca3b64de7e021fd80092ed62d9691ffb61f9d72977b5d698a7671b3b63d5e1869286565dcc1c6cd877aeab64a078c48b21323071f7e1691775a6ab1719f39a76c25c1506731f1d8b6f52435736f546ec647fcb470c2a27611595a8d5b81d6071575b2056427a3f8581cc15c2b7bc1dde7b3aeb4e04b187d41923ac57a4ac5e8d3775493dba4feac2a6150c006b5feee47294ac9a304a99e69c2a66e5077eaa519138c07936b70383cc13954e9c03f5a38678975affd950bcf5f501aae32b755f8afeb41d992a781f493cdf691cfcf492a8b08b2286a5f00961b961be7dd27578bed4ac41e188e8efaf3b3a19390415937863cda3dad5aec8b9943a1875cbc6dfccf9afde5ebfd3dccaf60285d5607848dadc8f88968a16fe814b2d4a1b8e3bb997cd59eef6306a12cd496d4200ae426735b85dba0b138a2408d5bb63453561ab381e52b3b83069c386dc566b5d104f7b631881e12f8122d07966fadc39c9b13e9e167aad2cdae08ca45d32941e46b766a9ab705f2388d731232ad5ee3f11c66192e6340397d587dc903380134b098cfe1cf4d9a86e8f9077d58df8de0bed22b29da282bfa4bc71fcef61ebc26c051339a926486a0047e0e0b71ba3cc23316e9e306bf9b0bbb7d8f483b91b972fac77bff534b214a3231748b1e373c8d95b7c09c5d1b55d01eb6a3ce2ec0eac5ae674fcbb8c9da758f1de5ab1aa35dda187d0cdfffeff9aa502c9cb957ce4688aa2c09f007fe08c2ad8cbbaec0f9d475669d2e3677d90e6eb1588fac891ddf7c0379f9e4fb44aa8931b43454dbd188c5393ed020bb63f12e2478810c835fb6be566c3bff0a57ecf0c75bf9a7ac4444227f09ac0773bfc13398bdf10e93ea502360734c44b80f563843b1945341a368b12c0370c640418d323316e9ccc92d8fc4981874a8f1138bcb4c2e80e005c4c71b0369f660c87db897344ac994b21196940f5074c91498a097e0d210d1069fefd98fbb018b04356fa3f387a4030559367370782a0a60e7c49f53b072f645c6a63a938c8fc3c7edfb8fba664c029df956433bea77d9dfe1f5d8db1b7a4f958378751392c86aa681b7d44e3080cb224a2a37f814064b9fdcf4dc39dc79dd570f02a3c06e68f6a1451b69d2345227f2f7c1dfd044b311f3813b19c1456c4b0898f388df9b85705992ee5c1f572e698cdaca55370d52dbc87b601244d425262cf04a6b8850c48b7b05e166a980ea9cec2e49f995ad7de93125dd597258554798f5e3059280efe31dc404c0080662453ff0136504da35cb058a082d0de61b1dfd76c42bc439d99e34ba5475449fc91e04b2b0756b55811d4fabc0c3461dc9d2f3efa647543a3024bbd5552c694f78e80878446da86b1580b856201aa2954e268a7ca40df53043ffa356b4c36deeff3ec272acedcf01504074979562cc01c8b64d557e85a3128f3de4f31a18726636bda51c78d28eb7b9504f8c15959cfe4a4458e5c50f57696d7405820d29c606a345437f687a16b4b9b9936a727659ed60f94d172925e4b31b7b81a174b0513a9d14e22e7dc179f1b8448ce87e02f3636c164c724cc202e95b36bc00cce0661bc49cfdd1d9d052fa647b46c6acd599ef523661117ca5069ce0096a0ded4710b00a2c143bca8232f2b90c4a0a05b1b4586a9c313affb25ab9382ac87e1ed1a3ba4a71ab2f89fe9533e0e5140f5946ffab7ff5e76e80a6e2d728c22e693b5f0b5805e3e0ae4d015b2f702d0f96d0ade335487ec9ac8cb88a11ba7cabe1605df9b73703644004376526f98b1a4b458318fa6420e06301bb9586c7f2c3484b18bf8eb808d52055671002f54bb9e798f35ca79e6e332b7c5a3bdd3b124ec1613dc8fc0ac9676a58dd154a491c39e056e41d57bbca3bd573f2e100136a46f7fb148493b8372e4312c4084d701d673c36b2cc8844fab01447d38bc1d45c3dd2e25462e8ef6d5ea2051ba65f594b480bb065c1ec4a5fb7ffb02aedddd88451f3253d093658b03f97a1465c2ecfc34c24efbcae81cac5dbbeae0f092c8116482a26494a81d6cc1e5db6baf51ca8d554aba0538d84304295ece60ceaf41f9b32add33ed868cb3a5b818763437c5a260560f7deb869b2321cb507262efe5c1fafbd8b824841864bc7de2382a5cce3bf1bd273ad04cd8483e7cf152d661b42866100b435adb98813277a78aa73befb0c8836256dadcfea7be828483c1edb953b22eeb179912fe1c8051272f3f50062af09e666d6ed2384e2c8b94d9b68cf4c5e18e4fd29175a9582e7c433799a6598da035711c96cb10e0fdfe6bca6bed362347d65df00576c7d302377ab6d978ecf7a3fe9d571ce24d64be69ac3a3b4b9a2165dab883c1393be7016910741309194d2900ebcb992b1024a96ece94681a89f3ab6c9f2c3c0e6b20df47031758a50ede3f2b2bbb8f3fc82418fbce9ca5b8ee3ee7ad4a4d9e6bf92875a6390ae4e68489fbf451115cd6aed12a2b3ede3d66198007288d66134255e36785728539774dd1331618997853d5bf04075a5e0f20470373e8fd98b62de8a6adad7e8fcdc8c770dce1f0dd76fdeec3b5fcb82d939e151bb934138e1d719a2ab883111a594423db70c7d47c2498cbdca93a834a9dff6be6a0e76960312c041d2d0f31e398426998746158eacc2a778c96f348b55dd2c7b922ba91d02f59f376b4cb9e207140fb1b41dcb5ec1e79d0c4a04133dfb017170561ff8824ba778a09b43a8490e5bb35f327f72122be390c5a57642d5755e2035a139642e09f1f3b60766edd95681498602dcc28fd88340f1782c8dd614958410413831aae91d46e3fb1dcf97065d19289fd32379e8f9a27dbd18ab6a69cda3e9316f888f05a87277c25da922d4d8f388c2aa797af138e304f5d3849fa8b4efab3a8f217e78d35c96770288a10073c60aa776c85b9f3fa6b88e6d5b20c065b9bd6fb3c9997410aba25cbb0d1ea375c0f83fb836e8fed9aa9995c8a3ecd745acbedb33f0d04ea8f8ccd4d38542ff3098b4b4e7fbb9886c2b822340bf10379b099426e62bfd79fa7cbbf2e892be791fa57472b3c5babe1e584e6e6159ca7db2cfc7042d0ab33a56dac82ab7f567b427d055118dfe759bdb361806807144d4b7d0fd7d4e6082c74fb3c0f95d5db389bd1b4eac9dbc16299d2f1dc172314a3c4f116708f89631555413f1ab1b73dceea88fbb42ec05b959b5d0204048e1dee2a14f4911e369675d5679558f0aaa3bea801ad613c1415a40096ffe730244cf4397db415938734b1541fc91f2636902ea0c96eaa4bb322481cc548b2ae34ec6dffe0ead5ffc9ad48eecb103a8aa9fce7c322310d6e3b6236d056ca72e7531bb78838889f9d75330b7c429894023762d56ffa96dc998de70742bcf41f3a77e24324c610d10c02672708053ccd730c0dc1c6764e69b8f89b3d20998f2db2f23f71f7dcde6c0bf117868f654414ecbdf895e4f3690499a89da19e8528c7452335f5ab3d0bf2c53f1a36a5e6d5e7760e66938c21febfbc5a07bb9146c939b7ef4c57f815b9adacaa46f45913d46fa3487503f6a9566acbf1718f6b668c84875b949ff8331080210fc2e0d519789e372e2265d27602cec504737e6146e6cd61668eca3409db4bf49640dd0da755a6c423d7093d1abb578d674608d5035381ef80007988c45746cf9bcffd2eeb84c67fb8ebf19e838f004ab13bf0dfb044f8c504f9e889657b0a6b3963a58e52e63f205fe410b41f8b4b53eddbce227633f506adca68fe1ea84fdfc50bb19076476eebed21fadf2d10cf60c5514c67f3562a3e145d5cff46a3500226119606e9a1885b1078500953c9c9ecea738ab1a47e9271f13638b9f2a6e663cbfd0c3cc18dcf65897ec77a6776c5399f553700a5c2872b77af47794f5ddc306f6b719fdae827e498485ef2d5d4f16916f5d14f67c9602d113f225c6fe3ca929c964f2917a0fe87e393181bfce7c4840835c59d3b0849fbe58be2ce976c305edcdd616e162e26bd440a399d259e910de5bdb8a8f6b931bcc8189c8a9a8bdf9f8fecb10808a9480709b6640d44e1200eb2a04bda4910031682461e30f3f837ae4d89746f5ccf247e163cbc92fb990fb8994c71841d866addc3c1873a202ccf6b8c259023c000c2ce3e06c640dc9d50c3a1ae701a2140cbc888fd48e2939bb363b1f87ae3aa6d4796ab521381b8f4655d26e22e23dbacb8332af8d647964b0a7142ef60600fc15d6d3f1d331fc80eefe88c0c17e61636de504e68b5e1d66d0ec66fbbf7e001a5567354ecf4363e1ba8f53fc881e4d65359e4240df4ecc07f587a529ee59c163ece8471747e4c2936579131b08132125f134a1bef5280986a91c5b1a88066da1ea9e3e1a130d6a0c0df55185fe95c2e9a0e0446e1a3aae446c91182064b32cb784e358a497d2f7fa08cd31463c213c60c9f9d0398b97b271b0e4739f8cf38eebe653257f2923206505c8e69c621334a8c499b6c120f23c7a9bbb499291ad278a65dfc963bee82f49c201ccff0501526067af216645c8a8cf2874639bcfbb1948a557cf2eee9534e1677c72d8ead0c9666f2a974dffe0265895929c3c17e14de4b5e9b6f62ec604f67f6e3ab35b6f533a076b46674eecf3b645add9786c741e52cb6814404ef6c246e2f5b6b5a8f76c555359dea950c79e2baedbc1887e77f9168751dd7824d3f29c7a716b80446d79f56a23778967811564235c5177272b3a45ac003f0c543c66641efa17215f038e74dbe8da2f7793d1b92ea4be5a2ba4320b8eccbd13c5fe483dec3799d2f4e296a5f529a62a6ec0fcaf05a0cd9fea1a1807f09054824b4030eb4d56e3e5f60aaec397a3c621d60895b0697b28f2d8a718c59649ba09e167cac895f081125285b337948a7d1b50b00dea23ba8297582ba6d3e902c3fe347582b2e3e6273308cf7eac559a4549b80c22edb71993e85d1b7aadfb11abffce0e265441637d930931bbc32db903d2708010b9af8c6c43d0f5cf71e68523d1f4ffef78b38260e2e1a576e02d4b7dd5eecee87f0d9a707598bbd6403779e197bd3d020e267586ec78a6ec96ccccdf5290d911a1c8460b434c83e5ecbc5c1114263521e2ff288e5ad68c0055a2f25465a05129a0afe9a65749728b1124ce2d3df76e4c9b45c596ea5cb8db8b492dd7b4c075b7c51a44b52f5c2fcf7b935c883db513fe84cd51bcace925a4eeef09dc33cb2f052f690248d46ccd747b1aca857145aa1b15eaef59fff2eb7524b56ef6ae4915e2aa77c96abdead786a9605cbe2a089f093d8148c4ce4215cad8723bfbaee0256af03893c69f89577b5886d4256d5dc92ab12f4b8494519d3688c3a74384c9b3961d89f563c9837dc219cf2f309c4e3314ab14470dd22fcd848afee8b7f4077d14179ef173bc244595f35e2f6f08a0c8c1e899c4b7816e3078152d7047ed606ee18e450967725b6f8c78c723c293cc062ad9af63d6f77c4fa55344e73533464494ac8c16075bd95b1e97975eca5116dd1959223d573ae8ee4619b66d64ba57bc31484092e40f570b72e2b801524f867d106d59873ab90d2d0e3066aa08166e9031cee31274d4446138cb4e65d10ebebece817b77950f6c2378d284dd94d629f4d531361a90bb06a1e59f61e7006805d2ab8a6a88ebc27e88ad264d20f0959888b6fc535832648b6d08f6566353445f3ea10d628129442975a15c7b49bde4e6b6b2610705aab94b83b8db9b3657e7ae822693ec40212ad652f4d932afd580d9a7d282d44d85dc76c732e9c582551cf19d7acff91e37feb474a33dd64a0afaf1f0adb7fdc31dc3a59e37db732c783cfa4a042c7ffbdd2ece227da905fb8263cf386229fea5ccaffd2797930428d0a34678fb7e2e411145823602a12e83523809905d9f0812c59bea9ccba8020f11cdc8dcdf25bc0b363d003bdbe2b170b898ec063dac7149453478092208312d84caa6171cd776047faa174ccf5e0fe7cf35ad2ef545e436b2384473ae2b02d7b449366ae35ae85d3addb09f9b6f0b512d20e832a1bc1327d518bf846dd7269c5251df890c3b8c4e6c550cd9f636038fc6211e49b51ffe4c36f12c037197521f4e8b155e1d8164aa9edaef43fcf8e29f555676544dc16c85428767e3ac2cf603c2a5112b4b0699ad16c48b5c4b597e8f849c4b83996e8a831152df1caa1bb84dfd7c094ff6e93593f15ec523f21ed689711bb4b2ef5fa3e939e83e0d83afce0f24f2b3e0b2ab494b4ebf6864713d1ca6a0670791ac8ae0d2537399c784f3f5c8094e86843d0336c053741743e4c68e610fe0d077dbe1a10b07724189e652f079e11b1f5e71a0c6c4ed3d87fb5a5710f6f43edb86123ed05f67ceda924d1b3b0eac47c7f09e111a35e86a7b40a5b869475862ea97f2ac3b18cb271f57733bfb6a7b3ad2590d79882c6688458512a01cee84fc18f56584eb946078dd35cb68ce0cc08f6f1c3bb65e3667c81714a5cc5f16be91514c4fe78bd3ad73d8434d5b8e87a7c8e5506ff008414429a0bc3ed3956bcb183b023272dbec327add5f16a8dcdcedb67471bd98cf3183e3d6854f17af8308514baeff0dd8b65adb13fc0503c62d9014c6b69de64c35ec732b33345cbfba118a305907f45177c210d71e5168e5c41bbe6e50c5e4043157273370a82cff980fb241710f4dfabc91a43ff6c4c3a22fd65afeea971856375c2826f95451e205f4d4d8c140b445f4efa5d36660eb91ce042da9dd756d7d0c5ba30f4f65e0110b5ccfb948cafb89e73946431120d706464a9f62bbc4ec40c55a9ca76dd578e6b17499a9f07eb48362dd52116763a44a58ff518324a1b3d47950d3b874c1ba6704306a7b862c2351504bba5c67174bc55cc1f8c998367589f78ba4e72946dd1ee81667baaad7fea124f51e7b845e7824d6d274b82d2f519e9cb9ea4c2d9e8d3bc857e126a17ff73136c08abd3e068a043caa209a4fb99685c79050cab54115776507045f5986efbc9ea8352ca4501287ee7cd7e34923139e6e118212b62aae4bd784d97f3eb1a33d42dc72d17d7bc62045ae09cecd6d27bb70990dee5daf5b28483fd2457d086da8d9fe1ae229de09f43e6afd2d8e050173299b7f4b0b5baf6c9472d244e6742f6fa59483eb0f579af005ef64208c9cfedb1f04be16f0599d6e6c8917c671e141da1087ba163dd056d63243778982c176e7f217a0f72a92fa96e8e0d6afddcb7bd69ab59be310ff24b6ae4a8f11c63cdb80d392b99eb615f21eb154316d7eaf9069924a417d2e9809617e0fa8b8cff5faf28da9ac1f01ba544a119e47f189c69f63b61edc3c1fe83d08a35172cc3bf5a3807870fd0937260f98b1cb73a1eab12464f3f22ad73fc38f25e3129a24d076349765f6688571c6c7845f418084d5cdec9e6f7915b76d96098f87a6a12c07917a13cbc2487765ebf7c3db974792d5295e359767a26d5846d29c5483ad1ebdbed9064c80bdc7404f313a562ee04366dad9166e6fe0e7b40408cdca23d9437e5f45852b7f973693ff0d4681da7546565963ff7c14e75f5d1ad5dc47dd855947a1dee463215181f77bb689c4b70505eb8c7949b9d3b6ddb8e45a354cabe71e899ec0c0f0401733a1d259c692d06da78a7193def984a07a77ac327f850c9d99729642bc200b910d43fe6c91aaab49bc3a67df8d4670540b3ec700108ee85df7b78b00d37066c06a1f92220be4bc63f99efa2b407d2041b1c5c9aefa529531dd09c90da640c132eadbd55bcb581710091fa7f670325dc9fe1366183fe0ff5014190270150c2991c5b230547c98c4760fcc80313960de60e482342f9b1d65bb2ec4b4588135e7618e6eeb2b7acfd2529c15a89692a32948a941120146ba21bfd7a7f1e33c29f552ca8ec46bd2851f52bc6dccbfc9c67abcb232868501d05e45fa10444d819d259e4774f26dab36383eca3b2cce95ca2abd612b83134ce734da4eca0e05c9428f7d9e02222089f0e096093f17f70d6d0eecba44a76cb87b3e494e03dd526042bd28aefafade1d0bfd5ef7c7f967225bd9256dc15b79f3060ea498652f7cd61bb65e4311cdf034b8c16593aca47823010a1eb2d846d0ec4d23bb2dbb49aab6b5e1830d56370661f1284ef374c0470316f634988227f3a27bab0ec02b79eeef2337268d06e4d8365ee2d1982c17933369e87e70b8534586c7157d1009043b4143f693fb7c5c013e7891d96d3ec6077254624685d13744f67200fc80cd4f8eda3abc6dc3b8f829751fcc802340062ad58495a7a5c0147d27412e270c14755dd1bf0a4af4f3540a9114faf3bb3a30a4be9424f75df3740386db391ef29fa6bbf0c10c11e9f97eedb1344c459bd71a5b856f84d3834e692efd43495bc08a6bb1419b69f011a4ce4899368372e0b0609adf6d840ff5150429041faed0f0ce3d68aadad857cf06de2dab751de1d76d8c30f193739353c9a4f2c991f1daf125ff717061b742985967c5fc5166a599477f3932d888c26e7b130e3d1ff5fbf855a82c298179ca8f5df38bf82e5f9c4c1aa6bb0b3e72dad8b243d7804ee0912b0463a4f84ac1e95587878c93b05ec35e4039845e1ce3e210fd5e265d219e7e0b887bdeb65ef9604d21da04acda5434ec486e3b3cb4f35c1c786c48f0e3a4fd3c1c86603ca6e6660e6f56089abe16a1e9d49d1bb28d82cf8c0889af91941c1514e0d1489a3ac4a0bc4d643cf1d3b66e6df6bf36fde7191f57b7f58770f1ce427379d1ff7708483967ba830ab2e59d0146e0de5cce52cb28529a872facf1f280daadc0b6abbca3e552821904dd1155dee73c9712356e27b9722a5e516e4e50610db543824868ec24d78c661e8a6d05d4ce4d687d69ebd704b2f39d62beba25bef028b90224f7f900e06b4c08caa6400e15c04dcd6ecc8018754f91094e4f34427bed5841034956a403cceb7fe2c6bf77a550cfa611c7da3ed2713d13d29388dd87fefca0604c0dca18462f3f1a6a7a99eefc53a880d75c67e98d6eadf716866af9d6e08300d85c7a95a22d17b844a7513d6a8dd41e55f56a037389005968d57041d870d556b855643cadf1c92d223e765e105fb43929c2b9a820d1f6bd7f348d1c54f616271099cf3605b49bb94e9ae3f063ad20c863f1b8e05922492f38ed513aa7d5960846996690e22878a3861e9e9597434025fd0e40d0a240812b3c818482f23c4ae5877c6c197310c942c596a9e921314bbd8db146d4319b40b955cfc509a37822255429cd08669102cd3aeff35039f9b4ba1c3f61b6741fe6a2fa1172a786be3fc5050d241b64ac199827a936ea71db05c2a85be025d00bc30ee24f8f4050c375191c95e0729724dd87da09849dedfd35c6bffd5d89c4d4f5f8b51465c61f4d0b52da134a03ef44a881cadff39792e8381cc356a82c233ac9fd16dca4ab6f19374633d9f88d0210cd2690614727f732ca68b16485191dae5becc7a5adeb1889d6a9e31f9ecce87da3233dcfb8de703933d6bccd588ede6e629a62f14fa7f86981eaa80e186777d1550a498a4167157ccb6cb36f7a8e77518f01a7a2c7edfb156088f4115efb3739ca9bda087c1d2c24b78a9a5718a2b3e211c617b420aef5a2bae242dc8e1e261b1e160e05f600f0b21b55451201ff068209ea923e5e6cb1dabf8a987a8eea85b86506f8b0897aed1d1ec9583cee3d6e292dc7a4821fef76f165d97419bd012bc6da5c63741442fe70f124aee93e7d17cb86dddb72c0185f87c05088e8ec3437d48fc4598db84cc2dafdac0f83adfc5c43286a3384eba4cd5c3cef230fab87aba3e09114d4b16104746b943364c02a91561ff8cc059d8bef3686962e6a155082578f95cbc7157888f584264c0e9a4404340bb8aae22dfbdc5e69e8c285e6f5ac38ce97075c6b3bac8c0b46286f882c3955b08ae12c51f189fb9b2145d14a281779758636c676d995068ad556cc0bb82434faf77838c1a2c3c972d65478ee3517d88763a54cecd0f6fd960edf71a0e91600b0e229097d155e6aad4f70490c6109641bda65092827dd2e84a83c90931046d88b24a211604ef25e3dcd82cac5ffa539527923bc24770f54a8e3985bcd7dd9e77f7913d881b2dc05026013880d0a0345a12b143f5b01ac1bd299cc34d25043e81b7f76b296d9a5b611404bd53831d6aacf892e08ef67d57aad136e65c565da182d14743a86e28a7c4c46be48d2b954a3ae6fca1f2c23c17a5cc4d782e6daa53295e2bc3583d6b047f15e47b17c3cae19c8c628e64596ca8ed34827424137e5f1dbed76ee06238ad827dc70e0a10f0e8d44d3001510782b5c1138281c363758eedf6a2f52256ff6e749c9fc7fa77e6865c5903fe444bf2e6da4dcdb8b71f123b9504589f5b718cbdad23c0e2f5c8c454bdb4e6464d7aa54cddeacb72ab86d6f53a0af3af1d237856a598500900d926709c08f81f13f20a52befbb626f9c6dd5a87854e0fa08b56c9f888e385120472121c59631ea268e5d8a02b7e102e2f1132ad7a7abb82e894ba36a384c9d82cec9af260bb383214f578265eb573ccb2a5ab19537722f0159befa453c533ab127190f6f720f5d0585cf94b5765ddc9a88399e478bb8ce59bb01749aa9ce769ecb946b8a80d47f422a8b756a494ea4a08ad91f80761630a9daa535e77c1124d12fa2e92c82c889c630105cdf74d5ea2e2926d9538364b3b711367ff3adf271fc8a491fdab2047e3ac61a0647d615c77ced8a86a01182a62428337827300b5e12e860d3e2c2bbeb8dd95e4d96577857c0bafc4f5a5e4aab196fbf7ec1e516b068cfc05b05199aaefc9c1639fd92e595920ae85fa3117897ec66b18329e3cf815ee64693d55a13b0c46049629a7e863cc2c62b34221c3bbca075098920d594fc27e3057ba3a2cead1eb1a726c6c13f90e7dc3cd9fbf61bef2cc56d0cd620d8fb3db6d5e7450d7142a33449df82bc6f28d176dca7a9035e98e65fd834e9c9cfda17003dc01076bdc4a0482fdaf6b94159a99636ec2705b445815fd6a6ac5a6e273d468440f9499c65f3bb3cdeb38d5613bb137098379e82233da7a0dfe160e6c852ea1cb2594b43248c85c8b7b623dffa6d8a24ac9624f46167bb4f4e257261d2e7bd5dea5d88d9223fe4e39f749ee417180496821c32adba45f14e440700f6f9f87f6689334ba0a4011a8b7003be9a91a4fa1126b8339254035b975346c35a4f9ccbafaf882b773608b1af7653cfeb1b51b2a85defea554c42df837104f8b273705ebbe684568596041742d93acc9c0513cafe78d9417bae3a0cdb8e98e441200f97256fb8fa41da320784efb95a6f50a7f2cdb591e6a6f05be80b4b70e33ab1d6bf1892c562c0f560ab3910dcdd9521f16ec31b62a7b643a7dce75060eef43eb22ba87676062d978b4bfc820a8a01f5cb52faaf8a0d8d8af5b5ce76e6a84243b52c1c4b4467738245bc6548d1be308f0fe2565bba18664ea04a0b454b7cdd7f2a9f05bcc706e6c3e2f97742cf14bb510186bc3a166bd0352af8799b8edc960a417a9358d9051a73645812c7b8eed89b7a330ea60d5c7493c5e18b957849d485d3b2470b9309916d050f47cfadf50e7c021cd89091ae849477d250beecb7857e21283d156b287119e16f8bd294bd1ae152e5ec5be8c112294d561f65e60b7f1648a0f590bb2a3a63a317f8ac2c4fe189cedb66c47f8df2faeaa7d6f1c57239813d3a1de375d47c92bef74b7022af1faacc5284e4e406634c02f6c1889ffe2ce57a67c1b11bf4201baca01e078354d371e18ccad19ecf61498a91f8763fdb25b06b8dfdff6bc639cc5564f17360fe43f28d043f0e1e329ac3ea98533bf12f82c7325d64542d92ca6f3037c1b47463db63811741cb94707dd62e04bede1e7c0d61f6f95f1a48e65f676f10aee27f27f7c294f84238444cf7b05db20f5389f797d47898d9cb8dbfb9b01f8ec2268ffd116418eb20261178be425271d9501c82b03081f2705544ca7248f2a5f05f91e09ecbb08791fbad6ba62c8012debdbc991fdf1cb2074d3c7c2dcd957c9befc91f9b5a5f58df6096d8626fcf0a40ea33329629dda7cb0761eb76795941a84c2af3afb65f3d5494ed979740deebe6745dcca9d4b19ad594efe57d10b684c9a4af6e3bcd3f247dbc0bdb69b032ee07684b1bb820cc88653bddd698dd03ee8e7697f5f3c9fe1faea7c958e789c6b2f587003232a33f8b619d776de9ae3b38a163eb5b449ec39a17d60e6e178ce250a8e5801301dda9ef50603752181596903c5c6a760fa9f46707946abd92f6dbc601a008da0dfcabecd0b2114a2c6c73fa75f4db50dec3916df2a480a6d3558e478d075a442f973f20d4191a5e2ba2fbefa46fae45ccb9af19bdcc787c4069e42b3a0d5ffc153f361e67634ade2db2a6234cf2614e3c9d288051f0cec37d01df2ce8de9c40bc9a9add0cae5bba40aa544c8f8f3eb690d0c38efd057009f5fa2dc35a1cbd7f7980585534f8700374ef039430455dd0860e0cedc3386aee77d33205c696898884d1cd4a9b9552b5d07bd173cbec480382c1761f5e9ee936a7b1fd43b8095596cddae59258205ea09dc7eaaf4decf2f590fcf21b160daa78d6a0b9f23c9d31a33ffdba3b1165ffa7317d2474ea1ed22f26bc035fa08d17cf1e3dad889d277020aa374b8551d5c999247e44a9b617be3b2e8c65c108fdeb1fd1f310bf798dccc012828941f9c8b47b58a7966b2676c14a7780ff439c7b8962e4cbd5517233164720adec7ed7b410ccfe59538f59ad3e83ff5bb78f5577d7a56cfd46368570486cf046b1a859609418b5a69d848ebd0ac5e48b1d995c0f888539b850ab60cae6541b4626055e4b603b024986ad759b35df58cadf065221266da00d6cea794fb7ccad12acb51f1be0a89b80e7dd0c512620ef26fb5d21f167e46b98dc32e2f9200237fe84ae3a0dc0182ad518041f0633dc1feb3dba1e9c0174083e3bd5750968237a4aff652dfb66f7cab98e809cda1e7feaf256136888e46229442094e37d762d59b764a107247c1253d384f086ed1a09d5135ee81ff7526f6b182eb275041cadf4d2a5551c991f4a350f10bd05c40c2ccb63b3e81612172977f09e262343e5c0c4e4cd5252ad583b6c0bd95e97cf327760193d15a65212d7960f6f078e1b27da40ad8ea8670ed55578a18751c6aaa7d0f5e09c960af66af9a857b1ce9ccd52491bffa0096911a1e3ce741349d9176c6df2fbd0a7dc578b7cdd016c2469884c8b21a7091ff9762c0e462327883b23e6297b6ae7b5f7cbae7a679b803de037a769f4c25f9aebb697ce82c293fb88bba2c0a1bfcc436a0bc261504a6529c3d53bf06609973af90857f3a9a6371f805b3618ede54fb3a2b582620071f1d38d2b229d2e71778faafeb4b7a25e97e68eb0f7c507c125e15355e2cf94244879199e93b99166a2d4bf34d5ca979fe53dd915a8fc3deb879508b5e00a752260f7e895b794c956ad5ed5abd764da79c6f1a1444904f4f7f42a13b1ac27506ade42d531594ae465c405ee20d28e59f034fde117e48df3f8d9a4af3a89ecbe8449311448268088011f7736f26a4cf97b7e7fb9e6dabc90a3b145d5e1897ffdd7cb9297b7cf899675c6bfaa8654b74266ba353d90a9404fa05af15926b7c86be098438c0bf09e50b6d8b5f06c4351f88d5277489d917636b2c42037767ac0777a2e2de7d2ec42565dd88b781d84f464e1eadcab6685af42d21b0f582d41b493af1d52a5983a44786e500f28644978728ad4ae587368e5d13516e17f2f5ba1b14a53f218415f25f9ba424f4a16d86f283ac87f5034a25cf935c56d869f20f5a1d98aee2713b01b5b130bf832c8a028ca3797dbbf272beae97f1e1ed97d64a0bb45addb3184f209bc62e5ac8c40f571a7fd57a17e35027bdc74082b6964ed1002c536ffa78e9999cfa17064f7aae665d71acd0af879a7fabf243ea313ff8067461a86029e8eea1bb58a9cfddfa32a2599f87105592512039eaac8351ce2702a7edf38f5e49686af571c7388a1f151081e1ec4074352d63a7dbc4eb6b6eb6f10cf698ea3dd7f8810f72be181597d1369c8988af6c094d35a3b48c26bac6be4c42b404f4591b6f3f2b21ad45d0bca71a686c0d9297e485ac7d77d9b50586079833d1635f91f69595df3026b03b4062d22c771da117fbb46e2f101145a4460c91caa704bf01985ea0eec1c9a10844df86b9a7f5518402470b433bf2ccd523a539873f5074066a17b3ac95f340c8131c2ee418880c773047b50e895c4c16ba4b35bc4a07bcde55218daae8a7868469fea19133349e1ea5aaf1d1cddad8f90f4d78fb6f3d551b81c28f37e8ba4de86d99ceb323fe023b56d53140d25fbb49cdd42b8357bafc8b1d11c74a92eb2b0a904e8d3084d4fcbd47c62cfec6ec2dc42007e2c1e4b05034ba34a6f0cb1dcd09648327d8d30f46675e1ef5028e93c01a29b0979a313900790139404d11aafd5cb68342f7fad51beb663c0a9df1529cba44ab7d05c6685ce07870fe61480547c7bdffe4175e933dddb2348663bef8f23b4d45105cb42a9b57e5d6e1385bade6afd4b17097d6ecdfe345bc4666ab5d9e4726554ce1b1f6ac3460cc1db5d65908758cecd3f2789e340535c320a2a2f96db016b04f1b7c6c99b686950bd003e5fc8cf1ca727ea0f54a33aa7cf850b8d70e1bd1da009eba43677d6e536a0fff260b20bf9255d8ca36b46b5e04c785bfa0246c304d83f2493836b1e0f355a21a8b005ea87aec4deb6efb2baf8fcd3a97118bd00df7d172c7bc8fae8d37fb304f4c113f74a92d3cd8266a88f9ed6f8a651a1d0eaf8297e77f6d1f68138a8b66662282ce972e38d4443d826e6e5e03e97c3296c864b0c6fb754d9b3d002335ffd0cf059e29c6af61aeeac268fc7c10ef82917f354216e9a0c24a91e134ceed48496b1fd27755ba8f7755858b25ae7425865f3f88d35581db19577357d9da22b5fadf25cec1d1afba2e592c344b4363fbf38ef020eb440277af18022c323b08a7c97eff5ff93485e79bec2425e4cca94857e01b77b810828e4857ccdbbb90286cc11ecf418614347676de198419847de6f71e296265de1b247ae1a69143c7e7633381ba37e3ef99b6f5ecb4deff08bdcbab0877215efc9626d1d75740acaccd758ab1b6c93c16ee402ab5851f1c9030d3cbc4018751c2ae4d97404c8804fbe48f84efe86b61d5623de0156b53aacd19a6c6f729166b0bd3f9ada1b6b695ea403bbe1ff1a747fe917eefcb868bc2f7ae0bcd0d45b784c7ce1221968d354440d6c778fa5e81375dafbdf4cefffd40e5ac40c60da728e9cf70c742fc09b058ec71be9039c38352ea81e664268241e8584905e0e50d0cbf7b3d6b64bcb91c2bf61194e244aaf9bbec466e3a155b593bef9221bc286f7dcd9a76a76f71eb5b3803ad28f0a84733de7658e652f00a15cc3b4a8285c393deb36890f7ad58454b67ceacfd566bff72eb5aa4f1e347eae5c539f0324fca8c06f205a9eb245e8ffa76c863918c424cfb7098f3e51f14a7154dc46779b730abf895f39b016bf088c9c9f945e949f2ab08893ad08b00868e240cecf775abad433d28cd2bdfda869f625bf809b7768c3f9a95d2d47ca9c02b6e0f20d317ea2f877abd58f4e5c9976696a31acb6b24cd1e8c78371b69acb1c5258a9edf15f2c5935fb5da3f59c7f627037612a048c18fc33d02ea0a4d054f49e84fa55ea4ba0308d368a76f54c9f1be3898138217dc8daa3c6affdfd9db5957619406275ad707949b5fce905fb5954bc8208061922bd81a0d50b2040f181dd31a62b760d358c67df9882ce91eb9f56e9ec95de3689354453b45eccc1e374e87dca4af3b76077d6845f19a3f2cdadb999de93eef0963ddf7a7fd2aca54f7c99589637c31fe8661eb2abb39165ff2d68ae1991dea15cac76ebdc3cd364a6578fe5ddea6f172e63181ade6b6144ac6467bc2c73dd0ea5ccf1e7ac193661edc4fcb1a0d418df1be763a3d0cabea8acd66c231fcda5960cc017b69b89b8d5afd50d63964d99363b5efe7c82ff13ef1abbbbe2eea4f66a2815e9907317d68b8cdbfd8e8444c072589fafda12fb194fc77ef7c55d9747a09919b69857d3e3ff97354c7e4d5d63833d53ca3dfc633e944766bf53f3ab10155d82675f35bd86d0d9424cb881adbb52ee21816852216e33e4251266d0fdc7d8a94bee79a87e2c200ea885a3465605597a68faaee7c8f7737b7649f329e93b68310819712fc271a65fbf7b5053325ad14d4799ce1eb0ca7a1d93016bb6a4c7a4f61c724ac44d5ad8ee7967619bc5e68d0568a4c2765bcf0cafa72b0df9286234365174659a97c3d8764598c0eab042f6c6d3e0d6fa7e1e8f63c1476ccd0cfa013587c8e229eb4f9073ea086fd179c5dadf53c2964153f14f1b71b26e460827c8ad9f152b7d880c5315cf80ee38eac855cbaffbaaace4f789974a5b74c3ae222e24579ae55d8982332fc503dc1925c7d66962753f4e29baec12c6e2668ad472ca919129438a713196225a67ad7b2955618a4e51a84aab6f25f86392fac4fdffc997e1380b457d691ef7363a79e3b83ecaec8865902e4456f2a1edd949a5a06b0e6f6bb1d6077264c04884de2ee8443185f22117c74e8225d3c8a913db2bad46405a228d783baccfae3cd9749fa17588402448550e33b3d14d25503fdb7a6dfeaaaad4e8f0fc8869bb25c1267c78ddcefd545b35c60b9c3ce519f04fde7263af7f50ed24c34fa4589184b9a9e81be7b9a66a11346207c691deba73938393264628f16e46cf18877dbcfa47bb1d0a096d53b6794b7f4e655ab017a3d20845a18f9c31f400f8b2f4f200af3821b20aa76426372324e99ac882e2a1729fc49ec3368f9c32102d6b62420926fad8f228258ad74cde3085f59da705e368ecd42678a22009827973d09214db8d1a56edb2d3cff91761c85e9ba63cc990139711d89f5fb78024d935dbe8f29c6632900eaaafe981fe4c3240ecc0098a25bf35f3d19e79dc7960dda8154216b6d51672874c43359ca0f0ec7aa607d015296f9c21d861c151355736383158b4a4db2cd7eab788e71e9c1c354806107add8edab46fafdee1bcc2a7c7c322be8cbcabe373220cc2c2d4d5e964a95d1fcf41870f464df34a213f50b62addc9f3b716312b3f4331d46ec269f6a7ec6ce37c2897a63a553e8b7e21694e9c033bd607138723fadce33d3c6f15bc6e39bf6dc2d37433316c35e30ac1b6abd5f6b6e8096863ad8d766903f0d3b00bb6bd9b9ac207fa2a4a3297aac5073ae875945c39ed93d3b86fa26582ac43f104d40f4448978563e366bfa9bbb9a036ea540b75c88fa6cccfa528572e0c2342b8cce8c69cb46acbd944fbfc8a6195efab10f0865727765eeb21851e5104b664e39a169e955c5e0f471640dc5f569642f49e7235a42706529bfeb6ff44c0a4fc281f0ec7f916f6dd7746305c2f96611744bd99fcf47328b767a65afb916496a8aabde27743a1e48377fc58558bc8ce27890aaefa9828ec544c1a2b53572954b7cecef60fd0cc8188be9149ebedd4d48fd7aeda53950aa909f420a3f4f370821fc1a110ff676dc831e16f2795c0350e78ca4eeb482e6e2086e0f7ecb47b2b81fd24651c12af3eacb9e8909e6a38b05659bdc7f41851c5d2ece983b19a3475b2d6f8dc0548c8bd7110f7558e1851596f850abfb9fd3ece6492a9d5efc896a2163c325c3f3f92101ceb712eda2c7ea116da41da3f5ee843c2e21181bd80fab32641a44e1192daab49842c3068fe8821fa88efce329ba3a6736a32293caf09ce1e10a5c6ac307023e22c852c3800ad513549ad5485f5c6b671a09e215de15f2eeb5c0bdb6f7f6499ff2e415646937a5f3458cc0b6c51aff12e31e6812a74ba2cc4762eceb25ade38470cfc4ecbac6c57f06a2b3d9fad91aabb6db2a774d9e879a8f822c80c4df73b34a8db3e116492a945e46e4846d7d0022ec05a4cdc1c051b0621afa0bf514c88077d81bfa6b5768ce6e12e9a85bc214c25a629e8802b2557c0d38113dc1ed2a62ae1daf304fe5054b018204749b5ee70ed0a6d54d7a6c01674a793f02c154202e426094761221f688fce304ab031a3a5cdd98feaa4cfb5ed0f9513573695797bb3506792599ff93198a19d41a0ef855c96da51a71d056aabf2bbf195590a992105e40a1d7b16a68fe726b46e102c955760a9f62a44a270da1b75537a27523a62004afce92a5f7764bf575458e78b7e66ff89c12dd428face06d07efed836030df05a50c61164f32dabeca8e0a461f45cb892f31611ffccd37aaee00e6f2c208ddb7ea622cb926e48ee1d4e5a29692558cdc9bedbdfc5d1ec081d7e180571392679b753f6b09f05874cc42f18b97ca31d9e5a2153b37d3963a51220dbe9b5704b90eb5bc7dee9e2de6b70af650dd3e014816b33337484a2dbd8ade6289dfdd12ccdd430cb7a4ed42407f0bca7c6adf6167c02bb7efc38817af822a92c0eb3efcb43da3f81050c87191753900187edb1907291c477b8fb2c870a1c95abd56fae1c47b6de8800542c989805a80f523b913aef6825ca59599a5481f584cb97c92140cb5d64a52074350aadb3f6fe11b67429d8405b4e8f4507d9e8457ca2d315cea169610c532b267c90161c974a046c120cf69a99ee183f2f26c5c531c06c5d378b25ebc9014d9d08e67ae9829ca49439bcf4dee88fefc973009515b9edc02b86e2e7815165fed13de4af07c1fa63603b6940d3d584f11d8cf10668e2b055f2fb88122a85dfc3d5e9d6fbab2807f53fdd13d82dd4b17f9c6ea3993123b5e9434a7d1ec9b06e9d94f3b6ea3cb3f84282cb31748a839682eb425bd77601fadd88d1db46c17f249ec7e354bb25ca5cd94ca68bd6821d941d744542a30618019fa2d09061630b64f0eb769701c80bd8f9131be94b93125e2242f08f7aae517d3916857f21ff13359c54d140bee300814256bbdd2d25b69997a40a36b5a06b848ac8956d61df35967ec69961642196a197fbd93961822e0b9dc20484b7badc16ccbc8a8c2f26a0678a8b78729007d33eb0fceac0ce24893f8bdeb133ab3c8b031c33aad108e2a02f2652418a56ada4663de3713d02ff6cfe3290265da41858ded6289513a4fa1fdd8f6bd078f0d8de912281805d57e17a77b907425c3d7f8fd6edefaebb650712540c45547bf58a3b201c54f7b7e556d4f40f5ac849ba0204cef3523e0b5a62410450a743be1479efbd9284634960d9e3637415495a1de7cfc659a83d4015f5ee21c2b01dab10aff5aadf3a25797d4984416b89bd39f5b438071f95072abe8430b7206cf28e5837f7d84ab7fba260bb2bc37fd238aa0e16b3f2ecd0eeb49fef7465ffca49eeef7e4703f34d90aef25de4b6e44bad9b49b5b7b068dd85ed5073328ab15d4f27c7bbaafa563ff3f03fe1fa462685d9b53a5c79a692e8cd335b70ede60e9504d3079eeeaf404bc4b67c6acf3e0f37fc6bce712ee5bf85a8df025848a510063cbae5f2c60b4e74fd86ab41bf1fea9aa57c4dcb7002269666e214c5a292631f759705fd07679c9cca1d320586c103dce088438b6ac08257289782031ebc8758a9f4b7c5606fd193bda85238f9b324f8412f772e04f9587c92780b0040e9b89d2750b9f6f0718852019c390c82e3325b0b60c772d29a804ab418980b4d860ea804d17cf2464920157c098d7a55ab245ef3b1f9f0e5f0a84b1ba6d4214c88628cafbf5c23b56225598c735f4d81969afa7f26386b53d41efdc1ac3230dc0538e22769ca994325835539ed1310564cf15d1e5a259d54519dd90f26a5b60b379ccb07ca0bd5a08ab7a6f1dc55eb12bb9455a05fb045159891f0822538a16090bb3f9e3e728b1247323ea2e36290b3aba36ba63868be4800549f25fd841576b596e9e4f8b3be62959a34a24e9a0c0e62ccbf4cd1d557959622da9b783e3c2138611be99974cac47dacfd0086e32144e8c0d1d64b962e91ecbec9e6ecbdd0b2784a481114c254c3f9fc0873ab70c546567c4da443134669a2bf5927690a525bbc2980019a69b240c5d54e7648fe6de1255b73b3ac0b1965d1a9e318bcfbb6e4fe54b56363536d7df9f4b6292cfb6539f3e8f5578811c2beff8a16137604601d7edd7764cb0ced798b7df31f5007a46c3e870241f7c6758ffcc0f21ebc96b75e2acc1a87c4cd9dc33cf7a5cd65db9f9266e001ef4de42324707dbabbbc7e3465967a26e2df0f1bb826a2630f3765a779976e3cfe8ef5c49cc653d8ddf81e804f37632f07593a963d68b894763357bd7f1c5375b14d754ca4c15fe0f506c69ceabbd2a1775269cdf8240802f1437818851e958a35ec89109e87d675c9c86e030711cb382a8840b1625b58cbf3a71ae97130b83d3e8f6b626744523d6508a0b54bf69f267f5f7707174093fb7481c9cb66d85b8a40738d4c1b493f1c87703b529544e28f0d2baa42f843a371ec01ed26f6e49a780b3eaa8dad6a08785244b28ae3e83c6d397488b9d7a9ed20d1b5f8e6f73346d276893b5d99bf598b4b7b7084647dfeca0c52bf6d72def71ad7a590ae33cd8b2fdacca6d60e5a54d6ec32b10c28318e2a265b6bcbf45fd46a3a87d38535315a6db2d5d46fa440164ae58a259ff0a420f71a2adf852b39ca2c3f6a7b08c698bb2a2ab2c3eb876858881f2e7d6bf1dc10214d5e22efd4a60f51a81d5be56e60f6dacd1607517ccaef90d87ae9c52f7aa2c08ad9b62d35573b936aff158988dd6bdcd4837285a148f127e7d3988a0cfb052dd4a96d614cd29d08fb7a3b11ef246a403d9036c945a8f2e52a451afec8f5188c4d17e1db4dcc2d75614cc41c6515c2a99a352509c9d7e1afa36ae333fe013eda3c20ae79146d1316ad8023d84b6933f1c62b6e70b024e753c0cdf485a943f99d60520b87124c623f11fa1bf0d592c165183dd719defbe81a08c959299aaf3cccde152293304e188a6d10220c55349c4b889f27d94bf825bd4e77de0798c476ca049008a91adcae8320405a05ab34b603f329cb6c8fcd715cbaf1bf2e919ea183d43c1bef49d4ef5a9f1b76fe242f1af04cd87b52cfb1605491e2cda019dc0c87903d654476c3450ac237fff3a67f51de9352c2cfaf9a556f04a518770198612a3b5ffe26389cd8d51d4c206abc6b24bc764ac2ccc1892ffad940eee06e02a1ff0ebc3c5620256ba6d2cf975cb803af542af785eac4b98fd3e5d1de90de18c3cdf891e166ba77e494b3cfb50bbf6f175f569b71e7fe3cac86e90ab8d6697f3c85b744dacd2c609a6c08ea509d60542dd3b22764a1d920b8b72a4716a62462dc81f5ebbded2486a5c6b189546a2b93e69e58579c30fd0738dcc4eb9d231de63583e9343010775e98fa8b5f28e32e7f701227c21e0adbf374e2d83d2e082fb0eb1ccb54fde562f27dce7edbf8abec8e41ad8a376ff378e3210988dfa9711a72d4e92270c119522c5822e60777f8ed14f13ea843f5e4c23f0b1677a07c81ec3307940b86f404c7a5ea59358c1194279aa96a92fad84a69643b36ce00a879a5f4bcf8656c3eabb413abef265d3958b9743a5228fcdcd6c5e0719093c47e98dffa4b0a668aa3f64b846968cb0f41b29860f3a69aafe648428b96e4280c06451258bbd838bcd4d84e64c05d9eceaeb213eab39c5a5d8c2ab9f6206690f72d298c0487fd147b1125750762f22b5bafa80cc5eb7b4ae5cd1a7b08b5fdb5c49206d5c6fe6fce8f86a7cc2484455e092303dcc935fc6892053f061786600f09c4107e1dd30026435f2eace0cb20d3065a15b597f5f8ebae9115b8466a348b7d243a58e4c84e408f345067533e60b4e341a03f5d3233cdc65e67e372e823be45dbdff94d2f42c18b7d34c3f9ce2515322f2c6d55496d6fc2f5dd9e28b764d25e4ee071995fad0a3d82a909f3ab0f44194a44ab6efd162ce940c8d113e60fc3fd64dd35c697c36f88fc6bc6393d7fc6c837191f9e20357c8ec79f056c749c5e429eb9a8a94b97ceb46f3598bb1587ece0bad885666a83bdf5a92e7bb22f210fa1504f5a14dd78592ec319ba45ea3e660814036973f20ba2e85ff2ddab215dab925346eeb3caf47b67a6b1a89d71285d55b8425414bed93376340cbda6501a68161f88f7512c8f4414ec29f69bf8f5941f0c256c1a6f531c65a12d0a5bbf5d81dbe30be2a8f20c82f6f2da260c36bc1ffde9913ede5c47f1e2cacffc98e0e8cd91683be33c3aeecdd81a268768314bc7fc58e08aa6fa4f0efcc3ef3814c140d097d6716d399eb8a4f0c886b0f2f7d5077021a663633de2f178e76faf2cf9bf4d85efabc83bcd5519b8b57809d7ac91aa5fad4d9e10770136bbe322ab37c1c739034749397d81856e701f3e74cc8d577962efa1705ae18fa81edcd7159f6b256cdc3446fac3ea6bebb679d527a75bba5ecb5ac1f3d80ac34e76bb6a34a25f6ed9db21a6bcb3d4374d2a4a4ad263cf3c0f0daa034682010ff3ff19706cb9c4584b57e43db1fc5cfd28947367be1e58b31e80969e0aa3944648f0a50cc01380ef83eb77bfd78b5b627b5930ff8ec2aa8c8a73b87ea1660accbdf8f13a6ff72ab6160749045c6c72cc7b1098d06b895195762f20b97bcbb8b366dde309092f7a5f8073edf6f12f7ed65cb1c9407a4187df553b1b019a51e091c72a5cccd653112cd02f088cb1a41d7476439098b2f66cbb0eb8dc943b503c708ae4ead732b477f660d0f4d8f2a5f68613afd90acb34f96fb8bea8e9cbee939d20eed9aa11a1a58f6a1eb3fb2c8b353db03259e712e4815375d8111e3b015fdbbce1239dbcad95a01ea63329a0d04a978bd733bd6ddcd4da83977b51555f728c7f64083e39c664e62297e68eaf464aa960d19bb9f11fb47c36f3c8afad42dacc177f254a7eb7f0abc5f0c0aa3ecc82597d145e8a4dee76e5e0c4e39856f06f13a3a042d06423014577bd6e7210dd1f06544855a32a9818010b543326334b6114ee19dae356cba86975c42524e50904f6639e4161f0f4158c36cb9de18d4bd511b08eda6346fece4424b8f396f8dba88fee4b24c039c1b842e52817134840709f1e5c53c947068a30e826656c7c0f1b76f37f0f7b527a5ab3567e63042340f5df9af4e489096d68ca98d7da6b27cde833f81ef9ced724121c36672c3379e2dec89f10f8e547d20f89861babf741497c0afb3af71047adf353c46e06366ea8d945a9da35a7ceff0ec6dcd824093b4d64e5cfed6256e0670a140fc8d8250c4c04587a65c9c21b83234f6d3e23f463dff407946148b53b33a6fd671869add1a769072be3db6bf817cce62015f9821c083f09bdc619c74b2eb069e140384bdd3b1444361fc5aa604b3cbb938e73bf3e00a63f80b92b1ae07c71bcecaaa9defbcd3aa92a7a943683a990c6f4224499185aceb25848b8ef02b2cda39e1af14ad350106a0536fe4f3afb4f3d1a599e22928294fa5a4205ddaf71c1f167f0b3000bebc37cd455c679feab585fb03edf31ce4dd2d21ee834fc6299f4050784727c964050134976fe3383b3f7a13b0a8ff715a4326884a7b9f7a206aed47b3b4c043eb21885538dfa808653410586936345927e6f429af2be8e9c7438a8627af48ea6ce49b2b0d56a5de961d2e4359c9022095f4ab67f32838d76d1efe4390a46b46963ef370c53c9efab132a5c7c9d136685437c5ba67480978ff09bd91c911565a85cad17ade6965d539983d00c1db8a87c349bae77387ab8e12f8487c5796344196d776c4f57d01b3f5d2776c0cb869c49d06c7b3573f14583e9ac93f9223c05b66c7c532286cac8e31a08ad7a90a8e3ecd5128d4871f173f6a05e5fa5d6795b4d77b50d976c4435a707f6ff1ab79ac0c02d63a2a88e0909eee67c6f633948b82d75fed4065b7b7a001c8ae4c61f26971d26683b1666e5cf845607847696e32c2bf9841f0fa8a2645fd01f0071ef1582de329dfff3413ac213fed21d25eb068418c43af9aa42a3b428b96b21cf191508b925b1cdc1206aaf305f104d636fb1f552bf634f9636e62e3918f38147c52c11ebcb581c70b2422bb989864fc4c83d67ff8aa5216aeed6a71c5fb1293dd12604c0fcaf11f2aed81f4cffba6e97783f79c5559302c27ab433909c93deb6da675cea40352197c0f37fad4cf7317cf5bd273c29291e9ccfb90c78aedacf9c51c163bcf10c887b5d76bc1d84e7918d69dc2fe78886eebfec2ed98daac8ed2b7c5bdd470873c776e1b025786c0c2f8f18e0e03255111ae62a95238de98342404b95be97ee4469445c860d8b5b424b013e51d06eccc3b031fbf6a04af950dc0cafedcbdca8df6e218439b428a4d288b77989f937008453eaaa328d26c5e2772306d5ba7a24fe3abdfaee1ceecc3a105d2bf0444b19feaaf8d0146d9c7ae8154671c69b7a6bf24b11fee33f53b55fbb41b673fac97d03a6d41439619de4392c13b4cd2242f716c44a79cfe9bd5e2d2655cf4924dd2792867330078d55c8e3d19e42fe78e9564faecd32811b3685e5d5861e3f6ea24299aaa3872e8d4f86fb765167e90ff59b568ce0608135f6e51e29eda5e14a92b27b5390beb86fa8f51eade00a4b20f3498dd442e5b38b34969ff2460214888739683c417da989e7607f5afee02dfa91088c5238aea29b35b90bbc7e79f91b4ad7b64de7adf1e860a4aaeba001af408d57c4a5a1615578e6ab5807601b3d5cb0729ec2f10ec9d92d14dd11cbd3962865a1745d044fa4f14be48bce2f52da13995c10e509a56256ed8409718bab9eed1b5345bb965a1345baefc6649a65c77baa5a354c8aa4e08cbe51f70651a9f95ffd82053c90b87f60f883dc98eaa8a4db380a6f3e81d98b8e3b1eaad552b8b6b6038d1df8228e6ac32d08ddf52979227274ce2de9e23131daa22a38229cf998201979a27047c105ffd35eb7eb96497603f59cf234925c3057157408b3beb847b618e90585f0cc63b7fc8a4a0c661922076c363b256b5d42608f7fb726b5f65abc0163ff8c17123d3edf7affa963a632c45289f317288a6658a8949fbc23220ad46b4cb4ba80f34d44539fd5e534502b1e5b3e0fbfa883f7bfb1655ebd03f56553f5902afa5d3c4b3a17dc696b0120a0319a611576f2aa325da1c2e4e15bd7bcfaeea0b1ceee6481a6d2e25995404e07595a6cbf5b803fd52c14053d4d27905646ac9e49f4c819ab346e44870a004fb86709058378816159926f0ab45d6791709668418b89d7f5c3d1c543379ff2024a4f8ce63cc779a48ea3c981caf1acdd695befa56353e29d50455e9f2c41f62437d8737ecfe6ead25addece6f94b9132d8ec8825adfc78e65c6ec4cd8ab3472879f94b745967bfd07b6959f2e31a28ee571ba964596b284f756c0e858ab2bcf3d38f8658c9fa2135cc6da5ebc21967be679396648edbda994713f1a41b198cea73802795bd636546d356fce9ee9a153f4cb692a8cb8e62b104a03e72ced28992e8b03c9080a0bd7b2bf09bd7d662eaecb56f135e615c94bf581f7443f6023338e24ab6948b3b32b4c5bfe5a49b104abaece81cec60160a3b62c2d179c8e794dd1d73187fdd05eff221fb02c4d1bf1474a0ae310500a1b13b002c8d05b4b08663e868b47de6f78fc60fc97881fd93202b057e2e5214b58e6750b820684f6941e30b26a5b00aa9cdf4ffc18fe49757328ea5c69f2c40b80809b841599ae0124cb9f460597a9f073590640286999bcba5c4a81c4b9d905188496b0cc3191c11de580797d00502a914fe018c99a7a886aa11dd7a7b32054d50663495bce6ef9187fca1fc00d4f98431b16e192a42c49b3284ae2560510597417cfe9b373523794f013820d62f6ea38b508323f5d437800ad317064ea4a9e7145a85f80c6fb8b0c08b9f64aa0188059fc082b213400270b87fec94ef4ac8d7142adb450d49c33d58cfe8836d633df528e19dcd489101646e5d492b404b3dc1d1e3523e620c63f7e690007e94f9f29ecad2316178ba80a6589a8dc194f1f7c9875704ac7b10a28acb3f97d41258920906bf5f6bb32d620ec0d0d31bae7d7488fbd4ba49f35531ba7180d60ddd9d3618e071846381e0e1cd7b3cca6417d895587dc51c88c1835f075fefc6d48760b866ecec1038736ce6f42f0fca8503cabdd11ab8d7024d5c5e80e582324f75c3146742ef68c4dab4c9c85a0fe676bc9c8ccad3ad3eff17dd02ca8dd5597f33e2cfe6cabd864f310553dc61c1206732e63c51ee2ee41258cba52c31311d3a4bd9f38cb2f2d481f37d1bf5b26f3d76481aa6dd62f2c222e8495306fc648d4308247a9dbe2f19b61d8ded21b4ae8845659ace507354fe6a8b043e33d0d0b4e15813aafe0b061a26c55b222ac08cf560e721e2051113a046df18e3b47127b06fd951f871cb234b30647d8bf52cd95b14562c2b6ddbafbdba0d4611eff608e4d5c24a3c508e03faa87dd4eff65bd6f042fdd9ec17bfcef3539bbcb2fc4ede782dfbdf12bd2e7d0fe443dd80d79e7402f4b6131c7be0be4ea147492f0cda57869d750a4fdc35cce752913acafc87cf51411df2b2bdeae625973721c21ad1de311b31fbbc6f9021916db537bcf5eaeacaf2fb1d0e0168d7735d8eb4feb5e21305720f108fcc4dcba6eabc1fc1229cc3686e5a9b1f2544367b8cfb1a7daedf7decc7dd020a0d67e73bd8ecd6291f034a37dc17f0bb087e9646695135841abcb596141549325daa0c2603bfcaf275aefd8f8af200bf103e5fa4ca6ee874cfd5dfa19efb4fa17a1932e57c668063d13b114047048bfb75250203f1c0a7bcc6b2b245ec0c95663b7f7087f02d1612f367971805e877546f264c8ae89bb54d1f0796fd0e757830c29a7b353fc6196d1999c942b47c6eae49aee1da1c3cb5d268266291f799044fce824b05e12cd8f19aaf23b5b8dd013e3f531a99d5381e165cc8fe5f5e687d48e9159a72990286d2b45d8831f8cea3a17027cd25c64a2522a209864a049ef7c410d93d3878da0bc94bbd3e8d7d2bd9363b93f7e747cd6863ab2f2afb5347970f306fe27c635b4704224568aceb7dcced6b5b267f95c9934bd85bf874380f541f829a6fa164098303ebe0e62f63997052d22b0690841ce40e773a8c30fe2eabaa259aa1ca250581fbb0472a18fb088ee922d19ff3c99913c8b178a97e50e36fa11d131ed0eff573538e2e2eae44ace12b4d637d42f3553c52252f7976244dcee29f77497040719bb8faebe3ae18ba0a787e02bc522bf77ddec60a61cd3a68e8b8c70382e01a75eccfc80d2659274603ef1a71af65b3e18a404cb1744273b45ec1141ef5980fcb304e671b3fdea067b5ddbffab31dfa7ff5d0c32bebae4749dc4be851b60544ba7c0c5103ae5ad27e43900a58cdec99a08c092f6f470488cb87bd5810694c0fb2008ea57295ecd53581611aa9dc8ae198c88e086a7b3aaeb199dc6e34d372139d2ce4f7564c5c2673c8e3c7ddc7b871a321554e5cf8bce4c17f98decfa6971dd239ba415abccec52ba988cab493d262fd883f70525b9ceac549bf8f35d28e504bb2206e500ba9992c4713ec89b1e24860b11bca0c45ca6435ef5351e552e025a54b78414e84817783a68a1a834f70f7f87096a40e631edd4ac5bd4ed273fb6b51216d44c11d8ac3c426f84acbf37db0cfcb883e59eaa792cf918e482aa8e1f9fe2cb18e9cf5f87f1b4b3256d2a89c4617f779044707773831fd024ac2056d9af361ddf7e2a5bc95a528eef89946afd509b25985025c16f7b4d4926ce3073be58fbb6cc889174389c95b54b8f7677e6194d5e232efb2860e456fb80962525c2e80e309e2aeac8efd7b81129414e4a79182e81088324e9a6b83e75214fe35a182eb897997677eae630ff6fd234215a2aeb25f0e825be7696432ae38a11f42d91052e15fd8bfe26dfb8ea804677407bdc63dc69253d8720bffde7b2c2b5a1310b967b073e145c9880a9913f677d822c1ae1c34956cc2affae6a9b3495cf64374e0dd5a218256b40bf9be38062995f15ec3d7f4316ce22b8c4f0566c2b1976436b63ec0c731695352187efc2141d4fb245048d5eb78bbc138a5ba4019670e56bd2a371180ded5069e7fa820b2ae1027e85fd18257337147e7c55a2d3ab6c0115484483ee9a55b30740902d95f4cfc4e1760bb14746d7b81d2755b99bd56db8292834678ca350dcd4468c8484f535b86ba98fc8ea55f4db8d354b813a893820c86643220d8f7ab4c85e9a1cf78189e0c8ca3aec750d2fde47d37a617f6aca49ddb910b0d1533747c60e987188f2d583a55efba9843de013ddd6c379bfd2f51cbb304f94083a8d577c68c75cf0271251e834929e40f30e28cb24ba9c82fbc31877a47cb0e6b04b1fdac67a443ee800d64a84ca0c375094f247221c994125896c68c5716b4d18935afca6cb5af018925a31ccc68dd0c20ab8173d214f014a5ab124b9f8024817c0ec208939a85792258277af3aff0faec05ff30ab430456afaa5e61e34b94f5305b07e5e6b8ebd89f19d39ac3b3f8e291878677f3a5660d5766666ecf3c64855d46f57b6ee92e28a17b67ffda975fa324b3a60bfcaac1ad958dc73e57fdaa13fe6cec216d6ce2e73a658f2a11c5fbb906e2d4bb829e47a73de4915604208f8f38c668930844b8ba3e2e9221c106974d2dad09f7689bd81d8bdc0443dd5fa17a599e740adeada87b94d5f81ac4f968922ce41833f399e509409ed8de069d559a95c3a924b5752352b61d5c9929975f0995c8a29bfe864a67ae9c1ec06b290567e9dc15d56a7466ce62212846a61a877eaf6d570705237d39cbbb5ca8950b617ed282a754ae7bd4e30b44e813841865839921c972a0c5c66c75138df18758cb654dd88a8e413de6c8c820d8e297083f12a7f76f97d81e850d2c0d27b4706ed4d8e8615dcfd0eb0f51c72b3fbe9013bd3ece3da3748255f8dc3214bd1b10cf83eb4525d2486f3b874f1f2a4251a611a057d254c6bb16d06375dfa9e63f333ab5fef0407cc7d7a52b1f29287da7ca2ea6c4c84cbf745a9bed60ac7dd64ebc313aec3ed5374b7819344382c07c602d09f66aa402fbcb9dac67183d86bcd540686be0495063cbab11815b6d9cbfc712db481609ea46b70f1e1e9606b6fa20eaf4ed0cbc2342ae565763953b4a4fa758b1280ad15d1ddc12d797816396af2046d26a17e3f8e0e4ef163a274a591ae1bdc6762b724135851a12aa8faa88166d9d012d80e0ad0b028313cc14a775d498cea2778d8c3e8a18a0d4b767b38295719b597e37f0820a7488be0061e4b42d06e47ad9da5f034c26b7f039c51f384d871a86a8ca173ce900b7dba5e99b5c009fc934fbb8c8781115a4735ff78615a455b3e0c55a2d9d0661b191d8f5058e3f0a55427ab6162064a243897c57e5030ba64daedaf3dac7776684d18637fc26c337f0753766ee69fc40d5520d6426a3ab6f622be68c59e5983e7aa25ba480cc18b8e51020de9fccd395cea34f0a97d0078ab777dbf21d9f5ae3a3fc12f92d1979f13b40bcf9e38e042ca79b7261649a847d860ef6ed580475fea8db549c7be44ed6fe57216c2a585550e937ff3d0a18d05724eb91567edf48be9f03052b33b3a822952510fe6718eb24c27c0d68fe703aff7bc757128bfd9d3b7d817d40889ccc6acd8288ebb723f9510c71cff6e7d3f5dc714298dbf6f2b4623d55a67b162579d0acbdb13f9a5d97329712c7e73bf3b33b30a03ab306e0338b7aeee6b76548ee50c89ebd368470945ea0c7995d13aedc8db926062e64f8f15da2a626101d250573b05a086734a2997f9aa7b1dfd1d6ffa6cfa6432fa5bc1ac08638ea28a10608cd2bf3400b3c36fdd34a955343621dad8a1da9763d78855c85b8680f5ed8ebc1db1abe433ec7d57a923d4bc733020b4d6da1f6abe91668d88319d1e634b6eb9364b12f0202873dbdd55ae09c188de7fdf5294fdaba76f975b72b098eeccf21e8a44051d0a6916bf40bd2532bc1948b1eba540835c3accb27c6d81efc5477bde1a1422056f1730af01cff7c9faaff6b8e0c0fbfc5d29e319ef1cf326e01a019e78784392bf7c32dead7e4166f89207bca871baaededb182d532a9dca273d01fbff7b7b3ef38341d491693684403e5f98bf4d819ed39f3b16189b60a0af40538a0f5b7f8e3d411f4bfdf873964e953a9afd93f20031517418ba02e70931e2a1504b7752b7803ecedd178d2da40585729c23484eb1891fa33023baae8e0a7337bee3551a14a3919d4ae542de59717a6fbbbbc671b58e233ddaf952fdecf4bf59276aafd5dd8d45b3d5231e133ce613aaf0f2e2e8e09d8cb1023afe66b5e70cfd3926d72709c0734681e6d21b2edc1c5da7232b9b9c7f78c499885ebc4bf5027e0a7f623d07fe9b9f6efe2380b7d2121f6ee23cae2358df83d96fef77c82d6702e13d1fc1934534d9684b7950a2004f11c58458bdd44d88fba2b0a7ac4d65a6d52e1d87ffb8168f398bd718e07f7c19568df1c63ddac1bcd5d2b42bc7d84aa277e698bb6b6643cea507afdcdd3f06c43f9e49c13e7c92a5c626c360c098d8c3d90e6114a2859a0f5a3a1376439a1952a4821f7add80d195863dac6568d701caea38be7b6dc0abfa39add0a28f15829d866d8fea5e8fb1e617c995ec97defee0589b37048bb8d7806f8d96246349ac46d3ca6952293d13dd95484033a800e285edc7d0a7adb95da9d7c902bce1725dd2392fd4a335bd495b7e9a2885bde95bdccd31e29cf28e9af5ccc667ea4d748b95e1a1186c8d072824611ea20558fafae7f22e2239b29d215c373f7082406fd8c9d5f94f1e3aa9e6a195c0d52b2ffcf114619f3058e2988beb93abb7bce2f69f984197306da93df2fbd045c909229767eff11d3e864794ba8bf0aaddd9aa067d9768af11a140a7683ec35c4eb0c43c1f924473e6bceb8c31772e5b1a1525cfb55e32b8cb10f83116a89e6ad824a1d29d7f178546d2447676f7d26bb61ff47b578eee1b99ece0ccf0f05c1257a331761469469302ab92d207eae941716f26650a2d643c9a08023f3b114daac7833125c39f47a94c772db34d9e937ff63f313aa790d8f666244fde9916f42919e43ac7cb3f6d6cd30cf387097e140f3985bf19fb5c25f3e8ba80acdde331afbb5484a95296a5398cbc9e32db23fb18dda2a7c746ddcd0d8bb62705fd221c49a5fca0bafd188e6ad62646ef396c1915aab652854b19c8e539182b9859c34101120d7594a6cc9b2628738fe68321216561597731a97b7474f625f9554534e6bb6c093810edac28a0b23fb43af879430aca5162c6522bf6961d8ea6b79c0a66823f3405d51ec2084d039e404b6e2138fd2ebb47df0b8b39cb9dad39709e98225df058f329ce21a44ba1f8f92c8e3e9011089ab2db0973f3ea883b2cdfb146bc34591fb9b66ddb270782f187e6648d7b1ee6b78c1fc5dec6ce16ea2c32e0149f33e66b0b868670d0a0b22ca946efcb9c9ccd3bd905aa30da8f447913058d805a1658ed9262c1d753294a1b81ba7a3b583e3c663ef2e088fe8d02572b30bdbea8d038698cd9c1232cbef5c2545fd8c98b112832f8c8cd6929fb14663c0631656db4ae0fcaa43b7228bd0efa1fcb652608ccaa817c4d68558cd9a0f9c62ce81097d799c4679086b1259a033c5eff252fff517e35d0c859511b798246d578c4f0ac4a4e25ea3bcd49ef32e9f4a5dc18c3d733a18270ae791662b5646bffcefdcc991a90648daf8db10a43698555ee168bf8f29c8cf4db009a04ead3557e5eb90cf45423778cf293fe5594fd06ffad1a7a08c342c8fc914bd5b45e53b48a1da8a7929ad2dae26e49c8db88b76e2f90a946b565c0ef0a2c1244c2c330511743135688324e749bb90cca872f6197e70a6fa7ae7a33a57a7ad2e54efff07b07a0a66eb6de545a12a176efbacb985a270c9871429ab65e64f3c7db6117f655951eabc86b4b77dca4e119f77c3f9948a9656b873bae284c05ed8f8c94d4d2432325ae5cae959c4d4176ac819df7c553cd452311ea7d86fa813dc5c5fb4d4d7548ec4525c0136cedc6f986c9ba3cc495083fdf4255cf184001c4a3934d524d9b202de3b328b21c0c620372f2184f4b55e87e55342bed051e484947cbce11a1047155b0debdadff54e13253209e1b389027375336be32780b6e7070e35b6bbbddab15a5744e7ab818e0d3355fbfa2ff3d611b67defef790214f67a27662a1cc56bcc04fc664e621a8d781b7600f804e680d44b83a8018ad371770ef760d7863d32bd045b300858294c2c3b43d819bbade3cad5c696477e50962180ff10315156ebc926338d6c137043e325e2b64eea3f8faebaaec003d4a0d86c359af98fdf83720987bc691f19d4578b1e3ed2b3577e0eb3480cd9c4719d27ef659cc0d0f69734d07a73ef2c3f6dbe80536a6f62e2c31da6bb7275683e4e31904b018390d4ec446f7fa027e76f4004b808d07e2c393a5df0ed4e28620e414f3d9ddf2fd50e054fbe66fedc34859bd51430574965c87eaf85c794710ea78167c415562e54a92bba30f983fc1e39292652786158ffd47f5b0ed9afe2d2abdafb500b4d91b70bb4e9b450d30e8918bc1e79bb2d6f69721eb4d9f166f30a75f2720ccd64bfadfe238722fdd8f9c781823c805e0f2644724aca847057a09ab00923aa7dbb0e17a3ea1d70b46b7a62b4d6cbd77a0c5c8876ef5e4792a1ee4549b32cceb5852a583759d1dd5512f772915ef7fdb6d7daed8996b6a3a672e63f687a9a0ae29b79a86f6077a3fef7acef41fc4ff9ff491d3b50a9e56cc32abf7575a035c77307021224fd32db0a5e4721011b0b501b30cfac3f0bc127411f633da18d56acc678f66998e866843c57f495629d31aac5636ff4bcbac153a8f6f0b1acfa7ef25ec122f4c18d1903fff031bb037183fea4e6678153ae415a1093fc936f9a93cdc4887e1737a4950cb80fe22edbcaf422ec96d20681242510820f5c0cc8c58f19e6967194a8aba4b9fac75ff02ca55a778a5a0a1bbfef88d6db0415a047ca4ff44dbe90e1395c1590c3cc6db2d444d2b7fc7a078140b244d743b7b7fa4b15c79b62f6dd55942fc82a0da9c4c33def0e2bdedc6ad33924241b45e973aa13e3eb5ef9f754f33b2f9dcbdba9da9518b6b917534998f56ace381b0050b02b6ea6de1894b634dae0e71b339dc219d43c4f05761bedc7b8ca7508d6386292713c81046f84d8d000ad840a3f783dca2dfa12078d85968b8190017868a47c0f88817050eb882547f24f7d01571b17db92e8393212775c94739958545fdc43f16da8018b8fcdbff4bea24711ebb71a942e1c4bd7fdeba4f39b4f21a5a8086fa1b63c37b361bcab4eb25c504897c0719bbe5d1541102586f039edaca5497bce59b19e7d7fedbf6d9da1270c5e6cea66af16c62f5be54d4c22ed2e72186d1ad13bb73be5363f1597dfbfe5c29635b97ca7b394aa2f5b5d247bcdeafdb22386036cd1d83b97ccf6129284e25a3841235d6e261ea150eaa53cdf906a07b878f0d6f903edba6f909b4be9a8d03c65a45dca0811466051dc50fb0a0dff2966a634d5db6e588ee82299670d2de337a888affaeae550c96c600453cc67dbf2d3311af5c792f20f869253bfe7a9a12bd556b7a237351426eedf6729004026176d384ed0cc3560c98ec6801349e349ec8e3ed83f6ea4a2bdbaeb6bbed59b583db56d44811d98e5348c3724e6d2d4c26381008862f0743bf44819c3f239ed7dc926f36d0488dd3427352c6429acafc9c2c2158d1572feaf725b99b76365b8c49deafc8c55b7b5f03c2b41b9d73b8def82b26696e4fd1311fc79f92b455dbe3545ffbeb8831eb701062445c623a390bd596cc1545802653f2f79924b35bb3e51f63eed22f9d6ca900802b098431d8097f74b1ade8069dd074ba6f2796352031ca22b983467316aeff4972af2d6e0b92e30acf96795f319159524fa1b79f437ff47c938fde89847d0e58a0e1d8be0e1f791c30aca3335881405c3ce5d72f416b71809b48c1a0f18d54aa0c9651f6ebfab880f145ebda7b34276d879c1475079765784124b9cb79ff731785302938a33fafd69ce5d05e679612bd1de77c644cd5b8b3cac5ea0e998588d42b54e1f10951da4b2425a539bc61cb30d5f0ea344a395595c4cbf330c8fa60592e90cfc22edc62b8e7e6431518adebd181a3d31e2bb778b9050021018a779740a1ad5b1ee870ada0ae7c64da318e3cc94d16d2639bb35b38990ba94fcedc217c492cef7e77bb5ca8b6c69f3e8d576a8a4abe5c772eeb40fc3057440cd26dcc1232bc40ab6c19a6e6aed117e2840628100fd28d03a6bc2603f028a5e7e8aa9625fbc6e0fc97a856da988a997d938f039623a2e7a878c15c467c7227d9e0d9c1f7d85ea9588dd430bbf1c7d55581651a8167f80fe715520b45967672ef9f36f4a270f6420685425bed6ef3d8ca23dd07eb179454db98c759c79a0ca6185560270d88caf901d967578605dd445a445fefc360ab470ecb156aebfe6a433165874f65e112bbe8ba1447ef3abf3dd4af8e2ceda48c415fa0ab3277adf159e2ccd0e4d99ba5538e76b8e27c0f8dbf830f02397dbe2528f879afb4e96157637ca020dd7e5b49a5eca12005ae1becb196e8881f6182e737bdfcf7280d1488a41aeed5e834e1d088bf98cac9e77ee6b90a96684bf6c2db77d14ffab3c10be555eb809ce4cffd5ab834eb85cc07e6e41b5a52eeb73da5649456738af87fbdb70149aeeda23435ffe2022c4000b0830b9d621d0896c22c94e37bae16c294e7a5acb73671087cc0570862b936813269d4ee04cd4d307f7e7c14531a93e3a5f92eb223055a105194a1f538be88dd62a145e2c8c8c473fef51d6341aafe1ac47ac67177ee645a3addda9060b715fa0050b83b9076d3dbe1a7dfc30b2e7bdef3137e6c24607f9b04e34199ba6d02d0da7a24ecb2e9416630ceda035cd24b0d3ad038d3e2422b85b5b68e9fc996cce446277dc51812e01b39ae4838f2e09d09123a06961e4b3e904692dff94f20c0168da5c818850cb4998971c4877859138b4c43e1e666b264d478bd324f2239b692c946456cb4bf55dc2f48e7b7acef2f5631be31d249c6d09c34a8ebb659e4c870f7339c43bbd759a7ab196262174c424eff2a206b5cf6b14c7d65fc9a130015d7f1370143ae33028187eb50f214b00974d6b7067bace21241ac4dcf2373039d13d626db78d967784bad0c4d09f9f4982984300932b288a06c279b20cba312f1f353f4bd1ec46295cfe3b1b05a873c44b90135060ca61f760e274ad43aa5a07fec5c8ee77cfd5b3458b17c7ae983dd2e3b2f3b40a2a055bc1d442404ca940dfcaf1486f5ab77e1ab359b79761d7b2023558a2ce00a64bdc4eb9d1bec5bee765951bf8b4bced72a53e9a003e08bf2fb5f891fb46debdcb7d6f55e1fecced60a2951f52870def0708146f4e937c2573cb2519be7a7bd70517b6758f9f0c8b5ab0b5c24cb776493e7c8ff13ccdd8e4fb4d42087eb9af4e6072404e66e7fdcc365f0d4efd8934821bb811912c7aaf9fdab7aa25ce57aba3d9685f949f5cd1b596bb5c0012eec4cb970d02df11fbc73aba4ebe9a252909923b85adfe6670cbba2c7ad0256ab90c91c2d6717a53272978c1545d37121cf7df4854b8ef7a85371228fa4da77fa2b33a5f59db847594d5618b965d740432fc7c6960c7d28fe9111d22a59cac19d09a6fe51820be2b7282fb6d24130b370f5b768bde03aa822734f5b9191e73c1cf26ca89e0a84073bc5c98d8b589587d19ed9acf7b254bdefa8db76f6d7d38356e3de4d8cc49a1577e0b98d815e670323fe9701fef1a71711ccb705997eac8fddf383ede2eeb6eb3fe0b288a959949f63cb4dbaff718d89a2e02ebaaf2a7c7ec3a7787e22223eb44264b7a3025844349de13c60043e33dea93a2c207e68fd86bff7364c0fcb4236b99db703e9c5a9ed0a7e7962e62ffcb8c03790d909e75913ed22927e4e7cf9675e5e915b47f4946396c80e0d58b0ed70afab9ebb990b4c7a7826eef9e35c1cf082e6c5ef59f65e38e19b12e0179f237ef5f6cfbec6c94b26e8c1aceeb93e12e2b527b34b876b1e839acff21205c6960d061f90c9079a73abf1b3afcd236282bc901774bc6a5a6c74f13208213a1aeb4e5dd4144670caf38afb2fdbae1f283d1baee9f0660446530cf348a8e0d14797f95af3784448a9e622233895cfc850976a09d301a91d3656d4ac68d0cfe29c3bd0bacc3c6099c58899fe1016d3afea378868c5ba8314e1be487c16b49fafd8a7e9bcbc91f4c3e0e688104b72677dc71f5ca94fdd05ea75658764e456719c6a4ee36af54b84cdf5bcd8946c2c6b715e30b22668eef7731e05b1056afe55c864749802c43c379fc9fd54d368af8f37ec93b078b4e69845ccf2dfac977fa797ee5acb22a65fac5cf3fba042fb7a2d9ba4e703000cd4ca3fb768fbcca38c6ccad42ea5c3f31604e1a9eef4a4313d78387d81b33b7e17649b5b493a0fc58383af588de0f986bff49cbee27ccd7dd0f2a67e9bcd462492caafe59737bd16034e18fa58daed73a615ea92cbd64f2fa8d9a015491e732a7842c3fbe5ce864146f493dd02a016856518e1b92e88c366156efc482b5ab0849f7d68dbb7ed3238c340d3074d18ff61f69850c444e0337f17d0b226d75d5d1c053040f38673fe9af57c790b3eb1bc37048b0508d9d25b4a05f3c451d7d01c59f80eaefc6488a5d7ed0a970bc272a6659ba761ee76727239123100817f1cc15220b1e6b0a8090265eb129e06ec32a57f7b9c8f24186f215def20aaf607e620b177508b3ef6f9235e699015343f7d25d4d4733163e1703f6717bca82f6e286988eac953f0ad7e31de64d64e8df6250ebd7eab7738077919f83a879ff128eb5cadf231a94f1259d849478edb166d1eed1488e305d4c0f1c563fe11a60d804d339baa657bc35066f619e8e0a2abc4e20853462c50ae7eaa9cb9f4b49d80b75c6d39a2d2348f81f9a5056d6feb942b187016df8ef8fd27c4c07ec1149e17dd3c02692ed035c913194cf0e7d28a70ad291eee66de9d00df323a65f77ed2c89fdaecd968344ad87adffffbababb8a7c3bec5863223a4b59432c9ff17e65c8d69f0c2fa6809f2b39c168e90e4697e563fc463ae822850c79974905399f0174398820bb43c04c69b989fb0bd166f7091a76177539e97523467ca493459703f44e8ed5944e222e1a7b2cd3c5aee592b70d290e6aa727d0c4c73e511d8242bd147113f201ada41477ce8f13ab60c4fdb434a25b5692883103420145a02878df213ef24e2e7073bd37f3b296007d2114e6da80421978e6bd5181356743648440135153c2e05f26e2a499e2975a3eba3181731568efbed71d6096e0b28f204aed3dc90f256e6146d1164b32137bbd454000bf76adc8487b9dc8118c7f683cc9c5238c4c78ad4e23176da0c0189869a422f0c03f0038022cf4c749b2a0fed080dfc7982f4b9df59e6a4175da325bf89b86b17a44249b0ae124d8316111bb73d71538102d87890dd711ce7d9800477905b6bb384fbe5d82a8a1047d08bd8d9ca7532598cc4687380051bc6195e54be9d6742666def44faf967d0e4d8823b883448b6c5f84e74f480be717333e4f56ca2a566d06ee2a20e36e0dcdff536088e7f1af631120ff8d38ac6ebc2311824f01b3f2ed9d6dc753eeaf544d9c1c6731b8076f89fe69c787052cf862a63735a7360c3670ae2cedec4ede8f271161c31d07252ea723eccbb57beae16cc8914229bd5f79a5d40dda67dee1c4047f25150892425059af842e9f416300b1515cc6d3f9d90d4db4d1cd6a511822ba0200256ee4f186a6300bfedc7c7b3689c4424b6e1540bcf8b46d368f7e419102883e89fd1e32c05a6fe321d2d92662724a6e2455d2d60e45f4785cbab05ff9b9fa57ee6a72f3c49ab85d73af89afb375486cb1bfa7052935410fa3f290584059a5b4bfc2a38feb6a9fb4d9ed22b233cf7f52482052ec1ade10a0182b45b9d939b12fabd0fe466288d1208a14e0464d75d76a9279b4ebd502572811c550931c0395b3d72de93442699ca350623e314786a856af584063e3d43ab5460fd4965a7de3ae1ec5b8739d96f582314d601dab1dd9a9d4488d6cc5b614cf5e8821bdc4506c273a87832f3bc2228be86e550d2accd2447a1cfe5f239c3f5fcddb905f69603433b4b425db896f06c0ad7bbbdcbf6694b97ddfe7f109a62a1eb509a791c10b6c3d1a02be8cb46319c61530dc63f27304895a19c4276e3cddd5314e19dcfbd631e12652442b8b251077bb7073dd8e41add53561f89dc0d4f1a070cdf02702e0cb9618e0af50238b9e252eec67f2d5398bca055bf210bed7e21cdaa5a8d5b40ce1ccf7d3a848eb6fe08165721f8efa2c94c2a4d90578dc1e21748ddd2191e73a44fc532d3acccf880dbad2ff71a496c5b08c7f4187087ac244a15e5a3a9a2fabd809a77ec9d196de997501e654cd96084519ac833fb1572674c0f2e032968757b6579b8bb91593e1491ff61e23f01ba0fe177e5343a729cbaf1cc8c7b1ae006a9933bb0afcf4dddbad54fefe2d8f672a0ff94df43932dddf5da2d2dbb3354291e21a9d29255e10627297b8046c3b9802b3b636aa295b2fb4341bc47cd8c61bbce19f079cf17ea7aa15493946a1848a7b6d9843d03d95ee6cf9ebc7e8e1490b53af6cce799d637893e62a2deaa50bc5c7bf8885dadae13004a631d77a46f3634969f5fb75f56b644ca09b1660272042b9f051933f9a6f4699326d4063d891d597ecb770ed44d54c7c1f0f3c867773923ba7733905cbc7eb36d717ed1b2f8339b27ce2ea593c2a924e92a789346cbe04241655c3bad63268fb1fedd69d2d5b73413ffeab5266b7eea36c7a4c68aec3cbc02c9a377f1d346fed6ace946adfc9e734d0c94673510773bfccb7670e80a3de4ab94cb6aabf43fff957410f2e6cd4604dbfbe9c5574314be8c59e70784d096ce6e72e99508bb2ba0eaf2927f26bc78863a952b00856ef9a38a54005e0f10201e679025ef9acf4329685c688af87062c0d79d3caabb82d95db2a2d96571f5f6f627f6cb2e52b96440d6edd4c6ab4500e8186cee62590fdc532d6271a7bfb9c31cc3f5b3917f275a32a3a03c1a6ec1994d083a8c3761a99bf27187beb908f9e7f624b201a310f1617edd3c56bc385626edf97becee92366f01d240e5ea5fc68d68247d4ebae6325d53098a053135816dc9027ffc74b7a6e51237192f0ce894de9cef223794efd5d2ea6b50e0ba3c5474359da09a9c82dab896298c10c64ade3cca573ddb8a9af4bba8b6be4dac58988c34c652899705024052ea8595b705e00205023e633628ffbf90e44c8957fffd5a6003d5dd971579d9c32ae3122eb83ea5b080f7b4f83e21bcc9561ebe9326b5f3e5c54833b88c29850a6acac7bace81085c70f8b22adb67a276d03e56701ff61d29a33d94ae436d9e942299e807f583b7b3691259339ab4cd9318f1823dabb90a7d7f68a39711435a70e00b5d33934e2e5193f6037d549d7effcbfab702cc9a73eecf5dfac19dfb7aee20ca6a96a0e2df35ea15d4060234b8138807ed684ad28882c0ad444c42e4c3bdba9d151d188f3b6c2db5c0bded1ecebac8e44842113b5c6d23f0892d8a366160cd50313f66fa76c1fe648b0f9a6eada9d7e183b8296e815d7ee63ccdd1a77c617f4b3bb9f26349de46ec8fe2dd868c38416a7abb852c4e154b28fded5e0c486b0b4a9cea662f11229ce6c68f00c433409734e9d06b8427d499dc9aa4a4d7a1591b2f4adbcb2b6c126a6a2f047ae07af4b2611595f666466515c371ebc99de8039a22f28a4593b3f845b1e1bc44f839eb7d02a3f49511348d7be40d396af210b9abb95afb1982261c6d934c18c6aab5588cdcd16cf1fce11b6ef36233928f3cb4b82a1f9d999533f5c46ea734af95f7307d9a2f8c1821f4951a834a936f4c83f2395e7bb0b983a9392a95ed1c8b0d0635ecb52f731cbb6734e4764befdb0b871ec6757e585c5501b071ac123876728bf6cde61cc140dd261535862c49fd0d37033bd12c6640359f05689151863a3c6fc56fa2eb0aff74549927aba681ec6ee93211cdfeb5159265e427fc226a53c012f08304e06951f2ad629e80483ad0646712952ec42664d7bf292a42a0803fa3d01c4a3c1ab8b505561f1b848525adfa15d1b37871caaa4c5df6ad6e2202ae1719b33e62fdf2e5316083cac2546d6aec6194938593136938c397f9380305a6bc3035cfac9ecdd7f9da19de97f4a81bfa2f2316d2bbfa8aa25c9792ab0b9688eca5388442f4e41fa7bb2725b379bd8fa39a1433f404de1ddd26619e17ba9c15d9ba69ddff5a4647f7fccadf02fe56412f07952686412266563236451b36cc49d1e82b3cd355743d1355938de84fcb85d2c87709193750cb9e2c7ae9a9089a4f56adc4bc433cdec755361dd7ab092bd5c86f3ff4ef975c938a5fa0bba81bbf674467896eb8347e082bbb9a6d02b3d930f9379c1006f7d0f15f882d3b9b76c4f04fc1999da193f43e51a97e20c6d5d87a1fa4ae307d0ac27f492e89d9f4898b165195ba3e866b11e178fe656cd30df32c8b11cc82afba9ff1c4c4aaf10aa5bb4efe48f6969d6dff9cf5df1a5d5da8dbd77cd3a27ca2d4a70d1191e39ba43e6c114e622b2da83655a2d17f96a282b0bf66ca7b1c9b36f88e04e973533daea0c9630b69871d3ff462e774225b164a9580f9f250cf2ffaadcdf4acb7214f554ae7eb4d158338311a3e76abc8db245b46708736116cf84ad0bb2b55f9cb76f88eb6d889cdda0a35081d61dedffc0c75a4c66fc8491a9b7eaee1befd9b29fbfcaa1a0e1f6148154ff3eefd0c05f9010b321580e04330abfd7d3cfd5386fdfec11fb69b13aee0c3dff11de605b303793752086d7cc8f9d4a6555d970d8353056bf6cd673dea76cf9ca5a5625c7abdf877a3ddff0dec8ff183187b00d2793f6a6843d8c7a73fa0181e4c85495c7004773cb2324bd21f89407f4172fd0e35f081d0ae7d9c03299771ac3059d6379c0b3929569179e1bd392d69697b9a463eebd3bd0b4848962b544035dcd7d40af4039bdbf7b7ee67e47ec449560e4db1a0a3d7049929a420f87f06c4834b38e022b8b53680c866180a1929193f04b34dbd99afa4f97ebc78f4f8b0a24b574eac506ebd2a6cfb7e9a2a6f710c60f5f7cf5100d2bd1f0c506d9b10eb187819eb5f1977ab885d0acf80ad1c23c7d4abadbf6d3464e3c01dae6a86791e795d3115efb55f0949e1129666532bffa28c446148c6d7689866c975b831a5d5aa22252b740774e2d9b26130bc128d07f47c31bb80c2adf98c81c31fa4173d8f603eb23ff30460adfce1bcc9fb07a988d2be319696c8099d9902e303bf8abe9aa08dde4bf2cadfa59294a1538a00cdcb5eb1c999b5157a9b6860cee2cdcf45ed6212133f4e6467bddf14c2151f8e78e9cdaa064baca300b0aa943c7d845f60b2d654efbc9d3d13d5e210c52ba255dc61d16e26f947d71366a33da5d3ff2e9bb44874347b06b90ee76096eb1ba17e8d1468de70a645a0ae4a127ec84bc25676c4f1402f45070a1aa30873f99101818364d5e8c081c2a312239478b526b1a21bdebf716c86b1b4824356d78521ebdf5f48592a57c49071b51593e56d12c781ca1c7fe9a20c53141e4a6d43d2663d67800cc2e9224d3d6e143b1facdb7096a08bb00f50becca39b6f3e4efc105feab9208a72660cc6132729a7f782065ff19da8efc031d483fe0a440a31cf2265f28d2defa4a2d4cea7f4610cbf73cfef5d53f1df88b697d1e97ff7b06f2f226491bc5ba1560ba813b97a6c1c65a4d4bc7cc712707bbca69557ab652d99595417b789f6f02a56dc8b18c58be9b1396a9deafb35d6b6b334aa23624476bd54d25cc1c48db1adb6401803ae68a573cf02a04019fa03cf23a2b323fa119718b3322aa1fea4bf690227e495910e445e959204e4ce9949d704f27d94806ab686b047186084d5d29b01d2fae973800bef7a37aefd352e4826124e9693d0d9f5db85963661998ae266540864c1c500a449f5543d05bed9c8d60da2db022d1af649cc92e03f12e521c86000bfff7703a97ec1c441c762071c9d47088ec246a7cef03b40cd8b9d670e73128d59f33f15963a50845491242b343c55a87162033256e21e3293700171aed25d97b6ae7e121cb988f1593196bbdc39cc9f383698a01898e1a0fc2679e6eacfd673ee4d4f525bc59e229f72d4b810c48f55ae2720439c8d23eae51fa219c07d22f3861775f2cadc80a4327162edf1c11ce1e77fef7348e4e9975025688b811103e9ec2a7092c97729ac24f875dce44aaec043c4b6dbbf6a8e53a18f10480b71d0da6fc7fdfbbb6b447361a43b3a580a31991d21733ee538569d4e0ced9318bc9dee87cda73d313d60379c91e49d79bca915d64cd2f668fed26e3b6bc115f47538e162feafd0bc9219be99377ea43aeb824b49d7a26a5821af0777b0e92cfd2763ad3e75b5e1d4a33b1e0782e6c688b1bde892b93c916ef67ac89fd9c4bb7f29cadb55242a027211b6d5ff18e754dabea1a4d3102a1ed9baab3e1a220264e8b641e5187c68153611fd70d0b020db0de955d26e7cce9b0556146de0ef527c78eb5b91aba5e4d71c6844f44ef234a00bb3e052550c83461f025825052b7060e6c95f3e05de239990e57a0a188e1bca75b3527bb750a030d17d4ed445fd65bfad24e2d4c203e1c5132300f5d77e2ae8000cfab7a4ee88a698d47c748b8d5d546340fbbbd84940a1270ce93b976c56f80afaee5b399ff43f7555847aa635105b31e665317d5c3e9787e4370eaaf936280074455dfb11c7e8d2533af3a7e1a344db4671736b16735118547a5f470b4dc3e121fd3a5a827804394b39c4d6844aeeaeec58b2450226f58f1566f1c9c5824658ed3792524d278edbe9f0b26c4b2e4a964d751a5731acfc761965c5352bfe7aa2c757e8da7c35b8ead1ad7e2d20149c3bcbf45db55cdd081f33c477df45b14ce09cd160add26eaf4619b9b1a6bf1701c70c37bcf856d3299bb5905537479bdb45e47ffd1b75e7b0ce5b65de28f6ec2730c012f16eba07e259d24b877e33b7a2d3fe627f1495d49d33236409c9bcf920edb15cb94856c15abddd2642fea3c2b108b623c32c98edd9b78918f97583cf66d40ccdd19e686c47b33b81706d3db86b509b867aa8d89cad1a18a4ee59cdca681a705860ea7e7ab0db0eb8f8ef671e9a0a0f2690f0158d7a2c97952df4427f445798bdd705bcbc1c22ee469749ac86b886f75152e16a6164bd0773a32cc0c1da16a9c34fd7c47514f605105ec73aa8dcd0e6ebc09304293ba62dc7e2b8a72b851a2b2efb26fc53f5403177d4cc988d05049cb3b5246403a379d239e41e207ac911c9200521777877cc0ed69f8db3ba1356c2f409e8cb5b5515106aa58260c11da249d8cc04def703b316d2d0d1fe03633631edfc2cb58ac65d003fee1f661e11e97df2735ac8faa2854d1725cab522a8f44a63fb7ea1cab751b0d6b2ce93e7004c4093247b055ba002cb574adbafcb10809dfc4d6a9fa587fc015b27978ff36207f93c6917272162d1c34ede8d8aafafca5792955f4fdedf24a21b1b4f2492ad66635907b790608d30046f3a959139962313c88039e0961dc64b66953e4ceb43628dfa288f93277b007bb2d36807d9c9c4d6a9a209c8eac90e4efaa08eddf0be2f9367b388d72cf58e3dcf63dcc618148f19bbd6bcac21684ca1275a167eeea24cd3cea94ee632a5ec7b060016dc2a3bb82d6c6d9fe80f44fe05082f0208b942c6ff2d1845cf85e0b2f47d0e7b7e7151e5b9a805b119c07ab3980baeb4206da9f37b42c8ab3bce2d9c60ddcdfaad826ec2cbbd9325d04d8e8720628a7cd9966e3a14bb16bf06a66a5a1b39b6460cdd29f1aaa9ecfed262a1e8c8f58e83c55828c99125ea85abdd85034a4d71212c7ef94cbb305fa1d61bb39697b54bef5136bb3c1c7c97e82f222954330c33fdcd5521bcd0645f6695f333d3e657db4643ee2a9e662ab0e8569bbc004ae79125445fee5f259821078950508c33215e332695e1ef602deef037432f2497e80ad0b9a80769d87f7e9276a87760a89c9702512cf282857669a26a68a4b7df28decff6eeabb517275f87231c55635dd32a903ccbf2dbb0f980ff7e0e9bcbb44d6c1a8693f7ff96d2528dda7184eeda90365dbd773bd0273626b702a6bcbdc233f5aef28f84a1a66fb73fe9b6e37495b17cd9081b52c2a6581959600faa4e0f7b0eb65240da8adcdf348befbfa24728cc1bb561da2ebaa98e171c11210cbf0eea13aed9bedc4665fdbafaf81fdccdd64e9db457cff1c700276e7dd139b586969588748daef02c131276c37e4d8d126d7b7760b0e54f368b3d8be6d526e3e944166942b97e851398e0d3630a5687800cae7c860f498fd63f8949f8788761ead0124e4e615d99bb1bfdaa033c901b7d3f511b2653402f21db3299e8638e36f3553155e414342afa48702ea91bfada6f81871e3ba551ef5cec14c0e984f06d9e159f4088b29ac9845079a0f76211d027eb1017401ca6ac93882ae2b75b16c3534b554a5526a23757775c7571874a6d7e3ff15a4a0bf3bedcdf25d262019a72e2feea17871929cfad614745772107f8b0eea43fbe5a850009e424ff000d2a7a9b9ec2d1c3157a68c177e17b91e366c34878e4e2184ddba693901243cc439a9d9ff79eb88783c404d753cabd040cb31a319de8a2960324219496c3eecef6dd6f17f7a9783baf57d9b433a5d7728d691f4f25b6ec1ccb41742d908af0f6bb12b88f7f874ee2c22dade06d46881e8bf38e067b72cde5a536c370479db6a112ec302fd356b3bf922fe28da7d7291d7ba09a0f906b853748c8322a9f9536e8d1b0bfb9e67f7dc51b1eb957680b5942805c114e963713ed88d18e30a448a3642845ff0220b60517904b16cc08b4598847517eecfeb0f63c57d7572699801f81b570e5d19f750200034cb5bd0bb81fc182fbbfc9ddd9dcde2090a5ed10f09acc289950e47c4b4347bdbcb2b3b83e6154388fa45d977c0f65f62f764deaefd2cfeab6361ebd576179a21c0f83c5e020877a5f226199ba8b4313ed7fd1979289f6eb1b27d21a05c2bae806c71262776184637da0f29cdeb2bc75b2590b9ccc0218bb07131556669d1a291879392bd89162b1c32acb6b942fee07ed9fb48a646d8fcd82da80e58b5e34d14059ea414613d4722b4b01b06afcf3af02ace8bc9c30e463e40f9696085c7d064759564986b9eca58f39eab23f77c9b3075dd4e646515bd51c95d99462eda57ba75d6635e7469410e54589c9899b96a151341b4f34104b02e05b1331c3074b09606eeb7119964b104ca6139f177e36948f96dfcb1976d5c63b620b032441a2003af0cbcfc2e8d115bb7ba5f9c0539737abe497469c33b702476e1750005d39fe6793418cf5928f260caa1a3722c4a164a6c5aca37147642d92e579eba397b8bb17b8d8e044b12438e00bdda22844db572ce79d24de7fa352623923f86c79f87b3999c59b87f135ac7f3ddb46072389fc8067504493071d77428a4bc5716d82a5cd55303da4097c957f238c9bec69444dada374d4cc662dd85f6f2a8cefc0edb506537c52a39abd0de6b7c3dadafc13044a2f07b2e6ffddfc0117ee44011a38626ab593477e764b31b7b6f985f7764f5d891a9150a64b37c5b331b863abcd742cc3a5b7993f450a85e13a0b986436582fbd876d59265f3038c38dd463e23b75499157f5f790572de702c02e91c7a57e7104a474a0c9985904352c61d5e6e5f5c575494df648b7bf621222b576ff7d32211016564847e9322b78f51a8fe5ae3870c671a0e40450ee842678ae88ea995fea705e07735220253b01516c5ebdf23d2bd06ec31e47d4548f2b05902a25df864402090ba544dea4ce83b2743816808cba000d2c2d76b9f2adc9176b75ade03c236957ddb6dd941094254a7d644c4c2ff2e4a61361fbc58688673f17297d32d836dd507ae9278c1974aa6adbc4212d2b9d612ad7b6b8e36044f2cc0fb4802510cbf4f352274bf119664d27e9183f1816172f9a6b246c93486f095e8a2d039a90f04335519a635f4e25e5795b2127eb10e632b9f4b54c1274edf4a26ecf41d798913b18df49e92e7007c694071a1ccebbc572374782a41fdc299204c7945872c85422ccc558b7b9a519d957505e31e57f8522f7a7edc48e85d91ac3f6a78e5bb0ae71f7aba76711e158698dbdf096169015c7956d0b768c2456e07449ceb0e511fe91a392535a77d5d90966f61359103220dca0cddbd08b92bb55fb138c86a4ab904b980ee2b071976df954fd1440fae9152ce6e1237181c07895fdcb3db970becf08dbe3781df1c621be72b91f60279656a853ffdcf53e23672ba99ece81d25931dc6dee53b3a8ad63ba48c082b3a7fc8c7434ee4bc12f993c338942b8dc8f731ccf1ad370ad51c2f94f36b9e6dacb4af073af94923e0b368ac06270616f02e2d7f72576ce5f4ba761b4ada13cb8dde8eceabc9978f31556df4c54273fc85b6c474fb80294aa0e3721580dd37bd34fd631f97a4e33f61528ca4634bcd3485f7300713b484db2b6c2c67c4659ff5fe200eb94af059650288c5d2deeeec52f5c9078ceb2cbe7f3e0c81d572fc16b44150c949c90564d2675686f7925fb25795b10754a78082113c82cdcbd6bb1191c2a285f0bfffaa9dccf8e2bbfc7db16336836fda926dac2a97f1b1e2a9e10406f6966efe5eba07adcb0d16d0572f5e96b113a92a5e563adc2a1760969355f9d6aaf4b790f5feed24509abd1059d694ecf25333523c3ea066991b9918c603f2c1b2a09a7f600df44f9eb2310523cd210163d02039fb9039e0c22cc09e13055dfeeee9789bb809214b427d441ffd7bd5b201a692e2322e77352856c2ff8c6d6d60d35d4526c7bf2d1dca9b29555c8817d4f89d0de89cb6d54ce0a761adc23b4d10b8c4f7c8c2e1b0be70d4b39ff346e05d3117ef0e53e7bb7420bb200284e87f3e61fc7405cd2200e1a346f9c60369b63f33ed2613db51baca11aac5b9c3b59350cc6fe1940e4ab2ee8492f38528b5f0584367272933c1f86bfe284a19984c89da82611b086c82898763bbf8ec4922d91aec15fca83640c51bfe27c5f152a39fd5191ba53d218e23c13825f3de10f88528840d0a7ac05b4ab9355cd0e21ba9d2bf69b12bfac8b140a09bdb29a0e7ef8f2501fe27792d3d4673befb7ab527486a0ff28e4c4e7967af4094809edecea59d2421adf16f9389386699e708f893ddb874b4df50ba7e65c2d7f517a26bf9ac5069638c2a98cd00052612796675d17238d2a85594ec87a94cc281f27cfeacc6c1e801b326ba6a34f80fe9d462317155d7377fef4714cc14a851c6eaa0f79de20d3ab7f53f03880d57ca8e18ebb1e6f0ea0e6f4d5dfad8d7caeeaab21d9abaa85725e8b05c3f2abbbf577efc7a29bb57f8c89545f904b0d2a4f102862e8557a7183e71c6be6454f8940647a168cc6e1ce712209a92f03ddf4bfa4227d3259f4697d81f18bc98eb6bfe02e42144a708969ed2432e1925bf8378069afa9e2213aba1d0e48cdf7846fc23cb0afd87a430333086525078a0fb95d72f14039ca890d9f1555d1690f32415f82b56a5241a32830b430a415398c82c2a01989df9e9ab65bdd29d9367c7fbc73f80cb1553a9f6206377bda1305762adc5c0a498df54587aeca4203a7afca199edecf8edc66b1680899a7b2e247da6858c0a642b0b00a164ab7f5deb465df77693d47360c9f23000e65df9e0934aa4b58cf8701d0ac9fb6894205f406bf21e95990fe34fba38df7f630ebc7843ef8bc7336e02600d00a3edbb06ad30eb6a3b9144b3b20456575aae1b25470bd121952406e2433c17671f28b8047e37ae2f2067d98e7a5cafdd1dbbbe226d0d01fe0e01004b5ea4d36870e701e1115f7148e8c86713e04ad7ce7d398abe987952a68221571277ac62e97c2f263211da54f2c84ba09975f3f80e4348d403d15435aa10fe9b3e7dba7080bfb7e187360588011859dc3eea234862e90f2cc3b4fdb229e7fd84857e8fb70709e46917caac851c61c3e570a6687c3c8b954db89268378c5b9711ba5b3fb556cc91dddcab83e7170c1d24b2710dd94187bbef414f406d13a91cc9152e3911708c62589d5db58a8a121ed0a73e0180880ae7940f77015bbf5d3834f6554af642f82650a36920721d15f4200cdd441a0c33e64756a16b7071cd08fb5b38fab4431ed5960a63aba62a82f3f740029b6307a07fe1e95cd3352d9980b0491d60e85a3862641a4f6da3e7f7b7fb1e2444c9e0a5a030278de5434818428b184861d07c681f8910403bee584bb4fe3feef3e2f4e0214a6f54266cbe168b3ec28831430677572b2b3952e1343e1b93b24360570b13888981f3cde9b691f97c2884629957ae98fc32bb3e8e0ce1611264a787ce1b25318e2428b73705b98f7dd5892015f9c739673bb058c47b4e8abfb57b1b271502b6a036a06b06b4df4b98322cbcde6416db7fbcd2b5ddde4f0068a913af382352592d5da125cfa5c816a93f0592a94145e543a90dfd20cd4ec9e3a5e9b57dab8a5e2574d5bbea7a03a14a54f538a8f6e739d83e850bda0d89f046f603d32e743d3cd5e978eb14c51831792c2cfa1d1d39620b0bd95aba888761e13d954e28b359ad1784b1f09c1253850f49ec90033079bb7b05cbadbec91ff8dd2f95c6ff0227976916642fa2f5c124267d86fc3845ed80d52ab5c01712f861902acde11b59b1960154fcc5cc459f55aaf3f61c0163ed3e2ff863b3360a76d71ad03d35d278defb5eaa36350f4dafb0fcf407339f43d53f2a9c8aea37157d35e518c34089ddc32882fba8d58cc6e424b486494ca85ea549d01a19ba240e9f24f27da7289f30129c152585683d79204a0a3c32f3ad6212971f6649011bac87ace0c6fea3b4301c871b805d0eaaf58a82abab3b6ec9d67f4c5164bc4d1bdbbf4fe421771e0c761c2de6883dec09e64b979070bfd4dace9c3e9a96bdf3dd8c53833502a7c0fe17774c834f0625659c188ed56665ae250aaaa875228f30982e57a2ea6b0c43a8b17996d1efd70a680622ec849ea2a5de7dbe7dc2dfb9a74716d15d6f073c49d7adb06ad6304052f03dfa66870444692b49e441a7dd340d84a19da80e61613edb1cdb3a98fcf08f1eb6ce3b6eaff7615a6a44b0f2918c89284eeaa7c38dc3c2d57904d3ee1f5f01686e73b42258d0911c096d697595446ea8ce427ff8f0e32e7e28058071cb65765fd691e2cb50ecbd15e507dfb314d3e85dddcdc85ce0435264ff754aafec7802ab5a241d7d1b26ad3c136fcdda631173c727d6abd90628f856878dad0907d43e535906d75b03073fd1a98e1e4c6fea5096f0ee87c622431f8661104615701ebb87852b56ffb5aaf9dab4e5bb127696dbba155b8eda401e40ea10c600be57215e116a87e956a671048e3bfb09499e3565a64c7996f72a37f2d85015ada4831a9279a7d0998de93a32bde4892cd9b942eba131e5fc64d5ae18842224f6a6554878e9825e936440a999b6c81ef4da169a1a9196dba268af223216cda2a2e51a75a3555eccd7114d0c4b61b519a9b8c2dd43fcf1ff71c22fa33e29d9bd6a65690bf6e7e3ed435713f9fb417e3595998cd44416212f1d9ea2c919455c50aebc2e5de18199eeaf428f528c27f94257c5ad032a66aee27114bd6834906bad0694bb4830f6999ea5b784bea55c05d51030c89f997ef9719277c5dcbcbc4466854a9f261c5cb650c7d07187392b57517f7b84473b50253267a42776b89245f3270ebeea4c89b8fb94feb7997c22fd00e71e36efcb46bd3930e88f3a04c50cdc91aaca44b147664eaa5f64179f3ecdbdfa6f95ea8d00ac9fbc50bad6e7102b68af02f3c6fcac5d77e76be56d827d36d9b69927036585a13ac5d46002839ac33829341d75032f11c425ef3e0e9294db4b74334bca2749811d7454484d351221ca192ec7fb692807cdb13dd2638a9d64eb4170819c7ee883c0941cd684f66a19a04ff8d57f63b97976be97786281ce00c489d477a64e85d3fc9dca10904a70d2d17d261dc4e3db521656ea6178b3a332fa4656a44b94a94d4b1df57e9dc9d0772f589283ac370165f38caabbef32ff87d2f1cadb8ea5fd38e532ae354fff433531a7681aa8cbcc41b739abe9570f4d6857afbd1b899a5484bc3fd2094ad2d61fb38f34d743a4e6a25289490a9d679f8e50ba7a92d33f75bfe638603905ad8a772ce97f07788754bc2dcc079f94ffd67ddb8a1aa128dc9edb48f39dbc5502660abfeb04d5332f3566e5c747e50190a6ace83239c6c1d78d35fcbbda1faffc7d26e8846037baa6b852de5d2a8c7cf62a7abd8e7023a9579ea3891e3fc698755ae1ceb0924a6949ba82a9af7096a7bad690144ad1abee7a59d5bf00586960e1d343f7a2122fba0b28e308eb3db8717331bca13cf8ab96ee72034aff161559fc82bf2c3a4eec8f4bf965edfeb34c5d2cb82c2b86e4515b38b3c8e345eab755f42c79939ff8b4d051cac529850ea710d41291b05a267f8b5289d81703590ae08cdb2b363c055fcac7dfc2187dad38fc6b2aa574ac46a50bb40b9cfd5be95d30c7f863939bb8228878cc18415fc7be497de16956073ac6482c1bc5f621a14b829482e0e9eac0f33ac8e6868af3586d592fd2e4085f95ca4390436929f069c4ba0685116161df8ccc097c89ea92890707033f0a261c96227153729dc54d00128d66d0f3ff74bf57d6f9b6eee42f52aefa8c7065a8b3b66eb977e88e14933eafbc25a608540983579746393b4d3a3b058a2eff63836d0ae4a00a69250d01766457a62884fb1eedf3016ceb0dc2ed0cdbbf1caa513a49a41bcfddfedf703809db775c77eb339c881971728fa303896bda935181f35bb7e70f85db9a1e191aa7a38bb72f104dbd3e5f5a2ea0fc9a6c55365230b9c2aadb87354fb54bb60c060b0c41d950f804b1f1c1d5a1221713a20c83db1a403616c763add3e9221670afb0633af2580d1f48555c4fae12ac1037537ad1d3e8ff321c9350d70d4381df4493c7d773292a39b314c90ff7cc6667442f22525a448b4486685fdcb6ab3b9ab1693c6feee55ac6030c1330e7ed7e294b5679b7cd2001fff4a37b982335884b5a2627a171cf1e6fdce99984d565b7d167d8abc874c665730033ae282444e9fe106dce5bf6e29344ae23d972adf43e8972e876bb19913fce7272317a6254fa3333899a176a72802d876547b0d91caa6dc2a4a0bd9d8470cb3e9c69539b0023b1d83f2af5dc340ff3b342409877eb376a9e6d49dfe2c1de88f41b8d657377ac2385e7f015d9367eb48e8dd7be5349fd4735ab5c32783994b8189813e498e2e744df453476869ab8e48c4fbb54a2326856d24fb29b274588e1b5a0f44e07f34034e22e3a937549e885220a5fef8256bd6b3905cb66d6ce83dc7a34a6364603a8f59b7d47f4e957f387ee59fb3683c16480d0ae85c54dac80ef35bd2c42f2711f5aa8533b8632a5caea5809c761fd98769891b905d2254ba8afcd92e0ea81e7f0c680449c064f376361d4d8e2270be98a42c7d27adef22351a992cbb19b5cc43082662727319eded9aa959fa0008f4eb0596392465f70a7dcf046a19568f8c0fc2e8a2ba3755f21a594a2ae62a611663617add1462f66b46cf36fa918feb72e33eddf0ad37277b33e774946a1a3b399b98d045855d2307b69c3b3a88f895bef6efc9ae105241d83f95e95374f7bde16cc3c2b9d54d8cd2e64f9630f34b8cadd60bf6fa5864bcbf46d2bc53c48e9906cfa0a6f4d56b2084db5fcfce24b7d14f99e9062b923d2ce66cb0eda013e8a7da4bb3d48acc4b5cb093392f7131005a910264bf2ff1311984752de0a45b71bddbe2037800e993ee1600238f8e6f37a6bf5fc8223927a6cb6195bdf20fa6ca650b97e2102409d6d8860573e0a6810af35012ecfc89e3f6fdec45049c81c9a3674c3b1840563eb746170e53d2e715bead024d16637a544ced0320c69997b96a3f34c6d4953804bb1ad13668ccb4b546aab459255577044d4550985ae005dea6b4700ecc8db7dce2bd0eda2606ffd1737917ab707ae89919872adbd1d923b6fbd10c1ba4540b1cdfca9a50923f0854ca3a40899655d47a1c431f342c34e0f92551d06f9c34c6aa78efaee28439b91ff3347f758a245b4f1f62945307c582d1a4e10aa586e3047407bd56e1e651db5d87beec6eed11b8e09bb7722728a0c4a89be008c3d133c660ae4217ba8ebb3625ef5761db67beda31c8f0f29df2a050f14034f4f9b13250f275800b04d0ad6c880a8875bde5705b4d263195457746474b9a8e5fa9524715816cc376c27078cb9c74ae5feb01866bf0cea881a7877096c71b88298a8833a5644b46a43c6cd52944f915541012a7369e6a33f14071627589d65d9508193a7b73ebc7c6359cce36da485a6a671e7451ca62993eee098e32ca5fd8dfd8a49137fbceb0c824c692e032cb6adf1ad671f6267dcbeb877f7806762113074292af42c01d38c0c33d17f9c343af580e2c696102d44fe444a22c5295380a212f6962da693eb085bafbf23c1504f9e0b688010ccbccf50ec16f7056c15a73a3d380b899049e9b863b5c6c53ff5f86be0302fc99a89642bb181324e97d9532ec57eeb469f426688deacb26df7fad38690413a2e858866eb27bbd394b5b707540dfa1e60a3af7b0d4d4be2d4a55344ce34e7ca10c48410fea0cd7714c0e1190f1ebadc8a8498170573dca1cf0d9bcd91701cd7f0552e83d1e6c0825c9ec1e965808ce5425507fdbed2615cbaa47ed1cb68097ca0059b55b78b96682e97aba4950adaca41d013260892ca578e4325f25b643a3d3d4de2e09abd636caeb9877beb61d45a0d75bc777781db353171cc0b5e5bc612d976dd262a31b2f40c729808d1fdf382a30f02c00b8d8834e1e51cee4257c93c8678ee554c37b4a96cfacf9bd17c93804c998ded70c36c8770c8c0f6c3a173951ebac0b4989d73beed9c9a8c86e048fe64a37d65e700558ebe2b68e3f3fc7f7c935a3a5c56ff50340503166cee88d0fd8396dce30a7e712f0fa37abde3b403f06d3d931b15433bddf92705f3d351f80f8031b6557934508e52736faa928d006d02b85fdc8ae189aa155bbe3884be4b21e9b05546d3bdd4c1b7c87fb72c747715946226ee74ffdb9150f89ab2f3c3259ac0baa5437572e57530a5b8b3caa84e9843b60d3835d8781f3f51cf2ec91018ae24654beadb20faa61b002f1f509b27c0cb7d1644c154b51cf2dc22bcfeee1e97b3a812ddeea081f4a8044d3a95c7ec2c13e59e3fbd325b206c624cf6511ccf7e7f6af3d7c2474f3eef668b4bf68e48e78082f9e6ad1039d4c89dc4e7ced5b3d9fd835e06ac2a53993369dabe678699cae187a5b724a338455ddd224f7b0ba029a605f23e998841e5a0562a3cf5e6e50db8778addfeace173fd45b431d3d204b72722313f7cce1d45bef869829f3f30b5d92c5fc6f3f5f21c63af7f780ffb6a63a9b24ca52fc02f79d5efdb4de132bc2d324eedf72b9a4fdb9791095908e0dab34b5a0153543dc279716341e35a994bc714cac8600922b68304413068cd5bb0aabc2b346e7a82b0cac7b1fd0a998dfec4642453d87d0d1492de59e96cc06b464c1e9b98bd128f88182b42586f0368d7182031ef6c21c53f13228ccd5d7e27b1bcc295407c7346dbb2acca5569cdf4ab4adca0e98fe58771e5ae4d95c370f22f8d095260d134c02ca800fa46442fa535ea9cf02fd588aa6131299c7353153ca7ad27daaabe372cbff0a12962dbe8606a792ca0eef0c5747ca72942cc6bb936d54fad9987a78eaf433751d9d3910ea1e5d416dabef28eea05c57dc9667181e621be2e36e7f6d24bbd7c549e00012aecc470030323ee86f7eee10ddf02b07e263f9019132e160e75cb7420ce065a7c6ac9cd3cea921ab0a2bac217fe5e63df24a61dbcec7ad2656823421c652df6964ba8f97de535a010883dae71db139636d5c89abb6a30aea31be72afcbdbde2fd07643fd2e521cb5c2df4904a922a6aff8484ce858261be5fb17ea0afe0a02b8b8f0a03d643ab562c7735c15fef78cc2a6905738277e59cca62b21e9807d7ffcf87cd181f1d9b852f001474a54522a7f6b9fdd809b211aaa9d62de2737cbed157d2a30c477395ca212a4cdbd91a649894d8b2e06ab9f38c1e006281aca8957f901bb65f6c748400ac400b1d8e718a7cba1b5e1c463d14cb53d32d8f2adbbe74bb5d42b2b9788b527e8b55b692fee1f1ce0549c5b7ab95dbda2c0139081b7648e70fcf5e6cfe155a9eafd5b575989b74dd0a6077f4a3b4642dcd9a1fa24e0a201c85f433f02fd004479f61c4a4315e023b8937b4ac19b9887dd87913f01ea657ebcd9bc81fc8e13a2e732ecdd5eed490b5b542bab000ce753b577086b4f09b55f266068f61da4d273f72c0cf9c8d57aa15ba658d8ff554029279092b65994fe6b1ce499520bf0e697187e88e4bd374523f37c822ae59ece0a6a7aa2de4d1df14d7be52f1999f8bf6f7b6048ffd7ed1dbc09c5ee852af52092665234e316b9fcf142a5bac88e23458d9112e2d3ce73e35870517ea91812e10bc64c71eee44f966a590ce63a1b2fc96b0487de6cc3b17f770b82c392bcfad23b57c8c6ba0a288733854adcf3f466e89892b8028e83061fdb78dc3a2620164530f6fdae4ff70a4dbd02defb7f4d2982dce065568226a8fa1383c4f9a68c4da7676e008c4e37c9cadbc49df04d8e8eed06684c1980c9c2f51648a822ece0523e6ed76e65b130c4c2b7a89540a01e223d1a235f8a994ca07b814103c84f0938de723bf6b42860ac9bcedb7ef11a476f5b4601c10444e952bea88af803a9518c61b187492bbcfa8e54e3d1db7bfb97aa6ac23797d1cab9bca2b9e29bfb859d0c74d35da98bbaf11cf117f04b311b0f30a0e7787e05b14c62e9b99bed495c8a2f5b1c20f190115139b99e2c1198a17c29cedfd827f907d5c1d4fab47745347532fee4afdab6d03b9cc5b7f1ed49ce7e5f45382a7f5900a5783abbaac91f70d1698b34903dd549ffe57c987b270d652dd4e8234b33c428a2d1dc8f6d90611b26e824c9dba2a62d0b4baca5e8dcca11ee5af2ca14bf086a3bb70937ab585397fbce1e9bf94ec37f418aa48404273afebfa643768c5cc030e12bc4fdff01096c6f119e4a676b074de4a899d70699577e5cdb4c1037b2243cf9039fbd54d7802be5926488007a688d68c1bc6255ac15d135554b17883e154bf47373e3568695160a75a4eb68cd80270ab0e5220deef967d61e9f537de5aa73241136c76a32773a41c280d9f6b0d32f2a0d14bb5422757d76cbf1c7dc312d9ce5a02d28b3c5c753807c81abc1cea27647e4d2bbeb187222ca4223ef3daa813dcba5979a3991689146619d4f10c25d1f087ccb5fa83c1ad6e07a24f95a39d06568be5b7ca49470ba9d59dc5b63b6c04420b3d8f355f803b916d9a50e988a6a46a7fb64c7fe0dda884fcfdf083d0fce29af8cf711c17727a3b4ce85f53fa8540628aa6e406abca91cbeb5fa36f1a0a6477c3c12b2ba3860b44613e87486e875f26f62e29f004853a2a11e243d55f9882b283701335e2d30daffa19d50d1b6887cf796e97938c1d8bbf80b36afb4b52cff899e7b74856735c4eab3e8344a0809db5866dcd2563491858c8504ecbe476a1130409b42a1a696a51781b4ce6e1d57fd50747f6be89dbf731877b337a62a2943960a0127e04d079b525cad8ad82e23e68bc7c004f4d072b9a1fed1add1e47c7afd3c0927f523584909fbdf94ac847d5457a976f62b693b8f62f521337424e03d343080960a62b816e2737bfcd14fd5d7b25dcff0d37bcaa378420547ecf475438568f41ca30a9edb7b57ffb0de989235deb4d370ecbbf92c9f93e06aa1af3d5d5c93d00919e718af2aa49db396ab34f055d15c43a0b2f0781d468ecceb449a54658373f346152201e5a68cad7860abaade3a78ff77f73d3ba6818cc82a2f941a6573345eebb06dcb5f19070bea68fc7756d2360618adea37dda2c08ab28b0e92e80a3dfd8a12e59472c295adec2603b541df6a4582799abcb7758be948646f2c57be1c122b73521c381313cf5d0c641179f5ec1265f03fffba1328c23521131f4a38a919985170371ee3b336f7d31757763ce2b43ec9efc060858dc215b381c24f48f546a95367d081895b647f68d6ca644c2552e0957c549a49be85cbf7ae37dce20c143fbcf83a231caf38623cdc63e22f688de3dcd3237849f2f7aa401a94f1289a0c4e8d96090a5777690ce34047a5134113e471fb1930300e3176191801396af28372e582b68d9487564fce9b22f92d5a59a34538baf89397ec1780ba0e8fd77af5daa653d6623a61570216e3e300f8c06ade8311002e463873b548baf08781ec8961faa5e9401afdf2da4a33aec3bc1b25187dde675f5acc1dd15dd4f05d9f3cc073106463e5ced23e38e755ae24decedc65028a516ad9ff6bfbe4d9832be185450a1e057ac2861128d6f53e830ee545049929fa0f4edb019db55d532fc49fa24e2ad19bd0eff1917e3c04cb4e70ad4d04e2efea09af142536e97a7727531c58dc95509948829b4b62ae7e8e120820f180343ecaf2a0748282014a3bb92dd3935ba6e48842d79ff071df796cb8a220c6063394213cc91baf9ed655cd0bfa9e173374cf33a1366643f5df9a6f2ba9895cac71860a31fb718248a606987ebc7c7b852c07d5440bfc145289637d16fc583fbfcacb73b4c3165a2f78c2b6e78dac3933aea1f7649ee69b8be7655a8466cd721b2c0b7cde66b61a00dcddeec7710e5945944a48689341249ffb8996964eb1a0c08fcd2b1b08dc36afa2eec650648d5812a3ffd5e91390cb0ff20443cdeac1cc26012171992f81e1be4e51ab91d0a317ad9003f9a539e26630afae8d2544db65b9ec79ba2a848ac2f12fc0f64868928b5c74724a578321601dc95ccc43c0b33e269e3a276f5df9a17dac910fb89d4fe34aa0e5a9e5d2fb0c85830146bafc11a1505300a9b4fb95cd48fba569c119a248a1a8679e76bc1e9583d3a95999307cf6c5615208cd34b75e4a6815570e54a2d73c479fc07f7872bb577c8872b2634bf14d40a6da735915a8d3411e059aeec7bd2d59725b2e9d10ac7193700d58989fa86428aa8903ffc3a9838183ff8faeb48dda3d88caa44274abf239f2281894b59ee83509b5d71170141065df24282db180f52d553e0dea01758657cea8bf4d1f445cee70ad24130f9423464c334d5157a33dbaa7d03a9019d0c0320b411256302c102ec511e0fd1eeaea6ad64c1103f2962d4931fc09e246c780b984659e13a09d0622d2c5deb034d748a1480f7258bbff3aebaabb660eab257d86d70e8bdfbc844511dfa6418f6e3f820489b56b79c0654dc28dffcad07528ee644ae6019aca454ab33623f7bfd445bbaa66cf511a6b8e8a67c70be9835c97281aabc2e62fad1ffa43683d662d5f0a77952fe546e4eacc5bcb4704095be632acf2e5790868afbb77976f21ab6435f2d06ecbaf67d6a17c9ffbdd24d77699761ef8bfd270e2c7810ad10b76a88f57157b19b3104c9c53a30a82931ffc66310b490f3f2c27110ff9d25af3c71b2d66b286bf5dc0e7da2fbe64dff6d5264fbf8f4245ae3829d1a2fe26fad08c0d0fd4694155ea910dd9716fba9d1c2bb76e344be54daa96108ff6c9f7a5c28a4af3208521bd3773026f11230e928bd3453156c699319b1bd938aa14a14bc7473a5e4dfd9669f8c700d927f7a8179ee46971b5ce6625ac90371e89ec2ebea54533477fc1e4137f621782d99aec2740ef669c6246868e5a1087e5a56a478f499045b99cb29ed72f867ea3cf8c0f20a7792a92cece856a84c79c931c4d0661697caabee8b748e37b566cd31833dc701714d5b9aae0dd1b0085cb91c290d5b352b282ca36944c923665bc7b9983d4a896e6d653b7d08265ecce9abb82172d330770370cfca4a1018a44eed8449bb55e1109edab8004d587950b5e50ac0f660da015008d6e1e1e746ef29c40cd2926914ea7c8ed24a81a8b0b7c854f7f022f94e693fd16d2e5ac2b6187996a76bb74192985363a68d2c6fa8b710f23b75d1007b5d8920ccdadc82fc392a6d5ccf0b0b4ab4960b2402da821df3e3973b440555d8378e9936af21fb870100cee74b3e989a0a02815b306190620d2bf6907c76f5546b874562949286266c45700158fce3b4acbd95ffcf2e5d7a918d3003f7b8257bfaadda23012c75d9f38914abaa25020e7c9481c312d533fd973d3e9b37c90c9c077add4e38f7ea47e249f219addb279940491856242fb692ce37803da51014a02e1a8d59184bfa4081cd67060ec175df998436ab57c2665e179c6a0d5ffe36aebc27e3ee110ed2de56cb3ae019d47c4c16ee628ffb9aa32e879a98572584ea6d13a99484eade8d4fd3b245ea2665fcfd6d14d0001e33bb197ec1d0bca1d5eb627e506e1697d5cdaa98a700a44ae205d4250468a49291fc99fa0f84563c194f947a046cf7916745e461d743a8e8a920a07b186c1b021d60e3d85ca808b7ff06a40887029510000a8fd8aa1b062841e349779a2141c42cc9fe7c52c7bc08a1294d36775f3c8fe437ec40fd1555de06a0f557f0989af3d7f2cb744c8b12025cff3813de50939ea55378f4f93e23a3cbc0df4ebddfcd08aff675ec9ceb57ff63f77feff41a1e8d6f24dfb4b94025621ec261cc06754f58967f86a71515a28b336eff70bf17f23b17d01a816d6033154caee0f3a8fb7e4a2df8b4be0cfddf42a727a1095445c47fbd394eb589bfe622745209d4c648f5facbf628d65b27fdce86b60a61a91271f6a50c544321a09b29e899c23100273cb5372efdb20f4c408d68279585573163735c17568b81b526cc410e0ea36c1e4084dea8d74cd6951f05b270c37b7456aa33900e5c51b6eaa9d3711b8cb2af63a76e9ef40321cf0b70711ac74de8a6b545012dfa24a4e48a0c2982b467fe39252e90198d32d773314a264a95a7149ac0ce5f2c8744b719ed4e273eccb22b48e7e3163de90ca1b08ede8274cd615c681ab1d022c379726409f926c321ab325e91ce81284fb2487264d39940a60c4ab3ab906b3f7999c8c1fd63d6ee7a6fc9b7e4fc970cbe601fd0cfbaea8f4da4f7d7b9058c8625d12ae0f6e49dbfe517a985897f2073424361a05fedd777cc46e35092057fc10c9ebc665d7aa1cc8905873c7f74e3e60ea5b5d640f1eb93d5826c3a9240793d1ce38463ac5b588872042d04e3baabf50b7502170f5630d204ab866f7c45b5b0d41c45667833dbfba5cabfcec47b727d9ee11f23113a0fae742db4262d117ba7a91decc3e141b2a42b215c14162712c4717b1a7c15a9d588faaa67bb099ad53f3dc8e72ef43c65a287301176088df22d079adbc89a682052f71d03378981f79dad31d4bdb60fb7f1ba1c43dd22ba35b149c066cbf6af84f78307055b55e437e2e11c0d3f3780d42abffa65f3ad66e2157d2c5c5947655c3854dc5d8c7bb1c4bdff63ebe14ee4f3d9db1d1e07033db020b0155cd96e633689319de865901b164093da2319fd103c9dc810e10594c1c328117331433917f17cfe59321cd846d9f2eea5cbbe87acd7c8249a0521823868555967f2db063a67486540c71847090540eebe04d8beb6ce2afe3e496407125b838d104997834fd57336f7a0c3edd5be242092ba9e1f9ee0d101333cc1407a2b4e16b76746f955df46dc67079ec6f25425b45ee168e493238fb5ec324e312edf3ce28a32f8591401bfd905a95a45418083037b97ab870fc905b8bfded0d51b632fe138503c59e608dac81053272495662e53496934521924f5806bb61b1fbdd9d6e9eb80e0e246b235f2308eada4baefd1fa265114e4605c99cf26f7f79d56c5a3f7a8f6b79650a37bf6e8cdaeb9066f531afff3b0ba300ccbc1ea5ad4e7577b32f1d1db60fa60185e17ea67e9a67d3256dacbb227dc67b226437553729da643a20ee805b382bfe87cbf1f6851cdc8d5e5a9c65a5c1580d437d2ead0c2d2f578934436568882b83dbb5925227d3ad294d6aaa033d229d6ee9c4bda1d66cc597a56088b460b3173c15d0b95597e7b868001f3ae402938d5ae4d23d20a773d59c174d5b2f3cad119fb42bf4a01d846e07a2f04c12b79f7558771fced7033126ef91f9e7b3e65c39b3ddd8cb5e7c691dfb1c2a5dbe7c4fa6026055430b2e3ff87479e5ea33f121030e4f2de2ac45071cda8b1dd5dd99c60f940a5735e9c3700d7ccb6c1b08930f757c2710c1076d6b486a9a2047ff9118b7db05cbe6f150fc0c55bc57ebc06b03a65daefcff41ade7cca782cb8e86845cfbe3fd0bd2e82d78ef94bae46c9eb36511530d4cf0f9028e100ccc6941dbbcb33015cf002ab11bb273440793a019427fac4caadfd23e6d91cc3b709067cb39a0fb45148d34e159d0b8d7c4b772a2383c8cde3bcfff77bfd54bd5438ddd26d547701d38dba84bf17889ae711b2458c75ec783bbd178a26a3e3e3b13aae4b04a31163a5a1f48bf11556cadff836d33f5295c38203f75a7be65638a9068f4a62df53dd5111f3f31f11d6dd9413a76cb3c0c6bf771fbd7013ce872cd62c3f98f9919acc27a33c5e7bed56668f7211d32580d1affd7da95a1ab19d36a43dfe6c194975ccad1169e1cdbb4bbd6af2f4a6e3dbf53b1e7c3b3939d1a56d150f3688d1b0ef0eb1a937c8248c80201ec218f44836085a579e80558f566b95edd113f1dc09c9dac6c068b7117fa82c3c7921858a91a61d9fd6a878eead23651f942244b769e79d4e732d9cc0c3fc5e8864c3909c6dc4c7c40ac025ffce77f831497132545744d0cedd1729f5b9cab6c9ca32e6c77939c0952f338928a103bee1365a2921cdc8928d69598c8e1d14a4a98442094b9d7abf49866e43ba4dcbae4c3d57be7a884be5e803f143eb6fe17004dc171257df425f5e2c991c8a60911dbdb562e384ea4f5f64fc8d073ca3f984b408c9caeb6ccc61847c3bad7bede2875dcd0233c0b5956e549cbed5ccdd9670d1df57d6195466f65f39ce43ac6b706046d8e81cd3b007f6ccad197a7538425b82795777e19bba89ab645905629e82a1b746774495e7e1e59a517d3ca69e6e6549dfc638b0d732cbfa8510632fbad0097f5d20605c7a8c33ea4efbb36a930f5b13e458f9c963b3bdcbb222819e306237d4b9feccaffef6ca938926c80f60a6f3412c0cf4dca60c69fe54249dccb0eacb2b333c0044bd1b85de5fb4d6952dac508a0b609bf30f3afa926dfe98296b16f92c184b2bb68a83e496497d4ff7d5098db20de64d683e142680f312cee16082a5b267ae30ea3ab95b962b457ea475252b98648bae0836255222a5b5aac69cfa16bd8c0e16e74522aebcd4b74c4fe9d5308f01e51c6000c75e416ad4e6982e81110bcff0c73a9672cd42ed861a43c8919948b1dcd48c3fcb6a34ec4ff1083957cc5cb0ad42330657266fe63c8b96fdf0ba939b5d9f2b8a63f8f6d148c599bbaf510c96ecb5b9c9ce40ba9173c4b0b3c053f3afc27299ba912775078896d5907914f35009cf427066a9dc1a251ad98930ba0b2c9f2067eb03ae367cb705a3d176863cd037bd48d6b9819daea4acc9394acc45017724e6351290d4b40fdd8226de64aa356ad773a985b406e8652c2e583cb383b05d1b3040d81a8e473829bb15843a437cf3ae4fb2a1f6b5b49bb9fd09abc7280529187385a96e9bedf8074db46b671fe03ed1f8290c589c8a74fdc4b20ed71fc1ea2a9258ec33c32e4adce8b5b1fa62b1f5f9404a943758d22ac3299f53e413cb9123c0a3d07de965f1e14f3d460ea3bca2bc76eca18255f9a64ec35ea24107a85e282b2c1ab1b7bb5f276ff866ee774d6bf16d003fdf38ad6f56f779545948eb2aba1252d08af9e670414290a89a4c27134295747b339d3d17883e17d2594fcdadc39fe5fb332097519ba76ea42df70980300ad3b42ce1587719675c25c23fd18b5c3db1e302858e16a85af1f0bca6d33ec721182042ca7e414d27683b6086af65b26cc26d49b3a57c96d61ebd70a7f47b32ad239e0784caa4eef5064ef9137ede260358907231de8075797b00e9dedc49e6561983c19787b397ee2d67922b8446fdb4e0edec0bafb3924997de0a51117704004a6d96d8a5f3bcb1036ae7569da12ced4e2629c97d77af9d37ab215be0be98063a178d7da006a2ce81b501bd95074c51d56aa8df32d06efa836ac1adf337e6e5a70b673499b90d63e08c72a0235083ed2cf69f6be2533ddbd4038c77d9c2d5b75c008c628c7ecca29ac92b3830a124321ed909b90b934bf5531065e8a0769744bc47ffa7ebd2a967c79fc934d4a8c28c8edb424f13558c9d39edb636f90f71e67c4e389310e556aff0754dca3654fc9a72d36d2153ceba308072ac69a2d9d6c241563f4c234079b11940e362a7443024d7f769141bf83b54ef719207f19b7d4b6d5b8fa08cd9082844fcbe1e0ff3664dbd082db1b141c174d1ad54c4becc2cf88679ac2e394f62bf28c6305a4d7c4f775f56c21978bd6314b08d83731865daf6633c1afc65946ffef18d23d91c8bad31b4cd4a236ab9452621b8c2ddc084a36d748bdfbbc7199362d1c86b183826c1259d6533cae3e47ea7a03265c19cae71678813be994eec1362666cdfcc9f18638491e5bbfa22e2df8a3ce02d4a5d41bd09c806447b933de5e7a39638dbb89eed76b6928008914aeaf76f97e22ce345fe6c748139bd2f8c44551c9fef27bdfc11b08052b92234bafb9fb2cbbbdf292a8ad09d9ab701dfb195416946d6ba996d63d7e79966179059fa5ee2d4166281b1e4b2d6cc2bd35692732c54c65f8fe1ebf14da496a9db096013c4e72b251b79358b6cce3ce0727c567c7bb20aa99245528b71230258336c20eb2c8c0e763ce0257482bbfc7561039fa08c7be7b443dd3acabaf1c40da4a6ca714b2dae4fdf78d01c54ba8d7008c4bb3fac4a5a298d0ab078716efb49a03456c59433ac96c1c9a57da95b8a19df4b9114af046da0634e64fa9114bd78630973cc91e1f5dd91e829e6e18c21c65cbe850fe427a344eb90b68c9ec591c66b358240c319419f7ad82f0df193a0c3163f22c361be72560e31732cac81c17033672aef752e753455f162bbe67350602b229cdab7aa449375e347c40c8fcd7494652cce32719beeba4b41994a2d42db8d8c0b25316bac1bd3231acb11477da91e5fd77ad640c343f0ec7bda73518bb6837aac360357c22ed5091cd5ece9801f3c700399f404622807b7075a51de3b040f450f4a72de1fb1f055d4ebeb966d1343d79e894999ffdf1c1e70ba151035ccefd196c74ef7f60d92650dd030b102112ba4b69f9735f734dbda624254b536637273776744dcd9ccfb626b7bf543f195892c45c2b5e33847a2d7916be84a051a6c31cc72482cfaf1cf4b6ead206f45eeb13716d8b9a5cb721a1e8baafb5cec0edf36c0789e0ee2e1f5f6458e67d3a584387d31aeddb2abf91aacd0aba8da009a3b2d03faafc023b92d08e9bfbf35ac5a0a56b541462a15e79d6d99728ca1393f2b51b0902fe7b7cc75dd283e58eb081c1686f1d76050658d0a74360a8e1254d85f80f2a8b49cfb3bc229ca9f6f2ccc99faf268cf1ad13f4c3e5976d24d68b6f20272fc3f7e42fd0222960f83a9d5a44e4977384a17ca065404bdb438703ab8d8a4c02261327e378511312ed34bfbcb198f19092c7b72c373df7b9735eb1121c3050e41f558872853ac754d5ef473f78bcb57eacda01e25a815e7f78a344d7fdd4ccacac2652af8285659c1c15c53e52398dca5e738d2ad10cdeb65fd555ffc759a4296f171f793f66bd41812f52dcf64bf7b880d7469caac6c6a0780377b7d7a80288f9b9959746b356167c8be94b2f21a4279bbc072451dbf9f314deffaa188493341e7d47222c3e78ad6ee7e5574af2eea939a65a5da8f17461ae571488aac93db4e30c00368deaa0ba308ed5fd9c545b517c836b1f9d70cf47b47adb90fbfeed864b45f97f0b7132134d85d3e71775b46983cbff2424f0008d22b8c9504e01a9aa6f8304633931a6a3f3ab8aaa461ec4ee7644a94a2c7c0e1cd333b067da027194a0c2497de37cb231238911455f8415fc4014cf5f75b5299531ca5bd57f399083938071626e6bf7d78b15c13c08d30e9ee8c134d8e2bf00f2279b620c1dd905012d00e4a82aa896de2405d00eb6f817db6485ddde2cc32b981b0d8ec266362a14640b9b992b059631f612c88d857d0e7a7831266b56118de03b808cdbd565f4840dd38a605c6c95387fccf9b00a44be8fc790684676fad9d9439cbb50afbb6282ee855d63eac77f21d0a401ff96c76a6678728c7b1cc0449483d7c60e129cc2b0ad69e9f35de093423cc6ec3bca1b34e20ded02291b6d5594a2741a6a4d5a9591fe9fc838b07499dbd678a87920fbc5a36cde8aab6a8e742f5456d9b85fa5c772344d59b82a59bf74e8c8cc011a8e4913899b5fb59bdb1d9c059b6aae9f55202f68c1e0d03fdd8720a930d6df6aa75e5a13fd6e887be4704a1c881e677245aeb4a887f7e61497765106b331c58b4952bc5f111e7a44b0a4e96ae03cb955ba38efda7a9b36f129d860d6c8dc5e32dce71435934ed2eb0084b3110d3d3a06e2e7d4cc64411f225fcc86451580d5aa3a4e5b1f9536b68d23a65095a1534442a2fc4e3e087963b2354133690d0191780daae96501cc6e53f3d7f65a1835d9dc5ff31801bedc09d9ca2941be8a8d18f6d1a791421833989f81d23b0b792ff4716562273dfd660278dac4664a2b8192f0f75cf3ecda287255e1b7c84fcf8ff1d5d661acd337c468949ee9f257b1012472afb303424400004892d61931e6062c2fa1a026286374140e29ba681e9310a42daa54be2f86841ec0c30a4beea626ad2653e5fd40d65152aafc8743699ae5d80848e0ba2fc771fc51eb2e223f73e3bf124ce6a8c1d49e9325749495e5fbb60773705b5f1387b304a8e3a8b5d043fbbb7dd7d64f25f121c9714fe594d1800712c3f68292a830205b86b29e9c7d95c7f8c808c46c77bd63021d02b6bfa091b488532635bf3bf4ef0f5ac58a023ac56e2dce33d18bb605c3adcd0955e84f6101ce92131e544bba74c3cb904e59a2b388b2724d0e8369d0e02e2bd5656f8b16c647ad89db60454fc994e63dc8a202331d46271e0c8c67a3937757e7cfa7be79a82c4a746ea1c6b7d86e01c1a770863fd3572e55adfbf7746e998624af6060554762ff0b9e52c315b0575277e730e73375b21608e490d869767fa81751d75b1f7b33db4fe5bb10c42d22bd8425e01645d282bd14d1ee5519131112a6f08f1d3177617e394ddec02bff1868955a384aeb421553a0217c7f854bc466f3a95d895cbca8b605bc30077ac4292635e612f3ccbdedf0cfdc97824c7fa68616d881ec8a6ca10b8a5d4b588190c59ee6ec8e2bfc13b49edf7f10ea9491f8004eb68378c7588940447cef0d00568c113f179227b6107fbae059a8b43829303ba001f657ac424d5f92b0f398ca2220ef573c9a4e46db68d883d037fb656690f5abac1af837a3f1e2cf920dcb953fbe9dd437c4adeade327ad04be6768d74d451bbc63bb0cc46bb548290a2d64c7ada9f15fac264b72442b9a7517c33aae00c6b89d0801566ef9482762049bc38d8044dda90f734c25bd8ada3ca7194fcb40f9dd85020cec6f17c2ca75bf33fb8cb2fb1bfa1e6a89f4266cb8598d63efbc9e278658ed9bdf5822d86c11ebc1c7527773ea6f92995c1eee794f90c8bf84b1c64f37356beca3502fb4338f4842f630e80fcf3200434f54ed8da4f08e204cedc022f6a737b2c6a941afcd4bc5d1110b9e8a5c453a6a120522d63540ad66055cb69639f3a86658125a6a02627994b3e19efa9c689385e98c5d438d4824b6a8db39ffd7d5b921faed4bde2809b8263665bbacbe8a9722f6820bfde69177dc85163767fc4d139845ea01d37a9e8c5a1a3c47ee8e4f9d6e81114b786a4d93ea1889ecbdaa848a8cef3ca1c1cd1d3c9ee2a6621d6c5cb26e579e40da57fa89d9511ad022d18c421aeb9746c9c461e605ddbbb488e69eb3b949b46152804d6cef2178fd9daa773fe5fcdd47f13a4b5097ea212cbe2b1a42193bcee867786e061a372e3e2f651fb0b0bae1866827ba5b852ef9795980e8993d926643ebd99758c39cc2eaad1b37f8a88b42af361db952117f73595b0899ead3b4df23ef168627a918a30ccc3ba1c5b10718d3981e13c1599a3d012383615df98d7a97d87f9e9bcb77f639a574daffa50b9fa91a18adc0f833530681c731f41f961511ade204277f11e1bdaf87cec09ee2bace4dbcb0911cc8c22824aa8995bb0c80ce7bc4f9e03da75f0e3faff51efbd5e4434636a72841b28ca0d36672ca1225c63610ae968631720cf9dfb1875a34b7908918063718371227845f338143b316e0c5dd466e63b5ae9ee0710b5cde1b9c8dba6a9a08d7e83255b33e2029fa3251a09da165b70fbdcc59982526f0ffacb0b7f6bbc45b18adf566d45a20c6da826dabbaa4c82ecd5d691a67e65d9301aea67156c2132937cb2f091fa8bab2d933eb1651b6a11fa9e785e2f19c9281e038ec2616f61e05d2009842cb55b59281bb2520aa1cea64467cac32c00662164699941d2f93238fc9c486b94f2ac3743c424919720414657710ff0a1f3c03645fbd7097582ed2f66a9154fac61b88fb2aeb6fb0ea02d93bee6b3d23359d434215ac9f9b0f6ee0908af939301fac8ba0ffd08981345c0d263a46d308ad1e3bdbc480ce1cffe0c9a0f60dd1890f3e5331925e80966732038d19e2c2dfbc42d315eb29a3f47fb6cdd93167bb231e6b73e1fa474eb659af14a174157e1b63105e8ac86cee28847c21b37c2374a1b97723634e2cb1efd144bb128ac697221288d5cf337b9a264f0f90bea94aad895ec66682a0f2c204bf977585fab5066a19ce08533197d23d146432ae917a713dbd3336aa0a4932a05b228ecf00c5ea4bd46e69759c4c3cee8866b6149443eafd6cc6ab9b57f888b1525b1f5fb64567815a90344b457406b3f094acc9638e175ee0f01976c19b13a06cd17079a1fe756a7a00a0ac5f0d1eaf3866a9ce6df29c871bfef7be1d746b2af5d7d2ddfa27552526b1648ab27f751cc931acaaed5b767f07825dc41856bb64f3242f7a9beb525f4a4f9660292a36ba68892252518a4cc15b93c3cc2cd0b7b9541653a14930d6562da0c12c0c10ce10fece4aaa280422c8b7b2be175e173d1eb5b4ebfabc4fee46ff6c412a74b390f0500dc6f6f33b9dfb752ad583f7aec25040390975d16bab9ec63d6a4d72b6af8eccb5e5cebf5b4781992c45fe79aa157183ab4a9d7c303cc3333918344ae03cc04138c5bdedab67c4be5c20aafd97a4107a55f635a82f0d3616fdbe3935f917849be52009fae5d998470558da8938b82787e688767d0facbfa8151ed1b71df46f612733af954d2a0187bea1eddb7b3f0624be6ad6a72e5d9e99d2e25f2942ed769e6a1295616f2897f99c497193fffd55672ac86947f1fbaf2d2e651a7ec1e2bb61ea0c75c0cbedf682d11db81143fe8fa81be8b3d8bc0b09b2db1b38cc9161ab038232d7f3a81ad982a0d7f6d6918ef6b2ab38fb37610cbaee0696b6b0cd6b2ac2269fa70e413f2bb2ca32c07bd625f2d74ad36d5f46e12fb61e3b3836b125b1036f6fe769a7b41ffdec6aee3cea188123c186f709942e0bbc3eec79c731fe8f24e70f4170cc9eec4c1e4416ed67dfccdc8ba3507b56ab6cfa343c306e172a214f41d8f2b1bfa285a304a602ad0cf8d68fbd1486a2f5db698fd1a31b725f155e96fd8f59587488d930b0eb40f6fa6dd98689f27a8c8cf4c0aea005d2b5001736b7f11d1a62b4a399c7b9af6d0501953ec003059f68bbebbbeb723504feefcae9dfba76a7fed9be82e49b7edf44b2d3199937d4c8a55e19eddfe782a3c0a8b5539494ef880e5cac681c4ee617a74a6114f33c5073c5ff236fec8d9703c34f555763219ad942e2ea814dca1f88090b289745123051966348debaa203167d52cc2aae48fe88a848ecd2e14d2ae6384959a16922e3778f2c21347a3e283dd66d7320bfa573b649dc7841106b3906716dfbc26e8b730812770af9067b68245300fc1000b3b5b84cf03c5691c95209546c0081349029affad4f6d13278433e72cf54f1a661644adfac821ac28f67a06edd65e1fad96816a7e0523b754b26347ea5690fc648c0f93714496d710bf7021b10f891694273a47cf2bca56b0c54d8cdabeff8d864bb815a614cbc4ff609672f9459b59f7de009de30de0b5f5a9788dc8b63a890047f64c0c5a3143a8b2b3056cc3498fc356e88225d6a19aaf1d1f59878249c215995f28ca882df66cf67cd50e7e612fa58091cdd59dcd1ffa28f24ca9af35f78232b95afd9f69c09bb6ae374c2acdc6c94bbdef8cfc24ecbd51c29fc5fa9d46bf4f783e9df82603080e18fffdb693b9b69e8d119f8441eb484dc7b59aba948f919570f761023b2a31713f54d61476b01bde41bec502642f14c9c0dcfded02de69eab066f0a42e1229d002e272c7781be31529f0e9eb4cb85be9daf7d8b804284183827eda37edb9907742842b7272fd7ae2707d09861793ccce85ec2dceb9b0f6556b23fb0b87177cd6e4e4f6f568fd24ed0c6a0cff62c3d53cf8d1a57199bc5b304952c6d759c0c9dea426c6d9b7af0ac2fb7c80cf41656399ac82bb0e7a4cf333bb9cdb2387622adb00d9acde452b38e88709087d65e85af9712e4fdd1f20b3aaf2ffdabdfcb1b608f29299a4ec08c4b522a123e213b50d1b7315fdb01cbea868aaf687b00307edb12e498b0d3b4b455ea420d63dac9c5c7f835fd869b23755955ea1683372517cd446abb23f0fef52f3a8888e3db9445452c577bc5ae1ac5ed6f6295bb54cf9697e7c513e9698b74996281e6bbe523d45513c1f89cc08a58c3fa2a3af454af0d15f07470099e2fad5af2d9b9fa6e3d75a83c387f5c5843bd2ca894aea01b00126af6863f61c0dea318ad9c20eca1e65a89db605ecf83835bcf26e28a61c5875de1a626edeca0262b7bbff27f12de4cf1d34fc66428cf25f055f6e699df4696b338f4c5bc257e16d9a2728cb6bc622a7b1eb35ff8b474db83cef9dd3d9c72bc79d8b49cb5bb60cecb18ec34f43e5578ae21cfe22540a8ff1b71ec5ef735763c7cf0bba61d71e3b5dcff0909457e57541b6b50e151df622fff3b42e2a5bdf471991268349658f4abbb4a175b2574155aadcb21111c5f6efa14bad26534a66ab1789cdb58ce0b01c549e78003ceab957fd551787c925a609fdd39d299520c1777c0de2e30396f57f6ebefd9d8abb9e59d5ddff09839a69015ad4fc216b54c74ad8282b2d7bcdf207b6e2fd1a70c77ab5f78705c3bfbf7cbad1a44cc68c6632d5dd87d24450a81864e299b6b72179fb37b852c12a9ff9fb32da7a006de755824a773277ffb42bac41b463e05b4eab1ad47dec832ccd8297e8eab4e8df3d6e0dcabd95da1d5d98d9f864466f1e39e9c078f14b5cf216e5114ffa9254ae910cdecbdb7fec405df0586fae251f119ed05ee7298365515685a75d1921bdefac0971c02164e9f465c45531bb07b409d90281f50502b4836c4b6826146937ca60a3199eca20158ea72887dfa154da4549a72d7652bd5dbee3c1ca5318984e7d9fe726924fe7d64bc46fd887a7122ca2c5744402116b5b0283c808c80d708d01df85e2c33bb223d3782f6f0d11c34315a1e0e26e57890075995ec42e1d3592942cf6a74b1719d5afaf74443a6ac02ea47f2e664d4f91df7b31d46b44848d6e5d8487e437aa372febed43bbcb529736f44d3efb3d924952a106457aed44c9576fcfc23026c16419ce5b20585cfe8fdf8c125636a9db75b1af244595752b02f77c20265bc1e1a68447d74135871468416f634804bb3e34e20b3fdaefa14e359f0551b04e585f4e5261752b5dddb6342379d408ad71e56b5386f1405cc285fc3d2fe08d65f7f521aef35fbd5a1ccb46203a798a6a469eab918eedccd2ac0abb90b422b36928382003aa0e8f716437555518d6b14282e30e3ec65eb07ecc7cea2a80d159e32b7447f8632492ef45958c381460ce69b1f1af27c43eac00b13440e491677084a05ac2ad578976bd6401dbbcf088d272af8215611c3082677bc0db1b3d8c07c3da9d76aeb1a14d4743c6f8fb16698bae0f82e4d46209627ba6f3e1fefefc45168822cf5844fe68df2d9b31b7858fd259e4f3c8c594909abde1b86265c7b90f3a4a54ee7b5c0d19b136f7ee61b194095ebde4176b4499b0743833cc8a61aa21880a174b266626d70330673341d7b91b272878173a6284751715c7b3420da7b9967768bcd69a3af70c55aff96b9f9cbe1664c5dc11dcb65f79bf408270224c63735efd63ef2e261ca99ccf960373ee9adad4c7820ae563b8302196c9cb6aa1f00a936190bb38a886232b927af109c47bfc166d200e8ec1e264c34b64662ae029bc3f633f751ca09c8bc051335b7f4602e2e13301e1fede0e9f091a727ce658a4263988a9c9b11981f24875540ad011e25472e3dcb159ef071e975c468c4b6403dada24a553840df3eb03377c807e0e747b446b856c61bb46b702b81a54a3a01c123a4793043720fda83f09fc532e45cb9283f9569a8f0ef55f0e4ca508dc0fccecfa5872e4676dd953a6a593177647e240f09e27e430aaab9eaf5dfb319d2fa56bfa6c2719e9c117a1f8f70d98f10cea6d28ea5b8735fe07189a0697b1a5591f7a9eba451a5eabb64713265c78ef9f16d19a487db86e4daac4eeeec0a02c93c5f0c7d9d6fe08fd64e047306ce2e53742eee92f682f9189536342385064a6c66a0cbdfe2226517dafba377a8203792b008dd94b7445e101fb3e13daa149ffc661e7010897bb0d54e9c3fb7f56376d73c8486c9424726319296ab01c369d914fc5ee0bd07b6f0184518dda75152ae3e25cbf4f3ee5b1a75b1f159591259947120f497ddac87b16e015b5b1acdca1e81998b140c46523d2bebae2d7c6df30d98f56ca50e0da2d4c0b06517fe3a69b4b04b614f5c5e125524628df0e218922628892c0f5ceb3a8b23e8851fa04b5a326b921655aa08243ce67222c2a7ab37cf2e24f21c9d52beb543c5cf8ad001b9d136547807da84a89342aab949b464c78bdc5473eaef62e59010cfa168c3a7b3b738b1dd61c4897828cd203f449f9b396b123482ec8b3ec9e0355aa3af99a96590a7f1d43c3a70bf3da45dcabd7bed54ddf54442736aa582bf90977d371d29d87b043487837521aed0235a3d64778ef5992bcfdcc84e031e15df305650d0ec70a93cc3ae62395c95ab3d596842a6f6351c537635cd7fb5283388d8b0669311be5b8d347453e63272dcd17a7237b00017ad58743297d56928c0a12d865718906343d2d91dc74e21f7b854d08fd42110548e82eb416ee40686dd6f6b0c2855908fa8e4495cfc924bc2fb43816caea84edd531c9a0b11950e21136b5b2c6ea70461e3ef90a7c9c0e22bbb4c8fa1369ff84d1d0505ceb4a9ee153996d4cd0c296127ee9780c7dc1b90a25f085a7b5534eefec955a6a9826c1e7445d14d37326bc6759b9456166d512946fac4151b672fdc08c7b6a3c1d55c0a705e76881bd78a99f0b76b36196dbf4d691f9fc918b1d95c1903f45f39ca4aab44bf6035a25a01608f92c28c9cbdcd0fcd92727438a55e88d9f6a52381efa30a6e0b90cd97aafb6e8301ee60526d58d7c5bc29d17035108349b265dbc3711b0def5336ed28a25b4370d83e3c9b5748c6623d4866f1f217c2720d198bae25ee9d936ae3ee10b1dd01b01fa22c3f827d09b1daf272ef3b5c7ec317bcef79fd4c79eff4f89b025baa2c17cbb34ca38606223b5c66959da063e29f97b4ef1476cbec5a648e33bd32b3984eebdea0d7918be5d10bf8c844f15d7b1d3ef5ca1b18ac9cb49fb6a5ebd0724d1204c10cf09aee4be7d34754a40813cd133586be0ab40040555a45e6af6429ff50e3815b3ca35f81d0b38c5f1a6ab22c7274a08de4356c9579bd439f5111e67ef73af2df74d6eb84006dcd8c253861ba8d01b7c8df7d5e32e2a54a31e334453d49f7560aebd946ed18ac0fbb3006b87819ebdbc4439f1fb2c78f981d04870da038e39bd4915ea70f7ea40bcb8f1206ef720da19716192751257f08370e4fb9488afa2c2c88f0c8370b1d0d3bdee46aafd93d35072a69f3aa7de72d98aa8e35ca76c3108ee50d3e39031e42000631c048ea6655249e07fbcc39258bf5cfc8317647ca3bf39133417f9b1f31afe65eb6cdf6e3a77a1e65680f46a0400c6c72b878b8c116640a62556f25c8673c8512c6d83801790034dc9083e5a21228a3b44b1caaebab18a69d2170398b58dfa3cf4926f8ea686b8fb10d6f4b2aeb98f68bb51b685995127d9b32d91bf7680c55bd8e39cf522fe0cfdd97976d8bcb7d24c37a22cd8807515e1059f97870c547c5f62e94408266f45df3dd328ac0cc27e06b6141d7553844fa535606e15180416790aa216b79e2793ec6a693d476cabe691070c18f9654bbe2d45d3675c88f6c91cf5598b139bdda186641c7a61aabfa518ac101cd1a4b48027d93012c8cdf3550c33688b20f9358f666af20b0c15a24800892f64594b404d5a091b99c1ccb0d627ea0d66eb27a019eaba511d6c8b1dea9672c29589023fd886b436a60a9ebc03e97ca034ca794a7f37334a6b6147f8b11981aa0023a880b3d5c506cfec5c8bf5723e7e26a4462635e77dd2a7fe9ac58ece37a3b6207611ee598c7d7ba902e3f67ac0f099e8f467beba5d6f749d3f574fe12c296d2f058cff0dfbbfc883c6544193d7ceafcbbf61dc6bfc2068f17b584f8d9f926a7fc2c0869c945ee9557e0d1ecde75dc0e8c98fb09ebc44fd2eec1070899a74adaa69eb16e352519907a8ac7855c0659507afb29028ebb4238174b8467e76935bba5984af7833809535cc95b78afc7d7ad074534e17a6b85d1267982dc4938fabfc95cce18af1b722f6c84097bc9bf2230b8c7e1997b5df3259ff776eba3b6d07859b80691cefaf08613961fe8c689a7d548cb019bfb0615248d60382090bf9f1b8e27c5359a59ad5e221b8a684dabc1f09e7b87deae1ea5ac43ce8fafc3bb776b3d793686a09401c68fd6f34556265c0da1b7564555963ae44bfd32c0dfad74540de27bba506f67b7d5d96adcbc17428585bbed0b3c00dad4257d39d6295cedbf79aea090b4ffbd4c3fa0afdc9ab215a4b362faab4b229a147a4a05964a7d7a5d86f1d62b93d395e6efa40985c92174dc996bff9b31db3384b6d083a78f01f1b96e453b760d380622ce36e0a22ef3524d4218931f89f3a685271da96c00f8f2f59d283593dea9b40954a0fa90ea9e054500c711c996437fbc379688780a151ad8263e3f26277dbc7cfc70b2e6f8c4d7e396a5843f10d9ef2cbb7b8afdf407bc17168cc542323b4f22ac3cc1c9ae0725b242efb076ebd547fb993ce26aace9bb9bee29862eaa2fff7e236101f412c314ed8728b5741acd5cfe6ac055fad014f75ec6595437167857e8db24ead68cfa8c747d841d20d198e81b0129733346b77c41f0374306b8bdd2d2901423a5b3a7ff229ef8effdd9191224f550828a93196c48f7cfd4aedf806933cce970d9735ee9cac4a7f046816002556a4ed017b0a20d9bcdfcdc49ac160491e01ffb6abf40e76c81aa7ceaae8ea2e8bffbda355dfe9c2601b01436408fb326e9299e7870caa091c25dea828fded575100bbc5e5514c7d2c072f352bdf417aebbae311bba916859038cd3cc24147d94926eb70930bdc5a4ed409b0bdd5e94d16c91a59a6f75665de66add25e5f2d711ab0c6ce288c995491f2c74ffac1fb2d090fde3a52c896f6ff3124716ce30861ffbde2c02af7604eaeab790a1c2ee53c271480f40ac9f9c376cdda5ebac4fd6d8bfac996d69678fb40dead13a7715a55b549f4f9ac651e854aa029cc1da3b220bafa53bda56cc1dce1401d319523737a3a332751e5c0cfdbdcdffa1683952dfef6bcdd424a0c90405bb7a8dd9dcbeba8379a59eb27feec2bb5b62470904d2982ffb4f254ab6d5ed2692ca52c71a076d301a71c8e21a9fb4d4232eb820164e87f25aca02989a2e22d8087833125c07bc2ddd87598aa21e8a5d7baceb7d1dcbead4a7178646ee798475757d47aa45033f91bebc43b7ff54a0952fa9aad8b3c254d18d921b1e8fad26ec029e3ad637836934369b00238b6f2c7c02e80e3e267b86c2fa71f1a849adb333f05f32156f3df9c03becddcac25553f230b4ad53cee8f8e138d2d696c83d5b7ab7222e5572c5257ec7d1eb6113436c7f2c9347f812d3d933ef120c2fb8d99e1a56f402ea43912d1bf287565b44f1c9b8489671007a186b7786807b072c3d9b8ba87c9a0c263329547e39bd76aab3df574976cfc7000402f56e184c338cd65181e8aa7c078eb725ece45f60b9406b402fbf8cb2dd4ccacbfa5314b81153abafd3bc9ae4573d747c410b9595f187bc3c26982f88fa437a58cccf2455591595576dae0592c59fd803c7e4d97c18f6e7becd2aad93428d1e34629e73b083c5c3ee691f3f5eac045b5f814090da98fed1762f435625cd95974aa396c7ac523f7aba4a7dbf6d96e78665ba170918b64991d6a409117df817285e69644652fee26553173b8e46a8d713284eab3faafdfa26412ba19102e9d640a54b15301b3010385b68a33e86c6092b1d9c5273477885be3f7a05ed967f43804fe8a70d7dec872de7bebd51f620b0fc794de14194c90c5a0bc29c7047fb9c1156ae3b73a9549fada2c26962a4d27bf3ad37ee8b43feefd2270e1852864b95d33ed993adac8a08fa82a44e69a2cadb91a1be3379a12a28974264e9f007529f3839df8843fc0366298b04acf890cf0a73de4d32e6d096065ca77ab779fd623657bdefc2feb7b8164155a7d4a1b950c5c4e69fe8fc62adc229205c6bfdd0acf0fcc9c50b7f4c3c6164440d272fe40acc755334387cf605d4122c65d94a56e0ffdbf451be4844166efe341a1556899193227eaabd003207edeef7bdd328b120168bc25a6cf12b238fea70acb385d8a97825cb4814d324c9a8671710382f3519b339b56b68cb4af2c53c335a58fd01837144bed44c8d270971a2c51bb6099ca988c80ff3f8b197e4edf05b7c516ebd1458791afaf523ba8efe4472c458aa144444f330610613b80752ec64c49438f9eb9981da1afc9b5de9b48bca31d5e2033cd235a9c36f4ce325c8ddbe1e3e08eee3799378f49d2ef6f4e3722358e1e0aa5a82ad0130f7ae80eb641e5438467a6eac286d4bf0f6c4e42964e5ca1893b574a6cce0825adbd77b2ee45441a69190f76f72f121076456fca0b33b1d1b9bbc8681e6c6faa70314a67fab6c4ce8af6f7067eb46aa2c45e5a25ef3efb64228312b6fefffe2bae30ca7befe19b6907a40a6a34d68a4e1cbfe554eba9190c04293c4cf2f9699b29b137acb7d1ac800b18a8df89679c1b6977086755afaa73f6b7c8a92116740548a983738706bcb86a5fec8095cf850cd69e51d51ba0dd729958f9d0f252e03f01d7aa20fd66448eaaa8405ba36062f53640b6a14ac682a6d5d277e2cca9e37d19d774d6cf861ecbf07362e96f682972e63d9649fdb7143a0f874e6064d05c5987c1132cc1be6133c7cfb32881f874c9fe268bb2cac0c1b4e0f712cc8efb065b3dd209c98539c125f6cafdb6bb1f7f72f8a3b313e52705e4e723f34824fb392076dc6756fac67aec4bffdc208e23cbd5d28817b84d45ae3f68d01e62cb8cdaa2f2f2cc3d69d7afdb31da25e39e5466787681d555b2149cd5427874b2d3c8f6a4d47af12faebcca3eba4b7d57c2fde5cdd7869fb01fc5dd9662a4a751283dc550eef27bdaa19dfb22b4438f7ff49f4e12c8a20e73e091c1db27b5f42fcaff2f58c194658205d4a20b67ab0677044b4a3369ca60e0ae53c1ff78ff8db290f698fdf195972169c7dbd72894c46f75237d0d47a7cf32e2c5c396dd22e48d1aa31e6d98af17175c8d4c09f52f2b1cbfa8099c2ae32ac36e37d735c2b38063129ceede861af5f8b915991466572165771e6d228372fe1dc12317f290a8ee296cb91d796ca4a9d23c020e785867ecf4067ceac7313c552d321376bfc48b4bb98fea9e21b6276187a71be80e3ad4da275b4f711a32a9d2093709d787ef93c619f11e113d90b0d4078506a561bf9a4aabe903548660c475b7af41a79dd9c62c9e6a9dd2d98ab92e5198b2735b1a96397386d11082636ebf0431618c9f7c6ac4607d6565337a07eb2b00128be1e51cf36706422f8cdd70e652a36c8206a63ae1f1d6ef0b0bde2abc9208e0876e7c3088f852030a05c6098de5d409d3151308393bfc62e22ebca85929bb44215c1ebc60441b64522a09016f83484e616f3d3aa6fab0fbeccb1e9d7d6024a1ed36034678540787650bbd81f4dcb363fdf11e1ebc3aebe444cd573126fdd2452f6470b8b7eea12fd1af89a0b79ba34a3c58360042507251a9811a5241ec50f495f6c69b5308054e02972209d495bca476e64d8c3313204e5bda690afa81fd2f8dccf2162457bedbe6c8cbe628f89483bea5ba8ddcb2e88ce2d1f52162bd826c894aae3a3f11a8761d3624ec341f3c6933243b9f8d5c0aa5e761157c69f97fa9b1fe5a4a3265e7fa3df5ec9942d87aae87dff69dd5b51c4b4831a8d555b5f2ea26d253c65c9a446c2d1845d72ef55978f973bf4fd75af27056ba0c340e5b7c30e80684854bfe8e28ea83070dc520d4d17550722d965813741cb02d2536242c14704f7c9ff3a9df2131defca1a57d837a3581d6c0e0c33f53286ff500d4e7734597982c3cf09fe2ac5c7dde3c33e4b62819a22f97dfa822b742fc66f8480abfdebcc6a0f76f7fc903246692b7759eb303214c8509b37549b74f6751156ad4d4eb9e9ba2568afa5a8a6d8a11518714413c99b84edab501bdb679b70645f9d2b819446f464275f93f3baf9ccc9f920ef75cfa92e587c2592326634ad1b9fa9f5c6b4405116ab1c1b7e2238eb4dedd9268e42c4145a4aa2566dbefd05bd0ca16f4288d68448d3fcb772ebe3fc834c615ab8430df556c01e0cf8ca3f56f49d569f62384f8709c243dd3f3cf7822aba7b2a19f47c0735472e05d87b78459211b77019f4abc872364012b31222c8d3e14e82426a27b5f1a72d0c9670bf7071591722dc9595c95c58321b2d31c507135f0e2fa4d5b80c141e5ea22fe7a7a89c68433173eea43e7585ec9332dc5cb9603ee3c0075e5ed5bce2cb47acf379b6bc20dd054bbe86b45e32b2999e74ac8ba4b663cb8d96e6c12b2858fa0d9ebfd3589e7ced532d842ce74d25309ca1db3846acb3c701154d62302c66cc635a1d9c7cfa9b50b5191b5c66773095164040b88ed706020cd8534aece972d594e701cd42264ea7b5d3851d91b1244c23965c55dfba3767d97228123ee5c820d047e876a6ab647c02da7dc66b05a3fc4cabbb1ed734ed52fe5a5377277590824ae8f5112424b219ac663a3e7714175b59ae497dcfd9e12969403cf099e65430ee2231ea7e6cea3a3c3b66e91b1ecc1d089a096686c8f19dc646c36e81398226f151060f70dc341d6db6c98f601c7155077c56a02b40c2131c0ad04201e13ab5b32adcbe05063cbd14daab0246d80340352ad0915210fcad68c024ce2a67d48690f960c8e4c78744aa1248bdf34fc3a2f0ef5fa00826543d77f19eff4d7d131dfb0101627ef9401b220c603058916970ae5ec513fa98a57fe0e4ab3d88a5c7abbb1503a40fd8b91223d5ab0cb9af6d302b8731d98fb68ab98c076f00d8ddf2a91280c7e6dd3fbfdd36601333cdcd06d67dae8d8120fa526f4c798fb87a9a2c8c7230bb57f101bd76aae1684e96a918cdfbedc004b5814cbc81d9a27a8031f852bb2d692faaf1c0d4cb744c43490085f55becea863b509fafe86f22ce8b07ebc7163a6cb0d9579b638b6856469865c9f4fb0836d46857b93f35abe487c651b3bf34dd3bacbd3a24c62653a5c3cc95fd7a69f042aa9e65eb39cad39ee0a60e240f5deb17de7b455cf1b991621baf1b01de097d87793549485275a7092108262e5be833fb4b7e080a46f02fef21bb8bd42f16ac0739fbb83e6cc36a119e321ef50fdeb190174d77d6c8854f529ead66a49dc82ab31d4e045a20b7b6c3391d41aac141b00fc2114b5e59d1760e94b7368173b67df8c9f85882cd8f0f6c0d752ea2d4c2a21255dac3b2ee5152311d71d98f9776697c93f52d8b0efb0440aae037d099abdd5c7940a722ccdddbb5fbf1ada0454fc47db48cd5e5a4f90b4581a4def1b1fcb8e8bbb0504c71142f616feae630b7a59b862707d6e0d7fee810c6d2b87c0059984180e5689b4dbf6c09d35826bf68d017c688900ffb28ce40077bd01aed0450186ac714557859e252ef7c9cddbcb1613b3e0f2d48bd4062de432f28efbf3f9803c9c90091c9792a121cf4a9bec409939692b254ad9da1fdecb11e730b76cb13ec07f714684042069c4dc27092cd0851be0aa63f1e314d589cca937c4e954a8a9ac46b81ec245c75a09cafef81c7ae47edfee364903b16d06a8f6238c87fcb6593450cb9382ed2c99df0465a2fedee1bf242b9dc740d5dd4485e2804836e652e4c4b4860c65ad50ec0527db411cb9230e8314fbf8f7b0cf11629b9f90f80ef9f5059c7c9f631c25e2d430b53dc1b482ecfd3b0b801f704c7865d011c53f18bfa9df1489f7c1312a1d6937df35bd1d786f2ba8ca76b5f2b688677f2516abe4048b128c2d90251f4ff02ba9495d9ad91d48148ee825c3b31f75982b69d80bfb79822a4c0db2cde721d313c1e68d1d901f276323c8d11822fa29c20b3071179c917d6c69424473232adae951fd1ffb956273db5a87506edb82b685cdfdad1032db050ecce83ab3eca1da66c5b78b3ddddf05cef2c578f09ca092797612dd8f22c8d64536e10954dcbf17fb97c7ec998a67f0ef3286c32da165b675d87fcf7bd5c9b49ed6137a769b74f8af7b793f823131a58da36c702f7c45d072f7e53ea3b8915af97d11d541c0c46a378f6159bd4d7c4b44fa31ea26ad4ea3219ab25f3e602c90e8210aadac71313eac2a0a01f97e3f589add611ace9d8651c42ac3887afec890a55debb4296bd13ec282680519c914d00a43331586cb942b9c511720385e42cb77f40d739e16dea92d71c955857e0b2284101f1f845b5d093e737dd1fce6da8e489e8bf69abc84990f0db490e080a577f24842db211dc0c13c8e79ef155887871a5e9af0dec914520d6e1d164ba144da6c424b9b84d2dd5c982d4b107f560b137dbb7d08c8510b7e57b4e14ee1719c39f352613e0bc3c4b9a01fcbc769f7b2daa6cf93da1a8afe0a9e485ddd79b6267cdbff179cc01a370f15ae2683710b17fb9cc6fde56f664d3b770f486106a6c5f4fdade8d6c4e9bd23bbc4e1f8cd1412ee91adbb87fab6bf010f9b6b76c84972e0457a31e590b37430f840932a4e5f85194a89e3f5781c256a0abb970f2400e29973d3157a2b28bf70686f24cbe5705a9970f479e7e8758b930398b984466214b5cbb840022bd89f247b015856000c5489e0a4caf50d28c4f6b60f6ce4ecd9773d889890e178017e26a5ad0183770815b67d3ad089d2b061dd3ddad748b2500af8de3044dde3181478c6719e757fe0cb5607e90c7560accd5949be984ab720337bf2f3fdfdab693470a934021e33d77ac39dfd167ed6558ecf541fce2b8ba7d154d87d100d3a24cef0680100f7c30a1f38525cde82aaaf5b098c4122f6a082e14dea41a2248d055c58ed4f58fa0527e125e6d50634e54596a562ccdbacb8c32ded2d1acf500a536cae6a17937c8003ffd87c25d8739e1ce90589c8eb11f7f462e2e654bd9243bb19761313f87f1a51553da4c5470c4e7fb782e8dbcebf787f44a082345262afd420b133a763deaf68eb6e9a9c8526da3bb377f663a0a0a46e85274180d3368b93476eed073a83bb17b38ed34ed37779f2935aacd681c4e80acadd8656e535bf38d5ee82e8fd0db928e763aae28db513f62906bf726014c7b38e279a12eae7faf2512362910984f1669fe29587fe3d338fc78e7ad9c86b26a3fa9f7a6207cb3ec2a907f95cc72f3c4258c1fd6cbd2aacc2ebcddca07fe2dc1e8fbc8f7619e34f4060b7e121e8a52b3a4ab4833cafe03e8105fe66054aff103bc0a6cd48e26df62b8dbd81efe75bf9c8ef0e7a42d9980f8d325527b0c2b2dcc8e60b3c86133a48de5d0adc392dee45c5dbf789c5e99598df76e8aebf43f9fb0c6163de0944822350dc471e03ef294331c50707e5fde30507395d348dd79ab0f5f88f81291e0bfbfe4e396289630c67007e99a6e0d2afc30a21f25658497aa9dfe61a716fa12a3f90015d7857a4018810b9ecad5e2a6cc658b4f301c567435045c3c56569c1afb20fd6a41500ba590c53b8cdb97aa8c36c77f244dc6de11a726511614d728ca221ea59e4e2170d5af6652689067dedece7834d4b7df0096d4e59fc705257f7b50f27fb8377ec2970fbb13064ad6e987a53a237d444f138ac1e018419c1f9a7ffeb614a870cb5ac6b25a583228e9366453d3084931fd6b0d545f8e76b3b33f357504685388b500685fed3fb958546e78b80760b9f4a78077cc47357fcee4adf36f3c20e3dc528fa0223d7fe98ee47e3aba5ab22ca6ba82c0dd1853e451192c5adf9c251e21c25babb710207e7b83f465676070039ae12da42aaf05f31e3e6e8e7e2b0fb73c4351647cded7ec326978b7354348d1c1741b77eae70f300ee1f4bfb83d73e7df4a881f2881511782c5bbe9187676a5fec64d3a9bb14da70d9fae2774856af7c8e255033e12ca58649753c9421a7ab2ec3ca91ce170dccc4bbae3b233891424e7954a1201e25c1c154afe4d6473228289060408345b7474b0178daa1e131be4437a9ba488502967a1912b017dea37bd55f4eea4e90b5ce967c7423e231bf748aac550b0bc68b362eaf26dc5a4664a696cfe49ffa04669663446f53b3107850c3e364df8b6007834565e89137db17e4088a722fa03da04b05da0223d98dff877a6e5512b6bcf1fac709742690a0c7f14543970a7d66078a7b0b3a56249c89b70d5f5b88398a3418c9858cb9c69779b20d0de40374e2eeb6b1550855cfdd89e94292df6e85162d83131eb8a6e2dc6b86cdea9e32e836e7eac04a6623fead917391872d51b85b8e5593361a1cce43f8b0fcd5fd053ebf27da5d2881d907208d9d684ca788378efaa162ff37bcc0eb5e83b03895a9f3d4aa34bd8cac497c01ab8d0c90ece346f8099c3099aaee92288b4d7dbce54a749b6a1cc6c85e1c91ea1e48ecbd4cdfc5e1263cfd7176e90a7df5dca9d923ad871cb606a8f180c8a31091e4f28010da4e7ec13cc32d867b3fcb1674dd2f55044550151b0ffaba7ae067ced8fd83f0572ebb8a6069d3cea5bad968dd887c8669217ca8e71c945a7ccc12809fe0d2098114cfcc37bdf29182c6f5e1b395c3e361b870fd004fe21341e2ae38f63d999485d24a4431b0ef92feb3b268e1d517780159ff76de3ed85ea05b1f2c294fe324d92d757c859a8c255d281411ed64d97d774c4c7aeb8d75ac3e5a2e7dff0eb2641553acafb0ffc37e9af29e1ebe42ae7a2bf7b500a4d558ced10564de7f4853a4f38fe41bcbbb19f0d8b2c1729dca600bae10f064108068676bcef429867180e944df72b874f4361c271f08f9d35c31e6607b45ea2343e484f9caf561badfcc8d408c1e54c36d5bad2835aa49003ba3fee83efac7f6529756b7c96131e08a7a129a566f7cc5a41754d1a13c4e0946db8d3286c4f38e79b27d4aeff7fd4f41bb237fcaeef9bfba389e821cf41be5699008926177559d37ad69542479ab6327b87c58324570a7899dee74f377eb384b3888c1108a6dae44573e6c52d6f004007c3045b46579dae1e78a50f3ae3270935c2bee2fb9649b1801d72ee3affcc0d765d70d851f6970d14ae7f8d165e0f449775daa87f6b8c1cfd3000eae12d62a385cd1c0c666098d5398ba1dfbe189e6309a531a78812b1de390b61657166d385467bca36212896f80531b1f534d7731b133753e6fc259bf8c5e427d6af7982b7b6babaa699be088a49b94b485e722a68ea93f306b336482d6b1b7480dabbc73655e0b937a4759e1ea8bc25a5686a19fad0ef0513b6065968fe2e963143ec5e8de63825beb99f8ab4cd46799dd11bc3c43dc45ea917f9d44f3153756c69a496b727a098ed3f6c153238b7418be198383a62b707bd740618bb8b3ea74008c3bcd1472fc7849297d1fed3f2822d8f2bfa89134df2243e26271fc3eea1b2e68906e2ad6d5e53af5844db0f70f9b865757b07d6fa817da83d68a290cab2eefbdb8b3736aec4dc65300944b9573d822d435137e28c3e62645f5495a5c5f5253deb22c2e3a406ff8a4404a23e1f18d9040fd0a0ba8b7385356ced361a9ea5d17c69db37813f15a7887b767e50b681c9c48fbe2d15b0ce0d4b23bb300d8c65b61337b4214b0f980b7be070d9d51d442a50049a4b38b296724e157c57f30a256930987d80a8c021e8426055f1b602edc5c03850e391a3fe3685880a5aade5519dad8c848fa6a12bc4b2a037858bc2c5370172062277552d22225318599d80f762315551b156b189adcc63fb9779eb16bbf8b491ff28a22b881a113351f252d18115e9dc75f9c01445895500ad04a6f68b66c48d375199493427f9d388cc5ff9f6aa23f51b7171118d05143f531031f684d24e448214a42f741c54e83a35e20e0325533e7fe0a9d959c21559d27681fcf37d54e47b1d05a54a2eacdab777e0861dd4fc8dea0bd93b7e1c9f9845d54ee32f519b650775bca19bf1f926f263394b36a07a4eb0f8043623746a9bcb45168d3129033ff33efa945a6b66e1ff15af53acbd577e3ab7e645795375238454efbb6d329d434e16b649ce8fb577bb6710a40267104cdf71d7c49b6f32ea9e08fa24851f39e29a46bb7b10c0eeac16d34b3ead58de34e5a0861a5c5862ae9dd4d0d17a70397133790734bd467c1811a5f198184ae623b8c37f9aa783729ef81fd7b4eaa2beebfd3f0a2a432ded273d105ee8c4851af9eaea3531bbc973edef5ab5567a85c019802bec6dc765ea36606e64fc77e99bdfa0281752ac8cd573f91e40db61331999d53968242a442659cdf156f39ac4874f1878f0e3961578d197309ff2b7c6c24507b0c99235917326611c9b9afbd3d4a1acdb3dbcbe3537d36376cce94790c520ed0d613705ec7cbd8192b40674157483a833cf8580ea25d6401b8c3f3398099e001b9a9ced29b0bcdd05eaac852f7b4f7a578466d631633187ce40dbf470ab46dd9bd6174ebe155f677b073653c4d5bfbbd6549a3ab0fb0669654d7478350190d444b6423588ea63068b2bd16ff0dc0a14cc660c12d013e27fa8122e33f832c415ae6881720a8851397903cc60993af5d901cfc487332a544f44cc57d690ec50e0cd1b1647b9bf1b4252e1fb55072bfd2b9524bf1b5bfdc31c6d9fe2a5c5db3d1fa9159201e30739824855d36f502b82ad2f8abfc44c3c980fc88307d6fde1457a54816f425cd1950c33eb3f3ac04f4f76d7967b8c7cb9f412565908708678d06fa6811a3ff1fd7d714da1b4f9b1f34d9e35c086fefb74e2185ee53f9fc89f4f7980e6b2437b18e46cf63d53cf7de3bceaf99edc67bd133b7a74bac5a414f1056c2a128eaa57218fad2bb1c9306ea3be05da0c155524c456145bdc8232a955fca2ad0c63c49ddecbcf2c951a16741b95418b37e59b6abd9806a65e0cd56f6c02f1396484a2f1de2fe9fc7f7fa2cbd18cf130933c9de496066f2f4e9a923ea81864de13cfae11e2b3f2a6ed69f61f431f43e30a87542271cb17ed5102eab4e49d5f14fa093af7ec800947218f94b2748ab5835d9523c73ddff412c45ee3da33de11a803a48a1b2f244740b8b5e2c2b9f703adac3dad1be8580aeda09b1752bbc41754de8041f2327bcf9641d9da1fec59f9ea4ed97119b3fa8d1b3093841406e85ad7ea0d812ee6c9f723cc20940e875ffc93e64e5f17e4bc253d55b4d8c589d25a145e9a15d2acc501864ca1faa272779193da17ca0af48270fb87ea4ef93a4fec18cf22395a8f11ff78d9a7989421c688330f820d3bdb7f9b1c502d74223d840db77c687151563260abf4c4aac7acfe9d9a8a9d6477231aefaef06845d62b9acd6a2ea6f0f942e972533c4fb7af59f37fffce04e41c31de9dc0dbd2535a43c1c2548119dca6c8e18d5143fb0d6f458fb86c109c88f7dece4a4369030218ca77c0f0cd52da3c2c6fde02fba4bb85a0a8573fa4cecfce17ab17784151c3dde8a55cfc8177164a52b12f37f0cd2f94208b8c302057a0aabf31d4c004ae410cbd5a7619d8a04a1e15acc98a7045d2cfff9a0daf2fa8e7abc21f1bbac3212bd3c0295799ca22e0065018f02e5469a5179052c78f65bc30eced9dd3ab479d9e7e15c364f197b03c08629b2157b2ae7342f4142fe03afcda17f9669c7be41ab0e2a4e50fb2d7ba93e49ce2d3e007122edf36dbf68c45e96d7d9dea49ff19399c7487f1cc73016aef7ae30876a953bf41b8e0501f05464357cc610dbfc47f7a3c154b72ca49d6012831deae34fcc495700e9ba63cebb8a68debedc761e55fab92d46b690be0bc108c5eff484ce66423e8daac7631d88b8f1048fa328b681609b36fafa96f5e1d4d30493ff7489a092f12f166cad67e91a0c7b9f391f25a382f74930026705e1be88a4efc819155f997a9789a33662a37af60b419c7133586928e125d3f5bd140d3c62522645fbb2113b37d349f0d07400743211904ed0d1066fcd2d7125c8bfad80c96a1e6290fd25093921dafd73402484cfee60d61d5e76e81d240b09b4de1d9ffa9919c9441089193c708b996d7aaa99774d51260d40dc33479ae38dafe8d0b993858932bf50fd14c77d4ab71b61a7dd750c6bb7f70ef4c31ab7e184cbc8d845e5aa9b6f8783adbb6b6a14d0770dc2a3666deb128336adacec526e2937fdbf9a49b61280e548b027ce6dffa45e961c5a585b39e5bc29f5ada8cd2ba8295142b4a94bd213fa75255dfc9e2b2972d6a02e71dc9279874b47e4d3a60a7ce7e5d9f2aa2f46a301f89a4b7d615dfbc1afb09768668d5cbcff4d5f9b5cb11d30b6db35e8e9319989100dcae32954d08525af4119fd8da212234afa3dc6287e71eb89985689ed4713f30e80cfa78484e459f6c65a75bd2b5147de15d4141c5c736d67f253841be5692054e03630ef0503a52e940714135dff8a5e4c7df4bfde3c18eb0e0d545fc738cc5bb4c4b3f48ddece6a431fb5cc6ab15792e53d4cf9f51a1b8e2ee2ffc49e6537aac31685c01323943aeeae7d1f10621544dffa82bd6bd50a0894a43e131b4b2135986651086394a5c8a37802c2e66ab74efe71d56054334596bc5e934ff5e109c4c1d157ba92b8849b6724a72aee03f810c48adefc6542b4f2b1a2922cfa9048547d9f309992c2cd21467db7a15c85c8af0fb37a72d9d8dcde4797f86af652a9e519dc66ec1e15d0facb4afc77a0bc37e2513a54ec89bb5310b63e3ddb311c8ea3d8032ed82cfd4e361bdb21bd7289953ff7faf4bbab45c0de985efe1d43243385ffd18e59fa31cc6f9abc3ae21123ef5e54df54935fe091c8def2c09a00052343af9375d0fe19de74473b0c29e03bc730ffaa1334ef6e919735f0c224590e9793e3a8a9a65f5cf364598a1ce374c45f88a94a614d3ffa2e94f97b084e2a5ec42ac35d89ef80392f8c8a804d86e38f8966a8d839165c70cdcfc92f7fac4113513202892db3a28040470ffb2c0d2e7ca02a4c863d9f6c06fac61533ae7dc104e67ebba20da9e90841ef4a4c3ada1d78b7794f3cc434c79b1780d2d54719a29c6fe025494645299d7b956ca992927c993b37437834478543dee99c5673c1ba284a5c902ea93b0666566bb35615795c5d0b76b9c236424a7bd133ec26abfc37c323e5d0821bd5a97d3c5eb5298f103a09a33ef006b3673cbfee45f7cc8220f1283295709784dfbcb851e6a7554ee7dde857d46817e24e892ff40874ddf799dbb8130391452d68036e4238547cf842086767960c7e863df31e936ea727ca64cbca5698231ce702e609b37871557f4192f66cbd58e453f75472e9a3b0f53af644e4c1816966b664cb332f59ed074224492a250e6ba68581611220b1265aecbbcd2174610d5e26d7d3aaa27b3e20b73a6ab2c1a0736178129194fc0a71f114cfdd9afc93de49b29cfbe27e219f7548a5b74fdc2d4ed7d5d2b2e1cde0f32ab746006f7e8c848713c4c233ee28e844db409641f5fe0aed7bae54c6f791bb3023bec72a3058ab902e4780ec77b86730e6932749e9e36fb7c9d9ca93631ee5c5bc9032c43c00621a2ce653f8377c0f25c33efe9154c8624fb2f2ddb0e84ae212bcbf2d99eb29da5585c1d9b39c508606eeef3aa281889a823f18c56346d83594dc08147e1ad3b5108155eb7c4205f38b7c6c81b8d39a43a9e01cd2bc089876e97cd901f7614c83f5960fb98fadaa7e9f4071a9612951e30221f73b17e3918cffb0fcbd15961b34943fbb02c3284cc00bd1ec58b52880e4a78967fc569e5026625c30f73546dbb542f74a8ed7661dd68410223fc1a908b78599b443a9ee3889ad2eab027482d1c05e5e41aa8529ba6bb021277e81cfa93434adcebfc442df1e6729a45983a1c7c9a76b79a97cb0ecb6aa498fe42731b434909f734b3127a1d6d49d3db772fadae8bb67a3b60953ced4d3da5a970c834da6c83e4b088126584cba562847d5a8ca3949eb09ef3bdfa6c104245f57ed6fe64c02b528c463e3125fe5a894c9468fde5c4a8b016b20e50e435a415555c857eb74e157f51e46b57f07f769d56e77b80f04a691d6cc3b468a9ce7623a8b2527ea37b48498f3ea7e005c014082cdbb991693eeb5c1430821793900432a08b64d5510fbcbb27a759e217255f955ff59b5f01fffe16d11827f7424fcd0afbf3564c87e837fcb8d4b88c9fc6c3821b9a4992905b7130454192acac92c7bba14d5439ff973e3aeabd4e678e1279e3813a27bf550f24d31d61e0f45db6e139cd77f13f2f195a24badb948a99235a9c4a2545578750ced9cc5bbdd0d28542029cf2308fee2a6defeed5354fd3b98e0203dfd0bd8805e9bbaf77ca272b13593feb00d97652362a15182c808aed32bfda354474259a46b417462848cbaca2f2af77d4f6c834a0a808b5b768f1027fe7adb877fe1b213e7f51a0d4b70c41f4124fcf585ba60ac76f6a30e623766ec7faf4180f57f5b7d6f6965a5a6bb10d70a393297cd48247306ae05ae2409a8473a540914fcc9ce84503d13c9e2a078d3fcdf3756f11820b9da48586207907baa53a924ea705d60abfd5df9eccb0604752fe95e38f8432e80572f84dca83cb01fd7e411fb432404864ae1360d1f776241a53a0ed72b54760400cb82c6d1aed50896667efe8033a6810e5afc8bc982619008d6822fbde8844b4d2381014b8e74989c041252b128a59435a467f260d86653678f39f226c20b3c646b622c235bc555e04ce088e80e17a383ee1901e77546806439f815a789441fa4a6b094b6aa83aecf253ff3f0473126da829b13680c43cb0933133224ba5ef7915bdd1841e2f015a3e0c2044f2a025445cc2bb0d64dfc9d6baa332257b332fa6e468499c1c533f9c79b32ce6c21d3357b08eb02ad483f4da79109664bf2952ef1baa5b1d542d835121e6fe3612b7ffa7255b8610dbf652ad24263bcb7075a149bc7d8b79d5c63b3258242d2bef5798bef4ddece594d24838e540f0693e40d18c0f2c99e9cb350a6266a79633b64b26341e601f2f7378e4a55e98b29ab9ac98f04c587a1d51573aa017aa959d6c01205931c960fcae8ef4ba4a476d6cee0c2a9c4f4697f9ac80155e5fe37916bc999ccd5051f7e1db0c02c76b40cc366b9ba46acfa80d7f6230627f252beda5709b1db30995aa501d2a8d5e9e8d3a6faa213aa168cbba9cee5267fc7950648085fe4daff2090b644650d72924ae727dbeb41850e2e6e0289cf019c2c1ed54fb9a150ad059e47a387355746597203ae507b06da997bb4b06fd5dc82667572f3b00c6fc4fa1f16b1cabd4f3e30bad3fa31c2d9145d1519fa53211477e799d3427b25411af09f5e6d667ee3120a2e8bab6b46b7411c366b9fd45eb4c293f48601b9c614b912e8169e2d93289ee330045bd2a2be2c5d34e0d9597f9c3c6d84608f53ceb52866e52674da604966da99a96cedd7ebfbd77ef4928bf2fea6d5d9d6a0f698172a79ce76c6c87a932952c644ba37cfb73d02e1507d966be7b94ea746e4a19121720d5b2eb7d151e8c3ac25f3ad03d0657c6168e0489e2b7f1e712a3d3d91b47c21fd16c650de98911f678aa935df9f9b752d3ec5ccb75d521d181d74c24cdf09999a7f48490649e4eed28ae93040d5c82621c85ada07d222f4cd9be0e56494c6826b98914537ce17d93abd3cb033bcb352e5e08521afac953820449454d64208349b7194a84eefd34b358f2de4ff5cd709e5ac9527ddf58e329fc39f2636d63f58da3247283ee7b6cc552db1da468a3cb0ba118ff688bb9a9f0dce31d5e3ca1f53fad584fdb928fcedc05e12a34024bf565d793bf41ae279b48a1dd2c44d78589660f489e9f601e0d0f7c63dd83981fb527c08065671c72f28cc9ed612ff44f6a18feff23a1ec5e681a489e5eef22a6cb09384d8e04001e962f70dc53c11a967dfaabd93f4ef19eba454592d61138bfd4406ddd26189d8b0b5e74426d9f2e2a8f172ecd71d11eb714eba34875cd2749d5bbcd2e1af92c6c3ba1b5d840ac663abff0d1b1a0fc5a38fb1595a5922a30e4451d7dbdb1b80c610a645e00db3b94be295205438f06c2e1016889e9e1195dfe5fc57b7f405e956a0bc5264537df578ced5c9ce86fb68e2389e137fa4bb1e4400952f737b04a9f7c4281b6d3eba4a8627657110e9eb75797b5f44b6b5a81fd76df0cdd7e464d65ff402944db34423b17aa8aadcb16d62c11218062cd8d988e6c3499eebb07b95f93e9f958ef24140de97e8dc0adba2dd27eb6d047f03e1e74d7bd46bb4c6dc382e6e848f4035a5cbe8374a5155a9c1c47f6a0000d06adb8544e51ed9079dfaafabdfae087ba4612263d59be3e0b6f5cad1d3f2df30f7a839dbaf1772710defc706c81547b81b44118e6db6099bb134b8aa04894554d7035f691d10a2cd1420ff1a655e9321465c9b49c41fb8f4381a662d5dac9ab96a89e8d06ccecfe6b696cf45eb445c1514889cdb7a6a7121315657392f18314bc86fbb83b4c643dbec98b8106bc4a09b3523f9ade8213bcdd27fd395fd8702e808e2ca28f32d83ff5ede79e005ebd938fb566f2d2bd16effd63526524e05304ac53adf936986722cf7fca67af20db5118f8496ab75d75bbe739bb134a7049414766018cf471fe6e2e0174dcadd17f794b2921abb9b263cea93afb40a7849a1be7daebf3a7757161493d5dbc043f04659fbe2fd01e323720c1cb1b9e786fe8f4e0700de887a80263ac759280e3211633be3add9a9a6f3b320f540fbb08055309b03f9400f135958cf086924649e2755581dfae39409206c780dddfd17c9b4edc8c23c2669c5fdc41ede768ccfaceefcb8366f20ef1e0c5849fb42966620b0b308622b4d7edf671c1c4533d59194004dbf23ecc8ee216ae8fd1b27c61e9edb70cd2379ec8aad9bc83799ca2ab53f5e69286e04a48350bb4bee83051c0087e1cfe8b9c236a9ef8454d50c4bb0d22b55720afe8f220a5040fb7712df0eb11f42e867c5ba704cc5d7dac2e42f385ca3fdd2c313e9e039c7d46a57d7d09e8f72631778c7de35b0a42463ba94e8867ae44907b619cdfc7bda5eb27997bf5cb64d934332635bffec8857fbc04c36cb2d9c5f8c3d4ba130c8815d1d190222203d12f662a5f83da7ecd58ac78b23717e7890b50ee5a61c6f6c86531578a48a6a7bb160fbd80be21d8e624dd2badea854f5e43e7f33f329cede6c0ee19730775bc6c38d5509b8e11f3403733a75ca2fb89accda3e20c669fd6980d09385dfbba77639925f9744a07d87abbb6fea7a28690106e49d7a7bc3669b60fe7edee53ed00d3460423dcb4253c6284a4cb849872ed99ae59bf557301e24d34d5e21b5e733a351d7f140c2967369feb0c76c582376473f4e12933315adce03e5eb72d4b85e633701d3ab3aa3aace39946e725b64687767ce8a1bd7b41b66952e485a50e1f39d8794bdb0c6e08761a9b6d3f26f40f41e9475ca57055d514d1f15b7b6484b2fc53adfa31ef121e43cb847d78061fabceb686d5bb9ade2d4f8ad38102e1be9e9d6c890b8f12846725e4d1a39c62a9fd99c4a0ffa05329c7b06294e4b49cad28a4a28435252f538ec0b8d3a698caf0fbbe45cea3f55300927618e41763dedc684f11b6ff13d68f22026e9fcada0e64bdc3eacb862c6a7de7b12568334611982118bcda8cec66fcadb8d683976de4843cdb742e426608fbc711dc3a83ff4e15846f104d58fb431c010cfc05c65c4f06677801220ad0893a1ed74d8aa26e72a05595163e64f48b5e9bd33604a52605b2460fdfebaa44256c66af9d5b194dcfa08fd6ae80a5abfa7de8b24ce0a07fc5ace8e6b31d6ad229dfa2a5443f2d3e155f534044d27adc3fe438f0de1dfa5c311bf0bb5eab1789107c2b43cdba65eddae46633d892a889d715d47217d38174b4d9e171e065e0202d8c3a3a473268d2fbb12dcecce1c5941b34dc105560306b262d027a785ac820c4e05a9ebcecd1c43c2aaf0a377c23e2852def54bee5d7b3eea41925fa8026361c46bd05a3eb6d5f80d61b5fa3af86fa8d3083fe71f1f20a57043b3ff4c6be64e07e69a598e7c670f67649b4507569577e9d0dc3664397155adf013df47cc759be10b05bc5b133244d91bf20f3eec3e5c2dcf1d7b2a4181f3c6336f84af3dd020d5b643cbaaa355203182cc46b609a68abcecb4862594c3ab78137d57a0f86a02190c63156b94e400f055fa981d418f012eafd3c859e622880c5f9bc00f0bfcdd4f389391c0d4a17dd8d2fe0a1f466fd0ff83f617d68f46c9f3b06541ad4a3b49b2687a2120e7623cc042ce691203807174b451941d2e3fcd06c2003807ee6241c2be2ae1951550de14bd469225b1429243463821489993603c13659bdd89205e422b95cca67cedd12922b9561c561cfcccc181fbf18cf97e3b888c09b89a16af8d8cda8e254a560912e544b9d3752895ed839439ab30baf95935b8429c7777bbec97d10d336002f10f2c2b3e05177e363e2968eaefddc89b3bca1a8d9461c957f3bab0c0d515f90e24975edca625510aa307e3319a19aa90d44dc3cf4cf7e0d3b2848eeb80d7020c397f8c3a3af2fad64580cbd8edcec2f41ae6499b98afd9a5a9980614c96f5a0e0dcd3c6f4509559cbde80e448e944b5700d6ba28bdaa19a515fb1eafecfe8d54ce436238084ea0ac84f30527a7597d55393f69a191df20b559b70ffc3fd9b929b1b42fedb98a6931c3bcc4957e92d39b644c6c6a1cd4b07e549775409c597b822d8a69ebd5cc12be28b0ba2642c7dbfec3b1a224e1d959b4f5a1ce783085d964bd81098860a3de0dfb1312816c034378c99c0ea1145ae68a33e0052f4cd644f3c7456ffd483ac5eb7ed1564cc1c9d6759b9cf49a32fb2bf4746042e069afe0e4d63fec560a0dd56fff238509771ef3e2f583c78e838a6250bdb28aab8a399dcea239e97796fd37a1edf7370417bff15dca4791073db5518958088b1163ab966637a1341f4638e52694e57f5110b3c5df42fe58a843c1544284cc528b5a5284884dd59bb3283481997456992ab2ff6e2c9fff15158a5f7056bbc481cb17e2ff3d33356b134ba48e78f23fe3598ba01507f3dbf3ca4fa3cf4cc696107db51ba4c3a7fa4d0968835d4e642f7fe1e23f0ffec4cd831a416fb35d62cc2a512a5ef07b2f363d7f87520f6e98ffb5488d6dc5ca7415a888f2e83066856de72a514db10b7e7840c114fd2794d6e4b23d513275bcd74312356a8c6be08a3b0ad98c8e45deda953ac464d0b4575acd9fee27848fc22b0148657cab18e24469e29be616034208d98ecbaddfadac2b0b8611d0d8cd259dd1826a311eb535844dbdac9a2d0b386f46cdec0906378b05b47344820d2ee0ebba8355ab955a766acf5f1b2f47d00c1fdeea27756181f9f332cf7cb84a00d795e9208c0001415f9ddb65b0b91447a5d2fae3ff325794b2f85eb501865b947cc1f253087acff6fd59d2501ec7697f3f5cd417f51f58604bba7fed65be5176b51dd110b8ff5f2b6405c7f0640f8438c048cf5abf8d23ee3e64ce9d1fb42a51f9ec09d7b3d0206d159eff33e43cd8909464b2759c1c249e80d6f76b5725ad042a7cc366b768150a93a008547f8227ed884b514c159cdd3885b2e105ac3fa0518edfcfef78d50f4d2887bc0373eee57065268fd25af29e1f7e2b09b3a30da34affe81131d156c70099b9b6ac5baf7f66989622e189211ba5b7d5167d69e0f8eb3e198a5dc112d741dd27467197035a3ddd26e07d14b6cccc58c073eb630e7467a44e6e13f54c7cd4f0b87554c5c9cf55ac56f02b023ff642a62af0659366ad1f949701bad31853933ee251549d618a107f5d9e9a91d290ae7e938ed19fbb65ccc2c94332f0302c74860599d1b0781925ea1d190bd0ef25475fbb3e2f4f22398339fbcb5e8d6c20d296e7a4ff9d162c364b67bde1ebdb6a648a6dfc093664dd1de1b549bcd93ccb99a8b0d0f59b4e2327ad2a89fe8a1e65096b1b345ab27562369efd40f94129ada05962f6f6afe5ed43447b251d934adf1eb084ab2b200924ee8285e6b8b219c7a733dfbcb333150b8b312d72fdf576ab4ece6c5ed14b1cae83ba3fd93ae7142f5d2616360a648e4cc6429d1765448360d4f96fe670db3ef73fa1da4096fa35a8726c8111beb31d597802ae9eec6c62d03617f4303e7cbf0cc3165d9d6704bf6551ba3c5f04576e360fd6800c88df1bbb8f40bbfee83061437af59e0074465bb28eaa7e103b5bd276d82b0542bdb45bd478845d6ab1ad65b87fb5fe14caa5b1999aa86660ad2653a0ca2af7d0c57f9a347eb459fd558380a24fe027f104f8a0b61e80505a5af32e5360b51b5c69a572f282f7df0774f5b486e804d7f41349dd32e6afd7453773429b722aa817a9d61598b71cc9e8e42b2dbd9a5f18b365315ad748bc54f4982db4df05b3764330bee119886d4823207966c05c3e891180d79c2ebbf46e5440fe914f2bf898c77bcfa53524eb9df35e784a7535ec02676c71efc9ebc44935050cd193e79bf24b56098cf888b3d9d2f0d95347ab0b017e8905328cdc0ba189f33b6d5b89c12c26a1c6c7b67dfd437a5548aa0f116290acbdd8f5200e32236a07f6923ce9756f8b1376879775923c7653aeac31eb6557abcbb9eca338219b527b8f6e40d2ce0e915652b21270c550a8b981564c221ff294260dfacfc25db3a638990545c3fc29766326b3ae5012dfac69ad5382ca579b740222e2786c821e537dd6c4edc5ab0b929f56037da085a114aa2a3efa4dcc6e06acd1604f102340cfb5b645ed68c79b953830127e56ec68d9775cfa8adcb285c42802320ffb70bea0e5e5f64ebb1504c1e1d844ebb465b2dd84f16246a67d977ca08d5682a0beabed7630346e50a8c5cadd8fd94d2356c1c5faa8cefae5a36adde46b7f02362f239fe9d1a94e6d0d3781854ec6c282789681fb0fb56b2f5272e6d34cad564c146a20c40780bfe57a66aa8d5231cee7b2b7ba28d3502adfffcbff60d3bda02f47056b46b8822ddc26d8ac2e39c0fc36c80aa79ef1f2b68879d786f67af4c98dc6a09016eed1c706bb87738214a36d960f95ade9e1e6d3035aa326b2faeeb8757ed5a63536d7dade96d9648d3597c2a4317551cb000be86b3e978f04681d5cad04c735dcc9dcc65c226566b8e2365e3250945ad6b5b640486b6ff49f766e92610e192977861e4cb82a46b12c13986c3133b837e5b0b87e92138bc652b58bf176b1a6d918a3807ca9f693ef6b3a3682edfb301d449719c6f8d3d109c60244242e35638b593d518f1a6a1b77ba2ddd00e3f70e307de99151b42c72bdde8108d97863fb9a89b1582b75cfdd220d4f9e8cc4d40e63ac4d543badfdd38387b8b5ae3b47c6bef4b7f45240e5b0fb9d6641cfcfb6fd0b18767e30e69dbeb1f288eef0c1da5b58b2e5e1d0428cd02391155aa1967968755e6a801f41ae499c703f70fa50fa6c2c61ca7396b8b7e2e9fa3756043ff310baa71d64afd5863d9551ee95231d14e11ea7cf345d63b5922617a89d079289ba59911b43a43fb41bd33daf150d1616d307fd53e96fd02d7b260aa2ab84f43ed7be80102de8bee6d2ac408043325bebffb08afd5041f3d190a4e30778522b104afbe0ab9bf018590d316b975cb851e6ab47ce4f75a762ce27700b9c0ea8a1b81e5b1947bdc33b628a8358e7a278f674e1edb7e9fe2242593032766c2361b232941b717e67a0487f39ad4f13b0146cf8b8fb032a3431266d4f0cac3b53330906388436629e60be35ba26964535035e261cc9371bc73baa9ef2f301f752381f5e2003060a483ca4ba214050e3e193f97d6468ac9004eef1749fd716766bfa49953380f907b03579b14801743cb6f62732de0f537de80d23dc5233827ff777582b010530c68a7c94be2c310bf47de98a0b58e3fcbbc813a870c10937594f46da41de9bb5743bfb269e7281ab7763ad30b95f651d70b85b6eb15f10a6adcea68151c81dc5e462f21eee8f99bcb5ae6b04a771175986483a802afd732a1796127cbbdeea4fd29a736f8405b0cb3e869f3b12a9a9009ecc928d51191a5fc4b954a627ac75a7dce1c612dd6f3b0c885746f35916fa708443639e48b39cc015010dbe34b0cc9dc13875a0e73ce84f1227f7abd4fff20400dba847a9827415df8f7528a862bb4dab7aca56848c054f4762e5a068b50412635b5ad66efa0d18490c17f782885f7ef6514ed4537e9da8d5c0bfdcf85cb0020a9622fa8f2aef487fe29773324e8a11eae9331170d78ffdcb835a9652784cce28a921766a49c86f5e153ae1fd18ec6158b9c7447d90d78b9010bd792596b2644687cee38ea23171fec98308afb61202058c8515a1f1b058487e77cd540a45033852c4e7a525bcb2515cf55ccd4b790489f69460a0ae291a5611418e3c66c1557768b10a823d9fa61b0d54fbc36aa87837bb3e82da4665bc47962cbfadbda533e16b895e86b372e9a007cb75c76f4ecb7973d23404afc738d539dac2e27dc79be93cdff444d2f4debaf3d03cc4924493a79d40f4c83c2e84dc4f951a77b9110a8bbc3cd4961d0c7a716a55c9409527f5c4d81dd1a0d79d33c72c2ef08535129e5e2e681588b23dc01f1b02fb0c77f9cced1238574950498608e3263a9e5bd54f1d6edf8dc244730bc284b43342f8ba05d73ac52302b69fd70175bc61af979f33d5f04ecf4cdf21cb6a1da388581b6d4c1fd80d24e9463fc02cfe12938b4ef754dbb8e8ce7b15c2d7a7d18e74f3180fb64e75fc4051b6b12c2ebe15caff249245e4971bb59610a099fc8c01523f14a567e47396da21b91efeaf8946af50588c980f61dde097443b3c91f7fe7a33c7834300dd1a667a41fd9032577e35a3b2b9644a3e55e9ca9e0c39dabe11d4c4038bee90c062eac6796559b2820739a520e067262eb71869a7a4e876ecd2abcecaf4b24dc3eeb219b4bd7253e3164e11d838f5b2c2ff93d189aea77551eb39f6369f6e1fccdc82142a2048658a0524ede5f0a39817df4a1b5ed0bb0f3209d745a77efb94a8952d96000ac424de46cb3ae04bce477cb8db573f7e7bc59c099af9c874a3e01b338a4bcb37d5c37cb1d0fa2798c6f24dd9ddf0739d3f7faf7a91cc245db7e619da8559df9c9fd30ca42666011f49965d2886331d7b13d4e4fa5de7c562fde4d51fac641e78e31e31c0e7819d151e38b1301e6ee78c60c4343a4cfe2a1bb6c5cb0e583130011a1735a4651b7aa00b74f80efe535b27a09eb81b27232eb951449c8bca9e45d5759b7d9cffb7e5847686d63f182cd7b852531bc661cebdb7677be14e1b4c4107f5dd945740d42678ade1c00c8662a2c8b0baa650498128e66f0125979e88d4ef4ddc92c528d87dde73f034033a69481c272fcf210d82a7c15930d61a4cb05558b4be39a4c324a7bd517938f34c01942e7201121a7aa43a19baea3dc6994785f95f9b7fbd189a305a935a1de3b11b8f47ba4501856607305cd762c022a9c11a3c724c47e8de021684dca7c62c4e8e04b43247dbf217085578e4f95989a51369e3decb254fd5dced5d2bbe65afb297ca913a5fbae66a99a24a2cab56a5ae2a8fc056f410144ea59165415c4214c07272b7e55138d49c1e88f9404f7ab80f053bdc90e5cde530f7691ae3a7f747129263109992115c92ea18ed5fb0ebf0583d35e5b4219dfd3532d1168a6e172f0db052be57bbddb98d92bbaef88386ebb5fa990947044b3c02af43b180624e37fd97f466b80a8789c37757332e9f43a8fb6c8130431849dc6239210050c3d88c9bc0e47f421bfd3e94c14a3b7a7ad76f69335899e5335104cb7d5a8da788d083f80955062d74d3d17280e1456a33481dc7fbc0676ce19ebdd3f6b386bb7525474b32e3e23c824b77b6594e40279dbbf92b83ebc447f867d6040bb06826a4e03b10b3f81d229d6abcbc1c449c1b28421d93202af222a329b646c8cf7379859dda3caab5d0ac84fe0bc94ac701420b07fb1b5d01377498bfaa7b677657148f7be7d94dc865abc02091492b8669fa7a1c5ded08e9c896f12e7ce7afd3006d9c2be15f82b63a45644e7722886c2a263592260afdc23d318cb6f3306d16c564995bd27410acc50456b490842ec3bb7dcce5d8dcaccf1b6875aa91f6222bebca52978d2645bd2b8dafbf96d505a4442b564da77fa22c4d7a6ccb5a5ba46cad0b1361a2ada3236881342f403205677f0d681e5b437366982a4c738ab0f57860a8a51d98c6d9e7d58cd522e20f51496f47afcebdd36b139b221d848441d80e00aad488a821e2505e05eb6bfbc918c82bd0105c6ca3ea816735d7fc0057b876ae0262b356b2245af2438da9546bd1e01bb16ea405a3a788b40c60b160199ef588e11a179d827ec9e765de693926ed0fe4ce915b0a633e3686e58f684f31d39e97e245bc00cd335868f814b78421d459ef68f9229306aab741fbc4dcd46ca464a0a778c49f4b6849d0504e3bd9b01b9aa5af89813459848d9812ca4ae222eb1097fcefcb298f5fac3e8dec9f4b67b5cae1827cf146191e2053b8e5e69e22e0ae112f2a528fd12c76424bf920485952a3aaec1bd0bebcecfb05e701c5a388120bde89e6314afc9c1bbc694aa61033853b1921b63e2e464535f98079d76ebd8bfddce5bfb3c464f497fcd72edf91726d13ee154418050b63a76cd6301881f7ee23637a43d9c082bfa41486ab8029b4bc1518c41cd6cfba5a5c39f67cc0b715c07902ef64a8c0bca5c1ad4fada967db9832713f124825f5e7838b306584b98777fddb91a0e273cb2a1b497285bd5ec2e4a8e2d68234db59498e47a4c3cca2c82176a3bbaed114e0f1aad0b04b4e84a14435c7ff61e8e7cf838f3c8c62206bfc9716e722618294d77686bcb32fc0f8f980cb832c3d3a77802af871ebe678740a9e4e6bd21a89cbad5b03eedf42b8dc6f5537e4be62212c09e951b0094c0f6e913172361cc7227282e5d7edb0c12343c90eb3be351ac089b954efa8e635d26985c5ca6d223e167120a23b8ab3aaf8adf47317b498cd4e594814a671a571574850145ea32b294892082805c6ed92163b59faad9200cac8d78cd7019e6df85a90ec53f4e2207832514a6be4722c51c923034318dcbd832b28f48d28c3947014392a486e041ef3177ed6b1fb66a07c2936cc0aaeb3b5cb505fa89389ae95b0b9b993ee9d68a857c9802e5e61f8f000c9c44382f8b866cfecd40e564f88d560a29dc062c4829df851c94a8d42121a95251dc4f199c1e84eca3e66fd19ee916884b0202cbb1e5b4ce524c7fd3d2429c93b339cbd2d4f6eb8f4a4e0085f2b8eefa6167b4c321a728ff6de1d47559528e020fa9a0412670d8acaaeec2b5b4bbf8bca045a0f8badaba106df03f27b4c1f7240776a2934df125f6df64bf5401a4fac77a544fd30961d84319b6985f7f2536a95f700e4abefa815655307e0a6138ef5a0084e335539d5402df7b817293c80a490687364fc0693e4967254e8288a507eb4e7775eb133df7154a9e3b92308609d2479cea920d8fb0915036e58e37ebbd895880659037ef786128e90a120d80159e8da987d9ed8ec62043842b85e76398083fcbb3e745fbb9ef8d2cc637847a25b4a8d81ebb51a5b9ea462ab91a8e7fd09aba80de5dc9d95ba0999f2c9873fad57c281b05540cb7b9ca8247c1163e12505e0cdca2ca11a8630224b4ad3b4990fa535aab811bdee638bc29c6820fec410ce4ce83eb239808e59bc123e0d5414fdf61b1a50c8201eb56b431cff3f097da76379844db4f0309cec838a121f0ee529b32cd34f8b78994979d6ff55554917489de57c68fdeb0c9969c211865f54e71763063e3e6cc283ae3f2b3b62752349d42ef296b06616b126e4fda163a60b4f8f6c7c95ac1c4aae97caf3f9b0ccadf0c24eb39f41fcb6a2fada95c74d1c8372bd3d477b3e18f11131ca220f211a719e11b72b0dc078316ad446fe461090e96d06ffec48363fccec73b158e4cfad8c33062ce2f1929b5d549ae0131ad683af28fb8dbf9d06c3f8f6491d4491a8705f0409612ebcf9e20e940d8f5b31976fdafb00c95751278654c1b61badfaf8670fec78ba3d53e4195d839c0797e2c3e3b4bcd3cf7d6ef056c11b066839bbd7861e9583f63c5af1812d5d8172251d71d4dc3ed399e4bc20e7f48c4dbf65fecccf5dec5eae094170028250bfb4e8a56002b798769eb71d2b8560d118587655840d04c6535483b15cb99eca8a9e53b3e6451e669f4270e0e8e536b11f9fc836dd3e6977cdf4b7a768723db8bc8854b4da82cec62c0a5ebc45f5a71a90cea3fdb4abfa4bf7035a423dd6a871569d0decc91ac0f652d78fb8848e8bbe90531aead8ff23818845d62e9c92e4936b5153c70ffe07dbce5ff0348427795820010586a0e39930345158c3a80202f8bc563debcac2df736419d2b961916e94231eeac56a011addedf1f1ad1c4c94a161f4834793cc7ad8795b0c001cd8123f2858b7f479fc38dc8acb64831a0c97acc825abcc0662232ec645e8b0a966f64047de322cfdf6534af674d10ad0b835bfb1c898ddd60e4f51687b03660db84e9b0aaf9d3f3491e9cb0949b9dc10e717871d8fc359ce5101ba60896f70ae5ce697b56b9ab0d47d70a389ca0e5d5fae314f94ff4d68ca53d0639b04287c99a5dbb854dd5fc7a7a8421c8ce62f717970fff943287495fcdbd13d7d91a330d1c6edca5bd7c535aa81765ef868ac07c1cbdab7e32f0014341e95a979386a04152e9aa9f49e06def6a54a5f0ab23278eb2f4cc51e1dc115d262a4e486a2dc49a1bea345b00ac7c61b09c94d565079004ddff04a54e2eeb2f2f70c537d2e2f61da9bd06d2e532e7d79d09bc2397e1cee60554dd030a8f1ff245db9505f4a4392ec62ab7b75640884341c97c8241b8d793fbef09d10601ae822bd7b35f9a7ee35a0922bab551a4ebae2e4b66ffeec9f84ad6fc0e9ee94937730d4f075fb50243fe6bb3225a7d061ad0ad66717eea9886b58d3207db8c16ee1f969e80e55adb4a5a2196d44b99be42d66f68c8ed0cc38c520c20ceca81277d6daf7ca12d55c8066c5702d4db7f332a9b0ec55b28a0691647cfb66741466869b2aacd1d32d43af9bc077b3206b8d2fcef82ea6859354a3c727e9b8984ce949e8e3d74a393f751af17a961da7699fb91ebac9f558352601d9c1b0839e2df3a3faa6f4700d9a2fd4f63331e856c7fb03df1fa1f99fe9fb5293dd8bcbe9dd690e9e35311f8a95cf5194a5e538d61e56aba1662767e42980a0c2afd867c449bcb7597fd39bdbe3286f73585db4c726cfc081eaaec46b61668481d1c4a862d316e2be5ff9d6200b7d96ec278d1720895474123fa746744cafd77ed4d3437b46e122e9f81f6a4e96ef8c9d05c7dfbee306eb0987b9405d97152d41439c1c1eef1f520ac3f7bbb45ad5031fd7e9ecdafb8f4be1120924824bd6a040dc98cb171b77102e3831eecc0bd3ce319848b7f3ec0f110464d812cf69c9ccfceeb3198363074c34a7fb09cf3ab322826758f92d501f3597d0f7f5444e2f9afe6f1ea4803583d2a4849c7a7918cfc077a4d1f4ef5a873faedfa70557c5461c3173ceff9a73f7434c2d30d126f9ce5d43b1bcce7042eac24d9e5fcf812f4d330d17bf646e797905e314b3683e59a3f32930929259a7f1cf7d3180defb567c3ee5463f159ed4f50a36dab804bdf38e64957a2b9b87767c40d9f31f50bf4a2dba137a8eaa0a5de5f0b0e4df6fc9c2d5766e5bbd20013c076007b0fdbd25d0ca050267a20f71e2654e6e9cf3ca344c6076242c560eedd6865598a12ff77e9338931e321f5d696af1a6e1cb6e28ac7c91f48c841447f3d5c299ed91292a92e3f1d2596e501bca04cd5cd227b504ee3f9aadb11c0e14bd36f1940f07245f4aa2663e7416812d31a485f4390bde59f3a4018350baaccb62ebc75daa0bb00d7a7a73eb5a2cc401410c75e67a43502bdfea2fdcae5b62176bde748fbb089edcd2004747a47d5563e49fc7097a00ac08c4c8caa48f248d08c50033a316eb426a51c72d9ac09e7d04397eb87a9dc0e87a8c515896b35d411c12e21a0cda400191c698a024955c15044fbd38a8c6eb477c59930dd560da91487105b2fc47635e98ed2be0714e10e2253cf5b4996b184c0a8492d16eecb2bc992c11fea8e812f0fcbd35f2ae1acd8864fd47c0fef22dd25dc721d053bdd44933d1bfe6879014af28c8d00a08058c2ee6d8688cd135e98297c32200fc5b604e977f0b35c45260483f0d6113bda1c0d4bb74545ba73dfd156696f5005bdb07e1ec2c7e0f21668c5137379549e7d6ee191e6497e9ec9793629b5d978bc9be0853394a4d3a80fcc36937295951c64b154bb360f83d61756f04d3490786f0c633478fb200fd9bb314425e62fd666e26e6956b2168348a704a6fb6d826738d1e0c44ca16094c18df59762e26d3d185a3c14e413420e6f9fd0ed69bf7f0270202cce5b644813bb88ba007a676b9d6224831a5e802bdecd40d4bdad64ec0938d1becb50ca2189f7adaa5cb66bd44c97be93d6d4264d7a35f3b9c114d00375eba73c6b1aa4c5ee62d7f76e34d21e8d15b1c15676bbab494b2558153508f961952c7e80ce9cb2dc2d5ea98c5ebc042d31c9d3803bc7b771514ff7574453b400de41c7bbf86f36b6084e753d0a7bba7e6d56f139027c1011fe30800a51ae215334cf87705be05608dc30829168d6f6e82d0979b0ef0cda448a47a965018c2f185546b9a9d3cd69139ee6646aa49b7e8bc34efb51c5d455c9b644cb15ef68c8349e650510348aa537863eb632cdc3af2317dece1941bcf00012e5b0433d048320c99a0c7bcb0d959d740322d7ab3931899358f8e58e75c86589a10bb3ae52617dcba69bdd4a73205d0c0d5b23fa0cc2518cdadd97ea78b81387a8bbfb9379a23f8ccdc9a0bd69a5899b3f05278d3f6ada1d5f437238f4b686ca66ca8f1d5cb75da76703e247bd7114f09361926ee0bc17721d6ff0ba0d00efdd41459693e2296465c028158ec5be34abddccd0bff1aaa759a1ee47a692cb2876dfc41f1da8d6272223ac15122bf6b5a87168103a676fbd76e5409f9680f0999d3941ebe1c97fd31160fa611fef49f0591724f330b00d27b752d4a356030b2957a00f5a3bbe8aec20fd3bca5a68caceb5642ca9ae7f4dd17399b2db9002a57507c3a6391b30e74a636c0aa4ced30925116e9103d2b9ec76f44795931fda49084841710ac38a3880c220aacee02c66d1a59a4ca901ead4c6a1a5d707dc2f15ccccf1451213d4868418178b3b6a6acb3506ecad78b8abddc4ef1422cbd1f22a5bb1459cee15fefb3dd56d0630767ca424cbddb7c094d6291a3306e32a1f16063e1056e43239e10ad2add2d9dc9e03c137d13d0dc9508a5d625f45f6c2597ce684d1aa122516d570d724a20da0799f880cb508b77aa68eb35b5503acb29d9379646c49f6c211f7ad146994e9c81d8b0d42d10e37da1ce2fe3e86e73b4ecea5509ce18f5103fe450b6fd2cb21f57bb929a147827668cff2b4c5fb124ecb17365bd6b6476b11f43a0a5a713a9e8dc76eb496606842323479fa27e3cb1538bc99aeaafaddc64801780b8b885582983905895820b73b729f000e54874d0ea05cab35db08881b58988d7f28c97dd89f1dd7c3a8523dcdb975ed10b9be5c83a96c4a3d4d2250fb6f23626bf05a7d45dc58b46bb65643755725ca13fd9ebe6ca96795df5eadcf3d61dcb34077ddcec77587bb149965f8dd0cc105ff586a91271e7234da17209bf8d20c268103616d40f5b0294ada0247bf76147280228108301a795c1d6927aedf0f7c1ab01a69d7c426c4fd17518b92eb2296e6744cc7974c380e4932a11707255715f3157acf97dbd049330893ca57f340303702841a432bee9b278d0e3dd561c054c45877fd212b5674be0864228511dc11014d92796284bcfb1e56d92020fba4d520187b21491837606c473d18967e27c851b279d97e32274daae46d94a0555a5a6baa84eb4266976d2f1c6e3788157b757230b93102601e201ac24387ccbce7bb921b6adfee482ccf0bf9402c82907f6fdfc16f693836e71341d49d9c59c4ba894726208f6a8a46257b37f32c7e05f1bf4ff99a2f1f2aa3e5c2797e1d6480f4a6779935541b7c84b4df063b6a620fda04400a02cc07a4abbf8d8284151f6f1bfce9501f5b4c7eea56158f1f7450a8877f59296a492d12ca0d3953989e0cc72578a45dd5b6b5a07846e510057e7caa6f34a0c52e8c82edaf4301437ad586b8e6b2493acd3307701960929335f6cdc80b24c47bd4a356d50ad1c26aff8ad7f6425ebce664f5471eaa32f573d1d28d169c536714b11e2b03c4cadae7459ee516a8812d5f9d4302d60421b2345a775a23b8b7877a18fa1da3a9348a0faa73a96bb7cc18fbba2b0eca942d48790e492df0541566268e3835a148e3dbb6c0342f2f8f6aa98784d7dbc4d31c2dab45f4456395a0cacbe1ecc0f1d464cf4ef1a705d5e4dc2e459eb1a68831341bcbb3a3d4680f1740d7bc2929808860410ad5c309d6090be1fce30e7c00e0d8da0e950deac2880790fff6895f9607ecdc98fe633807892f6d3af36bff7470c1de9cca4cf3fe46b7d0978ed5a02c8e2a72ff562ce815899b06d4b9afc08ab5a54746aeb7554734f5088e511ed3cb4511ddc8f7435dd5e1eeecbaa8931b17550071accc6d917e852bc4e92b6a89415122ba129d4a3b4d0f2ba468eab8bb8ae3b5b2e3d8ad3a13cb3ac36457cbe338a79640fce6155a5b2a99719fdbd7ba5ccde49c1c961c4a805113e1c07eb73992d5ff87230009f3767f5f5ec81f93dcc20364f3d17a361f5f2b73a05b74bdea6391fd41eff596371e16a0313d8ae63596b87ba483f1f2f0801da58cb56830c44a379cff4d856d1c1deb430aa036a09b3f3dad33d6fb85950064d9cd5bb596303f7f331433ac48722ea4480ecde10c69aa4d15f65498f45dfd231f394be451195b25a834de82f359d929ff7232d3e1b11052b94ae6abdba0c065a52c8e44667877b5ba0fb39d26eda2967ce5712045241701cea8fc794c03e8633ad94ef4250988063661279644e771d12d9115ab27d2b891140a8b36a92ff746e76452197666216c5e4672758101fae93e5ab8c1cd96ee384c45954a5633e97b9dd40a4fc181d4ac4769fb39d65010a2104147b16188a58f3e7652a0eccfce62f60be829af5c4436d88fd97869d129d1c57a9fc87c139945806b57d852bfa0273d4911349d2d8ec941f0d1bdbb257adf5a14bb7116bdbe7c970d016ecfb14bf8960887e86b4bee62cb46ba1442fc6b5a269ed8003cac74707bfc91f28645ec267897bca4a436a18dae3b4b7b109de6365ada42ad6a9ad9f53ae44548a63bbae2a4955af3833b509356a0b872ce5d61d145dc689145cd0f8144ec367acb3ed57883f16f16941cff5da4fb05e5e8ac8e7c71b568139cedaf8a3d9f7e1f85e8467fa32fa4f7193457a4f9edb8936d425b3acc57a50fccd5d9e6db2b696ed54e7015297dc87ecbf1a27c2916cc2d47972174ba3c9a6f5919ae0f41d00aecfe77ab69ece05a6a8b9ec41f5e7ae33c0bed5d5423afb5849a067e8675e48f85f535c19168b5a015e3e1833185bf5f2eb1d40e890041d3d33979fac0a37e7b594902c95bb7c43d0ed28839379c8802ffeaf444b61701b89c5c7f4a9359697b933a79a4c5b234027de2e8df6303e89cb81b432960f4067fea2bf41d779f9a63e2e425de519bd33c5e6587b0be889b33443be2704ddcec96a19873cf5f447fdfbd02616426b5e00317df0c89c7b96267d602c7ef98c49b98488b19ffd704897af171f12d36006a7ed7bf6b873b874a6718ded3a5afe3cdac4776dc3f28f6f1062f3268d1bcdb89c53118d5eec1d7b941ff99a3958e24a66a8945ca6a1980571676321809eb2c2bc37aafca764e4f368a2a865e92d59400cc1d72048ada055569ed70658dd1959f788c6c423b61e754cde3518219565362d355f267214eb95bfdc99256c1a95d86006456badf19ad3ca6f6381769bd3d23b79afe6bbdcf27a2f505da1b11b60d37305bb1d4c95f1505d66d1bcd89f654d0588ebb72692ff54829d4102996f28416722a8e4ebde28eca8ec8ecff1cddb835427ef78e211123857c53aaead28d1ead3601118d2ba3522691a67dcccb8a42be309da81fd8c6a2c69942de849e1a821fa03b529fcb91fb5683fc28b64c65b4ecfd3aa51744356127ff5dedc58e4f8a0e0a8606687add8be476f0038cdad732bd6f617adf03c7c3374279821ffc860eb107ccb2e4d49ef1ab4f686c4794f0c20f1a349fecba319a717ac46f217f67f2b3446b5014dbda4a4e2b457bec410e35f9780d1d95e77a78fe75dafe7bd11d3aaa950a5b83f2cf8694df6df54616036828cdf2847db4ed0a6c6744b76b4a176b02b85c2099f0b0fd8073db334e69906c31c712d29ab588b1ba9bbe264c76eb7843b0d4bd2f0ee1853fb39caa764b2fe97de49cd7b9a5a6bddf4912696db1ad2dde9d9298f9338f8c870fb40479ec655b2f8905eb65ba393b6918abd51165a042f2a3e62f1a2ef313ad072d8cd87e528eaf945b7f11eb67a1a54fede40be38d63611511087ede8a16b4874ee2c484a9e08d5ad3a98fbdb06805776ebddf5e1909d6934284f69ed95f00bc26f1eeba981b71e6c30f2f572d3a78bcb8461416205a41705d33ce0f4112691c771c8891d412ba6f72cae91f614f9b4849a23b3a1ecdeaeaf0f1c34c4acd6eaf5962b0c8afc3bf1976589c6e9cdbe073979d93354df5701e9c417098cf1794546662e86a81fe472f2055b9303bccfb134d7d323f2e708413c432389a321ace9e4928caa1970c131e1a15a8bef121da9a98b5b379be26796eb608dc2a9cc35629320a40afc46a5857bde83d444b5cae1496d4cd7b516ed7312380ed6574a56e1e2b5021f7d023ba6cee7f2aa808e8f12e5328f7ce4f4eebf09a04e24dcc736bc65c7f506c6e619b1302530f02bba852d3c7d1f10f141140875fe795069befa18d65ce80f6de0a7a991a2a190b48cbcb902919f7f02cd012415d63a749f4b83cb61c9144a743ac6c4f8031e9877c3ed484f7bd5af8cb53b885b4a1a90e067a229809c72abcbbe87adc88389e7c3a9fb8f395a7f39b1f12d3df1849ed9014f5244e40b850652f532ac09fc9e17b1a4b1a6d62a16b52ee2953c03b5cf5ec70ccd8395cb638499725ee653dee6153467a82e7fb23e9aff52f0a57f2d24c3ca101c342e55c86a22e2cbe5b945c3d0cbf3f40740583d7aafba8453bad17c279f3c7a46ad5449ef3bb2ef7064d3f11ce3a231729407717870002dc704494238d18b3d143ef44d5a08bf851bbc58adba7b5dcfcb48e9c89a1a5c3799e0657aead3333adad2206165a0bd4f1fc0b5630e8b416c511bd03440f3fcab17b07c6aa78847b4d22a8738026c09c892a3be8062ee10bcebc9f4c88c913bc654e3d54a5686e5bb656faa6676460b793bc0aaae94a542c7e9eb8131c61b0dbdc9d938887398067a1293715e3796ce2ed4f22e56dba0ac579423a65f273867dbfe9fdf414d21b607d74a2a77c3e20db6f89e4ef14a577d5fc8ff93c2e1f0a204004e466b646c9135bebe43b6ee0739f52997248922220874cc40de5a7881e604b942e6a15df29897d8c101a80ed005025fb8604a8e8d53fbd18d6c6643278615c135b64cea6d4a6417a58b5684d3f0efe13b553bfd143eca1fd174617ad7e49970293846677427eb4ab89d100766097a375221e85e6867c119955a71c9451777ac6689988c3f32fb7774dc23e53eaa6957d5e4ef2069672bcdc61403b4fef0d3408d4e20fe3b082778d434359bc962fa58287c10d65d27d06aa4b82018f5e852a2199705ec08daeed9e900bf5d7a0adeb183337e7b14afc422f7a6816134dc5670199fffd31f452df240fba39946e46ddc0039801ea1745ceedfa68dc41340b24e5fe57d2cb07636fe809baf5fe0ef3fcb290b06352ad9fb082318c46c8af5038e09ccfa1df0e8007fe61e8824c494eae3bdec0f6fdd1e424a049c019af3865893c91b8020e676e4618ab928789dbf2413c971f2dca9d9ef26d4cd9e69e8be7ab4d08ab6ec1d06b2563ee78cc8bdc044914d1638cb7811c1edc719e7d0a4c9af42db91967b6f9af0966fac6d0cc4a4539b0315f772a0dcc535095d154b9cb7a5a20b4219ae26f39296d04d0ac3db9db322289e44ec4dbeafb7807698e4f072cf0088c94d7dbd33154b84eeea7ccfa3adb999e42768bf19b62a5555827b723632fd88594f47fe742acb2a48d3cd22b1eb3893b08d4b7e34d709cbbd31d06f8a57add3c8f7b46b8af9c9bb2b6865b69a866945bbe005ba0b008c3a5b7805e7e337110920f6042f9db0f738e157108d73a984a9f567b724c22095e1bf36d3ad9450b5e4e94f5570febf40ba7870acd1800be790d973a31e38f6601f885fe9d37b5b0571c397170c83b0daaa6d0d030e35220846341b47e653b03e7d8a14d7af0aaedc9c72791693f31311e749b55a40c3316631195ba9b3b4091484450c4a75ad8d67efefe8a057ae907a497bdb24621280dc1cb00592c9e76c0a9a5e401c403f2b4030925268f6d8febf182c3fe2ff1e00326675311aa5284f271532f825ee71a98a06200e4116c4c93221ad80d4a3ae8d26893d8331c59502cb53c33476746821b7221290ff230fe04182fa9069edf4b50d494071f81290cbe33a925aceaa33f41cafad1067a40af781e1fbc1debe405b0f0332c84de56440fc814fe5faf66a46dbe7fa1367a5cdc99546f1a49d423e11bfd501273bfcbf5ad8b9c574e77612d5be360f3e47fb0d1841b9c4c01a1298ebcd81083afcc5ba3515a12fbd3414061d0e957a9ac8a28a5b724340bb7b2d19a230e29913126f63f1055115797ed1ec9403a8547b1850eb48f65269b20a1284fd5d7436394da27bfb00fb3791eacdb20e3878ea9f8eb3b631a4fb636087a47a02f7fc9a336b99721fc351f19f3ae2cf9220980b8822de31ac5a584ed7bc89c4f2dfc365e7a145389b4c041e41e5726b96f377d5c2a717e622c183e99877119543b61b0a36a5193cd0d42d752a94f7c22f6b4c782b2ad17f1ca7e79a03bba4d54d0cdc8044a1693ab7b6036204fa88227ea20114733b4ca43e947b318456f8b85e1010723844bab2e08f3694b3c78f1b5b750ddff3530c9778d4b52877091f0c04671127fffc409c27a7422a07fbd97c37ed9c3c522a42308a7e80a812444cfe0dd8de0c85bc488c34f79bb2e0abae4bede4a05aa307f9f13d274092d09e9751fcb87f4a036ce53848607c37d477ac8ce5800914cd8aac814176ff8ad2cab74bd5ac28d2528b6291a5b77654327cf04b8ed000ae7d45b04d85517308e169ee2757a3d9b8c4290940d60bdfad8c22b2edf35fa1a9089f99fcb319445e45644dc907f34c9e1f656754c70efd4e056f47bb335b9803dfbb43e7f3ed2379b5119fabeda4fc58888778fd31cd3a17fc52b06b4c9a1f15bec5d28c0502f86bad2af7776eeb4254a81cb16e69ebd5b8073c5af68023610227ad5e6ba274bab293792aca59a023bb96db358a888ac6eab78649fbcebace58d5f9e98613becd50757fe826bee8212aae771a4f55c5156bf0be20214ee035d0aa5dce8ceb0e14031de79c662dd89d7b062a1b842a032e77868c439297874b6deb988fd30a5938abcd3bbac56034c1d7e812f8c18f4d36d245ca755bfffbeccafe4ad91d48d7318d308966fff5514f994e74542e93050be7f7e450b2cfe37d8de5e9280fd1b9adbb612f0bf9cd2aaf465391f4b5d6d35a72073ff7b944b4b8fc9b1dcc54d3442633af61b62165feeeb351d234f62eb8f23d032a6f319532f19e11cfbd8fe08ce3664cf6f7186e5db83941fcbd40f273f152954f8690b4a44bbba6ac1b312ef2a8d7f1659707a1f4163a29ba2ba0209944c65de5875321ea309aa8f233b8528b2a0c85fb0c9e9a8aac7382cf08bccc08ae2df78bafe65509df0393f6967a97fcb53bc90a7daffee6706b0d3d6186eaf4bd2e69fc683c3e3eaa6c9152361455983f98322af80fa1774466c14de8c9948b0475f2131a70fd7020df1da2f687ec8254c9deafdef7575e524192b31f890692995c1fba46c0cf2360e500a522362bae1cc25ea8f8d90f9e2becd58216306ccf130b33950598b4ab96ba052da05287854e69ae6f8679af7683fe9ea7f6385682fd301e2b85d415712481c4be95cfe8cf28eb53fc98489a566d83e822dbbcdc22f03457b78ea22d77eabba81802f57a3a454a855c3997cad96fbb073a5697fe57dc36165593d2c37643dfa8b7864104f04c98c61fdb2c3eee44b8684c786bb5c756082208375c76ed3e15d16dfc4286e19b5ea6988383c02cf33772387405aa5cadf98ba785334ff920e7e0cd98d4ad6115612d698db3dd262d57317cac420c7fe74f2e85b902466d4c45b2dc7a76348db0baa58f1487f34b25f3ef4dc6175fd51f67b0cd93675f98b083a2df7c6ec3e3d2f5ed114d053d670665bd787b26d245e46081dc689cc9596cd417829d3823a716ba0591b36372b360a292a0d65eee609ddc82bd51ec61f3d99d34e1bb070b27645502896085886de2a8311e7a2d93c1ecf8850a3802183e95c47835cd4e24e85f9ad018ef083701b2f3734962df7f153a42919ef78d26f0084306d1d043336ac6419467e2dd123109db3ea0dce71268d99293798173824d62114bac83d77e400bb19e03ce3d4f7b918af229ba8cb1dc3601a3204993bf5bd3d2d852d172f9f4ec75ac491387dc9c09f342feac6bd6a7424552fef98f9b23a90f68f30bce0a4b95be14cad48f9b1f85a0a1a4331edc7b15344287d923972454ea4a321825a3dbdf78b51577f96998a42423de400e5e3bf1e00c6b69722ea6cc9cd3f309dc063b1a85f9768086cbe3b7a038b803d03ac6f205067a8220702d74021f76829e0d2084c25e3d1da4909dab860c59d477dbe3b96052df8026c43481b20332824b3fc0d3ad9aa0253cdbfb821c729572e3e38c029ef4cc17d0e2a308848db3f2cd3480ef3acdb3d2e27ac8eb20387dedfc824118eff601a1ed64dd3c919a547db95fa962d35843a4404f86122faf93600bd7e0ee0405a0eb642469dbb953b5b8de71196e8bc353c030cf881b71774ba6a1996258fe9fd0a49b73a94ba236fec38a9e2e3333e4dd356cebbdcf45a41344bb57a26fc5f26c7f9f87fb7a4bf6cb02d2f1a75dcab8d4a177ff5c2d849be6995daa6a6bea0840977663ffd42157582de85e96caa47e44e568553ddc1f91d0965537219df4346310f6cbd0a7fdf8cac6cbfcedc48be9b76c2737926e9d12e0bd0753d9b67cc620d48a4ff741b23dcef814af03a39cc07aa82c0aa5737c78d19665619f3dbe8ab42def678a1e6348fd5b9bbf96acc151a4dbf04f0c3b8a4af3802705c3048ce5ae9de7e4460d7bdb5d2215ff9a86e1448ea9b02e8c3c6497242f90f3993d5ac92fc8efb39559ddb17d143d59a1a6f48fc1680db95ad2d0d1ca54600fb66ecc3f82fd66c9ae2ecf58341c65d3e3f20ec1c2698a7aba999b01d38b6987aa79e953937a0a24674990a30c7d346a13d946ae3bbb491ecba6b85cfc922aa603b8e62818621beb5cce9087ee0f9dfdf8bc0c8bfc3540119a1d1e6483f43b701ebe025c8d24e3b6608ce6150cdbc1689dc26745c7684238b43b04b11d2f9e62686abbf34023b9dcaddf29b7483359dea85bd16b321c70c803bce7fb71f07a1f914016f8b52b49960cfb48de3e6fe71ea749f537d715d9aeb63298978e84455fc91258718b89500ca5ee65622c6b58e7c303ff60319329bbc82f41dc343a9328d94b49c244f8d215ae0750b7b7cfea3f1fb5e9f168a12dc13a53b43c2434c2ee81781b49c45acf33a1efdaedbed81cbdbfd58f2cd26caeeea96b3a3e6a902cc815f3d7add7dbdcced1e549d1a8fb7f8dfdded08a17d81e009ae129ba27acaf2dd8d4d608d4a520f2095c0c727cbf7e0d57c74e265f5d63ecc15471c42cfc0e8bc1aaa0c1fb836ed489427a469ef0cfede41ac31c65485fbf05fed910befd1137e3d222a362751df5df86c6b2aeda1c931deb67f029a47eeb2c52d0b17db8c4b4da63a559f723b16ef54ae8101e2fc1ce8daa2ee32e5d9869812f82e4e51897d210805d13c4c054757fd75fa3f0fa5824d9e48976beb1acbc1c624c794ef587309ab1f1df434ba48f30af297350ba7f2ef3cab8841d84442b258bb252c5bdd674666632232b92da1dcb54330fd87f280fd43eac186549173d8ac788088fb19f5e5d75c8d42b59d988a071da074e8fc9482eb32661e5a9d9cac10d55f644f2a9a1c5d4a90f489109bbbe46caf50f49cbf95d8225ea2c9f6aa7aa4b9b721701173b9bc61e93d51d578782e146d046f582a51e1688d054a48028c845eebf49b7ebc0ae531384ce6d19adcf8b20321533526915b9ab6a6704fee22ec73dd50d2769da1a004bc67dcf9df11166fc842e133f664303d784f863fe89297c39a574b01b58e421c7a2d9d77824730c3e0c455bcc3a7aa428575bfe6c640747407d086e1b5673322fd7fc6fae2685d98c86cf66a2a337b06e5d2526602a2edd42faaaeb724685034898c39b9f70cf7f40beedc1471a1b7d643f435eb0e0e6de6e8f494160a9ca73ec5210305a8c90eb6a5e882b99fe5e8204ddd06929076e7eb2267f7d7be753bf09da0cd363b88c4e281c820a6a2db6a9fbe8984484be380581fdae76015b822a3998144d10214e7875d5fb6916eb4bd62e932fe9f16fc2c480f132caf5904c501a30a2f4d903c7d3d259e716487957d946966887dac6d2c7527ddfd3691135dd5299dd6d9e96d7a364a48c810e4f389b9f145511080c3ff876947f16224ef9e833916ce9bf055fae86b2b33e23ccb805a71b703a4a3f220d3645fac556ff376d1d9b6832d5d1020903a3176ef89009ce52f03e04aa2871dac959dd22df6ba81d90dce65357434b5d208c218f87d185993b8826651c040b35b7f4c4669ca210c66b924b82e8f5702e6bcdb30ce4f8ad4746c867ce6884f23c9f715e093809eee5920d2f4b795127dd3101cc4f399021588721888242b613760a1ab16ed804938fb947a5c58d262a55c7afa3726e2a2d97815d8d87de38f0d74c256cb37ca74dcb1278b5cd056f7198423189f4ccffa6c6844f609b61a1a6346bbdaa9e5d2e81136d256abac98d1d4b68a51074a85e518d5ecb3f8ccd4c798c1db3103ee7d096d294a8222fc7c8a39bb1a9fb918cdcec5b4fd1168c6f11cac78099eca6f44d261974c920778bdb60ed6cc0a7a9c2a038599cc7f2eb861c96477b8cc2a20903c017310714cc266b6fee254653ce643172076a8701acb71b5130b7a172198da2fa71ca09d3081c7aad3796494b30480f62813af23ce833890872a196fb49345701fd0f8f315733966ca21fae571a9eb948384805e3583bd46a0ea0dd64af90bd423c1d6879a2b8745081de8cbc72d88e00b81c3986a58d976a7bd643645c14c41dbafbfb75c6666e6b0d063d3fb6aaa63073f1abccaf2f154c9f7a92ab475175c57efe6da7284adf7e99aa099aeac87bbfd2739c5f55b40c8961ea8317700ca50d9107971a8a1ad93fe3499b09a375235a88325a5b5f97d9e81c508227c97eec829efc13879af80a9db167b6958502c327ad911142509774ad325c223521ff196d0802b30366a9ce7747a015001048f823c134a5eea0c77f12556c9ece2c79e2dca5639cd5d9580b357f0ebc67ba511dbca74c1f8d74f982937773864ae64c0a4323f8649f6c7560dd524c130d63206db33ba90935cb5b5cbfa76171b50e886ee3e9c2bd69c2eed201fa5be78ad68d11526e7116dbe24e23c77f49b4826c44d32923e7ba5aaeaa286803da05f9099944d7e31b324a66c07967808764362653a226adb92b23049cd9a0a3d3be63d352cf51b2f7813981b15cdc000ecefd07fcf18bed6798b69b2dea4f01a8dcad5f6e4373e50d5e40ced29611d66a2757eab164ee405622a428dbb139337e425ad021eee8e38b2b2b8d94673fcc676cc5612a8c96e86a17b8cd7f91b1a95b3e0ede02764bdc58a0fc22eeac2e2438d5ef033009ff711d08a052d1d6ec6ae93f6f6b1c3601a13db053479dea483a23bca4351499aa546fb6735443d047601e5e127f41b6d71bc8601847774fd6c998f1a9f223e715320e88ff00bec8d8b0ee2869537edb7f2eaec489d733798f3181cdb5157e0d189e460e6ef50c0be33203d5e88a4cf45ff005b74283e372b358068cc9f6f11307e940c9d8086b00c17e79fe48e478d12f965609d6c1929814bbc6532dad18980795e461addb225e49232a4db40c15566485492a736143bca1f8617093990aacad9eda9533c9e12e6b736d546a489302a4f06230af88c1f8af5e80dc80fad890098baff5d8eecb225190a4a449e1770da78fa3e1abb308f5351be32fc759fdaae86a4a371c3e38f5cd46b99ed303a964682264cb253cf7dba5f2e121bc5f0159f0ba2e08f734363e7e80302cfad7daeb1cd50ae9ea2b1b221fd3d5f00219399b1f859961997b380a0d4ac20e24569fa43c401076e0f8dfbdd8b39f70af78d7171bb307455256379b8ffbe4120e054e9246fee59be0add363705d6e974895467bc1df4a68858352440efcddd2895ef9b37dc97e72587679a4022332e83d3ddc49f5b6c9762a5197312dbd0825fd871edffcf17af1f0d093c72caca2786ea12354ab388bdf17a5dc101dfe4b440bc0551892203696a6c460e12987adc41954a08e8f98f867fa8f2fcaf6a268fc1f08671295afabd0cd5fb10fc76b573acd15d20406adefb4d7fc56a26c0c9155ba2153d322de35b8295b012b1a130bdb01e804289e8d058ccd7565e67f4b9175416b4b5e4640b771aa3b327565072266fbb9f2ce767c6f12cfec9daf5e4e9bb7d800ac587ba5b38be7939a7a7d8bf304d8a157aa5659d006c576e96f470e181e0e171f7641c552726f520eacb31b6dbec2eadae92a6eb0764de4758beb6c90ff3d91528531331930d62bdd7ed9562cab10ee50db66371ac7ba711c6ae04bc6c3c2eddb8a949d0fac275bb059dc64f351313fb598a7e416ae6d6ebaf1ad73c36007be49f703786ce0ad3bee5c0c88ac9c52194e2bab031058c3204ff064adb629a3225f036dbcde36914871f9b77f8a113824385de61e00759396d0d401540fd24159eaea6eefa079110303de46e5f4644c259998986f972de39faa22b9dc6871135b269fdf3205e444ebee345f7bd0688b5b019459a5721c7db7ad1fe26890336c33fef6cd1cb36e7f7581fca6d52dca3bf46cd0bfc7588aad34b641bed42c345139299d37a00da3cb658d2712cd4ce4c8d98cb21049ab8f132f67d812db5e7fe4a7623c84e042bd71ffb1fc8a752649e78dc3ed21bfb8ebb54a8591084ee041d016645338a1a17249d53131c35a766f92d9d149bb2e942453a1227b62243525a3353033f594bb547dfe6cab480d9f4821d1efe8598bf7c1846018948694182518e8509c2fb8199b4bde786ae6b5686d6538b228cf0c79761658cde61b86bca4b9da8e5abcd551cb76065d618112cd5a2d0cd76627afb51c6e802cbf5795ed587dd60cb9034ecb8b966c49870353328d84e4505513ba60a7957bb9c2d7e04f4cabea1ba908e5802c57e8f1bfaa2da2cd81ae85bfa2dca6459431d5509e44e92ee4c60c2e660762366a06817cde278e1a11e34ffbf8d4faed4453a7b2778dc85e00d37f56318ffaaab8fd27ee154506568788869affe075a1390331d4ce8b06dc8cb2973322bd3aef9545429c415f3fe18281bb48f5524a5aa880aab369b0abbdbf38dfdaf3b6082b3920efe7265fd67678f687a92cb4b9440f46624793c5106e8cf883ef6be6e9158649d2df98cb21fd9aee6362c2f94cbbf4259b7b9d63088cb8712857b3af90682ba862f05a49414ac45a407e8afe24059574fca449361a6b27bf437077b8f64d79da41c3f14aa20c758b569d76fcc5ef966851dbcfc390599e50f3df5faaa96cbf091ae45215f94481f9a4eae710dc683d57dc12cad15f42f4d19c374c938679caf1575037af3993e7d9d5ccfdfe337a37c4cfca247297b3711614f8a101c1fb0a3ad56c522a9629a337e2ecfeb52875294d22805235701fc770aeaa9b3ee2464f86397300ebf32de93b2c2e91ed44ecd73ce7a9aac470922ba476692fbd98056c8c5dbb5c1d1c36d1d6c534ee77250876a9bdb40b03482a1bae65a6f416d0c31e7ac6e825f175542f02949dc053e2a201d9be9ef8412ded47e2ca592ca0eed3f75fcd616e9df0edd20e8f2649190819a0f9886d802560ef4f4f2ab52b33885770886b3b3e7a577745d89a9f786ca924b38545a24e087f6710756240e66e60f96a26441a09c5a6b458fac446f9f50b5e6e0351540cc7291ca6da63131394844cbfcf0057fd5404b341758af75532aa34597e184d632816dee9004807503607714c62b85128006d1af9721608f238051e513633f1369cc9c0fcd9e94f45c91635d0f7bcd651d6e21abcba67e8d438eca75d4420eaf148f66ff7dc10ea4d40f46e0ed0782578b7b3acc95329143602208b2d9614f73a84cbf4d2c0867b6afd4274b27bbef7cf84406a4d046eb1e4c7fd3146b985f6ff0733eb50451b56289df4c1cee795674fd6ee8d77d1e8574527968ab505bb6d4d04d937d8eb19608fcc41534d5ee1583d325951b1327b33904ca2fae00508a705bc77ff30d646a0daa32038144b23353e634dd222aeec1ed30d791eb32a993be3775978bd471135e616b3e1636804ea9862ff70a5033ac0d98f87778930f4e8ba14df808b2556764c8c3543403aeb2f5ea96985fde1161d2255df772e028b8ef7fcd5f4d24afbe026d01bd8e9d41d4a1245c5df6c926500da888c7e36f8b484316c09e590ad3c119e8ec926ffbca21f61ac177222f7f5ce81849cabf1e9004261efe1a1ccf1a10337cdfa690077949d8cb49ff3446f06a752a68b2eed1a2a8eaab7d600fad9f871143222581bf949c452e4830a52973f15bfca18569b7b03bef7193041ac1e248b98cd11cd54ab33ea87f8e82477ff107492a6a760dc492266040825f2ff990e4a0f0721d49d642eb261ab9f9eeb16086c56ffe15b83a87d589793e34d070c18013cf9bb9c548c78334c55709765a6e0656a9ef34aade4f26327e2a65ae71aa6df3da48264e0ea38408d889f17700d81acb9405f40040ab433a90c2f2a2ccb071f2adae0d4a5af59c069d465d83ab2a2ef0e1433fe82b85cfd1513e936cb14ad8975a6b4e72d6ac4b15af4202a307fa01bf407015602299a9d49a4543bd3c51c29327a8587b3c6f4f3767591e6f41db3de10ec5413699ec54cb86748fd538f8050fae64ddb03ed6b4bc3eb602d294cb6671e85408da1302d6e6cb11383c09c3b05649cf6b0e29db3835a19f214d0d4ffe5e73649bc1f775e0023d51fc04e9ff140b75bdbb08af33e1b820ae2bfe9556d8588a7ae03277ba5eb75452db665ac3d699a065aaf01dce42d35c57463ef5ccfe2a711e9742ea6fe5bd33b30851759c132753bc0b8eb0a72f14be19f5ce4c91303726f7769f6aa47a422cc7c3a7c99dc0f90ccc81d2f3e12c7371a05f4505409a283a4fe2a190975a0ca635d26f0f33962b13e06848e1f77c9f00faf55a83b699af2be8f6c2b975a0601ad0277ce80a57224cd53e3b21765f7dd1f51c0c9f47ebaa420b40ff46c03829cf861e8819b36c940af02aaacef53e7a298d21b9800a1badbdb127d7004afbf793e5741d4e67038729558dcc8429d051cecf2b026c167e65ca88b2de25c2ab8523ed677be5045a812bfe7c2e6fc7e8bee6be7e9fe4abc800f44c36fb60aa5d8ce30dbcec7f174e876ea682f523a2c38f28b3edf46b630ab9582c4f90e648e84bae5a918d96597208cca78ac49bbad29662f0bdeb9cbe97422eb463cd684a25738b3da8f4e6064545172b1db50c47db32c47139baf1e31632e9d75192468115c2777b054ac648e3f994e149697a7fc961e0a4bb74466a5453daad89f16eb1b55adddbfa9c7719191e527cc0b7e227fed564169eedbe6fee9300a0de21c70b1dbf23f192801863bad9bc14e6fa578623078cfb8de3107e368a5c0dbbd7ce02b046dc63117e3f84a0f4dcab599ca47b80d98e7499105479d81aaf8b62ef1907161592ab888b8ee00bbddf83d8e2869ddc2f833a37caec18ba902075043d620d83bc16183bab708982f640e7f514d3e3feb26325c9dee9a241d1e2f36c70608a98b9304cc2e1135bc905148021c7aabd8a9395c0b3b3ed93776dce8a5e20cb2d73579630d098dbb8508f04f0cc3c75c0f2e81a10b504b3b3c67a0d1dd3a90ff9af4f79b3f47d6ed7200a5420afc46e614a30830845be1e744da3deb213b2436ef12a412d48ed948e85db85c0c046f45bcfb5aee5496598134fad0cbfabe3caf940aa1d5c792c4a5c50bd112d45f1662dada5927beb55630b78acc59b30a993cb89f5582b5b539dd878303554bf94e414900e65f9d99a40f52ae36055f1d8a80c3df90d57bdbfd4aa0c34883bec27da226fe944a61661d145641f498fdcc36d28861613a31178e188238fc0cfe92c849b6cd62fc4ae3b60baddcceabe889d439ec3b4ac38887e4a2006f77be207ff27b44b9d7f78962db8e44ea9cc6e6589273462c87908476a3c76e3a5833c7360fe90a919d60dd0ee8e07875a526dd47b75647098bd51acff45dd14f2bbb705a8a129f32f492e29002eb431161a1643cbc700a36c1a059e94a6b013f2692626d53c40271d2f4a462ff9a6ebf90fb9d324a80b14743a447bc42480ebdd2247936ae705e574075e72f695562a26dde09f3fc2b82086f8552aaaa3772fc2d67f8f91faa78c16ce479c271832dcee7fd6691fea13a328ff1904942492e1d462360fb35eb06cc4338e006ced3b8863adf46befa3dbcc0376110c2bf07872742ae6c4e9880b38e2b8540ae07e7b86fd970ef451b437c6a73ac8650ca9809e18cb1b3b1f48bc5c4bae89e76b1cd3fbee54103e0943878d3381119767e975871749b05f3725658d089772feef8d7f47c29805e1a917096cd53242a5d5b49f12fff954c8c65313d966b7807719b7001feb8993191d949e4e0d489762f87822e67d8844a4a671c9206c8204d48cfa7eb228693582df3e48ce30606e235f4c2654cfde227ed4592094ab548d871544b83fee215dea78bc66962bc768e037fd29a095fef622377cbfbf96b560eefc9fdefe62834597a59d7076de7a9857f4106f9ae449a5004fce18d8396ebf292672f4a4a9a15d865e220fa15beab2c4a31b761abaa20b81b08fcd6e19c58a79a7c7504e28fd8f70c0c02b76cb83453159aee61b29a713651746a993fd5ecc1591c2614fe2f555c386be424d491f924f1ba3ecf29b137b26703e9121e0c8ba83443c01f812be3263ea86767f06f1bc3af271ee864c60fdd491c945a36bb216101e58f6316033748436469ffffdba711f3d81c7ff154a4a371cb15fe577218fe4ed997168fc11102c39953b1e952b470868fc5e602fbf29a71a0cc019166001e37d431c938ea630a4476c322a34dfbfa8668aa49c67f11672273b88723cf69cbe20299bf6de187570fe075859dee3cdc1685e7f12a6992661eea47337825ae8bdeddda9092dd52f37277e732476dd36bcea5df8274d877f7e4a79bd86d6c15fd6b16f72669aead6f74241319d34f7096957f09a1a37bd214601ff9dc69b81543a29cb4723f9237a5c5fc8f93ff5b9bb473b6a3a1fcc4d026b18d79f1ac764a35e144a0a290461b556073d20502302a29af80b614246f7040091a653521408b98c604d99625878919ff81e056a1d916cdcf4e804f40050e6e5b6163f0474880fb33ea2d8c53fa7f25a6d431c81df92ea73a327d730534d5662bc912fdbdb53120337f44d011fbab07c311169832d2f699c46d340c2f81c0a9707ce7e0a89c63265d0845e6e90af67292c182cbd42399e086a162aeee463f687156518a1e36d67361f53892ec714fcef45b952cde112a90c99f0a90814f2e42bbff2d883370ac41b4562b21f631b8609ec9a78139e509cb6aa8cc10b2484da4e92384955158945edeb561b7cc5cfad6c65a5c670830eb8ee7f7e9d65666bd9ebb885feb6ba0767050ec3d85a420c161df1cd661c18a5f5942edbab1286dbc4ec79c95c668ed7b346c0e70f9d5229fb01647112b156d971ede1aa3cbb015409de8506cd76672477e6e77da1e848142ca0ad6578ce4a1854acc7d02fb328c99f0bdbd0d0285fd3950f14b0a67428113d769c17f1e8a848eb6abd32ec5016f35a5765890e57e9b54d1712921b2fd8fa84809b5a6c925f754fef28f8d020ef628d438081772fec23fd9c8d9464a2f1a5d2e79ecf7cb465f01aca2ac2726457aa5682d5c143820c5323156d996ffd33a0293710b47dbfa41131cb838374203774c88d42fb14c0f5161d6fca6247aafe0e51e6774792c97dd61dfa8cf3f38f45a5a550bdd35bec5497c2b84e24c001e7064ed952d6447fc5ff96dd8a3e3b8434f08025d3e9a75eaf49d60720b4826f3ef573ad72677b8ac08d4dea1348021cc525d47d4fd41dce13415a6ef167b96f4fc31ea6bf2c6f55852394cf47fc410c1fed61f6e55290d706e5f3c03dee543914e4cc021192b888b8cf47872930304f135bbc6e7e84c18e4ac3f31aa722476af8c754d71b4e002327cb776fb45962ce284af5f3ef37639ea54e4e629dae7df44594cc24d657aa5d3eb6d4f574afdc8a1f02c82bbcfc18dc3fe0084d604b24bd7eb9e264e2ab52ac3b4a7e4fdeaf5429914eaed8171d2e82da8c44bb6b472b53a112eab7c8c89109e2fc9cc9adb88f4011f0631da573e29f9dcf9ccbaa15f34608dda1686ebb1dec4ee6b4eaa1c3fa7f206f7e0aa2afca322b054e4b6b82b3ee8730263662856572ecd98a2e99f6dc5886b941bb8b16d318c3ee8870e7da49b230e0873eac4ec3206bc048e9e8197fef6e6e47f7f95a7b7464a3d632b7949a45cea5da513baad14ba8f7b8ac91c7f802313c83f9489b873fa6f31d2413f30a39f6a1c3f419726859337153a1773346b9f039075c45c8119c31536d09194ee051ab06b0d0c05be39b45d85b19e44f8ed70aa5a96feaade8ca7cc8795df787be12511991bbb88a2f9debbc8504f19e172aafc060109b7e20ae03c5e451721936df75534b8fab48bc1c2d442a786de799651a8bb5f35aeb0f4f5c010c7d8eff0868bad80bf32ae820affdfcca25c565365306ad96210ea3bb750c91d1848761a54ac484122272d7d08101093c65dd07439c9cc6c0c45aa23ea9d53b5009e96b4ab854bca20d73c48281a1933705c9caee6f7fbec25930cafd4ebed8d5decaf3b93166635c262f6bc7d36c700f7e31e3e64721a1f80ca4ee56157bf171dc7b66603c8d4d00912b35208ac53ac281a18a2decf8e6a5cde7b3c59688be0ecd6db5f4cd2df6336f1b38e62d38d021f97a6dc1a5508c04d4659fd496f46ea26d8d6406b27b9c4e22a764bc7c9d92f8fb10ae63f87137827fd5b1255c0110b54abfdd4b1d9572afcf007ee95759cc1424739c29919066900cf6f1f49657d6175aee9fffe3a6ab51f2157612fcabb2a84a0e113b2c40c12bd5c41791680ebc96e12017a0de513ccf7ae98e840ffeaf8224cc9caa6bfffd4f54c86f8787a3cf4242df04f0e9fea69c05f6c737a835a75a83f0b39dfcc8305cb59328078c7c9c40e3aa7241c2a00c3b1e8a31ae8f6cbe97c7d83a269ae605c5faa1385ec2e023818edf8f553def7c7c07a782360765ebdef3d19dc051653b3c0acd10a00eb0bc62a72a08fc0fcb5f3dd8f6a06b3f763dbca62ea8f731e9445988624858f36939e4daca84c9ac2309636eea4bfb59477bf2dc31ed3a0f7eac12fed22899df1adee9e57db4e4d37ca0c5001bead5e5f1836970d9d2440c3e262466cf3b52a74029cb0640a85c3e937686190ff68eeff2678cfe9750eec4783a1f1ef09067568539ecbd25dca01e0fb8b1181d78419756f14bd9f401d4a653c5a6e5134085d32577d79a37ed04ce374bc767f27fe890b400f97fd4778e3eabdc4d239d4c69f9060900263933baf96fdf79f19a141818c7ca1f0fc45bea97fd3ae3eea112d1a65f5f770445a71bdbe774757b21c0a80ef0229033ef8da152cfb08d5be24e40aa0175fe384dd523163af755824fa65094d2f6764bffb004d5465d2b135287b9087bda9da0dfae1d3eefd94ae8ad58c6685792776a5ee8426cb8c075e9bf39a3ed89fae7a7d926c83c5867b61b0def874be21c1c6adef2ae7534005a0880ab8720538d9361f0d482dbb43e2d7a26df51954d6aa8c5afcbfdba58c74ea1d757929d562fe9e1f0f33d9e79a159331fc92a190e480ee4a3a0f5e81edfc2b5bf455b42f72616ef420b5c4024c48c058f11d616227b627d78e81bd7ef1dc5be495ff2d91233753474c8be8c4ac7e8f8a274cdbef4c01841a520d71b1abfe34c1a415042cf4a09090bc735d1f68d7fd9eacbdca023082ae1491a9f5aaff894af29cfc49af114c5fbbcb54e11dd33713709c7cc363912a953ccd20a017d3a727fef3df268301ee8c80252f962f7af4eecd67ce9d0d9a6b653a6d5251e8bbe266840036407e3e360779018a8a41dfb5bb08b2e2ba29e1e5396db5443eaecbc2eb4fd0e842becebd8367a7f22b5f2a12c6c1a75f68e020dcdbfda742c5b80527ee78d00924f354beff8284ae5386e3c2c4744223548f023bcce271fbb6f11db7d6b1e91bd68a4d7a2005594fc9a1161f9b2a84e4b61e9c7ed8c7124ec00502c6caa604e2f19d5bfb5504f970b586c3788ce4f06df82c11479b75cae25c7c487439589550d7f9ceb2353b080a7d64aa4568a271317be75c101ff769dda47d27cd3235dc2cc750ea2a297bcdf5dda7eff5ee3ba14f28356d80697e6f730e23c917d752b0a66f4d7a09282fbe468600b5a014d3065b841f6b571df25a3499c1e45c93793565da38287832a2ff78d3c9cdbf7b801162d0da036393792a2aab23b9b2f2042b312d34eb0e6a4b78b4714cc2e357cec7190175c931f3636c7c7d2f1585fea6b090555baf7313c3377f16150e487e7442d3dc09b39d5c2dce0e52d9df42ce3ee336df7b4ee97e9e4352e443182f79fafdfe4efe2de0fed770b908d2bd5ea2cce541ed6c2128f01e371239ee4809af4b50ba9879bca55d085e16acd36a522f9a3adad079c2e0989b7b904f184ece2ad64d265a95e05eff1f50ab796a465aa6b6869f1aef0b6ac2a712aa5fe3f65de350c4ede2a4e2aa97df320fb2ffe48d418306ef77bfce60d468a4c0e4078a1641c96c3ace9225f3c7dad771a62a9564904953386b859ae7aeb52d05c56124f822008a2c5b65a6ceb3df5464e3de1ef14579ca233e80b3bc7dd4a982c85fa20b472821c584d6747f3327da62f2abc033c24937f7bcc6425688d4ff44687dd5287bb48f00cef6a0210c61a4b2410c5905d4422f6cc4142ec92b79636db502a6ff9ab5901805d5332a48484f99597687b8379584ff4ec8b7c82fdbed1bc5de4f28ac565882af3155fab1fe78e56b95aa1b4b202d289ce70de09de2035112a61a95e95c6d2c7c9129db73d516b6c32a0cd0c4efc80250675d8250a7d639683eb581b0d896e6ad1431052f006cb421e75323e98a4c5b379676b8880fb9874d58124dfc464edd08f0a9dc807b9035cb1b6220a43d542ba6e70c2212025cd44193d9236b35fb775c1e1baa392340ff395e16cca76a96eb6019acb078ac43fc00330cf99a08cfc718577a30690d0540c448df4deb3c9f6788dc4ca5a707880d331215009b7e431ffaa7e0ce1f0fabc218fcd86b542235ceafdb3114321be6fe6d3c36af5694ca2c36948a325b4e9b562e69afea07f041981eda7002353051db661f65ec0d0d9f61e125e2b99b51e261e96a7ba13d81c3f06853c5db380618ec80725bc311f77b8a6299de10a03779535d32406c60b7b15baafa77eb66639af117f0e22fc2594e35e07f2be7fc289b7c05eba1ff6a49c5864d2328f378afa1b80e480b585c70c412833d968fbd30adf971b57b5e834f970dfc9b3cb8e53907c176bf7180d20bf809136d7e158b72fe5d577d1128e888808d3ae23483e914cdcc9e6ad62cb94ffb38fa403c56d41ae8fce8bc9870f8fd908b4bc629676eb3ee20a60fc54e8841cfc921a3951a89881a93d8c40a05ed7437b9d9f384e7703797f0dca5beb8eea196d5fb29d30a2d04f8348b632fae1e2e8709d5c053693064633bdeaddc9aac3bf26ee821271ee0df4f91484a6f9f2c4d8f6bf2d65d47e0ffbd64ee16cafc7ea56afa54c252fa1a95d19f0e2761acf64b0e340b04b76bc919ca2b38edfd2feb7106b470d644831413c2fd843c856cb443b03928d202a23acb065cefb0c009d35b177a5664ef892a27800f462bd72b6d8618b4a69e963c2573a5122b4874bebe68c1563b52daee60be2bd401795be4a879cadddeef7a9552f2e23c0784a423bc1f6a368b21e93ddf685a3f7d2c597ac1c2da1ac5c3d25528af8f26e5c0661a310cf884d170934ece71724fc9c9fcb315810ee01723142e79384c5cd04b2661930c7c1105fcb2c20deb31fda99386b974fd6eee081553f9b53fb5c2e2fbc7145a72d3ccff72cc41528eaad6b372892de11a6770d64cb8af571d1dbb379e709f599adafda68cbd82c8b0e155c0aa9fc293f5ac44d8836349fbb2d458370195fafe245ba47c57ab1502200ab9f962c680581b03d3e4162d70ee646b37e0eb692c09a0cf44adac68f3bf87a1996479e0f60adebd74049561c38fb083c4478c9182522f80bc56a068455a85d89703a4717e5f6034bb123b9cecc4506c03c0251c8344ff111e1c3191ac0763dc2c9170683ce4128bbb5941538b90c4981545f9ed0e4e2235ad246b7baa99e34b60b697a05ce39cf4d51bf11bbbb1c1a62299d0786d87db60620175fa6ee332f5607b99d70b1f8bd34c7b7c4fa6eb246c1c17d33640c755d3d5a5e10bc4cdd6c8247b62ce4274e5574cf1a429c259faa85abf7d6da4927b552a3f2bd39e63857b4069d3f5a0629144977625b14d074f92adb43df30cf8f355732511c984a2d8134bb75431f3bc5889749c14bde885c1346ad9585623a9ecccfc948a87f837d0a685c93b156adfc1c4548d5fae4b115343560650343935945b3217bb858c4d0dde6dfa65572fc00240f9ff530b7f28151d4c3761da5c790a26d0892981a1ffed2900198031f8fd41825114c26e3dda6306ac364787af0bb8cfe0d82b2d01436c4282743ff2509c02e67dd79b8c84c3d2bfba89131179fa04574d5952440e399ae4f1ad4ca3ad20ad4b73e3c695264bfc29c8ca7d1e64343d2bd8164c26f24abde940ffd24caafe9f6c2caaf8d5bb13d5162348fbe195c3485975985b3d7260df344b2f78c301c1a6848e8a935e31a3dbc54745588a034c11f90655509ddec7b634a3f74026462033baa5582dee21dc69e4c46e96470693dc6a3c94241cca245297f10479da252c2c9871a10cfe48a4a876e66064b233d2d49e70d49a609bb63250ca702037cb7ec8c197d07ca74cd5280d6d5f69a5d54ba5dfe6fc4867b547beb542f8257e50396ae9058dc82269b7bdc635615c54d500b028a999085d1d2998374b2cb831f4de15a6c974e3472b597be3a1d27118e36f560e8c275c75d7dd8b63a7b6c2e17461da7f969222c21d795607361130ed30a6e9ac2e28b33f4262fbfcc43d0e64c04b6f6438de198c9c5e3e2b20c39d286db9bac4fa771741fbddabab191276faaa688b8dbdd7d426cbc5fdbb42c7e759bab4fd7d0be1fee322e772d8046aecd418e362aef57000348c81f05aca2e6a9fd4b9945a4cea918172d6b45e2f162efe750ffee36e782619e18abd254028229749466278d2b60f373940df89ef00c291fdd93c886aa91442d612b11423727f6313442f6a7912777db7947a607816266ca49f6e2ad97b8d1267be29d02cbd255461a839d9ecaced3ad16d48f40f1c84a18857a3c5c4ac1564e8acde2f0e08c55f50b507cbc33362b194cd727b81c8123e5abd3de778fd67681f9216be5801aa4566820432b538b508ee87d3798a748293b79bd8acc58008a0111df82cc367d02ee8ecf985671225639a468aaa2c84d822723da2701f2b3a763abc7e85f52da2c8e4b64c995e04b2df9967ce21e305136d2e10f54ff2945658527ef562798652203f7a0b065b459f847d3dca8d5430235f9568083895fe8a4b3feb35a07c0f7f02edb0b2393008ae2e947443e20d5f31e3934d1ab5caf25e417a04c969d4710566eb369cee1d5f6e92d4dcffdc86e7c46fb9c20df6116d06c6c4a4a2dcdfd0e1dc778c90517028ea9ef548f0f9eb47c3fef2daa959cbccef67a3160e8f3e6dc66267e00126b57201417396401e3198daf0ff9ee9f68b21518415017a214150c3e7758696a30d48ef99720251c5835c2e1dd5ed548239d2c89bd0de595ef3f2b056630992d18758dab1aa74d07ffbdcd708799eb293a2cad6caa9d69471101edd99d5a1b075ec37c216f71fcc98cd925e0b857124669dab0e57114df3b70fe5b795513c4b6c3ac52908a3bfd6337ad5e43a4dd73aea11bcc3ae01d11f62f3513c61f399d41fff7c76e0e9be5c641a2d6d5268b5b0028903533d4a23d1534ae5a56e9f558b843ac75b24e297d167edc2e8e9c841461739203a319a71f8812403933b8b958650320a4728ffbfd9c0f54e60e03beb2fb0322822666af80fdf23744c0ddffc9fa3ad809a7f22af26f42bf3a9e6024a4bca834679071551501b07da0bbe1cd93216e8933a44d9516e5c9d3e9c605f19ffca479a3799a84889412f86a6a93d134191eb804c021449d51aa977bb7233cfc60ec1972a94d031a83ac2946168483b90e06828b00a13a6b399ef2f3a0d6f94b4bd45a3a2dde48e569c9c1607927cb4f84ee0d8f4828b2f3bae7de4bf33c36f440d6914b68a1728cfdc9e49346d3b162567794c907069f34e3e4b4fb6766bedb3ab72a031181774ac974ed83dd9e2244b4cc8349575eeb40be769fcbcad98e6fb98304d199311ee153b46bfe426d21a4731c621054afff3e18c425f0f2c6ad256a8e5476b64589932385fed92a131175f87edda25ab4f1c60b1f63ac6d167aeee2bd257c1537efb5e57941d3dc97be0181bdd44c9821a8e919ae890421c197d528d776a1a35388936d30e5f9983b3dbf31f104da09c842eda3a285313bbf93ce607ca8827428d0e448827ff173c2d46d6a482e29e1637c3146d41d94cff88c43cf6c6ccc0192baee83021d214b4bed911b381e9827e386ac0e00e0b28ba122a186ba29637208fefda44b2f476a54a4a69db30b23f5f60f9da3a1c7a46dd22a9a3f6614ac26c5b10dc470d5640bd58628ceb4f0fbd67f037fb0abe7ef9a5b4f17f5f1845603685af98e1f6858af95bfe286dd66c63ee3079204b913f4bd281eb730011b443d08d3eb3a624c0d1027654c77e4c4340452440e2ceda2b670e6b444d837d54dce0b08f809c2a8da77388abbf5702392d4ea2a420e4044c79f9474ae4a1d3b53847f458e3b0491cbfc7276d8a0e29f644d72962c70f4852cd529b56a30301a52694f374f65a85989d480ba72ae4520d06f2cf5dfaec162d749313385154bce5c8379fe6b715e19aa9d621bad8ccd0bff4095fed31c47068e356a2084fd9a32f2d0ae365c626d8f0646e315dc42d07ea0e194d8073a9bf01d35293ffca9201af727cae4a4c469938503e64b2ff069b34e30996f31f6c1facb38186c2a483b6c4f97f28d055ecb3f01651293e12b2aa1cb8bdaf370588c604759e6b401f9368620f069321f9417b070c1e5b8e62dbef510b221f38a1fe365bc76f37a5ea8b675f3ffe03be0a8b2851fa3164a3ef9b76281f94739229eef32d93088e09b2d56cfc832324924ca336dfb7f0dc6a11fe3799d18f29deea4f618e0c3468d39f869b6b630b104da6a61d8e1689aac1d4137dab9d31cbe116df4699815b47b35087f629fd5c811bc052bb29114b82e0e47fbe76590a922df9e693307f17d7744edccfd3e9d6a93da52641da508beaeea2127981ceb738d9e3df1b0ec8d1bfac6251d73400114f293d649cc27902b0b68e7517a05e60d2eff93d6944313769ac9c743c3e82604962e759524a00e77060365760dca02ad98a42cda45888732f24c86330955f6df15df8c83649f1a767cde24eb6ec391a894fa1bda710a7819db03a2dabdeb4896f05cea2507ea70925d8ab1d8ecb7829b791eacb99c930041789028a7b9073d3419e4cf8abcedf549e6402ff2d327a12fe21ce0c3e22ac0ffb9acf94e915d982e91c50cc3b3e08ba78d6c888c71ef43b15391c78d6af7c95668369bc5292d6ca1f0ec3e6638f7e3d95f3f58f242351dab9819f894a342e9d5ebe321ec03141ff77cefa8fee74e4f190afda5a1956068ebdc2b257e7defd971b5368d910d7794be1957b5bfef6a149c205edd01efdcdfd085292ec5d5fff3c5bef76805c7b857a640a485f734d78029c27963adbf43684fe9da749ed70508ff8ae38f0b87180d8930caf36fb32f187ec6f2c2959b9cb49eae333a2785986cd8d194d045cb27454d47e33a9b00f41e6b92634789257bcaa159c3ecd26422fc90970243bd7a0a6637a92b259ef108bc39f85eea3d406e24e239143f83199d5f017b12fa1f08ce5549af386fedc436fb8d7ac8ed6d7106bc54bb6ae115f46fa1a3ad4d2b840f62ec1b50a259e07e9f500daae825784a3f996a6b1982b3db11f217af10eb8737db37233ffab739063536d3a83c832dec73ed2e09b12f30df18e1d8dce5e88bf78cd31312f0b680d88b056d8f105bbae9d116bf7ae946d86192a35ad866d73c46bcc75cf4fe9ac3bbfb3ac8c753aa2c61aa0f3b2a9d2f7607a74acfdde9113ee9d301f189bcc9ba9c91d7fbf2d15ca810f6f2e085b67f1ef31eab5bf292c01a3ec09036b54aa545853a72257256d8d8639df60a466c15d35ea7c3b92529c544993613b8c6da67b029bb4f4911dfbf25d626b546b81dc799dcd7202a3cd3e731780d34c38bf9e264435a14c2e8cb62a8a7212cd42fece2d780af180a02f470b2211d66e3a136dceb75ec35539ff19b082e05b082d841253457c51effb078659d26a15dbebd630b5c49e4878daf408c1395596f5735fc221b5a54bbce881f2e684c699c6f80a073b10d6fd266af6b31a5d5a870cf2a7c18891098f108c51005b03436f3cb9a499c3168559099e0de15f55befeca2235373ee207e9115d4885eaf6b71de3555bc8dd0b66dfb5b77a886aa97cbcab28da16180c9e5ca1fbaee4e0a68b7ac656b3b5a20b5eca9642a239ba3b590f2ffbc6be0ad965dc21cdd44fe5a62a8ebb8bb29da06c5a56e51e88680904ed4afe769e488d1ce7ee6b9d205d1c0958fbd76184a47ccec9f20d6d8be5198420bb5ca727e17e75eb049a814f9a47d5bb8eb4fc19ff85b6f40be51614bd59a7c4a1601f1fed30fb3cd6002eb4dc8c099879b0231a577cf2893e88aa4701d484516a7c616e84a452515ad3f1d7d489034a90598b058e2c8e8a9b2f365c0b47dc64f5301d79bb710d35438b98883ab2f22e610f40324cae156b2bf87686402cfa19a4da7bcbfe5c871b3b01935fead8089af6cd5fd3034f44665024505bce18c0f1bcc70fe0ead6ca0339c46ed2322e793cc2053bf2c9abe02647ab3481f497768f0b71540813219efd62b70f35730efdfe38c6870079675a8a41d7bf9bd21ccc6c327ab64c571675aef2c9edcadb83742f5ede2a58a8ff13d0da091f36e9babfc610b441a2fb85cb9934de447a6150fefb35aa11f6d28b8a8a1a2d093014a763ef62754b6cdf53de8b20bc6992184874dca1479e639b0e7ded022a8f18468163167d5319a43c5c496109ec79e7fb081245b4b04adbf67319027cf46f753e170326987f9237d8478bc940b507e258b7bc1f2caeabafa05b851d3f9799dc890ecafe8ad8ecd9becf99d814233508a761813454c80d1021567749d2d87901d908431e5eca9c48e3a4b399a3900b708941bf98d4b2c3b133f0c5bd43195e832eef37b91e423f6ace6c29809c1dae3ed490a5694dda200d352f3e944f0719056b9e1050ed6cc88269e6eb5394fff00bae581857e2d15aef34a4490200dc3b6b2538ece4ba88bf17b643a25176602f926c00f919969900d51be8df1b513641bcc6abac8c9d06977b234e431d2142b93b03276f6e0549e393e26d49238c1d87006589b0d98eb8e98386fbe3ac1501a80a5830cc3a733437cf367d81f50b924df4284b1f8c9ceffce7575ea44dec7643bd3ae826930e6fa35263dafedb012b1b0d4bff519f6675dc9c948311a2fd081ce1210de8eefd7617d0753e7794265791efb3d24b43d541d964cacefc85fcb08ca90b237551b03891dc75fd7a8b316909ba385b5d9237e25287406ba88f4e4debe428c86b901daa48160775085547e128f9eb17959f7b6eb9a9986b76de6e1ff7a3d187f6900ef2699dea8c17dad7bfa1134276fdc79d13b79f01c3b56613c9a87bbc9697430aeab8803d177abdbd27592bb288411baf81916f0ea8a7bb80b7f712fdc0ae590c51d7431a0f852e8c75dd7dbf9361462b62baa52bd2d1d87b20f4df97e1f13e38b11f6e5d98f4bbc9e908e3ba1c1d913755de466019dbea5363586c6ece138696193ab436d1b15a8630c2867db7ea12506a8e78b5628ced25794e7c54198edcc9c1a9efc8fd676449291238461aca72b60e2bbabc39fdb6d05561e0180c7fb4488ca4693e44d405dec8e230bce05cf0f28c553659358138d0b4d6fdb38aa839daccc9bbd51ed9f8319152e9e4915f3366a37dd8e981e4e24716e7e85c7b89395eb43cd2f601950e037b37fecf7989af93bd9b6177ec45ba4ae02320dcd83aab47210b3c912ea5e2fa38d257f4d1b987174421c92f15c61f0ea163c2383180f9f6dd98e948a41f68bc5da5018f901417dc97f82b85250585316308fee555c541ef493dc6c745aa0fcd4e708a251acfb9aa6ef9db2774c67e69a0332c4a86015b102965d672434bc8a0411bd97149747cbb44a65b4d12c5920f174f65c6fdf91983dd1df85690e91c2d63ee3765d51d7f8a21d73e214da3219edba6312f7aab3e60a68e3cdafdefa8462716724b3b8af8a0d8f924ecddc7ae03cfb69211b925b7a3355a02808034cd320dae986facc92974b2921ff3dcb129306b39b702dd34af7e200aef2e099aa4448d92699d374190d11b904fc6754fbce24c689e3954825a337271c7564a83379bb99a9abdf43c8eaa5a1a19df847a55e1b06798cf9ee774a5a6981e4fea92880108cd00cf8aa932129ca0a2bd60d8c79b88bdabd9fd1e1e3d2009b59ef272c0ac33a71783ec022082d60c1e4c8ba1dcc08f258cfb0a8df1bc29d8fd19936af5e428b8b5b82afa24162bb5b277ff21a2029ba4b05765eb003e9026c583c815b74e45f37381321f258283f22ebc927b0ce28ae9a67b16361c369f6bc1715bcb85141a87c4b94a4a6556097b630ead1364d3d9f1dbbd0329f769e9610a4ea393084aba84277fc60f8a65fa87e0e8ab924e9547293315f422c7acae709d10b59dbb8bd238e4704085e05f2ecbf557d350ca753d2fb6e8d7373aa6ffd3706c0f3e9117e949939123a91bf0bef55ca1e1c4ec7a4f24214ac29f4882956b768c3a03f2cc34fc4ba8025b606f5aa7966774231f0c3bbebefdb52d5514af4d560a18b1c82386604052a895f9009b61b9b6e81f5a553aebecb9092117a2e567d87c8076b21ee85fd2b7f1ec2fbd3309a7aca622d83bfce5daf1c4437c02df0538704ee6fb713afeac6d31758f35409e75d36100809a7f17a55f9def3c4788ffb953e5c92268ab8d100b09e11095b2fec919fe8a35925e6245c86e03369f566bc153d7f4905a08f805cb5939005eb2eb0ae8dd02ce103bd7cbf6080eec4bc4b6acc62f3b24c91b21fca0337a842886e0e3a216bf931b14f9d1c64185cc60f9ec182fd75c107302409ead63c058436ec177823f0e50f8f58cacf455201d7560b531db55297a9a881f0d2fdfcca77b29a25dda116b93095d448fedb6175107d70648d2ff5f4378413aa38cdb09b383dd269a4ea04881d0c913bb0032076ac966ca2e6cda4c9c5879071d5b7cdad235670f785d36574dd42cbb01f600cc66dd9202b17742e354e79a7c4fa39cafb78b9b1e42ccc7b901152d3380f8999233b35d657c5cb5d687279bdfcb6f4d5f373b0db69703e51e05164ae6c44e77b8a7c017a6db7242eca535d42a68c104a613d71d70e96d15fadf5e01ff6ac0c40d11af1141ee8c70a3d4f96b4254094bc85108c995da50a8875ea8bd4ffcd2dceaf2effb9a26f42b739a6868f81d24754925eac0cdc6a960a01373815774be74f834fc2c055a562dba5b8a3e593e60d67259a357ef484b6f412c246f719581ebc6a8338bcec48e9202b0b3bb3bae9337e622f5f8e89e87c8750498a90e825be9d99b63f7faffb2731f80b9e3eeff79bcdd94abdb35cb1c226d5225377eaa351a9c15cf79323257447e58032d3ed7c74027c8481ecf7a839c2701b6ed91faa1134e8b58d8b7089af345e9d1ff28fc03dd32237d5612a5c520457957a46f96a72d4ea482c8acde0ee28d278ec23ea68eb99876b8f0e51998ce9cb1634c4b424b18dbe20a7aaa5423e9cf3dbad4fd594e6ab1a5db8835bfbec4fb88bcf1a6ff7cbb5e3455cf0c6fe25284a09702ff58440c9bd37647938c4c6c7072c735847ac5f544c5a28b4089db139604424255684d2d67d0a951704c49c025b7cbdfc0a20e2b0ed3db2126888346b07106e20b4d444fd5c835ac16f083daa9abf1649673f51c3f78c84c8944d6b59ff8eab44431f1680710fb65d13aebe5fff8d48c812d76d9cbf4d0a09e5eba9713a20bd6f10572d766c513e5a6df20e97b5d82fa5e509e638b280fab6c5c1ce4752a176dc453d37ede85b2f6ec635dc063964123aca2d950806809191fe2338ccf5281ea59d1c78ab922fa092d7b1a1ed1d543f110792879aef3e8e6477bfb0d85671863f791f5099136850b1d2575a61f0eaf7708c1f68c54834b66b94bb75ee9da36692cd2a19ff0274e975c1dc0941081082f92c2a0720c5f4574303d3eac181560f9374d97f4115954fd8beb673b4f6ac6fd45226111b7a26e87f7af6aaf7818b0f1a7aecbfb0887f6ffb2cfcbdecbd54205f9874b60611c64625e812571e6db3b2fe70f6ea27953bb24eae229f89013e390c6e8b693fb9daa77c3e2f04e1ad30aacb521266b608accf3bc5a6a3129c5d7f126d0bbe974c42a250a32038c9de1008a93b578d378faa579c6bcdde0c8b59e3257233a5a024a680bc1099cbfeaaa8d853d0fc4561c475064e3d4ee257377c2097fc38d2189b0e49536eb1f82720aad74024e17e70cb86775517ea9ae289dc339dec6a71080254ee8c69de30bb287ca5353f496c3c61fbc2d0a7f507c10334629167e39427d63ce351403b1f12cb599ce6339ed9b340c2f1b3cc143e91bfbf734a9700323765102ad64554706a0555f54b0d575bb7bf1aa84f0573a2d6c2478fc768a51d365de9b7eb7a6d2d7cdbf17bcf979a0222038ec5f5522bbf3de25feb96ab8f9307a5313c188d978e97719bcea28eebde2d3005e6e1f24b63f5226efa149e5129255aee8befbb6f4df565e5f7da8ae8d89c8fcf2e071d99979839004e21b6b4cea85a805eb7ad18fdb3220f8ada71419d0a9d9593febd06721d0a871b208713b712367e3165f53cbce5486c941f7ad6dfa18cd966f4e5f201111404d07d1d23092f3f06524cf017649ace36d1419b4bd4f32a28faf28c2c7a91fba9fb7649fd0db2874073e1407d59098bec9fab42bc2e38fa5fe9e9de516893ea1f7d78c48cc48a066b6ec99e037d0719ace6b63adacc3e434ab3172d0c4e768ded7502bebf47c50e24504b31a7c97c56d4dba254ce32d8b9886e1fcf519fa446cfd398fc2a6945b5504af3bba9d0ff1603d0f21ba86f2b393bb07f51b49b31ed429f09c909061cd1767e8495c5ae69d5f83c461a2de70adf9f469a7b257bcf011df1ce643f325297ffee8de1854ee7c89333778cdf30be796398bfd5e92022db943accbc289cfdbf9f13f495c37dc401a6be644290c42e654728f04294db364539d05b31ff8f28becafb0418dfedc5822c75a486fb92a4291b801c74db033e9d959950c5dbc1732595e0cc2f7f2e6257e9c74adfd7dbcecd4069da571fda35cb985a07c4c431f822073f972fadae9e37bd329749cfe4ebfb97c10ec8552afb0e5d6f6a0109841e1b47e419dc01e200da53860b69cbf7ffbc631fbd18325ec332f8582fd561301c64f28722ffe774e46ad2ed24d097d2ed85ef8bf4f2cea860d516caf7d7b37ac4768e506260d3700616c12ee9e52c2a7de738dbf23ee97e99fb2a06330c8d5907361cf586576e93149616a76a5f3cc14326727676960d9e69a72af439e662fd15bb6f5af4406394507dd4140bcb9a3c348b87750a81b18d55f91f3d029a4bc91466bbc1d8f620fed6781a40818864bcb85f2f13d0bb7995ccfdb1781d52db34a53f12f0fdde81ab864eb8dff19b752ad96b40145fac62de24d047d6dbe9aa5734114543bb0fc7f2ed14eb9b2f8e3b66eb636c4d48effef9243e326c7b654b0c32b17ecc9b4f114db478bb0dd966d19876c5864ab493010e5d6ef5bd383236c54c5d2e321135a540aa99ed8aef9024f98b58298124f5c24c9024b2d4b78a2c7a053739d94e15c2a1f0694fbd026aae4848e638f9c26014e4456fec1bd6427792fcbc9bd1449e6bd6bcf58d740825f28ebc55518baf34de391cfa98c0ee779ecf4ebc04c3ce83e6f3ea6be9dd12a1e8b4af727c09bc275e1a6f8a67d26f3210ef01b1d2a97ab69422335fceb00a035287cc26542e91e36b9ec04ecc70003c51c05395eead53097d7ba8bfa2378c938dc5d888117e91fbbaa73230b7c354afe8ad9eaebb4e5a5e316cacaf203e69011538611b14c22c8191ca3a96e5401a72a6b6a6bde1880ac151719d43d93a2228611775764ddfe84d5f21b3c0aae3fcbffab99b34a538bd16f9e4bd4a5d66889c16fde8196188c70c4a7d112e121ce28aa89730ca2c6e24d71c463f56d2a3114164dbbd6f41d4b2698c98a567df4bbbd63983b58e3a633c7fd94bc5496fd50441116b813c8e387038c8d1756252278b269ce8a499a81333fb86e0087345b10d6e7df6bcac24c683e65d71bf5dbc1270200de3284b4b4633f6f63cf3af61abd52b1c2b8f6917fc455050a63698509ecdc3b1e5dbc25db84c8c5468f36bec4d6b9658a1bb10b39625ae9b8ab7dd59e182c785d600c60cdc5029fdccb6ef0d6fcd2bef378df4b6964dcb6d2c4f412927356a9d6487b9a39d80d85c56101f7b919f8c0861de27877e46d965ad737d9a4a96d8e8a9868ce58d81c7f8c66f68c0f94334e31b9c5f08f156f23f651269ef5e00b273d96cb34e45ee1405001f2052e819955636de31b298fda261cedffb50f116bf9f0fa2af8e2d4266d5bc4266555ed755f98c6bfea92afaac08730a92a8bff8d1085b78f372286914b7faf7cc2be8713cdf3f8aa2fd7a8ee19a82b7c0416945865d9ef87fb8b75220f698bd7a3827471162e36f1bbeef0e91d0fbe74dc53c7ee5af42716d6ff9ba40fc75febd003db2c50918e370c0f6e02144519367298af45fdb5a8d501dedc0d1704e4e55fa3574d7825fe926b3700ddec76de9fb9ad899a86b3420e8f9fa623261da61c08f6998bc95d81de90f8f86d105c1cb39769fc931b0480501dab16fcd48972e2af5107cfa79532bd635f08a6b5ddf6e1b9ebe36aa65934a94dfe88cc2eed8203782bb7935a73285e9b680a19c031ee8ecc1c0305f22eaf189ea61b214093fefc01c87015f98bb13675f90ffdbecd90acdec7c52d1239d3fbf80ac827ea8d5fab2017014e3c2a12658bc8679e557de0facaea7b1f23c09b00c9bdbf9b4b1719de4d3681d35d54a35478875efc43f26a6e28ef1229e55fdc87373380d69462525ff07be0c023dd27a1e39aaa35fe4dc6ddf7dbd726d2b822dfad617f83a7d6ee44cfc628da040c61b80df157d693117acba2fb321a40e20ea11f83ffbe1890f4670ee3a96a26a25bec540d37573d8ade6eed0c63d31aa6a625bb45156b5e33a326589a561f7a47e681d1e02db312c05a1189b54d51cbfddbb1cbf5edf88066f250864c7aa2d613eb4278fbb4dc8296fe9dd3f5545e61618ba4711b0c23930a6a5c9648e73da0966f4cac1c095d8c6cfdccf5cc33605baa99757d18e10b2eb87374c18a55342db7cbb2700517b0a565372a839567686c0224eb74c91d4c03f8baa01a193955df9754356ea51ae70790592ddd4375aced17a2b3ea98bb4bd6276cee0fedaaba3671bfadb99ef508384a51cf14c11d131ffdc1209443f48322cce874343793b8b74474fb606b0f2ae9df8be769692ab863e9542d6f120e776ed68eee0c6125e7de411ad6d8ba42a7d155671ac6b4897f10ec690b24c7ba3635a89fc4264f12c411014302e6abeeb59ecdddd1563a4dcdbe6263598c5786a5d3bbbfce335a053da96ccaf2d7e1fcbc0648f3c18e95f9764e69e65eb6554d570aa87a4dd700559f091871aec41f106ac7354d308f5cb2ae70a877ec5179dc8a5d818e4d49df149693bc1a977b9faa331173afc6f4dcd91d8526829344f7d454450571946177637150cf142c9819e728f3eed0953bab91be3186159c3b1f05d1db987f6e5488be1c68a696c7068968f37ad3c19e99969e57355036871aa78d1bf22b1cfd8512e439f8cb0e73658d72d9002cae1fd2a811ac89ed0f4b7c18a9a76aa5152521d868abe5a73e2066f12a6fb847df1d18a58b56ea101c38d6914f0d11f07e754d0fc6332367c05ad66d90a9a15223514c7a5fc4259a9b9192e8c6517fd4ac1baec18312f350bfedb1728e882501607cffda16b289a28ee903b6b2c219ba92dae32613428413b727311cbfcfa30d7c1c27134dbf7e6a1aaf691f993ccb95a9bb79eebd6fe9345444b247d930191558da8a27d93310e8d65a0efe47ca23e52f290aac5a37681defa0d3ff42d2fbbf65586d4d861027589f2c6daebe194419cf1ffd68626e6fc38f9081322e918ff07e7959b545d510aa3ecad9f1769416fe3afa7a1f920928f12188295f34d4350e58f08fa68107b1549d9310bc1d14115fb8532ff2abf2a309fbf6d193dd6addc2492dcfb1f114cee171de6523f2976e8afbc729bce922ba9197ccf3635050482d61cba944da2b63725eab9803233e5195f40030547084e22b6e93f6bc4554d2809401d875e0f8f1a74dec8e7bb44f1cd4add74dee10d3d7d45200086d79cc65f69a618bfe30dcae1b9ef860c861b8b1c65ff2d7b2403d3646110b704b5fa4e1e6205872a4046d2cf75a98151e85f5ece7d016b244d2b4a449ff7cf38c1b54c89a3a40c646220e1ad7eb807cff32e605b24f009039598f338a143f2beb6d6d2b3c691668b16a6ee9f2e5bdea4c7a9e6cfd882f6dedeee9a7edd988babcd161b8689b21bce95b9db67c0474b8f627d22b80abc424f15b996041d945a85de98b9c44e5c7d3fd533d1920b44d3c6287fc23548dd1985c75a258e56e32cd6320abf04b8ca46a4d695783bf22a7bf9e4985e8bdd0b16dfa229d1ed5bf43710a257005800e108b16a5213068697bc47592f87a35a1047241e58b9a49070e7827cd6b8951b41215f22e0c03b988007502740326ef211f0985569eece70a3cb6507af473af061069e3df433a0dfd8d9dda3e1ff551ff5fc50dc2548319b712c35e14b63fe2647398ad392f1ac62139cc79b4b0dd9aa32813971c3c8aaa452525e9b13e5a388a8f1c80180f40926fbb65f5dc2de469c4448b6956ee484f42f13b65f3dddc70cd9d4b7c0f87e8267ab19481233d3f79d5c09ea0488172a50f6ee1b57d20d79beb63b6aefbb64bd24b3fbf009b33026c9b298bb59eafd51f23a4999b55a894bc7493b07dd74ccaa84447fb613be95f1b3237d0f75bfeab2d063aadc8647c8670aa8f06b2ee7f124d9916323af3b5fa5e0fff4e135bc99a158a3a8eb8943b30383810a78534de299d8d214d770c7ca887200607c819f77f1c27f245aebde20ae52453920cc6786ac3a000bcd90c84e70d421d2f0134c0fe6327eb4f2bf359dd2c221a42fa2d566da97d3231bedeb17cccf56d6bea036a1293c92ca9c4312fae75febbce57e4cc2ca6188921ecb53e081bcf9777dd1870214945c423de36f5c5985216ee1b0b2d4aed4d320bdca70d10b5ec28b071e975b5f3901b1760f08c53912002abb8a3a494deb9281439d32329ff26be5c3bb27825ba969fe97c0c0d18e0c35d3c85ddf89feac64a608c6087c8bd9266ebbac702b38bb1e8829e61581b25a1eec1f2dc689d383b28d50a1ab6037c0d5c2e188250ab8f4e5c20ab4379a8edd777743ac4381c1b87c3c5f2e62251a040e267b42014362419a321aed356e436c7df25c647349a71556f691bea35f7099cd962e6a2ff3a0f4cb5be57ee2f5b4e81f0101d6e075bb1bf518a447773122084fb9f3733b7cf2adf71d79a060a9767220602ce60bbbbcd36a5ca5ba482767db85b75d7257cde218421517e62cb5b6cd369dab925bc43090586d69193af54614d94eaf99fd3d6e3f9850a4595a6c0b85e93d2441e7e4923cea9b81c5e59241abf29d29df0a8d8f3582a2f8d4a1364ebcff0fc972aec6dc2211a858c134e1e3eb1934cad4aa36042af75a43cb84469819b179085d8f0d6895324a940bad458245e6cd0a126895b4c6bd1e2619c4f4c856c0d5987a9dbd26e442863d56744f1728f43ab5f60fc0d9dd61b9a026cbcf83c423dcbc120e8c451a672220e09e8702c2b8c4dd4f376621a6158a8dab1bd32c21b7c22a4d6f25a28488a0cb6382a2ac6b0aeb40fed41f78018d99a7e8cdea6e10e550590ba7123d2027ed4a12f004a0fba2ec91e609c901a710b716df4e61e52ee8c01cf7a72d3d11d7b41e800668b5acf1b781967ec58809a1f5872b0c5d5b1ed74472c045829d04b0d50dde21626f76b9f977b2681d4880ebd789c1d68305eef124595c945fd3f96e534abc91e0c14aa6fdd6d3f19ddaf4f9e88f14da8d0d50f965f58f5403c5ad3550edc49e531c53ecd020f7f1fc846d17afbcf57424d50309ed20fd67a8c57b3cc6a25c6cfa89990bd3b3d4fc1f29e8a8587aaa8f3010bfa441ff11a90c812b0243e1c2220d89a149fad50a61ae6937cf96e20e5a1626e6f795141de4131cfacdf83e9b9f4b1ebb3818dc28cf6116f059206af820184313cd8d1996cc306c985a29eceed24de7eecdd2c3ce2af15f7a677ca51ce66bc7cd1dcc37d2f53866ede7a43d575b0de5332d54c94fbe57f9db5b52f0368d856ea79be0cad29acb35348da3e9e05424a931bf4cf703a92fe4fe0c2bbee46cb1c2aa6912fdd60d14c835d68a18741b8df9bf29b22a575c085657630b79ff827c47eb1e8eb2f82b121b7b0004d854862bf46e9b76b06494a854d06e5709698559d788488f01bd0b2eefd160c00d93508b22dd68a67e9e680a3fb4c809bcec9f8da88c0953487f2fb191a8c46504f05d76d8640b4c802e2f66738a2741ea5fa5c66343282c08b37917418849b8ded9bbec758dcc5c5c424fec6df3c268128b955b8d6560030d5dffbb7730267e24da5b6bfda2033f517c1ad57733e5086b88bdba5a4e9f6c23e3cabfddfa40c58589c4ff129689a9644c804c58369bdd4eb1ce6abb5b057314e594a80adc181d69b546780480f71ecc8200758475e35e0056c10ad61ba1ac1df55e237ba5707f2db65ad84fe8bf17c483cece816eb7935ef4d0c678a09b4b8bda25172329a3ddf799cf167c88e4d516970e51649259df5761f2a03d19e9c98bf37028091a7a92dafad6a6527c53ce84467cee934546934cc0b6e62976a2dba8399b9d760800b9d1c7ed592879ea47bee0bdc9f40a68dd96bce8cea73d694d01979d3a52e0026c64b66bc9fb169a775c65a7fca49f96273ba3b675a151e0a531f77a87e84279b4b914d6cbbb06877d344f4e45ec60d6374f2aee8691e12926c445e6e33c12d5bb80849c45cb5f85cb09078c3fd378b9e787b5343625352058f64373d7fe3a690fcf47cd42b2474bd4d31bfb9f91fad396a0a62abfa8c30aef642abfaf6de4ce279159a6c21a39eb3cee9cefcdcbae2c9bfe9c3a8c75753f1f431d2aab2e47a240cf8fa24bbc312f0c9c0c2bf7f464267b64b49f9257700b664a6486629abc5b051003fb5a8441bf39c750521795093568bb1e1fe48b9ea0c9d39f749bef8883a6bce8db4aebf753b5591997ec371cc52cdbe5c6308ad79263bbbcdab5cd4d4cd50ba9cf7889583e0938682b56bd923380264e1af01ac52cad5da7c990edd1864d882afb01585851a66fe92147544bf8cd971198d1a568463d89a31202e85827edc0c8e33ca6f9268ade8dde13c54f8cf8d2d3747a81a7a140fb91e55ec5a257a54e2fc3a5f21d55f5abbcb596b5f2a9c7f963c6ef99fc8549b7c87ac376ad6c77b44778f6dcb5f99093845239bfed085f618d35e18b3f70419aad36f7ab96a0ffac422ad9fed69e3c3fb49454e6509a9c62c7574c6e81e63148df635031ecb11b5d5155444416b99743d119b7637ac5a9fc8e4296d926271d15c6a0c03884003f4542b74d39669e1f09f783e4361fe9933e713543a728add64b4697c98701a570ce23437ee1ce38447ceaf134fe1c2feb5ad9d4fdeded61181d8a4959e8f128201b8a15c4f1d9ade7f93360daad1f3eb0993cf814cf24ed7ac1bdab603b19d29adbdc5eea17a0d8be1261b417867c8900edc20818050a5c30ec6a5af8a7f7e92ac6e7f342804724d132a06615b774e776def009ce57f424ea3711ee2a9e8d1eeb9222100bc327d9878d43d13ff6a37f37101173e0c7e92ecdd353ea4bdcb3963c281dcd02522c739bba5f76b1ffce8d1f26e878566af3a0ebcc412f385fc7ac3c7ca07f575ea5948b8acc55a0fbcff8b4040693739f8a6f7b108f3adefe52fc0824a81cbf22a93f521bf8df8b3ac81283ad707eacceedd94897c3a72452aa280ee81586dc06016af054145663eeded65ba710a4e05707abbf4a25872206f985ad212df7248358630b5ca541fa8ad23b871303d18948c402cab3b8e9944dfe145941f04540abd4e71501b27a46516d8afd2592dc15ab6fa671f60887ce5962097b8e6cdf029927fa12fcd5b90d550a9eb2071ba6e729fa7a4811c702429590122040c59cac1fb2439f0f14293f4452abcc5c28187ebd63219d19b7a5209b911060fd971d69919997a2b11956e6c1a5805d01582d24822ced6e14ad03491d0c3ad2b73255c1e84529e7ff0712d2081db84faece67b6f69c2ec477d5fc8a525289ad6643b3bf56cbb57655c42c2d131a34b2bd56e4ed13c870327cd3925d0ca716088aa34949057f9435f404380c69ad0763b8fbb896fde0a0c7eab5d700bef10b885a00891b0ce9de4a8fe1256d3bb6462983a360c8d0e20b6a38c5fc64d3365c802e90be7b6a55dc25e23b974e71e68f796c48ef562070d851b32d710676ea1d71698906439448526d1dfafe9f306f1f6a03013dd8a31c3816231e9e92ebb989820843c3ce9320984320b6235ded9fe9eae5a17ca96c39f3ab34f0963250a5be9ba7126c54e2af22f02bef004645719d507d6ed977a0d8078680ba6af462f63a7f8b96c3c33fb67fd76cb577c56c99ec7c1db8a49912b604bdaead28e8c5c9becc1f5d93ef5affb7c9fd71bf94627f17cadca85b0e624bf56b800da6cf0347a289cb3ca379b3b5bfdf9face037be3c171a2b54e8ec55582fc09b1f8367c37479b031d2598e5e135221813b2127d419c56f554c9371fa8c1ee90e9dcd0b618ceef1aed5b2475d4f7c232250610309fd31acc58f4990972bfd9687fb7a0d1601602a193da127c586041be7f241aab3de012f8da184c5bd3882d5e9c2fdea084414699c72b837cbbb49d28f69342e3a75a1f02062b2ab60d1b1945edfc082cc3d73367076e1802360d79bf440feed2f0af770b12c7cadc83db5bc036ae28e21faa2a09dbc4f925819b5f6747dadf7929e648de36b73c9aceb91b7ce9030f78e13c80bb06fe78b0c6bb5850480a6acce873f842a3386cabdbaf9a00c020d9e580e6939f2682f22b94638b3dd8a6791fec2c8510f3ce31066aba603f27017bfd35fd378f52f6c5237a699408a4beb765b9e33987f39c0e240259c3dfa7e1505a002e92a89a0b38b812349054328d46bb59acadbbbd4bcb5979cb0bafcf1847127399ab7887b533d0ef568a7c507512af72fd6d9a4dc540813c0ca671dc3044da207ec6ecdb364beb8dd874998e6a2cc484206290d9f69689bcbbd9c0719a56f469e527f70c0018cefe6f6755dd7431b238da00250c6dd81f2f991223e1ed71eeb82102656b3bb6241156a00acd7a7ae7ebf9aa1aa412abf319d19ed623c0c9185ce60a1efb6b18c7b8108c19c98a4e4e10f88d027ca75c3162aa1a232ff337f55344aa4fbfaa09968e9f0a3d4de08a03c44cad3c4847a0c28830ff17feb216f1aa4eacf0ea5bb586a55af2fbd9e742c52d1e5eb2117c9517de70946249a82f235b6a20ee03ef5bdf36104728f5d31dbd210938ed1fb649ca9ce4ddfdaebc882da4bb9a7bcd26fa129ff73f7c63151bd48048e9a46ce36b0ec11b99ceffa279bc49c476e14de6c8b28e04a4ae4457a66630cdf396e21d29d35294c9cd047a82e642a8e42a5a4345181c2ad92da2a2c980ba29fff323c6b6c435f7e49f93d15f59fd8a2eae62e9974f74b3b61c3080f1162376c0640db6f7689609b421f10d1186667f5da77c5b7b35d0abf7f95619fbf8372d3242d89243cc3a63816dc6f671eaf6b85af78a5e9e3eff2ee5a53406f771874041fd780f0703bc44c50c7d815ce00a87e45f8fd67fe708d19bd118c6c6d44f5e48dad1f39937c7ea0cc84fd16408389239fb9c1ad8db8c3528871325002f6c73b1563edda955203de70cf4e9756621102825e8b56cd1b3e3ac871d6afac64037bcaa66c0d24568ec633797b1400e2ba0ab8e3d15c175ded63c6f7a81ec1c0fa810db4ffa5d12bc437237feba5ad35fd16e03f1e6546ccf842bee2f059e6955098247a6f43de8f47282af6e2b8222d649d680ee62fa3009acf8b36d121fda1e284bc49afa63bf23c356adadcbfef15b7152da205105280ebf6fa1f62ed2851d4671d5a101ce6cd9f06f38fe9108343bc7e6943a711549655ca8d9d9ba21e9b058a712dadfb8639306a14bbed882726696e2274fd9f0418a5761df8b4f7171d931aeca30eeb9bfaa6df17a148b94a64e9edbcdfcda43b8af7a0e0ca322dcddadb27c6e9ec93c9800ce9daaa6f7346b101d99212b854f0b74de9fe233ced071dfb9ec7a5dc21970c9a73c1dfc8037f5c31da5da88094b1649fa42ba64d6d6f33ac48a5a2a54fea8b0838c0739f1606521755143751954bef718471cf8bc9e0ed529adfeac5010e89057564ce462c557549e2ad0e9dc3b6e4db935add57ac1e42cb36f4264c6905255413f7caed7594304a8de5103888716ca65e272b042f44b56e1f04bedc362af46203b458317b6c68f875ee579ab6be270ff293b3e0bef5bf69fae8d5f08285d841f7a9a6c6aaf226a36575403a649f58d66787fee99f9ca7ccab21ed566815b1f3e0d9c7fb9443a8c1c783b41a1c776645c92799ead2ce1a8addf8055d7352934866452cfe903d411e089068a44c50225918674097e4c41222e46961eb15c48099289f42d5bd1ec9508fbd39c4fc635ac016ea2101298e4eee3d366a95d2207c07d47d71802efbfa52ffa8251345828655537a1ef4fbdb141b66f34e3f228e847016aa3fb570fe5ece09c5ff62e498fa342521e98a87ac7396d64c9e34e9da301cf7223a77a6ca1a114cd41abaf0a9f76b4e800a88390179eb3317fc97d5a0617f04f785e54e2b7ebafab07393efd609ac55bff8e7e23ae14025f12e15bf16a42b25d8670f6619a848baf5ae2b1a5a6b66f185c770c6744d31b031d77b090763b20092b6a482d5a07363dd4d830bd0a14bf88b22f140602e0b8f0555050233302eed9b96c5f2b9fced6eb0f33ddfbac72c236a8e2433b2b3cd550fb24b56d13c7949299dddb36eb9028e13dcaea72e3bc69b242d7f37bbf4ebef2293add5e4bbf02d0b2ce8de7ea9e058717b7ea0f3e22dbf76f78be1ebf90edd9543e83daae6ca3ab436774bfe79ab9ac4a35c62527ab23ca6c4a809dbd6ba4ed1d8311e64790a293a7bfd669f0b9eb11141283d3250e6241e489b62707e657c6d5caf43ea425c17b1e2e62036238b11d8dd839b1f7193e92574d29fe8fb9e4541dff4f9ec275f558890d1eed2cc8841a14121ca811aaa0238d5c09c426862aa93a59063892a6a3a1b84ac27f801b66c8dbcecdee0d3e9091d8dad643ceb2ca8fd484cecfea21f0c02ac61c236c129ee04da2147963e1f5917ceba371ed0c67bed332745fb1b94231d26e02a157293718085f1ec9c18b07663daa589ff6e3c2b8ba0692629a373f6fef732b6b306bdb681febaf397f4035614eec8e34cf5e4f3eb7917dadc3d55cef2063cb5d9fd46ccb5cdcef2268a2d43c1eb731d032924c389ce004ff1a474c3f4f7eff24b39095989ec8b8611ce5a85eb5c5548e427b70225d30ecdaa8766e3f0cf90e12ae7238586fd4f8995c409c3566eec08f191caf1adb2379aa758fa218161bad3abc5853ca022d2386628d2c9c28f1692a5eb7082fe00e165cf65b3b3755c9ac63bf7caa6f5adb0470d8b9f144ebfbd03d8e5dce0c0f25f9229e03ebbecdad501cf67ee0daf58a6b9d17600ea0a53e6b3b9eb8ccefff626402c309b0d0cf45924087ec0551b5d27472ec8bb81e99ae30d6eaeccda1083f779f59a10997deed417180f43e04fe7bff7600f2cbd2f3dfd5e2f95edf107a0baef93343e05aa80e27628cc59cbcfc4193cae648c03c2bda6b3e28f37479c0d95cbd75222b908c389e2f88527bb0e1fc6cbf381dfd623b617df7048c2fc4c696626ade5b1a2b092865b4659915bdc29e6113e3d8f07abc0518e5c8791d91f52db078274fdceff83e8a8f30ffd6cf9f46ee2ce2e3cf54072257ab8e9c5ebd6b099c7b7de9cb153e44d77c7b9cc45d306ae3df94af4f8708eb89da87ea821331ee1d0db71227987f4c12ae69b22967eedeaaa87a762c997df64b80d60c867cb96c55e68eda8e5c38a43494a1edb9109c1e1c4e6dd8369592ccf40f89bed6d4414ceaf07038b8a8cdaea0816b096928c96e36f551bc57f49fd2881714c7cab1828fbce04d4f30de278b3ec05b268785301612c706629936ec76833aef052ec25de99a02bbabd3c301f690cd1773405e24974266049adeb26987bdbb597552702d0d0011454b58c7e5ca0f3ccff603b28981d174ccf562195443c63e7f8863c40649e2485d7f17cd6704bb7c36111ac746dcb324c7a44678fa98cb60eb2a798f13b7923a94d4f4724ccc912235f7fca7573fe099a8a50f08ece609e2cc8ba4e6d994a05b14c0aa2117fb76656927124a6253abf9dbbc515c689e2fcc0099a73462f5ec94bd9e4ffd173af13c3dda6c146c7b8021114c55894b0ccd1368421569e4acc80cb6ddb0623591f7cc54521d48920c0ac3c77ca827bcef1583a8b2cdb868fb610eaecaa9ebaa9ef251c93e64d39482d9456a420043ec6d41b431c68672f461f2c588aa84229168d0488397c2c5848e50fd4477d074036bbfa8738a1a1f915b4f84b9035bd44a289dbcf047723b1d4525f5c641cf56049c6a1ccf670e5a49396cb432b9a6e300c2158da24d2cd3ffc8ce2786198ce164f7b6f7b4f74be73521ec730f3d74a1fec6cbc6d2495261855bd10aea94bf1edd5f4fc9f94c5e8abe24cf10e10afce65761a104f7b5d8cf67fdc513cbb5c2a576da2c7780198039497b6a482e2ac95d5d00751eddef72b40791f14889907367c91b07bcf0165dd013ca2392cbe9a86ac1114bedf5957f3709e7136976600f614d515eae5bee5c8b7e2ababcb2f0c4c6fbea7f6a2fdca66ed056bb0bffa7f07b7ff645ab43b603743be6e5e7457dfc8bd3cdc0bafbac6279699a9618f93fa0738da4710d01e2c47d86025e417a9bbac54ea7b232cc14f33c52b7c13ded8d588e6263b89de25d75c3b1f6cc2a56d495c0da0f44f791afe246c2a1a589d60bf01ad27080ee82846030011b8e81e02f8d093d61c8c163618b0e9fc3e96d43001fa2927cb640231fb434ef8462196848a6df2d6a41a96e6a86fee0c774112e8bc57a012bddf299e0800337631e485728faecdd59e6627c75910136540520843abcbb5a55a1ea3989233ad1ac4eb32fdce638fa9f329cd654cf88b3fc2fc26fcc753795b14049a15e867f98019e25b0c5a6ab46ff33613413de2f1ab8fbef34be9d9baf5a5817128c84ef2de38577bbc75c586e20cd51797d8c1922edb414d645151248d59dedd92fdc5fa8db4980bb43b15033c9f6371acd08695f692d53ed939e48415799b8595579c9d314dc2ba2618accd9a7e0d3745fb9aff43d923833c7571f7ce22be01ea6e7711f2e2876998cecf4ee6639fa5abfb0b1f04e290d62a3207bf8d67ea94239d66df432a48b925ca5dbcbf29a1eff28fb795be4f892dadac17f9da2a84f22ed470b69db8196fa7f9450831d2848d4a408b56782e2cabfab883b9a62bece6cab0f5526412c6b37ed1969b0035328e96b61aa3776994e2409adc0639f6a944d0af990a364c473e6aa694b4f149cb6c687fe7f30164ab1334f53cfae01353ddd02a3a4eedfe4756de2ded905eafdf9551dccf12d370154fc4e027f176aa4428d1fab66dc377fbc11785fe92119f6c7d3e922bb3f19a2e28a7cc04520f3a64080251ba7ed807736e0f25be4bc82b92f90e6a14155196065f76eccc337eee12b25a1483be3df31bfdc11d6e9abd26e7f9a218bf63a9c0055665ddf9ebe650d352da392c3a8eb5bd3c3fef2d46ab1873777b65471b905bb6e0f3b48da9294a1bedae350db25c0cf26cd42f212083642eef81608b7fdbf96e143728d295dc3334494ebf4b8c71dd9e7ed9fdbcccf291b63c5266cf5945fb0978d5ea0b9ae31e0aea5a0e17c9da4f635f129d51f4af760166bc1150e2f9b19c120dd1ef116242400a5791d2282ab67294124bfd7955c5e151b251fef31a02779958534376b8d0279e5757e00a235e41fc76bbd1e687788e51a01b01f45da622939a8d49b72b1498a2e92b0afe2673ef691727a4e9cdd602ac7d66fa8937bcaab0b3a1461b3cd19d7073c8c0fa58fe7cd8e421dc7664569288f9ff6f899ba8279686a6f897cd6d9ca61755a6a9f97154cae861283f6748175e53a7cfefd20c6901c78133aa85bf52f42fa925b90364abe9959bbdfb4e06af6b4bc86e1339fe36b490bf57d9ebfa9e33c44bac93bcaa0bd60c5517d930fff4931b8aa8fa1f19c74e11fee39760be1a7f68ad4398ec11fb6f9b35b9b60a2020c56c8c680ac9ed4fa673e2428fcfbdb4b2820b4a9de8a714605314e711f8bf58112adb90191f15ae1e8a336b276a0aabab34c99224d2f49737de1e18048ffb360fd8842340a7737e8e00365bd422c6044e54891e6e0a5db33b1bb10cae9336a4f2a0006abf938eb0cb5d0de80ec3c6d3bd652560df9ba08ca02d6382af1c7f1e38796ad2eddd8d6b69b1b76e6a8de7dd153e40731c1019b589af88145f7f27db27cdcb76ec9a4c638b9bc71acea6c706d3b3a8db76ebf16828d48264ca8a7b62ae0a9c3a9f676e3dde93c9dc180235aa71ab815947aec57eddd4fdfede6edac820f39195ae8799116712246501d9eeeab16f26fbe2597538dc9539b522a40f7aedb075b793d42f75c61706fc7efcb8eb1ef2c71556ce9c4e4664c2362256b38b96b52a3eab008d86129e0b24d11342c3f8c642f16a63371862e91424e94ce6762e62451eabe8f556679d82c84549d8b39ebc7e71d90178ecdce91fedac81d67b85d93d345d35d8182f383424c11aaffdf5b54d74e798e10465b9a123da431d2c06f4928f5159ce971abe4265aba86112969dbf007171152481752335af1896a6cb8e0153abd1dda0b327f1b6883eacdf3efd62481cc7668966610b27dbfe6d4edc6b4052bef3bf3c6012b07bb082857d8af6578bd5581e71ea8f5fc83ad35f696040780da821f2891272fa83df0d91ee983c64a3d3f099c040407921d3ec55889b86d3d1c580f248ecdcfb3b937cd7910b49f36dd6ad45e723a20a0245293b50831fc4cb79fbdda28dc93c1e62caf9793ad465fe196035d580817fccff9be5aa7843386e89500f3827b75bf92c39389104ca40dffb49bfa6e53977478d5a9d9b41c7d8d193b6e721e0fa481db9e2d9b8998db98cc1e82b48dc1a23c20b7cc5a94048208f62de46c8f42a1615760cc6dfb042533a9e64dff4e5682c23fce71fcbaca96b5cf067f2b17bce5cbcbac26765dabfd286a39789016b242501839ecea8a8608b33db139e85df76159ff0cdebbffa57f4dc38baab2e0f8ba2ac65b0bab5cea0e46fe4720b1b89abcdfc62e6cc70bdb28feee012d7a1ff59532b7c5639c8d7cc68b852497ebdc8f4571f8707272fcc392a1c06b55181627b2e6de134a7d8b0f1e0b62911f25b704b5363b2388a9f976c43a7f6c069209acb05036b94caf7fb7d350c98b864cd41e72a746de81c7141fc820aa6a12b7d4f13dabb715f9603d03514d2dad4912d62df6baffeb4f8eb0903aa408ec454f09afa27e557c9f75ebfd14b7a34698a51f456ccbafd1672c9182f6ef08a45495141f75a495023c34467e0709c517aa807d8309638f7834050d459f80d651e7d511d9452dcdb2955b4f2dbef53fbba1a3a529467665670fb87cc06b1a6ac0d3a348c5b72e7f653690d41fc96bf7d4584e7e38bfa2a13937c80225383198f5873e36dc366a456eb0408479e57aae450536d2a9fa3e94ab5cb97a72bc8110423d42fd4c63c4e55859006acc1a23da20dd4c8bada615c4a3d03fe4aa181a3afed722817977dc7ced08f8b7a81a9fb1826fc8e8e0fc93b86c2a203930a53c059331eb84853716355f7a44c59b087d0f612b45f6ace58d175e9ebe399ded022976a1d51c2f5522d032f1a3d46be58513fcc57c09f6cd97c5c0dd670a90ff73b58a54575d544043334b7c818f3f4abccd99760c8288006456f9b5015dedc82fbd910154ed4c43f9c6d44dd1ea5699b7f4ca6a80a516eb2c7e1fbe60003f13273881b990a0516123fdf1931e0b6a14a84531f31900aff27cc1acdb6d471c66a75f5a864e74d537791589a5c7f34efc349e45a305435e45dea5cc9f7ad6a174cb0a8998bf489d4750ec98a6c7c0f4e23d897fb0e4669a928cadc9c5250976c75e2f6ef039f7fa5e7cc7ed4553a65424055d0003773a0484f4d6268f635f309b9b46a0cb1cdb392726f4fcf67e797db0403b1cfe60daf31d433b3f135fef71abfd796c6653136f06dc07032dfe377c45bdf9f806a7246a362ebce83d14ab4ac735db31d491b0eeae508d9a4ea91677f209671f121a98d363e60848f4d2fa1cc49474f974aecdcedb184b33fa878a35386abeda43abe148fc11cfaaf630b7424855e491c6ae462346843ff6e4080ed6611554a755ef6eaf994df5b1049e16b2374a7b9ba360e68578c44fd7fc239db76e5f263c3a4b1ee083710ac1dc21ad1b967cf686c4230f4d529c43d25f16239d26ed14802af8367aaadd08eb9cb58b91457a26579103bc624d3d380e181e31a8170dfff9a6dd147d44b15957247aa12ac2c91e2b7d728a1696c24152e9c2444a23efdcd2e0b7316885ef2f73c6439ef847efa018cd957ccbf73881697fe646daa1e271537777eca9e750bbcc755c9c91a60b86e8333a0412954b4dc52126e0197c44eda6abf20dc8de7353ffcf8d13d933eaef825fa6933b73382ff0b3adbb1118d220126a5c462aadc7d6140227cb71a96c330f77ee86120700025334cd5d2c5fa0ad886a1d404f64c56dcb596a94fa6448bb92d372634dca71221edc5e771f140acee24fcce64f438397ea74f95078ccb3094b5d8ca8449b6be56bd1593863218a8f6f16b05519c37f9baadebc8123e4d62a78936ef233d8226d55197e93127edec35181920e2f4080a7741c7bc008f880af2cf502b49e5f5707b4f1e4c3f9ff84ab4b2466bb5f0a5239b8e53a61c8b4d86c77d0cdc21610278b2b824e18071c9b6109907018cdbcb2a5f02123bf66e9760bccd3eeff1f20fef002645038d1adfedf280114211ba151aaf6d3c4f9d7c1266d6199cee8a99f1563365e8569cf557f593ba09ad171e90c0f52a5173dd07ed3a7fa836e111b408b834a04a533bef90b1b9f01dcd00e2da4aa98a0f09eddfcd9f98fa3365238ac424bc8cfdb677fee48273ba36c6e3e39e4f1b346a0407688c539496166f6bda1421c73c5542f46faf0cec6979dea9dd3258638389467afb02e85700568bf1a10ecf1de7a58475f36fcdd1b08bde2228ad072cd549ef729f522e2dc902e9938a76fef80ea1870f5c9bfcf4e4b6b3b320c6e4b0add81e410583bb28ed244f990f0d1d30c1d2b0dfc1f0492636e577302553590b28048aeff04a071b7fb46f6d6b70771326bb6a59db801f7e6d6bdd5aa2257f2d76f00231beb02c3838bd2565b10852dc562796f57b7974b370ee8ccf25606d464ac30e8cf2ca10c2be0965594a4b12c95fb9f2edf6f01ab184848a1ee1a33e8e4dafd316cb8658d8440a8b7143d773e095c2e75058734e9e86fba31da807ad6856fc6e6dc15e0b9111eb97173a4e7e04f0e4f4388cee9010506c5f68bd88890c1590a6374d27f0f428cd58e73a950b68217b28afe2f13b7c587cf23c559826fed8554bb3c7c62197063ca2cc13b5ab905676af92cd8ffb041cfcc0537da072aad48c210a01b55ce7c1c2e97b462ae064b37310ec2a762da756aa153563c172686415cf3bd8b6a3576128ca3fb980b63955ada0ea79c415d1367ff359842c91380d3de452a84a7f58cb342c5281c48cc0cf95bc6e002a860deba5ef926c6410ef6fc15875a45f6aeb7acdcc10ba3c9ad5efc50a84d3230db3a74055cf6e358a9f29cd45d50c5bd01ca39bf9546dcfde06768111e0874edd377743b7ff1a775bb35fcd9c2e584756db75229cd049df57f8470787cd350b0fb2c7cab97181952f2f4868ffe2784c4b5d9b16c629df567144ad70fc9a601541e5ffd5bc221bc467a86a8bc8fc8fd5a8ae0e00c482edf6dd01c92da51bf16f7e3f2eacdc2e5502a18417a31a2ed9699d0cc8911db7c5446f226e768ea011b8f38bc0e36b44bded77ab9c0296d6affa81a3b48ba861a04320124cba76c61f95e0ee367e94a7691f9dbc0ed4b8264bc1f1df3ed9dc685953e989a557414d61ddd767d37edf7e542dbcde0b7c2b8d5f2d1ae7f60f52c4cd9afc38886466c90a56057afb5f67205ff816d426a14bd60486f6e441604ffc9d88eaaae5dbd844357191ce193efe10a7b345de8ab86d77f92ae589548667ea4b2c1d763deb689339637e128f717b5a23a6852789bf0403316939adc96c60355609358d1c6f56990b2bff94e087823a5075d41d0ad32bf92c5fcb82723a0b7bbbb85122168daec0aa8c6196823e0e612514bd1b5a20aa1fa5f2d000a42ee94c9830bcf80bed2ae081b639c975d8884d4cebf632de7e7372c2d73b3dfac8aa94e3621710c6fcdf651175fa9a7f6cf75e45ec9079eb96c5b015748ec8e12dd1237194716067030f4f49507c19dfb26be056fedd71d26336085f2d5f3fe85e9ff9b7ef249813dca1499313bc3fd225c2306cd6d91a065771cc23e143204dd917710be763e5d9a21d96cf32fe0319fd05653819e3d8c51afc979cce49ddcb55f8bf16f79ea977df689eb11ec7b2e2dae1fa1075ea047893dd915eb788c809e09ec953220a0e156b89cf7bfa5683f951883f32b6a3ea3c73d961b6169c39bd30023ad23c282a855ec90fd3e37496717fe97424506412e5b71f7f9c19af4aa86342925aee6e2bc28079e90d1b5e60b68e5e0bd6c9e9b1af0a76e3e3a222621dd07f7723c4b763219a99687bfe27fcfc8ee23827b8639d9773cf051e0621aee24a73bb3010a0a4bdd2877e9ac2940245c83fc9e988d5d1445febb72d852fe336ae44acb0c1e1a34c9c3154eae1f58629c98f130a790e6cffed2cb9cc5d9c0c80a6dc8e1c8a0845e3e29abc110fcb0c01b90db71a0a97f2c0fe1838a2d0acb7cb37d4fb293d167f512bccf419af20820ec6fd8ec9135b395b6070512addd544481f265b84cfa78e74d4a88ddfa5b060634063bc29e8621ec2c80935120acd6cfb614859bb3aa709577fd68b9edda9c53684f23dca95d2cb7e8190a4e6a308cf38771912950b3fff83c9cb0c994fe3798d0a78f6c69665b09c9b677e3118912b91e173a52084675985d99308ab8fa0da79a710e5b384350749b752923a84ad9429a460bd45ddab34a28992e1e0901780601a89ab2704b7f151dbf954b3e950bda7539b26e1e3a52baed454fa1187efabd331e362391ad02ad70e05a201895776183187d827c2b6cc498b77589dfa7aa4a9470bf85276f9bf3d00710a9b6b959e77a286a21b870f1f87761da68a5f3e1b70b934970b9abff33489b8d712dca9669f4babdefddb9059f140d51a16b0580e21299a8e422e4674a7f7058f6012d793a73114e057b7e6f36032e89c9a885742fc11e888a214a7114931ffe6b31679f9f3770413d77819d30e45bdccea20cbbd7c69369ca98f32fb9d695cf6ef5f07855739854ce95b78e6f4d8efa8a7c6469da34615700afe5504b1e656e4452e00a2d897a3a3ae3fe7d807f910e8aecafa607036b53593992b30ea68105387417451b70474f5579d5341776db1c04ace963250428e8ab35a36480da774b5f09479461331c7d95d866677732157db760de2a9cb16c227911802d8055be47a60322b78388e9ce2ba6b8f7ec45fc08e0eeb83aeb9286ed7db3bd12f1edf4ca70eba5d418b87ff5a169f8b965d66e36b5763ad2fdde1405becdf05fa9a79d7d3ab2f023d0baa159dcac96061888a2a7e4984ded920c8b7b905046db32d266f6aea1076519eaf52fb6008553f87767b91c9bfff231def3c91c5b66797da756a81ac1908c6581cb194e3fff0950cc184cd5f4922933c0f0550c0df6b4e16d1c6bbf25e5e65b063ac495cc4f34b2c6c2592eb60fcf320000fc9e6d4f3e4ba23eb411d1ad23fbe89b005a74de6fddf5e1447a3b58c113cd4817781b2578fc8a5522cfdcf8a79f918ddf017960e01a910a38613311d85b85ca7d5aa8567495cc5db15d1f2af871d13668b71761b8f349767c2dcaad029600dc71569104c64f5714bc2828ac20cbd8afa2752f2c5fd696b3fe402defd89701fd5557ba13dfabbb1630bd83e1219b81b80a226a3d45d351593724a8daf327784b9d2b45eccc90acfd64981d39d5956ba5e7d4ec5270285e7d13e14e477955668e4850f9aa04c3a3f1634cffa3e7a0912802a04a043dade42faa040a6bfc2f89f37d6f617b391543737a17d4b753b8614607217098f4af45f550487b6f4fa4bc82e3e2afe1e5a66303d9e6ac3c809ba6f1c1b650f3aea005bf16321bb9bcf7c62f12ede93048d1745eaac662c643756f08c884d2d601f2d68b4998fde257e3012e934e0dd8dbe65eddea84f64ff1d72f6915ef65327c2a7d864b3cfeae0e6ee118f6883f6b92d5d4c879e8a541ac93f83659291bef23d8bcacd31620f5df73467c598d83f358b53f8d9c975134eb4cc06cd1a53dbd15c6ac0633d23cd69427066811b2d93a19fea24b9815071553b67d6ed1ecd749a699de05c1a334c80ec5b409737be2182b28929a098ec0be1b7b3ebb8106f890a1ee153d33e4c89c6a9b92f3d0881eeb287d06bb5e4f74e8dbd3a7f2a202ff89cd4907e815825d9fe8d9365f8b70921dfca47eb92c00a4b74c158f8de75f669a091889fef2446cca3cedae67ba3220dbbd59c16faaebaad23e7a909f8284ad0ce8aa2a434ce77bde84d156bea56d80a333c86a78c656c171371311128e7318233360f8d71dbfd213ed46568a45970fa9490a94779a387edf8cae48a00da275572f610bad06c1630cc2d3bb32927e38002d2773274cdb0b4c1c49cad60b997c268859564ed8348d9cba1d487232fd670cabbb6677e9dc09d08edfc26017c860d50520a3e3515846f1c00604c0882e4a7d353796154736cda0f0ddcd4eb3a626ba148f4aab43d60dafccc49be1f7c3b3e3dd050dbe7a27aeee0513eb35b0f497d16d3c00f0702678ac6575023ad634605ed0bc494acda478cb46fc8b9433f945b9d96d500efabb76c121a858554c56a907ce47c3b0a7952ab34e68b2c8dffefd96e9dcb1f11662f900c61edc3f9969728b94f86b92afb6cdcf9e32c071f4e61caeedec567741604da03e0856e67aa1d881717132747e36b52c503d85163505ff29539a9f43541beb4fc3b3eca1c0e84b9865dba71b038d1a4feb43a170a5d0e568d05510d4bf7f5ecd1aa57afcdc3909dfe75553fa8190fdbe02c105ba58793a1d4066277462e72411264c014dcd1abcfbe27759b96eace1c19c63637bd949624d54672abd0c40a21e80dd1201e001e4f4c493282fb18998d803904f2576556f5d0b04bf858ed496295656bb8a653a9974c90364f508658d7f4cb9bec923418c802acb5154467711606c598c7d181aafaeb26c48090dd2cff3791b8a5cade5246ca9659fdd59a1da7ec1f20895a6206d2f9d18d7902ec4c7580d951724b1391dac2135429e7e2cc28808217512895df340316c9b740dda728afe7f654ab08540e28a4d720a64e838b1fdb73080e7a027db3a356e5dceee7d1a25555da9eca5604bd3829571a0e0c7b9a3f717d53bea50170954f96e2402d4cd0d5b7aa1ddd8fbe33d0a3323174ea94752b3c3f51ac70032bd2fa3edb08f960c51fae24d9f9b99d7043816a823fa109304976b75d8fef0d47252adeceff039d6d1ef21c94e4c704b3d228a12d5b392f066c4797787f0f9967f5db387d3ebbcf8e64425f0bd9d6fd9ca46b4ac751e8322228f37cdb1c36988afcee6c278ffa531b6ddbea7098345bac5db3e41139d300742b3dea3a81c2fd482badfaf4e7f3ba8da9b0dae025fae05990fb20a6c8ba5627ca0a01afbab8e0288daf9d3f4f6744fabc71c2b91360371101f1caa683efbcf355bf19aee2647fef8da472c1befc39628b281bbb6c83e56b55146d32fca07e7312ca732fd7b2d8e7d2edbb162b6e53038c1a99c6ff9d0838574b7eb2e365f1b581018b2863296a23029a2ba9df36faf1e40f2db09239785a93f944fb3d82a904aa424b46ede4aafe8d02f85231d2c814222a80c0bdeb4a7fe5cf18ca9a480099b572efcb7f0940bd6fd25108f3a1de105cf15f178fa6e1504c1f03fe1b3fef3617882535b4eb4d1706a1696e4f8edc39675428fdc3d631790855f2d60d59f3092ec9c27bbeb1cb909cfbbf7098184de6e1704a758d679e2754070687efef7e8c916c5b27dbfb133dd110d53038f0ef31fdc82b16ee576ca05e14f20095fb3707a1a1087797eb049bd08fb9dd68f86937e0ed0ef83004f26112073638965cde54a31542d5377421df6bc74b1eb0006ec7c55f2af30332217192baaf12f166617239cb4330e1345c6fc5ea1c355ffd3082a3ce9bb64bd56f74208f6ca46641259c527b1c41f0669b23c27557f4b6a0d603b939229bfe60bdb30166567dd37093f5977917ac8cdf5f40274f7a190230c1f1ff596e3e00d58103de885e1d7e1d544854b562a25e007eb8625a16b0e90ef8dde7732248233ef627a9fc319c6685b0cd3e223c4e64611e7d3124ec7d7c4831da35d2ed7636484419b4d0cefaab2b00a19559555a69ebe995f05e1db13d45705f5927c4b45815af7418d7583ea9a3b90848244ad880c46fba4f513ea6295c6deddb65f547c199a16900fc8e806f4583c37426c047dbc75eff3f422669d367f3fa1500987afe132da7f58806e8e0e98f12da668a4f1f0a55108881c2b88709a7eb208a8d55ebcb5a951a487fbc9edb95a7f92de112621c97699957787f9c6f2c5d9015c7181d6f7a718b6d53e9b2ada896b02b45e4f31f4863da366318aeab82136b01b5380e54d81673faf1d0c055f34c67325a722c58b2935d995d6a37627bedfd1c237af779d34a45a24b7ea1488b9ac12fc8c7600c0c1f5d6f08246bf7400e6ebcba448761f34a909c74ba9cb9b7aeddc4bf675dfc5af75de6ce968f244a2dc79de748fbf76ef0fecea157bf1eecc218b2d5db4db98f6f8a6561b47835a6f217e8971d84c90c9f12d07b2206eea17827606ed39e326216f5bfb4a8a307196ebeb297bb549cd6ae451fb0aa30b9d932eb20c74590cb46a96f29fead908531c3923d5a283b3ab00a4ea45d3c8d84318f518ba97e81f30213a103acae384875ad2270d79ecaccee181da74d68be9041b81be8ce5185eddaf66b039b477621f9641321886626838be7732e0927036ce36a15685b1165e0f2e69d324f499dd351ac47c9f21ad85c4f4c8c45e99962eaa9c677960025f051dd101905078c1b38f481545fabdca1dbab6dc78c8c8cdeaeaebaa356273c04b47cee31d51d4c19d8bcc098407ca8d11ba6c75d701e04fd1cd0830b312650530a1ec711a9b646f1c3e777b629438542a6194be82b4e27138f2f45c2fdbef793b1c372715555bccbc8c4acb3b38e463a2ef1792fd42102f7d9ce89d5117f35b0da14025fd6d20731ef058d91d32f4dbba62f8013bc9fe4e02fdab430f231950be13b4db5a275746ac1a63a7ec86e750ae3d28f59d27695629ea3aa322f46c0d3ea842755669983f5e80af5f6de9526bc62152f2df4e3ac1a4e04c9f793ec6e77201dc24e4215a689b822e540ca9b7e96cbbf474babe8f8903b7be5955fb4734f3a4b1a62801dcccf99ed73a2c35b8084791fbde7378bebe92c2ed9539f29373364fbe0c458fc54ffb482d6b2b47c8e96f0fca6fb3b473085a29b8c548079724b0ea4a0e208d0fb140240fc80de0aa21bcef67cccc82885a5f32425aaef8ac28f14ee8583429f10c843670e57be9e0a2ad1c0f4c4c80fceb9bbd7dba4ade604d91e2a962417a84d10b40e7d44d45f41b01f20c4188179542a0c9947c20e6bd8f9265229c5115b1951e850473738cb6485da297a937e725608dc4f9956c416e66d83348ea31d7be940333209c9de40cd80c954f31a06e85e2bcedb31f45aefc35e398261163fe8f504ef8be5e91de4dfe4ceb17a1adfb75db5304bc5a70fd15c4b217e1dd08e2ec42d467f9bd1a725c36af01d4d1fe9e1ad92ca5788963f6005c94944c54f683a4e6d917fed1f71b2fa04e2ba75f9a3f2791a982968a9083e4f886b07f8ecc5e751f87dd29da8ac80a055333c17e306dc991bc95bf9bc3060aebdbefe92219ac04dda0cce3b1b494d139042c8c99a18fa5b40372a456ee2058ce4e7724b1528424a9cb89e4bb92274fc6cfb26f1fbbfcc0a07183ad701fd55da0e46bf29e0433136987add977760be87dffc6f2968a71cc8c281deda867a4ffe2c3984f77fe1b57c0ac67454056bbed589647b7296111b64b07bede79e73b77221a34e49b433dae469a1cb6f4f64e70eeda8e857aa20716b9e3110693241ae93970b558c1f78e9848d0f30fba9d731b90b44a34b37138869386e55748b5266a46231ac6fc527cc7868338fe6ffa92f73a6cf119ce54461db48f62c4132a3cdca62d03ecb74881c3368efd4db71c3f74b404b10e01399a3417f7bf60bca9f0a138a019539b67ac09388df5b6eaad7166a5be92d600a916a0b1078af312a52fb45ecf9d87b307cef1bf4d2f31bfe61dba700f10f0bdbbf992d17fcd509b285de0c27016544ffffd52d3c57708b9625c12f1615d53b4399f70ad0900ed637cfa35c0715d210c19916e7cf06474921f499b0f03f87c738c628f361113f20c79fea250497ffdb4b32d9985c04f4104e0765434133758832ccfecf3ea3a83d16d0e8c0212ab263e20b1e7973fe1e3e14bc823502e3be4a2c543531b3d7ba2af0ebb6ffcc4d776d379934551c4fb98b701e6b63d2da7f05ef17e7cf9761893e633dea1867ed06744fa246a7bac0ab432cc3f9190cb45d9dc93937e74195b9c2adec748b7ecba29f6e09d49d2154fbd0a416d2b01eaf3cd6db027db8d3f2608f09cd48b3e3113bf7e4f7f2e7e1c754f2768895f8295420b4c6f62626e240573c1c5ab67ce1f3db9625038fb3fbf6b0793d1a03ef6d257a42fb63608713ffa4a0ff2bf89c4d86cf3bde17830712d9775dc746d7ec5091dd1a2e54d9912046314b07772cc368459cfb830a24cc500a55a1501e48992e6587ea732d40b6e49774c6889e9b88042335e9c0d3c06e9d8a2682d57d8a0752bd29b2ae29f37fad4d13d68f25d167960aa09b1fe92974485375e7b0519bf241a236ec4fa12ccf4cad0029266d238239d9f8903732598c2719ab050748c0e006cfbad8c8cb6c6ca50298c89434359d638003324e1713cc7ed960d853321b6f5c6f7253db8d5f16adb27ee02f219733653b8608b8722b8d46ee99dc99c7728c900d284585c9c6763f67b02321321761b5ff2f828d85fa2a074832bc604f121090dc3137ca8a34476d4d54efe44f19692217b99eb318980dee6e964e92721544120c3fb4a957c798b0f5ee0aa6f92f860fe392541280fbcbe084921dfeb1784b6c8a2aebf1da7191a041c5554d15539afbe3724630aeec62f7fbe70e7ee9252a80fa40c3b335fab0f9ad67d951626daa02cf3eb5a1d1dd342651a79e4bebf455906e996e9fe98706c5d0c13b171b5c913321cefd0ab26684cbdf09696f766ad80a3783cd4ab0a79f3c4449014499e7749beb29781bee6a9d58f85dcae36a1755e4c3c76512a8d815320c815a564fde730e97bfcd079d386180486b8aff1e92d36bd33b16d70a934195246fd7fa9ebfa7c210a54455f19800ab415f26dbcab4e6704265ad7c02bf48d3ddf95d6c60af4324963c2351acec45cb653530a8bb6e5594aaf6fe08deeb1df7704c927991ec9f40d1007257e4a9a31770495a4529ed0f82337cfc5eaa25d625fc8a949e1d335f3c0271e2045c55c483c3629c0ca69b7b4ca29a9707d447e63520dbe7537e6b2dc8dce3128a841d38cde2d3fb7c940ca8bda768eebcc8dfaf1ebc37357020b183cb23bfaf635048977a1d10d6dfe2c0f6918631683ad77eabbb9ab1e0723cca44cca18e7cefc8af32ae96e9e6c61788f97d9cf57a94c0be9a9fd552968035ba0b98fea853c4338edbe524e7ebc87740ee019eb228a1c1dfe6a4f425d2fbcc751655f80dab60c2d86b3747eadd0788b6f56c9895ec51c86cb47b88a55472b0efc522d1a675e8b326f69455d21767a2581b2efb86bf31749b8b4df5c1c85ad010228d345def5028720b98725c45c2debc1bbd83e407d4a2491ef95ce81d4fe18d510997fc5bed991277527771dd2a1401f794ebd1d8d810975cd1edcf71f43ecc7d29da4647a2f70c546b9f68c467b516df7c1bdb3b1f7ad37ada6dfe894f42b2216cbcd5c8338b848b50ea138fbcc06ca99917a5eddbb260d8385674483130c47be9c461b19d2b9ff8803cd2463f88931dd43e7d3d58bcaa99ad98f7f3c8fcb3077483f420dbf4e37ee3b05394f404c42da7c49dbada66f0dcc968806e96697020d8ceebe765271b6a8ebb21c6d3647df8c6d8941e5d0e7d5f73427e5392a20709313cc006aa560614c37ee06bb05e7619578b3de9aaf6c09bcb9806a6d1c9abb5bc6b295b3db97e47304fc77c2d976ef04177a06a2741e54ed4dfeeabcf72a4cce4dbec51da7c3852b8d383fc85108d33584319cbb2989bde08ea02868925ed980a0f34e130f2f10fa977a2960d9f3c6555e67d7b72872ffb29d009343742b494f79f4ac21bfb0ab5b757de96b50d962fdcf9c3eefbb288fa68a454534ada1a117edb041e90ad99431498e1118f9bbedaae890e3c8f5d555b9e727fe1fbcb54bc6451e3c016ea3212083e18583bff9ee9d9058056c3b2f50a6169293e84b0b2b970821247e357ccf6f951c0081c314408e9700dfc073cc7ed613c3610928123d7e3b3ab0ad9a412f06ed6a37332ada9a88401bbc6ddcc22aa23bb69a8c6216ecc2d6734f6f1e9a39a37bec570e3ebac31004f09a066f05d29b5e0fd34d76a3f844f03f8a22a1f607778c8132bf6801ad74a42a08ded675619dd5712a9daef3c79937fca5a2ddbc113ecb4217a2a17000ee3ab1a59a3bcadb29404be3af6e668fc79d0520808f5232f6876530975bdea89104a84e03a185c01721cc517980dcd95ab96f851ef0117e71451bfcdbabdbcc575c29dd70bb12eeb4c4441f0e8d6ffe53502244891512ce643ce8de8e9868027e3462bd4196395d7633dac894a877ab04e1fe5d4ac6c5f412a077a2324c09149505ea7763340d31d73e018839f737ed65bbaf2ff029cd511ab95b414ffd8ab698f36f0f962184468651cbe5c5eac007bc684141329611e5f85810e452f215a816bee8d196505e3407b9c1d4506957ba1f3fa686395d8e737bb205edf90d3321488eb6c53ffa97c7731851eee4d15bf58d6c984e5e17466a30a75f278786798cf980c07693c448f8585e14b2df7d530537b535cc36fd67aba1fdbc404c38d3680a3e7b4306fffdc9c9f3a35799456893ac8855ae46f01adc8c9ab8aef9c0f14b9b7a96eb1df2297f895d716fc53368701cff1a7c83e9ff680d06596112e3cfe6e3b269fe0dc5d0edd1fc4b1673792df9cd8d0819fc60be5766cb950a45521e2ccb2352686f609bb3bc950176d299974965096b8400984dd3059c85813bef6f86f004a495fbd3f1308534c6220c7ac816f149c1148843bd039349fa0500a28fc3ee592b2026eac71230ed6aeced8483438d76b5a522adf984c4e0bfbe3f72d4e7e7c20666ccb82142d0c52fd01ba6d6012287a1436bb07374e64a0b5220bc61df7e9c1eaf6edb24af7d9cff9c08535b94b78460b8411fe333d6950f85b96228ba7913d4ae0a2cc10f4ff35e6093007108fd4e584c6be1c9e1d3b1a5b73194ee03276897d096de325b3a61fc466023deb3211b47ad788cd4db007d1f7ac17c6ae43fbc7e8701810759c069d1cacf34ce7083a4e57cb7f721e4f6808479f084d81ef42b0a0d6d232c2ebf77e5971d896851359619d5e36e8a49387f044aa821edf35e330f91220be5215834fbdb7d1b1616366048cb569439e496e51b89d31af72821d54ee67b00bdae3ade95050cecc7360c4d0ff30087d52b9383ca4e746e543f12c719f0ba0db5761abc1593ef8e8b8548bcef3f733706772fbf6e5025a7e1843d29685cfd837a190fabb9b1d6d1f2e2bd3460a0a92e2fbbcadc2655008a549adf0a77ff0b66451afafb78af2cd64cac542d210e95cabcd8ea0e117c4389434863aab5698c418cb331c2712b1504f76b232d0f2d24dea05e823821f9a939bf445b586a03eb1e6a1c331a855cab4b6f96ec45b33e2dbc3ea66551d030212e3f8bb969bd1345fe151519264f6b54318cb5e8f2f3cdea90159fe44b0e8ac6afac4a6189c370d033f38811b70cc40e4a71f2b791a310db8b702311bb8323a4c2515352168cceb8afc7c42160fd851746343146fde5e69d25110970eba985fd5bb3e74a696e3c0ed199dcd5b984ed7705047412e968aa44c171c6d823853ec177f4fb77950bb0b49c3bed6df80844adbc4c1e769ccc2cff401ef2e5abe2d0cdddaa743dd445c8221b1a0d8d6f93ab19a4d7087cda0441f1ce7926df02d634eeaabb3eda817024ed9743bb2722afe795d1678b05711d317686184ad7ec19bbc5c8745d5f1d5058c4514819f672f6c05dbcb612cddb76963cb361bfa2c463e467e99249bfcf75f36ee90f34cc25a8352bcf755c299d2146650318dc76ea31edb53b9ed1443a98e140ccfcaffb57289fae94a9168490d4cae0fa103b511db437137b05e021d0d93cec535b6e7b0349bbcea828587059dcc723b5b899850fc862fbe13867cd524a74b2abf8222fdc2059833f6465bc202af1e1b0060227afd5ab13986033446d3d8234dc08a5e0c70b8320a7ecdea5aadb9be8f01a1175044a639121f87bf6b448e4dde98c84ee3db7928c7e196448d5bb5d5b0701759c539126c2e6e9318c2543f1c8d624e8162f13120e6ed2684ec5d892696937758ffc34c57214bfddcbce4cefa6e991119c138d1a1ec9660c14b1b36ee5c9482a9f4504620d26a84c2d814f6e4b70e7eff46c4fbbdcbd96b1044a5dd20eb340ff70fb70ded8bd9c0db84bc2ce70c28b136c0c8228b88b7a9f45764ebcb9c6c119c795bac022148222f70be146d06fae7565ac1557240ac10f71102ce22c711025eb43a78c4e565bb9556d4195ea2f8b7d1f24948f568f07be462973ad9f211ce470eb45d0a02c3756d763d047b7fdb403db0e3ca7fbdc2fa5c1793b4c34622e12cfacb95013d3ac09100a22e1ec8abdf489652d903ae3cd5c5611dc0be89fe4f2ff8ab73fe78096f2d8a0e45dc92d56a25ec955c5ae47be4c6659d7cd24780544c145856b1cececcd55a119e6d79aaa115371622496dc278735da6adc7f7f2597319993c382ace1af2dd858b43a0d71ba295ec1e11ebf983af21c8d6899110eb2179be9d0845b5474b14d132f3fd8f307d401fd7715f7464fcbda2e0bbbb63a360c49923ba5e84a33cffd7e34baab81748275e8be4f1847645b364eeeb87752706ff2a42a03b2943a0e27c256ba05d8717d76adde6027aaab383b02424ab783fe41ddd50245f1937e5f95e419539fc14648e10cfd23dc1016c26246a1ecd6aa6d3347768825b4ac0d947f42828849651fba6ef5a62b59fa9f25e8a1983a9c73188e5d15bf4f487ad4e65b2b2803bfd0d2968f979281c18d88b76c689c674b00bf458a855fb921f2e3daec79c6f29b9beb173666cd44fcfc1d8e93fb45c2083a1deff52658b56e55bcd259bcf237e962e88dd4475423fd4e9405001f731c4ea72487e95383bbc292ca0d99c3264f5bebaf4be8e75ed84e8eabfd60103e8328016384e464bf56df43bca2f8798bfa1fb2d709f7f61820d37ba7388e0cbac016d9994175c2a97d49c5518f65bea513940422408d374ce5d6542e126078b20617e3bf3181d1dea913cffa41195b3e37ee2f3f406d96942e7816222858e8dff8fc4704e245e9c0e2cad4433a8fe9a84ae8901cbc01e524b2b3ec1f4617515668463b9e89d2e1ea70aa392de2373a4893bf4e04722d511182d72787e0bb3ba0d0e80caa3400756000221bf8b659958ae055ceb23a323bfc0c77e1dd3107a15f6f4aa0be16eb17ed8c58163e33deace1a8d57e6a2411ffda253149f792c7fed36aeed2ee278c7582d0a2dab36024f7d0abdef2b5512e483ef5a04f867457af0523d3ca187968c0f569b6e05838ff15d39a4bb8ea4f23258e1354162c8d462329faa2f3ebfd6329672c5309d788f5179112e58f43c03d35df9a0df627f0bfbf49eca1796f385107d26dbcd85132780bba2a20ac25979fb1e455d0184c1dec68500d8ba583669e07a8b2d6cb48442080eceea1b4ea6cf37163a5fee6b4dd81ca07eadc26aa8e730b59cb0b87af3dd4a80ce541b40c03a7b6fc8d6d122b4f2ce156a10ac6f534ae0915122d27f5cbc3e7f781ee660fa1218ddf42bd426ebdc916eb773fcd63abef5efede3009917c0d1a4aab1957cde6323b936f3de947311b9bfb620732bb481fd3006e50b5b86bb144f2ce7f1c696e8dde4ae0f43eee7b6f03f7c67e10a5115c2d07b336d392c9962ac0dbd0e498d60e6630ce2f996c1ec127a72f3ded73146361afba94894c059d5162da9a701aeaea8691e5bcc7e5264d983de48cd695178e1547628e14d060fe00ba456795ef3a8080fea7d7394224c084a520eb12a7d809227b77c058604fd7a8bc2e41e0a7347675e9661b5b27c0ee34288b2179fa241468fa492856e3fd9daba4b6c9690a4d6a16a2c6316dcc8eb15058eeb277b15cbfd49909224fba80725bc9af3cbfd57d2cf4e0d70275b3d8a70c4211f54bcb2fe8ec0aa9b357355bfbcdaceb54b69bd49b2c7a5448a47890211a70280b18e40c1f57abefb45bb4ba238d99bb6c207e44b055a822c19328849abb036bb5bb121e1907a891a74700a26b4515ebb9a3eceb152f6226ec82e2d277b9fd949f8713a30e6cf41527f2cbbb06212d77cc60ee85a1e4d80842c39acbec780206bc01dcdbf870fdb26f4bdc2bce066437f6a9f3725d77b7e770e78f15a024fbdb6e2d876be931821dbe32356a9d0273d644afd94ccac910f944697f75e8c2c36aee416825d2b44c4712ff08ca2cf8b94031715fa8b0fdbc83ffed6a313937c56097718ee45f29e299cd3fa2232ffa5c22a5ab99fcc9a3bf439232859f4d39ae16dbe302349ca714eef5d9e13a4322ffa61c5290ffeca9cf6ed2eb3d4dc10db8a1e644c59e256b199068e4a62edc4d9160c421deaa14e8a3a7a708a423a3edbb49eabddf149522fa0f2afb4278baf7754655e3be308aa88912ee59d86dea793d2943ccb25031492969de3c91a42f33ba301a5f10dae13903165ff467db10b05ba2dd1f306fd2f6a5b429e066bea6bcc27b02cbadcca9358622f945def605f6c275201d72f1c7aafe0bfafb357f8a83800cb5914ed2c862b3d8ffb2ca3251fc79fec15971bba34fd39339f735ae74a3befeaa38d0879bc47116f02aded25e057d030c4ab20c3882d61c7ce8b26a015b2e64bd3a00f065ff3e1d139f3c859f5a35aa7a83d1fdcd28433365554a1e8358b5cda6e43c449739cdf320403126cb0a18951797d2d70c6c966bc1f90fe661184cba68775d1d336eff74c6bd5d9f141bdc77192b9e0353b2923192855f8c6ba41867a48f3265120fc87abd639f40860a32737f6ab6695b028b709d15e09576a2c4a2b12ad2d590f4665b5a0fe1fadc64ecee30c5a8465fa9d481ed6c3a0a921935fd1b008887b20047877c03241bac4ad268f06c270c660e82f7fc67feec0cbad8155918ec669d7c6c877dcdda83c9229deea3f7af84ecafe221891d87c78dd1f775c5ec60e35c46262eef48dd940bf0089e20a8f8f237a4291eccd8f2dd3fdfd7858194a64881871d968615340a04a951dd7663f833cd382b3ac64a9c31ac483eb56abeb1616ab1242df33b53b2ed06996f74ac3300eedcfa8cd0061c798da2ed99d764f0add51c160f6324f33a6613953ce1d0560e0eff38e4dcad5a1079bc94d97016993f8326f1ee98f53ddbea9799b79dd734558e8f767461ce6a8e0d92e9d412cb46e746b3f5294fca636e3eb66f0d667c489df1c12e42f1286b51babd5c92671af5ea9c4fe9e64302ec52ff9fe2138474e6b62348f9085802d852e34d27c8a7234d515481e1e2ede66ab3d9a155a718beee8eba6d4cdf5fc0efa6115e8b098874ae6196c3147065120494386f363167d600331fb4d35f5436b8b70ef22e7cdff7f8a47112804d1d6dd935b20536d5d0e02c8dd11dcb6f884e82a2e705f8377b95bb362db26e749cbc778fc3bd50665d042e50b5c9676cb7de2e9a14d7cf5502dbd70b132bad6be215af8093168bd20ca6fb5284f0f1f7842206d7243722d6cb4662fba99cf2ee1e8f30ca5e0487ef7620ab86ead50257c4d84498ccc954f009cce03cb4dd414744065dcd25172e1dd35dbaf308ef52aac6fbf81654725e3bdbf57217e693c34fdd457c819bbcad66e0e62675ad45c51bfdd04a5568af40c2c01c2ae2a9074158e224ecea8ff5f0e862011396377e749c3d6a8f0ceb2deb1061bfc7d7bc7ee7566e4d883647077885f1b13608de2b805e10b815c97b984a6d2dc9c45c14269be7517d49d7558b9a62285b6a50e3e23306630b05491faf59c12a1210884e65fe5356361487d7e3ecb2e65d0cdaf8580f0413093bbf432fa0521af2d0572cbadf350f57d6f0bf9059facdb4755e6c2d5d4a7e018c4e2ef2c155c4a4fc8d4b5d1ccc91df9c2639afc81a4e5185d20de3ec5cfca8bbfa655481a5513febebe33cad5995b15a147a0b41f845fbf0fbcd48dffcd270bd635bfc8bcae0e5752876bb155c55fe4557adc0ce16a47f8df1730087cd6835a5d82db178e0c132f064198acf9799e6e2b6899ccf6e0219d9ae9013cd42cd60893d0fdf5b9b1dd44184d7d77a46fee2778f43e1093fd0abd56f03746671035f263040a911e8cfad256ada8e1b8f25df98cff2fdfd0ad21d5025eae5efe3c498a192427c4703895069141cb540fc535256774e5016a2e2a12a0a4f7b442e30cd482ab403cfcf4c708f817704160392c574860dfbf56e8517c8cfa86344a594f66df196f6c8bf5b99f05468976f4f67f2871d74c979067734aaab8f62b25b5e2476fb06524737383d8da712d7843155d66270da0dc250bbb1452fd4a47d1af360a7a9501151e24b401cc5d214bcb574295abafeaa40d13996d4194a9596c7e16f86b56ef27ef34ab3e06e51571980a3904b1451ae2e2b9e2eee3f89a9592c5f6aabe9c1b590662eefaed16f2902cf70844e880d6030ce939cb59c310426795e1f98eaa111d514338ed59fc8763f0342ba7647ff22002062fba85ba4af772a35b1886304ed71bd6b5dc4c4ba39c7867b7d5fc5035c900a79db7533432cfcfa713cadc8fe21c9bd8fee352d932ce3246067ecb22615eee5b7bae07302efcf0ea8e5d29ac2b8d1ee7a5e17b215e58f7b0d77196b820fa4723a0511d1b605c1da993142155c836eec3a9be50bed0429e09d5a26027f19be3bf78a72da867730659e156c9cf53c74e5914e002b87554308ad4b261552770176870e5908c47c8bc50c82f4e56153f90d5bc046ddd554fde17865f37f98f54e52947ad2e7ebbde36681f7c9acda6c17195c95a97f8629b7e0fd950415f306cd022ac701b6de6452c5476eac92f77bad44dd8dadd1151b799241e7221447257cb152eed6412b905805081b7ee95b00c8dbc330e1eb9afd8c68ce07b459f7905ea8aff33754defafb2890595b92625163c65a8d559c4f5c61456827015ea620141045effc3dcc670ec4db3f7015c3e8d5405af09a0727da23d3251856b7efc201251b11576ad6b94064cf0a1ad3aef95cc9d0c47006374e0ba09a66de46aca9c9a80fb1ea607a72f4e8e5bcc56fe3d37bdd7f1e5d27078fb43a16ae69e465ab745212943f5eca1c535d98d499e32daf510236c6f4e8ca4adbb415e8685c809cd6ec720664bb7d967e09443424342c346d90b66af84b7fc1f70fb4f887dabded720aee8fda7c3dc705182aa7b27d788d77e0b82b226f0ee3631118d8e1ad7d9bb0452c55fb50072d5141d330840d32f2771142cebbcd7b95226eb102c5404bfe164c18b7c8f6419d00cef6b50874788876e696c81c4c2f40df8d2284604330832cd1176a7f36785a608a5e438d520d0c901daf6a419e6fd7cac92187792c094dd73cbcad3b815aeac484f24651538b7fcf585e62c647faa2b2c80ce18db3665039ad70adfbff4ecf35afcf3b1a63be8c0731066955f1ce893d17d394619698f9289fddff6f27d650b1bbb08064c8754da2ef5234c55d1556fff487c44d647a46956fb1368b01063fce711060db26041182f83cd84093125292e4607ad6022c24a2a6c924323d3ab24d0936a6699d9ad16a33b3542baf8dab77f9ef22880b63eb9238c8ca10572c520550a7820ddeb29f45c7a5c5da37570a738168564218541f98c80558b22c3008ad9515c6678b54d7e1ac42cd32c3d5927f73bd9629b8c1ad3cee6a957708636a9de2487c338042d11ffe3214987631d266eaf86a6f3b521288ff5556f86df6ec470dc22fb247611b5e8c799c2242b30fc500c2a2f160245b584fc308536e53e0d0c797819bee866d958295cd9821b4c3216c82d7c6f9b923ec1c2ff29076b978cff0916ec4827ec41d8fb5bee757731596a581b6388db27ca386024bd8fd2f1e44418ec8b85911885369b454055bc9c11274fcd4d2ab5e01b7fda4c4fd2d989468cb6f9cbb38aad3c257730be69eea235d221421f8a2c9aea1e996e9ca10b7d9d17357d449f6b1b908439ad53b455a2a5798938a2e27c697ec1595bbea97345b45f599d505725e231b47644c7be5c7ffb8a3cabc66a7087caf78e8329e42134693a489b726ea94b696fb4fda2039542809b026fd0a14c9f51bb33da3966878600015688cf38e55583c6fbf03f04aca445acf29aca59350b2cc12cdb18ae43d2a4cbc4e73f11cb2543178dd84fa052170ca8e35d644eb28a352881f43d451efc7ade9b00ee97ddd6a20a9d6afd51608cceb779e9d0008d18dbfa5f66e18a0939eec5bd181c9fcbb905dd3d52d8cd749e67f4d5e5bd55e28b226cbaf607396b0bc35a2649850522eb622ebe81cff8c19886391738e4782210789519f4bee427eb3ea45082701decede3724a2a0bcb7fa8c4b0e2402b1dd03de5637d299181aa1838c2394cebb393fee0b419d2731e0c85901430fb17dc440500b1afa9762943404e7c2db6e00de57f4573231eb3ba371d3028506674f2211f24b968250471e05231515fcdc7856094cf8b9c8866360f7ca76f0553b139628906424196a4c87434c75b99d8db3b0a23c37262a9cff47a16c5e21d4d35c27f8fdaffc40f19cbd3908f30b45f4cb21114fe98458d4ebf4823a1aec066704d561131d07b1867582c05e4fa1f213d941fa87c5f7cef40cc79e68b1a6e465c835c9f0ce018c9a8e4e361969a87b0df9921002afbcf6908c14d963f8cc7f931ea6e09e8add38f7f2bd33591491feb6fd6d0ee17fa41eaa3943818b761de0a9b754f33cc56602c0f9bdbbd5458d5b7834a80236eecb0036e2e9589bfa37e8c24277714356cbcf9ba8667c981de8242f0d5e0f699bfd27ccb685f47ba9c8e2600c5875ca8575997aa07ac0eb6c9108c736ea647d4966e1fd82e88e8e10455b50643cf08b87fdc0cf73ea39394c6c08260fbb78735466898d05c3d155f265bd5baf7f5529955f50e9e249cb9bca592fde3f5bbf24d5952fb94dcad50e669a45894c0b9d1f93887c3245bad3bc1a8fa7581a1f1187affd95d3d0bc1d78677d11e557e4a148a360256c1a5d1701f0fbb99f6a049ecc23218496908960e2df3495de3c40ad755b5308dbdd487b6735fc5e5853515e3b409951d8889d4313b42160cfbced74f4b6a8579f157906a62101b8ced82f175c58a348c91873acc565790765630fa49a2d9854de90ae327e58f9e767bb8686480d53a11a48bed62f6198d6dbff2ec1cc1851cb1bb731fdec1f9fc6a2cef153a0a8a73094ddf9b2fc415e2f3ece869ede556903db249b9a9bdb05762766f7cfb6b8e0aa7b6ad76753c4c0efcaa512fb8f2c23e3e31f68ddd42ef00c72b94f63155e5a2436eefad248525b800fc26ab9b5728097bd807dd7f9af63547e580b6e27972396b822df51dde76d8c97c27cbaae2923d4ca9aa7ef7949a2fbd049c20c89fa394adb67bb187b8c67a2046e9be3852a0fe62495cb218fd100024e0acd9105cf0f06f489f7a76727d61d87c810af25817f1f0ac8e46212974bd5bcfb57a24710d278a4f23e06dfd9a45c5b05c7e218f785e7da119ad604b01d8a310c3b41835be6205945c78975fcc888a13c4f679999eb03a26660f10185fd62aead1be03314a4b5e9699203320556e15d797d40000245a774c60b3f765e91251fd2e8e1514c4ff3960e949c52cafe13fbd882c22351a25b167914432ec7204f7ef5a3593805f2310e7a46f0d9965659e63e9c7cf83813909edaeda94b894f194ed5abb203c5b4b25523427dd58c6f93588cafb9391dfa2f4dc45995e7d68de676b7c347a4424c3cb617564ebe70aa3acdd5d0f70a1047881b5ece599c87eae840462c3ccc55dd10b92b1a5e7052de9ddeda009d0306a484284521df1614b417e98f319a1f854227122aedbaddb71b086a4d3ace09804f14b719a44c05384a98e50289007ade90c5a9b8de92e79a689932c2e541bbf73101c14b0aa4011997b35f5205af36396bea882ea00c7aa601b9d93d97396c8034d360b6b48dab768150b065004becc606585a1a1800609a3b6be234053a4f3a16b66746beee5498afae44ec3c0d489ffc356a584e3db10a51f7a98ac0f178df791631a60df5cf03e14ef0ad8719c643af55f9bd21b912c679e8c6dd4b97b3d04a81b614ec7e27a86066e5abcac7ea64f7b3c2e2b9e3d69138e7b0857be3cd9c694057c00ad195b53faaed75cc4bc1c1aba3c90fe1133d03eae208008a330411d9ae0e0736f942d47c397941190ce0922f0a184391aff0e4069bb928c92c51167dbddb4c5059619792c7b231c267478846d66dbe0efb2f654dacac2dbb3398fbc431519bde95d181dfe9c539383e81b1994ff8ab40f2d364934c13846a4f309039f8bcb76efb0db8b60633643fd9878332e6c2fe4c5863f16a119ff05645d6ca207cda96b58517e93be99e6e5a4fca4db4d6b3f624fb67453c4c6d2d9c21e47db291e4aa1aff9b93731d2c573274e6242b1b9923650556ba5288eae46bb45d6c657ec88017b7f94aa06573ae2b407440ac6ed3c7bc1c26c4a2f25ce1ac1db60b93df83010826278e8a82a498be80c0dc6fa0a0cd1db32a7cdc27361c7b954c8d3be96d3496ba69379becd80e030d06c44746ae4744e48c3654404f3494cf0b1816bcb38c7d9a886ee4f6843e53dd737411d2749ac3471361a0423bfd35e99a3d60f571427c95887f13cc7241b6f1d494b3cf0520e648c567415c4da2ddc24d5f6df55b7fb801780a494b46522aa307aca4eca21de3575ff87df52e06a9368eaf06e579b30c8d4bba09c6ff66c98a9576dfc17756dcabe8779a6e10971b527c488a4a05ecfdef274b9f95820ad083c3eb15f23f85ee35e8c866c61bdc8f7078dd25173de93ce03c2c49e5e048800746825b00deda9ecb532b8a6446e7ecaea33688780e66e0e66fbd4fa0c7ea983b5433014afcd8ff541006e4e389d9139cd5981596364ea6a40206c040097ac9dfe7222a1e2057ffd1212799c8517337d2e51c92da3ecc1b6b6c68db0bba504bec82cfefec2808daa7bbcc3c76581647402aeaa0e547fca7a919d03daed2024e31ef704bbd68f10173546fb2dfffba5b8a1e08e888fdbfea148d29b959e3feaf8997673dd62a3f85acfbc43f41024a268d02651055feb1593b90c660e51fb1df9c423858dd55bfb0a006b68aca95fa1260bedabc97cfb958826a108f5e4a98b442aa7b067d9f50dc856521a8a6494195ae5f2d71ed4c7f8135b193ec4a58b80ca33862bb3912aee78f34de12a381e0510a531a19b611efa8a8936d73cb448df74cb38c279b12156d203f56ec264f5c6d383739450a245cd6edb6ea591534f9d0ce9227b8ccb7b2fd6e54a51e52560dd130528a6c53138d88c8818175d5b33b78f9db1a0802a56a7bf4cebff5c936bdd2bd5f7e4e2d938b927c1f9e3abb4ee4a4198a05a4be122380bbd1f6835cbeb39382195d4ab1c0d5f0aec4d28fad9b18467d52e14c498153046db51cf6ac96c7565bf9f0c1c2597b2b33ba29d6c29c8a22bbe4050f28d38efcbda36b2852a2b66388a267c9b86ba016eac28a0c8ebbcb54952587b275a1de73efe4128def33c6c9769e762fabb9aeecd8bbff7c21d94113e09d5b15a4434d3bafbebc907d559ff17fc22616ab7f0f2a3a610f173c7266e2294a3a245242a6631d37b4985448deebc01ff6c7f29c16f9049fd41ff7e81c12e00564af9b884c15ebac64d3ea37c19eb1350c0048ccd4f70bc0f6b98844d4a5e90c90f6b8db8d94f4efcae6ff508ebb07634dff4ec4aa8239a135e08527f33b64bc0ff46e0285d0cc28a3ac7da5b719f8505d1d8ae98a179f6da664a18b85cdd44de449be823a27a2c660a093684744e3791e9147db721bef1e63ba9cbbd853d4ca987b7c9520128f18f0db9d441e60d614f02011b56f5fed84143cd2822207c57d246548cfda1a76a3057c6324a8e660c8a70ff2a17675f9105eb09e3ac4055922178cede0b11bc333ce173aaf5f457936770fea760e0a16e7be610e120e4d60c10c580f990810dea9a6ab87872a46d0ca24cba75cc1f8f83416dced97f1022953431f30518d122d198c5d84a99e8fb2684a10b36f0dc5563a1eeb0deb5a0340b96cefbcfcc5c360a964284b1a9e9d8bbf50a0c8e50b9fe1b8b32aa4da399ec7344ac063d25803ede79277c2e18d45f8468a2ecb9f6475ed4cbfdecdbf647c430beedeb5b3dd42c51354cab8dd38416894120e84c0333fd17af3f8bf8c8623b7b9c851544920b7a6f724c390e52cb4db201fa9400920ba597d7b85aad75d72f0b46dbbd3388b41310df639cd0fa9957076a5d3c7fb6e5aff9c08f5cd3f896d25117b19e23b541ae4824500742702b21ceaae89b1f84d93364befe542bf3fbc33e995815e3e0c8d49c42b7199f4d2b34cc8bfa71b21bbb1a4d6bfc7ba51430b7c5450632aa4706a1d4e4a3843f0b9a73b64af21ab0c51243d7570c1393217088510e27a52a7c039c2b206a63f9086b3c8c7545c165dc59f4156f144b92fcc0690ac23090b742b492e5c501b6dbb0e2f0d5bab8d8ebcb4fd3ba7832ae7f37312244113df609ded50832c94afc90d8344b2706c3f867c3193abfb5e5813f8e2fb4996fac94374d0edbbddb8aa255aef377001bae8dde92d10614cbc1471faa49ea95d19280175d77a591baeff164da60c704a227833e4ecf3ff4c39140c7fd2f232de7c1f34001b823292efa9fb27a84861e2c0f80f82194331bdb9d7ae519027e2eb70e0838843d6d112197ee09420a218dfb08bbee20e24ac94beebe56e99c32d4f3b0c6fbab49dde31d8385cb5c6f9952b165eb37ef2e02f645bd337926d57250a69a9c88a7f3f4d712e1f7befad0f56d75099ad456319f58d0024a23c91730a736b43c78fdba7c81c470104ef91fea66025a37ef8b9499fd5caa5e7ce40a70d9c774116dfdbcd1bb5097fe5cc7c1d0e44bdb12b9bfb1a47211425977b1146853f145c9e6f1f8bbbdeacc6f69afe0713ee77bf63eb879b41182f8b8572339d50d9ce8b3f4bb80aa36359b28f766214552e40a35dcd997bb83a5b963c38351233e67513d1b39c01b92023c9df2b2f35f4a1e466c124936409276ef4f3a7cbc4508288010e8ede928ded63dcdbe3f6386b8a31774c1e8e1b9e532d8edc908d9846c324d82c1a679515b30582340bc26b1b277a77066343c6195034e2265cf9778afa2b2ff8e49208ca09e26be65883592b7f5be42c35df410118dd1efaaf0f18a1a7564d58b157d1b32ea81bfa1354e371f5481d1eecb5a26e8a6294ee4e0b367dc1c4f6e9ff5833c29bf613ad8ff3b13be39ef6388bb178c9ab5100560e734f35e4576b9058b997e98a784e8f198aed8fdf369033b9d746c6a606d9c617db041f1f471cea83110a1a1b3f880ec46ef818b7bdd4bd0a38059e150be723c455bcf66b2c0d420ac7b638d102f43a331483a95c8b4cd9b084bd6f8b757e71c3762d218a9a8b7e949480f699851f489216826d89c1f5be253ed436f934aaa83275c2fcdc1d616dd972f403f0e01926e8490e8a022f7a0acc67e71dd523a825d9540f9136876e1471db1810cb526422cda5d3edccac1dbb63091e178c64c96475d882484c716aa63a1790aa26b307e3416add2dbde9ef7fde58e68e56b58471efa74bc97b54aa18221b7582c030832c3b1a20398283f874c4d9bd8554954c874f4e40abea309c9d0e87286b533f961f1750c2fb6ac163c2ee6740bf510bde1ecb823919f7120bd269c0bde2a8eeddb3d7f7ffab67e0f61012fe7b2e519c6645288f9011b00f214767b86d025a881f8635d3f76d74c9f34784a6c718f321fea95e034c3fd44e78201f5f6f475b7ffa1d0f1b9c73ff81ff4ff188c81d5ae18a41103fc76ba6caab5e484c951b5b4c5dbad550a0697c81e172f51f0b7be3fef5d1f0a1f86beefb4726d62f9ec737b9f880805c7940cdf7f0f6ad84ff23f08447b819464677cfe33ae9c2aa74f3aa768c73875722a0f5604e57bd61b89213288c5979a66687832eb97f5e40c7f4220207b1cef39da3114c7e77037b3f1325909d854904576c5d45155bccd0a7ee70e1bccb94a24cbae87c3aedc6195b6e46a7d55a18d419cdb0d1e5eb570e01078cbb9d45220ab9c7e50480cf35dcbecbd803c8816b91c554fbc4d8a8e00f3ee1d286534d7acac731cd823b803772431777ba3ffaef22d3616a6f6f8b55450809b72592d8d178f62df944ff9f5ea6a2ad96164ca5a3b94a92e40fab695c5c2e74e7eb864ed7f32686ff83a9ce8428daca0b9b6f625ded795747d048303cd69f8435c15d21c3e806eb0fd989c3a56e8be31cac1d92c13140a5d6a7af886009517bd0ba319ba8c82d7a924d0d7914cd9aa52ef5bb12d0bf6059627d809e5eeea340e5c78dda7f6de59594ba28de80a426574a4dde5bff857798443a35bc20e00ae99394a980537a3b88d77165a4c9d1bada37b71425ca3f7316c1b448561147a9afbaf8e1f0d6c9af1cb0bccc168a97f739d0de1f57c13cb4667e4d6526f6efeab3e6bc7f5ed8e13fec7b098f0439039789f1da2c476a8b86f136cfa08f69799acef6e5224a1dd7b7937ef64da1d8c6e5356a67f3eecb6bfd52379f56b12e8cd983db88a377b14285b196479ad5ec14f033f52ba5f0c81af8362a848c96704ac74727c7138565fc2da7d45394f6d5b63d43f2ca792137bcf2644488a7f3354aa17f040659beb429e9340f9b3642ef7ffb46f50c0d994d4bb75ff992f44f5b95459e3a84da2a50be887e2d0046d2b670a5916e79f2766f5406ada7d2146c905dfee42cbbaa896bcb5e66615ddbfc856d9b3d5777aea34695e3ae176cc2bf73549a00c570d1e5d673e130941e8bdc6efa88ee89e4c6f0546eda630fc36cbbebdc00bd918cf0ab48fa6fa32475b0ff143214df77afaf46a298f9ed344c8d9507e9f89573fa3e598633e022b97d3b122545d52ba99461038ff1e129f42041c281cab26dc619705ee72a6e8be21684e57a2be51beb5e299e39c0f77d8d001ae3477efafbb4a759b595607a870eeb696c0c783e69b56041441840f5c65fa1611487de954b131fca78cc8f76365eea3f3b3615bb75356f98f339e9cc23fc21af1af393b23f24e546d4a5e342391f6a1b2758b0696f2438fb8ee5df0038d1b768b2afecdccbefa1fd6e41b2a08a9a49882bfd64f3a50472f59bf43baeddc58e766b6a5d50a2af0bbf22513daa557412e4a2b95f48726842479c0ad5a91cee082a004348024b6b38718e47bc419dde81811947b6ab5674e28fb4723b56facaa6f37165d12d9eb5642ffe021fa30f55db125b9f88af43ec6a31b585c5d60db59720162de20502687437f1d43f0fa51ea4e48abdd7f6e95d2d1fc02e8966d0b26383df8debccb54efb473d1021b49ca5d297e1142633e0eb399d2dac7a0d6beb5647735c5d7553e7b2cf04df31bc393ac8d9c9268e7ed927ea44250feb11399d0a8f8f120a793398b0b952087e51cb2b24ed70d29e9326f99ab75c8841747a87062aaf2b5ee2e5d711ba89861aa15a90841f0deb2c95ad523cc02cc3572665ebc6f6dc59b26ece9d19740f7ac120b5754d91784fde6b4efeb6e85887519307340b2434b2b39cf9de715d11a8509aa4c26dd43d0fc06fc4596a83f4a5b9b44570d5ea3862d9dc08ecd32424e07227fee35b35b0070aa9a9b7682c9d4dd43452340799c67ba9622fe2f848e517f1197e9b9ebb18afb097834245be5f2ab5bf93c5240bd93e07f78d662cf518e71fb034eade66b8917fc677d59ded18962cda10b579d50f136b7ad9983a461e413c38168791baa9a343835fff5689d9ce4bfbd1d2c6cb6fa143d7f256d5c6385b836143cb7da0a849000fb3de1e2944a83320acc3300e56c2ddfe2c72e0fa0d6d828b8bab1bc95da56b5a2c51435b8864a063f7d3174462243efeaa5c3579c7ed1106253ae78fdbb25bb08486a0aef1065057f79bf8d8993e511098b1ac8f1cd08ef5305c188eb15b674f847e25fc2747a243e2c70d7759739d7f1218e588c13456eb311bad60a9b742a9bd7fc5730ac1d6e3e909c1a419a5efc83b6bc644f86f18abc7a133b07468ccfdb09ee804c96f7d61d767b74d95c5129691faa73005ad6ea1df9a3797d5b464ee9021fffd95b6eafa94f4098f3032391ac6a61e95e4c4557a6f90c2e31700d269a4c56c1353ab848dfaef25f86cb8974a08f1499d44e0f5740853e6a6d769ff2bdc196c7dd31e7d6aca0e9addc8fa78574fb54e4481afc6f5d2dce5f237ad33b79dc4c896c1d5d597d3a79e9c2abf954ad96d296095c46d78c4fc4e9047ac28d7f49c64d44f31e984591b9e38d549bbfc23de99bf96b14b9b01670c39fa541fdceec1315674e85a63675a91ecd214fd12f40a6586e7009e2dd4993e86e7859693003c5bcfa578183330ad77c1ede90a1611bf0e4190d988c74b8882c1965a977120ed21963218b05138e6a4a2a9c08a88fbb3e9ba0e908a04507282dea03aea0e06254386b1e357bc0eae315cee75c67692d513b947e35fcbb9a2e935eae3e439a035176fe6d9c0d29f9f7bbe50213de59e0fd30cd6b3f8e8088e6f8c5187b5057e50e49c20f45d1c24f04d86db9124c987c6ea6f1d946e65f70d475407f0aaab2008f014a8f8ac6fc05f95c3afed9e53807b133bd20a50c12b8b3d8f4ccc49c7f0cc2d2c2f5506e03fdc24287c79b324c10e25264b0be82968aaca7257193ec3ceea52988719f3a73f1ef207ebb4b9345976a4cd887762d289f52ec0614eb5b0c6daa14098b724ea29923e1a6dd8d25d76b5c6b109a246d536a3831065010228ca447ac3f6437141c45b59ce6c3ac2db7d7ebf2c2200ab6ab0d8e28150c19cc8145921c360bd3b8f03a224ffbdec754979af9c77fffbb055a2a7a009151a352534c53a89b2a10922b92309712896a05390545772181aa65dde9d9e3832cf6c35836407a9cba023a3f8e663fdecb0b6e883a933d0ed4f839b274662a2c86bc18fc2442d64b94d4400ed470a517d0982cda78c623bf5fbdf9a222d96c734641a25cba02391ed5c79fb8d0c0e30b00409085a49c8e2412e911522bf44ab32a81fcb6e4b4ed0a35170c6d34785738b4a60f987aba77cc0f2ef08c16c5cde3fb0c94b33d18cad58ef5ebfb3c8e334cbae573b0acd1ed525c120da63093023f30b63741fce097d4d87edec4d8f4863d14d165f274fda78e7968dc56e32def5abf7f4bdc8cd1244d23d9b1189f12a45471b4086420a7e5ac9ebce6e0de5a1c69f840a46cf742c3e63a6e81fa3ff2f9990f9756e1bde2825efd3a43f905ae9885b3eec9296e7428be25d7375aa905203ef87477fec2c286b0a4c5dbc18743a4063db048d0faef9b02f23e42a861dd4809545a764be29e35f7be45bca82fd0166c3f53eafabbc008701d2260b5ce0973b418652bfcb59c6630554f644218c7180eda06e449ab726af4f6300b19a7397f8eea0d226717436afdc3c94b61a35ad6e9d2ecc167fc7a056e1d00b4150505f8e16e4f8be5ef7441762a4c428766390d513498883a7166c4487714795bbd3d2c95fd285236ac4fcc0cca7e0f9f13a2499d6014c56a5294d73d59bc1608f31f013a0b7197537a08cf598d9682150f858a1ca787f26a20744df48ab3ae98ad98fb27416c7b469dfab8f009ca0428f8633b41df0f9131ae78640e25d365417ef2c15e9efdc3fa9887d7ee5e92af2c2c0be86c0ad7aa48674112f8f9a4095f4cbc4d0f264577838fe26c5c96f36a4150101f6815ee7077271a2404328873150b50b422af2afdceacd97b09a3713100ffd0078ab1455b497b1b0d1a629cd13df31bb32002a354f35668a2b4c14e1d998bf7c7238c5b4b607b868cc7485a319ddfcbc429147c21379dc103de93e281f921198b540dd7f4c2644ef3fd8709837019c443002ee779c53608417edf385438ba9dedc162168dd878c19eb1799796ae1c335ea5ea9ae685562e7547433cfd420cd71d671012eb9c1560d364cad728c96485c73cf15d5a700e69a28e73006422b82f88d73b51ce3dd255ec0d00abac2ef3ace223ce745861b4ba2d71af5617a00b29930c1e2a0b18fe62e14d2198c1193bc815c06daaf1eb1a348fcabdb9b70b9a6a0c2b65cd41fb67ccf710a4a9c548705862d2785d5d79e459be1cc0c2a71b5319972e7524b6ebaf0072bd59fff1dc826a837575cd2fbf4ca47f668cb092b68982dfcfcb49f7f329f961ac3eb732b5f198b6fe831ba020da43fb4434f5b792e623ecfbaf7bdd73b23806867f5da9dc62184aa008d719399ffaf6bc92d9570491c37cabda5a77a104f8f8c5cc5eff16b83cb593ea3f8935706b0b21d8f935671023c8458f01315b943cf72df8a5e0788918c93efb145f23facb9f2a043a1c702d1b79e60062e9d47850b81fe80fd03f16da8067f2c8315f114bce160b4bb1cdb6578b8dc65bd1b863d0606d8bf6e6a07112336eb13c694c188e7f580cb42421d7d0ff66926632a982cd095e8c8ee1bfa293ed6986ea2ebb0c957caaa2e8fc59353e61567eaefcb6462f79efa3860c6de6748d977f4780b28008896777d5983f6e554500996264e405f649324e5425ee84f80bb05efa5cee7439b023f43504d81cda6ecd760879cb8d70198e3431fa1c17509ef40d407877e44bb41ed851c0e01b46a2362f3e6b56cbba74e36223c7585248b58613185d40dcbd8d067af7f164132f9c2456604b933931c356bae31a73b196d477d0c3c357089ff850916f5511bb1dde3d115fd709326e65925357236075156985b232966cb51114ac36734ca98d5cd1ab1eec4e3283f128e46c9b6a0c738a6083134e364638f5d2248a0388aba89b7752b7ff74f997ee6444fd3d2aa81e64c1178aa81cb66dd9732e1ca98cfe6af26f60e6f78e04c513bf2952359d8eefc4112556f6413a9c2a3f1c5d4c06b88395f0a7b78ab738f0a22f2db354a3f8f6a40d8e703822b747278d75f5eb17503558735d4704df678b8891ce252e53587bbf00d56ca3b257a9f1d3641560595f46dc708961d768a92c489abd697c4f0850458752ab43ca06d4e1a80d87f4b42b14f909042c09c72dfd0cf7505cba3108845e4b1fdebc18f5b4162e690b50fb8c858731df5b9221f201bd6acfdfb16e9ed32fa064a565661d4b31e7982829364fa54a7926cb99efeb779db3144f07af4fbc3a55c253af81274aec1323338ccfee6982795bc6ccd4fc687daf3112953d328a6a118c8dc250c2b82d8afd62c1bc9df74906da59ad80b16f07194f9b4ce1652a4b811e1067ac854ebc4461d21ed062a79291e5e7c7fb35bb5a0eedfd6e9482861f5c996bc630df4cb278f367a553183a731fd6e1ff1f99278179cbb2fa494c4f3f96389e7470f1a03d3b51b242c30ac442dcba14edf6455ac5a091504906bdeb7df35512a01a617a79566f95f87cfa34f06cd74e4844f946cf4a623e79e69251ec982aa2932134077a1e45923e8bc2d64179dfd09b34d3d1fe9a92882a453b099230d487a49b500f364b2af2ff8858a644b0ca7c438206e650b8e51561dce18ae4c4a28cfa2853e4ffd7a9eb824423d6b4d3da8a9804ab3eb727255331334f5ba3f3041ad46688d66ebef055899c4eafd3e6d4712e5306a7bbd56ba1850d64c87fc5426d2af62e14c9dac19bc98d39b1181361a1880649eb0d12d10013911d5f00447ad4bc21223330a0f40c86e46e0b5395911ba5620ea43fe79c4247f6635b6e36f23bb19a5cfb58a8a018ac75dbae933094d85ccb09fe09a370c16b1e8e35c12c407c76abeabab3285ae6032cdada472a80a19f3df19bba24d51ec832fb4341c1a2b6181112bb5a015c6ca7477b7ce2b526a17224f054a7192604e474093fb176e6f1352f56ddee5e4efb7222019d9b0fa6291a839876d8d128390172960703048e1baa0301e67962eb2a9b528527ef7b4d3eb246f552540a33fff6d1e7785df7dc3802a63248090ec536d4cc0e15bf524251f98f1577f03ffc07da264d8fb47ff078c8cdb5a258ebcdc8a5a89cc84a646220b0550fbdf7eadc83c63b4c7476366d19d45dbe586e74eb3e68b53115a27c4c578ce9be58b2c10e08dff26f0ad5a6dae32c94921fbf9a9757229aba7c345e327edb7b0189fdef685f05c9be7917e304240c57030cc268ba54af43827ec1f3ee17aca55658e14e80ea5338fa5d5c45e9b586a8314117737f92c207e1f3ff95b63096b50d2aa8ff210862727d0a21f22ddad1eeba3a668cdd6b9b82bf621c02291af01b623e0077ef11912b06b00785d06dd5430f092165aeb3ff0704709a48adffba4185e63bf75af31a2a5ed6bd4ddf5740c8220fca6fe97ee4e30c36f4fc9c8ab34943c4945bfd2890a040a1eac2683d46d9fad8bcb569d6709594e36f5bfd99bbd9a8d88aa37f03bd4d38be2a5cd3bc5d6bfe13a80f23e0825d6b55b246bb6611305014235594375ad0c06ba4fed08af0f58c14e95e3d6c8a2f630c8dffce5204b205ab61344dfb3f2a82a7658e47f85c7dbbd84e62b8c5146b9ae7a9331ca1546ed38959d632fae20c871dba3e8ceee7a9822094a12113662a2b56cf5528d2402b63c0c9ea9c3de29ff4701634746aa213c71e0aaa4ef231076d60e0af9f5557383f4789751dff7990cd987bba1bdac93f2a062f12961adc7cc300b69c5509f20361e8ae42600a86c75e6bfe01a52c287d9d14c6b5c22c7226108510fd3fa4fed5275e0115cd9698840f86a619dfc328b148d4c0bfd8cd08d71e529015882cd6dad632b8ce4ac6b3407d37598a626120059b037e7d334f830ed2fed346ea2965dd9c627126c2d74d2a1a3f14427bb5fd6daf4a328daf77854b1ff6d4f40033b8b7e95eea38d6b4dc9cee601201b6c4d6507a960c46246f9a057fdd5107667aa1cfa8479e9811287be7e540ddcbe3bc3e68d5206ecedaed6f6d5043c2e4b9e88612404c708b0d0ac84eca3ed14a47f333a422527ca962ab32481681f11d760df0dcf40c81752604112e9dfa108f74a5f07197c21a755b33f4f8ddf94e9f7941b4401c9c059ae05ff4548d51e624a0d69147cef6dafbc0b4e44fc47b78f4f968173bf8683219bd5203f9a141ecba4001bde26dd189a1db8067c01e115a3edf7c6d83a50eaef181f47dab41a1d7161c04b4897fdd9d1e0a4cc9a356a16ceb54ce1ee171ac21255f2e45f0a4fb4de61a4c8f7853ffab31828ae1e9decd7600783cc6c19e1bf04d00dd639f4d0214a3a6fcf395956ed980637a913683f9d1e1b35ced5124a6fd210cb14cff0544a94abaeb112768cef37b0e63d258245a6c3ef059f927182e6b63812e9aaa048f38b4ddb4fd7e79ba73ae63fdf462f244a2d2c98d61ae7314d54130e0115b192e63346985611a3648df9864f9d2f5ebdff94073be545a3b3508037f9c729f837ed899df58aaa1c876d3ca48fd7e2b4230fd58470edd64fd47adb428f6ccc3fb559ef558f76a55c86a55d3b34b627d579b1c23eb64f8702bfda84fe32ac90432dad5938ba6dd439269bc93ec4d196ea3a59d92b84d32d7c8e4c855df796906266babe0c000ed4eeaf21ef3b47815234058ff2d7f03b8f98c731d838b28c4eeaea25750a0cc02c2ad930abcf44d727a4dabfd24a368963a3b04d51379cebd66f80a7612042c34cca481b24c3e28d7ce3fb78a0ff9b06c258e5666ce3d015e80eb5ce86f5d2c3c3bb7891bd78e365f4f21ea62f0ee4345acf796df1286ffd031d291653039a13ef8eb34dbf8a6969003ff63b8eb5374032020c7fb7b3e44d6fd07f0ab585412c1d2338e85c509c8d599b14c24b4b840506482af2734bb07656c08910c77f69a1c117fe18fc839f95c506d3be1c7255df7c03d1e54859456a72f1706a6fe4f46f90eda6ed418ded5a5ac0022495d62204c48760279ee15465752a23ab126f8e5ac192d79a116a1d3da43bbfdb43e95896ff2012d032c2ff55301c9828450b1b62b4742cf0a393359ee7b38d1581d00e81ee16f1edf9a9f38e5b36884baa423c4b537014ef6e60d4b1b43d45dff98270176d7e806966a0a0578526f328152fec7ca029aaf90ca2ffb31fecde57b58e2449b30cd2f34247060e8a3282bdfb1599ff4ca3c6657399f785d101fec307a643a60023d0ff547e262ea440149f472ef271664f681611755371ab14400c414f302d2bcb177c8049355bfdb2eadb3ee8f5917f49e805feda45e7e4875eb6f4b1cb8fbacf4a22070c85cfd5ca44649921136597339fb8fa0eef240a520b57a2e400d81b1975337c7ad0abe688695481583af8105fa1ae82e5dc70ccbb0f339f49204f1541d56fe9227c394a6efb426e52d8360990e1210e89c95131e023b20fa135ff40db77cb38a24ab5670dc4d16ca9e8a45898bcb5ba497eb4d8bdd39e2143f6ab5632df731c895744def38badb70d863e2869c23c54bdcade8ec697ec3a7ac0874cea208a50eddd60ff17379220b560db595a9befe64241c6b9745ea08866d5a7af99905085cca6670f7a955859a8b3477944d4f07c2cdd48a2d2003cb466c86eb3ffa1a81a5ba5b688a6a178f211e5bbc3f960ca7515cf1ce30e5ae7c041a9307aebd49648af5b140e2442a6f50ec1d0853780a3596b39148af9b747935cd4b2e7133da9aedb241db8ccb5bea4c272f3be315a9029d1c1db19485c30cfa42aec17174250231abb19612e9f9540aca6d28167e7d12045735e136a7e7837a51ab8ffa4d30c059e82e73cd31729661c2846f293dc99289cb4180e4ad82260959436e7bf671bf4dbecc63538eae9ec48e58e5da983a516433b7d464eb807f9242c3c48be728b7b2ab3053373b545e01b8e0013b239deebb10a7fc29e58a1a3404ca1851c8db6cf0c1446824ffe1b4ccdafea95434753f986b60fe8f09ec1307907babf14c51218645cc5e492bd718b05e1baa839ceae9de46b2ad6d13272d0b29c15040e6d25bc53beeec02cf69805b6b564e554051bcff6766b0612e8e6c6b8cae9321184a65d510ef81cb7ad4e37d1ad806c6465bb7ffd21b90c36240783c3e46464fa6e9803276ff4352bbce17c01b221eed25cf812c9d027a56890e642538b494d2fe8c1cb22a8dc000a02a8ed28d93a111f282a6fea58d4f0dfa121cd2ceff8c5ff3e4974bbdecfa38f4ff3324d7ad21906dfe1207f97d7d7b6f55e9c8384c611987a9c0eb3f25e26a79d737a5a98c63a1e905a97abeef6ea80cf361133746e06e1038c078ecd3af14ada480ea5617efdebfaa26d6d6a18e99aa2e3b812dbb660bdf8d5c936a69ca6eb719553dbbe6c06f6420d5e124390d40130e40ac7ea66832a72633ebd2afb440a2a7f9523ecf2a6fb2e1637894364d3feb29e13f7d1ac6bf9f597df57466ade906d1ae08c413e9c98fb0af21985334ba0da8a3afdc2fd5b2746d6806654e7c448ecbc89fbb492ce5f15ca0e74320ee04f14c0d3dcbb294f8467a7a3c2eeca6b89a03cc5a9a44c23ee07d7fe5cda3c93f24221edeeca8d2dec33cbca956fdd691d7656c703451364e9c84327d7e241dc2cf149c7fc35c157b031d72626a14d9a9d1e7057bc46ee427e0b113362ecb86a6feb768aa90dd62a1831780c057ae93a2752044cf70f720ebfafcc2cde220d9c1ed0b24f5fdb1a6c0ed0788dae6bb087a0c8a5d91bde8fb7a2833d7961132d1f75fb91ef849e84bf54d6ec34bff2b982b5e93fa773ed3cac445f761d879b7f99aa30af8000465557be9c895b50678539d6f0bfbddb6951d533cb176e00fa3749986a0c1b015e40464adc0aed1019c47d6692e32034cc75a3dbcd844f3a8a19c98ea49413b513c540fb2d87b64eb31850bb51f86c2a33f2ffce0c05f3c69b463d5c1213120faa7af146d152526313ec1229104867ed45b1ffce258bb49bb7099f2b720ac3fb5d1de4c1393fb79e98a96d7f55e4739cabdb4889286a33aa92d30d2f650e39f6ad212acac09b1ef4d8989533b858e6939de60cb1207a267c982836f27f1d041f2ab3adff8a3387133ce9659da9d78ec25e011e45b2ea64e9bf55d47ccf6aebf68838b908987e2806b2b7639e9cf596a4aafa28fff45f4f45d6e2f89c6445f763d7f92dd57f654e1b4e93f8934014a1d7abe40897d597be73aa919cefe34fa24e56e082458d8ee5206a7023595f0589b7bdfcec254ae3400bfd434f9b37f14a1a89db33403c1096afe10a5923d7620de0b3efabf298150bb2fdc45bd3ea518ab80a03d2f1ade415be6e626cec6f6c1fe69df049b645bbca5f20fb15a5aa2ad796de36eb00e537a9c328e3ab90e9fb20fb23509f9ec31296ce44064ad9920c96caea6fdd387f7f8688b547f448343080ffc7f945db91337c62454af624a7739b504028dee84b49df350e52803eb3c871d458fa1ad9491bcf7f1cac7896743e4a70260538076b10ac6e0b80d64ad8767c6db9aae6a07c7997a9510f1e4148adc8a0977fe985386a65944d505daa791e137ce4fbbff5327faaca3d7eb2788a7406dafca4b0fa235d42d75baa4ecabd345de8d0e575aa4024a5a23d450a71891d746b58569ea565c9d1b90caed03bc2c838cc7c6ba2730eabf4ad09649b84777a3f67eca06e3b24ef61dc59fc39d881ab809e3a5a4058f52c55693c8cb586e13819c3e1dd1fda058b2490f61a5e93c65b79c3b3ecde513a97891746d587fbd0538be6efed2bbef7cdbcfb746b1e9c772e4e695394da43bcc3a91b95d700bb45e4f814cc3ec269e93991597696717c911aa994b21d8aa8dd4a84a0d9b27a8312b6db452722dd0e11cf8f6d36663567c6389f3ebcdcfdd01e5f78daf771b073ea14beeea741fe239040242e75ed505696bb9fa4abc767031ee54bfa0afcaa914f1bd511cb12b20ee63a89107a2c5869bb981dfd369ef49ed799547abdcb41f6c28d0e6097f55dc8d249e2bd670c07ecfdc31caea08a71e74c99cce0e9969652a4a1bed130989b20b6c0a47a1f75953f3bb7b85a935ffa8705552565ec89d8cf6189c0f6bf02132aff1de554c4b236ecf06e6c0eab370f94c9368221015c8625981855233e7a86541fcd74e4ca2fbeb9116a057f52f982a074261329e22b1841c5fee89327c666b576bc980fff4ea5c8f5e152e224a8e894158849b544459210e0e5f079915739039ef3ea8f30ea328ac5a60fdf714ba3a21d4221cebc03026db9ff10726ceea185c2be4cab7227b82e9fc3c3aa06dba7fe80e89c3afa7013264118d0896d075df906b2d5529bc993df94db8387a900f737d7c1c9d576dab792add0b7eb23513874854e1afac8174c16ca7b62c0d744c32d48cde5961a5ad59ea993b62998e320d05223ae1374ac755176e721f5dd589f3ecf4188d6a714c0899a5a6358d000a169027d708d9dd3d5dfd0df5ce8f368be382cd7ceaab7b3362e5fcc84e7d5636cd22fc657d15fa6ec34f7869433e237d236a1ed60526cf0b6a399de19d36670517fa1dca7e66268f4dc5ed6b92fb2ba8f37bff2ad2bbdc64a769dda8491b5afa6863302af918bd5c4eb4fb0e5c618c6fbf02803d9bab175f5387b1dc73b974e6e8ca9074454781eedf2f0b24da7471d89fb60d4d3a95003f36275452132377d364e8f06e07f72f71da5a8cbad571e146ef784989756725957cb8dae298ef9d9c2e9d32008ae2466b242619499c6edd9eea176f3b0f62280ecab2f33cca300b7632acb6ce156f8481e1cbf225e8383b369d580647ffb7aba7f73c64c41e14bcff5f63f3685fdc4d9e7226d1a5ac11d3fb42e7614b07861f0a82fd42d6335522e8cd228fdd865736b45b4196a72ba5a5d0f78f613f14d60f8f38f7be6e57cbc7db9c8854622204491568e4980cd659a8af3f4da1306dc4ccbaf42ae80c038be56b9ff141183ebf6ee710e2077c2e1a906e6b4c5ada747802e313443fb4b09503f369092b68425d1bc2923b2e6c8278214370d62885cdd7f1eed9a868d61d6d5390b28720131410529bf357bba053793c40a6826aff465d305757f14e081c82e1156c18dbe8b9a4c94099d9f3f04863da5d8436cc9b1995170157595290ef66e9511d2f501a7da9b7cedb7aa931d2d9d185dbe5d29150e8aa801c00aef64587a10d47284e05f36fc409ece45621bf779780a3ff97140ee8072616fa1617eeee018f25ad22d6ab235874502c59c167a57b50418e5ee9df75cfd8ebf42637e94d6635c8d2ce1b9f23e9a0fdd149706c6b5084668233f17adb34060a5baa6ecbc7196c6ea22a29429abea468ba2272844f5fb29705422bfb8142e144f911b97bc90700f6aee2a0b5bc13b956bf417fbbd8259a614d5ec6d8652fc9fbe4419527d2e8bed473f5461cfce2051ba9cdddd64de9fc359cbd7b83659229018c716746a5377bd932f19e6a13435b5c1f8b0f9b83a2109d4ad911a9e002b8ab4ccd564714e635dc19fd147d91165b45c90544651e4c5072b868759f7d806041edccb5ffeb426f77dde5dd7ef05621f9a4cdc474be996f850962b5d4d05c2c06a15c00866d52dd66c2b5ddf50c54f1aba84d54ecbcc55137922637baedb2b6fae6f8a503610c72cfb881eae87024fa7929bbd6ccbeb8ec8b5202bd687d5dbc2ec8752281e77ad95f999cca14c336bb2e642257b01065cb998f2639a10b94333a8b730d2bee975a08e336cf99280db23d747bccc37b5eba8724ebac7605263cd530ff455248f4ed4be1d09105bc23487d8d342dbe02a3fb6e05379e7e91a1f86414632b8f9ee6b05a3053b7f30eee7cb0724b907a1a502f59d5d8246ab5b2b1d214620c5adbf926cedde5442a143bd39bbb9b204f132526ef4373d798b84492bfeba0634cba1ac73067ea41c303849b56743aaa847aabcf268ca5f2d9b4a75525ad82b0449ad8fb6755bfd27c5070e0a6e25ecfff3ef58d55a34af99cff16e5fa6b55aa1cfe18b16725ea8c9196e3edbbc0fe855aefd6c6d8dc61890bdc5cbfdf1fd95a9c81261f3e7b0cb5e20cdde261a03b068bb262d4f91b34a53de57d4382ee9975fad6bc18be488bc6615b3cb96ef4fa40ee0fc6e1a1e1da2866eb65841286e01e00b2927c855f48a24933bb1dfb53bc79b51533e5f75d434f53aecf3260fe83ca49cadf909b334f67a91f54381868c7082f3103201dc97f5d842cfbe06610d3eadf0bc991684629988e9e936763963dab11d6d62f34f51e3eeef56024dec9063aa94b1a281cca2817a0305bbded5ff5cfda748cb9068412a43c6616cbeac3dc26699fc052a165f1953c5a9db4d6fe712a2c25fb28811d883c5fd1b297fcd7a6447008e16c566f7c321907213ebd5a78365fa18f20939f43d53f89f12965ef9325c7971fcf2dc9892ef2824c18381c3fc786d0e8e003600778552ee705afa151faca60cf9f7fb92e162accf70f5fbedd219397429cb199aaf3ffee17a93ab362392bae3bce0acd3a87e57438c81e77ff24492cc4b2e6f591beeef32286af15d6a86d2182a668ec9b47ec24030e7f9022d75798468f619d63a6a132239481ab5d31c6b403cc54f5600610c77c5f9a6c760ec8f8107d2aa692e87c98d383ed7cebdc0d4d7be32ab8b8cb1e28f3cfa8be9e35b22f6bf00b34d88d4fb7fc45123e6b4a7fb41e526ac7def5bd091244c162310204cc0c835279d0f51727a64033ffbcadf2f31a0d45dd0a712501dac349b01dcef07d45af78b4d5555e08d26969ce6048eddc278006c2b861e408801cdedaaf35eee76207b8a1385c5eaa52a4d23bdce07b97de7d5e8f09091dfc05e947717ee7ba11e59377ca13967b9320a19b3739d4a2dd426c99877baf06b1717415606e521464b343f662a98c0b8f8fd70e63859bd413616c9212aed6118297fae64536a1425306f02e1c960f70e4506ea6fec83ab4b44c0c49dfa6421bcf03e48e72e301f07d86ff76e592d582f9f18e8d92cf3ee5b85c7d231cca9f16e5f22982e42633b4e05708bb42499cf20b36499df2d565e5a249c4571836785a6ed2fe2744c1d34771682b03e4bc91e59cd99ca57d677aaee924eb10316dd1d4fcea7359cd6cd66e7a79d51e561a58784af1fd127240231df06a033d857de90e1b1a602d3e022983125797c2da7ba940ebb8ff01dad3b9c06cb4295e2e92e9451f044415557fde46e25514faf877f6c7ba03bb4c48653bb553771b8f3e090484bf3ba43c5611c791a49b052d92859589d822fb9ced9011d9050e5ea9748becede989b3ce4700b5c7ef8b187c1594105c1eabd8a700a9918b52328b2d84d5e7c4d2c309458dbc5ceb9ec5d97728a6a18fd5f5c17db2d5920e93bb51e8cb9f49521632f9015c577724d16a27a2be3e13f884eac21d4af0b44eb26cbaf8d69849442ee0162611508662f45b67e8387aba66dc7dc0562e6be4e1dd7bbebaf5740fe7cab6f8d2e510e4a2f294fee8c3074ca40ba546c123698019ab2241ae67ffd0a5e848ff3f189b06052bbdb4dcb45d2330711e0eb2b251dcbb3409c55c72b4ec3ec2530c39ec70511d4c556d33ae1b9cf274040a07d7e6d4f628f09659a1657fdd5f5dc2f63c5121853706dfc754be7b2bed3eff1ed8bd34d59d95acb9acd19f0dc86f7af8fd444070261c3c4b86042cbbe2a246657b3900c683ee48f3ee033bf3c31041d0922c60e2896118528fb8f2238356a6221ca9b701a82b2f59b8a2c5e4f44ff8e389d7943b6192e322bb7e3344b8fd3ea16afd69e4a6d49a1cf7de3dead13a43bae60c856412fba5e6f2953bf4db55ac1b313ff38200c29fc4fc2deeeffb4121b9ff8eed87063c36fee14941d77a18cfe454ad85aa4a454c29f95426285805174e9667be4c5c21ea73c5c9c870a5790ca42768ebd4609b8735d8af3df61ff1c1aa76009c68c9bb2ce890142dd6d985b1be56a4432daa7144af18fd9692e5a84b4904d0fb5d427fa0a0819c8f5c8a0a5ab84c90a3a86d6226703ddecab538b128507dffed65c5103e9137ff7c4843072d868ef5bc669b4c70325e94a1d73c9fc87d820b00bf40b1a6c3c5b3e36eede59c10a0efbb6cc215abfb8a379baae35905c940dad0ccf3f184ef3ec6b51dca0958c510f8ea112dfc2fc20b047f067bc871f44b856dcd010b859dfd40c83e572c38e58d669872d660f873224af4ba09ff696a67f5094930a3f9674129c9926bc7855ac32a5de91ebc82d8a168aaab992e9be75f2ecb79063dc692b34560ba7342112c1140f87dd842c3fd7ee59cf23572113586e6b82a8c40374a5e2ee2a79068c6d10c918646e0227896db57896d2adbb46d17daadfadf3fa2be76315d865056c36fc499cad257d5ce32cb40e5e6379f8e3f14c64746cee4fa7488ca7560857bbc6de13f02b80b44e2bf7985ede462a63d772d552b989b632bfc212f0cd6b1cb1dc6b9afd715146ee542b207ca42b2490e02447406ca0673a15ee11679060d07525b2763e6d99f4d50fe04e2dc93761f4c268f8d16270ad98853d32f25f2970b631d2b0a3d091e4cb900edfe43d805f0c131667af863a9f04ff8716bc04fe4b3c3974240c75a1a42746162cdf4f9883a4f16f212dc6891d82d02b19d40c06a5b77808e0df825fcfefe49673abd39b598d1cd25bf1c3c9a22a4e4692ab375ee978860d4118bfd493a1df2adef47271acc6a975f682326f31c35f531c5ec5e8be7146ec2ff1db54f42c415a8ead2ac53fa347b0caa2efa94a7b5cc388ff4f38d3d11e1e5a7a8927a7d277cfd4d7bc83de0544182a00a8786a4dca1d726481c44cb5a1b48e380d7457acf9e659c4091f0b44149c5fd79121f2101162f022cdc4709bdf78eeadd4a35111f6779c8aee7fb1fc78af1c523ca1eb1366b5db278aefeb0abed0fee9e4ca427327323e8c1d1df5eda946c66bb495a3f700fe47c9f079cff571a27b01a045eb4705c7a14609682213936af65eb46106b3a4a2161421fd68c9f07937b8d9f378b478e30fd948f435415bf8a23a91e79e27a900ad99cca620b6c9f009c7a549e0ac44558a228a6cbaca89ca14c55f9e3fb11378fa8c1ee797eec650bac5722198b2cb0336292807becbd0864807abfa966f62565cad8b7140240837a3cbe8ee939e887bf5e57bf3cf0c2d642610558d653f9fe3046e4f93326bea456f3e08aa8dde893f6cdbd5d387bfffc45e24bcf11d8302f64d7aa2270fa782423499098ace02d754c61ea6cd7cbb69d4543c855387952bb814c771a2d9030fcaa8952d16db25ebd2de5d08fc7b8b3cad55d65a4e2ce58433396e1dc6eb97d9cf398637142f185a11dd069bad51b4f70366be3772076ef676e4a6a196cd10cc8e05d83460ad3c50c56f4da8f5699a222956e4aa2881989d51fb674b5e6eea12c9138a25ddb4d4ef7788e88c1564c449c0976140d3380b50f88a809fd91d5b1e90bc566fc4a29b8064bbf89895f5061087bb67e939f75682f7ad25429d10ffe26f975d29739a667727c125423e163a9618664c4db2258cce48c1556ce4cdc815f28c6ff2928f8b737c00d4c8c13bfece9e09004267757e67448d7cfa6395c7559b3c702b8b1a5018249a5cf8fe05f99dbcf7a3df0a0b54f9dee8f7e938e2bae6f40d2a905904656fc131ef2a036ed910f44fafff0ea55f7b36fbde03461d493a2657d2ff59aa50f0e49df92d5459cc0b0bcdf7386048c9ed32228492086e35a5c9704b78ebb6c918420ea5b7155664bdb42696c38ee4beea291a55ce1f88aeafcbf95f6c44aec93dc886cc4e3eb03c76f964d0dd39f89189d125d884b024555906fd2b3773392bb29f008c4c7c3370be6afd0138e18cc5277c7fda621addf9d696cb7448076ea053196db833fff20cba53d7bf6937bfc08710d130cccd2c3ab571eff10a2ad0d4dbc0600ec08f7f1ccc083a527be62b0e18e498226599e5611d99ceda2ce6cdd1fec798a2b65b0d39d234f266417e9ef2ccd85e41bac941d27255e64d23dd1275196a291ca74ae3f4f0557bed2702a137927c7603d41d9208438a93b451ff53e176ed30d4db3634cdfa9051820531459d44ef9f3711670a61260a5d2f14b479f998fcc3aebfc38f64dd135700d9488a2bfefc4f277679b81962314ed4aaac5900dd0e553789f71b00bdaa3d1da9c19b21bfa8562b867ce85c8cda43c80c8cfe552ed9d83bfa7c462a6749768c67e02c536d8bbe949160780ba74c43b1eb596afb444c47482ee3eaa5a3d7efff98feabb6ab3776839c3ba9577373098b7b15dec2a3565a9202736ec28ee4cab0d3f06c999ba0ce1fed4fff4b6f9a482709707389fa7bdf1a47128b3ff35dfcdcb6d202360ebab99fe631e1336da09feee4e41afe98258274771f0a04811e5bedb97d49abffbde1b03d10865b38c424b37718dc3c62b8272b1f68b41d8566c4ea1de2f734656bafc97fc45a2e8a65e50a4f4ed0a9286f8c84d1200e35837d5b050c62deb50bf056d5f878ce1ab4a9bf017a8517bf9a62e41b2caa296c2323777d60cbd17215044b40a63af42950d4e2626238b44aeae1e391326e2fa6666dd547abcdec7028334de46bd9060052394587d024d73bbf203627c3d556641f69c0551593c21cb9c0d11377cd2f1c19ee9d96ef76a3ce0da3376aa8afc3bfb4bb9ddb08684d40c90f1df72109d692025971e4510780f8dc05f1ecfc360a68c66364522f871e6c4d0ee1701c0e2759cc18406a28a45718962e2d64706e98b0d9bbbe71662aadc40ad55228df7e2a72c58795917effc840db1e6580f78dd4c221f45d4079356fb2a45c2abb85f7ba26c5474755f1d7fcafd68e72c6f04e3ad7e87bb6c2edb917fcf2c5a55d0947d6a9f068458283c95f03b666237f7f85cf656c7395b45e5d0442abf256142ec830a3f3b90f352fa8d86ca5c27fc3dc23251b33ae1a408ccd8c9c40d585bd888c85ef54af30c3cf250c6194c28462dca654cc884cd1cbd545217b937cb88039ca8f45ac7d3b4fb5a5f55340fdb04267613f07082172cb592624ac715cb19a934572ebac645b8f117dad26b947381b24a35373915baaa29d6dc7edeb3a689b3c9c60da1b89d2149c6ba5a3dac462f653c474bdc00b5876d1f112fe28ebfd663782fda696764ae32e10417f9d9fd99813f528ce03122d427b24bac37dcf6bd3a338ce555f825d4d99b6b4ae5bc9af837413be6f387dd40c65b3d0d1408966d2e4422b1856132a18d93fdfc4823a5d783d65fd1b38171111dda63a39056591f4976da6537516e862cb10e6b37450c312abdc57b34eb8cf0fc81c1ea2dc0ebac063db82e2b0905cf0a6d41c2c73039f50b1d883789b2ac50619e9f8059d6d75ff8be13ebb2bb9339b595ffebf8d229e5bf29534e3d4dac9e0e75805550a7fbb5c9569545837fa47e1663cb61702ee9db7309e4d67b5d3ba46f74a75781feee57c44ca67f7432423641172cbe7b67c44fcec9210c988e89728abc7bcad785ebd53e0305455f4da6363eade8c730c8d75391ab7031f71c4321a978a7d18b4c2b72b149fb568c663c63d65d912aa7b94d857fad72314b96bf9854c951666db64fc444cc11c677bf4a84d698b86255684de5225dcef5fa290b0ad8c897fc0ebee6138b0f6765a8f05713296ffb5a451bde07cdeb35fc1b08a03093bc7953f115c29a2721f4d97aeb1c2d48c2c7c78694169f2b0efb495e20b1034a78a635bdb29ac7ce63d7f3711f27d85352fa08eb9349fa87e5e82461f6cfac0ed52ed59f07ca4f4308e69c184fd30ea8ec81ce3284b56dde9859082fad698b49130ced1fd2d3ba9b41338325898229d6bb3dcfbc95b12f178bfc796b0d4a65ba0ab38643c34f33ec496d15016ea738e4d2b9c5bce7712fcddf12dd822287d5aa8e81bf50904ee5f0c0f2a70988b97c3b92df302949a989ee61b67826a1e910816164363a1395b30378a7969df097ea973462952b1949375675199e2c97c6ee4509cd36f3017cc426ac49590d336b0304a53505933028885b7b606146e5c7f41097d72428f1663d5a5fbdfb95910e7dbbc000fd79ef1ead80007a6de44a5dfcee7eea95697e10f4755737812dd93ce7c3027125366e5cf3591c71c314a86f895359228878db88aaf115e820270da998f18fd76f2ec124911929c8fff1fe22cf52b797cf7e6128816a88fd8d25f632de3992f98907016c561058c610a1885e40c6df5a3b84b53820f570f52e6fbca37a9d5478440d98b3865a582aafca10cb89ad645e3653b6383232dfeb1c01483be1875c834f82a5e66857bf8483452477e7c8a6dd8a23abee99ab39268a198f888c430811f6cf6899330d467097d5cdbbfb35390ba61c475f75703fdbec0e3abcca69bbd4e23519d6778d942c1d51e7e4355e2ee30e0718b18117fdbad19f21168f7165172b3b490eac272bffde381cd889dfd68adabdd3c24d36b275fa6f0aca66837fc21104bb29c94f781dc9c5ff9f26fecd6d2130b73c04f46c0574e63d2e295a8ca312d48e2e82af0a781215d3381f0602a3ac63652727a3ca4b61d6dfd66ab02414daa093bd8e0ad22188907c19aab1b34e4c5c66d951232e22435a9a2726a862ee53140b5c1dae44e9ceec339c851aebb979b85cfd7504112591dd338b00f19210c5f498ea028590005c4f72fbebcc39b42beb6893197a4303518b6079e48a3713a8b04c3c062eb7994d5d16902a046f2ec6026e37002d1c11a41eccabbccf4e03f3a14f62bd8a8ba61b150aa3e21c46eee2359e1a6d0b1d1a96cfb7aa77da1cfc575b1719e3eb0925bab51930054a23760d1a9e510ebf639e5411c11a26ebc8d45cf2756da7f39867fc85a434d3cc86f41d0d5ebe8676e976e02f866c00b0661d64e25ddd4f9929003318b3ea22f736aae4f2d109521f96f0eb1b9a16a55d4aab7234efffb094b16fa8a4b19e8a0a0f4591a3399bf11180d52329deb6b5adfe07fbc522f59c061040ca6e26b670267142bda54b0025ba84683044f25f6b03055cad3cb9b6c6598a0b550fa375d7ec961652f3ac627eb6a8cb0ea2c129515e5cab4b85984aa23318b31850c4a04c5a433139e4a179cfa3f75625a5327cdd73a59ef30d81e0f160f1e2bc7d6369bdec06c6a2c2e79ed2e3103a8580a856819785a64a91f3720bea0024a0d5975313ac1ccf87e116eb6a984670a0c709ba8f8aad8b57d6cadd57c7aa8ee758bb5ba3a0235b500a0bafb9874db9b549b9e815f42f24132242f464f12504583e55d07d5e128b4d0bbef6cf23bd41c9d80751f5fdfe0e5ada084d3f7cf6a60b8fc8b53e8b7287dc7e24e9596570b53cc97ce8d39739cf57559ebd5a437c04f8fedb6ce757e48ce9bd5e4d1ef7e3e5c0bc5cbe4b26b554541de5029d7e04df28ea1ebe0fff13cad068854b31c8f73c3645bb2db9d6b6cffdccb248ca6f105f0d44aa4f55fd8e71e244ff486f89c74453a7ce388a35ddeab3b0b1c1e0fd12726fb8f01f5fa1683ebcd850fc6151441440fe4e6533e20d0d8510eadf1f740d0d24c1d8e3b325920ff75097b56a7a21b52b7184ea3054cc5199bf3f96a0bdd3b1ea725dbb76743bae52019770af7b9e9126fde30614e0817c74704905e36308493c663275e9c7ec379772f0cceb4bbc1a92ee008aeae1f18a988f9d409ed1ad6d03a6159e730c8781f102722a614a9c67f8917e7c22d30481dd98b374d7eb585f4f0addb429a3f34a8bd957f415b9393c5cdcd13494a56a3cc58dee7a6098c99dc085034b9c8542762d8749b508505852cf0481d7edce1f7f47928f348ac015f90bfd8e6ecc5b6e5930376b61c8c6af87fc14c55c49b9edf8b83390ea80be8aea7a413fd3286b6f2c38ede6537752db8b5a6c039195270ba2076585ec5ac5dbe404a2fa2acb38c8d08718a3d7b703044b8ac16c66433a8629b6055afe5674735478901cba5d39919575c585d0df86b408ec6350cede6e8f526c789a74b8c697ba907f8199d1ff95371b17f7d7c4521684b8c62f5d24a47986fb4d5e25edeb6db5cc95634741eb7c9ffff0477b6b9f4b94dbbc6187ea493299e77d0f8b602961d87e21fa766b859e8173a159b0d5d854bd9556c6abc30cdcaf35a63a168776fb8acfdcba855c063584ccd9fddffa5b67537804f63ffa1deda4a93c87e441d951f07b02b7d62869258e4dbde84555ae3b45d7cbaa00705ec4191890a4c6eb8c5fe360100b09057e15d35143c606c9928226f5f0005f16ff72b1202e163a062243fadf69bfc7167c0f5c15bc8ce8a10419ebd5828888defd08b147a418ae2bdc480143b3c08f35e7be1dfaf8c6445380a81814be48d8623e6b70693eb7f23ab9acc28c8fe6b8cba61c85a2439abc2fc78697a0464e81b0b2da74137037692de8c8fd9f9bc616a0178fabba3523984912b20b5e6e12e1f87173ea8f7858c4eb41b1e98825589d3e0198a324b04cfaf208d752ed6a364a1188b95f6d3ecf78d0f429473f39a157da66cb134e0a466951311604bd191de2b944a2c8208b8a8a5c85e4c7fda2593a8e9654321adea207279ddd7a197cc880dc543fdf8f3788e2201cf42e9d239b5a61d189429585bfe1b742a8b90d84eb60a3c8ccf3e16dc80ef3474ec3befe27b98b912acfe38b20e67de53389b95f16dac8e75291449ea63b6e1d98a586979bac1819259d4363c0f8f3ef42d3ab3a38b075d32eb16fcc1487769edf48f282248ebe2dd8dbf60f1474085d4ac82db9a669bf4afa56c55b015f2ec2dd288b8c70bb93716eef48614bb816a2b87fab019071b85a7efb35d5c77b3d1dfed960c96740d790a3ace0f4aa0db2974bfe468376e65d6529909e87680b1eae412167ca2b35df8a455fd4d65d0fd38bafc85e7edabf5fc165a1f9d754f4ee7f4b9b56d5e726fe477919c8399e6094d60b5cd9bd327c55918ba716e2f6ce14538ef4e594b56b986f17ab426508bbf4205aa0151b887ce624a7d682ed46207a7253b169a2c0a2bc4bd8efb0e54a8aae19d956106ec17583bb59b70e56ffa4682d149aa2eb1392c586ec41604b5989924eaef07d6be5d933f6f38403b167c2711076238db87ed0ecc96806e080b6aaeaabdd1361177ceb4ab46e870ac639a81f1ed467542c52a4ff16e69384cf5df249c969ceb40bee6a5e17428617e7b4c5c70a22a3a176d26966418658be3ce192e91e0a8990cdc15255db91e1080503224aa3f8739b9573cea7969dd67d70e6de6e120516072b3f104097f5272564f6d9e57fe07b7d811b551d6deb40bcb0e2c622909922d6e44bcf9f28df99a54f2cdd6e43c8e17c230b21de4f44031e6ba8e3915811ab52786260ddb560365d91724217b33b7eabbb997d58d69be43181ecb6608e9e3388763c4c86d1bd9bff10f589bc748ea3f75f383bfa009bbf7d41c315f104f81ba6585b7fa939358a99fd65365c45844b0d0d3547f3618f5b66a49908eb5331c0fb36a6d827d41efc637a0be6a33de90bd9bbb8601c606f46806b52ba8048a9d4f3bc75ff6d33643048ae95bd1a169253ff47c8cca04c09e2e7f7305988119efd0674e5e9fd3df0a98f70eb00b1463d2cf1a127c0f60b4b5124d5dc538215a782e371483ddb8e265f7a32176cf00c4c4163a0feb1e8e9680d39489669c36a1217c48f53b63618a52cf6d9861632efb29a099881f59fb028f1087743b79eaaf0b513525275ebdfdbe8320010abccc7562062508dbf136c524870dc6988989f159102bc011f97d1b7507f0114c981f6eaf139f03ee12531287aed5769148b6493cddce67d6d1d236f7c140747c4fe9600ad939265b55d805ba985237c1f0be849c2f987a44f0925d7aebe8f44a041882b65808e8f5cd2adf466752d640e3b2522ec88e558b9f5e2f413f4c331101ab3ed71e67fb2696acdc4804ef4bdf65b180cbcc7333faa82f0210fa3215b7962214a35e38d03480ee2ab8f1ec819ddd374d867fb00109a9f53c7c2177b746cccd3e2665e9765b70e762cadd4e1d94fc2a4cd30ba3272f3b3fe6c79b56baeace0f770be3ffc7ff60198cac7a4f6d520dd765bafe9a71828a77248b990df5db1e1cf861028ad698d260c46ec3adcc1394e0790ac17c374a0397f2f2d465128a40a74223b0a73bc5af3097a8d1db59681b2b5a4f507142df1a76f51125fd157e9d72c9b9f08dae4488ce15b375b48261657de5c474b875e498886839e4d48cd52fc2f61e8b081630b27bcf7f965c11f7abc7cd2a4134f2672c46dc0ac20479f8e7f3ced96109b120154829187613b11af15405d2e4c63d3470b50cc665e538b92f4bccf754ae9fb780a8b171dcc82d42a9b88deff3a3c2102ee165613cfe3386abaeb6482fff5ab705a8d01bc24237670bdbe104d01e414778765afe95f38cf90eef95128c799feb997d1444e2f5ea004356714dc44f400b85c239b39626f9e27d586ed1a587c052aaa5bf23b927c139a72779c8fb4d1e50a88dde3bd9b91bf4cacaf6631ffbadacceb6f6008f692c031c7652f8ef8d3e0d804f17df131ec229dd2736d4d73650e9851e69de3b57c8499aaf9190a9ff9dd6ed1b4360555f1b4296b4990e005b005e37b4bc93bcf25f2715a34b79deec40fe2821893759216eff0f96dadb5c15146ba5a3d0b2bdf174cf193e8c794a6cad3ce3b32cf3b37e4924e75631d0d04043a8b4703a7f6b8dda093e11aaae377d811dba0f24d30da0805e49f208f3441825d4a8da5be910bd228658f1cfdc5c394565fccc9d275b87f51a3fb6eca77e7868521ab60cfbc08eb501f4946cb068f723ff85cf346bf0cf154cdbdc9230fbf108a18504b2c780e1fccc0abf0489daa5819793b1a0abfb8b34410730ff89ef32a9077a3f47d43a26933f985ef0fb4766da9b8ddeced67f95b3f744f4efa5f60e69ff939c380f1f0254e3bbdac11545aa120964bf161ee040cfd6df6d9a60a7a65e4c098b0262f74a808d1a0c005baa7ed502a7f551c86d2d7eeb3cb87841264c297d7c4bfbef7d8e06cea525d6ac177f021e0960e74401668dd66e45cf702932c3b7dfd5e370788bca0b84b589b2a0b718b7f46d1462fdea8dc116d99a13879c87e12a9b3ebc0a6759ca49e36edb963753516c951b2faeb06f969bfaf1fdd86a7fe724d1a4b7392703b79fbe08aaa0ef03ee3cb169ceed61197523c9150487f4d2607f1f2207119163203a051f4ba2c0297e566bdcaade47969042289e2cba829a3609d2706e9d2cc2e677c1152774b57580cb124cef33a312cae8511d47760690e36994a1fc1acaf00f50f59832a2274ff524129999821db05e973ce8b064d9e600c8707f9816d1223e777fecbc52a14e2f0c7b3f4b728ed7019b6d1d5e3fb395fb645e6e34cfb0de127e4b56a61287d76fadd12786ae81e6d78961ac574f68f178ba589c0b4e3080b9ffcc699d7195ec8a569255e562504f076580ef15e860c92141bdc0284ffe49d758651711cbe4c678560f14fbfc46124085ead5102dfab9eabf1c4eed54d8a124ddf060128fb10655e201d9076ff36c839219d137e835c1df0aef29ddba392a260ec8084523b2266f49e58b87997722b4dfd29bd08a588429480a68a1212c5948508b495bdbeb2f6ade13696100f158aea4cfa08875f105838d0c44dc65fea7383fe0cd0b50fbb76d6bfa609e4daf26c40060e5190ff43773957108952e92f6a595d9eefe8c6b72a6fbe9f78383198b144f0583616e2e23129345e2afe1f2bbef32bca085787791a6915f866e86583efffbac72efd2fbbab10bd4e07541be17ed26c8c67edc02474500410f5badc6d227b4454daf7dc1b9c4d7b7d50a42b7d2fba5cd690e88768d83bf3110fd655a8b4ac6643fb2a1fdc619e4bc9f80a9f76fca8503ce312768d5ae1c1e81446231f7dc4d88efe34fd578991b2e27c54dd8ef694a2d2979f232cf78c1beabf1ef00834e6eda16fd5928007d6af00d1c588170c35f4c35aed82da7b958331be0accf267a13fb971eb07b91292287d50d79b6078c144bad1362d2c2d38cf57c157eb8573646473f57f7bd7b0f92e1049debbc64bf5cc513d44879f4071d66f243ab2f0c515f22fbf791208b4376eb565cb0fc2bc364d443da6763e490da9e4c0a11fdc7f255fad968b106f56067e50d798b2abeea90c994491b93f5812ad1c26f2d55794661846d4ec547040aee3b6cab6d4c7b97765505a42f48f1ab290f9f25573e37bbc12a6055d7afb334d6efeb59b864094978b66bf031efb4a31de0d5c7252ca22731616345be6113a3b8c68902143da30669fe0c4dd9cbf70a60a0a5573a4d07bb4d70f47f992e770c595554208621e724f0528037e7aeb7373ababa477a393c6a4e3c0128fa679b5df7ef290a381cdd9c248c522d331eea8c1a61560dd6f6bdeedc58e0f9f7289db713ac952034c4548cc69ce79a3e03917a641dac62ebae55ccf320408a3a1df5f6ca20a2fb88470b67b84be61c2d46af48323627f3130c02b5944b50a6dc4af5e843831c1cd6504cfeaa3521bdf26583b0528431c4131b2a2aca4bb6bd885e356d073ddaab816897e132a9686bd19059c3ec4e4830d0c4cd9e9396d6ce4b72c3ac42a9e82fbab50d72377ec5d27764d5f386c4157b88184bb8da920dc374b88aae2a805061ba90fe28f59991e49ef8bbd3615a1fc8483fbc0669c9dcdf3ce9b7e51a3129fe14c7b3c4c258b1d0c35ae71797c2292c884826dc3e08d0a2cd0c653bc886524fa096ae37503ef117106dcffece2039d00f1e0559d525141caa50acf49be249a2bc1b0eb9b2664982dbcd40580f9cc0761775bd9bdc2a3c83077d105db58a042acca7175879bb37e2bd186f762bfbbd5f99a4130226e4c8f332f305f98d828f6cd7d2743d539ba4bfdeb377c156da69490020313542c14211ffc1b29bdd40147d2f3c4cef46a31253e70e83caa71a48b778b46ddc46724ee16f63a2349f9059665d9e912afc6ae65642111f47e9e006e432b9153d7beca817ae5149036762641f3e48a9a71d478d86b147ba391cc5fccdef6c0f250f646221185e03f7adf7cd56c8e0f1b4156e649b8a19e212e476d3ca4843f593e2d13e1730b706082f1c96264a5cbdba607d84cd519a469230a06194d3149d96a6996d500b78a31b431902f28efb3fbf06ab96ca19e375b0236e2442729face9431d0d99678083f725442ffca263565cd3688ce8cf048efc1dcb1883738f0af50334c52a66ca95a4d706e350a83862da184a5390ca1ca1d9f7af6a9f8b8c5c745afcc2245e8ec25f5da8aa6252dbdc90da97611e5b472564d10cf765c22e6f3dc746b8c02558e7eed8d0a37e27c5f617d4d65e97bedb1c74b0c9253caa40845bad955bf1dc3aa3c2f8acd7bbe53c09a89e74784538f54c01ed0eaaaf38d5074fd53f8b6c3bc927717dcb259fdf7fc840d4472de59c8987c99e67e073466cf41228dfc9e7c391a559f5f4b64db227751494e0d6ae12e14c5c0090f26e185915eac80fc71a57f4b1f485ec8f7063c99b830ea3e8abe58e4fffef3e46ce75f90bcb229bbb5a7c9173bd122bda716d16e3a3050f05ebdd33ccd55fc98c8bc0452237e3a4db60eef911924ff1f3efe75b5b2eade85c08b7813e5e927c5efffb88a2b8e3c569baa9d0926d38cad55b4650f9ecf84656c97eadad37b333ccfd655c1cce34c537fad3d34e94d77ef2bb826ef60d0adae66a401f3afc71ce851ff397d49016609302917eb6a6f47f1649c49b12a8baf6aa4092d0ae2d23720136e04175c2f27559f9250a73ac3b2895b0a2cb5a67c18a2291b56673d648d6716f85ea23ed179decd0c79b7097dfb749b8f564754481fde48d89be43970937362723ad0856ec0761409b1b7b8ec05920967b869a5e9b277aae0937336ff8740fd5092e28f74e8ec666cf7e1be280c6bae23a5a2d1bdcee8fea32ebc18e4d3b7025234c7e6e3099e6631f3f9964408a3568a10445a37b5bac451b7f3976d3881ffe7c086e44900ee9c002b5bb3bf1b9f43d2fcb6d208ee51b53c82719d742a88a642d51e831346e32a719cc40a53a745c0b96b1faf932c024e977ae2dfa0826a4c6398a029ea338c9e27f7e845e08e12a163051b712ccd284d0fd5bea9f7b9edaa4978ff0f4dd0d9224417189ac6d5ed9a1f65604b5e3b9104f6dd8f2dad9955876458e2763195b998f8040ea9de226608ed90d04a09a783d4d3df67ae5277a868a9ee71f90ffc1e0d7eedfdb7e45b678b35ae02f1df945d7957fd66b5da3045c46fbde2930b69222e1832d4d71fb6094ada5d9efa891edffe919caff1e46589b3955d2a1e031e320f65db8f90349617407e36cd1216133afc034b9522594d826086bff1b15aca45768aa7e317baeedb788ba6015195041881d7b5d6adb0e885db094630e4d9ef0541b0ca8fc9f0ff25df5bc47ef6f08c551039c70c350e09e5e57a655e9d82a78e21a4ea44bc3656e5f784c26cada1534f606d71516605abfe0210a29a57febf8ee32169dd28e592c6c098d7f6042c7a32df283436c8f851ded932f580a4837bdffbd8b899d4a9febfa563f8f41543f017c26eae813fab6525c928a97134745ff0d496dfaa87f706b8373814b64d9d3355c3fcc85cd5e13667fd477d9dec8b9ad14a5178d6f2dbf8841f612742d03dfea922e174252c7a5879c021809d4d663932316825b44c9bec9271eb193fdbc55279a9908dba71e0eb00277564f3d19f3030b1a37b4faeffe4d9ab6738f8862ac8a0c76fb93cffba08374028ac697d823bb568d467f373e14e94f9c5851d8875a214912c7ab285e57b2605af61870a0f71681c40333a7a8e399b8d5b55678cbf133e1b80aed5992fd842aebaab350b2af52e5bde3a5af763698c3d4b47f031fd7c0099c7905e3b0e4a016765b8cff47faa174bc4c34bc4fa64c9c17aad9c1fce3b4b17b9dd2bd7a870bde939dcdf622bdb50158d5afb76228d2b69c012a3141ca5d68a0f32edcf612bde22c94d53f0ecdd7b40266d97cc08d585b44c79d922609e34a21a832c635df134604f890a0d6f52f29999746cacff1ffbd302582fb13a80e77e8abf73538fbd97d7d823624bdb4298f1ac80f50666a69a3ee15b2e2a985a465123bac8597b13a902789f70b1ca8212dd3fc90efc22704ce9f6408d9b92ac5ceb7d8ebea67c714208c57918294bcb78e7a8a66a4e29b229d6a59db31cae4ee78351fb08bcc0ca6079e779aaaf71a94ef673cd57dac7f0cf28dee73f5e0ae7186acd8a3d090c768908a9996aa44fd2838c5eca6fb8ec58191a158f2b3ea72a88ec5e8e74f76436a95046a264cdc039b4cb3cce9fd01c34aa6cc3aaa39fd18f55b984420eb2cc28e1c6784b1f455ecaba6297acf74d5cc1d40ddf73453a841c767745d57274f0a9d915d87a16ad7d2659c0732726fb81d2ab863252edf3d0672783858e9b5f5404afde8656e629c0318589c5f9a27a1e936c0e504d975dd66e9029d3669b2626c4c5502a8cce097a0214893125dccea135dd35d24800a02cf97f3784d9e794022d96a039ebd6fd76ed0b3c446c9c01e820812ee615e36ab1e92c1ae8734e515ae8c1b5897826f4b97124b58a8140ff458b87d15ffe503741dc733b6f499664ebb2be3376e0044d7807c5f57132c7e4a623ee76511da064d196ccf34833e2e0c6c906872a317c6a57c4d42e2f7f385bc63723fe82eda23368fa00fe36e3dd321b370d680fafe3e4ec57b26d56296b80e34089075df98ad79f9584e0bdbc345476457e4c387b05aa3251392ede8b24fac07307deb8eae6aba045944ed54840881d71ae7c876583d9a58879aa04a4775e1163256a3ab8250c0d709e74a8131138ff658945c297b96a02f9f4b2c6d03a3adb011ae17ec1d6555677c99d83d5e30897e95b623c4901a78e4cf63c884d22c77aa672b17d6fd35748991462cbd7cda888c1319b81a8d22e7e56a9a3ff832d5fac7e2bf02c772ce45199a70c379e7e694635bd62812193461f00a5871abf7b8a56c13534e06ea593d52bf20d5eeddc4203f3f1543c5e266f537048bfae485194a3930f3598042b5df7e00d64f6530ffb207097f47f50475447a7c620f42af2a7c9482097c9be464b1843980c493b27c2f76d1b6323ff1bdaf62694940dfc2719b1b60a4c1fda1aab7b47bae610942d18913b57e807a51bc0cad7f1cd508592fe24def104f5270cc19cfff3bead605b6fd85e08da2659242bb69e933e311703efcb861c14e146e5a9b154155c179dafd74f7c68ab55fb3afd1c4f5ca658f913171a3570ef9e2bee64c2cf3c9a24f31c683ef7b5e0d1612df33b8c7b4ed1a845458df4e065994aeacc7f87fd8d7a90aa82bb8873702f5e3ff2d42f19e8654a0820d17fe9a85e7edb5983f46cda1a05f34fc1cf7218f12ae8b2380d0b8b195bcf50de8ef8798ed34612c60a4b41c3cfe687422b3a55ad19da6f9a5cb9a12bfe56dd30b7cdd103ba79ae458f6a0f4d9cca70a8d419098c7e7f6585b4010d8a78eb7c07b01713723f2fe29f45d14c97bacacf178825c5cbc804c29157acdb8f2a169a0014cd686ed66addf2b8ece37b415efdd6132e3def55ec17a55288813eefd636e10d9cb8bd510624c9a36e7de1edf668535b0b365a6c85778bfa7692d99e7368fa88c0144bfaa1562b33b26197c9167ce0c27db2e4dd7fe6b91b024d58b77682061e7712c9b6c9b9e20fa65781d8a74757fbd25ae6bcc41feb56d8079cac78fdc56894e01eda31cee86b572c7d2fe7c326e1dad6c581602c6cd2f33b9e26535c7552fe4a45232bb5adf2a012c510c3b31e547ebb1f4f24910772aca96df5558969feeb620e8dbd579495d683c0945f9dd5841406662bd080d16b2d975e705e6ed0eaeba3ee3b57ee5ad0bbafe672bacbdbd1033f94375a7d111fdcca90392448d4a6c9893568d0bc6084330b04e465ac66116dee3ccb227dc3ca2e7e5b129db27dd17376efc3ebd3f9f83fbad6a2524cf315678ebde8393801e97e5fbd3a6d91f82f7c1bd77655dfc6f7f9355b657e8a3131e23431af86f7992d4b43c77ece63014d0ebf4c2355796f5e34f342cc87e83dee3afea1e003cabb7505b3e92107e743509c35e506e06d9950dc10e4bc0172000120177135348b6f62386df379d0ccdcca62b76792d41611db12793024630995f7842ae2b2d23281322e62fe7d217efa49de90352eb057fb6c03554da2915c21d09248ddeeecbd201386cc89f94a2776fc7eedfad6c30e379292d918a9d3b5d4e295e204bbc333163e062348fefe04ad22e30554cbfa1f2e7db34e25bcb96762b15d84abd96807b87d91bbfa598f00deeadefd42f9a2cc8d2d9de9efeb6234cf6978ecc886f75881545a7e918c443a90de8636c80a7430c2fd135b5ea541ac5b1f4820cde3cfc4e203608a13c70c0cd94baf5f4560dfb82da2afdff23e3a8b2b48dd1b2270737091727b883cd6de5d11c92514193e0a9c9ee9790e89e15a03424ddd8286d6bb751a9994210776bac41e7bb2f4de1f58f75eb634a8b1ef5785ea3c0f4585bef3e8c49dc7a48f48388b6d95af981cc77574dea217c653727e3f63372e6696e13a927fba017f56c03d695cecd46f0454dec58b2f06e0053457af90a95077b089c013806285fbbd369999deacfad7a35724bef7e076fa1380259d9766360aff7e08f65c3ade170874e3a56b88a4ffb1643eef38f917141300ab6579f1056671cbf5c1e4c4339bfc14255aaf00740e048e9cf44ae3e2e25c1d5b4e58f7cdae5a7db803eed9ed00a300670878ff221d4ae58b923175d0de763eb6bc07938e98908465a4af8e381f2e4da38c83a0ca4185aca263d8a88d1f2dfe053169619aa5551214750f5595303165c348b93cf2d6398c57ca544da65c9a0d81cac89ca2d0d02deb81b9b07a0f04abb5573c9fb75aed02e8f8532039d4395469b7cb62c353d4d3b01e2bcc9dd777b80a3a76df46483fb4f8c1ed2fc350b196f9c17bfc78a057262522b9485c65f52c2a5016d198d8e1ce36a3bab359dd7f188cd7a9b658dc16de11b49a90272640ede2002bc55601cf4b2fbbd14de931ed0c43a6ff9293f212fb5efc1bab5c5279fc6a7f9203b6275ab177a17d569f7218f1d7006621bdfda23aa218c08ccace65a07e7aaf4d014315738a1723358129b2148e41b10c039efd262f23ea9842a67add14753195a2fae1fc6ede8891929d3ede40bc4a7413f20baffd2aff04af8ff61b5c3fbf0d855f35924a56b9a00165dc9a7444fb68de37012bc256a8b9e2c7bf1c092750ddc51a2969263715617af31e9a5fcfb0e0f44c795a4ecaf195f6ca99a60adfbdd0a65aa1c241ef6a6fe46b011cc337ace43f4d11216ed12eb6d02b6862399ef3e3b8ce1ecce3f124b8783da3038600ac52237f63f6bf944dc606fa4060a48826d9afe857c87d09dc7db3d89fc001791f67f73728f8f72fff8e5021d385227167cd2272eaa0f021deb49a8c6546c483f850722a0af26d5f937a2fa5cfe8833fff19a3d1c5fa0c2998be4cdbe492e96b9bd870540cd3f58ea37fefd6fbc95f0c6cba4aaeee9f6a59269d302290a74de97e3075bd4915efd466a0c9ad03e12151b95ba76b2f4958f0550df7670dc87709d9190ecc09af3cd7d0c4a9a30472829a2e458dc5b1f626a51b6b4ea02d75174aa49efdd78806f5357afe7f6551d382a36c4fd326c44393abcfcc42b222cc3d8e4a702958b29e5847ffa6e9e6d45157bf484b37c9b0410053d67175d9139dde28d2ffd404d7bf520e859d9fd2cb81592ba489bc8f10c447d4e8ef2a856de47f8ae6cdf3a3de5eae49ae732f6c8f937bfc365ee4aefa8da6a02932303049145ea599a83ba7a86d493b6321bacf830d1debc64fa9c3ac8073f932ce6355e320917b9c23bc88e612d86bd5b5b4f1b8424115cc3eb9e15c38587d4e48839f46c9f9842da71e10bbfa6fa64c2ae1b02ccdf25d5c8daea0a1da584da4810f32e955c5dbfa275a0a01913364be4a71efe578c3f2c2f27422b9cdf16a556e524664f8a537f4acb2cdab31dd65fe4736f8758f6ced1b6c1f6531c403c7ebf9f4fac0fec84fccce9942ff52ae69144aa747ecc180ae6c2eb4421efbbbf5a2cc14615227288df1fa90c6f8709f6d489d679ca069e2e3ece8e0a1a61513bc88455097920728e1bfee7d3a58060d6e77366a525d9f66204cab3ba7ebf5f3b48b955d91e7e5fdc2bfb435ca54a1d7b6ae0f1c2761689ff0e0574b6991346fce4f2f05d141c99cc2cf74a27dd926ae8bb0409a3a4dae79f34cf34ef29c185c44a903d22c3fe2819e08f42fbb8f1479ae1d1894337573645ff0cadfe1d6fa8e54da414def36b5140759727e7b5ca6373c07578937694faab3e8bc51bf907affde562c98c8b35f7b47edfb0c2ae3dafa61c0dea55f0b1194ff02ae7d65753d9870d83fab1aa036650c26aae695240321226d9f39d6e539d7db58353d5d66e7feae7aaca473c81b993ad4b031f547864dcda261d7ee8c480ce729e4f7799089b6a6f71f356030e23a5bb41ef74e496aed4d142faab993ce2b98ef73cef15d6ba9e1dd2b9eafad0a94adda4eda40a1e726c25d935ffb032a96465b9a8f0ade5f3d0e0bf0e94150971c593c56f228c38eebdf66d923fc1e54fd55339cee50fa0c5f2db829632344dbb4748890055cd53dc083e20a5b0d404a62ae2084b89ab58cf3ae5152c6b248a81846d3149480e23648ea9b1f30ce2d497fba9f23595151e5145041b35bf5264a12d10a15e4cf77e4a18ad5089251ba9836e36f489e2256facb0998be31397b1305281d45547f49983a0917381766d993e3263c27d83b1a9ade40de55ad8669d1c3912c425e951a724b114d156faf9532804ac4cd0c6f162bcc61dc03f1afb01a1d1e79e0d23e631d29eb717f715762e6b7eaa6b5bad7f56decbbf9f30b9aca1cf7a8a12895e807662b029138864e904620fc32b4188c55fc1a848beaae4da71a6c5d8a70424044c6a13586fdadc9bb5a93593256ae4e73a556a8c6dc4e967feee10848c1381432527e2fe61260e48ab380eb8a838b37fe86734063ca2e007dd6d4fc2137068a41a6486897e8533b6b2660291ad263f1dfdfd7fa04bcdd8e2ad4e5b4503f3eb5e0b4b1a20ddd910e4ad1f42c30900dc553abeba73021f6eb02340deef1226a8bfa3a00eccfba4c3a9c337afda1b16e964120ac32f3e3dca24c58597a9c647e2be669ba31b22f80e06a44cf753640305946275758f470d8e914f0abb85547f518707491a7651348d4191d862831c60ab65a6aab8da88517af10523478f69e284a5db025d6defd040df7014f0bf6b584b13d7a8ebd37cf747a5bb42daf55b1cc57a7cbdd4de697c88d80ab6494d40e4bc3fa9a421fce0e6bd7f7ee76e72f138178ed963445d03481d31051f2facfb7b3c4f4aeec04cc3078d48010387ab7b788456c916da3df76911664138eaf0df2529f94d4877b786345ad81e64c3953a5ea91147389f8e964041c02f47a04ac4d2634438f633adf6693557ed4f7af4de95419c5f4c08b837f24bd1367ff377ba096932ef90ddc534b3010e85b329950731028f2db8fd209b64239254b4a247abbf6c26d0a22f17206b72726227b921158bf8b086df4b7cbbd597166b85422416d6071f4953d0051d24bf76627ec8244136583aabbba048df66c7a06cd38dfa32c01993f48fc477674c84c058de2c3a99e77db7443aa5285d6a826217aa9cfdde9ab83c74ba39ca8b331994d8901eb93af483c1308cc4a4c0a16cb2e26a138fe712194fc0a54bd67878f9c2c13a561abb951de13383e7bee8714f6352c98c5c35e24bf201d45c75c0384e91221ddc41fc6710a1037a060d3aa496df236e7163fc3d38fabf517d678adfc6100da37c4cdeb6dc11cc2ceebd02db6705753f55f80fce84d3f1cf419b7ceeffcfb3587938254631201ed33bf3abe752d54f7ddcba19f3fcc9acbebac17b9eb9c9bdebea4f393d0405285f58c80f012e19cfa0bea46660cb5476b288b0d239bd0ea4b22d6e629d63c739bcaef24076cc67db169987d5a33e14a75735a4411207655579e5674e52c708feb1bf1c9bde3ce2a884beb4e629933048c918b58b51efa2d5bbe9ff77ec87969007a31d5c13d113f40ca40054e4efa4550f86f0dd8b3610727e91b25698e1af2029d188faf1e8eae40c1c76f1f247d5b89c0c2d4240e66816bbd7be277f6e503f5bd55ce9e858ee8daac01e0d732aaa6131dd2ba1af3c7e71481c0389585616668aa4a752a0e4a80451c5195817b7e14ef6792181f726b12520c450689be594b6ccec5c351513dae4a091e775bd008b963df5e8680390056667f35bd9add92ab6e703fabb565a15326cbe5b4bacbd5d091407eced8391522fae39d2911fbb07c49e8dbd56d73fa83a2da3242f11ec63b57d18f9736e05b406beb9a6750c6eed7bf2a71394a2450dad1e0c8ad12bc0b19b6324169aa7eff164d874eeae339c66ad3e6ac171df87187135ab5d204a310fae1ad68abeae8650d32fc4eacc8b6cee2b171f149ee88f07d2fcc7c2a9136bff2ab328b1d31b204c969f70db459436e0bba20aa2528ac228f22ad92618383a089d19d2f2fdbca2e9a1cbe492d8cacb89c559839bbb9ed0d4b98a6c34e379047af9c4d81ca0277e33bc1b023d4e15830759e35f2090edee4f64c8fe221bc612598792a13cd2b17050f7599ced3f517e4ae2f4da4a014d340cdfec51027f59ea68929c07a8bf0c906fbdb283fe1219adf37f63a6bbb75138fc217ea923c9f2808e1afa4f1fc3355fa16b5e9086f88ae538853eb578bb2db97155543da8f236444782f9d5879c44892dafeabb4cac37a3b5c87d334870c0ced313a4428507d702c80ec30e44e77040d0c369714db3cba0f594336e4fdb9ee8fb2b9bd8c8ca28e8bf5a92e2e2ba8f08971ce6fa95cadad38401f1c7d59ac7935f3503ddebc58141d5c2daffe7b44ea0a6b73e7125d472fc293c46235d3ae02168492e782ea4502f9c983d9fbe39fc735a05933ba55b62f7271e73b092e39d05a82f1592963ba937ba166f7fc2a9245eab1c68979e9c04c2a308ede92ba39e0cd7ee6ed00226c3ec8e09b772785ae5af267f094d039b4cdbb86713dd83a7ce8abc32488bad3417886aec9f434cab5c2d429f55d253f9d107f7050394dd432b756657cad0c0ae3b6b46762fe541f7795bd1cad46d9a4b5d26ba1ba5ef91bd7879c07b26716d98e2548c62874aadca1742a8d40240c3f3a5272f0baa067f7d31e5e58d1160acb25d0e2315a10cb6f16bf8810ab5f2232892528bfd087e44d817cca8331d0a71c8fb0f16772a164219d339bdcad43b166334614f6e7fda56a610145fd6670b8e2cd1619c1754c382b6af3ef602f27bccc51a7c229ed5a1f0efbc3b1b17bd785afccaf16c023c7a23c98fbfbb82fa135b426855bd1600101578a937792bde15bb87e0802d2add126186d060b593ea922f7fe226a3d6ca422ed72d1bb90aebb26d44d788fd0a755a72123ec185d32fc2cd76aa3f4798f7e476afab8e3397645de208c5beded5eeab482027711608c61dddb1a1e0e1e59d83fb03b342e1a26e0f5916416e01ad47ac9bcfb3ca7e431a00e385a3f75a3dad1188ae149a30dd57557015e87363f17d1d20fcf0ae53e679166334ef78037a6c33c218af3ba632f5db30fb0f79c8aefe8abc55669ffdbaa1e7772576857c938f9c080fa21d5fb2b97bdb2f9664776b05e218a57e34923baf4038acdc371293e07b7d04d6b576dffae61b4224da3025d3250271991089a16082756b856798dfac50c9a79471aff33eb057a13cd702825d198d1d4799539f6b5c4ed33f5b424210b183e5d2c7b0005c5773ff042d99c47a7244657e2564d0ee10a2569ab01bdb9b0752ec0f1afcdaac2aea5d88c53651ccfb9c2708b21c2c4f7d14a3631871b60b01919b874f6cff12a57818aad3a6f00446d35563cdcf90c4892bd14051d6c95466cc33c9456b905b86d9c8b26ade7e63b167fbd84f42d6d2d2d94334d4a7e034e00986a67b3d0c6f9674890f28aefd26ba626c451a98c0e8a0e4c583a85f4897ec61a5e34d354bb9b8fc0b8158e75dced198c65a6ee97287d9214c0561b10dbbe0b5c9e80ca22244a0f90833ada10a9775175771000bb61aa3da309bc6992da8d3fe1d8c1493815afe5e990b6add07e3a261a57da904641243c61767a32c24d8d7a2fb4d86150230577261ea065728995c1e557963bd6db80e16e47bf54a31992abfecb5573ce9d37b4bb41db744590f20076f768d6ca1f0a502bad2b594f60d0be57a32744780b6cb498a0b7777f4f204618879b06160152da46feae658b24a65ae1c3b00c053b9b560e59321210784fefdac230d097e85a2d6bb7b8368fdeafa1c6a05783a2c8977db65aec85041ce66380a9966631908ada9e0c63169000887bbf211adcb044cda48d6f7563ebaa1fe4f883cd201b3760f693feb9c67f39a8dd3627719ec3df8009c116bc9d73e6842e07b463554e8b7795f13ebcc6f6450413f0d84181f7336a9252f6d05cf4bf4077e94d3ce4a9b14f7b2e9e95d79fad31dcb4d58462ffeab6fbdec8822806b2017549fc42c9a5c721c21f6c17b50fa208a6004976ad7c6653e6794eee607372f2f0c94ce28ad5bc610e0b27401aab46c838d2c735f3f51ae89b0fe850d1f2d8d39060383c1b13a73216598584b34682bc49068f3f3a70d423436c598dcd8896d5bf5e69192c64399de5042b6c41992bda380a9004e47844fefbfe4446408fcb93b41df81f0c240cf12ceb3be5aba84f9f1cff0821f902eb1fd9615d8601625b22c8580d8334deac8dac96b7c98747def968116d6be53def4e1bd8055f9ab96d5d1b9857a799fc069a1eca651ebaca27f76293a590f1a89ebfdbf5560fe68ff1a42b5a43809189887671666c7f177e82523eb9bfb310f82c74d58dd78864d6b7ebc1c0e6dec153644786ac684230c74c77ea41bcbd75d03cb2cfbb2748659c6dff34d4eb6f29f3a5e18e2703696e120f40dc0b3be14e4102bf96b95b2370115b8dcbc3d5014829ed3e2c277c4d45c7a5a05a3d1577f7c2278bbc8f080d27cc290a750498fb072db8874563e7bf2489a669f83974087afae7211a2c0f671f5ab436c9295af98746aad808309ce58749641157c65fdd349ca35441838ab8c97a05c1287b0f7a8fec918977650c162c86b7a9d828e410115739730d1376348eea1a582ca0b833622334800bec4c1ad86f58622ead7a0e4118ad6b5592766d01c78a555545c47a2e5437287a7fe44ad00c8183b17b931384694974eee238a55daac9f5a4f3e927756d304ecd9d8471469ae5ff8e963f6aeea985ec77bb4c2db5f7b03cbdc76514c588301e98337aedf5b0bfe54ceb0002fd2168c769943e95098bf7c123f40651555ea5c62bf6dce3d4d3e56fbe3e3faaea1a31492f79fd94a7bb199589121f815ae15b92efd5caf9dbbdf495bbea5583c6d566ea71f19af28f634ab29b285ecc76c15f6a1134bf1a6ade3edebf3f38f3736102c0633770883f8651ef95ec758413a59a5d2c4c0eeda6ec678c44dea0cdb1b8d7433cd6b810e79b130a891e8bbe94f6b0a10dbbdfb5df4c6072e76c9e25de79156d9ee37c4af4ad8aff5e0b94361eb8c4800be789783325e5f853ff2086bd3200ae20f9fad9aab6cbcaabdf2670fa0d8a70940f9ce03ad869ba10aff2588290cf87e55aedbe722e686967cea7ee30ac9a21fd5799ec340b0b9a295fbe724fb5f3f17b33f6c480843ce8695c1050cf7c5527b2f1452a7d43f9918cf694732c867737f953e11bc3c65d676f78f34adb24c5f94d9e9af2fd9e6985e4157370b46d1f14ba8f84919394de43c12c7fa22d819cb3edc88e6788dd257f4886e146356e1d70afe8ec6e36e40687c80a0e8bfe934336b8a3fa4ea6e4e1aed36ce7b41af9f4a465052d72b4e52a0616a1eb0b0ba58ee6832801d8d378e32181afc0ffd45a433389c691bce75e08ffd822dd4797a14f58360f12e1774830691be519f01566d26892c22676065169ff0607f477a563bc9e68610ebd4fee8ede52526008efeb3645c1a225267c91a5cc1fc31d8c438043bb6636881593f5d6464ce7ad6b13ad51119b8f4c5a2fa4ac156f2c2d4670b46c90ee844be1096b96de9ec5846efb7bf5dde392a9de8ddef91137fdbe022fc11c61840c000d530a0161ca0e5f8d2f290b0cf76da001c67bcd6c7d1fb712ee804ec70597a658b0243ee580799415f10c8f997c5a2c0f5b3cb845b2d5449af1f8aae4a1b15691e440a4095c5d78f5df37597ba1c9a354c94a39a6e7ffb6a847d8d07d4cd968f259abe9f736b52abbc0b163e174c345383b5c802f2f0809f06e0bc8dbdc8aaeebb01f67b22949a0d4aef6fc5174bdb688508d877369362871412831cb51d1ea56f17480816ab8f93b77454ae0a221d410ca076693ee21a49f9e9abdb3ced03cbb719e8eb5b0659c3903d16a8a2ca75c738658bd9df5b7fc12cbd4b3efe7769299417f0338fef098be091bd0eba1068cbb79d910d78107c1704271b306b909eec517851dcc932b1bcd28bb811753ca7ca521a4dd80017f09ad64b1bd9f6db78397a240f3d1632d95020a09a72371c24bd2a28b3a3b537e87d1bdbf1903124932d3044a573a626e84ae9d53fc0ddedff6eb1a82621a1bd12a3bb6850d97136e9b84e667d8d97d5283d2eca3f9c5e17754f640197f762a9a2bf332c1eb6053a3c010543e713d1dc8353e841f8223071a116cb13adc911c937bd6241def1431efd3dd9ea80ff84f162eb0f9f9b6de556f0ef730b43dd15efbc210f22d4d407952b61b0210f633dfb88acf630bf1b0b2615a1b9834dbbdc2d67893f37ace1a752b498465bfebf79f712978f9df981e9e1f7e5dff7b097d2fe961f2ee05819a314d856968e94c55387c90dd108e59409ee15a036819a1d2faaca0333865114c222373e029262d21edaf5b9c7b5302c837d09b4d957a3c85affd97f6a7732b2ff04b578c7c25c750f8cb7c49a647a2ecce7f4db26b44f36b1d69f6eddcc7f93f31206c57b9df808ddb5c3edfec2f6dc5150e218985f45d31a0b5b9f4cf27b46d9596bbcf02b2ab59241ea4e9d6956c8ab52c94ddfd095266d5c5da92902211c50fa8cfd0acec9d033e2b5de96dbf58629b3283bee1c1cf634f33a6ec1d5ef6a9e0b54473aeb522e093819c8a8f4bcfe425b97bc73cae176199b1a05f76fab8645e3673254313d2adbfb5558e223d4165764d1764957d0aec0a52497e06ba514bb135354345fd546447eadb0bfe3ea57406ee70a30d2a5c0b2b121bbfadb3b667633a467368f421a995f8fa75966d42739c405e8a89fcb41b0332c26309f8f6fa27470fac4406055b5da95b7a80690ed785bd4e83f31fc1430ab9dc5b53f25cb752379322f5ffca5f485212d8782e5e19606ad8015f14f00caccae7e37239709fc29db627b444b0b01975adbf83785e20dec9bbe408f4db982c6514c6dc529d2e0a7efe5bfc9876fc24b7b7057db86495d900639f562b6fcf8e5da6bc55d41e186c1d0aee2effca95ffddf6a1710efd3a498e518e69d02c3f0c641f9eaf98ba0f057489e9270ab49e91964bf16bf4b963e87a3621f33bb4a260e02bf1eb713ddf0c1239b36a04297ee39ceb53fe6881d1bfe3eedbfe7b6ed3898255d0b19746e776abfc0c0a645c1c61c7ca74e574ef20d70233bc8aff631d8ca9d4a3febfa66ccb3d6c96e9e17aeb3c30f73a4dcfc54929edebc12d4c5cf1f232900dda8a221d7b67a34bf092711234c112c5ccb7b5fde2b0c507d519ab985e4c8c74e2ce84974bbbac71bc38654b4154ba0cdb6b3205415098ffa74f1c4c5cd724e7baa3e0ea07b25bd0bee3edd10113cc1fcbbc539dd8f3d156222570244f532e348a430426395e33f147b9dd70e0abdd7c74c4018325ec7dc1c492e024252a8ddb2c60c925e4862bd8a4b00c295d829db66587a67b8bbf9246a3cd3006d16a81c94d1dcf08c8e3cd975986ebcc37d2a697e8ec4db30cb05f92c773fa958b10257466136cf319210ca9f6c05a81cbb1126dad8013db9aea5de34f97c7443c0f98a862fd56ca0353233b9728a87ff99dc84177a00e57ee38f732cb67194b595259673cc715a04e49d80228db0110fa658ddd7e231f9e7814c74e9a7caf37f3c5fb6801b8eedb37b532afe3d5348163c5e03aed2f9bf1b80f963135cad942288392bb2978d9346746b9674a2df8f899f24ecd2a96ba2a123119c04b93a9c540ac8c18b938409b769f08fdc4be6a193270e8db39ca95ab21462998491191795b57664fb2d787bb40d267f98aab7f29f770f00ae4e15abee10111f3d397504dcede221ed6aec803455cfc98101fab25bdda7d45547e9b1348043d8899b9513fedc42d545abc3f2ea1a448a53ad24e72c412223b0be8b22fd5a7e3b06cc23c5e24022ff34e8dbe98d4ed889051d0cad3092b0d5568ee0e5d7c627bab77e383a439f16945258a7292ab582892cf3f023568f5d61d2304ecec4f404d182b018c8f4303de6eca9fd96f997df20885a5aeb877c07eeb5ab9c8a449081274702a03c762de8811c026c2a6078f47daa59dc622457580fe8447e8743a76ba47bf0affba291e6965db48055ea6c1b46642e67dd02a90466a373407f30db6bd12a545188d6f7b9dd9a37cef78bceb0e667775bad7fd919ff7527b15b40edcf02c8f9ec450e00f6a51a2a7abddf993ebb38b7bdeb33422f1c1a18ac3a71daab872637185c13938c99fb9f2f51dc2f07e22d186571c93f3bc89045428b0cfe492ec7697b5a80d48706fefaa80ad2115b0a611dd348389969dfe0651e6a7362c6e968a738751c0d276187fb85afb787428d573638758a140784e6744a5e39de2e149eaa1082a26f9f0b6b42d7dbdc91e29b0d5c7334419e64def60c125a68a4607b956816511ef6367eabd9b24a279cc8073e26738cf8033ce95756ddcacc6724f661cfe39164fb10a6b4c84221b5ddf1408875c2afc5a4c839fbcf5e282216d366a6c13ef198fa2a9ea9029b552dfe8c591c1003046705ecf1875a226220c177bf39195aa2694ad4482f965c30753e373ad79fc710439fcaace8448d6eacd63279e241810dbd593a3cf4d621e8547b2fe9df53058879360ba8f981d6b2a642aafd7e67ab2ed47a281498ab6a4ca80abdeb72af91d7f0975b03afb4bdc6e24dbc19a699a93b086524093b588f882ef97844bbb8ac32b0b7f6bff70d32c06dc0ccf44aa95991771f67832ea7689b544ce37d59fe23a4801785c22b744a534ba9422c360577895eddad2f7261133973e76280b9780ee0bc7fa10a2b02608aa100e518260f8c560dd1d3b5acb19e84ae480ed8a0871987b3856dde30d4f17755c1cca96788ceea692b889850c55c53bc62ebf0f8b467d5de1307b78efabaa5b07f82033c396a9bf8fe093bb997a497e4cca7869ee97042c9bf492ea9cd6a2f267269138c2c0aa57951b0f328fcff7441fcfba9bf52eb64c613352f44b73559bdc35709975126480acbd021de53fe94ed5bd0a6b4fa2e75708ebccd1073589af75183f7453871c9796e2b10a4ed3973e8c5dca79a39b4244d2a057d6c70d5494a0dba897b7018b7e0519be2367452d1a64f938cc8c2fe432c48e19ef2eefffe52accbdd3bc3bd53fe2b31df57b9b19235de7bffc62d9045909179137fe02ffa4e3a2e475c9d536dc4dfab48e425e6c9815f599725c44401ff3d544320a12861d8cd427cb0213aa5163644a35c8356222ace7405003b4409e027f9431f7df58bd3538ac73a812e1c5cd9df8463e38c7f0404d662d9698337802d746e4f896954a464ea1675765997dbc13f5b3961e1f07714becd5bde3a1dfcef7d5a22acb88314032b1f4640cedadd5d7d9aa94f1610a91bfad855dc9118467eb73e0d0a42f04532fc605d0d13cbb05bb5d26cf987fc44a99a1a6a016b15d76c308aae693d302d583fe53c9aa5e190a915ce9184eadd4963c5fe1516ec5868cdbe6a7b27ab05ffd5849b768d0a31e9ea98acd57d9affbc86bb41b884fe2406137e287fe7ee0ec64f75f9a49c05056a81dab186f8bc839edec47654928b494644b295eec1175785e90ff88b0f397f85934f0147b2acdfdcdc0706f45fc9df1dcddbe7c7014dddb1c41f4790eb6e3246e4cba0f4dd3c8d2ca38c9dfe0af233fdb254aa185ad468b981f309b2a5628e8f5018e6e30b1e64125bdef04441784c18e6bd9f7750c5d21b0f0f27746998136214eb3d1668afeec28318bafd6a5dfa68411cf860ffbec37c1449f87cef063cf99580ddc27d109f86750fe728b690770baff370934e087f23ef55dd0e438fbb337460de6000e8b4af7d5941a113456f89408d04ceeba69951f6531b01fcc35f156fd3faf944687a7e81e0ca1ed3c8aee52563c5578f8981bbef45ededcadec24127ea42667f4932d94209ac3f2b501ed9e2e606aed548f3c59ef62ece9202ba5370f8bf16f1a854557bb3bd27d1597f11eb2a86e7fb495c017f48566c658422e976a73970658080cbc00360fc434e427914e0c0270751914c7a5171c86ff2ddbb9716547c533a2774337c21abc25a43531cb39dc886790f9ef65e22d6c9d737467e40c1f0a4288ec4680c28ebed7471b83e85a42b97353a23c67994c614d2638f230498cb07846ac07470dfcb68a1de04502d6d7635879b7adaa8032c3b3da11359b468be590704779ca0b535452d9bc3f42cefc3a4d31acbac499345f13e3be53563c5f8915c22d73d1b92dcaaf52dd4cedfe0a243347617a5615855d5774df1036128aab469a56c8b01828cd4d3ee75eac02874a60f4be598a54026a1c742c4d3f767d82861e3ce51e031b98d101dae07d350e1a4ab8459cb3136b1ff5297a675418c8c7e22faeb86abdfded6e2d9580f57e3dec2d9f4792f1e4027544cc111470f745aacf90ba864a40b91adec0089cd966c5a0df2951d2b6b37bfaf7545ac5e039dcc5aacebc7a8450fd51458a78b221aebf6a400ba27943141984e9dd75df1d013f73866dbaa539554445365b02ab6f02b1c24cc82666ab48a20a2bdaf2b91c787aad44bf288a89eae5779e61bdcf70d4864c2e7a24b5e145a840067944c547cc7a2211f9e55426ec0931d8dc5a72905da7858c3295565e54802072726a077ac6cde07a7bf4bd871b079272f23032936944cf942aff9202b0a8be124777777e9cdf0c9f275dff497e43a9af604b0e399c5ea82a36c32cb906eab36f4f64995b49a869d3af1e6c0996a1596b53d96477ff8da3c334b380d95a1243b2b5efe31cf0f08e5a8f9760a4a7e7a113c44b13c5ffe97acbee69726cb7f7cfbe88d375cf4deeb5ee5895c37d3f55cb6c769c0613396aa1e56ad6691a3a6e111b318539c5ae6ea7980e7a2204cb2124c7a8a1da5a026bd161fd74f6f338ea5dc9b9866af2e68b8d3c423f26382dff94a2e9ce23c4dff6def82a35f838dd5b344c49693399ad17938a3b89bf572fa9d6fa713abca2cb5f8ac9ddf79ccccc0b6721d450aef7bdd3e4753d3e4e6e5c244dbed02efb8e6cc7046d5eab9c6ea2cdbf67570cc4e8a2714e96780cd318f7d5c4de38af6d5dbd5e4224a8f1a1ad010b6101f20b5574fbc96b4b95c4080d7190436f1141424e70eefb7b2e017797a3bd1c9ab94d68278a733ef2352b606edd6a3d4c05e15f57cc5cd0150597d2661ed97bb165282eeb2fb0a5b097c418f0cf8546cef019902547971585fa01587e889ee385b2096a7fa0de5d4af4172e81744eeb5cf6dc2ca765ea4035df6214f244c279ad54dca9e4618ae313e2aa27cef583c08e24a981412eda330357528364284094f50d378200adf468076de06603d653006404dac7c83a60da6299dc746ff52efd94165f1626c3996ec970368b48aa5ebd4c6eedc22c0713a234c2d21ad6985af76d991f91c5ee479eb2fcfa1e41aad5d062a71fb07ef7686c4a296908a7d6f7818de7044401a8e7e0667ce4087ce7060ac1a930361a8d5cb1e3b141ca4eac6e947c1a5a5238c4f8cffe21c3e6c70ffb6ca9ef66cd0f87eec0bd960cce5fa7eee8c642deda5106e03b90a1ca8c2e7f958b91969553661a6cf6e6fc90f4fc91ca214aa38f163bf58acdf35b515466f72b016bdda9b6316d5be4789866611258ab4022926a5327ba2998dc3908572baf1a4b6271c1c03c37c4c81f656d1f4da8dbca2247c81719e93dab0587672aa6028b6d19192bf98b23f4e1abc37fbdf52bf17edf303e1bb6f946a65ed4f3d20f15295fc18e76b71c42bbf404ce19efa79d0d3bc8b0ea8787772e476e3e326aa0ba7ae607f1b7d62c8f16747f5f3610c0b1e0ef751c5e16653a669b23424664e22ed08a22ee5cbc81a1e3d6e1f888fc33431238735c19fea677dca5743f3c6efdde949b431e4daa9e2d8e8c428c1543309355d81e7451bc4de3a5130609b79e09eb4bb848d40184a6866584944b830976c4cc144cfeb38e87faeadaa452fdf36d7336de6e6199b068710203ebbcffdef9507a772ae128757e7a64f58510b64ed699accf66f098ee41991a8c585d7ee35d54ee44588b9e8cb118e40cb7713a0a3a08064d87636937d22ceb597aed0882cc18ccd4af3aeea49a89b84f033954eea6049f8d2508e19ac4d04435a23b199f514221e266e237fe3ad583c90c58dcfe00fc3cb886ca6fce1a57cc9942f5aaf1334e39cd98a2138c2efefab9f5eedd38d460e4a693bf524a20fc0e90d8a616049d14a1abdb0d79b6bbea02f4b285704ae8155784e547e4e8b917abbd92115520718f5cf47aa56794f4fc247ec4978582a1dbfd871119e6655ec32803aeece3c328dbc03b47892e800d755ad9beb8543cb4973ef92ab1296fb676a44730091023aa6c4e075206cf5af2a1608b650bdbb6c35370b26ec8030dac5b5463b02a38f4c29fa41e1829f9ec5a502b0c79238a4a57ca83ebe5927a0a5b645f2e372e41da2828c48e7384bf6788ec2baa5d9793c1b2158c607f927f91cab0263c72a72321eaafbef4fd52b70c086c1e6806bfc704248cae828b24b34a31643b5de54d23305b524d6549009a20715ace558cddced21055c2734c9e97fc4cf8501378d5cb2191f1e773fc6e0434ad20b43c3f71c6bd224bae0a956466f976a6b2266bd01647fff905d98cdac7366f7cde679d4aae5b35b6844d1b81feb06c08cbe202b12942e0497b4bae62a57a182d6005496a46ee1c9fd1f8cc5be934a7d9ea77052a66a0e3a018c018e4ed52b74c1f221284baff0f1976fa27f64dbdde682c3c366e66be907a1d1f2e526cad6facc60629fc35fffb18e90c395f75afabf219f9418e1e318be363b9272fcdf37cb59677ed82d47ffa3898845d4b6ad99d000919a705ce993ab9a421e1ccb774a392a8a106a44f36b24e18cef036f1e1e211c765ec6ad2a37ce652384b7fc7f26a33c040697ee309fa0b6fd552a30a483603eed390887d034e58d8d45e5defb12e999be70d925008232c04539c23890dc884f1eb1a78a1ed88ee8b4a5dad771da2300a8cd95dd65d8efe0f1365c16bce68dc921457abc4935cdb08f793e7a6b4bc44d93f753bc5849aa6b6a82a9f53fdc684687aee52539b435bbf3cd6cf581c886004dbfe936884bc9f54473e07df103f60d36bfbfab616b478cfe129ada19c8cb15b294daaa2bbe603d7496e0fc8fb10af63952902b99e46cb239033ae0f711c5fa6b3585c691f6df73ae6647e6f8e59b4153aac245f316a28f59e84b70bd12235e6e7392157f8236e406ab43df86174be3edc811dbaff467b1a453fbe90335b47417e27230fc8f842de5906fb369529949561621c6f5d193fab7c8e3220aa1f8fdb218298658ee7d8534d3a4406eb70b51a25c8b3c6c6d9ab6ccce865b9fc3ce8ae956fa1bae9e66561b326097df0d56a7873a50b3cc1752b3965aa6cbb783da8302e60bd240d691935b1706e8b0505b7323943a456815a4db54d9911030b51053ac12088e61372956fe68194e0e2505f483235d8db041db5db353fa4bd8bc4c2c6eb3fe880d87e37625ffe1336a6b0c62d14a7eb3288afe59aeaef13fee1e6d970c7378f6f2560fecb0ca392b386c423869761fa4d567caee47fe45e76a610b0f869a3046e3e4c350a42197030e8b6d1abf4dcb1b633a058a9c8c8dc873e1a70f00f7467c1a51a2b008e03626885c721f571fc7a9ea26b7aa4d4a9f6640981d03618d1396000947e4b5fe07687d33e0aabbeedbb4bbf05360af4e0a273db4002679e2d81db45198b20a0d0b37bb342167b070e8c1ef7a62e9fe6d349fe729c67058b943fa36143ae320223b1c68ae8ad774497419288127db4e2b1e1f7273c8086dd1576d6ceb9f29c9b211c375a109b12548a172c0968ad2892b78cffe673e00f7d036b88b8b8884235be6cecfbea98f6b1aa943afb1db30f20a76477453a817e7cde07b1113f525053ffbac461ac36ee90cbe179f28a034807134cc59a10bb937370b4d1308e6f88c8cd6f0170d60fae526ea2f0875b0f03939b893f3548ea43475ea04fe1cf38a5700f6720a2b924b8a37b6e30fda1fae314f43754d18ced7f8f33a6b98f4699e9c97d26a434f0cbf906d80343869b8e93128f550b75a57f0b7e83e546bece5a94d65cece2bc681ea044abcdef9aa9dbe1913450fee426436bd4a5afc9db7a0b15c8dbf3a2bdf05b958eb80e95e36baa6d823b86dddd2136f1fab0f1f3267e442cb2b9a1f3bcfd7a604e036ccd872c5473da9309cc59bcba170ebcf10371b0f7438f0cfbfcd762f96c61ba947eed8491ff72d619e901ba6da12cadbc32f0286e1213735e755d41309a2fec4b9df8f72f22c9ff83de24ebb94fedfcf005e0abadf44478c29bbcd62e1814df40b3842ca5651e8970a47b197068ef3b2fb19d74af082593c97bad86b0ecabad95edcd748d8c4fe056d4415ba7a2de4598c8948c5b6ce937543ea39183ed9be436c5ccbc35e7b49ee0bce5ca2395ac54769d895d35318549e80ba04746a3ef2555394e69b8c884d47b1ffbc52d35ee1a1ebf119705151bc9485f5ccc13780ec15c20e96bce456f72f6f68e98bd7ebb94b009c6e5aca980dd378c3410a9ccdc622cbaf9dcde8048b6448c59647f7d2b719b6698f808245cb1dd234b8ed17e106df8f432466d8fffb4184a2738c87373eee8adc35b46a55888902fdc72bb0bdc72e3bf5078d44de112772fc91111c6b92d3049560815492ba0d054989b5259b45f35be7a6e6197443f9dac006b55fbc44769375b4f4a839b109f3bfbe1769a1bb0356d3e73ddf52a45d3e13b2074137325135b1d111ef537ca7f47236db30acdd46b4f319add11b8f13062c272d9fd1682ca8ccb1cc456c4b4651c0356edc1ab29f01727b4999fe633054dd673f65ca24a4717567a67ccc0ae6cccee6869d100823dfd515f26dccc8651759b732129b396c87df94aa26203700aa824847d4c5da927d7c9a5eec6ef12427c4efaf79ddc3a29b9f059805c7286898b1fb28fd24fe1bb3ccaf20851451d50dccbdb7a4b13a67d14d19f0ac5a61b49d7a9ccbbd2ea19639090d808b593e9c8a35bcd84e37516f9846ab7555bbbe6fe9f339494547c45152f28b41f65b4d21652d5116727cb9a69822d40bf942b45257be038963ac3f30276efbe92dbee3f32280a4f96caefeddc2fb8099f16c3034c651020af62efc695a78e13dd9e4756ace6a536fb1575d624ae47b2187f5f1a9020423a224e65475c437ae6c1b611ef816f288fbb389092f0113b969d66867f91c62850598c859a338be083d722ad7b45ffc1ddb391baabc0d69edc0b1235085120679b45ac18e3db09149ed8d88559d64fe5ce329e54808af9d68ff0f06b2ad6f25b321d7249d5c435dba3ef006402fcebb3a5ce8c4d0c193855600333f9265c557b40767e8a1720a53ab2db7e7348e1bb3a65b94eeaebcb55304e259486ed319aaa424002d817dbf90640d7f7442ffe03f6f53677751193de109b98a92cb1267cb40488e8bb263fc5d136d2a51cf23a20fa47f17009c8f3c146fb53d2a6b4491ff5801dfc2dfec5730e40000423e04787953c922d5adc983072525928f0c411241e998ddbb4cb4fae81f7e217660936c49144cf71435329e1fbae2bcbfc1f0615cc7f3467328e1e61c71458bf8b274a808ef7b573eb8d73a17fa1c620bbdd8ae74c20208f2ea14c649a33ffbe603d9bff0e83a9e66fa2b0d854fe6bd276845a3a30524c631535dbc0b885db62cec000b377db1853f9ec109e647e34fe6a2cd997e513a1a7a018c5825833e44733b2f6dcaf4f94c05b614acecf7707111fc31be255833a18bef2381591c48adb1ffdd0ca7bebca0553c70a135f70b12ba1a554128a651739e7b47570f93e690accabb2fbbd696758dfd7fb19e56b36d45e0516d948b895f92d57e45af1f11ef75c8b941557c27ac69be9c773f0cb93531bd8081618348998b1950efe2cdba0ccfdc7a4b3a3dc05b413c224160a982b228d8318a6a752f276edcfc531fd9ee72befe5cbd8caf3975094f5bb24db6f5ac271946a16e0aa1895039255e5046bcc9c0c1f0b509950836cefa9438db13ca958e241d030d4e085ba522b70f32324a6000b0143e4afa3c2583dff14cb4534ab1d68b59006e6fca7127a0e9fafcd2a3ab1f3d3fe57bd4cbb8a7f0065f9128b72154eadaa723907de0fb546d097a493c07dda03284dcf85e0a91a1b8ea3a33c95a2c20f023b0164d084f59842c2c6e6edb19e1ce6ee99bd055c09ef84608d4195717d84c6c330826c1f2ed633fce718017903e3b08f3251d0ddb232bbb1d504c1651ce5ed829e5315dadf9ff6dec3c43ded1f37042da7c06a3fee3a94e11678a5af1cae1aac2bb0aa9c3294972caf0c1d8d750ab2573aff9c98ccdf2744f2ac3e93d09777c3abf169521ecd89bd9f84966c863ca36afbaed4b2084960b04d83147448a5431c9b513d2ea3a38939ba96233f4edcce783db20dceb76b810b76f2507991ffde70ba6f64ce5cc0c7bbd0c6011bf49773e2a86eb97a90b18b2895b35c44c5fd641ce5acb1b4b912270559566a3d8a77265d55b343e4e113d4b0af3a6682f7764b8dd729864ddafda05bc8ccc6ff2fdfd52bc3f54db949908928e3f12a37d3d43e7b685c7fdf16619728757219b9998f4794ed2f2ebf59600cd0f274ab7c2dfbe68cfce93d9860a26aa0a40328fabaf40ded15e32b7c628cd6509594073f226a67ef5e9d0efedada8ea558e5777f34b97e0b2c65dc65a7877ad2da2f7fe717b2d25a56d3d1c5e9bd4347e4da4a433f0d58606e3b50c178bb8eb073b42530ef7bd61b1f2bb2ff2515c9ed818f1ed9fc770e849600ab0151368d38a0c1bf00994111bf67cce284e8751ac06c58f849e90624ffa62241c16281862409d5c4b986649891c13e3a898073294ad738d9aab96887e90426a66f8ab3a246031056c300ee3e593509207edf3133cfcf9c5f87364695c44e303f64cca2fc9f2f07a5e594857c47ab94511b8ea73cbee895d7bde81940c2b997382a381893804df38703776223c63e18715c20d79683602a95c5cf497e0431da145e35f04c87b7122a5045316f5b6d7216972691522a31404560e7c8bc153a9e5491653191b04607dd2c2a4fe12a525bf75dab24caa3d7c46aa6ab57cc73ea0b11aa77f95c8b2b7cd28cbc27737f9b7e727bf41adc96111f85c389676dc6fdfbc317db9ea00ee36a5cb65db0746ca6534d083705110947e7fb3a809fa287abe7bcbb2d5c55ac07857737a0a72ec38c73a50d6ce75a002583b5e0f46cdb3d6c671df80ae225c2b3980d07fe5c90b8808974dabb9cebaa4f4dcd36fb2feb8cd0deed131ecb6e77dd8f6f7969a1df99f136ac3b6d14af937ccff8842b7491735c390d3cb506a469e73754e9bcae48a263caf6211fc1553475967919a0de0ed4e0ca927cc289564c33defa4e86263f67525de8bd5edddb0fe93832b1295e641c70cf15231c008f6c73b692b390df6d5cda13186ed8ff075e5f47c68cf85b54b07afca79d12db4da44430b6702e767b1c775c84b0bafe3b801e91ea9ca4a328981c956de7b07bd3cf12ad4cc165a5e11e6b9d18ff2098322a53369fd5839311aed11ab04d827c336b342c0928c0a56745b2d92eaa04ef8930483a9701b95e4436de0ed7310cff71ad4a3cf2493d1f9f856937c71a3dea0afffa7e6c2661fba838260fa356e4be0de5a7b850868b0c4d88fbbe5d54a281f27ce78198cafc036a02f48956352e2f0732b0d54c280491805f2da98350b16a3b226370ab529e1daaa42d3165b2378482414f646b752469339fe49f5934844d2d6ca9a103972c30b0fb3f5912debae3674a127b4ea092e08d7c94b9b2d7c953fd66d7781188e174341e4df4ade7bb2b9a936c56837f494884209872ff95eb1408835e872de7ce240fe45345c9815a79e040ec2c6ff2fdf25ccac8a238e5ad2b5a3007df1448d1f725c5fc3cc4664a1b476f4b1cc154a2ae76a093e09209f10990dbefb5c5b1d70c6418086da1554d396755a2a5f710929ab6321a662439578ca1673656603d75c44944b400a2b99af22db15d697e7cf5bcd81d30b8f11f349a409765042e4aa0f48fe8559a9182052a6e7c45a0396c140e98320d6048fb2526cc1c52cd1e7cf86b55094dc6db9ecb28efac047188df28bffaf2bda75936948e32141797489358a0e69daa25c7f66f65b16c0bd467b7c8d8147fb184ca0110fb03a7ea152790ef4391c0596502934cd44cda05e05af266c0d49480d615f8e1cad8390be1b3299112b9fbfd2c64e6df3ff9c393ad89c6aeba7192f88f0e36c2ee40364d248998e2244252ca8afa2ed8367dc3679e4ff6d7d1a5280749f55ed734ad7974b5dd9518b3db190824893d11b356d828d208a3c265c6828ba7f491154df8589949d6e5f6a8bd6006e5cd3f53bd23c5349feca6bae4ebce8e5920c7c2cf97e0cd6343e288a1aeaa45f3fb00660ef0df750768e4eb1cba9aaf3361c2911bb18dfe8d9c91d005c4e9ed3db6ba34809572e43b9f154a5d7601ea499ade76c705d52950584864b653989f1bea937a11ef262381963833265157ccc91fc2d4f8684bef087c405517c8de189f5e532951ca397e910ef4ca8d59b239709ceed5dbec54e1026239befc92045b825ef2dbe54f97a4ee8806eafe3a1da726d03cf9437512fa85e35a65519519da11c5ad84adf5f7fff492e47e7e560a127211440ffb37bf223d7f7cf763177e42148bffdf2bd938b3fc4fe0bd7452f92170e26b6952a9729242ac3f5eb29acbc170458a2aafb2e09cfa7aa05ac1ab59acff884fbf80dc5877bbbc4c9caac387ac212ca96e6e12adc86555297730ea6f8805cb48c1fbbcb4f927d7aa23669d9a2231003f0f4d2413a0d066a5ea170609f802b05d3caef7e0de6bcd6bdeef70533a8057051b2fd072a6a41a331266d50db7e486b732ff7363c0d08d93745db14013f352aa9513f4d8acc571617f005c198f7a86e385fb676dda59ebb5e23ae47c01bf2b6e63b02b0bac1bbd40178bbdc5c2ed70a6e3c1ad08192622a63031f859d5df2ea1ee153c7b7853c6f7cb446a96b9b11004a0fa04c8ef1eeb67bc97e3ae6cb81d6b37aa6b76cb71fb9cd3d8a1b97a4a20a954d574a511d1903e2661a7e3f8e27e2e4a051be64a11421fbadc583f7782a2a9a7e855b431626af0f0fb709b2dff7ebf773df91f870ef5ecc7f040ef9b009c2be651dfc9282c0c9d04dd13f69c0ed92c0bf47a4a927dae8d7c1b4a29569c3b4f13c944cd46bc08db9f7d6e1ee1b08bfec5a2028b19682bb1df8435df9fbe19eae5ba91717f2151f69a065042dc3fe69d21fef8376c4d97e35af483baa5dee2fa591ef8b2d5f3793a3434b3c7d7581ce50ea885504e6705b1912b33c596a63253c07737537565763be6b0b880b42e84349942a930bf9ebd6ce7ecd1b2e702560ca14a36e5ab2a93c4f17c7f0a2ba5479a473db60a9f874e0818ec83d55c7d60ebdb11fdf3ad2df3e721998ab1693aad478688f91bddb4f87e5863289fb226a422c2e9a5b99b1c7cbf522ea9cbffc93c5596cf8b3060689c65853767d5e1e38a994598490b681fa86b13fbd00b3f8cdcac619e302003fc98b6a7415397be590e79e3ee560fef920a260c1f2988ac8fec9b68eab6be32703fa32bf029da13e52a4964fac848bf96602bc1a1a39c868480343232663ef24cb5f296ee0169b4b731885d7df5ad14d7252be74b91e94f664e64adb8e711c7a677555c911e07a82ca1e47e571e61aec4ddde9d0f18e984d98524bf741dc5bf907bb542eb988a06bfa3bcfa5f1cd36feb9bcb32d0c5c986290c8595eea8f41f7dd33e3c54b0deb1adeddb430af49e145c4d398919e332a1cedb5efbc409f90bd074da5903eb67ce5749d7615196a204b29c32729f925396977260228711d2be78caad607a9f7f736c3b2a5fa7be245d0b42027ec3f8fbe4a228aad35a962ca920a346c741e0d56f1c8866c578e8e64a9cc0c6786798bbd9555fce975fa7491d44afae6abd54e1739c4999912a7f34e8daa068a606617494e83efa5b4406d05e0aaac1d6029152425892782b968b8f6ad7c6789876df60a03f9a46531859cb8f9c3fa9f4a1e8559d292a0e60926b0909725d6112fd40a188d37b7e897acd6c5bcea6b87eb9e61ae5558526ecb8e9c2b71da9872ca4951afd2490cc707c076b7fd3f3d2634d6e6e86c2b062ea469288a6b61d36f9e6ef17f9e26ae588ae141e316e852bffd0d8ddd228c8952328c76faab59e373723855b76d2e9004a2bdfa2edea3001189f5a8133ffd8c912d6857a1797dfe3503abb98e8232038bdb9c5a7dd723a7e7a93e14cfe7bb8e27729c1bb8e2b5ec87b390de335813a27cb0527702dc40049de80c80b43bbb12b00be9d5bc5e2e887ef6b44adb88f4f2930d752c68708b6222ee1df298cbc1792ddb88e4d1031997b47ecf25d18ce64da37f0ec7b1e269f8dbcc7b33cf92c271b52db74cd72fc140bda1a0538602f08d515a4774a10f607ebd7fcfa667739224d762f6ac8b09aff85ac970ee50ec940ec3033ce31ab9bebd05f90e9c4be545278f29ee143fd4aae6c38b0417de9b58c357286687825639f6e75010394c210ea15a65ef4c819ef2660e1087af4fb5c193aa349fbbf7d609115b44f4ab5b53d2778084fcb27c7d4b84f3fe3da1252778e57917d64b8d26aa11fe2520762ead7a1c5d8e0a59d0deb8e742396d396f8cf1f93dd8e3b1d0ceaec8701a92a123809a3053af0472717e104ef9fa2e6747ae8f294260ef989ebb6ce1a86a167bfb8d7e78bf47715859962dd25eb77b84eff1129842931ae3592d451bdcd105af50845052a112e36dfe9c6aeb9766f67d3cf5ee99adc75a5b489c255fbc692f558fd606476aff79181b27f26ee07f16ab7f18ad1b369d84cc374bc3796b10260ef1e5f2fe4d0fe7a6dbc639d013302b1128218e68735b0b28974e7c4576c98d284fd57b3a7bc0f1003937cfd1562c0f7c5891bb98fccc95d80f827620ea3888401b58cb1911c31891f6295a77a60bdd3fc87c94c852934ddafedbd7c8a2bfb49ec2013cabe990f5ecdb05cc82bed564fb4aa5edbdde5f6f4e0eb9fb9be97e5e8acfbd02938aaa7ce6a4534856a021123c9fd2193fa608d4f0949a1bb8647fa55af74ef22e74f0a366b81f356d21f0d030299d4c9bab1e131d555168d6367d7d6209034c1aa0b0b42e8124d303dc0ba17a2eaef7fcb62bd38fa9fb8e4768f613517f67fc3b0d8a2d11f8ab3caf272f9f30ffd749de3eaf952b8d8c236568c9d2d2fa1b0d1efa61fd3ed24e9000835d47c56666da9b4854a465db39ce1e7d5d124d5d30c9a9316ec320d6742602c77d83a3a19d59e5f6f571288ffeb94116c2c3b11464b1128cac42b3d600e3db5961e2afd18cb904552c377d5c15ef0a280f7c1f43e250f6f63bb35ab1ab5dcc8353a717f9b4f9d2f57d9feaff46b6226858ac39deab10fc7b966b15402b5ca5d5fb62394a6d033f77b6706b47c88fe9faf38a6533cc0964e46e941e231547f0c49c2a8a21ac623a0c7e990c2e33fa55aba16cdc5ed172b36931b98feeaf89c921b9e6f9362ce985e607310e6adc94c9e6b91e0b88db6dee3b1ac91b217e227bb194904f22287f11d46b5968a199af529d6a1abd084a477de1118f60c9b1a68da17fb2d5ac66637c33f07b8a7be622756c3a4c5def44a67483451ce63e73fe90dd76cb922825ebb035383de3c42121b3d93adcc92e154a20b9a74b7a0c325fc2afb27d53f7d349212113c4cb14530b760e6c329ab3085044fd809a2922c94d25fa57dfde0f1ff3f4159d29e396b6101da2ae107af510b7a6910fd0b6834970a0a1d6a32fd5d5df52516211f7df3c19c58183522e101502c864f481711bff8a7508e82c1ab95377c60c7bde8ea14ea0b285f388c2b3a907158c3b8084596170db3e2e87e14076e15246b2e6e37c3495869801e007c52d7b818eef763de5e26b4d96377d42cd52cdba3f6967074552898e6f7382e0e4e9e3fb4f4651f88c30f9b9d5c65e68cf84b0403841918df3d1b63cd81563e5bb0d26537eb83b9a6e3d11031b7a6bfdb351842fa4b0177011e1e5725b3915a513ba319d1f3336afca13e8892ae7a6b482b0a993fe6d097704fab8f49fc9ce9e59f72f05566cd42deef74bb27ab8238179cdafa7669d0a01e663dc281aa880a6d5c1a9fa7ddc3aea4ff854570d416959e42dc67115ab3f172c027635e666ec476a89c7f84909cfda943c1e9684811cec8f4191bc0f70dab30d3ae590ebafb3eff8e5c2dc5d7d0f32bc2ccd00e5f2f7f2463ee0f44498891e710fbbaa1327ee955d294e7f7cb332114581ba43259f4a2658f826b7f4e8ef748a345e01b495549e1582abcc41cdae109aeb0c51dfe2181889b296fe6510b0e3794122f94dfeedad2678db2a1932eba167afbe68d7343ffbd74c12579127e71bf339b7bc5600c69e66c57309152311ce33799eefcb0a4135998f5189432e702bfb8370ef1a88ca616025d6823039ef82a23c4dedf26abac24b57b110fcdb6dfe9bd696c8aa8c37c2478c2d03d98f4568b6698894c3705865902f428f79685da2222af2865f2f552e0effb553ade202ddb982d7ba45d9049741e9d9db57a625a180c3876557cc0d24c5a0d65ea35c3288da3044cb3e32826d40a0359a9e11293c656a41a1e528d5d585477ac0efca30f0d5cea0db1ac49c85861823c98620ed94ab5538a33f89aa5c8352610cd4cb9ec0f08ae193ec8cd8bc23a1504d3df4c48cca50afd01adc7fc8783f06c00115f5be3f65f16e60f720dfe38ab2aa4d4118852814279c8992f5dc2c2039f2e746da8e9d4d97301b2d260a3c84d009db583db796eeeab1bec6825ea432c8dcf4e1c00ed81f28c9de3447ef7bf5d6d812603eaa75546d3a5fa8466edead4f7ab9d7afd71728cb77e67f07704c9b24ab2c187cb43aa106b814e1af8dd2aa637622dd38e04c80e41c35ed2260cfa635e49e4f80a494e6bc93bcb68f78221f19f4966baf0b06868d41852faab67bff28583f058235c02855afe5f78569fd50e4d6a813f924eb69c2acc1aee8fb26f2c54f015f19487bae866c9244181b613a81a03bfdb6dc35212b35622919074ce621fd601afc10a3600ec6cb2a196d0c0df54c70ebf3a34bce076f9b7f3b9f02db131853a476e334e558cab1bbefdd5b9d0a281af5c8e566db8dcac9bd3638223278101b2622798320429af7a344a7898ac5cb4040e0cecd8812a06e07142157bb43d68a8663d1d6172f81e7a2affb88d5fb92f962533890ee140183e85cd0a98b11cbcd65b2406201abb2a7907fa2cdec0152e02bd8426525b21b6f19803ff6215d2106114f6eeec0b7bc7707552a02d1794e5498d149e8b14b1ba248d29d777cbe6073ef6a35d296c736c445588158ee116572a48ecea0a1d7e0b5f1b1b8de08ea00cd8af8c9e9c6b196fb06bec28bb4fa079eba0efcfba5025378962816dd59b8165bafd0d700c326ae98ff2af4039d370917d24212ee87fb5a063619c23cdf99bcb84c08cd5d63d54acfb916eef6ddcf3abba31a4e9246f45fc386d5c9b7a766fbb90a5a330e314812a97d754e3e7f631b94550ee7a52f53825b754e4cca6ad5e3685a2ab14069cf910f2f2ee13d2c09f6d77f58ad85b5c9efadb47f6c68fc60f7471125e00c8f2569b10b5a96466b1cac29a4044c806714ab54f6ca9699b543211a34760c90cb28481fc35406593b726a42494417319f050a714e0bba21b1451a64ca0e37af2231b3a731a2771e6810218a8e3726ab0679319f699a15582da19d94cf1961ccb0ac5b15eadb4410470a3c000f456a81514242d5bb0ed74515bdc466a2e6a111e7916b40ec161b0fc06527be2e0c964f3acfd709aae7e3db0d1b9d205220ea30328aa33dfb4d7a3d5b467413ebb00a09800738e1810f6f82fe339284193128487cc2862abab7f0fcef5385839a94fe267e9bdb942591679ebb7b441dadd51725fbb9945738da7d68dfc739bcdd4e03e29683cbe882665e4786d639455643f026d5d89e465c39918a2a18fa6429d5242bbca0de9fbfb903ab6f9238d9312f8fc4917a38da28c48c52d113031aaa88b71ed61309de723a8e7a6a30e68f23915564833490ec7a43e1c0b099cd44f5c1045d516e85ba66f818f5fec0ea6a03957d29a4dfa4adbe157f30a1b644bf6fa128eaff17307171ab21a3f899a23ecff9f9b682ed54e75d4405ea5c593d40f08e9e93207c6de5119847885b88f2be061e0c9bc97707d13e2e30b39633311162b2630a3d0f6fc952f33b0a7c9203f522e343bd4550907b07099c0b28774744faf342236a24faae3b44f35c4e72c6cf6ae55c4c6bf23515981d3fda6605dc28dc7fc7cd9aa23c8ed15296cfd6456add567f0be7100500c662e3db4718dda905fc0f35861f0bdc7bf1e4dd163726ad5a440ace5260b59c1649896d839e434d81d413333bc59ec05cbbe13f40bed3769268158c17ec9aebf4f375a0ddd449e2c92861a1e3ed81d8c6e2426bf9a6b8c6e35ae1d9c4d1bf78d27f1fd57a88ef200230cd8a9c22a0d2b578c9800571fcc8eb16059dc76e5257ccef96842898a3c4df676f9742785392bfd065d9996b18515f715f7d5dc56f4f4f00ee7db0ac1c9651f1debbcfc8f0e0bc49d8aadffc96e7e012f1211293b853dc3546224c589aa3bf820113fe76330618d56830f4a38fa29dafaaf1f45ef53bbf8a7029c49b230307a2d274f4e325c3229ffaa520b8a5714318dad795947c252c150bc312267818cce2b9bdda11b785a2562b36a17fc71054dce31f7a3ddd8a20ddeecf5c830e39f42971d19eaed710352cfc6e24b65152397e430a96f9ca0e6183df3c5d09146feb7ebe6953b16e74a1ffe039a9e0430347dde07ffce953226bb02eac57e3c8277799576a0d1f8d079ea38688e88ad01850be878bb45dbd59b55e5c7c7f103c8a8dbaf2c6bd40669efd1f5298554156d9ae33f4ebb557a624589a31037a33639f21527fb1ea580678d59d3c2fd5c2217f97475128cca51dfc32b908240e16b55cc3f0954b3fde04b979a65d55e831e8fa5b23f0c8a3a15a92f3cd3a5880b1b9d7bef3dd6e645bc6fc0a43fa6bc8409cbfdc03cad2c61ce7d7f0121b2cffe0e0424f8d84aea12a53ada5019dd873ec132a5a96637f845101a880886914c9c5c7d0b2145b55cd06bb3366cfe226015c012b92ae85fddfc36c8c10f5ae853543bbb8e8e821dc29636a72ece013e1520afceef0032a29cc4e8052ab8cc082f3fc3b09665dd38dbed9d1b8f63f6eb81e821e8fe516cf8dcd82eaae16fe129f73339da8b7f2ce05cf184154fdd70756c8c742f189a0b823585a7bb01e1451c945722068e19d445ec444e805b0b31debe1b550edcfbc9447c5f83e11c366fb66f2214b03e7b7286696ee2265ab45568aa2329562e0b40bccf9d8de29a042646cd39324049069e99f65e229ec8485931e584870b150ba72d3a3c54086efd7a9f8a67ad755ac354f17d65026bbd5c3cd82faba53662baafb510ff7fc7fc1d48c8449f21b588a71bf4415a91a937abc2b75336050647fbf9a570f6649d4b243a2b7ed2c093f894c7045e386860be4cf1c5482c7164ff51922a36b60a271ee24f6a69e3ab29985daae92f2a9b7ab049c028d1717425c3f0b730c18901a7b08569b043bad319514d12bcd52f97ec4fb5e9079d7a54fd8c3f3135a548e62515f7b57e612c331a8afa89d6ef8e49a0b4b5871e5b88e815e6183587e0c0886ecac857be7da19837e3301bcdf5469351dd5413559718690e649f71c8d2da58d388a6fe9f890a944973e7c4c644722a9871a86c6365228acd4916bbaa5c859016426487380cbac3273c8e2ab4fa886994a8ac885f247ae2821ebafaf57154e03aec1c57566758a5bde01351e1845a2b756f80cc46b05f32c7539d33e7ee011e363cae3a6ff91aea7954232ddcb8427493413d44bc8367d73c10a4c8879a4cf30f0fdaf5c7855af392e15c22e24c145e1d874a2b4494b33ee1b6fabfbfbdfbed68e2ac5965edf2b0e7c476149d45a049c0e243f3e7727f9562e6dc9ec04aff0a75522e0f8cf263aa4f5b6e2990c8c745ba57fe5319a8f6be54a93b9993ec6bddf36166abae4d0d2615960fa3c19e3fdc8a2e3c989b41cddd3393dd830d690fe7acf3f66a4a42df808e3bdbe18e3716315f645dcdb350736ad12fb960017238a3e73bb8c2bf49aec41fbf1cf977ac9be84adf586f1ade0b60f975292a1d15ec8ace440ac1f4aee6aa632197b4b184a29911321ae9bab92441c0da442652c44a47a3a042c552d96a49261b7a1dc39aed614b676b2c0fc7a5b8eca8f8bd43cbc07200d82ee2eb70f3fe5a5f49407227cbe93ee0b4d846bbeea38419512358c069da93b813b535aa4568b84bf44dc56d6268ffcb82524d6fd82baca384f70f20518c5fe8a2801ce2de40e31ca35dbe3e8bd0c2e8208fe4d9381596c06a50c8e07e58fdcb188279fb34de76cb2a5e637db0d4654f68a6d0b7c64b9ecb0eae6373793b8f3fe6965c2b75205b5f096f43bd15043d5a7303cfe2b5bf8a66c5c30761342cf0739620c60f3fe79b604271f5991bd3fc0835daf29f5a688f4b84dfe057ae6b63b5b85559dc9c9541152ee45be45ee95281ad7323ec06f799a89a57b0b0afdd2bed5234db695394913e68142a66e932c149a7ef4dd87a98a9fa09ceb09ca4dbc5cdee1a3a0fac3064142a2335d6a85596ba9a56766f63f4180246b1b38fee7ce8df4ff8525e1b18fd3fa241dbaa8c0b9aa82d8d166d7fa2c6578a9ab83438682467f743467bad59afc08740edc173951ca92187fbcb75ec9b5f121468826424c2445960cd95380bf65cc8cb0be82d326f649557e1ff5ccd0eac47f24d7b4fa8d51ada53ca1ab8e39abb2189a1eeb51ab158ac499d77d435ffae93474adc66e2ee9381b0b7603a273325b92a65fd091867e5713f2d5464ddba1694f6150d2b96b248f0783a87960bd928fb3ede73e15459bd7d433d2bb8cfaa57ac005ccadc891070ced22808f7b7d5cef51ca1d4ff39812fd6e13405b18352a8f8be6c90c9da1902bcd8db4946483b3635828e0e3587ae48be7b2a2bb7d56f2ccc8177e8895b155e3e8f3acfb53f431434c1808c0665d1551f29ac37d3371a94740843ca41ebd7cf4c72da1f32264221f226b9a38ca63100703eb43a8f32637f9505272ee088b258a7168c8223a150a5ee109f11930d5dc8e8b3863ae3b697956f57602b7532de6a9edee2e906aec173e310e7126ea47673132aed3ff3ae8221190cc514851f77fcb00a797e1b0515c7eac47632f669399b591db29f830f953aee817f295536a9df7e4efb28696ff7642f8a0f6ecb323c798bef9b9eb5835a3ac4c8bca909999e2e7ece55cd1e7ad3942304e4ceacda8c1eea03a4e6b3d3b24ce6a772cc52c63c4865ebd5ad2e65917f8044701507dfd37e40c722fa118c247f8c447fde96292226a7bba0a9f90ff8a7044e7d0e58dc991b49d66dff3eb2a4330f7038ad86730853fc8772d52239be5c558749fbf51d2128da653c29cf20b47b4307e9aabd2512ad138a76666ec8886795ac7841ee8d23a8430269f2a65562bfe940e2d2800f63a7b233e97f55e2352ee2b6af37b8ba6de57cd2bd4bb5170799894f5ef095483e67b9ca2d51f4a1c3d776482207f755aadb767ba7c4f4154676e81a586c90326fce17e5df974060132371c0824c3434d315b2bd125cb9cc9c67da59523141d9f236259da08897cd56adef60a7da1cee6ee972c9eb5e934530e32ba367cdff492c3da5514433221b41f66494742898b1f751db5e24e16b706d48b1d43e87bfb00cedc9162ad17c7c1fcc106da76817419e3e6dfb0d12e71f62107caf8719146347b157b330c62af5c46d3711820fcdd17c0f5baa3c75d54757bee0d4c25188be172f56b41057da75b75cd47cc8521c9d4629e20454ab79af3470b9ced8c8ad4a48d70a3431ec9731fb3671df36afd9584735019fcde41e586bed6d37e6dcdddfda540a5d656cdf0ffacab90fd72a4750c69a421d9f08a70ece24dc1f91a089c52675a3cd687eb50d7d3ed3318f4180dc49c635c4e14e29336d361f09052cc0e5f9538b5a25c1f3fdf8c005e8f819da406bec961972591afb553f49c2b88d27d280e0c0514f09f609e7b6b53ad2208b2d14c740e5fb1f07bd5c5d494e2f419eb27f72bce12daef55f6893b3b2b16b74c2e4731b1b8756f988ed8cdb9a154f52557c06bc70c7658e4ece787bf64d19d548a68c16850d255e9080f468d678b33054e7d1a3cfbbf83fe394aa1e93f0e7cdb27ed7214c825f103c4f60a175fd4afbfe520cc3040ebb788731cf4c11e8502407830accf04ead039ed3028e92e91b8cd361a2e232cd5bbe27f95e8dc0a57e5e1ebc0500ea25f042ef1ab6467dda1ee6f5e65c68b7a3cc012b848ae811debda47676921b6ee922c806be08ed474c0c3b6d30ff23a505f5e55a66bbb7157369c4898466fed68c450f93e4a70638c72dad541689bd273c6649975df0bca8f6428a96ca5afe19f80f89ba9409ecefb31fce672f75b7307f2005dbbd3334841d0090406e4c96d66eeb6bd1ef6fbee7805ac033521ca45fce27ef1b82e38110d31f9e9e553cdbb7f8572e5e1b61aae13d1680bcd307a6deaee6de680339e783d2a40265340aaa3b31c512731ca166ee994215131b2dc909440fecc7efece94e1c9788c25ab1d749022e762cc4dfaa0bee79065e9ddc1eb0733c6b9f60b87f4e63047c6b706ca7aa28a3670eb415ec0cd607e8eeea677253b414fb4c406f2d71447d4e2ec7733d90e79608ff7c69ff9cc0798c334190c2a73b6f4b948d6f9b63de0ba5f41706f3ae595f86ca7dc50b35f9fd152a7e146cd4a7b71ecf6f4aa67f8a9a69b41d0709072fb26ab8a85bbd5b15b050010b271e41656290e58a9d18753c9a675f32a17e9836abd0f4ffc39ddc8b0cb5ffe0e27b50a6ce0893775c9a5d0899c13c7d2a40e3ece0328bd3f80bdf9507f4e5d8658245ed6077ac368c2a4827afe543c97481867779f32f425955e2c22b0686cef8c0887fac73343eca0702fb90af3e0f0488f3e62f35a47d86f3d40157f98b0a1f46226e8e70807256c5bf36921dad2670c903235351c53806c61ee01ebe07def83301ed3383ca8be73005244465dceaa7014a1e8aad71a906523d6a246e45fd7ab51f3e1e971a6a6338f57926528e6e630749b0e98741ca9a22d3865139a16b323f921a8804af9ec3d1d58ed88ab3a0f3a37b529e9e8367a41debe2c5c641b1574606d15a3134af858a523923e42ae96bfc04343718973d8fe81623ed667042c2a7525d9cf1d889415ea769019336fc27b3c26d84dcdc81a5aab432d87a423044436a1a7154ff891a8af13545912f13539bb6e0504f6365a0cfc8416a87955f61d629f199e45b7e18e4b0f95b289be3bf25964148e1bedea5cc514452324781d63a7ab3a9c41e76a07873d21acb8d47c620094a18d75539767355bafa5b80918a69f7a092b12c4ae7225f93e98099ed475bf8d7417597f426ccb143cbd5644f63b4face0b735eba17652332c991ceb9b5c084028834f54eaeebe9365f43862cf39f487f08f3070aef20015e8747e84aaabe7945ba37c25f5f5f6fe0e3a102c40319e519f97b27466bef51d30bbc5f95a8c0faf3b668f24c2e2ed8934608a43d0ea45c334aa11bffba9a963ca734015e7d1f6012f2e573ec8152a5fd071b313c16570351867feb1e6a79d0af60c0ed8ceef8aef1288d9d61801aeb9e2ea8e4d651407e5a60f8da5195db2ebd0b01aa289690ca0c88d126ed0f3ef1e164e65c454b10e1e6a5469431235036fadb7767160c320fd7a25beb06c50ee7f559270b8bce2b210c38f619f729168b60a0742eb410073e978d37ae48a862a7c90de7ac4883b235d8ff2070e207b3bcb0f3bd3c4595553a5ef100ade00ac6dca631a0e86c1356a3389f537653062d60441acc646c23f275e0006195beee02468ab2be3a723c9b51b435d7add04d9c57a3819e89c2f0cb293233b74c42f4731d9af865c5b8b986bde5e237c26c14b13bcd34103c677a49d9fc7d808e0701dec8296ac94f392f9a844f730ac95eb5aa6faf6acaef9d30806bc47b4b3c70186e22c2dac4a41c6f17524e608a7af79d0b1c40be9610ea114fe1e6843e447c1eb556959011f85d1608aa1fa3a5a1d2afd80d0cf1d754609299f879e69899c717f8153b1c1c007b971f9f01e11a710d24b366666413ec70756bd8d857aebfcd97c7b2fe372cd0a61ff173a93c96713043a545aeda862cfadb33416256b9105377ffce3318b60373124367f15be143e26a4cef880794178930be780f536826f82a12e2d4f961f8f7155d1c746b37c39295e3904eb0b10c883bd079fdea77625ffd4c6ad462a73a45ca85b2277485c0d02cd9352a19d4cc07b991b0f1d3e9d79b7a7d37e42cb8bed61d6b4e7eb20182cfd29f72a9707f3538ca83af90b042caf28033589cc6cdeea35c982ce25ea4f63530cd1dbe2e5a55e778d1c350fa5aed4dfc3b74f8623a0621245d87c017fd996eb6316fcd8d966c7ada8d42a53fd7c2807f817fdadd43f0a4872fcca870c3c25a941060b9cf663d396a0df46482bebd29c3fa375003e216d96b80032e9b4cb4463bf46a5cb270932e72990644561bc15214198cc065766080492142cea9faca92dfd30555525cf70b649cef2de882292ffa8d471a595c5828509023ede941a670ffdf9f00399b98a978c672eefcbd0e128ad387eec38c0b6edcb4a0820ff3402f6ba82ea495657249920dfa4a226d89db5be1a1711de11607cdcd8b374bc3804676ed1179974995e1b91fad8ca83ce09bbea3ed75b2ce2ba0645adcc8caf206a04c39d61c0e50bc5e98130445bbed17d2b74a971401140e984be9da12055e8c0ac67940f87e488ecb66b24298624d7913ce5f5606a77fffe360746a2220ec0f8807474af98c6fb7c7bcc65a2ed635ca16d7175043f076367c20454b8f3a877d326adfa49e97ed1468e0cd066b1f0967101d4f1da2327adbe461a79cc890bf6f2409f353ad51bc342d62e26e4aace5820d0c44c7e7168130500b37367fa378ad7bd27c4bbb47456a46e70b4f5c81025a0109b4077bba30bd66440ec90c81df270f32b54cb0dd7a11a0aac52603b7863e38b8b01de02b310261f06ef530f64ade2d8155f12e2627d8b2277dfada363ed72b194b9cbafed86f0832cac2d45761ca2777d974abc774a6f603d285cd84996759a4269ca6ea947a1027e8912876eb2e79260a7fb2679d6c8f749627ba7c9de440a9511756658e59ae63dfdd8dfdaffe4ccccde42653b4d20179bf961e841a1d24e07b2981ab02f87092a81441ea887275fe4dd5554c3cb9a1692649a23833554290c9cb5db499e8ff83eabcbb0fa16e9b84148e77f1145ef68a6eaae83f492ed257bafa7b53932695d6370b6c0bc19255f65b65ed2bee216d2efe91751dcc23c541f9f679b5c1288ed7a3e2ef2d417dc61ab9add44f3e473a6d40eec9494eaf8761590e5c67aad6017bbd210756148eb93e6bd31d422e8672c0549f7a5dc483d0c170b54421686761dbb34f505a8f6359f86d33b8a5cc347021fa61fb9004fdf4e2e76bed5a12f711043919388715ef75436fd5088ac180a11d17b039b9b75c8de038dbb3065e60f8558ad85aeafe7ae39bb99b2f77153c8f5795e7614586d81a9be13e4670809bc004db561bc00f1c1d9243f1edf3233669532907b9489beaa7c707a18cb9830d2e47bdd4605b97417fdff4d0845946f82676642112deb7216b93af50d7f71f3e0126c4f0e586edddd2fa6a1514b16329588fd83a3585c746cf32e235b698b7d806c8b56d3c597ccc50d5e206ed09a3443221f11e95200e08282f4c46555f79c8d84aef470f9cf96b37471c099bf261bb00da0d0a0645653972974de15d7a8f805ea07fa2e6f766d8830543cc9011e742e2de010b8bcdbcba68b2cef5532554a2b52cb7d0c514ee23c67117265f000d7293ece0928a001b7ca98000223df79a5aa0666c753945d17cabecdb81036999de37cfa2ecc2a06c5212fca7bab2e0a5f9a11407cc99851fd77edd8da71d177c10f81138e7493ddbf2cd69569f13ddbd98b24e21b028e2f79fa1aa49700a9105a757932544256efdc3c13586eecb4444bd4c843b61ca78d5c38601916143439fca543bb194459fb46f7f8f64eb430ffbef74bc4af2f98590bafbdb62e831cceb07ed3d5baff6ff4ef2702837a6478c2c8207ab49f28a268d455a6a75ef771bfc6e9359af7e1d1abde3df829cf337d223e6eb5e544cb80b32c49120f821e580e6b076c6f34b0d60a6a6269225017598583293631b61cab53bf2ab2c788382d14795bc15d440dc9c53068252a0cfa037cce7990e9ba4eeef9ec9386c3dab31f215ac5bcc1e6241730bbce6e2f769ac071264635dfa0f6f3c6c2a1ba77828c45511bc4d3fffa5510185101f8e4f551034f1b651a46cc46bdd900c43c8d3788e4f0a981593cb7248a1b7fe336d42ed52d683d705d6ad1a974516837660bb767704c2652b9b8ae1056cde352f96a98e12f6c005e6eb651bd32e98cd244d142cd909d814121798a18b977296fe83492f3e443f688ecd6a9b942de2139bdf8be30f34f304601bd544faf1f1d9a295169e02e18410d96ba81c183837aae445971f1f0442776bfe9a04e96942f530957ea8edcd824113bf1a9775b9ee948328359ec159f8a90798bf6b63e099aad3fb59f7d228b24cc0b558f3d271e8abc7499d4fc5ceedca9631ae0ab96ba2d0572cb0d8101d882c6ba5dc19f541e81a8eea969558b7b2c149a4ecaf3f97b2d0d6ca75f24f268342da8f610610d738d67afc76a2dd10361c4ff72ac1d8d857dba2530cb316d29f38441ca4a74159b882539403f9210e378898a35228936e415569c7eefb54219316e009c947af79e998b932d3bade00c8aebe6ee277dbd8b0483ab15d35b0fd81df97510abfc2b64e4e6e5476d29425c06a40e3b3f906808a639490344fa31a411627a3f91375bcbc98e37ae59f71c66563f40a59e308adcfacbe5ebccd50dc191c301a61c55ffc2013082fa3d30fd290a9c386df9a97d9b8aa18c5227a0c2cfc8aa03a4cfb0a27657ff2938aa644aba471c462546192903c15560ced976a7de2c2805999f71f864798aae99e97224f9bebfbd60696576dc6739fb20fbe90b919c6e61f2d309dffcde0888c63479cd3596dae59a266a56079120c559540869117734198501f609449f5346c6d7f10dba194324556bcafc972ab559f59482ef2c1be36f68252d92e7e45009d26cc871d9c59d43067de7514e380ba793d945ba3efec96664f9cffd10ff2533b1e3d0944b9f75d69c5714691234816cbc352c6e0c2c90d44f2996d35452bdefe92479580daa777adf1fc37d8ad3c534df07c77776b22b91b8d74eda170e08dce9c926b2b2e712d3ac2bfe49e79bdfe61b677260162d3a1e5f8f9f5d7fd78b7edd8dce64e3808dd071e78a42d4088a5603723a5088872cf53e9310afad527bdbd28a0c7eb146f9ddbfdba34fdbc211f1dfc17cd70dbcb80bfd3336dfcc2ff44001667d3a5e3f603cd57f64d5e46267d9a36ba66d30eee4eee9caf78b8b8d42164b3b020462fb205bf957eb4889845b813f75deb70524e34bdd795c8d39e20a7314dcd3193a11c92fd23fa1c6a6e26919166ebf6b0fbaece5adb0c0da24175b8db2e3f176b96a4ef6f3f291147b8e2faf2c86e444a5f2a77b5f6cdd352dec27977eca86e79323252612fd6a4039edfe4ccb04358fa5d94f0e7e8ac04db18e40affa3a3203c3ac5a4d4c9cb8b0da8c39ac834e72598ce287b0af5ac403538b62f40705441f16a26958e0c2cdbf2f1e4c5d60916928e6dbf6cf57500a13f672fdfd20eaf58c9646b243554e6ac7eced09a1657aa1c40c17e5e16c0e7b4def5a291b092159984d1b4ac2768b15b27013de8ebf8db5240a02568662332044e3e2b2376a24cdcd30e826c0b2462a2ca39bee829759e406d4679616b9774d56ec444cde6e9ff9e4e5790ce44f8472557ce7a6ddbcd90c66d3e2a9eec37de2965019efe24a1b5d8bb648ed7c21c009245ddceee6050648d0b1a6ed4344775ee67c63b46d881a1ba38a92e31c1bf639178645ecd2782379ffd3564a48a3b96837d063348aafc01b33ae7dc9daa011a27ce85aeba86e4d21f1d444e7a0b8bc91d89314416c96d7218567167874b1f96d9e361deb1066643070c0d48290a2ef52d8f8de0fb08f3f75ee0a443b19b93808640baa73aed4ea184504245e689148f233a4527095f8ce964b3d595bc2980b6d41c11e7350d22644e92304c6330eadaf7a26d8ea36c977539fd7a87cc17ac1df382a42dfa53ce6a73274f3731c18ad87c8963884147f99d28516db1699a8a7ddfe9c074760cf36c04874a7c7bab2f4a2772c95b5f31e21c6c505b6e6221adf5792c16e9e7b731277431f6a9cb43a84bef697ad58719444610d335596ed4e3993e4b8f392828b0f9d42b980e06614032a41b1ae037278e660d06bf6dc7ae907c57745f62fee4a3de26289f66e6a2f1916010becd8fb23f0df82ccc2a236c55c6891a936b2cfa9c40c347961fb861df1a7067f77f2e27cb71f0c83c1770e8e6320710ba939c1635e9ebb0de279acb4ecb4f8a01e73c30dd42f107473c150cb34cda28ff47dbaf6a481be443381115b011049c01c00b08bdc11ce9c8f1f29948220938a9c0bdd9ef23f729550c7a0ec00ad409726b3729ec05f46f7a4f1e04fcce270860b8f3918a8f89fe27540d56cf05dd66a9a2a0454176e952df0e23a1f0ab604be443c77d2b5d54f5ad644fd0e6824b1cf11d0e0eaa51fb3ff31038a822dec1d223c2e1297ab7dbd996c714617ccfe7efbdd3eee962333f520ae01d6e9b9457f11ca6b101ff48b6fa2438ad97e0590b282c5a88d7daa3d23754a7e2d97a4c7abe35b3e1bbb2424fbc764dcd1e19bea64af212ec59d66ecb0817a277bea50ef449cee6d7a47ae1da65e9400e1f370e68727493c0c9aee207d29aa0cae2bf11fdbdc998b8718491c410e183a693e3f6824c1514d907ff7e8faf9bf39b1c4b522643cfee2550cb4bb9fe5a79d0e05ac8361bb608bd29fbc9490d6a797f77995ca5d7a669d46484a4b444a058f47dc126476eec914534c1c516f2a8187929798c6af51104fad48faf8e2b4e9253c51661d6f8a6024145af59719053950b5311cdc7b256de93a90c80b5e9fae5e57b1827231678351fe1a6ee1b33f5f15344a2c13772e09241fb35c736bbcee46629eff2eaf480bcb44faab10ba683426c6bc7968c04acc38515f2f51298d7713e82768569a4795664d6b9a1ccd83442031a49d05b28e0577e834a5bb65fe949d036d26ad722079b48247772380a121847f485a201b142af572f8f6f6281b9f56697a434c71f30baa2c297970d73becf32717500af1d4c31e5755889d89099b1d449cbad146108f4f2fe3212d0d755d3d1f0426ddadbc6c379b9e36f51405eade931730ea9997ce33cd1f440806d7b0054da4368082eda4f288c820bd32638b572024c5942eec00dcfe523a32c29ba8ea40a466a6032512077e8e868ef7bcd8ad616cd7b731cb3e76cc8cb73cc0419cfb652efcb2a72a3978f1a5ae12e72e27c2adbffa68c2ca252822cc9620a3c352876e199adf469dc7e5373befaaf051ccaf3a6ee57e8ebe92ed1a0a7ebf651ca05a1e2a3766a5a9fa91d7f9eeb03539322c55688b3feb02e4356ebc086df0730822462be252ced4cf3649c36eef5d15b098fbc237351be187150c06e5ddfd0164165540a8891d9517049578156fe7fc706a3fffe2a05ac6cf833a1486a7cd587cc335dea3f16646b426e989a1103379f1c985302800cb318ef8fa40ca4fbf98ac64400f24453adb5c52d0c34878c57383d2d24621de201e03175374d8f1be8a0a1dcb8d33fa8ea22904f9548dbbc6fca9fb6fde0c453d32222bcf495dec821326b8ed1bb2c17b1ab85831113be6ccefb34785857eecab7142eec11b4e21957268e4d58900f04b49cdd2cab2a6724b2c2792bbbad5815f25e7baa311f5aeae6f342654d61c73a5ecb1ff604233bb04ee2399ad9cac46a4e354666971886839a6926c0c211f22cad25bd5fb9f42e950c8ef986f285baf886a16447ca28debb7883980057aea574d32ed2900b23056576967bb7869751f1020f31504308cb48d2a4985d0ddc7df56f8f4433bd3ff19cf114b8a6e1d81090778dda0724e4a66f011c553647cfee552d09afd9960d272b702e8a9493f4fa2cac102256c047b66a68abdf1cd83571d49e65a39b0842dac5b0e86e7598a8ffe060578686406d750bdfa7c293fd2d7936ebbb5237851481c0c0756316763606611fe06910218e16ce6fa55e4c53c1174ea31bd3d963beae88ffac6c8789e588a159c9e47d3fdcac60ffbd0af0781a5a2dfc15d7277cffbd562d0eecdf0b24040f40d5a3885c5bb923a317f54112cdaf27ab6ce59901fa314f6fe66288b47b8dc41ee0252d19e4f9514d12cbd23ef473beb086a674f7f6f0ec961a6bac0df37a45bbb4e7a7c2f78da4fb0028619c715fc2d9fe384805b83183581c1657d3cf51f2662163429a2c50c42b01986bc3ebfd127a7ca9036c9fe45dd3e57063bf21d94dd98dbdfd77faedb8acc2755b62fcb0ddda8d7c056c3209743b9aefefb8a8de2891b3632490ed9f743ee0f927086e1726ea2e7d72274dbe13227a77b2043998eb8e8f5e576a8e13a3a69e1c019d64ecfa45e46b93eda45310ce10727f74d7b0ea9d46ebe13072e1425126ca9a3cb367460cedc18845bb533aeec8a90a231f98ceb1e04400efa6ca17dba8ec6efc09ec21a0503408524243bdc5bbf71a17207bef4238b0ed5b162cdaf971848c7fb25a9b06fda77a28cf3597edd55700df356cfdd8566921d008402569a4f0ffde38173ead331aa98028e5419d21d0750564b8b8e22d622f0a258f453da44cd937844251a29f58462e99a771ea2e69741b653ff40ee9cfaf7de4c69a308fdeadfa183e6c00b565b871fdd0fbf5b3024b60a1804b6ef35a3d0f208ef1c5e9e1eb9c76cc597d8d0ed6b36dce8a0ebd32565954d4ac3f883fadf0b54ea4192601f1e62d231b5e3e5979a01507b0b77d75f95cf32a30080d9940abbb82405654f205d62637b6f1f87f50df42876c0052e950a0769a06a12aeb970f51f497c894d6124d325ada68c18bb9ebe93eaf491b16bb721322931a96447ccd8e92f213cdbac4c832c001f4b35fcf66cda5d5c7d2d2123911593dc7c78b3b0cba43cfc6c15ae605aabc138c575f82d022703fd4a2326c1ee0f6f97a2272d1defcab11c6c084ba3a01adc3eb8ec340b5e93cc92d8749d8ec3be33d7a38db2f50c4b642509a5702022cbce3adeb6dc61c1ba47d7b99f28cc282520f59608446bde2ea36073e8419e831ceb8530fe5e27d1454801ead98c1c92d001a3178cea109722f3aa8b19c2a8c067720a41457ccb89877c7f9e4c6621ea6a6deac07b06865f94435d54b6f30de582903ed1e0fdb48f1dce3e56288c86137930940a3ea0bed5a532b10aa97af8f5ebbefc51b307a1b5674afc138961fd10257c4fb21261fb96e07f2304309ae7aad59214e3254ad72b7ffc8e76e1eccf61251d6262e1768ce8bc9792e8ecb62a829762f99ce76f96025f7cac060eed9c3a098b2effdd5e705f24da4df9292c153a4faf3b00cef97530411271dee5fe5c0517975c720881538e85ab870d7272a5704fa1cd32f2898645900a09abc37b4b090ea75b41db0f92f6ce3ef9277c3894de09e09ee5e34b62a110a64f9f0d0664d2c318a23f440e6efb146c60c7e30fc3727f918a565d58ef1ab74e877329b6892624862445da5d73bdfb0c56c254d21d254982bb9a62ecc9652cdfd178c1c6096d0374d3f1d1ef6bcf3720fe02859d610144baa2f894612916d5eb8924e5b98f48b5abb631d1e76f328f05885f196cb77302fbe352f77057032813baaa4924a91423257fe63be4e5ae70d03e66ee41154cf136a2f85847e7f7cbf0bafec2340f584f112483c1854a78946d280cb4355f4565254b457327451b1c26b066178972d4fd1346ac188df78919717edbd8ac504e05132253584233f408a8be4d5f952e50b91161fade92b9ae801bbee5f531617ec81b03d1e66083b000dfde25cc44646f851a4cc0eda9e1402da686336c9f1376ac741cb0f7d532b858e28651aa8c713c512a332da6e85d7b892f952ebb537608328ffb9b3be7457cf5672e9e9dd688f042ced1384011c41b0b2bd447752e6927bb77e5dbaf89b5045da5b902ff6c339749ac67f85149201c714e7fbc166550498e7c12f3f306b177172d4abc105a307ef88eed8e1794bbc2c46db3a759fbd97005373806a1e627b1c575d76e11e4adcfe21645bdf3d58e3f4968d5a672d01ac63d169d8d83b9c1740f0313a31342b5591761750621e439850bb0de335de398bc0079a01cd7d0843fe7bb294d041f1e9268ffe9f1d70789445d9a864d5d7adca750ab3e14129403a9e773905ab6cd5f331468a98b96fd88d79370a35378267e0b354f711afb16066b3d2e472178cbd98c8ff0643f433011e9de0a0bc19b3d559cf2562206330dcc7093aad69480743851ac1af3efb0c588ef1ede101efd7eced4434602160057028ce25f1f02f5458e21f76de7e66b668ee4750eb3d5aa6aba9d34f8482999215c26bce98f54ec34ddaf5ce5b7a1d46ab7401e54c55b0b6242ed042569ff560705ad22306b70cbbf5dac1e8731115f6c0e97669eec9694a4fd4ac68639151ff29403d50167ca36dab470733539d1b797fae1624713f776e1a39ceefcb95bb9918efcc153f30bdddd40461c3c4e95a4622a015c4c66dd6b5c5e81bf43907727d759e9af5d83ec0717b25dca965e7016546bd451cbc08767f1920a0b6ea8cc1b4490203ae42cf0ac1819c53fee79d9a8b0fc7776c9eb36126351baffb857d1ff9338f9613608beca6a6d2d2ee91c51617b8a82da8c996088a966eba8bf841cb3ccce677319b6e99ce31a6ed33ee8645edae1d6baa5fc024835ba7ae52ab535fd6cc6cc5ab00273df5ec5ae9c66044a5761fd775a3cb4bc7281fffe7192900728f73f380915ce514fa6505a8d41cf0fa4126210c57080979a3c934a31847a1d8669a2625e98568d5df78fa58ba5721c31335ba6c288104e7f6df492fa11a417680498892b4cf99651890fad71ff4c76be30c660be0374dd99d23f1641dd37b4c6edca3663b00e840caa61fc9d7de47ea884033384e067f3611993876aa215c3c01d40da5ad12f1bd1b44e884597a7ac536f5576e30705cfecfcf2a4d0643e1819e749677586af138142f4162f3010a5c95c9ec757a8f2d5544adb3a1943964f24f416760e0e441f24e41d688fc48c7873a5af8ed670b50fc4ccfc0f9d2392d1e2d98f012e2521c53b51bb49784936d787146098d39aad041214f4c46516e6b689d345fb264e161de355505f19a43f9d049b9584ff370aa7366652af8589c32c77c0e3f4979c0ddd9f1aed3344b8dea659d202287cd277af604f2e3fcc73400143c059fbeaff7576a24da48b146c9ca3cf121fd732515fe5318f0db008c73bddf14486cbb479f2922573fd1689e04586742c2e1c6f13ab55ca8a3013529b3d1f1e8d162e79979e96e065831367c59535bbbf5cbaab84214ddd95a752f60713c592d00ab94bded46721ec901cb3c51645ccf1fb85df04cd2131bd7f0259fba7492ca57f7b6e8f34fcb5e65168bed155a1faa597efc68f339f299936f0a9e2ca33764d204752a9d638d9398dd90c4628614a8a1472078523bfb4ecf137a51bab7d3ac2299732392cce46fd1871a2143c3263e2be88a9b42f69704ab026f3ae690a741a2cf8c158cbba15610908b48b86ce36c7da7a79e4f6fad8baa110f7ce02164f48c14d57d9888a0448eaa760cf931ac6ac45afbd7941af28284ab2b8b0f6dd4608222429644b0ca2d55fac96be759def57eb04fc525d216914d0822e4c6e1bb3ffaaa641a8fe845074339863cc1584cf7fb3b75bce82a4e444a1740fd4af57791daec3bb3fe3b0f58ae59abbc58d6cbb605ae9ee5acbc03d4b341aa2a8fd50054ac92a63802d8d44d250047d4946891daec855c9cce47b218a11073932504ab4d0cb9069f0ba4c64c7f05b8c8d2f527987030e10ab3da194804214aa832cbe16a0bc9984cc1f50e30fe8c099fb884ca85731ce53e313dba7933dbb1f3d7e2113946252227d691eb4fd308431ffb2243979e66ac4ea1d96d7f8a9a13fc896769f0cce1696a87ef0263f474ca97dcf73569dc2a3b5dfa1b4489be14ad4ebc69e9c7fcd75167698df12c205cf42cc617f57390f95e10f7d397a5eae75a12545b95475fa6433771f0464fe80eb71e96c6673f33d874e7ae12eabe945afe0125dc9ac74f3c5623859b9ebd1068929dedad3261b839c4c66ce040e0d7f890a261aa922d74165f2fe131f36c41853bbc55a27552938a63262d9895ccdc1639784cf62ff267b1fd6a7ebf1cb768ecc7d85b9b895e197fb03dc4f66dcdc0085a8ea1199de5a5976a8d2d7e3dca79bc24ed420c39ff01c7d8b4043b384bc9bfb1f45d0b0eb18e466d551229d39ad3db02b2bd5f264217792b91417bb9f693de49ed07c753b466643b0b587be0ce9dfa27b792c38b8b26c678c9e0b22690cd49806a92d472e53be01240872308be261499dfa02a023727ac1e6ae0287905e0c17a67a72bb46a1645fe966f921d1d567ad605da9868fd546a100dc0b9f87dd37387d2d46cd9014354e81818f9db848fc747a328b83bac4dd9d72e44628ac40cef764b7afac340a56f4f1981368c983daff5c84b0b3ead88725bf6a4434b280a25a6c900b67e33372c86565d777ee79f53a295ae974e520e98b3aae37472ada29cff46cd7df7f3b653f89d0f0afd7af452213ee5ca096e1ac3a2b74f7e26e678016fa296f293afbded19fa2c050327d241abedc67f00a742f81089044c9ca36f6c8d6bdadecd6678fdf0da60e2fdf76702763d3acca09209795509aa6a0d8e891caee7e3fb3fd515d6df886ac2e3bf26a7cf537f604d4a1bc1cdef92fdc6ff913321691cf2f94d1533dbef9c2613df0c72e12b551cc4b8f8afd4b952114134ec92c56274f7d08db90ec0bba6819c7441ec967f31cca1d62274d9193de7afb75b0267a3b039685dfac011f4a7cc02bf28cb3becac8fb13c72c6e7c8a07a1965568eb5f793760e13aaaac9c7e2cf35c091263f69568b2c82bf42bdaa2ca79e44511ea1bbd14caffb9d94ae1d90691a4acdb6b03be5836c2444cda85abed8ed103bf34e5f1f45e7bc0687a161d203948621ebb815d66a350af0a4a437903affab03eea19ae8b81774e824f9870235b87067f211e3aaff063de6656aabb5209dd7526e5a36df8928373a94ed60f1fefb229c20cdd7db029f310a573ad07a0e65e62a9f6e674c71abb2b3ec52e320722100bf3bfec2d578a90401a39c7b09de78eb75fc1279e17083fc8d068355e2254a005085d7e468f80f4c6cc63a644f5f2ba156c3925e148d35b33fcbf8190efd4b71a4c541e0bc04cf2fb7252796cf99f0a888d1264c5ae82cc9ae04b4bf48bd70e0729506124533ea7cbd3ab2b50e096e40829a93c526e8e41be19fbe92a012ef554f9659a2e1964ab943f433e84ebc20d113e66a10f9aff68b9f6b42b212d02131a836f6b9897705c149fd03c9cc20aa45598a55d9ad5c3e9e48d00b3b80e7bb5b559816a0e4fcf2c2c41031a6047715c8e3a12698c2f59126095525385b0af5772afe9ed06e8b4a53eaeaa962ac78d3b80581cafca3f5bca892ccd2b3c21232cdf27ba16daa743521685f3d903104ddb54c53fa7eaac3359a07b6a00f98e8df9ca972cfdd10e57bd0a37969ac892d9d9584262f7ec2109d28a7f2dbedfbd00e0e2658730f808488faafc21e96c636b69cc70b2c8b57858b271a835bd172c943bf49418d71901e81e0b30a69398743bad3e9f8bc188c086a7bb9785397039d62bc540f87035426a9dfd8df76c263bb1bfd1d82892818952bc149d492def7eb6140948055fa42ebec4bbc4ca0583b8478655c68318df52371b3fea4b92d8e7092283017814e1815d1964e0411467caf5c89f4c1242b98979055a73a82a5632385dadc862733f791f2213a40b301eb0f239e2cf258c7568e47bde4b618d048865bf0d3e46b19bb49b06163d061b0311f17713f2341c266c654102dddfbe10d877750b657ba38cdacc681f4b87f6a18cfa3e5e0befb4fdd5666c0ba8953a0edbe6c7564ba5bff0b4582b49e2c59d7289a98eee7287357729fcc063b664306559d2785a2a67241d59187c385b8eba96bf4c0599374112185291a11ba0e2d0aee73b693cdd7d6d52c7b0bc4479dd7d3c74cb013764f8900acf9f742fa6f7115e7539f9116042cbf73bb9d30cb18e2e54fddcd7536ddb92aafaa08c6b4e385401f2c708d269bf3c2795d81dea3866c4dcfbd6b6ca436b23a2c62f27e2e6615fd501cfc7db415ba2c651fcbc655981e5ddb51f6d1386f96f8524855142493d7de216963f8b311a025096663a1e797f6327a9235f07f2de23b75d5cd72468e93713a49526cf101172da3c61c2deb8f03b8913318a04eb90da0deffae2b8a89102c1df737986123b37f28fcf48c180749a963dbad3e2410ab0666aeda6e185f5570117aab348ccea07514723f0e67a492503a26a06eb5d5a153c39448cae16aad33734e4f2e3552ca48a6e8fea9e6a5d12440a545c8b079c61a195226b600ddb758c7ae9d8aaabe06037582a0fa3299a87c610b881e6b04acd595571d5c1cb13809da8be86a3f7ef6472daee12a5cc12ca5c58b16b7b1a4fc75702d4dba687d7065cfba6193f2583ceed0478a60d2ea22f6adb5c282dfddebc0811e681b99e556bd0e623532aa30a8032e62d57c9b6c9d7426c702e9d7851fb985efcba85f4fc4f429031c72cee254f857c0dea8df26fab7f90119045db6270baf106b1291c54d4259e213fe352efd5b3c95fb34969864a294069096815ba3e64b3bedd3aef3a4f7c579a2aa8ad27cfa448d9c2bda9af07bfc208714b8ff7b963b526f9a817468ab101fa034785248257305793f245739198ef331f167c3603897795e21e163e9c563a82ec907c3df2a1715c405122f2406549919fff9e5c2de5b7f3aab60b710c460fc9400194a6461e810769d6589e7636aca1337e3ee6dee2ded94c21fdd85af7462cb62f7d795f293c73251b55bab5124279369e4bba47462c418992dd5db49f3ceb77318d04a863772cb28fb5878111b00e59187bec106fb2a2a668e6fbdfdc2c1e529da2fc4d361778f549c24805671e3ace94308bad1d1c2bbea3aee90ad8e77fa906a09571f83b340fa98d0f8fa7eeecb97d337dc82a2bcefa82da83db3086ec5a793dc32ca3360c806db8807a192206188841487385217fbda19b1069a6aa7d15ce444f1ae2ffa0a31c103944940306eb7d5e466ff6f2740c01e6d50e1c3974d5c3cf30b5df2907265c45f3829bea2a666fc52bdf31c77b04cf67e770a87dbcc901662206677c617f0af72320d78eb9a0f81507b0abffb365ee374c8638ebb3d3b9992eeedf7bb7c001f897940fd2ab61155735e1c3724401a4275062279600addb36ae47ec513e8d98ac7e3425b34cbfd19ca0bdb6e97114768c4997f2119e59bc256018e3e4a6f370330f6138e43af4eb635ff34c9b30221dd1487583f50484c90dbdd30efff3dd442290035d409ea3043603125b48c3a5e539524c5f694e319aa2bcba34bc9463141443c194a1a1347f917092ffd8e6bf67ea6ccb24bf8e5479f5d351f15ff872754e78486ad678f05ea50f7031e0acbe608af01c020ef425a60f12bacc45821e7c6255c10b979a2df20c80cb560a21c9a96a9720caf7e89b4e606e5346037597a7dc2a6a18115a0cd5155f56ca096812b42d09442bd03766e01f911b5b22eae4672f67956bf2fff6c08190c1df67974ddf64423c940e70e812147338264da56728f7ff9d4e3d30ed3194eaac643f654315faa44da34d361675e11aed9ab989a84dad7b0634a11dad44bc840cea092c5c0882fe876c1919ef252fed6d0c97132232b5c38520f009d1d438934413497bb1a92562f9788a2b20a141077fa693c9aece7451a0da9a846c3a5507caf3d0c199966b331ac393ab3a797f59fff79694f75c86795d47aae8b3b1cb1094c154ea5ced0ded844b88f595095f9651e17dc264808e799bbfd8afa87e5ab861c6001d2ade518bdb6b423e40f3a60346ac9f7f05bd47f070a54cff9c118c3cd5f94cc9e2587c4b07cb819cbe3e5637db3fb9adf1a7e4543b60f8af5e081ba8a4af741485ae4164ae66fcbbc42031c711ff8a6169bc93d7fd0bf8513302c3690020bb309f8fab1c3d6ef5614678db96dd4f138777ebe448a778117d9a556b5dab931bffe34852cd31193f43b1ec5ce5af5baa1c94fb742c6471512114eea42b6c3ba2744d8aeab998c2b5f329cfa356b17fdcec6a11444cc81628c5e4d69e171212edd21eb765ee71802f673b68303977863a403e8e250a761fd832b1c7e01afeeb910e22c2bab471ceb764a8ea9e2af30e074366016a15978f014e9781f959a8fbdf77be8d4c558f76b77880df55224a4a310977a2b785fabfedf76f259e60291f95f0a309f5e8546cc29692fd6fc6a979b333b87ca966a00114d6d1e22679ab0e571451390cf35a650a7a4fbcedd31ec62463ac24181a1df473ab961ba2c211704a0d6c10fbfa89092fb02642710d8dad2094ebe0b771fb774f2b8761320bd85becc0f520cc9999532b71c65cf609a26341a6a720d89751e94f88bd7d425197fa65eb33c6e4c3fa3b1f5a4dd90c44d3314eb44bfa151696a829d83a48a6e1aba11202041e9761f84cb5f44aa9b6fdcb1f88e7bb30db27b90a0ff9678f65e86cdba5cfa5bcf1b097dbe455157a1f6f5b44bbda76879be1e37b44b109df7bc1601668c530fd9f6824c40d173617b2bd8f0598897e96916731f3525b25902f044260a6d48bff6222885dbf946520eb82fbbc608264a14fc2000a46004314899256a1a131a159a07149bb84532b202d82e792f09e3e1a91b2e5af990ec0380f50d6961e7d89dc37c1310aa835e31f95f632c20f4566ed20d97ac6528c44626d1637193a30de1a5cf001efba3fc52890108fc1fb431bde483a86efc95b1b5b20816aa5df4340a6209f4da3c7316652e0a325afee0a5a895d0301449f282d7613f934b8b8295e338c024cd7d39ef747d39e18596c567e56746b5f908fc1cbea540fc93ca25b78f4eec28a71b8fae12d0f8eec307c4f58f8175930dbd2a6a509e83559c56cb61969ba58627f23793c3aa8d8436f8c4366996e24d196bb41102b4cf8f228af9b51aaab3d470f02fb0b0c98ed5e65f5064c3c703a0b715e256f886900e5232e0a9d1f235824dbbf450cb980752c87f56047fc744a6cd1462f2d97352f2003b2d1f631c5e0c917254658f8a681975db80184a142213e19967142cf81e39ac28e31bea95bb3ac788aa5b23b0e3c10cd1db6e3ccfce2e22a8a9b78588ed03c436d99535027cf5ac199bc1cfd6b6a997ac6bdb2113b3a821d0bf14ac1c22db5c48dc625d2352d9382f03b8550d2edbc12b4997ea941b30f8f405d0d44ef1da3e5c7856900721614cd86473647ba17050d44f7a816bc31b7fa734b98f7c42091d76c5821b97c7a9b7afe857ed3fc383889935a2d24d20b86e84e74be571898c0fa254a6f749687a6978c3e4d341f19ec4dba4cede5a191f587e03c8d9547c1d14dacc9c1dcfbdbeb807fe5cfb47285737652dbe7465540fdff338056fcbea963d4597b65bd629b2be947f46bc5de5f7e764c647af2e57f30a856c6dc645c11cf5ef914d1bc5684d7e74bc8befbe1a45d2d91ed7e84f21e235d4150636450553fb928c1527a48774e49e0f7ab8076dca73f22de022507cf64703531615e942d1a66d399622f341b554f72ed438f1ce4e2ec48d3f2ae18c8339f708f6162fce1decea081cfef3445641fe59067d8d37df354c330b6298c46538faae3ff118596e8af2b1b7528a76f63e11d97173e0040eafc9b168f935320ce1d09d11f3a870b645689612e213c6b89bb889346f2033af9cf10467fb2dc8ba36cfe76f1d0662b43d7a34560bbdbee7155a5a6f3e1750c3eb677525a397990cc28e6faba6e758b1e3efe91d6b20dd613fc2b31cf3c336881a4a9dae7dfc8f136a54a9d6afd0c19bb577b2eeeb691a890cfc2542ea381a986eb22b711a3ee9c5a4e2a676013bec2d4c4f09d3e33f1a963b233810fa7d38744cff4873836b0dacea548292178a235a32be61748506228e64ce9ba9601a8d7daf6858b59d00f0e0246f2e195db93975ce481ba1b06c2d31b08c24d0e7ff59866e066607eda5680af2b20f0bc8ea2c430cf3089a08ff08be2800372d5a9c842c5f6ae290e8f567b579914942c87360af391d36055bb9d546ce3d05b5ba0b9196f8a49dfbf9bc25b0334f8ed7a16d3cdf286b4db48fe3266e17c8f47081888f259f5c71e77b872265baca7a6c107bc0ba349f49378de19b8ac41f96bcf3d8315d7254cb154b5172f1468aaeb5ac38fc3bb34de953eb64e3f3a711a2ddcbe14ba5e61b889840b9a5326aee5d0ed32d5a5da2166498c3805a8ea70f344f4ea311d8f25fe673f5b12e1a6b4e1bbcae3e397161ea0a462a8316df8c7dcfa561920fe3dfbed07a9dda2d07d5537e14d7c62f5b972f67b0e689bd9a7f186870fba168cf7862007a8b718b892369569b08c6c4fac286ee2ead67501179024bbf61cad899d80b341ee1c2c4624191b211ae562a56ad6f61a37ea121dd10c88bc87a2b22416addfee7c505bc484fe1e009d6a0082dd4ed663fe035117e1f3fd976602dd20229be4fffbef4e4a85245f0bceace59ed59b6f56b93440f3d75d26832d0b38b7f729d1c4fa3353acec892f18e87ddb6fc8d164ec197e8f04d9fcb77e79e97ded718c44f428eef25654a967009b68228e3d9f77096656745c693d01bb839aa4d5ba91e708667ff1acf3270bc4f48c6b1f99c40ec61be5433f751ed556fc1249a5ee76a494b3b86a0a24a276e95cd241e07260f7747e602be9f64ef71f2cd51288500070bd1911ef2397154aed802c056733023f060fdf947718c300f6754fedd1541b4af4589328097f7d26baf1801604d6a43b6f0e244db32b7e59f3132197fff5c6a5b4a20b3be9c92afe1fd581fd16730b4c191bb32699cd4af55e72b1118720cc4ba4cadf99519255393d317ddc01b96c47ef17925ee655684143b580c90baa53c0845c147ee56e337af78de75835d130360760b326419217d0a6b9212e384523e3f908c5b90d3a6532e86a33b3763d6b8bf68791301ef2792f94bbad456e0226e2630430f3abc89bd21ba8de095dc57821e25fd7f621cdc8641ebb51b8641b9154f5232ae2e129ac13c07506ac45c7c514c06e531147f49e8485180cb7c521e109fbc42926025ca3d272478e7966a5ebcaf2e2f1d2cd10fe08f2c277005f0fe9f363a5d93f0ecc88833895f9177a98ad87a05a158f3b5cd8b8012d4968b8371cd6b6aad7fc1a3e8f089d82247f8e3a6d1aab52428098a749bc58aba314f0a4938a49c7e0ac04f3cc0b336e3ac69f3caef74fa77ba7516466df3b158d37aa5c08f43d7797e95a864b942574654bd70f1d8d9dc3fd74495510f21a268c7ba081df62928a9abc1e57cb9a6ccad7195e52b4b6b982e7f991ac03f9726ec5bba3d888a43f1c8db47ea40ee701167be0b0ae581d43171fba1fa14292e1886fcfc65d97566e1c15e84c5068ccc946af996a8e9ad73196e00e99f9ac0e052177be453221017c6e46507c0274b1e5bf735efdb92b7ccdf3e4cff690f9f75b358e91136170b238196d0ad6aa8f6939b734774b9c523619437154a370209f33629243d149d180dd749eea51c1c66735a68641de3e542962f142f03636057d43c7c6d522bde3aafafca033bbf659a15a0366f99d0ad3eb886675d6a2ff1e75a228843215a0c93dcf4145de4af56f75d179af2b48e045a91997cda69026b76f3efdfad184a6a0dd561b1691408df5b5d821fd4d85c32a55f935fd54b5acc2909accab7b40d30e42d027d9cacbdcfbfd9adcee1f05cdbbed18e1442624d9b8deefe4d048df670141afde4e31b09d21e538fd51770cf72080d51b6a0853a7f38792923abf51148461b4673ed310e73d50cc3cf320e6eab70650750f9e8c84218220dd737a9b9e3e6d3bac22a2b40994324e783b18a4c3e2f2683f255e7aea92073961304558ac948e25ffcdf4ae9c0b24b01f72ef65ad622190896852cc35cbdf49830b079ad8afdee54c88e7a03de8c653a3fed9a724605e07bf9039ce2b54b8400916263a4ad9e2b48d273f62e02562de7c79662d5d91a8c4a32c154cdd4ed0d6ce569f85b3a44ab6926d4660a88549b2fa319fb88fea6277d9a260b9b9fbda6e4e816bc85ef07912046cf63717777b10edb5837748ebd13721a669ff6bb6552f34826bf5940a92bfb3c54139ff41acb6a139d1ba6ad98b95539809b0f57faa2899fce73ae3b49ce83a2d579b729e899ad9f8c8e6a16bbd1971b7aa2ede5c50b789ea69b25cb9be6980fdfb4ffcb03cb4324a736af91b9f4d8f43b1e27669e00a2e191b3c2aa9e7c0da30b3636fc82a0f1fce65232d6d26262cdd81dd8fc346541f56c68b61293a13fbccb15c0013b5fe662b80e099e068c9f63c4aeef4723db5b41b18d6b9d25896f47ca02970c53a62825f5d23a57a90c4fb5df1f6e73bf2686f00f50303097c06d3026c868c55a9515cedde0e1e6ce346466f857fa71bb8f821f2110fa74e693adabc55f775d3f090540b5ac638c0708e3f4688e1610952f03ae164a2c43a2b99b0abbcedc72d4a9bda274d1f9ffeba15e8fead34afe5d8a0fb53c67a99294a714717af5b4bb6ff05e0b09a6346e659194daaa44f8234ec85b34748c8c9b34ca7561db7c2288e09df4f83633dc8505dff24881d9b45d127ff58af9b2aefbdd9816625ecafc01adf876a50586113104371dbc89df028c69e80aaec7439e3b88160fa0ac89acfac9cd66f85a2f3141dce46780a7a5bf47e5f286c95467fba5706fcdc2bac1af28b8e6839c42e2fde04ea965cf3a73873f1426b5c43c63ff0b38cbdb2f7a7ec109496f6f5d00f87e98782ce8c5b60c8b638e9d2ead714f174d8409ca676f03cba44c6721989cf84e5159f26ea1c215dd9da5884311c1340f060b78623b90315016b5f0f2489171a6bbd72ba22936354ca152ac432f1fc496336c7bc34174fe58f73e3063f23f00cb67a23c672aee7fb04443c214ab1df381604a6ae7727f7da4a2831f8aa8d62a08e59a1e9d02b65ab0da387e797bf7a317eb8a64ec3eaa7844c70730c2956ab428218276bc4e3eea84e9332f0869bdfc6346c1ccfe7fc6d591229baf51847a648bedc92e280b7e3c621127adc9885c3b2b4defa856cf88009c1118b3a48646db89ea09c04f2c4c266a009b0da2afe2b7e841b377e9c468ab1f1fb9c128eeadd8285171d2f5c394a6343b1ec59463dc62247fb884ff45cf2b81ac97058a4ff71f86257fb074af556fb339e961bfbb974d7f1647ce47ac82f9d7b02f23414b520fbd57dcab8d03cd59da476b064035e764d9c26c52e7d1685a889d85e15c6958e3b4749ce95efac92255ea2e100bc3719acf592b1ac2cbb5a64b64244c029165c0a8a196673d41ec4c6e55fb9d6e684473326f63578d15c8e6cf5f17fe8af005401b6cb5228b5d973b07a2eeb9c6958eff6dcfe25002b9c8e3cc55ae38c3f7dc3677f39ae157ae3e67b22e34e65049a300511b9a01a667ab325fbf0e70b17e6301c9cdf84ed67ee39beb14388cece398246ce5c77830dbe8f16dc7df9e9e3cb7fa0011be784afd43992bd8dbf20a5ba0f7a7e445dae1239ca0a726130e1eb178d6503a285da42b9ff1e9d1cde5389bf02edec3bd61f353d550dc92f5388480ca31f66778ebee7e47abe881514ec61bf9fa666136bcc359198985b29b4e454c10a38ff73575955acccc0a3f8e372f14ae2883bc0a56860b901f84adce2c0084256c41fbd9b291ccac001ec155d0e537379ecba7d85047137a34bc9064205a3cdea26c308a7a7512f1d0956a033618ba91720cfe5ac9c08bc6dceb2389efaeddd3566626d898f4a757bb8a173365cd108b406138307092c99e21ecd101a65547f6283275a3adc78985ae0918c5f270a97bee5faca3339623ae83bb1d0cfb87d40a84ae553258a2177ab876aeacdacf9167483ebf8675590a3a55acd4bf0f76757a5ddaf08348a1bba3d57484ba5c9f705f37b82bc6c47679375321623bdc53ced50be500446d34d09c43487b0dbe5402c9686c15e39c74b53a94d5323e30db7972554ed70f8155552b20bbcb677539e75e164419c37cbc1430f539546da25df215f888d2ab18d3927ad9a8278c7df0c75ef05d18af0db6acd7c4f04467992b963192a1ab2efe54d15600792276db12650f9413afa7689ce889e36bf9c876cd81ac5bf81c9b9344bb65b90be3b06ab771df5ef31bdc9092954ce34c6225d788a6bc85aa2512e587d0e9579fdafe14416a7df9a331fcf6676178c3aef4a036756a021d4b0f43a8cc8722cbf84a10d0437040a458b575bb17f7287d0f63e260116a6b749e23724084be50de358e9cba6c6c4e3499468e741ba1d03096b2fe8bb67894c30770206485b19bee05c87f8f2793b7d528e06e8d4c681bb1bb9159ccf9b55856942aed03c08ad37c187e941c52f7a329b27c44b9e3c74fdf85787d8fe28f9dcc56c24462c7a5afd65a93b5c55ad6ef26d59616bd2d09a98ced18036e747f386a57eec31678d44caa40509fd03c32e7d105c662424e39307096af6bc8d256931ca8bfcafaca78bc26869747752c57dccf11e7820ecf2827eecadac6f5106cc7f3c19a5809817beb4c47c7ecb726db557dfc46803bb0ce4481601b96dae3d5982c4375f2ea56f2f07266685095a7c00824d7cdec7d20fec9e1a408afd5fd8bc9f02f84d715f1887c3d7c9d706f06bc632aa988c7f196ebc8d8f8f62d2b3dc049159bffbd919aa69b4a28838e20a27573d0f5aa2692fec4a0c168ab2d8b28cff590409f63654c3b5baf80990403cabefc6db24316b8db1df2e8bb60d2dc4efc7d19318b29776a1cc46116a819a69c09dd872291fc77f754125a267e318292141fb645f3e61806c94626d9a25f5b6d4f0016c407f51657a3b4d307ede3ceef260e4f75dbeb5f72ea876c35c55801830000ee7e935b25ce68a3a07441df0368e77bb91fa85031df3c168733eb9a9386985b3949fc25f6d85ae41e327a5a33c411eac6e2f3b5972296aafb722e1810cb0caca26996a18b53de98a340bd6af120e1791a239c5e54a420db4beb5c4eb925de028514918bcea5cc4573fc6d9b8ced4293916e9e1f34fdc5557187777675fb23e101f5d29e486bc0ff2cc373810160bb9d599051faf3a3de32dfa7302485f8cebe6189322d58bb5307138d3597db8e2ca1193cdcdff0ccb55bd07180a5e5d39a779eaa679c8625fbcc94c592d7b2cea219731e4e8122fa50844a00c34668cb756e69eaf99df92a09513a95ad3e794b0ff3f6f07fd95534f5f01f7b5bb4820fb57b2e37ef9eefdc83d3ae4d42f024102295f6898e7a9b89421a8a04831c384d0933923178c88e6e45f84db22d901360e64692e3a1133ff4bd20ae01fbf7d7aff4eee3876f0eafc79bd228a4e7b2268fcf17f463dd3770aa278c037d515732d81c3c61ac0bf295d9882a09a47926963abf1afb7fe99229c4a270747bf4530861ac29ff793ed5135f49c406d42b0d15a3e691bd7470444d734ec42f7e33f50c8dfd19eaad0749276cabc187c9caf3bda9df808b9f42c55a399c95889988f6c9e2456c80d440409cbaffbe367c72a47ca1cfcb80d6c13d159afee65865672e58d4f884486afee21d210b53429217c28d7416e6b84b5b1327e4def9b3d7cc7f619fe63b982d471d70cf2c17af9c785cb6bf97da946e4dda19e44a4ce0ba677b88b1cae2e4e852524c61650ab157b328d1a8f7d1ca551bc5508c8dd7d8f265eb78d7fa12d9d2768af3a9b9b1b7ba2f8efef4f16e29c8927497a2b4bb8de2c8a1a361ea7ee4146b3f366b77f2dd4c7b737efc1a3053d157bf2a404c9dc802cb4284cdadfbb3fd668b8ffc9fb01dba6af557a4d2322aebaee7765ba023ab450ef28404929bb035b1c4d65d89ab53654219e40ae0cc83b255611cf3b7db2396ee9bc0dd1bcc843413c54df9a9a786d7385c4933a89535592aa0b5b31692965db37ed37102ddd06b344c348b37efd78605b69167efd643be18fd825f1337c502eda327316bd0982c1369e7f9b42510c94dfe0ef0a934ee7dd084c793c6bc563ed4071688c9ee5b5354cf6c90a81f40804ab607e57be288e0ca27f1726eab87c50e497d2b49a6d575430368cf4a24ac85d31973e8a5dd3cd7d80022cfb613749b71ea757d1c75df1c76b072effb9001c711d9347142bcf86343c51d35bf6a721d0d318f8f6a3dd858275d1ee8db847aaa6bc56062e5910882de109dc2e22787739111f029450aec85438f18cdce596460e6a5e554dddb4a2af0fe300919db9651090304699b2241fef6048f193327a58bbcffccd66445bf3b53fca0be86a8f03bd8f767d1f603aac3f744701f09abe793dda98673c4e8b5446cc3c2d7e4e598fb838f8345615df88eda2e81e7a43f8f1b6aa4aba0a61a170bb71b906260d68d1b5446796a3045ff711244c5a7faa68ea345a351fcb6f70b520bd39b47003a45dda8b8d1c3c1011871b1773e6d8a6e0b9b786d0e17471450e0e23708dc604ae084c34da27771d91a7667e54c232dfb68a1e959ef08d4b9a90fe50801158ea4eb2bcf17d51f795eca8da9d6bf8c8af0cebdea2024e833afc2ee1485a0147cdd6830e3f5ce0b84baa79a75ae8165aedb4c9d484a5be548aa9738481cee0044144c47cce26d818e71c856fd1dda9447e0df5c03fd7bb918c6ab62855d279fd92dcab6eb4b2d66a7e5074263ee0fa667ef10100d3793e9128b8514968cfa6fdf49a17a932b9f4748b97f22c2f92ccef7be50f4265fc70960716f4099e837cf25076b6c5771a63fed7fa3ce0815284b45db0d3dcb73f9ba76caab9ae1efd5abfd9850b4c152c8a215a0882066323c8ad038993d6d69b4e3a2eb7e7f3ecd77a8b3f1a9dedb1ff3808334876e1ffc64d0fe4830a2cd6855efc34b4aeaf134e0d016ac7fdd8ed4ccaade38ee8ae0e76484d5147c560cf1d289b6112d52407371c9fce65d1208627161848ab8f51df99d544bd622e6f6a510cfc4f13aa62476d8b4c86c2495589331611c5315d32f2f6e1ea76164e1539c3784c7c75dd8611f82a70675cbf9b5641cb5dcdd2cf3cd0ea9510e8a0278039153cd512a937acf0256e19c36959dca886a7912c3661662fafb387118b3f0bf661a9c2537c2edf3c17a488f3bb84849ae41dd0f9f9fc98cf26bb49021a3a3bd8792481437884d5ad831b714a7299f8ed482e14daa653d16b81cc02eecb7cba6cbb387d3fd3bf62798f269280c7f1c0cc72b7964ff2603e5a675d35915d712ebf0236e8edb71bba4e52e81ea8b60e393737ea9b95ee2ea9644f9de25815c71666f6cc2ebfdc0653246e4b80a1d55d9a7aef53fa80180af6446958331123c2bd267c58a638f6e04d7fa6867c1f2b8691ad658c8f378118fe0f69f9929009358f6e4c86b2f6de432af90db36e06af126587d0097b141d068790cb01d181060df2873115a86a454bab945254d684f910479809975794df49cc6e5716035f3674edcbb2319129d1e41e85a3945cfb59f046372176558f682e4927845e6696fecf20ed95a353985c531b326359469b055e090f34b24de6c318b61e822cbe6f5cbfebcaf40e0615c868cd10c1df73bc786bf9ffa502e7cee791deb318bfab40c29f816422b2cfe027863878b741db9efa85b65a32fcd0a1ba37d36cec07ae997980c54d148f87cdf4524ebe1da3c7fe221953f8b9a96a5cd26fad29f2bed9b6a46d1b91cc5e798b32695dcff19d2c86cb5a278d4335e40f16827d4b2d3c7d0ae9cbaebf7bd7d731f7d835cd55fbba26ef18ddcdb15e41100b4ff5c505b4d4d6e022bf8f67ca5ffe7341775977421b195a3806595f2ca3712d8e15ec9b407c06b067e004635b75e9796068f1429776c1f77a0e8e80215cdaebaa67310ff88bcdc20366ed80bfc59da705ef9d90b43bb3ec65addb8dd5d640d9a8edd695c1846083ef0e9ef35dffd5ad17639e5ce3d66dcfa642ccd5b803022a875b91e04d0f62cfe0e9576cfff4bf57c763857480f2f8af9c245e8bb02ed594747bc52b3acbcafd2064288369f909fb4700900a0a98406092815bbf47040f1c5527cf325c269a0b2775e319cac18b62bff3d0c633825973dec40d308ed5cc03e748aee0186a8486819229a5b03463470f7b0720914bd1c593ac217a901beb9f2d1fcc701b0395fa6664fe038797dc4e26592bf866ba4ebdafe33655f28ba64b4d4db44f57673b6d0c442d46778630758944c2f014c0fc33c9166d5383e01926f2686e0bdd4fedf7574aa1afd1e62b0f2b46b920c4a0a3efb9ccf07e477bd430291172d058489a02f11145aa7f7137f6e6d7d0f979b6306131e18d1e2bdacd2dffc982ed0a9e2c07320b118ef6085ada626f2b53260416bd061b0a2122f96e0a4bb0fbe86f5c68b2fbdb097e2a46917f57d11a2fd9d053e9175d60d34d56279a82215b915f41c9d5720645ed8448e5fe9d3ee989136c33880ec5ebd39389a2fc2a3c004c635952f56bcc31dda9be6a0ecc38ad246c3e0e7b855d787c41526dca34929871f9d7f8cf65ae4bedbddf47b1b92d36be33d6d72894a85daeda8d134bda3f41edfab885a8aa41adb668449e13f4b848fff8a3fb88bca6bda71f8aae60f155cfa33cc0e80fa6c33c7779521451673e08eb7691f252a9da29ab5136c0462d80dad9385955d443d490eb764e90018e681953dc63f488299907de5fcde0a4b91e9a61e2566b13d34f33307e01a2f40d4239651eb73cb9d65549dd9027a10b8ef40c859712d5c8a18d302c68b5dea294c07cc6dd84bc321eaf08a810c0888c87813b04a6c2d2b89937cae26aac87ba66f43b2fed29f42d6943df13b1cc2459eba6e3bf0d49e43a70e16852e75f98fd82597886a732eabbd8fc95e5408f0cb98f3de4b05cd26d5bc96f81e5597b654656c0997067d05b25418c35e797735ae5bcb396926c5bcf1e15602dccf487e7f74e8a8016cfaff3c214c34d94b253429ea1cc798d59b6fe2cb0c5b80f506e5c7e2f5a566d94bb80176175aafae5a0547999546744c8d705e492f13f075baa19996068d3fdf0380cbbb1646feafd98a649bbf435d4c3b85ea80bdb8b90ebf236241b569713791a7fe1bcfecad2f8477764572568b6efa26200ee0fe29367266935461365fd28d9e45b55210a9c55b80bc51008350623c5e61ea96603ccef230ece614557d57b27b161bfabb52c98ee13907cb247bb4860899a7414416a4626fea73c517da445c1a56253a42238d521995da35187a23968f571fb23155fd0cd86bf6d2c5801038f31befdca83f0d88ca12239dad795d25affeb29623c9d8da64a7015562ee81373db7230f45fdfdd5aca18e5766c1152650c9b22c291e2c0de905572cc46e8ba4efc345d6d8b921e5d36711e5e8a101f68a9757346c49b65ca1c56e253e4d081c63964322a3101f13dc7b2e1e452894ac13d4142346302cd5b097217f2ebf354220a8559eaeea1e7586d072691b6ae38a833df143831faa6bd44aee2ea242cf55fca1775096138bce4bee8436156811d759b5a6eb250604093983401c6238116a7f692f1eba68cfdc187ed619de0d43ec65c8058d7e33bb81dcd34aba4fdea40b4e73b26472d717b330f747c7ca4acca497805d006b3741b2b5900fe7f9e07afc150320a889b2eb32d41a88a9524aeaf550214f2eeac5bbd8f70dcfa390f38c50ffa4e34c36996aad75aa7739e3f05b92a2c18d7e9cf2558a90c320f1d14ab803fb10ce0c37c73ff3eb0431a7f322bb66457895bdaeaf83b7af530ddb3e6b7a8f7ef3a40eb17012fd0f48839cfc1cd480e7d395810de20882f087c2c85096d382ec02a91738fb4ccf8f67551fa144fe9b649768b8327c70317fd5f5d0cf207c79f8b046c0e3d5b3c3849d9321c2ddd55d9cbac431b848ca786d817ec43927e0b07e8d34d71de4bf327c625b5750427f92016b70d1260b39cabb6d0f954290c24ea59020fdecea2e7cebd885ac3cc73a24173721382d1f1535fcaa944f7c233a7eee852a29ab9b9fa6666a2109a4ea9de068336a5ba30fa8574cfde910e9f35745b84d1983bcc9d947fb6f012e0dc40e037ae99c7bb282b2bc214d7759d69a749eeb044e07d4194eff8cc9a9540eae8ab5dc1397a0638f06fa7dcbe1fe517525b0373fcffd4e0a978135867816b62fd9de523ef0a07df3e7c3cd3bb8747a40fe31840bda95581d5b92c02af9d92648fd15057405512caee304d031cd6ae44e28cf490c838f0f55f484b8181d6789bb0528f6afc602539a05a827f9aa5ca99f3b5a2d9389b4cc03f1df71e66588d1bd9acffabc124db09269f13c71ec59ae545b85a9200cf5fdd6db12dae89a1d367131122876b43f3856d4859140e1a73b847c7d3e39ef22ef5c50daf52ae4e13fc07a546c577f6754a8e5a46cd0f0908ad70677d23c872dae6232706d495f8752dc36787a027f629731e094b5c8f6143d798e17ddab90e791ffb4556e26089daca23309a584c7d24c5b0cf9ad22736097a889e5af124110b6703e5e38f1e852863544a0b98e4de540ee9cf11115b1d33fdefd051690be2906b9e6f5b736fada9ccff41c6032c40e6cf6606c14d8bab7ca9b4c6c1694a1278a9df5cecf5a8efc9ce15033c6604d670cb644f5f156066d82973d8b2ca52c0e1a631a8b3133cd73190edd6414deb5ed9a8199e0290b855942282bbdf9b93b833e4883c7401e44e6a936e6ced01112e50a47550463602bc1f62d448e9cad310579ac6b97fec2d483dc721860456fb1ac1c6d89c1c93b0f38a5d473076b74d6f71f9a96ab1180101b0cf048bdf9ef2752ad0ccb3dc76c1794eddcbc00920cefd4e8457128867d61f6940e58d85f2f2738a3cb253cefa440177822779cc5ea556b88f2d14fc54873956c5391808d1c003b97f4c4eb217522e35fd63d11b780ea148eb64a428d6af762bc8c840f74424a7e1d909aea7ba4a360bcdf29a8ef5ad024104cef401c396cfff158baadf737cbeaddd54682a1e5611131203d64edba7c1e6754bc68463e5890def9a7ccf3865ff830a4b6ab3326a27d0c80159360193b03158fb843cb6124697f858d1b7072f7532043e6bbb876a7b38d81f1e896b3031276212262ec672ec9fb7609f83247465e3b54b4811d28cca4f14e12ec7b729a679fde1c925d51a8976ad068dc15638b3eb9afefd71d8fe4ede3d0afb5096e560ecff5d6fce95e2dd2ccc808aa7cab1ede931ca69804d273319787b517f5bcd1fb8bff345304a816b1710b342fbdfa32c8a93c33e65d9315037f10fd77c4ffdf5b83c7506ae20624ccdefe2adab2589b62559e5d915852b3bd718473d3a8027ef40e119ca32ad66ffa5b061154b2cb6048f6dc0159bbc0b6f47b48254a0deadf289b3a4d507df1e0fb887cd7a5288bb1cd447457ab79f1a050af9482d0005e9c5929e0d5ca8272705cb89ef40dc5af07a1749b00caa6adb71dcf6c5bd143ed328e0c47532119668c1596489ae8cf8201f12394863e8864317b908b28046ee473bb8fa5a5474371ae3dbf8b8304fda54042f09ef9a477d3c51894ed5dc4a69c237a7e9742292e6754ef807502b3fdadbb8d93600167fc1bd4eb51b89b63d1d3a60690890a5c1abf6c733b952f53996311528af0e30e8135946b994481d652d6ffff605a06c00eae5d72cee561b51635dc9a428082a95f97737286b48a7bd4fcae63145fbe23098b9e756e1c5841b8d92c0d1ee61fefae1f53656108a547578353ce298f0bcbc10edc28038454942a55d4331353e51f4d652242445988a6681b6bcebbfb854818de93b10d76056ac961b837d51ffb7b13c14aa8bc70e89d152b1115fbd12bed0fdde1f1c335fc253ab95142a06534dec03030cf08c67507f53754074f736e725f649cdfe92e7e1a88477502162e6a50271efcc733999681b4e716096c9b75c547ea697b0c0ed171436b1ab8de51ccea98e41d02d31c0786a2a07ee90715c9661c3b7791dcf69e2438ad36751205074d553f7d61a8d352f5dbec35c6af4ef2cd44135a615259e12399e6fddbef47bb217474881dae5ad8b500f21888253e07f27a854cd32b9c25ecec623734f93dfa7b57fd77cb9c59fba3926d46ef8cfaf9f0449812d0cd03d3fd336c1bd920219f6150be8339efa154b0a4f6d92fdfd25ffe0e99ef78167a5d3e21f5648a48ec3c667123738916b8f93f17ecc55f06740c88931b677dc5014a4dd25cf6f05f7373a6203ac546a8fe43cd09989bedd4ba1e39a88d91ec43e92e0772e75057cfe0e539db41203314b9f8ba44648cd9a2b849c98ec1e4ea01c1428bd212fcce2a7950f673ecfca2c90b805b5bac707752a64ec60a615b5491b72399124bcfa8d63db10329869f12c79b4d0405a32cbc8884599f24eb4ac0c4f1e472e0d0e30ad89e4560510cb1a02293d25211af3ef0ff09af3398c32738c5506ec40b72850d2bb7cf086f69bc66af2b360254e1e50659d009a4556ce9fbcfe6b34bac173208a99bd958864b68ed00e9cf62dd985fb8104a92ec631106a6103d1aa531275ab8f604948ca88acaab73271fbe485e48f9d4817eeb0c7564beeeef63a15e462d5d8de472187a4ab6904fdac6e3425d23bc30c2ff2decc27abe451f7bb46180616217e94a8b152b9d67a5038da8df012a29fd587572c54ba8dcd794c2429f727b07681f2141d0399ed21a3f232e9a51ca05d07f9e50bedda0eda6806ecc894ed9fbac6ed127f4202ce49a93cee821f18730a12178311370d0f1255609edfb2bc7c03a500c67a9274f740d352f085f5709a22d26dbb1672a1246c96ea98ea067a974236e727c89df405b8cf980ab22d22c548821d4b6fd7c54d5dc16fb21ec5f72a67df3ca4e5b15c5f6a56cfe4b62804c6dd07fc2fd3954871f0df6ee04dd62ac906c37f4a5061149c82d3c2da5487699cbc4da9c0d396d97efd90b7f998aeadfaa630729087405ff19de5ec8ceb5763df8b89884ab8686e47727d8da61d0c2ca61744b1dd912760b6fa0c938f5219840f04e80a0c8f9042858fc9acea9112bc91386219fb056e025563f87f39a9d823289944355d42fe7c72b4aefcfd92e4659bbf6b8b70266ab7cb578cb1e77967807370143b2d51d1b252138147d6ff31522dd73dba11ea17c3932bd7c2559cf6688ad32d9eca8cd82364acf18802aa34ba8f59667db8fce38002802926947d89ffd2d46105f52ce7d6b8a7607fc88068d079faf9afb447c465c76ed6960568223e9c5873cea5c85fb0bb296ea9e385cf9c7dc8e6fcd8ddd5244d2bc9bc93beb0514d5c03f76327e499e5bb4bfb3a65f9e05b2efd67111f53f1840267257c07c631c2926aa89dba1d31277f929d9b27e6994d04e1642b76c1dae955fc300484357ac9a0d13bc41b8491564a067ed24016d20a2283a6711b433c2faec4e2608b03d2a001e0229fb90576c4a8d1f3c124c60a2d890037f04e31993d3da535b0e9f4263a19f685072ceaaa7269bedcf62ec6d674af8e32484a2ee4616a8827c4efbdd8e5d032d9ce2e6b88172f955b4f16fbe8677234c1c6915243da04105088926a04d0a1eb22d40fc8b354150b0621f0a30c531877ca851048455fdb6e5c319e7e284d321c316566d446317518b4551bcae572da3ad057365adf1384b82a065851bfcba073a7b9e04db8563bdd88ceb9b47ab84414d21b132f901e26a7182ad6887e06a0452e45d268353b3522ce3291272db6dc082c38266558bd088cbbed2598773b1d7c622d553606180c5f379cc451792746b5d1f8c7c7f4c8c4dcd61e702fc99c4c948871d2d41ef52a0761b6a2b9a850b0b0fe00ebfb714bbf3aae3fdcd81ff99cb9dbaafc9b0a060d3f81a2e154c35b87ab6be2a4dec8554c2519d5954984a9adfcd32f91142c193fa4fd0fe203501cf4390cd45f36ae35355c29617ddfc64719cc4880a770a0e392c96d02bfaa81368aa818a44e5e85103d03deba892e9a6429b467fb8d8b8dc58c60f6a2df17c1374e014ce655c0a09a86bc61053cd457697b982cc1df3156b83c80dd54512e6d60e9cc15986cbbbd2a07929855bb2b54d51cf3dd3a56a2a143b6cfaf56af69121d700b89104779ea2460f93ffef546cefcc1b3ef47545bca07c0baea0c23da23e6c0f1ba5ccedd788d7baa892b1fe4c3ac04d2f10256bed60fe0106811f9433c4fa2d2382a2c373aded475968e1281272afd9660ba93394a1f15b675fe31c1d33d8ed74023fc23c8bf1c1a3ba850e651c14d87041d618d08ac84d1b810e5089f4a2502fe09d76ccaf32477070998fda412c227a0b388503a3a565a53861cc3c09a311e6d2bf4bf635478bf861598be9a9da83d391b0a1f1ddb02e3d1cf2c8fc37fb1782edd2e17f1160062a9a6ca5d57647344168928921acd4bbb2cab8d12eb236feae3363335e25fd9bb78243a6e91ea807c29cb3dff8a03d813f84e4ee02287ba7a66535b6f0f8641183dc86cac08f5638a8b819fc27dfb5763fd6f46f8e3272c8d9fd94bfa749de3f5af3f6e2ba345e100ce8e2942828bf483a887b146fe1b4c91d9eddd0c21c444a2909923f399c96d1afe1aa3134445c821089a2943ace08889fd94d7edea64029b3138dcb222f4e2bc0616f32e74be97668280b5f4c9bdbdbe24304f8057eabe0009290faed9befb349b1234346b962dcdef050758b38223bd7bc9f8bd06439b7d15652ce26c986a05224241e21d0b751d09503fe77d30de0f4aa200d16e4f8603a1c8d4a0e96b08fc10499c580c3fcb1a72c230996ed1e49cfc172677e68ee84a2c3a6b5f4eb393b469bf4a4bae043e0099c2fea3202320d2545b66539e1bacd465373d5c8edc67711ebf39e3ec4551484d649a6362e04e1fb1780d764c057a32e71d4cb7b76419e619656e510044d4c2e768d3cceed70fa942f5b61643d3a8389196f680bfd9a073a36dc2e91b68940ab5b6cffc3f937230a13005451e7df46519fd76deab0494f58174b53a1a256032f4a0261de83b8ae6cd1a27a57c01bb2535aa49f4bc72081f4307d9194b371b9587df665a31c5cf107439371f8801f11baafd33de66bfe37cd44c49582edc50f4c1fe76f300f0ae080b6c013f813e4b2cf2ccc51060fc71fbc8508cbfef41c5172f300e9cc11e459034a09491ef0524901a8eb846341c8de12948f5045ccaa4ddc8288866c129439fc4667164e71c738204c9e5aa915c01dfe93293976f951f430f538188476bf0688546647cd75411c16d1046a3086d50a6c2ba1550bb1d49eb7d6e4a311d6d323ae9042f13494af12e1bd1ac59dcbbdd9cb31b1dfad42600cc1fc615a1c62aef4f007f40ce38baa9e2a1a546419c7cfaf54a7901f6e49223d3048db65b3f22a8ba669cca9c1173ba367a8ca6fa34ec7d5965605d1476ac05edce3cf7173be30f0583b3c794b6e1085af81d6d61cba65eabaa35232dce02d74c878e184d95cc86d735f14a84b53ebfbdaa921bcca70be174344bf2c12be34fbefc81ddab3fa82966baf33cf0ddd8852d9b1e311c7a06e01a3ef2a61ca51db5671e7674783481d8b5089b244de77ec65e21e40fe6c99e2e6c05ffcb2567a6fc457030508630abf8842323507b78dca6354a25e220537744f9bd668cb7202097570cedfbcd4aaef0c2821bb1410bb6f1219c765f41241bedd4e4f72923601b605ba27a5897a60c1781479e8052effc8b6eb1665708923f60ffe85e624f119de32bfd1567f32fdfb49846a09a5575a2b2d09391fd9953bb680468bd33b4bd1b0146591c8fec4ecd88578af85cb50e7a4a44569abbf26ad085e324dbb917888885053b4b5ecdbd814700b49ba9c4383d1c544bfc707e3625495cceee7c26af621a1522d79f04a2309f5f861297fbcfb61234b6fda619dbef96b0a4eaeae6853ad05b5802177e5f7f4a742aaa19e9e4ff84ff1b52d4cd393df361fef5e4403c8298bfd14d03ec0b676f47b3b82de476f43abc80c09f0205269c7e4ffe023b92c3a023822763f550a8077be3c35d3d7f7a75cd87753de73b470247681c230fc30e830ec9c374beabc9163184a222ac00e74e90c5dd46a4458499cf4e37bee01ecfe197d9eaa55531ef37a50fcdc91f2da76af79f57ad46919c7a4823405f1829cee5451d3edb153d093749f623f38f59f29483bd81a298fc5481815c1eadf9cbf309f4ab7da17e6a56d14e57dec8f31250208c882c3a969fb684bb33cabebac06c22d609d06c35c55fe49d30cb97d8b4ab5fef1127ce432ae0057b929f77ccb87c82e654caf98394cc5d450e0b551fc99e31421e45d28b7e695445ac07240a07001c5f3de2dd9de4bf0294110951aaca64f1a3c5c3419512422d1e14c5fec22eca1f50923746456a45fbd71200c8ca3feb06eb6518f88ad5637b54b2cc0fb452733c7d1f5bfc66187e2f776d1bc472251bcb9d99c08162572d69c8a415453f54daa2d7aee09faf8d2bf060dd7dc0ed7b409c516900bbbfacd8a1e8e16e108b65a62cb7e5ddce318948bdcb5c27a61bad9593ab97cc5b4c0771f8dc751e6978d029659d2a9bd5575621d7f7663cf5b1794eb3cec8f135b6ab6b2379e373b78329a02cb7193487e77c6ef96d653ca6645fdd00b6de2ab33bc4a915f338e5b64400963a31d18d011f8f70b73cbfd0564427ff095c56ecd08e99ffe461594b922716b881b6f4033f51e6b811ab3038709c70865030aaf7f08c935d7ac5a61ef6c7967f6205a1c5ebd9fe0550e379b8c8f8fe1c9105fa9dd66c15bfd47b2d3c64c8e14e008623fe3889d8299768fb2c26d22eb03d6b2108aa130117c128032a174123fe2dc5c8d184ea50efe21a1c174cf32b4530c4c5bc96647933faa924f31e37f698b210abe7c9df8549cd9ac535c357ca9089ec8b295c6088715e9c9d83cae97603a0c38257daf9f26859812583e3aff8ac9f6d629b08909c98bf41a5b206af21be0ca035aae63d356e43dd71349365bd922cd8707b70e6975fe8677808568723a1ff82be4d928d7717ed1209ea2621643e8bf36c2e8459d0376ee51de852a727b110b853505488b02e0d5d1f7f0a06972f343f40b0733ede359044dfd921bf36d764c5684b03a27707e689a2fd710627fe43b02316827821d53c9d5819fb116f253e40f8dfcf844c15a97af5b8e1f61efd44d8ed12af5a444516d6e94d9247069cd13a431a9cd9d77730557c7251f022ac04dc5962c539d44f238243ff2c3e251aadcbb3ec70c6128f1ec5c6f16ac7192d6275a082ae12fd4e3d1306da6567777870f58a835844e18afcb064be52d354f8eead3975544df6a761b8c559cfcd5d4d72a875851c907755294967a629202bab0c3f9ac968d86e69e7152f293e25ae1015ef080865221011e28082ddb7a7783c925ee9de2aefb6f2fa77682be76e637595e70a4763b998739d5fdf75f1d49301d708e96cf7addbc455922b35ff5063db30abbe52d5423c97e80ae8b949bc25d9dd00d0536d5b23be707d7fec0e15c788b49512e7a372304809d60eeda596eb0905beaa8841de0d84bec1bd030d234be9c53468856bdbd0404501bc4c65564499b723f3c5f871b0cc05ce401db2dc58cd5674bc42ef2f82f5b798c5a8b5c88d8f1829d83f9071dfa7c7493e1df40b14c3a7b1d8f41827b41e9b302d303ff47ac22b7fb6dda1cabf49066d2d86003c6144df9331bff07f07c4da9c657443885345ed4397cf46e9dc9514c05520cc8fe7eace4b6c249588b85ffcb0418de1dfbcadb2b81ce5e4f8ddfe91e0c46d9510aacd19902670a1cdb9e006e75f3ce60b2dabc7602c70fa12f7c76a8e1a2c41a3c175aa9d1471c3c17b7483ab9196fe16e0b7ac4a6cbcfac643afec3d91e633b142531e2afc63d80ff635d682c57b292306d397a6dd8cf006cc45ae33b75118b96bf819f1b08b728e130730c93801a6c99efd1bb827238d063dc5689da64810497de04dda21683eb963e35e9fe7eb14d5a9b2e79b9673e817939045933eaaa598f65cc3d58b8de85e2e7d89c200ecdb94b65a8e7e1ff23a5425b34ebaa9e29c32d29190a6ac232a10d1c03ddcc46d4bec256abace0f17a80ee13aa3b8780bf9081ae1c0557b7559c0151c1908ae24426fd3258a583af8cb3a4384aa6659b4b72be735cf02a586ba03b1c87a922326174a1085baaa3ff80e6d6f16a3dd8dc4d6d41f1dd140b0113dae5fd0127540e373cd1e5dc0980572736e57de9c68038beecfa3dedf9f815babe23758787e133e62545611d33ed38518f40defb8530f9243738f28ccc6d18e4d18ddb09933fd6028dde4659fde542e0930dfd30fc2a0d243e557909117a2179240e71e0624529b38119b032792042dc7b7f2471410612a89290620f8b78194e1ef066597207c40c8df13482eebe61a93d9513c56778babe4b9272b76fed650ddac391a8edd2f561c6fecbe95af914279e7c18430dfc07bbe03e2d9e75d4ed1fe7fefaf7ac36cd70d06742e6c1133790f6bca8b866a1945dd5e8422288433092602cfdff629453dc4b97d98a6c25c450d46589143b1de32c457861773a5a986064b5dff0c9b57d2f70dec606d56575c45ee1e33f8a19a4331b1d8fbde4435a43f09362c46fffc59b3e3400cd4eb41a75f8b2cb8607f1fa114baf648327e87693ce2e384e35a971721edc3f66e9166ef2a962dae322484d9a2f7be08817ae0cf01431603a4a743680c5067ca189656843248da75cdf18498b74244dfd0ffde0a14e1178869f5982c9fcf4c3fe11eeabef105b4fecbcedf22ecac1645b1766c63da2e6d5e42fbc240fc8a740f86a0fb0bc82cfeeedca2a99963b167610025fe813e2f7ba5dd7f25b31a7a334d86b9e86ed78b1c7067b2ff4bbdb45f66c114d045400fe3845a4b73a0b05d3a47c150a733c16e4fdff2718f5d3c698538e78c7640e98c70dfcfb343a202f3bb4003dbf924f8ad4c20916e0ccfd7edf9e51c9d0eae1a7e6b7f15ccae1c3e9f83ca1fb05d9648c3fbdcf9cd3855d2d6880d1da691893514620a19152905aca27b1552524452a7945fa0c12dc4a1a419d2560588389603424b1d7f504c1034de9b5287cd31cdf9ff2c33b4109bc77af9f781a0d0d429faff0508e23308722dbb7cd486148ff64b665d5eea6bd65bd57b3a324f4ea2ccba36f6b317122e1e7175159b639c2af9ab9f0ee227ca66ec9a4ad40acf6f3c4e65b71ea51a5d4297716f8bd7b21f736e45654bdf3461dd4bb4eb6ef9ba8af0caa51d1dd3e1a18adb2679aa9f17d4e0f2164c8712eb0eb77de5ac1144971f33fac0dc2fcbb8c0c4457f70738bdf8afd72315f13fa91dd8f89e3ce586382c1fcdf608df29774cde391eb9f17812a133023410a6e8969a558bf8718c7ab0f50274253221b37fe95a489dc4b9ed7056e7d9ed625fbd43009ab9a7461b146445b8741482cfdb8bbfda62cfbb62cd0781e0e9a5fd0549000bc449b146824a6eeb6cfc8fa866864479afc316cb6093e13228ebf750221828d5873ae51f547c364833baa26afc55bf82c5f7428fa4d6b7a339d7a38221bfe1d098eb8663ab7ab4fe1f7b338c5322ef367fc1c1abf0b5cbb93cc5ccca1b5b6b5fa183efd4d9ff126ea1bab222bd81d6ce1b035e61bd075d3bd9ed6a346d48c15fec8ade99726ab5593ece1b8c1c243d9060a586628b84a6220e7bdbb9a20c0c3a592665c53439c1c376cf8ec5acd9a2c040e1f862e515392db15caade9e6943a6f02db0579c4825619ae7c82eb042ad795a0f379104a46205fd38a858fa777c26ce755a44bd17fc0f810ebdf2beaac5d0916f11ad84942eddec75fae5c45acd82eed20e515d9679f0839f8d6323ad302ff06c6d2243d59190d3fac2bfe045a3858b7d0a12ed8645182ab8a34a08e1126f9b05ed77646d0028f0f2f5b20bdf11c1c5ee116f7a33e93276b0b53491857959d7f9f1a5433bb2b7aa9d131338e9084a4ae6de459a7d55ebdcbb59f8d6278a5f900c643b1ff3a877312dbf204d3dad7ce2950fe153f45fac54071bf86b5a4f44e259eaf42ccd52f87f2c71e58877a531325721f220ca051ab86e659b2507888472848cf606b3f7099e2161ce259e3504ee10180f4d138663f282f4404f02a0d9c06aab37721f2ba2a66d390ba47f4697df48da030265f1f3d6e240909ff6340988bdaa398ef7ebfd4beba733db6ce89517c934a63bad88eee46644b46972bfbdf522603940e071d50adfcba648e2069d65e2024914380c7c964150b2c909e459c722f120b08310dd1ee759538da0e3b45de19b2769469fe81003130ffad18bceec016d23b91c5c176d67387da0eb84b9c2470d9523abfb2315e3a020c99d6550999a8d220787830e7874b78b4df394eeef3ccb129afa5bed19d9591f839d6f52081e6786ff73e67b060d2669debfa22c0518790c06b2a2b3d3993f61adf7a47fbaeb9f0a4d28fa5061bad17969b0b9349fa09ef0bfebb2c80a15f6d8805d72da051b4fd0e4d34c85dffc5009cc90ac6c3f8e52660fb9b48a780d843975813b1b613e887433a8047baf091dd600aa124ca8d1b815ba2c681553695c703f5b99f0ae731c900b749ac7b03dca17bec4ef89ffd3a3906fd7caf7e348e16c0910ebfce225e0f521f271e0713d28d5d12623b0aade63a48ffa0865f39c958126428d70bf3aa65e1449b8ca7a9baa4987290babb376f3eee2ed5f4d16136a7efaeccc8ffc3481006837e91d5a312cabbd004c7e3b272b995b0faf50414db6f3da7d9bbaca1c664db5a016cacfc0003ccf4885c0d8b3a0a692cf913f5ff8655002a914aebb192bb644d1a6ef7040bfe992f391687e5696f92b3dab65536bf0c893593756f95dc52b592b24597be20527ab5a4dd008b60b30253dde3e99fee1c05f81f757f395b5389fca364d4053b0d3af5fe27ff7ada022a0b95733e704d5421b6eabd7cc3b06b8d125e0e1c6eb058865f51669b0e04094948cc20786e1bcbde7372da70ebfff40e9dcbe2c83ac5268bdf9cc3cee93db369a99fb83a7673a8703f239010590352e022546fc983334b827c2bd6fada62fc1f40ce19c4827a652dd79b8ddc334c24ec5dc97b278854a74ddf4fb545458268a02f062eef04fea25e31a2ddfaca950ad63517ab2d26d306eaada07af00910e650e84e29fb45d884b57dac0c90ceb19adef9b9a1cedabfe17c0d65ddf501ea19ee8d8e227e09e05bbb0c6af2c6ea244153fc8e71e898ac296685b90baeea16264b0fa1382f42d34ccbaf4fae5a204b8336e17e269521d74596acb9d785014c08c1399b059e4259a05b29527bab168c9abc1f10516c89d68821c24a23e3e587ed7be797788d38ebf496279d50bc33a7b81e7011d5bc85cb99e2f0c36494896843e03d55288f08ec7ad074c8371d2c1d2144cc31089b098a632d90cd83ca68c49e3e1bb43e1330c258a783551b478d3577a0aa24c4eb1d89d3ba7b80218661521e95d4da302987c740eec62cfe2c2c7f8ed27194e85f1aa26bd6f8b6a12b0eb292073a99bdf793b38fe5d79a09f180dec97558785917b4a158ade1ee95cbfeea92db655e2057788c73a9a1ee2d32648392814b80a99c9c6249724572786d97a439602892bf666a996d7569697098d3c95058619aafabc65f32a17262c0675237f6f18742c6660d7906eb4a70618017c017ab6a651902d2438b0e0375c226945a4e87cb586e2d4ce4ad5fb6bb4f0f324daa67f922c0e546e816c17aec5ea284c4d405ed30cdb0e98e26b710bd8e33e7ec0ab2fecb0a95152ed7e36d2445dbe4dc49ec30594031a1495b870dac7b2f846b0b0cd1a3a2ac9cdbb6037c9b7440f1634409527535e09b17796ff71d027427e599dee22ed12df4966e00b8223a57e4f29fec67382610a67e0caf7c2964116bf53e7ce82128046726909789881cb74548c377d9ecf19821a50d040df0b6c027590ab51fe30e23c121da7eed6c7269246b36cee0c5cc50eecb6d1ef6fe31c2238dd19d22b52a14744d65f35931cf6439ff061fa7bf7a552dfe34ae2fcc8591dcc01d9011b723adf4eb0449be2c5cdc7b180b57abd7a573b16d6b6cc029d307f4880b7cb54efcb9669bd7c3f7972cf9206f5474d1f839a3fa995d28c9124b935667255d141312c250ce687c69a2ec4508e941ce7acb10a3239df47f98b27a2683a73718fb196f04da50c302c104521fc0f710e198774977f248c80dce06b8ab3cd1dca605aa7fca5ade34eb7b12ad91c85f7ca1fd496733dc3f8c3e7d2c236189206f129be2dde6b6146ef8aabaf0eadd6b664ff0e227795f00505c94bdfe1abd2d5897a1e42bdcf9280e75dd3ed8f491990b82262106a72a87602d15b0652c640b8781abe7cbe60c8a3d73d4fcbc781a77bc95fd3ccf2ac81f6bd0f8cee159756d7115a9ebc6c592293854bffdf683bf13340a9f114071e0f726d0a59409f13f274a6a248adf0aa425fa3372f94bdbd92d68fc852086b73dbf1921335fe7c0490015049a16562ce77622b7abe1323ae4878b3e4f56d1071f71b7e5438470c543fdb5ee2a5615148fe367b4886edefeddb32c90d5f5d65e38da4c7396c43db1d023b1ed0b8d0c17883cfa4082ea5d561507288a9a07b85ef0bc5cd7c5a490ca5cf823d8196817ca4e734a20b10a6358a9371a59d835d42240105eb206ceab2ec7ef42a68c1f3ffee6452179b3eb2a6ef925059ae32bfe1b22d0cd257253403ba5554d43476f92cb465fb71bca3b5390a684a491a444e1575915f8f718f113d9bac8b1c961d95b29c43c4210f31777667534fd957812abebb98236c7c6c67e411766ec1df1f8e243ae3baa153b2e73250640b623dbbbde002b1fe6d633860ee601723af7bb26964758b85467791c1289299124a746909739ca124dc5d9e49f5a463b36980c116d8195b4bd35828ad313b52cab72953268e18e65dcb8d99a3f3e10929bb8d12728988c6bb913809200a406f8de6f4a07cc6142de8f8b4805ac4adf61e68d989cb3ac98ddc57850e7f2c9cd25830afb204454d4d8a34e97b35d49ba1f9297075a1df17789e5e222ae78229a94c97836cee07042f935d50c398c8571b0d2276e7633473fb723c0bbf86bea11e4ad3a62cb6642c4aaeedcbf910691665ddf5ad79500ef61c1dd6bf3c1f5115d7252c0075986b62fdf6c79194ffd47762381c848f8778b89d158a9af43d45dbb59b3524a7bc5b75e56bf675b83b8e35c2cd632e029d3cbedff8d8ee6e2e9c6836c82db35b1f7462d5367663eec4725efe07d93963e082729c8d620f679ca65c041f7b583a37c9166b248cb582b2a39ee7c98f5d295c90d6d6ca1a76836aff55998bf2e32f1de6691a31398f73c635e1abe3d77a729f6f5ffb42fc4714a7bb5b4c3fd3a29e74aa871a86b95733632488fa41529d90cc3d5a4f982f36abd68b54b804346626ba31f4b15f5287d1c50b412ef13f3e40ce891bfac338842083e7ba615aa35c3eaaea52f1878f32bdc8181f60ce5ef636b1012d667be3e73707fbdbda266a45a90aec2af6c0bc897e8f196989f057cc5e9992a7d3ed266fae03e3711e837ff8ccaddc5aca68ad495c740e93c074d3b45d06afa0865bcd8d6acaf9cb1f0d7ec26aa0e1ae0398236cc19ac4c7c66f844299ab3611dc68be5e101436a0301317235b17c06c28ee7afe83e2eb6fa189b79a8c76d80171bce4552a283816eb4dc409773034e1d6e241b31e836aa14d464303ec6eb7d47c1b74b598c82bdf4346e959ce40923b9a128ac1c7a2ca2095fbe82cf0a0ea4c57c3f7fee19cebb1e9018f72348538fc92aeda51d7a3f9298135e5659a6f1ca5e603a55664ea3bdbcdcb81e6b1f7cdb54cf82675d3beef9498c3846e528f3c720e227f359ab579e197367190ce972b077eeb17361d0b106ec7a44908d3ff5e3c0e8553811aba91b377e361701a4eebf03841c6aff52403176a55ebea8e4c3fcdb5600310656a7c43c71cf77e72a58efd7d92cfb70c424c64a15e0ad6c74a0b17e0fa925cb5a9fb09c54df1061a0a2a4b14c7273e13056509e2c6b528c945b7054c5b184aa6da2c1f13e86d70ae873f1e6e35792a446e39b5a906a0f0a1f5170213346af3968aedca9eeda1e2ee77a6f2b4d4993c4ade6f522c22dabadc85b082da6d0dbb24c910cb41820381e7feda772010f9cbdecb1f06e36506dd266e6b011c4645211e7aa08380c02db1c7df01eb93d9812e71bc718519d9e785b55395c89981e685b94e11b084a846e447230e7075c16056f57b533a8f614e7a48f0ad78d88be56200605449f5200947a1dc5101d60fc510a01c059130c8389f4085cc95c4ec0d064565e34f9518adbd1b17a5912c55b0b466accd7d97d20cfad7aedda7116455d65bffd5f4f58a202f6aae9077dbf9574843b5373109f678e318998775beb5213f73f09fdcec4911e6f2d4dc1c64b9b29f9cdb41434da454b61a45dcb28d8c1c12ea43b0ef63e90d9efc3e1d2e080953b1508401ca3884e0c1ac3785f5a33777e0a26f52c708728e8a20227dd686e8c1cae0c8b59085b1d9aec8c409654fa6e25185943dfa293aee52550981032b08ed6a33d8065318b8f5b24fd23f80445b4d5c5d8e2dfe3b86883f47a06a61ba60e815b3cd053d9f032325599a82370741c920f0d6498077e5b6723ffaee8b16a4b18ac165b53c546a58a25407a22eefc947ab91516e012f6a301b5a5c3f2fa8cf75c3c9014df8fa2eb8ff4593f9ded7d02dc0f80a98cf61de1f9ddd7b28d830790583081f22b1d69abb67739dbf6d294eff79531b8e3475ea9fae7cb6e7d8c30180f0036acd39b1482fc546dba34ba8192e3f3d5571a37c69a1e2b95fccfb018e99b58456e04c4e802380aca7f0f769ed3d7d0e0f664ce5674cdb3a6ab5ba93e311025b31be8155c6517698c2df937f3d29d92999f04e24a493580fdea95517dd5dc8e66fa248c4ace8743e68b283f4af0ad24bca815308a8beabea1b4096cb0a234666bb0787306b655737db1dcdf2025de6f3e821306b63f3d869501f3fa056c724cbc95d707f52b22b541c67f6011bdeecc85070eaf418600e886f4481bf65f6c6638a9e53740edf94ed567a3850f5f0fde594b23613258247ecd7820e939cf31758d5783a6febc89069fcc2f118f4812934aad59136a4778314ff66bc3875784a76457980dd3d4a2d633f0ac4b84b5a87a487c6ee2bc3b216d0f2aa544f27e49e070d24776b9e77821a0dfc361a2ac66e57aaf8dd8c7c344d1f43a9c41e1b9df04fac475ac01ce375188ff6bbb573c5cace87178861de5b96d3692e1ec949b012c1006e6ba02d7ee74047322cf949b6f9a95699df3c0f0451275609f4e7b5e8627aabe29fafa4b413da89650ff6c7e940f69a358bd7a570b4a6ba3721feb968aea0540a264d17ade0a007465e352a7d685aecaa7263609e312b36a07124c4c01ede58666cade40f830de3bba7ab98b858aea86932d1f696d40ee3e60fde12485cc2bb6adcc9fbcb59d93e55911e91dafa44291f48779d4b4ec53339e644ac47c1494d4ae3d3acf6a4be545e72c4db08fd237f7ea04ca1f2d26f969713670faf172f8716c880c0c4c108e6842e427d317a46533fd28d845b80478e3f05f48b14f766ec8655e713a8b9ddffda7728d4fb5a965e154bf089ba08c4054952c54d441ee0e76cfa8da79c1f989ba4377a0fb400718d4ca11739bb3cf4f9c0f1f46ffd8d131f31ed2d2c05ec3048116891278a647d6ebe1a7a4caf12183822bd2fd01a9c22266aeeda371def3b03e7b9adf827dee79f42eb63070243e082736ddc8e6fc60a0aaad246881eee2b940291b0d67cb8420eb75708e403b57bb794237423e169db395dcfb4a0d827656d899a7a1ed6ba342ca6c0f71f4fe5b39a405428e7c095567f84c18f0241edae9d63f73263e87bc358dc53c245893d8d165dc9ed91e4404224891c3416fe78bd83aacd740824fa769c02e6f9b80cf46313b48f2e5f0c5885badb0b32b62f732d374ba283e462062a0896bfc8e5b46747b10f4ed710dff1dfa47dd0022d9d330cb2d1ed346d5c236dccfaa310974871753c283fee2f5541a5e5b14e789fc1c3e7befa59165fbebb5734796ed501b14af4d549c635b2d3a15482970ec20641076be1e857b7288085ff45cd9c8ffc30237f9d7edf1faa9f4174bf50003ba9f44021e6ef1bdce221b18bbc5aa1348d53f479c7d4fd93f51c122b45412552e9c50c2a0538ac886cc948803c053d694a68d82615d547dfe4fa91af8a72567a067df9e4a6247cefac4f88def68907ccc17b5169eddeb2922bf6f2bedb5259407cbac01406fafbe807041663a4d24110ea0deb482f4b7913a61a3b9b4987ffa67dd21c0b0f86227b4c4e0772b4bebdd755d36da93fc84fe008b5f756c49699904def140c5c2fb0b825dd2332f21c427356f743c11eb038b009dd1fe4df1b19c42be97c8503a88e26e597f2a9a71df49317bff51b1513ca301d2dec292ad43ba075f573fc5f391b7ea6f31db97ce6a1c463c7bc1e1e6f934eeea667ff0411e5370ede1b173e9724a4d8726d68a486104d86df2d5335815cf417f80ba22ae450b85f3076c1f0fedc240fb7c300670119ff94c237489960b3b6d259fe88d9019b5dd5674c91ea9592757662c2ff089598dd4db6ee4979e9c615e27291ab531a6acc533aba2f60fabbe47ed5afe3523187097a285fb3baa79e9cbb545380812d9320a5740a8f8f598cfedd5aa561aee558c4aea2d4237b4e6a4e489b6c584d958130414a7d749ec71e0d9140c6d88f521cc625c52cf7d806c3076c0f19e2dd13be6ebd31d03ff2f6705c755f8ecab67745ce3689c71ea53d5769020b1701e9205c1e6586e2989443ec8b75c6b9aaee544d5c728d929976b286ccfe42dc808607a16ead063b0828c88d47c7bca98d19dc41ad3f0ecfb7e744e75fa4bad551c3189b96f05accbdd551b981133876ddd5d3a45a91be393cbc1fecfa9bacf78006c40a3eb9e844d1cb7ec0dbbe23b9f35b70364d60425b416c41ec4735813b6f49c8478228910b89ddce3f700f36e2554b686eea9687f35d08536836e3eb2aa547a2bfbd8655d334c886879e2f0fd23936589e8b0c926704e3494fa699bacab8f01b1a0d623ca80ac1800722c4ad83e26c6e44c9fdfeee344b204c3ae9d4cfd6281ea497c18690be585cfa834f4d1d07d5a708a3556243e1b61948da45dc56e5314f094f5fab9b43df3cc07bd844a52a5046df66921bedc93bc153528c3810eea1b582009281789a6d98b20e38adabcf95baa45b87f664a776bc661ba7eb3c5cd76a9d931370eef36bdb61ca33e449090071427e90da2947d20d5a82e89cb27c927ac1a640a681e3f6b157c7dba2dedc6d38a36910a2c1854341695f0dd3f19e70a674dd0c0b77c38d25dfe36bab1a84243c7120beba9a2b32db646ddf3d80010a75312900e3d429c7b4b6c4a5fa93732d2c7df15fbe56bc00241aa64ce18537d18d0e1a070e9cf8e0fec9feb8c5d4ca4e024f537da4cbe0d4bed366ff03eb61128e8b91db5b9a674bb677dc9f8a09224200209e82505e73e7b3f211870dc4a7f984af5f3855d80d6fd6d90634d2ea0ba15dcafea0b88731c46763d7fa703b30b2e43098dbf2c973cf361a09785f0b68058df660d38012b17162e194477143c3380c871c0b1af48e7a9a99f97a677cebf06677e51327d4142d6022c3c22c03abdee8337267f8317647dd57c5437d84d50464f958fa1cab2402c5e39cb4ebd57958a8fb628f49eb980131151ff5e7910af516f2fef798c0a1bb2cc0b70554a32f47470dbf927ef003fd009069b3bdf6a9f774fee900a5dec109bba2de2ee95ae970278a27b58408cd16f0f2d7dbb6b25a6eb3db40b95a68222498c9407fc120db644dc7534bb09d35b8f9d2b43baf1223be6661df632e71cc693061639c6f6b8b1ef03966e3bce76a750f3fa07fe8fd3cf30bdfd35e66287e7a1546b19bf5ac04daefbe3b976e60ce81fe221b4f8fd810ec97a398df6b2f95ad1623f99114b97e6d0a27d4309625b00a7abeb1727265e305c6a27760c574717858d2880b14d67a8d58f6cf85ef5ae239afe89e5799448ab692c2e72ebf39296d67cb9fbb511b963306d51eadd526ce787a7901d9545e315eb3e4c0f8bc7c3b82d1719f5818f9791aac49603ba3facd62552035a49eb59749a79b8882431bc21ec2e165970dc874818866d620b6d07b8ef311fd93033a593611e131ce08c0056d39887b2bd6e9550a8a03feac4040659516bfc9b6a2549b8e3fbe7632da20da1e4f351e3145b17c06f8332896a545d4b40e87a601bf1cc29c41a93fb0a10c5562cb78d4da0be30b5c4a87213ef4343860e3560eaf48a92fd119df598feb2a6080dfbe1ffe4cc265663822b1db482658cae0a2132e03529de1cb39c0d6a41de0df04961fbd82de1ff28dd5e653e3fa9f61582dc14ae2030f326954ae24b20a2ba58885ddb7d5059a7a5005d942e29669d850ae9965e1fe72e36085db9633c08e34fbeaf661ac73759452ba5c1ceb0d671c09315e679ff3302dfdbc27fc82033de45da51b90a4d99fd6ad05659dcf6c3c013d0dcdd8ef02f940f05a209febc5abc86d3d62f986ee1d96074cbe631575181d6a00afc937530faafd7b4c054a227529dabafeec0acb087fdf8a4e876637b0ffdf5e8e451f5b14c6c19b0730f38ec57ab15dc1afaa32c2ad351094a435b4642181c7566b56b1a0312965d962d7ef466019c8e513aab12e8b71df97b418866ce28ef3b11ed2d4749b703a6684cfed02ed64a6c7ef688ba8b36dada6664bae617cc2ab57a3aa197d565edaa220ff852507386478ac54127a1eb7b1f8de9cc1907836fbef16cac30544a278ff4bfdda626330e2f3253f2b9ee4065a1354a41083ff5662a1e42fe9fc9be27d9d811cd4fe41514cdf46cdc6ba9f3fe8237c354641d508fedfa1c8bd8597718ef75f8c83ac7f10305581503ce21489465f701cb090a7300af7f6e0e243ba27c2dd344874b76b99cfd196d41c9407cd2f3848165829f2d390749efcd7e5141bf1351c6dec4c176e8feff226fff21daab4a0fbffadcef46a9e3f1d4fa75c852b6cd621c96eeb40cfdff3dd199b92a12cc98fb3287ddecd877f5555d8bb2e4bd6faabc995c6b1c6798dbb7ec81fb81263145fb255a44e2b54115adf84c72aa3a713511b48e3fe5a04e9e8dfdf003e1c1903296404d910d04c13246476063233bd780227ed24ac261af5f33304e973108ae90d17719c49f3bf0fd3ad4dcd47d0367841c9c26a6fcef5f97867442aa734191903cb5923b6762752b5d15adcebb7d5c081618560dc5a25bb2d1dff30dc9152f96d9b8899528a0d7fc48c7f0fab03a530ff5819d5876cbc303a5ab7ad47b7172c044399121d730dd9b880ff0bae99eb81e25324bb24dab168adc5dee1169991f7f35635a2fbe8311ec752244983018a214f54ee0e6e9a48a519d02d6be5698e09c4d1ceb2c0a09279a4e85807bbd1643c4516e9a3a579bacf5e72198ad803e1c7c00e6914c788d9f3f2f6ffe0daeb28a80c526ec8efcd9e367fbb6a994e79adee97515a7a19548f79178208c97b6875b868e0262de6af75c9413fb64e560889f8a0539116ee0d9cf61de839bc2a7a2bf508464af5bbbf9aa5ce1b24cab97f61f2a1ce5fcd6fb0cf0e04223f65d3c44e4be5e4186b620e8bd78218842bd21e3fe3cabf2021a0de034ee190dcc9841d5dd6e328a31b6e630140b7f24efb2d31bc08cd7b1c4e50333216ed1246c5b3de3cdda9b6cc8db352138329f1e813a8f97b8345e328bd5f9456e1dfdf971b137c0d3eab46e569bee2312829b1fd9ef0685b7c2c7d970b1d090fb6b62fe0aa1c08ed00c23386d2244430da9fe212974a3317f47a1b1aea3835ed96224187bd126040e6f3b9dd26e5a7c80b17eaeb94bbbad0ec39211c5acb5b1b96fb9bf109fae1edd22a013cad0050b6bc2e24a88953daf61c4581c46b7c77b35d92852050c9513ad892c1c1731ad61f8a52319a3a3e9040d332a71a8540b2a55f49befb8c4ae5d8cc2e9e99ac4296431e5884c736967e8bb77f2305b1484841e2e554fbb5afd681a05b255c1e21009dd1214cfb0cad499c195c7a847d6f23964755012960cede93345a9388b86f7aa006289d6b8c142a62a2eae7b337de7934220d4a1aabdd9b63f5241fd23b015fd8596ed6ca19771dbdb8dcb98b57f4cb5b5a8545056c0f661968a5b2da4168a2f60fa817df576cac21b35396c719e6c868cafe41c49250b7e3efb0cdcdce97f816d5aadfe6eabd6d0110d176da4cadf57c6451db7d13f6d48e87d9abc81cf6efac25e68525c78afc1963215866b81e0f15f317e1f1b3dd047589edf914bf28b97a80ed56116131ee3f2e960536ec70136ec34c6174d76ea87026d57356c82d28bbe23cb17f78a69414123145a2b62d19d6965e6f2f830afa1aabb3d6f06480aa69d729ba9faf60a3f626a059db79ffe79cbd3a5e57a02143d941425d457eecbca673007570acbc2b40cece69677575ac778eb02e07e693e0379a7abc0d3596b721fb48e09987097153bd0b6b23b280bf589c5e21b1b9fa28c5b2dec77493fe4ef3d3ec349438f7bb0ef1152e5af21bd955a3fcaab96a3d67f023b8cf7f88813798a14cb5bd2304ca166d1b59f2be8dede1a2d552948a2b83c018fe6d379f183ab5e15a1916403dd28bfcf921d2b4a01a9da39778dfc944a464541580ed52a982e516aaa329381384afd2259ad7da6e9ced03134d7dab2b2ceca3d09a8067be80e367644d37d04aeb04f72e7aded1a560e51d88e801f0b9a12e695e31641dde0afc2cade1a79d7627357b656bbf1ca3b8427306b9759b5e5a329977464bff8ad67754a7ac196e81c5616cff34be5ca4da48569d42e8ff8e665207fcfb427a5de75e3b664cd26b07a0881fab29f757614efa50a541a504adaeaccbb397c66f938358de992ec05f8d4fb2a930f72f9cee4f7da11823f235295fa990f00b2eba11d5c01b839b317e0d1b99654c3cd3f3371e90acf4d7034d35e28da5516e3f58d35313359abe7eb897156a1e6a37430ada5fc51c9990e12a6b2ebdba18cb523eb6dacb151a137e50a4c8b2c415ed4206ffd0bed0698fded090984a6b3e467a45eb64b08ddd9ab91dc9381273a316a684e2b8daf13d81f9e8a4a4f5af9059f6fd448dcfdfa388492ac0675bb0de2ca251d6d3c2dec3ce6a28116d73537697d3e647cfb898ad94cd0c6f991563c6583487c0a37f730730982d29f44a1fa6831da6bd96938968da85c64f9aa8f4d47f0f4efa954e4c2f46beef420afab66f99035ca24fa98b3293dff1e3ca9dda77aa2272e40c421d4369ec9f60a565d9c4c165250e3598c8db5e98354171c82c36a1ed3ecd7644a1226e131412ce2716e5ef5c78ef000e289d5d9e60f04c8f64009d80b2ca827804393ff435fb202ecd247fd360def92d22caae8a18f6c1f367182453561069a6ddb56cb76745554be626b2a2f0a3b9699bbf5ccff3a19e3d985c40e3238a810f180bbc4487a5d1d675c672f657210e8ff01b6fe819ee91848688d46ca55d7d1904404ba90a53da629c82fe0aa8ac78cd05b8a4208171bdbcc3975b04723a6c99f18d5d421426ea7a09fe677ef2a3664927c695caa10145714329bcaccf31906e117a3c53d983c8810f63dfd830e57de906435f3e0b3b019a3921407a86bc1ed10f0278a6622f8b59983976752b5267caa42de82bfd82e60ac0ccd668aa20da867518948289146fc233b8314fc6780d817e153a94ed90b1d68026b4c04a690312d0d5409de09c92aa49cddea1cf154c13335f6c6d070389695c6482dbe39623d30768be68d8e002227fd16d1043c7024190187a86d7bef023b1d8aed24221ee1ca5a2b33028d74099b5c09685537ecf60fa3214184f5173658b47e387fe70411049784d6ca53e78a300f36575603bd1d22706308773b3b6920ebd910972f39b82bfc19817d93f0dd0edbd4891dcc003e41bd3d54b3ae9d9a2f370fea9fcdae8189c4e5fe3970218614505e638954eb2f3f19c8828e79362d384dab8f3d910837a3a57230624dce424543e95043ba387941137874bfeb9f864924301bcb5bc11b486c054d282aee6c27bd2fe0f6ce7d88ddd168e38851f21d25b6f41d80e98760067155b1e5a029772ec137a579fe789538ea7a9cb0f20178deb48229f5a6b68718adf74a3dc95129bf192a952ea35af8cb5a9d401fcc6a2afec690981fd45af0a3a02640665480a05a372367119283933a8e63c496b0d4ea6f36680b14c5edd5bdfe7e2eaba0996fa756f8b7e43aad273cd09ea174c8614d5e765febd8b2a270696040a574f51d907c8fa8b6ded12e983c74128993576c19f34b393db411fc855ab9f54576f755c76c0643640a1b036308688dad775b84b9bbd0f81a464a7ada58192896a69fcce2779aabbf1ae77c35382a9923d6b96f34f7f962d41db733dffa63e9700107b71df5e34d4b0101a895a1d58a8ce793130caeb4c970bb79323c510097d96bacd59085d4096407a4861e9d886172296708c4a6eb0772e1d6aed12e1946e41479ee42d6207055249edf08eb34c01e2535a7514b1341e44a6a396f2e1f6faa172863966c104364fb698490617f78a05bd2f157cc117a2af2a15c624d283a822457bcedfd19b77238bf9e5364e92c966f59849be842a1cc1debb45c4e3a6bdc67f353d39e2076a1f9da5a6517ca98a472e78e289a1bb6000946a2de0a7aa2c1581ef48798b3472953f444f53881c1e4fdefbe4156a58f3b0d3ed650580cacd6678ef10c265c46079924ceb9aeddcc13bf52a1c838c058081e1614dc187059ef122aa04ee39924f48195adc0f0418f57199420a2fbfec985f377729d2f438bcb4a387abe2f06eff132e0b1e2421a2026975a1df447baeffe9c009e2060a7d50a54d945af2a651153f269cc0a16b304884a212d59f42d5f83c3e8c93d0c6c2dd86c2db85ba9eb702dfadf33238f4940f43542910346132e3adef2466d1169593a4ae84629f6507f32ae4278935ce04b7114fa37e0c7b842fe0288ee87c38b8e6ef64eeea3c021267776c88590875e1957bf815fa4f581c10cf76fd203910ee5f63e5979e8d92798db127e43059e779d4f11f8fe55253dc39b7d6e86c1bfd39bbf717c445c1e2e5a3e90f88b58e0a2fa8a35acf67deb419c376386189c77ce7e651dce05da34d1e7cd43fb192f3a4769e8da9703320e9535f35cad05fca4e1ecdefc0eeb76eb27bf7793ba2c3a5b08b827b0967e3ea958f78892e62ce79b3d2f0ff4e2c8b4e134d3d52c854f745825b1faf26f65d6ea4f6c9ede834e0fc20e12fa5e6a8454db5080f123691cc84339ffcbe9c20142e1cb79058cb019294ce9ff94ee90f6c8586eecf29038618f643f76376c22aeaef716bc152bfb5631efc5fe42ee3c75e9d193a6e426b0cf38e288fa39bd63eb035d8b8a9731ff03735d4b4af15657542f601d7af7d0dbb67e5c1c7606d273c009c2fa1ea6740caa8f1a4f5c58a73bbbc382df4b72cfda9ed42c772f8f48b286a70147915521d7db3c1ac7fde40e9a53113e26ae0fa1411867721c1dc6f78290be1ff6bd955ce922e232f948610c63856b9493cfbc93360cfc7c817f4fdfb615c7a9e5a47edf6f127f2eee06fa52517f22930110d6e28e3d14ff1636b2390797605fb2390908af6da78bb0506fa5cbc65b5b35140835a06b1c30330dec2dcc2f233f156e3c3e46fea8bceed7f761a4292303b38473ab2566da53112eac466a1653c2627ee31f2aa26867cac858dd9cd78073b81391f2ff6e95442ac323e01a41ea77aed57265277bd5c91160b950700226172133e3ec43cfb94cdee0321dde5d0769643697ed8fde121306d843c4a33f46cbaf2f58339abcbd8b37dccd3f26420a7ad012ede98aed9d12d1b9f07ca8cdbbbac95e38f26d7f2a1e017bf3a02d814f0a2f9b0eb4b837e1dceb7ec2a773094754d3b5040efc35e52c545ccd468b211874367ba4b7469d69ab3720200fd3c99866b3d3270ce7519f9265db25b7ae91e8ca6bdb29733830c8b55a85ef55de23c5f074d5e5bf907f974b311ed5db9d69dec6db3c6412fe9431227146c41241c0f6cbb5520c57bf9e67d9c7bd2dc494b2bf11629de79953fb69d069d23dd7f0ed96d2fe6b5196aea5ad8a1b25de82ecc4d8a795064f90f6e3a08f9b095ad85793172e6a88cce0d37dd344b3f767d0c8e8412d7bb4e8b9482755c2fd2e2fae89248315f3a30b0e9aff53136b31bbb0a0835a111bcd181d9e3a2485d8051f46ca8b72e5112235582a7b9c606974b0241e3996fd1f311c098501671e5ea0def69e4cc71792f1d7cad83853a0211efc8ed175544b08e3980f2cdf86c4a42e8cc06e2811891e2551754d2f10d37d4ab3e10e5a87541502558929a07b92a46ead361609b9b01eb0ef90b11fbb5558597d47e520a2a6995bd595f7c79364e9d5cca4e9cf0636dcb8c3a313feb88f11e70bb3eeb686f52913e59c1eabbac9e53e2e054ea99df51705f3570167835e62f18da5f15ccef0d0450d2a25e51e5e48f24828156ed9ff4000f98542e9702b88751ad8e4bac55c2a6997eff0d8b82a4c02f126fa3193844c59aa3505975987c26bce3f82a3d6a4a2910a1689efc3163e63b793905bea819396ddc89702603765bb1d183321db956487f09dce6c6ae2ca56bab9a8b266c1a708affc336c3b7231bbe52a0dd108aed9ab059354b5685debca3e78e6d44d0f7195ed0485f82585f63a987a4850d239534c5c86133f6d21230ba1f460950ab06a4fb439cc8f4cca66206b042c7611ec80656b2a48844f4e19d5a242b30078b84d7bd083462473bded6ee097e2afc588d119984b2b8fc272a79661cda796518100a9ad70e614e2fe4c7360c8ec42ac9a0cb11a4a45eb74e0817d901c4276610d96c3a120bf7ac9498d6363bb8f995ddbe096714324d92f3eed43910688f4d04e360fbe1893b2df025de1748ccdb28bb31c8dff2de7dae41137113821b8e8f0acb63335b4856fea15539c8cf70800d85f8379d1f1bf7bc201741383bb3d7ccc733c8f7ca78c987b01008d3d353b45dd5409e00004bc025216f4a41727e7cd969849d417a568c293d9bf4d88be10a28dffa8429fe5e7951fcd5b4451931c57261b3a13e70cb8b796e006c7f7e3bb50719c35df166a57293995593454b8e15dc650661099542fc3efa888fa78ddc898116130c1a37b42f115c2171f12d67625433758eaade52c7b874cf8eaf18d6f1e751761d98f48d004d810f7ee8a7857fb3582e4ff62807ce9670412c96000628c9545e922d1f4a5c8720a96cf7a98b9959d4ce8c6cb584d4eb96ea975e8f530899954f9d0d2847ee84f9a4a7549ce4ced8be75bc9a5c3d0c734549eb45ee509a77994ed285e3b83c5c7c5fafe8ca82af7876d19292f57443f27f3ddd9cf66af36b6758bf815fd058ec7f7a31cbe2a7d5125783e50a604671a18ffdb2148bf120ea019eebaf54c3a7d08893f884f2603d13f0e9a86bf1a971954f95bc0b95a3fdab0bbd95ecfac53bead0050d555ff01c856ad884b8b968184235055d38828bcfa8812e49c01c87154a9259771ed77969bd21bd1feed6e156886522b05dcf86ba0ccc2cf61f117b1d5ec1177873c8ca5d95792ee486fed00971f5fb154630505c5556f3a7f322b5e58dfd3b2256e6e19af06ba64539c8d7430107fb60f5dad4af46ed40cf36fc606a59c6096122570b054884cbc82a2705918fd6dc06efbabdc8ec5105d925a05ee57561e7061b58c07c389a9c56eeee47262e2e3f6c64f4e6f19ec6998b9ce35d6f985af5b3402aff336eb4457401df9e7635f71caeeda58c04c3db6d92e7deadca6b24009acb3df188bd58ab1563e97ada27be50f824bbb6f82c6dcc7d41da94e8ea8947ec9cd38caba0791fad590199a9d749e6aceb9a06b53f0799dd406f11a0340262fc986b1fd929a1133ff94ed9a19d64136eca7d89610f51f7cf7498b212973bf830671842bbe692a3087fbace8fc70ba533a6358249d9352065fab30a71ddbfe9e7281ff1bf19992fe55bf43b295db6d0495d99af11146a3ea413c618db4dbe7deb3e0298e151e51368306aa41876258e9f655d9fff4414f04f53df064eafe49bcc1f77ec6d8ee31155ba1757147822526be0aa947262649f659184006939470d9cf78151e79d2edf37a2f250820153c518aac2907ee96f1842f90e24824c1dabfb668fc72725f7430b065c08ca58e010a62ddf194945c7100c61d405448bb117bce081ce6d36b602c4708384f95a62c4d50c9170c8a4acf1366824a217afac0baad05f6c08fc3c4d34f07538df7f1727b2f8f155ea469be322cfe1b747e79cd85beb36a5f308a71a87909ad1870e45ba05d3f046fddbd098c2f1cedf292ba686d151a658447c239276233f0e645028e71e096fb35cc5740eb55d9723acba935f94c6c8632bec2ad5b2b691a455334f43aaf8ab5b482d4dfac393f22f8f96d14f1554511f2c3e74dd09092afc563bb0eedbf454be00e231e4a28a87252a0ab4968f2306b92b8982635a2f98c21197d87405c3cbaa6aa0f6bfdd4ad0e3bd0eb5f217a7d73af1639c3112d0353d057d6dca6a1cffc6996e6e47fae0e34a2f4f63032fb57a24618c92b48e189aa5425329276af0702d06fbfd6a08a36c9cc5633a734dd2c262584cee218be34317de43db2d2ab44642900ab7788510477a8e45024cddb6f24b5c7e5d2f05fab61db0449e299edd9533104e77a069dba96ee725e33bef6034e6821146b0d5ea1ac6886f3b77b9f1f778c979fb7c10a5b834d150e44e2b516a971c8d5c3235adecec76da6ae619a295d9e0215abedbc00f42a41ff9f62cf43268b3f1b6724f933d293e1584309c81803e4682e9c4254a98c6a0152a9b5a535ff53dccb6ed6fe22d8de211b49a59e88de3098ef86a5b4bb973d74ad0ef863270e6d28fe539a414e70fa060666236139e7b23f6317e5c6b017f6ec5be10ca79f316ef55482a95c8cc24c5f0cea695bde95b2518972c87bd9d747c525c25a40cb9c2ba5e1e0307b055d8a06e8ce7a29205d61fdf604500b1724ccb4b79784d3f0419caae9eb68ce1bc057b7244833b09fef5b930ddc3eb3f5ac0ba59d1820274fe23029db3e02cda6877a43d976a314a7e7accd8aee6729fc161b60e8cb46197c19348fce31c7ae637c86980e3d47fa06860d1fbcbde8f0f046857f201823c0860df12a8f49868933a8a38c890c694ccf64a6ae54cf5596cfee6db26783dd042e849ae21a16db93736109129f65cb32d1dc4d1c491ecddc5b50dd27ac5625478491045f5f3d2499876e7c695fc44adb4803358ba5c7158f45243fb820710a7a20a4dcee6e522134068fa13a4ed6281a62ac107b4e6b696f0504cb7d24719a4aeab5d8b9ed718fa67a33f7c7b1c1dc224569874a37668f65303c728c63d6a1290c857330e5941697a5a45570079631e8951766bf47343ec8a78a297d3abc94ed4f836c0b1380a6a0f4775d2470fc86f427147f7353be1772d05d3cf0317d62c0b282f2e94e2b2f7b20dc164be20d351afcc166149166e92280c1acf92c246426e68e2968899f2b9addd918ac7bfcee88a090347872be110c82eab0c1258d52159e4d2437e23b7ac104414818e79f67bde17fb509aad29058bba504f432f3e7ac5d691ce6b413049ad8b7f12d95fa62661002d4fed1ec5a7239727a75b0c64e3ddd9f86af5805f92d9c8b98be9753ade8d6d3378cf79dbf2d8def777c2496c43fc482b836ef0881cdc9e7cc4bbcaff21fc9625831128f871c3166afd8517b1634a089dc41199c04013724598efb39f2e49cdd92e5b21651af9d880cadc06ffc572235036c90e10c86661586a22e4ab6fe6edb8fa19bb84eef53ae158fd20f2545f0aedc20f1556befca41186d1d6eece8fe7dfc8c0454015d1b9efb3be9565e8631a197450a57928a6b5112026ad926ef2bed12f0a2aa8bf23aeaa47212d865e68e041cf0c1862a6a20e45770f032998b66105f089e30d716dc5856dafaa691c9e9d663cb9ce65fec28b904dbe0f8dceb52fc97bd22f17fd79baa0dcaf90fa59cfa5336a5193527610dd424c662304c6a3750196d753aa15d99b566bb3a992f1e1ea3eb97b3cd6358c96467ceccf714cff932dfad5bc2abc1b73c3babadcd9e746fc2267aaa796f70be5c008c82456da7393947231df1346103024e2a9d1c36878358aa02f1163169f8bd36f09ceb2b4d5e48ee624d9833c6aedfc2f484fd99ef7419a75e5cb72e37e50d5bab210bcb1c16b248b12c29d6507f0db8ad1280b0f92e31860ced28ed01bf8784b2c9fe1802da7692c3e8c578a0e9ddd97e77c7e2d1907f55bf03bd208e6c2ae9bb496910550e2c990104464a5049186840abb646e5b217f1f54c9d62d36cc03159bbb4af996228ecb1ea2f807576e426402ceef71d7e39990c876dcba44d35e021caa87ba178b023b304d104439386894cc37cc93680e55f7cb5c259a12d709262f1e3d08527d28d20230c7823a866d49dee8c7ad5355296e80a47bcbdd31bb727b63d9b70f45048e617abddd7c399ceada373c3ec1b6c7c60e1394bd151e37c4a747dbbb75e2d8bd030db14e9f63caa7993c8c753dc0e00e0aa312a3f261ea2b3c4999d1654c6aa03a747e6076702e46bb9d9041ad59e5ca5633c75a1391170309992768687bcbbeb35f84b6d2bc8ed0d4c6c3e5e07f9ecea754cbb4c698836d9dac985b8e27fabf8247e350f6c79b80ead85f498297c14624381bb479db21699c98dbd3a141bdd4c15b56f6fcb979ed16d6d7aaa6ce106e708303bc9221e71502f2a67119ba4299b72184375fa5307de19c4f14d0645eb75d064b3d8bd1956f0c27033727258eb703562816ef1f12f0336a11d54dfb3f7ec4047ba62f9ff72596f71a61dfe83de1713f8b496c385a1335c06a47a94f2875fa23a81bd63b320dd6babf399a46265593e66340a00ed1adcc163514cdf7b1d348b13758c423f89d2e024d23becc60226aaf1027f10ccb1ec9b32dc8c42ad80123c491cd70c1e9147760afba45a8fb02cff1a4cd449039048aed5839a8a80f89227bc49d49e96e84b905f225daa9e396a90f0da28cbda40844968aab3bc9837cb8ef4d0ab6ad2744b92cedd169d9ca10c5fa57ae0754cc9fed40811bbcae3c379f98bf035e53562f5e4517feb367a20c2a5b838ba6cbc1b6830a33b692cd24e3e3cd5a6de47b11292ee3825dd77799cb27d992a94c11fe55d545f90699c6c7df4fdcdf61205ed579dbba7806c9ebb511bab2e05d15bf5b45300887dc9fd19740956b42ea0073e201ee280fd30b1913e7c71fe20f2da916a23144cb2fbaee898042613f32cdb8171a16cc8cd16abdddad11ab8c83801448c26b526106f416f85b77bf3527bb2481b81aa714d3155ff621e4a1a1f23571b88e6e25484c640a23e81a1d82db3480b69ab827c3ed93a6c6fc9513f803680880f12c644be6ecc99e0c46f4b7aa325631ea7fe33d7cf8f15ff39beb48842ee3a4b2b39850f119128c703429e6c93a07e803bd856e8c9fbb75994cad55e4f41c341a1d4e4080468829e5e747e9be79eb744990c2bac9944adbe43752ee42bb96ff23c62748fddc232494e647c8c5fb51863777cb893b4a5bd1a7a4cec26e553cdf5ee4246917b5f9b461452b6dfa357791fe85dc00fa4c2113e8293ca2f944a2228eb6af1e1e21f44d19323dcd7612c374dcf9a3cf1719ce1119db731fc4498a0e44fd3a0d3362ec0e0bdba3465e6549d8a6fa356f0c3019bf765e264ad0c5fbd04ed6464850ecc1fc95ec47a8538e6c6cd69f51da2b6063b91a5b47c12006bfc23d7ab3c71b588df82f158b79c23f0b61ccc4dca4414bc1a88c32274d7c178684beb9c66c57e8d69412792858239e4a7c3e70cff11a905ab207ef2c87290c901604ebad7adf17a8bfb6d2679dd1dbe3e309c18b5739dd15b07e753b57a99f68d5a689aef6fd819779b402330fca5609e58ab8d930991f0846754c5dab6c8d496a312ae8724482a11c3558ba2e1f8d5dcfb02352ceee82aa420cf69e887c57de110c2cd57f88412331cbc6945e00ebd8bf88a72ed8201e772d9dd31831ca1be0340ed49492572204e2a610054c23051dbb7d5001e44d8a81e9ed87cc63e0b7849575bb0e6919ea69b6b23002f9577c11b90a6f177586d65759ab8830ccb6e8574ea9563286624e8a0e1bee13d584bdf3f0c1c97bf8b348e01659d46c7e13a78ee829c3efae87c15b1d9cd9d0f8a58e996b88ac29251b7591a06d2dec2937ab31bee2029e7a5e0056bc25f323607ed3a6d1de543e5d427aeda777fdec8d01d28772cd74963f9ae44d91a2923b604bd248e81bb6fd88efac1fda920521b2cfe592fb14439b23fe094cb5911d98b401427fa0f6ad666095d6a02531857b00c673ea69eda49e44d87271105a491e8785a47a46c3034c05f367d1222efb5c829d4e04ab0a6423acc131553c8ce64cd3a3833993b361bc25cc4857c9e73ab9ceff15c703a2eaf0e2aa43de7ca2147dae21a928fa8bcd65cf944f4c3ee03b4d1f814d7daa41ce6356edf4aaab01c5a42fdff8b48290ae46cf958ab45c277f1369451292e1aa9da5bca13a42bd787522149368d9cd99b9b4355be2d98c292f3a66b851563cf51b1cef35bdb715e21ea3e53b36f2f30ce026f27e9c9a426cd0cbff16dfccc128596dd3ae384733a01463e506ed0b656808b33c94823c42968bd3cde4c604e35c59ba45929f9cb8d6fd708a6c5e69830d952c9332b66e329da1f566a3c942020ec6b10fd0e6da26666e0c8d63b133ddb10014853690aed294de2169978fb57be16a370bf58fbb537aed45586de2db16ac1468b9eef0213442ef64154458c10b0e711697d923a5bd03474ed459d36073cf848a6baecca6bbcc2bcdfbb9fb74ea427300380c94c9d40d0779af4b47b63ca8d2ef48296eab5a0ce9ad707285996705b59c31d59d3922358854d576ba0b82bd79f14a99397ea765b881c548cc5470492e3d8db4caf8a2f2bb3257d2bb0cec500bb0e115217a8ec283d4a388a87ac70120096d76dd3c37a8be428ae5e64529b7b5bcef336b2c12cceb2e4f0bda2a502f3b4301796eabcf03c9e8cce3a972e62c29be66c77583ad58bd2b6ab1e04f2b265b100b4a46a308c459000daa70c3d9a1b6913811ed5f971b4c30f6e827ba1656a72d3e2888fb2fd99f3737825f3ff1b7e762860ff27bbfe6ae084303766693566fd3bf87110dc93269754e2a51f5e5551d06449a7358f063fa1442de9f25c4452e99f7200df98ad8897f68db4ad0fcdd3b6dd22cd3d1a59dc46b960b25a51c8199d49c16482547a5783b86340c9297d150309a0b2487dee36ad887c4031dd629b4bdbafe0d881be39f72db03db757bf1d6f33a24562e4b75fea1807d452bd7a54c2d8a61abc630203438f74eced2867e3e3123a046881199bfb2328a64c27007d0163ab479823b5c32ddef9138b0d1b79a2c904835b1737b10ba469f2f8ff9a2f7665784e8cc6a51144e54b42f70a6876b6b330bb6fc589169bbf7523b8cf95649b2bdc9098f42203801b60651f84e289a47da44e5277c8a92b47fe58b04e9e2aa1e7173fb3c487172af9b884f7683a43d5cb300155a0c8e7320443fd1e9d22f0adb553f4aed14b544ab17ea6861fe25ba3dce1a7013ecbd7d5d1fefae615b2575e0130672e924597c0a1e1f8075c790ed7765eb13b4e85218d4a80effcfc4f2e6e253b2a3b41f73bab5aa4b8a0379a9b513ea9ed977a0dae9b798c176ec3c46830e5e8b00ec07c56c2ffc6f0ceb5f51aaed8e4225ea27ec0cf1db4015735127a8af5a4a6a7827d8c752e18cead1f00da95adbb3e206a0882382d2b3bfc01cb4cac791a46650ef2494a0f28d9e439098480d5692ec03fe6ce83e0640b58a7746bffc49a8a7a06ccf9013148b0697233d0f3e4dbccf4773bea5cc9c7bbc5acdf48026808a2a2bd0cfa7570135ce438a2846d0cf23ad7210720a9f9bdb69ca5a673a75a24f97f103622791c62639f6aded10ac73597c8338f0d8a700daf46b5ee5463a91cdbd1559f6991daa931e421d8b33be8a10267632111949929c865e58c8a52cfb44135f8f503fd9d4c8535590fd82bc10eaddaa8632b97f36e5b14dc484b0211730267801586f92aabf956447e127f868dd059606868ced51b7a8a78ec1846f65c3cf040f39d5ff410664201be2d45f82f142f708913a97050c74da6bf221d72352a225c53bc45f2036ef6fbbd4f5ca769051f72d66e6ff6edc64edd7ca9e5c213ce91f5186ec7e74657c44613e8b89f4e81ef25c19b564bb27990cf660b8407884a46fa4c5770de0319328821082719d3d123b4d087369c5d171713a5762d5c28155d98af604f679ebfe7951e5dcc3abae381d0865d1f772fb7caf24127440fd9ea8d54efa3ae9f45192ed471947c32690784a5ec7f4f2b9f3f1b364682f622d035cc56edd45d8cad8f064235053649d6c83e8aea30bbffa36e80b240b32600bff9b3a6db795771a0dc2df908bb8a7e9a7a5976c1e26fcbfbfd3c88be778fee7e648e20bdaa2fbebe192e31a2c202c50f33134a03876e6210a3ee27e32ee27fce1e11fce2874f24e4b47aacc941ec7a040d2e3acc7c621f8157b9bb547666bae83d6d3f21517f621fe5bb566fe6f95c60cc55c3f66351c1e50d5d4ab12a3c52098fe3d63fa88dbe60026b51635d4acc4b8286c0329e726a68669ab6926d19069a73453a1d9b03924c18afa1b81cb01f4255e23475ade55e91d78520b76ae6df8000dc8e9b8282a4e8d6045b290b8ebddf59f3b7aaa5be37641aace0a331ddbe12c40f8b753c18188f0083a4411810071b2259a938ba13a3b3116d99d765c1c03ebf05358913a5ef86a580f513e62a0b6d11a585611febc4e25d15a882892a09945618d13cab2148e8810c3c8ae654aa285e4733ad157ef3ad09506de7bf4f2648d9daba41b644f9655de0cb1ac99f18e6c0d0d9d49cb01ecc5c613df060b83e8e7486d60b6c8445d03d373d9fc17d9ab0b3b55475d414df4cf19fdbfdbe4ed9adddd1f00ea170e3db99f81c0d527dd7579d7ad71768d87e8528a3653a8fd003b1ce8d324ae96504e5d393dedfc7557493c98f7bb31b5b8dec093b6a0d6decb19dcfce64239be91363d0b641cb88149ef698763df1b39244068e9cee678961d46b290e7d9e0149236b960170d06da1e7fff742d38fffbbfa293dc8b578b7ea1a317b6ca2996894219ecf3d33a49b72d72e4d6f68bf6ed7190d86bba314c313df11b0b2d8c14dd185936c5597bdd9fdd5bee33a074b08a764edfe9c80631157309a7df264fd1e3349263c651a9303bb0afca10f4f6fb790eeafdb26b5b53fdde5c301167223ad61a0f56d261b35e5ae0d98188d074046e29f2d4f64bc494e827dafed75b3883dc23a562bd59045ced2a047721095a788074bbd300590e3f76212a5f231861a0f745ba24d149be1dcc95bb9d3af1e54161301bd93da81fbe963989c0cdf158ed8e8b3215f306350364683adf1e4e5757c1d0051049b3cf15af237c0588657364474aa31a40139c0b5cb6c82ce3b269f6d734bc665a2daff55a06776c39d61ccb228fa97479cf81b29cbb6fa735c4f260ca16e486e8c14801a36acfbcf5b7943cc0f74b886a69f4a6628e02e2456a17bfb0a71e912ad0aa8185332b43e50b3b3ff8377f0bd302f2b0eb3e40495370fdda79a1785f6f705f2fbe7fdde1f16e9e697ea0c6d87f11688a739760f0c3dbc213901e64d7eddb27c36eadb443bff2b9216e368a03179647529599440ae8d7e3a4ecfd9dc139826b01f9d2c96172a07a8ef3a7aa525561cadd1b513fc1f732bfbd05ca376ecf2a282caf0e45709a871012821d6f011ff7d633a8ab923ee292567d2142ff9315639d03b6ef577785002c8dd928c80e2e54b2dfc1d3b819bc32feda94908c056ec672e867cbff623be6ce54448a9e9ba36e8140e88fb8c7f04d2f73482c91a22f0078500c3f4bd85ef031cf89538c2375efeb5de37355be7098bf803cf82378bfe685fc74a81af3d0babe73d48ec5eb7b35be89bd1718419ea62c1fda7a72cdc199a3ae90f15a82ab743eb9bf75690a1f47451498069741e9fd2239ea39349c17cf1527850235e3ffdcff6cfd55cfd5f348e99ca7e2d6f9203cbb88bfd1a8d48455e1d1883bde9723fb62c3e13ebbcdcb6458770b721222aadd085e2a32dd40733a04519503f0202926b035c36ac2a623b579ffd065c1a64e6d0019b07c5925b9a38c7673b3a7f5f47879ca56a0594f87eaa3e0326ebee04b3ed0db89aaa942c888824ea2d1ef0247cdc66f69758daf54970d16fa97a716e1c6df1e315bc3ad2c67a2b86fecd34ec082cd1f582daf02cf9b41b722b29f4008316448d05e26ae3056f735b16d909bf7b28f67076bfa6117d6f66d47dc918a747d066c9e6a842add6f079f59ba725f4b309d1e0a6dd696b864fd55af7f9635477b05895d1887d3d640ac43ff15c60079a864dd1b6d2f7dc0feb876d1145ae7c302dc26e0eac4e0c57e671c94e5ad144424e0113aa7153916a7fb3ddef1c7112f72587dc0ba4161b7476f28cd4ac2712c0aca520200506ac99c9d1bcb66d4c3903ed52edc72e836d50784281a1e052720bfc28cbffd6799749a492ea9ea33a53023160a40ea6b8ddf939acefccfeeb82eacd7e4fc4f1f1f6ef7576546e1913679faf8ac6a2d70d1c969f04c9d2231044e48b0640bc00dce7a4e57155f5faf32f48f0f7e46ac1dcd95391520a6df33e1cb7f04516ab776e0a51dbd50e9869a40c128cb06633756c7f50ab066387cc53c38d2abe63029b5703d2687d6c0f63794bb3ec75d4677bbfb3f99c6bed7f2ff2d044ceee3857d095820448e6c365fb612eca43d3b8283386b68a8ddc624db73a55fc4f75420a843426056403653d04ee42d7e9ce393bd090945d5da0f5210d21fabc675443870a7de812bc4b27704a65776dda7cb3cdafd76016f8e81a35914f499072a3824906801a18f6d88b3aff0589d14b01465e694babfa6f3dedd622922f55f675245b58fa9bcf0e10ebfef4c18d2db64f0ecdd6e67ba16c3eb293782adcb117a4ddd435260d97eebfd390b059bc7f0ac0f9489037cf555054a0aee318b6d83549d1f8b60c762fa37821fa4cf3eb0507f13da55b3700ceaa5b8fc52968d378d8c8681f44c627a6a5fd3a6229becc934eac2afdb795bc7c02386054463787080a378f35b34c3aa0a862566363ac71e56333508200cca02f84978ac1758e3241f8d48c70d24e52a72e5326adb68ea8ae02c7e222ac9d4a27b59b56346445c827c12fc9ee2bf3e5e9f743bb048e80dcb8348645f811c03dfcb87808c76fce63027f799268198a3f2a6c6abb1784fabf7b61c374bc22116af5d1f7ebc3619ba36d02df231c9125a1760ad5b83342e102fc2b2f1ed3dcb5ec39164c03ede3fd89c7cedfaff87e1a84caa5fbd96ecec35338f3bce4ea5952a8b62ece0b765fd5de040e63cf15ffeead0d46c3526a2779739d15c492b15467b49da17d043e0fb2e7fdcab655fe8cdce7bab073ebe4f7381dc258f5cb74d10465cd6836977d3b5b8de134f8e8783cc0027e9f5c217f2c0b0f2b7d6e7e31a66fe100947a4421ae49a4ceda34b9de5bd2dcdd62855192a3b918a2a5cbd4257336b72e7b24d885055d013ee332bc6f81443439d7313bf6c637884cf1582dbecbf2d13ec4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">此处输入正确密码，【回车】确定</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 教程 </tag>
            
            <tag> C++基础 </tag>
            
            <tag> 基础语法 </tag>
            
            <tag> 快速入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++从零开始（一）：环境搭建（上）之VSCode远程开发</title>
      <link href="/p/18652/"/>
      <url>/p/18652/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，开始更新中…</p></blockquote><div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div><p>实习的时候，公司会给每个人配置一台远程服务器，用于日常开发。体验下来感觉很不错的：</p><ul><li>所有的开发代码、环境均运行在云端，任何一台机器可直连快速开发，<strong>本地无需任何部署环境或者代码</strong>等；</li><li>实际C/C++开发大部分也是在<strong>Linux</strong>环境上完成的，拥有一台自己的（云）Linux开发机还是很有必要的（<strong>省去了Win上开发各种怪问题</strong>）。</li></ul><p>因此，在这个C++系列中，所有的代码也将以：本地（Win）+远程（Linux）形式进行开发。</p><p>好了，让我们快速开始吧。</p><h3 id="快速开始">快速开始</h3><blockquote><p>本文开发环境如下：</p><ul><li>本地：Win10 + VSCode</li><li>远程：CentOS 7 （腾讯云）</li></ul></blockquote><h4 id="云上开发">云上开发</h4><p>腾讯云/阿里云服务器都有学生优惠≈10元/月，以下是撸羊毛详细过程。</p><ol><li><p>进入学生优惠购买界面，以腾讯云为例：<a href="https://cloud.tencent.com/act/campus">腾讯云学生优惠</a></p><p>地区可选 <code>上海三区</code> &amp; <code>广州四区</code>等，广州离重庆更近一点所以选择 <code>广州四区</code> 。</p><p>选择操作系统为：<code>CentOS 7.6.64</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/qiJSVvHcUyPTGOr.png" alt="1579750584238"></p></li><li><p>付费&amp;设置密码</p><p>点击立即购买后，<strong>记得设置好相应root密码</strong>。</p><p>现在你可以右上角点击：控制台–&gt;云服务器，查看你购买的云服务器：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/s7R9KFTe1oaYIcC.png" alt="1579755304749"></p><p>你应该看到上图类似界面。红框部分是对应 <strong>内网&amp;公网IP</strong>，记录下来后面多次要用到。</p></li></ol><h4 id="本地配置">本地配置</h4><ol><li><p>配置SSH</p><p>Win10默认自带安装OpenSSH，下面我们直接进入到环境变量配置环节。</p><ul><li><p>用<a href="https://www.voidtools.com/zh-cn/">everything</a>进行搜索<code>ssh.exe</code> ，并记录OpenSSH文件夹路径：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206162135005.png" alt="image-20211206162135005"></p></li><li><p>win10搜索环境变量—&gt;编辑系统环境变量—&gt;环境变量，找到系统变量(S)—&gt;选择Path—&gt;编辑：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206162428787.png" alt="image-20211206162428787"></p></li><li><p>选择：新建–&gt;输入OpenSSH路径</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206162532446.png" alt="image-20211206162532446"></p><p>保存后退出。</p></li><li><p>测试：打开CMD，输入<code>ssh</code> ，出现如下则环境变量配置成功（被系统成功识别）：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206162726410.png" alt="image-20211206162726410"></p></li></ul></li><li><p>安装相关插件</p><ul><li><p>安装Remote-SSH：左侧Extension图标 —&gt; 输入 <code>Remote-SSH</code> —&gt;安装即可。注意，需要<strong>远程和本地都进行安装</strong>。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206163014391.png" alt="image-20211206163014391"></p></li><li><p>安装C/C++插件：同上安装不再赘述。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206163953436.png" alt="image-20211206163953436"></p></li></ul></li><li><p>配置Remote-SSH</p><p>如图所示选择<code>.ssh/config</code> 文件进行配置：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206163445062.png" alt="image-20211206163445062"></p><p>打开文件后，需要设置以下字段：</p><ul><li>Host：自定义即可</li><li>HostName：云主机公网IP</li><li>User：登陆的用户</li></ul><p>以下为示例：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206163758522.png" alt="image-20211206163758522"></p></li><li><p>登陆测试</p><p>点击下图按钮进行登陆：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206164334870.png" alt="image-20211206164334870"></p><p>输入密码后，便可以看到远程服务器已经成功连接。</p></li><li><p>hello cpp!</p><p>现在我们来编写一个简单的cpp文件，体验远程编码的快感。</p><ul><li><p>打开远程服务器文件夹</p><p>File—&gt;Open Folder—&gt;指定文件夹路径。</p></li><li><p>hello.cpp文件编写</p><p>新建文件hello.cpp–&gt;编写如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello Cpp!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g hello.cpp -o hello.out </span><br></pre></td></tr></table></figure><p>执行我们刚刚生成的可执行文件：<code>hello.out</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206165317305.png" alt="image-20211206165317305"></p></li></ul></li></ol><p>至此，顺利完成了初步的远程开发环境配置。</p><p>或许聪明的你已经想到：<strong>远程开发怎么在本地进行debug呢？</strong></p><h3 id="远程Debug">远程Debug</h3><p>VSCode中进行远程调试，通常需配置以下文件<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="vscode中c++的三个配置文件的作用：https://blog.csdn.net/zhxue_11/article/details/89457545 ">[1]</span></a></sup>：</p><ol><li><code>launch.json</code>：最重要的文件，配置<strong>调试器</strong>与<strong>需要调试的可执行文件</strong>进行调试；</li><li><code>c_cpp_properties.json</code>： c与cpp选项，实际开发主要作用是，<strong>解决系统环境的头文件找不到</strong>的情况；</li><li><code>setting.json</code> ：可以对VS Code进行页面风格、代码格式、字体颜色大小等的编辑设置，这里只用来<strong>将其它语言识别为cpp</strong>；<ul><li>更多作用可参考：<a href="https://www.zhihu.com/question/366164002">settings.json是什么?对VS Code有什么用？</a></li></ul></li><li><code>tasks.json</code>：通常用来执行<strong>比较简单的编译指令</strong>，所以一般不用，不进行过多介绍。</li></ol><p>下面正式进行相关配置介绍<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="vscode C++远程调试运行：https://zhuanlan.zhihu.com/p/104131448">[2]</span></a></sup>。</p><blockquote><p>⚠️ 以下过程执行前提：</p><ol><li>你已经根据前面步骤，成功编译生成了一个可执行文件，如：<code>hello.out</code> ；</li><li>编译生成的执行文件<strong>可以被Debug</strong>，e.g.，g++带上<code>-g</code>参数。</li></ol></blockquote><h4 id="launch-json">launch.json</h4><p>菜单栏依次选择：Debug —&gt; Add Configuration—&gt; 选择C++ (GDB/LLDB) —&gt; 选择g++ build and debug active file。</p><blockquote><p>如果以上创建过程报错：<strong>VScode找不到任务c/c++：g++.exe生成活动文件</strong> 。</p><ul><li>需要你<strong>先打开一个cpp文件</strong>，再执行上面步骤。</li></ul></blockquote><p>VSCode<strong>会根据你的机器环境</strong>，自动创建<code>launch.json</code> 。正如前所言该文件的作用，我们需进行以下配置：</p><ul><li><p><strong>配置调试器信息</strong>：创建文件时系统自动配置好了，所以不用管；</p></li><li><p><strong>配置可执行文件</strong>：也就是我们<strong>编译生成的可执行文件路径</strong></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206173236205.png" alt="image-20211206173236205"></p><p>当然我们还可以为可执行文件<strong>设置参数</strong>，格式如下：<br><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206173526162.png" alt="image-20211206173526162" style="zoom:67%;" /></p></li><li><p><strong>注释多余参数</strong>：<code>preLaunchTask</code>（调试会话开始前执行的任务），不需要。</p></li></ul><p>最终完整的配置示例文件如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;(gdb) Launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="comment">// 将要进行调试的可执行文件的路径</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/bin/hello.out&quot;</span>,   </span><br><span class="line">            <span class="comment">// 调试的可执行文件参数</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="c-cpp-properties-json">c_cpp_properties.json</h4><p>VSCode开发过程中，经常容易出现：<strong>明明路径正确引用其它头文件，但VSCode就是一直提示无法找到</strong>。所以在这个文件中，提供了<code>includePath</code>参数，让编译器顺利找到其它路径的文件。</p><p>在菜单栏中：F1—&gt;选择C/Cpp: Edit configurations，让VSCode根据实际环境自动生成c_cpp_properties.json。</p><p>以下给出示例配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Linux&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;defines&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span>: <span class="string">&quot;/usr/bin/gcc&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span>: <span class="string">&quot;c89&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span>: <span class="string">&quot;gnu++98&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;linux-gcc-x64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setting-json">setting.json</h4><p>这里只用来，将其它语言识别为CPP，不太重要。按以下配置好了就行。</p><p>在菜单栏中：F1—&gt;输入 “Open Settings”—&gt; 选择 “Preferences: Open Settings (JSON)” ，自动生成该文件。</p><p>编辑以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;files.associations&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;*.tcc&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cctype&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;clocale&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cstdarg&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cstdint&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cstdio&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cstdlib&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cwchar&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cwctype&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;exception&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;initializer_list&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;iosfwd&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;iostream&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;istream&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;limits&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;new&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;ostream&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;streambuf&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;type_traits&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;typeinfo&quot;</span>: <span class="string">&quot;cpp&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;C_Cpp.errorSquiggles&quot;</span>: <span class="string">&quot;Enabled&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试">测试</h4><p>现在让我们波澜不惊的在<code>hello.cpp</code> ，打上断点，按上<code>F5</code> 进行调试。</p><p>发现可以顺利进行远程调试，跨越了你离技术专家的一小步 😃 。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206180754574.png" alt="image-20211206180754574"></p><h3 id="体验优化">体验优化</h3><h4 id="免密登陆">免密登陆</h4><p>每次连接到远程服务器要输入密码，实在让暴躁开发的我难以忍受。现在让我们来配置免密登陆，减少服务器被我再次remake的风险。</p><ol><li><p><strong>本地</strong>生成密钥对</p><p>打开cmd —&gt; 输入 <code>ssh-keygen -t  rsa</code> 生成密钥对。</p><ul><li>在该过程会有三个系统提示，一直回车即可；</li><li>该过程会显示<strong>密钥保存路径</strong>，记录下来。</li></ul><p>打开密钥保存路径—&gt;打开<code>id_rsa.pub</code> 文件，并<strong>复制其全部内容</strong>。</p></li><li><p><strong>远程</strong>密钥配置</p><p>在VSCode打开远程服务器终端，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>按下 <code>i</code> 进入插入模式 —&gt; 粘贴刚刚复制的密钥—&gt;按下<code>:</code>，输入<code>wq!</code> 进行保存。</p></li><li><p>登陆测试</p><p>现在你可以重新登陆远程服务器，发现可以愉快的免密登陆了。</p><ul><li>如果依旧不行，建议在第一步生成密钥对时，<strong>选择覆盖之前密钥</strong>。</li></ul></li></ol><h4 id="文件同步">文件同步</h4><p>工作中经常需要<strong>同步本地和服务器之间的文件</strong>，通常有以下几种方式：</p><ol><li><code>FileZilla</code>软件同步 ；</li><li>VSCode 中<code>STFP</code>插件同步；</li><li>命令行<code>SCP</code>命令同步。</li></ol><p>在这里我们主要介绍1、2两种方式。</p><div class="tabs" id="文件同步方式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#文件同步方式-1">STFP插件</button></li><li class="tab"><button type="button" data-href="#文件同步方式-2">FileZilla</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="文件同步方式-1"><p>因为本文主要是基于VSCode开发，所以介绍一下使用VSCode相关插件进行同步<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="vscode使用sftp快速同步服务器文件：https://blog.csdn.net/qq_24798295/article/details/90228795">[3]</span></a></sup>。</p><ol><li><p>安装SFTP插件</p><p>左侧Extension图标 —&gt; 输入 <code>STFP</code> —&gt;安装即可。注意，需要<strong>远程和本地都进行安装</strong>。</p></li><li><p>工作区：准备</p><p>在<strong>本地</strong>路径下：创建新文件夹—&gt;使用VSCode打开，文件夹被自动加入到工作区中。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206154403565.png" alt="image-20211206154403565"></p></li><li><p>配置<code>sftp.json</code></p><p>在：F1—&gt; 输入SFTP —&gt;选择 SFTP: config ，进行文件配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;roy-cpp&quot;</span>, <span class="comment">// 随意</span></span><br><span class="line">    <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;119.111.111.111&quot;</span>, <span class="comment">// 你的云主机公网IP</span></span><br><span class="line">    <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;sftp&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;port&quot;</span>: <span class="number">22</span>,</span><br><span class="line">    <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>,  <span class="comment">// 登陆用户名</span></span><br><span class="line">    <span class="attr">&quot;remotePath&quot;</span>: <span class="string">&quot;/home/royhuang/syn&quot;</span>, <span class="comment">// 随意，不存在会自动创建</span></span><br><span class="line">    <span class="attr">&quot;uploadOnSave&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指定本地同步文件夹</p><p>在：F1—&gt;输入SFTP —&gt;选择SFTP: Sync Local -&gt; Remote ，将会显示本地工作区的文件夹。</p><p>选择一个文件夹，作为我们同步到远端的本地路径（输入登陆用户密码后确定）。</p><p>同步设置完成后，在VSCode底部会显示SFTP标识：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206160159444.png" alt="image-20211206160159444"></p></li><li><p>（可选）BUG解决：No Such File</p><p>这是SFTP的一个Bug，参考<a href="https://stackoverflow.com/questions/67506693/error-no-such-file-sftp-liximomo-extension">stackoverflow</a>进行解决。</p><ul><li><p>找到<code>sftp.js</code>（Win下可用<a href="https://www.voidtools.com/zh-cn/">everything</a>进行搜索），通常是在以下路径：<code>C:\Users\account_name\.vscode\extensions\liximomo.sftp-1.12.9\node_modules\ssh2-streams\lib\sftp.js</code></p></li><li><p>修改第388行，将 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( code === STATUS_CODE . OK ) &#123;</span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (code === STATUS_CODE.OK || code === STATUS_CODE.NO_SUCH_FILE) &#123;</span><br></pre></td></tr></table></figure></li><li><p>保存文件后，重启VSCode一般可解决。</p></li></ul></li><li><p>测试</p><ul><li><p>本地</p><ol><li>准备测试文件，放入之前设置的<strong>本地同步文件夹</strong>中</li><li>用VSCode打开该同步文件夹：选择测试文件–&gt;右击–&gt;选择<strong>底部Upload</strong> 上传</li></ol></li><li><p>远程服务器</p><ol><li>VSCode打开<strong>远程服务器同步文件夹</strong> ，发现文件已经被顺利上传</li><li>当然远程文件也可同步到本地：选择测试文件–&gt;右击–&gt;选择<strong>底部DownLoad</strong>下载即可。</li></ol></li></ul><p>尽情愉快玩耍吧！</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="文件同步方式-2"><blockquote><p>这里引用<a href="https://github.com/Wanghui-Huang/CQU_bigdata/blob/master/Experiment/Ex2_WordCount/ex2.md">之间写的教程</a> ，文件路径可能有点奇怪，但不影响阅读。</p></blockquote><p>该小节将介绍如何使用FTP软件将本地（Windows）文件上传到服务器(Linux)。</p><ol><li><p>下载软件</p><p>FTP工具我们选择<code>Filezilla</code> ，下载地址：<a href="https://pc.qq.com/search.html#!keyword=fielzilla">Filezilla下载</a></p><p><img src="https://i.loli.net/2020/09/17/RLvUt4bDNa69X1Y.png" alt="1579960280360"></p><p>点击进行下载安装，安装过程较为简单不再赘述。</p></li><li><p>连接服务器</p><p>依次点击：文件 --&gt; 站点管理器 --&gt;  新站点</p><p><img src="https://i.loli.net/2020/09/17/snKEbvuzyc2CXLR.png" alt="1580056871863"></p></li><li><p>上传文件</p><p>如下图所示，左侧为本地文件，右侧为服务器文件目录（默认为 <code>/home/hadoop</code>）</p><p><img src="https://i.loli.net/2020/09/17/aWGltFuJnEXmvpV.png" alt="1580057006302"></p><p>上传完毕后，可在服务器上查看文件：</p><p><img src="https://i.loli.net/2020/09/17/c12v7n9fI4h5BSi.png" alt="1580057304136"></p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="写在最后">写在最后</h3><p>看到这里，相信聪明的你已经将远程开发环境顺利搭建起来。同时，使用g++编译了个小demo，还顺手进行了一次不错的调试体验。</p><p>但在实际开发中，对于<strong>如何优雅去编译我们的项目</strong>，是个不小的问题。为此，我们还需要学习下：</p><ul><li>g++/Makefile/CMake 原理及基础命令；</li><li>项目构建逻辑及编译。</li></ul><p>在下一篇文章：<a href="https://www.hwh.zone/p/2834">环境搭建（下）g++/Makefile/CMake快速入门</a> ，和我一起学习下吧。</p><h3 id="更新记录">更新记录</h3><div class="timeline"><div class="timenode"><div class="meta"><p><p>2021-12-06 ：第一次更新</p></p></div><div class="body"><ol><li>初稿完成并发布</li></ol></div></div></div><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">vscode中c++的三个配置文件的作用：https://blog.csdn.net/zhxue_11/article/details/89457545<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">vscode C++远程调试运行：https://zhuanlan.zhihu.com/p/104131448<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">vscode使用sftp快速同步服务器文件：https://blog.csdn.net/qq_24798295/article/details/90228795<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 教程 </tag>
            
            <tag> C++基础 </tag>
            
            <tag> 远程开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门</title>
      <link href="/p/2834/"/>
      <url>/p/2834/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，开始更新中…</p></blockquote><div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div><p>作为一名C/C++程序员，g++/Makefile/CMake等相关工具是必备的基础。但之前使用中一直存在一些困惑，因此参考了一些资料<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="g++，CMake和Makefile了解一下 ： https://zhuanlan.zhihu.com/p/55027085">[1]</span></a></sup><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Linux下使用CMake编译C++：https://zhuanlan.zhihu.com/p/373256365">[2]</span></a></sup><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="阮一峰--编译器的工作过程：http://www.ruanyifeng.com/blog/2014/11/compiler.html">[3]</span></a></sup>，动笔写了这篇文章，希望可以帮助自己或大家：</p><ul><li>对编译处理过程有个基本认知；</li><li>能初步使用编译工具g++/Makefile/CMake；</li><li>能初步使用CMake编译大型项目。</li></ul><p>才疏学浅，若有错误不吝指正。</p><h3 id="g">g++</h3><p>在下文中，我们将多次利用了g++编译代码。为了方便后续学习Makefile和CMake，我们先进行简单总结。</p><p>以hello.cpp为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt;endl;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速入门">快速入门</h4><p>程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。</p><p>当然，用 gcc 来编译链接 C++ 程序是可行的，如下例所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.cpp -lstdc++ -o hello.out</span><br></pre></td></tr></table></figure><p>不过我们还是主要熟悉g++基本用法来编译C++代码。</p><ol><li><p>g++最简单的编译方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ hello.cpp</span></span><br></pre></td></tr></table></figure><p>由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></li><li><p>指定可执行程序文件名</p><p>我们使用 <strong>-o</strong> 选项指定可执行程序的文件名，以下实例生成一个 名为hello.out 的可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ hello.cpp -o hello.out</span><br></pre></td></tr></table></figure><p>执行 hello.out:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello.out</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></li><li><p>多个 C++ 代码文件</p><p>如 a.cpp、b.cpp，编译命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ a.cpp cpp、b.cpp -o test.out</span><br></pre></td></tr></table></figure><p>生成一个 test.out可执行文件。</p></li></ol><p>g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 hello.cpp 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -Wall -std=c++11 hello.cpp -o hello.out.</span><br></pre></td></tr></table></figure><h4 id="g-常用命令选项">g++ 常用命令选项</h4><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">-ansi</td><td style="text-align:center">只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td></tr><tr><td style="text-align:center">-c</td><td style="text-align:center">只编译并生成目标文件。</td></tr><tr><td style="text-align:center">-DMACRO</td><td style="text-align:center">以字符串&quot;1&quot;定义 MACRO 宏。</td></tr><tr><td style="text-align:center">-DMACRO=DEFN</td><td style="text-align:center">以字符串&quot;DEFN&quot;定义 MACRO 宏。</td></tr><tr><td style="text-align:center">-E</td><td style="text-align:center">只运行 C 预编译器。</td></tr><tr><td style="text-align:center">-g</td><td style="text-align:center">生成调试信息。GNU 调试器可利用该信息。</td></tr><tr><td style="text-align:center">-IDIRECTORY</td><td style="text-align:center">指定额外的头文件搜索路径DIRECTORY。</td></tr><tr><td style="text-align:center">-LDIRECTORY</td><td style="text-align:center">指定额外的函数库搜索路径DIRECTORY。</td></tr><tr><td style="text-align:center">-lLIBRARY</td><td style="text-align:center">连接时搜索指定的函数库LIBRARY。</td></tr><tr><td style="text-align:center">-m486</td><td style="text-align:center">针对 486 进行代码优化。</td></tr><tr><td style="text-align:center">-o</td><td style="text-align:center">FILE 生成指定的输出文件。用在生成可执行文件时。</td></tr><tr><td style="text-align:center">-O0</td><td style="text-align:center">不进行优化处理。</td></tr><tr><td style="text-align:center">-O</td><td style="text-align:center">或 -O1 优化生成代码。</td></tr><tr><td style="text-align:center">-O2</td><td style="text-align:center">进一步优化。</td></tr><tr><td style="text-align:center">-O3</td><td style="text-align:center">比 -O2 更进一步优化，包括 inline 函数。</td></tr><tr><td style="text-align:center">-shared</td><td style="text-align:center">生成共享目标文件。通常用在建立共享库时。</td></tr><tr><td style="text-align:center">-static</td><td style="text-align:center">禁止使用共享连接。</td></tr><tr><td style="text-align:center">-UMACRO</td><td style="text-align:center">取消对 MACRO 宏的定义。</td></tr><tr><td style="text-align:center">-w</td><td style="text-align:center">不生成任何警告信息。</td></tr><tr><td style="text-align:center">-Wall</td><td style="text-align:center">生成所有警告信息。</td></tr></tbody></table><h3 id="编译过程初探">编译过程初探</h3><p>现在让我们从一个简单的例子，来一步步探讨下编译过程。</p><p>准备的<code>hello.cpp</code>程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt;endl;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对它进行简单的编译&amp;输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++  hello.cpp -o hello.out  <span class="comment"># 文件名可包含指定路径</span></span><br></pre></td></tr></table></figure><p>可以看到，当前路径生成了<code>hello.out</code>文件，这是一个可执行的二进制文件。</p><p>让我们执行一下试试：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208140718480.png" alt="image-20211208140718480"></p><p>我们的代码被正确执行了。但这整个过程的细节被隐藏了，如果不了解清楚对我们以后的学习工作阻碍很大。</p><p>正式开始接触细节前，我们先大致了解下上述编译过程（四步）：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/20200423003518622.png" alt="C/C++程序编译的过程| 码农家园"></p><ol><li><code>预处理</code>：资源进行等价替换，生成<strong>预编译文件</strong>（<strong>.i</strong>文件）；</li><li><code>编译</code> ：生成<strong>汇编代码</strong>（<strong>.s</strong>文件）；</li><li><code>汇编</code> ：将汇编代码最终生成<strong>机器代码</strong>（<strong>.o</strong>文件）；</li><li><code>链接</code>：动态或静态链接外部函数/库(lib)/变量，生成<strong>可执行的二进制(hex)文件/静态库(.a)文件/动态库(.so)文件</strong>。</li></ol><p>现在让我们来逐步分析。</p><h4 id="预处理">预处理</h4><p>预处理的主要作用：通过内建功能对<strong>预处理指令进行等价文本替换</strong>。</p><p>一般地，<code>C/C++</code> 程序的源代码中包含以 <code>#</code> 开头的各种编译指令，被称为<strong>预处理指令</strong>。根据ANSI C 定义，主要包括：<strong>文件包含、宏定义、条件编译和特殊控制</strong>等4大类<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="gcc编译生成可执行文件的过程中发生了什么：https://blog.csdn.net/albertsh/article/details/89309107">[7]</span></a></sup>。</p><ul><li><p><strong>文件包含</strong>：例如常用的预处理指令 <code>#include &lt;iostream&gt;</code> ，预编译阶段会使用系统目录下<code>iostream</code>文件中的全部内容，替换 <code>#include &lt;iostream&gt;</code> 。</p><blockquote><p><code>#include &quot;xxx.h&quot;</code> ，表示使用当前目录下xxx.h文件，<code>&lt;&gt;</code> 是在系统目录下查找。</p></blockquote></li><li><p><strong>宏定义展开及处理</strong>： 预处理阶段会将定义的常量符号进行等价替换，e.g. <code>#define A 100</code> , 所有的宏定义符号A都会被替换成<code>100</code>。还会将一些内置的宏展开，比如用于显示文件全路径的<code>__FILE__</code>。</p></li><li><p><strong>条件编译处理</strong>: 如 <code>#ifdef，#ifndef，#else，#elif，#endif</code>等，这些条件编译指令的引入，使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预处理时会将那些不必要的代码过滤掉，防止文件重复包含等。</p></li><li><p>其它：特殊控制处理…</p></li></ul><p>特别的，预处理过程还会发生：</p><ul><li><strong>添加行号和文件名标识</strong>： 比如在文件<code>hello.i</code>中就有类似 <code># 2 &quot;main.c&quot; 2</code> 的内容，以便于编译时编译器产生调试用的行号信息，编译时产生编译错误或警告时能够显示行号；</li><li>清理注释内容等。</li></ul><p>在这一步，我们亲眼瞧瞧<strong>预处理的等价文本替换</strong>究竟做了什么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -E hello.cpp &gt; hello.i  <span class="comment"># 输出文件重定向到hello.i中</span></span><br></pre></td></tr></table></figure><p>可以看到：</p><ol><li><p><strong>文件包含</strong>：我们之前引入的头文件 <code>#include &lt;iostream&gt;</code> ，<strong>预处理后会将<code>#include &lt;iostream&gt;</code> 代码替换为iostream文件的内容，插入到<code>hello.i</code>中</strong>。</p><p>文件过长，以下是部分截图：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208235953948.png" alt="image-20211208235953948"></p><p>特别的，<strong>iostream文件本身也#include了头文件，同样会被替换</strong>，也就是进行大杂烩嵌套拼接。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/20200422202617233.png" alt="在这里插入图片描述" style="zoom:80%;" /></li><li><p>其它，<u>条件编译处理</u>、<u>添加行号和标识</u>等也一并可以（左图）观察到。</p></li></ol><h4 id="编译">编译</h4><p>编译过程是整个程序构建的核心部分，也是最复杂的部分之一，其工作就是把预处理完生成的 <code>.i</code> 文件进行一系列的<strong>词法分析、语法分析、语义分析以及代码优化</strong>，最终产生相应的汇编代码文件，也就是 <code>.s</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -S hello.cpp -o hello.s  <span class="comment"># 该命令包含等价替换过程</span></span><br></pre></td></tr></table></figure><p>打开当前目录下<code>hello.s</code> ，入目即是熟悉的汇编天书：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208150625682.png" alt="image-20211208150625682"></p><h4 id="汇编">汇编</h4><p>相对来说比较简单，每个汇编语句都有相对应的机器指令，只需根据汇编代码语法和机器指令的对照表翻译过来就可以了。</p><p>有了上述汇编代码后，我们便可以将其转换为机器码（<code>.o</code>文件，即object file）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c hello.cpp -o hello.o  <span class="comment"># -c 表示不进行链接</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208151441286.png" alt="image-20211208151441286"></p><p>但是在这一步还不能直接执行，会报错：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208151833947.png" alt="image-20211208151833947"></p><p>这是因为我们还<strong>没有链接其它相应的文件</strong>，因此会报错。我们来试试链接再生成可执行代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.o -o hello.out</span><br></pre></td></tr></table></figure><p>然后执行：<code>./hello.out</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208160023661.png" alt="image-20211208160023661"></p><p>假装惊喜的发现（是的就是这么戏精），文件确实已经被成功执行了。</p><p>那么，<strong>链接过程中究竟发生了什么？为什么一定要链接后才能执行</strong>？</p><h4 id="链接">链接</h4><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/807220-3b44242bee5ba363" alt="img" style="zoom:80%;" /><h5 id="链接过程究竟做了什么？">链接过程究竟做了什么？</h5><p>一言蔽之：就是<strong>进行符号解析和重定位</strong>的过程<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="符号解析：https://www.jianshu.com/p/2786533a34c9">[4]</span></a></sup>。</p><ul><li>比如我们上一步生成的可执行文件<code>hello.o</code> 执行出错，就是因为<strong>没有符号解析和重定位</strong>。</li></ul><p><strong>为什么一定要进行符号解析和重定位</strong>？</p><p>例如，在前面预处理阶段，我们将 <code>#include&lt;iostream&gt;</code> 预处理指定替换为头文件<code>iostream</code>中的内容。但实际上，<code>iostream</code>中的<code>cout</code>只是被定义，并没有实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> ostream cout;<span class="comment">/// Linked to standard output</span></span><br></pre></td></tr></table></figure><p>具体是在<code>libstdc++.so</code>中被实现的。我们必须要让编译器找到<code>libstdc++.so</code>，并将<strong>cout符号解析重定向libstdc++.so中</strong>。这样，<code>cout</code>才可以被正常执行。</p><h5 id="准备代码片段">准备代码片段</h5><p>为了更清楚的说明整个过程，我们不妨换一个例子，<strong>不使用系统库文件</strong>（预处理后的文件太复杂）。</p><ul><li><p>Main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> shared;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>*,<span class="keyword">int</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="built_in">swap</span>(&amp;a, &amp;shared);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Libtest.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> shared = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   *a ^= *b ^= *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>可以看到：Libtest.cpp<strong>不引用</strong>任何外部变量符号，但Main.cpp文件会<strong>引用</strong>Libtest.cpp中的<strong>shared变量</strong> 和 <strong>swap函数</strong>。</p><p>那么，<strong>Main.cpp中外部符号即shared和swap，怎么样才能被正确解析到Libtest.cpp中</strong>？</p><h5 id="链接前置知识">链接前置知识</h5><blockquote><p>下面有不理解的地方，建议阅读：<a href="https://www.cnblogs.com/fellow1988/p/6158240.html">ELF学习–重定位文件</a></p></blockquote><p>继续讲解前，我们还需补充几个基本概念<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="计算机原理系列之七-链接过程分析：https://luomuxiaoxiao.com/?p=572">[5]</span></a></sup>：</p><ul><li><p><strong>符号和外部符号</strong></p><ul><li>在链接中，我们将函数和变量统称为<strong>符号</strong>（<strong>Symbol</strong>）；</li><li>在本目标文件中使用，而又没有在本目标文件中定义的全局符号，称为<strong>外部符号</strong>（<strong>External Symbol</strong>）。</li></ul></li><li><p><strong>重定位表</strong></p><p>由于<strong>外部符号在编译后并不能确定其位置地址（链接重定位后才能确定</strong>）。所以需要这么一个文件：<strong>将需要重定位的外部符号进行标记</strong>。</p><p>比如，编译后<code>Main.o</code> 文件符号表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c Main.cpp -o Main.o # -c参数表示不进行链接</span><br><span class="line">objdump -r Main.o</span><br></pre></td></tr></table></figure><ul><li><p>可见，<code>shared</code>和<code>swap()</code>为外部符号被标记记录，显然，<strong>这些符号是需要被解析重定向</strong>的。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227201402682.png" alt="image-20211227201402682"></p></li></ul><p>但是<strong>Libtest.o中没有外部符号</strong>，因此其重定位表为空。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c Libtest.cpp -o Libtest.o</span><br><span class="line">objdump -r Libtest.o</span><br></pre></td></tr></table></figure><p>重定位表为空。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227215524264.png" alt="image-20211227215524264"></p></li><li><p><strong>符号表</strong></p><p>目标文件使用<strong>符号表</strong>（<strong>Symbol Table</strong>）来记录本目标文件中的<strong>全局符号</strong>的信息。</p><p>e.g. <strong>自定义的全局符号地址</strong>，这样别的文件中引用了该自定义的全局符号，就可以查找其真实地址。</p><ul><li><p><strong>Main.o符号表</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s Main.o</span><br></pre></td></tr></table></figure><ul><li><p>Main.o定义了全局符号<code>main</code>，使用到了外部符号<code>shared</code>和<code>swap</code>。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227201514728.png" alt="image-20211227201514728"></p><p><code>UND</code> 即表示未定义需要重定义。</p></li></ul></li><li><p><strong>Libtest.o的符号表</strong></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s Libtest.o</span><br></pre></td></tr></table></figure><ul><li><p>Libtest.o定义了符号<code>shared</code>和<code>swap</code>，没有使用到外部符号</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227201608874.png" alt="image-20211227201608874"></p></li></ul></li></ul><h5 id="静态链接过程">静态链接过程</h5><blockquote><p><strong>静态链接的主要目的：1）将多个目标文件合并，2）并处理各目标文件用到的外部符号（e.g. main.cpp 中的 swap和shared）</strong>，对外部符号重定位（ 调整地址到真正定义实现的地方，e.g.，<strong>Libtest.cpp</strong>），最后生成<strong>可独立运行</strong>的可执行文件。</p></blockquote><p>现在我们进行静态链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -static Main.cpp Libtest.cpp -o main.out</span><br></pre></td></tr></table></figure><p>静态链接一般采用<strong>两步链接</strong>（<strong>Two-pass Linking</strong>）的方法，下面以链接 Main.cpp 和 Libtest.cpp为例具体说明。</p><p><strong>第一步，空间与地址分配。</strong></p><p>扫描<strong>所有的编译生成的可重定向文件（Main.o和Libtest.o）并合并</strong>，同时获得其以下信息：</p><ol><li><p><strong>全局符号表</strong>：包含所有的符号定义和符号引用；</p><table><thead><tr><th style="text-align:center">符号名</th><th style="text-align:center">状态</th><th style="text-align:center">所在目标文件</th><th style="text-align:center">…</th></tr></thead><tbody><tr><td style="text-align:center">main</td><td style="text-align:center">定义</td><td style="text-align:center">Main</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">shared</td><td style="text-align:center"><strong>引用</strong></td><td style="text-align:center">Main</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">swap</td><td style="text-align:center"><strong>引用</strong></td><td style="text-align:center">Mian</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">shared</td><td style="text-align:center">定义</td><td style="text-align:center">Lib</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">swap</td><td style="text-align:center">定义</td><td style="text-align:center">Lib</td><td style="text-align:center"></td></tr></tbody></table></li><li><p><strong>段信息</strong>：各个段的长度、属性和位置。</p></li></ol><p><strong>第二步，符号解析与重定位。</strong></p><ol><li><p>查看<strong>全局符号表</strong>，发现<code>shared</code>需要重定位；</p></li><li><p>在<strong>全局符号表</strong>发现Libtest.o定义了<code>shared</code>；</p></li><li><p>查看<strong>Libtest.o的符号表</strong>以及第一步的<strong>段信息</strong>，确定<code>shared</code>的地址；</p></li><li><p>再查看<strong>Main.o的重定位表</strong>，找到所有<code>shared</code>需要重定位的地址，修改为<code>shared</code>的真实地址；</p><blockquote><p>Main.o和Libtest.o被合并，必须要查看重定位表，知道哪些是属于Main的<code>share</code>，进行重定位。</p></blockquote></li><li><p>继续查看<strong>全局符号表</strong>，发现<code>swap</code> 需要重定位，过程同上；</p></li><li><p>直至所有的<strong>符号引用都被修改为真实地址</strong>，结束。</p></li></ol><p>我们可以反编译一下最后的可执行文件，看看是否如上所示已经全部重定义完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d main.out &gt; tmp.txt</span><br></pre></td></tr></table></figure><p>例如，主函数中调用的swap函数的地址被修正为40050d。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227204728883.png" alt="image-20211227204728883"></p><p>在静态链接下，链接器通过将<strong>各个目标文件的代码段和数据段【合并拷贝】到可执行文件</strong>，因此静态链接下可执行文件当中<strong>包含了所依赖的所有代码和数据</strong>。</p><ul><li><p>在本例中，Main.o和Libtest.o被合并拷贝到可执行文件中，然后进行解析重定位。</p></li><li><p>特别的，如果还包含静态库，【<strong>静态库中需要的目标文件，e.g.，下图静态库.a中的c.o】，在链接时也会一并被拷贝合并</strong>到可执行文件中。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/807220-2e1bc10a88be493b" alt="img"></p></li></ul><p>看到这里，相信你已经明白，在静态链接中外部符号：</p><ul><li><strong>为什么要被解析重定位</strong>：外部符号能被定位到真正实现的地方；</li><li><strong>如何被解析重定位</strong>：通过符号表实现。</li></ul><p>同时，静态链接还会将需要的目标文件进行合并，因此体积比较大。</p><h5 id="动态链接过程">动态链接过程</h5><p><strong>为什么需要动态链接</strong>？</p><p>试试想想以下两种糟糕的情况：</p><ul><li><p><strong>空间浪费</strong>： 假设你是个腾讯技术专家，你写的代码Libtest.cpp性能挺好，于是开源出来<strong>生成一个静态库</strong>给其它人也用用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c Libtest.cpp -o libtest.o</span><br><span class="line">ar cqs libtest.a libtest.o</span><br></pre></td></tr></table></figure><p>github反应不错，你的大作很受欢迎，基本机器上每个程序都调用了你的库。但是<strong>由于每个程序都静态链接你的静态库libtest.a，导致每个程序都会【拷贝】Libtest.a中的代码</strong>，造成了很大的空间浪费。</p></li><li><p><strong>更新困难</strong>： 不幸的是，你不但技术精湛<s>头发稀少</s>同时精力旺盛，经常对你的大作libtest.a进行更新。这样你每更新一次，<strong>为了跟上你技术专家的步伐，所有的程序都要重新编译一次，来静态链接拷贝你的最新代码</strong>。情况严重的话，这可能收到一些礼貌的问候。</p></li></ul><p>聪明的你，自然想到号召大家使用<strong>动态链接</strong>：</p><ul><li>对那些组成程序的目标文件，比如你的libtest，不进行直接链接，而只是将<strong>必要信息写入了可执行文件，等到程序要运行时才进行链接</strong>。这样他们只用下载你大作libtest.so最新的版本，可执行文件运行时就会自动（动态）链接新版本，从而<strong>不用重新编译</strong>了。</li></ul><p>于是你开心地开始尝试下动态链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment"># 生成的动态库的名字必须是lib+名字.so</span></span><br><span class="line">g++ -shared  -o libtest.so Libtest.cpp</span><br><span class="line"><span class="comment"># 保存在/usr/lib64/下</span></span><br><span class="line">mv libtest.so  /usr/lib64/</span><br><span class="line"><span class="comment"># 动态链接你的大作libtest.so，可以直接使用-ltest来引用</span></span><br><span class="line">g++  Main.cpp  -L/usr/lib64/ -ltest -o main.out</span><br></pre></td></tr></table></figure><p>得到可执行文件<code>main.out</code>。</p><p>但是<code>main.out</code><strong>仅包含了<code>libtest.so</code> 的符号信息</strong>，并没有将 <code>libtest.so</code>相关代码 和 <code>main.out</code>合并。只有当我们执行 <code>./main.out</code> ，此时才会动态加载<code>Libtest.so</code>中需要的代码 。</p><p>从上也回答本节开头的问题：<strong>动态链接生成的可执行文件体积小，避免了空间浪费，同时灵活性强</strong>。这也就是使用动态链接的主要原因。</p><p>那么，动态链接的需要的动态库，和静态链接需要的静态库又是什么呢？</p><h5 id="静态库和动态库">静态库和动态库</h5><blockquote><p>Windows下的静态库和动态库分别为<code>.lib</code>和<code>.dll</code> 结尾的文件，本节中仅以在Linux系统中说明相关概念。</p></blockquote><p>Linux 下的库有两种<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="C/C++中关于静态链接库(.a)、动态链接库（.so）的编译与使用：https://blog.csdn.net/qq_27825451/article/details/105700361">[8]</span></a></sup>：<strong>静态库</strong>和<strong>共享库（动态库）</strong> ，都采用以下方式进行链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 【例】Main.cpp动态链接libtest.so，静态链接需加上-static参数</span></span><br><span class="line"><span class="comment"># -L：指定搜素路径，:可分隔多个路径</span></span><br><span class="line"><span class="comment"># -l：指定库名，前缀&quot;lib&quot;和后缀&quot;.a&quot; 或&quot;.so&quot;省略</span></span><br><span class="line">g++  Main.cpp  -L/usr/lib64/ -ltest -o main.out</span><br></pre></td></tr></table></figure><ul><li><p><strong>静态库</strong></p><ul><li><p><strong>特点</strong>：编译过程中已经被载入可执行程序，因此体积较大；</p></li><li><p><strong>命名</strong>：.a为后缀，lib为前缀， 例如 <code>libtest.a</code> ；</p></li><li><p><strong>生成</strong>：先生成<code>.o</code> 文件，再用<code>ar</code>工具可生成；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c Libtest.cpp -o libtest.o</span><br><span class="line">ar cqs libtest.a libtest.o</span><br></pre></td></tr></table></figure></li><li><p><strong>链接路径</strong>：</p><ol><li><strong>参数-L</strong>：ld会去找gcc/g++命令中的参数<code>-L</code>指定的路径；</li><li><strong>环境变量</strong>：gcc的环境变量<code>LIBRARY_PATH</code>，它指定程序<strong>静态</strong>链接库文件搜索路径；</li><li><strong>默认库</strong>：再找默认库目录 <code>/lib</code>、 <code>/usr/lib</code>、 <code>/usr/local/lib</code>。</li></ol></li></ul></li><li><p><strong>动态库</strong></p><ul><li><p><strong>特点</strong>：可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小；</p></li><li><p><strong>命名</strong>：.so为后缀，lib为前缀，通常还会加上版本号， 例如 <code>libtest.a.0.1</code> ;</p></li><li><p><strong>生成</strong>：<code>g++</code>工具可生成；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c Libtest.cpp -o libtest.o</span><br><span class="line">g++ -shared  libtest.o -o libtest.so.1.0</span><br></pre></td></tr></table></figure></li><li><p><strong>链接路径</strong>：</p><ol><li><strong>参数-L</strong>：ld会去找gcc/g++命令中的参数<code>-L</code>指定的路径；</li><li><strong>环境变量</strong>：gcc的环境变量<code>LD_LIBRARY_PATH</code>，它指定程序<strong>动态</strong>链接库文件搜索路径；</li><li><strong>配置文件</strong>：配置文件 <code>/etc/ld.so.conf</code> 中指定动态库路径；</li><li><strong>默认库</strong>：再找默认库目录 <code>/lib</code>、 <code>/usr/lib</code>。</li></ol></li></ul></li></ul><h3 id="g-Makefile-CMake">g++/Makefile/CMake</h3><p>在前面我们简单使用g++进行文件编译、执行。当然，主要还是偏“<strong>务虚</strong>”探讨了下编译的过程及原理。</p><p>接下来，我们将偏”<strong>务实</strong>“的介绍一下基本三大编译工具的使用 ：g++/Makefile/CMake。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/catkin.jpg" alt="ROS课程讲义--2.1 Catkin编译系统_jinking01的专栏-CSDN博客"></p><p>三者关系如上图所示。</p><ul><li><strong>gcc/g++</strong>：Linux编译器有gcc/g++，随着源文件的增加，直接用gcc/g++命令的方式<strong>效率较低</strong>，于是发明了Makefile来进行编译；</li><li><strong>Makefile</strong>： Makefile描述了整个工程的编译、链接等规则，可以<strong>有效的减少大工程中需要编译和链接的文件，只编译和链接那些需要修改的文件</strong>。然而随着工程体量的增大，Makefile也不能满足需求，于是便出现了Cmake工具；</li><li><strong>CMake</strong>：CMake是一个跨平台的编译(Build)工具，可以用简单的语句来描述所有平台的编译过程。早期的make需要程序员写Makefile文件进行编译，而现在CMake能够通过对<a href="https://www.zhihu.com/search?q=cmakelists.txt&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%2255027085%22%7D">CMakeLists.txt</a>的编辑，<strong>轻松实现对复杂工程的组织</strong>。</li></ul><p>下面我们来进行具体实操练习掌握。</p><h3 id="Makefile">Makefile</h3><h4 id="快速入门-2">快速入门</h4><p>Makefile基本格式如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure><ul><li><p><strong>target（目标）</strong> ： 目标文件, 可以是 Object File, 也可以是可执行文件；</p></li><li><p><strong>prerequisites（前置条件）</strong> ： 生成target所需要的文件或者目标；</p></li><li><p><strong>command（命令）</strong>： make需要执行的命令(任意的shell命令)，Makefile中的命令必须以 <code>[tab],即四个空格</code> 开头。</p></li></ul><p><strong>基本语法</strong></p><blockquote><p>先熟悉以下偏理论总结上的东西，实践时互相验证效果更好~</p></blockquote><p>Makefile包含了五个重要的东西：<strong>显示规则、隐晦规则、变量定义、文件指示和注释</strong>。</p><ul><li><strong>显示规则</strong>： 即<strong>需要指明target和prerequisite文件</strong>。<ul><li><u>一条规则可以包含多个target</u>，这意味着其中每个target的prerequisite都是相同的；</li><li><u>当其中的一个target被修改后</u>，整个规则中的其他target文件都会被重新编译或执行。</li></ul></li><li><strong>隐晦规则</strong>：make自动推导功能所执行的规则。</li><li><strong>变量和定义</strong>：Makefile中定义的变量，一般是字符串。</li><li><strong>文件指示</strong>：通常指以下<ol><li>Makefile中引用其他Makefile；</li><li>指定Makefile中有效部分；</li><li>定义一个多行命令。</li></ol></li><li><strong>注释</strong>：只有行注释<code>#</code> 。</li></ul><h5 id="一起试试">一起试试</h5><p>我们准了一段代码<code>DisplayImage.cpp</code>：使用c++和opencv对图片进行读取和显示。</p><p>为了方便阅读，代码已经尽量精简。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 读取</span></span><br><span class="line">    Mat image = cv.<span class="built_in">imread</span>( argv[<span class="number">1</span>], <span class="number">1</span> );</span><br><span class="line">    <span class="comment">// 显示</span></span><br><span class="line">    cv.<span class="built_in">namedWindow</span>(<span class="string">&quot;Display Image&quot;</span>, WINDOW_AUTOSIZE );</span><br><span class="line">    cv.<span class="built_in">imshow</span>(<span class="string">&quot;Display Image&quot;</span>, image);</span><br><span class="line">    cv.<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先给出已完成的Makefile文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/home/royhuang/lib/pkgconfig</span><br><span class="line"></span><br><span class="line">CXXFLAGS:=<span class="variable">$(<span class="built_in">shell</span> pkg-config --cflgs --libs opencv)</span></span><br><span class="line"></span><br><span class="line"><span class="section">DispalyImage:DispalyImage.o</span></span><br><span class="line">g++ DispalyImage.o -o DispalyImage</span><br><span class="line"><span class="section">DispalyImage.o:DispalyImage.cpp</span></span><br><span class="line">        g++ -c DispalyImage.cpp -o DispalyImage.o</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *o test</span><br></pre></td></tr></table></figure><p>现在建议我们<strong>从下往上</strong>分析：</p><ol><li><p><strong>编写clean</strong> ：删除所有的.o文件和可执行文件，避免过多的中间文件产生；</p></li><li><p><strong>编写 DispalyImage.o:DispalyImage.cpp</strong> ：根据之前的格式，<code>target  : prerequisites</code> ，这个时候 <code>target</code> 为   <strong>DispalyImage.o</strong> ，<code>prerequisites</code> 为<strong>DispalyImage.cpp</strong> 。</p><p>下一行的g++命令，将cpp文件进行编译为object file（<code>.o</code> 文件）。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">DispalyImage.o:DispalyImage.cpp</span></span><br><span class="line">        g++ -c DispalyImage.cpp -o DispalyImage.o</span><br></pre></td></tr></table></figure></li><li><p><strong>编写 DispalyImage:DispalyImage.o</strong> ：在上一步我们得到了编译后的目标文件 DispalyImage.o 。现在我们可以build生成可执行文件DispalyImage。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">DispalyImage:DispalyImage.o</span></span><br><span class="line">g++ DispalyImage.o -o DispalyImage</span><br></pre></td></tr></table></figure></li><li><p><strong>应用OpenCV库和头文件</strong> 。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/home/royhuang/lib/pkgconfig</span><br><span class="line"></span><br><span class="line">CXXFLAGS:=<span class="variable">$(<span class="built_in">shell</span> pkg-config --cflgs --libs opencv)</span></span><br></pre></td></tr></table></figure><ul><li><p><code>PKG_CONFIG_PATH</code> ：添加指定路径到环境变量。如上例，添加了路径<code>/home/royhuang/lib/pkgconfig</code>到环境变量 ，这样我们就可以直接在命令行中使用<code>pkg-config</code>命令 。</p></li><li><p><code>CXXFLAGS</code> ：指定文件（.h文件或lib文件）的路径，使得编译时可以找到相应头文件和库文件。</p><p>在本例中，<code>pkg-config</code>命令可查看opencv的include头文件的路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --libs 参数可查看库文件</span></span><br><span class="line">shell pkg-config --cflgs  opencv</span><br></pre></td></tr></table></figure><p>同时引入头文件和库文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config opencv --cflgs --libs opencv</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>有了<code>makefile</code>文件后，我们就可以make生成可执行文件<code>DisplayImage</code>了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动查找当前目录下叫“Makefile”或“makefile”的文件</span></span><br><span class="line">make </span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">./DisplayImage ../01.jpg</span><br></pre></td></tr></table></figure><p>从上也可总结出：<strong>Makefile 包含了所有的规则和目标，而 make 则是为了完成目标而去解释 Makefile 规则的工具</strong>。</p><p>总的来说，Makefile的基本套路就是以上，熟练使用需要实际项目多练习下。</p><h4 id="进阶学习">进阶学习</h4><p>这里准备举一些较复杂的项目，怎么来编写Makefile文件。</p><p>但是一般较复杂的项目我现在一般用<strong>CMake</strong>，也是后文需要介绍的。因此这里复杂项目Makefile编写案例，暂时留白，后续补上。</p><p>当然，你可以先看看：<a href="https://www.ruanyifeng.com/blog/2015/02/make.html">Make 命令教程 - 阮一峰</a> 。</p><h3 id="CMake">CMake</h3><p>早期的make需要程序员写Makefile文件，进行编译。而现在CMake能够通过对<code>CmakeLists.txt</code>的编辑，轻松实现对复杂工程的组织。</p><h4 id="快速入门-3">快速入门</h4><p>首先，我们在Linux系统（CentOS）下安装下CMake：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install cmake</span><br></pre></td></tr></table></figure><p>一般使用CMake生成Makefile并编译的流程如下：</p><ol><li>编写<code>CMakeLists.txt</code>，假定其路径为<code>PATH</code>；</li><li>执行命令<code>cmake PATH</code>生成Makefile；</li><li>最后使用<code>make</code>进行编译。</li></ol><h5 id="一起试试-2">一起试试</h5><p>我们准备一个<code>hello.cpp</code> 文件，它所在的目录如下所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- build  <span class="comment"># cmake生成的中间文件都放这</span></span><br><span class="line">|-- hello.cpp</span><br><span class="line">|-- CMakeLists.txt <span class="comment"># 每个子目录下都要有CMakeLists.txt文件</span></span><br></pre></td></tr></table></figure><p>文件内容很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hello.cpp */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello Cpp!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们编写的<code>CMakeLists.txt</code>，每一行代码解释如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式：&lt;命令名&gt;(参数 参数值) ，中间参数空格隔开</span></span><br><span class="line"><span class="comment"># 设置项目名</span></span><br><span class="line"><span class="keyword">project</span>(helloDemo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限定CMAKE最低版本</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">2.6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索当前目录所有源代码文件，并赋值给PROJECT_ROOT_SRCS</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. PROJECT_ROOT_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加C++11特性</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-std=c++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_executable 从一组源文件编译出一个可执行文件 </span></span><br><span class="line"><span class="comment"># 这里将$&#123;PROJECT_ROOT_SRCS&#125;中文件编译，生成可执行文件hello.out</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello.out <span class="variable">$&#123;PROJECT_ROOT_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure><p>开始编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成makefile等中间文件</span></span><br><span class="line"><span class="comment"># 生成的可执行文件 【如果要可以被调试】，还要带上参数：cmake -DCMAKE_BUILD_TYPE:STRING=Debug</span></span><br><span class="line"><span class="built_in">cd</span> ./build  &amp;&amp; cmake ..</span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>最后执行刚刚生成的可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello.out</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211209221810181.png" alt="image-20211209221810181"></p><p>看到这里，相信你对CMake有了个基本的认知。在前面我们也知道，CMake通常是用来编译大型项目的。</p><p>那么，<strong>大型项目结构是什么样的？又如何进行编译呢</strong>？</p><h4 id="大型项目结构">大型项目结构</h4><blockquote><p>主要参考：<a href="https://github.com/hattonl/cpp-project-structure">cpp-project-structure</a>。</p></blockquote><p>这里假定项目名为 <code>my_poject</code> ，一个完整的大项目结构通常如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">my_poject  </span><br><span class="line">├── deploy <span class="comment"># 存放部署、交付的文件 </span></span><br><span class="line">│   └── bin      <span class="comment"># 项目生成的可执行文件</span></span><br><span class="line">│   └── lib      <span class="comment"># 项目生成的库文件</span></span><br><span class="line">│   └── include  <span class="comment"># 项目对外提供的头文件</span></span><br><span class="line">├── build  <span class="comment"># 存放cmake产生的中间文件</span></span><br><span class="line">│   └── release</span><br><span class="line">│   └── debug  </span><br><span class="line">├── doc      <span class="comment"># 存放项目文档</span></span><br><span class="line">├── src      <span class="comment"># 存放资源文件</span></span><br><span class="line">│   └── pic            </span><br><span class="line">├── 3rdparty <span class="comment"># 存放第三方库</span></span><br><span class="line">│   └── lib       <span class="comment"># 库文件  </span></span><br><span class="line">│   └── include   <span class="comment"># 头文件</span></span><br><span class="line">├── my_poject <span class="comment"># 项目【代码源文件】</span></span><br><span class="line">|   └── module_1</span><br><span class="line">│        ├── 1.cpp</span><br><span class="line">│        ├── 1.h</span><br><span class="line">│        ├── CMakeLists.txt</span><br><span class="line">|   └── module_2</span><br><span class="line">│        ├── 2.cpp</span><br><span class="line">│        ├── 2.h</span><br><span class="line">│        ├── CMakeLists.txt</span><br><span class="line">├── tools     <span class="comment"># 项目构建支持工具，如编译器</span></span><br><span class="line">├── scripts   <span class="comment"># 脚本文件，如预处理脚本</span></span><br><span class="line">├── config    <span class="comment"># 配置文件</span></span><br><span class="line">│   └── xxx.yml       </span><br><span class="line">│   └── yyy.yml   </span><br><span class="line">├── <span class="built_in">test</span>      <span class="comment"># 测试代码</span></span><br><span class="line">├── LICENSE   <span class="comment"># 版权信息</span></span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── build.sh  <span class="comment"># 构建项目的脚本</span></span><br><span class="line">├── .gitignore</span><br><span class="line">├── README.md <span class="comment"># 项目说明文件</span></span><br><span class="line">└── sample    <span class="comment"># 示例代码</span></span><br></pre></td></tr></table></figure><h4 id="编译复杂项目">编译复杂项目</h4><p>现在我们举一个复杂点的，<strong>多层级项目</strong>如何用CMake进行编译。</p><p>整个目录结构如下（为方便，进行了精简）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">|-- 3rdparty </span><br><span class="line">|   |-- include</span><br><span class="line">|   `-- lib</span><br><span class="line">|-- deploy </span><br><span class="line">|   |-- bin</span><br><span class="line">|   `-- lib</span><br><span class="line">|-- build</span><br><span class="line">|-- hello  <span class="comment"># 整个项目源码</span></span><br><span class="line">|   |-- module1</span><br><span class="line">|   |   |-- people.cpp</span><br><span class="line">|   |   |-- people.h</span><br><span class="line">|   |   `-- CMakeLists.txt</span><br><span class="line">|   |-- module2</span><br><span class="line">|   |   |-- bird.cpp</span><br><span class="line">|   |   |-- bird.h</span><br><span class="line">|   |   `-- CMakeLists.txt</span><br><span class="line">|   |-- hello.cpp</span><br><span class="line">|   |-- CMakeLists.txt</span><br><span class="line">|-- LICENSE</span><br><span class="line">|-- README.md</span><br><span class="line">|-- src</span><br><span class="line">|   `-- video</span><br><span class="line">|       `-- 1577414323962.mp4</span><br></pre></td></tr></table></figure><p>其中<code>hello</code>目录下各源文件如下：</p><ul><li><p><code>moule1/people</code> 相关源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*people.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;people.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">people_hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;people say : Hello Cpp!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*people.h*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">people_hello</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><code>moule2/bird</code> 相关源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*bird.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bird.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bird_hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;bird say : Hello Cpp!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*bird.h*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bird_hello</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><code>hello/hello.cpp</code> 源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;./module1/people.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;./module2/bird.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">people_hello</span>();</span><br><span class="line">    <span class="built_in">bird_hello</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最后给出各个目录下的CMakeLists.txt文件。</p><div class="tabs" id="tags"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tags-1">module1</button></li><li class="tab"><button type="button" data-href="#tags-2">module2</button></li><li class="tab"><button type="button" data-href="#tags-3">hello</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tags-1"><ul><li><p><strong>module1</strong></p><p>编译生成动态库<code>libmodule1.so</code> 。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录（module1）下的相关文件,并赋值给MODULE1_SRC</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. MODULE1_SRC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的源文件（MODULE1_SRC）生成库文件libmodule1.so</span></span><br><span class="line"><span class="comment"># 【注1】不需要写全libmodule1.so，只需写module即可，cmake会自动补全。</span></span><br><span class="line"><span class="comment"># 【注2】SHARED参数指定生成动态库（.so文件），不加参数默认生成静态库（.a）文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(module1 SHARED <span class="variable">$&#123;MODULE1_SRC&#125;</span>)</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tags-2"><ul><li><p><strong>module2</strong></p><p>编译生成动态库<code>libmodule2.so</code> ，基本同前。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录（module2）下的相关文件,并赋值给MODULE2_SRC</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. MODULE2_SRC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的源文件（MODULE1_SRC）生成库文件libmodule1.so</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(module2 SHARED <span class="variable">$&#123;MODULE2_SRC&#125;</span>)</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tags-3"><ul><li><p><strong>hello</strong></p><p>编译生成可执行文件<code>hello.out</code> ，然后链接<code>libmodule1.so</code>和 <code>libmodule2.so</code>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式：&lt;命令名&gt;(参数 参数值) ，中间参数空格隔开</span></span><br><span class="line"><span class="comment"># 设置项目名</span></span><br><span class="line"><span class="keyword">project</span>(helloDemo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置可执行文件保存路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/../deploy/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限定CMAKE最低版本</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">2.6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将module1和module2文件夹加入子目录,这样cmake就可以去其中查找编译</span></span><br><span class="line"><span class="comment"># 【注1】没有这个会报错，ld:找不到 -lmoudle1 和 -lmoudle2</span></span><br><span class="line"><span class="comment"># 【注2】这里只能用相对路径，不是hello项目下的路径，是指</span></span><br><span class="line"><span class="comment">#       build下的相对路径。</span></span><br><span class="line"><span class="comment">#       因为最后make是在build路径下，libmoudule1.so和</span></span><br><span class="line"><span class="comment">#       libmoudule2.so是分别保存在build/moudle1 和build/module2下</span></span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(./module1) </span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(./module2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索当前目录所有源代码文件，并赋值给PROJECT_ROOT_SRCS</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. PROJECT_ROOT_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加C++11特性</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-std=c++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【编译】</span></span><br><span class="line"><span class="comment"># add_executable 从一组源文件编译出一个可执行文件 </span></span><br><span class="line"><span class="comment"># 这里将$&#123;PROJECT_ROOT_SRCS&#125;中文件编译，生成可执行文件hello.out</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello.out <span class="variable">$&#123;PROJECT_ROOT_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【链接】</span></span><br><span class="line"><span class="comment"># 将目标文件与库文件进行链接，不显示指示文件后缀（如 module1.so），优先链接动态库</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(</span><br><span class="line">    hello.out </span><br><span class="line">    module2 </span><br><span class="line">    module1</span><br><span class="line">) </span><br></pre></td></tr></table></figure><p>特别的，如果你还引用了第三方库，还应该做如下修改。</p><blockquote><p>假设你引用的第三方库为<code>ffmpeg</code> ，相关头文件和库文件都放在<code>3rdparty</code>目录下。</p></blockquote><ul><li><p>增加ffmpeg库文件和头文件搜索路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 头文件搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>../<span class="number">3</span>rdparty/inclue)</span><br><span class="line"><span class="comment"># 库文件搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>../<span class="number">3</span>rdparty/lib)</span><br></pre></td></tr></table></figure></li><li><p>链接ffmepeg相应库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 链接ffmpeg库</span></span><br><span class="line"><span class="comment"># 将目标文件与库文件进行链接</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(</span><br><span class="line">    hello.out </span><br><span class="line">    module2 </span><br><span class="line">    module1</span><br><span class="line">    libavcodec.so   <span class="comment"># 显示指定动态库</span></span><br><span class="line">    libavdevice.so  </span><br><span class="line">    libavfilter.so</span><br><span class="line">    libavformat.so</span><br><span class="line">    libavutil.so</span><br><span class="line">    libpostproc.so</span><br><span class="line">    libswresample.so</span><br><span class="line">    libswscale.so</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>准备好所有的文件后，我们开始进行cmake构建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./build</span><br><span class="line">cmake ../hello &amp;&amp; make</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211210122630662.png" alt="image-20211210122630662"></p><p>在<code>bin</code> 下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../deploy/bin/hello.out </span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211210122942175.png" alt="image-20211210122942175"></p><p>👨‍💻 CMake相关介绍到此完结。</p><h3 id="写在最后">写在最后</h3><p>这篇博客主要介绍了编译的基本过程和原理，以及常用的编译工具（g++/Makefile/CMake）使用。</p><p>从构思大纲到最后初步完工大概用了五天，比最初预估的进度多花了一倍时间。最主要的原因就是中间我一直在删删改改，特别是写<u>编译过程初探</u>这一节：<strong>每写完一个版本，我就自己先看一遍再问自己：你真的能看明白吗</strong>？还是有些不理解的地方，就继续Google些资料看，直到把自己说服----至少文章逻辑上自恰了。同时也更深刻地体会到了：<strong>自己觉得懂了可能不是真的懂了，能把别人讲明白才可能算是懂了</strong>。</p><p>C++环境相关介绍就先告一段落了，接下来准备整理一下<strong>C++基础相关知识</strong>（有事情做的感觉还不错😀 ），回复完论文评审意见后尽快开始更新。</p><h3 id="更新记录">更新记录</h3><div class="timeline"><div class="timenode"><div class="meta"><p><p>2021-12-20 ：更新笔记</p></p></div><div class="body"><ol><li>增加g++相关介绍</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-12-10 ：上传初稿</p></p></div><div class="body"><ol><li>第一次更新，发布初稿</li></ol></div></div></div><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">g++，CMake和Makefile了解一下 ： https://zhuanlan.zhihu.com/p/55027085<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Linux下使用CMake编译C++：https://zhuanlan.zhihu.com/p/373256365<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">阮一峰--编译器的工作过程：http://www.ruanyifeng.com/blog/2014/11/compiler.html<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">符号解析：https://www.jianshu.com/p/2786533a34c9<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">计算机原理系列之七-链接过程分析：https://luomuxiaoxiao.com/?p=572<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">静态链接与动态链接在链接过程和文件结构上的区别：https://www.polarxiong.com/<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">gcc编译生成可执行文件的过程中发生了什么：https://blog.csdn.net/albertsh/article/details/89309107<a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C/C++中关于静态链接库(.a)、动态链接库（.so）的编译与使用：https://blog.csdn.net/qq_27825451/article/details/105700361<a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">cpp_new_features：https://github.com/0voice/cpp_new_features/blob/main/<a href="#fnref:9" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 教程 </tag>
            
            <tag> C++基础 </tag>
            
            <tag> CMake </tag>
            
            <tag> Makefile </tag>
            
            <tag> g++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++从零开始（零）</title>
      <link href="/p/62712/"/>
      <url>/p/62712/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🖋 《C++从零开始》系列，持续更新中…</p></blockquote><p>这个系列虽然名为：《C++从零开始》，但细细算来，我已经不止系统性地学过C++一次了。说来惭愧，每次目的也都是为了对付考试，取个不错的成绩而下点苦工罢了。</p><p>阴差阳错，<a href="https://hwh.zone/p/29708/">我明年即将入职腾讯，并以C++开始自己职业生涯的第一站</a>，正好在校还有段较清闲的时光，于是下笔写了这个C++系列笔记。<strong>一是分享记录</strong>，希望能对同样学习C++的读者有点帮助；<strong>二是好记性不如烂笔头</strong>，能帮助自己时时记忆和温习。</p><p>动笔前，我仔细构思了下该系列笔记的整体结构，下节会开始介绍具体介绍。</p><ul><li>特别的，这个系列处于初建状态，文章可能会由于更新等原因和之前版本有所不同；</li><li>所有的文章更新记录变化，可以在第三大节：<strong>更新记录</strong>中查看。</li></ul><h3 id="总目录">总目录</h3><blockquote><p>⏰ 最后更新时间：<code>2021/12/05 18:00</code> 。</p></blockquote><p>系列总结构暂分为：C++基础<sup id="fnref:0"><a href="#fn:0" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="C++教程从0到1入门编程：https://www.bilibili.com/video/BV1et411b73Z">[0]</span></a></sup><sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="腾讯云C++教程：https://cloud.tencent.com/edu/learning/course-1844-21296">[5]</span></a></sup>、C++进阶<sup id="fnref:0"><a href="#fn:0" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="C++教程从0到1入门编程：https://www.bilibili.com/video/BV1et411b73Z">[0]</span></a></sup><sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="腾讯云C++教程：https://cloud.tencent.com/edu/learning/course-1844-21296">[5]</span></a></sup>、C++面经<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="阿秀的求职笔记：https://interviewguide.cn/">[1]</span></a></sup>、C++开源<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="zavar开源地址: https://github.com/zyearn/zaver">[2]</span></a></sup><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="ffmpeg-trancode开源地址: https://github.com/leichn/exercises/tree/master/source/ffmpeg/ffmpeg_transcode">[3]</span></a></sup><sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="SRS开源地址：https://github.com/ossrs/srs">[4]</span></a></sup>，四大板块。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><strong>文章</strong></th><th style="text-align:center"><strong>备注</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>C++基础</strong></td><td style="text-align:center"><a href="https://hwh.zone/p/18652/">C++从零开始（一）：环境搭建（上）之VSCode远程开发</a></td><td style="text-align:center">✔️更新完成</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://www.hwh.zone/p/2834">C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门</a></td><td style="text-align:center">✔️更新完成</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（二）：基础语法（上）之快速入门</a></td><td style="text-align:center">🔨 更新ing</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（二）：基础语法（中）之面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（二）：基础语法（下）之模板</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>C++进阶</strong></td><td style="text-align:center"><a href="">C++从零开始（三）：STL（上）之快速入门</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（三）：STL（中）之容器</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（三）：STL（下）之实战</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（四）：C++新特性之C++11</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>C++面经</strong></td><td style="text-align:center"><a href="">C++从零开始（五）：C++面经之基础语法</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（六）：C++面经之内存管理</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（七）：C++面经之C++11</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（八）：C++面经之STL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（九）：C++面经之其它补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>C++开源</strong></td><td style="text-align:center"><a href="">C++从零开始（十）：C++开源之Zaver源码分析</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（十一）：C++开源之实现自己的ffmpeg转码器</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="">C++从零开始（十二）：C++开源之SRS源码分析</a></td><td style="text-align:center"></td></tr></tbody></table><h3 id="写在最后">写在最后</h3><blockquote><p>⏲ 更新时间：<code>2021/12/05 17:00</code> 。</p></blockquote><p>从玩到无聊开始学习到十二月初给自己挖了个大坑，<code>play hard study hard</code> 居然不知不觉成了我的行为习惯。当然，玩到胖了十多斤并不是我本意…</p><p>借此机会，提前许下几个新年愿望（是的，就是这么突然）：</p><ul><li>三个月内顺利更新完这个系列大部分文档；</li><li>多花点时间学习，不能过分玩乐；</li><li>少熬夜，多喝茶；</li><li>如意考试顺利。</li></ul><p>敬请期待~ 😋 （顺便分享一下<s>我的新插件</s>一首应景的小诗）</p><div class='poem'><div class='poem-title'>[飞鸟集]</div><div class='poem-author'>[泰戈尔]</div><p>闲暇在动作时</p><p>便是工作。<br>静止的海水荡动时</p><p>便成波涛。</p></div><h3 id="更新记录">更新记录</h3><div class="timeline"><div class="timenode"><div class="meta"><p><p>2021-12-10 ：文章更新</p></p></div><div class="body"><ol><li><a href="https://www.hwh.zone/p/2834">C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门</a>更新完毕</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-12-06 ：文章更新</p></p></div><div class="body"><ol><li><a href="https://hwh.zone/p/18652/">C++从零开始（一）：环境搭建（上）之VSCode远程开发</a> 更新完毕</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-12-05 ：第一次更新</p></p></div><div class="body"><ol><li>初步确定《C++从零开始系列》大纲</li><li>即将更新：<code>C++基础系列</code></li></ol></div></div></div><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:0"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">0.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++教程从0到1入门编程：https://www.bilibili.com/video/BV1et411b73Z<a href="#fnref:0" rev="footnote"> ↩</a></span></li><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">阿秀的求职笔记：https://interviewguide.cn/<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">zavar开源地址: https://github.com/zyearn/zaver<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">ffmpeg-trancode开源地址: https://github.com/leichn/exercises/tree/master/source/ffmpeg/ffmpeg_transcode<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">SRS开源地址：https://github.com/ossrs/srs<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">腾讯云C++教程：https://cloud.tencent.com/edu/learning/course-1844-21296<a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 从零开始 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github Pages快速打造属于自己的网站</title>
      <link href="/p/56326/"/>
      <url>/p/56326/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>⚠️ 阅读本文前，默认你具有：</p><ol><li>git操作基本知识</li><li>Linux操作基本知识</li><li>网络相关基本知识</li></ol><p>如果操作遇到困难，可在文章下方进行留言😃。</p></blockquote><h3 id="前言">前言</h3><blockquote><p>迫不及待？建站效果实时预览：<a href="https://hwh.zone/">royhuang‘s blog</a> 。</p></blockquote><div class="tag link"><a class="link-card" title="royhuang's blog" href="https://www.hwh.zone"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">royhuang's blog</p><p class="url">https://www.hwh.zone</p></div></a></div><p>第一次建站时还是三年前用<strong>WordPress</strong>搭建，网站放在腾讯云VPS上运行。因为机器配置较低比较卡，有次暴躁debug把整个服务器remake了，不了了之。再后面又因为对<strong>Java Web开发</strong>比较感兴趣，折腾了SpringBoot Web开发和前后端相关知识，打算自己<strong>完全前后端自主开发</strong>一个博客。因为主客观各种原因，做了一个残次品，阴差阳错最后要以C++开始自己职业生涯第一站，也没有最终完善。</p><p>趁着这段时间，使用<strong>Hexo+Github Pages</strong> 作为最终建站方案折腾了几天，总体来说效果还比较满意。为了后来人少踩点坑，同时为自己糟糕的记忆留点回忆，特此记录。</p><h3 id="主流建站方式比较">主流建站方式比较</h3><p>在正式开始前，我们不妨先来分析下主流建站方式，做到心中有数。自然，此节也可以略过。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">建站难度</th><th style="text-align:center">所需知识</th><th style="text-align:center">定制化程度</th><th style="text-align:center">适合人群</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>WordPress</strong></td><td style="text-align:center">⭐️⭐️</td><td style="text-align:center">Linux、Git基本知识</td><td style="text-align:center">一般</td><td style="text-align:center">Web开发小白人群</td><td style="text-align:center">之前写的教程：<a href="https://blog.csdn.net/hwh1996/article/details/90666775">教练,我想建网站！</a></td></tr><tr><td style="text-align:center"><strong>Java Web</strong></td><td style="text-align:center">⭐️⭐️⭐️⭐️</td><td style="text-align:center">Web前后端开发知识，多且杂</td><td style="text-align:center">非常高，前后端代码全栈开发</td><td style="text-align:center">Java Web开发人员</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>Hexo + Github Pages</strong></td><td style="text-align:center">⭐️⭐️</td><td style="text-align:center">Linux、Git基本知识</td><td style="text-align:center">较高，基于配置文件修改较方便</td><td style="text-align:center">Web开发小白人群</td><td style="text-align:center"><strong>不需要备案域名</strong></td></tr><tr><td style="text-align:center"><strong>Hexo + 腾讯云</strong></td><td style="text-align:center">⭐️⭐️</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td><td style="text-align:center"><strong>域名需要备案</strong>，但网站访问速度会变快很多</td></tr></tbody></table><p>根据以上，我们可以根据不同情况进行选择：</p><ul><li><p><strong>Java Web全栈搭建</strong>？</p><ul><li>适合Java Web为技术栈的<strong>专业人员</strong>，可以作为个小项目；</li><li>但如果你<strong>并非专业</strong>的Java Web开发人员，不想学习复杂的Java Web体系，但是又具备开发基础知识，想搭建一个漂亮的博客：<strong>WordPress 和 Hexo是你不二的选择</strong>。</li></ul></li><li><p><strong>WordPress还是Hexo</strong><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="从wordpress到hexo：https://www.wenjinyu.me/zh/from-wordpress-to-hexo-my-blog-should-have-been-like-this/">[3]</span></a></sup>  ？</p><p>作为都体验过的人，我说说一下自己比较主观的对比：</p><ul><li>WordPress优点：很简单，适合特别小白的同学；</li><li>WordPress缺点：占用资源多，<strong>响应慢</strong>；<strong>不支持原生markdown</strong>（每次要导出.html太痛苦了）；主题也不够合心意（不美观）。</li></ul><p>所以我自己（有开发基础）还是推荐使用Hexo。</p></li><li><p><strong>Hexo + Github Pages 还是 Hexo + 腾讯云</strong>?</p><ul><li><strong>Github Pages 托管网站</strong>：因为服务器在国外（Github），域名无需备案，但访问速度会比较慢，也无需购买云服务器；</li><li><strong>腾讯云托管网站</strong>：需要购买云服务器（或COS），且域名需要备案，但访问速度会很快。</li></ul></li></ul><p>因为本文考虑<strong>更低成本，我也比较懒不想备案，访问速度虽然慢点但还能接受</strong>，所以采用Hexo + Github Pages作为最终的建站方案。</p><p>好了，现在让我们开始激动人心的环节吧，动手搭建自己的网络快乐小窝。</p><h3 id="Hexo-Github-Pages">Hexo + Github Pages</h3><p>Hexo是一款基于Node.js的静态博客框架，<strong>依赖少易于安装使用</strong>，可以方便的生成静态网页<strong>托管在GitHub Pages上</strong>（<u>无需云服务器</u>），是搭建博客的首选框架<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Hexo 知乎教程：https://zhuanlan.zhihu.com/p/26625249">[2]</span></a></sup>。</p><p>用大白话来说就是：</p><ul><li>Hexo：用来将我们写的文章，渲染<strong>生成本地生成静态网页</strong> ，但只有你自己能看到；</li><li>Github Pages : 将Hexo生成的静态网页，<strong>部署托管到云服务器（Github Pages，VPS，COS均可）上</strong>，这样别人也可以访问。</li></ul><h4 id="快速开始">快速开始</h4><blockquote><p>以下主要操作均已在虚拟机中经过二次验证。</p></blockquote><h5 id="准备工作：Github-Git">准备工作：Github &amp; Git</h5><ol><li><p>创建Github个人仓库</p><p>⚠️ 注意命令方式必须为：<code>你的Github用户名.github.io</code> ，这种形式。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202204544684.png" alt="image-20211202204544684"></p><ul><li><p><strong>登陆用户名和昵称分不清</strong>?你的个人主页，下面红框所示才是你的用户名。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211209194854716.png" alt="image-20211209194854716"></p></li><li><p>我已创建过该项目，故显示重复</p></li></ul></li><li><p>安装Git</p><p><a href="https://git-scm.com/downloads">Git下载地址</a> , 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，则Git安装成功。</p><p>同时还需配置基本Github相关信息，主要是用户名和邮箱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Wanghui-Huang&quot;</span>    </span><br><span class="line">$ git config --global user.email <span class="string">&quot;380141202@qq.com&quot;</span></span><br></pre></td></tr></table></figure><p>本文默认你具备基本Git相关知识，故不再赘述，如果不具备可以学习：<a href="https://hwh.zone/p/43848/">Git基础笔记</a> 。</p></li><li><p>安装Node.js</p><blockquote><p>Hexo基于Node.js，自然需要安装相关组件。</p></blockquote><p>下载 <a href="https://nodejs.org/en/download/">Node.js </a>  , 一直默认安装即可（不要随意勾选）。</p><p>安装成功后，分别输入 <code>node -v</code> &amp; <code>npm -v</code>，出现以下版本信息则安装成功：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202211811979.png" alt="image-20211202211811979"></p></li></ol><h5 id="搭建Hexo">搭建Hexo</h5><ol><li><p>新建文件夹</p><p>我们在合适的路径新建一个文件夹，命名随意，我命名为：<code>www.hwh.zone</code>。</p></li><li><p>安装Hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br></pre></td></tr></table></figure></li><li><p>初始化博客</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./www.hwh.zone/</span><br><span class="line">hexo init blog</span><br></pre></td></tr></table></figure></li><li><p>本地测试验证</p><blockquote><p>⚠️ 注意以下命令全部都在：<code>./www.hwh.zone/blog</code> 路径下执行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./blog/</span><br><span class="line">hexo new test_my_site  <span class="comment"># 生成一篇新文章</span></span><br><span class="line">hexo g  <span class="comment"># 生成静态文件（网页）</span></span><br><span class="line">hexo s  <span class="comment"># 本地生成静态网站预览</span></span><br></pre></td></tr></table></figure><p>执行完毕后，输入：<a href="http://localhost:4000">http://localhost:4000</a> ，出现以下页面则生成成功：</p><blockquote><p>如果<code>hexo s</code> 执行成功，浏览器却打不开，通常是端口（4000）被占用。可以设置hexo使用别的端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server -p 4001</span><br></pre></td></tr></table></figure><p>然后输入：<a href="http://localhost:4001">http://localhost:4001</a> ，重新打开即可。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/53_21AIX_V3NIT9L0O6_H$8.png" alt="img"></p><p>现在你已经初步搭建好了自己的网站，现在让我们开始<strong>发布自己的网站</strong>，让更多人看到~</p></li><li><p>配置远程推送信息</p><p>在 <code>./www.hwh.zone/blog</code> 路径下，找到<strong>主配置文件：__config.yml</strong> ：</p><ul><li>[注1]：因为这个文件<strong>很重要</strong>，特附图示例 。</li><li>[注2]：该配置文件对<strong>缩进</strong>等都严格要求，建议用IDE打开编辑（比如VScode），不易出错。</li></ul><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202214234731.png" alt="image-20211202214234731" style="zoom:80%;" /><p>在文件最下方配置相关信息：</p><ul><li>⚠️ 注意： <code>:</code> 后面需要留一个空格 ，repo地址最后需要带上 <code>.git</code> !</li></ul><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202214436348.png" alt="image-20211202214436348" style="zoom:80%;" /></li><li><p>安装Git插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>写一篇自己的文章</p><blockquote><p><code>_posts</code>  路径下的 <code>md</code> 文件，会被Hexo自动解析、渲染生成网页。我们所有的博客都是放在这个目录的。</p></blockquote><p>我们在：<code>www.hwh.zone\blog\source\_posts</code> 路径下，写一篇属于自己的文章：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202220312686.png" alt="image-20211202220312686"></p></li><li><p>开始发布网站</p><p>以上命令如果不出错，依次执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清除缓存网页</span></span><br><span class="line">hexo clean  </span><br><span class="line"><span class="comment"># 生成静态网页</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment"># 推送发布网站，要输入Github账号和token（注意不是密码，github从上月开始已经使用token验证身份，生成token可参考：https://zhuanlan.zhihu.com/p/38800965）</span></span><br><span class="line">hexo d  </span><br></pre></td></tr></table></figure><p>🐛 解决BUG：<strong>OpenSSL SSL_read：Connection was reset，erron 10054</strong>。</p><ul><li><p>第一种情况：未解除SSL验证</p><ol><li><p>打开<code>git</code>，切换到<code>www.hwh.zone/blog</code> 目录下</p></li><li><p>取消SSL验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>第二种情况：开了小飞机，让小飞机重新换个服务器重新连接。</p></li></ul></li><li><p>欣赏你自己的网站~！</p><p>现在我们在浏览器输入：<code>Wanghui-Huang.github.io</code> , 可以看到我们第一篇博客已经正式发布了！🤙</p><p>愉快的多欣赏一下吧~</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202220438110.png" alt="image-20211202220438110"></p></li><li><p>TIPS</p><p>💡 一般我们发布文章（或修改主题CSS样式等）, 流程如下：</p><ul><li><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code> ，打开 <code>localhost:4000</code>本地预览；</li><li><strong>本地</strong>进行修改，e.g. 文章增改、CSS样式修改；</li><li><strong>F5刷新下网页</strong>即可看到修改后的文章或样式，一般<strong>不需要</strong>重新执行<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code> ；</li><li>但是如果<strong>出现刷新无效</strong>，此时最好重新执行下以上三个命令；</li><li>最后再执行<code>hexo d</code> , 发布文章。</li></ul></li></ol><h4 id="主题-美化：以Butterfly为例">主题&amp;美化：以Butterfly为例</h4><p>hexo的众多开发者，无私提供了非常多主题供我们进行主题美化。去<a href="https://hexo.io/themes/">Hexo官网</a>或在<a href="https://github.com/search?q=hexo+theme">Github-hexo theme</a> ，搜索一个你喜欢的主题：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202221852344.png" alt="image-20211202221852344"></p><p>在这里，我使用主题 <a href="https://github.com/jerryc127/hexo-theme-butterfly">Github-Butterfly</a> ，作为最终的选择。</p><h5 id="快速开始-2">快速开始</h5><ol><li><p>下载主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>⚠️ 下载完毕后，文件重命名为 <code>butterfly</code> ， 放在 <code>www.hwh.zone\blog\themes</code> 目录下。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202222937528.png" alt="image-20211202222937528"></p></li><li><p>应用主题</p><p>在Hexo根目录下主配置文件 <code>_config.yml</code> , 进行配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure></li><li><p>安装必要插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure></li><li><p>测试查看</p><p>重新生成静态网页：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>打开 ：<a href="http://localhost:4000">http://localhost:4000</a>  , 可看到主题已经被成功替换。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/UP$@K0WX1%602JNDTP%60~DLFZM.png" alt="img" style="zoom:80%;" /></li></ol><h5 id="基本配置">基本配置</h5><blockquote><p>如果你想参考我的配置信息，可在进行<strong>附录</strong>中查看。</p></blockquote><p>在这一节我们将进行主题的基本信息设置，包括但不限于：</p><ul><li>网站基本信息设置</li><li>背景图片设置</li><li>目录相关设置</li><li>…</li></ul><p>但是在本文<strong>并不准备将以上设置过程详细列出</strong>，因为官网对这些的描述已经非常清晰和简洁。因此，<strong>强烈建议</strong>你参考官网文档：<a href="https://butterfly.js.org/posts/21cfbf15/">butterfly主题配置官方文档</a> ，根据个人喜欢进行这些基本设置。</p><p>在这里将主要记录：<strong>官网文档未提及的优化</strong>，以及根据<strong>官网文档配置时遇到的问题解决办法</strong>。</p><h5 id="Markdowm渲染优化">Markdowm渲染优化</h5><p>本节涉及：数学公式、脚注、表情、标题大小等设置。</p><div class="tabs" id="markdown"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#markdown-1">数学公式</button></li><li class="tab"><button type="button" data-href="#markdown-2">表情</button></li><li class="tab"><button type="button" data-href="#markdown-3">脚注</button></li><li class="tab"><button type="button" data-href="#markdown-4">标题大小</button></li><li class="tab"><button type="button" data-href="#markdown-5">标签外挂</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="markdown-1"><p>按照 <a href="https://butterfly.js.org/posts/ceeb73f/#Math-%E6%95%B8%E5%AD%B8">官方文档</a> , 进行配置：</p><ol><li><p>修改<strong>主题配置文件</strong>，加载katex.min.css</p><blockquote><p>⚠️ per_page 属性不能设置true，否则会出现bug：公式被渲染两次。</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">katex:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># true 表示每一頁都加載katex.js</span></span><br><span class="line">  <span class="comment"># false 需要時加載，須在使用的Markdown Front-matter 加上 katex: true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span>   <span class="comment"># 不要选择为true！！</span></span><br><span class="line">  <span class="attr">hide_scrollbar:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后在需要打开数学公式渲染的文章，开头设置：<code>katex: true</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202231613955.png" alt="image-20211202231613955"></p></li><li><p>安裝 hexo-renderer-markdown-it</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save <span class="comment"># 如果有安裝這個的話，卸載</span></span><br><span class="line">npm un hexo-renderer-kramed --save <span class="comment"># 如果有安裝這個的話，卸載</span></span><br><span class="line"></span><br><span class="line">npm i hexo-renderer-markdown-it --save <span class="comment"># 需要安裝這個渲染插件</span></span><br><span class="line">npm install @neilsustc/markdown-it-katex --save <span class="comment">#需要安裝這個katex插件</span></span><br></pre></td></tr></table></figure></li><li><p>修改Hexo根目录配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">markdown:</span><br><span class="line">  plugins:</span><br><span class="line">    - plugin:</span><br><span class="line">      name: <span class="string">&#x27;@neilsustc/markdown-it-katex&#x27;</span></span><br><span class="line">      options:</span><br><span class="line">        strict: <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-2"><p>表情插件配置过程如下：</p><ol><li><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install markdown-it-emoji --save</span><br></pre></td></tr></table></figure></li><li><p>根目录配置文件添加插件</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202233532272.png" alt="image-20211202233532272"></p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-3"><p>脚注直接安装插件即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-reference --save</span><br></pre></td></tr></table></figure><p>如果安装后，本地（typora）可以正确渲染，hexo无法正确渲染：多半是脚注使用出现<strong>语法错误</strong>。</p><ul><li>在正文中：严格按照[^1] 写入脚注，<strong>不要用任何空格</strong>！</li><li>在链接中：严格按照[^1]: 写入引用链接，<strong>不要用任何空格</strong>！</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-4"><p>butterfly主题标题大小默认的过小，不易于和正文进行区分。</p><p>为此，我们需要：</p><ol><li>找到<code>\www.hwh.zone\blog\themes\butterfly\source\css\_third-party</code> 路径下的<code>normalize.min.css</code> 文件</li><li>手动设置 h1~h5标题大小<br><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211202234443112.png" alt="image-20211202234443112"></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="markdown-5"><p>标签外挂插件 <code>Tag Plugins Plus</code> ，提供了丰富的<strong>markdown文件编写美化</strong>：</p><ul><li>时间轴</li><li>各种卡片</li><li>音频、视频插入</li><li>…</li></ul><p>可以让你的文章看起来美观许多，具体配置请参考：<a href="https://akilar.top/posts/615e2dec/">Tag Plugins Plus官网</a> 。</p><p>文档清晰简洁，这里不再赘述。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h5 id="支持评论功能">支持评论功能</h5><p>官网文档虽然给了很多种设置的评论方式，但就我自己尝试而言，<strong>Utterances和Twikoo</strong>属于比较方便的方式。</p><p>Utterances主要优点：</p><ul><li>和Gitalk类似，但不需要过多的权限设置；</li><li>相比Facebook Comments 等无需翻墙；</li><li>相比Disqus等UI更简洁美观。</li></ul><p>唯一美中不足的便是<strong>不能匿名评论</strong>，留言必须要用Github账号先登录。<strong>Twikoo</strong>在下文进行介绍。</p><div class="tabs" id="tags"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tags-1">Utterances（免费）</button></li><li class="tab"><button type="button" data-href="#tags-2">Twikoo（付费）</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tags-1"><p>以下是Utterances设置过程：</p><ol><li><p>在Github创建一个public的项目</p><p>不再赘述过程，我使用的是：<a href="https://github.com/Wanghui-Huang/gittalk">https://github.com/Wanghui-Huang/gittalk</a> ，这个项目。</p></li><li><p>安装 utterances</p><p>点击：<a href="https://github.com/apps/utterances">https://github.com/apps/utterances</a> ，安装app（右上方处<code>Install</code>按钮）。</p><p>安装成功后，会出现下面<code>Configure</code>按钮：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203105709777.png" alt="image-20211203105709777"></p></li><li><p>设置相关信息</p><p>点击<code>Configure</code>按钮，进入设置界面，注意<strong>红框处</strong>相关信息设置：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203105915848.png" alt="image-20211203105915848"></p><p>设置完毕后保存。</p></li><li><p>主题文件配置</p><p>修改主题配置文件：repo修改为你刚刚创建的repo，形式为 <code>你的用户名.项目名</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203110208806.png" alt="image-20211203110208806"></p><p>继续修改配置文件，指定评价插件名：<br><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203110412952.png" alt="image-20211203110412952"></p></li><li><p>测试 &amp; bug解决</p><p>选择任意一篇文章，可以看到评论框已经顺利出现：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203110741161.png" alt="image-20211203110741161"></p><p>经过实际测试，依旧会出现评论框无法显示的问题：</p><ul><li>我的问题是因为使用了自己的域名，<code>https</code>不安全便会出现这个问题；</li><li>如何使用自己的域名，后续小节有详细教程 &amp; 踩坑记录。</li></ul><p>可以在 Github项目：<code>Wanghui-Huang.github.io</code> → <code>Setting</code>→<code>Pages</code>   ，勾选<code>Enforce HTTPS</code>  ：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203111826078.png" alt="image-20211203111826078"></p><p>三连重新生成静态网页：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>便可以看到评论框已经正确显示了。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tags-2"><p>虽然Utterances已经足够简洁优秀且免费，但是Twikoo基于腾讯云开发，<strong>在国内速度很快&amp;支持匿名</strong>，价格也足够实惠（包年大约6元/月）。另一方面，支持下东家业务最后选择了这个方案。</p><ol><li><p>腾讯云函数配置</p><p>这一部分看<a href="https://twikoo.js.org/quick-start.html">官网文档</a>即可，很详细不再赘述。</p></li><li><p>Butterfly主题配置</p><p>修改 <code>主題配置文件</code> ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">twikoo:</span></span><br><span class="line">  <span class="attr">envId:</span> <span class="string">blog-comments-5g2cfs*******</span>  <span class="comment"># 腾讯云函数配置完后的id</span></span><br><span class="line">  <span class="attr">region:</span> <span class="string">ap-shanghai</span>  <span class="comment"># 默认上海 </span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span>        <span class="comment"># 显示文章浏览数</span></span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><p>静态网页生成三连，便可以看到已经生成成功了：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203160342989.png" alt="image-20211203160342989"></p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="其它补充">其它补充</h4><blockquote><p>链接太长不好分享？</p><p>想要一个属于自己的漂漂域名？</p><p>网站发布后本地图片全挂？</p><p>…</p></blockquote><p>在这里我们依次进行解决各种问题，让你的网络小窝看起来更加的专业。</p><h5 id="使用短连接">使用短连接</h5><p>hexo 默认生成文章<strong>长链接具有以下几个缺点</strong>：</p><ol><li>如果文章名包含中文，将会被转码，链接不雅观且长；</li><li>长链接不利于搜索引擎收录；</li><li>长链接不方便分享给他人。</li></ol><p>因此，参考<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Hexo-abbrlink插件生成唯一文章链接：https://zhuanlan.zhihu.com/p/112318081">[4]</span></a></sup>，我们利用Hexo-abbrlink插件，生成唯一文章短链接。</p><ol><li><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure></li><li><p>修改根目录配置文件</p><ul><li><code>url</code>：你的域名 ，如果是Github Pages命令方式为 <code>https://你的用户名.github.io</code></li><li><code>permalink</code>：按下图修改</li><li><code>permalink_defaults</code>：注释掉</li></ul><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203120905856.png" alt="image-20211203120905856"></p></li><li><p>三连重新生成</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></li><li><p>测试</p><p>生成完毕后，可以看到，在每一篇文章开头，自动多出了以下属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">abbrlink:</span> <span class="number">56326</span>  <span class="comment"># 这个id每篇文章都不一样</span></span><br></pre></td></tr></table></figure><p>文章链接也变成了短链接的形式：<br><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203121301172.png" alt="image-20211203121301172"></p></li></ol><h5 id="使用图床">使用图床</h5><p>使用markdown最头疼的地方，估计就是图片问题了：文章图片通常保存在<strong>本地</strong>，发布网站还是分享给他人通常还需要单独保存图片。显然，这一点也不cool。</p><p>幸运的是，我们可以使用<strong>图床</strong>，将图片通通保存在<strong>云端</strong>，本地只需像如下引用个链接即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![image-20211203121301172](https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203121301172.png)</span><br></pre></td></tr></table></figure><p>特别的，配合<a href="https://typora.io/">Typora</a>，所有本地图片可以自动上传到云端，可以说是很方便了。</p><p>因此，本文参考<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Typora+PicGo+腾讯云COS实现图片上传功能：https://www.daimajiaoliu.com/daima/56a7c8410d4cc09">[5]</span></a></sup>，使用<strong>Typora配合腾讯云COS存储搭建图床</strong>。</p><blockquote><p><strong>为什么选择要付费的腾讯云COS？</strong></p><p>在这之前我也选择了其它的免费图床，使用体验不太佳：</p><ul><li>速度很慢，而且限制一天上传的数量和频率，有时候需要集中上传本地文件的大量图片便很不友好了；</li><li>腾讯云COS虽然付费，但是价格很便宜，10元可以租10G/年。</li></ul><p>因此，最终我还是选择了腾讯云COS存储作为图床。</p></blockquote><ol><li><p>下载Typora</p><p>下载地址：<a href="https://pc.qq.com/search.html#!keyword=typora">腾讯云高速下载</a> ，默认安装即可。</p></li><li><p>下载PicGo</p><p>下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases">官网下载</a> ，默认安装即可。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203123433623.png" alt="image-20211203123433623"></p></li><li><p>腾讯云创建COS存储</p><p>进入腾讯云对象存储，在存储桶列表中点击创建存储桶：</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/736d7f4664f36fc1d2b286ac0859e814.png" alt="在这里插入图片描述" style="zoom:80%;" /><p>设置存储信息如下：</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/56fdfdd3b03104661de1abc72ea521fe.png" alt="在这里插入图片描述" style="zoom:80%;" /></li><li><p>密钥管理</p><p>密钥需要等会儿在配置文件中用到，因此我们需要提前设置好。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/604771ab575b32e30683e83e058c49a5.png" alt="在这里插入图片描述"></p><p>如果没有密钥，则新建密钥：</p><ul><li>记录以下：<strong>SecretID 和 SecretKey</strong>，等下要用到。</li></ul><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/a0c7902b4f48200a071bf216d574aba4.png" alt="在这里插入图片描述"></p></li><li><p>配置PicGo</p><p>打开PicGo后，图片上传选择腾讯云COS，然后进行以下设置：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1cf828eadf1b5b060fdd6f9337afa205.png" alt="在这里插入图片描述"></p></li><li><p>测试PicGO</p><p>在左上【上传区】，任意拖拽一张图片，如果上传成功则说明配置成功。</p></li><li><p>配置Typora</p><p>打开Typora：<code>文件</code>→<code>偏好设置</code>→<code>图像</code>：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/5b009f6cfef200d2b3ef58655730777d.png" alt="在这里插入图片描述"></p></li><li><p>测试Typora配置</p><ol><li>在右侧栏中左下角，找到【验证图片上传选项】，测试是否成功；</li><li>打开typora，任意在文章中粘贴一张本地图片，看是否会<strong>自动上传</strong>。</li></ol><p>以上成功，便可以愉快的开始编写文章了，开始你的大文豪生活了。</p></li></ol><h5 id="使用自己的域名">使用自己的域名</h5><blockquote><p><code>xxxxx.github.io</code> 看起来丑丑的，怎么拥有一个自己的漂漂域名呢？</p></blockquote><ol><li><p>买一个属于自己的域名</p><p>点击：<a href="https://dnspod.cloud.tencent.com/">腾讯云域名注册</a> ，注册一个自己的域名。</p></li><li><p>实名认证</p><p>参考官方文档：<a href="https://cloud.tencent.com/document/product/242/6707">域名实名认证</a> , 不进行实名认证可能无法进行正常域名解析。</p></li><li><p>域名解析设置</p><p>进入腾讯云解析设置：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203130549613.png" alt="image-20211203130549613"></p><p>分别添加以下解析记录：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203130911464.png" alt="image-20211203130911464"></p><ul><li>配置CNAME：我的域名 <code>www.hwh.zone</code>  可以解析到原本域名<code>Wanghui-Huang.github.io</code>  ，这个时候 <code>www.hwh.zone</code>相当是个别名，也就是<strong>暴露给别人看到的名字</strong>。</li><li>配置A记录：可以把域名<code>www.hwh.zone</code> <strong>直接解析</strong>到 <code>Github IP地址</code> （二次保障能解析到Github IP地址）。</li></ul><p><strong>不理解CNAME作用？有了A记录解析为什么还要CNAME</strong>？可参考：<a href="https://www.zhihu.com/question/22916306">cname记录是什么？他存在的意义是什么？</a></p></li><li><p>申请免费SSL证书</p><p>参考官方文档：<a href="https://cloud.tencent.com/document/product/400/6814">域名型（DV）免费 SSL 证书申请流程</a></p></li><li><p>Github Page设置</p><p>在 Github项目：<code>Wanghui-Huang.github.io</code> → <code>Setting</code>→<code>Pages</code>   ，设置你自己的域名  ：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203132157159.png" alt="image-20211203132157159"></p></li><li><p>创建CNAME文件</p><p>进入本地博客文件夹目录，例如我的：<code>www.hwh.zone\blog\source</code> ：</p><ul><li><p><strong>新建文件CNAME→输入你的域名</strong></p><p>⚠️ 注意：域名不要带<code>www.</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211203132639333.png" alt="image-20211203132639333"></p></li><li><p><strong>保存文件</strong></p><p>⚠️ 保存文件<strong>类型为所有文件</strong>，不是TXT文件！</p></li></ul></li><li><p>测试</p><p>网站三连发布后，浏览器输入：<code>你的域名</code> ，便可以正常开始解析了。</p><p>如果遇到错误，可以在下方评论留言。</p></li></ol><h5 id="网站备案">网站备案</h5><p>网站备案后通常有不少好处<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="网站域名备案的好处有哪些？https://www.ggcx.com/news/2105/251639.html">[6]</span></a></sup>，对于个人博客来说最重要的三个便是：</p><ol><li>加快网站的访问速度；</li><li>利于搜索引擎收录；</li><li>Github Pages访问较慢，备案后可以<strong>将服务器部署到（国内服务器）腾讯云COS或者腾讯云VPS</strong>上，访问速度极大加快。</li></ol><p>但这<strong>不影响网站域名的正常解析（除了慢点</strong>），因为毕竟网站部署在<strong>国外服务器</strong>（Github）上。</p><p>另外，网站备案经过我的尝试相比之前简便很多，只需要在<a href="https://cloud.tencent.com/product/ba">腾讯云全程线上备案</a>登记注册就好。但因为我身份证归属省份（江西），根据当地政策<strong>备案需要关闭网站</strong>，所以放弃折腾了。后续有时间补上。</p><h3 id="写在最后">写在最后</h3><p>断断续续写了大概一天，终于记录完了Hexo建站的基本所有的过程。因为没怎么运动，肩膀一直隐隐酸痛还是坚持写完了，可以说是身残志坚了。</p><p>后续的话可能会继续更新这篇文章，更好的打造自己的小窝，但主要还是更新一些C++和音视频相关博文：</p><ul><li>C++从零开始系列：C++基础、C++11特性学习、C++八股总结、C++开源源码分析；</li><li>音视频系列：待定；</li><li>其它：<strong>备案完成后</strong>，更新部署到腾讯云COS上教程。</li></ul><p>欢迎继续关注，一起学习。</p><img src="https://thumb.jfcdns.com/thumb/up/2017-8/201788194159800965660810_460_0.jpg" alt="溜了表情包-溜了溜了表情包下载全套无水印--pc6下载" style="zoom: 50%;" /><h3 id="更新记录">更新记录</h3><div class="timeline"><div class="timenode"><div class="meta"><p><p>2021-12-06 ：更新文档</p></p></div><div class="body"><ol><li>修改备案相关描述；</li><li>新增腾讯云COS相关描述。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-12-05 ：更新文档</p></p></div><div class="body"><ol><li>支持标签外挂，并新增安装教程</li><li>优化文章版式：分栏书写</li><li>更新配置文件</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-12-01 ：第一次更新</p></p></div><div class="body"><ol><li>上传初稿并发布</li></ol></div></div></div><h3 id="附录">附录</h3><blockquote><p>以下配置文件最终更新时间：2021/12/05  00:00 。</p></blockquote><ul><li><p><strong>royhuang’s 主配置文件</strong></p><p>点击这里查看：<a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/hwh.zone/p/hexo-build-site/_config.yml">_config.yml</a></p></li><li><p><strong>royhuang’s Butterfly配置文件</strong></p><p>点击这里查看：<a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/hwh.zone/p/hexo-build-site/_config.butterfly.yml">_config.butterfly.yml</a></p></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Butterfly 官方教程：https://butterfly.js.org/posts/21cfbf15/<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Hexo 知乎教程：https://zhuanlan.zhihu.com/p/26625249<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">从wordpress到hexo：https://www.wenjinyu.me/zh/from-wordpress-to-hexo-my-blog-should-have-been-like-this/<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Hexo-abbrlink插件生成唯一文章链接：https://zhuanlan.zhihu.com/p/112318081<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Typora+PicGo+腾讯云COS实现图片上传功能：https://www.daimajiaoliu.com/daima/56a7c8410d4cc09<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">网站域名备案的好处有哪些？https://www.ggcx.com/news/2105/251639.html<a href="#fnref:6" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站建设 </tag>
            
            <tag> hexo </tag>
            
            <tag> github pages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（八）_计算机基础_场景&amp;智力题</title>
      <link href="/p/31667/"/>
      <url>/p/31667/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h1>八、场景题&amp;智力题</h1><h2 id="8-1-场景题">8.1 场景题</h2><h4 id="1-设计一个微信运动排行榜？（Redis）">1. <strong>设计一个微信运动排行榜？（Redis</strong>）</h4><ul><li><p><strong>被CSIG伤过的的心还可以爱谁（第一次回答</strong>）</p><blockquote><p>“可以使用mysql, 将用户的好友列表关联的运动记录查询出来，然后通过order by 来进行排序，就可以实现了。”</p></blockquote><p>一旦数据量大达到千万级别的时候，不可避免地会出现慢查询，效率就会降低。所以<u>这不是面试官想听到的回答！</u></p></li><li><p><strong>Redis–高效</strong></p><p>使用Redis的有序集合 zset（<strong>有序且不重复</strong>） 。因为 zset 排序的下标从0 开始，自带一个score 值，该值可以当作排行的标准 。</p><ul><li><strong>添加用户和步数</strong>： <code>zadd key score member</code></li><li><strong>查询指定排名范围内用户</strong>： （从小到大）<code>zrange key start stop withscores </code>or （从大到小）<code>zrevrange key start stop withscores</code></li></ul><p>根据上面，所以用户按score从小到大排序完毕了，如果还要获取排名也可以使用下面命令：</p><ul><li><strong>查询指定用户排名</strong> ： <code>zrank key member</code> or <code>zrevrank key member</code></li></ul><p>一个简单的排行榜就设计完成了。</p><blockquote><p>如果面试官进一步问：一周排行榜怎么设计？</p></blockquote><p>一周的数据其实就是7天数据的累加，累加完后再排序，一个月的数据原理也是一样。可以使用 ：</p><ul><li><p><code>ZINTERSTORE</code> ： 计算给定一个或多个有序集的交集并将结果放到一个新的有序集合destination中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</span><br></pre></td></tr></table></figure><p>默认情况使用的函数是求和。</p></li></ul><p>所以可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zunionstore last_seven_days 7 20210315  20210316 20210317 20210318 20210319 20210320 20210321</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-海量数据问题">2. <strong>海量数据问题</strong></h4><blockquote><p>参考：<a href="https://blog.csdn.net/v_JULY_v/article/details/6279498">https://blog.csdn.net/v_JULY_v/article/details/6279498</a></p></blockquote><p>在海量数据中，针对top K类问题，通常比较好的方案是：</p><ul><li><p><strong>Top数问题：小根堆</strong></p><blockquote><p><strong>有1亿个浮点数，如何找出其最大的10000个</strong>？</p></blockquote><p>直接进行排序，大约需要10^8*4字节 = 400M ，如果内存够可以直接进行排序；如果内存不够采用：</p><ol><li><strong>最小堆法</strong> ：（1）先读入10000个数来创建大小为10000的<strong>最小堆</strong>（假设这10000个数是最大的10000个，然后每次和这10000中最小的比较）（2）遍历后续数字，和堆顶最小数字比较：如果小于堆顶数字，继续；如果大于堆顶数字，则替换堆顶并重新调整为最小堆（3）整个过程直至1亿个数全部遍历完为止</li><li><strong>分治法</strong>。 （1）1亿分为100份，每份100万个数据，找到每份的<strong>最大的1万</strong>个 （2）在剩下的100*1万个数据找到最大的1万个</li><li><strong>哈希法</strong>。 <u>如果这1亿个书里面有很多重复的数</u>，先通过Hash法，把这1亿个数字去重复。 然后再采用方法 1 或 2 。</li></ol></li><li><p><strong>最多重复（频率最高）：Hash映射+HashMap频率计算</strong></p><blockquote><p><strong>【最多重复】海量日志数据，提取出某日访问百度次数最多的那个IP。</strong></p></blockquote><ul><li><strong>分治法（基于Hash</strong>）。 （1）按照IP地址的<code>Hash(IP)%1024</code>值，把海量IP日志分别存储到1024个小文件中 （2）对于每一个小文件，可以构建一个IP为key，出现次数为value的<strong>Hash map</strong> （3）可以得到1024个小文件中的出现次数最多的IP ，再根据常规排序得到。</li></ul><p><u>⚠️ 使用Hash分散ip可以保证相同ip都在同一个文件夹</u>，如果只是简单均分是不行的。</p><blockquote><p><strong>【最多重复】有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词</strong>。</p></blockquote><ul><li>同上，<strong>分治法（基于Hash</strong>）。 首先计算下：1G / 1M = 1000个小文件，为保险分为2000个（1）<code>Hash(词)%2000</code> 映射到2000个文件中（2）分别计算2000个文件频率最高的那个单词，然后常规排序即可（2000个单词占：2k*16B=32KB&lt;&lt;1M）</li></ul><blockquote><p><strong>【最多重复】有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序</strong>。</p></blockquote><ul><li>同上，<strong>分治法（基于Hash</strong>）。 顺序读取10个文件，然后将query重新映射到若干个文件中，保证相同query都在同一个文件。其余同上。</li></ul></li><li><p><strong>不重复数：位图</strong></p><blockquote><p>【<strong>不重复</strong>】 <strong>在2.5亿个整数中找出不重复的整数。注，内存不足以容纳这2.5亿个整数</strong>。</p></blockquote><ul><li><p><strong>采用2位图（<a href="https://www.cnblogs.com/54chensongxia/p/11591979.html">BitMap</a></strong>）。00表示不存在，01表示出现一次，10表示多次，11无意义，需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2.5</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mi>b</mi><mo>=</mo><mn>2.5</mn><mo>∗</mo><mn>0.1</mn><mi>G</mi><mi>b</mi><mo>=</mo><mn>0.25</mn><mi>G</mi><mi>b</mi><mo>=</mo><mn>25</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2.5*10^8b = 2.5*0.1Gb=0.25Gb=25MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2.5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2.5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">0.1</span><span class="mord mathnormal">G</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">0.25</span><span class="mord mathnormal">G</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">25</span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span></span></span></span>。但是我们<strong>需要把所有的整数都表示出来</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><msup><mn>2</mn><mn>32</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi><mo>=</mo><mn>1</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2*2^{32}bit=1GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span></span></span></span>（1）扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变（2）查看bitmap，<u>把对应位是<strong>01</strong></u> 的整数输出即可。</p><p>注，int类型占32个字节，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span> 表示其能表示的整数个数。</p></li></ul><blockquote><p>【<strong>不重复·腾讯</strong>】<strong>给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中</strong>？</p></blockquote><ul><li><strong>采用2位图（<a href="https://www.cnblogs.com/54chensongxia/p/11591979.html">BitMap</a></strong>）。 需要40亿bit，大约500M，但实际是要表示所有整数，故还是1GB。其余同上。</li></ul></li><li><p><strong>共同数</strong></p><blockquote><p>【<strong>相同数</strong>】 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</p></blockquote><ul><li><strong>分治法（基于Hash</strong>）。 （1）分别将a，b两个大文件各自映射为10000个小文件，这样相同url会映射到a,b相同哈希值小文件中。（2）在a,b每一对小文件找到相同的url。</li></ul></li></ul><h4 id="3-分布式相关">3. <strong>分布式相关</strong></h4><blockquote><p><strong>谈一谈，分布式集群中如何保证线程安全</strong>？</p></blockquote><ul><li><p>对于单一服务来说，只要保证一台机器上的对于共享资源的访问是同步进行的就能保证线程安全了；但是对于分布式系统而已，保证一台服务器的同步，并不能保证访问共享资源是同步的；</p></li><li><p>所以可以考虑使用<strong>分布式锁</strong>的方式来保证分布式中的线程的安全线，这样不同的服务不同的线程通过竞争分布式锁来获取共享资源的操作权限；</p></li><li><p>例如<u><strong>redis的分布式锁、zookeeper锁</strong></u>，都可以作为分布式线程安全的手段。</p></li></ul><blockquote><p><strong>在淘宝购物，这个场景下，你会怎样来设计消息队列</strong>？</p></blockquote><ul><li><p><a href="https://juejin.cn/post/6844903817348136968">什么是消息队列？</a></p><p>消息队列（MQ）可以简单理解为：<strong>把要传输的数据放在队列中</strong>，一种先进先出的结构。</p></li><li><p><strong>怎么去设计淘宝消息队列</strong>？</p><p>待补充。</p></li></ul><h4 id="4-微信抢红包">4. <strong>微信抢红包</strong></h4><blockquote><p><a href="https://www.cnblogs.com/alimayun/p/12795698.html">例如一个人在群里发了100块钱的红包，群里有10个人一起来抢红包，每人抢到的金额随机分配。</a></p><ol><li><p>所有人抢到的金额之和要等于红包金额，不能多也不能少。</p></li><li><p>每个人至少抢到1分钱。</p></li><li><p>要保证红包拆分的金额尽可能分布均衡，不要出现两极分化太严重的情况。</p></li></ol></blockquote><p><strong>二倍均值法</strong>：假设剩余红包金额为m元，剩余人数为n，那么有如下公式：</p><ul><li><p><strong>每次抢到的金额 =  [0.01，m /n × 2 - 0.01]</strong></p></li><li><p>这个公式，保证了每次随机金额的平均值是相等的，不会因为抢红包的先后顺序而造成不公平。</p></li></ul><p>举例说明：</p><ul><li>假设有5个人，红包总额100元。100÷5×2 = 40，所以第1个人抢到的金额随机范围是[0.01，39.99]元，在正常情况下，平均可以抢到20元。假设第1个人随机抢到了20元，那么剩余金额是80元。80÷4×2 = 40，所以第2个人抢到的金额的随机范围同样是[0.01，39.99]元，在正常的情况下，还是平均可以抢到20元。假设第2个人随机抢到了20元，那么剩余金额是60元。60÷3×2 = 40，所以第3个人抢到的金额的随机范围同样是[0.01，39.99]元，平均可以抢到20元。以此类推，每一次抢到金额随机范围的均值是相等的。</li></ul><h2 id="8-2-智力题">8.2 智力题</h2><h4 id="1-厉害了我的杯">1. <strong>厉害了我的杯</strong></h4><blockquote><p>有一种玻璃杯质量确定但未知，需要检测。 有一栋100层的大楼，该种玻璃杯从某一层楼扔下，刚好会碎。 现给你两个杯子，问怎样检测出这个杯子的质量，即找到在哪一层楼刚好会碎？</p></blockquote><p>参考：<a href="https://cloud.tencent.com/developer/article/1497944">https://cloud.tencent.com/developer/article/1497944</a></p><h4 id="2-赛马问题">2. <strong>赛马问题</strong></h4><blockquote><p>64匹马，8个跑道，问最少比赛多少场，可以选出跑得最快的4匹马。</p><ul><li>Assumptions：每场比赛每个跑道只允许一匹马，且不存在并列情形。</li></ul></blockquote><h4 id="3-三人三鬼过桥">3. 三人三鬼过桥</h4><blockquote><p>有三个人跟三个鬼要过河,河上没桥只有条小船,然后船一次只能渡一个人和一个鬼,或者两个鬼或者两个人,无论在哪边岸上,只有是人比鬼少的情况下(如两鬼一人,三鬼两人,三鬼一人)人会被鬼吃,然而船又一定需要人或鬼操作才能航行(要有人或鬼划船),问,如何安全的把三人三鬼渡过河对岸?</p></blockquote><p>参考回答</p><ul><li>先两鬼过去。在一鬼回来。对面有一鬼。这边有三人两鬼。</li><li>再两鬼过去。在一鬼回来。对面有两鬼。这边有三人一鬼。</li><li>再两人过去。一人一鬼回来。对面一人一鬼。这边两人两鬼。</li><li>最后两人过去。一鬼回来。对面三人。这边三鬼。</li><li>剩下的就三个鬼二个过去一个回来在接另外个就OK了。</li></ul><h4 id="3-给定随机函数，生成别的随机数">3. 给定随机函数，生成别的随机数</h4><blockquote><p>给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？</p></blockquote><p>由大的生成小的容易，比如由Rand7()生成Rand5()，所以我们先构造一个大于7的随机数生成函数。 记住下面这个式子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成1到N^2之间的随机数,可以看作是在数轴上撒豆子。N是跨度/步长，是RandN()生成的数的范围长度</span></span><br><span class="line"><span class="comment">// RandN()-1的目的是生成0到N-1的数，是跳数。后面+RandN()的目的是填满中间的空隙Copy to clipboardErrorCopied</span></span><br><span class="line"></span><br><span class="line">RandNN= N( RandN()<span class="number">-1</span> ) + RandN() ;</span><br></pre></td></tr></table></figure><p>比如<code>Rand25= 5( Rand5()-1 ) + Rand5()</code>可以生成1到25之间的随机数。我们可以只要1到21（3*7）之间的数字，所以可以这么写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand7</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x=INT_MAX;</span><br><span class="line">  <span class="keyword">while</span>(x&gt;<span class="number">21</span>)&#123;</span><br><span class="line">    x=<span class="number">5</span>*(<span class="built_in">rand5</span>()<span class="number">-1</span>)+<span class="built_in">rand5</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x%<span class="number">7</span>+<span class="number">1</span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h4 id="4-砝码称轻重，找出最轻的">4. 砝码称轻重，找出最轻的</h4><p>其实这都是一类题，这里列举几个经典的：</p><blockquote><p>1、有一个天平，九个砝码，其中一个砝码比另八个要轻一些，问至少要用天平称几次才能将轻的那个找出来？</p></blockquote><p>参考回答：至少2次。第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个； 第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个；至少称2次．</p><blockquote><p>2、十组砝码每组十个，每个砝码都是10g重，但是现在其中有一组砝码每个都只有9g重，现有一个能显示克数的秤，最少称几次能找到轻的那组？</p></blockquote><p>参考回答：至少1次。</p><p>将砝码分组1~10，第一组拿一个，第二组拿两个以此类推。。第十组拿十个放到秤上称出克数x，则y = 550 - x，第y组就是轻的那组。</p><h4 id="5-利用空瓶换饮料，最多喝几瓶">5. 利用空瓶换饮料，最多喝几瓶</h4><blockquote><p>1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶？</p></blockquote><p><strong>第一种思路</strong></p><p>拿走3瓶，换回1瓶，相当于减少2瓶。</p><p>但是最后剩下4瓶的时候例外，这时只能换1瓶。所以我们计算1000减2能减多少次，直到剩下4.（1000-4=996，996/2=498）所以1000减2能减498次直到剩下4瓶，最后剩下的4瓶还可以换一瓶，所以总共是1000+498+1=1499瓶。</p><p><strong>第二种思路</strong></p><ul><li><p>1000瓶饮料，3个空瓶子能换1瓶饮料，最多可以喝几瓶？</p></li><li><p>第一种思维：可以考虑成dp思路</p><ul><li><p>初始情况，3个瓶子时将发生一次交换，因此视为特殊情况</p></li><li><p>之后每增加两个瓶子又可以再换一瓶</p></li><li><p>即dp[i] = dp[i - 2] + (i - (i - 2)) + 1</p></li><li><ul><li>由dp[i - 2]可求得dp[i]</li><li>(i - (i - 2))，即为当前增加的2瓶饮料（写成这样便于理解）</li><li>1即为增加了2个空瓶，之后又可以换一瓶饮料</li></ul></li><li><p>简化为dp[i] = dp[i - 2] + 2 + 1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// n为0/1/2的特殊情况省略了</span></span><br><span class="line">    <span class="comment">// 定义dp数组</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始状态</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line"> &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li></ul></li><li><p>回归正题</p><ul><li>特殊情况：从上面的分析中，留下2个瓶子</li><li>剩下998个瓶子相当于每消耗2个瓶子即可获得一瓶，即为499瓶</li><li>最后剩下的2个瓶子无法再进行兑换，因此总共为1000 + 499 = 1499</li></ul></li><li><p>第二种思维</p><ul><li>因为兑换一瓶饮料需要三个空瓶，这瓶饮料如果是找老板借来的，那么喝完后这个空瓶将会还给他，同时需要附赠给他另外两个空瓶，即每消耗手里两个空瓶就获得一瓶饮料</li><li>但是值得注意的是，上面只是一种假设，实际情况老板是不会借给你的，因此我们至少需要保留2个空瓶，这样可以在998个瓶子剩下一个瓶子时，对其进行补足为3个空瓶，从而兑换一瓶新饮料</li><li>此时使用998个瓶子进行上述的兑换，将获得499瓶饮料</li><li>之前留下的两个瓶子正好无法兑换，最终获得饮料为1000 + 499 = 1499瓶</li></ul></li></ul><h4 id="6-毒药毒白鼠，找出哪个瓶子中是毒药">6. 毒药毒白鼠，找出哪个瓶子中是毒药</h4><blockquote><p>有1000个一模一样的瓶子，其中有999瓶是普通的水，有1瓶是毒药。任何喝下毒药的生命都会在一星期之后死亡。现在你只有10只小白鼠和1个星期的时间，如何检验出哪个瓶子有毒药？</p></blockquote><p>参考回答</p><ol><li><p>将10只老鼠剁成馅儿，分到1000个瓶盖中，每个瓶盖倒入适量相应瓶子的液体，置于户外，并每天补充适量相应的液体，观察一周，看哪个瓶盖中的肉馅没有腐烂或生蛆。（你要是胆子够大就可以这么回答，是个狼人）</p></li><li><p>首先一共有1000瓶，2的10次方是1024，刚好大于1000，也就是说，1000瓶药品可以使用10位二进制数就可以表示。从第一个开始：</p><p>第一瓶 ： 00 0000 0001</p><p>第二瓶： 00 0000 0010</p><p>第三瓶： 00 0000 0011</p><p>……</p><p>第999瓶： 11 1111 0010</p><p>第1000瓶： 11 1111 0011</p><p>需要十只老鼠，如果按顺序编号，ABCDEFGHIJ分别代表从低位到高位每一个位。 每只老鼠对应一个二进制位，如果该位上的数字为1，则给老鼠喝瓶里的药。</p><p>观察，若死亡的老鼠编号为：ACFGJ，一共死去五只老鼠，则对应的编号为 10 0110 0101，则有毒的药品为该编号的药品，转为十进制数为：613号。（这才是正解，当然前提是老鼠还没被撑死）</p></li></ol><blockquote><p>类似问题：8瓶酒一瓶有毒，用小老鼠测试。每次测试结果8小时后才会得出，而你只有8个小时的时间。最少需要（ ）老鼠测试？</p><ul><li>A 、2  B、3  C、4  D、6</li></ul></blockquote><p>解析：用3位2进制代表8瓶酒，如下表所示</p><p>瓶序号 二进制 中毒情况</p><p>第一瓶 000 全没中毒</p><p>第二瓶 001 只有第一个老鼠中毒</p><p>第三瓶 010 只有第二个老鼠中毒</p><p>第四瓶 011 第一个老鼠、第三个老鼠同时中毒</p><p>第五瓶 100 只有第三个老鼠中毒</p><p>第六瓶 101 第一个老鼠、第三个老鼠同时中毒</p><p>第七瓶 110 第二个老鼠、第三个老鼠同时中毒</p><p>第八瓶 111 三个老鼠同时中毒</p><p>其中，第一个老鼠喝下最低位为1对应的酒，第二个老鼠喝下中间位为1对应的酒，第三个老鼠喝下最高位为1对应的酒。</p><p>最后将所有中毒的老鼠，对应的位次进行与操作即可以知道那瓶毒药有毒了。</p><h4 id="7-利用烧绳子计算时间">7. 利用烧绳子计算时间</h4><blockquote><p>现有若干不均匀的绳子，烧完这根绳子需要一个小时，问如何准确计时15分钟，30分钟，45分钟，75分钟。。。</p></blockquote><ul><li><p>计算15分钟：对折之后两头烧(要求对折之后绑的够紧，否则看45分钟解法)</p></li><li><p>计算30分钟：两头烧</p></li><li><p>计算45分钟：两根，一根两头烧一根一头烧，两头烧完过了30分钟，立即将第二根另一头点燃，到烧完又过15分钟，加起来45分钟</p></li><li><p>计算75分钟：将30和45分钟的方式加起来就可以了</p></li></ul><p>其余类似</p><h4 id="8-在24小时里面时针分针秒针可以重合几次">8. 在24小时里面时针分针秒针可以重合几次</h4><p>24小时中时针走2圈，而分针走24圈，时针和分针重合24-2=22次，而只要时针和分针重合，秒针一定有机会重合，所以总共重合22次。</p><h4 id="9-100个奴隶猜帽子颜色">9. 100个奴隶猜帽子颜色</h4><blockquote><p>一百个奴隶站成一纵列，每人头上随机带上黑色或白色的帽子，各人不知道自己帽子的颜色，但是能看见自己前面所有人帽子的颜色． 然后从最后一个奴隶开始，每人只能用同一种声调和音量说一个字：”黑”或”白”， 如果说中了自己帽子的颜色，就存活，说错了就拉出去斩了，说的参考回答所有奴隶都能听见。 是否说对，其他奴隶不知道。</p><p>在这之前，所有奴隶可以聚在一起商量策略，问如果奴隶都足够聪明而且反应足够快，100个人最大存活率是多少？</p></blockquote><p>参考回答：这是一道经典推理题</p><ol><li><p>最后一个人如果看到奇数顶黑帽子报“黑”否则报“白”，他可能死</p></li><li><p>其他人记住这个值（实际是黑帽奇偶数），在此之后当再听到黑时，黑帽数量减一</p></li><li><p>从倒数第二人开始，就有两个信息：记住的值与看到的值，相同报“白”，不同报“黑”</p></li></ol><p>99人能100%存活，1人50%能活</p><blockquote><p>变种：每个奴隶只能看见前面一个人帽子颜色又能最多存活多少人？</p></blockquote><p>增加限制条件后，上面的方法就失效了，此时只能约定偶数位奴隶说他前一个人的帽子颜色，奇数奴隶获取信息100%存活，偶数奴隶50几率存活。</p><h4 id="10-小猴子搬香蕉">10. 小猴子搬香蕉</h4><blockquote><p>一个小猴子边上有100根香蕉，它要走过50米才能到家，每次它最多搬50根香蕉，（多了就被压死了），它每走 1米就要吃掉一根，请问它最多能把多少根香蕉搬到家里？</p><p>（提示：他可以把香蕉放下往返的走，但是必须保证它每走一米都能有香蕉吃。也可以走到n米时，放下一些香蕉，拿着n根香蕉走回去重新搬50根。）</p></blockquote><p>这种试题通常有一个迷惑点，让人看不懂题目的意图。此题迷惑点在于：走一米吃一根香蕉，一共走50米，那不是把50根香蕉吃完了吗？如果要回去搬另外50根香蕉，则往回走的时候也要吃香蕉，这样每走一米需要吃掉三根香蕉，走50米岂不是需要150根香蕉？</p><p>其实不然，本题关键点在于：猴子搬箱子的过程其实分为两个阶段，第一阶段：来回搬，当香蕉数目大于50根时，猴子每搬一米需要吃掉三根香蕉。第二阶段：香蕉数&lt;=50，直接搬回去。每走一米吃掉1根。</p><ol><li><p>第一阶段：假如把100根香蕉分为两箱，一箱50根</p><p>第一步，把A箱搬一米，吃一根。</p><p>第二步，往回走一米，吃一根。</p><p>第三步，把B箱搬一米，吃一根。</p><p>这样，把所有香蕉搬走一米需要吃掉三根香蕉。这样走到第几米的时候，香蕉数刚好小于50呢？</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>100</mn><mo>−</mo><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mn>3</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mn>50</mn><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mn>100</mn><mo>−</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>∗</mo><mn>3</mn><mo stretchy="false">)</mo><mo>&gt;</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">100-(n*3)&lt;50 \&amp;\&amp; 100-(n-1*3)&gt;50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">100</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">50&amp;&amp;100</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">50</span></span></span></span></span></p><p>走到16米的时候，吃掉48根香蕉，剩52根香蕉。这步很有意思，它可以直接搬50往前走，也可以再来回搬一次，但结果都是一样的。</p><p>到17米的时候，猴子还有49根香蕉。这时猴子就轻松啦，直接背着走就行。</p></li><li><p>第二阶段：走一米吃一根</p><p>把剩下的50-17=33米走完。还剩49-33=16根香蕉。</p></li></ol><h4 id="11-N只蚂蚁走树枝，问总距离或者总时间">11. N只蚂蚁走树枝，问总距离或者总时间</h4><blockquote><p>问题：放N只蚂蚁在一条长度为M树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间为多少？</p></blockquote><p>这个其实就一个诀窍：蚂蚁相碰就往反方向走，可以直接看做没有发生任何事：大家都相当于独立的</p><p>A蚂蚁与B蚂蚁相碰后你可以看做没有发生这次碰撞，这样无论是求时间还是距离都很简单了。</p><h4 id="12-N个强盗分配M个金币，求方案使得自己分配最多">12. N个强盗分配M个金币，求方案使得自己分配最多</h4><blockquote><p>5个海盗抢到了100枚金币，每一颗都一样的大小和价值。 他们决定这么分：</p><ol><li><p>抽签决定自己的号码（1，2，3，4，5）</p></li><li><p>首先，由1号提出分配方案，然后大家5人进行表决，当 半数以上的人同意时（ 不包括半数，这是重点），按照他的提案进行分配，否则将被扔入大海喂鲨鱼。</p></li><li><p>如果1号死后，再由2号提出分配方案，然后大家4人进行表决，当且仅当半超过半数的人同意时，按照他的提案进行分配，否则将被扔入大海喂鲨鱼。</p></li><li><p>依次类推…</p></li></ol><p>假设每一位海盗都足够聪明，并且利益至上，能多分一枚金币绝不少分，那么1号海盗该怎么分金币才能使自己分到最多的金币呢？</p></blockquote><p>从后向前推，如果1至3号强盗都喂了鲨鱼，只剩4号和5号的话，5号一定投反对票让4号喂鲨鱼，以独吞全部金币。所以，4号惟有支持3号才能保命。</p><ul><li><p>3号知道这一点，就会提出“100，0，0”的分配方案，对4号、5号一毛不拔而将全部金币归为已有，因为他知道4号一无所获但还是会投赞成票，再加上自己一票，他的方案即可通过。</p></li><li><p>不过，2号推知3号的方案，就会提出“98，0，1，1”的方案，即放弃3号，而给予4号和5号各一枚金币。由于该方案对于4号和5号来说比在3号分配时更为有利，他们将支持他而不希望他出局而由3号来分配。这样，2号将拿走98枚金币。</p></li><li><p>同样，2号的方案也会被1号所洞悉，1号并将提出（97，0，1，2，0）或（97，0，1，0，2）的方案，即放弃2号，而给3号一枚金币，同时给4号（或5号）2枚金币。由于1号的这一方案对于3号和4号（或5号）来说，相比2号分配时更优，他们将投1号的赞成票，再加上1号自己的票，1号的方案可获通过，97枚金币可轻松落入囊中。这无疑是1号能够获取最大收益的方案了！</p></li></ul><p>1号强盗分给3号1枚金币，分给4号或5号强盗2枚，自己独得97枚。分配方案可写成（97，0，1，2，0）或（97，0，1，0，2）。</p><blockquote><p>变种：就是只需要一半人同意即可，不需要一半人以上同意方案就可以通过，在其他条件不变的情况下，1号该怎么分配才能获得最多的金币？</p></blockquote><ul><li><p>4号：4号提出的方案的时候肯定是最终方案，因为不管5号同意不同意都能通过，所以4号5号不必担心自己被投入大海。那此时5号获得的金币为0，4号获得的金币为100。</p></li><li><p>5号：因为4号提方案的时候 ，自己获取的金币为0 。所以只要4号之前的人分配给自己的金币大于0就同意该方案。</p></li><li><p>4号：如果3号提的方案一定能获得通过（原因：3号给5号的金币大于0， 5号就同意 因此就能通过），那自己获得的金币就为0，所以只要2号让自己获得的金币大于0就会同意。</p></li><li><p>3号：因为到了自己提方案的时候可以给5号一金币，自己的方案就能通过，但考虑到2号提方案的时候给4号一个金币，2号的方案就会通过，那自己获得的金币就为0。所以只要1号让自己获得的金币大于0就会同意。</p></li><li><p>2号：因为到了自己提方案的时候只要给4号一金币，就能获得通过，根本就不用顾及3 号 5号同意不同意，所以不管1号怎么提都不会同意。</p></li><li><p>1号：2号肯定不会同意。但只要给3号一块金币，5号一块金币（因为5号如果不同意，那么4号分配的时候，他什么都拿不到）就能获得通过。</p></li></ul><p>所以参考回答是： 98，0，1，0，1。</p><h4 id="14-火枪手决斗，谁活下来的概率大？">14. 火枪手决斗，谁活下来的概率大？</h4><blockquote><p>问题：彼此痛恨的甲、乙、丙三个枪手准备决斗。甲枪法最好，十发八中；乙枪法次之，十发六中；丙枪法最差，十发四中。如果三人同时开枪，并且每人每轮只发一枪；那么枪战后，谁活下来的机会大一些？</p></blockquote><p>一般人认为甲的枪法好，活下来的可能性大一些。但合乎推理的结论是，枪法最糟糕的丙活下来的几率最大。</p><p>那么我们先来分析一下各个枪手的策略。</p><p>如同田忌赛马一般，枪手甲一定要对枪手乙先。因为乙对甲的威胁要比丙对甲的威胁更大，甲应该首先干掉乙，这是甲的最佳策略。</p><p>同样的道理，枪手乙的最佳策略是第一枪瞄准甲。乙一旦将甲干掉，乙和丙进行对决，乙胜算的概率自然大很多。</p><p>枪手丙的最佳策略也是先对甲。乙的枪法毕竟比甲差一些，丙先把甲干掉再与乙进行对决，丙的存活概率还是要高一些。</p><p>我们根据分析来计算一下三个枪手在上述情况下的存活几率： 第一轮：甲射乙，乙射甲，丙射甲。</p><ul><li><p>甲的活率为24%（40% X 60%）</p></li><li><p>乙的活率为20%(100% - 80%)</p></li><li><p>丙的活率为100%（无人射丙）</p></li></ul><p>由于丙100％存活率，因此根据上轮甲乙存活的情况来计算三人第二轮的存活几率：</p><ul><li>情况1：甲活乙死（24% X 80% = 19.2%） 甲射丙，丙射甲：甲的活率为60%，丙的活率为20%。</li><li>情况2：乙活甲死（20% X 76% = 15.2%） 乙射丙，丙射乙：乙的活率为60%，丙的活率为40%。</li><li>情况3：甲乙同活（24% X 20% = 4.8%） 重复第一轮。 情况4：甲乙同死（76% X 80% = 60.8%） 枪战结束。</li></ul><p>据此来计算三人活率：</p><ul><li>甲的活率为(19.2% X 60%) + (4.8% X 24%) = 12.672%</li><li>乙的活率为(15.2% X 60%) + (4.8% X 20%) = 10.08%</li><li>丙的活率为(19.2% X 20%) + (15.2% X 40%) + (4.8% X 100%) + (60.8% X 100%) = 75.52%</li></ul><p>通过对两轮枪战的详细概率计算，我们发现枪法最差的丙存活的几率最大，枪法较好的甲和乙的存活几率却远低于丙的存活几率。</p><h4 id="15-先手必胜的问题">15. 先手必胜的问题</h4><blockquote><p>100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿？</p></blockquote><p>寻找每个回合固定的拿取模式，最后一次是我拿，那么上个回合最少剩下6本。那么只要保持每个回合结束后都剩下6的倍数，并且在这个回合中我拿的和对方拿的加起来为6（这样这个回合结束后剩下的还是6的倍数），就必胜。</p><p>关键是第一次我必须先手拿（100%6=4）本（这不算在第一回合里面）。</p><h4 id="16-掰巧克力问题或者参加辩论赛">16. 掰巧克力问题或者参加辩论赛</h4><blockquote><p>1、掰巧克力问题 N<em>M块巧克力，每次掰一块的一行或一列，掰成1</em>1的巧克力需要多少次？</p><p>2、1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛？</p></blockquote><p>每次拿起一块巧克力，掰一下（无论横着还是竖着）都会变成两块，因为所有的巧克力共有N<em>M块，所以要掰N</em>M-1次，-1是因为最开始的一块是不用算进去的。</p><p>每一场辩论赛参加两个人，消失一个人，所以可以看作是每一场辩论赛减少一个人，直到最后剩下1个人，所以是1000-1=999场。</p>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 场景题 </tag>
            
            <tag> 智力题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（七）_计算机基础_数据结构</title>
      <link href="/p/61434/"/>
      <url>/p/61434/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h1>七、数据结构和算法</h1><h4 id="1-如何对快排进行优化？">1. 如何对快排进行优化？</h4><ul><li><p><strong>三数取中法和随机交换法</strong></p><blockquote><p>快排将选取的基准点经过调整放到合适的位置，之后将这个基准点左右两边的区间分别递归的进行快排。</p><p>如果基准点的数据比较小，将会导致调整后基准点处于靠近两侧的位置，那么两边的区间长度将会严重失去平衡.</p></blockquote><p><strong>三数取中法：指的是选取基准点之前</strong>我们可以拿出数列中间位置元素的值，将它和首尾的元素进行比较，之后将这三个数中的<strong>中间数</strong>交换到<strong>数列首位</strong>的位置，之后将这个数作为基准点，<u>尽量减小之后的分区后左右两边的区间长度之差</u>。</p></li><li><p><strong>三路分割法</strong></p><p><strong>三路法同样是针对含有大量【重复数列】的优化</strong>。</p><p>3路法的思想是将数列分成3个区间，分别是<strong>小于、等于和大于基准点的区间</strong>。那么分区之后，对于等于基准点的区间内的元素，我们就不需要对其做任何处理了，只需要递归的处理小于和大于基准点的元素即可。</p></li><li><p><strong>结合插入排序</strong></p><p>当待排序序列的长度分割到一定大小后，使用<strong>插入排序</strong>。</p><ul><li><strong>对于很小和部分有序的数组，快排不如插排好</strong>。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排。</li></ul></li></ul><h4 id="2-快排和堆排的区别？什么时候使用快排和堆排？">2.<strong>快排和堆排的区别</strong>？<strong>什么时候使用快排和堆排</strong>？</h4><ul><li><p><strong>快排和堆排区别</strong>？</p><ul><li><p><strong>综合性能</strong>：实际应用中，虽然<u>堆排序的时间复杂度要比快速排序稳定</u>（快排最差退化成O(N^2)） ，但是统计意义上这种情况较少，所以综合性能还是快排更优；</p></li><li><p><strong>交换次数</strong>： 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序；</p></li><li><p><strong>访问友好</strong>： 堆排序数据访问的方式没有快速排序友好。</p><blockquote><p><strong>对于快速排序来说，数据是顺序访问的；而堆排序来说，数据是跳着访问的</strong>。比如，堆排序中，最重要的一个操作就是数据的堆化。对堆顶节点进行堆化，会一次访问<strong>数组下标1，2，4，8</strong>的元素，而不是像快排那样，局部顺序访问，<u>所以对<strong>CPU缓存</strong>是不友好的</u>。</p></blockquote></li></ul></li><li><p><strong>快排和堆排使用场景</strong>？</p><ul><li><p><strong>快排</strong>： 绝大多数场合。</p></li><li><p><strong>堆排</strong>： topK问题、优先队列（需要在一组不停更新的数据中不停地找最大/小元素）</p><blockquote><p>在N个元素中找到top K，时间复杂度是O(N log K)，空间复杂的是O(K)，而快速排序的空间复杂度是O(N)。</p></blockquote></li></ul></li></ul><h4 id="3-【面试重点】有哪些排序算法，各算法的时间复杂度-哪些是稳定的？为什么是稳定的？">3. 【面试重点】有哪些排序算法，各算法的时间复杂度 ? 哪些是稳定的？为什么是稳定的？</h4><p><img src="https://i.loli.net/2021/05/01/K3s7DFEvyhHkwI9.png" alt="image-20210501224258097"></p><h5 id="3-1-如果数据大致有序的，用什么排序比较好？">3.1 如果数据大致有序的，用什么排序比较好？</h5><p>如果是<strong>大致有序</strong>，用 <u>插入排序</u> 比较好：</p><ul><li><u>直接插入排序</u>是将第i个元素插入到已经排序好的前i-1个元素中 ，当元素基本有序时。和前i-1个元素<strong>末尾比较一次</strong>就可以直接插入。</li></ul><p>在相比使用其它排序：</p><ul><li><p><u>归并排序：</u> 归并排序和数组是否有序无关，都是O(nlgn)。</p><blockquote><p>归并排序是把一个有n个记录的无序文件看成由<strong>n个长度为1</strong>的有序子文件组成的文件，然后进行两两归并，得到[n/2]个长度为2或1的有序文件，再两两归并 。</p></blockquote></li><li><p><u>快速排序：</u> 数组基本有序时，此时如果使用基点是最后一个元素，划分的两个子数组极为不平衡，每次划分比较次数都很多。所以不推荐。</p></li></ul><h4 id="4-二叉查找树，红黑树和平衡二叉树的区别？（有了二叉查找树、平衡树（AVL）为啥还需要红黑树？）">4. 二叉查找树，红黑树和平衡二叉树的区别？（有了二叉查找树、平衡树（AVL）为啥还需要红黑树？）</h4><blockquote><p>总结来说：平衡树是为了解决二叉查找树退化为链表的情况；而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。</p></blockquote><ul><li><p><strong>二叉查找树退化成单链表</strong></p><p>正常使用二叉查找树是类似于<u>二分查找 O（logn）</u>，但是极端情况：</p><ul><li><p>构建的二叉树所有节点都只有右子树或左子树，此时时间复杂度退化成O(N)</p><p><img src="https://i.loli.net/2021/05/01/38TASb1DB7sYN5k.jpg" alt="preview"></p></li></ul></li><li><p><strong>平衡二叉树频繁左右旋</strong></p><p>平衡二叉树就是为了解决二叉查找树退化成一颗链表而诞生了，平衡树具有如下特点：</p><ol><li><p>具有二叉查找树的全部特性；</p></li><li><p><strong>每个节点的左子树和右子树的高度差至多等于1</strong>。</p></li></ol><p>避免了二叉查找树极端情况产生，但是：</p><ul><li>每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过<strong>左旋</strong>和<strong>右旋</strong>来进行调整，使之再次成为一颗符合要求的平衡树。</li></ul><p>平衡树性能大打折扣。</p></li><li><p><strong>红黑树规不需要频繁着调整</strong></p><p>红黑树具有如下特点：</p><blockquote><p>最坏情况下，也能在 O(logn) 的时间复杂度查找到某个节点。</p><ul><li>与平衡树不同的是，红黑树在插入、删除等操作，（🚩*1）<strong>不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整</strong>，这也是我们为什么大多数情况下使用红黑树的原因；</li><li>但是，单单在查找方面的效率的话，平衡树比红黑树快。</li></ul></blockquote><p><img src="https://i.loli.net/2021/05/01/sFSaG9POEi73hdo.jpg" alt="img"></p><ol><li>具有二叉查找树的特点；</li><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据；</li><li><strong>任何相邻的节点都不能同时为红色</strong>，也就是说，红色节点是被黑色节点隔开的；</li><li>每个节点，<strong>从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点</strong>。</li></ol></li></ul><h5 id="4-1-为什么红黑树不需要频繁调整？">4.1 为什么红黑树不需要频繁调整？</h5><blockquote><p>详细理解红黑树一篇不错的文章：<a href="https://zhuanlan.zhihu.com/p/97523789">百图详解红黑树，想不理解都难</a></p></blockquote><p>平衡二叉树这种高度差为 1 的要求太严格了，尤其是对于频繁删除、插入的场景非常浪费时间。</p><p>但是由于红黑树：</p><ul><li>具有二叉树所有特点。</li><li>每个节点只能是红色或者是黑色。</li><li><strong>根节点只能是黑色</strong>，且黑色根节点不存储数据。</li><li><strong>任何相邻的节点都不能同时为红色</strong>。</li><li>红色的节点，它的子节点只能是黑色。</li><li>从任一节点到其每个叶子的所有路径都包含<strong>相同数目的黑色节点</strong>。</li></ul><p><strong>不追求插入、删除等操作绝对平衡</strong>，只需满足上述条件即可。它的旋转次数少，<strong>插入最多两次旋转</strong>，<strong>删除最多三次旋转</strong>。</p><p>所以在搜索、插入、删除操作较多的情况下，红黑树的效率是优于平衡二叉树的。</p><h4 id="5-快速排序的过程-？">5.快速排序的过程 ？</h4><ul><li><p>手撕一个<a href="">二分查找</a> 和快排？</p><ul><li><p><strong>二分查找</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binary search</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid ;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right) <span class="comment">//*&lt;= 而不是&lt; </span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(value == arr[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid; <span class="comment">// 如果数组存在待查找元素，按照逻辑一定会是mid</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span>(value &lt; arr[mid])</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// value &gt; arr[mid]</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>快速排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] quick_sort(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;=left)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择基准：数组最右数字</span></span><br><span class="line">        <span class="comment">// *如果选择最左，思考交换过程</span></span><br><span class="line">        <span class="comment">// *partition 左侧始终是比pivot小的数</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[right];</span><br><span class="line">        <span class="keyword">int</span> partition = left;</span><br><span class="line">        <span class="comment">// 遍历分区元素</span></span><br><span class="line">        <span class="comment">// 小于基准的放基准左边，大于的放基准右边</span></span><br><span class="line">        <span class="comment">// * 终止条件：i &lt; right 而非 right-1！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt; right;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;pivot) <span class="comment">// 实际只交换小于到左边即可</span></span><br><span class="line">            &#123;</span><br><span class="line">                swap(arr,i,partition);</span><br><span class="line">                partition++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// *基准插入位置partition位置</span></span><br><span class="line">        swap(arr,partition,right);</span><br><span class="line">        <span class="comment">//递归的排序</span></span><br><span class="line">        quick_sort(arr,left,partition-<span class="number">1</span>);</span><br><span class="line">        quick_sort(arr,partition+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-布隆过滤器原理？为什么使用多个哈希函数？其它相关应用？">6. 布隆过滤器原理？为什么使用多个哈希函数？其它相关应用？</h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/43263751">详解布隆过滤器的原理，使用场景和注意事项</a></p></blockquote><blockquote><p>“布隆说：<strong>不存在</strong>的那么<strong>一定不存在</strong>”</p><p>“布隆说：<strong>存在</strong>的那么<strong>只是可能存在</strong>”</p></blockquote><h5 id="7-1-从HashMap说起—当你判断某个元素时候你在想什么？">7.1 从HashMap说起—当你判断某个元素时候你在想什么？</h5><blockquote><p>通常我们怎么判断一个数组，是否存在某个元素呢？</p></blockquote><p>聪明的你一定想到HashMap：（1）HashMap将数组所有元素使用哈希函数，映射到HashMap上（HashMap本身也是一个数组）（2）然后就可以在O(1)级别判断某个元素是否存在。</p><p>但是这种做法通常会导致以下问题：</p><ol><li><strong>一旦数组很大</strong>，比如上亿，HashMap将会占据非常大的内存；</li><li>数组很大，不大可能一次性能在内存构建HashMap；</li><li>而且HashMap，通常存在负载因子，是不能充分利用内存的。</li></ol><p>为此，我们可以从以下方向优化：</p><ul><li><p><strong>只存储key。<strong>但是，因为我们</strong>只要判断某个元素（key）是否存在</strong>， 不需要取出对应key的value—也就是<strong>不需要存储value</strong>。</p></li><li><p><strong>key映射为bit数组索引。<strong>key映射为<code>bit</code>数组索引，即</strong>位图对应索引</strong>，  索引对应数值用 <code>0/1</code> 就可以标识为是否存在该key。</p></li></ul><p>为此，我们可以【第一阶段优化】如下：</p><p><img src="https://i.loli.net/2021/05/28/acoknPGdU3DVMEw.png" alt="img"></p><p>看样子似乎是满足我们要求了，但是依旧存在以下问题：</p><ol><li>只使用一个<code>hash</code>函数，<strong>空间利用率低</strong>。</li></ol><p>一个<code>hash</code>函数只能<strong>将key散列到一个位置</strong> ，虽然hash尽量优良映射均匀，但是空间利用率依然不算高。</p><p>因此，我们可以多个函数，将<strong>key同时映射到多个位置</strong>，即使发生哈希冲突，某个位置被覆盖，其它依旧存在，<strong>变相的降低了哈希冲突</strong>。</p><h5 id="7-2-数据结构及原理">7.2 数据结构及原理</h5><p>布隆过滤器，最终结构如下：一个<code>bit</code>数组，采用<strong>多个hash函数</strong>进行映射。</p><p><img src="https://i.loli.net/2021/05/28/zIxX9WcwUoT2lGK.png" alt="img"></p><h5 id="7-3-布隆函数优缺点">7.3 布隆函数优缺点</h5><ul><li><strong>优点</strong><ol><li><code>存储/插入/查询</code>时间复杂度，都是常数级别<code>O(1)</code></li><li><strong>保密性好</strong>，因为不需要存储数据本身</li><li><strong>存储数据大</strong>，可以存储非常大的数据本身</li></ol></li><li><strong>缺点</strong><ol><li>随着元素数量增加，<strong>误算率</strong>会增加</li><li><strong>不能删除</strong>元素，因为删除某个元素，要把其对应所有hash函数散列的位置如A,B，置为<code>0</code> 。其它元素的可能散列到位置A，再去判断这个元素是否存在就会出现<strong>误判</strong>。</li></ol></li></ul><h5 id="7-4-应用场景">7.4 应用场景</h5><ol><li><p><strong>解决缓存穿透</strong>，防止<strong>不存在</strong>的元素去查询数据库</p></li><li><p><strong>防止重复被攻击</strong>，用户第一次请求，将请求参数放入布隆过滤器中，当第二次请求时，先判断请求参数是否被布隆过滤器命中。可以提高缓存命中率</p></li><li><p><strong>判断用户是否阅读过某视频或文章</strong>， 比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（六）_计算机基础_Redis</title>
      <link href="/p/31215/"/>
      <url>/p/31215/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h1>六、Redis</h1><h2 id="6-1-Redis基本">6.1 Redis基本</h2><h4 id="1-什么是-Redis？">1.<strong>什么是</strong> <strong>Redis？</strong></h4><p>Redis 是一个开源（BSD 许可）、基于<u>内存（读写快）</u>、支持多种数据结构的存储系统，可以作为<u>数据库、缓存和消息中间件</u>。</p><ul><li>支持的数据结构有<strong>5</strong>种：字符串（String）、哈希（hash）、列表（list）、集合（set）、有序集合（sorted set）。</li></ul><h5 id="1-1-有MySQL不就够用了吗？为什么要用Redis这种新的数据库？">1.1 有MySQL不就够用了吗？为什么要用Redis这种新的数据库？</h5><p>主要是因为 Redis <strong>具备高性能和高并发</strong>两种特性。</p><ul><li><strong>高性能</strong>：除了第一次读取硬盘比较慢，后面加载到缓存，读取速度都相关快，性能高；</li><li><strong>高并发</strong>：直接<strong>操作缓存能够承受的并发请求是远远大于直接访问数据库</strong>的，所以我们可以考虑把数据库中的<strong>部分热点数据</strong>转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</li></ul><h5 id="1-2-C-JAVA-中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？">1.2 C++ / JAVA 中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？</h5><p>缓存分为本地缓存和分布式缓存 。</p><ul><li><strong>本地缓存不具一致性</strong>。以Java为例 ，使用自带的map或者guava实现的是本地缓存，最主要的特点是<strong>轻量以及快速</strong>，生命周期<strong>随着jvm的销毁而结束</strong>，并且在多实例的情况下，<strong>每个实例都需要各自保存一份缓存</strong>，缓存不具有一致性；</li><li><strong>Redis分布式缓存具有一致性</strong>。 使用redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性；</li><li><strong>Redis可以使用更大内存作为缓存</strong>。 Redis可以使用几十G内存作为缓存，Map不行，比如JVM最多使用几个G ；</li><li><strong>Redis可以持久化</strong>。 Redis可以实现持久化，而Map是内存对象，程序重启就没了；</li><li><strong>Redis可以处理百万级别并发；</strong></li><li><strong>Redis有丰富的API &amp; 缓存过期等机制</strong>。</li></ul><h4 id="2-【重点】redis的数据类型，以及每种数据类型的使用场景？">2. 【重点】redis的数据类型，以及每种数据类型的使用场景？</h4><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">使用场景</th></tr></thead><tbody><tr><td style="text-align:center">String</td><td style="text-align:center">存储key-value键值对，注意redis中String可修改。统计在线人数；也可以存储<strong>视频、图片</strong>等</td></tr><tr><td style="text-align:center">hash</td><td style="text-align:center">购物车：<code>hset [key] [field] [value]</code> 命令， 存放键值对，一般可以用来存某个对象的基本属性信息，例如，用户信息，商品信息等</td></tr><tr><td style="text-align:center">set</td><td style="text-align:center">全局去重，JVM自带的set不适合分布式集群情况</td></tr><tr><td style="text-align:center">zset</td><td style="text-align:center">排行榜，比如微信运动排行榜</td></tr><tr><td style="text-align:center">list</td><td style="text-align:center">分页功能，lrange做基于redis的分页功能，性能很好；模仿一个消息队列</td></tr></tbody></table><h4 id="3-说一下-Redis有什么优点和缺点-？">3.<strong>说一下</strong> <strong>Redis</strong>有什么优点和缺点 ？</h4><table><thead><tr><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center"><strong>速度快</strong>：因为在内存中</td><td style="text-align:center"><strong>存储有限</strong>：因为Redis是内存数据库，大小和机器本身内存有关</td></tr><tr><td style="text-align:center"><strong>支持多种数据结构：</strong> String，List，Set，Hash，Sorted Set等</td><td style="text-align:center">完成重同步耗费CPU资源和带宽</td></tr><tr><td style="text-align:center"><strong>持久化存储</strong>：RDB和AOF</td><td style="text-align:center"><strong>当Redis重启后</strong>通过把硬盘文件重新加载到内存，速度比较慢，这个时候redis做不了其它事。</td></tr><tr><td style="text-align:center"><strong>高可用</strong>：内置 <u>Redis Sentinel</u> （哨兵），实现主从故障自动转移。 内置 <u>Redis Cluster</u> ，提供集群方案。</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>丰富特性</strong>：Key过期、计数、分布式锁</td><td style="text-align:center"></td></tr></tbody></table><h4 id="4-Redis的数据结构？key是怎么存储的？">4. Redis的数据结构？key是怎么存储的？</h4><blockquote><p>参考：<a href="https://juejin.cn/post/6862291064624152583">【大课堂】Redis底层数据存储原理</a></p></blockquote><ul><li><p><strong>概述</strong></p><p>Redis底层采用<strong>数组</strong>， key就是对应数组的<strong>索引</strong> ，采用Hash(key)映射到数组上。解决冲突采用<strong>链地址法</strong>。</p><p>具体可看参考下文。</p></li><li><p><strong>底层存储原理</strong></p><p>redis 中以<code>redisDb</code>作为整个缓存存储的核心，保存着我们<strong>客户端需要的缓存</strong>数据。</p><p>其结构如下：</p><p><img src="https://i.loli.net/2021/05/26/tbGEW3eV986aRkj.png" alt="RedisDB主体数据结构"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span>    </span><br><span class="line">       dict *dict;           <span class="comment">// 最重要--字典类型，保存数据库的键值对</span></span><br><span class="line">       dict *expires;        <span class="comment">// 重要--字典类型，保存过期的时间          </span></span><br><span class="line">       dict *blocking_keys;  <span class="comment">// 和ready_key 实现BLPOP等阻塞命令         </span></span><br><span class="line">       dict *ready_keys;     <span class="comment">// 同上      </span></span><br><span class="line">       dict *watched_keys;   <span class="comment">// 实现watch命令，记录正在被watch的key         </span></span><br><span class="line">       <span class="keyword">int</span> id;    <span class="comment">// 数据库id，默认16个，支持单个                      </span></span><br><span class="line">       <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;    <span class="comment">/* Average TTL, just for stats */</span>      </span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>现在我们来查看，<strong>dict</strong> 的结构。</p><ul><li><p><strong>dict的结构</strong></p><p><img src="https://i.loli.net/2021/05/26/kV1JhcrUwFHLznG.png" alt="image-20210526111544663"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  字典 : 每个字典使用两个哈希表，用于实现渐进式 rehash */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span>    </span><br><span class="line">       <span class="comment">// type存储了hash函数，key和value的复制函数等，比较以及销毁函数</span></span><br><span class="line">      dictType *type;   </span><br><span class="line">      <span class="comment">// privdata保存一些私有数据，决定了*type保存的函数，实现了【多态】</span></span><br><span class="line">      <span class="keyword">void</span> *privdata;     </span><br><span class="line">      dictht ht[<span class="number">2</span>];      <span class="comment">// 哈希表（2 个）,  正常使用ht[0],rehash就会扩容使用ht[1]</span></span><br><span class="line">      <span class="keyword">int</span> rehashidx;     <span class="comment">// 记录 rehash 进度的标志，值为 -1 表示 rehash 未进</span></span><br><span class="line">      <span class="keyword">int</span> iterators;    <span class="comment">// 当前正在运作的安全迭代器数量</span></span><br><span class="line">&#125; dict;  </span><br></pre></td></tr></table></figure><p>上述<code>dictht</code>就是个hash表，包含：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span>    </span><br><span class="line">   <span class="comment">// 哈希表节点指针数组（俗称桶，bucket）    </span></span><br><span class="line">   dictEntry **table;    </span><br><span class="line">   <span class="comment">// 指针数组的大小   </span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> size;    </span><br><span class="line">   <span class="comment">// 指针数组的长度掩码，用于计算索引值，其实永远都是size-1    </span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;   </span><br><span class="line">   <span class="comment">// 哈希表现有的节点数量   </span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><ul><li><p><strong>dictEntry 指针数组（table</strong>）。key 的哈希值最终映射到这个数组的某个位置上（对应一个 bucket）。如果多个 key 映射到同一个位置，就发生了冲突，那么就拉出一个 dictEntry 链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表节点dictEntry</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span>     </span><br><span class="line">    <span class="keyword">void</span> *key;    <span class="comment">// redis的键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>        </span><br><span class="line">    <span class="keyword">void</span> *val;    <span class="comment">// 存储了对应string/set/list/hash/zset的数据     </span></span><br><span class="line">    <span class="keyword">uint64_t</span> u64;        </span><br><span class="line">    <span class="keyword">int64_t</span> s64; </span><br><span class="line">    &#125; v;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  <span class="comment">//链表后续节点</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure></li><li><p><em><strong>size</strong></em>：标识 dictEntry 指针数组的长度。它总是 2 的指数次幂。</p></li></ul><p>上面<code>dictEntry</code> 的<strong>value</strong> 最终指向了<code>redisObject</code>对象，我们来观察下其结构。</p></li><li><p><strong>Redis Object</strong></p><p><img src="https://i.loli.net/2021/05/26/kvhZQdtOuJjE6gY.png" alt="image-20210526112251563"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span>    </span><br><span class="line">     <span class="keyword">unsigned</span> type:<span class="number">4</span>;     <span class="comment">// 类型 ，比如string，set等，才能确定是哪种数据结构使用什么API操作   </span></span><br><span class="line">     <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// encoding 表示 ptr 指向的具体数据结构,这个对象使用什么数据结构实现   </span></span><br><span class="line">     <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS;  <span class="comment">// 对象最后一次被访问的时</span></span><br><span class="line">     <span class="keyword">int</span> refcount;    <span class="comment">// 引用计数         </span></span><br><span class="line">     <span class="keyword">void</span> *ptr;  <span class="comment">// 指向底层数据结构的指针 </span></span><br><span class="line"> robj;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="4-1-String、list、hash、set、zset的底层结构是什么？">4.1 String、list、hash、set、zset的底层结构是什么？</h5><blockquote><p>参考：<a href="https://i6448038.github.io/2019/12/01/redis-data-struct/">图解redis五种数据结构底层实现(动图哦)</a></p><p>版本：redis 3.0.6中版本各种数据结构的实现</p></blockquote><ol><li><p><strong>String</strong></p><ul><li>embstr和raw都是由SDS动态字符串构成的 ，底层结构应该都是<strong>char数组</strong>吧 ；</li><li>int ，就是指<strong>int类型</strong>。</li></ul><p><img src="https://i.loli.net/2021/05/26/h4mzJvU9I5BEj1o.png" alt="img"></p></li><li><p><strong>list</strong></p><p><img src="https://i.loli.net/2021/05/26/QSgDl39yIA5uXN2.png" alt="img"></p></li><li><p><strong>hash</strong></p><p><img src="https://i.loli.net/2021/05/26/9X8gPmG6MeDb4V3.png" alt="img"></p></li><li><p><strong>set</strong></p><p>intset是集合键的底层实现方式之一，是int类型数组。</p><p><img src="https://i.loli.net/2021/05/26/KXD9yHLewkIFGha.png" alt="img"></p><img src="https://i.loli.net/2021/05/26/rn3BfhLOT8dsRCH.png" alt="img" style="zoom:67%;" /></li><li><p><strong>zest</strong></p><p><img src="https://i6448038.github.io/img/redis-data-struct/object_zset.png" alt="img"></p></li></ol><h5 id="4-2-讲讲redis的hash表扩容方式？">4.2 讲讲redis的hash表扩容方式？</h5><blockquote><p>参考：<a href="https://luoming1224.github.io/2018/11/12/%5Bredis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Dredis%E6%B8%90%E8%BF%9B%E5%BC%8Frehash%E6%9C%BA%E5%88%B6/">[redis学习笔记]redis渐进式rehash机制</a></p></blockquote><ul><li><p><strong>扩容条件</strong></p><ul><li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 （<strong>保存的key超过哈希表大小</strong>）；</li><li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；</li></ul></li><li><p><strong>渐进式rehash</strong></p><ol><li><p>新建一个哈希表大小，为<code>2^N</code> 次方，并分配内存，此时字典<strong>同时持有：ht[0] 和 ht[1] 两个哈希表</strong></p><blockquote><p>同hashmap：哈希表掩码sizemask为size-1，当size满足2的n次方时，计算每个key的索引值时只需要用key的hash值与掩码sizemask进行位与操作，替代求余操作，计算更快。</p></blockquote></li><li><p>哈希表赋值给字典的ht[1]，然后将rehashidx赋值为0，表示rehash工作开始</p><blockquote><p>rehashidx也标识了，当前rehash<strong>进行到了哪个槽</strong></p></blockquote></li><li><p>在 rehash 进行期间，：每次对字典执行<strong>添加、删除、查找或者更新操作</strong>时， 程序除了执行指定的操作以外， 还会顺带将 <strong>ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]</strong> 。</p><p>当 rehash 工作完成之后， 程序将 rehashidx 属性的值**+1**</p></li><li><p>随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] 。此时<code>rehashidx=-1</code>，表示rehash完成。</p></li></ol><p>采取分而治之的方式， 将 rehash 键值对所需的计算工作<strong>均摊</strong>到对字典的每个添加、删除、查找和更新操作上， 从而<strong>避免了集中式 rehash 而带来的庞大计算量</strong>。</p></li><li><p><strong>渐进式rehas优缺点</strong></p><ul><li>优点：避免redis阻塞</li><li>缺点：rehash需要分配一个新的hash表，会使得<strong>内存爆增，使得大量key被驱逐</strong></li></ul></li></ul><h5 id="4-3-rehash过程中增删查改怎么操作呢？">4.3 rehash过程中增删查改怎么操作呢？</h5><ul><li><p><strong>增加</strong>： 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作</p></li><li><p><strong>删除（delete）、查找（find）、更新（update）等</strong>： 同时在ht[0] &amp; ht[1]两个表进行。</p><blockquote><p>比如：要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找。</p></blockquote></li></ul><h4 id="5-说说Redis有序集合zset的底层结构？">5. 说说Redis有序集合zset的底层结构？</h4><p>zset底层的存储结构包括<u>ziplist</u>或<u> skiplist &amp; dic</u> ，<strong>当满足以下两个条件的时候使用ziplist</strong>：</p><ul><li>有序集合保存的元素数量小于128个</li><li>有序集合保存的所有元素的长度小于64字节</li></ul><p>其余情况用skiplist。</p><ul><li><p><strong><a href="https://www.cnblogs.com/exceptioneye/p/7040815.html">什么是ziplist？</a></strong></p><p>ziplist是一个经过特殊编码的<u>双向链表</u>，以O(1)的时间复杂度在表的两端提供push和pop操作。</p><p>ziplist将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。</p><ul><li><p><strong>使用原因</strong>：一个普通的<u>双向链表</u>，链表中每一项都<u>占用独立的一块内存</u>，各项之间用地址指针（或引用）连接起来；这种方式会带来大量的<strong>内存碎片</strong>，而且<strong>地址指针也会占用额外的内存</strong>。</p></li><li><p><strong>具体结构</strong></p><p><img src="https://i.loli.net/2021/05/04/zYwG2PtCZq84hgV.jpg" alt="img"></p><ul><li>entry：表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构。</li></ul></li></ul></li><li><p><a href="https://segmentfault.com/a/1190000037473381"><strong>什么是skiplist ?</strong></a></p><p>跳表是在单链表上实现多级索引，<strong>可以实现 <u>二分查找</u> 的有序链表</strong>。</p><blockquote><p>跳表插入、删除、查找元素的时间复杂度跟红黑树都是一样量级的，时间复杂度都是O(logn)。</p></blockquote><ul><li><p>主要形式</p><p>在单链表上进行多级索引。</p><p><img src="https://i.loli.net/2021/05/28/Rc6tAuOmELHz5nN.png" alt="image-20210528143426041"></p></li><li><p>构建过程</p><blockquote><p>上面链表是如何构建的呢，请见下图。</p></blockquote><p>⚠️ skiplist为了避免上下两层出现<strong>严格1:2</strong>数量对应关系后，新插入节点会打乱这种关系，而需要<strong>把新插入节点后所以节点都进行调整</strong>。</p><p><strong>它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)</strong>。</p><img src="https://i.loli.net/2021/05/28/sEy7B6gUHuIfbd3.png" alt="preview" style="zoom: 67%;" /></li><li><p>查找过程</p><blockquote><p>zset : <code>&lt;key&gt; &lt;score&gt; &lt;member&gt;</code></p></blockquote><p>在上图中，我们没有区分member和score，但是实际上链表是<strong>按score进行排序，查找也是在比较score</strong>。</p><blockquote><p>以查找 和 插入23为例。</p></blockquote><ol><li>从最高层（第4）层开始查找，因为<code>7&lt;23</code> ,本应该继续往后查找，但是后继节点为null，所以往下一层进行查找</li><li>此时第3层，满足<code>7&lt;23&lt;37</code> ，继续往下一层继续查找</li><li>此时第2层，<code>7&lt;23 &amp; 19&lt;23</code> ，往下第二层的下一个节点（19）查找；此时满足<code>19&lt;23&lt;37</code> ，继续往下一层</li><li>此时第1层，一直往后遍历到22，发现<code>22&lt;23&lt;26</code> ：<ul><li>如果此时是<strong>查询23</strong>：返回null，不存在</li><li>此时是<strong>插入23</strong>：生成新节点 &amp; 随机生成层数，（1）将新节点各层指针指向对应层的<strong>下一个节点</strong>（不存在则指向null）（2）将新节点节点各层<strong>前一个节点</strong>对应层数的指针指向新节点</li></ul></li></ol></li></ul></li></ul><h5 id="5-1-Redis为什么不用红黑树">5.1 Redis为什么不用红黑树</h5><blockquote><p>参考 ： <a href="https://www.zhihu.com/question/20202931">知乎回答</a></p></blockquote><p>虽然跳表操作<strong>时间复杂度和红黑树相同</strong> ，但是：</p><ol><li><p><strong>实现简单</strong>：跳表代码实现更易读</p></li><li><p><strong>区间查找</strong>：跳表区间查找效率更高</p></li></ol><h4 id="6-Redis持久化方式有哪些？以及有什么区别？">6. <strong>Redis持久化方式有哪些？以及有什么区别</strong>？</h4><p><code>Redis</code> 提供两种持久化机制 <code>RDB</code> 和 <code>AOF</code> 机制。</p><ul><li><p><strong>各自优点</strong></p><table><thead><tr><th style="text-align:center">RDB</th><th style="text-align:center">AOF</th></tr></thead><tbody><tr><td style="text-align:center">【<strong>方便</strong>】只有一个文件 <code>dump.rdb</code> ，方便持久化</td><td style="text-align:center">【<strong>数据安全</strong>】 AOF 持久化有 <code>always</code>，每进行一次命令操作就记录到 AOF 文件中一次。</td></tr><tr><td style="text-align:center">【<strong>容灾性好</strong>】一个文件可以保存到安全的磁盘</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">【<strong>性能</strong>】最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">【<strong>启动效率高</strong>】相对于数据集大时，比 AOF 的<strong>启动效率</strong>更高</td><td style="text-align:center"></td></tr></tbody></table></li><li><p><strong>各自缺点</strong></p><table><thead><tr><th style="text-align:center">RDB</th><th style="text-align:center">AOF</th></tr></thead><tbody><tr><td style="text-align:center">【<strong>安全性低</strong>】 <code>RDB</code> 是间隔一段时间进行持久化</td><td style="text-align:center">【<strong>启动效率低</strong>】数据集大的时候，比 RDB 启动效率低。</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">【<strong>恢复慢</strong>】<code>AOF</code> 文件比 <code>RDB</code> 文件大，且恢复速度慢。</td></tr></tbody></table></li></ul><h5 id="6-1-AOF-重写了解吗？">6.1 AOF 重写了解吗？</h5><p>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，<strong>但体积更小</strong>。</p><blockquote><p>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的<strong>键值</strong>对来实现的，程序<strong>无须对现有AOF文件进行</strong>任伺读入、分析或者写入操作。</p></blockquote><p>具体过程如下：</p><ol><li>在执行 <code>BGREWRITEAOF</code> 命令，开始重写；</li><li>Redis 服务器会维护一个 AOF <strong>重写缓冲区</strong>，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令；</li><li>当子进程完成创建新AOF文件的工作之后，服务器会将重写<strong>缓冲区中的所有内容追加到新AOF文件的末尾</strong> ；</li><li>最后，服务器用新的AOF文件替换旧的 AOF文件，以此来完成AOF文件重写操作。</li></ol><h4 id="7-Redis持久化有两种，那应该怎么选择呢？">7. Redis持久化有两种，那应该怎么选择呢？</h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/39412293">https://zhuanlan.zhihu.com/p/39412293</a></p></blockquote><ol><li><strong>如果Redis中的数据完全丢弃也没有关系</strong>（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化；</li><li><strong>单机环境</strong>： 如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF；</li><li><strong>主从架构</strong>：<ul><li><strong>master</strong>：完全关闭持久化（包括RDB和AOF），这样可以让master的性能达到最好；</li><li><strong>slave：关闭RDB，开启AOF</strong>（如果对数据安全要求不高，开启RDB关闭AOF也可以），并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；然后关闭AOF的自动重写，然后添加定时任务，在每天Redis闲时（如凌晨12点）调bgrewriteaof。</li></ul></li></ol><h4 id="8-（-u-不太理解-u-）pipeline有什么好处，为什么要用-pipeline？">8. （<u>不太理解</u>）pipeline有什么好处，为什么要用 pipeline？</h4><ul><li><p>使用 pipeline（管道）的好处在于可以将多次 I/O 往返的时间缩短为一次，但是要求管道中执行的指令间没有因果关系；</p></li><li><p>用 pipeline 的原因在于可以实现请求/响应服务器的功能，当客户端尚未读取旧响应时，它也可以处理新的请求。如果客户端存在多个命令发送到服务器时，那么客户端无需等待服务端的每次响应才能执行下个命令，只需最后一步从服务端读取回复即可。</p></li></ul><h4 id="9-怎么使用-Redis实现消息队列？-如何实现延时队列？">9.<strong>怎么使用</strong> Redis实现消息队列？ 如何实现延时队列？</h4><ul><li><p><strong>消息队列</strong>：一般使用 <code>list</code> 结构作为队列， <code>rpush</code> 生产消息， <code>lpop</code> 消费消息。当 <code>lpop</code> 没有消息的时候，要适当<code>sleep</code> 一会再重试；</p></li><li><p><strong>延时队列</strong>： ：使用<code>sortedset</code> ，拿<u>时间戳</u>作为 <code>score</code> ，消息内容作为 <code>key</code> 调用 <code>zadd</code> 来生产消息，消费者用<code>zrangebyscore</code> 指令获取符合条件的数据轮询进行处理。</p><blockquote><p>什么是延时队列？</p><p>当用户发送一个消息请求给服务器后台的时候，服务器会检测这条消息是否需要进行延时处理：</p><ul><li>如果需要就放入到延时队列中，由延时任务检测器进行检测和处理；</li><li>如果不需要进行延时处理的任务，服务器会立马对消息进行处理，并把处理后的结果返会给用户。</li></ul><p>【举个例子】</p><ul><li>点外卖时，下单后不会立即安排配送，而是等待一段时间让商户接单才正式安排配送，否则超时取消</li></ul></blockquote></li></ul><h2 id="6-2-Redis单线程模型">6.2 Redis单线程模型</h2><h4 id="1-为什么-Redis-使用单线程模型？单线程模型效率也能那么高？">1.<strong>为什么</strong> <strong>Redis 使用单线程模型？单线程模型效率也能那么高</strong>？</h4><ol><li><p>采用单线程，避免了不要的上下文切换和竞争条件；</p></li><li><p><strong>其次 CPU 不是 Redis 的瓶颈</strong>，Redis 的瓶颈最有可能是机器内存或者网络带宽。</p></li></ol><p>【<strong>效率高的原因</strong>】</p><p>. 1. <strong>C语言</strong>实现，效率高</p><ol start="2"><li><p>纯<strong>内存</strong>操作</p></li><li><p><strong>基于非阻塞的IO复用模型机制</strong>（可能会跟自己挖坑）</p></li><li><p>单线程的话就能避免多线程的频繁上下文切换问题（为什么单线程效率高）</p></li><li><p>丰富的数据结构（<u>全程采用hash结构，读取速度非常快</u>，对数据存储进行了一些优化，<u>比如zset压缩表，跳表等</u>）</p></li></ol><h4 id="2-（新，易忘）说说-Redis-的单线程模型-？">2.<strong>（新，易忘）说说 Redis 的单线程模型</strong> ？</h4><blockquote><p>这问题是因为前面回答问题的时候提到了 Redis 是基于非阻塞的IO复用模型。如果这个问题回答不上来，就相当于前面的回答是给自己挖坑了。</p></blockquote><p>redis 内部使⽤⽂件事件处理器 file event handler ，这个⽂件事件处理器是单线程的，所以redis 才叫做单线程的模型。它采⽤ IO 多路复⽤机制一个线程同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进⾏处理。<br>⽂件事件处理器的结构包含 4 个部分：</p><ol><li>多个 socket</li><li>IO 多路复⽤程序</li><li>⽂件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ol><p>（1） IO 多路复⽤程序会监听多个 socket，（2）会将 socket 产⽣的事件<strong>放⼊队列中排</strong>队，（3）事件分派器每次从队列中取出⼀个事件，（4）把该事件交给对应的事件处理器进⾏处理。</p><h4 id="3-你说Redis是单线程的，那如何处理高并发？比如1000个并发请求同时发生？">3. 你说Redis是单线程的，那如何处理高并发？比如1000个并发请求同时发生？</h4><ul><li><p>Redis采用了<strong>IO多路复用机制</strong>，使其在网络IO操作中能并发处理大量的客户端请求。</p><blockquote><p>详见上一个问题。</p></blockquote></li><li><p>Redis可以采用<strong>主从架构</strong>，master负责写，slave负责读。</p></li></ul><h4 id="4-说说你对Redis事务的理解-？">4.<strong>说说你对Redis事务的理解</strong> ？</h4><p>Redis 中的事务是<strong>一组命令的集合</strong>，是 Redis 的最小执行单位。</p><blockquote><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的 Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p></blockquote><ul><li><p><strong>需要注意的地方</strong></p><ol><li><p><strong>Redis 事务不支持回滚</strong>：不像 MySQL 的事务一样，要么都执行要么都不执行；</p><blockquote><p>因为回滚需要增加很多工作，而不支持回滚则可以保持简单、快速的特性。</p></blockquote></li><li><p>Redis 服务端在执行事务的过程中，<u><strong>不会被其他客户端发送来的命令请求打断</strong></u>，直到事务命令全部执行完毕才会执行其他客户端的命令。</p></li></ol></li></ul><h4 id="5-为什么Redis的操作是原子性的，怎么保证原子性的？">5.<strong>为什么Redis的操作是原子性的，怎么保证原子性的</strong>？</h4><ul><li><strong>原子性</strong>。 因为Redis是单线程的， Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。</li><li><strong>事务性</strong>。 Redis中的事务其实是要保证<u>批量操作</u>的原子性。</li></ul><h2 id="6-3-Redis缓存">6.3 Redis缓存</h2><h4 id="1-为什么要用缓存-？怎么提高缓存命中率？">1.<strong>为什么要用缓存</strong> <strong>？怎么提高缓存命中率</strong>？</h4><ul><li><p><strong>为什么用缓存</strong>？</p><p>把热点数据存入内存中，提高读写性能。</p></li><li><p><strong>提高命中率</strong>？</p><ol><li>增加缓存空间</li><li>提升缓存更新频率</li><li>提前加载数据到缓存中</li></ol></li></ul><h4 id="2-缓存雪崩、缓存穿透、缓存击透、缓存预热、缓存更新、缓存降级等？">2.<strong>缓存雪崩、缓存穿透、缓存击透、缓存预热、缓存更新、缓存降级等</strong>？</h4><blockquote><p>参考：<a href="https://juejin.cn/post/6844904173725548557">https://juejin.cn/post/6844904173725548557</a></p></blockquote><ul><li><p><strong>缓存雪崩</strong></p><blockquote><p>简而言之：<strong>Redis 挂掉了</strong>，请求全部走数据库 。</p></blockquote><ul><li><p><strong>例如</strong>： 对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库；</p><ul><li><strong>key过期解决</strong>： 在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。</li></ul><p>更通用情况的做法：</p><ul><li><strong>事发前</strong>：实现 Redis 的<strong>高可用 (主从架构 + Redis Cluster)</strong>，尽量避免 Redis 挂掉这种情况发生；</li><li><strong>事发中</strong>：万一 Redis 真的挂了，我们可以设置<strong>本地缓存 (ehcache)+ 限流 (hystrix)</strong>，尽量避免我们的数据库被干掉；</li><li><strong>事发后：<strong>redis <strong>持久化</strong>，重启后</strong>自动</strong>从磁盘上加载数据，<strong>快速恢复缓存数据</strong>。</li></ul></li></ul></li><li><p><strong>缓存穿透</strong></p><blockquote><p>查询一个一定<strong>不存在的数据</strong> ，导致<strong>每次请求都要到数据库去查询</strong>，失去了缓存的意义 。</p></blockquote><ul><li><strong>解决1：</strong> 使用布隆过滤器 (BloomFilter) <strong>提前拦截</strong>，不合法就不让这个请求到数据库层；</li><li><strong>解决2：<strong>当我们从数据库找不到的时候，我们也将这个</strong>空对象设置到缓存里边去</strong>，下次再请求的时候，就可以从缓存里边获取了。</li></ul></li><li><p><strong>缓存击穿</strong></p><p>在平常高并发的系统中，大量的请求同时查询一个key时，此时这个<strong>高热key</strong>正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为缓存击穿。</p><ul><li><p><strong>解决1：使用互斥锁(mutex key</strong>)。 是只让一个线程构建缓存，<strong>其他线程等待构建缓存</strong>的线程执行完，重新从缓存获取数据就行。</p><blockquote><p>如果是单机，可以用synchronized或者lock来处理，如果是【<strong>淘特】分布式环境可以用分布式锁</strong>就可以了。</p><p><img src="https://i.loli.net/2021/05/06/4oRvz638eOiEFTf.png" alt="image-20210506115517283"></p></blockquote></li><li><p><strong>解决2：</strong> <strong>key永不过期</strong>。 把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建。</p><p><img src="https://i.loli.net/2021/05/06/jZ9v47kthTmADqg.png" alt="image-20210506115748032"></p></li></ul></li><li><p><strong>缓存预热</strong></p><blockquote><p>系统上线后，将相关的缓存数据直接加载到缓存系统。</p></blockquote><p>这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。</p></li><li><p><strong>缓存更新</strong></p><ul><li><code>LRU</code>(访问时间最旧淘汰)/<code>LFU</code>(把频次低的淘汰掉)</li><li>超时剔除：设置key过期时间</li><li>主动更新：开发设置生命周期</li></ul></li><li><p><strong>缓存降级</strong></p><p>降级的情况，<u>就是<strong>缓存失效或者缓存服务挂掉</strong>的情况下，我们也不去访问数据库</u>。我们<strong>直接访问内存部分数据缓存</strong>或者直接返回默认数据。</p><blockquote><p>对于应用的首页，一般是访问量非常大的地方，首页里面往往包含了部分推荐商品的展示信息。这些推荐商品都会放到缓存中进行存储，同时我们为了避免缓存的异常情况，对<strong>热点商品数据</strong>也存储到了<strong>内存</strong>中。同时内存中还保留了一些默认的商品信息。</p><p>如下图所示：</p></blockquote><p><img src="https://i.loli.net/2021/05/06/a1XZHWCterV3uR2.png" alt="image-20210506115200276"></p></li></ul><h4 id="3-Redis-设置key过期后如何处理？Redis缓存刷新策略（内存淘汰机制）有哪些？">3. Redis 设置key过期后如何处理？<strong>Redis缓存刷新策略（内存淘汰机制）有哪些</strong>？</h4><ul><li><p><strong>Redis 设置过期时间</strong></p><p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置⼀个过期时间。</p><ul><li>如我们⼀般项⽬中的 <strong>token</strong> 或者⼀些登录信息，尤其是短信验证码都是有时间限制的，过期后基本不会使用</li></ul></li><li><p><strong>过期后采用什么策略进行删除</strong>？</p><ul><li><strong>定期删除</strong>：redis默认是<strong>每隔 100ms</strong> 就<strong>随机抽取</strong>⼀些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这⾥是随机抽取的。<strong>为什么要随机呢</strong>？你想⼀想假如 redis 存了⼏⼗万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li></ul></li><li><p><strong>惰性删除</strong>：<u><strong>定期删除可能会导致很多过期 key 到了时间并没有被删除掉</strong></u>，所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存⾥，除⾮你的系统去查⼀下那个 key，才会被redis给删除掉。</p><ul><li><strong>内存淘汰策略</strong> ：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没⾛惰性删除，此时会怎么样？如果大量过期key堆积在内存⾥，导致redis内存块耗尽了。所以有内存淘汰策略。</li><li><strong>volatile-lru</strong>：从已设置过期时间的数据中挑选最近最少使⽤的数据淘汰<ul><li><p><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选<strong>将要过期的数据</strong>淘汰</p></li><li><p><strong>volatile-random</strong>：从已设置过期时间的数据中任意选择数据淘汰</p></li><li><p><strong>allkeys-lru</strong>：当内存不⾜以容纳新写⼊数据时，在键空间中，移除最近最少使⽤的key（这个是最常⽤的）</p></li><li><p><strong>allkeys-random</strong>：从数据集中任意选择数据淘汰</p></li><li><p><strong>no-eviction</strong>：禁⽌驱逐数据，也就是说当内存不⾜以容纳新写⼊数据时，新写⼊操作会报错。这个应该没⼈使⽤吧！</p></li></ul></li></ul></li></ul><h4 id="4-Redis报内存不足怎么处理？">4. Redis报内存不足怎么处理？</h4><ul><li>增加 Redis 可用内存：<ol><li>修改件 <code>redis.conf</code> 的 <code>maxmemory</code> 参数；</li><li>使用分布式集群，提高存储量；</li></ol></li><li><strong>设置缓存淘汰策略</strong>：提高内存的使用效率；</li></ul><h4 id="5-【重点】缓存和数据库谁先更新呢？-（保持缓存和数据库一致性）">5. 【<strong>重点</strong>】<strong>缓存和数据库谁先更新呢</strong>？ <strong>（保持缓存和数据库一致性</strong>）</h4><blockquote><p>参考：<a href="https://learnku.com/articles/22363">https://learnku.com/articles/22363</a></p></blockquote><ul><li><p><strong>对于读（查询）操作</strong></p><p>一般我们对<strong>读操作</strong>的时候有这么一个固定的套路：</p><ol><li>如果我们的数据在缓存里边有，那么就直接取缓存的；</li><li>如果缓存里没有我们想要的数据，我们会先去查询数据库，<u>然后将数据库查出来的数据写到缓存中</u>；</li><li>最后将数据返回给请求。</li></ol><p><strong>不用更新（写）数据库，只用更新（写）缓存</strong>。</p></li><li><p><strong>对于写操作导致双写问题</strong></p><blockquote><p><a href="https://developer.aliyun.com/article/712285">如何保证缓存(redis)与数据库(MySQL)的一致性</a></p></blockquote><p>写操作会更新数据库，那么缓存也要进行更新，此时会发生数据库和缓存不一致的问题。</p><blockquote><p><strong>键的过期时间</strong>：能保证缓存和数据库的数据最终是一致的。</p><p><u>因为只要缓存数据过期了，就会被删除</u>。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据<strong>重新写入到缓存</strong>中。<br>除了设置过期时间，我们还需要做更多的措施来尽量避免数据库与缓存处于不一致的情况发生。</p></blockquote><p>直接看结论：</p><blockquote><p>不考虑更新缓存而是<strong>直接删除缓存</strong>，因为更新逻辑较为复杂涉及到其它数据，更新cache消耗会比较大。</p></blockquote><ul><li><strong>先删除缓存，再更新数据库</strong><ul><li>在高并发下可能<strong>会导致数据长时间不一致</strong></li><li>采用<u>异步更新缓存</u>的策略，不会导致数据不一致，但在数据库更新完成之前，都需要到数据库层面去读取数据，读的效率不太好——<strong>保证了数据的一致性，适用于对一致性要求高的业务</strong></li></ul></li><li><strong>先更新数据库，再删除缓存</strong> (<strong>Cache Aside Pattern 设计模式</strong>)<ul><li>在高并发下不会导致数据长时间不一致</li><li>在<strong>更新数据库期间，cache中的旧数据会被读取</strong>，可能会有一段时间的数据不一致，但读的效率很好。——<strong>保证了数据读取的效率，如果业务对一致性要求不是很高，这种方案最合适</strong></li></ul></li></ul></li><li><p><strong>先删除缓存，再更新数据库</strong></p><blockquote><p>⚠️ <strong>只有读才会更新缓存！！</strong></p></blockquote><ul><li><p><u>正常情况</u></p><ol><li>A线程进行写操作，先淘汰缓存，再更新数据库</li><li>B线程进行读操作，发现缓存中没有想要的数据，从数据库中读取更新后的新数据 ，并更新缓存</li></ol></li><li><p><u>高并发异常</u></p><ol><li>A线程进行<strong>写</strong>操作，先淘汰缓存，但由于<u>网络原因等未及时更新数据库</u></li><li>B线程<strong>读</strong>取缓存失败，去<u>读取数据库的是旧值</u> ，并将<u>旧数据放入缓存</u></li><li>A线程再更新数据库成功（<strong>同步情况下写操作不更新redis而读操作更新redis</strong>），<u>此时缓存（旧）和数据库（新）不一致</u></li></ol><p>而且没有设置键过期，会保持很长时间的数据不一致。</p></li><li><p><u>解决方案</u></p><ul><li><strong>异步更新缓存</strong> ：B线程读操作不更新缓存，而是由<u>A线程写操作更新数据库成功后，通过binlog异步更新缓存</u></li><li><strong>延时双删</strong>： A线程<u>休眠M秒（确保事务都已提交）</u>，再更新数据库成功后，<strong>再次删除缓存</strong>。其它线程进行<strong>读</strong>操作时，缓存中无数据，从数据库中读取的是更新后的新数据，<u>又再次一致了</u>。</li></ul></li></ul></li><li><p><strong>先更新数据库，再删除缓存</strong></p><ul><li><p><u>正常情况</u></p><ol><li>A线程进行<strong>写</strong>操作，先更新数据库，再删除缓存</li><li>B线程进行<strong>读</strong>操作，发现缓存中没有想要的数据，从数据库中读取更新后的新数据 ，并更新缓存</li></ol></li><li><p><u>高并发异常</u></p><ol><li><p>A线程进行<strong>写</strong>操作，先更新数据库，<u>但未来得及删除缓存</u></p></li><li><p>B线程进行<strong>读</strong>操作，<u><strong>读取缓存的旧数据</strong>（背错一次），此时数据不一致</u></p></li><li><p>A线程再删缓存</p></li></ol><p>但其它线程进行读数据的时候更新缓存，更新缓存又一致了，<u>不一致的时间很短。</u></p><p>但是还可能会考虑：3. <strong>A线程删除缓存失败</strong> ，此后读取的一直都是旧数据了。</p></li><li><p><u>解决方案</u></p><ul><li><strong>消息队列进行删除补偿</strong>。如果Redis删除发现报错，将Redis的key作为消息发送到消息队列中，系统收到消息队列再次对Redis进行删除操作。</li></ul></li></ul></li></ul><h2 id="6-4-集群相关">6.4 集群相关</h2><h4 id="1-Redis的同步机制了解是什么？">1. Redis的同步机制了解是什么？</h4><p>Redis主从复制可以根据是否是全量分为：<u>全量同步</u>和<u>增量同步</u>。</p><blockquote><p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。</p></blockquote><ul><li><p><strong>全量同步</strong></p><p>Redis全量复制一般发生在Slave初始化阶段，这时<strong>Slave需要将Master上的所有数据都复制一份</strong>：</p><p>​       1）从服务器连接主服务器，发送<code>SYNC</code>命令；<br>　　2）主服务器接收到SYNC命名后，开始执行<code>BGSAVE</code>命令（1）生成<u>RDB文件</u>  （2）并使用<u>缓冲区记录</u>此后执行的所有<strong>写</strong>命令；<br>　　3）主服务器<code>BGSAVE</code>执行完后，向所有从服务器发送RDB快照文件，并在发送期间继续记录被执行的写命令；<br>　　4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；<br>　　5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</p></li><li><p><strong>增量同步</strong></p><p>Slave初始化后开始正常工作时：<strong>主服务器发生的写操作同步到从服务器的过程</strong>。</p><ol><li>主服务器每执行一个<strong>写命令</strong>就会向从服务器发送相同的写命令；</li><li>从服务器接收并执行收到的写命令。</li></ol></li></ul><h4 id="2-【新补充】-Redis集群架构模式有哪几种？集群的原理是什么？">2.【新补充】 <strong>Redis</strong>集群架构模式有哪几种？集群的原理是什么？</h4><blockquote><p>待补充：<a href="https://blog.csdn.net/zzhongcy/article/details/108446687">Redis 架构模式详解（单机、主从、哨兵、集群模式）</a></p></blockquote><ul><li><p><strong>1. 单机模式</strong></p><blockquote><p>QPS（每秒查询速度）大约在几万左右。</p></blockquote><p>安装一个 Redis，启动起来，业务调用即可。</p><p><img src="https://i.loli.net/2021/05/25/m5euvrDF1UOtYbn.png" alt="image-20210525232444113"></p><ul><li><strong>优点</strong>： 部署简单；成本低；高性能</li><li><strong>缺点</strong>： 单节点宕机风险 ;  单机高性能受限于 CPU 的处理能力</li></ul></li><li><p><strong>2. 主从复制</strong></p><p><img src="https://i.loli.net/2021/05/25/tGy6WCzmKpS4Mfr.png" alt="image-20210525232806643"></p><p>Redis 的复制（Replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品。</p><ul><li>被复制的服务器为主服务器（Master），而通过复制创建出来的复制品则为从服务器（Slave）。</li></ul><p>主要优缺点：</p><ul><li><strong>优点</strong>： Master/Slave 角色方便水平扩展，降低 Master <strong>读</strong>压力，转交给 Slave 节点；</li><li><strong>缺点</strong>： 可靠性保证不是很好，主节点故障便无法提供写入服务；没有解决主节点<strong>写的压力</strong> ；主节点宕机，需要人为干预。</li></ul></li><li><p><strong>3. 哨兵模式</strong></p><blockquote><p>Redis 2.8版本后引入了哨兵的概念。</p></blockquote><p><img src="https://i.loli.net/2021/05/01/81lKSUu7skhM2Yr.png" alt="img"></p><p>主从模式中，当主节点宕机之后，<strong>从节点是可以作为主节点顶上来继续提供服务</strong>，<u>但是需要修改应用方的主节点地址</u>，还需要命令所有从节点去复制新的主节点数据，整个过程需要<strong>人工干预</strong>。</p><p>为此，引入了哨兵（Sentinel）这个概念，在<strong>主从复制的基础</strong>上，哨兵实现了<strong>自动化故障恢复</strong>。哨兵模式由两部分组成，哨兵节点和数据节点：</p><ul><li><p><strong>哨兵节点</strong>：哨兵节点是特殊的 Redis 节点，不存储数据；</p></li><li><p><strong>数据节点</strong>：主节点和从节点都是数据节点。</p></li></ul><p><strong>哨兵工作原理</strong>：</p><ol><li>每个 Sentinel 以每秒一次的频率向它所知的 <strong>Master，Slave 以及其他 Sentinel</strong> 节点发送一个 <code>PING</code> 命令；</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间<strong>超过配置文件 <code>own-after-milliseconds</code> 选项所指定的值</strong>，则这个实例会被 Sentinel 标记为<strong>主观下线</strong>；</li><li>如果一个 Master 被标记为主观下线，那么正在监视这个 Master 的所有 Sentinel 要以<strong>每秒一次</strong>的频率确认 Master 是否真的进入主观下线状态；</li><li>当有<strong>足够数量的 Sentinel</strong>（大于等于配置文件指定的值）在<strong>指定的时间范围内确认</strong> Master 的确进入了主观下线状态，则 Master 会被标记为<strong>客观下线</strong>；</li><li>如果 Master 处于 <strong>ODOWN 状态</strong>，则投票自动选出新的主节点;将剩余的从节点指向新的主节点继续进行数据复制；</li><li>若没有足够数量的 Sentinel 同意 Master 已经下线，Master 的客观下线状态就会被移除。<u>若 Master 重新向 Sentinel 的 PING 命令返回有效回复</u>，Master 的主观下线状态就会被移除。</li></ol><p><u><strong>哨兵模式优缺点</strong></u>：</p><ul><li><strong>优点</strong>：（1）主从自动切换，更加健壮</li><li><strong>缺点</strong>： （1）主从切换需要时间还是会丢失数据；（2）没有解决主节点<strong>写</strong>压力 （3）动态扩容复杂</li></ul></li><li><p><strong>4. 集群模式</strong></p><blockquote><p>Redis 3.0 版本引入了Redis Cluster集群模式。</p></blockquote><img src="https://i.loli.net/2021/05/25/yfskJDK3vrzUoWp.png" alt="img" style="zoom:80%;" /><ul><li>如上图所示：该集群中包含 6 个 Redis 节点，3 主 3 从，分别为 M1，M2，M3，S1，S2，S3。除了主从 Redis 节点之间进行数据复制外，所有 Redis 节点之间采用 <strong>Gossip</strong> 协议进行通信，交换维护节点元数据信息</li></ul><p>Redis Cluster 采用<strong>无中心</strong>结构，<strong>每个节点都可以保存数据</strong>和整个集群状态，每个节点<strong>都</strong>和其他所有节点<strong>连接</strong>。</p><ul><li>Cluster 一般由多个节点组成，节点数量至少为 6 个才能保证组成完整高可用的集群，其中3个为<strong>主</strong>节点，3个为<strong>从</strong>节点；</li></ul><p><strong>4.1 Redis 集群分片概念</strong></p><blockquote><p>单机、主从、哨兵的模式数据都是存储在<strong>一个master节点</strong>上，<strong>其他节点进行数据的复制</strong>。</p><p>集群模式就是把数据进行<strong>分片</strong>存储，当一个分片数据达到上限的时候，还可以分成多个分片。</p></blockquote><p>Redis Cluster 采用<strong>虚拟哈希槽分区</strong>，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式：</p><ul><li><code>HASH_SLOT = CRC16(key) % 16384</code></li></ul><p><strong>每一个主</strong>节点负责维护一部分<strong>槽</strong>以<strong>及</strong>槽所<strong>映射的键值数据</strong>。</p><ul><li><p><strong>举例说明</strong>：</p><blockquote><p>有 3 个节点的集群环境如下</p><ul><li>节点 A 哈希槽范围为 0 ~ 5500；</li><li>节点 B 哈希槽范围为 5501 ~ 11000；</li><li>节点 C 哈希槽范围为 11001 ~ 16383。</li></ul></blockquote><p><strong>增加数据</strong>： （1）根据上述公式计算<strong>新增的key存储</strong> ，映射到相应节点（假设为B）</p><p><strong>增加节点</strong>： （1）从各个节点拿出一部分哈希槽分配到新增的D节点上即可</p><p><strong>删除节点</strong>： （1）删除A节点，只需将A节点的哈希槽移动到其它节点接口</p></li></ul><p><strong>4.2 Reids集群的主从模式</strong></p><p>Redis Cluster 为了保证数据的高可用性，加入了主从模式，<strong>一个主节点对应一个或多个从节点</strong>，主节点提供数据存取，从节点复制主节点数据备份，当这个主节点挂掉后，就会通过这个主节点的从节点选取一个来充当主节点，从而保证集群的高可用。</p><p><strong>4.3 优缺点总结</strong></p><ul><li><strong>优点</strong>： （1）无中心结构 ，<strong>多</strong>节点<strong>存储</strong>数据；（2）节点动态<strong>删除、移动</strong>数据分布方便；（3）<strong>部分节点不可用</strong>，集群依旧可用（哈希槽 + 从节点备份并故障晋升主节点）；</li><li><strong>缺点</strong>： （1）<strong>异步</strong>复制，<strong>无法保证数据一致性</strong>（2）集群搭建<strong>复杂</strong>（3）<strong><code>mget</code>,<code>pipeline</code><strong>等命令。它们需要把请求</strong>分散到多个节点执行</strong>、再聚合。节点越多，性能越低</li></ul></li></ul><h4 id="3-说说-Redis哈希槽的概念？什么情况下会导致整个集群不可用？">3.<strong>说说</strong> <strong>Redis哈希槽的概念</strong>？<strong>什么情况下会导致整个集群不可用</strong>？</h4><blockquote><p>Redis 没有使用哈希一致性算法，而是使用哈希槽。Redis 中的哈希槽一共有 16384 个，计算给定密钥的哈希槽，我们只需要对密钥的 CRC16 取摸 16384。</p></blockquote><p>假设集群中有 A、B、C 三个集群节点，<strong>不存在复制模式</strong>下，每个集群的节点包含的哈希槽如下：</p><ul><li><p>节点 A 包含从 0 到 5500 的哈希槽；</p></li><li><p>节点 B 包含从 5501 到 11000 的哈希槽；</p></li><li><p>节点 C 包含从 11001 到 16383 的哈希槽；</p></li></ul><p>这时，如果<strong>节点 B 出现故障</strong>，<u>整个集群就会出现缺少 5501 到 11000</u> 的哈希槽范围而不可用。</p><h4 id="4-Redis-常见性能问题和解决方案有哪些？">4. <strong>Redis 常见性能问题和解决方案有哪些</strong>？</h4><p>Redis 常见性能问题和解决方案如下：</p><ul><li><strong>Master不做持久化，   Slave 做 AOF</strong>：Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件；如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次；</li><li><strong>同局域网</strong>：为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内；</li><li>尽量避免在压力很大的主库上增加从库；</li><li><strong>主从复制不要用图状结构</strong>，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;-Slave3….；这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变</li></ul><h2 id="6-5-Redis-Key相关">6.5 Redis Key相关</h2><h4 id="1-假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如果将它们全部找出来？">1.<strong>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某</strong>个固定的已知的前缀开头的，如果将它们全部找出来？</h4><p>我们可以使用 keys 命令和 scan 命令，但是会发现使用 scan 更好。</p><ul><li><p><strong>keys命令</strong></p><p>虽然可以查询但不太推荐：</p><ul><li><strong>时间长且会导致线程阻塞</strong>： 时间长是因为O(N)遍历 ； 阻塞是因为Redis单线程，要等遍历完，这使得Redis要等keys执行完毕才能恢复生产（在生成环境中这是不被允许的）。</li><li><strong>没有分页功能</strong>： 一次查找所有的结果</li></ul></li><li><p><strong>scan命令</strong></p><p>推荐：</p><ul><li><p>不会阻塞，但查找出的元素可能重复，需要客户端去重下</p><blockquote><p><strong>为什么不会阻塞</strong>？</p><p>因为 scan 是通过游标方式查询的 ，查询过程中会把游标返回给客户端，单次返回空值且游标不为 0，则说明遍历还没结束，客户端继续遍历查询。</p></blockquote></li></ul></li></ul><h4 id="2-如果有大量的-key-需要设置同一时间过期，一般需要注意什么？">2.<strong>如果有大量的 key 需要设置同一时间过期，一般需要注意什</strong>么？</h4><p>如果有大量的 key 在同一时间过期，那么可能同一秒都从数据库获取数据，给数据库造成很大的压力，导致<strong>缓存雪崩</strong>。</p><ul><li><strong>解决方案</strong>： 最好给数据的过期时间加一个<strong>随机值</strong>，让过期时间更加分散</li></ul><h4 id="3-什么是-bigkey？会存在什么影响？">3.<strong>什么是</strong> <strong>bigkey？会存在什么影响</strong>？</h4><p>bigkey 是指键值占用内存空间非常大的 key。例如一个字符串 a 存储了 200M 的数据。</p><p><strong>bigkey 的主要影响有</strong>：</p><ul><li><p><strong>网络阻塞</strong>：获取 bigkey 时，传输的数据量比较大，会增加带宽的压力；</p></li><li><p>超时阻塞：因为 bigkey 占用的空间比较大，所以<u>操作起来效率会比较低</u>，导致出现阻塞的可能性增加。</p></li></ul><h4 id="4-Redis如何解决-key冲突？">4. <strong>Redis如何解决 key冲突</strong>？</h4><blockquote><p>Redis 如果 key 相同，后一个 key 会覆盖前一个 key。</p></blockquote><p>如果要解决 key 冲突，最好给 <strong>key 取好名</strong>区分开，可以按业务名和参数区分开取名，避免重复 key 导致的冲突。</p><h4 id="5-如何解决Redis的并发竞争Key问题-？">5. 如何解决Redis的并发竞争Key问题 ？</h4><blockquote><p>多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同。</p></blockquote><ul><li><p>解决方案：<strong>分布式锁</strong>（zookeeper 和 Redis 都可以实现分布式锁）。</p><ul><li><p><strong>zookeeper分布式锁</strong>：（1）每个客户端对某个方法加锁时，在zookeeper上的 与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点；（2）判断是否获取锁的方式很简单，只需要判断有 序节点中序号最小的一个；（3）当释放锁的时候，只需将这个瞬时节点删除即可。</p><blockquote><p>同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p></blockquote></li></ul></li></ul><h4 id="6-Redis删除key的底层原理实现？">6. Redis删除key的底层原理实现？</h4><blockquote><p>参考：<a href="https://www.hoohack.me/2019/06/24/redis-expire-strategy">https://www.hoohack.me/2019/06/24/redis-expire-strategy</a></p></blockquote><p>Redis在启动的时候，会注册两种事件：</p><ol><li><strong>时间事件</strong>： Redis处理后台操作的一类事件，比如客户端超时、删除过期key</li><li><strong>文件事件</strong>： redis注册的回调函数是serverCron，在<strong>定时任务（惰性删除</strong>）回调函数中，通过调用databasesCron清理部分过期key</li></ol><p><strong>定时删除</strong></p><p>对于每一个设置了过期时间的key都会创建一个<strong>定时器</strong>，一旦到达过期时间就立即删除：</p><ul><li>缺点：占用了大量的CPU资源去处理过期的数据，会影响Redis的吞吐量和响应时间。</li></ul><p><strong>惰性删除</strong></p><p><strong>每次访问key的时候</strong>，都会调用<code>expireIfNeeded</code>函数判断key是否过期，如果是，清理key：</p><ul><li>缺点：大量的过期key没有被再次访问，因此不会被清除，导致占用了大量的内存。</li></ul><p><strong>定期删除</strong></p><p>每隔一段时间，扫描Redis中过期key字典，并清除部分过期的key：</p><ul><li>缺点：折中方案</li></ul><p><strong>Redis单线程清理key的时机</strong></p><p>Redis是以<strong>单线程运行的，在清理key是不能占用过多的时间和CPU</strong>，需要在尽量不影响正常的服务情况下，进行过期key的清理。</p><ul><li><p><strong>以随机删除为例</strong></p><ol><li><p>server.hz配置了serverCron任务的执行周期，默认是10，<strong>即CPU空闲时每秒执行十次</strong>；</p></li><li><p><strong>每次清理过期key的时间不能超过CPU时间的25%</strong> ；</p></li><li><p>如果是快速清理模式（在beforeSleep函数调用），则一次清理的最大时间是1ms；</p></li><li><p>依次遍历所有的DB；</p></li><li><p>从db的过期列表中随机取20个key，判断是否过期，如果过期，则清理；</p></li><li><p>如果有5个以上的key过期，则重复步骤5，否则继续处理下一个db ；</p></li><li><p>在清理过程中，如果达到CPU的25%时间，退出清理过程。</p></li></ol></li><li><p><strong>Redis4.0使用BIO处理</strong></p><p>Redis4.0以前，删除指令是del，del会直接释放对象的内存，但是，如果删除的key是一个<strong>非常大的对象</strong>，那么删除操作就会导致单线程卡顿，Redis的响应就慢了。</p><ul><li>在Redis4.0版本引入了unlink指令，能对删除操作进行“懒”处理，<strong>将删除操作丢给后台线程，由后台线程BIO来异步回收内存</strong>。</li></ul></li></ul><p><strong>内存淘汰策略</strong></p><p>Redis的内存淘汰策略，是指内存达到maxmemory极限时，使用某种算法来决定清理掉哪些数据，以保证新数据的存入。</p>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 校招 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（五）_计算机基础_MySQL</title>
      <link href="/p/56848/"/>
      <url>/p/56848/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h1>五、MySQL</h1><h2 id="5-1-MySQL基本">5.1 MySQL基本</h2><h4 id="0-关系型数据库和非关系数据库的区别？">0. 关系型数据库和非关系数据库的区别？</h4><ul><li><strong>关系型数据库的优点</strong><ul><li>容易理解，因为它采用了关系模型来组织数据；</li><li>可以<strong>保持数据的一致性</strong>；</li><li>数据<strong>更新的开销比较小</strong>；</li><li><strong>支持复杂查询</strong>（带where子句的查询）。</li></ul></li><li><strong>非关系型数据库的优点</strong><ul><li>不需要经过SQL层的解析，<strong>读写效率高</strong>；</li><li><strong>基于键值对</strong>，数据的扩展性很好；</li><li><strong>支持多种类型数据的存储</strong>，如图片，文档等等。</li></ul></li></ul><h4 id="1-介绍一下数据库三范式？">1.<strong>介绍一下数据库三范式</strong>？</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html">https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html</a></p></blockquote><ul><li><p><strong>第一范式</strong>： 数据库表中的<u>所有字段值都是不可分解的原子值</u> 。</p><blockquote><p>数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要<u>将“地址”这个属性重新拆分为省份、城市、详细地址</u>等多个部分进行存储。</p><p><img src="https://i.loli.net/2021/05/03/NiPm9KajxLXpRQf.png" alt="img"></p></blockquote></li><li><p><strong>第二范式</strong>： 第二范式基于第一范式，且要求：<u>数据库表中的每一列都和主键相关，且不能只与主键的某一部分相关</u>（主要针对联合主键而言）, 即<strong>不存在部分依赖</strong>；</p><blockquote><p>下表是以：<u>订单编号&amp;商品编号</u>作为联合主键。这样在该<strong>表中商品名称、单位、商品价格等信息不与该表的订单编号相关</strong>，而仅仅是与商品编号相关。</p><p><img src="https://i.loli.net/2021/05/03/RoCLmOBcgJKhvyx.png" alt="img"></p><p>所以根据第二范式，将它进行拆分三个表：</p><p><img src="https://i.loli.net/2021/05/03/TnN8t5k3lrWxIgp.png" alt="img"></p></blockquote></li><li><p><strong>第三范式</strong>： 基于第二范式，数据表中的每一列数据都和主键<strong>直接相关</strong>，即<strong>不存在传递依赖</strong>；</p><blockquote><p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/2012040114105477.png" alt="img"></p></blockquote></li></ul><h4 id="2-MySQL数据库引擎有哪些？">2. <strong>MySQL数据库引擎有哪些</strong>？</h4><blockquote><p>MySQL查看所有的数据引擎：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engines;</span><br></pre></td></tr></table></figure></blockquote><p>MySQL常用引擎包括：<code>MYISAM</code>、<code>Innodb</code>、<code>Memory</code>、<code>MERGE</code>，</p><ul><li><p><strong><code>MYISAM</code></strong> （读：my+i+son）</p><p>以select、insert为主的应用基本上可以使用这引擎。</p><ul><li><strong>优点</strong>：<strong>全表锁</strong>，拥有较高的执行速度，占用空间小；</li><li><strong>缺点</strong> ：不支持事务，不支持外键，并发性能差。</li></ul></li><li><p><strong><code>Innodb</code></strong></p><p>Innodb引擎提供了对数据库ACID<strong>事务</strong>的支持，并且实现了SQL标准的四种隔离级别，它的设计目标是<u>处理大容量数据库系统</u>。</p><ul><li><strong>优点</strong>：<strong>行级锁</strong>，<strong>支持事务</strong>，支持<u><strong>自动增长列</strong></u>，支持外键约束，<strong>并发能力强</strong></li><li><strong>缺点</strong>： 占用空间是MYISAM的2倍，处理效率相对也更低</li></ul></li><li><p><strong><code>Memory</code></strong></p><p>主要用于<strong>内容变化不频繁的</strong>代码表。</p><ul><li><strong>优点</strong>：<strong>全表锁</strong>，<u>存储在内存中，默认使用Hash，检索效率非常高</u></li><li><strong>缺点</strong>： 会占用和数据量成正比的内存空间且，mysql重启时会丢失，不适合精确查找</li></ul></li><li><p><strong><code>MERGE</code></strong></p><p>是一组MYISAM表的组合。</p></li></ul><h5 id="2-1-InnoDB、MyISAM、Memory-【索引】（按数据结构分）">2.1 InnoDB、MyISAM、Memory 【索引】（按数据结构分）</h5><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000037683781">https://segmentfault.com/a/1190000037683781</a></p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210820194526488.png" alt="image-20210820194526488"></p><h5 id="2-2-为什么Innodb使用自增id作为主键？">2.2 为什么Innodb使用自增id作为主键？</h5><ul><li><strong>如果不使用自增主键</strong>， 如身份证号、学号，每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置（<strong>涉及到B+树分裂等</strong>）， 频繁的移动、分页操作造成了大量的碎片；</li><li><strong>如果使用自增主键，</strong> 那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。</li></ul><h4 id="3-说说InnoDB与MyISAM的区别？">3.<strong>说说InnoDB与MyISAM的区别</strong>？</h4><p>见前。</p><h5 id="3-1-说说InnoDB与MyISAM在B-数索引方式区别？">3.1 说说InnoDB与MyISAM在B+数索引方式区别？</h5><ul><li><p><strong>MyISAm</strong> , B+Tree叶节点的data域存放的是数据<strong>记录的地址</strong>，在索引检索的时候，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引” ；</p></li><li><p><strong>InnoDB，</strong> 树的节点data域保存了完整的数据记录，这个索引的<strong>key是数据表的主键（自增id）</strong> ；而<strong>其它索引都叫做辅助索引</strong>， 助索引的data域存储相应记录<strong>主键的值</strong>而不是记录地址。</p><blockquote><ul><li>在根据主索引搜索时，直接找到key所在的节点即可取出数据；</li><li>在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</li></ul></blockquote></li></ul><h5 id="3-2-【百度】说说InnoDB与MyISAM在适用场景上的区别？">3.2 【百度】说说InnoDB与MyISAM在适用场景上的区别？</h5><ul><li><strong>MyISAM</strong> ，没有事务， 适合<strong>插入不频繁，查询非常频繁</strong>；</li><li><strong>Innodb：</strong> 有事务，适合<strong>可靠性要求比较高</strong>，或者<strong>更新和查询比较频繁</strong>。</li></ul><h4 id="4-为什么-SELECT-COUNT-FROM-table-在-InnoDB-比MyISAM-慢？">4. 为什么 SELECT COUNT(*) FROM table 在 InnoDB 比MyISAM 慢？</h4><p>对于 SELECT COUNT(*) FROM table 语句，在没有 WHERE 条件的情况下，InnoDB 比 MyISAM 可能会慢很多，尤其在大表的情况下。</p><ul><li>InnoDB 是去实时统计结果，会<strong>全表扫描</strong>；</li><li>而 MyISAM内部维持了一个<u><strong>计数器</strong></u>，<strong>预存了结果</strong>，所以直接返回即可。</li></ul><h4 id="5-简单说一说drop、delete与truncate的区别？">5.<strong>简单说一说drop、delete与truncate的区别</strong>？</h4><p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别：</p><ul><li><strong>删除类型</strong>： drop删除表结构；delete、truncate删除表内容。</li><li><strong>删除速度</strong>：  <strong>drop</strong>&gt; truncate &gt;delete</li><li><strong>生效速度</strong>： drop和truncate ，操作立即生效，不能回滚也不触发触发器；<strong>delete事务提交后才生效，会触发相应触发器</strong>。</li></ul><h4 id="6-什么是视图？-游标？">6.<strong>什么是视图</strong>？ 游标？</h4><p>视图是一种虚拟的表，通常是一个表或者多个表的行或列的子集，具有和物理表相同的功能。</p><ul><li>可以对视图进行增，改，查，操作，但<strong>对视图的修改不影响基本表</strong>；</li><li>相比多表查询，获取数据速度更容易。</li></ul><p>游标，是对<strong>查询出来的结果集</strong>作为一个单元来有效的处理。</p><ul><li>一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</li></ul><h4 id="7-什么是内联接、左外联接、右外联接？">7.<strong>什么是内联接、左外联接、右外联接</strong>？</h4><ul><li><p><strong>内联接（Inner Join）</strong>：两个表（或连接）中某一数据项相等的连接称为内连接。 连接的结果是形成一个新的数据表。 内连接中参与连接的表（或连接）的地位是相等的；</p></li><li><p><strong>左外联接（Left Outer Join</strong>）：除了匹配2张表中相关联的记录外，<u>还会匹配左表中剩余的记录</u>，<u>右表中未匹配到的字段用NULL表示</u>；</p></li><li><p><strong>右外联接（Right Outer Join）</strong>：除了匹配2张表中相关联的记录外，还会<u>匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示</u>。</p></li></ul><h4 id="8-说说在-MySQL-中一条查询-SQL-是如何执行的？">8.<strong>说说在 MySQL 中一条查询 SQL 是如何执行的</strong>？</h4><p>例如：<code>select name from t_user where id=1</code></p><ol><li><p><strong>取得链接</strong>，使用使用到 MySQL 中的<strong>连接器</strong>；</p></li><li><p><strong>查询缓存</strong>，key 为 SQL 语句，value 为查询结果，如果查到就直接返回；</p><blockquote><p>在 MySQL 8.0 版本已经将查询缓存删除，也就是说 MySQL 8.0 版本后不存在此功能。</p></blockquote></li><li><p><strong>分析器</strong>，分为词法分析和语法分析。此阶段只是做一些 SQL 解析，语法校验。所以一般语法错误在此阶段；</p></li><li><p><strong>优化器</strong>，是在表里<strong>有多个索引的时候，决定使用哪个索引</strong>；或者一个语句中存在多表关联的时候（join），决定<strong>各个表的连接顺序</strong>；</p></li><li><p><strong>执行器</strong>，开始执行语句。执行语句的时候还要判断是否具备此权限，如果有权限：（1）根据表的引擎定义，使用引擎提供的接口，获取表的第一行，判断id是否等于1 ；（2）如果不是则继续调用引擎接口去获取下一行，继续判断；（3）直至取到这个表的最后一行</p></li></ol><h4 id="9-MySQL-中-varchar-与-char-的区别？-int-3-呢？">9. <strong>MySQL 中 varchar 与 char 的区别</strong>？ int(3) 呢？</h4><ul><li><p>char 是一种固定长度的类型，varchar 则是一种可变长度的类型。</p><p><img src="https://i.loli.net/2021/05/03/SoHv6lyhp94TwWP.png" alt="image-20210503214113219"></p></li><li><p><strong>float(3,2) 和 int(3)</strong></p><ul><li><code>float(3,2)</code> : &quot;浮点型&quot;的长度是用来<strong>限制数字存储范围</strong>的。比如 float(3,2) 只能够写入 <code>0.00~999.99</code>。</li><li><code>int(3)</code> ：&quot;整型&quot;的长度并<strong>不会限制存储的数字范围</strong>，都是<code>-2147483648 ~ 2147483647</code> 。只<strong>限制显示长度</strong>。</li></ul></li></ul><h4 id="10-超键、主键、候选键和外键有什么区别？">10.<strong>超键、主键、候选键和外键有什么区别</strong>？</h4><ul><li><strong>超键(super key)</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键；</li><li><strong>候选键(candidate key)</strong>：不含有多余属性的超键称为候选键，<u>是超键的子集</u>；</li><li><strong>主键(primary key)</strong>：用户选作元组标识的一个候选键程序主键，<u>是候选键的子集</u> ；</li><li><strong>外键</strong>：如果关系模式<strong>R中属性K是其它模式的主键</strong>，那么<strong>k在模式R中称为外键</strong>。</li></ul><p>下面举例说明（<strong>假设姓名不重复唯一</strong>）：</p><table><thead><tr><th style="text-align:center">身份证</th><th style="text-align:center">姓名</th><th style="text-align:center">性别</th><th style="text-align:center">年龄</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><ul><li><u>超键：</u> 身份证、姓名、（姓名、性别）、（姓名、性别、年龄）都可以作为超键；</li><li><u>候选键</u> ：身份证、姓名 都唯一，都可以作为候选键；</li><li><u>主键：</u> 在候选键选一个作为主键，例如：身份证。</li></ul><h4 id="11-解释⼀下什么是池化设计思想。什么是数据库连接池-为什么需要数据库连接池">11.  解释⼀下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?</h4><ul><li><p><strong>池化设计思想</strong></p><p>我们常⻅的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会<u>初始预设资源</u>，<strong>解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销</strong>等。</p></li><li><p><strong>数据库连接池</strong></p><p>数据库连接本质就是⼀个 <strong>socket</strong> 的连接。数据库服务端还要维护⼀些缓存和⽤户权限信息之类的所以<strong>占⽤了⼀些内存</strong>。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以<strong>重⽤这些连接</strong>。</p></li><li><p><strong>为什么要用数据库连接池</strong>？</p><p>为每个⽤户打开和维护数据库连接，尤其是对动态数据库驱动的网站应⽤程序的请求，既昂贵⼜浪费资源。在连接池中，创建连接后，将其放置在池中，并再次使⽤它，因此不必建⽴新的连接。如果使⽤了所有连接，则会建⽴⼀个新连接并将其添加到池中。</p></li></ul><h4 id="12-如果数据不存储在磁盘而是在内存，用什么数据结构？为什么Mysql不使用hash？">12. 如果数据不存储在磁盘而是在内存，用什么数据结构？为什么Mysql不使用hash？</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/wangtao_20/p/3643994.html">为什么hash作为内存使用的经典数据结构?</a></p></blockquote><p>数据放在磁盘，使用<strong>B+树</strong>，<strong>核心是为了减少磁盘IO</strong>，因为磁盘IO的代价很大（是内存的十万倍）。</p><p>我们使用<strong>hash</strong>寻找数据的时候，<strong>数据随机分散到各个物理位置</strong>，不是有序的数据。而<strong>内存设备也是随机访问设备</strong>，内存很适合用hash方式来读取数据。</p><ul><li><p><strong>随机访问</strong>：存储器单元的内容可以根据需要自由取出或存储，而且<strong>访问的速度与存储器单元的位置</strong>无关 。(通过行，列地址总线就可以快速定位存储的数据)</p><blockquote><p>但是磁盘，每次访问数据，是需要先定位，然后<strong>顺序</strong>移动；如果下个数据不在磁头附近，又要重新定位。</p><p>如果Hash索引磁盘数据，（1）每次访问都要IO<strong>不能范围</strong>（2）数据太多，Hash索引保存不了键值，而<strong>高度为3的B+数就能保存千万级别的数据</strong>（3）当数据量很大时，<strong>hash冲突</strong>的概率也会非常大（4）组合索引可以支持部分索引查询，如(a,b,c)的组合索引，查询中只用到了阿和b也可以查询的，如果使用hash表，组合索引会将几个字段合并hash，<strong>没办法支持部分索引</strong> （5）当需要按照索引进行order by时，hash值<strong>没办法支持排序</strong> 。</p></blockquote></li></ul><h4 id="13-【字节】Mysql-Join的原理？">13.【字节】Mysql Join的原理？</h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/54275505">https://zhuanlan.zhihu.com/p/54275505</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user tb1 left join level tb2 on tb1.id=tb2.user_id</span><br></pre></td></tr></table></figure><ol><li><p><strong>简单嵌套循环</strong></p><p><strong>双层for 循环</strong> ，通过循环外层表的行数据，逐个与内层表的所有行数据进行比较来获取结果。</p><img src="https://i.loli.net/2021/09/04/u3LJnMgZsIV6Atd.png" alt="image-20210904063419237" style="zoom:50%;" /></li><li><p><strong>索引嵌套循环连接</strong></p><p>通过外层表匹配条件<strong>直接与内层表索引进行匹配</strong>，避免和内层表的每条记录去进行比较， 这样极大的减少了对内层表的匹配次数。</p><ul><li>从原来的匹配次数=外层表行数 * 内层表行数,变成了 外层表的行数 * 内层表索引的高度，极大的提升了 join的性能；</li><li>注意，<strong>要为表user_level 去建立索引</strong></li></ul><img src="https://i.loli.net/2021/09/04/1gkP9upMosUtYS4.png" alt="image-20210904063546011" style="zoom:80%;" /></li><li><p><strong>缓存块嵌套循环连接</strong></p><p>其优化思路是<strong>减少内层表的扫表次数</strong>。</p><ul><li>通过简单的嵌套循环查询的图，我们可以看到，左表的每一条记录都会对右表进行一次扫表，扫表的过程其实也就是<strong>从内存读取数据</strong>的过程，那么这个过程其实是比较消耗性能的。</li></ul><p><img src="https://i.loli.net/2021/09/04/s1nE7IzYZ6TGlkK.jpg" alt="img"></p><p>所以缓存块嵌套循环连接算法意在通过<strong>一次性缓存外层表的多条数据</strong>，以此来减少内层表的扫表次数，从而达到提升性能的目的。如果无法使用<strong>Index Nested-Loop Join</strong>的时候，数据库是默认使用的是<strong>Block Nested-Loop Join算法的</strong>。</p><ul><li><strong>当level 表的 user_id 不为索引</strong>的时候，默认会使用Block Nested-Loop Join算法。</li></ul><p><img src="https://i.loli.net/2021/09/04/iP9o6OpU8ZxcIwF.jpg" alt="img"></p></li></ol><h5 id="13-1-join和left-join区别">13.1 join和left join区别?</h5><p><strong>join相当于我们平时用的where</strong>，就是把两张表中同时满足a.id=b.id的数据找出来；</p><p>left join是以左表（a）为参考对象，相当于做一个for循环，把a表的数据一条一条的读取出来，然后根据a.id=b.id的条件到b表中查找数据。</p><h5 id="13-2-unio和unio-all的区别">13.2 unio和unio all的区别?</h5><p>如果我们需要将<strong>两个select语句的结果作为一个整体显示出来</strong>，我们就需要用到union或者union all关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select employee_id,job_id from employees union select employee_id,job_id from job_history</span><br></pre></td></tr></table></figure><p><strong>union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来</strong>，不管是不是重复。</p><h5 id="13-3-unio-和-join的区别">13.3 unio 和 join的区别?</h5><blockquote><p>参考：<a href="https://www.jb51.net/article/30975.htm">https://www.jb51.net/article/30975.htm</a></p></blockquote><p>join是对两个表进行联合，相当于where，满足条件的行会被选出，<strong>其中列会被扩充！</strong>  但unio是连接结果集，需要满足列个数相同，<strong>只会保存第一个表列个数，列个数不会被扩充！</strong></p><h2 id="5-2-分布式数据库">5.2 分布式数据库</h2><h4 id="0-【字节】分布式数据库锁如何实现？">0. 【字节】分布式数据库锁如何实现？</h4><ul><li><strong>什么时候用到分布式数据库</strong>？<ol><li><strong>水平拆分</strong> <strong>：数据量大到单机数据库已存储不下</strong>时， 可以对数据进行拆分，化整为零，将数据均匀分布到多个数据库节点中。</li><li><strong>读写分离</strong>：主要用在<strong>数据量并不大</strong>，单机数据库能够hold得住，<strong>但读请求很高</strong>的情况下。此时，可以配置多个只读数据库节点，来分担主节点的读请求。通过数据复制机制，<strong>在主节点和只读节点之间进行数据的实时同步</strong>，保证主从节点的数据一致性。</li></ol></li><li><strong>分布式数据库锁</strong>？<ol><li><strong>直接锁表</strong>，代价比较大</li><li><strong>加入排它锁</strong>，查询语句后面增加<strong>for update</strong>（这里我们希望使用行级锁，就要给method_name添加索引）</li><li><strong>Zookeeper实现分布式锁</strong></li></ol></li></ul><h4 id="1-请说说MySQL数据库的锁？">1.请说说MySQL数据库的锁？</h4><p><img src="https://i.loli.net/2021/05/24/S7HoKh8EcpXT1Mz.png" alt="img"></p><p>MySQL 中常见锁如下：</p><p>【<u>按使用方式划分</u>】</p><ul><li><p><strong>共享锁</strong>：不堵塞，多个用户可以同一时刻<strong>读取</strong>同一个资源，相互之间没有影响；</p></li><li><p><strong>排它锁（写锁</strong>）：<u>一个写操作阻塞其他的读锁和写锁</u>，<strong>只允许一个用户进行写入</strong>，<strong>防止其他用户读取正在写入的资源</strong>。</p></li></ul><p>【<u>按锁粒度划分</u>】</p><ul><li><p><strong>表锁</strong>：系统开销最小，会锁定整张表，<u>不会出现死锁</u>；但是由于粒度太大，因此造成锁的冲突几率大，并发性能低。<strong>MyISAM 使用表锁。</strong></p></li><li><p><strong>行锁</strong>：<u>容易出现死锁</u>，发生冲突概率低，并发性能高。<strong>InnoDB 支持行锁</strong>。</p><blockquote><p><strong>必须有索引才能实现</strong>，否则会自动锁全表，那么就不是行锁。</p></blockquote></li></ul><p>【<u>按思想划分</u>】</p><ul><li><strong>乐观锁</strong></li><li><strong>悲观锁</strong></li></ul><h4 id="2-说说什么是锁升级？什么情况发生锁升级？">2.<strong>说说什么是锁升级？什么情况发生锁升级</strong>？</h4><blockquote><p>区分一下sycronized锁升级。</p></blockquote><p>锁升级是指将当前锁的粒度降低：<code>行锁→页锁→表锁</code>。</p><p>发生锁升级的情况：</p><ol><li>当一条SQL语句对<u>同一个对象</u>上持有的锁数量超锁了阈值，默认这个阈值为5000，<strong>但是对于不同对象不会发生锁升级</strong></li><li>锁资源占用的内存超过<u>激活内存</u>的百分之40 就会发生锁升级</li></ol><h5 id="2-1-为什么说innoDB-引擎不存在锁升级的问题-？">2.1 为什么说innoDB 引擎不存在锁升级的问题 ？</h5><p>待补充。</p><h5 id="2-2-什么时候触发行锁和表级锁？">2.2 什么时候触发行锁和表级锁？</h5><p>mysql默认存储引擎都是<strong>innodb</strong>，默认是使用<strong>行锁</strong> 。</p><ul><li><p>触发行级锁 ，<strong>行级锁锁的是索引记录</strong> ，使用了索引所以就会触发行级锁。</p></li><li><p>触发表级锁，有以下三种情况</p><blockquote><p>其实不管是读操作(select)还是写操作(update,delete,insert),只要涉及到带有筛选条件的语句，<strong>如果筛选条件中没有用到索引</strong>，就会触发全表扫描。</p></blockquote><ol><li><strong>全表更新</strong>：事务<strong>需要更新大部分数据或全部数</strong>据，如果使用行级锁，会导致事务执行效率低，从而导致其他事务长时间等待锁和更多的锁冲突</li><li><strong>多表级联：事务涉及多张表</strong>，比较复杂的关联查询，很可能造成死锁，这种情况若能一次性锁住事务涉及的表，从而避免死锁，减少数据库事务回滚所带来的开销</li><li><strong>筛选条件中未用到索引</strong>： 全表扫描</li><li><strong>用到索引，但区分度程度不高</strong> ：innodb认为全表扫描比走索引效率更高导致索引失效，这个时候就要通过explain去查看下查询计划，看下查询语句是否真的用到了索引</li></ol></li></ul><h5 id="2-3-行锁适合的场景？">2.3 行锁适合的场景？</h5><p>A用户消费，service层先查询该用户的账户余额，若余额足够，则进行后续的扣款操作；这种情况查询的时候应该对该记录进行加锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for update # 操作该记录时加上</span><br></pre></td></tr></table></figure><p>否则，B用户在A用户查询后消费前先一步将A用户账号上的钱转走，而此时A用户已经进行了用户余额是否足够的判断，则可能会出现余额已经不足但却扣款成功的情况。</p><h4 id="3-怎样尽量避免死锁的出现？">3.<strong>怎样尽量避免死锁的出现</strong>？</h4><ol><li><p><strong>设置获取锁的超时时间</strong>，至少能保证最差情况下，可以退出程序，不至于一直等待导致死锁；</p></li><li><p><strong>设置按照同一顺序访问资源</strong>，类似于串行执行；</p></li><li><p><strong>避免事务中的用户交叉</strong>；</p></li><li><p>保持事务简短并在一个批处理中；</p></li><li><p>使用<strong>低隔离级别</strong>。</p></li></ol><h4 id="4-解释一下悲观锁和乐观锁？">4.<strong>解释一下悲观锁和乐观锁</strong>？</h4><ul><li><p><strong>悲观锁</strong>： 悲观锁是基于一种悲观的态度类来防止一切数据冲突。它是以一种预防的姿态 <u>在修改数据之前把数据锁住</u>，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作。一般数据库本身锁的机制都是基于悲观锁的机制实现的。</p><ul><li><p><strong>特点</strong>： 完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁；但是造成性能消耗</p></li><li><p><strong>实现</strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 加读锁</span><br><span class="line">LOCK tables test_db READ </span><br><span class="line"># 释放锁</span><br><span class="line">UNLOCK TABLES</span><br><span class="line"># 加写锁</span><br><span class="line">LOCK tables test_db WRITE </span><br><span class="line"># 释放锁</span><br><span class="line">UNLOCK TABLES</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>乐观锁</strong>： 对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁，使得<u>多个任务可并行对数据操作</u>。但是<u>使用一种验证机制来避免数据冲突</u> （一般通过加版本后对比来实现）。</p><ul><li><p><strong>特点</strong>： 并发类型的锁，<u>本身不加锁但通过业务实现锁的功能</u> ，没有锁操作因此性能更高。</p></li><li><p><strong>实现形式</strong>：</p><p>（1）两个请求同时操作操作标Name字段，二者查询需检索的数据都是一样的：</p><p><img src="https://i.loli.net/2021/04/20/H6wyLdqZN8BJipx.png" alt="img"></p><p>（2）请求1修改字段数据<code>“zhangsan”→“lisi”</code> ，并将版本号增加+1 ，验证版本号一直后提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update A set Name=lisi,version=version+1 where ID=#&#123;id&#125; and version=#&#123;version&#125;</span><br></pre></td></tr></table></figure><p>（3）请求2也想修改<code>“zhangsan”→“liming”</code>  ，但是提交时由于 <u>版本号不一致，无法提交成功</u></p></li></ul></li></ul><h5 id="4-1-数据库乐观锁和悲观锁，如何实现？">4.1 数据库乐观锁和悲观锁，如何实现？</h5><ul><li><p><strong>实现乐观锁</strong></p><ol><li><p>利用版本号，如MVCC；</p></li><li><p><strong>时间戳</strong>：同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似。</p><p>也是在更新提交的时候，将当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</p></li></ol></li><li><p><strong>实现悲观锁</strong></p><p>直接加上读锁或者写锁，SELECT … FOR UPDATE 。</p></li></ul><h4 id="5-介绍一下分布式数据库全局ID唯一且自增，如何生成？-（或者问分库分表之后，id-主键如何处理？）">5.<strong>介绍一下分布式数据库全局ID唯一且自增，如何生成</strong>？ （<strong>或者问分库分表之后，id 主键如何处理</strong>？）</h4><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要⼀个全局唯⼀的 id来支持。</p><ol><li><p><strong>UUID</strong>：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。</p></li><li><p>ID自增量为<u>分布式数据库个数</u>，缺点是扩展性不好；</p></li><li><p><a href="https://www.cnblogs.com/jiangxinlingdu/p/8440413.html">snow flake算法</a>：snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。</p><p><img src="https://pic3.zhimg.com/80/v2-b3a91b9e3f6468be39f3dc3345e9f4f2_720w.jpg" alt="img"></p><ul><li><strong>核心思想</strong>： 使用41bit作为毫秒数，10bit作为机器的ID（<strong>5个bit是数据中心，5个bit的机器ID</strong>），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 <u>不同ID</u>），最后还有一个符号位，永远是0。</li></ul></li><li><p><a href="https://blog.csdn.net/minkeyto/article/details/104943883">Leaf算法</a>：分号段</p></li></ol><h4 id="8-介绍一下哈希算法？和一致性哈希算法？">8.<strong>介绍一下哈希算法？和一致性哈希算法</strong>？</h4><ul><li><p><strong>哈希算法</strong></p><ul><li><strong>介绍</strong>： 哈希算法<u>将任意长度的二进制值映射为较短的固定长度的二进制值</u>，这个小的二进制值称为<strong>哈希值</strong>。哈希值是一段数据唯一且<strong>极其紧凑的数值表示形式</strong>。</li><li><strong>分布式应用中缺点</strong>： 在分布式的存储系统中，<u>要将数据存储到具体的节点上</u>。如果采用哈希算法：<code>key%N</code>（key是数据的key，N是机器节点数） 。出现机器加入或退出集群（<strong>N变了，映射值不一样了</strong>），所有的数据映射都无效了。</li></ul></li><li><p><strong>一致性哈希算法</strong></p><ul><li><p><strong>介绍</strong>：解决普通哈希算法造成负载均衡时，在<strong>服务节点数量变动</strong>时出现<strong>哈希失效</strong> 问题</p></li><li><p><strong>实现</strong>：</p><ol><li><p><strong>构建环</strong>：按照常用的hash算法来将对应的key哈希到一个具有<strong>2^32</strong>次方个节点的空间中（即0 ~ (2^32)-1）。</p><blockquote><p>Note: 节点的个数可以自定义, hash环我们可以用TreeMap来实现, 因为treeMap是排序的，我们刚好可以利用上。</p></blockquote><img src="https://i.loli.net/2021/04/20/Al6k3ZmHJO2qbe9.jpg" alt="img" style="zoom:50%;" /></li><li><p><strong>映射服务器节点</strong>： 将各个服务器使用Hash进行一个哈希，确定每台机器其在哈希环上的位置。</p><blockquote><p>一般用服务器ip或唯一主机名进行哈希。</p></blockquote><img src="https://i.loli.net/2021/04/20/1ZKalnT9CStVc8s.jpg" alt="img" style="zoom:50%;" /></li><li><p><strong>映射数据。</strong> 对于要存储的数据：<code>ojectA、objectB、objectC、objectD</code> ，首先通过特定哈希函数计算出<code>hash</code>值 ，散列到环上。然后从数据所在位置<u>沿环顺时针“行走”</u>，第一台遇到的服务器就是其应该定位到的服务器。</p><img src="https://i.loli.net/2021/04/20/SwUijYkyJPp34v1.jpg" alt="img" style="zoom:50%;" /></li><li><p><strong>出现服务器变动。</strong> 如果此时NodeC宕机了，此时Object A、B、D不会受到影响，只有Object C会重新分配到Node D。<u>避免了大量数据迁移，减小了服务器的的压力</u> 。</p></li></ol></li></ul></li></ul><h4 id="9-（再理解）介绍一下MVVC？">9. （再理解）介绍一下MVVC？</h4><p>MVCC（Multi-Version Concurrency Control）多版本并发控制，是</p><p>数据库控制并发访问的一种手段。</p><blockquote><ul><li>特别要注意<strong>MVCC</strong>只在<strong>读已提交(RC)</strong> 和<strong>可重复读（RR）</strong> 这两种事务隔离级别下才有效</li><li>是<strong>数据库引擎（InnoDB）</strong> 层面实现的，用来处理读写冲突的手段（不用加锁），提高访问性能</li></ul></blockquote><ul><li><p>MVCC协议中，事务提交不会覆盖原数据，而是产生新版本数据，<strong>每个数据有多个历史版本</strong>，但同一时刻只有最新的版本有效；</p></li><li><p>MVCC是在并发访问数据库时，通过对数据做多版本管理，避免<u>【<strong>因为写锁的阻塞而造成读数据的并发阻塞</strong>】</u>问题。可以让<strong>读取数据同时修改，【修改数据时同时可读取】</strong>。简单来说，就是<strong>不对数据库加上读写锁！</strong></p></li></ul><h5 id="9-1-MVCC-如何实现-？">9.1 MVCC 如何实现 ？</h5><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/52977862">Innodb MVCC实现原理</a></p></blockquote><ul><li><p><strong>总结性回答</strong></p><p>MVCC是以一个多版本并发控制系统，它主要通过以下两个部分实现：</p><ul><li>每行记录：记录最近操作该行记录的事务ID，和上一版本数据的指针（指向undo log）</li><li>readview：每次<strong>读（写不可以</strong>） 可以获取一个readview，记录当前活跃的事务ID ，可以在<strong>写的过程进行读</strong></li></ul><p>写的时候并发读，通过比较当前行记录的事务ID和readview活跃的事务ID，来决定是否读取该行记录还是上一版本的数据。</p></li></ul><p>MVCC实现的核心部分为：</p><ol><li><p><strong>事务版本号</strong>：每次<strong>事务开启前</strong>都会从数据库获得一个自增长的<strong>事务ID</strong>，可以从事务ID判断事务的执行先后顺序。</p></li><li><p><strong>表的隐藏列</strong> <strong>：每一行</strong> 有如下三个重要字段属性：</p><table><thead><tr><th style="text-align:center">隐藏列</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>DB_TRX_ID</strong></td><td style="text-align:center">记录操作该行事务的ID</td></tr><tr><td style="text-align:center"><strong>DB_ROLL_PTR</strong></td><td style="text-align:center">指向上一个版本的数据（在undo log）的指针</td></tr><tr><td style="text-align:center"><strong>DB_ROW_ID</strong></td><td style="text-align:center">隐藏ID，当表没有合适的索引作为聚簇索引时，会用该ID创建聚簇索引</td></tr></tbody></table></li><li><p><strong>undo log</strong> ：每一行记录被修改之前的日志。</p><blockquote><p>当事务被回滚时，可以用通过undo log日志对数据进行还原。</p></blockquote><p>一个小例子：修改某行记录name从 <code>“张三→李四”</code></p><p><img src="https://pic1.zhimg.com/v2-1daaeab59495ff3378dae24ea21dc158_r.jpg" alt="preview"></p></li><li><p><strong>read view</strong>。在innodb 中<strong>每个SQL语句执行前</strong>都会得到一个read_view，保存了当前数据库系统中正<strong>处于活跃（没有提交</strong>）的事务的ID号。</p><blockquote><p>根据事务的隔离性，这些事务ID列表不会被其它事务看到。</p></blockquote><p>其相关重要属性如下：</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>trx_ids</strong></td><td style="text-align:center">当前系统：活跃<code>（未提交）事务版本号集合</code></td></tr><tr><td style="text-align:center"><strong>low_limit_id</strong></td><td style="text-align:center">当前系统：<code>最大版本事务号+1</code></td></tr><tr><td style="text-align:center"><strong>up_limit_id</strong></td><td style="text-align:center">当前系统：<code>活跃的最小事务版本号</code></td></tr><tr><td style="text-align:center"><strong>creator_trx_id</strong></td><td style="text-align:center">当前read view：<code>事务版本号</code></td></tr></tbody></table></li></ol><p>具体原理可以描述如下：</p><blockquote><p>举个例子，假设有一个user_info表，初始数据如下：</p><p><img src="https://i.loli.net/2021/05/30/ATDHgI7sKeziOxE.png" alt="image-20210529211818428"></p><p>现在有事务A，B<strong>同时对<code>id=1</code> 这行数据进行操作</strong>，先开启事务A（未提交），此时执行事务B，最后返回什么结果呢？</p></blockquote><ol><li><p>事务A（写），执行 <code>update user_info set name =”李四”</code></p><ul><li><p>获得事务编号：102</p></li><li><p>当前事务A的视图为：（<strong>写）不会获得read view</strong>！</p></li></ul></li><li><p>事务B（读），执行 <code>select * fom user_info where id=1</code></p><ul><li><p>获得事务B编号：103</p></li><li><p>当前事务B的视图为：</p><table><thead><tr><th style="text-align:center"><strong>trx_ids</strong></th><th style="text-align:center">当前活跃的事务：102,103</th></tr></thead><tbody><tr><td style="text-align:center"><strong>low_limit_id</strong></td><td style="text-align:center">当前最大事务id+1:<strong>104</strong></td></tr><tr><td style="text-align:center"><strong>up_limit_id</strong></td><td style="text-align:center">当前最小事务id：<strong>102</strong></td></tr><tr><td style="text-align:center"><strong>creator_trx_id</strong></td><td style="text-align:center">当前事务id：<strong>103</strong></td></tr></tbody></table></li></ul><blockquote><p><strong>不同隔离级别下，read view的工作方式</strong>：</p><ol><li><p><strong>读未提交</strong>：不会获得read view的副本（等于没有并发控制所以会出现脏读）</p></li><li><p><strong>读提交</strong>：每一次select都会获得一个read view的副本，所以会造成【不可重复读】</p><p><img src="https://i.loli.net/2021/05/30/EQSJBYZMeUljA3g.png" alt="image-20210529222746175"></p></li><li><p><strong>可重复读</strong>：同一个事务select只会获得一次read view副本（select的时候不允许修改），所以不会出现不可重复读。</p><p><img src="https://i.loli.net/2021/05/30/ITXb5OukhL1EJ4N.png" alt="image-20210529222905837"></p></li></ol></blockquote></li><li><p>事务A（写），开始执行update语句：（1）把原数据拷贝到undo log，（2）然后进行修改name字段：<code>“张三→李四”</code>，（3）并设置DB_TRX_ID 隐藏字段：<code>99→102</code> （4）设置DB_ROLL_PTR隐藏字段：<code>执行上个事务版本地址</code></p><p><img src="https://i.loli.net/2021/05/30/zjCi4AeRQsbHaPO.png" alt="image-20210529213739125"></p><p>此时，<strong>事务A还并未提交</strong>，依旧是处于活跃状态。</p></li><li><p>事务B（读），开始执行select语句，<strong>查询到是事务A修改后的语句</strong></p><p><img src="https://i.loli.net/2021/05/30/xspAhSDXbOGroqC.png" alt="image-20210529214159799"></p><p>把<strong>数据和read view （视图）匹配</strong>： <u>保证</u>（1）<strong>数据已提交，没有其他事物修改，否则去找上一版本的数据</strong>。</p><blockquote><ol><li><code>当前数据记录的事务id &lt; 事务B视图中最小活跃事务id</code> : 说明<strong>数据</strong>，是在<strong>事务B的read view 创建前</strong>就存在，所以可以显示。</li><li><code>当前数据记录的事务id &gt; 事务B视图中最大活跃事务id</code> ：说明<strong>数据</strong>，是在<strong>事务B的read view 创建后</strong>才存在，此时不应该显示。</li><li><code>事务B视图中最小活跃事务id&lt;= 当前数据记录的事务id &lt;= 事务B视图中最大活跃事务id</code> ： 说明有<strong>其它事务在修改这行记录数据</strong>，但可能还没有提交。把id和事务B的read view的活跃事务集合trx_ids进行匹配：<ul><li>如果数据记录的ID不存在trx_ids，说明已经提交了事务，可以显示</li><li>如果存在trx_ids，说明<strong>数据还没提交，此时事务B查询到数据不能显示</strong>（除非此时数据记录的事务id == 事务B的id，由于是自己的当然可以显示）</li></ul></li></ol></blockquote></li><li><p>事务B（读），根据上述匹配规则，<strong>此时不能读</strong>，应该去undo log中找到上一版本数据。</p><blockquote><p>此时<code>事务B的id=103，数据记录的事务id=102</code> ：满足条件3，且此时trx_ids存在事务id=102，说明事务A（id=102）还没提交，因此<strong>不能显示。</strong></p></blockquote><p>故，最终查找的数据为：</p><img src="https://i.loli.net/2021/05/30/ATDHgI7sKeziOxE.png" alt="image-20210529211818428" style="zoom:80%;" /></li></ol><p>可以看到，整个过程MVCC<strong>事务A【写】没有加锁</strong>，只是进行版本号控制 &amp; undo log，可以进行<strong>并发【读】</strong>。</p><h5 id="9-2-MVCC-版本号如何变化的？更新的数据如何确定版本的？【幻读】又是怎么解决的呢？">9.2 MVCC 版本号如何变化的？更新的数据如何确定版本的？【幻读】又是怎么解决的呢？</h5><ul><li><p><strong>版本号变化</strong></p><p>每条记录有三个隐藏列：（1）<strong>DB_TRX_ID</strong> （2）<strong>DB_ROLL_PTR</strong> （3）<strong>DB_ROW_ID</strong></p><p>每一次新事务，<strong>update更新语句</strong>，都会将（1）拷贝数据到undo log（2）DB_ROLL_PTR指向上个数据的版本undo log（3）DB_TRX_ID修改为新事务的id 。</p></li><li><p><strong>为什么MVCC可解决幻读</strong></p><p><strong>在RR（可重复读级别下）不会出现幻读</strong>。例如：</p><ol><li>开启事务1，获得事务ID为1；</li><li>事务1执行查询，得到readview；</li><li>开始事务2；</li><li>执行insert；</li><li>提交事务2；</li><li>执行事务1的第二次查询 (因为这里是RR级别，所以<strong>不会再去获得readview，<strong>还是使用第一次获得的readview，所以</strong>当前read view 事务的ID不会更新</strong>，即不会加入插入事务2)；</li><li>最后得到的结果是，插入的数据不会显示，因为<strong>插入的数据事务ID &gt; readview里的最大活跃事务ID</strong>。</li></ol></li></ul><h5 id="9-3-mvvc-和-for-update的区别">9.3 mvvc 和 for update的区别</h5><ol><li><strong>是否加锁</strong>：  mvvc不加锁，只通过多版本来进行并发控制；for update会加锁（<strong>即X/写锁</strong>）。</li></ol><h5 id="9-4-（快手）MVCC作用，如何实现RC，RR">9.4 <strong>（快手）MVCC作用，如何实现RC，RR?</strong></h5><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/73078137">https://zhuanlan.zhihu.com/p/73078137</a></p></blockquote><p><strong>作用如下</strong>：</p><ol><li>最简单的描述，<strong>读写不阻塞，读的时候可以写</strong></li><li>提高性能</li></ol><p><strong>实现RC，RR两个隔离级别</strong>：</p><blockquote><p>MVCC <strong>读</strong>某一个数据时，<strong>根据隔离级别</strong>，事务选择要读取哪个版本的数据，过程中完全不需要加锁。</p></blockquote><ol><li><p><strong>Read Committed</strong> ：一个事务读取数据时总是读这个数据<strong>最近一次被commit</strong>的版本 ，<strong>所以可以避免脏读（快手</strong>）；</p></li><li><p><strong>Repeatable Read</strong> ： 一个事务读取数据时总是读取当前【<strong>事务开始之前】最后一次被commit</strong>的版本（所以底层实现时需要比较当前事务和数据被commit的版本号），<strong>所以避免了幻读（快手</strong>）。</p></li></ol><p><strong>举个简单的例子</strong>：</p><ol><li><strong>一个事务A（txnId=100）修改了数据X，使得X=1，并且commit了</strong></li><li><strong>另外一个事务B（txnId=101）开始尝试读取X，但是还X=1。但B没有提交。</strong></li><li><strong>第三个事务C（txnId=102）修改了数据X，使得X=2。并且提交了</strong></li><li><strong>事务B又一次读取了X。这时</strong><ul><li><strong>如果事务B是Read Committed。那么就读取X的最新commit的版本，也就是X=2</strong></li><li><strong>如果事务B是Repeatable Read。那么读取的就是当前事务（txnId=101）之前X的最新版本，也就是X被txnId=100提交的版本，即X=1。</strong></li></ul></li></ol><p>注意，这里B不论是Read Committed，还是Repeatable Read，<strong>都不会被锁</strong>，都能立刻拿到结果。这也就是MVCC存在的意义。</p><h2 id="5-3-索引相关">5.3 索引相关</h2><blockquote><p>🛰 强烈建议对索引更深刻理解，先看完美团这篇技术文章：<a href="https://tech.meituan.com/2014/06/30/mysql-index.html">MySQL索引原理及慢查询优化</a></p></blockquote><h4 id="0-MySQL索引原理及慢查询优化">0. <a href="https://tech.meituan.com/2014/06/30/mysql-index.html">MySQL索引原理及慢查询优化</a></h4><h5 id="0-1-为什么要需要索引">0.1 为什么要需要索引</h5><blockquote><p>答到：遍历磁盘开销太大这个关键。</p></blockquote><p>数据库实现比较复杂，数据保存在<strong>磁盘</strong>上，而为了提高性能，每次又可以把<strong>部分读入内存</strong>来计算 。</p><p>磁盘的成本大概是访问内存的<strong>十万倍</strong>左右 ， 每次去遍历磁盘找到数据再读入内存，是难以接受的。因此需要一种快速找到磁盘数据的方式，就像字典通过<strong>字母索引→快速定位单词</strong>。因此索引由此而出现。</p><h5 id="0-2-局部性原理（磁盘IO一次读取大小）">0.2 局部性原理（磁盘IO一次读取大小）</h5><blockquote><p>在继续往下讲之前，先来讲讲磁盘读取局部性原理。</p></blockquote><p>局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与<strong>其相邻的数据也会很快被访问到</strong>。</p><ul><li>因此，当<strong>一次</strong>IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内。</li></ul><p>每次IO读取的数据，分为下面情况：</p><ul><li>Linux：上以<strong>页</strong>为单位，一次一页（<strong>4K</strong>）</li><li>数据库：mysql（InnoDB引擎）一页（<strong>16K</strong>）; SQL Server/ Oracle，默认<strong>块</strong>，大小都是<strong>8KB</strong></li></ul><h5 id="0-3-索引→B-树">0.3 索引→B+树</h5><p>相比二叉树，平衡树等，<strong>B+树</strong> 作为<strong>高度可控的多路搜索树</strong> ，可以很好的满足要求。（详细选择原因，可以参考：<u>5.3 索引相关–问答6</u>）</p><ul><li><p><strong>B+树基本结构</strong></p><p><img src="https://i.loli.net/2021/05/23/xXQFuqgEfpreHdG.jpg" alt="b+树"></p><p>浅蓝色是一个磁盘块，数据项就是被组织索引那<strong>列</strong>的字段值。</p><blockquote><p>如果是Innodb引擎，使用聚簇索引就是按照每张表的<strong>主键</strong> 构造索引，那么此时<strong>数据项就是主键值</strong>。</p></blockquote><ul><li><p>蓝色部分（如17,35）是数据项；黄色部分（如P1,P2,P3）是指针，指向<strong>下个磁盘块（页地址</strong>）。</p></li><li><p><strong>1. 为什么B+树非叶子节点不存放数据</strong>？</p><p>IO次数取决于b+数的高度h，每个磁盘块大小也是一定（一页）的。<strong>如果数据项占的空间越小，一个磁盘块数据项的数量越多，树的高度越低，B+可以更高阶（指针占用先忽略</strong>）。</p><p>所以磁盘<strong>非叶子</strong>节点不保存数据，是为了保存更多的数据项和指针，这样一颗B+树<strong>叶子</strong>节点就能存储更多的数据。</p></li><li><p><strong>2. 数据查找过程</strong>？</p><p>以查找<code>数据项=28</code> ，过程为例：<br>（1） 先 <u>加载（一般常驻内存）</u> 根页面1（磁盘块1），因为<code>17&lt;28&lt;35</code> 所以使用<code>P2</code>指针 ， 找到磁盘块3（页面3）<strong>地址</strong></p><p>（2）在 <u>IO加载</u> 磁盘块3，因为 <code>26&lt;28&lt;30</code>  ，因此根据此时的<code>P2</code> 指针，找到磁盘块8所在的地址</p><p>（3） <u>IO加载</u> 磁盘块8，因为此时是叶子节点，可以得到<code>数据项=28</code>对应的<strong>那行记录</strong> 。</p><p>仅仅最多<strong>3</strong>次磁盘IO就找到了数据，这提升是巨大的。</p></li><li><p><strong>3. 高度为3的B+数可以存储多少数据</strong>？</p><ul><li><p><strong>叶子节点一页存储的记录数</strong></p><p>mysql一页16K，所以一页存储<code>16K/1K = 16条</code> 记录。（实际真实业务场景一条记录一般就是1K）</p></li><li><p><strong>非叶子节点一页存储的指针数</strong></p><p>由于数据项也要占用空间，其和指针只相差1，按<strong>成对</strong>算。</p><p>假设主键ID（数据项）为bigint类型，长度为<code>8</code>字节，而<code>指针大小</code>在InnoDB源码中设置为<code>6字节</code> 。那么一共<code>14</code>字节。</p><p>所以一页可以存储：<code>16K / 14B ≈ 1K</code> 个指向页面的指针。</p></li><li><p><strong>计算可以存储多少页</strong></p><p>高度为3的B+树，第3层叶子节点存储真实<strong>数据页</strong>，前2层是存储<strong>数据项+指针</strong>。<strong>第二层指针</strong>==叶子节点存储的页面数。</p><ol><li>第一层：根页面可以存储1K个指针，每个指针指向一个新的页面</li><li>第二层：存储 <code>1K*1K = 1M</code> ，约一百万个指针，指向一百万个叶子数据页面</li></ol><p>所以一共存储：<code>1M*16≈16M</code> ，即千万级别的数据。</p></li></ul></li></ul></li></ul><h5 id="0-4-慢查询优化">0.4 慢查询优化</h5><p>（暂略）</p><h4 id="1-MySQ索引的原理和数据结构能介绍一下吗？索引的缺点？">1. <strong>MySQ索引的原理和数据结构能介绍一下吗</strong>？<strong>索引的缺点</strong>？</h4><ul><li><p><strong>索引原理</strong>： 本质是用来优化查询速度。<u>用一个数据结构组织某一列的数据</u>，然后如果你要根据那一列的数据查询的时候，就可以<u>不用全表扫描</u>，只要根据那个特定的数据结构快速去找到那一列的值。</p></li><li><p><strong>数据结构</strong>： MySQL索引通过B+树来实现（按数据结构分也有hash索引、fulltext索引）。</p></li><li><p><strong>索引缺点</strong>： （1）占用磁盘存储空间 （2）降低表更新速度，表发生变化，索引也要发生变化</p></li></ul><h4 id="2-MySQL-索引类型有哪些？">2. <strong>MySQL 索引类型有哪些</strong>？</h4><p>按数据结构分类可分为：<strong>B+tree索引、Hash索引、Full-text索引</strong>。<br>按物理存储分类可分为：<strong>聚簇索引、二级索引（辅助索引</strong>）。<br>按字段特性分类可分为：<strong>主键索引、普通索引、前缀索引</strong>。<br>按字段个数分类可分为：<strong>单列索引、联合索引（复合索引、组合索引</strong>）。</p><ul><li><p><strong>主键索引</strong>：索引列中的值必须是唯一的，不允许有空值；</p></li><li><p><strong>唯一索引</strong>：索引列中的值必须是唯一的，但是允许为空值；</p></li><li><p><strong>普通索引</strong>：MySQL中<u>基本索引类型</u>，没有什么限制，允许在定义索引的列中插入重复值和空值；</p></li><li><p><strong>全文索引</strong>：只能在<strong>文本类型CHAR,VARCHAR,TEXT</strong>类型字段上创建全文索引；</p><blockquote><p>字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引；</p><p>MyISAM和InnoDB中都可以使用全文索引。</p></blockquote></li><li><p><strong>前缀索引</strong>：在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定；</p></li><li><p><strong>空间索引</strong>： MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。</p><blockquote><p>MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。</p></blockquote></li></ul><h5 id="2-1-什么是覆盖索引？">2.1 什么是覆盖索引？</h5><p>我们在<u>非聚簇索</u>引一般只获得了，记录的key值（Innodb引擎），还需要回到聚簇索引中<strong>再次查询</strong>。</p><ul><li><strong>覆盖索引</strong>： 从<strong>非主键索引中就能查到的记录</strong>，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。</li></ul><blockquote><p>一个小例子。</p></blockquote><p>以name和age两个字段建立<strong>联合索引</strong>，sql命令与建立后的索引树结构如下：</p><img src="https://i.loli.net/2021/05/28/V2ApYvt9zWGFhcf.png" alt="image-20210526230732546" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student DROP INDEX I_name;</span><br><span class="line">ALTER TABLE student ADD INDEX I_name_age(name, age);</span><br></pre></td></tr></table></figure><p>此时执行如下sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT age FROM student WHERE name = &#x27;小李&#x27;；</span><br></pre></td></tr></table></figure><p>在<strong>非聚簇索引中包含了age信息</strong>，那么直接返回12，不需要再到聚簇索引中查询。</p><h4 id="【重点】3-什么时候使用索引比较好？什么时候不要使用索引？">【重点】3.<strong>什么时候使用索引比较好</strong>？什么时候不要使用索引？</h4><h5 id="3-1-什么时候用索引">3.1 什么时候用索引</h5><blockquote><p>特别的，主键自动建立唯一索引。</p></blockquote><ol><li><p><strong>频繁</strong>作为查询条件的字段应该创建索引 ；</p></li><li><p><strong>查询中与其他表关联的字段</strong>，外键关系建立索引；</p></li><li><p><strong>查询中排序的字段</strong>，排序字段若通过索引去访问将大大提高排序速度（<strong>索引就是排序加快速查找</strong>）；</p></li><li><p><strong>查询中统计或者分组字段</strong>。</p></li></ol><h5 id="3-2-什么时候不用索引">3.2 什么时候不用索引</h5><ol><li><p><strong>经常增删改</strong>的列不要建立索引（因为每次更新不单单是更新记录，还会更新索引，保存索引文件）；</p></li><li><p><strong>表记录太少</strong>不要建立索引；</p></li><li><p>（<strong>被CSIG问过</strong>）区分度低，数据重复且分布平均的字段不适合做索引；</p><blockquote><p>例如性别字段，只有男女，不适合建立索引。</p><ul><li>因为从索引中拿到的只是地址，要想真正访问到数据还是要对表进行一次IO；</li><li>假如你要从表的100万行数据中取几个数据，那么利用索引迅速定位，访问索引的这IO开销就非常值了；</li><li>但如果你是从100万行数据中取50万行数据，就比如性别字段，那你相对需要 <u>访问50万次索引，再访问50万次表</u>，加起来的开销并不会比直接对表进行一次完整扫描小。</li></ul></blockquote></li><li><p><strong>text，image</strong>等类型不应该建立索引，<strong>这些列的数据量大</strong>；</p></li><li><p><strong>多个单列索引并不是最佳选择</strong> MySQL 只能使用一个索引，会从多个索引中选择一个限制最为严格的索引 ；</p></li><li><p><strong>参加运算 或 作为函数参值等字段</strong>，不要建立索引，这会使得索引失效而全表扫描 。</p></li></ol><h4 id="4-主键与唯一索引有什么区别？">4.<strong>主键与唯一索引有什么区别</strong>？</h4><ul><li><p>主键一<strong>定会创建一个唯一索引，但是有唯一索引的列不一定是主键；</strong></p></li><li><p>主键不允许为空值，唯一索引列允许空值；</p></li><li><p>一个表只能有一个主键，但是可以有多个唯一索引；</p></li><li><p>主键可以被<strong>其他表引用为外键，唯一索引列不可以；</strong></p></li><li><p>主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本质差别。</p></li></ul><h4 id="5-b-树和b树有什么区别？">5. <strong>b+树和b树有什么区别</strong>？</h4><p>B树：</p><p><img src="https://i.loli.net/2021/04/21/YsAxSctJ1wKUm3g.png" alt="clip_image002"></p><ul><li>索引与数据存储在每个节点中（增加了IO次数）；</li><li>搜索过程有可能在非叶子节点结束（最好情况下<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>）。</li></ul><p>B+树：</p><p><img src="https://i.loli.net/2021/04/21/ihT3SbqwodNUvPe.png" alt="clip_image039"></p><ul><li>所有数据<strong>按顺序</strong>存储在叶子节点中；</li><li>所有叶子节点被<strong>双向链连接</strong>；</li><li>搜索过程固定时间复杂度（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>）；</li><li>（优点易忘）<u>适合范围查找，降低磁盘IO次数</u>。</li></ul><h4 id="6-为什么MySQL使用B-树作为索引？而不是平衡二叉树、红黑树、B树、或者Hash？">6.<strong>为什么MySQL使用B+树作为索引？而不是平衡二叉树、红黑树、B树、或者Hash？</strong></h4><ul><li><p><strong>不用平衡二叉树或者红黑树</strong>： 树的查询时间和树的结构有关，B+树是一颗多路搜索数，可以降低树的高度提高查询速度。</p></li><li><p><strong>不用B树</strong>： （1）无法范围查询，而<strong>B+树所有叶子节点形成有序链表便于范围查询</strong>；（2）N阶B+数，B树，B+数可以存储n个关键字，而B树是n个。</p></li><li><p><strong>不用Hash：</strong> （1）B+树允许分配加载节点，如果内存数据太大B+树更好（2）B+树更适合范围查询</p><blockquote><p>用Hash需要把数据全部<strong>加载到内存中</strong>，如果数据量大，是一件很<strong>消耗内存</strong>的事，而采用B+树，是基于<strong>按照节点分段加载，由此减少内存消耗</strong>。</p></blockquote></li></ul><h5 id="6-1-无限增加树的路数是不是可以有最优的查找效率？">6.1 <strong>无限增加树的路数是不是可以有最优的查找效率</strong>？</h5><ul><li><p>这样会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，<u>不一定能一次性加载到内存中</u>。</p></li><li><p><strong>有序数组没法一次性加载进内存</strong>，这时候B+树的多路存储威力就出来了，<strong>可以每次加载B+树的一个结点，然后一步步往下找</strong>。</p></li></ul><h4 id="7-B-树怎么进行分裂、合并的？知道具体步骤吗？">7. <strong>B+树怎么进行分裂、合并的？知道具体步骤吗</strong>？</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/nullzx/p/8729425.htm">https://www.cnblogs.com/nullzx/p/8729425.htm</a></p></blockquote><p><img src="https://i.loli.net/2021/04/21/aejwRD2WxNb7slY.png" alt="image-20210421124006795"></p><h4 id="8-MySQL聚簇索引和非聚簇索引的区别是什么？">8. <strong>MySQL聚簇索引和非聚簇索引的区别是什么</strong>？</h4><ul><li><p><strong>主要区别</strong></p><ul><li><p><strong>聚簇索引</strong> ： 找到索引就找到了需要的数据，那么这个索引就是聚簇索引;</p><blockquote><p>所以Innodb主键就是<strong>聚簇索引</strong>，修改聚簇索引其实就是修改主键；但在<u>Myisam下主键索引是非聚集索引</u>。</p><p>InnoDB 会<strong>隐式定义一个主键</strong>来作为聚簇索引（但是这个主键如果更改代价较高，<u>故建表时要考虑自增ID不能频繁update</u>这点）。</p></blockquote><p><img src="https://i.loli.net/2021/05/03/mzwGgCjxuIpaeA7.png" alt="img"></p></li><li><p><strong>非聚簇索引</strong>：索引的存储和数据的存储是分离的 , 找到了索引但没找到数据，需要根<u>据<strong>索引上的值(主键/地址)再次回表查询</strong></u>，<strong>也叫做辅助索引</strong>。</p><blockquote><p>MyISM使用的是非聚簇索引 ，下图叶节点的<strong>data域存放的是数据记录的地址</strong> 。</p></blockquote><p><img src="https://i.loli.net/2021/05/03/A1X5aOY6qkuEol9.png" alt="img"></p></li></ul></li><li><p><strong>聚簇索引查找过程</strong></p><blockquote><p>首先澄清一个概念，聚簇索引和和辅助索引。</p><p>Innodb存储引擎的B+树分为，聚簇索引保存的是放着一整行的数据；辅助索引都引用<u>主键作为data域</u>。</p><p>例如，下图以Col3建立一个<strong>Innodb辅助索引</strong> ：</p><p><img src="https://i.loli.net/2021/05/03/l1IHbpgGAYr73sT.png" alt="img"></p><p>对于MyISAM，主索引和辅助索引（Secondary key）在结构上没有任何区别。<strong>只是主索引要求key是唯一的，而辅助索引的key可以重复</strong>。</p><p>例如，下图以Col2建立一个<strong>MyISAM的辅助索引</strong>：</p><p><img src="https://i.loli.net/2021/05/03/9jpKvRbIWFwucLT.png" alt="img"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * Where name=‘Alice’</span><br></pre></td></tr></table></figure><p>首先根据<u>辅助索引</u> ，在叶子节点找到<strong>0X56对应主键值</strong><code>18</code> ；然后在<u>聚簇索引</u>，根据<code>18</code> 找到对应行数据。</p></li></ul><h5 id="8-1-看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B-树查找，这不是多此一举吗？聚簇索引的优势在哪？">8.1 <strong>看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，这不是多此一举吗？聚簇索引的优势在哪</strong>？</h5><ul><li><p><strong>重复访问同一页更快</strong>：由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，<strong>已经把页加载到了Buffer中</strong>，<strong>再次访问的时候，会在内存中完成访问</strong>，不必访问磁盘；</p><blockquote><p>B+树的每个节点的数量都是一个mysql分区页的大小(阿里面试) 。</p></blockquote></li><li><p><strong>辅助索引使用主键值作为指针</strong>： 辅助索引使用主键作为&quot;指针&quot;而不是使用地址值作为指针（MyISAM） ，<strong>减少了当出现【行移动】或者数据页分裂时（<u>地址值变化</u>）辅助索引的维护工作</strong> 。</p></li></ul><h5 id="8-2-为什么name-age这些字段不适合做索引？">8.2 为什么name,age这些字段不适合做索引？</h5><p>在InnoDB中每一个表都会有聚集索引，如果表定义了主键，则（默认）主键就是聚簇索引。</p><p>一个表只有一个聚集索引，其余为普通索引。所以name，age就是普通索引，也就是作为辅助索引。</p><p>在使用普通索引name查询时，会先加载普通索引：</p><p>（1）通过普通索引查询到实际行的主键</p><p>（2）再使用主键通过聚集索引查询相应的行</p><p>（3）以此<strong>循环查询所有的行</strong><br>若直接全量搜索聚集索引，则不需要在普通索引和聚集索引中来回切换。相比两种操作的总开销可能扫描全表效率更高。</p><h4 id="9-MySQL联合索引如何使用？什么是最左匹配原则？">9. <strong>MySQL联合索引如何使用</strong>？<strong>什么是最左匹配原则</strong>？</h4><blockquote><p>参考：<a href="https://blog.csdn.net/Abysscarry/article/details/80792876">https://blog.csdn.net/Abysscarry/article/details/80792876</a></p></blockquote><p>对多个字段同时建立的索引(有顺序，ABC，ACB是完全不同的两种联合索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test` (</span><br><span class="line">  `id` int(4) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `a` varchar(10) NOT NULL,</span><br><span class="line">  `b` varchar(10) NOT NULL,</span><br><span class="line">  `c` varchar(10) NOT NULL,</span><br><span class="line">  `d` varchar(10) NOT NULL,</span><br><span class="line">  `e` varchar(10) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  # 联合索引(a,b,c)</span><br><span class="line">  UNIQUE KEY `idx_a_b_c` (`a`,`b`,`c`) USING BTREE </span><br><span class="line">) ENGINE=I</span><br></pre></td></tr></table></figure><p>以联合索引(a,b,c)为例：</p><ul><li><p><strong>建立这样的索引相当于建立了索引a、ab、abc三个索引</strong>。一个索引顶三个索引当然是好事，毕竟每多一个索引，都会增加写操作的开销和磁盘空间的开销。</p><blockquote><p><strong>a,c</strong>组合也可以但不是为他建立了索引，但实际上只用到了a的索引，c并没有用到！</p></blockquote></li><li><p><strong>最左匹配原则</strong></p><p>最左优先，在检索数据时从联合索引的最左边开始匹配，<strong>即是where条件必须有联合索引的第一个字段。</strong></p><ul><li><p>不包含第一个字段</p><p>不会走索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  * from test where  b = &#x27;333&#x27; and c = &#x27;333&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>where和索引顺序不一样</p><p>会走索引，<u>和顺序无关</u>。</p><blockquote><p>where 后面列的顺序是被<strong>优化器</strong>优化了的，所以才会觉得无影响，你可以查看一下优化器优化后的语句，会帮你调整为满足最左前缀的顺序。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  * from test where c = &#x27;333&#x27; and b = &#x27;333&#x27; and a = &#x27;333&#x27;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="9-1-联合索引的好处？">9.1 联合索引的好处？</h5><h4 id="10-（还要补充）介绍一下索引失效的原因？">10. （还要补充）介绍一下索引失效的原因？</h4><blockquote><p>很不错的一篇文章：<a href="https://cloud.tencent.com/developer/article/1704743">索引失效原理，终于有人讲明白了</a></p><p>结合这篇文章：<a href="https://juejin.cn/post/6844904073955639304">https://juejin.cn/post/6844904073955639304</a></p></blockquote><p>假设mysql 存在联合索引（a,b），显然也是一颗B+树:</p><p><img src="https://i.loli.net/2021/05/24/GlDckpZzWTnodIf.png" alt="image-20210524114029113"></p><ul><li><p><strong>不符合最左匹配失效</strong></p><ol><li><p>情况1 ：<code>select * from testTable where b=2</code></p><p>联合索引是通过第一个索引<code>a</code> 来构建B+树，进行定位二分查找的，不能直接通过<code>b</code> 来进行二分查找。</p></li><li><p>情况2：<code>like</code>查询失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">where name like &quot;a%&quot;  # 会有效，因为可以匹配到首字母</span><br><span class="line"></span><br><span class="line">where name like &quot;%a%&quot; # 首字母是任意匹配的，所以索引用不上</span><br><span class="line"></span><br><span class="line">where name like &quot;%a&quot; # 同上，不能根据尾字母来索引</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>范围查询失效</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from testTable where a&gt;1 and b=2</span><br></pre></td></tr></table></figure><p>首先<strong>a字段在B+树上是有序</strong>的，所以可以用二分查找法定位到1，然后将所有大于1的数据取出来，a可以用到索引。</p><p><strong>b有序的前提是a是确定的值</strong>，那么现在a的值是取大于1的，可能有10个大于1的a，也可能有一百个a。</p><p>大于1的a那部分的B+树里，b字段是无序的（开局一张图），所以b不能在无序的B+树里用二分查找来查询，b用不到索引。</p></li><li><p><strong>多个单列索引</strong></p><p>我们首先建立了三个单列索引：userid，mobile，billMonth。然后使用以下查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE  userid=&#x27;2222&#x27; AND mobile=&#x27;13281899972&#x27; AND billMonth=&#x27;2018-04&#x27;</span><br></pre></td></tr></table></figure><ul><li><p><code>explain</code> 结果分析，最终只有<code>userid</code> 这<strong>一个索引有效</strong>。</p><blockquote><p>此处<code>userid 、mobile 、billMonth</code>这三个索引列都能用，只不过<strong>优化器判断使用<code>userid</code>这一个索引能最高效完成本次查询</strong>，故最终explain展示的key为userid。</p></blockquote></li></ul><p>特别的，如果改为 <code>or</code> 进行判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE  userid=&#x27;2222&#x27; OR mobile=&#x27;13281899972&#x27; </span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/24/UDQxsm7YIrglvu8.png" alt="这里写图片描述"></p><ul><li><p><strong>此时两个索引 userid &amp; mobile都用上了</strong>。</p><blockquote><p>mysql <u>5.0 版本之前</u> 使用or<strong>只会用到一个索引</strong>, 自从<u>5.0版本开始</u> ，引入了index_merge索引合并优化！也就是说，我们现在可以利用上多个索引去优化or查询了。</p></blockquote></li></ul></li><li><p><strong>或者索引加上了运算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c - 1 = 1000;</span><br></pre></td></tr></table></figure><p>这种情况不会有效，应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c = 1000 + 1;</span><br></pre></td></tr></table></figure><p>又比如用了函数操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where pow(c,2) = 1000;</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-【⚠️-新增】索引实战篇">11. 【⚠️ 新增】索引实战篇</h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/115778804">https://zhuanlan.zhihu.com/p/115778804</a></p></blockquote><ol><li><p><code>where a=xxx and b=xxx order by c</code>  ，如何建立索引？</p><p>建立联合索引<code>（a,b,c）</code> ，因为这样的话<strong>无需做一次额外的排序操作</strong>。</p><p>因为建立联合索引时，根据最左匹配原则，先按<code>a</code>排序，再按<code>b</code>排序，最后按<code>c</code> 排序。根据联合索引检索到，<code>a=xxx and b=xxx</code>条件时，再去检索<code>c</code>本身已排序的。那么不用 <code>order by c</code> ，不用进行文件排序。</p><ul><li>注意，建立联合索引 <code>（a,b）</code> , 则是走不到 sort的！</li></ul></li><li><p><code>where a=xxx  order by b,c</code>  ，如何建立索引？</p><p>道理同上，建立<code>（a,b,c）</code> 。</p></li><li><p><code>where a &gt; 1 ORDER BY b</code>，怎么建立索引？</p><p>建立索引（a）即可，因为a是范围查询：</p><ul><li>建立（a,b）的 话b也用不上，因为是a是范围查询；</li><li>建立（b,a）, <strong>b按索引排好序，a&gt;1可以用上？错误，因为先where筛选才会order by！</strong></li></ul></li><li><p><code>where a=1 and b=2 and c&gt;3 and d=4</code> ，如何建立索引？</p><p>建立联合索引，<code>(a,b,d,c)</code>  即可。</p><ul><li>但是对于建立<code>(a,b,c,d)</code> ，<strong>a,b,c三个字段能用到索引，而d就匹配不到</strong>，因为遇到了<strong>范围查询，在c&gt;3这个范围内，d不是有序的；但是c=3，这个范围内，d是有序的</strong>！</li></ul></li><li><p><code>where a &gt; 1 and b = 2 and c &gt; 3</code>，如何建立索引？</p><p>建立（b,c）或者（b,a）即可，但至少有一个索引要失效（遇上范围查询）。</p></li><li><p><code>WHERE a IN (1,2,3) and b &gt; 1</code>，怎么建立索引？</p><p>还是对(a，b)建立索引，因为IN在这里可以视为等值引用，不会中止索引匹配，所以还是(a,b)！</p></li></ol><h5 id="11-1-有个字段值可能正，可能负，查询该字段要绝对值，但计算会导致索引失效，怎么优化？">11.1 <strong>有个字段值可能正，可能负，查询该字段要绝对值，但计算会导致索引失效，怎么优化</strong>？</h5><ol><li>拆成两列1列只存绝对值，另起一列tinyint来表示正负或者方向；</li><li>先查询到结果，然后再查询的结果上进行操作（取绝对值）？</li></ol><h4 id="12-order-by-怎么进行排序的？怎么优化？">12. order by 怎么进行排序的？怎么优化？</h4><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000040357292">https://segmentfault.com/a/1190000040357292</a></p></blockquote><p>假设存在以下数据：</p><p><img src="https://i.loli.net/2021/09/04/cudfwqEHGmn3Ppt.png" alt="image-20210904013336980"></p><p>此时进行如下查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select city, order_num, user_code from `order` where city=&#x27;广州&#x27; order by order_num limit 1000;</span><br></pre></td></tr></table></figure><ol><li><p><strong>建立索引(city)：order by过程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `order` ADD INDEX city_index ( `city` );</span><br></pre></td></tr></table></figure><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210904013506155.png" alt="image-20210904013506155" style="zoom:80%;" /><ul><li><p><strong>用 explain 看看执行情况</strong></p><p><img src="https://i.loli.net/2021/09/04/lv3uyaxWkKPtqjd.png" alt="img"></p><p>注意到最后一个 extra 字段的结果是：<strong>Using filesort</strong>，表示需要排序。<strong>其实 MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer</strong>。</p></li><li><p><strong>完整执行过程</strong></p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/Pm7eJ1vQFg8l2xA.png" alt="image-20210904013732363" style="zoom:80%;" /><ol><li><p>初始化 <strong>sort_buffer</strong>，放入 <code>city、order_num、user_code</code> 这三个字段；</p></li><li><p>从索引 city 找到第一个满足 city=’ 广州’条件的主键 id，也就是图中的 ID_3；</p></li><li><p><strong>到主键 id 索引取出整行</strong>，取 city、order_num、user_code 三个字段的值，存入 sort_buffer 中；</p></li><li><p>从索引 city 取下一个记录的主键 id；</p></li><li><p>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_X；</p></li><li><p>对 sort_buffer 中的数据按照字段 <strong>order_num 做快速排序</strong>；</p><blockquote><p>其中，<strong>按 order_num 排序</strong>这个步骤，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 <strong>sort_buffer_size</strong>。</p></blockquote></li><li><p>按照排序结果取前 1000 行返回给客户端。</p></li></ol></li></ul></li><li><p><strong>优化1：使用rowid</strong></p><p>上面的全字段排序其实会有很大的问题，你可能发现了。<strong>我们需要查询的字段都要放到 sort_buffer 中，如果查询的字段多了起来，内存占用升高，就会很容易打满 sort_buffer</strong> 。</p><ul><li><p><strong>sort_buffer 只存 order_num 和 id 字段</strong>。</p><img src="https://i.loli.net/2021/09/04/PRwrO4ae3BJLciH.png" alt="img" style="zoom:80%;" /><ol><li>初始化 sort_buffer，确定放入两个字段，即 order_num 和 id；</li><li>从索引 city 找到第一个满足 city=’ 广州’条件的主键 id，也就是图中的 ID_3；</li><li><strong>回表</strong>，取 order_num、id 这两个字段，存入 sort_buffer 中；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到不满足 city=’ 广州’条件为止，也就是图中的 ID_X；</li><li>对 sort_buffer 中的数据按照字段 order_num 进行排序；</li><li>遍历排序结果，取前 1000 行，再次回表取出 city、order_num 和 user_code 三个字段返回给客户端。</li></ol></li></ul></li><li><p><strong>优化2：建立联合索引</strong></p><p>参见索引部分解释，不再赘述。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1460000040357304" alt="img" style="zoom:80%;" /><ol><li><p>从索引 (city,order_num) 找到第一个满足 city=’ 广州’条件的主键 id；</p></li><li><p>回表，取 city、order_num、user_code 三个字段的值，作为结果集的一部分直接返回；</p></li><li><p>从索引 (city,order_num) 取下一个记录主键 id；</p></li><li><p>重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’ 广州’条件时循环结束。</p></li></ol></li></ol><h2 id="5-3-事务相关">5.3 事务相关</h2><h4 id="1-请介绍一下数据库事务？和-u-事务特性-u-（ACID）？">1.<strong>请介绍一下数据库事务？和<u>事务特性</u>（ACID）</strong>？</h4><ul><li><p><strong>数据库事务</strong>： 数据库事务指的是一组数据操作，事务内的操作要么就是全部成功，要么就是全部失败。</p><blockquote><p><em>e.g.</em>  假设一个网购付款的操作，用户付款后要涉及到订单状态更新、扣库存以及其他一系列动作，这就是一个事务，如果一切正常那就相安无事，一旦中间有某个环节异常，那整个事务就要回滚，总不能更新了订单状态但是不扣库存吧。</p></blockquote></li><li><p><strong>事务特性</strong>：（1） 原子性（Atomicity）：一个事务必须视为一个不可分割的最小工作单元，要么都成功要么都失败（2）一致性（Consistency）：数据库总能从一个<strong>一致性的状态转换到另一个一致性的状态</strong>（3）隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的（4）持久性（Durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中</p></li></ul><h5 id="1-1-四大特性得不到保障会出现什么情况？">1.1 四大特性得不到保障会出现什么情况？</h5><blockquote><p>们以从A账户转账50元到B账户为例进行说明一下ACID这四大特性。</p></blockquote><ul><li><p><strong>原子性</strong> : 原子性是指一个事务是一个不可分割的工作单位，<strong>其中的操作要么都做，要么都不做</strong>。即要么转账成功，要么转账失败，是不存在中间的状态。</p><blockquote><p><strong>如果无法保证原子性会怎么样</strong>？</p></blockquote><p>会出现数据不一致的情形，A账户减去50元，而B账户增加50元操作失败。系统将无故丢失50元~</p></li><li><p><strong>一致性</strong> ：一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的。 那什么是合法的数据状态呢？这个状态是满足预定的约束就叫做合法的状态，再通俗一点，这状态是由你自己来定义的。<strong>满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的。</strong></p><blockquote><p><strong>如果无法保证一致性会怎么样</strong>？</p></blockquote><ul><li><p>例一: A账户有200元，转账300元出去，此时A账户余额为-100元。</p><p>你自然就发现了此时数据是不一致的，为什么呢？因为你定义了一个状态，<strong>余额这列必须大于0</strong>。</p></li><li><p>例二：A账户200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。</p><p>你也知道此时数据是不一致的，为什么呢？因为你定义了一个状态，<strong>要求A+B的余额必须不变</strong>。</p></li></ul></li><li><p><strong>隔离性</strong> ：隔离性是指<strong>多个事务并发执行的时候，事务内部的操作与其他事务是隔离的</strong>，并发执行的各个事务之间不能互相干扰。</p><blockquote><p><strong>如果无法保证隔离性会怎么样</strong>？</p></blockquote><p>假设A账户有200元，B账户0元。A账户往B账户转账两次，金额为50元，分别在两个事务中执行。</p><p>如果无法保证隔离性，A可能就会出现扣款两次的情形，而B只加款一次，凭空消失了50元，依然出现了数据不一致的情形！</p></li><li><p><strong>持久性</strong> : 根据定义，<strong>持久性是指事务一旦提交，它对数据库的改变就应该是永久性的</strong>。接下来的其他操作或故障不应该对其有任何影响。</p><blockquote><p><strong>如果无法保证持久性会怎么样</strong>？</p></blockquote><p>在MySQL中，为了解决CPU和磁盘速度不一致问题，MySQL是将磁盘上的数据加载到内存，对内存进行操作，然后再回写磁盘。好，假设此时宕机了，在内存中修改的数据全部丢失了，持久性就无法保证。</p><p>设想一下，系统提示你转账成功。但是你发现金额没有发生任何改变，此时数据出现了不合法的数据状态，我们将这种状态认为是<strong>数据不一致</strong>的情形。</p></li></ul><h5 id="1-2-数据库如何保证四大特性（如何实现事务）？">1.2 数据库如何保证四大特性（如何实现事务）？</h5><p>数据库事务的 ACID 四大特性是事务的基础，了解了 ACID 是如何实现的，我们也就清楚了事务的实现，接下来我们将依次介绍数据库是如何实现这四个特性的。</p><ul><li><p><strong>保证原子性</strong></p><p>主要是利用Innodb的<strong>undo log</strong>。</p><p>undo log名为回滚日志，是实现原子性的关键，当<strong>事务回滚时能够撤销所有已经成功执行的sql语句</strong>，他需要记录你要回滚的相应日志信息。</p><p>例如</p><ul><li>(1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据</li><li>(2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作</li><li>(3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操</li></ul><p>undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p></li><li><p><strong>保证一致性</strong></p><p>数据库对于 ACID 中的一致性的定义是这样的：<strong>如果一个事务原子地在一个一致地数据库中独立运行，那么在它执行之后，数据库的状态一定是一致的</strong>。</p><ul><li>它的第一层意思就是对<strong>于数据完整性的约束</strong>，包括主键约束、引用约束以及一些约束检查等等，在事务的执行的前后以及过程中不会违背对数据完整性的约束，所有对数据库写入的操作都应该是合法的，并不能产生不合法的数据状态。</li><li>第二层意思其实是指逻辑上的对<strong>于开发者的要求</strong>，我们要在代码中写出正确的事务逻辑，比如银行转账，事务中的逻辑不可能只扣钱或者只加钱，这是应用层面上对于数据库一致性的要求。</li></ul></li><li><p><strong>保证隔离性</strong></p><p>在 SQL 标准中定义了四种数据库的事务的隔离级别：<code>READ UNCOMMITED</code>、<code>READ COMMITED</code>、<code>REPEATABLE READ</code> 和 <code>SERIALIZABLE</code>；</p><p>数据库对于隔离级别的实现就是使用<strong>并发控制机制</strong>对在同一时间执行的事务进行控制：</p><ol><li><p><strong>锁</strong>： MySQL 和常见数据库中的锁都分为两种，共享锁（Shared）和互斥锁（Exclusive），前者也叫读锁，后者叫写锁。</p></li><li><p><strong>mvcc实现</strong>：实现RC和RR。</p></li></ol></li><li><p><strong>保证持久性</strong></p><p>利用Innodb的<strong>redo log</strong>，为什么要使用redo log，请看下面：</p><ul><li>正如之前说的，Mysql是把磁盘上的数据<strong>先加载到内存</strong>中，在内存中对数据进行修改，再刷回磁盘上。<strong>如果此时突然宕机，内存中的数据就会丢失；</strong></li><li><strong>如果事务提交前直接把数据写入磁盘，只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了</strong>。</li></ul><p><strong>redo log解决方案</strong>：</p><ul><li>当做数据修改的时候，<strong>不仅在内存中操作，还会在redo log中记录这次操作</strong>；</li><li>当事务提交的时候，<strong>会将redo log日志进行刷盘</strong>(redo log一部分在内存中，一部分在磁盘上)；</li><li><strong>当数据库宕机重启</strong>的时候，会将redo log中的内容恢复到数据库中，<strong>再根据undo log和binlog内容决定回滚数据</strong>还是提交数据。</li></ul></li></ul><h5 id="1-3-binlog日志是做什么的？">1.3 binlog日志是做什么的？</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/kevingrace/p/5907254.html">https://www.cnblogs.com/kevingrace/p/5907254.html</a></p></blockquote><p>MySQL的二进制日志binlog可以说是MySQL最重要的日志，<strong>它记录了所有的DDL和DML语句（除了数据查询语句select）</strong>，以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。</p><blockquote><p>DDL ，即 Data Definition Language 数据库定义语言。</p><ul><li>主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。</li></ul><p>DML，即Data Manipulation Language 数据操纵语言。</p><ul><li>主要的命令是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言。</li></ul></blockquote><p>binlog日志有两个最重要的使用场景：</p><ol><li><strong>MySQL主从复制</strong>：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves来达到<br>master-slave数据一致的目的。</li><li><strong>自然就是数据恢复了</strong>，通过使用mysqlbinlog工具来使恢复数据。</li></ol><h4 id="2-介绍一下（并发）事务不同隔离级别？对应可能出现的问题？">2.<strong>介绍一下（并发）事务不同隔离级别</strong>？<strong>对应可能出现的问题</strong>？</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/shan-kylin/p/9543294.html">https://www.cnblogs.com/shan-kylin/p/9543294.html</a></p></blockquote><p>下面<strong>排它锁和共享锁</strong>都是<strong>行锁</strong>，锁住一行。</p><ul><li><p><strong>Read uncommitted：</strong> 顾名思义，就是一个事务可以读取另一个未提交事务的数据。但这种情况会出现<strong>脏读</strong>： 因为<strong>写</strong>数据的时候添加一个<strong>X锁（排他锁，拿到锁的事务可以写，其它事务只能等待阻塞</strong>）；但<strong>读</strong>不受限制，读不加锁。</p><blockquote><p>由于读不加锁，读的是可能是修改前（未提交）的数据，也就是<strong>脏读</strong>。</p></blockquote></li><li><p><strong>Read Committed ：写</strong>数据的时候加上<strong>X锁（排他锁</strong>），<strong>读</strong>数据的时候添加<strong>S锁（共享锁，拿到锁的事务可以查看但无法修改和删除，其它事务【只能加S锁】【不能加其它锁】如X锁</strong>）。解决脏读，但会导致出现<strong>不可重复读</strong>的问题。</p><blockquote><ol><li>初始x=100,；</li><li>事务A<strong>读</strong>x，加上<strong>S锁</strong>，读到x=<strong>100</strong>，<strong>立即释放S锁且未提交</strong>；</li><li>事务B<strong>修改</strong>x，加上<strong>X锁</strong>，修改x=50，提交 ；</li><li>事务A再次<strong>读取x</strong>，加上<strong>S锁</strong>，读取x=<strong>50</strong>，发现和第一次读取不一致，提交事务。</li></ol><p>上述过程，事务A在提交前读取两次不一样的x值，为<strong>不可重复读</strong>。</p></blockquote></li><li><p><strong>Repeatable read</strong> ：<strong>MySQL 默认隔离界别</strong> , 开始<strong>读取</strong>数据（事务开启）时，<strong>【S】锁不再立即释放，其它事务就不能加上【X】锁修改数据</strong>。解决了脏读、不可重复读，但是可能会出现<strong>幻读</strong>：-</p><ul><li>Mysql官方给出的幻读解释是：<strong>只要在一个事务中，第二次select（读）多出了row就算幻读</strong>。</li></ul><blockquote><p>现在做如下修改：</p><ul><li>写：X锁保持不变</li><li>读：S锁，<strong>读完不再立即释放</strong>，而是<strong>在提交的时候再释放</strong>。</li></ul><p>这样的话，保证事务A在<u>提交前</u>，读取的x是一致的。解决了<strong>不可重复读</strong>，但依旧可能出现<strong>幻读</strong>。例如，<strong>X锁不能阻止（表中其它记录）插入操作，因为只锁住了当前记录，是行级锁</strong>。</p><ol><li>事务A加上X锁，更新了<strong>所有用户</strong>年龄从<code>20→18</code>；</li><li>过一会儿再读发现<strong>还有一个用户没修改</strong>，还是20岁？出现幻觉了吗？</li></ol><p>这是因为，其它事务B同时插入了一行新数据，年龄就是20岁。所以再读发现没修改。</p></blockquote></li><li><p><strong>Serializable</strong>： 序列化，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。耗费性能，一般不用。</p></li></ul><h5 id="2-1【猿辅导】-怎么解决幻读？">2.1【猿辅导】 怎么解决幻读？</h5><p>解决幻读使用两种方式：</p><ol><li><p><strong>间隙锁</strong></p><ul><li><p><strong>间隙锁（Gap Lock</strong>）：当我们用【范围条件】而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给<strong>符合条件的已有数据记录的索引项加锁</strong>；对于键值在<strong>条件范围内但并不存在的记录，叫做“间隙（GAP)”</strong>，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁；</p></li><li><p><strong>举例</strong>： 假如user表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  <span class="keyword">user</span> <span class="keyword">where</span> user_id <span class="operator">&gt;</span> <span class="number">99</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><p>是一个范围条件的检索，InnoDB不仅会对（1）<strong>符合条件的user_id值（100、101）的记录加锁</strong>，也会对（2）user_id大于101（这些<strong>记录并不存在）的“间隙”加锁</strong>。</p></li><li><p><strong>如何解决幻读</strong>？ 产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”，导致下次读取产生幻读。如果锁住了间隙，自然也就没锁的问题了。</p></li></ul></li><li><p><strong>mvvc</strong></p><p>在RR（可重复读级别下）不会出现幻读。例如：</p><ol><li><p>开启事务1，获得事务ID为1。</p></li><li><p>事务1执行查询，得到readview。</p></li><li><p>开始事务2。</p></li><li><p>执行insert。</p></li><li><p>提交事务2。</p></li><li><p>执行事务1的第二次查询 (因为这里是RR级别，所以<strong>不会再去获得readview，<strong>还是使用第一次获得的readview，所以</strong>当前read view 事务的ID不会更新</strong>，即不会加入插入事务2)</p></li><li><p>最后得到的结果是，插入的数据不会被读取显示，因为<strong>插入的数据事务ID &gt; readview里的最大活跃事务ID</strong>。</p></li></ol></li></ol><h2 id="5-4-MySQ优化">5.4 MySQ优化</h2><h4 id="0-分页查询慢的原因？如何优化？">0. 分页查询慢的原因？如何优化？</h4><blockquote><p>参考：<a href="https://juejin.cn/post/6844904141878214664">https://juejin.cn/post/6844904141878214664</a></p></blockquote><p>在偏移量非常大的时候，也就是翻页到很靠后的页面时，查询速度会变得越来越慢，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_order order by id limit 1000000000, 10;</span><br></pre></td></tr></table></figure><p>这是因为，需要查询 100000000010 (100000000000 + 10) 条记录，然后只返回最后 10 条，并将前面的 100000000000 条记录抛弃，这样当翻页越靠后时，代价就变得越来越高。</p><p><strong>优化方法</strong>：</p><ol><li><p><strong>最大id法</strong></p><ul><li><p>举例：查询第一页的时候是limit 400000,10 查询到的最后一条id是4000000，那么下一页的查询只需要查询id大于400000的10条数据即可。</p></li><li><p>语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from user where id &gt; 4000000  limit 10;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>BETWEEN … AND</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id BETWEEN 4000000 and 4000010</span><br></pre></td></tr></table></figure></li><li><p><strong>分表查询</strong></p><p>mysql推荐一张表的存储不要超过500w数据，查询400w不到1秒对于一般的查询来说已经可以了，如果还要更快的话，我建议使用分表存储，分表又分两种情况，水平分表于垂直分表。</p></li><li><p><strong>延迟关联（个人推荐</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table a,(select id from table limit 100000,20) b on a.id=b.id</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-SQL优化手段有哪些？">1. <strong>SQL优化手段有哪些</strong>？</h4><ol><li><p>查询语句中不要使用select</p></li><li><p><strong>尽量减少子查询，使用关联查询</strong>（left join,right join,inner join）替代</p></li><li><p><strong>减少使用IN或者NOT IN ,使用exists，not exists</strong>或者关联查询语句替代(在确认没有重复数据或者不用剔除重复数据时，union all会更好)</p></li><li><p><strong>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符</strong>，否则将引擎放弃使用索引而进行全表扫描。</p></li><li><p><strong>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</strong>，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0</p></li></ol><h4 id="2-请问如何防止SQL被注入？">2.<strong>请问如何防止SQL被注入</strong>？</h4><ul><li><p><strong>什么是SQL注入</strong>？</p><p>攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。</p><ul><li><p>例如：用户登录，攻击者输入：<code>用户名 = liangzone</code>，<code>密码 = ‘ or ‘1’=’1</code>  ，那么拼接后的语句是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name = ‘lianggzone’ and password = ‘’ or ‘1’=‘1’ </span><br></pre></td></tr></table></figure><p>攻击者就可以<strong>查询出所有的用户表信息</strong>！</p></li></ul></li><li><p><strong>如何防范SQL注入</strong>？</p><ul><li>Web端：1）有效性检验； 2）限制字符串输入的长度</li><li>服务器端：1）不用拼接SQL字符串， 2）使用预编译的PrepareStatement， 3）有效性检验，4）<strong>过滤SQL需要的参数中的特殊字符，比如单引号、双引号</strong>。</li></ul></li></ul><h4 id="3-MySQL-如何做到高并发解决方案？">3. <strong>MySQL 如何做到高并发解决方案</strong>？</h4><ol><li><strong>在web服务框架中加入缓存</strong>。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li><li><strong>增加数据库索引，进而提高查询速度</strong>。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li><li><strong>主从读写分离分库</strong>，让主服务器负责写，从服务器负责读。</li><li><strong>将数据库表进行拆分表</strong>，使得数据库的表尽可能小，提高查询的速度。</li><li><strong>使用分布式架构</strong>，分散计算压力。</li></ol><h4 id="4-大表如何进行优化？">4. 大表如何进行优化？</h4><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，⼀些常⻅的优化措施如下。</p><ul><li><p><strong>限定数据的范围</strong>：务必禁⽌不带任何限制数据范围条件的查询语句。⽐如：我们当⽤户在查询订单历史的时候，我们可以控制在⼀个⽉的范围内；</p></li><li><p><strong>读/写分离</strong>：经典的数据库拆分⽅案，主库负责写，从库负责读；</p></li><li><p><strong>垂直分区</strong>：根据数据库⾥⾯数据表的相关性进行拆分。</p><blockquote><p>例如，⽤户表中既有⽤户的登录信息⼜有⽤户的基本信息，可以将⽤户表拆分成两个单独的表，甚⾄放到单独的库做分库。</p><ul><li><p>简单来说垂直拆分是指数据表列的拆分，把⼀张列⽐较多的表拆分为多张表。</p><p><img src="https://i.loli.net/2021/05/16/25HtBIuXygCUVrq.png" alt="image-20210516234359675"></p></li></ul></blockquote></li><li><p><strong>水平分区 :</strong> 保持数据表结构不变，通过某种策略存储数据分⽚。这样每⼀⽚数据分散到不同的表或者库中，<strong>达到了分布式的⽬的</strong>。 ⽔平拆分可以支撑⾮常大的数据量。</p></li></ul><p>其它数据库结构方面优化：</p><ul><li><strong>范式优化</strong>： 比如消除冗余（节省空间。。）</li><li><strong>反范式优化</strong>：比如适当加冗余等（减少join）</li></ul><h4 id="5-数据库如何去重？">5. 数据库如何去重？</h4><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000002508404">MySQL数据库行去重复和列去重复</a></p></blockquote><h5 id="5-1-行去重">5.1 行去重</h5><blockquote><p>存在行重复，则无法建立 <u>唯一索引</u> 等。</p></blockquote><blockquote><p>用<code>distinct</code> 得到我们要保留的数据也是可以的。</p></blockquote><p>下面假设的是email字段重复。</p><ol><li><p>查看我们的分组后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *,count(id) from demo_table group by email having count(id)&gt;1 order by id;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----+------+--------------+-----------+</span><br><span class="line">| id | name | email        | count(id) |</span><br><span class="line">+----+------+--------------+-----------+</span><br><span class="line">|  1 | u1   | u1@email.com |         4 |</span><br><span class="line">|  2 | u2   | u2@email.com |         4 |</span><br><span class="line">|  3 | u3   | u3@email.com |         3 |</span><br><span class="line">|  4 | u4   | u4@email.com |         2 |</span><br><span class="line">|  5 | u5   | u5@email.com |         2 |</span><br><span class="line">+----+------+--------------+-----------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>保留每个分组<strong>最小的id</strong>，表中其余都删除</p><p>在表中删除不符合要求的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from demo_table where id not in (select min(id) from demo_table group by email);</span><br></pre></td></tr></table></figure><p>但是似乎有保护机制，无法直接删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1093 (HY000): You can&#x27;t specify target table &#x27;demo_table&#x27; for update in FROM clause</span><br></pre></td></tr></table></figure></li><li><p>创建临时表再删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建临时表保存每个分组中最小的那个id</span><br><span class="line">create table tmp_table as select min(id) from demo_table group by email;</span><br><span class="line"></span><br><span class="line"># 删除表中数据</span><br><span class="line">delete from demo_table where id not in (select * from tmp_table);</span><br><span class="line"></span><br><span class="line"># 删除临时表</span><br><span class="line">drop table tmp_table;</span><br></pre></td></tr></table></figure></li></ol><h5 id="5-2-列重复">5.2 列重复</h5><ol><li><p>先找到重复字段的<strong>行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from demo_table as a, demo_table as b where a.id=b.id and a.name=b.email;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----+--------------+--------------+----+--------------+--------------+</span><br><span class="line">| id | name         | email        | id | name         | email        |</span><br><span class="line">+----+--------------+--------------+----+--------------+--------------+</span><br><span class="line">| 31 | 31@email.com | 31@email.com | 31 | 31@email.com | 31@email.com |</span><br><span class="line">| 32 | 32@email.com | 32@email.com | 32 | 32@email.com | 32@email.com |</span><br><span class="line">| 33 | 33@email.com | 33@email.com | 33 | 33@email.com | 33@email.com |</span><br><span class="line">| 34 | 34@email.com | 34@email.com | 34 | 34@email.com | 34@email.com |</span><br><span class="line">| 35 | 35@email.com | 35@email.com | 35 | 35@email.com | 35@email.com |</span><br><span class="line">+----+--------------+--------------+----+--------------+--------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>重复记录的id都已经找出来了，删除就参考上述方式处理了。</p></li></ol><h4 id="6-select慢的原因？慢查询的优化策略？">6. select慢的原因？慢查询的优化策略？</h4><h5 id="6-1-select-很慢的原因">6.1 select 很慢的原因</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/kubidemanong/p/10734045.html">腾讯面试：一条SQL语句执行得很慢的原因有哪些?</a></p></blockquote><ul><li><p><strong>如果是偶尔很慢</strong></p><p>针对这种情况，这条SQL语句的书写本身是没什么问题的。可能是其它原因导致：</p><ol><li><strong>被加锁。</strong> 要执行的这条语句，刚好这条语句涉及到的<strong>表</strong>，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了；或者，表没有加锁，但要使用到的某个一<strong>行</strong>被加锁了 。</li><li>数据库在刷新脏页 ？ 看链接，不太明白流程。</li></ol></li><li><p><strong>如果是经常很慢</strong></p><ol><li><p><strong>没用到索引</strong></p></li><li><p><strong>索引失效了</strong> ：</p><p>（1）联合索引不满足最左匹配（不包含第一个索引）；</p><p>（2）like语句不满足最左匹配（不包含第一个索引）</p><p>（3）或者索引加上了运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c - 1 = 1000;</span><br></pre></td></tr></table></figure><p>这种情况不会有效，应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c = 1000 + 1;</span><br></pre></td></tr></table></figure><p>（4）或者函数操作用上索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where pow(c,2) = 1000;</span><br></pre></td></tr></table></figure></li><li><p><strong>数据库使用非聚簇索引</strong></p><p>我们在进行查询操作的时候，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where 100 &lt; c and c &lt; 100000;</span><br></pre></td></tr></table></figure><p>此时使用的非聚簇索引（辅助索引），只是存储了<strong>主键的key</strong> ，还是要再次通过聚簇索引去查找。效率可能不必全表扫描高。</p></li></ol></li></ul><h4 id="7-select…for-update用法？">7. select…for update用法？</h4><blockquote><p><a href="https://segmentfault.com/a/1190000023045909">数据库-MySQL中for update的作用和用法</a></p></blockquote><p><code>for update</code>是一种<code>行级锁</code>，又叫<code>排它锁</code>。</p><p>一旦用户对某个行施加了行级加锁，则<strong>该用户可以查询也可以更新</strong>被加锁的数据行，<strong>其它用户只能查询</strong>但不能更新被加锁的数据行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 开启事务</span><br><span class="line">begin;</span><br><span class="line">SELECT * FROM user WHERE id=3 FOR UPDATE;</span><br><span class="line">SELECT * FROM user WHERE id=3 and name=&#x27;Tom&#x27; FOR UPDATE;</span><br><span class="line">-- 提交事务</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><h4 id="8-场景题：假如选择MySQL数据库，一天五万条增量，运维三年，有哪些优化手段？">8. 场景题：假如选择MySQL数据库，一天五万条增量，运维三年，有哪些优化手段？</h4><ol><li><strong>设计良好的数据库结构</strong>，允许部分数据冗余，尽量避免join查询，提高效率；</li><li>选择合适的表字段数据类型和存储引擎，适当的<strong>添加索引</strong>；</li><li>MySQL库主从<strong>分库读写分离</strong>；</li><li>找规律<strong>分表</strong>，减少单表中的数据量提高查询速度；</li><li><strong>添加缓存机制</strong>，比如Memcached，Apc等；</li><li><strong>书写高效率的SQL</strong>。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 校招 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（四）_计算机基础_操作系统</title>
      <link href="/p/15646/"/>
      <url>/p/15646/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h1>四、操场系统</h1><h2 id="4-1-操作系统基础">4.1 操作系统基础</h2><h4 id="0-（百度安全一面）-冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？">0. （百度安全一面） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？</h4><ul><li>存储器：内存</li><li><strong>控制器：南桥北桥</strong></li><li>运算器：CPU</li><li>输入设备：键盘</li><li>输出设备：显示器、网卡</li></ul><h4 id="1-什么是操作系统？">1. 什么是操作系统？</h4><ol><li>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基⽯；</li><li>操作系统本质上是运行在计算机上的软件程序 ；</li><li>操作系统为用户提供⼀个与系统交互的操作界面 ；</li><li>操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。</li></ol><h4 id="2-什么是系统调用呢？-能不能详细介绍⼀下？">2. 什么是系统调用呢？ 能不能详细介绍⼀下？</h4><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ol><li><strong>用户态(user mode) :</strong> 用户态运行的进程或可以直接读取用户程序的数据。</li><li><strong>系统态(kernel mode)</strong>：可以简单的理解系统态运行的进程或程序⼏乎可以访问计算机的任何资源，不受限制。</li></ol><p>我们运行的程序基本都是运行在<strong>用户态</strong>，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p><p>这些系统调用按功能大致可分为如下⼏类：</p><ul><li><strong>设备管理</strong>。完成设备的请求或释放，以及设备启动等功能。</li><li><strong>⽂件管理</strong>。完成⽂件的读、写、创建及删除等功能。</li><li><strong>进程控制</strong>。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li><strong>进程通信</strong>。完成进程之间的消息传递或信号传递等功能。</li><li><strong>内存管理</strong>。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li></ul><h4 id="3-CentOS-和-Linux的关系？">3. <strong>CentOS 和 Linux的关系？</strong></h4><p>Linux意思较广广义的范围，多指是Linux内核。CentOS是RedHat的一个分支，RedHat是Linux的一个发行版本，RedHat与CentOS的区别在于，RedHat收费，CentOS免费。</p><h4 id="4-什么是分布式，优缺点？集群？">4. 什么是分布式，优缺点？集群？</h4><ul><li><p><strong>分布式</strong></p><p>根据业务需求进行拆<strong>分成N个子系统</strong>，多个子系统相互协作才能完成业务流程<strong>子系统之间通讯</strong>使用<strong>RPC</strong>远程通讯技术。</p></li><li><p><strong>集群</strong></p><p>同一个工程部署在多个不同的服务器上。</p></li><li><p><strong>分布式优点</strong></p><p>1.把模块拆分，使用接口通信，降低模块之间的耦合度。</p><p>2.把项目拆分成若干个子项目，不同的团队负责不同的子项目。</p><p>3.增加功能时只需要再增加一个子项目，调用其它系统的接口就可以。</p><p>4.可以灵活的进行分布式部署。</p></li><li><p><strong>分布式缺点</strong></p><p>1.系统之间交互需要使用远程通信，接口开发增加工作量。</p><p>2.各个模块有一些通用的业务逻辑无法共用。</p></li></ul><h4 id="5-在Linux-windows栈空间的大小？">5. 在Linux/windows栈空间的大小？</h4><ul><li><p><strong>Linux环境下由操作系统决定</strong>，一般是<code>8KB</code> ， 通过ulimit命令查看以及修改</p><blockquote><p>在Linux下通过如下命令可查看和设置栈的大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">ulimit</span> -a            <span class="comment"># 显示当前栈的大小 （ulimit为系统命令，非编译器命令）</span></span>       </span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">ulimit</span> -s 32768      <span class="comment"># 设置当前栈的大小为32MCopy to clipboardErrorCopied</span></span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>Windows环境下由编译器决定</strong>，VC++6.0一般是<code>1M</code> \</p><blockquote><p>Windows平台下栈的大小是被记录在可执行文件中的（由编译器来设置)，即：windows下可以由编译器决定栈大小，而在Linux下是由系统环境变量来控制栈的大小的。</p></blockquote></li></ul><h4 id="6-ASCII、Unicode和UTF-8编码的区别？">6. ASCII、Unicode和UTF-8编码的区别？</h4><ul><li><p><strong>ASCII :</strong>  ASCII 只有127个字符，表示英文字母的大小写、数字和一些符号 ；</p><blockquote><p>常用中文需要两个字节，且不能和ASCII冲突，中国定制了<code>GB2312</code>编码格式。</p></blockquote></li><li><p><strong>Unicode：</strong> Unicode就是将<strong>不同语言统一到一套编码格式中</strong>，通常<strong>两个</strong>字节表示一个字符，而<strong>ASCII是一个</strong>字节表示一个字符 ；</p><blockquote><p>如果你编译的文本是全英文的，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p></blockquote></li><li><p><strong>UTF-8 :</strong>  把Unicode编码转化为 “<strong>可变长编码</strong>” UTF-8编码，UTF-8编码将Unicode字符按数字大小编码为<strong>1-6</strong>个字节，英文字母被编码成<strong>1</strong>个字节，常用汉字被编码成<strong>2</strong>个字节。</p></li></ul><h5 id="6-1-三者区别和联系">6.1 三者区别和联系</h5><ul><li><p>在<strong>计算机内存</strong>中，统一使用<strong>Unicode</strong>编码 ；</p></li><li><p>当需要<strong>保存到硬盘或者需要传输</strong>的时候，就转换为<strong>UTF-8</strong>编码</p></li></ul><p>举例说明：</p><blockquote><p>例1 ：记事本编辑（内存）→保存（磁盘）。</p></blockquote><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。</p><p><img src="https://i.loli.net/2021/06/11/9IjWniLHqrwRd2s.png" alt="image-20210611131935690"></p><blockquote><p>例2：网络传输服务器→浏览器。</p></blockquote><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。</p><p><img src="https://i.loli.net/2021/06/11/hZFaKbezvQEsxko.png" alt="image-20210611132058826"></p><h4 id="7-什么是并发和并行？同步和异步？">7. 什么是并发和并行？同步和异步？</h4><ul><li><strong>并发和并行</strong><ul><li><strong>并发</strong>： 是指宏观上在<strong>一段时间</strong>内能同时运行多个<strong>程序</strong>；</li><li><strong>并行</strong> ：则指<strong>同一时刻</strong>能运行多个<strong>指令</strong>。</li></ul></li><li><strong>同步和异步</strong><ul><li><p><strong>同步</strong>：可以理解为在执行完一个函数或方法之后，<strong>一直等待系统返回值或消息，这时程序是出于阻塞的</strong>，只有接收到返回的值或消息后才往下执行其他的命令。</p></li><li><p><strong>异步</strong>：执行完函数或方法后，<strong>不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程</strong>，那么当系统接收到返回值或消息时，系统会<strong>自动触发委托的异步过程</strong>，从而完成一个完整的流程。</p></li></ul></li></ul><h4 id="8-什么是共享？">8. 什么是共享？</h4><ul><li><p><strong>共享定义</strong>： 系统中的资源可以被多个并发进程共同使用 ；</p></li><li><p><strong>共享方式</strong>：<u>互斥</u>共享和<u>同时</u>共享：</p><ul><li><strong>互斥共享</strong>： 在<strong>同一时刻只允许一个进程访问</strong>，需要用同步机制来实现互斥访问 ，如：打印机。</li></ul></li></ul><h2 id="4-2-进程和线程">4.2 进程和线程</h2><h4 id="1-请问64位和32位的区别？">1.<strong>请问64位和32位的区别</strong>？</h4><ol><li><strong>运行能力不同</strong>：64位可以一次性可以处理8个字节的数据量，而32位一次性只可以处理4个字节的数据量，因此64位比32位的运行能力提高了一倍。</li><li><strong>内存寻址不同</strong>：64位最大寻址空间为2的64次方，理论值直接达到了16TB，而32位的最大寻址空间为2的32次方，为4GB，换而言之，就是说32位系统的处理器最大只支持到4G内存，而64位系统最大支持的内存高达亿位数。</li><li><strong>运行软件不同</strong>：由于32位和64位<u>CPU的指令集是不同</u>的。所以需要区分32位和64位版本的软件。<br>为了保证兼容性，64位CPU上也能运行老的32位指令，但反过来32位系统不可以运行64位的软件。</li></ol><h4 id="2-介绍一下线程和进程的区别？">2.<strong>介绍一下线程和进程的区别？</strong></h4><ol><li><p><strong>根本区别</strong>：进程是操作系统<strong>资源分配</strong>的基本单位，而线程是处理器<strong>任务调度</strong>和执行的基本单位</p></li><li><p><strong>资源开销：每个进程都有独立的代码和数据空间（程序上下文）</strong>，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，<strong>每个线程都有自己独立的运行栈和程序计数器</strong>（PC），线程之间切换的开销小</p></li><li><p><strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</p></li><li><p><strong>内存分配</strong>：同一进程的线程<strong>共享本进程的【地址空间和资源】</strong>，而进程之间的地址空间和资源是相互独立的</p></li><li><p><strong>影响关系</strong>：一个进程崩溃后，在保护模式下不会对其他进程产生影响，<strong>但是一个线程崩溃整个进程都死掉</strong>，<strong>所以多进程要比多线程健壮</strong>。</p><blockquote><p>线程没有独立的地址空间，如果崩溃，会发信号，如果没有错误处理的handler，OS一般直接杀死进程。</p></blockquote></li><li><p><strong>能否独立</strong>：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p></li></ol><h5 id="2-1-线程和协程之间的区别？">2.1 线程和协程之间的区别？</h5><blockquote><p><strong>进程是资源调度的基本单位</strong>，<strong>运行一个可执行程序会创建一个或多个进程</strong>，进程就是运行起来的可执行程序 ;</p><p><strong>线程是程序执行的基本单位</strong>，是轻量级的进程。<strong>每个进程中都有唯一的主线程，和多个线程</strong>，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束；</p><p><strong>协程</strong>是用户态的<strong>轻量级线程</strong>，<strong>也是线程内部调度的基本单位</strong> 。</p></blockquote><p>协程和线程的区别如下（补充了和进程的区别，方便对比）。</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">进程</th><th style="text-align:left">线程</th><th>协程</th></tr></thead><tbody><tr><td style="text-align:left">定义</td><td style="text-align:left">资源分配和拥有的基本单位</td><td style="text-align:left">程序执行的基本单位</td><td>用户态的轻量级线程，线程内部调度的基本单位</td></tr><tr><td style="text-align:left">切换情况</td><td style="text-align:left">进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td><td style="text-align:left">保存和设置程序计数器、少量寄存器和栈的内容</td><td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td></tr><tr><td style="text-align:left">切换者</td><td style="text-align:left">操作系统</td><td style="text-align:left">操作系统</td><td>用户</td></tr><tr><td style="text-align:left">切换过程</td><td style="text-align:left">用户态-&gt;内核态-&gt;用户态</td><td style="text-align:left">用户态-&gt;内核态-&gt;用户态</td><td>用户态(没有陷入内核)</td></tr><tr><td style="text-align:left">调用栈</td><td style="text-align:left">内核栈</td><td style="text-align:left">内核栈</td><td>用户栈</td></tr><tr><td style="text-align:left">拥有资源</td><td style="text-align:left"><strong>CPU资源、内存资源、文件资源和句柄等</strong></td><td style="text-align:left"><strong>程序计数器、寄存器、栈和状态字</strong></td><td><strong>拥有自己的寄存器上下文和栈</strong></td></tr><tr><td style="text-align:left">并发性</td><td style="text-align:left">不同进程之间切换实现并发，各自占有CPU实现并行</td><td style="text-align:left">一个进程内部的多个线程并发执行</td><td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td></tr><tr><td style="text-align:left">系统开销</td><td style="text-align:left">切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td><td style="text-align:left">切换时只需保存和设置少量寄存器内容，因此开销很小</td><td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td></tr><tr><td style="text-align:left">通信方面</td><td style="text-align:left">进程间通信需要借助操作系统</td><td style="text-align:left">线程间可以直接读写进程数据段(如全局变量)来进行通信</td><td>共享内存、消息队列</td></tr></tbody></table><h5 id="2-2-一个进程可以创建多少个线程，和什么有关？">2.2 一个进程可以创建多少个线程，和什么有关？</h5><p>一个进程可用虚拟空间是（C++）2G，默认情况下，（假设）<strong>线程的栈的大小是1MB</strong>（Linux是8kb），则理论上最多只能创建2048个线程。如果要创建多于2048的话，必须修改编译器的设置。</p><h5 id="2-3-进程之间的同步方式？（区分通信方式）">2.3 进程之间的同步方式？（区分通信方式）</h5><ol><li><p><strong>临界区</strong>。 对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p></li><li><p><strong>同步和互斥</strong>。</p><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻<strong>只有一个进程</strong>能进入临界区。</li></ul></li><li><p><strong>信号量</strong>。 常见的 P 和 V 操作。</p><ul><li>特别的，<u>如果信号量的取值只能为 0 或者 1</u>，那么就成为了<strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</li></ul></li><li><p><strong>条件变量</strong>。</p><blockquote><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p></blockquote><p>管程引入了<strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程：解决生产者、消费者问题</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function">procedure <span class="title">insert</span><span class="params">(item: integer)</span></span>;</span><br><span class="line">    begin</span><br><span class="line">        <span class="keyword">if</span> count = N then wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> then signal(empty);</span><br><span class="line">    end;</span><br><span class="line"></span><br><span class="line">    function remove: integer;</span><br><span class="line">    begin</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> then wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N <span class="number">-1</span> then signal(full);</span><br><span class="line">    end;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line">procedure producer</span><br><span class="line">begin</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    begin</span><br><span class="line">        item = produce_item;</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    end</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line">procedure consumer</span><br><span class="line">begin</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    begin</span><br><span class="line">        item = ProducerConsumer.remove;</span><br><span class="line">        consume_item(item);</span><br><span class="line">    end</span><br><span class="line">end;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-请问【进程】之间如何进行通信？">3.<strong>请问【进程】之间如何进行通信</strong>？</h4><p>可以分为如下两个方面：</p><ol><li>本地进程之间的通信方式</li><li>远程进程之间的通信方式</li></ol><p><strong>1. 本地进程之间的通信方式（没有同步互斥！！</strong>）</p><ul><li><p><strong>无名管道</strong> ：半双工通信方式，<strong>数据(消息)单向流动</strong>，只能是字节流格式的消息。</p><ul><li><strong>优点</strong>：简单方便</li><li><strong>缺点</strong>：单向通信、只能用于<strong>具有亲缘关系（一般指父子</strong>）的进程之间、<strong>缓冲区有限</strong></li></ul></li><li><p><strong>有名管道：半双工通信</strong>方式，数据也称为命名管道：是一种文件类型，以一种特殊设备文件形式存在于文件系统中。</p><ul><li><strong>优点</strong>：可以实现<strong>任意关系的进程</strong>间的通信（无法同步）</li><li><strong>缺点</strong>： 长期存于系统中，使用不当容易出错、<strong>缓冲区有限</strong></li></ul></li><li><p><strong>消息队列</strong>：消息队列是消息的<strong>链表</strong>,存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少,管道只能承载无格式字节流以及缓冲区大小受限等特点。</p><ul><li><strong>优点</strong>：<u>可以实现任意进程间的通信</u>，并通过系统调用函数来实现消息发送和接收之间的同步<u>，无需考虑同步</u>问题</li><li><strong>缺点</strong>：信息的复制需要<u>额外消耗CPU的时间</u>，不适宜于信息量大或操作频繁的场合</li></ul></li><li><p><strong>共享内存</strong></p><p>直接对内存存取，<u>通信快</u>，但是多个进程可以同时操作，<u>需要用信号量进行同步</u>。</p></li><li><p><strong>信号量</strong></p><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><ul><li><p><strong>优点</strong>：可以同步进程；</p></li><li><p><strong>缺点</strong>：信号量有限</p><blockquote><p>注解：P操作就是对S减一，V操作就是对S加一</p></blockquote><ul><li><strong>同步</strong>：S = 0，进程A执行完进行V操作，进程B执行前执行P操作，这样B就可以等A执行完再执行；</li><li><strong>互斥</strong>：S = 1，进程执行前进行P操作，执行后进行V操作。</li></ul></li></ul></li></ul><p><strong>2.远程进程之间的通信方式</strong></p><p>首要解决的问题是如何唯一标识一个进程？本地上采用PID即可，但是网络中 <u>TCP/IP五层网络模型中传输层的 “<strong>套接字：IP+端口</strong>”</u></p><ul><li><p><strong>套接字交互</strong></p><ul><li><strong>优点</strong>：1）传输数据为字节级，传输数据可自定义，数据量小效率高；2）传输数据时间短，性能高；3) 适合于客户端和服务器端之间信息实时交互；4) 可以加密,数据安全性强</li><li><strong>缺点</strong>：1) 需对传输的数据进行解析，转化成应用级的数据。</li></ul></li><li><p><strong>远程过程调用（RPC）</strong></p></li></ul><h4 id="4-请问【线程】间同步方式（通信方式）？">4. 请问【线程】间同步方式（通信方式）？</h4><p><img src="https://i.loli.net/2021/06/11/38AqLbJEZnhSPC9.png" alt="image-20210611000107784"></p><p>【<strong>1. Linux下线程通知方式</strong>】</p><ol><li><strong>互斥量(Mutex)</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有⼀个，所以可以保证公共资源不会被多个线程同时访问。<ul><li>⽐如 Java 中的<strong>synchronized 关键词和各种 Lock锁</strong> 都是这种机制。</li></ul></li><li><strong>信号量(Semphares)</strong> ：它允许同⼀时刻多个线程访问同⼀资源，但是需要控制同⼀时刻访问此资源的最大线程数量</li><li><strong>条件变量</strong> : 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级<ul><li>比如Wait/Notify</li></ul></li></ol><p>【<strong>2. Windows下线程通知方式</strong>】</p><ol><li><strong>全局变量</strong>：需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防编译器对此变量进行优化 ；</li><li><strong>CEvent对象</strong>：CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法；</li><li><strong>Message消息机制</strong>：常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。</li></ol><h4 id="5-什么时候用多线程-多进程？">5.<strong>什么时候用多线程 / 多进程</strong>？</h4><ul><li><strong>需要<u>频繁创建销毁</u>的优先用线程</strong> ：创建和销毁的代价是很难承受的 ；</li><li><strong>需要进行<u>大量计算</u>的优先使用线程</strong> ：此时<strong>耗费很多CPU，切换频繁</strong>，用线程更轻量；</li><li><strong>任务间相关性比较强的用多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单；</li></ul><p>考虑多进程：</p><ul><li>扩展到<strong>多机分布</strong>的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong> ；</li><li>其它一般用多线程比较好</li></ul><h4 id="6-【线程】调度算法？">6.<strong>【线程】调度算法？</strong></h4><p>在资源一定的情况下，调度算法需要在<strong>吞吐量（Throughput）、平均响应时间（延迟，Average Response Time）、公平性、调度引起的额外开销（overhead</strong>）等几个方面做权衡。</p><ol><li><p><strong>先进先出算法（FIFO，First-In-First-Out）</strong></p><ul><li><strong>优点</strong>：<ul><li><strong>最少的任务切换开销</strong>（因为没有在任务执行过程中发生切换，故任务切换开销为0）</li><li><strong>最大的吞吐量</strong>（因没有任务切换开销，在其他一定的情况下，吞吐量肯定是最大的）</li><li><strong>最朴实的公平性</strong>（先来先做）</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>平均响应时间高</strong>：耗时只需10毫秒的任务若恰巧在耗时1000毫秒的任务后到来，他则需要1010毫秒才能执行完成，绝大部分时间都花在等待被调度。</li></ul></li></ul></li><li><p><strong>最短耗时任务优先算法</strong></p><p>优先调度耗时短的任务，需要预先知道每个任务的耗时情况，这在实际情况中是不大现实的。</p><ul><li>（<strong>优点</strong>）<strong>平均响应时间较低</strong>：这里有一点，因为将时间长的任务无限往后推移，实际计算的平均响应时间的任务都是执行较快的任务，统计出来的平均响应时间必然较低的。</li><li><strong>（缺点</strong>）<strong>耗时长任务饥饿</strong>：耗时长的任务迟迟得不到调度，不公平，容易形成饥饿 。</li><li><strong>（缺点</strong>）<strong>开销大</strong>：<u>频繁的任务切换</u>，调度的额外开销大。</li></ul></li><li><p><strong>时间片轮转算法</strong></p><p>给队列中的每个任务一个时间片，第一个任务先执行，时间片到了之后，将此任务放到队列尾部，切换到下个任务执行，<u>解决最短耗时任务优先算法中耗时长任务饥饿的问题</u> 。</p><ul><li><strong>（特点）时间片设置问题</strong>： 算法介于FIFO和SJF之间，若时间片足够<strong>大</strong>，则退化到FIFO ；若分片足够小（假设不考虑任务切换的开销），则任务的完成时间顺序是以耗时从小到大排列。</li><li>（<strong>优点）公平调度</strong>：每个任务都能够得到公平的调度<ul><li>（<strong>优点）不会饥饿</strong>：耗时短的任务即使落在耗时长的任务后面，也能够较快的得到调度执行</li></ul></li><li><strong>（缺点）开销大</strong>：<u>任务切换引起的调度开销较大</u>，需要多次切换任务上下文<ul><li><strong>（缺点</strong>）时间片不太好设置</li></ul></li></ul></li><li><p><strong>最大最小公平算法</strong></p></li></ol><h4 id="7-【进程】调度算法？">7.<strong>【进程】调度算法？</strong></h4><ul><li>先来先服务调度算法</li><li>短作业(进程)优先调度算法</li><li>时间片轮转法</li><li><strong>多级反馈队列调度算法</strong></li><li>优先权调度算法</li></ul><h4 id="8-CPU上下文切换？有什么类型？线程发生在什么地方？">8. <strong>CPU上下文切换？有什么类型？线程发生在什么地方？</strong></h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/52845869">https://zhuanlan.zhihu.com/p/52845869</a></p></blockquote><ul><li><p><strong>什么是 CPU 上下文</strong> ？</p><p><u>CPU 寄存器和程序计数器</u> 就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前，<strong>必须的依赖环境</strong>。</p><blockquote><ul><li><u>CPU 寄存器</u> 是 CPU 内置的容量小、但速度极快的内存。</li></ul></blockquote></li><li><p><strong>什么是 CPU 上下文切换?</strong></p><p>通常指以下过程：</p><ol><li>前一个任务的 CPU 上下文（也就是 <strong>CPU 寄存器和程序计数器</strong>）保存起来;</li><li>然后加载新任务的上下文到这些寄存器和程序计数器;</li><li>最后再跳转到程序计数器所指的新位置，运行新任务。</li></ol></li><li><p><strong>CPU 上下文切换的类型</strong>？</p><p>根据任务的不同，可以分为以下三种类型 : <strong>进程上下文切换 - 线程上下文切换 - 中断上下文切换</strong> 。</p><ol><li><p><strong>进程上下文切换</strong></p><p>进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。</p><blockquote><ul><li><p>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</p></li><li><p>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</p></li></ul></blockquote><p>从用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成，在<u>这个过程中就发生了 <strong>CPU</strong> 上下文切换（<strong>两</strong>次，用户态-内核态-用户态））</u>。</p><blockquote><p><strong>系统调用</strong> : 查看文件时read()、wirte() 操作就发生了系统调用。</p><p>但是，系统调用过程中，<strong>并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程</strong>。</p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-440bb1699b2fa0f0340b38eabcbd7452_720w.jpg" alt="img"></p><p>而<u><strong>进程</strong>上下文切换</u> ，比系统调用时多了一步：在<strong>保存内核态资源</strong>（当前进程的<u>内核状态和 CPU 寄存器</u>）之前，需要先把该进程的<strong>用户态资源</strong>（<u>虚拟内存、栈等</u>）保存下来。</p></li><li><p><strong>线程上下文调用</strong></p><p>线程是调度的基本单位，而进程则是资源拥有的基本单位。</p><p>【面试高频】发生线程上下文切换的场景</p><ul><li><strong>前后两个线程属于不同进程</strong>。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。</li><li><strong>前后两个线程属于同一个进程</strong>。此时，因为虚拟内存是共享的，所以在切换时，<u>虚拟内存</u>这些资源就保持不动，只需要切换<strong>线程的私有数据（栈、寄存器等</strong>)不共享的数据</li></ul></li><li><p><strong>中断上下文切换</strong></p></li></ol></li></ul><h4 id="9-如何杀死一个进程？进程终止的方式？">9.<strong>如何杀死一个进程</strong>？进程终止的方式？</h4><ol><li>linux命令：<code>kill -9 &lt;pid&gt;</code></li><li>接受能导致进程终止的信号：ctrl+c (^C)、SIGINT(SIGINT中断进程)</li><li>main函数的自然返回，<code>return</code></li><li>调用<code>exit</code>函数，属于c的函数库 3、调用<code>_exit</code>函数，属于系统调用</li><li>调用<code>abort</code>函数，异常程序终止，同时发送SIGABRT信号给调用进程</li></ol><h5 id="9-1-终端退出，终端运行的进程会怎么样？">9.1 终端退出，终端运行的进程会怎么样？</h5><ol><li><p>终端在退出时会发送<code>SIGHUP</code>给对应的bash进程，</p></li><li><p>bash进程收到这个信号后首先将它发给session下面的进程</p><blockquote><p>一个session就是一个shell终端会话窗口。</p></blockquote></li><li><p>如果程序没有对SIGHUP信号做特殊处理，那么进程就会随着终端关闭而退出</p></li></ol><h5 id="9-2-怎么让进程后台运行？">9.2 怎么让进程后台运行？</h5><ol><li><code>命令 + &amp;</code> 即可，实际上，这样是将命令放入到一个作业队列中了</li><li><code>ctrl + z</code> 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程</li><li><code>nohup + &amp;</code>，将标准输出和标准错误缺省会被重定向到 nohup.out 文件中，忽略所有挂断（SIGHUP）信号</li><li><code>setsid + 命令</code>，使其父进程编程init进程，不受HUP信号的影响</li><li>将<code>命令+ &amp;</code>放在()括号中，也可以是进程不受HUP信号的影响</li></ol><h4 id="10-外中断和异常的区别？">10. 外中断和异常的区别？</h4><ul><li><p><strong>外中断是指由 CPU 执行指令以外的事件引起</strong>，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p></li><li><p><strong>异常时由 CPU 执行指令的内部事件引起</strong>，如非法操作码、地址越界、算术溢出等。</p></li></ul><h4 id="11-什么是父进程、子进程、进程组、作业和会话？">11. 什么是父进程、子进程、进程组、作业和会话？</h4><ul><li><p><strong>父进程</strong>： 已创建一个或多个子进程的进程 ；</p></li><li><p><strong>子进程</strong>： 由<strong>fork</strong>创建的新进程被称为子进程（child process），函数被调用一次，但返回两次；</p><p>fork之后，操作系统会<strong>复制一个与父进程完全相同的子进程</strong>，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系：</p><ul><li>（1）它们共<strong>享代码空间</strong>，（2）<strong>数据空间是互相独立</strong>的，但<strong>子进程数据空间中的内容是父进程的完整拷贝</strong>，（3）<strong>指令指针也完全相同</strong>，（4）子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同）。</li></ul><p>除了：fork成功，<strong>子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号pid</strong> 。</p></li><li><p><strong>进程组</strong>： 进程组就是多个进程的集合，其中肯定有一个组长，其进程PID等于进程组的PGID ；</p></li><li><p><strong>作业</strong>： shell<strong>分前后台</strong>来控制的不是进程而是作业（job）或者进程组（Process Group）。</p><blockquote><p>一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，shell可以运行一个前台作业和任意多个后台作业，这称为作业控制。、</p></blockquote></li><li><p><strong>会话</strong>。 一个或多个<strong>进程组的集合</strong>，<strong>一个会话可以有一个控制终端</strong>。在xshell或者WinSCP中打开一个窗口就是新建一个会话。</p></li></ul><h4 id="12-什么是守护进程、僵尸进程、孤儿进程？">12. 什么是守护进程、僵尸进程、孤儿进程？</h4><blockquote><p>参考：<a href="https://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/">Linux 之守护进程、僵死进程与孤儿进程</a></p></blockquote><ul><li><p><strong>守护进程</strong></p><p><strong>在后台运行的，没有控制终端与之相连</strong>的进程。它<strong>独立于控制终端</strong>，周期性地执行某种任务。它不需要用户输入就能运行而且提供某种服务，不是<strong>对整个系统就是对某个用户程序</strong>提供服务。</p><ul><li>举例：常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。</li></ul><p>一个守护进程的父进程是init进程，也是一个<u>孤儿进程</u> ，一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。</p></li><li><p><strong>孤儿进程</strong></p><p>一个<strong>父进程退出，而它的一个或多个子进程还在运行</strong>，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p></li><li><p><strong>僵尸进程</strong></p><p>一个进程使用fork创建子进程，如果<strong>子进程退出</strong>，而父进程并没有调用wait或waitpid获取子进程的状态信息（子进程必须<strong>等到父进程捕获到了子进程的退出状态才真正结束</strong>），那么<strong>子进程的进程描述符仍然保存在系统中</strong>。这种进程称之为僵死进程。</p></li></ul><h5 id="11-1-如何避免僵尸进程？">11.1 如何避免僵尸进程？</h5><ul><li><p>通过<strong>signal(SIGCHLD, SIG_IGN</strong>)通知内核对子进程的结束不关心，由内核回收；</p><blockquote><p>如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN); 表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。</p></blockquote></li><li><p>父进程调用wait/waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞；</p><blockquote><p>waitpid可以通过传递WNOHANG使父进程不阻塞立即返回。</p></blockquote></li><li><p>如果父进程很忙可以用signal注册信号处理函数，在信号处理函数调用wait/waitpid等待子进程退出;</p></li><li><p>通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等待回收。</p></li></ul><h2 id="4-3-socket编程">4.3 socket编程</h2><p>暂略</p><h2 id="4-4-内存管理">4.4 内存管理</h2><h4 id="1-介绍一下操作系统的堆和栈？">1.<strong>介绍一下操作系统的堆和栈？</strong></h4><ul><li><p><strong>栈内存</strong>：栈内存首先是一片内存区域，存储的都是<u>局部变量</u>，栈内存的<u>更新速度很快</u>，因为局部变量的生命周期都很短。</p><blockquote><p>局部变量：方法内的变量，for循环内部定义的也是局部变量等。</p></blockquote></li><li><p><strong>堆内存</strong>：存储的是<u><strong>数组</strong></u>和<strong>对象</strong>（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象）。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</p></li></ul><h5 id="1-1-什么时候会栈溢出？">1.1 什么时候会栈溢出？</h5><p>栈能使用的内存是有限的，一般是 1M~8M，这在编译时就已经决定了，程序运行期间不能再改变。</p><ul><li>如果程序使用的栈内存超出最大值，就会发生栈溢出（Stack Overflow）错误，程序就崩溃了；</li><li>一般常见的情况，如<strong>递归过深</strong></li></ul><h4 id="2-介绍一下什么内存管理？常用的内存管理机制？">2. 介绍一下什么内存管理？常用的内存管理机制？</h4><ul><li><p><strong>内存管理</strong></p><p>操作系统的内存管理主要负责内存的（1）<strong>分配与回收（<strong>malloc 函数：申请内存，free 函数：释放内存），（2）另外地址转换也就是将</strong>逻辑地址转换成相应的物理地址</strong>等功能也是操作系统内存管理做的事情。</p></li><li><p><strong>常用内存管理机制</strong></p><p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为⼀个用户程序分配⼀个连续的内存空间，常见的如<strong>块式管理</strong> 。同样地，非连续分配管理方式允许⼀个程序使用的内存分在离散或者说不相邻的内存中，常见的如<strong>页式管理 和 段式管理</strong>。</p><ol><li><p><strong>块式管理</strong> ： 远古时代的计算机操系统的内存管理方式。<strong>将内存分为⼏个固定大小的块</strong>，每个块中只包含⼀个进程。如果程序运行需要内存的话，操作系统就分配给它⼀块，如果程序运行只需<br>要很小的空间的话，分配的这块内存很大⼀部分⼏乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</p></li><li><p><strong>页式管理</strong> ：把主存分为大小相等且固定的⼀页⼀页的形式，<strong>页较小，相对相⽐于块式管理的划分⼒度更大</strong>，提高了内存利用率，减少了碎片。页式管理通过<u>页表对应逻辑地址和物理地址</u>。</p></li><li><p><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。段式管理把主存分为⼀段段的，<strong>每⼀段的空间⼜要⽐⼀页的空间小很多</strong> 。</p></li></ol><blockquote><p>但是，最重要的是段是有实际意义的，每个段定义了⼀组逻辑信息，例如，有主程段 MAIN、子程序段 X、数据段 D及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</p></blockquote><ol start="4"><li><strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲页，也就是说 段页式管理机制中段与段之间以及段的内部的都是离散的。</li></ol></li></ul><h5 id="2-1-介绍一下逻辑地址和物理地址？">2.1 介绍一下逻辑地址和物理地址？</h5><ul><li>我们编程⼀般只有可能和逻辑地址打交道，⽐如在 C 语⾔中，指针⾥面存储的数值就可以理解成为<strong>内存⾥的⼀个地址</strong>，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。</li><li>物理地址指的是<strong>真实物理内存中地址</strong>，更具体⼀点来说就是内存地址寄存器中的地址。</li></ul><h5 id="2-2-操作系统在内存管理需要做什么？">2.2 操作系统在内存管理需要做什么？</h5><ul><li>内存空间的分配与回收；</li><li>从逻辑上对内存空间进行扩充；</li><li>逻辑地址与物理地址的转换；</li><li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。</li></ul><h4 id="3-介绍一下快表和多级页表？">3. 介绍一下快表和多级页表？</h4><p>在分页内存管理中，很重要的两点是：</p><ol><li>虚拟地址到物理地址的转换要快。</li><li>解决虚拟地址空间大，<strong>页表也会很大</strong>的问题。</li></ol><h5 id="快表介绍">快表介绍</h5><p>快表理解为⼀种<strong>特殊的高速缓冲存储器</strong>（Cache），其中的<strong>内容是页表的⼀部分或者全部内容</strong>。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。</p><blockquote><p>但有时快表不命中要访问两次缓存，不过总体还是提高了性能。</p></blockquote><h5 id="多级页表介绍">多级页表介绍</h5><p>引⼊多级页表的主要⽬的是为了 <u><strong>避免把全部页表⼀直放在内存中占用过多空间</strong></u>，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表<strong>属于时间换空间</strong>的典型场景。</p><h4 id="4-分页机制和分段机制的共同点和区别-？">4. 分页机制和分段机制的共同点和区别 ？</h4><ol><li>共同点 ：<ul><li>分页机制和分段机制都是为了<strong>提高内存利用率，较少内存碎片</strong>。</li><li>页和段都是<strong>离散存储</strong>的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li></ul></li><li>区别 ：<ul><li><strong>页的大小是固定的</strong>，由操作系统决定；<strong>而段的大小不固定</strong>，取决于我们当前运行的程序。</li><li>分页仅仅是为了<strong>满⾜操作系统内存管理</strong>的需求，而<strong>段是逻辑信息的单位，在程序中可以体现为代码段，数据段</strong>，能够更好满⾜用户的需要。</li></ul></li></ol><h4 id="5-【待扩充】CPU-寻址了解吗-为什么需要虚拟地址空间">5. 【待扩充】CPU 寻址了解吗?为什么需要虚拟地址空间?</h4><ul><li><p>现代处理器使用的是⼀种称为 虚拟寻址(Virtual Addressing) 的寻址⽅式。使用虚拟寻址，<strong>CPU 需要虚拟地址翻译成物理地址</strong>，这样才能访问到真实的物理内存。</p><blockquote><p>实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有⼀个被称为 内存管理单元（Memory Management Unit, MMU） 的硬件。</p></blockquote></li><li><p><strong>如果直接把物理地址暴露出来的话会带来严重问题</strong>，⽐如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</p></li></ul><h4 id="6-如果系统中具有快表后，那么地址的转换过程变成什么样了？">6. 如果系统中具有快表后，那么地址的转换过程变成什么样了？</h4><blockquote><p>简单来说：cup计算页号 → 快表查询是否有该页号 → 否则页表查询</p></blockquote><ol><li><strong>计算页号和页偏移量</strong>。 CPU给出逻辑地址，由某个硬件算得页号、页内偏移量；</li><li><strong>快表中查找内存块号</strong>。 将页号与快表中的所有页号进行比较，如果找到匹配的页号，则直接从中取出该页对应的内存块号，再<strong>将内存块号与页内偏移量拼接形成物理地址</strong>；</li><li><strong>页表中查找内存块号</strong>。 如果快表中查找不存在，访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。</li></ol><h4 id="7-进程内存分配动态分区算法？">7. 进程内存分配动态分区算法？</h4><ol><li><p><strong>首次适应法</strong>。</p><ul><li><p><strong>算法思想</strong>：每次都从低地址开始查找，找到第一个能满足大小的空闲分区；</p></li><li><p><strong>实现方式</strong>：空闲分区以<strong>地址递增</strong>的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分[表)，找到大小能满足要求的第-一个空闲分区。</p></li><li><p><strong>优点</strong>： 综合性能最好，开销小。</p><p><img src="https://i.loli.net/2021/06/10/PEpjmDW52eqGl4f.png" alt="image-20210610231604639"></p></li></ul></li><li><p><strong>最佳适应法</strong>。</p><ul><li><strong>算法思想</strong>：为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区；</li><li><strong>实现方式</strong>： 空闲分区按<strong>容量递增</strong>次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</li><li><strong>优点</strong>： 会有更多的大分区被保留下来，<u>更能满足大进程需求</u></li><li><strong>缺点</strong>： 产生很多太小的、难以利用的碎片，算法开销大</li></ul></li><li><p><strong>最坏适应法</strong>。</p><ul><li><strong>算法思想</strong>： 为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</li><li><strong>实现方式</strong>：空闲分区按<strong>容量递减</strong>次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</li><li><strong>优点</strong>： 可以减少难以利用的小碎片</li><li><strong>缺点</strong>： 大分区容易被用完，不利于大进程，算法开销大</li></ul></li><li><p><strong>领近适应法</strong>。</p><ul><li><strong>算法思想</strong>： 首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。</li><li><strong>实现方式</strong>：空闲分区以<strong>地址递增</strong>的顺序排列(可排成一个<strong>循环链表</strong>)。每次分配内存时<u>从上次查找结束的位置开始</u> ，查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</li><li><strong>优点</strong>： 算法开销小</li></ul></li></ol><h4 id="8-什么是内存覆盖和内存交换？">8. 什么是内存覆盖和内存交换？</h4><ul><li><strong>内存覆盖</strong><ul><li><strong>思想</strong>： 把用户空间分成为一个<strong>固定区</strong>和<strong>若干个覆盖区</strong>。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。</li><li><strong>特点</strong>：<strong>打破</strong>了必须将<strong>一个进程的全部信息装入内存后才能运行</strong>的限制 。</li></ul></li><li><strong>内存交换</strong><ul><li><strong>思想</strong>： <u>内存空间紧张</u> 时，系统将内存中<strong>某些进程暂时换出外存</strong>，把外存中某些已<strong>具备运行条件的进程换入内存</strong>。</li></ul></li></ul><h2 id="4-5-虚拟内存">4.5 虚拟内存</h2><h4 id="0-什么是虚拟技术-？从时间和空间两方面来说。">0. 什么是虚拟技术 ？从时间和空间两方面来说。</h4><p>虚拟技术<strong>把一个物理实体转换为多个逻辑实体</strong> ：</p><ul><li><strong>时分复用技术</strong> ： 如多个进程能在同一个处理器上并发执行使用了时分复用技术，让<u>每个进程轮流占用处理器，每次只执行一小个时间片并快速切换</u> ；</li><li><strong>空分复用技术</strong>： <u>物理内存抽象为地址空间，每个进程都有各自的地址空间</u>。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</li></ul><h4 id="1-介绍一下局部性原理吧？">1. 介绍一下局部性原理吧？</h4><p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装⼊部分程序到内存就开始运行。</p><p>局部性原理表现在以下两个⽅面：</p><ol><li><strong>时间局部性</strong>：如果程序中的<strong>某条指令</strong>⼀旦执行，不久以后<strong>该指令可能再次执</strong>行；如果某数据被访问过，不久以后该数据可能再次被访问。产⽣时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li></ol><blockquote><p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。</p></blockquote><ol start="2"><li><strong>空间局部性</strong>：⼀旦程序访问了<strong>某个存储单元</strong>，在不久之后，其<strong>附近的存储单</strong>元也将被访问，即程序在⼀段时间内所访问的地址，可能集中在⼀定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也⼀般是以向量、数组、表等形式簇聚存储的。</li></ol><blockquote><p>空间局部性通常是使用教大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。</p></blockquote><p>虚拟内存技术实际上就是建⽴了 “内存⼀外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p><h4 id="2-介绍一下，什么是虚拟内存？页式存储？">2.<strong>介绍一下，什么是虚拟内存？页式存储</strong>？</h4><ul><li><p><strong>虚拟内存</strong></p><p>虚拟内存是一种存储机制，可为用户提供一个拥有很大主内存的错觉。<strong>通过将辅存的一部分作为主存</strong>来完成。在虚拟内存中，用户可以存储比可用主内存更大的进程。</p><blockquote><p>每个进程创建加载的时候，会被分配一个大小为4G的连续的虚拟地址空间，仅仅是每个进程“认为”自己拥有4G的内存。等到进程真正运行的时候，<strong>需要某些数据并且数据不在物理内存中，才会触发缺页异常，进行磁盘数据拷贝到物理内存中</strong></p></blockquote><p><img src="https://i.loli.net/2021/04/20/NO5zyG824P9FSHs.jpg" alt="img"></p></li><li><p><strong>页式存储</strong></p><p>大部分虚拟存储系统采用的是一种称为<strong>分页（paging</strong>）的技术。这种方式叫做虚拟页式存储管理。</p><ul><li><p>物理内存空间划分为固定大小的内存块，称为物理页面，或者是<strong>页框</strong>（page frame）</p></li><li><p>虚拟地址空间也划分成大小相同的块，称为虚拟页面，或者简称<strong>页面</strong>（page）</p><blockquote><p>页表：将<strong>虚拟页面映射为</strong>相应的<strong>物理页面</strong>。</p></blockquote></li></ul></li></ul><h4 id="3-虚拟内存的技术实现-？">3. 虚拟内存的技术实现 ？</h4><p>虚拟内存的实现需要建⽴在离散分配的内存管理⽅式的基础上。 虚拟内存的实现有以下三种⽅式：</p><ol><li><strong>请求分页存储管理</strong> ：建⽴在分页管理之上，为了支持虚拟存储器功能而增加了<strong>请求调页功能和页面置换功能</strong>。请求分页是⽬前最常用的⼀种实现虚拟存储器的⽅法。请求分页存储管理系统中，在作业开始运行之前，仅装⼊当前要执行的部分页即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调⼊到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li><li><strong>请求分段存储管理</strong>：建⽴在分段存储管理之上，增加了<strong>请求调段功能、分段置换功能</strong>。请求分段储存管理⽅式就如同请求分页储存管理⽅式⼀样，在作业开始运行之前，仅装⼊当前要执行的部分段即可运行；在执行过程中，可使用请求调⼊中断动态装⼊要访问但⼜不在内存的程序段；当内存空间已满，而⼜需要装⼊新的段时，根据置换功能适当调出某个段，以便腾出空间而装⼊新的段。</li><li><strong>请求段页式存储管理</strong></li></ol><h4 id="4-请你介绍一下页面置换算法？">4. 请你介绍一下页面置换算法？</h4><p>当发⽣缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择⼀个页面将其移出内存，以便为即将调⼊的页面让出空间。用来选择淘汰哪⼀页的规则叫做页面置换算法，我们可以把页<br>⾯置换算法看成是淘汰页面的规则。</p><ul><li><p><strong>OPT （最佳页面置换算法）</strong>：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最⻓时间内不再被访问的页面,这样可以保证获得最低的缺页率。</p><blockquote><p>但由于⼈们⽬前无法预知进程在内存下的若千页面中哪个是未来最⻓时间内不再被访问的，因⽽该算法无法实现。⼀般作为衡量其他置换算法的⽅法。</p></blockquote></li><li><p><strong>FIFO（First In First Out） （先进先出页面置换算法</strong>）: 总是淘汰最先进⼊内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</p></li><li><p><strong>LRU （Least Currently Used）（最近最久未使用页面置换算法</strong>）：LRU算法赋予每个页面⼀个访问字段，用来记录⼀个页面⾃上次被访问以来所经历的时间 T，当须淘汰⼀个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</p></li><li><p><strong>LFU （Least Frequently Used）（最少使用页面置换算法</strong>）: 该置换算法选择在前时期使用最少的页面作为淘汰页。</p></li></ul><h4 id="5-你怎么理解操作系统里的内存碎片，有什么解决办法？">5.<strong>你怎么理解操作系统里的内存碎片，有什么解决办法</strong>？</h4><p>内存碎片分为：内部碎片和外部碎片。</p><ul><li><p><strong>内部碎片</strong>： 已经<strong>被分配</strong>出去（能明确指出属于哪个进程）却<strong>不能被利用</strong>的内存空间；</p><blockquote><p><strong>内存泄漏</strong>：不再会被使用的<strong>对象</strong>的内存不能被<strong>回收</strong> 。</p></blockquote></li><li><p><strong>外部碎片</strong>： 还<strong>没有被分配</strong>出去（不属于任何进程），但由于<strong>太小了无法分配</strong>，给申请内存空间的新进程的内存空闲区域。</p></li></ul><h4 id="6-什么是内存抖动？">6. 什么是内存抖动？</h4><ul><li><strong>现象</strong>：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种<strong>频繁的页面调度行为</strong>称为抖动，或颠簸；</li><li><strong>原因</strong>： 程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够) ；</li><li><strong>解决</strong>： 分配更多的物理块</li></ul><h2 id="4-6-并发和死锁">4.6 并发和死锁</h2><h4 id="0-介绍几种典型的锁？">0. 介绍几种典型的锁？</h4><ol><li><strong>读写锁</strong>。 可以同时读，但写必须互斥，只允许一个写；</li><li><strong>互斥锁</strong>。 一次只能一个线程拥有锁，其它只能等待；</li><li><strong>条件变量</strong>：  互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定；而条件变量<strong>通过允许线程阻塞和等待另一个线程发送信号</strong>的方法弥补了互斥锁的不足；</li><li><strong>自旋锁</strong>。 如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。</li></ol><h4 id="1-【重点】什么是线程死锁？什么情况下会发生死锁？解决死锁的策略有哪些？">1. 【<strong>重点</strong>】<strong>什么是线程死锁？什么情况下会发生死锁？解决死锁的策略有哪些</strong>？</h4><ul><li><p><strong>什么是死锁</strong></p><p>死锁是指<u>两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</u>，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p></li><li><p><strong>发生死锁的条件</strong></p><ol><li><strong>互斥</strong>：一个资源只能给一个进程使用；</li><li><strong>占有并等待</strong>：进程持有资源并申请新资源，在申请到需要的资源之前，<u>已有的资源不释放</u>；</li><li><strong>不可剥夺</strong>：进程申请到的资源在使用完之前，不可以被其他进程使用；</li><li><strong>循环等待</strong>：各个进程的资源请求形成首尾连接循环等待。</li></ol></li><li><p><strong>解决方法：预防，避免，检测与恢复三种</strong></p><ol><li><strong>预防：破坏死锁会发生的四个条件</strong><ul><li>破坏互斥：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的</li><li><strong>破坏请求和保持</strong>：实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源；</li><li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进⼀步申请其他资源时，<strong>如果申请不到</strong>，可以<strong>主动释放它占有的资源</strong>；</li><li><strong>破坏循环等待</strong>：资源分类标号，进行有序分配。</li></ul></li><li><strong>避免</strong>： <u>它不限制进程有关申请资源的命令</u>，而是对进程所发出的每一个申请资源命令加以<strong>动态地检查</strong>，并根据检查结果决定是否进行资源分配<ul><li><strong>安全序列</strong>：找到一种能让进程安全执行完的有序序列<code>&#123;P1，P2，...，Pn&#125;</code></li><li><strong>银行家算法</strong>：系统在为进程分配资源之前，首先计算此次资源分配的安全性，<strong>如果是安全的，则进行分配</strong>；如果这次分配会导致进入不安全状态，不进行分配。</li></ul></li><li><strong>恢复</strong>： 用<u>资源分配图、进程等待图</u>来协助这种检测出死锁，然后进行恢复。<ul><li>系统重新启动，但代价很大</li><li><strong>撤消参与死锁的全部或部分进程，剥夺资源</strong></li></ul></li></ol></li></ul><h5 id="1-1-什么时候需要使用分布式锁？">1.1 <strong>什么时候需要使用分布式锁</strong>？</h5><ul><li>在<strong>单体应用的</strong>时候，如果<strong>多个线程要访问共享资源的时候，我们通常线程间加锁的机制</strong>，在某一个时刻，只有一个线程可以对这个资源进行操作，其他线程需要等待锁的释放，Java中也有一些处理锁的机制，比如synchronized。</li><li>而到了<strong>分布式的环境</strong>中，当<strong>某个资源可以被多个系统访问使用到的时候（例如，有多个客户端需要访问并操作同一个资源，还需要保持这个资源一致性的时候，就需要使用【分布式锁）</strong>，为了保证大家访问这个数据是一致性的，那么就要求再同一个时刻，只能被一个系统使用，这时候<strong>线程之间的锁机制就无法起到作用</strong>了，因为分布式环境中，系统是会部署到不同的机器上面的，那么就需要【分布式锁】了。</li></ul><h4 id="2-（待补充）请你解释一下，通常系统CPU比较高是什么原因？">2. （待补充）<strong>请你解释一下，通常系统CPU比较高是什么原因</strong>？</h4><ol><li>首先查看是哪些进程的CPU占用率最高</li></ol><h4 id="3-说一下NIO，BIO，AIO区别">3.<strong>说一下NIO，BIO，AIO区别?</strong></h4><blockquote><p>参考：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/basis/IO%E6%A8%A1%E5%9E%8B.md">JAVaGuide</a></p></blockquote><p>【<strong>BIO（同步阻塞）</strong>】</p><ul><li><p><strong>BIO</strong>：同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把<u> </u>。</p><img src="https://i.loli.net/2021/05/06/HqJyg2Ykxtm6Wba.png" alt="图源：《深入拆解Tomcat & Jetty》" style="zoom: 67%;" /></li></ul><p>【<strong>NIO（同步非阻塞）</strong>】</p><p>NIO 本身是基于 <u>事件驱动</u> 的思想来实现的，其目的就是解决 BIO 的大并发问题：</p><ul><li>BIO 模型中，<strong>如果需要并发处理多个 I/O 请求，那就需要多线程来支持</strong>；</li><li><strong>IO 多路复用模型</strong>中，线程首先发起 <u>select 调用，询问内核数据是否准备就绪</u>，等内核把数据准备好了，用户线程再发起 <strong>read 调用</strong>。<strong>read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的</strong>。</li></ul><img src="https://i.loli.net/2021/05/06/9iJE3IaVOW2xAwh.png" alt="img" style="zoom:67%;" /><p>【<strong>AIO（异步非阻塞）</strong>】</p><blockquote><p>Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型 。</p></blockquote><p><strong>AIO：</strong> 异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。</p><blockquote><p>异步 IO 是基于事件和<strong>回调机制</strong>实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p></blockquote><p><img src="https://i.loli.net/2021/05/06/uIcCQeBUliqT2gk.png" alt="img" style="zoom:67%;" />0.</p><h4 id="4-【重点】介绍一下select，poll，epoll-原理？">4. 【重点】<strong>介绍一下select，poll，epoll 原理？</strong></h4><blockquote><p><strong>参考</strong></p><ol><li><a href="https://blog.csdn.net/jiejiemcu/article/details/107083724">select、poll、epoll的原理与区别</a></li></ol></blockquote><h5 id="4-1-从阻塞I-O-非阻塞I-O说起">4.1 从阻塞I/O &amp; 非阻塞I/O说起</h5><ul><li><p><strong>阻塞I/O</strong></p><blockquote><p>在linux中，默认情况下所有的socket都是阻塞的。</p></blockquote><p><img src="https://i.loli.net/2021/05/17/aJFOtPvy4xiMKkI.png" alt="image-20210517125922790"></p><ol><li>当用户进程调用了<code>read()/recvfrom()</code>等系统调用函数，它会进入内核空间中；</li><li>当这个网络I/O没有数据的时候，内核就要等待数据的到来，此时<strong>用户进程被阻塞</strong>；</li><li>当内核空间的数据准备好了，它就会将数据从<strong>内核空间中拷贝到用户空间</strong>；</li><li>用户进程才解除阻塞的的状态，重新运行读取数据。</li></ol></li><li><p><strong>非阻塞I/O</strong></p><blockquote><p>linux下，可以通过设置socket使其变为非阻塞模式，这种情况下，当内核空间并无数据的时候，它会<u>马上返回结果而不会阻塞</u>。</p></blockquote><p><img src="https://i.loli.net/2021/05/17/hW2DtsGBiU8AnHN.png" alt="image-20210517130232559"></p><ol><li>当用户进程调用了<code>read()/recvfrom()</code>等系统调用函数，它会进入内核空间中；</li><li>如果内核空间中的数据还没有准备好，那么它并不会阻塞用户进程，而是<strong>立刻返回一个error</strong>；</li><li>对于应用进程来说，它发起一个<code>read()</code>操作后，并不需要等待，那么它可以再次调用read()/recvfrom()等函数；</li><li>当内核空间的数据准备好了，它就会将数据从内核空间中拷贝到用户空间；</li><li>用户进程才解除阻塞的的状态，重新运行读取数据。</li></ol></li></ul><blockquote><p>多路复用I/O就是我们说的<code>select，poll，epoll</code>等操作，复用的好处就在于<strong>单个进程</strong>就可以同时处理<strong>多个</strong>网络连接的I/O，能实现这种功能的原理就是<code>select、poll、epoll</code>等函数会不断的<strong>轮询</strong>它们所负责的所有<code>socket</code>，当某个<code>socket</code>有数据到达了，就通知用户进程。</p></blockquote><h5 id="4-2-select原理">4.2 select原理</h5><blockquote><p>更加深刻对比理解：<a href="https://www.cnblogs.com/skyfsm/p/7079458.html">Linux编程之select</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>select函数监视的文件socket描述符分3类，分别是writefds、readfds、和exceptfds；</li><li>调用后select<strong>函数会阻塞（不是线程）</strong>，直到有描述符就绪（有数据 <u>可read、可write、except、超时timeout</u>），函数返回。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">select(socket);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">sockets = select(); <span class="comment">// 还是要从内核拷贝到用户</span></span><br><span class="line"><span class="keyword">for</span>(socket in sockets) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(can_read(socket)) </span><br><span class="line">&#123;</span><br><span class="line">read(socket, buffer);</span><br><span class="line">process(buffer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细执行原理如下：</p><ol><li><p>用户首先将需要进行IO操作的<strong>socket添加到select</strong>中，然后<strong>阻塞函数select（不是线程）等待系统调用返回</strong>；</p></li><li><p><strong>当数据到达时，socket被激活，select函数返回</strong>，会唤醒其等待队列上睡眠的内核进程，即在<strong>socket可读写时唤醒</strong>，或者在<strong>超时</strong>后唤醒；</p><blockquote><p>每次调用<code>select</code>查看fd，都需要把fd集合拷贝进行系统调用<strong>陷入内核态</strong> 。</p></blockquote></li><li><p>返回<code>select()</code>函数的调用结果给用户进程，<strong>返回就绪socket描述符的数目</strong>，超时返回0，出错返回-1；</p></li><li><p>在select()函数返回后<strong>还是需要轮询</strong>去找到就绪的socket描述符的（<u>将此前传入内核空间的<code>fd_set</code>拷贝到用户空间</u>），此时用户进程才可以去操作socket；</p></li><li><p>进程调用<code>read() / recvfrom()</code> 读取数据 。</p></li></ol><p><strong>select优点</strong>：</p><blockquote><p>从流程上来看，使用select函数进行IO请求和<strong>同步阻塞模型</strong>没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。</p><p><strong>那为什么还要使用select？</strong></p></blockquote><ul><li>使用select以后最大的优势是用户可以在一<strong>个线程内同时处理多个socket</strong>的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的；</li><li>而在<strong>同步阻塞模型</strong>中，必须通过<strong>多线程的方式才能达到这个目的</strong>。</li></ul><p><strong>select缺点</strong>：</p><ol><li><p><strong>描述符数量</strong>：<code>select</code>支持的文件描述符数量太小了，默认是<code>1024</code>  ；</p></li><li><p><strong>系统开销</strong>：每次调用<code>select</code>都需要把fd集合拷贝进行系统调用<strong>陷入内核态</strong>，这个开销在fd很多时会很大 ；</p></li><li><p><strong>二次轮询</strong>：<code>select</code>需要二次查询拷贝所有文件描述fd_set进行遍历查看是否有描述符准备就绪。</p></li></ol><h5 id="4-3-poll原理">4.3 poll原理</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 <strong>pollfd指针</strong>实现。</p><blockquote><p>poll使用<strong>链表</strong>维护这些socket描述符，而select使用的是<strong>数组</strong>（位图）。</p></blockquote><p>其他的都差不多和select()函数一样，poll()函数返回后，需要轮询pollfd来获取就绪的描述符，根据描述符的状态进行处理，<u>但是poll没有最大文件描述符数量的限制</u>。</p><p><strong>poll缺点</strong>：</p><p>解决了selec第一个缺点（文件描述符数量太少），但是依旧存在后面两个缺点。</p><ol start="2"><li><p><strong>系统开销</strong>：每次调用<code>poll</code>都需要把fd集合拷贝进行系统调用<strong>陷入内核态</strong>，这个开销在fd很多时会很大 ；</p></li><li><p><strong>二次轮询</strong>：<code>poll</code>需要二次查询拷贝所有文件描述fd_set进行遍历查看是否有描述符准备就绪。</p></li></ol><h5 id="4-3-epoll原理">4.3 epoll原理</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll只有epoll_create()、epoll_ctl()、epoll_wait() 3个系统调用函数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>epoll_create</code></p><p>创建一个epoll文件描述符的epfd（或者称之为句柄）, <strong>epoll使用一个epfd文件描述符管理多个socket描述符</strong>。</p><blockquote><p>当创建好epoll句柄后，它就是会占用一个fd值，必须调用close()关闭，否则可能导致fd被耗尽 。</p></blockquote></li><li><p><code>epoll_ctl</code></p><p>该函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，以及删除事件。相关参数：</p><blockquote><p>使用<strong>红黑树</strong>对监视的文件描述符进行：添加、修改、删除等。</p></blockquote><ul><li><p><code>epdf</code>：由epoll_create()函数返回的epoll文件描述符（句柄）；</p></li><li><p><code>op</code> ： op是操作的选项，注册要监听的目标socket描述符fd到epoll句柄中 ；修改epoll句柄已经注册的fd的监听事件；从epoll句柄删除已经注册的socket描述符 ；</p></li><li><p><code>fd</code>：指定监听的socket描述符；</p></li><li><p><code>event</code>：事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>        *ptr;</span><br><span class="line">    <span class="keyword">int</span>          fd;</span><br><span class="line">    <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>epoll_wait()</code></p><p>epoll_wait()函数的作用就是等待监听的事件的发生，<strong>类似于调用select()函数</strong>。 相关参数如下：</p><blockquote><p>函数的返回值表示需要处理的事件数目，如返回0表示已超时。</p></blockquote><ul><li><code>events</code>：用来从内核得到事件的集合。</li><li><code>maxevents</code> ：告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的指定的size。</li><li><code>timeout</code>：超时时间。</li></ul></li></ul><p><strong>epoll高效运行过程</strong></p><blockquote><p>参考：<a href="https://www.jianshu.com/p/31cdfd6f5a48">彻底搞懂epoll高效运行的原理</a></p></blockquote><ol><li><p>执行<code>epoll_create</code>会在内核的高速cache区中建立一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。接着用户执行<code>epoll_ctl</code> 函数添加文件描述符会在红黑树上增加相应的结点。</p><blockquote><p>select：创建3个文件描述符集并<u>拷贝到内核</u>中 ; poll：将传入的struct pollfd结构体数组<u>拷贝到内核</u>中进行监听。</p></blockquote></li><li><p>调用<code>epoll_wait</code> <strong>阻塞，等待可读事件</strong>；</p></li><li><p>内核在检测到满足条件的socket描述符会调用<strong>回调函数</strong> ，回调函数将文件描述符<strong>放在就绪链表</strong>中 ；</p><blockquote><p>而select/poll 都需要 ，遍历所有文件描述符fd_set 。</p><p>而执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，只需调用回调函数。</p></blockquote></li><li><p>epoll_wait只用观察就绪链表中有无数据即可，最后将链表的数据<strong>返回给读写事件数组events</strong> &amp;<strong>返回就绪的数量</strong>，只用<strong>遍历events</strong>依次处理即可。</p><blockquote><p>这里返回的文件描述符是通过<strong>mmap让内核和用户空间共享同一块内存</strong>实现传递的，减少了不必要的拷贝。</p><p>而select/poll <u>只返回socket就绪数目</u>， 还需要将<strong>所有的文件描述符再次从内核→用户</strong>，遍历就绪的socket文件描述符。</p></blockquote></li></ol><h5 id="4-4-select，poll，epoll-各自区别？">4.4 select，poll，epoll 各自区别？</h5><blockquote><p>不错的文章：<a href="https://www.codenong.com/cs105364662/">https://www.codenong.com/cs105364662/</a></p></blockquote><p><strong>相同点</strong>：</p><ul><li><p>select，poll，epoll 都是 IO 多路复用的机制（NIO？yes）；</p><blockquote><p>IO 多路复用的本质是通过一种机制，让<strong>单个进程可以监视多个描述符</strong>，当发现某个描述符就绪之后，能够通知程序进行相应的操作。</p></blockquote></li><li><p>select，poll，epoll 都是同步 IO 。</p></li></ul><p><strong>不同点</strong>：</p><img src="https://i.loli.net/2021/05/17/xj2ncf8VLbAGrwh.png" alt="image-20210517125057917" style="zoom: 80%;" /><ol><li><strong>IO 效率</strong>：（1）select 只知道<u>有 IO 事件发生，却不知道是哪几个流</u>，只能采取轮询所有流（ fd_set 集合）的方式，故其具有 O(n) 的无差别轮询复杂度，处理的流越多，无差别轮询时间就越长；（2）poll 与 select 并无区别，它的时间复杂度也是O(n)；（3）epoll 会将哪个流发生了怎样的 IO 事件通知我们（当描述符就绪时，<u>系统注册的回调函数会被调用</u>，将就绪描述符放到 readyList 里面），<strong>它是事件驱动的</strong>，其时间复杂度为 O(1)；</li><li><strong>操作方式</strong>：select 和 poll 都是采取遍历的方式，而 epoll 则是采取了回调的方式；</li><li><strong>底层实现</strong>：select 的底层实现为数组，poll 的底层实现为链表；而 epoll 的底层实现为红黑树；</li><li><strong>最大连接数</strong>：select 的最大连接数为 1024 或 2048；而 poll 和 epoll 是无上限的；</li><li><strong>对描述符的拷贝</strong>：select 和 poll 每次被调用时都会把描述符集合从用户态拷贝到内核态，而 epoll 在调用 epoll_ctl 时会拷贝进内核并保存，之后每次 epoll_wait 时不会拷贝；</li><li><strong>性能</strong>：<u>epoll 在绝大多数情况下性能远超 select 和 poll</u>，但在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，因为 epoll 的通知机制需要很多函数回调 。</li></ol><h5 id="4-5-ET-LT-模式介绍？各自优缺点？">4.5 ET , LT 模式介绍？各自优缺点？</h5><blockquote><p>参考：<a href="https://cloud.tencent.com/developer/article/1636224">https://cloud.tencent.com/developer/article/1636224</a></p></blockquote><ul><li><p><strong>边缘触发模式</strong>（<strong>E</strong>dge <strong>T</strong>rigger，ET），只有一个事件从无到有才会触发；</p><blockquote><ol><li>低电平 =&gt; 高电平 。</li></ol></blockquote></li><li><p><strong>水平触发模式</strong>（<strong>L</strong>evel <strong>T</strong>rigger，LT），一个事件只要有，就会一直触发。</p><blockquote><ol><li>低电平 =&gt; 高电平 ; 2. 处于高电平状态</li></ol></blockquote></li><li><p><strong>举例说明</strong></p><ul><li><strong>socket 的读事件</strong><ul><li><strong>LT模式</strong>，只要 socket 上有未读完的数据，就会一直产生 EPOLLIN 事件；</li><li><strong>ET模式</strong>，socket 上每新来一次数据就会触发一次，如果上一次触发后，<strong>未将 socket 上的数据读完，也不会再触发</strong>，除非再新来一次数据。</li></ul></li><li><strong>对于 socket 写事件</strong><ul><li><strong>LT模式</strong>，如果 socket 的 TCP 窗口一直不饱和，会一直触发 EPOLLOUT 事件；</li><li><strong>ET模式</strong>，只会触发一次，除非 TCP 窗口由不饱和变成饱和再一次变成不饱和，才会再次触发 EPOLLOUT 事件。</li></ul></li></ul></li><li><p><strong>优缺点</strong></p><ul><li>使用 LT 模式，我们可以自由决定<strong>每次收取多少字节（对于普通 socket）或何时接收连接</strong>（对于侦听 socket），但是可能会<strong>导致多次触发</strong>；</li><li>使用 ET 模式，我们必须<strong>每次都要将数据收完</strong>（对于普通 socket）或必须理解调用 accept 接收连接（对于侦听socket），其<strong>优点是触发次数少</strong>。</li></ul></li></ul><h4 id="5-操作系统底层是怎么实现原子操作的？">5. 操作系统底层是怎么实现原子操作的？</h4><p>处理器使用基于对<strong>缓存加锁</strong>或<strong>总线加锁</strong>的方式，来实现多处理器之间的原子操作。</p><ol><li><p><strong>总线锁</strong>： 处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器<strong>可以独占共享内存</strong>；</p><blockquote><p><strong>总线锁定把CPU和内存之间的通信锁住了</strong>，这使得锁定期间，其他处理器不能操作其他内存地址的数据</p></blockquote></li><li><p><strong>缓存锁</strong>：相比总线锁，缓存锁即降低了锁的力度。核心机制是基于<u>缓存一致性协议</u>来实现的。</p><blockquote><p>详细参考：<a href="https://www.jianshu.com/p/06717ac8312c">JMM基础（总线锁、缓存锁、MESI缓存一致性协议、CPU 层面的内存屏障）</a></p></blockquote></li></ol><h2 id="4-7-其它">4.7 其它</h2><h4 id="1-常见的磁盘调度算法？">1. 常见的磁盘调度算法？</h4><p>读写一个磁盘块的时间的影响因素有：</p><ul><li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li><li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li><li>实际的数据传输时间</li></ul><p>其中，<strong>寻道时间最长</strong>，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><ol><li><p><strong>先来先服务</strong>。 按照磁盘请求的顺序进行调度。</p><ul><li><strong>优点</strong>：公平、简单；</li><li><strong>缺点</strong>：未对寻道做任何优化，使平均寻道时间可能较长。</li></ul></li><li><p><strong>最短寻道优先</strong>。 优先调度与当前磁头所在磁道距离最近的磁道。</p><ul><li><strong>优点</strong>： 平均寻道时间比较低；</li><li><strong>缺点</strong>：不公平，如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去。</li></ul></li><li><p><strong>电梯扫描算法</strong>。 电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p><ul><li><strong>优点</strong>： 性能较好，同时不会存在饥饿现象。</li></ul></li></ol><h4 id="2-服务器高并发的解决方案你知道多少？">2. 服务器高并发的解决方案你知道多少？</h4><ul><li><strong>应用数据与静态资源分离</strong>：将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从<strong>静态资源服务器中返回静态资源</strong>，从<strong>主服务器中返回应用数据</strong>；</li><li><strong>客户端缓存</strong> ：例如先生成静态页面，然后用ajax异步请求获取动态数据；</li><li><strong>集群和分布式</strong> ：使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度；</li><li><strong>反向代理</strong>： 在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（三）_计算机基础_计算机网络</title>
      <link href="/p/46361/"/>
      <url>/p/46361/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h1>三、计算机网络</h1><h2 id="3-1-ISO-OSI模型-和-TCP-IP-模型">3.1 ISO/OSI模型  和 TCP/IP 模型</h2><h4 id="1-请你简要介绍一下TCP-IP-五层协议-和-ISO-OSI七层协议？">1.<strong>请你简要介绍一下TCP/IP 五层协议 和 ISO/OSI七层协议？</strong></h4><p><img src="https://uploadfiles.nowcoder.com/images/20190814/980266035_1565787665824_1ABB2DC3D76311944FFDBE9980FBAADD" alt="img"></p><ul><li><p><strong>应用层</strong>：为用户的<strong>应用程序</strong>（如：电子邮件、文件传输和仿真终端）<u><strong>*提供网络服务</strong></u>；</p></li><li><p><strong>表示层</strong>： 可以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取；</p></li><li><p><strong>会话层</strong>：  通过运输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求；</p></li><li><p><strong>运输层:</strong> 任务是为两台主机中<strong>进程之间的通信</strong>提供通用的<u><strong>*数据传输服务</strong></u>，传输的是<strong>报文段（tcp）/用户数据报（udp）</strong>；</p><blockquote><p>复用：多个应用层进程可同时使用下面运输层的服务。<br>分用：运输层把收到的信息分别交付上面应用层中的相应进程。</p></blockquote></li><li><p><strong>网络层</strong>： 为主机间<u><strong>*提供通信服务</strong></u>。在发送数据时，网络层把运输层的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为<strong>数据报</strong></p></li><li><p><strong>数据链路层（忘</strong>）： 两台主机通信，总是在<strong>一段一段的链路</strong>上传送的，这就需要需要专门的链路层的协议。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的<u><strong>*IP数据报组装成帧</strong></u>，在两个相邻结点间的链路上传送帧。每一帧包括数据和必要的控制信息。</p></li><li><p><strong>物理层</strong>：主要作用是<u>传入比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0）</u>，定义物理设备标准（例如网线的接口类型、光线的接口类型、各种传输介质的传输速率）。</p></li></ul><h4 id="2-请你简要介绍一下各层的协议？">2.<strong>请你简要介绍一下各层的协议？</strong></h4><ul><li><p><strong>物理层</strong>：暂无</p></li><li><p><strong>（<u>快手</u>）数据链路层</strong>：数据链路层主要是负责传输数据，</p><ul><li><p><strong>PPP（点到点协议</strong>）：在<strong>点对点</strong>连接上传输多协议数据包提供了一个标准方法，PPP 最初设计是为<strong>两个对等节点</strong>之间的 IP <strong>流量传输</strong>提供一种封装协议。这种链路提供<strong>全双工</strong>操作，并按照顺序传递数据包。</p><blockquote><p>设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。</p></blockquote></li><li><p><strong>以太网（Ethernet)</strong>：</p></li><li><p><strong>CSMA/CD 协议</strong>： 冲突检测的载波监听多路访问技术(载波监听多点接入/碰撞检测)。</p><blockquote><p>许多计算机以<strong>多点接入</strong>的方式连接<strong>在一根总线</strong>上，每个主机都必须不停地监听信道。发送前监听，如果忙则等待，如果空闲则发送。</p><p>若检测到信道有干扰信号，则表示产生了碰撞，于是就要停止发送数据，计算出退避等待时间，然后使用 CSMA 方法继续尝试发送。</p></blockquote></li></ul></li><li><p><strong>网络层</strong>： <a href="https://www.hhcycj.com/post/item/491.html">可参考</a></p><p><strong>IP</strong>：网络协议，非常重要的中间层协议，TCP和UDP必须基于IP工作</p><p><strong>ICMP</strong>：非常重要的中间层协议，用于在 <u>IP主机、路由器</u> 之间传递控制消息</p><p><strong>IGMP</strong>：网络组消息协议，用来在<u>IP主机</u>和与其<strong>直接相邻的<u>组播路由器</u>之间</strong>建立、维护组播组成员</p><p><strong>ARP</strong>：地址解析协议，建立<code>IP→MAC</code>地址映射表</p><p><strong>RARP</strong>：反向地址解析协议，某个网络设备的MAC物理地址转换为IP地址</p></li><li><p><strong>运输层:TCP(Transmission Control Protocol)</strong> 面向连接的，数据传输的单位是<u><strong>报文段</strong></u>，能够提供可靠的交付。</p><p><strong>UDP(User Datagram Protocol)</strong> ：无连接的，数据传输的单位<strong>是<u>用户数据报</u>，不保证提供可靠的交付</strong>，只能提供“尽最大努力交付”</p></li><li><p><strong>应用层</strong>：如支持万维网应用的<strong>HTTP</strong>协议，支持电子邮件的<strong>SMTP</strong>协议，支持文件传送的<strong>FTP</strong>协议，DNS，POP3，SNMP，Telnet等等。</p></li></ul><h5 id="2-1-RARP-工作原理？">2.1 RARP 工作原理？</h5><p>RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。</p><blockquote><p>网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。</p></blockquote><ol><li>主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包；</li><li><strong>RARP服务器</strong>收到了<strong>RARP请求数据包</strong>，<strong>为其分配IP地址</strong>，并将<strong>RARP回应发送</strong>给主机；</li><li>主机收到RARP回应后，就使用得到的IP地址进行通讯。</li></ol><h4 id="3-端口在哪一层？有效端口范围？">3. 端口在哪一层？有效端口范围？</h4><p>端口在<strong>传输层</strong>。传输层以下的包封装过程：</p><ul><li>数据报在传输层：加源端口号和目的端口号；</li><li>在网络层加上：源ip和目的ip ；</li><li>在数据链路层转化成：数据桢进行校验；</li><li>在物理层变成信号（电、光、等信号）发送出去。</li></ul><p>UDP和TCP报头使用<strong>两个字节存放端口号</strong>，端口一共有一共有<strong>65535</strong>个。</p><ul><li>知名端口号从0~1023，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口） ；</li><li>动态端口的范围是从1024~65535。</li></ul><h2 id="3-2-运输层">3.2 运输层</h2><h4 id="0-TCP报文头？UDP报文头？">0. TCP报文头？UDP报文头？</h4><blockquote><p>参考：<a href="http://st233.com/blog.php?id=30">IP、TCP、UDP报文头说明</a></p></blockquote><ul><li><p><strong>TCP报文头</strong></p><p><img src="https://i.loli.net/2021/06/11/RtnwTmysWBvVlPD.png" alt="img"></p><ul><li><p><strong>来源端口</strong>：向目标主机指明接入他的主机所使用的端口号 用于目标主机回应</p></li><li><p><strong>目标端口</strong>：指明要连接的目标主机的端口号</p><blockquote><p>从这也可以看书，端口占16bit，故范围是0~65535。</p></blockquote></li><li><p><strong>顺序号：数据包编号</strong>， 表明发送的数据包的顺序 。其值通常应该为<code>上次发送包中的顺序号+1</code> ，若该数据包是整个TCP连接中的第一个包(SYN包) 则该值随意(通常随机)</p></li><li><p><strong>确认号</strong>：通常该值是<code>接受到的顺序号+1</code> ，若该数据包是整个TCP连接中的第一个数据包(SYN包) 则该值随意(通常为0)</p></li><li><p><strong>首部长度</strong>：TCP头长度 。表明包好多少个32Bit 包括可选头(如果有) 值为TCP头大小除以4 ：</p><ul><li>如：没有可选头TCP头为20字节 则该值为5</li></ul></li><li><p><strong>标志位</strong>：</p></li><li><ul><li>紧急标志位(URG)：开启时表明此数据包处于紧急状态应该优先处理</li><li>确认标志位(ACK)：开启时表明确认号有效 否则忽略确认号</li><li>推送标志位(PSH)：开启时表明应该尽快交付给应用进程 而不必等到缓存区填满才推送</li><li>复位标志位(RST)：开启时表明TCP连接出现连接出现错误 数据包非法拒绝连接</li><li>同步标志位(SYN)：开启时表明一个连接的请求或者接受报文</li><li>终止标志位(FIN)：开启时表明释放一个连接</li></ul></li><li><p><strong>窗口大小</strong>：表示期望接受到的每个数据包字节数</p></li><li><p><strong>校验和</strong>：该值为TCP报文头括数据部分中每16Bit的二进制反码求和</p></li><li><p><strong>紧急指针</strong>：若指定该值 他应该是一个偏移量 该值加上顺序号表示紧急数据最后一个字节的顺序号</p></li><li><p><strong>可选字段</strong>：包含最大载荷与窗口比例等信息 注：若使用该字段则长度必须为32Bit的倍数 不足则填充0</p></li></ul></li><li><p><strong>UDP报文</strong></p><p><img src="https://i.loli.net/2021/06/11/Bfh3THSLgzZCUAu.png" alt="img"></p><ul><li><p><strong>来源端口</strong>：向目标主机指明接入他的主机所使用的端口号 用于目标主机回应</p></li><li><p><strong>目标端口</strong>：指明要连接的目标主机的端口号</p></li><li><p><strong>数据包长度</strong>：UDP头和数据总长度字节数</p></li><li><p><strong>检验和</strong>：该值为UDP报文头括数据部分中每16Bit的二进制反码求和</p></li><li><ul><li><strong>注：UDP检验和不是必须的</strong></li></ul></li></ul></li></ul><h4 id="1-请你说明一下，TCP协议的3次握手（进行连接）？">1. 请你说明一下，TCP协议的3次握手（进行连接）？</h4><blockquote><p>参考：<a href="https://juejin.cn/post/6844903834708344840">三次握手与四次挥手面试官想考我们什么？</a></p></blockquote><blockquote><p>TCP中，对<strong>确认ACK报文是不需要发送确认</strong>的 。</p></blockquote><ul><li><p><strong>简略过程</strong></p><blockquote><p>⚠️ SYN 和ACK报文是一起发的！！</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/27203200-7e3630b0fe1442898e6824ac061d475e.x-png" alt="TCP三次握手原理- asfion - 博客园"></p><p><strong>1、第一次握手</strong>：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 <strong>ISN©</strong>。此时客户端处于 <strong>SYN_Send</strong> 状态。</p><p><strong>2、第二次握手</strong>：（⚠️ <strong>SYN+ACK是在一个包里发的！（字节一面</strong>） ）服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 <strong>ISN(s)</strong>，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <strong>SYN_REVD</strong> 的状态。</p><p><strong>3、第三次握手</strong>：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <strong>establised</strong> 状态。</p><p>服务器收到 ACK 报文之后，也处于 <strong>establised 状态</strong>，此时，双方以建立起了链接。</p></li></ul><h5 id="1-1-ISN-（Initial-Sequence-Number）是固定的吗？">1.1 ISN （Initial Sequence Number）是固定的吗？</h5><ul><li><p><strong>ISN作用</strong></p><p>三次握手，其中一个重要功能是客户端和服务端交换 ISN，以便让对方知道<strong>接下来接收数据的时候如何按序列号组装数据</strong>。</p></li><li><p><strong>ISN为什么不固定</strong>（还是不太理解）</p><blockquote><p>ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个<strong>32比特</strong>的计数器，<strong>每4ms加1</strong> 。</p></blockquote><ul><li><strong>防止在网络中被延迟的分组在以后被重复传输</strong>，而导致某个连接的一端对它作错误的判断；</li><li>如果 ISN 是固定的，攻击者很<strong>容易猜出后续的确认号</strong>，因此 ISN 是动态生成的。</li></ul></li></ul><h4 id="2-为什么要三次握手？">2.<strong>为什么要三次握手</strong>？</h4><p>1.<strong>用来确定服务端和客户端的发送能力是否正常；</strong></p><ul><li><strong>第一次握手</strong>：客户端发送网络包，服务端收到了。这样服务端就能得出结论：<u>客户端的发送能力、服务端的接收能力是正常的。</u></li><li><strong>第二次握手</strong>：服务端发包，客户端收到了。这样客户端就能得出结论：<u>服务端的接收、发送能力，客户端的接收、发送能力是正常的</u>。<strong>不过此时服务器并不能确认客户端的接收能力是否正常</strong>。</li><li><strong>第三次握手</strong>：客户端发包，服务端收到了。这样服务端就能得出结论：<u>客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</u></li></ul><p>2.<strong>指定自己的初始化序列号，为后面的可靠传送做准备；</strong></p><ul><li>如果只有两次握手，那么客户端的起始序列号可以确认，<u>服务端的起始序列号</u>将得不到确认。</li></ul><ol start="3"><li><strong>如果是 https 协议的话，三次握手这个过程，还会进行数字<u>证书的验证以及加密密钥</u>的生成</strong>。</li></ol><h5 id="2-1-三次握手可以携带数据吗？">2.1 三次握手可以携带数据吗？</h5><p><strong>第一次、第二次握手不可以携带数据 ，</strong> 第三次可以携带数据：</p><ul><li><strong>对于第一次握手</strong>，不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。<ul><li>如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，<strong>消耗服务器空间来接收数据</strong>；</li></ul></li><li><strong>对于第三次握手</strong>，客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，<strong>已经知道服务器的接收、发送能力正常</strong>，所以能携带数据。</li></ul><h4 id="3-请你说明一下，TCP协议的4次挥手（断开连接）？">3.<strong>请你说明一下，TCP协议的4次挥手（断开连接）</strong>？</h4><blockquote><p><a href="https://www.zhihu.com/question/63264012">为什么不像三次握手一样执行三次即可？</a></p><p>因为第二次和第三次对于被动方来说，意义是不一样的。<br>第二次是为了让主动方闭嘴（不再发挥手请求），自己该干嘛还是干嘛（但是自己可能还有数据美处理完）。<br>第三次是为了表示“我的活儿干完了，可以结束了”。<br>通常server接收到挥手的时候，手里还有活儿没做完。</p></blockquote><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。</p><p><u>收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据</u>。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p>TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211127191012778.png" alt="image-20211127191012778"></p><p>（1）客户端A发送一个FIN，<u>报文中会指定一个序列号</u>M，用来关闭客户A到服务器B的数据传送，此时客户端处于<strong>FIN_WAIT1</strong>状态；</p><p>（2）服务器B收到这个FIN，它发回一个ACK，<u>确认序号为收到的序号M+1</u>。和SYN一样，一个FIN将占用一个序号，此时服务端处于 <strong>CLOSE_WAIT</strong>状态；</p><p>（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A和序列号N，此时服务端处于 <strong>LAST_ACK</strong> 的状态；</p><p>（4）客户端A发回ACK报文确认，并将确认序号设置为收到序N+1，此时客户端处于 <strong>TIME_WAIT</strong> 状态，需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 <strong>CLOSED</strong> 状态；服务端收到 ACK 报文之后，就处于关闭连接了，处于 <strong>CLOSED</strong> 状态。</p><h5 id="3-1-为什么TCP四次挥手要基于全双工，不基于半双工呢？基于半双工可以改为三次挥手吗？">3.1 为什么TCP四次挥手要基于全双工，不基于半双工呢？基于半双工可以改为三次挥手吗？</h5><blockquote><p>半双工：同时只能有一端发送消息 ； 全双工：两端都可以随机接受/发送。</p></blockquote><p>在四次挥手过程中，似乎C/S两端都是等待对方发送FIN/ACK，才会发送对应的ACK/FIN版本。同一时刻只有一方在发送消息，满足半双工。</p><p>但是，半双工模式效率会更低：比如C端（客户端）发送FIN报文请求关闭，但是S端（<strong>服务端</strong>）依旧<strong>可以同时发生数据</strong> ，这个时候效率更高。</p><h5 id="3-2（重点）-服务器出现大量close-wait的连接的原因是什么？有什么解决方法？">3.2（重点） 服务器出现大量close_wait的连接的原因是什么？有什么解决方法？</h5><p>close_wait状态是在，TCP四次挥手的时候<strong>服务器收到FIN，但是没有发送自己的FIN时出现的</strong>。服务器出现大量close_wait状态的原因有两种：</p><ul><li><strong>服务器内部业务处理占用了过多时间</strong>，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li><li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候<strong>子进程处理但父进程没有处理该信号</strong>，导致socket的引用不为0无法回收</li></ul><p>处理方法：</p><ul><li>停止应用程序</li><li>修改程序里的bug</li></ul><h4 id="4-为什么要有TIME-WAIT-状态？为什么等待是2MSL？">4. 为什么要有TIME_WAIT 状态？为什么等待是2MSL？</h4><ul><li><p><strong>要确保服务器是否已经收到了客户端最后的ACK 报文</strong>，如果没有收到的话，<u>服务器会重新发 FIN + ACK报文给客户端</u>，客户端再次收到 FIN + ACK 报文之后，就知道之前的 ACK 报文丢失了，然后<u>再次发送 ACK 报文。</u></p></li><li><p><strong>确保之前连接的一些数据不在滞留在网络中</strong>：确保已经失效连接请求报文段不会再出现在本连接中，<strong>客户端发完最后一个ACK报文段后</strong>，再经过<strong>2MSL</strong>可以使得本连接中所有的报文段都从网络中消失。客户端就可以放心地<strong>释放</strong>TCP占用的资源、端口号，连接任何服务器。</p><blockquote><p>如果<strong>客户端</strong>直接CLOSED，然后又再次向服务器<strong>发起一个新连接</strong>，有可能<strong>新、老连接的端口号一样</strong>的。假设新、老连接端口号一致，若老连接的一些数据仍滞留在网络中，这些滞留数据在新连接建立后才到达服务器，鉴于前后端口号一致，TCP协议就默认这些数据属于新连接，于是数据就这样乱成一锅粥了。</p></blockquote></li></ul><h5 id="4-1-为什么是2MSL">4.1 为什么是2MSL?</h5><p>MSL是报文在网络中最长生存时间，这是一个工程值(经验值)，不同的系统中可能不同 。</p><p>考虑最坏 情况，客户端A最后一次挥手发送给服务端B的ACK报文丢失了：</p><ol><li>ACK从最多经过1MSL会到达服务端，<strong>超过1MSL服务端会重发FIN</strong></li><li>服务端重发的FIN最多经过1MSL到达A</li></ol><p>所以为了确保，客户端能<strong>接收到服务端重发的FIN报文</strong>。</p><h4 id="5-【重点】请问TCP为什么要更可靠？哪种场景会有所应用？">5. 【重点】<strong>请问TCP为什么要更可靠？哪种场景会有所应用？</strong></h4><ol><li><p><strong>超时重传</strong>：当 TCP 发出⼀个报文段后，它启动⼀个定时器，等待⽬的端确认收到这个报⽂段。如果不能及时收到⼀个确认，将重发这个报⽂段；</p></li><li><p><strong>数据排序</strong>：TCP有专门的序列号<strong>ISN字段</strong>，可提供数据re-order；</p></li><li><p><strong>流量控制</strong>：滑动窗口和计时器的使用。TCP窗口中会指明双方能够<u>发送接收的最大数据量；</u></p><blockquote><p><strong>ARQ协议</strong>： 也是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待对方确认。在收到确认后再发下⼀个分组。</p></blockquote></li><li><p><strong>拥塞控制</strong>：TCP的拥塞控制由4个核心算法组成。“慢启动”（Slow Start）、<u>“拥塞避免”</u>（Congestion avoidance）、“快重传 ”（Fast Retransmit）、“快恢复”（Fast Recovery）；</p></li><li><p><strong>校验和</strong>： TCP 将保持它⾸部和数据的检验和。这是⼀个端到端的检验和，⽬的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将<strong>丢弃这个报⽂段和不确认收到此报⽂段</strong>。</p></li></ol><p>【<strong>应用场景</strong>】</p><p><u>当对网络通讯质量有要求的时候，</u>比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用</p><ul><li>比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议</li></ul><h5 id="5-1-超时重传机制原理？">5.1 超时重传机制原理？</h5><p>基本原理：在发送一个数据之后，就开启一个<strong>定时器</strong>，若是在这个时间内<strong>没有收到发送数据的ACK确认报文</strong>，则对该报文进行<strong>重传</strong>，在达到一定次数还没有成功时放弃并发送一个复位信号。</p><p>TCP中有四种计时器（Timer），分别为：</p><ol><li><p><strong>重传计时器</strong>：在<strong>滑动窗口协议</strong>中，接受窗口会在<strong>连续收到的包序列（连续ARQ）<strong>中的</strong>最后一个包</strong>向接收端发送一个ACK。当网络拥堵的时候，发送端的数据包和接收端的ACK包都有可能丢失。TCP为了保证数据可靠传输，就规定在<strong>重传的“时间片”<strong>到了以后，如果还没有收到对方的ACK，就</strong>重发此包</strong>，以避免陷入无限等待中。</p></li><li><p><strong>坚持计时器</strong>：在<strong>滑动窗口协议</strong>中，当发送TCP收到<strong>窗口大小为0</strong>的确认ACK时，就坚持启动计时器。当坚持计时器期限到时，发送TCP就发送一个特殊的报文段，叫做探测报文。这个报文段只有一个字节的数据。他有一个序号，但他的序号永远不需要确认；甚至在计算机对其他部分的数据的确认时该序号也被忽略。探测报文段提醒接受TCP：确认已丢失，必须重传。</p></li><li><p><strong>保活计时器</strong>：保活计时器使用在某些实现中，用来<strong>防止在两个TCP之间的连接出现长时间的空闲</strong>。假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远的处于打开状态。</p><p>通常设置为两小时。若服务器过了两小时还没有收到客户的信息，他就发送探测报文段。若<strong>发送了10个探测报文段</strong>（每一个像个75秒）还没有响应，就假定客户除了故障，因而就终止了该连接。</p></li><li><p><strong>时间等待计时器</strong>：四次挥收后time waiter状态中使用。</p></li></ol><h5 id="5-2-介绍一下ARQ协议-？">5.2 介绍一下ARQ协议 ？</h5><p>⾃动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之⼀。它通过使用<strong>确认和超时</strong>这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。</p><p>ARQ包括<strong>停⽌等待ARQ协议</strong>和<strong>连续ARQ协议</strong>。</p><ul><li><strong>停⽌等待ARQ协议</strong>。 停⽌等待协议是为了实现可靠传输的，它的基本原理就是每发完⼀个<strong>分组</strong>就停⽌发送，等待对方确认（回复ACK）。如果过了⼀段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下⼀个分组；在停⽌等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。<ul><li><strong>优点</strong>：简单</li><li><strong>缺点</strong>：信道利用低，等待时间长</li></ul></li><li><strong>连续ARQ协议</strong>。连续 ARQ 协议可提高信道利用率。发送方维持⼀<strong>个发送窗口</strong>，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方⼀般采用<strong>累计确认</strong>，对按序到达的<strong>最后⼀个分组发送确</strong>认，表明到这个分组为⽌的所有分组都已经正确收到了。<ul><li><strong>优点</strong>： 信道利用率高，容易实现，即使确认丢失，也不必重传。</li><li><strong>缺点</strong>： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 ⽐如：发送方发送了 5条 消息，<strong>中间第三条丢失（3号</strong>），这时接收方<strong>只能对前两个发送确认</strong>。发送方无法知道后三个分组的下落，而只好把后<strong>三个全部重传</strong>⼀次。这也叫 <strong>Go-Back-N</strong>（回退 N），表示需要退回来重传已经发送过的N 个消息。</li></ul></li></ul><h5 id="5-2-介绍一下连续ARQ协议滑动窗口和流量控制？">5.2 介绍一下连续ARQ协议滑动窗口和流量控制？</h5><p>TCP 利用滑动窗口实现流量控制。流量控制是为了<strong>控制发送方发送速率，保证接收方来得及接收</strong>。 接收方发送的确认报⽂中的窗口字段可以用来控制<strong>发送方窗口</strong>大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h5 id="5-3-介绍一下拥塞控制？">5.3 介绍一下拥塞控制？</h5><p>为了进行拥塞控制，TCP 发送方要维持⼀个 <u>拥塞窗口(cwnd)</u> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让⾃⼰的<strong>发送窗口 == 取为拥塞窗口和接收方的接受窗口中较小的⼀个</strong>。</p><p>TCP的拥塞控制采用了四种算法：</p><ul><li><p><strong>慢开始</strong>： 慢开始算法的思路是当主机开始发送数据时，如果⽴即把大量数据字节注⼊到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测⼀下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，<strong>每经过⼀个传播轮次RTT，cwnd加倍</strong>；</p></li><li><p><strong>拥塞避免</strong>： 拥塞避免算法的思路是让拥塞窗⼝cwnd缓慢增大，即每经过<strong>⼀个往返时间RTT，就把发送放的cwnd加1</strong>；</p></li><li><p><strong>快重传/快恢复</strong>：</p><blockquote><p>区分快重传，连续ARQ中间丢失是Go back n。</p></blockquote><p>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是⼀种拥塞控制算法，<u>它能快速恢复丢失的数据包。</u>如果<strong>接收机</strong>接收到⼀个【<strong>不按顺序】的数据段，它会⽴即给发送机发送⼀个重复确认（而不是等到自己发送数据时才捎带确认）。如果发送机接收到三个重复确认</strong>，它会假定确认指出的数据段丢失了，并⽴即重传这些丢失的数据段（<strong>而不必继续等待为该报文段设置的重传计时器的超时</strong>）。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/20170823152124856" alt="img"></p></li></ul><h5 id="5-4-如何区分流量控制和拥塞控制？">5.4 如何区分流量控制和拥塞控制？</h5><ul><li><strong>流量控制属于通信双方协商，拥塞控制涉及通信链路全局；</strong></li><li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，<strong>接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定</strong>；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</li></ul><h4 id="6-如何提高客户端并发数？">6.<strong>如何提高客户端并发数？</strong></h4><p>客户端建立的tcp数量受限于最大文件句柄数，一个连接就会建一个文件句柄，在linux 上默认是<strong>1024</strong>。</p><ul><li>使用<code>ulimit</code> 可以修改最大进程数（<strong>最大为65535</strong>）</li></ul><h4 id="7-说说HTTP、TCP、Socket-的关系是什么？">7.<strong>说说HTTP、TCP</strong>、Socket 的关系是什么？</h4><ul><li><strong>TCP/IP</strong> 代表传输控制协议/网际协议，指的是一系列协议族；</li><li><strong>HTTP</strong> 本身就是一个协议，是从 <u>Web 服务器和本地浏览器</u>的超文本传送协议；</li><li><strong>Socket</strong> 是 TCP/IP 网络的 <strong>API</strong> ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</li></ul><h4 id="8-什么是半连接队列？泛洪攻击（DDos攻击的一种），以及解决策略-？">8. 什么是半连接队列？<strong>泛洪攻击（DDos攻击的一种），以及解决策略</strong> ？</h4><ul><li><p><strong>半连接队列</strong></p><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个<strong>队列</strong>里，我们把这种队列称之为<strong>半连接队列</strong>。</p><blockquote><p>已经完成三次握手，建立起连接的就会放在<strong>全连接队列</strong>中。如果队列满了就有可能会出现丢包现象。</p></blockquote></li><li><p><strong>泛洪攻击</strong></p><p>在 TCP 的三次握手机制的第一步中，客户端会向服务器发送 SYN 报文段。</p><ol><li>服务器接收到 SYN 报文段后会为该 <u>TCP分配<strong>缓存和变量</strong></u>，如果<u>攻击分子<strong>伪造大量不存在的IP地址</strong>，大量地往服务器发送 SYN 报文段</u>，服务器的连接资源终将被耗尽，导致<strong>内存溢出</strong>无法继续服务。</li><li>当服务端接收到 SYN 后进入 SYN-RECV 状态，此时的连接称为<strong>半连接</strong>，同时会被服务端写入一个<strong>半连接队列</strong>。<br>想象一下，如果攻击者在短时间内不断的向服务端发送大量的 SYN 包而不响应，那么服务器的<strong>半连接队列很快会被写满</strong>，从而导致无法工作。</li></ol></li><li><p><strong>解决策略</strong></p><p><strong>设置验证机制</strong>：当服务器接受到 SYN 报文段时，<strong>不直接为该 TCP 分配资源</strong>，而只是打开一个<u>半开的套接字</u>。接着会使用 SYN 报文段的<u>源 Id，目的 Id，端口号</u>以及只有服务器自己知道的一个<u>秘密函数生成一个 cookie，并<strong>把 cookie作为序列号响应</strong></u> 给客户端。</p><p>如果客户端是正常建立连接，将会返回一个确认字段为 <strong>cookie + 1 的报文段</strong>。接下来服务器会根据确认报文的源 Id，目的 Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1 等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源 。</p><p><strong>防火墙过滤</strong>： 暂不了解具体</p></li></ul><h4 id="9-为什么DNS（域名解析）用UDP，而区域传送用TCP">9.<strong>为什么DNS（域名解析）用UDP，而区域传送用TCP?</strong></h4><ul><li><strong>DNS用UDP</strong>：客户端向DNS服务器查询域名，一<u>般返回的内容都不超过512字节，用UDP传输即可</u>。不用经过TCP三次握手，这样<u>DNS服务器负载更低，响应更快</u>。</li><li><strong>区域传送用TCP：</strong> TCP协议可靠性好，<u>TCP协议传输的内容大，而UDP最大只能传512字节</u>。</li></ul><h4 id="10-说一下-TCP-粘包是怎么产生的？怎么解决粘包？">10.<strong>说一下 TCP 粘包是怎么产生的？怎么解决粘包？</strong></h4><p><strong>TCP粘包</strong></p><p><strong>TCP粘包</strong>是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><p>客户端要发送原信息是A和B两个数据包，服务端接收到之后，可能出现如下情况：</p><ul><li><strong>正常情况</strong>：读取到了A和B两个数据包；</li><li><strong>粘包</strong>：A和B两个数据包一起读取了；</li><li><strong>拆包</strong>：读取了A数据包的一部分，A的另一部分和B数据包一起读取了。</li></ul><p><strong>TCP粘包原因</strong></p><ul><li><strong>【发送方】TCP默认使用Nagle算法</strong>。客户端通过socket给服务端发送数据，为了传输更有效率，会将<strong>多次间隔较小的且数据量小的数据</strong>，通过<strong>nagle</strong>算法，合并成一个大的数据块，然后进行封包。这样做提高了效率，缺点就是你发送到服务端的数据，服务端不知道是不是完整的，不知道哪几小块数据拼起来才是原来的数据；</li><li><strong>【接收方】来不及接收缓存区的包</strong>，导致多个包接收；</li><li>TCP<strong>连接复用</strong>造成的粘包问题；</li><li>流量控制，<strong>拥塞控制</strong>也可能导致粘包。</li></ul><p><strong>解决粘包</strong></p><p>解决问题的关键在于如何给<strong>每个数据包添加边界信息</strong>：</p><ol><li><strong>Nagle算法</strong>问题导致的，需要结合应用场景适当关闭该算法；</li><li><strong>发送端给每个数据包添加包 <u>首部</u> <strong>，首部中应该至少包含数据包的</strong>长度</strong>，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了；</li><li><strong>数据包之间设置边界</strong>，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开 ；</li><li><strong>发送端将每个数据包封装为固定长度</strong>（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li></ol><h4 id="11-TCP-UDP的区别？">11. TCP, UDP的区别？</h4><ul><li>UDP 在<strong>传送数据之前不需要先建立连接</strong>。远地主机在收到 UDP 报⽂后，不需要给出任何确认。虽然UDP 不提供可靠交付，但在某些情况下 UDP 确是⼀种最有效的⼯作方式（⼀般用于即时通信）<ul><li>⽐如： <u>QQ 语⾳、 QQ 视频 、直播</u>等等</li></ul></li><li>TCP <strong>提供面向连接的服务</strong>。在传送数据之前必须先建⽴连接，数据传送结束后要释放连接。 TCP 不提供⼴播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握⼿来建⽴连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这⼀难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的⾸部增大很多，还要占用许多处理机资源。<ul><li>TCP ⼀般用于<u>⽂件传输、发送和接收邮件、远程登录</u>等场景。</li></ul></li><li><strong>数据包</strong>： TCP是<strong>报文段</strong>，UDP是<strong>用户数据报</strong>。</li><li><strong>应用场景</strong> ： TCP用于一些需要可靠传输的场景； UDP则应用一些即时通信场景，不需要可靠传输的场景。</li><li><strong>长度</strong>：UDP在DNS最长只能是512字节，TCP会更长。</li></ul><h2 id="3-3-网络层">3.3 网络层</h2><h4 id="1-请简单解释一下，ARP协议和ARP攻击">1.<strong>请简单解释一下，ARP协议和ARP攻击?</strong></h4><ul><li>ARP协议：地址解析协议，建立<code>IP/MAC</code>地址映射表</li><li>ARP攻击：</li></ul><h4 id="2-什么是ICMP协议，它的作用是什么？">2.<strong>什么是ICMP协议，它的作用是什么</strong>？</h4><p>用于在<strong>IP主机、路由器</strong>之间传递控制消息。</p><blockquote><p>控制消息是指：<strong>网络通不通、主机是否可达、路由是否可用</strong>等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p></blockquote><h4 id="3-请你讲一下路由器和交换机的区别？">3.<strong>请你讲一下路由器和交换机的区别？</strong></h4><ol><li><p><strong>动态IP</strong>：<u>路由器可以给你的局域网自动分配IP</u>，虚拟拨号，就像一个交通警察，指挥着你的电脑该往哪走，你自己不用操心那么多了。<u>交换机只是用来分配网络数据的</u>。</p><p><u>路由器可以把一个IP分配给很多个主机使用，这些主机对外只表现出一个IP</u>。交换机可以把很多主机连起来，这些主机对外各有各的IP。</p></li><li><p><strong>寻址方式</strong>：路由器在<strong>网络层</strong>，<u>路由器根据IP地址寻址</u>，路由器可以处理TCP/IP协议，交换机不可以；交换机在<strong>中继层</strong>，<u>交换机根据MAC地址</u>寻址。</p></li><li><p><strong>防火墙</strong>：路由器提供防火墙的服务，交换机不能提供该功能。集线器、交换机都是做端口扩展的，就是扩大局域网(通常都是以太网)的接入点，也就是能让局域网可以连进来更多的电脑。路由器是用来做网间连接，也就是用来连接不同的网络。</p></li></ol><h4 id="4-请解释ping命令过程？">4.<strong>请解释<code>ping</code>命令过程？</strong></h4><ol><li>域名在DNS服务器查找IP地址；</li><li>通过Ping程序发送<strong>ICMP包；</strong></li><li>同一网段的情况下，调用IP层的<strong>ARP协议</strong>请求<strong>广播</strong>（不同网段的情况下，交给路由器处理），<strong>查找目标主机的MAC地址</strong>；</li><li>目标主机ARP协议收到请求后，将本机<strong>MAC地址填充</strong>并<strong>发送ARP应答</strong>回到请求发送方；</li><li>请求发送方发送<strong>ICMP数据</strong>到目标主机；</li><li>目标主机<strong>响应ICMP包</strong>；</li><li>请求主机收到目标主机的<strong>ICMP响应包</strong>。</li></ol><h4 id="5-（补充介绍）介绍一下IPV6？一共多少位？">5. （补充介绍）介绍一下IPV6？一共多少位？</h4><p><img src="https://i.loli.net/2021/05/17/i5Nz6lF9RXYsShw.png" alt="IPv6 协议基础_果子哥丶的博客-CSDN博客"></p><p>源IP和目的IP地址都是，128（4*32）位（图中标识不清晰）！</p><h4 id="6-介绍一下IP地址分类？C类哪些是保留地址？网络号全-0-全-1-，主机号全-0-全1-分别什么含义？">6. 介绍一下IP地址分类？C类哪些是保留地址？网络号全 0 全 1   ，主机号全 0 全1 分别什么含义？</h4><ul><li><p><strong>IP地址分类</strong></p><p><code>IP地址 == &#123;&lt;网络号&gt;，&lt;主机号&gt;&#125;</code></p><p><img src="https://i.loli.net/2021/05/17/ZINJCj9l8WM7qhf.jpg" alt="img"></p><ul><li><p><strong>A类</strong>： 第1位固定为0，网络号只有7位 。0（0000 0000）的IP地址是<strong>保留地址</strong>，意思是“本网络” ； 127（0111 1111）的IP地址也是<strong>保留地址</strong>，作为本地环回软件测试 。</p><blockquote><p>特别的，<strong>主机号全1</strong>的是<a href="https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80">广播地址</a>，它代表了网络全部的<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA">主机</a>。</p></blockquote></li><li><p><strong>B类</strong>： 第1、2位固定为10，网络号有14位可以使用 。</p><blockquote><p>B类地址网络号为128.0（1000 000  0000 0000）的IP地址是不指派的，所以可指派的网络号需要减一。</p></blockquote></li><li><p><strong>C类</strong>： 第1、2、3位固定为110，网络号有21位可以使用 。</p><blockquote><p>（快手问）C类IP地址包含<strong>私有C类地址</strong>，范围从192.0.0.0 到223.255.255.255，其中私有C类地址范围从<strong>192.168.0.0 到192.168.255.255。</strong></p></blockquote></li></ul></li><li><p><strong>全0或者全1的含义</strong></p><ul><li><p><strong>网络号全0：</strong>（1）如果主机号也为全0，那么此类ip地址可以当源端但不可以做目的端 （2）如果主机号不全为0，那么此类ip地址的使用和（1)相同，只是它代表的是网络上特定的主机</p></li><li><p><strong>网络号全1：<strong>全1的网络号和</strong>任意的主机号</strong>组合当做<strong>回环地址</strong>来使用。</p><blockquote><p>例如：127（0111 1111）的IP地址</p></blockquote></li><li><p><strong>主机号全0：</strong> 全为0，所得到的地址就是192.168.100.0，它是一个网络地址，代表的是一个<strong>网段</strong>；</p></li><li><p><strong>主机号全1：</strong> 机号全1 代表的是<strong>广播地址</strong>，广播地址是不可以做源端的，但是可以做目的端。</p></li></ul></li></ul><h2 id="3-4-应用层">3.4 应用层</h2><h4 id="1-请你谈谈DNS的寻址过程？">1.<strong>请你谈谈DNS的寻址过程？</strong></h4><p>（1）检查<strong>浏览器缓存、检查本地hosts文</strong>件：是否有这个网址的映射，如果有，就调用这个IP地址映射，解析完成。</p><p>（2）如果没有，则查找<strong>本地DNS解析器缓存</strong>：是否有这个网址的映射，如果有，返回映射，解析完成。</p><blockquote><p><strong>本地dns服务器一般都是你的网络接入服务器商提供</strong>，比如中国电信，中国移动等。</p></blockquote><p>（3）如果没有，则查找填写或分配的<strong>首选DNS服务器</strong>：称为本地DNS服务器。服务器接收到查询时：</p><ul><li><p>如果要查询的域名包含在本地配置区域资源中，返回解析结果，查询结束，此解析具有权威性。</p></li><li><p>如果要查询的域名不由本地DNS服务器区域解析，但服务器缓存了此网址的映射关系，返回解析结果，查询结束，此解析不具有权威性。</p></li></ul><p>（4）如果本地DNS服务器也失效：</p><ul><li>如果未采用<u>转发模式</u>（<strong>迭代</strong>，从上至下）（1）<strong>本地DNS服务器</strong>就把<strong>请求发至13台根DNS</strong>，根DNS服务器收到请求后，会判断这个域名（<a href="http://xn--bvs.com">如.com</a>）是谁来授权管理，<u>并返回一个负责该顶级域名服务器的IP</u>，（2）本地DNS服务器收到顶级域名服务器IP信息后，继续向该<strong>顶级域名</strong>服务器IP发送请求，（3）该服务器如果无法解析，则会找到负责这个域名的下一级DNS服务器（如http://baidu.com）的IP给本地DNS服务器，循环往复直至查询到映射，（4）将解析结果<strong>返回<u>本地DNS服务器</u>，再由本地DNS服务器</strong>返回解析结果，查询完成。</li><li>如果采用<u>转发模式</u>（<strong>递归</strong>，从下至上）（1）则此DNS服务器就会把请求转<strong>发至上一级DNS服务器</strong>，（2）如果上一级DNS服务器不能解析，则继续向上请求，（3）最终将解析结果依次<u>返回本地DNS服务器</u>，本地DNS服务器再返回给客户机，查询完成。</li></ul><h5 id="1-1-怎么获取13台根服务器？">1.1 怎么获取13台根服务器？</h5><p>ping -R ? 抓包？</p><h5 id="1-2-解释一下DNS劫持和DNS污染？">1.2 <strong>解释一下DNS劫持和DNS污染</strong>？</h5><blockquote><p>参考：<a href="https://juejin.cn/post/6844903991764058126">什么是http劫持 ? </a></p></blockquote><p><strong>一、DNS劫持</strong></p><p>DNS劫持某些手段取得<strong>某域名的解析记录控制权</strong>，进而修改此域名的解析结果，返回给用户一个错误的查询结果。</p><ul><li><p><strong>劫持过程</strong></p><ol><li><p>客户端发起域名请求到DNS解析服务器（一般是LocalDNS），<u>但此时DNS解析服务器被攻击篡改</u>；</p></li><li><p>被攻击篡改后的DNS解析服务器将请求转发给虚假服务器；</p><blockquote><p>DNS查询没有任何认证机制且基于UDP不可靠连接，因此很容易被篡改。</p></blockquote></li><li><p>虚假服务器返回<u>响应虚假信息</u>给被攻击篡改后的DNS解析服务器（也可能直接不响应）；</p></li></ol></li><li><p><strong>解决办法</strong></p><p>DNS劫持的本质是<strong>运营商的DNS解析服务器被攻击篡改</strong></p><ul><li>使用国外免费公用的DNS服务器解决。例如OpenDNS（208.67.222.222）或GoogleDNS（8.8.8.8）</li><li>直接使用ip进行访问</li></ul></li></ul><p><strong>二、DNS污染</strong></p><p>DNS污染是一种让一般用户由于<strong>得到虚假目标主机IP</strong>而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。因为是不是<u>劫持单个DNS服务器，而是监听所有的，所以个人比较难防范。</u></p><ul><li><p><strong>污染原理</strong></p><ol><li><p>通过对UDP端口53上的<strong>DNS查询进行入侵检测</strong>；</p><blockquote><p>由于通常的DNS查询没有任何认证机制，而且DNS查询通常基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改。</p></blockquote></li><li><p>一经发现与关键词相匹配的请求则<u><strong>立即伪装成目标域名的解析服务器</strong></u>（NS，Name Server）给查询者返回虚假结果。</p></li></ol></li><li><p><strong>解决办法</strong></p><ol><li>VPN代理或者域名远程解析的方法解决</li><li>通过修改Hosts，手动设置<u>域名正确的IP地址</u></li></ol></li></ul><h4 id="2-Forward和Redirect的区别？">2. <strong>Forward和Redirect的区别</strong>？</h4><ul><li><p><strong>浏览器 URL 地址</strong>：Forward 是服务器<u>内部的重定向</u>，服务器<strong>内部请求某个 servlet</strong>，然后获取响应的内容，<strong>浏览器的 URL 地址不会变化</strong>；Redirect 是客户端请求服务器，然后服务器给客户端返回了一个<strong>302</strong> 状态码和<strong>新的 location</strong>，客户端<u><strong>重新发起 HTTP 请求</strong></u>，服务器给客户端响<u>应 location 对应的 URL 地址，</u>浏览器的 <strong>URL 地址发生了变化</strong>。</p></li><li><p><strong>数据的共享</strong>：Forward 是服务器内部的重定向，request 在整个重定向过程中是不变的，<strong>request 中的信息在 servlet 间是共享</strong>的。Redirect 发起了<strong>两次 HTTP 请求</strong>分别使用<strong>不同的request</strong>。</p></li><li><p><strong>请求的次数</strong>：Forward 只有一次请求；Redirect 有两次请求。</p></li></ul><h4 id="3-请你简单讲解一下，负载均衡反向代理模式的优点、缺点？">3.<strong>请你简单讲解一下，负载均衡反向代理模式的优点、缺点？</strong></h4><blockquote><p>联系实际：<a href="https://server.zol.com.cn/633/6339623_all.html">正反向代理、科学上网、VPN之间的关系</a> 和<a href="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">翻墙基本原理（看他的其他文章补充）</a></p></blockquote><p>【基本介绍】</p><ol><li><p><strong>反向代理</strong>（Reverse Proxy）：方式是指<u>以代理服务器来接受internet上的连接请求</u>，然后将请求转发给内部网络上的服务器，并将从<strong>服务器上得到的结果返回给internet上请求连接的客户端</strong>，此时代理服务器对外就表现为一个服务器；</p><ul><li><p><strong>优点</strong>： 网络络外部用户不能直接访问真实的服务器，具备额外的安全性</p></li><li><p><strong>缺点</strong>： 反向代理是处于OSI参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反向代理服务器；限制了应用范围；</p><p><u><strong>针对每一次代理，代理服务器就必须打开两个连接</strong></u>，一个对外，一个对内，因此在并发连接请求数量非常大的时候，<strong>代理服务器的负载也就非常大了</strong>，在最后代理服务器本身会成为服务的瓶颈。</p></li></ul></li><li><p><strong>反向代理负载均衡技术</strong>：是把将来自internet上的连接请求以反向代理的方式动态地<strong>转发</strong>给内部网络上的<strong>多台服务器</strong>进行处理，从而达到负载均衡的目的。</p><ul><li><strong>实现</strong>：apache mod_proxy、netscape proxy等，也可以在高速缓存器、负载均衡器等硬件设备上实现。</li><li><strong>优点</strong>：可以将优化的 <u>负载均衡策略和代理服务器的高速缓存技术</u>结合在一起，提升静态网页的访问速度，提供有益的性能</li><li><strong>缺点</strong>：</li></ul></li></ol><h5 id="3-1-请解释下负载均衡的相关算法？">3.1 请解释下负载均衡的相关算法？</h5><p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。</p><ul><li>给配置高、负载低的机器配置更高的权重，让其处理更多的请求；</li><li>给配置低、负载高的机器分配较低的权重，降低系统负载。</li></ul><p>下面是几种比较相关的算法。</p><ul><li><p><strong>加权轮询算法</strong></p><blockquote><p>参考：<a href="https://www.fanhaobai.com/2018/11/load-balance-round-robin.html">加权轮询算法</a></p></blockquote><ul><li><p>基本定义</p><ol><li>假设有 N 台实例 S = {S1, S2, …, Sn}，权重 W = {W1, W2, …, Wn}</li><li>currentPos 表示当前选择的实例 ID，初始化为 -1；</li><li>currentWeight 表示当前权重，初始值为 max(S)；</li><li>max(S) 表示 N 台实例的最大权重值，gcd(S) 表示 N 台实例权重的最大公约数。</li></ol></li><li><p>算法过程</p><ol><li>从上一次调度实例起，<strong>遍历后面</strong>的每个实例；</li><li>若所有实例已被遍历过一次，则减小 currentWeight 为 currentWeight - gcd(S)，并从头开始遍历；若 currentWeight 小于等于 0，则重置为 max(S)；</li><li><strong>直到</strong> 遍历的实例的权重 &gt;= currentWeight 时结束，<strong>此时实例为需调度的实例</strong>；</li><li>每次调度重复步骤 1、2、3；</li></ol></li><li><p>算法实例</p><p><img src="https://i.loli.net/2021/05/30/YCVDN4miMvPy7sJ.png" alt="image-20210529232315965"></p><p>例如，上述 4 个服务，最大权重 max(S) 为 4，最大公约数 gcd(S) 为 1。其调度过程如下：</p><p><img src="https://i.loli.net/2021/05/30/7A4s6i3opra8LWR.png" alt="image-20210529232350799"></p></li><li><p>算法优缺点</p><ul><li><p><strong>优点</strong>： 相比 <u>简单轮询</u> 方式，通过权重进行分配，更加均匀</p></li><li><p><strong>缺点</strong>：如下一个极端情况</p><blockquote><p>服务实例 S = {a, b, c}，权重 W = {5, 1, 1}，使用加权轮询调度生成的实例序列为 {a, a, a, a, a, b, c}，那么就会存在连续 5 个请求都被调度到实例 a。</p></blockquote><p>关于这点，可以采用  <a href="https://www.fanhaobai.com/2018/11/load-balance-round-robin.html#">平滑加权轮询</a> 调度算法 。</p></li></ul></li></ul></li><li><p><strong>一致性哈希算法</strong></p><p>负载均衡算法中的哈希算法，就是根据某个值生成一个哈希值，然后对应到某台服务器上去，即<strong>哈希环</strong>。</p><p><img src="https://i.loli.net/2021/05/30/fAa2jzXxGZ7lVq1.png" alt="image-20210529232953082"></p><p>但是可能出现一种，<strong>哈希倾斜</strong>的情况：A负责的区域太大，B，C负责的小。这个时候采用虚拟节点去解决，这里不表。</p></li></ul><h5 id="3-2-DNS-负载均衡是什么策略？">3.2 DNS 负载均衡是什么策略？</h5><blockquote><p>参考：<a href=""></a></p></blockquote><ul><li><strong>原理</strong>： 还是不太明白，DNS递归查询本身就是个负载均衡策略吧？多台服务器满足同一个查询服务？</li></ul><h4 id="4-请说明一下http和https的区别？">4.<strong>请说明一下http和https的区别？</strong></h4><ol><li>https协议要申请证书到ca，需要一定<u>经济成本</u>；</li><li>http是明文传输，https是加密的安全传输；</li><li>（🚩*1）连接的端口不一样，http是<strong>80</strong>，https是<strong>443</strong>；</li><li>http连接很简单，没有状态；</li><li>https是ssl加密的传输，身份认证的网络协议，相对http明文传输比较安全。</li></ol><h5 id="4-1-讲一讲http的请求报文和响应报文？协议？">4.1 讲一讲http的请求报文和响应报文？协议？</h5><ul><li><p><strong>请求报文和协议</strong></p><p>一个HTTP请求报文由<strong>请求行（request line）</strong>、<strong>请求头部（header）</strong>、<strong>空行</strong>和<strong>请求数据</strong>4个部分组成，下图给出了请求报文的一般格式。</p><p><img src="https://i.loli.net/2021/05/17/uxX1gbcnhTsS9td.png" alt="img"></p><ul><li><p><strong>请求行</strong> ：由请求方法字段、URL字段和HTTP协议版本字段3个字段组成。</p><blockquote><p><strong>HTTP协议</strong> :  的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</p></blockquote></li><li><p><strong>请求头部</strong>： 请求头部由<strong>关键字/值</strong>对组成，每行一对，关键字和值用英文冒号“:”分隔 。 请求头部<strong>通知服务器有关于客户端请求的信息</strong>。</p><blockquote><p>User-Agent：产生请求的浏览器类型。</p><p>Accept：客户端可识别的内容类型列表。</p><p><strong>Host</strong>：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</p></blockquote></li><li><p><strong>请求数据 :</strong> 请求数据<strong>不在GET方法中使用，而是在POST方法</strong>中使用。POST方法适用于需要客户填写表单的场合。</p></li></ul></li><li><p><strong>响应报文和协议</strong></p><p>HTTP响应也由四个部分组成，分别是：<strong>状态行、响应头、空格、响应数据</strong>。</p><p><img src="https://i.loli.net/2021/05/17/QNIRoY5f7jk6sHv.jpg" alt="img"></p><ul><li><strong>状态行</strong> ： 状态行（status line）通过提供一个状态码来说明所请求的资源情况。如<strong>404</strong>等</li></ul></li></ul><h5 id="4-2-一个TCP连接中多个HTTP请求发生可以【同时】一起发生吗？">4.2  一个TCP连接中多个HTTP请求发生可以【同时】一起发生吗？</h5><ul><li><strong>HTTP/1.1单个 TCP 连接在同一时刻只能处理一个请求</strong>。意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠；</li><li><strong>Pipelining 技术 &amp; Multiplexing。</strong> Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行；</li></ul><blockquote><p>那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？</p></blockquote><ul><li>维持和服务器已经建立的 TCP 连接，在同一连接上<strong>顺序处理多个请求</strong>；</li><li><strong>和服务器建立多个 TCP 连接</strong>。</li></ul><h4 id="5-请说明一下http1-0-和https1-1-区别？">5.<strong>请说明一下http1.0 和https1.1 区别</strong>？</h4><ul><li><strong>长连接</strong><ul><li>HTTP1.0默认使用短连接，每次HTTP请求都需要建立新的TCP连接，连接不能复用；</li><li>HTTP1.1支持<strong>持久连接和请求的流水线处理（但不是并发！！</strong>），在<strong>一个TCP连接上可以传送多个HTTP请求和响应</strong>，<u>减少建立和关闭TCP连接的消耗和延迟，提高效率</u></li></ul></li><li><strong>host字段</strong><ul><li>在<strong>HTTP1.0中为每台服务器绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名</strong>（hostname）</li><li>HTTP1.1的请求消息和响应消息都应支持Host头域（<u>补充：F12 抓包可以看到</u>），且请求消息中如果<strong>没有Host头域</strong>，会<strong>报400 Bad Request错误</strong></li></ul></li><li><strong>缓存处理</strong><ul><li>HTTP1.1则引入了更多的缓存控制策略</li></ul></li><li><strong>带宽优化及网络连接的使用</strong><ul><li>HTTP1.0中存在浪费带宽现象，例如：（1）客户端只需要某个对象的一部分，而服务器却<u>将整个对象发送过来</u>；(2) 下载大文件不支持断点续传功能，在发生断连后需要重新下载完整的包；</li><li>HTTP1.1则在请求头中引入range头域，它允许<strong>只请求资源的某个部分(因此也支持断点重传)</strong>，即返回码是206；</li></ul></li><li><strong>新增一些错误通知状态码</strong><ul><li>如：409（Conflict）表示请求的资源与资源的当前状态发生冲突 。</li></ul></li></ul><h4 id="6-请说明一下http1-0-和https2-0-区别？">6.<strong>请说明一下http1.0 和https2.0 区别</strong>？</h4><h4 id="7-请讲一下浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程？">7.<strong>请讲一下浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程</strong>？</h4><ol><li><p>在浏览器地址栏中输入URL；</p></li><li><p>DNS域名解析，获得域名相对应的IP地址（详见：<u>应用层DNS寻址过程</u>）；</p><blockquote><p>浏览器首先会从（1）本地浏览器缓存、hosts文件是否存在相应的域名、IP对应关系，如果有则向这个IP地址发送请求，如果没有则向（2）本地DNS<strong>解析器</strong>缓存中查找，如果都没有，（3）再去DNS<strong>服务器</strong>中找IP。</p></blockquote></li><li><p>浏览器向服务器发起TCP连接，与浏览器建立TCP三次握手；然后 <u><strong>向服务器发送HTTP请求</strong></u>，请求数据包</p><blockquote><p><strong>HTTP请求是由三部分组成：请求行、请求报头和请求正文</strong>。</p><p>与服务器建立了连接后，就可以向服务器发起请求了。发送HTTP请求的过程就是<u>构建HTTP请求报文</u>，并通过TCP协议发送到服务器指定端口（<u>HTTP协议80/8080，HTTPS协议443</u>）。</p></blockquote></li><li><p>服务端（由web服务器）处理收到的请求</p><blockquote><p>服务器端收到请求后，由web服务器（准确来说应该是HTTP服务器）处理请求，诸如Apache、Ngnix、IIS 。</p></blockquote></li><li><p>服务器返回相应结果（响应报文）至浏览器</p><blockquote><p>HTTP响应报文也是由三部分组成：<strong>状态码、响应报头和响应报文</strong>。</p><p>状态码是由三位数组成，<u>第一个数字定义了响应的类别</u>：</p><ul><li><strong>1XX</strong>：指示信息，表示请求已接受，继续处理；</li><li><strong>2XX</strong>：成功，表示请求已被成功接收、理解、接受；</li><li><strong>3XX</strong>：重定向，要完成请求必须进行更进一步的操作；</li><li><strong>4XX</strong>：客户端错误，请求有语法错误或无法实现；</li><li><strong>5XX</strong>：服务器端错误，服务器未能实现合法的请求。</li></ul></blockquote></li><li><p>四次挥手关闭TCP连接</p><blockquote><p>四次挥手，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。</p></blockquote></li><li><p>浏览器解析渲染页面</p><blockquote><p>浏览器在 <u>收到HTML、CSS、JS文件</u>后，就需要进行渲染。</p><p>（1）浏览器解析HTML文件构建<u>DOM树</u>，（2）然后解析CSS文件构建<u>渲染树</u>，（3）等到渲染树构建完成后，浏览器开始布局渲染树并将其<u>绘制到屏幕</u>上</p></blockquote></li></ol><h4 id="8-请解释一下SSL工作过程（Https传输过程）？">8.<strong>请解释一下SSL工作过程（Https传输过程）？</strong></h4><blockquote><p>https是http的扩展，在传输层使用了安全协议：<strong>安全套接字层SSL(Secure Socket Layer)</strong>。</p><p>参考：<a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p></blockquote><blockquote><p><strong>公钥</strong>通常用于加密会话密钥、验证数字签名，或加密可以用相应的私钥解密的数据。公钥和私钥是通过一种算法得到的一个密钥对(即一个公钥和一个私钥)。</p><ul><li>通过这种算法得到的密钥对能保证在世界范围内是唯一的。</li><li>使用这个密钥对的时候,如果用其中一个密钥加密一段数据，必须用另一个密钥解密。</li></ul></blockquote><p>SSL/TLS协议的基本思路是采用<a href="http://en.wikipedia.org/wiki/Public-key_cryptography">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p><img src="https://i.loli.net/2021/04/21/aH6gjc5UT9Xu2io.png" alt="image-20210421171336262"></p><p>所以基本过程是：</p><blockquote><p>（1） 客户端向服务器端索要并验证公钥。</p><p>（2） 双方协商生成&quot;对话密钥&quot;。</p><p>（3） 双方采用&quot;对话密钥&quot;进行加密通信。</p></blockquote><ol><li><p><strong>协商加密算法</strong>。客户端（通常是浏览器）先向服务器发出<u>加密通信的请求</u>，这被叫做ClientHello请求；</p><blockquote><p>（1） 支持的协议版本，比如TLS 1.0版。</p><p>（2） <u>一个客户端生成的随机数</u>，来生成&quot;对话密钥&quot;。</p><p>（3） 支持的加密方法，比如RSA公钥加密。</p><p>（4） 支持的压缩方法。</p></blockquote></li><li><p><strong>服务器回应</strong>。服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello；</p><blockquote><p>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</p><p>（2） <u>一个服务器生成的随机数</u>，稍后用于生成&quot;对话密钥&quot;。</p><p>（3） 确认使用的加密方法，比如RSA公钥加密。</p><p>（4） 服务器证书。</p></blockquote></li><li><p><strong>客户端鉴别</strong>。客户端收到服务器回应以后，（1）<u>首先验证服务器证书</u>：如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p><p>（2）<u>如果证书没有问题，客户端就会从证书中取出服务器的公钥</u>。然后，向服务器发送下面三项信息：</p><blockquote><p>（1） <u>一个随机数</u>。该随机数用服务器公钥加密，防止被窃听。</p><p>（2） <u>编码改变通知</u>，表示随后的信息都将用双方商定的加密方法和密钥发送。</p><p>（3） <u>客户端握手结束通知</u>，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p></blockquote></li><li><p><strong>会话秘钥计算</strong>。 服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的&quot;会话密钥&quot;（使用3个随机数生成更安全）；</p><blockquote><p>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p><p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p></blockquote></li><li><p><strong>安全数据传输</strong>。双方用会话秘钥加密和解密之间传送的数据。</p></li></ol><h5 id="8-1-公钥如何保证不被篡改？说一说证书。">8.1 公钥如何保证不被篡改？说一说证书。</h5><p>将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p><ul><li><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p></li><li><p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，<strong>会对已申请的公开密钥做数字签名</strong>，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p></li><li><p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过（<strong>证书不可信浏览器会提示</strong>），就可以开始通信了。</p></li></ul><h5 id="8-2-公钥加密计算量太大，如何减少耗用的时间？">8.2 公钥加密计算量太大，如何减少耗用的时间？</h5><p>每一次对话（session），客户端和服务器端都生成一个&quot;对话密钥&quot;（session key），用它来加密信息。由于<strong>对话密钥是对称加密</strong>，所以<strong>运算速度非常快</strong>，而服务器公钥只用于加密&quot;对话密钥&quot;本身，这样就减少了加密运算的消耗时间。</p><h5 id="8-3-为什么有的时候刷新页面不需要重新建立-SSL-连接？">8.3 为什么有的时候刷新页面不需要重新建立 SSL 连接？</h5><p>TCP 连接有的时候会被浏览器和服务端维持一段时间，<strong>TCP 不需要重新建立，SSL 自然也会用之前的</strong>。</p><h4 id="9-介绍一下常见的几种非对称加密算法？优缺点？">9. 介绍一下常见的几种非对称加密算法？优缺点？</h4><ul><li><p><strong>非对称加密</strong></p><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，<strong>通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密</strong>，<strong>接收方收到通信内容后使用私有密钥解密</strong>。</p></li><li><p><strong>常用非对称加密算法</strong></p><p><img src="https://i.loli.net/2021/04/21/8cmyAzUZYDw5vJt.png" alt="面试题——对称加密和非对称加密3"></p><ul><li>RSA：由 RSA 公司发明，是一个支持<strong>变长密钥</strong>的公共密钥算法，需要加密的文件块的长度也是可变的</li><li>DSA（Digital Signature Algorithm）<strong>：数字签名</strong>算法，是一种标准的 DSS（数字签名标准）</li><li>ECC（Elliptic Curves Cryptography）<strong>：椭圆曲线加密</strong></li></ul></li><li><p><strong>非对称加密优缺点</strong></p><ul><li><strong>优点</strong>： 可以更安全地将公开密钥传输给通信发送方；</li><li><strong>缺点</strong>： 运算速度慢。</li></ul></li></ul><h4 id="10-公钥加密–私钥解密与公钥解密–私钥加密有什么区别">10.<strong>公钥加密–私钥解密与公钥解密–私钥加密有什么区别?</strong></h4><p>主要是应用场景不同。</p><ul><li><p>加解密：公钥加密，私钥解密</p><blockquote><p>不希望别人知道我的消息，<u>所以只有我才能解密</u>，所以可得出公钥负责加密，私钥负责解密</p></blockquote></li><li><p>签名：私钥签名，公钥验签</p><blockquote><p>是不希望有人冒充我发消息，只有<u>我才能发布这个签名</u>，所以可得出私钥负责签名，公钥负责验证</p></blockquote></li><li><p><strong>https可以只有非对称加密吗?</strong></p><p>https<u>验证证书阶段是非对称加密</u>，但是在数据传输阶段是对称加密。<strong>https不可以只有非对称加密</strong>：</p><ul><li><strong>非对称加密</strong>的加解密<strong>效率是非常低</strong>的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的；</li><li>在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。</li></ul></li></ul><h4 id="11-HTTPS-为什么安全？为什么需要CA证书？只有认证机构可以生成证书吗？HTTPS-绝对安全吗？">11. <strong>HTTPS 为什么安全？为什么需要CA证书？只有认证机构可以生成证书吗？HTTPS 绝对安全吗？</strong></h4><ul><li><p><strong>安全</strong>：因为 HTTPS 保证了传输安全，防止传输过程被监听、防止数据被窃取，可以确认网站的真实性；</p></li><li><p><strong>CA证书</strong>： <u>HTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器</u>，而 HTTPS 协议主要解决的便是网络传输的安全性问题，所以需要CA证书</p></li><li><p><strong>证书生成</strong>： 如果需要浏览器不提示安全风险，那只能使用认证机构签发的证书。但<strong>浏览器通常只是提示安全风险，并不限制网站不能访问</strong>，所以从技术上<strong>谁都可以生成证书</strong>，只要有证书就可以完成网站的 HTTPS 传输。</p></li><li><p><strong>不绝对安全</strong>： 不是绝对安全的，可以通过中间人攻击。</p><blockquote><p>CA证书不是可以解决“中间人”吗？</p></blockquote><p>过程原理：</p><ol><li>本地请求被劫持（<u>如DNS劫持等</u>），所有请求均发送到中间人的服务器</li><li>中间人服务器返回中间人自己的证书（<strong>但是这一步服务器不是会对服务器证书进行验证吗？</strong>）</li><li>客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输</li><li>中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密</li><li>中间人以客户端的请求内容再向官方网站发起请求</li><li>因为中间人与服务器的通信过程是合法的，官方网站通过建立的安全通道返回加密后的数据</li><li>中间人凭借与官方网站建立的对称加密算法对内容进行解密</li><li>中间人通过与客户端建立的对称加密算法对官方内容返回的数据进行加密传输</li><li>客户端通过与中间人建立的对称加密算法对返回结果数据进行解密</li></ol></li></ul><h4 id="12-http应答码中的301-2-4、500、502、503、504状态码进行解释？">12. <strong>http应答码中的301/2/4、500、502、503、504状态码进行解释</strong>？</h4><ul><li><p><strong>200：</strong>  请求成功。</p></li><li><p><img src="https://i.loli.net/2021/04/21/MRi5Oy9Ltd3v8uA.png" alt="image-20210421150625709"></p></li><li><p><strong>500：</strong> 500 (<strong>服务器内部错误</strong>) 服务器遇到错误，无法完成请求。 例如，服务器<strong>无法识别请求方法</strong>时可能会返回此代码。</p></li><li><p><strong>501：<strong>服务器</strong>不支持请求的功能</strong>，无法完成请求</p></li><li><p><strong>502：</strong> 作为<strong>网关或者代理工作的服务器</strong>尝试执行请求时，从<u>上游服务器</u>接收到<strong>无效</strong>的响应。</p></li><li><p><strong>503：</strong> 由于超载或系统维护，服务器暂时的<strong>无法处理客户端</strong>的请求。</p></li><li><p><strong>504(及时)</strong>：作为网关或者代理工作的服务器尝试执行请求时，<strong>未能及时</strong>从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。</p></li></ul><h4 id="13-介绍一下http请求get、post等？">13.<strong>介绍一下http请求get、post等</strong>？</h4><p><img src="https://i.loli.net/2021/04/21/WRLspE4fvjdKq8F.png" alt="image-20210421140204266"></p><p><strong>重点区分一下get和post：</strong></p><ul><li><p><code>get</code> ：GET方法用于使用给定的URI从给定服务器中<u>检索信息</u>，即从指定资源中请求数据。</p><ul><li><strong>GET请求是可以缓存的</strong>，浏览器历史记录中查找到GET请求；<strong>长度有限制</strong>；不安全，<strong>url会暴露请求的参数</strong></li></ul></li><li><p><code>post</code>：POST方法用于将数据发送到服务器以<u>创建或更新资源</u> 。</p><ul><li><strong>POST请求不会被缓存</strong>；<strong>长度无限制</strong>；更安全</li></ul></li><li><p><strong>特别的：<code>GET产生一个TCP数据包;POST产生两个TCP数据包。</code></strong></p><ul><li><p>get：http header和body一并发送出去 ；</p></li><li><p>post：浏览器先发送header，服务器响应100 continue，浏览器再发送body 。</p><blockquote><p>⚠️ post是不一定会发生两个的。</p><ul><li>HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送；</li><li>header 和 body 分开发送<strong>是部分浏览器或框架的请求方法</strong>，不属于 post 必然行为。</li></ul></blockquote></li></ul></li></ul><h5 id="13-1-Get方法长度有限制是怎么回事？">13.1 Get方法长度有限制是怎么回事？</h5><p>HTTP 协议没有 Body 和 URL 的长度限制，<strong>对 URL 限制的大多是浏览器 / 服务器的原因</strong>。</p><ul><li>服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制；</li><li>浏览器也会设置url有限。</li></ul><h5 id="13-2-POST-方法相比GET方法是绝对安全吗？">13.2 POST 方法相比GET方法是绝对安全吗？</h5><ul><li>POST 比 GET 安全，因为数据在地址栏上不可见；</li><li><strong>POST不是绝对安全</strong>，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。</li></ul><p>想要安全，只有使用<strong>HTTPS</strong>。</p><h4 id="14-HTTP是不保存状态的协议-如何保存用户状态">14.  HTTP是不保存状态的协议,如何保存用户状态?</h4><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太⼀样。</p><ul><li><strong>Cookie ⼀般用来保存用户<u>信息</u></strong><ul><li>我们在 Cookie 中<strong>保存已经登录过得用户信息</strong>，下次访问网站的时候页面可以⾃动帮你登录的⼀些基本信息给填了；</li><li>⼀般的网站都会有<strong>保持登录</strong>也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以<strong>存放了⼀个 Token 在 Cookie</strong>中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录⼀般要将 Token<br>重写)；</li><li>登录⼀次网站后访问网站其他页面不需要重新登录。</li></ul></li><li><strong>Session 的主要作用就是通过服务端记录用户的<u>状态</strong></u>。<ul><li><strong>典型的场景是购物⻋</strong>，当你要添加商品到购物⻋的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</li><li><strong>既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢</strong>？大部分情况下，我们都是通过在Cookie 中附加⼀个 Session ID 来方式来跟踪。</li></ul></li></ul><h4 id="15-cookie-、session的作用和区别？">15. <strong>cookie 、session的作用和区别</strong>？</h4><ul><li><p><strong>Cookie</strong></p><ul><li><p><strong>作用</strong>： 服务器发送到用户浏览器并保存在本地的一小块数据，它会在<u>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</u>。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。</p><blockquote><p>Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p></blockquote></li></ul></li><li><p><strong>Session</strong></p><ul><li><strong>作用</strong>： Session 代表着服务器和客户端<strong>一次会话的过程</strong>，Session <u>对象存储特定用户会话所需的属性及配置信息</u>。</li></ul></li><li><p><strong>二者区别</strong></p><ul><li><strong>作用范围不同</strong>，Cookie 保存在客户端（浏览器），Session 保存在服务器端；</li><li><strong>有效期不同</strong>，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效；</li><li><strong>安全性</strong>： Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些；</li><li><strong>存储大小不同</strong>：  <u>单个 Cookie 保存的数据不能超过 4K</u>，Session 可存储数据远高于 Cookie；</li><li><strong>存取类型的不同</strong>，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li></ul></li></ul><h5 id="15-1-Session的共享方式？（好未来问过）">15.1 Session的共享方式？（好未来问过）</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/jing99/p/11785070.html">Session如何共享</a></p></blockquote><ul><li><p><strong>问题描述</strong></p><ol><li>在集群环境中，假设客户端第一次访问服务A，服务A响应返回了一个sessionId并且存入了本地Cookie中。第二次不访问服务A了，转去访问服务B；</li><li>访问服务B的时候，会将sessionId加入到请求头中，而服务B因为通过sessionId没有找到相对应的数据，因此它就会<strong>创建一个新的sessionId并且响应返回给客户端</strong></li></ol><p>这样就造成了不能共享Session的问题。</p></li><li><p><strong>解决方案</strong></p><ol><li><strong>使用Cookie实现</strong>。 将系统用户的Session信息加密、序列化后，以Cookie的方式， 统一种植在根域名下（如：.host.com），利用浏览器访问该根域名下的所有二级域名站点时，会传递与之域名对应的所有Cookie内容的特性，从而实现用户的Cookie化Session在多服务间的共享访问。</li><li><strong>数据库同步session。</strong>  每次将session数据存到数据库中。这个方案还是比较可行的。<ul><li><strong>缺点</strong>： Session的并发读写能力取决于MySQL数据库的性能，对数据库的压力大，同时需要自己实现Session淘汰逻辑，以便定时从数据表中更新、删除 Session记录，当并发过高时容易出现表锁。</li></ul></li><li><strong>使用token代替session。</strong> 就是Token方式替代了，但是还是没解决。</li><li><strong>Spring-Sesion实现</strong> 。将原本需要由Web服务器创建会话的过程转交给Spring-Session进行创建。Spring-Session会将原本应该保存在Web服务器内存的Session存放到Redis中。然后<strong>Web服务器之间通过连接Redis来共享数据</strong>，达到Sesson共享的目的。</li></ol></li></ul><h4 id="16-Cookie-和-Session有什么关联？（问过）token有什么作用，优点，（JWT）结构是什么？">16.  Cookie 和 Session有什么关联？（问过）token有什么作用，优点，（JWT）结构是什么？</h4><blockquote><p>参考：<a href="https://juejin.cn/post/6844904009061367821">一文彻底搞懂Cookie、Session、Token到底是什么</a></p></blockquote><ul><li><p><strong>为什么需要session？</strong></p><blockquote><p>既然浏览器已经通过<code>Cookie</code>实现了有状态这一需求，那么为什么又来了一个<code>Session</code>呢？</p></blockquote><p>如果将账户的一些重要信息都存入<code>Cookie</code>中的话，一旦<strong>被拦截</strong>，那么我们所有的账户信息都会丢失掉。所以就出现了<code>Session</code>，在一次会话中将重要信息保存在<code>Session</code>中，浏览器只记录<code>SessionId</code>一个<code>SessionId</code>对应一次会话请求。</p></li><li><p><strong>session和cookie二者关联</strong></p><p><img src="https://i.loli.net/2021/05/04/jNerb9CXZ6Jpgs2.jpg" alt="img"></p><blockquote><p>以用户一次登录为例。</p></blockquote><ol><li>用户第一次请求服务器的时候，用户提交包含<strong>用户名和密码</strong>的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 <strong>Redis</strong> 中，它在 Redis 中的 Key 称为 Session ID；并将此 Session 的唯一标识信息 SessionID 返回给浏览器；</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名；</li><li>当用户第二次访问服务器的时候，请求会自动判断<u>此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端</u>；</li><li>服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 <u>Session 信息，如果没有找到说明用户没有登录或者登录失效</u>，如果找到 Session 证明用户已经登录可执行后面操作。</li></ol></li><li><p><strong>什么是Token？</strong></p><blockquote><p><code>Session</code>是将要验证的信息存储在服务端，并以<code>SessionId</code>和数据进行对应，<code>SessionId</code>由客户端存储，在请求时将<code>SessionId</code>也带过去，因此实现了状态的对应。</p></blockquote><p>但是，而<code>Token</code>是在服务端将<strong>用户信息经过Base64Url【编码，不是加密】过后传给在客户端</strong>，每次用户请求的时候都会带上这一段信息，因此服务端拿到此信息进行解密后就知道此用户是谁了。</p><p>这个方法叫做<strong>JWT(Json Web Token)</strong>。</p><blockquote><p>一个例子理解：基于Token的身份验证流程，在服务端不需要存储用户的登录记录 。</p><ol><li><p>客户端<strong>使用用户名跟密</strong>码请求登录</p></li><li><p>服务端收到请求，去验证用户名与密码</p></li><li><p>验证成功后，服务端会<strong>签发一个 Token</strong>，再把这个 Token 发送给客户端</p><blockquote><p>Token在服务器端，可以保存在Redis缓存中。</p></blockquote></li><li><p>客户端收到 Token 以后可以把它存储起来，比如<strong>放在 Cookie 里或者 Local Storage</strong> 里</p></li><li><p>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p></li><li><p>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p></li></ol></blockquote><ul><li><p><strong>Token的优点</strong></p><ol><li><strong>无状态，可扩展和解耦</strong>： 使用 token 而不是 cookie 的最大优点应该就是无状态，<strong>后端不需要保持对 token 的记录，每个 token 都是独立的</strong>，包含了检查其有效性的所有数据，并通过申明传达了用户信息。</li><li><strong>在 JWT 中存储数据</strong> ： 当使用 cookie 进行验证时，你是将 session id 存储到 cookie 里，JWT 允许你存储任何类型的元数据，只要是合法的 JSON。</li><li><strong>自包含</strong>：由于串包含了用户所需要的信息，避免了多次查询数据库。</li></ol></li><li><p><strong>JWT介绍</strong></p><p>JWT有三部分组成：Header，Payload，Signature。</p><p><img src="https://i.loli.net/2021/05/26/AC6ULh5293HQngE.png" alt="image-20210526214555872"></p><ul><li><p><strong>Header：</strong> 一个Json对象，描述JWT的元数据，通常是下面这样子的。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>, # 签名的算法为HS256</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>    # Token类型为JWT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Payload：</strong> 也是一个Json对象，用来存放实际需要传输的数据，也可以自己定义一些私有字段，如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xiaoMing&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Signature</strong>： <strong>对前面的两部分的数据进行签名</strong>，<strong>防止数据篡改</strong> 。</p><blockquote><p>首先需要定义一个<strong>秘钥</strong>，这个秘钥只有服务器才知道，不能泄露给用户，然后使用<strong>Header中指定的签名算法</strong>(默认情况是HMAC SHA256)。算出签名以后将Header、Payload、Signature三部分拼成一个字符串，<strong>每个部分用<code>.</code>分割开来</strong>，就可以返给用户了。</p></blockquote></li></ul></li></ul></li></ul><h5 id="16-1-session和cookie应该如何去选择（适用场景）？">16.1 session和cookie应该如何去选择（适用场景）？</h5><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在<strong>考虑数据复杂性时首选 Session</strong>；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；<strong>考虑安全考虑session</strong></li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此<strong>不建议将所有的用户信息都存储到 Session 中，一般是cookie和session配合使用的</strong>。</li></ul><h4 id="17-说说HTTP、TCP、Socket-的关系是什么？">17.<strong>说说HTTP、TCP、Socket 的关系是什么</strong>？</h4><ul><li>TCP/IP 代表<u>传输控制协议/网际协议</u>，指的是一系列协议族；</li><li>HTTP 本身就是一个协议，是<u>从 Web 服务器传输超文本到本地浏览器</u>的传送协议；</li><li><strong>Socket 是 TCP/IP 网络的 API</strong> ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</li></ul><h2 id="3-5-其它">3.5 其它</h2><h4 id="1-介绍一下CDN-？-CDN分发节点各个数据都一样吗？">1. 介绍一下CDN ？ <strong>CDN</strong>分发节点各个数据都一样吗？</h4><ul><li><p><strong>CDN，即内容分发网络</strong></p><ul><li><p><strong>解决静态网页加载</strong></p><p>不同地区用户访问服务器速度不同，<strong>可以把静态网页放在不同地区的服务器，这样用户可以就近去连接</strong>，大大提升体验；</p></li><li><p>发展转换成，<strong>就近接入解决访问网络资源</strong></p><ol><li>如一个电信用户送请求，进入解析系统，会<strong>让用户连接到最近的边缘节点</strong>，然后请求数据；</li><li>如果边缘节点没有数据，则去访问<strong>源节点</strong>；</li><li>源节点也没有，就会去访问<strong>主干节点，去联通服务器中查找；</strong></li><li>最后返回数据。</li></ol></li></ul></li><li><p><strong>CDN分发节点各个数据不一样</strong></p><p>不一样，就相当于DNS服务器<strong>缓存</strong>了些域名→ip数据，如果没有的话还要向上级查询，最终把源站数据拉下来。</p></li></ul><h4 id="2-什么是CDN三级溯源？">2.  什么是CDN三级溯源？</h4><ul><li><strong>CDN目的</strong>。CDN 系统设计的首要目标是<strong>尽量减少用户的访问响应时间</strong></li><li><strong>CDN实现思路</strong>。为达到这一目标，CDN 系统应该<strong>尽量将用户所需要的内容存放在距离用户最近的位置</strong>。也就是说，负责为用户提供内容服务的 <strong>Cache设备应部署在物理上的网络边缘位置</strong>，我们称这一层为 CDN边缘层 。</li><li><strong>CDN系统架构</strong>。CDN 系统中负责全局性管理和控制的设备组成 中心层 ，<strong>中心层同时保存着最多的内容副本</strong>，当边缘层设备未命中时，会向中心层请求，如果在中心层仍未命中，则需要中心层向源站回源。</li></ul><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210813124031742.png" alt="image-20210813124031742"></p><p>各位同学们好：<br>我们今年大数据课程已经接近尾声，这门课已经开设了三年，每年都会邀请同学们来共同建设。每年我们也都会根据同学们的反馈进行完善，今年我们预计会进行一次更大的系统性更新。<br>按照当初承诺，现在我们统计下大家开源贡献，请按照示例，在进行下方评论完成填写。</p><ul><li>[注1] ：为保证大家隐私情况，该Issue<strong>会在三天内统计完毕后关闭</strong>，请及时填写~</li></ul><table><thead><tr><th style="text-align:center">组号</th><th style="text-align:center">贡献类型（文档建设、Issue、PR等）</th><th style="text-align:center">链接（或其它证明截图）</th><th style="text-align:center">贡献人</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">01组</td><td style="text-align:center">issue</td><td style="text-align:center"><a href="">test-issue</a></td><td style="text-align:center">张三（20196666）、李四（20197777）</td><td style="text-align:center"></td></tr></tbody></table><p>感谢大家的积极参与！</p>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（二）_计算机基础_Linux&amp;Git</title>
      <link href="/p/44980/"/>
      <url>/p/44980/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h1>二、Linux &amp; Git</h1><h2 id="2-1-Linux">2.1 Linux</h2><h3 id="2-1-1-常用命令">2.1.1 常用命令</h3><ol><li><p><strong>查看80端口状态</strong>？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntulp | grep 80</span><br></pre></td></tr></table></figure><ul><li><code>-t</code> : 指明显示TCP端口</li><li><code>-u</code> : 指明显示UDP端口</li><li><code>-l</code> : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)</li><li><code>-p</code> : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序</li><li><code>-n</code> : 不进行DNS轮询，显示IP(可以加速操作)</li></ul></li><li><p><strong>怎么查看指定端口是否开放</strong>？</p><p>通过 netstat 命令，注意加上-a参数，看是否有<code>0.0.0.0:22</code> 在被监听。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210906215822732.png" alt="image-20210906215822732"></p><p>通过lsof命令，如果没有任何显示，则端口没有被打开。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210906215941036.png" alt="image-20210906215941036"></p></li><li><p><strong>查看进程状态？怎么退出？怎么搜索进程？怎么查看某一个进程的内存和CPU使用情况</strong>？</p><ul><li><p>所有进程状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -aux  <span class="comment"># 内存中进程信息</span></span><br><span class="line">ps -l    <span class="comment"># 本次登陆所有的进程信息</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/19/ayQRIA8FcqBjtlV.png" alt="image-20210519183338193"></p></li><li><p>退出进程：</p><p><code>exit</code></p></li><li><p>搜索进程：</p><p><code>ps -ef </code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep &lt;进程名&gt;</span><br></pre></td></tr></table></figure><ul><li><code>-e</code>相当于<code>-a</code>是全部列出，<code>-f</code>是显示UID等；</li></ul></li><li><p>查看指定进程（如kalfa）CPU和内存占用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep java</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/23/r5vaDgo4sYGfA8c.png" alt="image-20210523171131744"></p><ul><li>1.3是<strong>CPU占用率</strong>，12.7是<strong>内存占用率</strong>，943100是<strong>物理内存使用量</strong></li></ul><p>还可以使用 top命令查看指定进程（PID）的内存和CPU使用率：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p 2913</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>查看占用指定端口的进程</strong> ？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :8040</span><br></pre></td></tr></table></figure><p>这一步只<u>能获取进程名</u>，还要<code>ps</code> 命令进一步获取进程<code>id</code></p><p>如果要杀死相应进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 &lt;进程id&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>任务管理器</strong>（cpu占用率、内存占用率、进程）？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p>（<strong>总忘</strong>）还可以使用 top命令查看<strong>指定进程（PID）的内存和CPU使用率</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p</span><br></pre></td></tr></table></figure></li><li><p><strong>内存使用情况 和 磁盘使用情况</strong>？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m  <span class="comment"># 内存使用情况</span></span><br></pre></td></tr></table></figure><p>磁盘使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -m</span><br></pre></td></tr></table></figure><p><code>-m</code> : 以Mb为单位显示磁盘使用量和占用率</p></li><li><p><strong>统计单词个数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -o &lt;单词&gt; &lt;文件地址&gt; ｜ wc -l   <span class="comment"># -l表示统计行数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>修改用户权限及常用参数</strong>？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod &lt;参数(可选)&gt; &lt;模式&gt; &lt;文件/文件夹&gt;</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li><code>-R</code> ：递归的修改文件夹下所有子文件/文件夹的所属用户</li></ul><blockquote><p>【示例】如何修改 <code>/test5/5.txt</code> ，权限从<code>rw-r--r--</code> —&gt; <code>r--rwxrwx </code> ？</p><p><img src="https://camo.githubusercontent.com/fc3e66b1514a14614059e9423b7393b39d9a79db57cdcf11f0efd07fd95d32ca/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30392f31372f527a664d625165377471756b786c452e706e67" alt="1580875509098"></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户（U）权限[减去写]权限</span></span><br><span class="line">chmod u-w /test5/5.txt</span><br><span class="line"><span class="comment"># 组（G）/其他用户（O）权限[加上写、执行]</span></span><br><span class="line">chmod go+wx /test5/5.txt</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/20/3wrFPWplI47MTbO.png" alt="1580875689076"></p></li><li><p><strong>查看文件的命令有哪些</strong>？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi 文件名   <span class="comment">#编辑方式查看，可修改</span></span><br><span class="line">cat 文件名  <span class="comment">#显示全部文件内容</span></span><br><span class="line">more 文件名 <span class="comment">#分页显示文件内容</span></span><br><span class="line">less 文件名 <span class="comment">#与 more 相似，更好的是可以往前翻页</span></span><br><span class="line">tail 文件名 <span class="comment">#仅查看尾部，还可以指定行数</span></span><br><span class="line">head 文件名 <span class="comment">#仅查看头部,还可以指定行数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>你平时怎么查看日志的</strong>？</p><p>Linux查看日志的命令有多种: tail、cat、tac、head、echo等，本文只介绍几种常用的方法。</p><ul><li><p><strong>tail（最常使用）</strong></p><p>命令格式: <code>tail[必要参数][选择参数][文件]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail -n 10 test.log 查询日志尾部最后10行的日志;</span><br><span class="line">tail -n +10 test.log 查询10行之后的所有日志;</span><br><span class="line">tail -fn 10 test.log 循环实时查看最后10行记录(最常用的)</span><br></pre></td></tr></table></figure><p>一般还会配合着grep搜索用，例如 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -fn 1000 test.log | grep <span class="string">&#x27;关键字&#x27;</span></span><br></pre></td></tr></table></figure><p>如果一次性查询的数据量太大,可以进行翻页查看，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 4700 aa.log |more -1000 可以进行多屏显示(ctrl + f 或者 空格键可以快捷键)</span><br></pre></td></tr></table></figure></li><li><p><strong>其它配合的命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span>              <span class="comment"># 所有的历史记录</span></span><br><span class="line"><span class="built_in">history</span> | grep XXX   <span class="comment"># 历史记录中包含某些指令的记录</span></span><br><span class="line"><span class="built_in">history</span> | more       <span class="comment"># 分页查看记录</span></span><br><span class="line"><span class="built_in">history</span> -c           <span class="comment"># 清空所有的历史记录</span></span><br><span class="line">!! 重复执行上一个命令</span><br><span class="line">查询出来记录后选中 : !323</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>怎么让进程后台运行</strong>？</p><ol><li><p>命令后面加上**&amp;**即可，实际上，这样是将命令放入到一个作业队列中了；</p><p>通常配合<strong>nohup</strong> ，忽略发送给子命令的挂断SIGHUP信号（<strong>终端关闭</strong>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup subcommand &amp;</span><br></pre></td></tr></table></figure></li><li><p>ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程；</p><blockquote><p>ctrl + c 是进程终止。</p></blockquote></li><li><p>运行指令前面**+ setsid**，使其父进程编程init进程，<strong>不受SIGHUP信号的影响</strong>。</p></li></ol></li></ol><h3 id="2-1-2-其它问题">2.1.2 其它问题</h3><h4 id="1-请问-proc-目录有什么用？">1.<strong>请问<code>/proc</code> 目录有什么用</strong>？</h4><p>Linux系统上的/proc目录是一种文件系统，即proc文件系统。 /proc是一种伪文件系统（也即虚拟文件系统），存储的是<strong>当前内核运行状态</strong>的一系列特殊文件，用户可以通过这些文件：</p><ul><li><strong>查看系统有关（1）硬件及当前（2）正在运行进程</strong>的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。</li></ul><h4 id="2-Linux的软-硬链接是什么？有什么区别？">2. <strong>Linux的软/硬链接是什么？有什么区别</strong>？</h4><blockquote><p>参考：<a href="https://www.linuxprobe.com/soft-and-hard-links.html">“软链接”和“硬链接”的区别</a></p></blockquote><ul><li><p><strong>什么是链接</strong> ？</p><p>文件在Linux上被分成两部分：<strong>用户数据 (user data) 与元数据 (metadata)</strong> 。</p><ul><li><strong>用户数据</strong>：即文件数据块，保留记录文件真实内容的地方</li><li><strong>元数据</strong>：  是文件的附加属性，如创建大小、时间，所有信息等。其中<strong>inode号</strong> ，是文件的唯一标识。</li></ul><p>系统通过inode号快速找到文件，有一种方式可以<strong>快速寻找到数据元信息</strong>，那就是软/硬链接。</p><p>现在我们创建一个新文件<code>myfile</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch myfile &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;This is a plain text file.&quot;</span> &gt; myfile</span><br><span class="line">$ cat myfile</span><br><span class="line"></span><br><span class="line">This is a plain text file.</span><br></pre></td></tr></table></figure><p>来展示二者区别。</p></li><li><p><strong>硬链接</strong></p><p>建立 <code>myfile</code> 的一个硬链接 <code>hard</code> ，可以看到二者的<code>inode</code>  是一致的，也就是说<strong>指向了同一个物理区块</strong>。</p><blockquote><p>硬链接inode ：指向文件的地址 &amp; 维护了一个引用计数，只要有文件还指向这个区块，它就不会从硬盘消失。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ln myfile hard  <span class="comment"># 建立硬链接hard</span></span><br><span class="line">$ ls -li</span><br><span class="line"></span><br><span class="line">25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 hard</span><br><span class="line">25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 myfile</span><br></pre></td></tr></table></figure><ul><li><p><strong>操作硬链接更新文件，等价更新原文件</strong></p><p>使用hard硬链接修改文件，发现原文件也被修改了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;New line&quot;</span> &gt;&gt; hard</span><br><span class="line">$ cat myfile</span><br><span class="line"></span><br><span class="line">This is a plain text file.</span><br><span class="line">New line</span><br></pre></td></tr></table></figure></li><li><p><strong>删除原文件，使用硬链接依旧可以显示</strong></p><p>因为<strong>磁盘块还有硬链接在引用，所以不会消失</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rm myfile  <span class="comment"># 删除原文件</span></span><br><span class="line">$ cat hard   <span class="comment"># 硬链接依旧可以显示</span></span><br><span class="line"></span><br><span class="line">This is a plain text file.</span><br><span class="line">New line</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>软链接</strong></p><p>建立一个<code>soft</code>软链接如下，可以看到二者的inode号是不一样的。</p><blockquote><p>软连接的inode ：保存真实的文件的<strong>绝对路径地址</strong>，找到软链接，还<strong>要根据inode号找到真实文件路径</strong>。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s myfile soft <span class="comment"># 建立软连接soft</span></span><br><span class="line">$ ls -li</span><br><span class="line"></span><br><span class="line">25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 myfile</span><br><span class="line">25869216 lrwxr-xr-x 1 unixzii staff 6 7 8 17:47 soft -&gt; myfile</span><br></pre></td></tr></table></figure><ul><li><p><strong>操作软链接更新文件，等价更新原文件</strong></p><p>因为软链接就是相当个快捷方式，当然更新原文件。</p></li><li><p><strong>删除原文件，使用软链接不会显示</strong></p><p>因为软件inode指向的绝对地址，已经不存在文件了，所以当然不存在文件了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rm myfile</span><br><span class="line">$ cat soft</span><br><span class="line"></span><br><span class="line">cat: soft: No such file or directory</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>软硬连接区别总结</strong></p><ol><li><p><strong>inode号不同</strong>。硬链接原文件/链接文件公用一个inode号，说明他们是同一个文件，而软链接原文件/链接文件拥有不同的inode号，表明他们是两个不同的文件；</p></li><li><p><strong>链接数目不同</strong>。 软链接的链接数目不会增加；硬链接每多一个链接就会+1。</p></li><li><p><strong>文件大小不同</strong>。硬链接文件显示的大小是跟原文件是一样 ；软链接显示的大小与原文件就不同了，BBB大小是95B，而BBBsoft是3B，因为BBB共有3个字符。</p></li><li><p><strong>文件系统限制</strong>。 软链接没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。</p><blockquote><p><strong>建立软链接就是建立了一个新文件</strong>：当访问链接文件时，系统就会发现他是个链接文件，它读取链接文件找到真正要访问的文件。</p></blockquote></li></ol></li></ul><h3 id="3-查询日志的top10-IP">3. 查询日志的top10 IP?</h3><p>命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="built_in">log</span> | cut -d <span class="string">&#x27; &#x27;</span> -f 1 | sort | uniq -c | sort -nr | awk <span class="string">&#x27;&#123;print $0&#125;&#x27;</span> | head -n 10</span><br></pre></td></tr></table></figure><ol><li><p><code>cat *.log</code>  ：将文本内容打印到屏幕</p></li><li><p><code>cut</code>：截取指定IP那一列</p></li><li><p><code>sort </code>，按IP ASCII码排序：进行排序，默认是按照ascii码进行排序的</p></li><li><p><code>uniq -c  </code> ，统计重复的IP ：统计<strong>相邻的行</strong>的重复数量，结果是类似 <code>3 127.13.13.13</code> ，前面的数字代码重复的行数</p><p><code>sort|uniq -c</code>  统计重复的行数</p></li><li><p><code>sort -n</code>，再次排序 ：是按照数值进行由小到大进行排序， -r是表示逆序，-t是指定分割符，-k是执行按照第几列进行排序</p></li><li><p><code>awk</code> ，只显示IP：按照分割符将一行分割为多个列，第一列用1表示，第二列用​2表示，依次类推</p><p><code>awk -F&quot; &quot; '&#123;print $2&#125;</code>   ，表示用空格作为分隔符进行分割，打印出第2列</p></li><li><p><code>head -n ：</code>表示取前n个</p></li></ol><h2 id="2-2-Git">2.2 Git</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/96631135">讲git原理的的一篇不错文章</a></p></blockquote><h3 id="2-2-1-常问命令">2.2.1 常问命令</h3><h4 id="1-什么是Git？是用什么语言编写的？">1.什么是Git？是用什么语言编写的？</h4><ul><li>Git是一个 <u>分布式</u> <u>代码控制系统</u> ；</li><li>Git使用 C 语言编写：<u>使得 GIT 很快，C 语言减少运行时开销</u>来做到这一点。</li></ul><h4 id="2-如何在Git中创建存储库？">2.如何在Git中创建存储库？</h4><ol><li>如果项目不存在，创建</li><li>然后运行 <code>git init</code> ，会在目录下创建一个 <code>.git</code> 目录</li></ol><h4 id="3-列举工作中常用的几个git命令？">3.<strong>列举工作中常用的几个git命令</strong>？</h4><ul><li><code>git add</code> : 增加文件</li><li><code>git commit -m</code> ：提交文件</li><li><code>git status</code> ：拉取远程分支</li><li><code>git push</code> ：合并当前分支和主分支</li><li><code>git pull</code> OR <code>git fetch/git merge</code> ：拉取远程分支</li></ul><h4 id="4-讲讲Git-commit-基本参数？">4.<strong>讲讲Git commit 基本参数</strong>？</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/qianqiannian/p/6005628.html">https://www.cnblogs.com/qianqiannian/p/6005628.html</a></p></blockquote><ul><li><code>git commit -m “message”</code> ：简要说明这次提交的语句</li><li><code>git commit -a</code> ：即使没有经过 <code>git add</code> ，也可以将所有 <u>修改</u> 或 <u>删除</u> 的文件提交到本地仓库，<strong>但新建的文件不会提交</strong></li><li><code>git commit --amend</code> ：追加提交，它可以在<u>不增加一个新的commit-id</u> 的情况下将新修改的代码追加到前一次的commit-id中，</li></ul><h4 id="5-在Git中，你如何还原已经-push-并公开的提交？">5.<strong>在Git中，你如何还原已经 push 并公开的提交</strong>？</h4><ul><li><p>删除或修复新提交中的错误文件，并将其<strong>覆盖</strong>推送到远程存储库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;commit message&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>创建一个新的提交，<strong>撤消</strong>在错误提交中所做的所有更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;name of bad commit&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-git-pull-和-git-fetch-有什么区别？">6. <strong>git pull 和 git fetch 有什么区别</strong>？</h4><ul><li><p><code>git pull</code></p><p>取回远程主机某个分支的更新，<strong>再与本地的指定分支合并</strong> （可能要解决冲突）。</p></li><li><p><code>git fetch</code></p><p>从远程获取最新版本到本地，<strong>不会自动合并</strong> ，需要手动执行 <code>git merge</code></p></li></ul><h4 id="7-什么是-git-stash-你一般什么情况下会使用它？">7.<strong>什么是 git stash?你一般什么情况下会使用它</strong>？</h4><blockquote><p>经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是<code>git stash</code>命令。储藏(stash)可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用</p></blockquote><ul><li><strong>使用情况</strong>： 当前分支还没处理完，不能去commit提交，但是要去处理一个紧急开发项目，使用 <code>git stash</code></li><li>处理完后<code>git stash pop</code> 继续处理工作</li></ul><h4 id="8-如果本次提交误操作，如何撤销？">8.<strong>如果本次提交误操作，如何撤销</strong>？</h4><ul><li><p><strong>场景1</strong>:改乱了（包括删除等）工作区某个文件的内容（<code>git add 之前</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure><p>丢弃之前所有的修改。</p></li><li><p><strong>场景2</strong>:撤销提交到索引区的文件 （<code>git add 之后</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure><p>此时回到了场景1，然后再使用 <code>git checkout</code></p></li><li><p><strong>场景3</strong>： 撤销已经提交之后的文件（<code>git commit之后</code>）：</p><p>回退版本号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog  <span class="comment"># 查看版本</span></span><br><span class="line">$ git reset --hard  3928   <span class="comment"># 回退版本</span></span><br></pre></td></tr></table></figure></li><li><p><strong>场景4：</strong> 撤销已经push到远程分支之后的文件（<code>git push之后</code>）</p><ul><li><p>创建一个新的提交，<strong>撤消</strong>在错误提交中所做的所有更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;name of bad commit&gt;</span><br></pre></td></tr></table></figure></li><li><p>删除或修复新提交中的错误文件，并将其<strong>覆盖</strong>推送到远程存储库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;commit message&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="9-使用过git-merge和git-rebase吗？它们之间有什么区别？">9.<strong>使用过git merge和git rebase吗？它们之间有什么区别</strong>？</h4><p>都是用来合并分支的，但是：</p><ul><li><p><code>git merge &lt;当前分支要合并的分支&gt;</code> ： 在当前分支合并&lt;指定要合并的分支&gt;，会自动在当前分支（下图为master）创建一个commit节点，保留了要合并的分支（下图为branch1）的提交记录</p><p><img src="https://i.loli.net/2021/05/02/oLOVlIs7yNazKnJ.png" alt="preview"></p></li><li><p><code>git rebase &lt;当前分支变基的基点分支&gt;</code> ：相当将当前分支（下图为branch1）的分支节点（5,6） 依次提交到基点分支（master）的4节点之后，保留了更干净的历史记录，没有生成行的commit 节点</p><p><img src="https://i.loli.net/2021/05/02/ebDoLAUMSd13QRI.png" alt="image-20210502231023075"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 校招 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（一）_Java_JVM</title>
      <link href="/p/42516/"/>
      <url>/p/42516/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h2 id="1-6-JVM相关">1.6 JVM相关</h2><h3 id="1-6-1-常问问题">1.6.1 常问问题</h3><h4 id="1-（被问过）JVM启动的基本配置参数有哪些？（或者说调优参数）">1. （被问过）<strong>JVM启动的基本配置参数有哪些</strong>？（或者说调优参数）</h4><p><strong>「堆栈内存相关」</strong></p><ul><li><p>-Xms： 设置初始堆的大小</p></li><li><p>-Xmx： 设置最大堆的大小</p></li><li><p>-Xmn ：设置年轻代大小，相当于同时配置-XX:NewSize和-XX:MaxNewSize为一样的值</p></li><li><p>-Xss： 每个线程的堆栈大小</p></li><li><p>-XX:NewSize 设置年轻代大小(for 1.3/1.4)</p></li><li><p>-XX:MaxNewSize 年轻代最大值(for 1.3/1.4)</p></li><li><p>-XX:NewRatio 年轻代与年老代的比值(除去持久代)</p></li><li><p>-XX:SurvivorRatio Eden区与Survivor区的的比值</p></li><li><p>-XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。</p></li><li><p>-XX:MaxTenuringThreshold设定对象在Survivor复制的最大年龄阈值，超过阈值转移到老年代</p></li></ul><p><strong>「垃圾收集器相关」</strong></p><p>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。</p><ul><li><p>-XX:ParallelGCThreads=20：配置并行收集器的线程数</p></li><li><p>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。</p></li><li><p>-XX:CMSFullGCsBeforeCompaction=5 由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行5次GC以后对内存空间进行压缩、整理。</p></li><li><p>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</p></li></ul><p><strong>「辅助信息相关」</strong></p><ul><li><p>-XX:+PrintGCDetails 打印GC详细信息</p></li><li><p>-XX:+HeapDumpOnOutOfMemoryError让JVM在发生内存溢出的时候自动生成内存快照,排查问题用</p></li><li><p>-XX:+DisableExplicitGC禁止系统System.gc()，防止手动误触发FGC造成问题.</p></li><li><p>-XX:+PrintTLAB 查看TLAB空间的使用情况</p></li></ul><h4 id="2-说说堆和栈的区别？">2.<strong>说说堆和栈的区别</strong>？</h4><ol><li><p><strong>功能不同</strong>：栈内存用来存储<u>局部变量和方法调用</u>，而堆内存用<u>来存储Java中的对象</u>；</p><blockquote><p>注：无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p></blockquote></li><li><p><strong>共享性不同</strong>：栈内存是线程私有的； 堆内存是所有线程共有的；</p></li><li><p><strong>异常错误不同</strong>：如果栈内存或者堆内存不足，都会抛出异常但不同；</p><blockquote><p>栈空间不足：<code>java.lang.StackOverFlowError</code>。 堆空间不足：<code>java.lang.OutOfMemoryError</code>；</p></blockquote></li><li><p><strong>空间大小</strong>：栈的空间大小远远小于堆的。</p></li></ol><h4 id="3-【重点】请问JVM运行时内存布局分布？-哪些是线程共享的？">3.<strong>【重点】请问JVM运行时内存布局分布？ 哪些是线程共享的</strong>？</h4><p>从概念上大致分为 6 个（逻辑）区域，参考下图。注：Method Area 中还有一个常量池区，图中未明确标出。</p><ul><li>总的来看，JVM 把内存划分为<u>“栈(stack)”与“堆(heap)”</u>两大类</li></ul><p><img src="https://static001.infoq.cn/resource/image/dd/a9/dd614bf56417939aa0e0694fedf2caa9.png" alt="img"></p><p><u>线程私有的：</u></p><ul><li><p><strong>程序计数器</strong>：当同时进行的线程数超过CPU数或其内核数时，就要通过时间片轮询分派CPU的时间资源，不免发生线程切换。这时，<u>每个线程就需要一个属于自己的计数器来记录下一条要运行的指令</u>；</p></li><li><p><strong>虚拟机栈</strong>： <u>每个java方法执行时都会创建一个<strong>桢栈</strong></u>来存储方法的：</p><ul><li><p>变量表、操作数栈、动态链接方法、返回值、返回地址等信息；</p></li><li><p>栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法），“<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">栈帧参考</a>” ；</p></li></ul></li><li><p><strong>本地方法栈</strong>： 与虚拟机栈作用相似。但它不是为Java方法服务的，而是调用操作系统原生本地方法时，所需要的内存区域。</p><ul><li>本地方法被执行的时候，在本地方法栈也会创建⼀个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</li></ul></li></ul><p><u>线程共享的：</u></p><ul><li><p><strong>堆</strong>：GC 垃圾回收的主站场，用于<u>存放类的实例对象及 数组实例</u>等；</p><p><img src="https://i.loli.net/2021/05/05/6Ri9BzxGtLpFemP.png" alt="img"></p></li><li><p><strong>方法区</strong>： 线程共享的，用于存放被虚拟机加载的<strong>类的元数据信息</strong>：</p><ul><li>如 <u><strong>常量</strong>、<strong>静态变量</strong></u>和 <u> 即时<strong>编译器编译后的代码</strong></u><strong>；</strong></li><li><strong>运行时常量池：字符串</strong>，int -128~127 范围的值等，它是 <u>方法区</u> 中的一部分。</li></ul></li></ul><h5 id="3-1-JVM-堆中又怎么分的？为什么要这么划分？为什么要取消永久代用元空间代替？">3.1 JVM 堆中又怎么分的？为什么要这么划分？为什么要取消永久代用元空间代替？</h5><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/111809384">https://zhuanlan.zhihu.com/p/111809384</a></p></blockquote><ul><li><p><strong>堆划分</strong>：堆又被划分为，新生代，老年代。新生代又被划分为eden和survivor区。</p></li><li><p><strong>为什么划分新生代、老年代</strong>？</p><p>因为有的对象寿命长，有的对象寿命短。<strong>应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率</strong>。</p></li><li><p><strong>代替</strong>： 在java7版本前，堆和方法区连在了一起，但这并不能说堆和方法区是一起的，它们在逻辑上依旧是分开的。<strong>但在物理上来说，它们又是连续的一块内存</strong>。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210906224656302.png" alt="image-20210906224656302" style="zoom:50%;" /><p><strong>也就是说，方法区和前面讲到的Eden和老年代是连续的</strong>。</p><p><strong>永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集</strong>。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210906224744446.png" alt="image-20210906224744446" style="zoom:50%;" /><p>在Java8中，元空间(Metaspace)登上舞台，<strong>方法区存在于元空间(Metaspace)</strong>。同时，元空间不再与堆连续，<strong>而且是存在于本地内存（Native memory）。本地内存（Native memory），也称为C-Heap</strong>，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210906224848120.png" alt="image-20210906224848120" style="zoom:50%;" /><p><strong>元空间存在于本地内存，意味着只要本地内存足够，它不会出现像永久代中“java.lang.OutOfMemoryError: PermGen space”这种错误。看上图中的方法区，是不是“膨胀”了</strong>。</p></li></ul><h5 id="3-2-程序计数器存哪些东西？能为空吗？">3.2 <strong>程序计数器存哪些东西？能为空吗</strong>？</h5><p>程序计数器是用于存放下一条指令所在单元的地址的地方。</p><p>如果正在执行的是Native方法，这个计数器值为空（Ubdifined）。</p><h4 id="4-（新）说一下Java创建对象的过程？">4. （新）说一下Java创建对象的过程？</h4><p><img src="https://i.loli.net/2021/05/16/EBIujUDhkF9VRtg.png" alt="image-20210516205754856"></p><ol><li><p><strong>类加载检查</strong>： 虚拟机遇到⼀条 new 指令时，⾸先将去检查这个指令的参数是否能在<strong>常量池中定位到这个类的符号引用</strong>，并且检查这个符号引用代表的<strong>类是否已被加载过、解析和初始化过</strong>。如果没有，那必须先执行相应的类加载过程。</p></li><li><p><strong>分配内存</strong>： 在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把⼀块确定大小的内存从 <u>Java 堆中划分出来</u>。</p><blockquote><p><strong>（重要）分配方式有 “指针碰撞” 和 “空闲列表” 两种</strong>，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整⼜由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p><img src="https://i.loli.net/2021/05/16/S27KdREVrpGqt5I.png" alt="image-20210516210222497"></p></blockquote></li><li><p><strong>初始化对象字段零值</strong>。 内存分配完成后，进行对象初始化操作。</p><blockquote><p>例如给<strong>对象中（区分类加载过程，初始化类变量</strong>）所有的基本数据变量赋上初始化值， 当我们没有对它们进行赋值操作时就可以使用对象了。</p></blockquote></li><li><p><strong>设置对象头</strong>： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是<u>哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息</u>。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用<u>偏向锁</u>等，对象头会有不同的设置方式。</p></li><li><p><strong>执行init() &amp; 构造函数</strong>。然后执行对象内部生成的init方法，然后执行构造器方法（程序员设置的）。</p></li><li><p><strong>内存地址赋给引用</strong>： 在虚拟机会将刚创建好对象的内存地址赋给引用对象。完成此操作后，便可以在程序中通过引用访问对象的实例数据。</p></li></ol><h5 id="4-1-什么是指针碰撞？空闲列表？TLAB">4.1 什么是指针碰撞？空闲列表？TLAB?</h5><p>三种虚拟机<strong>划分堆内存</strong>区域的方法，TLAB也可用来给堆内存分配空间。</p><ul><li><p><strong>指针碰撞</strong></p><p>一般情况下，JVM的对象都放在堆内存中（发生逃逸分析除外）。当类加载检查通过后，Java虚拟机开始为新生对象分配内存。</p><ul><li>如果Java堆中内存是绝对规整的，所有被<strong>使用过的的内存都被放到一边，空闲的内存放到另外一边</strong>，中间放着一个<strong>指针作为分界点</strong>的指示器，<u>所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例</u>，这种分配方式就是指针碰撞。</li></ul></li><li><p><strong>空闲列表</strong></p><p><u>如果Java堆内存中的内存并不是规整的</u>，已被使用的内存和空闲的内存相互交错在一起，<u>不可以进行指针碰撞</u>。</p><ul><li>虚拟机必须维护一个列表，<strong>记录哪些内存是可用的</strong>，在分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表。</li></ul></li><li><p><strong>TLAB</strong></p><p>TLAB 是虚拟机在内存的<u><strong>eden 区</strong>划分出来的一块专用空间，是线程专属的</u>。 在启用TLAB 的情况下，当线程被创建时，虚拟机会为每个线程分配一块TLAB 空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提高分配效率。</p><blockquote><p>虚拟机通过 -XX:UseTLAB 设定它的。</p></blockquote></li></ul><h5 id="4-2-JVM如何保证对象分配的线程安全问题？">4.2 JVM如何保证对象分配的线程安全问题？</h5><p>因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>TLAB</strong>： 为<strong>每⼀个线程预先在Eden区分配⼀块⼉内存TLAB</strong>，JVM在<strong>给线程中的对象分配内存时，⾸先在TLAB分配</strong>，当<u>对象大于TLAB中的剩余内存或TLAB的内存已用尽时</u>，再采用的CAS进行内存分配。</li><li><strong>CAS+失败重试</strong>： CAS 是乐观锁的⼀种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为⽌。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li></ul><h4 id="5-描述一下对象分配【原则】？（区分前面new对象【过程】）">5.<strong>描述一下对象分配【原则】？（区分前面new对象【过程】</strong>）</h4><p>JVM 中的堆可划分为两大部分，<u>新生代和老年代</u>，大小比例为1:2：</p><ul><li>新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to 区</li></ul><p><img src="https://i.loli.net/2021/05/05/6Ri9BzxGtLpFemP.png" alt="img"></p><p>具体回收过程：</p><p><img src="https://i.loli.net/2021/04/19/p2LqRv6krQnbga4.png" alt="image-20210419224230046"></p><p>对象的正常流程：<em>Eden 区 -&gt; Survivor 区 -&gt; 老年代</em>。</p><ol><li>新的对象<strong>优先在 Eden 区分配</strong>（<em>大对象直接进入老年区，避免在Eden区及两个Survivor区之间发生大量的内存复制</em>） ,<strong>当 Eden 区没有足够空间时</strong>，会发起一次<em><strong>Minor GC</strong></em>；</li><li><em><strong>Minor GC</strong></em>采用<strong>复制回收算法</strong>的改进版本回收Eden中对象：<ul><li>先将Eden存活对象迁移到 to 区，然后清空Eden</li><li>最后交换to和from区域<strong>标签</strong></li></ul></li><li>每经过一次<em><strong>Minor GC</strong></em>  （在交换区）后对象年龄加1，对象年龄达到<em><strong>15次</strong></em>后将会晋升到老年代；</li><li>对象提前晋升到老年代，动态年龄判定：如果在 Survivor 区中相<u>同年龄所有对象大小总和大于 Survivor 区大小的一半</u>， 年龄大于或等于该年龄的对象就可以直接进入老年代；</li><li>老年代空间不够时进行<em><strong>Full GC</strong></em>。</li></ol><h5 id="5-1-对象一定分配到堆上吗？">5.1 对象一定分配到堆上吗？</h5><blockquote><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTQxOTc5NQ==&amp;mid=2650500024&amp;idx=1&amp;sn=0997c486387bf56bbe8ca909d55a7edf&amp;chksm=83c88c44b4bf05521d66f6a396550cd9c8379c3fdddee1ee198968f6a9ddd172550d3329a94d&amp;scene=21#wechat_redirect">面试官：是不是所有的对象和数组都会在堆内存分配空间</a></p></blockquote><blockquote><p>小伙，来给我讲一下是不是<strong>所有的对象和数组</strong>都会在堆内存分配空间？</p></blockquote><p>并不是，这涉及到<strong>对象逃逸</strong>。请看下面的代码：</p><p>StringBuffer对象，最终会被return，也就是<strong>会被该方法之外的给利用</strong>。 发生了对象逃逸。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/640" alt="图片"></p><p><strong>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识</strong>。 但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一<strong>个对象并没有逃逸出方法的话</strong>，那么就可能被<strong>优化成栈上分配</strong>。</p><h4 id="6-对象的访问定位有哪两种方式">6.<strong>对象的访问定位有哪两种方式</strong>?</h4><p>建⽴对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，⽬前主流的访问方式有：<strong>①使用句柄和 ②直接指针两种</strong>。</p><ol><li><p><strong>句柄</strong>： 如果使用句柄的话，那么Java堆中将会划分出⼀块内存来作为句柄池，reference 中存储的就是<strong>对象的句柄地址</strong>，而句柄中包含了<strong>对象实例数据</strong>与<strong>类型数据（存放在方法区</strong>）各⾃的具体地址信息；</p><blockquote><p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p></blockquote><p><img src="https://i.loli.net/2021/05/16/4XShu2w1nRbZl5x.png" alt="image-20210516211902118"></p></li><li><p><strong>直接指针</strong>： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，<strong>而reference 中存储的直接就是对象的地址</strong>。</p><blockquote><p>使用直接指针访问方式最大的好处就是速度快，它节省了⼀次指针定位的时间开销。</p></blockquote><p><img src="https://i.loli.net/2021/05/16/lTvrqnOFu5X9VJk.png" alt="image-20210516212141885"></p></li></ol><h4 id="7-如何判断对象是否需要回收（死亡）？">7.<strong>如何判断对象是否需要回收（死亡</strong>）？</h4><ul><li><strong>可达性分析</strong>：根据引用的关系构造引用链（有向图），在图中不可达的对象就是要被回收的；</li><li><strong>引用计数</strong>：有地方引用该对象，计数器++，引用失效，计数器–，有循环引用的问题。</li></ul><h4 id="8-如何判断一个常量是废弃变量？如何判断一个类是无用类？">8. 如何判断一个常量是废弃变量？如何判断一个类是无用类？</h4><ul><li><p><strong>判断常量是废弃变量</strong></p><p>运行时常量池主要回收的是废弃的常量。</p><p>假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量&quot;abc&quot; 就是废弃常量，如果这时发⽣内存回收的话而且有必要的话，“abc” 就会被系统清理出常量池。</p></li><li><p><strong>判断类是无用类</strong>？</p><p>虚拟机可以对满足下面3个条件的无用类进行回收，这⾥说的仅仅是“可以”，而并不是和对象⼀样不使用了就会必然被回收。</p><ul><li><p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例；</p></li><li><p>加载该类的 ClassLoader 已经被回收；</p></li><li><p>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ul></li></ul><h3 id="1-6-1-GC相关">1.6.1 GC相关</h3><blockquote><p>不错的GC介绍文章：<a href="https://www.infoq.cn/article/3wyretkqrhivtw4frmr3">一文看懂 JVM 内存布局及 GC 原理</a></p></blockquote><h4 id="1-请介绍GC基本原理？有什么优点？GC可以马上回收内存吗？如何主动让虚拟机回收？">1.<strong>请介绍GC基本原理？有什么优点？GC可以马上回收内存吗？如何主动让虚拟机回收</strong>？</h4><p>当程序员创建对象时，GC就开始监控这个对象的<u>地址、大小</u>及<u>使用情况</u> ，当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间 ：</p><ul><li><strong>基本原理</strong>： GC采用<u><strong>有向图</strong></u>的方式记录和管理<strong>堆(heap)<strong>中的所有对象 ，并确定对象</strong>是否“可达”</strong></li><li><strong>GC优点</strong>：（1）使得程序员不用考虑内存管理 （2）Java中的对象不再有&quot;作用域&quot;的概念，只有对象的引用才有&quot;作用域&quot; （3）有效防止内存泄漏</li><li><strong>马上回收</strong>： 程序员<strong>不能实时</strong>的调用垃圾回收器对某个对象或所有对象进行垃圾回收。</li><li><strong>主动回收</strong>： 手动执行<code>System.gc()</code> ，但是Java语言规范 <u>并不保证</u> GC一定会执行。</li></ul><h5 id="1-1-本地java程序默认启动的是什么垃圾回收器？">1.1 本地java程序默认启动的是什么垃圾回收器？</h5><p>cmd执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><p>输出：<a href="http://codewenda.com/xx%EF%BC%9Auseparallelgc%E5%92%8C-xx%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A-useparnewgc/">-XX：UseParallelGC</a>。</p><h4 id="2-什么是GC-Root？可以作为GC-Root的对象？">2.<strong>什么是GC Root？可以作为GC Root的对象</strong>？</h4><ul><li><p><strong>GC Root <strong>：  判断对象是通过可达性分析，所以所有的可达性算法</strong>都会有起点</strong> ，这就是 GC Root。</p><ul><li><strong>特点</strong>：当前时刻存活的对象！</li></ul><p>通过GC Root 找出所有活的对象，那么剩下所有的没有标记的对象就是需要回收的对象。</p><p><img src="https://pic1.zhimg.com/80/v2-38552a00d9bfb53f0c780e26a0d4b078_720w.jpg" alt="img"></p></li><li><p><strong>GC Root对象</strong>： （1）虚拟机栈中<strong>引用</strong>的<strong>对象</strong>；（2）方法区中的<strong>静态</strong>变量、<strong>常量</strong>对象；（3）本地方法<strong>引用</strong>的<strong>对象</strong>；（4）被<code>synchronized</code>修饰的对象等。</p></li></ul><h4 id="3-哪些内存区域需要GC">3.<strong>哪些内存区域需要GC?</strong></h4><ul><li><p><strong>（无需）线程独享区域</strong>：<code>PC Regiester、JVM Stack、Native Method Stack</code>，其生命周期都与线程相同（即：与线程共生死），所以无需 GC;</p></li><li><p><strong>（需）线程共享</strong>的 Heap 区、Method Area 则是 GC 关注的重点对象。</p></li></ul><p><img src="https://static001.infoq.cn/resource/image/e3/71/e36c624e8b4300775123f95a34b86571.png" alt="img"></p><h4 id="4-什么时候会触发Full-GC？">4.<strong>什么时候会触发Full GC？</strong></h4><ol><li><p><strong>调用 System.gc()</strong> ；</p></li><li><p><strong>老年代空间不足</strong>；</p></li><li><p><strong>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</strong>；</p><blockquote><p>如果发现<strong>统计之前Minor GC的平均晋升大小比目前old gen剩余的空间大</strong>，则不会触发Minor GC而是转为触发full GC。</p></blockquote></li><li><p><strong>方法区空间不足</strong>。</p><blockquote><p>JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中存放的为一些<u><strong>class的信息、常量、静态变量等数据</strong></u>，当系统中<strong>要加载的类、反射的类和调用的方法较多</strong>时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：<code>java.lang.OutOfMemoryError: PermGen space</code> 。<br>为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p></blockquote></li></ol><h4 id="5-什么时候触发-Minor-GC-什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？">5.<strong>什么时候触发 Minor GC ? 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢</strong>？</h4><ul><li><p><strong>什么时候触发Minor GC ?</strong></p><p><strong>当Eden区不足时</strong>就会触发 Minor GC 。</p></li><li><p><strong>minor gc运行频繁</strong></p></li></ul><ol><li><p>产生了太多朝生夕灭的对象导致需要频繁minor gc</p></li><li><p>新生代空间设置太小</p></li></ol><ul><li><p><strong>minor gc运行很慢</strong></p><ol><li><u>新生代空间设置过大</u>；</li><li><u>对象引用链较长</u>，进行可达性分析时间较长；</li><li><u>新生代survivor区设置的比较小</u>，清理后剩余的对象不能装进去需要移动到老年代，造成移动开销；</li><li><u>内存分配担保失败</u>，由minor gc转化为full gc；</li><li><u>采用的垃圾收集器效率较低</u>，比如新生代使用serial收集器。</li></ol></li></ul><h4 id="6-描述一下GC算法？">6.<strong>描述一下GC算法</strong>？</h4><p>GC算法包含：引用计数法，标记清除，标记复制，标记压缩。</p><ul><li><strong>引用计数</strong>：对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用；</li><li><strong>标记清除</strong>： 垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象；然后，在清除阶段，<u>清除所有未被标记的对象，<strong>但会产生很多垃圾碎片</strong></u> ；</li><li><strong>标记复制</strong>： 将内存对半分，总是<strong>保留一块空着</strong>（上图中的右侧），将左侧存活的对象（浅灰色区域）复制到右侧。<strong>避免了内存碎片问题，但是内存浪费很严重</strong>，<u>相当于只能使用 50%的内存</u>；</li><li><strong>标记压缩（标记整理</strong>）：标记过程仍然与<u>“标记-清除”</u>算法一样，但后续步骤<strong>不是直接对可回收对象进行清理</strong>，而是让<strong>所有存活的对象都向一端移动</strong>，然后<strong>直接清理掉端边界以外的内存</strong>（类似于 windows 的磁盘碎片整理），避免垃圾碎片。</li></ul><h5 id="6-1-新生代和老年代用哪些算法？stw问题会发生在新生代吗">6.1 <strong>新生代和老年代用哪些算法？stw问题会发生在新生代吗?</strong></h5><ul><li><p><strong>针对新生代，采用标记复制算法</strong></p><blockquote><p>参考：<a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">https://tech.meituan.com/2017/12/29/jvm-optimize.html</a></p></blockquote><p>大多数对象在新生代中被创建，其中很多对象的生命周期很短。<strong>每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活</strong>，所以选用复制算法，只需要<strong>少量的复制成本</strong>就可以完成回收。</p><p>HotSpot实现的<strong>复制算法流程</strong>如下:</p><ol><li>当Eden区满的时候,<strong>会触发第一次Minor gc，把还活着的对象拷贝到Survivor From区</strong>；当Eden区<strong>再次触发Minor gc</strong>的时候,会扫描Eden区和From区域，<strong>对两个区域进行垃圾回收,经过这次回收后还存活的对象,则直接复制到To区域</strong>,并将Eden和From区域清空。</li><li>当后续Eden又发生Minor gc的时候,会对<strong>Eden和To区域进行垃圾回收</strong>,存活的对象复制到From区域,并将Eden和To区域清空。</li><li>部分对象会在From和To区域中复制来复制去，<strong>如此交换15次</strong>(由JVM参数MaxTenuringThreshold决定,这个参数默认是15)，最终如果还是存活,就存入到老年代。</li></ol></li><li><p><strong>针对老年代对象存活率高的特点</strong></p><p>在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，<strong>该区域中对象存活率高</strong>。</p><p>老年代的垃圾回收（又称Major GC）通常使用<strong>标记-清理或标记-整理算法。整堆包括新生代和老年代的垃圾回收称为Full GC</strong>（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。</p></li></ul><h4 id="7-什么是Stop-The-World-什么是安全点？安全区域？">7.<strong>什么是Stop The World ?</strong> 什么是安全点？安全区域？</h4><ul><li><p><strong>Stop The World</strong></p><p>进行<strong>垃圾回收</strong>的过程中，<u>会<strong>涉及对象的移动。为了保证对象引用更新的正确性</strong>，必须暂停所有的用户线程</u>，像这样的停顿，虚拟机设计者形象描述为「Stop The World」。也简称为STW。JVM在暂停的时候，需要选准一个时机。</p><p>由于JVM系统运行期间的复杂性，不可能做到随时暂停，因此引入了<strong>安全点</strong>的概念。</p></li><li><p><strong>安全点</strong></p><blockquote><p>安全点，即程序（非GC先）执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。</p></blockquote><p>安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，<strong>Java虚拟机的堆栈不会发生变化</strong>。这么一来，<strong>垃圾回收器便能够“安全”地执行可达性分析</strong>。只要不离开这个安全点，Java虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。</p></li><li><p><strong>如何保证中断时所有线程都在安全点</strong></p><ul><li><p><strong>抢先式中断（Preemptive Suspension）</strong><br>抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，<strong>如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上</strong>。现在几乎没有虚拟机采用这种方式来暂停线程从而响应GC事件。</p></li><li><p><strong>主动式中断（Voluntary Suspension）</strong><br>主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。<strong>轮询标志的地方和安全点是重合的</strong>，另外再加上创建对象需要分配内存的地方。</p></li></ul></li></ul><h4 id="8-常见的垃圾回收器有哪些（比如G1）？">8. 常见的垃圾回收器有哪些（比如G1）？</h4><p><img src="https://i.loli.net/2021/05/16/ypmn6LRB5trC3Dl.png" alt="image-20210516215006746"></p><ul><li><p><strong>Serial收集器</strong>。 Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是⼀个单线程收集器了。它的<strong>单线程</strong> 的意义不仅仅意味着它只会使用⼀条垃圾收集线程去完成垃圾收集⼯作，更重要的是它在进行垃圾收集⼯作的时候必须<strong>暂停其他所有的⼯作线程（ “Stop The World”</strong>），直到它收集结束。</p></li><li><p><strong>ParNew收集器</strong>。 ParNew收集器其实就是<strong>Serial收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全⼀样。</p><ul><li>新⽣代采用<u><strong>标记-复制</strong>算法，⽼年代采用<strong>标记-整理</strong>算法</u>。</li></ul></li><li><p><strong>Parallel Scavenge收集器</strong>。 Parallel Scavenge 收集器类似于ParNew 收集器。 那么它有什么特别之处呢？ Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量。</p><blockquote><p>如果对于收集器运作不太了解的话，⼿⼯优化存在的话可以选择把内存管理优化交给虚拟机去完成也是⼀个不错的选择。-</p></blockquote><ul><li><u>新⽣代采用<strong>标记-复制</strong>算法，⽼年代采用<strong>标记-整理</strong>算法</u>。</li></ul></li><li><p><strong>（重点）CMS收集器。<strong>CMS（Concurrent Mark Sweep）收集器是一种以</strong>获取最短回收停顿时间</strong>为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以<code>并发</code>执行，以此来达到降低收集停顿时间的目的。</p><ul><li>CMS收集器仅作用于<strong>老年代</strong>的收集，基于 <u>“<strong>标记-清除</strong>”</u> 。</li><li><strong>优点</strong>： 并发收集、低停顿。</li><li><strong>缺点（快手</strong>）： CMS收集器<strong>对CPU资源非常敏感</strong>；CMS收集器<strong>无法处理浮动垃圾</strong>（Floating Garbage）。</li></ul></li><li><p><strong>（重点）G1收集器</strong>。 G1重新定义了堆空间，<strong>打破了原有的分代模型，将堆划分为一个个区域</strong>。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。区域划分的好处就是带来了<strong>停顿时间可预测的收集模型</strong>：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</p><ul><li><strong>并行与并发</strong>：G1能充分利⽤CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核⼼）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li><li><strong>分代收集</strong>：虽然G1可以不需要其他收集器配合就能独⽴管理整个GC堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与CMS的<u>“标记–清除”</u>算法不同，G1从整体来看是基于<strong>标记-整理</strong>算法实现的收集器；从局部上来看是<strong>基于<u>标记-复制</u>算法</strong>实现的。</li><li><strong>可预测的停顿</strong>：这是G1相对于CMS的另⼀个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建⽴可预测的停顿时间模型，能让使用者明确指定在⼀个⻓度为M毫秒的时间片段内。</li></ul></li></ul><h5 id="8-1-介绍一下CMS-和-G1-垃圾回收器原理？">8.1 介绍一下CMS 和 G1 垃圾回收器原理？</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/heyonggang/p/11718170.html">弄明白CMS和G1，就靠这一篇了</a></p></blockquote><ul><li><p><strong>CMS收集器</strong></p><p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的。</p><p>CMS收集器仅作用于老年代的收集，是基于<u>标记-清除</u>算法的，它的运作过程分为4个步骤：</p><ol><li><strong>初始标记（CMS initial mark） :</strong> 需要<strong>STW</strong>，标记一下GC Roots能<strong>直接</strong>关联到的对象 ；</li><li><strong>并发标记（CMS concurrent mark）</strong>：从GC Roots开始堆中对象进<strong>行可达性分析</strong>，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行；</li><li><strong>重新标记（CMS remark）</strong>：需要<strong>STW</strong> ，<strong>修正并发标记期间</strong>因用户程序继续运作而导致<strong>标记产生变动</strong>的那一部分对象的标记记录 ；</li><li><strong>并发清除（CMS concurrent sweep）</strong>： 清除对象。</li></ol></li><li><p><strong>G1收集器</strong></p><p>在堆的结构设计时，G1打破了以往将收集范围固定在新生代或老年代的模式，G1将堆分成许多<strong>相同大小</strong>的区域单元，每个单元称为<strong>Region</strong>。Region是一块地址连续的内存空间，G1模块的组成如下图所示：</p><blockquote><p>区域划分的好处就是带来了<strong>停顿时间可预测的收集模型</strong>：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</p></blockquote><p>和CMS挺像的。</p><ol><li>初始标记（Initial Marking）：仅仅只是标记一下GC Roots能<strong>直接关联</strong>到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</li><li>并发标记（Concurrent Marking）：是从GC Roots开始堆中对象进行<strong>可达性分</strong>析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</li><li>最终标记（Final Marking）：是为了修正并发标记期间因用户程序继续运作而导致<strong>标记产生变动</strong>的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</li><li><strong>筛选回收</strong>（Live Data Counting and Evacuation）：首先<strong>对各个Region的回收价值和成本进行排序</strong>，根据用户<strong>所期望的GC停顿时间来制定回收计划</strong>。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li></ol></li></ul><h5 id="8-2-为什么CMS不用标记-压缩算法？">8.2 为什么CMS不用标记-压缩算法？</h5><p>CMS主要关注<strong>低延迟</strong>，因而采用并发方式。</p><p>在<strong>并发清理垃圾</strong>时，如果采用压缩算法，这<strong>涉及到移动存活的对象。如果不进行停顿会很难处理</strong>，违背了CMS初衷，所以采用<strong>标记-清除</strong>算法。</p><h4 id="9-什么是内存泄漏？">9.<strong>什么是内存泄漏</strong>？</h4><p>广义并通俗的说，就是：<u>不再会被使用的<strong>对象</strong>的内存不能被回收</u>，就是内存泄漏。</p><p><strong>内存泄漏场景</strong>：</p><ul><li><p>静态集合类、数组<strong>添加对象以后遗漏了对于他们的处理</strong>，例如HashMap和Vector；</p></li><li><p>各种连接，如数据库连接、网络连接、IO连接；</p></li><li><p>单例模式；</p></li><li><p>变量不合理的作用域。</p></li></ul><h3 id="1-6-2-类加载">1.6.2 类加载</h3><h4 id="1-介绍一下类文件结构？">1. 介绍一下类文件结构？</h4><p>Class⽂件字节码结构组织示意图 。</p><p><img src="https://i.loli.net/2021/05/16/VkMjgwfFb9NGr2L.png" alt="image-20210516220600929"></p><ol><li><strong>魔数:</strong> 确定这个⽂件是否为⼀个能被虚拟机接收的 Class ⽂件。</li><li><strong>Class ⽂件版本</strong>：Class ⽂件的版本号，保证编译正常执行。</li><li><strong>常量池</strong> ：常量池主要存放两大常量：字面量和符号引用。</li><li><strong>访问标志</strong>：标志用于识别⼀些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</li><li><strong>当前类索引,⽗类索引</strong> ：类索引用于确定这个类的全限定名，⽗类索引用于确定这个类的⽗类的全限定名，由于 Java 语⾔的单继承，所以⽗类索引只有⼀个，除了 java.lang.Object 之外，所有的 java 类都有⽗类，因此除了 java.lang.Object 外，所有 Java 类的⽗类索引<br>都不为 0。</li><li><strong>接口索引集合</strong>：接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 implents (如果这个类本身是接口的话则是 extends ) 后的接口顺序从左到右排列在接口索引集合中。</li><li><strong>字段表集合</strong>：描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</li><li><strong>方法表集合</strong> ：类中的方法。</li><li><strong>属性表集合</strong>： 在 Class ⽂件，字段表，方法表中都可以携带⾃⼰的属性表集合。</li></ol><h4 id="2-什么是类加载器？请你解释一下java程序运行的过程？">2. 什么是类加载器？请你解释一下java程序运行的过程？</h4><blockquote><p>参考 ： <a href="https://cloud.tencent.com/developer/article/1350078">一个简单java程序的运行全过程</a></p></blockquote><p><u>类加载器是一个用来加载类文件的<strong>类</strong></u> 。</p><p>我们所说的类加载过程即是指<strong>JVM虚拟机把.class文件中类信息加载</strong>进内存。主要分为以下3大步、5小步：</p><p><img src="https://i.loli.net/2021/04/21/m1Ot3nQcMGq2YfW.jpg" alt="img"></p><ol><li><p><strong>编译</strong>。 将编译的<code>.java</code> 文件编译为<code>.class</code>字节码文件，然后交给JVM运行；</p></li><li><p><strong>加载</strong> ：class字节码文件从各个来源通过<strong>类加载器</strong>装载入<u>内存</u>中 。</p><blockquote><ul><li><strong>来源</strong>：包本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译</li><li><strong>类加载器</strong> ：一般包括<strong>启动类加载器</strong>，<strong>扩展类加载器</strong>，<strong>系统类加载器</strong>，以及用户的<u><strong>自定义类加载器</strong> （代码加密防止反编译）</u>。</li></ul></blockquote></li><li><p><strong>链接</strong>： 分为，验证、准备、解析（”正-中-准-心“）三阶段</p><ul><li><p><strong>验证</strong>： 保证加载进来的<u>字节流符合虚拟机规范</u>；</p><blockquote><p><strong>文件格式的验证</strong>，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</p><p><strong>元数据的验证</strong>，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</p><p><strong>字节码的验证</strong>，保证程序语义的合理性，比如要保证<u>类型转换的合理性</u>。</p><p><strong>符号引用的验证</strong>，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p></blockquote></li><li><p><strong>准备</strong>：类变量（<strong>注意，不是实例变量</strong> ）分配内存，并且赋予<strong>初值</strong>（虚拟机根据不同类型设定的初始值）；</p><blockquote><p>这些变量所使用的内存都将在<strong>方法区</strong>中进行分配 ，进行<strong>零初始化</strong>：</p><ul><li>即数字类型初始化为 0 ，boolean 初始化为 false，引用类型初始化为 null 等</li></ul></blockquote></li><li><p><strong>解析</strong>：将常量池内的 <u>符号引用</u> 替换为 <u>直接引用</u> 的过程。</p><blockquote><p><u>符号引用：</u>即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。<br><u>直接引用：</u>可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量。</p><p>🌾 实例： 调用方法hello()，方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。</p></blockquote></li></ul></li><li><p><strong>初始化</strong>。 初始化就是执行类的<code> cinit</code>()的过程。</p><blockquote><p>❔ 和准备阶段那个初始化看得我有点迷糊？</p><ul><li><strong>在编译阶段</strong>，编译器收集所有的<strong>静态字段的赋值语句及静态代码块</strong>，并按 <u>语句出现的顺序</u> 拼接出一个类初始化方法 <code>&lt;clinit&gt;()</code>。此时，执行引擎会调用这个方法对静态字段进行代码中编写的初始化操作。</li></ul></blockquote></li></ol><h4 id="3-知道类的生命周期吗？">3.<strong>知道类的生命周期吗</strong>？</h4><p><strong>在类加载的过程</strong>再加上：</p><ol start="4"><li><strong>使用</strong>。new出对象程序中使用</li><li><strong>卸载</strong>。执行垃圾回收</li></ol><h4 id="4-请你介绍一下类加载器？">4.<strong>请你介绍一下类加载器</strong>？</h4><img src="https://upload-images.jianshu.io/upload_images/7634245-7b7882e1f4ea5d7d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom:50%;" /><p>JVM预定义的三种类型类加载器：</p><ul><li><strong>启动类加载器（BootstrapClassLoader）</strong>：是一般用本地代码实现，负责将 <code>&lt;Java_Runtime_Home&gt;/lib</code>下面的类库加载到内存中；</li><li><strong>标准扩展类加载器（ExtensionClassLoader）</strong>：<code>&lt; Java_Runtime_Home &gt;/lib/ext</code>或者由系统变量 <code>java.ext.dir</code>指定位置中的类库加载到内存中；</li><li><strong>系统类加载器（AppClassLoader）</strong>：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从<u>环境变量或者系统属性<code>java.class.path</code></u>所指定的目录中加载类，是<strong>用户自定义加载器的默认父加载器</strong>。</li></ul><h4 id="5-请你介绍一下双亲委派机制？为什么要这么做？">5.<strong>请你介绍一下双亲委派机制？为什么要这么做</strong>？</h4><ul><li><p><strong>双亲委派机制</strong>。某个特定的类加载器在接到加载类的请求时，首先将加载任务<strong>委托给父类加载器</strong>，<strong>依次递归</strong>，如果父类加载器可以完成类加载任务，就成功返回；<strong>只有父类加载器无法完成此加载任务时，才自己去加载</strong>；</p></li><li><p><strong>为什么要这么做？防止内存中出现多份同样的字节码</strong> 。</p><blockquote><p>比如两个类A和类B都要加载System类：</p><ul><li>如果不用委托：而是自己加载自己的，那么类A就会加载一份System字节码，然后类B又会加载一份System字节码，<strong>这样内存中就出现了两份System字节码</strong>。</li><li>如果使用委托机制：会递归的向父类查找，也就是<strong>首选用Bootstrap尝试加载</strong>，如果找不到再向下。这里的System就能在Bootstrap中找到然后加载，如果此时类B也要加载System，也从Bootstrap开始，此时<strong>Bootstrap发现已经加载过了System那么直接返回内存中的System即可而不需要重新加载</strong>，这样内存中就只有一份System的字节码了。</li></ul></blockquote></li></ul><h5 id="5-1-如何自定义类加载器-，如何打破双亲委派机制-？">5.1 如何自定义类加载器 ，如何打破双亲委派机制 ？</h5><ul><li><p><strong>自定义类加载器 &amp; 打破双亲委派机制</strong></p><p>在实现自己的ClassLoader之前，我们先看一下JDK中的ClassLoader是怎么实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line"> <span class="number">2</span>     <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line"> <span class="number">3</span>     &#123;</span><br><span class="line"> <span class="number">4</span>     <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line"> <span class="number">5</span>     Class c = findLoadedClass(name);</span><br><span class="line"> <span class="number">6</span>     <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">7</span>         <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="number">8</span>         <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">9</span>             c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line"><span class="number">10</span>         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">11</span>             c = findBootstrapClass0(name);</span><br><span class="line"><span class="number">12</span>         &#125;</span><br><span class="line"><span class="number">13</span>         &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="number">14</span>             <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line"><span class="number">15</span>             <span class="comment">// to find the class.</span></span><br><span class="line"><span class="number">16</span>             c = findClass(name);</span><br><span class="line"><span class="number">17</span>         &#125;</span><br><span class="line"><span class="number">18</span>     &#125;</span><br><span class="line"><span class="number">19</span>     <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line"><span class="number">20</span>         resolveClass(c);</span><br><span class="line"><span class="number">21</span>     &#125;</span><br><span class="line"><span class="number">22</span>     <span class="keyword">return</span> c;</span><br><span class="line"><span class="number">23</span>     &#125;</span><br></pre></td></tr></table></figure><p>1、<strong>如果不想打破双亲委派模型，那么只需要重写findClass方法即可</strong></p><p><strong>（1）继承ClassLoader</strong></p><p><strong>（2）重写findClass()方法</strong></p><p>2、<strong>如果想打破双亲委派模型，那么就重写整个loadClass方法</strong></p><p><strong>（1）继承ClassLoader</strong></p><p><strong>（2）重写findClass()方法</strong>6</p><p><strong>（3）调用defineClass()方法</strong></p></li><li><p><strong>tomcat 为什么要违背双亲委托机制</strong>？</p><ol><li>双亲委托机制不能满足tomcat的业务需求；</li><li>Webapp类加载器需要独立加载自身的class以及依赖的jar；</li><li>例如，<strong>webapp1</strong>依赖的spring版本为4.x，另一个<strong>webapp2</strong>依赖的spring版本为5.x. 如果使用双亲委托，那么spring的版本只能存在一个，没法满足这个需求。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（一）_Java_锁</title>
      <link href="/p/45493/"/>
      <url>/p/45493/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h2 id="1-5-锁">1.5 锁</h2><h4 id="【新增】-java常用的并发工具类？">【新增】 java常用的并发工具类？</h4><blockquote><p>这篇不错：<a href="https://zhuanlan.zhihu.com/p/163654320">《今天面试了吗》- 并发编程之AQS同步工具类</a></p></blockquote><p>JUC就是java.util.concurrent包，这个包俗称JUC，里面都是<strong>解决并发问题</strong>。</p><p>常用四大并发工具包（以下都是基于<strong>AQS</strong>实现的）：</p><ol><li><p><strong>CountDownLatch</strong>： CyclicBarrier描述的是“允许一组线程相互等待，直到<strong>到达某个公共屏障点</strong>，才会进行后续任务”。</p><p>而<strong>CountDownLatch</strong>所描述的是“在<strong>完成一组正在其他线程中</strong>执行的操作之前，它允 一个或多个线程一直等待”。</p><p>在API中是这样描述的：用给定的计数初始CountDownLatch。由于调用了countDown方法，所以在当前计数到达零之前，await方法会一直受阻塞。之后，会释放所有等待的线程，await的所有后续调用都将立即返回。这种现象只出现一次（计数无法被重置。如果需要重置计数，请考虑使CyclicBarrier）。</p></li><li><p><strong>CyclicBarrier</strong>：CyclicBarrier是一个同步辅助类。它允许<strong>一组线程互相等待</strong>，<strong>直到到达某个公共屏障点</strong>。在涉及一组固定大小的线程的程序里，这些线程必须不时的互相等待，此时CyclicBarrier 很有用。因为CyclicBarrier在释放等待线程后可以重用，因此成为循环的屏障。</p><blockquote><p>使用**await()**方法，每个线程调用await()方法告诉CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。当所有线程都到达了屏障，结束阻塞，所有线程可继续执行后续逻辑。</p></blockquote></li><li><p><strong>Semaphore</strong>：信号量Semaphore是一个控制访问<strong>多个共享资源的计数器</strong>，和CountDownLatch一样，其本质上是一个“共享锁”。在API是这么介绍信号量的：一个计数信号量，从概念上讲，信号量维护了一个许可集。</p></li><li><p><strong>ExChanger</strong> ：Exchanger是一个同步器，字面上就可以看出这个类的主要作用是交换数据。Exchanger有点<strong>类似CyclicBarrier</strong>，前面说到CyclicBarrier是一个栅栏，到达栅栏的 线程需要等待一定数量的线程到达后，才能通过栅栏。Exchanger可以看成是一个双向的栅栏。线程1到达栅栏后，会首先观察有没有其他线程已经到达栅栏，如果没有就会等待。如果已经有其他线程（比如线程2）到达了，就会<strong>以成对的方式交换各自携带的信息</strong>，因此Exchanger非常适合<strong>两个线程</strong>之间的<strong>数据交换</strong>。</p></li></ol><h4 id="1-5-1-synchronized-相关">1.5.1 synchronized 相关</h4><h5 id="1-1-重点-说一说自己对于-synchronized-关键字的了解-synchronized-底层原理">1.1 [重点]<strong>说一说自己对于 synchronized 关键字的了解? synchronized 底层原理</strong> ?</h5><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/356010805">Java面试常见问题：Monitor对象是什么？</a></p><p><a href="https://www.cnblogs.com/aspirant/p/11470858.html">深入分析Synchronized原理(阿里面试题)</a></p></blockquote><ul><li><p><strong>基本了解</strong></p><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><ul><li>synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是<strong>依赖于底层的操作系统的<u>Mutex Lock</u></strong> 来实现的；</li><li>Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，<strong>而操作系统实现线程之间的切换</strong>时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。</li></ul></li><li><p><strong>moniter介绍</strong></p><blockquote><p><strong>Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用</strong>。</p></blockquote><p>在HotSpot虚拟机中，Monitor是基于C++的<strong>ObjectMonitor类</strong>实现的，其主要成员包括：</p><ul><li>_owner：指向持有ObjectMonitor对象的线程</li><li>_WaitSet：存放处于wait状态的线程队列，即调用wait()方法的线程</li><li>EntryList：存放处于等待锁block状态的线程队列</li><li>_count：约为_WaitSet 和 _EntryList 的节点数之和</li><li>_cxq: 多个线程争抢锁，会先存入这个单向链表</li><li>_recursions: 记录重入次数</li></ul></li><li><p><strong>底层原理</strong></p><p>synchronized 关键字底层原理属于 JVM 层面。</p><p><strong>① synchronized同步语句块的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 JDK ⾃带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：</p><ul><li><p>⾸先切换到类的对应⽬录执行 javac SynchronizedDemo.java 命令⽣成编译后的 .class ⽂件，然后执行 <code>javap -c -s-v -l SynchronizedDemo.class</code></p></li><li><p><img src="https://i.loli.net/2021/05/16/DTSB86Z2GcRy9XC.png" alt="image-20210516130259067"></p></li></ul><p><strong>synchronized</strong>同步语句块的实现使用的是monitorenter和 monitorexit指令，其中<strong>monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置</strong>。</p><ol><li><p>当执行monitorenter 指令时，线程试图获取锁也就是获取 monitor的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1 ;</p><blockquote><p>monitor对象存在于每个Java对象的对象头中 synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因。</p></blockquote></li><li><p>相应的在执行monitorexit 指令后，<strong>将锁计数器设为0</strong>，表明锁被释放；</p></li><li><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外⼀个线程释放为⽌。</p></li></ol></li></ul><p><strong>② synchronized修饰方法的的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/16/oElScfCHI978Qtw.png" alt="image-20210516131938787"></p><ul><li><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是<code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是⼀个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问。</p><blockquote><p>当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。<strong>在方法执行期间，其他任何线程都无法再获得同一个monitor对象</strong>。</p></blockquote><p>两种同步方式<strong>本质上没有区别</strong>，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。两个指令的执行是JVM通过调用操作系统的<strong>互斥原语mutex</strong>来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p></li></ul><h5 id="1-2-请你谈谈关于Synchronized和ReentrantLock？">1.2 <strong>请你谈谈关于Synchronized和ReentrantLock？</strong></h5><ul><li><p><strong>相似点</strong></p><ul><li><p><strong>都是阻塞式同步</strong>：一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待；</p><blockquote><p>线程阻塞和唤醒的代价是比较高的（操作系统需要在用户态与内核态之间来回切换，代价很高，不过可以通过对锁优化进行改善）。</p></blockquote></li><li><p><strong>都是可重入锁</strong>：是同一个线程可重复获得锁，每获得一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p></li></ul></li><li><p><strong>不同点</strong></p><ul><li><p><strong>实现原理</strong>： Synchronized是java语言的关键字，是原生语法层面的互斥， JVM 层面；ReentrantLock是JDK 1.5后的API层面的互斥锁，需要<u>lock()和unlock()方法配合try/finally语句块来完成</u>；</p><blockquote><p><img src="https://i.loli.net/2021/04/28/tSoiYbRl5kdA9my.png" alt="image-20210428222639476"></p></blockquote></li><li><p><strong>是否避免死锁</strong>： synchronized<strong>在发生异常时</strong>，会自动释放线程占有的锁，<strong>因此不会导致死锁现象</strong>发生；Lock不会主动适应 <code>unLock()</code> 释放，必须手动在f<code>inally</code>释放；相⽐synchronized，ReentrantLock增加了⼀些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</p></li><li><p><u><strong>线程等待可中断</strong>：</u> Lock可以让等待锁的线程响应中断，线程可以中断去干别的事务；而synchronized却不行，使用synchronized时，等待的线程会一直等待下去；</p></li><li><p><strong>公平锁</strong>： synchronized的锁是非公平锁，ReentrantLock默认情况下也是非公平锁，但可以通过带布尔值的构造函数要求使用公平锁；</p><ul><li><strong>选择性通知</strong>： synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。<br>Condition是JDK1.5之后才有的，它具有很好的灵活性，⽐如可以实现多路通知功能也就是在⼀个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使⽤notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，⽤ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有⼀个Condition实例，所有的线程都注册在它⼀个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，<u>而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程</u>。</li></ul></li></ul></li></ul><h5 id="1-3-synchronized锁住的是什么，在项目中遇到了吗？">1.3 <strong>synchronized锁住的是什么，在项目中遇到了吗</strong>？</h5><p>synchronized本身并不是锁，锁本身是一个对象，synchronized最多相当于“加锁”操作，所以synchronized并不是锁住代码块。</p><p>（<strong>重点</strong>）Java中的每一个对象都可以作为锁，具体表示有三种形式：</p><p><img src="https://i.loli.net/2021/05/04/LzjeqdIi5rbM819.png" alt="image-20210504232344320"></p><blockquote><p>面试中面试官经常会说：“单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁方式实现单例模式的原理呗！”</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton       <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码</span></span><br><span class="line">       <span class="keyword">if</span> (uniqueInstance WX <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//类对象加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance WX <span class="keyword">null</span>) &#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure><p>这段代码其实是分为三步执行：</p><ol><li><p>为 uniqueInstance 分配内存空间</p></li><li><p>初始化 uniqueInstance</p></li><li><p>将 uniqueInstance 指向分配的内存地址</p></li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致⼀个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回uniqueInstance，<u>但此时 uniqueInstance 还未被初始化</u>。</p><h5 id="1-4-synchronized锁的优化机制了解吗？">1.4 <strong>synchronized锁的优化机制了解吗</strong>？</h5><blockquote><p>参考：<a href="https://juejin.cn/post/6844903726545633287">死磕Synchronized底层实现</a></p><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html">美团技术团队</a></p></blockquote><p>synchronized本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括：</p><ul><li>自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁；</li><li>锁的状态从低到高依次为：<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong>。</li></ul><p><img src="https://i.loli.net/2021/05/16/PjXkchreF9sSEKG.png" alt="image-20210516131559341"></p><p>常见的锁：</p><ul><li><p><strong>无锁</strong>：无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，<strong>但同时只有一个线程能修改成功</strong>。</p><blockquote><p>锁到底存在哪里呢？答案就是对象头中。</p><p>对象头主要又包括了两部分数据：Mark Word（标记字段）、Class Point（类型指针）。</p></blockquote><ol start="0"><li><p>初始mark word 将是可偏向状态，此时的 <u>是否偏向锁</u> 为 0，表示当前没有任何一个线程持有该锁。</p><p><img src="https://i.loli.net/2021/05/21/bNepQwU6scYXCv5.png" alt="image-20210521210754337"></p></li></ol></li><li><p><strong>偏向锁</strong>：在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><blockquote><p>JDK1.6 中为了提高一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能，引入了偏向锁。在<strong>第一次</strong>获得锁时，会有一个 CAS 操作（见下）；<strong>之后</strong>该线程再获取锁，只会执行几个简单的命令，而不是开销相对较大的 CAS 命令。</p></blockquote><ol><li><p><strong>CASE 1 :</strong> 线程<strong>第一次</strong>获得锁，如果<strong>未偏向</strong>，通过 <strong>CAS</strong> 指令：</p><p><img src="https://i.loli.net/2021/05/21/fwEX4OAMFnyWrbJ.png" alt="image-20210521210949942"></p><ul><li><strong>插入线程ID :</strong> 向mark word插入线程ID</li><li><strong>偏向锁标识</strong>：将 mark word 中的偏向锁标识从<code>0→1</code></li><li><s><strong>锁标志位</strong>：不修改！因为不变！</s></li></ul><p>如果操作成功：，则说明获得了偏向锁，以后当前<u>线程等于owner</u>就可以<strong>零成本</strong>的直接获得锁；</p><p>如果操作失败，说明有其它线程获取了锁：</p><ul><li><strong>如果偏向线程还存在</strong>：直接进行升级为轻量级锁；</li><li><strong>如果偏向线程不存在：先修改锁标识为01→00</strong> ，再升级为轻量级锁。</li></ul></li><li><p><strong>CASE 2 :</strong>  这是<strong>一次可重入</strong>，偏向线程是自己。</p><p>在<u>当前线程栈</u>中找到一个可用的 <strong>Lock Record</strong> <strong>：并将其 obj 指向锁对象 &amp; Displaced Mark Word 置为null</strong></p><img src="https://i.loli.net/2021/05/18/LXj2NZi7fVOzpox.png" alt="img" style="zoom:50%;" /></li></ol></li><li><p><strong>轻量级锁</strong>：当发现多线程竞争时，偏向锁会升级为轻量级锁，一般来说，会在 safepoint（此时用户代码不会执行）中去查看<u>偏向的线程是否还存活</u>。</p><p><img src="https://i.loli.net/2021/05/18/anN1S6AD7MI9gK8.jpg" alt="img"></p><ol><li>如果偏向的线程已经不存活或者不在同步块中，则将对象头的 mark word 改为无锁状态（unlocked），<strong>重新偏向新的线程</strong>；</li><li>如果存活且还在<strong>同步块</strong>中，原偏向的线程继续拥有锁，当前线程则走入到轻量级锁的加锁逻辑中；</li></ol><p>轻量级锁的处理流程 ：</p><ol start="3"><li>发现已经有偏向的线程了，则会<strong>先 撤 销偏向锁，然后升级为轻量锁</strong> 。通过<strong>CAS命令更新</strong>：</li></ol><p><img src="https://i.loli.net/2021/06/02/BMyh36f2OPCGkKe.png" alt="image-20210602161303534"></p><ul><li><p><strong>修改此前 <u>当前线程栈帧Lock Record</u>：</strong> （1）Displaced Mark Word 复制 mark word （此时<strong>无锁</strong>状态）中的现有内容</p></li><li><p><strong>修改mark word <strong>：<u>mark word 指向</strong>当前线程栈帧Lock Record的</strong> <strong>Displaced Mark Word</strong>的地址</u>，见上图；</p></li><li><p><strong>修改锁标志位</strong>： <code>01 → 00</code></p><p><img src="https://i.loli.net/2021/05/21/QNDEreAK6Ulohvg.png" alt="image-20210521214141329"></p></li></ul><ol start="4"><li><p>上述CAS更新成功，则<strong>当前线程获得了对象的锁</strong>  ；</p><p>如果不成功：</p><ul><li><p>检查Mark Word是否指向当前线程的栈帧的Lock Record ，是则是一次<strong>可重入</strong></p><blockquote><p>设置<code>Lock Record</code>第一部分（<code>Displaced Mark Word</code>）为null，起到了一个重入计数器的作用。然后结束。</p></blockquote></li><li><p>如果不是则是进行<strong>自旋等待</strong></p></li></ul></li><li><p>当<strong>1.自旋超过一定的次数</strong>（默认10），或者<strong>2.一个线程在持有锁，一个在自旋，又有第三个来访时</strong>，轻量级锁升级为重量级锁。</p></li></ol></li><li><p><strong>重量级锁</strong>：内置锁在Java中被抽象为<strong>监视器锁（monitor）</strong>。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种<strong>同步方式的成本非常高</strong>，<u>包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等</u>。</p><blockquote><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。<strong>每一个Java对象就有一把看不见的锁Monitor</strong>，称为内部锁或者Monitor锁。</p><p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个<strong>Owner</strong>字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p></blockquote><p>如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。<u>线程去获取重量级锁，其实就是就尝试获取对象的monitor锁。</u></p><blockquote><p>即将 monitor锁的 <strong>Owner字段修改为当前线程ID</strong> 。</p></blockquote><p>如果获取成功，此时线程获得了锁，<strong>CAS修改</strong> ：</p><ol start="2"><li><p><strong>修改mark word</strong> ：然后将对象头mark word 改为<strong>指向该 monitor 的指针</strong>。</p></li><li><p><strong>锁标志位</strong>：<code>00 → 10</code></p><p><img src="https://i.loli.net/2021/05/21/NLFv3fKIh14RlzY.png" alt="image-20210521214213205"></p></li></ol></li></ul><h5 id="1-5-为什么说Synchronized是非公平锁，这样的优缺点是什么？">1.5 <strong>为什么说Synchronized是非公平锁，这样的优缺点是什么</strong>？</h5><p>并非是按照申请锁的时间前后给等待线程分配锁的，<strong>每当锁被释放后，任何一个线程都有机会竞争到锁</strong>。</p><ul><li><strong>优点</strong>：这样做的目的是为了提高执行性能；</li><li><strong>缺点</strong>：是可能产生线程饥饿现象。</li></ul><h5 id="1-6-为什么说synchronized是一个悲观锁？乐观锁的实现原理又是什么？">1.6 <strong>为什么说synchronized是一个悲观锁？乐观锁的实现原理又是什么</strong>？</h5><blockquote><p>没看完，了解了下核心问题：<a href="https://www.cnblogs.com/jojop/p/14022029.html">https://www.cnblogs.com/jojop/p/14022029.html</a></p></blockquote><ul><li><p><strong>synchronized悲观锁</strong></p><p>Synchronized显然是一个悲观锁，因为它的并发策略是悲观的：</p><ul><li><strong>不管是否会产生竞争，任何的数据都必须加锁</strong>。</li></ul></li><li><p><strong>synchronized原理</strong></p><p>Synchronized是通过<strong>获取对象内部的一个叫做监视器锁（monitor</strong>）来实现的，每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权。</p><blockquote><p>监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。</p></blockquote><ol><li><p>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</p></li><li><p>如果线程已经占有该monitor，<u>只是重新进入</u>，则进入monitor的进入数加1；</p></li><li><p>如果<u>其他线程已经占用了monitor，则该线程进入阻塞状态</u>，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p></li></ol></li><li><p><strong>乐观锁实现原理：CAS</strong></p><blockquote><p>参考好文：<a href="https://zhuanlan.zhihu.com/p/94762520">一文彻底搞懂CAS实现原理</a></p></blockquote></li></ul><h5 id="1-7-（CAS原理重点）什么是CAS？CAS的缺点？说说CAS源码实现？">1.7 （CAS原理重点）什么是CAS？CAS的缺点？说说CAS源码实现？</h5><p>乐观锁的核心算法是CAS（Compared And Swap，比较并交换）：</p><ul><li><p><strong>关键逻辑</strong>： CAS，有几个重要的参数：</p><p>（1）<strong>this</strong>，Unsafe 对象本身，需要通过这个类来获取 value 的内存偏移地址。</p><p>（2）<strong>valueOffset</strong>，value 变量的内存偏移地址。</p><p>（3）<strong>expect</strong>，期望更新的值。</p><p>（4）<strong>update</strong>，要更新的最新值。</p><p>如果原子变量中的 <strong>value 值等于 expect</strong>，则使用 update 值更新该值并返回 true，否则返回 false。</p></li><li><p><strong>CAS特性</strong>： CAS具有原子性，它的原子性由CPU硬件指令实现保证。</p><ul><li>【<strong>缺点1</strong>】<strong>ABA问题</strong>：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。<ul><li><strong>解决ABA：</strong> 在变量前面加上版本号，每次变量更新的时候变量的<strong>版本号都<code>+1</code></strong>，即<code>A-&gt;B-&gt;A</code>就变成了<code>1A-&gt;2B-&gt;3A</code></li></ul></li><li>【<strong>缺点2】只能保证一个共享变量的原子操作</strong>：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</li><li>【<strong>缺点3</strong>】<strong>循环时间长开销大</strong>：对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li></ul></li><li><p><strong>CAS源码分析</strong></p><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000014858404?utm_source=sf-similar-article">Java CAS 原理分析</a></p></blockquote><blockquote><p>CAS 全称是 compare and swap，是一种用于在<strong>多线程环境下实现同步</strong>功能的机制。</p></blockquote><p>CAS 操作包含三个操作数 – 内存位置、预期数值和新值。CAS 的实现逻辑是将内存位置处的数值与预期数值想比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。</p><p>Java 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的，下面是具体分析。</p><ul><li><p><strong>背景介绍</strong></p><p>在多核心时代下，<strong>多个核心通过同一条总线和内存以及其他硬件进行通信</strong>。</p><p><img src="https://segmentfault.com/img/remote/1460000014858409?w=1598&amp;h=710" alt="img"></p><p><strong>CPU 的多个核心同时对同一片内存进行操作</strong>，会导致错误。例如，递增指令<code>inc dword ptr [...]</code>，等价于<code>DEST = DEST + 1</code>。该指令包含三个操作<code>读-&gt;改-&gt;写</code>，涉及两次访存。</p><ol><li>核心1,2从内存读取数据<code>1</code>，并写到各自寄存器中</li><li>核心1将寄存器中数据<code>1→2</code></li><li>核心2将寄存器中数据<code>1→2</code></li><li>然后都写回主存，此时为<code>2</code></li></ol><p>可以看到，由于核心2在核心1<strong>写入主存操作完成前进行读取</strong>，导致并不是我们期望的<code>3</code> 。</p><p>通过在递增<code>inc</code> 指令前添加 lock 前缀，可以让核心独占某个内存区域，由此可以避免上面问题。lock 前缀保证核心独占某片内存区域，有两种方式：</p><ol><li><strong>总线锁</strong>。总线被锁定后，其他核心就不能访问内存了，可能会导致其他核心短时内停止工作；</li><li><strong>缓存锁</strong>。若<strong>某处</strong>内存数据被缓存在处理器缓存中，处理器发出的 LOCK# 信号不会锁定总线，而是<strong>锁定缓存对应的内存区域</strong>。其他处理器在这片内存区域锁定期间，无法对这片内存区域进行相关操作。（<strong>不是乐观机制都可以操作吗？不能写入内存</strong>？）</li></ol></li><li><p><strong>源码分析</strong></p><blockquote><p>我们分析，<code>java.util.concurrent.atomic</code> 包下的原子类 <code>AtomicInteger</code> 中的 <code>compareAndSet</code> 方法 。</p></blockquote><ol><li><p>AtomicInteger具体实现中，compareAndSet 实际上只是一个壳子，主要的逻辑封装在 Unsafe 的 compareAndSwapInt 方法中；</p></li><li><p>compareAndSwapInt是一个native方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,<span class="keyword">int</span> expected,<span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 计算变量 value 在类对象中的偏移</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * compareAndSet 实际上只是一个壳子，主要的逻辑封装在 Unsafe的compareAndSwapInt 方法中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    <span class="comment">// compareAndSwapInt 是 native 类型的方法，继续往下看</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们进入unsafe.cpp（compareAndSwapInt是native方法）具体实现中，看看调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unsafe.cpp</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个看起来好像不像一个函数，不过不用担心，不是重点。UNSAFE_ENTRY 和 UNSAFE_END 都是宏，</span></span><br><span class="line"><span class="comment"> * 在预编译期间会被替换成真正的代码。下面的 jboolean、jlong 和 jint 等是一些类型定义（typedef）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);</span><br><span class="line">  <span class="comment">// 根据偏移量，计算 value 的地址。这里的 offset 就是 AtomaicInteger 中的 valueOffset</span></span><br><span class="line">  jint* addr = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>(p, offset);</span><br><span class="line">  <span class="comment">// 调用 Atomic 中的函数 cmpxchg，该函数声明于 Atomic.hpp 中</span></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::<span class="built_in">cmpxchg</span>(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br><span class="line"></span><br><span class="line"><span class="comment">// atomic.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">Atomic::cmpxchg</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> exchange_value, <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>* dest, <span class="keyword">unsigned</span> <span class="keyword">int</span> compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) == <span class="built_in"><span class="keyword">sizeof</span></span>(jint), <span class="string">&quot;more work to do&quot;</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载</span></span><br><span class="line"><span class="comment">   * 接下来分析 atomic_windows_x86.inline.hpp 中的 cmpxchg 函数实现</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)Atomic::<span class="built_in">cmpxchg</span>((jint)exchange_value, (<span class="keyword">volatile</span> jint*)dest,</span><br><span class="line">                                       (jint)compare_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析 Windows 平台下的 Atomic::cmpxchg 函数为例，看看具体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// atomic_windows_x86.inline.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) __asm cmp mp, 0  \</span></span><br><span class="line"><span class="meta">                       __asm je L0      \</span></span><br><span class="line"><span class="meta">                       __asm _emit 0xF0 \</span></span><br><span class="line"><span class="meta">                       __asm L0:</span></span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">inline</span> jint <span class="title">Atomic::cmpxchg</span> <span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否是多核 CPU</span></span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    <span class="comment">// 将参数值放入寄存器中</span></span><br><span class="line">    mov edx, dest  <span class="comment">// 注意: dest 是指针类型，这里是把内存地址存入 edx 寄存器中</span></span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, <span class="function">compare_value</span></span><br><span class="line"><span class="function">    <span class="title">LOCK_IF_MP</span><span class="params">(mp)</span>  <span class="comment">// 核心比较写入操作</span></span></span><br><span class="line"><span class="function">    cmpxchg dword ptr [edx], ecx</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>其中LOCK_IF_MP实际内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// LOCK_IF_MP</span></span><br><span class="line">    cmp mp, <span class="number">0</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 mp = 0，表明是线程运行在单核 CPU 环境下。此时 je 会跳转到 L0 标记处，</span></span><br><span class="line"><span class="comment">     * 也就是越过 _emit 0xF0 指令，直接执行 cmpxchg 指令。也就是不在下面的 cmpxchg 指令前加 lock 前缀。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    je L0</span><br><span class="line">     <span class="comment">/* 0xF0 是 lock 前缀的机器码，这里没有使用 lock，而是直接使用了机器码的形式。*/</span></span><br><span class="line">    _emit <span class="number">0xF0</span></span><br><span class="line">L0:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 比较并交换。简单解释一下下面这条指令，熟悉汇编的朋友可以略过下面的解释:</span></span><br><span class="line"><span class="comment">     *   cmpxchg: 即“比较并交换”指令</span></span><br><span class="line"><span class="comment">     *   dword: 全称是 double word，在 x86/x64 体系中，一个</span></span><br><span class="line"><span class="comment">     *          word = 2 byte，dword = 4 byte = 32 bit</span></span><br><span class="line"><span class="comment">     *   ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元</span></span><br><span class="line"><span class="comment">     *   [edx]: [...] 表示一个内存单元，edx 是寄存器，dest 指针值存放在 edx 中。</span></span><br><span class="line"><span class="comment">     *          那么 [edx] 表示内存地址为 dest 的内存单元</span></span><br><span class="line"><span class="comment">     *        </span></span><br><span class="line"><span class="comment">     * 这一条指令的意思就是，将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值</span></span><br><span class="line"><span class="comment">     * 进行对比，如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实际举例说明</strong></p><p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile</strong> 来保证原子操作。AtomicInteger 的主要方法都是通过调用Unsafe类方法去实现，如 compareAndSet 实际是调用AtomicInteger 的compareAndSwapInt方法。</p><blockquote><p>下面以 getAndIncrement实现来说明。</p></blockquote><ol><li><p>getAndIncrement调用了 Unsafe的getAndAddInt方法，传递了（1）当前this对象，（2）value偏移量，用来计算得到value值（3）要加上的值，由于是递增所以是1</p><blockquote><p>⚠️ <strong>为什么不传value的值，而是偏移量</strong>？ 传偏移量是为了计算value所在的内存地址，进而获取最新的value值。</p></blockquote></li><li><p>getAndAddInt采用CAS方式进行更新，还需要进行当前期望值的计算</p><ul><li>通过<code>getIntVolatile</code>获取到<strong>线程此时内存value值</strong>（期望值），也就是记录<strong>执行CAS前</strong>的内存最新value值；</li></ul></li><li><p>然后开始执行Unsafe的 <code>compareAndSwapInt</code> ，主要是通过<code>Atomic::cmpxchg</code> 逻辑来实现</p><p>（1）将要dest（value内存地址），compareValue（期望值），exchange_value（要更新的值）写入寄存器中</p><p>（2）线程如果是运行多核CPU，上<strong>LOCK#锁，将dest内存区域锁住</strong> ；否则不上LOCK#锁</p><p>（3）执行cmpxchg（比较并交换命令），如果dest的value值（<strong>执行CAS中</strong>的最新value值） == compareValue，则写入exchange_value ；</p><p>（4）否则写入失败，通过不断自旋（循环）期望得到执行</p></li></ol></li></ul></li></ul><h5 id="1-8-请说明一下synchronized的-u-可重入-u-怎么实现？">1.8 <strong>请说明一下synchronized的<u>可重入</u>怎么实现</strong>？</h5><p>每个锁关联一个线程持有者对象和一个计数器。</p><ol><li>当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁（即monitor对象）而调用相应方法。</li><li>当一个线程请求成功后，JVM对象头会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。</li><li>而该持有锁的线程如果<strong>再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增</strong>。</li><li>当线程退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁。</li></ol><h5 id="1-9-在synchronized偏向锁过程中，调用hashcode方法，markword会发生什么？">1.9 在synchronized偏向锁过程中，调用hashcode方法，markword会发生什么？</h5><p>第一次调用Hashcode：当<u>对象的hashCode()方法</u>（非用户自定义）第一次被调用时，JVM会生成对应的<strong>identity hash code</strong>值，并将该值<u>存储到Mark Word</u>中 。</p><blockquote><p>后续如果该对象的hashCode()方法再次被调用则不会再通过JVM进行计算得到，<strong>而是直接从Mark Word中获取，保证唯一相同</strong>。</p></blockquote><ul><li><strong>无锁状态</strong>：在无锁状态下，Mark Word中可以存储对象的identity hash code值 ；</li><li><strong>偏向锁状态</strong>：需要计算其identity hash code的话，则它的偏向锁会被撤销（因为没有保存的位置），并且锁会膨胀为轻量级锁或者重量锁 ；</li><li><strong>轻量锁状态</strong>：<u>线程栈帧</u>的Lock Recode可以记录存储Displaced Mark Word ，所以轻量级锁可以和identity hash code <strong>共存</strong> ；</li><li><strong>重量级锁状态</strong>：<u>ObjectMonitor</u>类里有字段HashCode<strong>可以记录</strong>非加锁状态<strong>下的mark word，所以重量级锁也可以和identity hash code共存</strong>；</li></ul><h5 id="1-10-Synchronized-确定不可中断吗？如果一个线程访问Synchronized-代码，其它线程可以能否中断？比如使用Stop？是在中断前还是中断后获取锁？">1.10 Synchronized 确定不可中断吗？如果一个线程访问Synchronized 代码，其它线程可以能否中断？比如使用Stop？是在中断前还是中断后获取锁？</h5><blockquote><p>参考：<a href="https://blog.csdn.net/deel_feel/article/details/105771902">https://blog.csdn.net/deel_feel/article/details/105771902</a></p></blockquote><p>正确说法时：<strong>只有获取到锁之后才能中断，等待锁时不可中断</strong>。</p><h4 id="1-5-2-Reetrantlock-相关">1.5.2 Reetrantlock 相关</h4><p>ReentrantLock意思为可重入锁 。</p><h5 id="2-1-非公平锁和公平锁在reetrantlock里的实现过程是怎样的？">2.1 <strong>非公平锁和公平锁在reetrantlock里的实现过程是怎样的</strong>？</h5><blockquote><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html">美团技术文章-java-lock</a></p></blockquote><ul><li><p>公平锁：那么锁的 <u>获取顺序</u> 就应该符合请求的 <u>绝对时间顺序</u>，FIFO</p></li><li><p>非公平锁：只要<strong>CAS</strong>设置同步状态成功state，则表示当前线程获取了锁</p><blockquote><p>但公平锁还需要判断当前节点是否有前驱节点，如果有，则表示有线程比当前线程更早请求获取锁，因此需要等待。</p></blockquote></li></ul><p>【<strong>源码分析</strong>】</p><ul><li><p><strong>基本结构</strong></p><p>根据代码可知，ReentrantLock里面有一个内部类<strong>Sync</strong>，Sync继承AQS，添加锁和释放锁的大部分操作实际上都是在Sync中实现的。</p><ul><li>Sync有公平锁FairSync和非公平锁NonfairSync两个子类；</li><li>ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</li></ul><p><img src="https://i.loli.net/2021/05/21/YDAreyBEImxQfj2.png" alt="img"></p></li><li><p><strong>公平和非公平锁区分</strong></p><p><img src="https://i.loli.net/2021/05/21/zsPnT7qrXN5ovKZ.png" alt="img"></p><p>公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在<strong>CAS获取同步状态时</strong>，多了一个限制条件：<strong>hasQueuedPredecessors()</strong>。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/bd0036bb.png" alt="img"></p><ul><li><strong>该方法主要做一件事情</strong>：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</li></ul></li></ul><h5 id="2-2-ReentrantLock的实现原理？">2.2 ReentrantLock的实现原理？</h5><p>ReentrantLock的实现基于队列同步（AbstractQueuedSynchronizer，后面简称AQS）。关于AQS的实现原理见下。</p><p>ReentrantLock的核心，是通过修改AQS中state的值来同步锁的状态。</p><h5 id="2-3-希望等待一段时间锁没有获取，可以自动放弃用哪种锁？">2.3 希望等待一段时间锁没有获取，可以自动放弃用哪种锁？</h5><p>Lock（ReentranLock）</p><p>但是基于AQS的源码哪里体现了？ 应该Lock锁的代码里自己的实现吧。</p><h4 id="1-5-3-AQS-相关">1.5.3 AQS 相关</h4><h5 id="3-1-什么是AQS请你简单介绍一下？">3.1 什么是AQS请你简单介绍一下？</h5><p>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。</p><p><img src="https://i.loli.net/2021/05/16/QhJg8pnTv3zWj4w.png" alt="image-20210516144436982"></p><p><strong>AQS是⼀个用来构建锁和同步器的框架</strong>，使⽤AQS能简单且高效地构造出应用⼴泛的大量的同步器。</p><ul><li>例如：ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue等等皆是基于AQS的。当然，我们⾃⼰也能利⽤AQS非常轻松容易地构造出符合我们⾃⼰需求的同步器。</li></ul><h5 id="3-2-请介绍一下AQS原理？">3.2 请介绍一下AQS原理？</h5><blockquote><p>后续建议研读：<a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用</a></p></blockquote><p>先带着问题来进行看下面内容：</p><blockquote><p>Q：某个线程获取锁失败的后续流程是什么呢？</p><p>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p><p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p><p>A：是CLH变体的FIFO双端队列。</p><p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p><p>A：可以详细看下2.3.1.3小节。</p><p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</p><p>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。</p><p>Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p><p>A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。</p></blockquote><ul><li><p><strong>核心原理概览</strong></p><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。</p><p>如果被请求的共享资源被占用，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，<u>这个机制AQS是⽤CLH队列锁实现的</u>，即将暂时获取不到锁的线程加⼊到队列中。</p><blockquote><p>CLH(Craig,Landin,and Hagersten)队列是⼀个<strong>虚拟的双向队列</strong>（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成⼀个CLH锁队列的⼀个结点（Node）来实现锁的分配。</p></blockquote><p><img src="https://i.loli.net/2021/05/16/XqshLCnMYKbB7Ip.png" alt="image-20210516145134124"></p><p>AQS使用⼀个int成员变量<code>state</code>来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队⼯作。<strong>AQS使⽤CAS对该同步状态进行原子操作实现对其值的修改</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state; <span class="comment">//共享变量，使⽤volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure><p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作 。</p><img src="https://i.loli.net/2021/05/28/g7GORpXKhuo8aS4.png" alt="image-20210526122910138" style="zoom:67%;" /></li><li><p><strong>AQS 对资源的共享方式</strong><br>AQS定义两种资源共享方式，可以通过修改state字段来实现多线程的独占（经典如ReentranLock）和共享模式。</p><p><img src="https://i.loli.net/2021/05/26/YdcSGMs5jgiFnmk.png" alt="img"></p><ul><li><strong>Exclusive（独占）</strong>：只有⼀个线程能执行，如ReentrantLock。⼜可分为公平锁和非公平锁：<ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><strong>Share（共享）</strong>：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li></ul></li><li><p><strong>AQS详细原理</strong></p><blockquote><p>最终参考：<a href="https://zhuanlan.zhihu.com/p/90851418">从源码角度彻底理解ReentrantLock(重入锁)</a></p></blockquote><blockquote><p>以下是基于ReentractLock语境下进行分析。</p></blockquote><ul><li><p><strong>加锁过程：非公平锁</strong></p><blockquote><p>简单来说：<strong>新建线程→CAS尝试快速获取锁→tryAcquire()CAS修改state→addWaiter() 获取失败CAS尝试插入队尾入队→acquireQueued等待前驱线程唤醒继续CAS获取锁</strong></p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-28c16752466cd95dfe0504f0306d6352_720w.jpg" alt="img"></p><p>加锁流程从<code>lock.lock()</code>开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入该源码,正确找到sycn的实现类后可以看到真正有内容的入口方法：</p></li></ul><ol><li><strong>CAS尝试快速加锁</strong>，在ReentranLock只有state=0，才能更新成功（因为是非多线程共享资源）</li><li>获取锁失败执行acquire方法</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 加锁流程真正意义上的入口</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//以cas方式尝试将AQS中的state从0更新为1</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">          setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//获取锁成功则将当前线程标记为持有锁的线程,然后直接返回</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          acquire(<span class="number">1</span>);<span class="comment">//获取锁失败则执行该方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquire</code> 在主要的逻辑都在if判断条件中,这里面有3个重要的方法tryAcquire()，addWaiter() 和 acquireQueued() 。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">          selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>acquire流程1：tryAcquire()</strong></p><p>tryAcquire()在公平和非公平下获取的方式不一样，这里<strong>只说非公平</strong>实现。</p><ol><li><p>如果<strong>state==0（未被其它线程持有）</strong>，<strong>CAS</strong>尝试获取锁,</p></li><li><p>如果当前线程==持有锁的线程，<strong>可重入</strong> ，<strong>state+1</strong></p><ol start="3"><li><p>否则 reture false获取锁失败，加入等待队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Thread current = Thread.currentThread();<span class="comment">//获取当前线程实例</span></span><br><span class="line">     <span class="keyword">int</span> c = getState();<span class="comment">//获取state变量的值,即当前锁被重入的次数</span></span><br><span class="line">     <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;   <span class="comment">//state为0,说明当前锁未被任何线程持有</span></span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//以cas方式获取锁</span></span><br><span class="line">             setExclusiveOwnerThread(current);  <span class="comment">//将当前线程标记为持有锁的线程</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//获取锁成功,非重入</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">//当前线程就是持有锁的线程,说明该锁被重入了</span></span><br><span class="line">         <span class="keyword">int</span> nextc = c + acquires;<span class="comment">//计算state变量要更新的值</span></span><br><span class="line">         <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">         setState(nextc);<span class="comment">//非同步方式更新state值</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//获取锁成功,重入</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;     <span class="comment">//走到这里说明尝试获取锁失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p><strong>acquire流程2：addWaiter()</strong></p><p>主要逻辑如下：</p><ol><li>首先通过new Node()创建一个空结点；</li><li>如果队列不空**，以<strong>CAS</strong>方式让新节点插入到队尾;</li><li>如果队列为空，执行<code>enq(node)</code> 逻辑</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">       Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);<span class="comment">//首先创建一个新节点,并将当前线程实例封装在内部,mode这里为null</span></span><br><span class="line">       <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">       Node pred = tail;</span><br><span class="line">       <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">           node.prev = pred;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">               pred.next = node;</span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       enq(node);<span class="comment">//入队的逻辑这里都有</span></span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               Node t = tail;<span class="comment">//t指向当前队列的最后一个节点,队列为空则为null</span></span><br><span class="line">               <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize  //队列为空</span></span><br><span class="line">                   <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">//构造新结点,CAS方式设置为队列首元素,当head==null时更新成功</span></span><br><span class="line">                       tail = head;<span class="comment">//尾指针指向首结点</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;  <span class="comment">//队列不为空</span></span><br><span class="line">                   node.prev = t;</span><br><span class="line">                   <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">//CAS将尾指针指向当前结点,当t(原来的尾指针)==tail(当前真实的尾指针)时执行成功</span></span><br><span class="line">                       t.next = node;    <span class="comment">//原尾结点的next指针指向当前结点</span></span><br><span class="line">                       <span class="keyword">return</span> t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>acquire流程3：acquireQueued()</strong></p><blockquote><p><strong>线程加入同步队列后，获取锁的流程是什么呢</strong>？</p><p>简单来说，就是不断判断当前是否是老二，并尝试去获取锁。</p></blockquote><img src="https://pic4.zhimg.com/v2-f83b087a039a8de3f9815d9018e2273f_b.jpg" alt="img" style="zoom:80%;" /><ul><li><code>SIGNAL ：</code>意味着线程释放锁后会唤醒后面阻塞的线程。毕竟，只有确保能够被唤醒，当前线程才能放心的阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//死循环,正常情况下线程只有获得锁才能跳出循环</span></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//获得当前线程所在结点的前驱结点</span></span><br><span class="line">              <span class="comment">//第一个if分句</span></span><br><span class="line">              <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; </span><br><span class="line">                  setHead(node); <span class="comment">//将当前结点设置为队列头结点</span></span><br><span class="line">                  p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                  failed = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> interrupted;<span class="comment">//正常情况下死循环唯一的出口</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//第二个if分句</span></span><br><span class="line">              <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  <span class="comment">//判断是否要阻塞当前线程</span></span><br><span class="line">                  parkAndCheckInterrupt())      <span class="comment">//阻塞当前线程</span></span><br><span class="line">                  interrupted = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p><strong>解锁：非公平锁</strong></p><img src="https://i.loli.net/2021/05/26/sSQZlA2paTcNKXi.png" alt="image-20210526170709280" style="zoom:67%;" /></li><li><p><strong>加锁：公平锁</strong></p><blockquote><p>简单来说：<strong>新来线程→【必须】先CAS加入等待队列→等待前驱节点释放锁（state=0），如果是老二则获取锁</strong>。</p></blockquote><p>公平锁加锁入口加锁从：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finally void lock() &#123;</span><br><span class="line">    acqiuire();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前非公平锁的逻辑中，线程有三次机会获取锁：</p><ol><li><strong>新创建时</strong>，CAS尝试修改state=1，去获取</li><li><strong>可重入</strong>，当前获取锁线程为自己</li><li><strong>前驱节点释放锁</strong>，自己作为老二被唤醒</li></ol><p>而<strong>公平锁</strong>，只能按加入队列的<u>先后次序 &amp; 可重入</u>获得锁 ：</p><ol><li><p>所有线程在获取锁前<strong>必须先加入同步队列</strong></p></li><li><p>如果state=0，<code>hasQueuedPredecessors</code>判断当前是头节点，则获取锁</p></li></ol><p><img src="https://i.loli.net/2021/05/26/wZSLYOP4bTGEqRJ.jpg" alt="img"></p></li></ul></li></ul><h5 id="3-3-为什么基于FIFO的同步队列可以实现非公平锁？">3.3 为什么基于FIFO的同步队列可以实现非公平锁？</h5><p>因为非公平锁，除了等<strong>前驱节点唤醒去获取锁</strong> ，还有以下三种方式获取锁：</p><ol><li><p><strong>新创建时</strong>，CAS尝试修改state=1，去获取</p><blockquote><p>公平锁：进来先执行<code>hasQueuedPredecessors()</code> , 看等待队列是否有有效节点，有的话不能获取锁！</p></blockquote></li><li><p><strong>可重入</strong>，当前获取锁线程为自己</p><blockquote><p>公平锁：也可以</p></blockquote></li><li><p><strong>同步队列等待</strong>，等待唤醒获取锁</p><blockquote><p>公平锁：也可以</p></blockquote></li></ol><p>并且在锁释放时：是<strong>先释放锁（修改state=-1），再去唤醒后继节点</strong></p><ol><li>会导致新来的线程，可能在<strong>后继节点被唤醒前</strong>就获取了锁，这就不会公平</li></ol><h5 id="3-4-【易忘】为什么非公平锁性能好？">3.4 【易忘】为什么非公平锁性能好？</h5><ol><li>.线程不必加入等待队列就可以获得锁,不仅<strong>免去了构造结点并加入队列的繁琐操作</strong> ，<strong>节省了线程阻塞、唤醒</strong>的开销（这涉及到上下文的切换）；</li><li><strong>减少CAS竞争</strong>。如果<strong>线程必须要加入阻塞队列才能获取锁</strong>,那<strong>0</strong>将变得异常激烈,CAS操作虽然不会导致失败线程挂起,但不断失败重试导致的对CPU的浪费也不能忽视</li></ol><h5 id="3-4-AQS-有哪些组件，请简单介绍一下？介绍一下CountDownLatch的应用场景-？">3.4 AQS 有哪些组件，请简单介绍一下？介绍一下CountDownLatch的应用场景 ？</h5><p><img src="https://i.loli.net/2021/05/26/OWhD4Hu3GkBP2vc.png" alt="image-20210526215800096"></p><ul><li><p><strong>Semaphore(信号量)：<strong>Semaphore(信号量)可以指定</strong>多个</strong>线程<strong>同时</strong>访问某个资源； <strong>synchronized 和 ReentrantLock</strong> 都是⼀次只允许<strong>⼀个</strong>线程访问<strong>同时</strong>某个资源。</p><blockquote><p>计数信号量具备两种操作动作，称为V（signal()）与P（wait()）（即部分参考书常称的“PV操作”）。V操作会增加信号标S的数值，P操作会减少它。</p><p>运行P（wait()），信号标S的值将被减少。企图进入临界区段的进程，需要先运行P（wait()）。当信号标<strong>S减为负值</strong>时，进程会被挡住，不能继续；当<strong>信号标S不为负值</strong>时，进程可以获准进入临界区段。</p></blockquote></li><li><p><strong>CountDownLatch （倒计时器）</strong>： CountDownLatch是⼀个同步⼯具类，用来协调多个线程之间的同步。这个⼯具通常用来控制线程等待，<u>它可以让<strong>某⼀个线程等待直到倒计时结束</strong></u>，再开始执行。</p></li><li><p><strong>CyclicBarrier(循环栅栏)</strong>： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能⽐ CountDownLatch 更加复杂和强大。主要应用场景和CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让⼀组线程到达⼀个屏障（也可以叫同步点）时被阻塞，直到最后⼀个线程到达屏障时，屏障才会开⻔，所有被屏障拦截的线程才会继续⼲活。</p><blockquote><p>CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调⽤**await()**方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</p></blockquote></li></ul><p><strong>CountDownLatch的应用场景</strong></p><p>我们要读取处理<strong>6</strong>个⽂件，这6个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这6个⽂件的处理的结果进行统计整理。</p><p>为此我们定义了⼀个线程池和<strong>count为6的 CountDownLatch 对象</strong> 。使用线程池处理读取任务，每⼀个线程处理完之后就将count-1，调用 CountDownLatch 对象的 await() 方法，直到所有⽂件读取完之后，才会接着执行后面的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理⽂件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">6</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建⼀个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">     ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">     <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span></span><br><span class="line">CountDownLatch(threadCount);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> threadnum = i;</span><br><span class="line">         threadPool.execute(() → &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//处理⽂件的业务操作</span></span><br><span class="line">                ......</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//表示⼀个⽂件已经被完成</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       countDownLatch.await();</span><br><span class="line">       threadPool.shutdown();</span><br><span class="line">       System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-4-Volatile-关键字">1.5.4 Volatile 关键字</h4><h5 id="4-0-JMM-是什么-？-缓存一致性协议MESI-CPU内存屏障？JAVA内存屏障？">4.0 JMM 是什么 ？ 缓存一致性协议MESI ? CPU内存屏障？JAVA内存屏障？</h5><blockquote><p>参考：<a href="https://www.jianshu.com/p/06717ac8312c">并发编程-（4）-JMM基础（总线锁、缓存锁、MESI缓存一致性协议、CPU 层面的内存屏障）</a></p></blockquote><ul><li><p><strong>JMM定义</strong></p><p>全称Java Memory Model（java内存模型）是一系列的Java虚拟机平台对开发者提供的多线程环境下的内存可见性、是否可以重排序等问题的无关具体平台的统一的保证。</p></li><li><p><strong>MESI 缓存一致性协议协议</strong></p><ul><li><p><strong>缓存不一致问题</strong></p><p>CPU处理速度，远大于I/O设备（磁盘），为了解决了处理器与内存的速度矛盾，引入了<strong>高速缓存</strong>。但是由此也带来了缓存不一致的问题。</p><ul><li><strong>每个线程都会缓存内存的数据在各自寄存器中</strong>，在<strong>不同 CPU 中运行的不同线程看到同一份内存的缓存值不一样</strong>就会存在缓存不一致的问题。</li></ul></li><li><p><strong>MESI协议内容</strong></p><p>为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，<strong>最常见的就是 MESI 协议</strong>：<br>MESI 表示缓存行的四种状态，分别是：</p><blockquote><p>在 MESI 协议中，每个缓存的缓存控制器不仅知道自己的 读写操作，而且<strong>也监听(snoop)其它 Cache 的读写操作</strong>。</p></blockquote><ul><li><strong>M(Modify)</strong> 表示共享<strong>数据</strong>只缓存在<strong>当前 CPU 缓存</strong>中， 并且是被修改状态，也就是缓存的数据和主内存中的<strong>数据不一致</strong>。</li><li><strong>E(Exclusive)</strong> 表示缓存的独占状态，<strong>数据</strong>只缓存在<strong>当前 CPU 缓存</strong>中，并且<strong>没有被修改</strong>。</li><li><strong>S(Shared)</strong> 表示<strong>数据</strong>可能被<strong>多个 CPU 缓存</strong>，并且各个缓存中的<strong>数据和主内存数据一致</strong>。</li><li><strong>I(Invalid)</strong> 表示缓存已经<strong>失效</strong>。</li></ul><p>对于 MESI 协议，从 CPU 读写角度来说会遵循以下原则：</p><p><img src="https://i.loli.net/2021/06/11/YbfKoySNDMX5swn.png" alt="image-20210611200929872"></p><ul><li><strong>CPU 读请求</strong>：缓存处于 M、E、S 状态都可以被读取，I 状 态 CPU 只能从主存中读取数据；</li><li><strong>CPU 写请求</strong>：缓存处于 M、E 状态才可以被写。对于 S 状 态的写，需要将<strong>其他 CPU 中缓存行置为无效</strong>才可写。</li></ul></li><li><p><strong>Store Bufferes（存储缓存）</strong></p><blockquote><p>CPU 缓存行的状态是通过消息传递来进行的，如果 CPU0 要对一个在缓存中<strong>共享的变量</strong>进行<strong>写入</strong>，首先发送一个失效的消息给到其他缓存了该数据的 CPU。并且要<strong>等到他们的确认回执</strong>。CPU0 在这段时间内都会处于<strong>阻塞状态</strong>。</p></blockquote><p>为了避免阻塞带来的资源浪费。在 cpu 中引入 了 Store Bufferes（存储缓存） 和 Invalidate Queue（无效队列）。</p><ul><li>CPU0 写入共享数据时，<strong>直接把数据写入到 store bufferes 中，同时发送 invalidate 消息，然后继续去处理其他指令</strong>；</li><li>收到其他所有 CPU 发送了 invalidate ACK消息时，<strong>再将 store bufferes 中的数据数据存储至 cache 中</strong>；</li><li>最后再从<strong>本地Cache同步到主内存</strong>。</li></ul></li><li><p><strong>CPU层面内存屏障</strong></p><blockquote><p>内存屏障就是<strong>将 Store Bufferes 中的指令写入到内存</strong>，从而使得其他访问同一共享内存的线程的可见性。</p></blockquote><p>硬件层的内存屏障分为两种：<strong>Load Barrier （读屏障</strong>）和 <strong>Store Barrier（写屏障）及 Full Barrier（全屏障</strong>）是读屏障和写屏障的合集。</p><ul><li><strong>写屏障</strong>：强制<strong>把写缓冲区/高速缓存</strong>中的脏数据等<strong>写回主内存</strong></li><li><strong>读屏障</strong>：将缓冲区/高速缓存中相应的<strong>数据失效</strong>。</li></ul></li><li><p><strong>JAVA 内存屏障</strong></p><p>java的内存屏障通常所谓的四种，<strong>LoadLoad（LL）, StoreStore（SS）, LoadStore（LS）, StoreLoad（SL</strong>)实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</p><ul><li><strong>LoadLoad（LL）屏障</strong>：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li><strong>StoreStore（SS）屏障</strong>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li><strong>LoadStore（LS）屏障</strong>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li><strong>StoreLoad（SL）屏障</strong>：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li></ul></li></ul></li></ul><h5 id="4-1-什么是HappenBefore原则？">4.1 什么是HappenBefore原则？</h5><p>在 JMM 中，<strong>如果一个操作执行的结果需要对另一个操作【可见】，那么这两个操作必须要存在 happens-before 关系</strong>。这两个操作可以是同一个线程，也可以是不同的线程。</p><p><strong>它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</strong> 。</p><ul><li><p><strong>HappenBefore原则</strong></p><ul><li><p><strong>as-if-serial 规则（程序顺序执行）</strong>：单个线程中的代码顺序不管怎么重排序，对于结果来说是不变的。</p></li><li><p><strong>volatile 变量规则</strong>，对于 volatile 修饰的变量的<strong>写操作</strong>， 一定 happen-before 后续对于 volatile 变量的<strong>读操作</strong>;</p></li><li><p><strong>监视器锁规则（monitor lock rule）</strong>：对一个监视器的解锁，happens-before于随后对这个监视器的加锁。</p></li><li><p><strong>传递性规则</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</p></li><li><p><strong>start 规则</strong>：如果线程 A 执行操作 ThreadB.start(),那么线程 A 的 ThreadB.start()操作 happens-before 线程 B 中的任意操作。</p></li><li><p><strong>join 规则</strong>：如果线程 A 执行操作 ThreadB.join()并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join()操作成功返回。</p></li></ul></li><li><p><strong>举例说明：什么是指令重排序</strong>？</p><p>请看下面代码：</p><blockquote><p><strong>假设</strong> 线程A执行writer()方法之<strong>后</strong>，线程B执行reader()方法，那么线程B执行4的时候一定能看到线程A写入的值吗？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;           <span class="comment">//1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;     <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;       <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> i = a;    <span class="comment">//4</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是<strong>肯定的</strong>。因为根据happens-before规则，我们可以得到如下关系：</p><ol><li>根据<strong>程序顺序规则</strong>，1 happens-before 2；3 happens-before 4</li><li>根据<strong>volatile规则</strong>，2 happens-before 3；</li><li>根据<strong>传递性规则</strong>，1 happens-before 4 。</li></ol><p>因此，综合运用<strong>程序顺序规则、volatile规则及传递性规则</strong>，我们可以得到1 happens-before 4，即线程B在执行4的时候一定能看到A写入的值。</p></li></ul><h5 id="4-2-Volatile-关键字原理">4.2 Volatile 关键字原理</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/paddix/p/5428507.html">https://www.cnblogs.com/paddix/p/5428507.html</a> 。</p></blockquote><p>此题考察的是<code>volatile</code>这个关键字。可以从<code>volatile</code>的作用和<code>volatile</code>的原理这三个方面来进行回答。<strong>volatile只能保证变量的可见性、有序性，但是不能保证原子性</strong>。</p><ul><li><strong>可见性实现原理</strong></li></ul><blockquote><p>为了实现<strong>volatile可见性</strong>和<strong>happen-befor</strong>的语义。JVM底层是通过一个叫做“<strong>内存屏障（基于MESI）</strong>”的东西来完成（也实现了<strong>有序性</strong> ？）。</p></blockquote><p><strong>线程本身并不直接与主内存进行数据的交互</strong>，而是通过线程的工作内存来完成相应的操作。这也是导致线程间数据不可见的本质原因。</p><p>使用<strong>MESI</strong> 协议，使得<strong>任意一个线程修改了 volatile 修饰的变量，其他线程可以马上识别到最新值</strong>。</p><blockquote><p>最终目标：保证了<strong>缓存的一致性</strong>。</p><p>具体的话，下面是用<strong>内存屏障</strong>来实现的。</p></blockquote><ol><li>修改本地工作内存，强制刷回主内存；</li></ol><p><img src="https://i.loli.net/2021/06/11/JTFaYRu13pfQg9d.png" alt="image-20210611204633903"></p><ol start="2"><li><p>强制让其他线程的工作内存失效过期；</p><p><img src="https://i.loli.net/2021/06/11/2kphvOoJu4K65Hb.png" alt="image-20210611204715422"></p></li><li><p>其他线程重新从主内存加载最新值；</p><p><img src="https://i.loli.net/2021/06/11/rvo58ueDB6CPyMa.png" alt="image-20210611204743839"></p></li></ol><ul><li><p><strong>有序性实现原理</strong></p><blockquote><p>参考：<a href="https://blog.csdn.net/qq_42764468/article/details/106898608">https://blog.csdn.net/qq_42764468/article/details/106898608</a></p></blockquote><p>从源代码到最终执行的指令，可能会经过三种重排序：</p><p><img src="https:////upload-images.jianshu.io/upload_images/2845835-8fc217f556cd34f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680/format/webp" alt="img"></p></li><li><p><strong>【指令】重排序</strong>，<strong>JMM</strong> 会要求编译器生成指令时，会<strong>插入内存屏障</strong>来禁止处理器重排序。</p></li></ul><blockquote><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止：①特定类型的编译器重排序和②处理器重排序，为程序员提供一致的内存可见性保证。</p></blockquote><ul><li><p><strong>编译器重排序</strong>，<strong>JMM</strong> <strong>禁止了特定类型的编译器</strong>重排序（不是所有的编译器重排序都要禁止）。</p></li><li><p><strong>内存重排序</strong>：由于处理器会使用读/写缓冲区，出于性能的原因，内存会对读/写进行重排序</p></li></ul><p>JVM 是<strong>使用内存屏障来禁止【指令】重排，从而达到：可见性 + 部分有序性</strong>效果。</p><blockquote><p><strong>lock前缀指令实际相当于一个内存屏障</strong>？ 下面不是可见性吗？？？</p></blockquote><p>对volatile变量的<strong>写</strong>操作与普通变量的主要区别有两点：</p><ol><li><p>修改volatile变量<strong>前</strong>，<strong>会强制将修改后的值刷新的主内存中</strong>。</p><blockquote><p>每个volatile写操作前插入<strong>StoreStore（SS）屏障</strong></p></blockquote></li><li><p>修改volatile变量<strong>后</strong>，<strong>会导致其他线程工作内存中对应的变量值失效</strong>，因此，再读取该变量值的时候就需要重新从读取主内存中的值。</p><blockquote><p>在写操作后插入StoreLoad屏障；</p></blockquote></li></ol><p>对volatile变量的<strong>读</strong>操作类似：</p><ol><li><p>在每个volatile读操作前插入<strong>LoadLoad（LL）屏障</strong>；</p><blockquote><p>确保Load2及后续Load指令加载数据之前能访问到Load1加载的数据。</p></blockquote></li><li><p>在读操作后插入<strong>LoadStore（LS屏障</strong>）。</p><blockquote><p>确保Store2和后续Store指令执行前，可以访问到Load1加载的数据。</p></blockquote></li></ol><h5 id="4-3-volatile为什么不能保证原子性？">4.3 volatile为什么不能保证原子性？</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/simpleDi/p/11517150.html">为什么volatile能保证有序性不能保证原子性</a></p></blockquote><p>对于i++这种复合操作，即使使用volatile关键字修饰也不能保证操作的原子性，可能会引发数据不一致问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure><p>上述<code>i++</code>操作，其实分为三个操作：</p><ol><li><p>线程读取i</p></li><li><p>temp = i + 1</p></li><li><p>i = temp</p></li></ol><p>A,B两个线程多线程操作时：</p><ol><li><p>A线程读取i并执行了 temp = i + 1的操作， 此时的 i（0） 的值还没有变化</p></li><li><p>此时B也读入i并执行temp = i + 1操作，此时i（0）也没变化</p><blockquote><p>⚠️ 虽然有MESI协议，但是<code>temp</code>不保存变量<code>i</code>所在内存区域，<strong>是cpu内部的计算</strong>，不会被立马刷新内存！</p></blockquote></li><li><p>当A写入i = temp（1）时，由于可见性立马在主存被刷新了值 i=1</p></li><li><p>当B也写入i = temp时，<strong>此时A依旧是1，而不是2</strong></p></li></ol><h5 id="4-4-并发编程的三个重要特性-？">4.4 <strong>并发编程的三个重要特性</strong> ？</h5><ol><li><strong>原子性 :</strong> ⼀个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的⼲扰而中断，<strong>要么所有的操作都执行，要么都不执行</strong>。 <code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性 <strong>：当</strong>⼀个变量对共享变量进行了修改，那么另外的线程都是⽴即可以看到修改后的最新值</strong>。 volatile 关键字可以保证共享变量的可见性。</li><li><strong>有序性</strong>：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。 <code>volatile</code> 关键字可以禁⽌指令进行重排序优化。</li></ol><h5 id="4-5-说说-synchronized-关键字和-volatile-关键字的区别？">4.5 <strong>说说</strong> synchronized <strong>关键字和</strong> volatile <strong>关键字的区别</strong>？</h5><p>synchronized关键字和volatile关键字比较：</p><ul><li><p><strong>volatile关键字是线程同步的轻量级实现</strong>，所以volatile性能肯定⽐synchronized关键字要好。</p></li><li><p><strong>volatile关键字只能用于变量</strong>，而synchronized关键字可以修饰方法以及代码块。</p><blockquote><p>synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引⼊的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用<br>synchronized 关键字的场景还是更多⼀些。</p></blockquote></li><li><p><strong>volatile关键字只能保证数据的可见性</strong>，但不能保证数据的原子性。synchronized关键字两者都能保证。</p></li><li><p><strong>多线程访问volatile关键字不会发生阻塞</strong>，而synchronized关键字可能会发⽣阻塞</p></li></ul><h4 id="1-5-5-Atomic-原子类">1.5.5 Atomic 原子类</h4><h5 id="5-1-什么是Atomic-原子类？">5.1 什么是Atomic 原子类？</h5><p>所以，所谓原子类说简单点就是<strong>具有原子/原子操作特征的类</strong>。</p><blockquote><p>在我们这⾥ Atomic 是指⼀个操作是不可中断的。即使是在多个线程⼀起执行的时候，⼀个操作⼀旦开始，就不会被其他线程⼲扰。</p></blockquote><h5 id="5-2-JUC-包中的原子类是哪4类">5.2 JUC <strong>包中的原子类是哪</strong>4<strong>类</strong>?</h5><p><img src="https://i.loli.net/2021/05/16/vS4DHpKCN9bjnTF.png" alt="image-20210516152124223"></p><h5 id="5-3-Volatile-和-atomic-变量区别？">5.3 Volatile 和  atomic  变量区别？</h5><ul><li>Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。</li><li>而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</li></ul><h5 id="5-4-讲讲-AtomicInteger-的使用-？">5.4 讲讲 AtomicInteger 的使用 ？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并⾃增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并⾃减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输⼊的数值等于预期值，则以原子方式将该值设置为输⼊值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet设置之后可能导致其他线程在之后的⼀小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 基本类型也要是原子类</span></span><br><span class="line">       <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">       <span class="comment">//使⽤AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-5（重点提问）-AtomicInteger-原理？">5.5（重点提问） AtomicInteger 原理？</h5><p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile</strong> 和 <strong>native</strong> 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>我们以自增方法为例： <code>getAndIncrement</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，本质是在调用 unsafe中的 <code>getAndAddInt</code></p><blockquote><p>unsafe中的compareAndSwapInt方法参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compareAndSwapInt(Object o, <span class="keyword">long</span> offset,<span class="keyword">int</span> expected,<span class="keyword">int</span> x);  <span class="comment">// x是准备更新的值</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.<span class="built_in">getAndAddInt</span>(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unsafe中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="comment">// getIntVolatile方法获取到期望值value后去调用compareAndSwapInt方法，失败则进行重试</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// var5是计算得到的期望值，获取此时内存的最新值（因为value是votilate修饰，修改总是被能及时看到）</span></span><br><span class="line">        var5 = <span class="keyword">this</span>.<span class="built_in">getIntVolatile</span>(var1, var2);</span><br><span class="line">    <span class="comment">// 计算传入compareAndSwapInt的四个参数</span></span><br><span class="line">    <span class="comment">// var1：传入的this对象；var2：value内存偏移值；var5：期望值，希望和【var2】一致； var5+var4：var5+var4（1），递增</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.<span class="built_in">compareAndSwapInt</span>(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最终总结如下</strong></p><p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile</strong> 来保证原子操作。AtomicInteger 的主要方法都是通过调用Unsafe类方法去实现，如 compareAndSet 实际是调用AtomicInteger 的compareAndSwapInt方法。</p><p>下面以 getAndIncrement实现来说明。</p><ol><li><p>getAndIncrement调用了 Unsafe的getAndAddInt方法，传递了（1）当前this对象，（2）value偏移量valueoffset，用来计算得到value值（3）要加上的值，由于是递增所以是1</p><blockquote><p>⚠️ <strong>为什么不传value的值，而是偏移量</strong>？ 传偏移量是为了计算value所在的内存地址，进而获取最新的value值。</p></blockquote></li><li><p>getAndAddInt采用CAS方式进行更新，还需要进行当前期望值的计算</p><ul><li>通过<code>getIntVolatile</code>获取到<strong>线程此时内存value值</strong>（期望值），也就是记录<strong>执行CAS前</strong>的内存最新value值；</li></ul></li><li><p>然后开始执行Unsafe的 <code>compareAndSwapInt</code> ，主要是通过<code>Atomic::cmpxchg</code> 逻辑来实现</p><p>（1）将要dest（value内存地址），compareValue（期望值），exchange_value（要更新的值）写入寄存器中</p><p>（2）线程如果是运行多核CPU，上<strong>LOCK#锁，将dest内存区域锁住</strong> ；否则不上LOCK#锁</p><p>（3）执行cmpxchg（比较并交换命令），如果dest的value值（<strong>执行CAS中</strong>的最新value值） == compareValue，则写入exchange_value ；</p><p>（4）否则写入失败，通过不断<strong>自旋（循环</strong>）期望得到执行</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（一）_Java_多线程</title>
      <link href="/p/8959/"/>
      <url>/p/8959/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h2 id="1-4-多线程">1.4 多线程</h2><h4 id="0-三个线程，如何让他们按顺序打印A、B、C？如果是循环打印10次呢？依次打印1-100呢？交替打印奇偶10次呢？">0.<strong>三个线程，如何让他们按顺序打印A、B、C？如果是循环打印10次呢？依次打印1~100呢？交替打印奇偶10次呢？</strong></h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/370130458">https://zhuanlan.zhihu.com/p/370130458</a></p></blockquote><h5 id="0-1-synchronized-条件变量">0.1 <strong>synchronized + 条件变量</strong></h5><ol><li><p><strong>synchronized + 条件变量</strong>（循环打印1次）</p><p>思路如下：</p><ul><li>新建三个线程1、2、3 ，分别负责打印A、B、C；同时，每个线程对应一个条件变量：<code>num%3==当前线程条件变量?</code> ；</li><li>把打印的代码用synchronized 加锁，每个线程拿到锁后，<strong>while循环判断</strong>是否满足当前线程的条件变量 ；</li><li><strong>如果满足</strong> ，便执行后续逻辑打印当前线程，之后<strong>notifyall()唤醒其它线程</strong>；</li><li><strong>如果不满足</strong>，执行wait等待释放锁；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wait_Notify_ACB</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">// targetNum ： 每个线程应该满足的对应条件变量</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) </span><br><span class="line">                &#123;   <span class="comment">// while ：线程阻塞在wait(),再次被唤醒应该先检查下是否满足条件，因为这个时候未必轮到当前线程执行；用if会导致直接往下执行。</span></span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Wait_Notify_ACB  wait_notify_acb = <span class="keyword">new</span> Wait_Notify_ACB ();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>synchronized + 条件变量</strong>（循环打印10次）</p><p>打印10次，只需让三个线程，尝试去竞争10次锁即可。所以在<strong>synchronized前加上for循环</strong>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wait_Notify_ACB</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">// targetNum ： 每个线程应该满足的对应条件变量</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">10</span> ;i++)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) </span><br><span class="line">                &#123;   <span class="comment">// while ：线程阻塞在wait(),再次被唤醒应该先检查下是否满足条件，因为这个时候未必轮到当前线程执行；用if会导致直接往下执行。</span></span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Wait_Notify_ACB  wait_notify_acb = <span class="keyword">new</span> Wait_Notify_ACB ();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>synchronized + 条件变量</strong>（打印1~100)</p><p>设置一个全局变量，synchronized 中加锁函数对num+1，保证只要每次只有一个线程能执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wait_Notify_100</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxnum = <span class="number">10</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) &#123; <span class="comment">//想想这里为什么不能用if代替，想不起来可以看公众号上一篇文章</span></span><br><span class="line">                    <span class="keyword">if</span>(num &gt;= maxnum)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(num &gt;= maxnum)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + num);</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wait_Notify_100  wait_notify_100 = <span class="keyword">new</span> Wait_Notify_100 ();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread3&quot;</span>).start();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>synchronized + 条件变量</strong>（奇偶打印10次）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Wait_Notify_Odd_Even</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object monitor = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line">    Wait_Notify_Odd_Even(<span class="keyword">int</span> initCount) &#123;</span><br><span class="line">        <span class="keyword">this</span>.count = initCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printOddEven</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> <span class="comment">// 这里不用while循环判断，是因为下次notifyAll的一定是奇数或偶数</span></span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print( Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span>);</span><br><span class="line">                    System.out.println(++count);</span><br><span class="line">                    monitor.notifyAll();</span><br><span class="line">                    monitor.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//防止count=10后，while()循环不再执行，有子线程被阻塞未被唤醒，导致主线程不能退出</span></span><br><span class="line">            monitor.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Wait_Notify_Odd_Even waitNotifyOddEven = <span class="keyword">new</span> Wait_Notify_Odd_Even(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(waitNotifyOddEven::printOddEven, <span class="string">&quot;odd&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>); <span class="comment">//为了保证线程odd先拿到锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread(waitNotifyOddEven::printOddEven, <span class="string">&quot;even&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="0-2-join">0.2 join</h5><p><code>join()</code>方法**：在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行**。</p><p>基于这个原理，我们使得三个线程按顺序执行，然后循环多次即可。无论线程1、线程2、线程3哪个先执行，最后执行的顺序都是线程1——&gt;线程2——&gt;线程3。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Join_ABC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> printABC(<span class="keyword">null</span>),<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> printABC(t1),<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> printABC(t2),<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t3.start();</span><br><span class="line">            Thread.sleep(<span class="number">10</span>); <span class="comment">//这里是要保证只有t1、t2、t3为一组，进行执行才能保证t1-&gt;t2-&gt;t3的执行顺序。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">printABC</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread beforeThread;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">printABC</span><span class="params">(Thread beforeThread)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.beforeThread = beforeThread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(beforeThread!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeThread.join(); </span><br><span class="line">                    System.out.print(Thread.currentThread().getName());</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="0-3-Lock">0.3 Lock</h5><p>该方法很容易理解，不管哪个线程拿到锁，<strong>只有符合条件的才能打印</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Lock_ABC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;   <span class="comment">// 当前状态值：保证三个线程之间交替打印</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">3</span> == targetNum) &#123;</span><br><span class="line">                num++;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock(); <span class="comment">// 不符合要求直接释放锁，不会像sync一样阻塞在sync或wait处</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock_ABC lockABC = <span class="keyword">new</span> Lock_ABC();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="0-4-Semaphore">0.4 <strong>Semaphore</strong></h5><p>Semaphore：用来控制同时访问某个特定资源的操作数量，或者同时执行某个制定操作的数量。Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。</p><ul><li>一个线程要访问共享资源，先使用<code>acquire()</code>方法获得信号量，如果信号量的计数器值大于等于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。如果计数器值为0,线程进入休眠；</li><li>当某个线程使用完共享资源后，使用<code>release()</code>释放信号量，<strong>并将信号量内部的计数器加1</strong>，之前进入休眠的线程将被唤醒并再次试图获得信号量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SemaphoreABC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s1 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>); <span class="comment">//因为先执行线程A，所以这里设s1的计数器为1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s2 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s3 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(Semaphore currentThread, Semaphore nextThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentThread.acquire();       <span class="comment">//阻塞当前线程，即信号量的计数器减1为0</span></span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                nextThread.release();          <span class="comment">//唤醒下一个线程，即信号量的计数器加1</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SemaphoreABC printer = <span class="keyword">new</span> SemaphoreABC();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s1, s2);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s2, s3);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s3, s1);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-1-线程基本">1.4.1 线程基本</h3><h4 id="1-什么是线程和进程？如何保证线程安全？">1. 什么是线程和进程？<strong>如何保证线程安全？</strong></h4><h5 id="1-1-什么是线程和进程？">1.1 什么是线程和进程？</h5><ul><li><p><strong>什么是进程？</strong></p><p><strong>进程是程序的⼀次执行过程，是系统运行程序的基本单位</strong>，因此进程是<strong>动态</strong>的。系统运行⼀个程序即是⼀个进程从创建，运行到消亡的过程。</p><blockquote><p>如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe ⽂件的运行）。在Windows操作系统中，一个程序只对应一个进程，里面可以有一个或多个线程。</p><p><img src="https://i.loli.net/2021/05/16/cxYPKI1LnR4V3Mt.png" alt="image-20210516101110229"></p></blockquote></li><li><p><strong>什么是线程？</strong></p><p><strong>线程与进程相似，但线程是⼀个⽐进程更小的执行单位</strong>。⼀个进程在其执行的过程中可以产⽣多个线程。</p><ul><li>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有⾃⼰的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></li></ul><p>所以系统在产⽣⼀个线程，或是在各个线程之间作<u>切换⼯作</u>时，<strong>负担要⽐进程小得多</strong>，也正因为如此，线程也被称为轻量级进程。</p><blockquote><p>⼀个 Java 程序的运行是 main 线程和多个其他线程同时运行。</p></blockquote></li></ul><h5 id="1-2-如何保证线程安全？">1.2 如何保证线程安全？</h5><ol><li><strong>原子性</strong>，简单说就是<u>相关操作不会中途被其他线程干扰，一般通过同步机制实现</u>；</li><li><strong>可见性</strong>，<u>是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓</u>，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的；</li><li><strong>有序性</strong>，<u>是保证线程内串行语义，避免指令重排</u>等。</li></ol><h5 id="1-3-为什么程序计数器、虚拟机栈和本地方法栈是-u-线程-u-私有的">1.3 为什么程序计数器、虚拟机栈和本地方法栈是<u>线程</u>私有的?</h5><ul><li><p><strong>程序计数器为什么是私有</strong></p><p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪⼉了。</p><p>所以，程序计数器<u>私有</u>主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p></li><li><p><strong>虚拟机栈和本地方法栈为什么私有</strong></p><ul><li><p><strong>虚拟机栈</strong>： <u>每个 Java 方法在执行的同时会创建⼀个栈帧用于存储局部变量表、操作数栈、常量池引用等信息</u>。从方法调用直⾄执行完成的过程，就对应着⼀个栈帧在 Java 虚拟机栈中<strong>⼊栈和出栈</strong>的过程。</p></li><li><p><strong>本地方法法栈</strong>： 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行</strong> <strong>Java</strong> 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 <strong>Native方法服务</strong>。 在 HotSpot 虚拟机中和 Java 虚拟机栈合⼆为⼀。</p></li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p></li></ul><h4 id="2-创建线程的方式（非线程池）？-哪种最好？">2.<strong>创建线程的方式（非线程池）？ 哪种最好？</strong></h4><p>一般有三种方式来进行创建：</p><ol><li><p><strong>继承Thread类</strong>：（1）定义Thread类的子类，并重写该类的run方法（2）创建Thread子类的实例对象 （3）调用对象start()方法</p><blockquote><ul><li>优点：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用this即可获取当前线程；</li><li>缺点：因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了。</li></ul></blockquote></li><li><p><strong>实现Runnable接口</strong>：（1）定义runnable接口的<strong>实现类</strong>，并重写该接口的run()方法 （2）创建实现类的实例对象（3）调用线程对象的start()方法来启动该线程</p></li><li><p><strong>通过Callable和Future创建线程</strong>：（1）创建Callable接口的实现类，<strong>并实现call()方法</strong>（2）创建Callable实现类的实例，并使用FutureTask类来包装Callable对象（3）使用FutureTask对象作为Thread对象的target创建并启动新线程（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p></li></ol><p>其中 <u>实现Runnalbe接口更好</u>  ，使用实现Runnable接口的方式创建的线程<strong>可以处理同一资源</strong>，从而实现资源的共享。</p><h4 id="3-如何停止一个正在运行的线程？">3.<strong>如何停止一个正在运行的线程？</strong></h4><ol><li><p>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止；</p></li><li><p>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法；</p></li><li><p>使用interrupt方法中断线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">     <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">           sleep(<span class="number">1000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;week up from blcok...&quot;</span>);</span><br><span class="line">            stop = <span class="keyword">true</span>; <span class="comment">// 在异常处理代码中修改共享变量的状态</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    System.out.println(getName() + <span class="string">&quot; is exiting...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterruptThreadDemo3</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>          InterruptedException </span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">          MyThread m1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">          System.out.println(<span class="string">&quot;Starting thread...&quot;</span>);</span><br><span class="line">          m1.start();</span><br><span class="line">          Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;Interrupt thread...: &quot;</span> +           m1.getName());</span><br><span class="line">          m1.stop = <span class="keyword">true</span>; <span class="comment">// 设置共享变量为true</span></span><br><span class="line">          m1.interrupt(); <span class="comment">// 阻塞时退出阻塞状态</span></span><br><span class="line">          Thread.sleep(<span class="number">3000</span>); <span class="comment">// 主线程休眠3秒以便观察线程m1的中断情况</span></span><br><span class="line">          System.out.println(<span class="string">&quot;Stopping application...&quot;</span>);</span><br><span class="line">       &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-什么是Daemon线程？它有什么意义？">4.<strong>什么是Daemon线程？它有什么意义？</strong></h4><p>所谓后台(daemon)线程，也叫守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。</p><ul><li><strong>意义</strong>：JVM的垃圾回收线程就是Daemon线程，Finalizer也是守护线程。</li></ul><h4 id="5-说说CyclicBarrier和CountDownLatch的区别？">5.<strong>说说CyclicBarrier和CountDownLatch的区别？</strong></h4><p>两个看上去有点像的类，都在<code>java.util.concurrent</code>下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><ol><li>CyclicBarrier的某个线程运行到某个点上之后，<strong>该线程即停止运行</strong>，<strong>直到所有的线程都到达了这个点</strong>，所有线程才重新运行CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值**-1**而已，该线程继续运行；</li><li>CyclicBarrier<strong>只能唤起一个任务</strong>，CountDownLatch可以唤起多个任务</li><li>CyclicBarrier可重用，<strong>CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</strong></li></ol><h4 id="6-请你简要说明一下线程的基本状态以及状态之间的关系？">6.<strong>请你简要说明一下线程的基本状态以及状态之间的关系？</strong></h4><p><img src="https://i.loli.net/2021/04/28/VCN8xckXHMdrl1R.png" alt="image-20210428164922743"></p><ol><li><strong>新建状态</strong>：new语句创建的线程对象处于新建状态，仅被分配了内存；</li><li><strong>等待状态</strong>： 当线程在new之后，并且<u>在调用start方法前</u>，线程处于等待状态 ;</li><li><strong>就绪状态</strong>： 其他线程调用它的**start()**方法，该线程就进入就绪状态，<u>只差等待cpu的使用权 </u> ;</li><li><strong>运行状态</strong>： <u>线程占用CPU，执行程序代码</u>  ;</li><li><strong>阻塞状态</strong>： 阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。<u>阻塞状态分为三种：</u><ul><li><u>等待阻塞:</u> 运行的线程执行**wait()**方法，JVM会把该线程放入等待池中；</li><li><u>同步阻塞:</u> 运行的线程在获取<strong>对象同步锁</strong>时，若该同步锁被别的线程占用，则JVM会把线程放入锁池中；</li><li><u>其他阻塞:</u> 运行的线程执行Sleep()方法，或者发出I/O请求时，JVM会把线程设为阻塞状态。</li></ul></li><li><strong>死亡状态</strong>： 线程执行完<strong>run()方法中的代码</strong>，或者遇到了未捕获的异常，就会退出run()方法，结束生命周期</li></ol><h4 id="7-notify-和notifyAll-有什么区别？">7. <strong>notify()和notifyAll()有什么区别？</strong></h4><ul><li><strong>notify可能会导致死锁（why？</strong>），而notifyAll则不会；</li><li>使用notifyall,可以唤醒 所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。</li></ul><h4 id="8-sleep-和wait-有什么区别？">8. <strong>sleep()和wait() 有什么区别？</strong></h4><ul><li><p><strong>继承的类</strong>：sleep()方法，我们首先要知道该方法是属于Thread类中的；而wait()方法，则是属于Object类中的；</p><blockquote><p><em>sleep()</em> 是 <em>Thread</em> 类静态方法，可以使 <u>当前</u> 线程阻塞，并指定暂停时间，重点在于理解 <u>当前</u>。休眠时间期满后，该线程不一定会立即执行被CPU调度，只是到了就绪状态。</p></blockquote></li><li><p><strong>是否释放锁</strong>：sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。<strong>在调用sleep()方法的过程中，线程不会释放对象锁；当调用wait()方法的时候，线程会放弃对象锁</strong>，进入等待此对象的等待锁定池；</p></li><li><p><strong>用处</strong>： <strong>Wait 通常被用于线程间交互/通信</strong>，sleep 通常被用于暂停执行；</p></li><li><p><strong>再次唤醒</strong>： wait() 方法被调用后，线程不会⾃动苏醒，需要别的线程调用同⼀个对象上的 notify() 或者notifyAll() 方法。sleep() 方法执行完成后，线程会⾃动苏醒。</p></li></ul><h5 id="8-1-Thread类中的yield方法有什么作用？">8.1 <strong>Thread类中的yield方法有什么作用？</strong></h5><p><em>yield()</em> 也是 <em>Thread</em> 类静态方法，<strong>使当前线程变为<u>就绪状态</u></strong> （<em>sleep()</em> 是阻塞），使得其他线程更多机会获取CPU。执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p><h5 id="8-2-java-中Wait、Sleep和Yield方法的区别？">8.2 <strong>java 中Wait、Sleep和Yield方法的区别？</strong></h5><p><a href="https://www.jianshu.com/p/25e959037eed">https://www.jianshu.com/p/25e959037eed</a></p><h4 id="9-volatile-是什么-可以保证有序性吗">9. <strong>volatile 是什么?可以保证有序性吗?</strong></h4><ol><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存；</li><li>禁止进行指令重排序。</li></ol><p><strong>能保证有序性</strong>，因为禁止指令重排。</p><h4 id="10-为什么wait-notify-和-notifyAll这些方法不在thread类里面？">10. 为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h4><p><a href="https://www.zhihu.com/question/321674476">https://www.zhihu.com/question/321674476</a></p><p>明显的原因是<strong>JAVA提供的锁是对象级的而不是线程级的</strong>，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。<u>如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了</u>。</p><ul><li>简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</li></ul><h4 id="11-为什么wait和notify方法要在同步块中调用？">11.<strong>为什么wait和notify方法要在同步块中调用？</strong></h4><ul><li><u>wait()方法<strong>强制当前线程释放对象锁</strong></u>。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法；</li><li>在调用对象的notify()和notifyAll()方法之前，<u>调用线程必须<strong>已经得到该对象的锁</strong></u>。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。</li></ul><h4 id="12-（没细看）Java中interrupted-和-isInterruptedd方法的区别？">12. （没细看）<strong>Java中interrupted 和 isInterruptedd方法的区别？</strong></h4><p>interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法。</p><h3 id="1-4-2-线程池">1.4.2 线程池</h3><h4 id="1-请你解释一下什么是线程池（thread-pool）？">1.<strong>请你解释一下什么是线程池（thread pool）？</strong></h4><p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，<u>使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销</u>。 除此之外：</p><ul><li>提高性能，利用多线程压榨CPU算力；</li><li>提高线程的可管理性，限制线程数量并可以进行统一的分配、调优和监控。</li></ul><h5 id="1-1-请介绍一下使用线程池任务执行过程？"><strong>1.1 请介绍一下使用线程池任务执行过程？</strong></h5><p><strong>核心参数</strong>：其中<code>corePool</code>是核心线程池（保活线程），<code>maximumPool</code>是总线程池（保活线程+工作线程），<code>blockQueue </code>是等待任务队列，<code>rejectedExecutionHandler</code>是拒绝策略：</p><p><img src="https://i.loli.net/2021/04/19/Pn4wc5621hqIXpl.png" alt="image-20210419235537833" style="zoom: 33%;" /><img src="https://segmentfault.com/img/remote/1460000038860133" alt="iShot2021-01-03 20.18.23.png" style="zoom: 67%;" /></p><p><strong>流程：corePoolSize→队列→maximumPool→拒绝策略</strong></p><ol><li>未达到corePoolSize时，核心线程池会开辟新线程运行任务（<u>可以使用已有线程吗？</u>），<strong>任务结束后线程不销毁</strong>；</li><li>达到corePoolSize，而任务队列未满时，新任务提交到等待队列，<strong>线程空闲时间超过keepAliveTime时被销毁；</strong></li><li>任务队列也满了，但未超过最大线程数，新建工作线程执行任务；</li><li>超过最大线程数时，<strong>按拒绝策略处理</strong>，包括：<u>抛出异常、使用调用者线程运行任务、丢弃新任务、丢弃队列头任务</u>等。</li></ol><h5 id="1-2-线程池会回收核心线程吗？">1.2 线程池会回收核心线程吗？</h5><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000038836285">线程池是怎么回收空闲线程的</a></p></blockquote><p>会，可以通过allowCoreThreadTimeOut参数来进行设置。</p><ul><li><p>先回忆一下整体线程池流程</p><img src="https://segmentfault.com/img/remote/1460000038860133" alt="iShot2021-01-03 20.18.23.png" style="zoom:67%;" /></li><li><p><strong>excute方法</strong></p><p>我们的任务放到线程池后，是从调用execute执行开始的。<br><img src="https://i.loli.net/2021/05/26/hc4w6ZIbm57CpOQ.png" alt="image-20210526234652655" style="zoom: 67%;" /></p><ul><li><p>核心是addWorker办法， 里面最最重要的就是初始化Worker同时启动thread。</p></li><li><p>Worker实现了Runnable接口，我们直接看它的run方法，看截图的③处标记，抽离出来一个runWorker方法：</p><p><img src="https://i.loli.net/2021/05/26/39woAvIR4QjNfxd.png" alt="iShot2021-01-03 20.39.22.png"></p><p>也就是说：①处是一个while循环，<strong>getTask</strong>方法就是从线程池队列取任务，<strong>如果取不到任务</strong>就会执行</p><p>​                   ②<strong>一旦跳出while循环，即进入到processWorkExit方法，这就是回收Worker</strong></p></li></ul></li><li><p><strong>getTask方法</strong></p><p>可以看到，①判断是否回收线程的条件，<strong>timed</strong> ，有两种情况要回收线程：</p><ol><li><strong>wc&gt;corePoolSize</strong> ，当前线程数大于核心线程数</li><li><strong>allowCoreThreadTimeOut</strong>，核心线程超时，所以<strong>核心线程是会被回收</strong>的</li></ol><p>然后②处就是从任务队列取任务了，<strong>带了timeOut参数的poll方法超时</strong> ，未能从任务队列获取任务即返回null，从而实现最终的<strong>线程回收</strong>。</p><blockquote><p>不是processWorkExit处理吗，怎么在getTask处理，还是得好好看看。</p></blockquote><p><img src="https://i.loli.net/2021/05/26/hxJerXAo16msf38.png" alt="image-20210526235850331"></p></li></ul><h4 id="2-请介绍一下什么是生产者消费者模式？">2.<strong>请介绍一下什么是生产者消费者模式？</strong></h4><p><img src="https://uploadfiles.nowcoder.com/images/20180925/308572_1537880635592_7142B8354CA8A352B2B805F997C71549" alt="img"></p><p>生产者消费者问题是线程模型中的经典问题：</p><ul><li>生产者和消费者在<strong>同一时间段内共用同一存储空间</strong>，生产者向空间里生产数据，而消费者取走数据。</li></ul><h4 id="3-线程池的拒绝策略有哪些？">3.<strong>线程池的拒绝策略有哪些？</strong></h4><p>主要有4种拒绝策略：</p><ol><li>AbortPolicy：直接丢弃任务，抛出异常，这是默认策略</li><li><strong>CallerRunsPolicy</strong>：只用调用者所在的线程来处理任务</li><li>DiscardOldestPolicy：<strong>丢弃等待队列中最旧</strong>的任务，并执行当前任务</li><li>DiscardPolicy：直接丢弃任务，也不抛出异常</li></ol><h4 id="4-如何创建一个线程池（四大方法）？相关参数（七大参数）是什么">4.<strong>如何创建一个线程池（四大方法）？相关参数（七大参数）是什么?</strong></h4><p>java通过Executors提供<strong>四大方法</strong>：</p><ol><li><strong>newCachedThreadPool</strong>：创建一个可缓存线程池，如果线程池长度超过处理需要，<strong>可灵活回收空闲线程，若无可回收，则新建线程</strong>；</li><li><strong>newFixedThreadPool</strong>：创建一个定长线程池，<u>可控制线程最大并发数</u>，<strong>超出的线程会在<u>队列中等待</u></strong>；</li><li><strong>newScheduledThreadPool</strong>：创建一个定长线程池，<u>支持定时及周期性任务执行</u>；</li><li><strong>newSingleThreadExecutor</strong>： 创建一个<u>单线程化的线程池</u>，它只会用<strong>唯一的工作线程</strong>来执行任务，保证<u>所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</u>。</li></ol><p><strong>七大参数设置</strong>：</p><ol><li><p><strong>corePoolSize</strong>：当使用了<code>LinkedBlockingQueue = new LinkedBlockQueue</code>的时候，<strong>队列长度默认无限长</strong>，会导致线程数量永远等于<code>corePoolSize</code>，任务激增时任务响应时间也激增；</p></li><li><p><strong>maximumPoolSize</strong>：线程池中线程个数，增加线程的公式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>任务数</mtext><mo>−</mo><mi>q</mi><mi>u</mi><mi>e</mi><mi>u</mi><mi>e</mi><mi>C</mi><mi>a</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mtext>原线程数</mtext><mo>÷</mo><mtext>原任务数</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(任务数-queueCapacity) \times (原线程数 \div 原任务数)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">任务数</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">原线程数</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">原任务数</span><span class="mclose">)</span></span></span></span>；</p></li><li><p><strong>keepAliveTime</strong>：线程最大（空闲）存活时间；</p></li><li><p><strong>rejectedExecutionHandler</strong>：线程被拒绝的解决方案，可以自己重写；</p></li><li><p><strong>workQueue</strong> ： 阻塞队列；</p></li><li><p><strong>unit</strong>：keepAliveTime的单位 ；</p></li><li><p><strong>threadFactory</strong>：表示生成线程池中工作线程的线程工厂，用于创建线程一般默认即可</p></li></ol><h4 id="5-线程池核心线程数corePoolSize怎么设置呢？">5.<strong>线程池核心线程数corePoolSize怎么设置呢？</strong></h4><p>分为CPU密集型和IO密集型来考虑：</p><ul><li><p><strong>CPU密集型</strong>。这种任务消耗的主要是 CPU 资源，可以将线程数设置为 <code>N（CPU 核心数）+1</code>。</p><blockquote><p><u>比 CPU 核心数多出来的一个线程</u> ：是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p></blockquote></li><li><p><strong>IO密集型</strong>。这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，<strong>而线程在处理 I/O 的时间段内不会占用 CPU 来处理</strong>，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 ： <code>核心线程数=CPU核心数量*2</code></p></li></ul><h4 id="6-（不熟悉）Java线程池中队列常用类型有哪些？">6.<strong>（不熟悉）Java线程池中队列常用类型有哪些？</strong></h4><ul><li><code>ArrayBlockingQueue</code> ：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序；</li><li><code>LinkedBlockingQueue</code> :一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于 ArrayBlockingQueue ；</li><li><code>SynchronousQueue</code> : 一个不存储元素的阻塞队列；</li><li><code>PriorityBlockingQueue</code>： 一个具有优先级的无限阻塞队列，PriorityBlockingQueue 也是基于最小二叉堆实现。</li></ul><h4 id="7-有三个线程T1-T2-T3-如何保证顺序执行？">7.<strong>有三个线程T1,T2,T3,如何保证顺序执行？</strong></h4><p>因为在每个线程的run方法中用join()方法限定了三个线程的执行顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="comment">// 1.现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() </span><br><span class="line">         &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">               </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         <span class="keyword">final</span> Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// t2线程内run方法最开始，引用t1.join，等待t1线程执行完</span></span><br><span class="line">                   t1.join();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">                   System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// t3线程内run方法最开始，引用t2.join，等待t2线程执行完</span></span><br><span class="line">                        t2.join();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                          &#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                          &#125;</span><br><span class="line">                         System.out.println(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">                         &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//这里三个线程的启动顺序可以任意，大家可以试下！</span></span><br><span class="line">         t3.start();</span><br><span class="line">         t2.start();</span><br><span class="line">         t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-3-多线程">1.4.3 多线程</h3><h4 id="1-请简述一下实现多线程同步的方法？-为什么需要使用多线程？使用多线程会带来什么问题？">1.<strong>请简述一下实现多线程同步的方法？</strong> 为什么需要使用多线程？使用多线程会带来什么问题？</h4><ul><li><p><strong>同步方法</strong>：可以使用synchronized、lock、volatile和ThreadLocal来实现同步。</p></li><li><p><strong>为什么需要使用多线程？</strong></p><ul><li>减少<strong>上下文切换开销</strong>（共享进程的堆和方法区 ，注意，减少≠没有）</li><li>利用好多线程机制可以大大提<strong>高系统整体的并发能⼒</strong>以及性能</li><li><strong>多核时代</strong> ：多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算⼀个复杂的任务，我们只用⼀个线程的话，CPU <strong>只会⼀个 CPU 核⼼</strong>被利用到，而创建多个线程就可以让多个 CPU 核⼼被利用到，这样就提高了 CPU 的利用率。</li></ul></li><li><p><strong>带来的问题？</strong></p><ul><li><u>内存泄漏、上下⽂切换、死锁</u>还有受限于硬件和软件的资源闲置问题。</li></ul></li></ul><h4 id="2-什么是线程安全？如何保证线程安全？">2. 什么是线程安全？如何保证线程安全？</h4><blockquote><p>好文：<a href="https://zhuanlan.zhihu.com/p/94762520">一文搞懂CAS</a></p></blockquote><ul><li><p><strong>什么是线程安全？</strong></p><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。<u>如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的</u>，就是线程安全的。</p></li><li><p><strong>如何保证线程安全？</strong></p><ol><li><strong>使用 synchronized 关键字</strong> 。开销比较大</li><li><strong>使用Lock 锁</strong> 。高并发场景下，使用 Lock 锁要比使用synchronized 关键字，在性能上得到极大的提高。因为 Lock 底层是通过 AQS + CAS 机制来实现的。</li><li><strong>使用 Atomic 原子类</strong> 。使用 Lock 方式，一旦 unlock() 方法使用不规范，可能导致死锁。 Atomic 原子类，因为其底层基于 CAS 乐观锁来实现的，性能较高。</li><li><strong>使用Volatile？不可行！</strong> 因为无法保证原子性。</li></ol></li></ul><h4 id="3-线程安全需要保证几个基本特征？">3.<strong>线程安全需要保证几个基本特征？</strong></h4><ul><li><strong>原子性</strong>，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</li><li><strong>可见性</strong>，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将<br>线程本地状态反映到主内存上，volatile 就是负责保证可见性的。</li><li><strong>有序性</strong>，是保证线程内串行语义，避免指令重排等。</li></ul><h4 id="4-【待补充】如何在线程安全的情况下实现一个计数器？">4. 【待补充】<strong>如何在线程安全的情况下实现一个计数器？</strong></h4><p>可以使用加锁，比如synchronized或者lock。也可以使用Concurrent包下的原子类。</p><h4 id="5-多线程中的i-线程安全吗？请简述一下原因？">5.<strong>多线程中的i++线程安全吗？请简述一下原因？</strong></h4><p>不安全，因为<strong>i++不是原子性操作</strong>。i++分为读取i值，对i值加一，再赋值给i++，执行期中任何一步都是有可能被其他线程抢占的。</p><h4 id="6-介绍一下ThreadLocal原理？">6.<strong>介绍一下ThreadLocal原理？</strong></h4><blockquote><p>一篇讲的不错的文章：<a href="https://www.cnblogs.com/wupeixuan/p/12638203.html">https://www.cnblogs.com/wupeixuan/p/12638203.html</a></p></blockquote><p>当多线程访问共享可变数据时，涉及到线程间同步的问题，<u><strong>并不是</strong>所有时候，都要用到共享数据</u>，所以就需要线程封闭出场了。<strong>数据都被封闭在各自的线程之中</strong>，就不需要同步，这种通过将数据封闭在线程中而避免使用同步的技术称为<strong>线程封闭</strong>。</p><p>ThreadLocal 是 Java 里一种特殊变量，它是一个线程级别变量，<u>每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量</u>，竞态条件被彻底消除了，在并发模式下是绝对安全的变量。</p><ul><li><p><strong>使用示例</strong></p><p>在下面例子中，TreadLocal 做到多个线程对同一对象 set 操作，但是 get 获取的值还都是每个线程 set 的值，体现了线程的封闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadLocal变量，每个线程都有一个副本，互不干扰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; THREAD_LOCAL = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadLocalDemo().threadLocalTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadLocalTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 主线程设置值</span></span><br><span class="line">        THREAD_LOCAL.set(<span class="string">&quot;wupx&quot;</span>);</span><br><span class="line">        String v = THREAD_LOCAL.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread-0线程执行之前，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程取到的值：&quot;</span> + v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String v = THREAD_LOCAL.get();</span><br><span class="line">                <span class="comment">// 此时新建线程Thread-0取到的是null，意味着不同线程取到的值不同的</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程取到的值：&quot;</span> + v);</span><br><span class="line">                <span class="comment">// 设置 threadLocal</span></span><br><span class="line">                THREAD_LOCAL.set(<span class="string">&quot;huxy&quot;</span>);</span><br><span class="line">                v = THREAD_LOCAL.get();</span><br><span class="line">                System.out.println(<span class="string">&quot;重新设置之后，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程取到的值为：&quot;</span> + v);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 等待所有线程执行结束</span></span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        v = THREAD_LOCAL.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread-0线程执行之后，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程取到的值：&quot;</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  输出结果 */</span></span><br><span class="line"><span class="comment">// 虽然Thread-0已经改变了值，但是main取到的值依旧是一样的。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thread-0线程执行之前，main线程取到的值：wupx</span></span><br><span class="line"><span class="comment">Thread-0线程取到的值：null</span></span><br><span class="line"><span class="comment">重新设置之后Thread-0线程取到的值为：huxy</span></span><br><span class="line"><span class="comment">Thread-0线程执行结束</span></span><br><span class="line"><span class="comment">Thread-0线程执行之后，main线程取到的值：wupx</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>ThreadLocal原理</strong></p><p>ThreadLocal有一个<strong>静态内部类ThreadLocalMap，ThreadLocalMap又包含了一个Entry数组</strong>，Entry本身是一个弱引用，他的key是指向ThreadLocal的弱引用，Entry具备了保存key value键值对的能力。</p><p><img src="https://i.loli.net/2021/05/16/MXKyQxYDjWdOku2.png" alt="image-20210516142348550"></p><ul><li><p><strong>ThreadLocalMap</strong></p><blockquote><p>ThreadLocalMap 是 ThreadLocal 的静态内部类，当一个<strong>线程有多个 ThreadLocal 对象时</strong>时，需要一个容器来管理多 ThreadLocal，ThreadLocalMap 的作用就是管理线程中多个 ThreadLocal。</p></blockquote><p>从源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构，底层是数组，有初始化大小，也有扩容阈值大小，数组的元素是 Entry，<strong>Entry 的 key 就是 ThreadLocal 的引用，value 是 ThreadLocal 的值</strong>。ThreadLocalMap 解决 hash 冲突的方式采用的是<strong>线性探测法</strong>，如果发生冲突会继续寻找下一个空的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 键值对实体的存储结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 当前线程关联的 value，这个 value 并没有用弱引用追踪</span></span><br><span class="line">Object value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造键值对</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k k 作 key,作为 key 的 ThreadLocal 会被包装为一个弱引用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v v 作 value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line"><span class="keyword">super</span>(k);</span><br><span class="line">value = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始容量，必须为 2 的幂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储 ThreadLocal 的键值对实体数组，长度必须为 2 的幂</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadLocalMap 元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容的阈值，默认是数组大小的三分之二</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Set方法</strong></p><blockquote><p>调用 ThreadLocal对象.set(value)，实际在调用当前线程的ThreadLocalMap对象.set(this,value) ，会把当前 <code>threadLocal</code> 对象作为 key，想要保存的对象作为 value，存入 map。</p></blockquote><p>set 方法的流程主要是：</p><ul><li>先获取到当前线程的引用</li><li>利用这个引用来获返回当前线程到 ThreadLocalMap</li><li>如果 map 为空，则去创建一个 ThreadLocalMap</li><li>如果 map 不为空，就利用 ThreadLocalMap 的 <code>set (this当前对象，value)</code> 添加键值对</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为当前 ThreadLocal 对象关联 value 值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要存储在此线程的线程副本的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 返回当前ThreadLocal所在的线程</span></span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line"><span class="comment">// 返回当前线程持有的map</span></span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line"><span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果 ThreadLocalMap 不为空，则直接存储&lt;ThreadLocal, T&gt;键值对</span></span><br><span class="line">        <span class="comment">// 此时this是ThreadLocal对象，这是在ThreadLocal类中</span></span><br><span class="line">map.set(<span class="keyword">this</span>, value);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 否则，需要为当前线程初始化 ThreadLocalMap，并存储键值对 &lt;this, firstValue&gt;</span></span><br><span class="line">createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程 thread 持有的 ThreadLocalMap对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Get方法</strong></p><blockquote><p>调用ThreadLocal对象.get() 方式时，实际在调用ThreadLocalMap对象.getEntry(this) 方法。this是当前ThreadLocal对象。</p></blockquote><p>get 方法的主要流程为：</p><ul><li>先获取到当前线程的引用</li><li>获取当前线程内部的 ThreadLocalMap对象</li><li>如果 map 存在，则获取当前 ThreadLocal 对应的 value 值</li><li>如果 map 不存在或者找不到 value 值，则调用 setInitialValue() 进行初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前 ThreadLocal 对象关联的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 返回当前 ThreadLocal 所在的线程</span></span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line"><span class="comment">// 从线程中拿到 ThreadLocalMap</span></span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line"><span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 从 map 中拿到 entry</span></span><br><span class="line">ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 如果不为空，读取当前 ThreadLocal 中保存的值</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">T result = (T) e.value;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若 map 为空，则对当前线程的 ThreadLocal 进行初始化，最后返回当前的 ThreadLocal 对象关联的初值，即 value</span></span><br><span class="line"><span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>resize 方法</strong></p><p>当前线程的 ThreadLocalMap 中的 ThreadLocal 的个数超过容量阈值时，ThreadLocalMap 就要开始扩容了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 略</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7-为什么ThreadLocal造成内存泄漏？">7.<strong>为什么<code>ThreadLocal</code>造成内存泄漏？</strong></h4><p>ThreadLocalMap 是 ThreadLocal 的静态内部类，当一个线程有多 个ThreadLocal 时，需要一个容器来管理多个 ThreadLocal，ThreadLocalMap 的作用就是管理线程中多个 ThreadLocal。</p><blockquote><p>源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构：</p><p>底层是数组<code>Entry[] table</code>，数组的元素是 Entry类：<strong>Entry 的两个属性， key 是 ThreadLocal类型的引用，value 是 ThreadLocal 的值</strong>。</p></blockquote><ul><li><strong>原因</strong>：<code>ThreadLocalMap</code>的key为<strong>弱引用</strong>（有用但非必需，下一次GC会被回收），value为<strong>强引用</strong>（GC过程不会被回收），<u>有可能造成key被GC，value没被G</u>C，<code>ThreadLocalMap</code>中出现<code>null</code>为key的<code>Entry</code>，产生<u>内存泄漏</u>（<strong>软引用</strong>：有用但非必需，内存溢出之前被回收）；</li><li><strong>解决</strong>： 调用<code>set()</code>、<code>get()</code>和<code>remove()</code>方法时，会自动清理掉key为<code>null</code>的记录，但使用<code>ThreadLocal</code>方法后<strong>手动<code>remove()</code></strong>。</li></ul><h4 id="8-什么是多线程中的上下文切换？">8.<strong>什么是多线程中的上下文切换？</strong></h4><p><u>一个线程<strong>让出处理器使用权</strong>，就是“切出”；另外一个线程获取处理器使用权，就是“切入”。</u>在这个切入切出的过程中，操作系统会保存和恢复相关的进度信息，这个进度信息就是我们常说的“上下文”，上下文中一般包含了寄存器的存储内容以及程序计数器存储的指令内容。</p><h4 id="9-请问什么是死锁-deadlock">9.<strong>请问什么是死锁(deadlock)?</strong></h4><p>死锁是指<u>两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</u>，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p><h4 id="10-JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？">10. <strong>JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？</strong></h4><p><u>最简单方法：<strong>指定获取锁的顺序，并强制线程按照指定的顺序获取锁</strong>。</u></p><p>因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。或者通过破坏死锁的四个条件：</p><ul><li><strong>互斥</strong> ： 不可能破坏。</li><li><strong>破坏请求和保持条件</strong>：进程必须 <u>等所有要请求的资源都空闲时才能申请资源</u>， 这种方法会使<strong>资源浪费严重</strong> 。允许进程获取初期所需资源后，便开始运行，运行过程中再逐步释放自己占有的资源。</li><li><strong>破坏不可抢占条件</strong>： 方法代价大，实现复杂。</li><li><strong>破坏循坏等待条件</strong> ：对各进程请求资源的顺序做一个规定，避免相互等待。这种方法对<u>资源的利用率比前两种都高</u>，但是前期要为设备指定序号，新设备加入会有一个问题，其次对用户编程也有限制。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（一）_Java_集合</title>
      <link href="/p/21069/"/>
      <url>/p/21069/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h2 id="1-3-集合">1.3 集合</h2><h3 id="1-3-1-集合类">1.3.1 集合类</h3><h4 id="1-请说明Java集合类框架的基本接口有哪些？">1.<strong>请说明Java集合类框架的基本接口有哪些</strong>？</h4><ul><li><code>Collection</code>：代表一组对象，每一个对象都是它的子元素。</li><li><code>Set</code>：不包含重复元素的Collection。</li><li><code>List</code>：有顺序的collection，并且可以包含重复元素。</li><li><code>Map</code>：可以把键(key)映射到值(value)的对象，键不能重复。</li></ul><h4 id="2-（补充：举例说明）说说什么是fail-fast？">2.<strong>（补充：举例说明）说说什么是fail-fast？</strong></h4><p>fail-fast 机制是 Java 集合（Collection）中的一种错误<strong>快速反馈</strong>机制。当<strong>多个线程对同一个集合的内容进行操作时</strong>，就可能会产生 fail-fast 事件。</p><blockquote><p>例如：当某一个线程 A 通过 iterator 去遍历某集合的过程中，<strong>若该集合的内容被其他线程所改变了，那么线程 A 访问集合时，就会抛出 ConcurrentModifificationException 异常</strong>，产生 fail-fast 事件。这里的操作主要是指 add、remove 和 clear，对集合元素个数进行修改。</p></blockquote><h4 id="3-请说明List、Map、Set三个接口区分？">3.<strong>请说明List、Map、Set三个接口区分</strong>？</h4><ul><li><strong>重复元素</strong>：List以特定索引来存取元素，可以有重复元素；Map以键值对映射，不能有重复key；Set元素不能重复</li><li><strong>继承collection</strong>： List、Set继承于collection；Map和前二者明显区分，不继承collection</li><li><strong>实现方式</strong>： List是线性结构的容器 ，典型实现有<u>ArrayList 、LinkedList、Vector</u>； Map、Set都有 <u>基于哈希存储和排序树</u> 的两种实现版本，前者实现有 <u>HashMap和Hashtable</u> ，后者有<u>HashSet</u></li></ul><h4 id="4-请讲讲你所知道的常用集合类以及主要方法？">4.<strong>请讲讲你所知道的常用集合类以及主要方法</strong>？</h4><p>最常用的集合类是List 和 Map。</p><ul><li><strong>List</strong>：典型实现有<u>ArrayList 、LinkedList、Vector</u> ，大小可变，适合用于按数值索引元素类型；</li><li><strong>Map</strong>： 其中每个键映射到一个值，实现有 <u>HashMap和Hashtable</u> 。</li></ul><h3 id="1-3-2-Map-Set">1.3.2 <strong>Map &amp; Set</strong></h3><h4 id="1-请你介绍一下map的分类和常见的情况？">1.<strong>请你介绍一下map的分类和常见的情况</strong>？</h4><p>java为数据结构中的映射定义了一个接口<code>java.util.Map</code>  ， 它有四个实现类,分别是<code>HashMap、 Hashtable、 LinkedHashMap、 和TreeMap</code>.</p><ul><li><p><strong>Hashmap</strong>  ：根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度。</p><ul><li>遍历：访问快，遍历时取得的<u>数据随机</u></li><li>线程：不支持线程同步（但可以用Collections的synchronizedMap 实现同步）</li><li>key和记录：<strong>HashMap允许键和值是null</strong></li></ul></li><li><p><strong>Hashtable</strong> ：和Hashmap类似，是其子类。但其：</p></li><li><p>线程： 支持线程同步，也导致写入比较慢（一个时候只能一个线程写入）</p></li><li><p>key和记录：不允许记录的键或者值为空 ；</p></li><li><p><strong>LinkedHashMap</strong> ：HashMap的一个子类，<u>保存了记录插入顺序</u>：</p></li><li><p>遍历：<strong>遍历</strong>先得到的记录是先插入、一般情况比HashMap慢。</p></li><li><p><strong>TreeMap</strong> ： 实现SortMap接口，默认是按键值的升序排序，</p></li><li><p>遍历：当用<strong>遍历</strong>TreeMap时，得到的记录是<u>排过序</u>的</p><ul><li>线程：线程安全</li></ul></li></ul><p>一般情况下，我们用的最多的是HashMap, 在Map 中插入、删除和定位元素，HashMap 是最好的选择。但<u>如果您要按自然顺序或自定义顺序遍历键</u>，那么TreeMap会更好。如果需要<u>输出的顺序和输入的相同</u>,那么用LinkedHashMap 可以实现,它还<strong>可以按读取顺序来排列</strong>。</p><h5 id="1-1-TreeMap的底层实现？">1.1  TreeMap的底层实现？</h5><p>TreeMap实现了SotredMap接口，它是有序的集合。<strong>而且是一个红黑树结构，每个key-value都作为一个红黑树的节点</strong>。如果在调用<strong>TreeMap的构造函数时没有指定比较器，则根据key执行自然排序</strong>。这点会在接下来的代码中做说明，如<strong>果指定了比较器则按照比较器来进行排序</strong>。</p><ul><li>自然排序：TreeMap的所有key必须实现Comparable接口，所有的key都是同一个类的对象</li><li>定制排序：创建TreeMap对象传入了一个Comparator对象，该对象负责对TreeMap中所有的key进行排序，采用定制排序不要求Map的key实现Comparable接口。等下面分析到比较方法的时候在分析这两种比较有何不同。</li></ul><h4 id="2-请问HashMap和Hashtable区别？">2.<strong>请问HashMap和Hashtable区别</strong>？</h4><ul><li><strong>共同点</strong>：都实现Map接口</li><li><strong>不同点</strong>：<ol><li><strong>对Null key 和Null value的支持</strong>：HashMap<u>允许键和值是null</u>，而Hashtable不允许键或者值是null；</li><li><strong>线程安全</strong>：Hashtable是同步的线程安全，而HashMap不是；</li><li><strong>初始容量大小和每次扩充容量大小不同</strong>：  （1）创建时如果不指定容量初始值，Hashtable 默认的初始大小为<strong>11</strong>，之后每次扩充，容量变为原来的<strong>2n+1</strong>。HashMap 默认的初始化大小为<strong>16</strong>，之后每次扩充，容量变为原来的<strong>2</strong>倍 ；（2）创建时如果给定了容量初始值，那么 Hashtable 会直接使用<strong>你给定的大小</strong>，而 HashMap 会将其<strong>扩充为2的幂次方大小</strong>，也就是说 <u>HashMap 总是使用2的幂作为哈希表的大小</u>；</li><li><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表⻓度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有转换为红黑树这样的机制；</li><li><strong>继承父类</strong>：HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。</li></ol></li></ul><h4 id="3-请问Map接口实现：HashMap、Hashtable和ConcurrentHashMap区别？">3.<strong>请问Map接口实现：HashMap、Hashtable和ConcurrentHashMap区别</strong>？</h4><p>都是key-value存储形式。</p><ul><li><p><strong>底层数据结构</strong>：<code>HashMap</code>与<code>ConcurrentHashMap</code>底层数据结构相似（数组+链表+红黑树），<code>Hashtable</code>没有红黑树；</p></li><li><p><strong>线程安全</strong>：<code>Hashtable</code>的<code>synchronized</code>修饰在方法，是对象级的加锁，同一时间只有一个线程能对数据进行操作；<code>ConcurrentHashMap</code>使用了修饰具体对象的<code>synchronized</code>（锁一个桶）和CAS机制，实现了更细粒度的锁；</p></li><li><p><strong>地址计算</strong>：</p></li></ul><ul><li><code>HashMap</code>使用<code>key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16)</code>；-<ul><li><code>Hashtable</code>使用<code>(key.hashCode() &amp; 0x7fffffff) % tab.length()</code></li></ul></li><li><code>ConcurrentHashMap</code>使用<code>(key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16)) &amp; 0x7fffffff</code>。</li></ul><h4 id="4-说一说红黑树特征？">4.<strong>说一说红黑树特征</strong>？</h4><blockquote><p>紧接上个问题，面试官很有可能会问红黑树。</p></blockquote><ul><li>每个节点是黑色是红色</li><li><strong>根节点和叶子节点是黑色</strong></li><li>红色节点不能相邻</li><li>从一个节点到子孙节点路径上相同数目的黑节点</li></ul><p><img src="https://i.loli.net/2021/05/05/yismA9xYt5MEeFw.png" alt="image-20210505132113159"></p><h4 id="5-hashmap的基本原理，扩容方式（rehash）？">5. <strong>hashmap的基本原理，扩容方式（rehash）</strong>？</h4><blockquote><p>很棒的一篇文章：<a href="https://www.jianshu.com/p/dde9b12343c1">https://www.jianshu.com/p/dde9b12343c1</a></p><p>更棒的一篇文章：<a href="https://zhuanlan.zhihu.com/p/81587796">https://zhuanlan.zhihu.com/p/81587796</a></p></blockquote><ul><li><p><code>HashMap定义</code></p><p>HashMap继承了Map端口，实现了Serializable等接口。存储HashMap的是一个Entry[]数组，Entry是一个单向链表：</p><blockquote><p>所以我们说HashMap实现的是一个<code>数组+链表</code> 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li><li><p><code>Entry类</code></p><p>Entry在HashMap中实现为一个静态内部类，封装了key和value，还有<u>类型为Entry的next指向下一个Entry引用</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       V value;</span><br><span class="line">       Entry&lt;K,V&gt; next;</span><br><span class="line">       <span class="keyword">int</span> hash;</span><br></pre></td></tr></table></figure></li><li><p><code>图解HashMap</code></p><p>根据前面所知，我们可以得到HashMap的实现如下（默认初始化容量为16）：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/4843132-05b3a55bd2686dd3.png" alt="img"></p></li><li><p><code>put方法实现</code></p><ol><li><p>输入的<code>key</code>根据<code>hash(key)</code> 计算出hash值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 对key为null的处理</span></span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="comment">// 根据key算出hash值</span></span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br></pre></td></tr></table></figure><ul><li><p><strong>hash方法如下（JDK1.8版本</strong>）</p><p>下面这段代码也叫<strong>扰动函数</strong> ，参考：<a href="https://www.zhihu.com/question/20733617">JDK 源码中 HashMap 的 hash 方法原理是什么？</a></p><p><img src="https://i.loli.net/2021/05/15/OZT8G6PdxkAtQVi.png" alt="img"></p><p>混合原始哈希码的高位和低位，以此来加大低位的随机性 。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"><span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line"><span class="comment">// ^ ：按位异或</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt;⽆符号右移，忽略符号位，空位都以0补⻬</span></span><br><span class="line"><span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相⽐于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差⼀点点，因为毕竟扰动了 4 次。</p></li><li><p><strong>Object类HashCode实现</strong></p><blockquote><p>详细源码分析参考 ：<a href="https://juejin.cn/post/6844903487432556551">Java Object.hashCode()返回的是对象内存地址？</a></p></blockquote><p>JDK8 的<strong>默认</strong>hashCode的计算方法是通过和当前线程有关的<strong>一个随机数+三个确定值</strong>，运用Marsaglia’s xorshift scheme随机数算法得到的一个随机数 。</p><p>可以通过在JVM启动参数中添加<code>-XX:hashCode=4</code>，<u>改变默认的hashCode计算方式</u>：</p><ul><li>hashCode == 0 ：返回一个Park-Miller伪随机数生成器生成的随机数 ，OpenJdk 6 &amp;7的默认实现；</li><li>hashCode == 1：此类方案将对象的内存地址，做移位运算后与一个随机数进行异或得到结果 ；</li><li>hashCode == 2：此类方案返回固定的1；</li><li>hashCode == 3：此类方案返回一个自增序列的当前值；</li><li>hashCode == 4：此类方案返回当前对象的内存地址。</li></ul></li></ul></li><li><p>根据<code>indexFor(hash, table.length)</code> ，计算在table中下标</p><p><code>key.hashcode得到hash → 经过高低16异或扰动得到行hash →  indexFor计算下标</code></p><blockquote><p><code>indexFor()</code>  实际就是hash值取余：<code>hash%(table.lenght-1)</code> 。但在具体实现中通过位运算实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><strong>计算原理</strong>。 顺便说一下，这也正好解释了<strong>为什么HashMap的数组长度要取2的整次幂</strong>。因为这样（数组长度-1）正好相当于一个<strong>低位掩码</strong>。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是<strong>截取了最低的四位值</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">          10100101 11000100 00100101</span><br><span class="line">&amp;         00000000 00000000 00001111 （16）</span><br><span class="line">------------------------------------------</span><br><span class="line">          00000000 00000000 000000101</span><br></pre></td></tr></table></figure></li><li><p><strong>位运算要求<code>length</code> 一定是偶数</strong>。<code>length-1</code>则一定是奇数。 这样<code>h &amp; (length-1)</code>进行位运算出现的结果可奇可偶，不会一直是偶数，浪费奇数空间。而length为2的幂次，可以保证length一定是偶数，<strong>这也是扩容为什么要求一定是2的幂次</strong>。</p></li></ul></li><li><p><u>遍历table中下标为i的Entry单向链表</u>，找是否有相同的key已经在HashMap中，如果有，就替换value为最新的值；没有就直接插入。所以HashMap中只能存储唯一的key。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="comment">// 先判断hash值是否一样，如果一样，再判断key是否一样</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果是第一次put上面<code>for</code>循环不会执行，而是<code>addEntry</code>方法直接把key和value封装成Entry，然后加入到table中的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modCount++;</span><br><span class="line">addEntry(hash, key, value, i);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>这涉及到HashMap的<strong>扩容机制</strong>。</p></li></ol></li><li><p><code>扩容机制</code></p><blockquote><p>当HashMap中存储的元素个数达到扩容的阀值 ，那如何进行扩容？</p></blockquote><blockquote><p>⚠️ 在jdk1.8版本以后，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><img src="https://i.loli.net/2021/05/04/PoScN7yntJRhFvd.png" alt="在这里插入图片描述" style="zoom: 50%;" /></blockquote><p>我们再来看看addEntry方法中的扩容相关代码：</p><ul><li>扩容就是通过<code>resize()</code>方法创建一个长度为原来<strong>2</strong>倍的新table ；</li><li><code>resize()</code>方法内部通过遍历的方式，将老table的数据，重新计算hash并存储到新table的适当位置，最后使用新的table，并重新计HashMap的扩容阀值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">      <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">      <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">          threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">     <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">     transfer(newTable);     </span><br><span class="line">     <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">     table = newTable;  </span><br><span class="line">     <span class="comment">//修改阈值</span></span><br><span class="line">     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure><p>transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">      Entry[] src = table;                   </span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                  <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                  <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">                 e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                 newTable[i] = e; <span class="comment">//将元素放在数组上</span></span><br><span class="line">                 e = next; <span class="comment">//访问下一个Entry链上元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式 。下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p><p><img src="https://i.loli.net/2021/05/15/nCYJf3KPqBdEU4G.png" alt="image-20210515115619336"></p></li><li><p><code>get方法实现</code></p><p>用key的hash值算出key对应的Entry所在链表在在table的下标，然后遍历下标即可。</p><img src="4843132-9b5f706433247a6c.webp" alt="img" style="zoom:80%;"/></li></ul><h5 id="5-1-为什么HashMap默认链表长度超过8转为红黑树，而不是6、7或9？">5.1 为什么HashMap默认链表长度超过8转为红黑树，而不是6、7或9？</h5><ul><li><p>在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为 8 的时候，概率仅为 0.00000006。源码中注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line"><span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line"><span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line"><span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line"><span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line"><span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line"><span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line"><span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line"><span class="number">8</span>:    <span class="number">0.00000006</span></span><br><span class="line">more: less than <span class="number">1</span> in ten million</span><br></pre></td></tr></table></figure><p>这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。</p></li><li><p>特别的，默认是链表长度达到 8 就转成红黑树，而当长度降到 6 就转换回去，这体现了时间和空间平衡的思想。<strong>长度较小时，使用链<u>表空间占用少</u>，时间也不会长（因为链表短</strong>）。</p></li></ul><h5 id="5-2-HashMap-多线程操作导致死循环问题？">5.2  HashMap 多线程操作导致死循环问题？</h5><p><strong>总结</strong>： HashMap之所以在并发下的扩容造成死循环，是因为，多个线程并发进行时，<strong>因为一个线程先期完成了扩容</strong>，将原的链表重新散列到自己的表中，并且链表变成了<strong>倒序</strong>，后一个线程再扩容时，又进行自己的散列，再次将<strong>倒序链表变为正序链表</strong>，于是形成了一个环形链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">      Entry[] src = table;                   </span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              src[j] = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                  Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                  <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">               <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">               e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">               newTable[i] = e;    <span class="comment">//将元素放在数组上</span></span><br><span class="line">                e = next;    <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li><p>map初始化为一个长度为2的数组，loadFactor=0.75，<code>threshold=2*0.75</code>=1，也就是说当put第二个key的时候，map就需要进行resize。</p></li><li><p>设置断点让线程1和线程2同时debug到transfer方法的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p><p><img src="https://i.loli.net/2021/05/15/9wiAnOHdBe7hjLs.png" alt="image-20210515120319361"></p></li><li><p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，<strong>指向了线程二重组后的新链表</strong>。</p></li><li><p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p><p><img src="https://i.loli.net/2021/05/15/NFfwAOguQmsyeWh.png" alt="image-20210515120436107"></p></li><li><p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p><p><img src="https://i.loli.net/2021/05/15/ApClYedO6JTWmnx.png" alt="image-20210515120503570"></p></li></ol><h5 id="5-3-说说HashMap的put方法？">5.3 说说HashMap的put方法？</h5><p>根据key值计算在数组中的位置：</p><ul><li>如果定位到的数组位置没有元素 就直接插入；</li><li>如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，<u>依次和插入的 key 比较，如果 <strong>hash值&amp;equals对象相同</strong>就直接<strong>覆盖</strong>，<strong>不同</strong>就采用<strong>头插法</strong>插入元素</u>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//table[i]的位置已经存在元素，遍历链表</span></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;    </span><br><span class="line">    Object k;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用 equals 方法判断key是否相等，若相等，该key对应的键值对已经存在，用新的value取代旧的value</span></span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;    </span><br><span class="line">        V oldValue = e.value;    </span><br><span class="line">        e.value = value;    </span><br><span class="line">        e.recordAccess(<span class="keyword">this</span>);    </span><br><span class="line">        <span class="keyword">return</span> oldValue;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h5 id="5-4-说说HashMap的get方法？"><strong>5.4 说说HashMap的get方法</strong>？</h5><p>根据key值计算在数组中的位置：</p><ul><li>遍历链表或者在红黑树，比较key来获取value</li></ul><h5 id="5-5-【百度】rehash扩容时机？在插入前还是插入后？">5.5 【百度】rehash扩容时机？在插入前还是插入后？</h5><p>rehash过程在put函数中，其大致扩容时机如下：</p><ol><li><p>计算hash，定位到桶；且遍历桶外挂链表，如果有相同key则覆盖；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)  <span class="comment">// 【百度】怎么处理key或value为NULL的情况？</span></span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);<span class="comment">//计算键的hash值</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//通过hash值对应到桶位置</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;<span class="comment">//顺序遍历桶外挂的单链表</span></span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;/</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);<span class="comment">//遍历单链表完毕，没有找到与键相对的Entry，需新建一个Entry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>【如果没有找到相同key，说明要插入一个新entry】</strong> ，执行addEntry，<strong>插入前</strong>先验证下是否扩容；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * table.length);<span class="comment">//将容量扩容为原来的2倍</span></span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);<span class="comment">//扩容后的，该hash值对应的新的桶位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);<span class="comment">//在指定的桶位置上，创建一个新的Entry</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);<span class="comment">//链表的头插法插入新建的Entry</span></span><br><span class="line">        size++;<span class="comment">//更新size</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>因此总结扩容时机如下：</p><ul><li>在执行put时，如果遍历指定桶外挂链表<strong>没有找到相同key</strong>的节点时，说明需要<strong>新建一个entry</strong>，这个时候在<strong>插入前</strong>验证下是否要扩容。</li></ul><h5 id="5-6-hashmap在1-7版本之前为什么使用头插法？">5.6 hashmap在1.7版本之前为什么使用头插法？</h5><blockquote><p>1.7版本之前采用头插法，1.8之后采用尾插法。</p></blockquote><p><strong>头插法</strong>会改变链表中元素原本的顺序，以至于在并发场景下<strong>导致链表成环</strong>的问题；而<strong>尾插法</strong>，在扩容时<strong>会保持链表元素原本的顺序</strong>，就不会出现链表成环的问题 。</p><blockquote><p>既然有多线程并发问题，那为什么1.8之前还要使用头插法？</p></blockquote><ol><li><strong>局部性原理</strong>： 最近访问过的数据下次大概率会再次访问，把刚访问过的元素<strong>放在链表最前面</strong>可以直接被查询到，减少查找次数</li><li><strong>不是为了适应多线程而设计</strong>：　只有在并发情况下，头插法才会出现链表成环的问题，多线程情况下，HashMap 本就非线程安全，这就<strong>相当于你在它的规则之外</strong>出了问题。</li></ol><h5 id="5-7-为什么-HashMap-的负载因子设置成-0-75，而不是-1-也不是-0-5？">5.7 <strong>为什么 HashMap 的负载因子设置成 0.75，而不是 1 也不是 0.5？</strong></h5><p>在 HashMap 中，临界值（threshold） = 负载因子（loadFactor） * 容量（capacity）。</p><p><strong>那么如何能有效的避免哈希碰撞呢</strong>？</p><p>我们先反向思维一下，你认为什么情况会导致 HashMap 的哈希碰撞比较多？</p><p>无外乎两种情况：</p><ol><li><p>容量太小。容量小，碰撞的概率就高了。狼多肉少，就会发生争抢。</p></li><li><p>hash 算法不够好。算法不合理，就可能都分到同一个或几个桶中。分配不均，也会发生争抢。</p></li></ol><p><strong>为了避免哈希碰撞，HashMap 需要在合适的时候进行扩容</strong>。那就是当其中的元素个数达到临界值的时候（<strong>等全满了再扩容，那么在此之前容量太少，导致碰撞的概率过高</strong>），而这个临界值前面说过和 loadFactor 有关，换句话说，<strong>设置一个合理的 loadFactor</strong>，可以有效的避免哈希冲突。</p><blockquote><p>JVM中原话：</p><p><strong>一般来说，默认的负载因子 (0.75) 在时间和空间成本之间提供了很好的权衡。更高的值减少了空间开销，但增加了查找成本(反映在 HashMap 类的大多数操作中，包括 get 和 put)</strong>。</p><p>另一方面，<strong>为了保证负载因子（loadFactor） * 容量（capacity）的结果是一个整数，这个值是 0.75(3/4) 比较合理，因为这个数和任何 2 的幂乘积结果都是整数</strong>。</p></blockquote><h5 id="5-8-Hashmap-怎么处理key和value为null的情况？">5.8 Hashmap 怎么处理key和value为null的情况？</h5><h4 id="6-Hashtable-源码分析">6. Hashtable 源码分析</h4><blockquote><p>参考：<a href="https://juejin.cn/post/6844903509725282317">Java集合之Hashtable源码解析</a></p></blockquote><ul><li><p><strong>构造函数</strong></p><p>和HashMap还是挺相似的，但是默认初始容量是11（HashMap是16）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;<span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;<span class="comment">//键值对的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;<span class="comment">//阀值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> loadFactor;<span class="comment">//加载因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;<span class="comment">//修改次数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;<span class="comment">//下面的三个构造函数都是调用这个函数，来进行相关的初始化</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">            initialCapacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[initialCapacity];<span class="comment">//这里是与HashMap的区别之一，HashMap中table</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">        initHashSeedAsNeeded(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;<span class="comment">//指定初始数组长度</span></span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;<span class="comment">//从这里可以看出容量的默认值为16，加载因子为0.75f.</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">        putAll(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>put方法</strong></p><p>和HashMap整体过程依旧很像，但有4点注意：</p><ol><li><p>put方法是加锁synchronized，所以线程安全</p></li><li><p>Hashtable计算hash值的hash(key)，不允许为null，所以会抛出异常</p></li><li><p>获取数组散列的下标 <code>(hash &amp; 0x7FFFFFFF) % tab.length</code> 和HashMap <code>hash &amp; length-1</code> 不同</p><blockquote><ul><li><code>(hash &amp; 0x7FFFFFFF) % tab.length</code>  是（1）<code>hash &amp; 0x7FFFFFFF</code>  保证hash是正数 （2）然后取余</li><li>相比之下，HashMap是位运算进行了优化，更高效</li></ul></blockquote></li><li><p>Hashtable没有链表转红黑树的机制</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;<span class="comment">//这里方法修饰符为synchronized,所以是线程安全的。</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();<span class="comment">//value如果为Null,抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        Entry tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);<span class="comment">//hash里面的代码是hashSeed^key.hashcode（）,null.hashCode（）会抛出异常，所以这就解释了Hashtable的key和value不能为null的原因。</span></span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;<span class="comment">//获取数组元素下标,先对hash值取正，然后取余。</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                V old = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;<span class="comment">//修改次数。</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;<span class="comment">//键值对的总数大于其阀值</span></span><br><span class="line">            rehash();<span class="comment">//在rehash里进行扩容处理</span></span><br><span class="line"></span><br><span class="line">            tab = table;</span><br><span class="line">            hash = hash(key);</span><br><span class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>rehash方法（扩容</strong>）</p><p>和HashMap依旧很像，但是扩容每次是 <code>old*2+1</code> 。</p></li><li><p><strong>get方法</strong></p><p>也是相比Hashmap直接加了 synchronized 进行修饰，保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;<span class="comment">//没有什么特殊性，就是加了一个synchronized，就是根据index来遍历索引处的单链表。</span></span><br><span class="line">       Entry tab[] = table;</span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">               <span class="keyword">return</span> e.value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="6-1-（容易忘）HashMap-和-Hashtable-的区别-？">6.1 （容易忘）HashMap <strong>和</strong> Hashtable <strong>的区别</strong> ？</h5><ol><li><p><strong>关于null</strong>，HashMap允许key和value都可以为null，而Hashtable则不接受key为null或value为null的键值对。</p></li><li><p><strong>关于线程安全</strong>，HashMap是线程不安全的，Hashtable是线程安全的，因为Hashtable的许多操作函数都用synchronized修饰。</p></li><li><p><strong>Hashtable与HashMap实现的接口不一致</strong>，但Hashtable继承Dictionary，而HashMap继承自AbstractMap，即父类不同</p></li><li><p><strong>默认初始容量不同</strong>，扩容大小不同。HashMap的hash数组的默认大小是16，而且一定是2 的指数<code>old*2</code>；Hashtable中hash数组默认大小是11，增加的方式是<code>old*2+1</code>。</p></li></ol><h5 id="6-2-ConcurrentHashMap-和-Hashtable-的区别-？">6.2 ConcurrentHashMap <strong>和</strong> Hashtable <strong>的区别</strong> ？</h5><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用<strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构⼀样，数组+链表/红黑⼆叉树。Hashtable 和 JDK1.8 之前的HashMap 的底层数据结构类似都是采用<strong>数组+链表/红黑树</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要</strong>）： ①<strong>在JDK1.7</strong>的时候ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提高并发访问率。<strong>到JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和CAS 来操作</strong>。（JDK1.6以后 对 synchronized锁做了很多优化） <u>整个看起来就像是优化过且线程安全的 HashMap</u>，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同⼀把锁，全表锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当⼀个线程访问同步方法时，其他线程也访问同步方法，可能会进⼊阻塞或轮询状态，如使用 put 添加元素，另⼀个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><h4 id="7-ConcurrentHashMap线程安全的具体实现方式-底层具体实现-？">7.  ConcurrentHashMap<strong>线程安全的具体实现方式</strong>/<strong>底层具体实现</strong> ？</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/huangjuncong/p/9478505.html">https://www.cnblogs.com/huangjuncong/p/9478505.html</a></p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ConcurrentHashMap%E6%BA%90%E7%A0%81%2B%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.md">javaGuide</a></p></blockquote><p>Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p><p>Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p><ul><li><p><strong>JDK 1.7 实现</strong></p><p>Java 7 中 ConcurrentHashMap 的存储结构如下图。</p><img src="https://i.loli.net/2021/05/15/iT9npPGIdazS4vw.png" alt="img" style="zoom:150%;" /><ul><li><p><strong>存储结构</strong></p><p>ConcurrentHashMap 为了提高本身的并发能力，在内部采用了一个叫做 Segment 的结构，<strong>一个 Segment 其实就是一个类 HashTable 的结构</strong>，Segment 内部维护了一个链表数组。</p><blockquote><p><strong>两次Hash</strong>。ConcurrentHashMap 定位一个元素的过程需要进行两次Hash操作，第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部。</p><p>因此，这一种结构的带来的副作用是 Hash 的过程要比普通的 HashMap 要长，但是带来的好处是写操作的时候可以只对元素所在的 Segment 进行操作即可，不会影响到其他的 Segment。</p></blockquote><p><strong>1. ConcurrentHashMap的成员变量和构造函数</strong></p><blockquote><p><strong>ConcurrentHashMap扩容</strong>： 元素数量增加导致ConrruentHashMap需要扩容，ConcurrentHashMap不会增加Segment的数量，而<strong>只会增加Segment中链表数组的容量大小</strong>。 需要对整个ConcurrentHashMap做rehash，而只需要对Segment里面的元素做一次rehash就可以了。</p></blockquote><p>核心初始化函数逻辑如下：</p><blockquote><p>2的指数是为了可以使用移位操作加快hash计算过程。</p></blockquote><ol><li><p>计算出Segment的数量<code>ssize</code>，是不大于concurrencyLevel的最大的2的指数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">          ++sshift; </span><br><span class="line">           ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据intialCapacity确定Segment的容量的大小，每一个Segment的容量大小也是2的指数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">      ++c;</span><br><span class="line">      <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">      <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ol><p>下面是完整代码：</p><blockquote><ul><li>segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到 <strong>。默认是 32 - sshift = 28</strong></li><li>segmentMask，默认是 ssize - 1 = 16 -1 = 15</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 默认segment层级</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// segment最小容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 一个segment最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 锁之前重试次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数：无参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数：指定初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数：指定初始容量，负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数：指定初始容量，负载因子，并发级别</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">        <span class="comment">// 找到两种大小的最匹配参数</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// segment数组的长度是由concurrentLevel计算来的，segment数组的长度是2的N次方，</span></span><br><span class="line">        <span class="comment">// 默认concurrencyLevel = 16, 所以ssize在默认情况下也是16,此时 sshift = 4</span></span><br><span class="line">        <span class="comment">// sshift相当于ssize从1向左移的次数</span></span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift; </span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 段偏移量，默认值情况下此时segmentShift = 28</span></span><br><span class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">        <span class="comment">// 散列算法的掩码，默认值情况下segmentMask = 15</span></span><br><span class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// create segments and segments[0]</span></span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">            <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                             (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">        <span class="comment">// 创建ssize长度的Segment数组</span></span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">        <span class="keyword">this</span>.segments = ss;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>2.来查看具体代码定义，Segment的成员变量</strong>：</p><blockquote><p>Segment 继承于 ReentrantLock，不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;    <span class="comment">//Segment中元素的数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;      <span class="comment">//对table的大小造成影响的操作的数量(比如put或者remove操作)</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;    <span class="comment">//阈值,Segment里面元素的数量超过这个值那么就会对Segment进行扩容</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;   <span class="comment">//负载因子,用于确定threshold</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;    <span class="comment">//链表数组,数组中的每一个元素代表了一个链表的头部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 继续查看HashEntry组成</strong>：</p><blockquote><p>和 HashMap 非常类似，唯一的区别就是其中的核心数据如 <strong>value ，以及链表都是 volatile 修饰的</strong>，保证了获取时的可见性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    　<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ConcurrentHashMap列表Entry。注意，这不会作为用户可见的Map.Entry导出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">    </span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置具有volatile写语义的next字段。</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(HashEntry&lt;K,V&gt; n)</span> </span>&#123;</span><br><span class="line">      UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面不太重要，略。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>put() 方法实现</strong></p><blockquote><p>相比Hashtable，1.7版本concurrentHashmap的更加细粒度，只有定位到段，才会锁住。也就是段锁！</p><p>而Hashtable直接锁住整个方法。</p></blockquote><ol><li><p>计算key的hash值 ;</p></li><li><p>根据<strong>hash值，segmentShift，segmentMask定位到哪个Segment</strong>；</p></li><li><p>如果指定位置的 Segment 为空，则初始化这个 Segment；</p></li><li><p>在对应的 Segment 中进行具体的 put。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span></span><br><span class="line">    <span class="comment">// 其实也就是把高4位与segmentMask（1111）做与运算</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        <span class="comment">// 如果查找到的 Segment 为空，初始化</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Segment 中进行具体的 put的源码如下：</p><blockquote><p>判断元素个数是否超过了阈值或者segment中数组的长度超过了MAXIMUM_CAPACITY，如果满足条件则rehash扩容！</p></blockquote><p>由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p><ol><li><p>tryLock() 获取锁，获取不到使用<code>scanAndLockForPut</code>方法继续获取；</p><blockquote><p>这里面的第一步中的 scanAndLockForPut 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。</p></blockquote></li><li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry ；</p></li><li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待；</p><p>如果这个位置上的 <strong>HashEntry 不存在</strong>：</p><ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接<strong>头插法</strong>插入。</li></ol><p>如果这个位置上的 <strong>HashEntry 存在</strong>：</p><ol><li>判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致，<strong>一致则替换值</strong></li><li>不一致，<u>获取链表下一个节点</u>，直到发现相同进行值替换，或者链表表里完毕没有相同的。<ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接链表<strong>头插法</strong>插入。</li></ol></li></ol></li><li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 计算要put的数据位置</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// CAS 获取 index 坐标的值</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>扩容 rehash</strong></p><blockquote><p>rehash在put()内部被触发。</p></blockquote><p>ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，<strong>位置要么不变，要么变为 index+ oldSize</strong>，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> idx = e.hash &amp; sizeMask;  <span class="comment">// 新位置计算</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="comment">// 老容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 新容量，扩大两倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 新的扩容阀值 </span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新的数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历老数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算新的位置，新的位置只可能是不变或者是：老的位置+老的容量。</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                <span class="comment">// 如果当前位置还不是链表，只是一个元素，直接赋值</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// 如果是链表了</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">// 新的位置只可能是不变或者是：老的位置+老的容量。</span></span><br><span class="line">                <span class="comment">// 遍历结束后，lastRun 后面的元素位置都是相同的</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="keyword">null</span>; last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    <span class="comment">// 遍历剩余元素，头插法到指定 k 位置。</span></span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头插法插入新的节点</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>get方法</strong></p><blockquote><p>注意，Hashtable 会使用Synchronized进行修饰，所以不支持并发。但是ConcurrentHashmap <strong>没有使用同步机制</strong>：</p><ul><li>1.7版本 <strong>。使用unsafe方法（）等方式直接操作来保证并发处理的安全性</strong>，使用的是硬件的安全机制。</li><li>1.8版本。没有使用同步，也没有使用unsafe方式。所以<strong>是并发</strong>的。</li></ul></blockquote><ul><li><p>到这里就很简单了，get 方法只需要两步即可。</p><ol><li>计算得到segment的位置 u</li><li><strong>CAS方式获取segment数组对象 segment[u]</strong></li><li>计算HashEntry数组的下标 i</li><li><strong>CAS方式获取HashEntry[i]，即数组首节点</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 计算得到 key 的存放位置</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="comment">// 如果是链表，遍历查找到相同 key 的 value。</span></span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>JDK 1.8 实现</strong></p><blockquote><p>1.8版本分析，建议参考：<a href="https://www.cnblogs.com/zerotomax/p/8687425.html">https://www.cnblogs.com/zerotomax/p/8687425.html</a> 。</p></blockquote><p><img src="https://i.loli.net/2021/05/15/F6UhuXNQGKnldVk.png" alt="image-20210515224441806"></p><p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p><blockquote><p>和JDK1.8的HashMap是很相似 , 抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p></blockquote><ul><li><p><strong>存储结构和属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>; <span class="comment">// hashmap也是16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">// 超过8扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">// 超过64红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// 表示正在转移</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 表示已经转换成树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Node数组存储元素</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;<span class="comment">//默认没初始化的数组，用来保存元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<span class="comment">//转移的时候用的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来控制表初始化和扩容的，默认值为0，当在初始化的时候指定了大小，这会将这个大小保存在sizeCtl中，大小为数组的0.75</span></span><br><span class="line"><span class="comment">     * 当为负的时候，说明表正在初始化或扩张，</span></span><br><span class="line"><span class="comment">     *     -1表示初始化</span></span><br><span class="line"><span class="comment">     *     -(1+n) n:表示活动的扩张线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在ConcurrentHashMap中使用了unSafe方法，通过直接操作内存的方式来保证并发处理的安全性，使用的是硬件的安全机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用来返回节点数组的指定位置的节点的原子操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * cas原子操作，在指定位置设定值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 原子操作，在指定位置设定值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">        U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMapDebug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果在实例化对象的时候指定了容量，则初始化sizeCtl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMapDebug</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当出入一个Map的时候，先设定sizeCtl为默认容量，在添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMapDebug</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>put方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>再来看putVal ：</p><blockquote><p>可以发现相比HashTable直接对方法进行加锁synchronized / 1.7版本的ConcurrentHashMap 进入的开头尝试获取锁，1.8版本的ConcurrentHashMap 锁更加细粒度化。</p><ul><li>只有：（1）table不为初始化 （2）定位到table位置<code>i</code>不存在元素（此时会用CAS方式进行添加）（3）数组也没有在进行扩张（MOVED=-1）</li></ul><p>此时才会进行synchronized 添加元素（不会锁住rehash方法，最后才判断是否扩容）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当添加一对键值对的时候，首先会去判断保存这些键值对的数组是不是初始化了，</span></span><br><span class="line"><span class="comment">     * 如果没有的话就初始化数组</span></span><br><span class="line"><span class="comment">     *  然后通过计算hash值来确定放在数组的哪个位置</span></span><br><span class="line"><span class="comment">     * 如果这个位置为空则直接添加，如果不为空的话，则取出这个节点来</span></span><br><span class="line"><span class="comment">     * 如果取出来的节点的hash值是MOVED(-1)的话，则表示当前正在对这个数组进行扩容，复制到新的数组，则当前线程也去帮助复制</span></span><br><span class="line"><span class="comment">     * 最后一种情况就是，如果这个节点，不为空，也不在扩容，则通过synchronized来加锁，进行添加操作</span></span><br><span class="line"><span class="comment">     *    然后判断当前取出的节点位置存放的是链表还是树</span></span><br><span class="line"><span class="comment">     *    如果是链表的话，则遍历整个链表，直到取出来的节点的key来个要放的key进行比较，如果key相等，并且key的hash值也相等的话，</span></span><br><span class="line"><span class="comment">     *          则说明是同一个key，则覆盖掉value，否则的话则添加到链表的末尾</span></span><br><span class="line"><span class="comment">     *    如果是树的话，则调用putTreeVal方法把这个元素添加到树中去</span></span><br><span class="line"><span class="comment">     *  最后在添加完成之后，会判断在该节点处共有多少个节点（注意是添加前的个数），如果达到8个以上了的话，</span></span><br><span class="line"><span class="comment">     *  则调用treeifyBin方法来尝试将处的链表转为树，或者扩容数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();<span class="comment">//K,V都不能为空，否则的话跑出异常</span></span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());    <span class="comment">//取得key的hash值</span></span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;    <span class="comment">//用来计算在这个节点总共有多少个元素，用来控制扩容或者转移为树</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;    <span class="comment">//</span></span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)    </span><br><span class="line">                tab = initTable();    <span class="comment">//第一次put的时候table没有初始化，则初始化table</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;    <span class="comment">//通过哈希计算出一个表中的位置因为n是数组的长度，所以(n-1)&amp;hash肯定不会出现数组越界</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,        <span class="comment">//如果这个位置没有元素的话，则通过cas的方式尝试添加，注意这个时候是没有加锁的</span></span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))        <span class="comment">//创建一个Node添加到数组中区，null表示的是下一个节点为空</span></span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果检测到某个节点的hash值是MOVED，则表示正在进行数组扩张的数据复制阶段，</span></span><br><span class="line"><span class="comment">             * 则当前线程也会参与去复制，通过允许多线程复制的功能，一次来减少数组的复制所带来的性能损失</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)    </span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果在这个位置有元素的话，就采用synchronized的方式加锁，</span></span><br><span class="line"><span class="comment">                 *     如果是链表的话(hash大于0)，就对这个链表的所有元素进行遍历，</span></span><br><span class="line"><span class="comment">                 *         如果找到了key和key的hash值都一样的节点，则把它的值替换到</span></span><br><span class="line"><span class="comment">                 *         如果没找到的话，则添加在链表的最后面</span></span><br><span class="line"><span class="comment">                 *  否则，是树的话，则调用putTreeVal方法添加到树中去</span></span><br><span class="line"><span class="comment">                 *  </span></span><br><span class="line"><span class="comment">                 *  在添加完之后，会对该节点上关联的的数目进行判断，</span></span><br><span class="line"><span class="comment">                 *  如果在8个以上的话，则会调用treeifyBin方法，来尝试转化为树，或者是扩容</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;        <span class="comment">//再次取出要存储的位置的元素，跟前面取出来的比较</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;                <span class="comment">//取出来的元素的hash值大于0，当转换为树之后，hash值为-2</span></span><br><span class="line">                            binCount = <span class="number">1</span>;            </span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;    <span class="comment">//遍历这个链表</span></span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;        <span class="comment">//要存的元素的hash，key跟要存储的位置的节点的相同的时候，替换掉该节点的value即可</span></span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)        <span class="comment">//当使用putIfAbsent的时候，只有在这个key没有设置值得时候才设置</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;    <span class="comment">//如果不是同样的hash，同样的key的时候，则判断该节点的下一个节点是否为空，</span></span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,        <span class="comment">//为空的话把这个要加入的节点设置为当前节点的下一个节点</span></span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;    <span class="comment">//表示已经转化成红黑树类型了</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,    <span class="comment">//调用putTreeVal方法，将该元素添加到树中去</span></span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)    <span class="comment">//当在同一个节点的数目达到8个的时候，则扩张数组或将给节点的数据转为tree</span></span><br><span class="line">                        treeifyBin(tab, i);    </span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);    <span class="comment">//计数，可能也会触发扩容</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>扩容<code>transfer</code></p><blockquote><p>扩容主要是通过transfer方法来进行的。</p><ul><li>只有在往map中添加元素的时候，在某一个节点的数目已经超过了8个，调用<strong>treeifyBin()</strong> 触发数组的扩容/转换为数；</li><li>使用**addCount()**添加元素数组元素，会进行判断达到了sizeCtl的数量的时候，则会调用transfer方法来进行扩容</li></ul></blockquote><ul><li><p><strong>treeifyBin()</strong></p><p>某一个节点的数目已经超过了8个，执行treeifyBin() 。</p><ol><li><p>当需要扩容的时候，调用的时候tryPresize方法</p><p>（1）<strong>tryPresize方法并没有加锁</strong>，允许多个线程进入，如果数组正在扩张，则当前线程也去帮助扩容使用<strong>transfer</strong>方法</p><p>（2）<u>transfer比较复杂还没有详细看，它里面使用的synchronized 进行单个节点处理扩容</u>  （查看上面看transfer源码）</p></li><li><p>否则synchronized进行链表转换为树</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当数组长度小于64的时候，扩张数组长度一倍，否则的话把链表转为树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;treeifyBin方\t==&gt;数组长：&quot;</span>+tab.length);</span><br><span class="line">            <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)    <span class="comment">//MIN_TREEIFY_CAPACITY 64</span></span><br><span class="line">                tryPresize(n &lt;&lt; <span class="number">1</span>);        <span class="comment">// 数组扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;    <span class="comment">//使用synchronized同步器，将该节点出的链表转为树</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;    <span class="comment">//hd：树的头(head)</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p =</span><br><span class="line">                                <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)        <span class="comment">//把Node组成的链表，转化为TreeNode的链表，头结点任然放在相同的位置</span></span><br><span class="line">                                hd = p;    <span class="comment">//设置head</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                tl.next = p;</span><br><span class="line">                            tl = p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));<span class="comment">//把TreeNode的链表放入容器TreeBin中</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>addCount()</strong></p><p>addCount也主要是调用transfer，这里主要还是寄一下transfer的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Moves and/or copies the nodes in each bin to new table. See</span></span><br><span class="line"><span class="comment">     * above for explanation.</span></span><br><span class="line"><span class="comment">     * 把数组中的节点复制到新的数组的相同位置，或者移动到扩张部分的相同位置</span></span><br><span class="line"><span class="comment">     * 在这里首先会计算一个步长，表示一个线程处理的数组长度，用来控制对CPU的使用，</span></span><br><span class="line"><span class="comment">     * 每个CPU最少处理16个长度的数组元素,也就是说，如果一个数组的长度只有16，那只有一个线程会对其进行扩容的复制移动操作</span></span><br><span class="line"><span class="comment">     * 扩容的时候会一直遍历，知道复制完所有节点，没处理一个节点的时候会在链表的头部设置一个fwd节点，这样其他线程就会跳过他，</span></span><br><span class="line"><span class="comment">     * 复制后在新数组中的链表不是绝对的反序的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)    <span class="comment">//MIN_TRANSFER_STRIDE 用来控制不要占用太多CPU</span></span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range    //MIN_TRANSFER_STRIDE=16</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果复制的目标nextTab为null的话，则初始化一个table两倍长的nextTab</span></span><br><span class="line"><span class="comment">         * 此时nextTable被设置值了(在初始情况下是为null的)</span></span><br><span class="line"><span class="comment">         * 因为如果有一个线程开始了表的扩张的时候，其他线程也会进来帮忙扩张，</span></span><br><span class="line"><span class="comment">         * 而只是第一个开始扩张的线程需要初始化下目标数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 创建一个fwd节点，这个是用来控制并发的，当一个节点为空或已经被转移之后，就设置为fwd节点</span></span><br><span class="line"><span class="comment">         * 这是一个空的标志节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">        <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;    <span class="comment">//是否继续向前查找的标志位</span></span><br><span class="line">        <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep(清扫) before committing nextTab,在完成之前重新在扫描一遍数组，看看有没完成的没</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing) &#123;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                         (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="keyword">int</span> sc;</span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;        <span class="comment">//已经完成转移</span></span><br><span class="line">                    nextTable = <span class="keyword">null</span>;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);    <span class="comment">//设置sizeCtl为扩容后的0.75</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)            <span class="comment">//数组中把null的元素设置为ForwardingNode节点(hash值为MOVED[-1])</span></span><br><span class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;                <span class="comment">//加锁操作</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;        <span class="comment">//该节点的hash值大于等于0，说明是一个Node节点</span></span><br><span class="line">                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                 * 因为n的值为数组的长度，且是power(2,x)的，所以，在&amp;操作的结果只可能是0或者n</span></span><br><span class="line"><span class="comment">                                 * 根据这个规则</span></span><br><span class="line"><span class="comment">                                 *         0--&gt;  放在新表的相同位置</span></span><br><span class="line"><span class="comment">                                 *         n--&gt;  放在新表的（n+原来位置）</span></span><br><span class="line"><span class="comment">                                 */</span></span><br><span class="line">                            <span class="keyword">int</span> runBit = fh &amp; n; </span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * lastRun 表示的是需要复制的最后一个节点</span></span><br><span class="line"><span class="comment">                             * 每当新节点的hash&amp;n -&gt; b 发生变化的时候，就把runBit设置为这个结果b</span></span><br><span class="line"><span class="comment">                             * 这样for循环之后，runBit的值就是最后不变的hash&amp;n的值</span></span><br><span class="line"><span class="comment">                             * 而lastRun的值就是最后一次导致hash&amp;n 发生变化的节点(假设为p节点)</span></span><br><span class="line"><span class="comment">                             * 为什么要这么做呢？因为p节点后面的节点的hash&amp;n 值跟p节点是一样的，</span></span><br><span class="line"><span class="comment">                             * 所以在复制到新的table的时候，它肯定还是跟p节点在同一个位置</span></span><br><span class="line"><span class="comment">                             * 在复制完p节点之后，p节点的next节点还是指向它原来的节点，就不需要进行复制了，自己就被带过去了</span></span><br><span class="line"><span class="comment">                             * 这也就导致了一个问题就是复制后的链表的顺序并不一定是原来的倒序</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> b = p.hash &amp; n;    <span class="comment">//n的值为扩张前的数组的长度</span></span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 构造两个链表，顺序大部分和原来是反的</span></span><br><span class="line"><span class="comment">                             * 分别放到原来的位置和新增加的长度的相同位置(i/n+i)</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                         * 假设runBit的值为0，</span></span><br><span class="line"><span class="comment">                                         * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同为0的节点)设置到旧的table的第一个hash计算后为0的节点下一个节点</span></span><br><span class="line"><span class="comment">                                         * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">                                    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                         * 假设runBit的值不为0，</span></span><br><span class="line"><span class="comment">                                         * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同不为0的节点)设置到旧的table的第一个hash计算后不为0的节点下一个节点</span></span><br><span class="line"><span class="comment">                                         * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);    </span><br><span class="line">                            &#125;</span><br><span class="line">                            setTabAt(nextTab, i, ln);    </span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;    <span class="comment">//否则的话是一个树节点</span></span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 在复制完树节点之后，判断该节点处构成的树还有几个节点，</span></span><br><span class="line"><span class="comment">                             * 如果≤6个的话，就转回为一个链表</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>get方法</strong></p><p>get操作中，根本没有使用同步机制，<strong>也没有使用unsafe方法</strong>，所以读（get）操作是支持并发操作的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 相比put方法，get就很单纯了，支持并发操作，</span></span><br><span class="line"><span class="comment">     * 当key为null的时候回抛出NullPointerException的异常</span></span><br><span class="line"><span class="comment">     * get操作通过首先计算key的hash值来确定该元素放在数组的哪个位置</span></span><br><span class="line"><span class="comment">     * 然后遍历该位置的所有节点</span></span><br><span class="line"><span class="comment">     * 如果不存在的话返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">        <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="7-1-你知道-ConcurrentHashMap-的工作原理吗？">7.1 你知道 ConcurrentHashMap 的工作原理吗？</h5><ul><li>Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。<ul><li><strong>主要采用锁机制</strong>，在对某个Segment进行操作时，将该Segment锁定，不允许对其进行非查询操作</li></ul></li><li>Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。<ul><li><strong>CAS无锁算法</strong>，这种乐观操作在完成前进行判断，如果符合预期结果才给予执行</li></ul></li></ul><h5 id="7-2-请问ConcurrentHashMap中变量使用final和volatile修饰有什么用呢？其中链表是final的next属性，那么发生删除某个元素，如何实现的？">7.2 请问ConcurrentHashMap中变量使用final和volatile修饰有什么用呢？其中链表是final的next属性，那么发生删除某个元素，如何实现的？</h5><p>ConcurrentHashMap被final修饰的变量，（部分）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 默认segment层级</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// segment最小容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 一个segment最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 锁之前重试次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>HashEntry中被volatile修饰的部分变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="keyword">volatile</span> V value;  <span class="comment">// 保证可见性</span></span><br><span class="line">       <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure><ul><li><strong>使用final</strong>。用来实现不变模式（immutable），他是多线程安全里最简单的一种保障方式。因为你拿他没有办法，想改变它也没有机会。不变模式主要通过final关键字来限定的。在JMM中final关键字还有特殊的语义。Final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让不可变形对象不需要同步就能自由地被访问和共享。</li><li><strong>使用volatile</strong>。保证某个变量内存的改变对其他线程即时可见，在配合CAS可以实现不加锁对并发操作的支持。</li></ul><h5 id="7-3-HashTable与ConcurrentHashMap有什么区别，描述锁分段技术。">7.3 HashTable与ConcurrentHashMap有什么区别，描述锁分段技术。</h5><ul><li><strong>锁机制</strong>。 所有访问HashTable的线程都必须竞争同一把锁，效率更低；ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li><li><strong>底层数据结构</strong>。 1.8之后很相似，都是数组+链表/红黑树 ； 1.8之前，ConcurrentHashMap是Segement数组 + HashEntry数组 + 链表。</li></ul><h5 id="7-4-（阿里·淘特）ConcurrentHashMap1-8为什么不使用分段锁？">7.4 （阿里·淘特）ConcurrentHashMap1.8为什么不使用分段锁？</h5><p>先说分段锁的优点：</p><ol><li>保证在<strong>操作不同段 map</strong> 的时候<strong>可以并发执行</strong>；操作<strong>同段 map</strong> 的时候，进行<strong>锁的竞争和等待</strong>。这相<strong>对于直接对整个map同步synchronized</strong>是有优势的。</li></ol><p>但是分段锁也有一些不可忽视的缺点：</p><ol><li>分成很多段时会比较<strong>浪费内存空间</strong>(不连续，碎片化)；</li><li><strong>操作map时竞争同一个分段锁的概率非常小（段散列比较好的时候</strong>）时，分段锁反而会造成更新等操作的长时间等待；</li><li>当某个段很大时，分段锁的性能会下降。</li></ol><p>综上考虑1.8不再使用分段锁。</p><h5 id="7-5-为什么1-8中-get-方法不加锁？">7.5 为什么1.8中 get() 方法不加锁？</h5><p>因为链表每个节点的val和next都使用volatile修饰，保证了可见性。</p><h5 id="7-6-为什么1-8不使用lock而是使用sync？">7.6 为什么1.8不使用lock而是使用sync？</h5><ol><li>因为sync加入锁升级机制（jdk1.6之后），已经优化的不错了；</li><li>lock通过reentranclock实现，reentranlock是通过AQS实现，需要增加额外内存开销（CLH双向队列）。</li></ol><h5 id="7-7-ConcurrenthashMap使用的时候有可能出现不安全的情况？">7.7 ConcurrenthashMap使用的时候有可能出现不安全的情况？</h5><blockquote><p>参考：<a href="https://blog.csdn.net/luzhensmart/article/details/108133560">https://blog.csdn.net/luzhensmart/article/details/108133560</a></p></blockquote><p>查了一些资料后发现，<strong>原来ConcurrentHashMap的线程安全指的是，它的【每个方法】单独调用（即原子操作）都是线程安全的，但是代码总体的互斥性并不受控制</strong>。以上面的代码为例，最后一行中的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            this.addup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void addup() &#123;</span><br><span class="line">        if (!map.containsKey(KEY)) &#123;</span><br><span class="line">            map.put(KEY, 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.put(KEY, map.get(KEY) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>在上面一个线程内部进行了100次加法，但是其实加1在线程内部本身也并不是原子操作</strong>。</p><p>实际上并不是原子操作，它包含了三步：</p><ol><li>map.get</li><li>加1</li><li>map.put</li></ol><p>是由于在上面的代码中，map本身是一个共享变量。<strong>当线程A执行map.get的时候，其它线程可能正在执行map.put</strong>，这样一来当线程A执行到map.put的时候，线程A的值就已经是脏数据了，然后脏数据覆盖了真值，导致线程不安全。</p><h4 id="8-HashMap-和-HashSet区别-？">8. HashMap <strong>和</strong> HashSet<strong>区别</strong> ？</h4><blockquote><p>如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了clone() 、 writeObject() 、 readObject() 是 HashSet ⾃⼰不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p></blockquote><table><thead><tr><th style="text-align:center"><strong>HashMap</strong></th><th style="text-align:center"><strong>HashSet</strong></th></tr></thead><tbody><tr><td style="text-align:center">实现了Map接⼝</td><td style="text-align:center">实现Set接⼝</td></tr><tr><td style="text-align:center">存储键值对</td><td style="text-align:center">仅存储对象</td></tr><tr><td style="text-align:center">调⽤ <code>put()</code> 向map中添加元素</td><td style="text-align:center">调⽤ <code>add()</code> ⽅法向Set中添加元素</td></tr><tr><td style="text-align:center">HashMap使⽤键（Key）计算Hashcode：<code>int hash = hash(key);</code></td><td style="text-align:center">HashSet使⽤成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()⽅法⽤来判断对象的相等性。</td></tr></tbody></table><h4 id="9-说说HashSet的基本原理？">9. 说说HashSet的基本原理？</h4><ul><li><p><strong>底层结构</strong></p><p><code>HashSet</code>底层原理完全就是包装了一下<code>HashMap</code> ，只不过存储的时候<code>value</code>是默认存储了一个<code>Object</code>的静态常量，取的时候也是只返回<code>key</code>，所以看起来就像<code>List</code>一样。</p></li><li><p><strong>初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>add()方法</strong></p><p>可以看到这三个方法都是直接调用的<code>HashMap</code>的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>add其实就是调用HashMap的put方法，那么如何保证<strong>唯一性</strong>？</p></blockquote><p><strong>如果<code>哈希值</code>和<code>key</code>都一样</strong>，就会直接拿新值<strong>覆盖旧值</strong>，而<code>HashSet</code>就是利用这个特性来保证唯一性。</p><p>其实和HashMap就是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br></pre></td></tr></table></figure></li><li><p><strong>contains方法</strong>（<s>Get()方法</s> ）</p><p><strong>hashset没有get方法</strong>，因为没有意义：不需要获取某个键值对应的value。</p><p>具体实现直接调用hashmap的containsKey()方法：</p><blockquote><p>过程和hashmap的get方法过程差不多，返回为null则是不存在。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="9-1-HashSet如何检查重复-？">9. 1 HashSet<strong>如何检查重复</strong> ？</h5><ol><li>把对象加⼊ HashSet 时，HashSet先计算对象的hashcode 值；</li><li>根据hashcode值计算出要加⼊的位置，同时也会与其他加⼊的对象的hashcode值作⽐教；</li><li>如果没有相符的hashcode，HashSet会假设对象没有重复出现；</li><li><strong>如果发现有相同hashcode值的对象，这时会调用 equals()</strong> 方法来检查hashcode相等的对象是否真的相同，如果两者相同，HashSet就不会让加⼊操作成功。</li></ol><h5 id="9-2-【新】contains-方法在HashSet和ArrayList的实现区别？">9.2 【新】contains()方法在HashSet和ArrayList的实现区别？</h5><ul><li><p><strong>Arraylist</strong></p><p>因为底层是object数组，判断某个对象是否存在，其实是通过遍历来进行判断的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;<span class="comment">//#1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回指定元素在列表中第一次出现的索引，如果该列表不包含该元素，则返回-1。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Hashset</strong></p><p>Hashset是<strong>hash值 &amp;&amp; 遍历链表equals()</strong> 都相等，来判断的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-comparable-和-Comparator的区别？">10. comparable <strong>和</strong> Comparator的区别？</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/xujian2014/p/5215082.html">https://www.cnblogs.com/xujian2014/p/5215082.html</a></p></blockquote><ul><li><p>Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。</p><blockquote><p>例如Person类，实现Comparable接口，使得所有Person类对象可以按照各自年龄大小进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.age-p.getAge();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p><blockquote><p>Person类没有实现Comparable接口，该如何比较大小呢？我们可以新建一个类，让其实现Comparator接口，从而构造一个“比较器&quot;。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。。</p></li></ul><h4 id="11-如何选用集合">11. <strong>如何选用集合</strong>?</h4><p><img src="https://img-blog.csdn.net/20140630092900390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaml1cWl5dWxpYW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p><strong>需要存储键值对</strong>：</p><ul><li><strong>Map接口的集合</strong><ul><li>需要排序时选择TreeMap</li><li>不需要排序时就选择HashMap</li><li>需要保证线程安全就选⽤ConcurrentHashMap</li></ul></li></ul><p><strong>只需要存储元素，实现collection接口的集合，又分为</strong>：</p><ul><li><strong>需要保证元素唯一–Set接口的集合</strong><ul><li>HashSet</li></ul></li><li><strong>不需要元素唯一–List接口结合</strong><ul><li>查找比较多：ArrayList</li><li>增删比较多：LinkedList</li></ul></li></ul><h3 id="1-3-3-List">1.3.3 <strong>List</strong></h3><h4 id="1-用过-ArrayList-吗？说一下它有什么特点？">1.<strong>用过 ArrayList 吗？说一下它有什么特点</strong>？</h4><ul><li><strong>自动扩容</strong>： 当加入数据达到一定程度后，会实行自动扩容，即扩大数组大小 ；</li><li><strong>底层实现</strong>：底层是使用数组实现，add(int,o)，添加到某个位置，那么可能会挪动大量的数组元素，并且可能会触发扩容机制；</li><li><strong>线程不安全</strong></li></ul><h4 id="2-ArrayList-与-Vector-区别呢-为什么要用Arraylist取代Vector呢？">2. ArrayList <strong>与</strong> Vector <strong>区别呢</strong>?<strong>为什么要用</strong>Arraylist<strong>取代</strong>Vector<strong>呢</strong>？</h4><ul><li><p><strong>线程安全</strong>： Vector线程安全，ArrayList 不是；</p></li><li><p><strong>Vector耗时</strong>：Vector 类的所有方法都是同步的。可以由两个线程安全地访问⼀个Vector对象、但是⼀个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p></li></ul><h4 id="3-Array-ArrayList不同点">3. Array &amp; ArrayList不同点?</h4><ol><li><strong>Array可以包含基本类型和对象类型</strong>，<strong>ArrayList只能包含对象类型</strong> ；</li><li>Array大小是固定的，ArrayList的大小是 <u>动态变化</u> 的 ；</li><li>ArrayList提供了更多的方法和特性: addAll()，removeAll()，iterator()。</li></ol><h4 id="4-Arraylist-与-LinkedList-区别">4. Arraylist <strong>与</strong> LinkedList <strong>区别</strong>?</h4><ul><li><p><strong>索引/插入</strong>：ArrayList按序号索引，索引快插入慢；LinkedList不是，索引慢，插入快；</p></li><li><p><strong>内存方面</strong>： Arraylist 是线性连续存储， 内存利用更低；LinkedList 是链表，内存利用更高（将内存零散空间串联），但也更占有内存（每个节点存储了两个引用）；</p></li><li><p><strong>线程安全</strong>： ArrayList 和 LinkedList 都是不同步的，也就是<strong>都不</strong>保证线程安全；</p></li><li><p><strong>底层数据结构</strong>： Arraylist 底层使用的是 <strong>Object</strong>数组； LinkedList  底层使用的是<strong>双向链表</strong> 数据结构 ；</p><blockquote><p>JDK1.6之前为循环链表，JDK1.7取消了循环。</p></blockquote></li></ul><h4 id="5-【-u-源码解读-u-】说说ArrayList的扩容机制吧-？为什么是扩容1-5倍？默认大小是多少。">5. 【<u>源码解读</u>】说说ArrayList的扩容机制吧 ？为什么是扩容1.5倍？默认大小是多少。</h4><blockquote><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81%2B%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90.md">逐源码分析扩容机制</a></p></blockquote><p>先把回答写在下面：</p><blockquote><p><strong>ArrayList/vector默认大小都是10，但vectot扩容是2倍</strong>。</p></blockquote><p><strong>1. 扩容机制</strong>：</p><p>使用无参构造函数创建的数组长度为0，当第一次add后数组长度为10 ； 如果继续add超过10后，也就是不满足<strong>minCapacity（最小需要容量） - elementData.length &gt; 0</strong> 会触发扩容机制。 将新容量更新为旧容量的1.5倍 ，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】。</p><p>最后检查设置的新容量是否大于最大容量MAX_ARRAY_SIZE ，进入<code>hugeCapacity()</code> :</p><ul><li>如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code> 。</li></ul><p><strong>2. 为什么是1.5倍</strong>？</p><p>因为，<strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)，所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同。</p><p>比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数。</p><ul><li><p><strong>ArrayList总览</strong></p><p><code>ArrayList</code>继承于<strong>AbstractList</strong> ，实现了<strong>List</strong>,<strong>RandomAccess</strong>,<strong>Cloneable</strong>,<strong>java.io.Serializable</strong> 这些接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问；</li><li><code>ArrayList</code> 实现了<strong>Cloneable 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆；</li><li><code>ArrayList</code> 实现了 <code>java.io.Serializable </code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li></ul></li><li><p><strong>ArrayList 核心源码解读（先耐心看一遍</strong>）</p><p>直接点击上面链接 <a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81%2B%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90.md">逐源码分析扩容机制</a> 查看。</p></li><li><p><strong>【重点】JDK8 <u>扩容机制</u> 解读</strong></p><ol><li><p><strong>从构造函数说起</strong></p><p>（JDK8）ArrayList 有三种方式来初始化 :</p><ul><li>以<strong>无参数构造方法</strong>创建 ArrayList 时，实际上初始化赋值的是一个<strong>空数组</strong>。<u>当真正对数组进行添加元素操作时，才真正分配容量</u>。即向数组中添加第一个元素时，数组容量扩为 10。</li><li>jdk8中的ArrayList的对象的创建<strong>类似于单例的懒汉式</strong>。JDK8的内存优化也值得我们在平时开发中学习。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 默认初始容量大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 空数组（用于空实例）。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">     </span><br><span class="line">  <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">   <span class="comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 保存ArrayList数据的数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * ArrayList 所包含的元素个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment"> /**</span></span><br><span class="line"><span class="comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">         <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">         <span class="comment">//创建空数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">     elementData = c.toArray();</span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// replace with empty array.</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>再看<code>add</code>方法</strong></p><blockquote><p>这里<u>以无参构造函数创建的 ArrayList</u> 为例分析 。</p></blockquote><blockquote><p>JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">      ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">      <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">      elementData[size++] = e;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>再看 <code>ensureCapacityInternal()</code> 方法</strong></p><p>第2步（JDK7）可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code> 。</p><ul><li><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></li><li>然后开始调用 <code>ensureExplicitCapacity()</code> 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">          minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">      ensureExplicitCapacity(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>调用 <code>ensureCapacityInternal()</code> 进入<code>ensureExplicitCapacity()</code>这个方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们来仔细分析一下：</p><ul><li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，<strong>所以 minCapacity 此时为 10</strong>。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li><li>当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>添加第 3、4···到第 9 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li></ul><p>直到添加第 10 个元素，<code>minCapacity &lt; elementData.length</code><strong>不成立</strong>。进入 grow 方法进行扩容。</p></li><li><p><strong>elementData.length（实际容量）&gt;= minCapacity（最小需要容量）  , 执行 grow()</strong></p><blockquote><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数。</p></blockquote><p>将新容量更新为旧容量的1.5倍 ，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】。</p><ul><li>最后检查设置的新容量是否大于最大容量MAX_ARRAY_SIZE ，进入<code>hugeCapacity()</code> :<ul><li>如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code> 。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">     </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ArrayList扩容的核心方法grow。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">       <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】，</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">      <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">      <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br></pre></td></tr></table></figure></li><li><p><strong>设置完新容量 newCapacity ，进行<code>Arrays.copyOf</code></strong></p><p>Arrays的copyOf()方法传回的数组是新的数组对象，改变传回数组中的元素值，不会影响原来的数组。</p><ul><li><u>第二个自变量指定要建立的新数组长度</u>，如果新数组的长度超过原数组的长度，则保留数组默认值，例如：</li></ul><p>使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容。</p></li></ol></li><li><p><strong>contains()方法</strong></p><p>就是遍历数组看是否存在该元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;<span class="comment">//#1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回指定元素在列表中第一次出现的索引，如果该列表不包含该元素，则返回-1。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="5-1-多线程操作ArrayList会出现什么错误？">5.1 多线程操作ArrayList会出现什么错误？</h5><p>从ArrayList的（1）添加元素（<code>add</code>/<code>addAll</code>）和（2）获取元素（<code>get</code>）  两个角度来说：</p><ol><li><p><strong>多线程添加元素</strong></p><p>假设此时<code>minCapacity（最小需要容量）= 10</code> ，此时数组容量是10。A,B两个线程各需要添加若干元素，<strong>同时</strong> 判断此时不需要扩容，后续可能就会发生<strong>数组越界</strong>。</p></li><li><p><strong>多线程获取元素</strong></p><p>一个线程正在修改某个元素，另外一个线程此时正在读，那么读到的就是修改前的元素，也就是<strong>脏数据</strong>。</p></li></ol><h5 id="5-2-arraylist可以存多少数据？">5.2 <strong>arraylist可以存多少数据</strong>？</h5><p>Integer.MAX_VALUE = 2147483647 。</p><p>arraylist底层是一个数组对象：Object[] arr = new Object[10]，数组的大小只能设置int类型。所以能存储2147483647 字节数据。</p><h4 id="6-说一下LinkedList底层原理？">6. 说一下LinkedList底层原理？</h4><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000021433760">Java集合系列之三：LinkedList底层原理</a></p></blockquote><p>LinkedList实现了<strong>List</strong>接口和<strong>Deque</strong>接口的，底层的<strong>双端链表</strong>结构使它支持高效的插入和删除操作，<u>也具有队列的特性</u>，非线程安全的。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/2192701-9c26f117619ad840.png" alt="img"></p><blockquote><p>相比ArrayList要简单很多，主要是双向链表那些操作。</p></blockquote><ul><li><p><strong>底层结构</strong></p><p>核心属性、构造方法和Node定义如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;<span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;   <span class="comment">//LinkedList中存放的元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;  <span class="comment">//头节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;   <span class="comment">//尾节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，创建一个空的列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个指定的集合添加到LinkedList中，先完成初始化，在调用添加操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span>     </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node节点    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     E item;</span><br><span class="line">     Node&lt;E&gt; next;</span><br><span class="line">     Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">     Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">         <span class="keyword">this</span>.item = element;</span><br><span class="line">         <span class="keyword">this</span>.next = next;</span><br><span class="line">         <span class="keyword">this</span>.prev = prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>add() 方法</strong></p><p><strong>朴实无华的双向链表尾插法</strong>。获得当前最后一个节点最为当前节点的前置节点，同样把当前节点设置为前置节点的后置节点，然后把当前节点作为最后一个节点，因为只需要创建一个节点与前一个节点建立前后关系即可，时间复杂度是O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得当前最后一个节点作为前置节点，可能为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 初始化当前节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 把当前节点作为最后的节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 第一次添加设置为第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 把当前节点设置为前置节点的后置节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>add(int index,E e)</strong></p><p>按索引插入元素，首先判断是不是第一个添加的元素，如果是的话，直接使用add()方法添加就可以了，如果不是则需要根据索引来遍历寻找链表上对应位置。</p><ul><li>这里用了个小技巧，<strong>判断索引是在前半段还是在后半段</strong>，从短的那头开始遍历，找到之后，新建一个节点，建立新的前置节点和后置节点的关系。时间复杂度是O(n)，n为size/2。</li></ul></li><li><p><strong>get(int index)方法</strong></p><p>get()方法是用的上面介绍过的node()方法，时间复杂度是O(n)，n为size/2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 判断数组越界</span></span><br><span class="line">     checkElementIndex(index);</span><br><span class="line">     <span class="comment">// 遍历寻找节点</span></span><br><span class="line">     <span class="keyword">return</span> node(index).item;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得被插入索引上的元素</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"><span class="comment">// 如果索引是在链表的前半段</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="comment">// 获得第一个节点</span></span><br><span class="line">    Node&lt;E&gt; x = first;</span><br><span class="line">    <span class="comment">// 往后找到插入索引位置上的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        x = x.next;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果索引是在链表的前半段</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获得最后个节点</span></span><br><span class="line">    Node&lt;E&gt; x = last;</span><br><span class="line">    <span class="comment">// 往前找到插入索引位置上的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">        x = x.prev;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-4-迭代器">1.3.4 迭代器</h3><h4 id="1-请简单说明一下什么是迭代器？">1.<strong>请简单说明一下什么是迭代器</strong>？</h4><p>Iterator提供了统一遍历操作集合元素的统一接口, <strong>Collection接口实现Iterable接口</strong>。</p><ul><li>每个集合<strong>都通过实现Iterable接口中iterator()方法</strong>返回Iterator接口的实例, 然后对集合的元素进行迭代操作；</li><li>在<u><strong>迭代元素的时候不能通过集合的方法删除元素</strong></u>, 否则会抛出ConcurrentModificationException 异常. 但是可以通过Iterator接口中的remove()方法进行删除。</li></ul><h4 id="2-请你说说Iterator和ListIterator的区别？">2.<strong>请你说说Iterator和ListIterator的区别</strong>？</h4><ul><li><strong>遍历类型</strong>：<code>Iterator</code>可用来遍历Set和List集合，但是<code>ListIterator</code>只能用来遍历List；</li><li><strong>遍历方向</strong>：<code>Iterator</code>对集合只能是前向遍历，<code>ListIterator</code>既可以前向也可以后向；</li><li><strong>功能区别</strong>：<code>ListIterator</code>实现了Iterator接口，并包含其他的功能</li></ul>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（一）_Java_面对对象</title>
      <link href="/p/7257/"/>
      <url>/p/7257/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h2 id="1-2-面对对象">1.2 面对对象</h2><h3 id="1-2-1-基本问题">1.2.1 基本问题</h3><h4 id="1-介绍一下面对对象七大原则？三大特性？">1.<strong>介绍一下面对对象七大原则？三大特性</strong>？</h4><h5 id="七大原则">七大原则</h5><ul><li><p><strong>单一职责原则</strong>： 就一个类来说，应该仅有一个引起它变化的原因。也就是说，<strong>一个类应该只有一个职责</strong>。</p><blockquote><p>如果有多个职责，那么就相当于把这些指责耦合在起，一个职责的变化就可能削弱或抑制了这个类完成其他职责的能力，引起类的变化的原因就会有多个。所以在构造一个类时， 将类的不同职责分离至两个或多个类中(或者接口中)，确保引起该类变化的原因只有一个。</p></blockquote></li><li><p><strong>开闭原则(OCP)</strong>： 软件组成实体应该是可扩展的，但是不可修改。开放-封闭原则认为应该试图设计永远也不需要改变的模块。可以添加新代码来打展系统的行为，不能对已有的代码进行修改。</p><blockquote><p>这个原则很好的实现了面向对象的封装性和可重用性。</p></blockquote></li><li><p><strong>李氏替换原则(LSP)</strong>： 子类应当可以替换父类并出现在父类能够出现的任何地方。</p><blockquote><p>以圆和椭圆为例，圆是椭圆的一一个特殊子类。因此任何出现椭圆的地方，圆均可以出现。</p></blockquote></li><li><p><strong>依赖倒置原则(DIP)</strong>： 在进行业务设计时，与<u>特定业务有关的依赖</u>关系应该尽量依赖<strong>接口和抽象类</strong>，<strong>而不是依赖于具体类</strong>。具体类只负责相关业务的实现，修改具体类不影响与特定业务有关的依赖关系。</p><blockquote><p>为此，在进行业务设计时，应尽量在接口或抽象类中定义业务方法的原型，并通过具体的实现类(子类)来实现该业务方法，业务方法内容的修改将不会影响到运行时业务方法的调用。</p></blockquote></li><li><p><strong>接口分离原则(ISP)</strong>：  <u>采用多个与特定客户类有关的接口</u> 比采用一个通用的涵盖多个业务方法的接口要好。</p><blockquote><p>举例：如果拥有一个针对多个客户的类，为每一个客户创建特定业务接口，然后使该客户类继承多个特定业务接口将<u>比直接加载客户所需所有方法有效</u>。</p></blockquote></li><li><p><strong>组合重用原则</strong> ：能用组合实现的地方，<strong>尽量用组合来</strong>实现，而<strong>不要使用继承</strong>来扩展功能。</p><blockquote><p>097因为组合能更好地实现封装，比继承具有更大的灵活性和更稳定的结构。</p></blockquote></li><li><p><strong>迪米特原则 :</strong> <u>一个对象应该对于其他对象有最少的了解</u>，这样做的好处就是可以有效地降低类之间的耦合要求。</p></li></ul><h5 id="三大特性">三大特性</h5><ul><li><p><strong>封装</strong>。<u>封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的方法</u>，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果⼀个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p></li><li><p><strong>继承</strong>。 <u>继承是使用已存在的类的定义作为基础建⽴新类的技术，新类的定义可以增加新的数据或新的功能</u>，也可以用⽗类的功能，但不能选择性地继承⽗类。通过使用继承我们能够非常方便地<strong>复用</strong>以前的代码。</p><blockquote><ol><li>子类拥有⽗类对象所有的属性和方法（包括私有属性和私有方法），但是⽗类中的私有属性和方法子类是无法访问，只是拥有。</li><li>子类可以拥有⾃⼰属性和方法，即子类可以对⽗类进行扩展。</li><li>子类可以用⾃⼰的方式实现⽗类的方法。</li></ol></blockquote></li><li><p><strong>多态</strong>。（1）<strong>静态多态：重载</strong> （2）<strong>动态多态</strong>：所谓多态就是指程序中定义的<strong>引用变量所指向的具体类型</strong>和&lt;通过该<strong>引用变量发出的方法调用</strong>在<strong>编程时并不确定</strong>，而是在【<strong>程序运行期间才确定</strong>】。即⼀个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><blockquote><p>在 Java 中有两种形式可以实现多态：<strong>继承</strong>（多个子类对同⼀方法的重写）和<strong>接口</strong>（实现接口并覆盖接口中同⼀方法）。</p></blockquote></li></ul><h5 id="1-1-java多态的原理？【阿里-待重写】">1.1 java多态的原理？【阿里&amp;待重写】</h5><p>多态分两种：（1）【编译】时多态（静态多态）（2）运行时多态（动态多态）。</p><ol><li><p><strong>静态多态</strong></p><p><strong>重载</strong>（overload）就是编译时多态的一个例子，<strong>编译时</strong>多态在编译时就已经<strong>确定</strong>。</p><p>运行时运行的时候调用的是确定的方法。</p></li><li><p><strong>动态多态</strong></p><blockquote><p>我们通常所说的多态指的都是运行时多态，也就是<strong>编译时不确定究竟调用哪个具体方法</strong>，一直延迟到运行时（<strong>链接过程</strong>）才能确定。</p></blockquote><p>通常动态多态的实现方法：</p><ol><li>子类继承父类（extends）</li><li>类实现接口（implements）</li></ol><p>核心之处就在于<strong>对父类方法的改写或对接口方法的实现</strong>，以取得在运行时不同的执行效果。</p></li><li><p><strong>多态运行的原理</strong></p><blockquote><p>详细建议查看：<a href="https://zhuanlan.zhihu.com/p/94086109">深入理解Java多态的实现原理</a></p></blockquote><ul><li><p><strong>背景介绍</strong></p><p><img src="https://i.loli.net/2021/04/21/m1Ot3nQcMGq2YfW.jpg" alt="img"></p><p><u>类加载</u> 时会将<strong>类的元数据信息</strong>（<strong>类的方法代码、类变量、成员变量的定义</strong>等等）保存到方法区，<strong>方法区</strong>主要分为两部分：</p><ol><li><strong>常量池</strong>：Java 类引用的一些常量信息，比如<strong>类的符号引用信息</strong></li><li><strong>方法区其它部分</strong>： 保存<strong>方法表</strong>等</li></ol><p><u>链接过程</u> <strong>类的多态就发生在 <u>链接的解析</u></strong> 过程，将 <u>符号引用替换为直接引用</u>。</p></li><li><p><strong>原理简述（子类方法继承</strong>）</p><blockquote><p>参考：<a href="https://www.huaweicloud.com/articles/9b805c24ab31a65f5883c0dfeaf5a39b.html">https://www.huaweicloud.com/articles/9b805c24ab31a65f5883c0dfeaf5a39b.html</a></p></blockquote></li></ul></li></ol><h4 id="2-请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？">2.<strong>请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数</strong>？</h4><ul><li><strong>构造函数</strong>： 每一个类都有构造函数，程序员没有创建时，编译器会默认创建一个构造函数；<strong>对象被创建时，构造函数被调用</strong>；</li><li><strong>构造函数重载</strong>： 和方法重载类似，一个类可以创建多个构造函数，每个构造函数都有<strong>唯一参数列表</strong>；</li><li><strong>复制构造函数</strong>： Java不支持像C++中那样的复制构造函数。</li></ul><h4 id="3-请说明Java中的方法重写-Overriding-和方法重载-Overloading-是什么意思？构造函数能否被重写？">3.<strong>请说明Java中的方法重写(Overriding)和方法重载(Overloading)是什么意思？构造函数能否被重写</strong>？</h4><ul><li><p>Overriding ： 方法重写是说<u>子类重新定义了父类的方法</u>，有<u>相同的方法名，参数列表和返回类型</u> ；</p></li><li><p>Overloading： 同一个类里面两个或者是多个方法<u>同名</u> ，但 <u>参数列表不同</u>不同。</p><blockquote><p>特别的重写要求返回类型一致，但<strong>重载不要求返回类型一致</strong>！</p></blockquote></li></ul><p><strong>构造函数不能被 override（重写）</strong>！但是可以 overload（重载）,所以你可以看到⼀个类中有多个构造函数的情况。</p><h5 id="3-1-f（List-String-l）-f（List-Integer-l）是重载么？">3.1 f（List&lt;String&gt; l） f（List&lt;Integer&gt; l）是重载么？</h5><p>不是重载。</p><p>静态类型一致，并<strong>不会因为泛型而改变</strong>。因为<strong>编译</strong>期间，会对泛型进行<strong>擦除</strong>。</p><h4 id="4-介绍一下接口和抽象类的区别？">4.<strong>介绍一下接口和抽象类的区别</strong>？</h4><ul><li><p><strong>设计层面</strong></p><p>接口，是对类的行为进行约束，<strong>强制要求</strong>不同类实现相同行为 ； 抽象类，既 1.<strong>非抽象类实现代码复用</strong> 2.又同时有<strong>抽象方法使得被继承类各自实现</strong>。</p></li><li><p><strong>方法实现</strong></p><p>抽象类可以<strong>有非抽象方法，有方法体</strong> ； 接口不能有。</p><blockquote><p><strong>抽象类中添加新的方法，你可以给它提供默认的实现</strong>。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。</p></blockquote></li><li><p><strong>构造函数</strong></p><p>抽象类有；接口没有。</p></li><li><p><strong>修饰符</strong></p><p>抽象类除private 都有（抽象类目的是被继承，所以<strong>抽象方法是为被重写，不能私有</strong>）；接口<strong>默认public</strong>。</p></li><li><p><strong>继承个数 [接口优]</strong></p><p>抽象类只能被继承一次；接口可以有多个。</p></li></ul><h4 id="5-Java的四种引用？强软弱虚-？">5. <strong>Java的四种引用？强软弱虚</strong> ？</h4><ul><li><p><strong>强引用</strong> ：强引用是平常中使用最多的引用，强引用<strong>在程序内存不足（OOM</strong>）的时候也不会被回收，使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure></li><li><p><strong>软引用</strong>： 软引用<strong>在程序内存不足时，会被回收（“软”，没钱用了第一个被打劫</strong>），使用方式：</p><blockquote><p>可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收<u>早先创建的对象</u>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，</span></span><br><span class="line"><span class="comment">// 这里的软引用指的是指向new String(&quot;str&quot;)的引用，也就是SoftReference类中T</span></span><br><span class="line">SoftReference&lt;String&gt; wrf = <span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>弱引用</strong>：是<strong>只要<u>JVM垃圾回收器发现了弱引用</u>，就会将之回收</strong>，使用方式：</p><blockquote><p><strong>可用场景</strong>：  Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用。一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; wrf = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure></li><li><p><strong>虚引用：无法通过虚引用来获取对一个对象的真实引用</strong>； 虚引用必须与ReferenceQueue一起使用，当GC准备回收一个<strong>对象</strong>，如果发现<strong>它还有虚引用</strong>，就会在回收之前，把这个虚引用加入到与之关联的ReferenceQueue中。</p><blockquote><p>可用场景： 对象销毁前的一些操作，比如说资源释放等。 Object.finalize() 虽然也可以做这类动作，但是这个方式即不安全又低效。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; prf = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>),</span><br><span class="line"><span class="keyword">new</span> ReferenceQueue&lt;&gt;());</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-JAVA创建对象的机制？">6. <strong>JAVA创建对象的机制</strong>？</h4><ul><li><p>new创建新对象</p></li><li><p>通过反射机制</p></li><li><p>采用clone机制</p></li><li><p>通过序列化机制</p></li></ul><h4 id="7-简述Java的对象结构？">7.<strong>简述Java的对象结构</strong>？</h4><p>Java对象由三个部分组成：对象头、实例数据、<u>对齐填充</u>。</p><ol><li><p><strong>对象头</strong>。 在JVM中，对象在内存中除了本身的数据外还会有个对象头，对于普通对象而言，其对象头中有两类信息：<strong>mark word和类型指针</strong>。 如果是数组对象，还有数组长度。</p><ol><li><p><u><code>mark word(32位)</code></u></p><p><img src="https://i.loli.net/2021/05/16/PjXkchreF9sSEKG.png" alt="image-20210516131559341"></p><ul><li>具体的内容包含对象的hashcode、分代年龄、轻量级锁指针、重量级锁指针、GC标记（分代年龄）、偏向锁线程ID、偏向锁时间戳。</li><li>当对象状态为偏向锁时，<code>mark word</code>存储的是偏向的线程ID；当状态为轻量级锁（lightweight locked）时，<code>mark word</code>存储的是指向线程栈中<code>Lock Record</code>的指针；<strong>当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针</strong>。</li></ul></li><li><p><u>存储类型指针</u>，也就是指向类的元数据的指针，通过这个指针才能确定对象是<strong>属于哪个类的实例</strong>；</p></li><li><p><u>数组长度：</u>另外对于数组而言还会有一份记录数组长度的数据。</p></li></ol></li><li><p><strong>实例数据</strong>。 来存储对象真正的有效信息（包括父类继承下来的和自己定义的）；</p></li><li><p><strong>对齐填充</strong>。JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）。</p></li></ol><h4 id="8-Object有哪些常用方法？">8. Object有哪些常用方法？</h4><ul><li><em>equals方法</em></li><li>hashCode方法</li><li>wait方法</li><li>notify方法</li><li>notifyAll方法</li></ul><h3 id="1-2-2-反射">1.2.2 反射</h3><h4 id="1-请说明一下JAVA中反射的实现过程和作用分别是什么？-（快手）优缺点？">1.<strong>请说明一下JAVA中反射的实现过程和作用分别是什么</strong>？ （快手）优缺点？</h4><ul><li><p><strong>定义</strong></p><p>反射机制是<strong>在运行时</strong>，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p><blockquote><p>jdbc就是典型的反射 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&#x27;com.mysql.jdbc.Driver.class&#x27;</span>);<span class="comment">//加载MySQL的驱动类</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>实现和作用</strong></p><p>JAVA语言编译之后会生成一个<code>.class</code>文件，反射就是通过<strong>字节码</strong>文件<strong>找到某一个类、类中的方法以及属性</strong>等。</p><ul><li><p><strong>实现</strong>： （1）<strong>代码会编译成一个.class文件</strong> （2）<strong>类加载器加载进JVM的内存中，在方法区创建了Object类的Class对象</strong></p><blockquote><p>不是new出来的对象，而是类的类型对象，每个类都只有一个Class对象，作为方法区类的数据结构的接口。</p></blockquote><p>我们便是通过这个class对象来进行反射获取类的信息。</p></li><li><p><strong>作用</strong>：</p><ol><li>反射机制指的是程序在运行时能够获取自身的信息。在JAVA中，<strong><u>只要给定类的名字</u></strong>，那么就可以通过反射机制来获取类的所有信息。</li><li>根据类名在<strong>运行时创建实例</strong>（类名可以从配置文件读取，不用new）</li></ol></li></ul></li><li><p><strong>反射优缺点</strong></p><ul><li><strong>优点</strong>：（1）对于任意一个类，都能够知道这个类的所有属性和方法；（2）对于任意一个对象，都能够调用它的任意一个方法</li><li><strong>缺点</strong>：<ul><li><strong>性能降低</strong> ： 反射包括了一些<strong>动态类型</strong>，所以JVM<strong>无法对这些代码进行优化</strong></li><li><strong>安全限制</strong>： 使用反射技术要求程序必须在一个<strong>没有安全限制的环境</strong>中运行</li><li><strong>内部暴露</strong>：由于反射允许代码执行一些在正常情况下不被允许的操作（比如<strong>访问私有的属性和方法</strong>），所以使用反射可能会导致意料之外的副作用</li></ul></li></ul></li></ul><h4 id="2-解释一下JAVA代理模式？动态代理的原理？">2. 解释一下JAVA代理模式？动态代理的原理？</h4><blockquote><p>参考这个：<a href="https://zhuanlan.zhihu.com/p/54733692">JAVA面试50讲之9：动态代理的原理是什么？</a></p></blockquote><p>代理模式是给某一个对象提供一个代理，并由【<strong>代理对象】控制对【原对象】的引用(使用)</strong>。</p><ul><li><strong>优点</strong>：代理模式能够协调调用者和被调用者，<u>在一定程度上降低了系统的<strong>耦合度</strong></u>；可以<u>灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务</u>。</li><li><strong>缺点</strong>：由于使用了代理模式，因此程序的性能<u>没有直接调用性能高</u>；使用代理模式<u>提高了代码的复杂度</u>。</li></ul><p>根据代理模式又可以分为：静态代理和动态代理。</p><h5 id="2-1-静态代理">2.1 静态代理</h5><blockquote><p>静态代理：由程序员创建或特定工具自动生成源代码，也就是在<strong>编译时</strong>就已经将接口、被代理类、代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。</p></blockquote><p>代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。</p><ul><li><p>一个班的同学（Student）要向老师交班费，但是都是通过班长（StudentProxy）把自己的钱转交给老师。这里，班长就是代理学生上交班费，班长就是学生的代理。</p></li><li><p><strong>公共Person接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Student实现Person接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;上交班费50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>StudentsProxy实现Person接口</strong></p><p>实现了Peson接口，<strong>同时持有一个Student对象</strong>，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为。</p><blockquote><p>⚠️ 自己实现的giveMoney，调用的是<strong>被代理的学生对象.giveMoney()</strong> 方法！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsProxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentsProxy</span><span class="params">(Person stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理上交班费，调用被【代理学生的上交班费】行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用实例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//被代理的学生张三，他的班费上交有代理对象monitor（班长）完成</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成代理对象，并将张三传给代理对象</span></span><br><span class="line">        Person monitor = <span class="keyword">new</span> StudentsProxy(zhangsan);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//班长代理上交班费，实际上是调用被代理对象的giveMoney方法</span></span><br><span class="line">        monitor.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用实例2</strong>：扩充增强原对象方法</p><p>班长在帮张三上交班费之前，想要先反映一下<strong>张三最近学习有很大进步</strong>，通过代理模式很轻松就能办到 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsProxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentsProxy</span><span class="params">(Person stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张三最近学习有进步！&quot;</span>);</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-2-动态代理">2.2 动态代理</h5><blockquote><p>上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就<strong>已经编译</strong>完成 。</p></blockquote><p>然而动态代理，代理类<strong>并不是在Java代码中定义</strong>的，而是在运行时根据我们在Java代码中的“指示”<strong>动态生成</strong>“的 。</p><ul><li><p><strong>优点</strong>： 可以很方便的对代理类的函数进行统一的处理，<strong>而不用修改每个代理类中的方法</strong>。 比如说，想要在每个代理的方法前<u>都加上</u>一个处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="comment">//调用被代理方法前加入处理方法</span></span><br><span class="line">        beforeMethod();</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 代理类其它方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveHomework</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//调用被代理方法前加入处理方法</span></span><br><span class="line">        beforeMethod();</span><br><span class="line">        stu.giveHomework();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>除了giveMonney还有很多其他的方法（giveHomework），那就需要写很多次beforeMethod方法，麻烦。</p></li><li><p><strong>简单实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">  InvocationHandler stuHandler = <span class="keyword">new</span> MyInvocationHandler&lt;Person&gt;(stu);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">  Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler);</span><br></pre></td></tr></table></figure></li><li><p><strong>公共Person接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Student实现Person接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//假设数钱花了一秒时间</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;上交班费50元&quot;</span>);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>增加一个计算方法执行时间的检测方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tl.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束时打印耗时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> finishTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(methodName + <span class="string">&quot;方法耗时&quot;</span> + (finishTime - tl.get()) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>StuInvocationHandler 实现 InvocationHandler接口</strong></p><blockquote><p>并没有像之前一样：用一个代理类 StudentsProxy实现公共<strong>Person</strong>接口，而是代理类StuInvocationHandler 实现<strong>InvocationHandler</strong>接口。</p><p>但二者<strong>都是持有被代理的对象Student引用</strong>。</p></blockquote><p>InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。</p><ul><li>通过<strong>反射</strong>，可以执行被代理对象Student的相应方法giveMoney()。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StuInvocationHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">   <span class="comment">//invocationHandler持有的被代理对象</span></span><br><span class="line">    T target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StuInvocationHandler</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxy:代表动态代理对象</span></span><br><span class="line"><span class="comment">     * method：代表正在执行的方法</span></span><br><span class="line"><span class="comment">     * args：代表调用目标方法时传入的实参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理执行&quot;</span> +method.getName() + <span class="string">&quot;方法&quot;</span>);</span><br><span class="line">     */   </span><br><span class="line">        <span class="comment">//代理过程中插入监测方法,计算该方法耗时</span></span><br><span class="line">        MonitorUtil.start();</span><br><span class="line">        <span class="comment">// 原来的代理对象Student中的方法</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        MonitorUtil.finish(method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>具体实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个实例对象，这个对象是被代理的对象</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">        InvocationHandler stuHandler = <span class="keyword">new</span> StuInvocationHandler&lt;Person&gt;(zhangsan);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)；</span><br><span class="line"></span><br><span class="line">       <span class="comment">//代理执行上交班费的方法</span></span><br><span class="line">        stuProxy.giveMoney();</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/26/bIVRJdO5vKX36nQ.jpg" alt="img"></p></li></ul><h5 id="2-3-动态代理的原理">2.3 动态代理的原理</h5><p>从 JVM 角度来说，动态代理是在运行时<u>，通过<strong>反射</strong>动态生成类<strong>字节码</strong>，</u>并加载到 JVM 中的。</p><h4 id="3-如何利用反射创建一个对象？">3. 如何利用反射创建一个对象？</h4><p>过程如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 得到Stu类的运行时Class描述符</span></span><br><span class="line">            <span class="comment">//简单理解为你现在有了这个类，可以调用相应的方法进行实例化了</span></span><br><span class="line">            Class&lt;?&gt; stu = Class.forName(<span class="string">&quot;Stu&quot;</span>);</span><br><span class="line">            <span class="comment">//2.从getDeclaredConstructor()的字面意思就能理解，得到所有声明的构造器</span></span><br><span class="line">            <span class="comment">//这里得到的是所有声明的构造器，getConstructor()则只能得到被public修饰的构造器</span></span><br><span class="line">            Constructor&lt;?&gt; declaredConstructor = stu.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;String.class, <span class="keyword">int</span>.class&#125;);</span><br><span class="line">            <span class="comment">//3. 使用newInstance()方法创建对象并传入参数</span></span><br><span class="line">            <span class="comment">//简单的理解为Stu o = new Stu(&quot;zhangsan&quot;, 01)</span></span><br><span class="line">            Stu o = (Stu) declaredConstructor.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="number">01</span>&#125;);</span><br><span class="line">            <span class="comment">//4.调用Stu这个类里面的方法</span></span><br><span class="line">            <span class="comment">// getDeclaredMethod()方法能调用到所有声明的方法</span></span><br><span class="line">            Method method = stu.getDeclaredMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line">            <span class="comment">//5. 简单的理解为o.toStirng()</span></span><br><span class="line">            String invoke = (String)method.invoke(o, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">            System.out.println(invoke);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（一）_Java_Java入门</title>
      <link href="/p/51787/"/>
      <url>/p/51787/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h2 id="1-1-JAVA入门">1.1  JAVA入门</h2><h3 id="1-1-1-JAVA基本">1.1.1 JAVA基本</h3><h4 id="1-介绍一下JVM-JRE-JDK？-JAVA语言有什么特点？">1.<strong>介绍一下JVM&amp;JRE&amp;JDK？</strong> JAVA语言有什么特点？</h4><ul><li><strong>JVM&amp;JRE&amp;JDK</strong><ul><li><strong>JVM:</strong>  即java虚拟机，针对不同操作系统，JVM把Java代码翻译成<u>对应操作系统可以识别的内容，实现跨平台</u> ；</li><li><strong>JRE</strong> : <u>JVM + 核心类库 = JRE</u> ， 即Java运行时环境。只有JVM不能运行，它还<strong>需要核心类库，才能保证Java运行</strong> ；</li><li><strong>JDK:</strong> <u>JRE + <strong>java开发工具</strong>（编译器等) = JDK</u> ，Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具。</li></ul></li><li><strong>Java语言特点</strong><ol><li><p>简单易学；</p></li><li><p>面向对象（封装，继承，多态）；</p></li><li><p><strong>平台无关性</strong>（ Java 虚拟机实现平台无关性）；</p></li><li><p>可靠性；</p></li><li><p>安全性；</p></li><li><p><strong>支持多线程</strong>（ <u>C++ 语⾔没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计</u>，而 Java 语⾔却提供了多线程支持）；</p></li></ol></li></ul><h4 id="2-什么是Java虚拟机？为什么Java被称为平台无关的编程语言？">2.<strong>什么是Java虚拟机？为什么Java被称为平台无关的编程语言</strong>？</h4><p><img src="https://i.loli.net/2021/05/12/b4HUYmVo6P5uFCi.png" alt="image-20210512104311616"></p><ul><li><p>java虚拟机，是<strong>执行字节码文件（.class</strong>）的<u>虚拟机进程</u>；</p><blockquote><p>在 Java 中，<strong>JVM 可以理解的代码就叫做 字节码</strong> （即扩展名为 .class 的⽂件），它不面向任 何特定的处理器，<strong>只面向虚拟机</strong>。</p></blockquote></li><li><p>java源程序（.java）被编译器编译成字节码文件（.class）。然后字节码文件，将由<u>java虚拟机，解释成机器码（<strong>不同平台的机器码不同</strong>）</u>。</p></li></ul><h4 id="3-请你谈谈Java中是如何支持正则表达式操作的？（补充实例）">3. 请你谈谈Java中是如何支持正则表达式操作的？（补充实例）</h4><p>Java中的String类提供了支持正则表达式操作的方法，包括：</p><ul><li><code>matches()、replaceAll()、replaceFirst()、split()</code></li></ul><p>此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegExpTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;成都市(成华区)(武侯区)(高新区)&quot;</span>;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;.*?(?=\\()&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(str);</span><br><span class="line">        <span class="keyword">if</span>(m.find()) &#123;</span><br><span class="line">            System.out.println(m.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实例示范（PCG问过）">实例示范（PCG问过）</h5><blockquote><p>参考：<a href="https://www.runoob.com/regexp/regexp-syntax.html">https://www.runoob.com/regexp/regexp-syntax.html</a></p></blockquote><ul><li><p><strong>特殊字符</strong></p><img src="https://i.loli.net/2021/05/12/9IBVheAOz5aGnxC.png" alt="image-20210512110705420" style="zoom:80%;" /></li><li><p><strong>普通字符</strong></p><p><img src="https://i.loli.net/2021/05/12/QcjTKqEJZwx7LdM.png" alt="image-20210512111050519"></p></li><li><p><strong>实例示范</strong></p><ol><li><p>匹配邮箱</p><p><img src="https://i.loli.net/2021/05/12/Lvo56GHie2Qqla1.png" alt="img"></p></li><li><p>匹配电话号码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配电话号码</span></span><br><span class="line">String phone = <span class="string">&quot;18637866964&quot;</span>;</span><br><span class="line">String reg = <span class="string">&quot;^1[3,5,7,8,9]\\d&#123;9&#125;$&quot;</span>;</span><br><span class="line">System.out.println(phone.matches(reg));</span><br></pre></td></tr></table></figure></li><li><p>匹配第一个出现的数字</p><p>下面好像是不对的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String phone = <span class="string">&quot;avss1sdp22&quot;</span>;</span><br><span class="line">String reg = <span class="string">&quot;\d?&quot;</span>;</span><br><span class="line">System.out.println(phone.matches(reg));</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="4-（补充例子）请你简单描述一下正则表达式及其用途。">4.<strong>（补充例子）请你简单描述一下正则表达式及其用途</strong>。</h4><p>在编写处理字符串的程序时，经常会有查找 <u>符合某些复杂规则的字符串</u> 的需要。</p><ul><li>计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具；</li><li>绝大多数语言都提供了对正则表达式的支持。</li></ul><h4 id="5-和-区分？">5.<strong>&amp;和&amp;&amp;区分？</strong></h4><ul><li><strong>共同点</strong>：都要求运算符左右两端的布尔值 <u>都是true</u> 整个表达式的值才是true</li><li>区别：&amp;&amp;之称为短路运算，<u>如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算</u>。 好处：<ul><li><em>e.g.</em> ：右边判别式有如果有空指针<code>NullPointerException</code>异常判断风险，可以避免。</li></ul></li></ul><h4 id="6-值传递和引用传递区分？">6.<strong>值传递和引用传递区分？</strong></h4><ul><li><p>值传递是<strong>该变量</strong>的一个<u>副本</u>， 改变副本<u>不影响</u>原变量；</p></li><li><p>引用传递是<strong>对象地址</strong>的<u>副本</u>，引用对象进行操作会同时<u>改变</u>原对象。</p></li></ul><h4 id="7-十进制与二进制？">7.<strong>十进制与二进制？</strong></h4><ul><li><p><strong>请你讲讲一个十进制的数在内存中是怎么存的？</strong></p><p>补码形式。</p></li><li><p><strong>为什么会出现4.0-3.6=0.40000001这种现象？</strong></p><p>2进制的小数无法精确的表达10进制小数，计算机在 <u>计算10进制小数的过程中要先转换为2进制进行计算</u> ，这个过程中出现了误差。</p></li></ul><h4 id="8-（重要）equals与-的区别">8.<strong>（重要）equals与==的区别</strong></h4><blockquote><p>很清晰严谨的一篇文章：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p></blockquote><ul><li><p><strong>==</strong></p><ol><li>基本类型：比较的是值是否相同；</li><li>引用类型：比较的是<strong>引用（对象地址</strong>）是否相同；</li></ol></li><li><p><strong>equals</strong></p><p>要看<strong>类是否覆盖equals()方法</strong>，将它分为两种情况：</p><ol><li><p>若某个类没有覆盖equals()方法，当它的通过<strong>equals()比较两个对象</strong>时，实际上是比较两个对象（地址）是不是同一个对象。这时，<u>等价于通过“==”去比较这两个对象</u>；</p></li><li><p>我们可以覆盖类的equals()方法，来让equals()通过其它方式比较两个对象的内容（<strong>而不是地址</strong>）是否相等。</p><blockquote><p>String 中的 equals 方法是被重写过的：</p><ul><li>因为 object 的 equals 方法是⽐教的对象的内存地址</li><li>而 <strong>String 的 equals 方法（1）先比较对象地址是否相等 ，相同则ture，否则（2）再比较值是否相等</strong></li></ul></blockquote></li></ol></li></ul><h4 id="7-请解释hashCode-和equals-方法有什么联系？">7.<strong>请解释hashCode()和equals()方法有什么联系？</strong></h4><blockquote><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode方法？”</p><ul><li>建议看文中例子理解：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html">https://www.cnblogs.com/skywang12345/p/3324958.html</a></li></ul></blockquote><ul><li><p><strong>hashCode()介绍</strong></p><p>hashCode() 的作用是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个int整数。这个<strong>哈希码的作用</strong>是确定该 <u>对象在哈希表中的索引位置</u>。</p><blockquote><p>我们仅在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。  其它情况下hashCode() 则根本没有任何作用，所以，不用理会hashCode()。</p><ul><li>在这种情况下对象相等，hashcode值也会不相等。</li></ul></blockquote></li><li><p><strong>为什么要有hashcode()</strong></p><p>hashCode() 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回⼀个 int整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。 <strong>hashCode()</strong><u>在散列表中</u>才有用，在其它情况下没用。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><p><strong>先判断hashcode，而不是直接遍历O(n)复杂度用equals()判断，减少判断时间</strong>。</p><blockquote><p><strong>如果hashcode一样，会调用equals()去比较</strong>。</p><ul><li><strong>HashSet</strong> 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加⼊操作成功。如果不同的话，就会重新散列到其他位置。</li></ul></blockquote></li></ul><h5 id="7-1-为什么重写了equals-一定要重写hashcode-方法？">7.1 为什么重写了equals()一定要重写hashcode()方法？</h5><blockquote><p>参考：<a href="https://blog.csdn.net/xyh269/article/details/69171545">为什么重写了equals()，还要重写hashCode()？</a></p></blockquote><p>在Hashmap / Hashset中，通过计算hash = hash(key.hashcode) 然后进行取余操作，快速定位到数组中。</p><p>因为<strong>map中是不允许重复key</strong>的，所以对内部get()/add()方法：对于散列到数组同一位置的对象来说，<strong>如果hash相等 &amp;&amp; equals()判断相等</strong> ，是要进行<strong>覆盖</strong>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用 equals 方法判断key是否相等，若相等，该key对应的键值对已经存在，用新的value取代旧的value</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;    </span><br></pre></td></tr></table></figure><p>如果我们只重写了equals方法：用来判断两个对象是否相等。但是依旧可能出现：两个相同对象<strong>equals相等，但hashcode不等，被散列到不同桶上，map中依旧出现了重复键值对！</strong></p><p><img src="https://i.loli.net/2021/05/26/v5aHJGt8qErx6P9.png" alt="hashcode"></p><p>所以，需要重写hashcode方法，保证<strong>相同对象一定是散列到同一个位置（具有同样的hash值）</strong>。</p><h5 id="7-2-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，该说法是否正确，为什么？">7.2 <strong>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么</strong>？</h5><p>不一定正确，<u>如果在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中</u>，两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。</p><p>其它情况下可能会出现题目描述的情况。</p><h4 id="8-自动拆箱和装箱？">8. 自动拆箱和装箱？</h4><h5 id="8-1-介绍一下int-Integer？">8.1 <strong>介绍一下int&amp;Integer？</strong></h5><p>Java为了编程的方便还是引入了基本数据类型，但是 <u>为了能够将这些基本数据类型当成对象操作</u>，Java为每一个基本数据类型都引入了对应的<strong>包装类型</strong>（wrapper class）</p><ul><li><p>int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e.g. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">        Integer b = <span class="number">3</span>;          <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">        System.out.println(a == b);  </span><br><span class="line">        <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">        System.out.println(a == c);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>Java 为<u>每个原始类型</u>提供了包装类型：</p><ul><li>（<strong>8种基本类型</strong>）原始类型: boolean，char，byte，short，int，long，float，double</li><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li></ul></li></ul><h5 id="8-2-拆箱、装箱存在的意义？">8.2 <strong>拆箱、装箱存在的意义？</strong></h5><blockquote><p>为什么要有装箱、拆箱，它们的作用是什么？</p></blockquote><p><em>java</em> 是 面对对象编程，而基本数据类型不是对象，<strong>所有才有封装类 引用基本数据类型进行操作</strong>。比如，下面打印出<em>int</em>型数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>； </span><br><span class="line">System.out.println(i); <span class="comment">// 自动装箱</span></span><br></pre></td></tr></table></figure><p>其实，查看源码，实际经过以下几个过程：</p><ul><li>将 <em>i</em> 自动装箱成封装类 <em>Integer</em></li><li>然后调用 <em>Integer</em>中 <em>toString</em>() 方法，打印出字符串输出到控制台。</li></ul><blockquote><p>自动装箱和拆箱？</p></blockquote><ul><li>自动装箱：就是自动将基本数据类型转换为包装器类型</li><li>自动拆箱：就是自动将包装器类型转换为基本数据类型</li></ul><h5 id="8-3-char和byte的区别-，-能否强制转换？">8.3 char和byte的区别 ， 能否强制转换？</h5><p>区别：</p><ul><li>Char是无符号型的，可以表示一个整数，不能表示负数，大小范围 是0—65535；而byte是有符号型的，可以表示-128—127 的数</li><li>char可以表中英文字符，byte不可以</li></ul><p>强制转换：</p><p>可以，但是会出现精度丢失。</p><h4 id="9-String-StringBuffer-StringBuilder-区别？为什么String不可变">9.  String &amp; StringBuffer&amp; StringBuilder 区别？为什么String不可变?</h4><ul><li><p><strong>请解释String &amp; StringBuffer区别？</strong></p><ul><li><p><strong>共同点</strong>：它们可以<strong>储存和操作</strong>字符串，即包含多个字符的字符数据；</p></li><li><p><strong>可否修改</strong>：String类提供了数值不可改变的字符，StringBuffer可以修改字符串，需要 <u>字符数据要改变</u> 时用。</p></li></ul><p>典型地，你可以使用StringBuffers来动态构造字符数据。</p></li><li><p><strong>请解释 StringBuilder&amp; StringBuffer 区别？</strong></p><ul><li><p><strong>共同点</strong>：<code>AbstractStringBuilder</code> 是 StringBuilder 与 StringBuffer 的公共⽗类。都可以修<u>改字符串，操作字符串方法丰富</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value is used for character storage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">char</span>[] value;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The count is the number of characters used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> count;</span><br><span class="line"> AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line"> value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><u><strong>线程安全</strong>：</u>单线程且操作大量字符串用StringBuilder,速度快，但线程不安全，可修改；在多线程且操作大量字符串用<strong>StringBuffer，线程安全，可修改</strong>。</p><blockquote><p>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p></blockquote></li></ul></li><li><p><strong>为什么String 不可变？</strong></p><p>String 类中使用 final 关键字修饰字符数组来保存字符串， 所以 String 对象是不可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[]</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-说说深拷贝和浅拷贝？">10.<strong>说说深拷贝和浅拷贝</strong>？</h4><ul><li><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址；</p><blockquote><p>因此，可能会出现出现浅拷贝时释放同一个内存的错误。</p></blockquote></li><li><p>深拷贝（deepCopy）是增加了一个指针<strong>并且申请了一个新的内存</strong>，使这个增加的指针指向这个新的内存。</p></li></ul><h4 id="11-【新增】介绍一下JDK1-8的新特性？">11. 【新增】介绍一下JDK1.8的新特性？</h4><p>JDK1.8新增了非常多的特性，如：</p><ul><li><strong>Lambda表达式</strong>：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li><li><strong>方法引用</strong>：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li><li><strong>默认方法</strong>：默认方法就是一个<strong>在接口里面有了一个实现的方法</strong>。</li><li><strong>新工具</strong>：新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li><li><strong>Stream API</strong>：新添加的Stream API（java.util.stream） 把真正的<strong>函数式编程风格</strong>引入到Java中。</li><li><strong>Date Time API</strong>：加强对日期与时间的处理。</li><li><strong>Optional类</strong>：Optional 类已经成为 Java 8 类库的一部分，用来解决<strong>空指针异常</strong>。</li><li><strong>Nashorn，JavaScript引擎</strong>：JDK1.8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li></ul><h4 id="12-【新增】java一个程序能不能有多个main方法？一个类里呢？">12. 【新增】java一个程序能不能有多个main方法？一个类里呢？</h4><ul><li><p><strong>一个程序里，多个class都有main方法</strong></p><p>可以，默认第一个为入口，其余为普通函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>一个类有多个main方法</strong></p><p>可以，其余就相当是重载。但是具有以下sigature（签名）的主要方法将被视为app入口点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-1-2-关键字">1.1.2 关键字</h3><h4 id="1-请你讲讲Java里面的final关键字是怎么用的？">1.<strong>请你讲讲Java里面的final关键字是怎么用的</strong>？</h4><ul><li><p><strong>修饰类</strong>：表示不能被继承，final类 <u>成员变量</u> 可以设为final；但final类<u>所有方法</u> ，都被隐式指定为final方法；</p></li><li><p><strong>修饰方法</strong>：防任何继承类修改它的含义 ； 在早期的Java实现版本中，会将final方法转为内嵌调用，效率会更高；</p></li><li><p><strong>修饰变量、引用</strong>：<u>基本类型</u>的话一旦初始化不能修改；<u>引用类型</u>，不能指定其他对象 。</p></li></ul><h4 id="2-【重点】请你谈谈关于Synchronized和lock-？">2. 【<strong>重点</strong>】请你谈谈关于Synchronized和lock ？</h4><ul><li><p><strong>Synchronized</strong>：是一个关键字，修饰<u>类、方法 </u> 或 <u>代码块</u> ，保证在同一时刻最<strong>多只有一个线程</strong>执行该段代码；</p><blockquote><p>作用范围：</p><ol><li>修饰一个类/静态方法，<strong>作用的对象是这个类的所有对象</strong>。</li><li>修饰一个方法/代码块，<strong>作用的对象是调用这个方法/代码块的对象</strong>。</li></ol></blockquote></li><li><p>Lock：<strong>是一个接口</strong>，Lock能完成synchronized所实现的所有功能。</p><blockquote><p>Lock接口是不能直接实例化的，需要靠它的实现类ReentrantLock来进行实例化。</p></blockquote><ul><li><p>区别：</p><ul><li><u>锁释放：</u><strong>synchronized在发生异常时，会自动释放线程占有的锁</strong>，因此不会导致死锁现象发生；Lock不会主动适应 <code>unLock()</code> 释放，必须手动在f<code>inally</code>释放。；</li><li><u>线程等待：</u> <u>Lock可以让<strong>等待锁的线程可以响应中断</strong></u>，线程可以中断去干别的事务；而synchronized却不行，使用synchronized时，等待的线程会一直等待下去；</li><li><u>成功获取锁：</u> 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li></ul></li></ul></li></ul><h4 id="3-instanceof关键字的作用？">3. <strong>instanceof</strong>关键字的作用？</h4><p>instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Integer);<span class="comment">//编译不通过 i必须是引用类型，不能是基本类型</span></span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Object);<span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(integer <span class="keyword">instanceof</span> Integer);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="4-final有哪些用法">4. <strong>final有哪些用法?</strong></h4><ul><li><p>被final修饰的类不可以被继承 ；</p></li><li><p>被final修饰的方法<strong>不可以被重写</strong>，<u>而且JVM会尝试将其内联，以提高运行效率</u>；</p></li><li><p>被final修饰的<u>变量</u>不可以被改变；</p><ul><li><p>被final修饰的<u>引用</u>，那么表示引用不可变，<u>引用指向的内容可变</u>；</p></li><li><p>被final修饰的<u>常量</u>，在编译阶段会存入常量池中。</p></li></ul></li></ul><h4 id="5-static都有哪些用法">5. <strong>static都有哪些用法 ?</strong></h4><ul><li><p><strong>修饰静态变量和静态方法</strong> ：都属于类的静态资源，类实例所共享 ；</p></li><li><p><strong>修饰静态块</strong>：用于初始化操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss PreCache&#123;</span><br><span class="line"> <span class="keyword">static</span>&#123;</span><br><span class="line"> <span class="comment">//执行相关操作</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>修饰静态包</strong>：在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且<strong>不需要使用类名,<strong>可以直接</strong>使用方法名</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(Math.sin(20));传统做法</span></span><br><span class="line">        System.out.println(sin(<span class="number">20</span>));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-谈一谈transient关键字？">6. 谈一谈transient关键字？</h4><blockquote><p><strong>参考</strong> : <a href="https://www.cnblogs.com/chenpi/p/6185773.html">Java中的关键字 transient</a></p></blockquote><ul><li><p><strong>Java中序列化操作</strong></p><p>Java中对象的序列化指的是将<strong>对象转换成以【字节序列】的形式来表示</strong>，这些字节序列<strong>包含了对象的数据和信息</strong>。</p><blockquote><p>当然，序列化后的最终目的是为了反序列化，恢复成原先的Java对象，要不然序列化后干嘛呢，所以序列化后的字节序列都是可以恢复成Java对象的，这个过程就是反序列化。</p></blockquote><ul><li><u>一个序列化后的对象可以<strong>被写到数据库或文件</strong>中</u>，也可用于<strong>网络传输</strong>，一般当我们使用缓存cache（内存空间不够有可能会本地存储到硬盘）或远程调用rpc（网络传输）的时候，经常需要让我们的实体类实现Serializable接口，目的就是为了让其可序列化。</li></ul></li><li><p><strong>关于transient关键字</strong></p><p>Java中transient关键字的作用，向虚拟机表明: <strong><code>transient</code>变量不是对象的<u>持久状态</u>的一部分</strong>。</p><p>简单地说，就是让某些被修饰的成员属性变量不被序列化，例如：</p><ol><li><p>类中的字段值可以根据其它字段推导出来，如一个长方形类有三个属性：长度、宽度、面积（示例而已，一般不会这样设计），那么在序列化的时候，面积这个属性就没必要被序列化了；</p></li><li><p>其它，看具体业务需求吧，哪些字段不想被序列化；</p></li></ol></li></ul><h5 id="7-1-HashMap中源码modCount为什么用tranisent修饰？">7.1 HashMap中源码modCount为什么用tranisent修饰？</h5><p>modCount主要用于判断HashMap是否被修改（像put、remove操作的时候，modCount都会自增）。</p><p>对于这种变量，一开始可以为任何值，0当然也是可以（new出来、反序列化出来、或者克隆clone出来的时候都是为0的），没必要持久化其值。</p><h3 id="1-1-3-Java异常">1.1.3 Java异常</h3><h4 id="1-Java常见异常和分类？">1. Java常见异常和分类？</h4><p><img src="https://i.loli.net/2021/05/26/1ctoGfDdrj6Wapv.png" alt="Java异常的分类和类结构图1"></p><p>常见分为两类，Error和Exception ：</p><ul><li><strong>Error</strong> ：指程序无法恢复的异常情况，对于其所有类型，都不要求程序处理。<ul><li>常见错误：Stackoverflow，outOfMemory</li></ul></li><li><strong>Exception：</strong> 程序有可能恢复的错误，又分为IOException &amp; RuntimeException ，常见错误：<ul><li><strong>IOException</strong>：FileNotFoundExcepetion</li><li><strong>RuntimeException</strong>  : 空指针，参数不合法，类未找到等</li></ul></li></ul><h4 id="2-OOM产生原因和分析？">2. OOM产生原因和分析？</h4><blockquote><p>OOM，全称“Out Of Memory”，翻译成中文就是“内存用完了”，来源于java.lang.OutOfMemoryError 。</p></blockquote><ol><li><p><strong>java.lang.OutOfMemoryError: Java heap space</strong> （堆溢出）</p><ul><li><p><strong>产生原因</strong></p><ol><li><strong>内存泄漏</strong>；</li><li>堆分配太小；</li></ol></li><li><p><strong>解决办法</strong></p><ol><li><strong>内存泄漏要手动去释放内存</strong>，比如数据库连接池，单例模式</li><li>通过虚拟机参数<code>-Xms,-Xmx</code>等修改，对内存大小</li></ol></li></ul></li><li><p><strong>java.lang.OutOfMemoryError: PermGen space</strong> （永久代（方法区）溢出）</p><ul><li><p><strong>产生原因</strong></p><p>即方法区溢出了：</p><ol><li>一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生<strong>大量的Class信息存储于方法区</strong> ；</li><li><strong>过多的常量</strong>尤其是字符串也会导致方法区溢出。</li></ol></li><li><p><strong>解决办法</strong></p><ol><li>永久代的内存分配增大 ：-XX:PermSize和-XX:MaxPermSize</li></ol></li></ul></li><li><p><strong>java.lang.StackOverflowError ------&gt; 不会抛OOM error，但也是比较常见的Java内存溢出</strong>。</p><p>线程栈相关的内存异常有两个：</p><ul><li>StackOverflowError(方法调用层次太深，内存不够新建栈帧)</li><li>OutOfMemoryError（线程太多，内存不够新建线程）</li></ul></li><li><p><strong>java.lang.OutOfMemoryError: Metaspace</strong></p><blockquote><p>Java中<strong>普通I/O</strong>采用<strong>输入/输出流</strong>方式实现，输入流InputStream（  终端—&gt;直接内存-&gt;JVM），输出流（JVM-&gt;直接内存-&gt;终端），这一过程中有kenel与JVM之间的拷贝（很多次）。</p></blockquote><p>为了使用<strong>直接内存</strong>，Java是有一块区域叫<strong>DirectBuffer</strong>，不是JavaHeap而是<strong>cHeap</strong>的一部分。</p><p>但由于直接内存没有被java虚机完全托管，若使用不当，也容易触发溢出，导致宕机。</p></li></ol><h4 id="3-try-catch-finally，try里有return，finally还执行么？"><strong>3. try catch finally，try里有return，finally还执行么</strong>？</h4><p>执行，并且finally的执行早于try里面的return ：</p><ol><li>不管有木有出现异常，finally块中代码都会执行；</li><li>当try和catch中有return时，finally仍然会执行；</li><li>finally是<strong>在return后面的表达式运算后执行</strong>的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以<strong>函数返回值是在finally执行前确定</strong>的。</li></ol><h4 id="4-说说你是怎么处理异常的？">4.<strong>说说你是怎么处理异常的？</strong></h4><p><em><strong>try-catch-finally</strong></em></p><p><img src="https://i.loli.net/2021/05/05/JfavipzFPb6GI2t.png" alt="image-20210505154833171"></p><ul><li><p>try 块负责监控可能出现异常的代码</p></li><li><p>catch 块负责捕获可能出现的异常，并进行处理</p></li><li><p>finally 块负责清理各种资源，不管是否出现异常都会执行</p></li><li><p>其中 try 块是必须的，<strong>catch 和 finally 至少存在一个标准异常处理流程</strong></p></li></ul><h4 id="5-web网页卡怎么排查？cpu100-怎么排查？OOM怎么排查？">5. web网页卡怎么排查？cpu100%怎么排查？OOM怎么排查？</h4><ul><li><p><strong>web网页卡顿</strong></p><ol><li><strong>用户端</strong>：硬件配置低、资源不足；CPU 或者内存资源不足, 比如用户是否使用了 Chrome 这种 “吃内存大户” 的浏览器并且打开了很多网页?</li><li><strong>网络分析</strong>：<strong>DNS 解析慢</strong>；<strong>未设置 CDN</strong>，如果没有设置 CDN, 在跨线路访问(比如用户是铁通, 但是服务器部署在联通, 这种情况就是跨线路), 地理位置相差很远 等情况 ；用户端的带宽不足或所处环境网络不佳；</li><li><strong>服务端</strong>：服务端响应慢，性能比较差 。</li></ol></li><li><p><strong>cpu100%</strong></p><blockquote><p>参考：<a href="https://www.cnblogs.com/dennyzhangdd/p/11585971.html">https://www.cnblogs.com/dennyzhangdd/p/11585971.html</a></p></blockquote><ol><li><p><strong>执行<code>top</code>命令</strong>：查看所有进程占系统CPU的排序；</p><blockquote><p>极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。</p></blockquote></li><li><p>执行<strong>top -Hp 进程号</strong>命令：查看java进程下的<strong>所有线程占CPU的情况</strong>；</p></li><li><p>执行<strong>printf &quot;%x\n 10</strong>命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，咱们需要把线程号转成16进制。</p></li><li><p>执行<strong>jstack 进程号 | grep 线程ID” 查找某进程下</strong>–&gt;<code>线程ID(jstack堆栈信息中的nid)=0xa</code>的<strong>线程状态</strong>。</p><p>代码中有大量消耗CPU的操作，导致CPU过高，系统运行缓慢：</p><blockquote><ol><li><p>jstack，可直接定位到代码行。例如某些复杂算法，甚至算法BUG，无限循环递归等等。</p></li><li><p>如果有死锁，会直接提示关键字：deadlock。步骤4，会打印出业务死锁的位置。</p></li></ol></blockquote></li><li><p>执行<strong>jstat -gcutil 进程号</strong> 统计间隔毫秒 统计次数（缺省代表一致统计）”，<strong>查看某进程GC持续变化情况</strong>，<strong>如果发现返回中FGC很大且一直增大–&gt;确认Full GC!</strong></p><p>也可以使用“<strong>jmap -heap 进程ID”查看一下进程的堆内从是不是要溢出了</strong>，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。</p><blockquote><p>jstat命令监控GC情况，可以看到Full GC次数非常多，并且次数在不断增加。</p></blockquote></li><li><p>执行<strong>jmap -dump:format=b,file=filename 进程ID</strong>，导出某进程下内存heap输出到文件中。</p></li></ol></li><li><p><strong>OOM</strong></p><blockquote><p>参考：<a href="https://www.cnblogs.com/valjeanshaw/p/13130102.html">https://www.cnblogs.com/valjeanshaw/p/13130102.html</a></p></blockquote><p>先通过内存映像工具对Dump出来的堆转储快照进行分析，<strong>重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=$java_pid.hprof     #java_pid为java进程ID</span><br></pre></td></tr></table></figure><p>然后看具体是报什么错：很明显下面是堆溢出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to oom.out ...</span><br><span class="line">Heap dump file created [3196858 bytes in 0.016 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">        at java.util.Arrays.copyOf(Arrays.java:3332)</span><br><span class="line">        at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)</span><br><span class="line">        at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:700)</span><br><span class="line">        at java.lang.StringBuilder.append(StringBuilder.java:214)</span><br><span class="line">        at jvm.OomDemo.main(OomDemo.java:13)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（零）_写在前面</title>
      <link href="/p/29708/"/>
      <url>/p/29708/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>转眼就到了属于我的毕业季，还记得初来学校的期待和兴奋，却从“小师弟”眨眼变成了“老油条”。实习和秋招也算正式告一段落，对于我这种懒蛋，有幸拿到了<u>腾讯</u>、<u>美团</u>、<u>Shoope SG</u>等 <u>后端开发岗</u> offer，勉强算是一个 “happy ending”。找工作是今年我经历的最重要事情之一，同时也想给师弟师妹提供一点帮助，便整理了这份 <u>（互联网）校招笔记</u>。</p></blockquote><h3 id="直入主题">直入主题</h3><p>互联网校招主要形式和考察内容如下：</p><ul><li><p><strong>考察形式</strong></p><p>线上考察，视频面试（大部分公司）或电话面试（阿里等部分公司喜欢这种方式）。</p></li><li><p><strong>考察内容</strong></p><ul><li><p><strong>算法能力</strong></p><p>俗称“刷题”，一般面试都是常见题，理论上刷完<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a>，能做到烂熟于心（指现场<strong>秒背题或模板</strong>），大厂面试一般没有多大问题。</p><p>当然针对心仪公司，可以在面试前<strong>更加针对性</strong>地练习该公司的常出题，这一点上<a href="https://codetop.cc/">codeTop</a>是一个不错的网站。</p></li><li><p><strong>计算机基础</strong></p><p>俗称“八股”，考察范围包含：计算机网络、Linux、数据库、操作系统、常见中间件&amp;框架、智力题等。可以看得到<strong>考察范围非常广</strong>，但是<strong>考察的题目非常固定</strong>。所以只要背熟常见题目问答便能不错地应对面试，这也是该部分内容被称为“八股文”的原因。</p></li><li><p><strong>项目 &amp; 实习</strong></p><p>项目顾名思义，就是实际做的开发项目（如果是算法岗则对应论文）。根据面试经验，一个<strong>好的开源项目</strong>是非常加分的。</p><p>实习通常是指大厂实习，在竞争这么激烈的情况下，如果没有实习，秋招想进入互联网大厂将会变得很困难。</p></li></ul></li></ul><p>根据以上内容，这份校招笔记争取尽量全面覆盖，整个目录安排如下：</p><ul><li>[注1]：本份笔记除自身总结外，主要参考资料来源于<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Java Guide：https://github.com/Snailclimb/JavaGuide">[1]</span></a></sup><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="阿秀C++面试笔记：https://github.com/forthespada/InterviewGuide">[2]</span></a></sup><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="牛客网面经：https://www.nowcoder.com/interview/center">[3]</span></a></sup>，特此注明。</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><p>下面是一些奇怪没有脑袋的絮絮叨叨，迫不及待年入百万可以根据上面目录直接开始学习了，以下可略过。</p><h3 id="算法还是后端？">算法还是后端？</h3><blockquote><p>读了个（<s>末流</s>）985硕士，也有篇不错的（<s>水</s>）论文，最后去做了当时本科毕业就能做的开发岗？—《本科同学竟是我的面试官》系列。</p></blockquote><p>如果你和我有一样的困惑和选择，不妨来看看我的经历，也许会有点帮助。在这之前，我们先分析下算法和后端的各自优劣。</p><h4 id="算法-P-K-后端">算法 P.K. 后端</h4><p>在这里我将从，起薪、门槛、竞争强度、未来发展等维度来分析二者优劣。</p><ul><li>[注1]：以下均以一线大厂（腾讯、阿里、字节、美团等）为基准。</li><li>[注2]：CV=Computer Vision，NLP=Natural Language Processing 。</li><li>[注3]：非特别说明，不考虑特例情况。</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">算法</th><th style="text-align:center">后端</th></tr></thead><tbody><tr><td style="text-align:center"><strong>起薪</strong></td><td style="text-align:center">同级别比后端高：1~2K/月</td><td style="text-align:center">中档薪资：40W+</td></tr><tr><td style="text-align:center"><strong>简历门槛</strong></td><td style="text-align:center">211硕士起</td><td style="text-align:center">211本起（部分知名双非）</td></tr><tr><td style="text-align:center"><strong>竞争强度</strong></td><td style="text-align:center">CV&gt;&gt;搜广推&gt;NLP</td><td style="text-align:center">CV&gt;Java后端&gt;&gt;C++后端&gt;其它</td></tr><tr><td style="text-align:center"><strong>未来发展</strong></td><td style="text-align:center">二者发展相差不大，和个人强相关</td><td style="text-align:center">二者发展相差不大，和个人强相关</td></tr><tr><td style="text-align:center"><strong>其它</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>可以看到，CV竞争强度远大于其它算法岗位，即使和后端中竞争最激烈的<strong>Java后端</strong>相比，也依旧更大。</p><p>在读研期间，我个人研究方向就是CV领域（Object Tracking），有一篇论文（CCF-A，三审）和几篇专利。但是并没有信心去竞争CV相关岗位（学历和论文无优势），也对深度学习产生了迷茫：<u>调参和模型缝补也许并不是我想做的事，虽然有更底层的研究方向但自己的数学基础不够牢靠</u>。</p><p>就这样，带着<strong>七分迷茫三分盲目自信</strong> 的我一股脑扎进Java的苦海。可是<strong>Java后端岗位</strong>的竞争激烈程度远超我想象，实习和秋招一直都在失业边缘疯狂试探。无论是实习还是秋招，最后我接受的Offer都是<strong>C++后端岗位(腾讯)</strong> ，可以说是现实Java小丑了。</p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/b393ec036fd14f3c9d9610f7d0c839ff.png" alt="2021Q1天猫淘宝同比增长达53%，爆发的男士香水市场背后……_品牌" style="zoom:67%;" /><p>现在回头想想，Java后端竞争之所以这么激烈也基本是必然的：互联网的高薪（<s>和996</s>）吸引了大量其它专业转行的同学，而Java相比C++：易上手速成、需求大、生态丰富（<s>培训班一条龙服务</s>），自然是首选。</p><p>那么：<strong>到底是选择Java后端还是C++后端呢?</strong> 这里我也简单分析一下各自优劣，大家可以根据个人情况进行抉择。</p><h4 id="Java后端-P-K-C-后端">Java后端 P.K. C++后端</h4><blockquote><p>一家之言，仅供参考。</p></blockquote><p>在这里我将从，起薪&amp;门槛、岗位需求，竞争强度、未来发展等维度来分析二者优劣。</p><ul><li>[注1]：以下均以一线大厂（腾讯、阿里、字节、美团等）为基准。</li><li>[注2]：非特别说明，不考虑特例情况。</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><strong>Java后端</strong></th><th style="text-align:center"><strong>C++后端</strong></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>起薪&amp;门槛</strong></td><td style="text-align:center">基本一致</td><td style="text-align:center">基本一致</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>岗位需求</strong></td><td style="text-align:center">非常多</td><td style="text-align:center">一般</td><td style="text-align:center"><strong>今年嵌入式爆热</strong>，C++岗位需求预计会增加</td></tr><tr><td style="text-align:center"><strong>竞争强度</strong></td><td style="text-align:center">非常大，Java&gt;&gt;C++</td><td style="text-align:center">一般</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>未来发展</strong></td><td style="text-align:center">相差不大，和个人相关</td><td style="text-align:center">相差不大，和个人相关</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>其它</strong></td><td style="text-align:center">银行和国企等<strong>养老性质</strong>单位对Java需求比较大，后期职业发展<strong>有更多选择</strong></td><td style="text-align:center">C++岗位需求主要是<strong>大厂</strong>，后期职业发展跳槽<strong>可选较少</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>对口公司</strong></td><td style="text-align:center">阿里、美团等</td><td style="text-align:center">腾讯、百度、华为等</td><td style="text-align:center"></td></tr></tbody></table><p>相信看到这里的聪明你，根据自己的技术倾向、意向公司等已经有了大概的思路：</p><ul><li>想更容易去大厂，做一些更底层（网络、存储、操作系统、安全方面等）的事情，C++自然是不错的选择；</li><li>但是未来考虑去一些养老单位养老，对Web开发、移动开发等更感兴趣的话，Java应该是更好的选择。</li></ul><h3 id="求职时间节点"><strong>求职时间节点</strong></h3><p>整个实习和秋招，由于自己的拖延和懒散，所有的时间节点基本都是在DDL上反复横跳。如果不是运气还不错，现在说不定正在寝室抱着浅蓝色床单哭泣 😭 ，留下不学无术的泪水。</p><p>所以根据自己的经验，整理了一份<strong>我认为</strong>的完美求职时间节点，同时也整理了一份工作小丑时间节点安排，供对比参考。</p><ul><li>[注1]：年份以当年应届求职年份为准。</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">自律大佬 ⛹</th><th style="text-align:center">工作小丑 😹</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1月份</strong></td><td style="text-align:center">刷完<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a>，准备项目</td><td style="text-align:center">玩</td></tr><tr><td style="text-align:center"><strong>2月份</strong></td><td style="text-align:center">二刷LeetCode，开始背诵八股，优化项目</td><td style="text-align:center">继续玩</td></tr><tr><td style="text-align:center"><strong>3月份</strong></td><td style="text-align:center">八股基本烂熟，开始面试（<strong>找实习</strong>）小试锋芒</td><td style="text-align:center">焦虑的玩</td></tr><tr><td style="text-align:center"><strong>4月份</strong></td><td style="text-align:center">LeetCode和八股烂熟，收获众多大厂实习Offer，赢来工作小丑羡慕的赞叹</td><td style="text-align:center">特别焦虑，开始一边羡慕一边投简历，面试被无情暴打</td></tr><tr><td style="text-align:center"><strong>5月份</strong></td><td style="text-align:center">开始<strong>第一段</strong>大厂实习</td><td style="text-align:center">极度焦虑，开始熬夜准备刷题和八股，继续面试</td></tr><tr><td style="text-align:center"><strong>6月份</strong></td><td style="text-align:center">已实习两个月，同时面试收获了第二个大厂Offer，波澜不惊</td><td style="text-align:center">终于收获Offer，现代范进中举，奔走相告</td></tr><tr><td style="text-align:center"><strong>7月份</strong></td><td style="text-align:center">开始<strong>第二段</strong>大厂实习，开始<strong>提前批</strong></td><td style="text-align:center">实习第一个月，下班就是玩，<strong>提前批那是个啥？</strong></td></tr><tr><td style="text-align:center"><strong>8月份</strong></td><td style="text-align:center">第二段大厂实习二个月，提前批收获校招Offer，同时无意外<strong>转正</strong></td><td style="text-align:center">实习两个月，继续无视提前批，运气好也<strong>转正</strong>了</td></tr><tr><td style="text-align:center"><strong>9月份</strong></td><td style="text-align:center"><code>Offer收割机</code>+<code>SSP收割机</code>称号达成，羡慕听到麻</td><td style="text-align:center">又玩了半个月，开始投简历，捡了几家Offer，彻底躺平</td></tr><tr><td style="text-align:center"><strong>10月份</strong></td><td style="text-align:center">开始准备<strong>选调</strong></td><td style="text-align:center"><code>白菜收割机</code>称号达成，最终无奈选一颗大白菜<strong>结束秋招</strong></td></tr></tbody></table><ul><li><p><strong>关于实习</strong>：可以看到，工作小丑如果不是<strong>运气好转正</strong>，秋招<strong>凭借实习经历（另一方面也说明了实习的重要性</strong>）拿了几个Offer，整个求职过程并不乐观。</p></li><li><p><strong>关于提前批</strong> ：实习的时候<strong>一定要去准备提前批</strong>，提前批<strong>HC众多</strong>（特别是好岗位），<strong>难度也较低（亲身感受）</strong> ，拿到Offer的概率<strong>相比秋招</strong>会大很多。</p></li></ul><p>所以，大家<strong>尽量早点</strong>充分准备，找工作不至于长期处于焦虑状态。拼运气自然不如拼实力，当然也要劳逸结合，有空闲多和师兄打打LOL放松下也是很有必要的 🕹 ，哈哈。</p><h3 id="一些有用的app-网站"><strong>一些有用的app &amp; 网站</strong></h3><blockquote><p>未必全面，仅供参考。</p></blockquote><ul><li>[注1]：各大公司校招官网，比如：<a href="join.qq.com">腾讯校园招聘</a> ，最好先去提前一次性注册好简历。</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">应用/网站名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>网站</strong></td><td style="text-align:center"><a href="https://www.nowcoder.com/">牛客网</a></td><td style="text-align:center">找内推、看面经、求职交流等</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode-cn.com/">Leetcode</a></td><td style="text-align:center">刷题</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://codetop.cc/">codeTop</a></td><td style="text-align:center">刷题</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://www.wondercv.com/">超级简历</a></td><td style="text-align:center">制作简历的不二之选</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://www.hwh.zone">royhuang’s blog</a></td><td style="text-align:center">毛遂自荐，看看八股</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/">github</a></td><td style="text-align:center">神奇的地方，多在这里找各种资源：面经总结、项目教程等</td></tr><tr><td style="text-align:center"><strong>APP</strong></td><td style="text-align:center">牛客网</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">脉脉</td><td style="text-align:center">求职信息交流，国内最大的职场交流APP</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">闲鱼</td><td style="text-align:center">各种教学视频课程，不妨这里先搜一搜</td></tr></tbody></table><p>🔼 以上大概就是我求职所用到的，全部网站或APP，不算多但基本有点用。</p><h3 id="写在最后"><strong>写在最后</strong></h3><p>碎碎念又写了小几K字了，9月底结束秋招时，便想着把自己求职的笔记总结&amp;经历复盘。不知不觉又拖延/玩了两个月，这个星期把网站搞好了也正好顺手开始整理。写到这里，终于有了初步了结，感觉像是De一个大BUG 🐛 ，心情都舒畅了起来。</p><p>后面还会<strong>继续更新没填好的坑</strong>，e.g. 怎么准备一个秋招项目。也会开始记录一些<strong>C++音视频相关方向博文</strong>，和一些生活记录（虽然大部分时间都是无聊地待在寝室或家里）。当然，如果还有什么想要和我说的，可以在下面留言。</p><p>最后，给上我最诚挚的祝福：</p><div align = "center" style="bold"> <h5>“ 明年请务必倒挂我，谢谢。”</h5></div><h3 id="更新记录">更新记录</h3><div class="timeline"><div class="timenode"><div class="meta"><p><p>2021-11-29 ：更新文档</p></p></div><div class="body"><ol><li>更新校招心得记录 &amp; 重新分类整理笔记</li><li>支持评论系统</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-11-24 ：第一次更新</p></p></div><div class="body"><ol><li>上传所有笔记并发布</li></ol></div></div></div> <div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Java Guide：https://github.com/Snailclimb/JavaGuide<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">阿秀C++面试笔记：https://github.com/forthespada/InterviewGuide<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">牛客网面经：https://www.nowcoder.com/interview/center<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 目录 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础笔记（初步整理）</title>
      <link href="/p/43848/"/>
      <url>/p/43848/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="一、Git-简介">一、Git 简介</h2><h3 id="1-1-安装">1.1 安装</h3><ul><li><p>安装地址</p><p>官网下载：<a href="https://git-scm.com/downloads">Git官网下载</a></p></li><li><p>设置用户信息</p><p>主要是设置 ： 名字 &amp; Email 地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;hwh&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;380141202@qq.com&quot;</span></span><br></pre></td></tr></table></figure><p><code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p></li></ul><h3 id="1-2-创建版本库">1.2 创建版本库</h3><ul><li><p>创建仓库</p><p>​       windows可以直接在桌面创建一个名为：&quot;Git&quot;文件夹，下有“test”子文件夹，子文件夹含有一个名为“<a href="http://readme.md">readme.md</a>”文件。</p><p>​       然后切换到其目录下（这里切换的是&quot;Git&quot;文件夹，而非“test”子文件夹）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> Git/</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/c/Users/86151/Desktop/Git</span><br></pre></td></tr></table></figure></li><li><p>初步提交过程</p><ul><li><p>初始化仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure></li><li><p>修改仓库文件</p><p>将“test”子文件夹，下readme.md文件，增加内容。</p></li><li><p>添加文件到仓库</p><p>注意：可以同时 一次添加<strong>多个</strong>文件到仓库！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure></li><li><p>提交文件</p><p>可以增加m参数：添加修改信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;第一次文件改动&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="二、时光机穿梭">二、时光机穿梭</h2><h3 id="2-0-更多控制修改提交">2.0 更多控制修改提交</h3><ul><li><p>概览</p><ul><li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li><li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff &lt;filepath&gt;</code>可以查看修改内容。</li></ul></li><li><p>实操</p><ul><li><p>再次修改文件</p><p>可以先清除原文件，再增添readme.md文档内容 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“i am  huitailang , here  is my first test word .“</span><br><span class="line"></span><br><span class="line"> “这是我第二次修改这个文件”</span><br></pre></td></tr></table></figure><p>使用 <code>git status</code>，查看状态发现readme.md文件已被修改但未提交（<strong>no changes</strong>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560766427962.png" alt="1560766427962"></p></li><li><p>查看具体修改了什么内容</p><p><code>git diff &lt;filepath&gt;</code>查看文件具体修改，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560766437006.png" alt="1560766437006"></p></li><li><p>添加仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure><p>同时可用 <code>git status</code>，查看此时状态会显示，readme.md将要被提交修改。</p></li><li><p>提交仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;这是我第二次修改&quot;</span></span><br></pre></td></tr></table></figure><p>​     再用 <code>git status</code>，查看仓库当前状态，显示没有需要提交的修改，而且工作目录是干净的（working tree clean）。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560766449576.png" alt="1560766449576"></p></li></ul></li></ul><h3 id="2-1-版本回退">2.1 版本回退</h3><ul><li><p>概览</p><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本</li></ul></li><li><p>实操</p><ul><li><p>N次修改文件</p><p>先多修改几次文件提交，得到多个版本。</p></li><li><p>版本回退</p><ul><li><p>查看版本历史</p><p><code>git log </code>查看当前版本和之前的历史，<code>git relog</code> 查看所有版本历史</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span>  <span class="comment"># 可以加上 --pretty=oneline 参数使显示更简洁</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560778515569.png" alt="1560778515569"></p></li></ul></li><li><p>回退版本</p><p><code>git reset --hard &lt;指定版本&gt;</code>：可用于回到指定版本，&lt;<strong>指定版本</strong>&gt;方式：</p><ul><li><p>HEAD ^</p><p>HEAD ^ 回到上个版本；HEAD ^ ^  回到上上 个版本，依此类推。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^^  <span class="comment"># 回到上上个版本</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560779037449.png" alt="1560779037449"></p></li><li><p>HEAD~&lt;数字&gt;</p><p>回到前&lt;数字&gt;版本。如HEAD~100，回到前100个版本。</p></li><li><p><commit ID> :</p><p>commit ID 不用打全，一般打前面几个字符即可。如，如果回退第2版本，<code>git log</code>，只能看到第2版本及之前的版本信息。那么可用 <code>git reflog</code>查看所有版本ID，然后指定ID，回到第4版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560779323726.png" alt="1560779323726"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 3928d   <span class="comment"># 再次回到第四次修改版本</span></span><br><span class="line">HEAD is now at 3928d9f 第四次修改</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="2-2-工作区和暂存区">2.2 工作区和暂存区</h3><ul><li><p>概览</p><ul><li>理解工作区和暂存区的区别，暂存区是版本库的一个子集</li><li>比较文件有三个不同命令<ul><li>git diff   <filename></li><li>git diff  --cached <filename></li><li>git diff  --HEAD <filename></li></ul></li></ul></li><li><p>工作区</p><p>工作区就是我们能看到的目录，如我前面创建的<code>Git</code>文件夹就是一个工作区</p></li><li><p>版本库 &amp; 暂存区</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/0" alt="git-repo"></p><p>工作区有一个隐藏目录<code>.git</code>，不属于工作区而是Git版本库，版本库包含</p><ul><li><p>Git自动创建的分支<code>master</code>&amp;指向<code>master</code>的指针<code>HEAD</code></p></li><li><p>stage（或叫index）暂存区</p></li></ul></li><li><p>暂存区工作</p><ul><li><p><strong>git add</strong></p><p>这一步实际上就是把文件修改（已存在被修改 OR 新文件）添加到暂存区，可以add多个文件，一次被提交。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/0" alt="git-stage"></p></li><li><p><strong>git commit</strong></p><p>把暂存区的<strong>所有</strong>内容提交到当前分支。</p><p>但是注意，git commit 后<strong>暂存区文件不会消失</strong>，始终是上一次git add之后文件！</p></li><li><p><strong>git diff</strong>  &amp;<strong>git diff --cached</strong> &amp;<strong>git diff HEAD</strong></p><p>git diff  比较的是<strong>工作区文件和暂存区文件</strong>区别。</p><p>git diff --cached 比较的是<strong>暂存区文件和仓库分支文件</strong>区别。</p><p>git diff --HEAD 比较的是<strong>工作区文件和仓库分支最新版本</strong>区别。</p><ul><li><p>暂存区：就是 .git / index 这个文件，git add 会把工作区修改的文件添加到暂存区，即使 git commit 后也不会空，<strong>始终保存最近一次 git add后的内容</strong>。</p></li><li><p>仓库分支：<strong>始终保存上次git commit 内容</strong>。</p></li></ul></li></ul></li></ul><h3 id="2-3-管理修改">2.3 管理修改</h3><ul><li><p>概览</p><ul><li>git管理的是修改，而非文件</li></ul></li><li><p>实操</p><p>新建一个文件 readme1.txt，然后依次：</p><blockquote><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p></blockquote><p>​      用<code>git diff HEAD test/readme1.txt</code> 比较<strong>工作区和版本分支</strong>，会发现第二次修改没有被提交，说明git只把git add后暂存区内容提交了，而不管理文件。</p><p>如果要把第二次修改也提交了，需要进行以下操作：</p><blockquote><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改-&gt; <code>git add</code>  -&gt; <code>git commit</code></p></blockquote></li></ul><h3 id="2-4-撤销修改">2.4 撤销修改</h3><ul><li><p>概览</p><ul><li><p>场景1：改乱了工作区某个文件的内容，想直接丢弃工作区的修改时</p><p>用命令<code>git checkout -- file</code>。</p></li><li><p>场景2：不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改</p><ul><li>第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1</li><li>第二步按场景1操作。</li></ul></li><li><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交</p><p>参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p></li></ul></li><li><p>实操</p><ul><li><p>场景1</p><p>不小心在文件里增加了一句话：</p><blockquote><p>刘婷是傻子</p></blockquote><p>用 <code>git checkout</code>命令撤回工作区修改，有两种情况</p><ul><li><code>readme.txt</code>修改但未被放到暂存区，撤销修改就回到和版本库一样状态；</li><li><code>readme.txt</code>修改且添加到暂存区后，撤销修改就回到添加到暂存区后的状态。</li></ul><blockquote><p>⚠️ 总之，就是让文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>🕵所以，也可用于恢复误删的文件（撤销工作区删除操作）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560826918878.png" alt="1560826918878"></p></li><li><p>场景2</p><p>不小心在文件里增加了一句话，而且已经git add提交到暂存区</p><blockquote><p>刘婷是傻子哈哈哈</p></blockquote><p>命令<code>git reset </code><strong>不仅可以回退版本 而且可以把暂存区的修改撤销</strong>。</p><p>⚠️之所以不直接 git checkout 是因为此时会用<strong>暂存区内容覆盖工作区</strong>，显然不行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD <span class="built_in">test</span>/readme.md <span class="comment"># HEAD表示最新版本</span></span><br></pre></td></tr></table></figure><p>然后此时再用git checkout ，暂存区内容覆盖工作区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure><p>再次查看文件发现，‘’刘婷是傻子哈哈哈‘’ 的胡话已经被没了，暂存区也没了。</p></li><li><p>场景3</p><p>又说胡话，不但 git add 且git  commit（暂存区和版本库<strong>HEAD</strong>都是修改后版本）</p><blockquote><p>刘婷是傻子哈哈哈哈哈哈</p></blockquote><p>这个时候只有回退版本了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog  <span class="comment"># 查看版本号</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard  3928</span><br><span class="line">HEAD is now at 3928d9f 第四次修改</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-5-删除文件">2.5 删除文件</h3><ul><li><p>rm 删除</p><ul><li><p>原理</p><p>rm 删除文件，只相当于删除了 工作区文件，如果要恢复文件撤销工作区修改即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure></li><li><p>恢复</p><p>用<code>git checkout -- &lt;file&gt;</code>，它会用最新版本库文件（如果已经git add 用最新暂存区内容，见前）覆盖工作区文件，则相当于撤销工作区修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure></li></ul></li><li><p>git rm 删除</p><ul><li><p>原理</p><p>git rm 删除文件，不但相当于<strong>删除工作区文件 &amp;  而且git add添加到暂存区</strong>。</p><p>所以此时直接<code>git checkout </code>是用暂存区内容覆盖 工作区，显然是没用的。</p></li><li><p>恢复</p><ul><li><p>先恢复暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD <span class="built_in">test</span>/readme.md <span class="comment"># HEAD表示最新版本</span></span><br></pre></td></tr></table></figure></li><li><p>再用暂存区覆盖工作区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- <span class="built_in">test</span>/readme.md</span><br></pre></td></tr></table></figure></li></ul></li><li><p>彻底删除</p><p>如前所述，git rm 已经删除了 ①工作区文件 ② 添加到暂存区，那么此时只需要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --m <span class="string">&#x27;彻底删除&#x27;</span>  <span class="comment"># 将③版本库内容也修改</span></span><br></pre></td></tr></table></figure><p>那么文件就会从工作区、暂存区、版本库全部删除。</p></li><li><p>彻底删除恢复</p><p>如果已经commit，那么只能<code>git reset</code>回退版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard  3928</span><br><span class="line">HEAD is now at 3928d9f 第四次修改</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="三、远程仓库">三、远程仓库</h2><h3 id="3-1-添加远程库上传本地文件">3.1 添加远程库上传本地文件</h3><blockquote><p>以下操作基于默认你</p><ul><li>创建好 github 账号 &amp; 创建好一个仓库</li><li>设置好本地ssh -key 而且已经同时在github网页服务端账号设置里添加 ssh -key</li></ul></blockquote><ol><li><p>添加用户信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;hwh&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;380141202@qq.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>初始化本地仓库</p><blockquote><p>如果本地仓库从未被初始化才需要，初始化会创建一个隐藏的 .git 文件管理版本。</p></blockquote><ul><li><p>cd切换 + git init</p><p>cd命令切换到后本地仓库；</p><p>git init 初始化本地仓库，会为你创建一个 .git文件，已经初始化不用。</p></li><li><p>手动 bash</p><blockquote><p>⚠️ 很奇怪的是，这样 git add . --&gt; git commit --&gt; git push后，会把整个父文件夹推送上去。</p><p>比如：地址 TEST 文件夹下有 <a href="http://README.md">README.md</a> ，推送后github上显示的 TEST文件夹，而不是我想的README.md文件。</p></blockquote><p>右击本地仓库，选择<code>Git Bash here</code></p></li></ul></li><li><p>把本地仓库添加到版本库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add .  <span class="comment"># add . 提交所有新建、修改文件</span></span><br><span class="line">$ git commit -m <span class="string">&#x27;第一次添加本地仓库到版本库&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>本地仓库关联远程库</p><p><code>git remote add &lt;远程库名设置&gt;  &lt;远程仓库地址&gt;</code></p><p>显然这里把<strong>远程仓库地址设置为 origin</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:huangwanghuiYY/gitTest.git</span><br></pre></td></tr></table></figure></li><li><p>推送到远程库</p><p>下面代码表示：将本地<code>master</code>分支推送到远程仓库<code>origin</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master  <span class="comment"># 第一次推送带 -u 参数</span></span><br></pre></td></tr></table></figure><p><code>-u</code>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2-从远程库克隆">3.2 从远程库克隆</h3><blockquote><p>​       当我们想多人协作时会用到克隆。比如有一个不错的开源项目，你可以克隆到<code>本地仓库</code>进行修改等。</p></blockquote><ol><li><p>确定要克隆的仓库</p><p>比如我的XSurvey项目。</p></li><li><p>git clone 进行克隆</p><p>克隆会在<code>当前文件夹</code>创建克隆的仓库，克隆仓库以XSuery为名，下含项目文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:huangwanghuiYY/XSurvey.git</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560943024969.png" alt="1560943024969"></p></li></ol><h2 id="四、分支管理">四、分支管理</h2><h3 id="4-1-创建和合并分支">4.1 创建和合并分支</h3><blockquote><p>这一节，涉及大量图形，<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424">廖雪峰教程</a>  讲的很好，这里尽量精简记录心得。</p></blockquote><ul><li><p>概述</p><ul><li><p>查看分支：<code>git branch</code></p></li><li><p>创建分支：<code>git branch &lt;name&gt;</code></p></li><li><p>切换分支：<code>git checkout &lt;name&gt;</code></p></li><li><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p></li><li><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p></li><li><p>删除分支：<code>git branch -d &lt;name&gt;</code></p></li></ul></li><li><p>实操记录</p><ul><li><p>主分支</p><p>​       <code>master</code>分支也是一条时间线，每次<strong>提交</strong> master 分支都会向前移动一步，随着不断提交 master分支也就越长。</p><p>⚠️下图有两个指针：<code>HEAD</code> &amp; <code>master</code> ，<code>HEAD</code>严格来说不是指向提交。HEAD指向master，master指向最新分支。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/0" alt="git-br-initial"></p></li><li><p>新分支创建切换</p><ul><li><p>创建新分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev1   <span class="comment"># 新建分支</span></span><br><span class="line">$ git branch        <span class="comment"># 查看分支</span></span><br><span class="line">  dev1</span><br><span class="line">* master           <span class="comment"># * 表示当前所在的分支（master）</span></span><br></pre></td></tr></table></figure><p>​     当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>指向的提交。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1560997582503.png" alt="1560997582503"></p></li><li><p>切换到当前分支</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev1</span><br></pre></td></tr></table></figure><p>如果checkout 加上 -b参数，表示 创建 &amp; 切换两个操作</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev1</span><br></pre></td></tr></table></figure><p>切换到当前分支，其实把head指向master所指向的提交。</p><p>⚠️这张图，还表示dev分支还执行了<strong>一次提交</strong>。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/0" alt="git-br-dev-fd"></p></li></ul></li><li><p>合并分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master  <span class="comment"># 先切回master分支（即HEAD指向master）</span></span><br><span class="line">$ git merge dev1   <span class="comment"># 表示当前分支（master）合并 dev1分支</span></span><br></pre></td></tr></table></figure><p>根据上图我们可以看到：</p><p>​      <code>dev</code>分支向前走了一步，<code>dev</code>指向了<strong>当前最新</strong>提交，而<code>master</code>指针依然指向<strong>上次</strong>提交。</p><p>​      如果要合并，那么直接<strong>让<code>master</code>指向<code>dev</code>指向的当前提交</strong> 。相当于，master也提交过一次。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/0" alt="git-br-ff-merge"></p></li><li><p>删除分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure><p>​     删除分支，等价于删除创建分支后的提交记录（上图红色线），但由于master指向了最新提交，等价复制dev1的提交记录（蓝色线）。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/0" alt="git-br-rm"></p><p>​</p></li></ul></li></ul><h3 id="4-2-解决同时修改冲突">4.2 解决同时修改冲突</h3><ul><li><p>产生冲突原因</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561001334904.png" alt="1561001334904"></p><ul><li><p>在master分支上</p><ul><li><p>在当前<code>master</code>分支上，创建一个新分支  <code>dev2</code></p></li><li><p>同时master分支上，对README.md文件增加一句话</p><blockquote><p>i said master</p></blockquote></li><li><p>⚠️ 然后，<code>git add  --&gt; git commit</code></p></li></ul></li><li><p>在dev2分支上</p><ul><li><p>checkout切回master分支上，对README.md文件增加一句话</p><blockquote><p>i said dev2</p></blockquote></li><li><p>⚠️ 然后，<code>git add  --&gt; git commit</code></p></li></ul></li><li><p>合并</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge dev2</span><br></pre></td></tr></table></figure><p>显示，README.md文件同时被修改，发生冲突（也可用 <code>git status</code> 查看）</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561001544117.png" alt="1561001544117"></p><p>vim 查看文件显示具体冲突：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim README.md <span class="comment">#当前HEAD指向master，所以下图显示HEAD</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561001684363.png" alt="1561001684363"></p></li></ul></li><li><p>解决冲突</p><p>Ⓜ️此时<strong>两</strong><a href="http://xn--README-ov7i.md">个README.md</a><strong>已经是一个文件了</strong>，文件内容就是上图vim查看的<strong>所有</strong>内容 。</p><p>我们再命令行端口也可以看到，提示我们在 master|MERGING 合并中。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561002765319.png" alt="1561002765319"></p><p>​     我们打开文件，修改文件内容为：（第一句话有误，此时实在master分支上，不用在意）</p><blockquote><p>这是的dev分支，我增加了一句话</p><p>修改冲突，这里变成这样。其实不修改直接提交也解决冲突，只是没解决同时修改。</p></blockquote><p>然后再提交，发现冲突已经解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add README.md </span><br><span class="line">$ git commit -m <span class="string">&#x27;解决冲突&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561002865426.png" alt="1561002865426"></p></li></ul><h3 id="4-3-分支管理策略-–-禁用Fast-forward">4.3 分支管理策略 – 禁用Fast forward</h3><ul><li><p>概览</p><blockquote><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，则直接把 master 的指针直接指向了 dev 分支的最新提交，这样两个分支的最新提交的 commit id 就是一样的。但这种模式下，删除分支后，会丢掉分支信息。</p><p><strong>加上<code>--no-ff</code>参数，强制禁用<code>Fast forward</code>模式，使用普通模式</strong>。Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p></blockquote></li><li><p>实操</p><blockquote><p>默认已经创建好分支 dev3，且修该了文，进行了一次<strong>commit</strong>。</p><p>然后下面都是在 master分支上尝试合并操作</p></blockquote><ol><li><p>切回master</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure></li><li><p>合并分支</p><p>–no–ff ： 普通模式合并。</p><p>-m ：由于本次合并<strong>dev</strong>要创建一个新的commit，所以加上<code>-m</code>参数，添加描述。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">&quot;merge with no-ff&quot;</span> dev</span><br></pre></td></tr></table></figure></li><li><p>查看历史</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure></li><li><p>Fast forward模式 &amp; 普通模式 对比</p><blockquote><p>FF模式不用<code>--no-ff</code>，实际上只是将master的指针update成dev分支而已。用的还是dev的commit ID。</p><p>普通模式用，则是重新commit一次，有了新的commit ID，<strong>保留了分支版本记录</strong>。</p></blockquote><ul><li><p>Fast forward模式</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/0" alt="git-br-ff-merge"></p></li><li><p>普通模式</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/0" alt="git-no-ff-mode"></p></li></ul></li></ol></li></ul><h3 id="4-4-BUG分支—git-stash">4.4 BUG分支—git stash</h3><ul><li><p>概览</p><blockquote><p>​      修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>​      当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p></blockquote></li><li><p>实操（应用场景）</p><ol><li><p>master 上面发布的是A的1.0版本</p></li><li><p>dev 上开发的是A的2.0版本 ，<strong>刚刚新建了test文件</strong> &amp;<strong><a href="http://xn--README-2g0js76l.md">修改README.md</a></strong>：</p><blockquote><p>这里是dev分支。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561019801527.png" alt="1561019801527"></p></li><li><p>这时，用户反映 1.0版本存在漏洞，有人利用这个漏洞开外挂</p></li><li><p>需要从dev切换到master去填这个漏洞，正常必须先提交dev目前的工作，才能切换。</p><ul><li><p>如果不commit切换分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master </span><br></pre></td></tr></table></figure><p>发现当前工作目录，是dev分支工作目录！</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561018815751.png" alt="1561018815751"></p></li><li><p>解释1</p><blockquote><p>一个本地的git repo只有一个工作区和暂存区，但是有多个分支的提交区，而我们的checkout只是将HEAD指针从一个分支切换到另一个分支。</p></blockquote><p>所以：</p><ol><li><p>切换后工作区内容是branch的工作内容</p></li><li><p>经过测试，如果切回dev分支，进行<code>add --&gt; commi</code>t 再切回master就回到       master工作区。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561019439523.png" alt="1561019439523"></p></li></ol></li></ul></li><li><p>而dev的工作还未完成，不想提交，所以先把dev的工作stash一下，然后切换到master：</p><ol><li><p>先git add test</p><blockquote><p>⚠️  为什么要先add test文件？</p><p>test文件是新建，还未被git管理！让git add<strong>追踪test文件</strong>，否则即使 git stash ，test文件也依然会出现在master工作目录中！</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li><li><p>git stash 然后切换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561021862083.png" alt="1561021862083"></p></li><li><p>恢复dev工作目录</p><p>简单恢复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop  <span class="comment"># 恢复的同时把stash内容也删了</span></span><br></pre></td></tr></table></figure><p>有多个因此目录，可以配合下面目录恢复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list  </span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br><span class="line">$ git stash apply stash@&#123;0&#125; <span class="comment"># 恢复不会删除stash内容</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>在master建立分支issue101并切换。</p></li><li><p>在issue101上修复漏洞。</p></li><li><p>修复后，在master上合并issue101  。</p></li><li><p>切回dev，恢复原本工作，继续工作。</p></li></ol></li></ul><h3 id="4-5-删除分支">4.5 删除分支</h3><p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h3 id="4-6-多人协作">4.6 多人协作</h3><ul><li><p><strong>查看分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v  <span class="comment"># 带-v参数查看更加详细</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561023498006.png" alt="1561023498006"></p></li><li><p><strong>push 推送分支</strong></p><p><code>git push &lt;远程库名&gt; &lt;要推送分支名&gt;</code></p><blockquote><p>​      推送本地主分支master到 origin master，相当用本地master版本覆盖远程origin master版本。</p><p>⚠️ git push 只能用户该项目属于自己的情况，因为要输入账号密码！参与他人开源：</p><ul><li>成为该开源项目贡献者（由项目作者设置）</li><li>fork 该项目 ----&gt; clone到本地----&gt; 修改 ----&gt; 发起 pull requset —&gt; 讨论 &amp; 等待合并</li></ul><p>还有其他更多情况，如产生冲突等，查看：<a href="%5Bhttps://progit.bootcss.com/#_%E5%AF%B9%E9%A1%B9%E7%9B%AE%E5%81%9A%E5%87%BA%E8%B4%A1%E7%8C%AE%5D(https://progit.bootcss.com/#_%E5%AF%B9%E9%A1%B9%E7%9B%AE%E5%81%9A%E5%87%BA%E8%B4%A1%E7%8C%AE)">pro git 中文# 对项目做出贡献</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561024444763.png" alt="1561024444763"></p><blockquote><p>推送其他分支到远程库 ，也可以查看。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561024648502.png" alt="1561024648502"></p></li><li><p>clone 克隆分支工作</p><p>多人协作时，大家都会往<strong>远程库</strong><code>master</code>和<code>dev</code>分支上推送各自的修改。</p><ol><li><p>克隆主分支</p><blockquote><p>⚠️ 克隆只能克隆master分支！！</p></blockquote><p>现在，模拟你的小伙伴，在另一台电脑（注意要把SSH Key添加到GitHub）克隆：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:michaelliao/Python-100-Days</span><br></pre></td></tr></table></figure></li><li><p>克隆远程dev分支开发</p><p>由于只能克隆master分支，而又要在远程dev分支开发，那么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>之后就可进行修改 —&gt; 提交 ：git push了</p></li></ol></li><li><p><code>git pull</code></p><blockquote><p>一种应用情况：A、B都克隆了项目，在远程分支dev上进行开发（分别在本地也克隆dev分支）</p><ol><li><p>A修改了文件 README，并进行了push提交 。</p></li><li><p>你也修改了README，进行提交修改，会出错，原因是</p><p>⚠️<strong>远程分支比你的本地更新！</strong></p></li><li><p>只有先 pull 最新分支你的分支合并 —&gt; 解决冲突—&gt;提交</p></li></ol></blockquote><p><code>git pull</code>命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并，它的完整格式稍稍有点复杂。</p><blockquote><p>在默认模式下，<code>git pull</code>是<code>git fetch</code>后跟<code>git merge FETCH_HEAD</code>的缩写。</p><p>git pull == git fetch+  git merge （默认是检索头部合并到当前分支）</p><p>⚠️ 使用–rebase，它运行<code>git rebase</code>而不是<code>git merge</code>。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull&lt;可选参数&gt; &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span></span><br></pre></td></tr></table></figure><h2 id="示例">示例</h2><p>比如，要取回<code>origin</code>主机的<code>next</code>分支，与本地的<code>master</code>分支合并：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin next:master</span></span><br></pre></td></tr></table></figure><ul><li><p>省略当前分支名</p><p>如果远程分支(<code>next</code>)要与当前分支合并，则冒号后面的部分可以省略。上面命令可以简写为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin next</span></span><br></pre></td></tr></table></figure><p>上面命令表示，取回<code>origin/next</code>分支，再与当前分支合并。实质上，这等同于先做<code>git fetch</code>，再执行<code>git merge</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/next</span></span><br></pre></td></tr></table></figure></li><li><p>省略远程分支名</p><blockquote><p>某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在<code>git clone</code>的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的<code>master</code>分支自动”追踪”<code>origin/master</code>分支。</p><p>Git也允许手动建立追踪关系，指定<code>master</code>分支追踪<code>origin/next</code>分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream master origin/next</span></span><br></pre></td></tr></table></figure></blockquote><p>如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin</span></span><br></pre></td></tr></table></figure><p>上面命令表示，本地的当前分支自动与对应的<code>origin</code>主机”追踪分支”(remote-tracking branch)进行合并。</p></li><li><p>省略远程主机名</p><p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>git fetch和git pull的区别</strong></p><ol><li><em>git fetch</em>：相当于是从远程获取最新版本到本地，不会自动合并。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p master..origin/master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/master</span></span><br></pre></td></tr></table></figure><p>以上命令的含义：</p><ul><li>首先从远程的<code>origin</code>的<code>master</code>主分支下载最新的版本到<code>origin/master</code>分支上</li><li>然后比较本地的<code>master</code>分支和<code>origin/master</code>分支的差别</li><li>最后进行合并</li></ul><p>上述过程其实可以用以下更清晰的方式来进行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin master:tmp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff tmp</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge tmp</span></span><br></pre></td></tr></table></figure><ol start="2"><li><em>git pull</em>：相当于是从远程获取最新版本并<code>merge</code>到本地</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin maste</span><br></pre></td></tr></table></figure></li></ul><h2 id="五、标签管理">五、标签管理</h2><h3 id="5-1-创建标签">5.1 创建标签</h3><h3 id="5-2-操作标签">5.2 操作标签</h3><h2 id="六、使用Github">六、使用Github</h2><h3 id="6-1-简单上传">6.1 简单上传</h3><ol><li><p>设置用户信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;hwh&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;380141202@qq.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>git init 初始化仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></li><li><p>本地创建ssh key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;380141202@qq.com&quot;</span> <span class="comment"># 后面会要求设置密码可不设置</span></span><br></pre></td></tr></table></figure><p>然后会在：C:\Users\80651\.ssh 生成ssh key 文件，其下有一个公钥 <code>id_rsa.pub</code>，记事本打开复制。</p></li><li><p>打开github设置</p><p>打开github 在个人设置中添加**2.**中ssh key。</p><p>可用 <code>ssh -T</code>查看是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></li><li><p>对文件一些操作</p><p>比如，这里以增加一个README文件，然后<strong>git commit 提交</strong>到版本库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add README   <span class="comment"># 也可add . 提交所有新建、修改文件</span></span><br><span class="line">$ git commit -m <span class="string">&#x27;增加readme&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>push 上传到版本库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><blockquote><p>Q : git push 出现错误 ‘’ error: failed to push some refs to git‘’</p><p>A : 一般是因为github中的<code>README.md</code>文件不在本地代码目录中</p><ul><li><p>添加 -f 参数强制覆盖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure></li><li><p>通过如下命令进行github与本地代码合并:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git pull --rebase origin master   <span class="comment"># 先和本地代码合并</span></span><br><span class="line">$ git push    <span class="comment"># 然后再上传</span></span><br></pre></td></tr></table></figure></li></ul></blockquote></li></ol><h3 id="6-2-参与开源项目">6.2 参与开源项目</h3><blockquote><p>可参考：<a href="https://www.zhihu.com/question/21682976/answer/79489643">GitHub的Pull Request 是指什么意思</a></p></blockquote><h2 id="七、自定义Git">七、自定义Git</h2><ol><li><p>服务器端安装Git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install git</span><br></pre></td></tr></table></figure></li><li><p>创建用户 &amp; 组 管理仓库目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ groupadd git</span><br><span class="line">$ useradd git -g git  <span class="comment"># -g 参数表示把用户gituser主组设置为 git</span></span><br></pre></td></tr></table></figure></li><li><p>创建目录</p><p>我们先创建一个目录<code>gitrepo</code>用来管理其下仓库，一般习惯在 /var下创建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var</span><br><span class="line">$ mkdir gitrepo</span><br></pre></td></tr></table></figure><p>给其设置好用户 &amp; 组，便于管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chown -R gituser:git gitrepo <span class="comment"># 把目录gitrepo 设置用户gituser &amp; 组 git</span></span><br></pre></td></tr></table></figure><p><code>ls -l</code> 查看是否设置成功：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561122220352.png" alt="1561122220352"></p></li><li><p>创建仓库</p><p>创建<code>hwhComputer2Backup.git</code>仓库，并初始化用来上传电脑备份。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> gitrepo  <span class="comment"># 注意先切换到git下</span></span><br><span class="line">$ git init --bare hwhComputer2Backup.git</span><br></pre></td></tr></table></figure></li><li><p>创建证书</p><ul><li><p>在本地电脑上</p><p>执行以下命令创建ssh 公钥。会在：<code>C:\Users\80651\\.ssh</code> 生成ssh key 文件，其下有一个公钥 <code>id_rsa.pub</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;380141202@qq.com&quot;</span> <span class="comment"># 后面会要求设置密码可不设置</span></span><br></pre></td></tr></table></figure></li><li><p>切回服务端</p><blockquote><p>裸机需创建<code>/home/git/.ssh/authorized_keys</code>文件。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> gitrepo/</span><br><span class="line">$ mkdir .ssh</span><br><span class="line">$ touch .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>然后把本地电脑上公钥复制导入，一行一个（？）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561123680464.png" alt="1561123680464"></p></li></ul></li><li><p>再次修改权限</p><blockquote><p>创建的子目录 用户 &amp; 组 默认是 root root</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561124160395.png" alt="1561124160395"></p><p>⚠️由于.ssh &amp; 仓库 hwhComputer2Backup.git 都不属于 gituser ，所有还需设置权限。否则进行 push pull 操作 没有足够权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var</span><br><span class="line">$ chown -R gituser:git gitrepo</span><br></pre></td></tr></table></figure></li><li><p>本地上传文件</p><ol><li><p>添加用户信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;hwh&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;380141202@qq.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>初始化本地仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> D:/hwh/uploadToGit</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure></li><li><p>把本地仓库添加到版本库</p><blockquote><p>错误：c#程序练习 does not have a commit checked out</p><p>解决：是因为 c#程序练习 这个文件夹已经被初始化，查看隐藏文件可以发现 .git文件删除其即可。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add .  <span class="comment"># add . 提交所有新建、修改文件</span></span><br><span class="line">$ git commit -m <span class="string">&#x27;第一次备份文件&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>本地仓库关联远程库</p><blockquote><p>移除当前远程连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin </span><br></pre></td></tr></table></figure></blockquote><p><code>git remote add origin &lt;服务端用户名&gt;@&lt;远程库名地址&gt;:&lt;远程仓库地址&gt;</code></p><p>⚠️<code>&lt;服务端用户名&gt; :</code> 是在服务端的用户！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin gituser@129.28.154.240:/var/gitrepo/hwhComputer2Backup.git</span><br></pre></td></tr></table></figure></li><li><p>推送到远程库</p><blockquote><p>似乎由于 <em>ssh key</em> 设置不对，<em>git push</em> 要输入用户 <em>gituser</em> 的密码 123456？</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master  <span class="comment"># 第一次推送带 -u 参数</span></span><br></pre></td></tr></table></figure><p>等待上传服务器(速度有点慢)：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561128011507.png" alt="1561128011507"></p></li></ol></li></ol><h2 id="八、debug-记录">八、<code>debug</code> 记录</h2><blockquote><p><strong>ERROR</strong>：由于存在 <code>&gt;100M</code> 文件，提交后报错，不允许提交超过<code>100M</code> 文件，进行如下操作：</p><ul><li>压缩并删除<code>&gt;100M</code>文件</li><li>将相应文件加入 <code>.gitignore</code></li><li>再次<code>commit</code>  --&gt; <code>push</code></li></ul><p>依旧报相同错误。</p></blockquote><p>解决办法如下，参考：<a href="https://medium.com/@marcosantonocito/fixing-the-gh001-large-files-detected-you-may-want-to-try-git-large-file-storage-43336b983272">Fixing the “GH001…</a></p><ol><li><p>删除文件</p><blockquote><p>建议可以先回退最近的<code>commit</code> 分支</p></blockquote><p>利用以下命令删除所有在仓库中  <code>&gt;100M</code> 的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --index-filter <span class="string">&#x27;git rm --cached --ignore-unmatch &lt;大于100M文件URL&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>例如，我的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --index-filter <span class="string">&#x27;git rm --cached --ignore-unmatch  Experiment/Ex4_CustomerForecast/src/train.csv&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>再次提交</p><p>为了保险，可以先：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached ./   <span class="comment"># 本地代码不会被删除</span></span><br></pre></td></tr></table></figure><p>接下来正常：<code>git add --&gt; git commit --&gt; git push</code> 即可</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招笔记（九）_计算机基础_相关补充</title>
      <link href="/p/5582/"/>
      <url>/p/5582/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我的校招记录：<a href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>算法能力（“刷题”）</strong></td><td style="text-align:center">这部分就是耗时间多练习，<a href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td><td style="text-align:center">补充练习：<a href="https://codetop.cc/">codeTop</a></td></tr><tr><td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td><td style="text-align:center">C++后端后续更新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td><td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>项目&amp;实习</strong></td><td style="text-align:center">主要是怎么准备项目，后续更新</td><td style="text-align:center"></td></tr></tbody></table><h1>九、相关补充</h1><h2 id="9-1-（要扩充）设计模式">9.1 （要扩充）设计模式</h2><blockquote><p>没有足够实际代码经验，只好先写这些应付下面试。</p></blockquote><h4 id="1-说说什么是单例模式-手写一个？">1.说说什么是单例模式 ?手写一个？</h4><p>单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。</p><ul><li><p><strong>手写单例模式</strong></p><blockquote><p>参考：<a href="https://www.runoob.com/design-pattern/singleton-pattern.html">https://www.runoob.com/design-pattern/singleton-pattern.html</a></p></blockquote><blockquote><p>记忆：“2private + 1public ”</p></blockquote><ol><li><p><strong>饿汉式</strong></p><p>线程安全 ， 但：类加载时就初始化，浪费内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建 SingleObject 的一个对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingleObject();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// *让构造函数为 private，这样该类就不会被实例化</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 获取唯一可用的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>懒汉式（不加锁）</strong></p><p>只有真正调用获取实例对象时，才会创建一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 调用时才判断</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) </span><br><span class="line">    &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>懒汉式（加锁）</strong></p><p>线程安全，但加锁性能不够高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="comment">// 就是多了个synchronized关键字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>双检锁式</strong></p><p>懒汉式（加锁）虽然可以保证只创建一个单例，但其性能不高，因为每次访问<strong>整个方法都加锁</strong>。</p><p>因此出现双检索式，在<code>instance=new DoubleCheckSingleton();</code> 进行加锁 ， <code>return instance;</code><strong>不加锁</strong>！</p><blockquote><p><strong>为什么要进行两次检查instance==null？</strong></p><ol><li><p>第一层检查作用</p><p>主要为了提高性能。如果没有第一层，上来就要加锁比较耗费性能</p></li><li><p>第二层检查作用</p><p>解决多线程并发问题。假设是第一次开始执行<code>getInstance</code>方法：</p><ol><li>A，B两个线程，此时<code>instance==null</code> ，A，B都通过了第一层检查。</li><li>假设A先拿到锁，往下执行创建一个实例，然后释放了锁；</li><li>此时B也拿到了锁，<strong>如果没有第二层检查，B会进行重新new一个实例</strong>，违背单例模式！</li></ol></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckSingleton</span></span></span><br><span class="line"><span class="class"></span>&#123;      </span><br><span class="line">     <span class="comment">// volitale 关键字修饰，避免指令重排，因为初始化操作是不原子化的 ：</span></span><br><span class="line">    <span class="comment">//  (1) 给DoubleCheckSingleton类的实例instance分配内存</span></span><br><span class="line">    <span class="comment">//  (2) 调用实例instance的构造函数来初始化成员变量</span></span><br><span class="line">    <span class="comment">//  (3) 将instance指向分配的内存地址</span></span><br><span class="line">    <span class="comment">//  在多线程中，A可能是 1→3→2的顺序，执行到1→3，此时另外一个线程看到instance不为null（因为前面线程执行了3）就直接返回实例。而此时并没有被分配内存故可能出现问题。</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123; <span class="comment">//第一层检查，是否存在实例</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckSingleton.class)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123; <span class="comment">//第二层检查，防止出现另外一个线程阻塞在synchronized，获得锁后重复创建实例</span></span><br><span class="line"></span><br><span class="line">                    instance=<span class="keyword">new</span> DoubleCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="2-说说你对代理模式的理解？">2.<strong>说说你对代理模式的理解</strong>？</h4><p>代理模式是给某一个对象提供一个代理，并由<strong>代理对象控制对原对象的引用</strong>。</p><ul><li><strong>优点</strong>：代理模式能够协调调用者和被调用者，<u>在一定程度上降低了系统的<strong>耦合度</strong></u>；可以<u>灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务</u>。</li><li><strong>缺点</strong>：由于使用了代理模式，因此程序的性能<u>没有直接调用性能高</u>；使用代理模式<u>提高了代码的复杂度</u>。</li></ul><h4 id="3-说说简单工厂模式？">3.<strong>说说简单工厂模式</strong>？</h4><p>简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，<strong>对实现了同一接口的一些类进行实例的创建</strong>。</p><ul><li><p>比如，一台咖啡机就可以理解为一个工厂模式，你只需要按下想喝的咖啡品类的按钮（摩卡或拿铁），它就会给你生产一杯相应的咖啡，你不需要管它内部的具体实现，只要告诉它你的需求即可；</p></li><li><p>【<strong>优点</strong>】<strong>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例</strong>，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；</p></li><li><p>【<strong>缺点</strong>】 不易拓展，<u>一旦添加新的产品类型，就不得不修改工厂的创建逻辑</u>； 产品类型较多时，工厂的创建逻辑可能过于复杂，一旦出错可能造成所有产品的创建失败，不利于系统的维护。</p></li></ul><h4 id="4-说说抽象工厂模式？">4.<strong>说说抽象工厂模式</strong>？</h4><p>抽象工厂模式是在简单工厂的基础上将未来<strong>可能需要修改的代码抽象出来</strong>，通过继承的方式让子类去做决定。</p><ul><li>【<strong>简单工厂模式缺点</strong>】以上面的咖啡工厂为例，某天我的口味突然变了，<u>不想喝咖啡了想喝啤酒，这个时候如果直接修改简单工厂里面的代码</u>，这种做法不但不够优雅，也不符合软件设计的“开闭原则”，因为每次新增品类都要修改原来的代码。</li><li>【<strong>抽象工厂</strong>】<strong>抽象工厂里只声明方法，具体的实现交给子类（子工厂）去实现</strong>，这个时候再有新增品类的需求，只需要新创建代码即可。如，创建一个啤酒工厂而不是咖啡工厂。</li></ul><h4 id="5-装饰器模式是什么？">5.<strong>装饰器模式是什么</strong>？</h4><blockquote><p>不够深入。</p></blockquote><p>装饰器模式是指<u>动态地给一个对象增加一些额外的功能</u>，同时<strong>又不改变其结构</strong>。</p><h2 id="9-2-分布式问题【校招必问】">9.2 分布式问题【校招必问】</h2><blockquote><p>非常系统的总结文档：<a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/03%20%20%E9%9D%A2%E8%AF%95%E5%AE%98%E5%A6%82%E4%BD%95%E8%80%83%E5%AF%9F%E4%B8%8E%20CAP%20%E6%9C%89%E5%85%B3%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%EF%BC%9F.md">分布式相关：第一页</a></p></blockquote><p>CAP 理论指的是什么：C（Consistency）是数据一致性、A（Availability）是服务可用性、P（Partition tolerance）是分区容错性。</p><ul><li><p><strong>问题引入</strong></p><p>现在有一个分布式系统 A，它有一个副本 A1，在正常情况下，客户端 Client 写数据到系统 A，然后数据从 A 节点同步到 A1 节点，再返回给 Client 成功状态。</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/assets/CgqCHl_-eW2ALOs5AAFBvaYD4f8199.png" alt="6.png"></p><p>但由于网络是不可靠的，节点 A 和 A1 的网络随时会因为中断而出现分区。所谓网络分区就是由于网络不通导致节点 A 和 A1 被隔离在不同的网络子集中，此时节点 A 的数据就不能及时同步到节点 A1 中了。</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/assets/Ciqc1F_-eXaAcu6nAAE3Pk18sD8666.png" alt="7.png"></p></li></ul><h4 id="9-1-1-在CAP基础上讲讲BASE？举实例说说？">9.1.1 在CAP基础上讲讲BASE？举实例说说？</h4><p>BASE 理论，它是 CAP 理论的延伸。BASE 是 Basically Available（基本可用）、Soft State（软状态）和 Eventually Consistent（最终一致性）三个单词的简写，作用是保证系统的可用性，然后通过<strong>最终一致性来代替强一致性</strong>，它是目前分布式系统设计中最具指导意义的经验总结。</p><p>其实是做了“可用性”方面的妥协，比如：</p><ul><li>电商网站在双十一大促等访问压力较大的时候，关闭商品排行榜等次要功能的展示，从而保证商品交易主流程的可用性，这也是我们常说的<strong>服务降级；</strong></li><li>为了错开双十一高峰期，电商网站会将<strong>预售商品的支付时间</strong>延后十到二十分钟，这就是<strong>流量削峰</strong>；</li><li>在你抢购商品的时候，往往会在队列中等待处理，这也是常用的<strong>延迟队列</strong>。</li></ul><p>软状态和最终一致性指的是允许系统中的数据存在中间状态，这同样是<strong>为了系统可用性而牺牲一段时间窗内的数据一致性</strong>，从而保证最终的数据一致性的做法。</p><h4 id="9-1-2-亿级商品分布式存储问题？">9.1.2 亿级商品分布式存储问题？</h4><h5 id="1-如何设计一个支持海量商品存储的高扩展性架构？">1.如何设计一个支持海量商品存储的高扩展性架构？</h5><p><strong>从这一点出发会考察你Hash（哈希）分片的具体实现原理</strong>。</p><ol><li>以商品 ID 作为关键字进行分片，系统会通过一个 Hash 函数计算商品 ID 的 Hash 值，然后取模，就能得到对应的分片；</li></ol><h5 id="2-在做分库分表时，基于-Hash-取模和一致性-Hash-的数据分片是如何实现的？">2.在做分库分表时，基于 Hash 取模和一致性 Hash 的数据分片是如何实现的？</h5><ol><li><strong>解决 Hash 分片的缺点，既保证数据均匀分布，又保证扩展性</strong> ，最终采用一致性 Hash ：它是指将存储节点和数据都映射到一个首尾相连的哈希环上。</li><li>具体见前，一致性哈希相关算法描述</li></ol><h5 id="3-在电商大促时期，如何对热点商品数据做存储策略-？">3.在电商大促时期，如何对热点商品数据做存储策略 ？</h5><ul><li><p><strong>问题</strong></p><p>一致性 Hash 提升了稳定性，使节点的加入和退出不会造成大规模的数据迁移，但<strong>本质上 Hash 分片是一种静态的分片方式</strong>，必须要提前设定分片的最大规模，<strong>而且无法避免单一热点问题，</strong> 某一数据被海量并发请求后，不论如何进行 Hash，数据也只能存在一个节点上，这势必会带来热点请求问题。</p></li><li><p><strong>解决</strong></p><p><strong>做 Range（范围）分片</strong>。 与 Hash 分片不同的是，Range 分片能结合业务逻辑规则，例如，我们用 “Category（商品类目）” 作为关键字进行<strong>动态分片时</strong>，不是以统一的商品一级类目为标准，而是可以按照一、二、三级类目进行灵活分片。例如，对于京东强势的 3C 品类，可以按照 3C 的三级品类设置分片；对于弱势品类，可以先按照一级品类进行分片，这样会让分片间的数据更加平衡。</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/assets/CgpVE1_-ed6AfUBMAAFtDc6PlH4881.png" alt="15.png"></p></li></ul><p><strong>4.强一致性和最终一致性的数据共识算法是如何实现的</strong>？</p><h4 id="9-1-3-海量并发，分布式事务一致性问题？">9.1.3 海量并发，分布式事务一致性问题？</h4><ul><li><p><strong>什么是分布式事务问题</strong>？</p><p>一次大的操作由多个小操作组成，这些<strong>小的操作分布在不同的服务器上</strong>，分布式事务需要<strong>保证这些小操作要么全部成功，要么全部失败</strong>。</p><p>举一个实例：</p><ul><li>京东旅行系统，拆分成多个子系统，如商品系统、促销系统、订单系统。用户下单时，<strong>订单系统生成订单，商品系统扣减库存，促销系统扣减优惠券</strong>，<strong>只有当三个系统的事务都提交之后，才认为此次下单成功</strong>，否则失败。</li></ul></li><li><p><strong>解决方案</strong></p><p>有两阶段提交协议（Two-Phase Commit，2PC）、3PC 、TCC 和基于消息队列的实现方式。</p><ul><li><p><strong>错误回答</strong>：方案很多，可以选择 2PC ，2PC 实现的流程是…</p></li><li><p><strong>错误原因</strong>： 因为在实际工作中，<strong>很少采用前几种方案（互联网中落地方案代价大）</strong>，基本都是基于 MQ 的可靠消息投递的方式来实现。</p></li><li><p><strong>正确回答</strong>：先介绍目前主流实现分布式系统事务一致性的方案（也就是基于 MQ 的可靠消息投递的机制）然后回答出可实现方案和关键知识点。另外，<strong>为了和面试官进一步交流，你可以提出 2PC 或 TCC</strong> （这是一种交流方案）。</p></li><li><p><strong>回答一、基于 MQ 的可靠消息投递方案</strong></p><ul><li><p><strong>什么是MQ</strong></p><p>核心的五个概念：</p><ol><li><strong>Queue</strong>: 真正存储数据的地方</li><li><strong>Exchange</strong>: 接收请求，转存数据</li><li><strong>Bind:</strong> 收到请求后存储到哪里</li><li><strong>消息生产者</strong>:发送数据的应用</li><li><strong>消息消费者</strong>: 取出数据处理的应用</li></ol></li><li><p><strong>场景实例</strong></p><blockquote><p><strong>订单系统（1）完成订单后，（2）购物车系统减购物车中的商品</strong>。</p></blockquote><p><img src="https://i.loli.net/2021/09/05/B2uKDL8cyfhplis.png" alt="img"></p><ol><li><p>订单系统在<strong>消息队列上</strong>开启一个事务（没有创建订单）；</p></li><li><p>订单系统给消息服务器发送一个“半消息”；</p><blockquote><p>这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，<strong>在事务提交之前，对于消费者来说，这个消息是不可见的</strong>。</p></blockquote></li><li><p>半消息发送成功后，<strong>订单系统就可以执行本地事务了</strong>，在订单库中创建一条订单记录，并提交订单库的数据库事务。</p></li><li><p>然后<strong>根据本地事务的执行结果决定提交或者回滚事务消息</strong>。</p><blockquote><p>如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。</p></blockquote></li><li><p>购物系统消费这条拿到的订单系统消息（<strong>确认了订单系统事务执行完毕</strong>），这样就可以继续下一步购物操作</p></li></ol></li></ul></li></ul></li></ul><h4 id="9-1-4-分布式锁问题">9.1.4 分布式锁问题</h4><blockquote><p><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/06%20%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F.md">06 分布式系统中，如何回答锁的实现原理？</a></p></blockquote><p>分布式锁是解决协调分布式系统之间，同步访问共享资源的一种方式。详细来讲：在分布式环境下，<strong>多个系统在同时操作共享资源</strong>（如写数据）时，发起操作的系统通常会通过一种方式去协调其他系统，然后获取访问权限，得到访问权限后才可以写入数据，其他系统必须等待权限释放。</p><img src="https://i.loli.net/2021/09/05/f7Fh83wrnqvH6PK.png" alt="image-20210905232542573" style="zoom:80%;" /><ul><li><p><strong>基于redis的分布式锁</strong></p><p><strong>使用setnx命令加锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongGetLock1</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 第一步：加锁</span></span><br><span class="line">    Long result = jedis.setnx(lockKey, requestId);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 第二步：设置过期时间</span></span><br><span class="line">        jedis.expire(lockKey, expireTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>setnx命令，意思就是 set if not exist，<strong>如果lockKey不存在，把key存入Redis</strong>，保存成功后如果result返回1，表示设置成功，如果非1，表示失败，别的线程已经设置过了。</p></li><li><p>expire()，设置过期时间，防止死锁，假设，如果一个锁set后，一直不删掉，那这个锁相当于一直存在，产生死锁。</p></li></ul></li></ul><p><strong>解决setnx与expire不是一个原子操作</strong></p><ul><li><p>加锁总共分两步，第一步jedis.setnx，第二步jedis.expire设置过期时间，setnx与expire不是一个原子操作，如果程序执行完第一步后异常了，第二步jedis.expire(lockKey, expireTime)没有得到执行，<strong>相当于这个锁没有过期时间，有产生死锁的可能</strong>。</p></li><li><p>解决方案为：一步操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockDemo</span> </span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">&quot;NX&quot;</span>;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">&quot;PX&quot;</span>;   </span><br><span class="line">        <span class="comment">/**     </span></span><br><span class="line"><span class="comment">        * 获取分布式锁    </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> jedis Redis客户端     </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> lockKey 锁    </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> requestId 请求标识     </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> expireTime 超期时间     </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> 是否获取功     */</span>   </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span></span></span><br><span class="line"><span class="function">   </span>&#123;    </span><br><span class="line">           <span class="comment">// 两步合二为一，一行代码加锁并设置 + 过期时间。       </span></span><br><span class="line">     <span class="keyword">if</span> (<span class="number">1</span> == jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime))</span><br><span class="line">      &#123;           </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//加锁成功        </span></span><br><span class="line">      &#125;       </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//加锁失败   </span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 解锁：对应del删除key即可</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;           </span><br><span class="line">      <span class="comment">// 第一步： 使用 requestId 判断加锁与解锁是不是同一个客户端    </span></span><br><span class="line">      <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) </span><br><span class="line">      &#123;       </span><br><span class="line">          <span class="comment">// 第二步： 若在此时，这把锁突然不是这个客户端的，则会误解锁     </span></span><br><span class="line">          jedis.del(lockKey);    </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​</p><ul><li><p><strong>基于Zoopkeeper的分布式锁</strong></p><blockquote><p>sync，lock也只能保证你当前机器线程安全，这样分布式访问还是有问题。</p><p>建议参考：<a href="https://www.cnblogs.com/aobing/p/12650036.html">https://www.cnblogs.com/aobing/p/12650036.html</a></p></blockquote><p>一个机器接收到了请求之后，先获取 zookeeper 上的一把分布式锁（zk会创建一个 znode），执行操作；然后另外一个机器也<strong>尝试去创建</strong>那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等待，等第一个机器执行完了方可拿到锁。</p><p>下面是创建临时顺序节点的情况：</p><ol><li><p>客户端调用create()方法创建名为“/dlm-locks/lockname/lock-”的临时顺序节点。</p></li><li><p>客户端调用getChildren(“lockname”)方法来获取所有已经创建的子节点。</p></li><li><p>客户端获取到所有子节点path之后，如果发现<strong>自己在步骤1中创建的节点是所有节点中序号最小</strong>的，就是看自己创建的序列号是否排第一，如果是第一，那么<strong>就认为这个客户端获得了锁</strong>，在它前面没有别的客户端拿到锁。</p></li><li><p>如果创建的节点不是所有节点中需要最小的，那么则<strong>监视比自己创建节点的序列号小的最大的节点，进入等待</strong>。直到下次监视的<strong>子节点变更的时候</strong>，再进行子节点的获取，判断是否获取锁。</p></li></ol></li><li><p><strong>基于关系型数据库 MySQL 实现分布式锁</strong></p><blockquote><p>参考：<a href="https://juejin.cn/post/6844904137172189198">https://juejin.cn/post/6844904137172189198</a></p></blockquote><p>利用 Mysql 的锁表，创建一张表，设置一个 UNIQUE KEY（如，<strong>利用主键ID的唯一性</strong>） 这个 KEY 就是要锁的 KEY，所以同一个 KEY 在mysql表里只能插入一次了。</p><blockquote><p>这样对锁的竞争就交给了数据库，处理同一个 KEY 数据库保证了只有一个节点能插入成功，其他节点都会插入失败。</p></blockquote><p>定义加锁、解锁代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lock</span> ：  </span></span><br><span class="line"><span class="function">    <span class="title">exec</span> <span class="title">sql</span>:</span> insert into lockedtable (xxx) values (xxx)    </span><br><span class="line">    <span class="keyword">if</span> result == true :       </span><br><span class="line">         <span class="keyword">return</span> true    </span><br><span class="line">    <span class="keyword">else</span> :        </span><br><span class="line">         <span class="keyword">return</span> falsedef </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">unlock</span> ：   # 解锁就是删除</span></span><br><span class="line"><span class="function"> <span class="title">exec</span> <span class="title">sql</span>:</span> delete <span class="keyword">from</span> lockedOrder where order_id=<span class="string">&#x27;order_id&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="9-3-其它问题">9.3 其它问题</h2><h4 id="1-【字节-懂车帝】什么是跨域？">1. 【字节-懂车帝】什么是跨域？</h4><blockquote><p>参考：<a href="https://www.jianshu.com/p/f049ac7e2220">https://www.jianshu.com/p/f049ac7e2220</a></p></blockquote><p>跨域，是指浏览器不能执行其他网站的脚本。它是由<strong>浏览器的同源策略</strong>造成的，是浏览器对JavaScript实施的安全限制。</p><p>同源策略限制了一下行为：</p><ol><li><p>Cookie、LocalStorage 和 IndexDB 无法读取</p></li><li><p>DOM 和 JS 对象无法获取</p></li><li><p>Ajax请求发送不出去</p></li></ol><p>具体的一些实例：</p><ol><li><p><strong>非跨域</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxxyyy.cn/index.html 调用 http://www.xxxyyy.cn/server.php 非跨域</span><br></pre></td></tr></table></figure></li><li><p><strong>跨域：主域不同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxxyyy.cn/index.html 调用  http://www.xxx.cn/server.php</span><br></pre></td></tr></table></figure></li><li><p><strong>跨域：子域名不同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://abc.xxxyyy.cn/index.html 调用  http://def.xxx.cn/server.php</span><br></pre></td></tr></table></figure></li><li><p><strong>跨域：端口不同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.cn:**8080**/index.html 调用  http://www.xxx.cn/server.php</span><br></pre></td></tr></table></figure></li><li><p><strong>跨域：协议不同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**https**://www.xxx.cn/index.html 调用  **http**://www.xxx.cn/server.php</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 校招笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
