<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>XXX | royhuang's blog</title><meta name="keywords" content="C++ / Java / Backend / Daily life"><meta name="author" content="Wanghui Huang"><meta name="copyright" content="Wanghui Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言找工作记录的刷题笔记。  TO  DO 补充SQL算法题  虾皮专场1. 栈实现队列 https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;implement-queue-using-stacks&#x2F;   思路 设置两个栈S1、S2 ，S1始终用来当做队列存元素，S2用作中转栈。当需要操作（取，删除）S1中队头元素，就pop S1中元素到S2中，操作完成后再pop S2中元素回来S1">
<meta property="og:type" content="article">
<meta property="og:title" content="XXX">
<meta property="og:url" content="http://example.com/2021/11/25/%E5%B7%A5%E4%BD%9C%E4%B8%80_%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="royhuang&#39;s blog">
<meta property="og:description" content="前言找工作记录的刷题笔记。  TO  DO 补充SQL算法题  虾皮专场1. 栈实现队列 https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;implement-queue-using-stacks&#x2F;   思路 设置两个栈S1、S2 ，S1始终用来当做队列存元素，S2用作中转栈。当需要操作（取，删除）S1中队头元素，就pop S1中元素到S2中，操作完成后再pop S2中元素回来S1">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-11-25T03:34:30.479Z">
<meta property="article:modified_time" content="2021-11-25T03:49:00.735Z">
<meta property="article:author" content="Wanghui Huang">
<meta property="article:tag" content="C++ &#x2F; Java &#x2F; Backend &#x2F; Daily life">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/cat.jpg"><link rel="canonical" href="http://example.com/2021/11/25/%E5%B7%A5%E4%BD%9C%E4%B8%80_%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":"true# copy button","highlightLang":false,"highlightHeightLimit":400},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":100,"languages":{"author":"Author: Wanghui Huang","link":"Link: ","source":"Source: royhuang's blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'XXX',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-25 11:49:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">royhuang's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">XXX</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-11-25T03:34:30.479Z" title="Created 2021-11-25 11:34:30">2021-11-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-11-25T03:49:00.735Z" title="Updated 2021-11-25 11:49:00">2021-11-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">32.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>134min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="XXX"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>找工作记录的刷题笔记。</p>
<p><img src="https://i.loli.net/2021/04/29/5lEu6pPCfAR2Lct.png" alt="image-20210429214007842"></p>
<h3 id="TO-DO"><a href="#TO-DO" class="headerlink" title="TO  DO"></a>TO  DO</h3><ol>
<li>补充SQL算法题</li>
</ol>
<h2 id="虾皮专场"><a href="#虾皮专场" class="headerlink" title="虾皮专场"></a>虾皮专场</h2><h3 id="1-栈实现队列"><a href="#1-栈实现队列" class="headerlink" title="1. 栈实现队列"></a>1. 栈实现队列</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">https://leetcode-cn.com/problems/implement-queue-using-stacks/</a></p>
</blockquote>
<ul>
<li><p>思路</p>
<p>设置两个栈S1、S2 ，S1始终用来当做队列存元素，S2用作中转栈。当需要操作（取，删除）S1中队头元素，就pop S1中元素到S2中，操作完成后再pop S2中元素回来S1。</p>
</li>
<li><p>代码</p>
<p>代码<strong>易错点1、2</strong>见下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1 ;</span><br><span class="line">    Stack&lt;Integer&gt; stack2 ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 【易错点1】在这里使用 for(int i=0 ; i&lt;stack1.size();i++ ) 判断，</span></span><br><span class="line">            <span class="comment">// 但是stack1.size()是变量，随着循环会不断减少。</span></span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = stack2.pop();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 【易错点2】不用傻傻再倒回去，此时stack2，从栈顶到栈尾就是队列的顺序</span></span><br><span class="line"><span class="comment">        // stack2为空再倒回去就行</span></span><br><span class="line"><span class="comment">        while(!stack2.isEmpty())</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            stack1.push(stack2.pop());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = stack2.peek();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 【易错点2】不用傻傻再倒回去，此时stack2，从栈顶到栈尾就是队列的顺序</span></span><br><span class="line"><span class="comment">        while(!stack2.isEmpty())</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            stack1.push(stack2.pop());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (stack1.isEmpty() &amp;&amp; stack2.isEmpty()) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>代码（进阶：用自己实现的栈）</p>
<p>注意：泛型数组不能直接初始化，而且先定义一个Object数组再强制转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackDemo</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** 底层使用一个泛型数组做存储 */</span></span><br><span class="line">    <span class="keyword">private</span> E[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//会调用下面一个构造方法,初始化一个长度为10的数组</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackDemo</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity=i;</span><br><span class="line">        <span class="comment">// 【易错3】泛型数组不能直接初始化，而且先定义一个Object数组再强制转换。</span></span><br><span class="line">        <span class="keyword">this</span>.items=(E[])<span class="keyword">new</span> Object [<span class="keyword">this</span>.capacity];</span><br><span class="line">        <span class="keyword">this</span>.top=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top!=capacity)&#123;</span><br><span class="line">            items[top++]=e;</span><br><span class="line">            <span class="comment">//判断数据是不是已经满了,看需不需要扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出栈操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            E ret=items[--top];</span><br><span class="line">            items[top]=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * resize操作,把数组扩大两倍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果top和capacity相等的话,说明满了</span></span><br><span class="line">        <span class="keyword">if</span>(top==capacity)&#123;</span><br><span class="line">            <span class="comment">// 把范围扩大2倍</span></span><br><span class="line">            <span class="keyword">this</span>.capacity = <span class="keyword">this</span>.capacity*<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// new一个新数组</span></span><br><span class="line">            E[] newItems = (E[])<span class="keyword">new</span> Object [<span class="keyword">this</span>.capacity];</span><br><span class="line">            <span class="comment">// 转移老数据</span></span><br><span class="line">            System.arraycopy(items,<span class="number">0</span>,newItems,<span class="number">0</span>,items.length);</span><br><span class="line">            <span class="comment">// 把新的数组当成底层的存储</span></span><br><span class="line">            <span class="keyword">this</span>.items = newItems;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StackDemo&lt;String&gt; stack = <span class="keyword">new</span> StackDemo&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stack.push(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">            stack.push(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">            stack.push(<span class="string">&quot;third&quot;</span>);</span><br><span class="line">            stack.push(<span class="string">&quot;four&quot;</span>);</span><br><span class="line">            String pop = stack.pop();</span><br><span class="line">            System.out.println(pop);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-LRUCache"><a href="#2-LRUCache" class="headerlink" title="2. LRUCache"></a>2. LRUCache</h3><p>hashmap + 双向的linklist，略。</p>
<h3 id="3-相交链表"><a href="#3-相交链表" class="headerlink" title="3. 相交链表"></a>3. 相交链表</h3><p>注意下面两点：</p>
<ol>
<li>计算差值要用绝对值</li>
<li>判断相等，比较的是节点，所以返回第一个相等的节点就可以了</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode pA = headA ; </span><br><span class="line">        ListNode pB = headB ; </span><br><span class="line">        <span class="comment">// 计算A、B链表长度之差</span></span><br><span class="line">        <span class="keyword">int</span> lenA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lenB = <span class="number">0</span> ; </span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pA != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pA = pA.next;</span><br><span class="line">            lenA++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pB != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pB = pB.next;</span><br><span class="line">            lenB++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A1：绝对值</span></span><br><span class="line">        d = Math.abs(lenA-lenB);</span><br><span class="line">        <span class="comment">// 更长的先走d步</span></span><br><span class="line">        <span class="keyword">if</span>(lenA&lt;lenB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(d--&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               headB = headB.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(lenA&gt;lenB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(d--&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               headA = headA.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始一起走开始判断</span></span><br><span class="line">        <span class="keyword">while</span>(headA != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// A2 : 返回第一个相等的节点</span></span><br><span class="line">            <span class="keyword">if</span>(headA == headB)</span><br><span class="line">                <span class="keyword">return</span> headA;</span><br><span class="line">            headA = headA.next;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-有序链表合并"><a href="#4-有序链表合并" class="headerlink" title="4. 有序链表合并"></a>4. 有序链表合并</h3><p>没啥好说的，记住就行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建虚拟节点head,tail ，p1,p2初始指针分别指向l1、l2</span></span><br><span class="line">        <span class="comment">// 2. 比较p1、p2指针所指的值大小,更小的用tail指向</span></span><br><span class="line">        <span class="comment">// 3. 更新p1或p2指向下一个节点</span></span><br><span class="line">        <span class="comment">// 4. 最后串起来剩下未比较的节点</span></span><br><span class="line"></span><br><span class="line">       ListNode head = <span class="keyword">new</span> ListNode() ;</span><br><span class="line">       ListNode tail = head;</span><br><span class="line">       ListNode p1 = l1 , p2 = l2; </span><br><span class="line">      </span><br><span class="line">       <span class="keyword">while</span>(p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(p1.val &lt; p2.val)</span><br><span class="line">           &#123;</span><br><span class="line">               tail.next = p1;</span><br><span class="line">               tail = p1;</span><br><span class="line">               p1 = p1.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="comment">// 这里不能用if判断，因为上一个if会想修改这个if的判断条件</span></span><br><span class="line">           &#123;</span><br><span class="line">               tail.next = p2;</span><br><span class="line">               tail = p2;</span><br><span class="line">               p2 = p2.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(p1 == <span class="keyword">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               tail.next = p2;</span><br><span class="line">               tail = p2;</span><br><span class="line">               p2 = p2.next ;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(p2 == <span class="keyword">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">while</span>(p1 != <span class="keyword">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               tail.next = p1;</span><br><span class="line">               tail = p1;</span><br><span class="line">               p1 = p1.next ;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-反转链表"><a href="#5-反转链表" class="headerlink" title="5. 反转链表"></a><strong>5. 反转链表</strong></h3><p>注意下面，对象引用不是对象复制（clone）！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 记录两个指针p,q ， 初始分别指向链表第一个，第二个节点</span></span><br><span class="line">        <span class="comment">// 2. p-&gt;q 转换为 p&lt;-q </span></span><br><span class="line">        <span class="comment">// 3. 更新p，q同时往后移动，直至q为null</span></span><br><span class="line">        <span class="comment">// 4. 最后处理下head-&gt;next = null </span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> head;</span><br><span class="line">        ListNode p = head , q = head.next;</span><br><span class="line">        ListNode tmp = <span class="keyword">null</span> ;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 【易错】用tmp记录q的位置，在q.next = p，执行后尝试再去获取原先q.next</span></span><br><span class="line">          <span class="comment">// 此时tmp, q 都是指向同一个对象，q操作对象改变next指向后，tmp对应对象next也被改变了</span></span><br><span class="line">          <span class="comment">// 真要用tmp记录之前状态的q，应该是使用【重写clone方法】 </span></span><br><span class="line">           tmp = q.next;   </span><br><span class="line">           q.next = p;</span><br><span class="line">           p = q;</span><br><span class="line">           q = tmp; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> p;  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-两数之和"><a href="#6-两数之和" class="headerlink" title="6. 两数之和"></a>6. 两数之和</h3><p>注意两点：</p>
<ol>
<li>hashmap的 containsKey方法</li>
<li>返回的是数组下标</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// hashmap将数组每个值作为key存入</span></span><br><span class="line">       HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i++)</span><br><span class="line">       &#123;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i++)</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i]) &amp;&amp; map.get(target-nums[i]) != i )</span><br><span class="line">            &#123;</span><br><span class="line">                 res[<span class="number">0</span>] = i;</span><br><span class="line">                 res[<span class="number">1</span>] = map.get(target-nums[i]);</span><br><span class="line">                 <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125; </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-k个一组翻转链表"><a href="#7-k个一组翻转链表" class="headerlink" title="7. k个一组翻转链表"></a>7. k个一组翻转链表</h3><p>还是边界没有处理好，直接看原来的解法吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路</span></span><br><span class="line"><span class="comment">// 遍历链表找到每次反转的first,end 进行翻转</span></span><br><span class="line"><span class="comment">// *特别的：第一次翻转end是返回的头结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span> <span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode  pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode  f = head;</span><br><span class="line">        ListNode  e = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录翻转后链表第一个节点</span></span><br><span class="line">        ListNode firstNode = e;</span><br><span class="line">        <span class="keyword">while</span> (e!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 找到翻转段的尾节点e</span></span><br><span class="line">            <span class="keyword">if</span>(count % k == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 第一次翻转</span></span><br><span class="line">                <span class="keyword">if</span>(count == k)</span><br><span class="line">                    firstNode = e;</span><br><span class="line">                <span class="comment">// 翻转</span></span><br><span class="line">                reverse(pre,f,e);</span><br><span class="line">                <span class="comment">// *更新:注意此时段尾部是f</span></span><br><span class="line">                <span class="comment">// *尾部e移动了，要count+1</span></span><br><span class="line">                pre = f;</span><br><span class="line">                f = e = f.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            <span class="comment">// 无论哪种情况都要count++，所以移到这儿</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  firstNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指定链表段翻转</span></span><br><span class="line">    <span class="comment">// 先将[first-end] 节点反转，再修改反转后的首尾节点指向</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode pre,ListNode first,ListNode end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode p = <span class="keyword">null</span>;</span><br><span class="line">        ListNode q = first;</span><br><span class="line">        ListNode q_next = <span class="keyword">null</span>; <span class="comment">// 临时节点存储q.next</span></span><br><span class="line">        <span class="keyword">while</span> (p !=end )  <span class="comment">// 修改：到达末尾终止条件</span></span><br><span class="line">        &#123;</span><br><span class="line">            q_next = q.next;</span><br><span class="line">            q.next = p;</span><br><span class="line">            p = q;</span><br><span class="line">            q = q_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改：处理反转后的首尾节点指向</span></span><br><span class="line">        first.next = q;</span><br><span class="line">        <span class="comment">// 【边界情况】：从头节点开始反转</span></span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="keyword">null</span>)</span><br><span class="line">            pre.next=end;</span><br><span class="line">        <span class="comment">// *返回翻转后链表首节点end</span></span><br><span class="line">         <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-二叉树最近公共祖先"><a href="#8-二叉树最近公共祖先" class="headerlink" title="8. 二叉树最近公共祖先"></a>8. 二叉树最近公共祖先</h3><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/</a></p>
</blockquote>
<p>这个关键是明白：</p>
<ol>
<li>后序递归查找节点p，q ，叶子节点，这部分子树就返回节点（p,q,null）</li>
<li>由于是后序递归，每次都比较<strong>当前root左右子树的返回值</strong><ol>
<li>左右子树都有返回值，说明root就是当前最近公共祖先，返回</li>
<li>如果只有左或右子树（假设左）有返回值（不为null），返回左子树返回的节点当做最小公共节点，继续往上递归比较左右子树，看是否更新这个最小公共节点（一直没有更新，说明就是p是q的祖先这种情况）</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 叶子节点返回 ， 当前左、右子树找到了p或q也返回</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q )</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前左右子树都返回了节点（找到了 p,q 且异侧），返回root</span></span><br><span class="line">        <span class="comment">// 因为是从底层往上，所以此时root一定是最近的祖先</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子树不为null，但右子树为null，把左子树返回的节点当成以root为根的子树结果往上返回</span></span><br><span class="line">        <span class="comment">// 这样保证了：（1）找到了p，q子树的结果（节点）可以一直往上返回 （2）也保证了p是q的祖先节点，</span></span><br><span class="line">        <span class="comment">//              但是遍历到p就往上返回p，不用去再找到q</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> left;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        <span class="keyword">if</span>(right != <span class="keyword">null</span> &amp;&amp; left == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> right;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 左右子树都为null，且root不为p，q</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-删除链表重复元素"><a href="#9-删除链表重复元素" class="headerlink" title="9. 删除链表重复元素"></a>9. 删除链表重复元素</h3><p>注意不保留第一个重复元素，而是全部删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 设置节点p，q初始都指向head</span></span><br><span class="line">        <span class="comment">// 2. q往后遍历找到第一个不重复的节点</span></span><br><span class="line">        <span class="comment">// 3. 设置p-&gt;q，p=q , 重复2，直至q为null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这的q不要指向下一个节点比较好</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span> ,  p = head ,q = head ;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q.next == <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">return</span> head;</span><br><span class="line">            <span class="keyword">if</span>(p.val == q.next.val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 找到不重复的元素</span></span><br><span class="line">                <span class="keyword">while</span>(q.next != <span class="keyword">null</span> &amp;&amp;  p.val == q.next.val)</span><br><span class="line">                    q = q.next;</span><br><span class="line">                <span class="keyword">if</span>(pre == <span class="keyword">null</span>)  <span class="comment">// 考虑pre==null的情况</span></span><br><span class="line">                    head = q.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pre.next = q.next;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                 pre = p;   <span class="comment">// 删除重复元素的时候是不用更新pre</span></span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            p = q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-最大数"><a href="#10-最大数" class="headerlink" title="10. 最大数"></a>10. 最大数</h3><p>关键在于怎么比较两个字符串，java中自带的 compareTo可以比较两个字符串a，b：</p>
<ol>
<li>先比较字符串的首字符串的ASCII码，如果相同再比较下一个</li>
</ol>
<p>那么我们可以比较a+b 与 b+a来确定谁应该在前面。其它应该注意的地方：</p>
<ol>
<li>StringBuilder 常用的 append 、charAt、toString方法要记住</li>
<li>Arrays.sort 高级函数用法怎么写要记住  <code>Arrays.sort(数组,(参数..) -&gt; &#123; return 比较的逻辑 &#125;)</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       </span><br><span class="line">       String[] stringNums = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           stringNums[i] = String.valueOf(nums[i]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 要对JAVA的lambda熟悉</span></span><br><span class="line">       Arrays.sort</span><br><span class="line">       (</span><br><span class="line">           <span class="comment">// 数组,(参数..) -&gt; &#123; return 比较的逻辑 &#125;</span></span><br><span class="line">           <span class="comment">// 返回值&gt;0 ，则b和a互换 </span></span><br><span class="line">           stringNums,(a,b) -&gt; </span><br><span class="line">           &#123;</span><br><span class="line">              <span class="keyword">return</span>  (b+a).compareTo(a+b);</span><br><span class="line">           &#125;</span><br><span class="line">       );</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">       StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           sb.append(stringNums[i]);</span><br><span class="line">       &#125;   </span><br><span class="line">       <span class="comment">// toString() 可以将sb转换为String字符串</span></span><br><span class="line">              </span><br><span class="line">       <span class="keyword">if</span>(sb.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">           <span class="keyword">return</span>  <span class="keyword">new</span> String(<span class="string">&quot;0&quot;</span>); <span class="comment">// 或者直接返回:&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-二分查找"><a href="#11-二分查找" class="headerlink" title="11. 二分查找"></a>11. 二分查找</h3><p>注意：边界条件是 &lt;= 不是&lt; 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, e = len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s &lt;= e )  <span class="comment">// 这里是&lt;= , 不是&lt; </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (s+e)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[mid])</span><br><span class="line">                 <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                s = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                e = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-最长不重复子串"><a href="#12-最长不重复子串" class="headerlink" title="12. 最长不重复子串"></a>12. 最长不重复子串</h3><p>维持一个滑动窗口，rigth无论如何都++ ； left 当滑动窗口加入了重复的字符串就更新为left=重复的字符串下标+1。</p>
<p>注意以下两点：</p>
<ol>
<li><p>此题还可以用HashMap&lt;字符，字符下标&gt;记录窗口的所有值，每次都加入一个字符串都判断是否在hashmap中。</p>
<p>map.get&lt;新加入字符的下标&gt; left ，说明窗口内有重复，更新left = map.get&lt;新加入字符的下标&gt; 。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="comment">// 1. 设置指针left, rigth 分别在指向滑动窗口的左右, maxLen 记录窗口最大值，len记录长度</span></span><br><span class="line">         <span class="comment">// 2. 每次rigth向右移动，判断当前right指向的字符是否出现在窗口内 </span></span><br><span class="line">         <span class="comment">//    1） 如果不出现，则len+1，同时判断是否更新maxLen</span></span><br><span class="line">         <span class="comment">//    2） 如果出现，则left更新为窗口内出现重复字符串的下一个位置</span></span><br><span class="line">         <span class="comment">// 3. 重复2，直至rigth&gt;=字符串最大长度</span></span><br><span class="line">         <span class="keyword">int</span> left = <span class="number">0</span> , right = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> len  = <span class="number">1</span> , maxLen = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(s.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">         <span class="keyword">while</span>(right &lt; s.length()-<span class="number">1</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">int</span> idx = isExist(s,s.charAt(right+<span class="number">1</span>),left,right);</span><br><span class="line">             right++;</span><br><span class="line">             <span class="keyword">if</span>(idx == -<span class="number">1</span>) <span class="comment">// 不存在</span></span><br><span class="line">             &#123; </span><br><span class="line">                 len++;</span><br><span class="line">                 maxLen = len&gt;maxLen? len:maxLen; </span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 left = idx+<span class="number">1</span>;</span><br><span class="line">                 len = right-left+<span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> maxLen;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">isExist</span><span class="params">(String s ,<span class="keyword">char</span> c, <span class="keyword">int</span> left , <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = left ; i &lt;= right ; i++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(s.charAt(i) == c )</span><br><span class="line">                 <span class="keyword">return</span> i;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化后的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            max = Math.max(max,i-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-两数相加II"><a href="#13-两数相加II" class="headerlink" title="13. 两数相加II"></a>13. 两数相加II</h3><p>注意：</p>
<ol>
<li>想把链表反转 + 长度一致，做法有点复杂易错，比较好的做法还是：<strong>栈压入 + 新建节点构建新链表</strong>；</li>
<li>用<strong>尾插法</strong>，保证输出的结果是逆序的</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) </span><br><span class="line">    &#123;</span><br><span class="line">        // 1. 采用两个栈压入两个链表</span><br><span class="line">        // 2. 逐个弹出计算值，创建新节点</span><br><span class="line"></span><br><span class="line">        Stack&lt;ListNode&gt; s1  = new Stack&lt;ListNode&gt;();</span><br><span class="line">        Stack&lt;ListNode&gt; s2  = new Stack&lt;ListNode&gt;();</span><br><span class="line"></span><br><span class="line">        while(l1 != null)</span><br><span class="line">        &#123;</span><br><span class="line">            s1.push(l1);</span><br><span class="line">            l1=l1.next;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        while(l2 != null)</span><br><span class="line">        &#123;</span><br><span class="line">            s2.push(l2);</span><br><span class="line">            l2=l2.next;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        ListNode head = null;</span><br><span class="line">        int r = 0;</span><br><span class="line">        while(s1.size() != 0 &amp;&amp; s2.size() != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            int val1 = s1.pop().val;</span><br><span class="line">            int val2 = s2.pop().val;</span><br><span class="line">            int sum  =  val1 + val2 + r;</span><br><span class="line">            ListNode newNode = new ListNode(sum%10);</span><br><span class="line">            newNode.next = head;</span><br><span class="line">            head = newNode;</span><br><span class="line">            r = sum / 10;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(s1.size() != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            int sum = s1.pop().val + r ;</span><br><span class="line">            ListNode newNode = new ListNode(sum%10);</span><br><span class="line">            newNode.next = head;</span><br><span class="line">            head = newNode;</span><br><span class="line">            r = sum / 10;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(s2.size() != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            int sum = s2.pop().val + r ;</span><br><span class="line">            ListNode newNode = new ListNode(sum%10);</span><br><span class="line">            newNode.next = head;</span><br><span class="line">            head = newNode;</span><br><span class="line">            r = sum / 10;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(r != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode newNode = new ListNode(r);</span><br><span class="line">            newNode.next = head;</span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-三数之和"><a href="#14-三数之和" class="headerlink" title="14. 三数之和"></a>14. 三数之和</h3><h3 id="15-next树（空间O-1-）"><a href="#15-next树（空间O-1-）" class="headerlink" title="15. next树（空间O(1)）"></a>15. next树（空间O(1)）</h3><p>注意，要求常数的空间复杂度，下面这种是空间复杂度O(n)。</p>
<ol>
<li>一旦在某层的节点之间建立了 \text{next}next 指针，那这层节点实际上形成了一个<strong>链表</strong>。因此，如果先去建立某一层的 \text{next}next 指针，<strong>再去遍历这一层，就无需再使用队列了</strong>。</li>
<li>队列初始化是用 new LinkedList<Node>();</li>
</ol>
<p><strong>核心：</strong> 都是<strong>遍历当前层</strong>（出队/ 遍历next指针），来处理<strong>下一层</strong> （入队 / 设置next指针）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public Node <span class="function"><span class="title">connect</span>(<span class="params">Node root</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;Node&gt;  queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        root.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>)  <span class="comment">// 优化：cur表示当前层指针（初始第一个），这里只要cur不为null</span></span><br><span class="line">        &#123;</span><br><span class="line">            int len =  queue.size();  </span><br><span class="line">            <span class="comment">// Node preNode = null; </span></span><br><span class="line">            Node preNode = <span class="keyword">new</span> Node(<span class="number">0</span>);  <span class="comment">// 优化：这里为每一层链表设置个虚拟头节点比较好！！</span></span><br><span class="line">            <span class="keyword">while</span>(len-- &gt; <span class="number">0</span>)   <span class="comment">// 每次只加入下一层的节点，优化：根据cur是否为null来判断是否遍历完成</span></span><br><span class="line">            &#123;</span><br><span class="line">               Node tmpNode = queue.poll();</span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">               // 原始思路，是在当前层处理当前层所有节点的指向，但这样不太好</span></span><br><span class="line"><span class="comment">               //  还是在当前层处理下一层所有节点的指向比较好</span></span><br><span class="line"><span class="comment">               if(preNode != null) </span></span><br><span class="line"><span class="comment">               &#123;</span></span><br><span class="line"><span class="comment">                   preNode.next = tmpNode;</span></span><br><span class="line"><span class="comment">               &#125;</span></span><br><span class="line"><span class="comment">               preNode = tmpNode;</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               <span class="keyword">if</span>(tmpNode.left != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.offer(tmpNode.left); <span class="comment">// 使用链表这一步可以省略</span></span><br><span class="line">                    <span class="comment">// 在当前层处理下一层所有节点</span></span><br><span class="line">                    preNode.next = tmpNode.left;</span><br><span class="line">                    preNode  = tmpNode.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmpNode.right != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.offer(tmpNode.right); <span class="comment">// 使用链表这一步可以省略</span></span><br><span class="line">                    <span class="comment">// 在当前层处理下一层所有节点</span></span><br><span class="line">                    preNode.next = tmpNode.right;</span><br><span class="line">                    preNode  = tmpNode.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">                 preNode.next = <span class="literal">null</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化后O(1) 级别的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">//cur我们可以把它看做是每一层的链表</span></span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历当前层的时候，为了方便操作在下一</span></span><br><span class="line">        <span class="comment">//层前面添加一个哑结点（注意这里是访问</span></span><br><span class="line">        <span class="comment">//当前层的节点，然后把下一层的节点串起来）</span></span><br><span class="line">        Node dummy = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//pre表示访下一层节点的前一个节点</span></span><br><span class="line">        Node pre = dummy;</span><br><span class="line">        <span class="comment">//然后开始遍历当前层的链表</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果当前节点的左子节点不为空，就让pre节点</span></span><br><span class="line">                <span class="comment">//的next指向他，也就是把它串起来</span></span><br><span class="line">                pre.next = cur.left;</span><br><span class="line">                <span class="comment">//然后再更新pre</span></span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//同理参照左子树</span></span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre.next = cur.right;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续访问这一行的下一个节点</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把下一层串联成一个链表之后，让他赋值给cur，</span></span><br><span class="line">        <span class="comment">//后续继续循环，直到cur为空为止</span></span><br><span class="line">        cur = dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-跳跃游戏2"><a href="#16-跳跃游戏2" class="headerlink" title="16. 跳跃游戏2"></a>16. 跳跃游戏2</h3><p>注意两点：</p>
<ol>
<li>对于数组 [3,1] ，判断可跳跃的范围大于数组右边界时，此时直接退出</li>
<li>在可跳跃的范围建议用数组真实下标s表示，每个跳跃的范围距离 = <code>s+nums[s]</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 对于数组 S0  S1 S2 S3 S4 S5 S6 S7 S8 S9</span></span><br><span class="line">        <span class="comment">//            3   2  3  3 </span></span><br><span class="line">        <span class="comment">// 从S0起跳，可以跳 S1 S2 S3 ，尝试从 S1 S2 S3 分别跳</span></span><br><span class="line">        <span class="comment">// 发现S3可以跳到最远（3+3），所以下一跳选S3</span></span><br><span class="line">        <span class="comment">// 那么有没有选S1 或者 S2 能更快跳到终点呢？</span></span><br><span class="line">        <span class="comment">// 不可能，因为S3是能跳到最远的，它下一次跳的范围（可能的路径）也就必然比S1 或 S2 多（且包含）</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> step =  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.length-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> maxPos = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> maxDistance = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> e = i+nums[i]; </span><br><span class="line">            <span class="keyword">if</span>(e&gt;=nums.length-<span class="number">1</span>)  <span class="comment">// 注意可跳跃的范围如果大于当前数组右边界，则退出</span></span><br><span class="line">            &#123;</span><br><span class="line">                step++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s = i+<span class="number">1</span> ; s &lt;= e ; s++) <span class="comment">// 可以跳的数组位置下标</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> curDistance = s + nums[s];</span><br><span class="line">                <span class="keyword">if</span>(curDistance &gt; maxDistance)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxPos = s;</span><br><span class="line">                    maxDistance = curDistance;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i = maxPos;  <span class="comment">// 找到能跳最远距离位置下标</span></span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-二叉树所有路径"><a href="#17-二叉树所有路径" class="headerlink" title="17. 二叉树所有路径"></a>17. 二叉树所有路径</h3><p>首先明确以下几点：</p>
<ol>
<li>根节点到指定叶节点的路径是唯一的</li>
<li>递归遍历，可以设置一个变量（就放到参数里），记录走到当前节点的路径是什么</li>
<li>使用后序遍历，如果到了叶子节点（左右节点都为null），就把路径输出</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 不能定义到递归函数里面</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      </span><br><span class="line">        findPaths(root, String.valueOf(root.val));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPaths</span><span class="params">(TreeNode root , String curPath)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)  <span class="comment">// 记录到左节点的路径，防止为左节点为空判断</span></span><br><span class="line">            findPaths(root.left, curPath + <span class="string">&quot;-&gt;&quot;</span> + root.left.val );</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) <span class="comment">// 同上</span></span><br><span class="line">            findPaths(root.right, curPath + <span class="string">&quot;-&gt;&quot;</span> + root.right.val );</span><br><span class="line">        <span class="keyword">if</span>( root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="comment">// 判断是否遍历到叶子节点（执行到这也可能是左右子树遍历完）</span></span><br><span class="line">           res.add(curPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="华为专场"><a href="#华为专场" class="headerlink" title="华为专场"></a>华为专场</h2><ol>
<li><p>机试的两道算法题</p>
<p>第一题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_KS</span> </span>&#123;</span><br><span class="line">    Solution_KS() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String[] locs = in.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = locs.length;</span><br><span class="line">        <span class="keyword">int</span>[] locArray = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            locArray[i] = Integer.parseInt(locs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] fixs = in.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len1 = fixs.length;</span><br><span class="line">        <span class="keyword">int</span>[] fixArray = <span class="keyword">new</span> <span class="keyword">int</span>[len1];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">for</span>(res = <span class="number">0</span>; res &lt; len1; ++res) &#123;</span><br><span class="line">            fixArray[res] = Integer.parseInt(fixs[res]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = findR(locArray, fixArray);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findR</span><span class="params">(<span class="keyword">int</span>[] workstations, <span class="keyword">int</span>[] sterilizers)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(workstations);</span><br><span class="line">        Arrays.sort(sterilizers);</span><br><span class="line">        <span class="keyword">int</span> worksNums = workstations.length;</span><br><span class="line">        <span class="keyword">int</span> sterNums = sterilizers.length;</span><br><span class="line">        <span class="keyword">int</span>[][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[sterNums][worksNums];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lastSter;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sterNums; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(lastSter = <span class="number">0</span>; lastSter &lt; worksNums; ++lastSter) &#123;</span><br><span class="line">                distance[i][lastSter] = Math.abs(sterilizers[i] - workstations[lastSter]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] minRs = <span class="keyword">new</span> <span class="keyword">int</span>[worksNums];</span><br><span class="line">        Arrays.fill(minRs, -<span class="number">1</span>);</span><br><span class="line">        lastSter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res_max;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(res_max = <span class="number">0</span>; res_max &lt; worksNums; ++res_max) &#123;</span><br><span class="line">            minRs[res_max] = distance[lastSter][res_max];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(i = lastSter + <span class="number">1</span>; i &lt; sterNums &amp;&amp; distance[i][res_max] &lt; minRs[res_max]; lastSter = i++) &#123;</span><br><span class="line">                minRs[res_max] = distance[i][res_max];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res_max = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; minRs.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minRs[i] &gt; res_max) &#123;</span><br><span class="line">                res_max = minRs[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m = in.nextInt();</span><br><span class="line">        in.nextLine();</span><br><span class="line">        List&lt;Integer&gt; v = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; f = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>*m);</span><br><span class="line">        Collections.fill(f,<span class="number">0</span>);</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*m;i++)&#123;</span><br><span class="line">            v.add(in.nextInt());</span><br><span class="line">            f.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(v);</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">2</span>*m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = r-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f.get(r) !=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r--;</span><br><span class="line">                l = r-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(l&gt;=<span class="number">0</span>&amp;&amp;(f.get(l) != <span class="number">0</span>||(v.get(r)+v.get(l))%n!=<span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                l--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l&gt;=<span class="number">0</span>&amp;&amp;l!=r&amp;&amp;(v.get(r)+v.get(l))%n==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.add(v.get(r));</span><br><span class="line">                ans.add(v.get(l));</span><br><span class="line">                f.set(r,<span class="number">1</span>);</span><br><span class="line">                f.set(l,<span class="number">1</span>);</span><br><span class="line">                r--;</span><br><span class="line">                l = r-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans.size()!=<span class="number">2</span>*m)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="number">0</span>);;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*m;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(ans.get(i));;</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">2</span>*m-<span class="number">1</span>)</span><br><span class="line">                    System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>runable、callable各自的区别 </p>
<p><strong>Runnable</strong>是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成的能返回一个值，那么可以实现<strong>Callable</strong>接口而不是<strong>Runnable</strong>接口。在Java SE5中引入的<strong>Callable</strong>是一种具有类型参数的泛型，它的参数类型表示的是从方法<strong>call</strong>()(不是<strong>run</strong>())中返回的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> 1 package ThreadOne;</span><br><span class="line"> 2 </span><br><span class="line"> 3 import java.awt.Panel;</span><br><span class="line"> 4 import java.util.concurrent.Callable;</span><br><span class="line"> 5 import java.util.concurrent.Future;</span><br><span class="line"> 6 import java.util.concurrent.FutureTask;</span><br><span class="line"> 7 </span><br><span class="line"> 8 public class ThreadCallable extends Panel &#123;</span><br><span class="line"> 9 </span><br><span class="line">10     public static void main(String[] args) &#123;</span><br><span class="line">11 </span><br><span class="line">12         MyThread2 myThread2 = new MyThread2();</span><br><span class="line">13 </span><br><span class="line">14         FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(myThread2);</span><br><span class="line">15         new Thread(futureTask, &quot;线程名：有返回值的线程2&quot;).start();</span><br><span class="line">16 </span><br><span class="line">17         try &#123;</span><br><span class="line">18             System.out.println(&quot;子线程的返回值：&quot; + futureTask.get());</span><br><span class="line">19         &#125; catch (Exception e) &#123;</span><br><span class="line">20             e.printStackTrace();</span><br><span class="line">21         &#125;</span><br><span class="line">22     &#125;</span><br><span class="line">23 &#125;</span><br><span class="line">24 </span><br><span class="line">25 class MyThread2 implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">26 </span><br><span class="line">27     public Integer call() throws Exception &#123;</span><br><span class="line">28         System.out.println(&quot;当前线程名——&quot; + Thread.currentThread().getName());</span><br><span class="line">29         int i = 0;</span><br><span class="line">30         for (; i &lt; 5; i++) &#123;</span><br><span class="line">31             System.out.println(&quot;循环变量i的值：&quot; + i);</span><br><span class="line">32         &#125;</span><br><span class="line">33 </span><br><span class="line">34         return i;</span><br><span class="line">35     &#125;</span><br><span class="line">36 </span><br><span class="line">37 &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>内存溢出、内存泄漏、怎么分析</p>
<ul>
<li>内存泄漏：<u>不再会被使用的<strong>对象</strong>的内存不能被回收</u>，就是内存泄露。</li>
<li>内存溢出：<strong>java.lang.OutOfMemoryError。</strong>内存溢出通俗理解就是内存不够，是指运行程序时要求的内存，超出了系统所能分配的范围，从而导致发生内存溢出。 </li>
</ul>
</li>
<li></li>
</ol>
<h2 id="一、算法"><a href="#一、算法" class="headerlink" title="一、算法"></a>一、算法</h2><h3 id="1-1-基本算法"><a href="#1-1-基本算法" class="headerlink" title="1.1 基本算法"></a>1.1 基本算法</h3><p>最基本要记忆、烂熟于心的算法。</p>
<h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/guoyaohua/p/8600214.html">十大经典排序算法最强总结（含JAVA代码实现）</a></p>
</blockquote>
<p>下面描述中，记：已排序部分为<code>S</code>，未排序部分为<code>R</code>，且相邻。</p>
<ol>
<li><p><strong>冒泡排序</strong></p>
<ul>
<li><p>核心思想</p>
<p>内循环：每次在<code>R</code>中<strong>从头</strong> 扫描（已排序<code>S</code>放最<strong>后</strong>），相邻元素比较，较大往后交换；外循环：<code>n</code>个数需<code>n-1</code>轮依次选出$R_i$ 中最大。</p>
<p>每次<strong>从头</strong>，未排<u>相邻</u>比较，最大最后。（如果逆序，最小最后）</p>
<p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" alt="img"></p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] bubble_sort(<span class="keyword">int</span>[] arr)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>;i++)   <span class="comment">// 外轮=n-1</span></span><br><span class="line">          <span class="comment">// * j=0,每次都是从头开始比较</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; arr.length-i-<span class="number">1</span>; j++ ) <span class="comment">// 内轮=余下乱序数-1</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>])</span><br><span class="line">                  swap(arr,j,j+<span class="number">1</span>); </span><br><span class="line">          &#125;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">     </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> idx_i,<span class="keyword">int</span> idx_j)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> tmp = arr[idx_i];</span><br><span class="line">      arr[idx_i] = arr[idx_j];</span><br><span class="line">      arr[idx_j] = tmp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>选择排序</strong></p>
<ul>
<li><p>核心思想</p>
<p>内循环：每次在<code>R</code>中从头 扫描（已排序<code>S</code>放最<strong>前</strong>），记录最大元素交换；外循环：<code>n</code>个数需<code>n-1</code>轮依次选出$R_i$ 中最大。</p>
<p>未排开始，一轮循环，比较最大（小），放在已排最后。</p>
<p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" alt="img"></p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] select_sort(<span class="keyword">int</span>[] arr)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>;i++)   <span class="comment">// 外轮=n-1</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> min = i;</span><br><span class="line">           <span class="comment">// 和冒泡排序不同，虽然内轮循环数同样=余下未排数-1</span></span><br><span class="line">           <span class="comment">// * 但是循环条件是 j&lt;arr.length-1 ，因为【已排序数】放最前，而非最后</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;arr.length-<span class="number">1</span>; j++)  <span class="comment">// 内轮=余下未排数-1</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// 寻找一轮循环最小数</span></span><br><span class="line">               <span class="keyword">if</span>(arr[j+<span class="number">1</span>]&lt;arr[min])</span><br><span class="line">                   min = j+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           swap(arr,i,min);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>插入排序</strong></p>
<ul>
<li><p>核心思想</p>
<p>内循环：选取<code>R[0]</code>，每次在<strong>已排</strong><code>S</code>中从<strong>尾</strong>扫描（已排序<code>S</code>放最<strong>前</strong>），如果该元素（已排序）&gt;<code>R[0]</code>，移动下一位，否则插入<code>R[0]</code>在其后；</p>
<blockquote>
<p>关于空位：如果<code>R[0]</code>大于已排<code>S</code> 最后一个数，则直接插入<code>S</code> 最后（由于<code>S,R</code>实际不变相邻，<code>R[0]</code>位置不变）和普通插入情况一致；如果<code>R[0]</code>小于已排<code>S</code> 最前一个数，则插入最前。<strong>实际中，通过记录pre_index，可统一插入操作。</strong></p>
</blockquote>
<p>外循环：<code>n</code>个数需<code>n-1</code>轮依次选出$R_i$ 中最大。</p>
<p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" alt="img"></p>
</li>
<li><p>代码实现1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] insert_sort(<span class="keyword">int</span>[] arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>;i++)   <span class="comment">// 外轮=n-1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> insert_num = arr[i+<span class="number">1</span>]; <span class="comment">// 第1个数默认已排序</span></span><br><span class="line">            <span class="comment">// * 内循环从后遍历已排S，比较→移动元素/插入空位</span></span><br><span class="line">            <span class="comment">// ** 从前遍历不方便移动元素，巧妙利用R[0]其实在S后</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=<span class="number">0</span>; j--)  <span class="comment">// 内轮= 已排序的数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(insert_num&lt;arr[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    arr[j+<span class="number">1</span>]=arr[j];  <span class="comment">// 大往后移动</span></span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">0</span>)  <span class="comment">// 边界条件：扫描完毕插入最前</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        arr[<span class="number">0</span>]=insert_num; <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    arr[j+<span class="number">1</span>]=insert_num; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>代码实现2（优化）</p>
<p>优化在内循环后统一插入，减少两次插入操作为一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] insert_sort1(<span class="keyword">int</span>[] arr)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>;i++)   <span class="comment">// 外轮=n-1</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">int</span> insert_num = arr[i+<span class="number">1</span>]; <span class="comment">// 第1个数默认已排序</span></span><br><span class="line">          <span class="comment">// * 内循环从后遍历已排S，比较→移动元素/插入空位</span></span><br><span class="line">          <span class="comment">// ** 从前遍历不方便移动元素，巧妙利用R[0]其实在S后</span></span><br><span class="line">          <span class="comment">// *** 初始为-1,处理恰好插入数最小插入最前的情况</span></span><br><span class="line">          <span class="keyword">int</span> pre_idx=-<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=<span class="number">0</span>; j--)  <span class="comment">// 内轮= 已排序的数</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(insert_num&lt;arr[j])</span><br><span class="line">              &#123;</span><br><span class="line">                  arr[j+<span class="number">1</span>]=arr[j];  <span class="comment">// 大往后移动</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="comment">// 小插入其后</span></span><br><span class="line">              &#123;</span><br><span class="line">                  pre_idx = j; <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          arr[pre_idx+<span class="number">1</span>]= insert_num;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="4">
<li><p><strong>归并排序</strong></p>
<ul>
<li><p>核心思想</p>
<ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 左边</span></span><br><span class="line">            mergeSort(arr, low, mid);</span><br><span class="line">            <span class="comment">// 右边</span></span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">            <span class="comment">// 左右归并</span></span><br><span class="line">            merge(arr, low, mid, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = low;     <span class="comment">// 左指针</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">// 右指针</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把较小的数先移到新数组中</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[j])</span><br><span class="line">                temp[k++] = arr[i++];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把左边剩余的数移入数组</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) </span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        <span class="comment">// 把右边边剩余的数移入数组</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= high) </span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        <span class="comment">// 把新数组中的数覆盖nums数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; temp.length; k2++) </span><br><span class="line">            arr[k2 + low] = temp[k2];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>快速排序</strong></p>
<ul>
<li><p>核心思想</p>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）：</p>
<ol>
<li><p>设定一个基准pivot=arr[right], 分割标记partition=left<br>  partition 表示最终基准插入的位置，<u>初始==left表示默认所有元素&gt;pivot</u></p>
</li>
<li><p>遍历数组，如果数组元素arr[i]&lt;pivot,交换arr[partition]和arr[i] ，</p>
<p>且partition+1，将arr[i]交换到partition左边。保证基准左侧元素&lt;基准</p>
</li>
<li><p>递归重复上述操作</p>
</li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] quick_sort(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(right&lt;=left)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">     </span><br><span class="line">       <span class="comment">// 选择基准：数组最右数字</span></span><br><span class="line">       <span class="comment">// *如果选择最左，思考交换过程</span></span><br><span class="line">       <span class="comment">// *partition 左侧始终是比pivot小的数</span></span><br><span class="line">       <span class="keyword">int</span> pivot = arr[right];</span><br><span class="line">       <span class="keyword">int</span> partition = left;</span><br><span class="line">       <span class="comment">// 遍历分区元素</span></span><br><span class="line">       <span class="comment">// 小于基准的放基准左边，大于的放基准右边</span></span><br><span class="line">       <span class="comment">// * 终止条件：i &lt; right 而非 right-1！</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt; right;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(arr[i]&lt;pivot) <span class="comment">// 实际只交换小于到左边即可</span></span><br><span class="line">           &#123;</span><br><span class="line">               swap(arr,i,partition);</span><br><span class="line">               partition++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 基准插入位置partition位置</span></span><br><span class="line">       swap(arr,partition,right);</span><br><span class="line">       <span class="comment">//递归的排序</span></span><br><span class="line">       quick_sort(arr,left,partition-<span class="number">1</span>);</span><br><span class="line">       quick_sort(arr,partition+<span class="number">1</span>,right);</span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>堆排序</strong></p>
<blockquote>
<p>之前笔记：<a href="D:\hwh\uploadToGit\本科\考研\数据结构笔记\6.排序.docx">6.排序</a></p>
</blockquote>
<ul>
<li><p>核心思想</p>
<blockquote>
<p>空间复杂度：<code>O(1)</code> , 时间复杂度：<code>O(n*logn)</code>。其中建堆：<code>O(n)</code> ，排序：<code>O(n*logn)</code>，时空复杂度由计算比较次数得到，具体理解 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20729324/answer/231955716">堆排序中建堆过程时间复杂度O(n)怎么来的？ - wuxinliulei的回答 - 知乎 </a></p>
</blockquote>
<p>具体对应代码实现：</p>
<ol start="0">
<li>将一维数组$arr$视作为完全二叉树处理（见上）</li>
<li><strong>构建初始最大堆。</strong>遍历数组，从倒数第一个非叶子节点$i=len/2$,进行构建最大堆</li>
<li>如果左孩子（$i<em>2+1$）,右孩子（$i</em>2+2$）大于当前节点值，则交换</li>
<li>如果发生交换可能会破坏最大堆性质，继续往下调整</li>
<li>重复1~3，直至所有节点的子树都调整完毕</li>
<li><strong>堆排序。</strong> 遍历数组，每次交换堆顶$i=0$ （最大值）和堆尾元素$i=len-1$</li>
<li>由于交换元素值会可能改变最大堆性质，从堆顶往下调整（数组长度-1）</li>
<li>重复5~6直至堆排序完成  </li>
</ol>
<p><img src="https://i.loli.net/2021/03/22/bSY7fwUmEGCkA9W.png" alt="image-20210322224209304"></p>
<p><img src="https://i.loli.net/2021/03/25/pgoeI684Ob2jrT9.png" alt="image-20210325195014406"></p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] heapSort(<span class="keyword">int</span>[] arr)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">int</span> len = arr.length;</span><br><span class="line">       <span class="comment">// 1.构建初始堆</span></span><br><span class="line">       <span class="comment">// 从最后一个非叶子节点构建初始堆</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i= len/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">           <span class="comment">// 对每一个节点视作根节点，调整子树符合最大堆</span></span><br><span class="line">           MaxHeapfily(arr,i,len);</span><br><span class="line">     </span><br><span class="line">       <span class="comment">// 2.排序</span></span><br><span class="line">       <span class="comment">// 每次交换堆顶和堆尾元素</span></span><br><span class="line">       <span class="comment">// *注意数组长度会变化，所以终止条件是i&lt;arr.length-1，而不是len-1</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span> ; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           swap(arr,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">           <span class="comment">// 交换破坏最大堆性质</span></span><br><span class="line">           <span class="comment">// 从交换的元素i=0，开始往下调整</span></span><br><span class="line">           <span class="comment">// *注意数组长度-1,而且会递归调用，所以不要在函数参数调用len--</span></span><br><span class="line">           len = len-<span class="number">1</span>;</span><br><span class="line">           MaxHeapfily(arr,<span class="number">0</span>,len);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br><span class="line">     </span><br><span class="line">   <span class="comment">// 设置参数要有数组长度，因为排序时交换堆顶和堆尾元素，相当删除堆顶元素</span></span><br><span class="line">   <span class="comment">// 对应数组长度-1</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MaxHeapfily</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> root , <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">// 左右孩子</span></span><br><span class="line">       <span class="keyword">int</span> left = root*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> right = root*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">if</span>(left&gt;=len)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">int</span> largest = root;</span><br><span class="line">       <span class="comment">// 选择最大者</span></span><br><span class="line">       <span class="comment">// *保证左右孩子存在</span></span><br><span class="line">       largest = arr[left]&gt;arr[largest]? left : largest;</span><br><span class="line">       largest = right&lt;len &amp;&amp; arr[right]&gt;arr[largest]?</span><br><span class="line">                                             right : largest;</span><br><span class="line">     </span><br><span class="line">       <span class="comment">// 如果发生交换要往下调整</span></span><br><span class="line">       <span class="keyword">if</span>(largest!=root)</span><br><span class="line">       &#123;</span><br><span class="line">           swap(arr,largest,root);</span><br><span class="line">           MaxHeapfily(arr,largest,len);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> temp ;</span><br><span class="line">       temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="数组查找"><a href="#数组查找" class="headerlink" title="数组查找"></a>数组查找</h4><ul>
<li><p><strong>二分查找</strong></p>
<p>二分查找还是较为简单的，易错的部分看代码注释就行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binary search</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> left = <span class="number">0</span>,right = arr.length-<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> mid ;</span><br><span class="line">     <span class="keyword">while</span> (left&lt;=right) <span class="comment">//*&lt;= 而不是&lt; </span></span><br><span class="line">     &#123;</span><br><span class="line">         mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">         <span class="keyword">if</span>(value == arr[mid])</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">return</span> mid; <span class="comment">// 如果数组存在待查找元素，按照逻辑一定会是mid</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>  <span class="keyword">if</span>(value &lt; arr[mid])</span><br><span class="line">         &#123;</span><br><span class="line">  </span><br><span class="line">             right = mid-<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>  <span class="comment">// value &gt; arr[mid]</span></span><br><span class="line">         &#123;</span><br><span class="line">             left = mid+<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">  </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="树遍历"><a href="#树遍历" class="headerlink" title="树遍历"></a>树遍历</h4><p>首先，我们定义基本树结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定测试树结构如下：</p>
<p><img src="https://i.loli.net/2021/03/05/pAOjITqwbmdXxHW.png" alt="image-20210305113653348"></p>
<p>回忆树三种遍历方式：</p>
<ul>
<li><p>前序遍历（根→左→右）：按照根节点→左孩子→右孩子依次访问，<u>每访问就立即打印出值</u> 。(1)一直往根节点左孩子访问，<u>每访问就立即输出值（含根节点）</u> ，直至节点没有左孩子（子树）；（2）如果该节点有右孩子，右孩子作为根节点，重复(1) ; （3）如果没有，访问该节点的根节点右孩子，作为根节点，重复以上，直至全部访问<strong>并输出</strong>。</p>
<p>测试值：<code>6 2 0 1 4 5  8 9</code></p>
</li>
<li><p>中序遍历（左→根→右）：(1)一直往根节点左孩子访问，如果至<u>节点没有左孩子/子树（或已访问），则输出该节点值</u>；(2)如果该节点有右孩子，右孩子作为根节点，重复(1) ; （3）如果没有，访问其根节点的右孩子，作为根节点，重复以上，直至全部访问<strong>并输出</strong>。</p>
<p>测试值：<code>0 1 2 4 5 6 8 9</code></p>
</li>
<li><p>后序遍历（左→右→根）：类比前中序遍历，不过访问输出条件变为：<u>节点左右子树都没有（或已访问），则输出该节点值</u>；访问优先顺序，**都是先沿根节点左孩子访问，再右孩子或者上一节点右孩子继续..**。</p>
<p>测试值：<code>1 0 5 4 2 9 8 6</code></p>
</li>
</ul>
<p><strong>共同点：</strong>前/中/后序遍历，输出节点条件不一样，<strong>但递归遍历顺序一样</strong>：</p>
<ul>
<li>（1）对于给定根节点root，一直沿着左孩子走直到为空（2）为空需要访问其右孩子，作为新的根节点重复以上步骤。</li>
</ul>
<blockquote>
<p>从图遍历到→树遍历：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/98406357">看完这篇，你会理解图和树的遍历</a></p>
</blockquote>
<p>图有两种遍历方式，<strong>深度优先遍历</strong>（DFS）<strong>和广度优先遍历</strong>（BFS），下面用来遍历树结构。</p>
<ul>
<li><p><strong>深度优先遍历（DFS）</strong></p>
<blockquote>
<p>更细致讲解DFS和BFS，可以看：<a target="_blank" rel="noopener" href="https://developer.51cto.com/art/202004/614590.htm">图文详解两种算法：DFS和BFS</a></p>
</blockquote>
<p>见上讲解链接：首先知道，DFS遍历过程==树前序遍历（根→左→右）。递归代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">      System.out.print(root.val+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">	  inOrderTraverse1(root.left);</span><br><span class="line">	  inOrderTraverse1(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么要用（栈，<code>stack</code>）非递归模拟进行实现DFS/ 前序遍历？</p>
</blockquote>
<p>栈是模拟递归不二选择，因为递归其实函数调用栈的问题，因此需要<code>栈</code> 这种数据结构支持。</p>
<blockquote>
<p>栈用栈时模拟递归操作，核心操作要点？</p>
</blockquote>
<ul>
<li><p><code>push</code> 时机：一经访问即push，同递归</p>
</li>
<li><p><code>pop</code> 时机：节点左右<strong>子树</strong>都被访问，同递归函数被访问完毕。在前/中序非递归遍历时，左右<strong>孩子</strong>被访问即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">递归时，要等节点右孩子pop出，即右子树被访问完毕（注，都访问右孩子了，左子树肯定被访问完毕）再pop出节点（此时节点左右子树都已被访问），也就是pop两次；</span><br><span class="line">  但对于【前序/中序】非递归时可以提前pop，即在节点右孩子被访问即pop，【不影响遍历输出值】：因为循环逻辑同时pop多次比较复杂，递归的第二次pop出节点也没有实质性影响。</span><br><span class="line">  </span><br><span class="line">  [*]然而【后序】非递归，必须要：判断节点左右子树都访问完，才可以pop并输出其值。如果只是如前/中序非递归：左子树访问完，访问右孩子就pop输出其值，不符合实际递归后序调用。所以需要设置判断右子树是否访问完毕，再pop和输出。</span><br></pre></td></tr></table></figure></li>
<li><p><code>输出</code>时机：根据前/中/后序，所需不同条件进行输出。例如，前序/DFS：一访问则立即输出；中序：访问右孩子时即输出。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode root)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  		LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  		TreeNode pNode = root;</span><br><span class="line">          <span class="comment">// *栈空依旧可能没遍历完（如，访问右孩子但没压入）</span></span><br><span class="line">  		<span class="keyword">while</span> (pNode != <span class="keyword">null</span> || !stack.isEmpty()) </span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">// *这个条件易忘：输出空节点数值</span></span><br><span class="line">  			<span class="keyword">if</span> (pNode != <span class="keyword">null</span>) <span class="comment">// *这里不用while更简洁</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">// 前序遍历：访问后立即输出</span></span><br><span class="line">  				System.out.print(pNode.val+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">                  <span class="comment">// 压入栈是为了走到空节点，可以退回到根节点</span></span><br><span class="line">                  <span class="comment">// 进而可以访问同级右孩子（模拟递归）</span></span><br><span class="line">  				stack.push(pNode);</span><br><span class="line">                  <span class="comment">// 沿着下一个左孩子走</span></span><br><span class="line">  				pNode = pNode.left;</span><br><span class="line">  			&#125; </span><br><span class="line">              <span class="keyword">else</span> <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">// 一个节点【左右孩子都被访问】即pop</span></span><br><span class="line">                  <span class="comment">// 虽然不是子树，但这里符合递归调用逻辑</span></span><br><span class="line">  				TreeNode node = stack.pop();</span><br><span class="line">                  <span class="comment">// 右孩子作为根节点（node右子树），重复以上</span></span><br><span class="line">  				pNode = node.right;</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>和广度优先遍历（BFS）</strong></p>
<p>广度优先遍历较为简单，使用队列：</p>
<ul>
<li>队列首先加入根节点，之后对于首节点</li>
<li><u>出队并输出其元素，同时判断其是否右左右孩子</u>，有则加入</li>
<li>直至队列为空</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS,队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		queue.offer(root);   <span class="comment">// 队尾加入，下同 </span></span><br><span class="line">		<span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">			TreeNode node = queue.poll();   <span class="comment">// 出列</span></span><br><span class="line">			System.out.print(node.val+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (node.left != <span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">				queue.offer(node.left);  </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">				queue.offer(node.right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>前序遍历</strong></p>
<p>前序遍历，非递归代码同DFS，不再赘述。以下是递归代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse1</span><span class="params">(TreeNode root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			System.out.print(root.val+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">			preOrderTraverse1(root.left);</span><br><span class="line">			preOrderTraverse1(root.right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>中序遍历</strong></p>
<p>中序非递归代码，有了前序非递归实现就简单很多了。</p>
<p>同前，递归遍历顺序都是一样的，但是 <u>访问条件不一样</u> 对于中序遍历： 左孩子为空，访问根节点右孩子时。所以，代码只需修改一处：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse</span><span class="params">(TreeNode root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		TreeNode pNode = root;</span><br><span class="line">        <span class="comment">// *栈空依旧可能没遍历完（如，访问右孩子但没压入）</span></span><br><span class="line">		<span class="keyword">while</span> (pNode != <span class="keyword">null</span> || !stack.isEmpty()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// *这个条件易忘：输出空节点数值</span></span><br><span class="line">			<span class="keyword">if</span> (pNode != <span class="keyword">null</span>) <span class="comment">// *这里不用while更简洁</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 【前序遍历输出】</span></span><br><span class="line">                <span class="comment">// System.out.print(node.val+&quot;  &quot;);</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 压入栈是为了走到空节点，可以退回到根节点</span></span><br><span class="line">                <span class="comment">// 进而可以访问同级右孩子（模拟递归）</span></span><br><span class="line">				stack.push(pNode);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 沿着下一个左孩子走</span></span><br><span class="line">				pNode = pNode.left;</span><br><span class="line">			&#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//如果 pNode == null 且栈不同</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 一个节点【左右孩子都被访问】即pop</span></span><br><span class="line">                <span class="comment">// 虽然不是子树，但这里符合递归调用逻辑</span></span><br><span class="line">				TreeNode node = stack.pop();</span><br><span class="line">            </span><br><span class="line">                <span class="comment">//【中序遍历输出】</span></span><br><span class="line">                System.out.print(node.val+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 右孩子作为根节点（node右子树），重复以上</span></span><br><span class="line">				pNode = node.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>后序遍历</strong></p>
<blockquote>
<p>非递归后序遍历这个分析比较清晰：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/456af5480cee">二叉树遍历(先序、中序、后序)</a></p>
</blockquote>
<p>如前所述：</p>
<blockquote>
<p>[*] 然而【后序】非递归，必须要：判断节点左右子树都访问完，才可以pop并输出其值。如果只是如前/中序非递归：左子树访问完，访问右孩子就pop&amp;输出其值，不符合实际递归后序调用。<u>所以需要设置判断右子树是否访问完毕</u>，再pop和输出。</p>
</blockquote>
<p><strong>代码哪一块需要修改呢？</strong></p>
<p><code>while</code>内部前面代码：一直沿节点左孩子往下走并PUSH入栈，直至==null 。符合实际递归逻辑，不用修改。所以，实际是如何对后续<strong>“往右走”</strong>后的逻辑修改，增加对右子树是否访问完毕，进而是否出栈pop。</p>
<p><strong>如何判断右子树是否访问完毕呢？</strong></p>
<p>如果直接思考右子树是否被访问，难以得出好的方法。可以先考虑一种特殊情况：如果往右走时，右孩子为空</p>
<ol>
<li>右孩子==null，则pop</li>
</ol>
<p>对于判断右子树!=null，但已访问也需pop的情况。因为我们设置<strong>lastVisit</strong>来标记上一个被pop的节点，如果lastVisit指向的节点的右孩子，则说明节点右子树都已被访问完毕可以被pop（和输出）。</p>
<ol start="2">
<li>或者 lastVisit==节点.right，则pop</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode node = root;</span><br><span class="line">    TreeNode lastVisit = root;   <span class="comment">// 初始化为null？</span></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        node = stack.peek();</span><br><span class="line">        <span class="comment">//如果其右子树也为空，或者右子树已经访问</span></span><br><span class="line">        <span class="comment">//则可以直接输出当前节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span> || node.right == lastVisit) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            stack.pop();</span><br><span class="line">            lastVisit = node;</span><br><span class="line">            node = <span class="keyword">null</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//否则，继续遍历右孩子为新根节点，往左走</span></span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><blockquote>
<p>参考教程：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/91582909">告别动态规划，连刷 40 道题，我总结了这些套路，看不懂你打我</a></p>
</blockquote>
<p>动态规划解析核心四个条件，以斐波那契数列为例：</p>
<ul>
<li><strong>状态定义：</strong> 设 $dp$ 为一维数组，其中 d$p[i]$ 的值代表 斐波那契数列第 $i$ 个数字 。</li>
<li><strong>转移方程：</strong> $dp[i + 1] = dp[i] + dp[i - 1]$ ，即对应数列定义$ f(n + 1) = f(n) + f(n - 1)$ ；</li>
<li><strong>初始状态：</strong> $dp[0] = 1,dp[1]=1$ ，即初始化前两个数字；</li>
<li><strong>返回值：</strong> $dp[n]$，即斐波那契数列的第 $n$ 个数字。</li>
</ul>
<p>以下案例分析。</p>
<ol>
<li><p><strong>青蛙跳台阶（1维dp）</strong></p>
<ul>
<li><p>问题描述</p>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
</li>
<li><p>解法分析</p>
<blockquote>
<p>参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution/mian-shi-ti-10-ii-qing-wa-tiao-tai-jie-wen-ti-dong/">面试题10- II. 青蛙跳台阶问题（动态规划，清晰图解）</a></p>
</blockquote>
<p>同上分析我们可以得出代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 状态定义：dp[i]表示跳到第i个台阶的方式</span></span><br><span class="line">      <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 初始状态</span></span><br><span class="line">      dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">      dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">      <span class="comment">// 转移方程：跳到第n个台阶的方式d[n]</span></span><br><span class="line">      <span class="comment">//  -从第n-1→跳到n，跳到第n-1个台阶有d[n-1]方式，第n-1→跳到n有</span></span><br><span class="line">      <span class="comment">//  1种方式（跳1阶），故有d[n-1]*1      </span></span><br><span class="line">      <span class="comment">//  -从第n-2→跳到n，跳到第n-2个台阶有d[n-2]方式，第n-1→跳到n有</span></span><br><span class="line">      <span class="comment">//  1种方式（跳2阶），故有d[n-2]*1   </span></span><br><span class="line">      <span class="comment">//  一共是：d[n-1]+d[n-2]</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) </span><br><span class="line">          dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">      <span class="comment">// 返回值</span></span><br><span class="line">      <span class="keyword">return</span> dp[n];</span><br><span class="line">  &#125;</span><br><span class="line">     </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>不同路径I（二维dp）</strong></p>
<ul>
<li><p>题目描述</p>
<blockquote>
<p>一个机器人位于一个 m x n 网格的左上角，机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，一共有多少种路径？</p>
</blockquote>
</li>
<li><p>解法分析</p>
<p>按照之前动态规划四步走：</p>
<ul>
<li><p><strong>状态定义：</strong> $d[i][j]$ 表示移动坐标为$(i,j)$ 的路径方式</p>
</li>
<li><p><strong>转移方程：</strong>    $$(i,j)$$只能由左边 $(i-1,j)$→右到$(i,j)$  或者$(i,j-1)$→下到 $(i,j)$，所以类似青蛙跳台阶： $d[i][j]$ =  $d[i-1][j]$ +  $d[i][j-1]$</p>
<p><u>PS:</u> 这样思考不也会有重复路径产生</p>
</li>
<li><p><strong>返回状态：</strong>  $d[n-1][m-1]$</p>
</li>
<li><p><strong>初始值：</strong> 对于状态方程  $d[i][j]$ =  $d[i-1][j]$ +  $d[i][j-1]$ ，必须是$i&gt;0,j&gt;0$ 才成立，所以初始状态应该是$d[0][j]=1$ , $d[i][0]=1$ 。表示如果坐标$(i,j)$是在第一列或者第一行，只能一直向下走 或 向右走这一种方式</p>
</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span> <span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="comment">// 1.状态定义：dp[i][j]表示走到当前位置(i,j)不同路径数</span></span><br><span class="line">        <span class="comment">// 2.转移方程：位置(i,j)可以由</span></span><br><span class="line">        <span class="comment">//         1）(i-1,j)向右走(i,j)</span></span><br><span class="line">        <span class="comment">//         2）(i,j-1)向下走(i,j)</span></span><br><span class="line">        <span class="comment">// 所以走到(i,j)的总路径数dp[i,j]=dp[i-1,j]+dp[i,j-1]</span></span><br><span class="line">        <span class="comment">// 3.初始定义：初始化dp[0,j] 和 dp[i,0]</span></span><br><span class="line">        <span class="comment">// 4.返回值：返回dp[m-1][n-1]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span> || n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 状态定义</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始定义</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;m ; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ; j&lt;n ; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转移方程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ; i&lt;m ; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span> ; j&lt;n ; j++)</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>不同路径II（二维dp）</strong> </p>
<ul>
<li><p>题目描述</p>
<blockquote>
<p>给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有数字累加就是路径和，输出所有路径中最小路径和。</p>
</blockquote>
</li>
<li><p>解法分析</p>
<p>按照之前动态规划四步走：</p>
<ul>
<li><p><strong>状态定义：</strong> $d[i][j]$ 表示移动坐标为$(i,j)$ 的<u>路径之和最小方式的值</u></p>
</li>
<li><p><strong>转移方程：</strong>  $$(i,j)$$只能由左边 $(i-1,j)$→右到$(i,j)$  或者$(i,j-1)$→下到 ，$(i,j)$ ，比较 $d[i-1][j]$ 和 $d[i][j-1]$ 大小取较小值加上 $places[i][j]$ 便是最小路径之和：<br>$$<br>d[i][j] = d[i-1][j]&lt;d[i][j-1]?d[i-1][j]+places[i][j]：d[i][j-1]+places[i][j]​<br>$$</p>
</li>
<li><p><strong>返回状态：</strong>  $d[n-1][m-1]$</p>
</li>
<li><p><strong>初始值：</strong> 对于状态方程  $d[i][j]$ =  $d[i-1][j]$ +  $d[i][j-1]$ ，必须是$i&gt;0,j&gt;0$ 才成立，所以初始状态应该是：$d[0][j]=\sum_j places[0][j]$  (向下走路径之和，由于只能向右和向下，所以第一列上的位置只能一直往下走) ；同理，第一行上位置，$d[i][0]=\sum_i places[i][0]$ 。</p>
</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span> <span class="params">(<span class="keyword">int</span>[][] matrix)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = matrix.length;    <span class="comment">// 行，一维矩阵个数</span></span><br><span class="line">       <span class="keyword">int</span> m = matrix[<span class="number">0</span>].length; <span class="comment">// 列，一维数组长度</span></span><br><span class="line">       <span class="comment">// 状态定义</span></span><br><span class="line">       <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">       <span class="comment">// 初始值</span></span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>]; </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">           dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + matrix[i][<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;m; j++)</span><br><span class="line">           dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>] + matrix[<span class="number">0</span>][j];</span><br><span class="line">       <span class="comment">// 递推&amp;转移方程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;m; j++)</span><br><span class="line">               dp[i][j] = dp[i-<span class="number">1</span>][j]&lt;dp[i][j-<span class="number">1</span>]? </span><br><span class="line">                          dp[i-<span class="number">1</span>][j]+matrix[i][j]:</span><br><span class="line">                          dp[i][j-<span class="number">1</span>]+matrix[i][j];</span><br><span class="line">       <span class="keyword">return</span> dp[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>编辑字符（二维dp）</strong></p>
<ul>
<li><p>题目描述</p>
<p><img src="https://i.loli.net/2021/03/18/IidwRjWmBp9DCYs.png" alt="image-20210318120433079"></p>
</li>
<li><p>解法思路</p>
<blockquote>
<p>状态定义比较难想到，还需多做题。转移方程也很难写，直接看 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-by-leetcode-solution/">leetcode题解-编辑距离</a> 吧。</p>
</blockquote>
<p>  动态规划四步走：</p>
<ul>
<li><p><strong>状态定义：</strong> $d[i][j]$ 表示从长度为$i$ 的word1转为为长度为$j$的word2所需最少操作数</p>
</li>
<li><p><strong>转移方程：</strong> </p>
<p><img src="../AppData/Roaming/Typora/typora-user-images/image-20210318130558789.png" alt="image-20210318130558789"></p>
<p><img src="https://i.loli.net/2021/03/18/6MtKAUvRYy9jEJz.png" alt="image-20210318130633980"></p>
</li>
<li><p><strong>返回状态：</strong>  $d[n][m]$</p>
</li>
<li><p><strong>初始值：</strong> 同前，保证$i，j&gt;0$ 成立，所以初始状态应该是：$d[0][j]=\sum_{j=0} j+1$  ， $d[i][0]=\sum_{i=0} i+1$   </p>
</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> n = word1.length();</span><br><span class="line">         <span class="keyword">int</span> m = word2.length();</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 有一个字符串为空串</span></span><br><span class="line">         <span class="keyword">if</span> (n * m == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> n + m;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// DP 数组</span></span><br><span class="line">         <span class="keyword">int</span>[][] D = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 边界状态初始化</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">             D[i][<span class="number">0</span>] = i;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">             D[<span class="number">0</span>][j] = j;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 计算所有 DP 值</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                 <span class="keyword">int</span> left = D[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">int</span> down = D[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">int</span> left_down = D[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                 <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) != word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                     left_down += <span class="number">1</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 D[i][j] = Math.min(left, Math.min(down,                                                            left_down));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> D[n][m];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h4><blockquote>
<p>基本链表实现，含删除、插入等基本操作。</p>
</blockquote>
<ul>
<li><p>定义<code>ListNode</code></p>
<p>使用通常<code>OJ</code> (e.g. 牛客网) ，的节点定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义<code>LinkList</code></p>
<p>为了引入<code>头结点head</code> ，和一些基本（单）链表操作。</p>
<p>如果不引入<code>头结点head</code>，还要特别判断要 <u>删除/插入/…的节点是否头结点</u>。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ListNode head;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【初始化】</span></span><br><span class="line">    LinkList()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ** head 必须初始化！！</span></span><br><span class="line">        head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 【删除】一个节点:关键在于找到被删除节点的前一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(ListNode delNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        <span class="comment">// 找到被删除节点的前一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (pre.next!=delNode)</span><br><span class="line">            pre = pre.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始删除节点</span></span><br><span class="line">        <span class="comment">// head→..→pre→delnode→..</span></span><br><span class="line">        pre.next = delNode.next;</span><br><span class="line">        delNode.next=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// *更新长度</span></span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【插入】一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(ListNode preNode,ListNode newNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// *尽量先不破坏原先链接，先更新新节点newNode的指向</span></span><br><span class="line">        <span class="comment">//  再更新原先节点preNode的指向</span></span><br><span class="line">        newNode.next = preNode.next;</span><br><span class="line">        preNode.next = newNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//*长度更新</span></span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【打印】链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp.next!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(tmp.next.val+<span class="string">&quot;→&quot;</span>);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>基本：翻转链表</strong></p>
<p>提供的链表头结点指向第一个节点，而非伪节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// *p,q,q_next,分别记录前一个节点，当前节点，下一个节点</span></span><br><span class="line">        <span class="comment">// *为了操作统一，p最开始指向null！！</span></span><br><span class="line">        ListNode p = <span class="keyword">null</span>;</span><br><span class="line">        ListNode q = head,q_next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// *下一个节点更新放在循环开始，而非末尾</span></span><br><span class="line">            <span class="comment">// 避免q.next==null时，q.next.next赋值给q.next出错</span></span><br><span class="line">            q_next = q.next;</span><br><span class="line">            <span class="comment">// 改变q指向</span></span><br><span class="line">            q.next=p;</span><br><span class="line">            <span class="comment">// *更新前一个节点，当前更新p,q节点只能在循环末尾</span></span><br><span class="line">            <span class="comment">//  因为后面代码q.next=p，要操作p，q，在此之前不能更新p，q</span></span><br><span class="line">            p=q;</span><br><span class="line">            q=q_next;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>基本：是否有环</strong></p>
<p>终止条件记下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 思路1：快慢指针（trick），最优解，O(1)复杂度</span></span><br><span class="line">        <span class="comment">// 思路2：hashmap存下所有节点，然后遍历节点就去判断是否在hashmap中</span></span><br><span class="line">        <span class="comment">// *要先判断head==null的情况</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode step1 = head;</span><br><span class="line">        ListNode step2 = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(step2!= <span class="keyword">null</span> &amp;&amp; step2.next != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 好像不会出现step1==null的情况？</span></span><br><span class="line">            <span class="comment">// 因为【如果有环】会在快指针走到终点前就相遇</span></span><br><span class="line">            step1 = step1.next;</span><br><span class="line">            <span class="comment">// 循环终止条件从这里得到</span></span><br><span class="line">            step2 = step2.next.next;</span><br><span class="line">            <span class="comment">// *不能在前面判断，因为初始step1==step2</span></span><br><span class="line">            <span class="keyword">if</span>(step1==step2)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>基本：合并链表</strong></p>
<p>高频出现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeList</span><span class="params">(ListNode head1,ListNode head2)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">     <span class="comment">// *保留head，使用工作指针h</span></span><br><span class="line">     ListNode h = head; </span><br><span class="line">     </span><br><span class="line">     <span class="keyword">while</span>(head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>(head1.val&lt;head2.val)</span><br><span class="line">         &#123;</span><br><span class="line">             h.next = head1;</span><br><span class="line">             head1 = head1.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             h.next = head2;</span><br><span class="line">             head2 = head2.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// *指向合并链表末尾</span></span><br><span class="line">         h = h.next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 剩下未排序完成的</span></span><br><span class="line">     <span class="keyword">if</span>(head1 != <span class="keyword">null</span>)</span><br><span class="line">         h.next = head1;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         h.next = head2;</span><br><span class="line">  </span><br><span class="line">     <span class="keyword">return</span> head.next;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>基础：删除重复数</strong></p>
<p>不知道为啥，我删除重复代码记得好牢靠。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span> <span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       <span class="comment">// 思路(保证下面链表至少有2个节点)</span></span><br><span class="line">       <span class="comment">// 1.设置初始工作指针pre=head,p=head.next</span></span><br><span class="line">       <span class="comment">//   pre指向的待删除重复数在链表排序最前的数字</span></span><br><span class="line">       <span class="comment">// 2.如果pre.val = p.val,则删除p指向的节点,p往后移动</span></span><br><span class="line">       <span class="comment">// 3.如果不等，说明pre指向的数字不存在重复数，</span></span><br><span class="line">       <span class="comment">//   pre和p都往后移动，直至p为null退出循环</span></span><br><span class="line">       </span><br><span class="line">       ListNode pre = head, p = head.next; </span><br><span class="line">       <span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(pre.val == p.val)</span><br><span class="line">           &#123;</span><br><span class="line">               pre.next = p.next;</span><br><span class="line">               p = p.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               pre = pre.next;</span><br><span class="line">               p = p.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-2-数组"><a href="#1-2-数组" class="headerlink" title="1.2 数组"></a>1.2 数组</h3><h5 id="【看】NC61-两数之和"><a href="#【看】NC61-两数之和" class="headerlink" title="【看】NC61: 两数之和"></a>【看】NC61: 两数之和</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/20ef0972485e41019e39543e8e895b7f?tpId=117&tqId=37756&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/03/yuXZAMhH5jTFWcf.png" alt="image-20210303170655653"></p>
</li>
<li><p>解法思路</p>
<p>暴力解法，比较耗时：对数组每个元素（循环1），去遍历剩余的元素找到补足数并返回下标（循环2）。</p>
<p>（循环2）可转换为 <strong>“在数组中找到 <u>指定数</u> 的下标”</strong> ，可以考虑对数组建立以：<u>元素为key，下标为value</u> 的<code>HashMap</code> 。对于已知的key（<u>指定数</u>），<code>HashMap</code> 可在<code>O(1)</code> 时间找到，而非每次遍历其余数组剩下数<code>O(n)</code>。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum (<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        HashMap&lt;Integer , Integer&gt; dic = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="comment">// 一次遍历建立hashmap</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; numbers.length; i++)</span><br><span class="line">            dic.put(numbers[i],i);</span><br><span class="line">        <span class="comment">// 遍历每个元素找到补足数</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; numbers.length-<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Object complemetNumIdx = dic.get(target-numbers[i]);</span><br><span class="line">            <span class="keyword">if</span> (complemetNumIdx!=<span class="keyword">null</span> &amp;&amp; (Integer) complemetNumIdx != i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// *i一定&lt;complemetNumIdx，不用判断大小</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>,(Integer) complemetNumIdx+<span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC22-合并数组"><a href="#NC22-合并数组" class="headerlink" title="NC22: 合并数组"></a>NC22: 合并数组</h5><blockquote>
<p>【套路】【归并】：两个有序子数组归并排序</p>
</blockquote>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/89865d4375634fc484f3a24b7fe65665?tpId=190&tqId=35185&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/03/E1C3fgRZbGcTQMz.png" alt="image-20210303213255566"></p>
</li>
<li><p>解法思路</p>
<p>套路：设置三个指针<code>i，j，k</code> 分别指向：数组<strong>A末尾</strong>元素、数组<strong>B末尾</strong>元素，数组A索引$m+n-1$ 处。每次指针<code>i</code> 与<code>j</code> 进行对比，取较大者元素放置指针<code>k</code> 处，且对应指针（<code>i</code>或<code>j</code>） 与<code>k</code>往前移动。直至<code>i</code> 或<code>j</code> &lt;0（null），处理边界情况：</p>
<ul>
<li>数组A未遍历完（<code>i&gt;0</code>）：由于是对A操作，已经有序了，结束</li>
<li>数组B未遍历完（<code>j&gt;0</code>）：说明B剩余元素都小于A中元素，A所有元素都已移动至后，指针<code>j</code> 继续往前移动，将B剩余元素直接插入A中即可。</li>
</ul>
</li>
<li><p>代码实现</p>
<p>*一个蠢蠢错误：数组B全部用数组A。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 定义三个指针</span></span><br><span class="line">        <span class="keyword">int</span> qa= m-<span class="number">1</span>,qb=n-<span class="number">1</span>,qc=m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 循环遍历：从尾部开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=qc; i&gt;=<span class="number">0</span> ; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(qb&lt;<span class="number">0</span>)     <span class="comment">// 数组B遍历结束</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(qa&lt;<span class="number">0</span>)     <span class="comment">// 数组A遍历结束，但B未结束</span></span><br><span class="line">                A[qc--] = B[qb--];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                A[qc--] = A[qa]&gt;B[qb]? A[qa--]:B[qb--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC38-螺旋矩阵"><a href="#NC38-螺旋矩阵" class="headerlink" title="NC38: 螺旋矩阵"></a>NC38: 螺旋矩阵</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7edf70f2d29c4b599693dc3aaeea1d31?tpId=190&tqId=35349&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/03/UbKJYSraDMOH8yX.png" alt="image-20210303222853442"></p>
</li>
<li><p>解法思路</p>
<p>对于这种多层递归循环问题，<strong>通过从特例思考</strong>，比如：如何遍历最外层矩阵元素输出？</p>
<ul>
<li>出发位置：→向右出发，超出右侧边界则停下；↓接着往下，超出下侧边界则停下；←往左继续，超出左侧边界则停下；↑向上继续，<u>即将到达初始位置</u>则停下。</li>
</ul>
<p>这样最外层遍历便明了了，对于内层矩阵继续循环输出有什么不一样吗？</p>
<ul>
<li>出发位置变化（左上）：下一层矩阵循环，出发位置横纵坐标均+1</li>
<li>边界位置变化（右下）：边界位置-1（矩阵最右侧索引，最下侧索引位置）</li>
</ul>
<p>这样我们只要：<u>外侧套入一个循环，将出发位置和边界位置作为变量</u> ，便可以遍历整个螺旋矩阵。循环结束条件：已返回的元素个数==矩阵元素个数。</p>
</li>
<li><p>代码实现</p>
<p>代码一直在牛客网通过不了，但本地没问题？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NC38</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">  </span><br><span class="line">       ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       <span class="keyword">int</span> m = matrix.length;    <span class="comment">// 矩阵行数</span></span><br><span class="line">       <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length; <span class="comment">// 矩阵列数</span></span><br><span class="line">       <span class="keyword">if</span>(n == <span class="number">0</span>)  <span class="comment">// * 注意边界条件</span></span><br><span class="line">           <span class="keyword">return</span> arr;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 螺旋递归思考太复杂，先思考如何遍历一圈</span></span><br><span class="line">       <span class="keyword">int</span> i,j; <span class="comment">//  矩阵遍历索引</span></span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>   , top=<span class="number">0</span> ,        <span class="comment">// 矩阵左上</span></span><br><span class="line">           right = m-<span class="number">1</span>, bottom = n-<span class="number">1</span>;  <span class="comment">// 矩阵右下</span></span><br><span class="line">  </span><br><span class="line">       <span class="comment">// *判断条件不能是&lt;=, 会导致再次进入循环</span></span><br><span class="line">       <span class="keyword">while</span> (arr.size() &lt; m*n) <span class="comment">// 递归螺旋矩阵</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 初始矩阵遍历位置</span></span><br><span class="line">           i = left; j = top;</span><br><span class="line">  </span><br><span class="line">           <span class="keyword">while</span> (j&lt;=bottom)  <span class="comment">// 向右</span></span><br><span class="line">           &#123;</span><br><span class="line">               arr.add(matrix[i][j++]);</span><br><span class="line">           &#125;</span><br><span class="line">  </span><br><span class="line">           j--; i++;   <span class="comment">// *矩阵右边从第二个元素开始</span></span><br><span class="line">           <span class="keyword">while</span> (i&lt;=right)  <span class="comment">// 向下</span></span><br><span class="line">           &#123;</span><br><span class="line">               arr.add(matrix[i++][j]);</span><br><span class="line">           &#125;</span><br><span class="line">  </span><br><span class="line">           i--; j--;   <span class="comment">// *从矩阵下边从左→右第二个元素开始</span></span><br><span class="line">           <span class="keyword">while</span> (j&gt;=left)  <span class="comment">// 向左</span></span><br><span class="line">           &#123;</span><br><span class="line">               arr.add(matrix[i][j--]);</span><br><span class="line">           &#125;</span><br><span class="line">  </span><br><span class="line">           j++; i--;  <span class="comment">// *从矩阵左边从下→上第二个元素开始</span></span><br><span class="line">           <span class="keyword">while</span> (i &gt; top)  <span class="comment">// 向上</span></span><br><span class="line">           &#123;</span><br><span class="line">               arr.add(matrix[i--][j]);</span><br><span class="line">           &#125;</span><br><span class="line">  </span><br><span class="line">           <span class="comment">// 开始下一内层矩阵遍历</span></span><br><span class="line">           left++  ; top++;          <span class="comment">// 更新内矩阵左上位置</span></span><br><span class="line">           right-- ; bottom--;       <span class="comment">// 更新内矩阵右下位置</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC12-重建二叉树"><a href="#NC12-重建二叉树" class="headerlink" title="NC12: 重建二叉树"></a>NC12: 重建二叉树</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=190&tqId=35426&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/04/POXaf14TCHn7rvY.png" alt="image-20210304182604437"></p>
</li>
<li><p>解法思路</p>
<p>树遍历的模板代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">// 1.递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)          </span><br><span class="line">        <span class="keyword">return</span>;      </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.确定新的递归参数</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.递归操作</span></span><br><span class="line">    Traverse(root.left);   </span><br><span class="line">    Traverse(root.right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何将模板代码修改为我们需要的重建二叉树的代码？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// code is here   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们将问题转换为递归思路：</p>
<ul>
<li>根据前序序列第一个结点确定根结点</li>
<li>根据根结点在中序序列中的位置分割出左右两个子序列</li>
<li>对左子树和右子树分别递归使用同样的方法继续分解</li>
</ul>
<p>根据模板代码，我们：</p>
<ol>
<li><p><strong>确定递归终止条件</strong></p>
<p>原来确定递归终止是，<u>当前节点为null</u>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.递归终止条件</span></span><br><span class="line">   <span class="keyword">if</span> (root == <span class="keyword">null</span>)          </span><br><span class="line">       <span class="keyword">return</span>;  </span><br></pre></td></tr></table></figure>

<p>中序给定参数为前序、中序数组<code>pre</code>和<code>in</code> , 可以通过判断数组长度==0判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pre.length==<span class="number">0</span>)   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>确定新的递归参数pre、in</strong></p>
<p>对于树遍历模板，新的递归参数只需<code>root.left</code> /<code>root.right</code> 可直接获取。</p>
<p>但对于重建二叉树，需要根据前序、中序序列确定左右子树，进而得到新的递归参数<code>pre/ in</code>。 这一部分主要知道如何根据前序、中序序列确定一根树，难度不高。</p>
<ul>
<li>根据前序<code>pre</code>确定树根<code>pre[0]</code></li>
<li>找到<code>pre[0]</code> 在中序<code>in</code> 的位置<code>root_idx</code></li>
<li>进而确定左右子树的中序、前序序列</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确定根节点在中序中位置，进而划分左右子树</span></span><br><span class="line">int rootIdx = findRootIdx(<span class="keyword">in</span>,pre[<span class="number">0</span>]);</span><br><span class="line">     </span><br><span class="line"><span class="comment">// 左子树的：前序序列，中序序列(copyOfRange 函数，左闭右开)</span></span><br><span class="line">int[] l_pre =  Arrays.copyOfRange(pre, <span class="number">1</span>, rootIdx + <span class="number">1</span>);</span><br><span class="line">int[] l_in  =  Arrays.copyOfRange(<span class="keyword">in</span>, <span class="number">0</span>, rootIdx);</span><br><span class="line"><span class="comment">//右子树的：前序序列，中序序列</span></span><br><span class="line">int[] r_pre =  Arrays.copyOfRange(pre, rootIdx+<span class="number">1</span>,  pre.length);</span><br><span class="line">int[] r_in  =  Arrays.copyOfRange(<span class="keyword">in</span>, rootIdx+<span class="number">1</span>, <span class="keyword">in</span>.length);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>递归操作</strong></p>
<p>这一部分略微难以理解: </p>
<ul>
<li>当前节点左子树<u>遍历完成时</u>，我们希望返回它的根节点作为当前节点的左孩子</li>
<li>当前节点右子树<u>遍历完成时</u>，返回它的根节点作为当前节点的右孩子</li>
</ul>
<p>无论左子树还是右子树：<u>“遍历完成时”</u> ,均指的是代码将要执行完成到函数末尾<code>&#125;</code> 。</p>
<p>即在后序位置，返回当前节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序找到根节点</span></span><br><span class="line"> TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明当前节点的左子树已经访问完毕（即将访问右子树）</span></span><br><span class="line"><span class="comment">// 返回的是左子树的根节点（即当前节点的左孩子）</span></span><br><span class="line"><span class="comment">// *所以函数最后还要 return root;</span></span><br><span class="line"> root.left  =  reConstructBinaryTree(l_pre,l_in);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右子树完成时</span></span><br><span class="line"> root.right =  reConstructBinaryTree(r_pre,r_in);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// [后序]*必须要返回当前节点(用来构建左右子树)</span></span><br><span class="line"> <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="comment">// [递归终止] 根据pre和in判断</span></span><br><span class="line">          <span class="comment">// 前序（或中序）长度为0，说明当前节点为空节点</span></span><br><span class="line">          <span class="keyword">if</span>(pre.length==<span class="number">0</span>)    </span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">// 确定根节点在中序中位置，进而划分左右子树</span></span><br><span class="line">          <span class="keyword">int</span> rootIdx = findRootIdx(in,pre[<span class="number">0</span>]);</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 左子树的：前序序列，中序序列(copyOfRange 函数，左闭右开)</span></span><br><span class="line">          <span class="keyword">int</span>[] l_pre =  Arrays.copyOfRange(pre, <span class="number">1</span>, rootIdx + <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">int</span>[] l_in  =  Arrays.copyOfRange(in, <span class="number">0</span>, rootIdx);</span><br><span class="line">          <span class="comment">//右子树的：前序序列，中序序列</span></span><br><span class="line">          <span class="keyword">int</span>[] r_pre =  Arrays.copyOfRange(pre, rootIdx+<span class="number">1</span>,  pre.length);</span><br><span class="line">          <span class="keyword">int</span>[] r_in  =  Arrays.copyOfRange(in, rootIdx+<span class="number">1</span>, in.length);</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 递归计算k</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 前序找到根节点</span></span><br><span class="line">      TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 说明当前节点的左子树已经访问完毕（即将访问右子树）</span></span><br><span class="line">      <span class="comment">// 返回的是左子树的根节点（即当前节点的左孩子）</span></span><br><span class="line">      <span class="comment">// *所以函数最后还要 return root;</span></span><br><span class="line">      root.left  =  reConstructBinaryTree(l_pre,l_in);</span><br><span class="line">  </span><br><span class="line">      root.right =  reConstructBinaryTree(r_pre,r_in);</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// *必须要返回当前节点(用来构建左右子树)</span></span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">     &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRootIdx</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> val_idx = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i &lt; array.length; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (val == array[i])</span><br><span class="line">          &#123;</span><br><span class="line">              val_idx = i;</span><br><span class="line">              <span class="keyword">return</span> val_idx;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val_idx;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC65-斐波那契"><a href="#NC65-斐波那契" class="headerlink" title="NC65: 斐波那契"></a>NC65: 斐波那契</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=190&tqId=35364&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/10/brDFApyECg5U9Km.png" alt="image-20210310212306342"></p>
</li>
<li><p>题解思路</p>
<p>斐波那契数列，同样是递归解决，关键在于如何拆解为递归子问题？</p>
<ul>
<li>欲求<code>F(n)</code> , 拆解为求<code>F(n-1)</code> 和<code>F(n-2)</code>之和</li>
<li>对于<code>F(n-1)</code> 拆解为求<code>F(n-2)</code> 和<code>F(n-3)</code>之和 ；<code>F(n-2)</code> 拆解为求<code>F(n-3)</code> 和<code>F(n-4)</code>之和 </li>
<li>重复以上，直至拆解为已知的<code>F(0)=1</code> 和<code>F(1)=1</code>之和</li>
</ul>
<p>所以代码容易得出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">// 第0项是0，第1项是第一个1,每一项等于前两项之和</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)  <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>)+Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种方式进行的递归有太多重复计算，如下图：</p>
<ul>
<li>f(2) 被重复计算3次 ； f(3) 被重复计算2次</li>
</ul>
<p><img src="https://i.loli.net/2021/03/11/bl9D3I2tCPUJFLs.png" alt=" "></p>
<p>为此，我们可以考虑用一个数组（或字典）来保存已计算的值，从而减少重复计算。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] res ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];  <span class="comment">// *长度==n+1，否则res[n]超出索引</span></span><br><span class="line">        Arrays.fill(res,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> F(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span>(res[n] != -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res[n] = F(n-<span class="number">1</span>)+F(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC48-动数组找值"><a href="#NC48-动数组找值" class="headerlink" title="NC48: 动数组找值"></a>NC48: 动数组找值</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7cd13986c79d4d3a8d928d490db5d707?tpId=190&tqId=35352&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/11/i6IXm7AaRofgxny.png" alt="image-20210311114729914"></p>
</li>
<li><p>题目思路</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/sou-suo-xuan-zhuan-pai-xu-shu-zu-by-leetcode-solut/">leetcode官方解析</a> 已经很清晰了，仅补充一点自己想法。</p>
</blockquote>
<p>此题难点在于：如何用二分查找法完成查找？</p>
<p>首先，数组有序仅是可以使用二分查找的充分条件而并不是必要条件，关键在于<u>能否确定待查找的数（target）在界桩（如，mid）的哪一边</u>？</p>
<p>对于转动的数组，依旧以mid为界桩，根据转动特点在mid左右数组子序列必有一边是有序的。我们可以根据有序那边确定target是否在其中，否则在另外一边：</p>
<ol>
<li><p>确定哪一边有序：对于左边，由于转动导致左边界可能存在非有序数字，如<code>mid&gt;左边界</code>则左边一定有序 ；同理，<code>mid&lt;右边界</code>则右边有序。</p>
</li>
<li><p>查找target是否在有序部分范围内，如果</p>
<ul>
<li>在有序部分内，重复1,2（但是判断条件就有点多余了）</li>
<li>如果不在，重复1,2在无序部分搜索（无序部分依旧符合转动特点）</li>
</ul>
</li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span> <span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">int</span> left=<span class="number">0</span>, right=A.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> mid=-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// *但是可能存在此时划分的数组长度=1，left=right=mid</span></span><br><span class="line">           <span class="comment">// 且left/right此时为数组左/右边界，下面mid-1/mid+1会超索引</span></span><br><span class="line">           <span class="comment">// 如 [1] 查找0（不存在），所以先排除该情况</span></span><br><span class="line">           <span class="keyword">if</span>(right-left==<span class="number">0</span> &amp;&amp; A[left]!=target)</span><br><span class="line">               <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">           </span><br><span class="line">           mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(A[mid]==target)</span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line">           <span class="keyword">if</span>(A[left]&lt;A[mid]) <span class="comment">// 左边此时有序（右边也可能）</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// 判断target是否在左边有序部分</span></span><br><span class="line">               <span class="keyword">if</span>(A[left]&lt;=target &amp;&amp; target&lt;=A[mid-<span class="number">1</span>])</span><br><span class="line">                   right=mid-<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span>  <span class="comment">// 否则在右边有序部分</span></span><br><span class="line">                   left=mid+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="comment">// 如果左边不有序则右边一定有序</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// 判断target是否在右边有序部分</span></span><br><span class="line">               <span class="keyword">if</span>(A[mid+<span class="number">1</span>]&lt;=target &amp;&amp; target&lt;=A[right])</span><br><span class="line">                   left=mid+<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="comment">// 否则在左边无序部分</span></span><br><span class="line">                   right=mid-<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC54-3sum"><a href="#NC54-3sum" class="headerlink" title="NC54: 3sum"></a>NC54: 3sum</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/345e2ed5f81d4017bbb8cc6055b0b711?tpId=190&tqId=35196&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/15/Dkcxy3en92mYvuT.png" alt="image-20210315215013181"></p>
</li>
<li><p>解法思路</p>
<blockquote>
<p>建议直接看<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/">LeetCode解答</a>更清晰 : 如何一步步从三重循环优化</p>
</blockquote>
<p>题目中要求找到所有「不重复」且和为 00 的三元组，这个「不重复」的要求使得我们无法简单地使用三重循环枚举所有的三元组。这是因为在最坏的情况下，数组中的元素全部为 00，即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 0, 0, 0, 0, ..., 0, 0, 0]</span><br></pre></td></tr></table></figure>

<p>任意一个三元组的和都为 0。如果我们直接使用三重循环枚举三元组，会得到 $O(N^3) $个满足题目要求的三元组（其中 $N$ 是数组的长度）时间复杂度至少为 $O(N^3)$。在这之后，我们还需要使用哈希表进行去重操作，得到不包含重复三元组的最终答案，又消耗了大量的空间。这个做法的时间复杂度和空间复杂度都很高，因此我们要换一种思路来考虑这个问题。</p>
<p>「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证：</p>
<ul>
<li><p>第二重循环枚举到的元素不小于当前第一重循环枚举到的元素；</p>
</li>
<li><p>第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。</p>
</li>
</ul>
<p>也就是说，我们枚举的三元组 $(a, b, c)$满足 $a \leq b \leq c$，保证了只有$ (a, b, c)$ 这个顺序会被枚举到，而 $(b, a, c)$、$(c,b,a)$ 等等这些不会，这样就减少了重复。要实现这一点，我们可以将 <u>数组中的元素从小到大进行排序</u> ，随后使用普通的三重循环就可以满足上面的要求。</p>
<p>同时，对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复。举个例子，如果排完序的数组为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 2, 2, 3]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>  我们使用三重循环枚举到的第一个三元组为 $(0, 1, 2)$，如果第三重循环继续枚举下一个元素，那么仍然是三元组 $(0, 1, 2)$，产生了重复。因此我们需要将第三重循环「跳到」下一个不相同的元素，即数组中的最后一个元素 $3$，枚举三元组$ (0, 1, 3)$。</p>
<p>  下面给出了改进的方法的伪代码实现：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums.sort()</span><br><span class="line"><span class="keyword">for</span> first = <span class="number">0</span> .. n-<span class="number">1</span></span><br><span class="line">    <span class="comment">// 只有和上一次枚举的元素不相同，我们才会进行枚举</span></span><br><span class="line">    <span class="keyword">if</span> first == <span class="number">0</span> or nums[first] != nums[first-<span class="number">1</span>] then</span><br><span class="line">        <span class="keyword">for</span> second = first+<span class="number">1</span> .. n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> second == first+<span class="number">1</span> or nums[second] != nums[second-<span class="number">1</span>] then</span><br><span class="line">                <span class="keyword">for</span> third = second+<span class="number">1</span> .. n-<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> third == second+<span class="number">1</span> or nums[third] != nums[third-<span class="number">1</span>] then</span><br><span class="line">                        <span class="comment">// 判断是否有 a+b+c==0</span></span><br><span class="line">                        check(first, second, third)</span><br></pre></td></tr></table></figure>

<p>  这种方法的时间复杂度仍然为 $O(N^3)$，毕竟我们还是没有跳出三重循环的大框架。然而它是很容易继续优化的，可以发现，如果我们固定了前两重循环枚举到的元素 $a$ 和 $b$，那么只有唯一的 $c$ 满足 $a+b+c=0$。当第二重循环往后枚举一个元素$ b’$时，由于 $b’ &gt;b$，那么满足 $a+b’+c’=0$ 的 $c’$一定有 $c’ &lt; c$ 即 $c’$在数组中一定出现在 $c$ 的左侧。也就是说，<strong>我们可以从小到大枚举 $b$，同时从大到小枚举 $c$，即第二重循环和第三重循环实际上是并列的关系。</strong></p>
<p>  有了这样的发现，我们就可以保持第二重循环不变，而将第三重循环变成一个从数组最右端开始向左移动的指针，从而得到下面的伪代码：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums.sort()</span><br><span class="line"><span class="keyword">for</span> first = <span class="number">0</span> .. n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> first == <span class="number">0</span> or nums[first] != nums[first-<span class="number">1</span>] then</span><br><span class="line">        <span class="comment">// 第三重循环对应的指针</span></span><br><span class="line">        third = n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> second = first+<span class="number">1</span> .. n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> second == first+<span class="number">1</span> or nums[second] != nums[second-<span class="number">1</span>] then</span><br><span class="line">                <span class="comment">// 向左移动指针，直到 a+b+c 不大于 0</span></span><br><span class="line">                <span class="keyword">while</span> nums[first]+nums[second]+nums[third] &gt; <span class="number">0</span></span><br><span class="line">                    third = third-<span class="number">1</span></span><br><span class="line">                <span class="comment">// 判断是否有 a+b+c==0</span></span><br><span class="line">                check(first, second, third)</span><br></pre></td></tr></table></figure>

<p>  这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们<u>发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法</u>，将枚举的时间复杂度从 $O(N^2)$ 减少至 $O(N)$。为什么是 $O(N)$ 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 $b$），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 $O(N)$，均摊下来，每次也向左移动一个位置，因此时间复杂度为$O(N)$。</p>
<p>  注意到我们的伪代码中还有第一重循环，时间复杂度为 $O(N)$，因此枚举的总时间复杂度为 $O(N^2)$。由于排序的时间复杂度为 $O(N \log N)$，在渐进意义下小于前者，因此算法的总时间复杂度为 $O(N^2)$。</p>
<p>  上述的伪代码中还有一些细节需要补充，例如我们需要保持左指针一直在右指针的左侧（即满足$ b \leq c$），具体可以参考下面的代码，均给出了详细的注释。</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] num)</span><br><span class="line">   &#123;</span><br><span class="line">       ArrayList&lt;ArrayList&lt;Integer&gt;&gt;  res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> len = num.length;</span><br><span class="line">       <span class="comment">// 排序方便循环不重复</span></span><br><span class="line">       <span class="comment">// 多重循环有序数组组合不重复：下一轮循环&gt;=上一轮元素</span></span><br><span class="line">       Arrays.sort(num);</span><br><span class="line">       <span class="comment">// 一重循环：选择一个数为目标数（不能重复）</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>; a&lt;len ; a++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// *重复则跳过</span></span><br><span class="line">           <span class="comment">//  如果是判断num[a]==num[a+1]? 会出现case：nums=[0,0,0]</span></span><br><span class="line">           <span class="comment">//  输出为[] 而非预期的输出[0,0,0]</span></span><br><span class="line">           <span class="comment">//  保证多个相邻重复数，第一个可以使用</span></span><br><span class="line">           <span class="keyword">if</span>(a&gt;<span class="number">0</span> &amp;&amp; num[a]==num[a-<span class="number">1</span>])</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           <span class="comment">// 二重循环：双指针法</span></span><br><span class="line">           <span class="comment">// 元素不重复:二重循环元素&gt;=一重循环</span></span><br><span class="line">           <span class="keyword">int</span> c = len-<span class="number">1</span>;   <span class="comment">// 右指针</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> b=a+<span class="number">1</span>; b&lt;c ; b++) </span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// *重复则跳过</span></span><br><span class="line">               <span class="comment">// 这里b&gt;a+1,否则同样case：nums=[0,0,0]</span></span><br><span class="line">               <span class="comment">// 输出为[]</span></span><br><span class="line">                <span class="keyword">if</span>(b&gt;a+<span class="number">1</span> &amp;&amp; num[b]==num[b-<span class="number">1</span>])</span><br><span class="line">                     <span class="keyword">continue</span>;</span><br><span class="line">               <span class="comment">// 右指针左移动，直至a+b+c&lt;=0</span></span><br><span class="line">               <span class="comment">// *保证c在b的右侧，否则会使用重复元素</span></span><br><span class="line">               <span class="keyword">while</span>(b&lt;c &amp;&amp; num[a]+num[b]+num[c]&gt;<span class="number">0</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   c--;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 检查此时a+b+c=0？</span></span><br><span class="line">               <span class="comment">// **注意此时b不能等于c，否则会使用重复元素！</span></span><br><span class="line">               <span class="keyword">if</span>(b!=c &amp;&amp; num[a]+num[b]+num[c]==<span class="number">0</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   ArrayList&lt;Integer&gt; triple = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                   triple.add(num[a]);</span><br><span class="line">                   triple.add(num[b]);</span><br><span class="line">                   triple.add(num[c]);</span><br><span class="line">                   res.add(triple);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC73-一半数字"><a href="#NC73-一半数字" class="headerlink" title="NC73:一半数字"></a>NC73:一半数字</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=190&tqId=35371&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/18/NqVOhLRmMIi9AaK.png" alt="image-20210318131812426"></p>
</li>
<li><p>解法思路</p>
<p>题目挺简单的</p>
<ul>
<li><p>哈希法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">// 采用haspmap一次记录</span></span><br><span class="line">        HashMap dic = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="comment">// 一次遍历记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Object obj_cur_count = dic.get(array[i]);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(obj_cur_count!=<span class="keyword">null</span>)</span><br><span class="line">                count = Integer.parseInt(obj_cur_count.toString())+<span class="number">1</span>;</span><br><span class="line">            dic.put(array[i], count);</span><br><span class="line">            <span class="comment">// *是i&gt;= 不是 i&gt;</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=len/<span class="number">2</span> &amp;&amp; count&gt;len/<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>候选法</p>
<p>加入数组中存在众数，那么众数一定大于数组的长度的一半。</p>
<ol>
<li>初始化：众数=num[0] , 票数=0，</li>
<li>从i=1遍历数组，如果当前数字≠众数，票数-1 。如果票数&lt;=0，则众数=num[i++] 。最差的情况是消去一个众数和一个非众数；</li>
<li>如果当前数字=众数，票数+1</li>
<li>循环结束，返回最终众数</li>
</ol>
</li>
</ul>
</li>
<li><p>代码实现</p>
<p>候选法实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="comment">// 初始化众数和票数</span></span><br><span class="line">      <span class="keyword">int</span> modal = array[<span class="number">0</span>], vote = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;array.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 判断众数是否和当前数字相等</span></span><br><span class="line">          <span class="comment">// 相等则vote+1，不相等则vote-1</span></span><br><span class="line">          vote = modal==array[i]?vote+<span class="number">1</span>:vote-<span class="number">1</span>;</span><br><span class="line">          <span class="comment">// 票数&lt;=0 &amp;&amp; i不指向数组末尾，更新众数</span></span><br><span class="line">          <span class="comment">// 票数&lt;=0 且当前i指向数组末尾，此时必不存在众数</span></span><br><span class="line">          <span class="keyword">if</span>(vote&lt;=<span class="number">0</span> &amp;&amp; ++i&lt;array.length)</span><br><span class="line">              modal=array[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 验证众数</span></span><br><span class="line">       <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(modal==array[i])</span><br><span class="line">               count++;</span><br><span class="line">           <span class="keyword">if</span>(count&gt;array.length/<span class="number">2</span>)</span><br><span class="line">               <span class="keyword">return</span> modal;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC36-数组中位数"><a href="#NC36-数组中位数" class="headerlink" title="NC36: 数组中位数"></a>NC36: 数组中位数</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/activity/oj">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/19/TV5l72Q4snwmN3z.png" alt="image-20210319233619198"></p>
</li>
<li><p>解法思路</p>
<blockquote>
<p>leetcode 题解：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/">详细通俗的思路分析，多解法</a></p>
</blockquote>
<p>本题易联想到归并排序中 <u>合并两个有序数组</u>，再取中位数。在这个过程中，只需记录指针位移，不用进行实际元素更新：空间复杂度可以优化成O(1)，但是时间复杂度依旧是O(n+m) : </p>
<blockquote>
<p>注意和NC22不同（数组A有多余空间可以存下B），这里的指针从头开始而非尾部。</p>
<p>从头部考虑更简单。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMedianinTwoSortedAray</span> <span class="params">(<span class="keyword">int</span>[] arrA, <span class="keyword">int</span>[] arrB)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 将两个有序数组合并成一个有序数组：三指针法</span></span><br><span class="line">        <span class="keyword">int</span> m = arrA.length , n = arrB.length;</span><br><span class="line">        <span class="comment">// 定义三个指针</span></span><br><span class="line">        <span class="comment">// 这里qc用来记录指针总的移动次数</span></span><br><span class="line">        <span class="comment">// 指针每移动一次代表一个数被确定(被排序好)</span></span><br><span class="line">        <span class="keyword">int</span> qa= <span class="number">0</span> ,qb=<span class="number">0</span>, qc=<span class="number">0</span>; </span><br><span class="line">        <span class="comment">// 需被确定的数，中位数k及之前的所有的数</span></span><br><span class="line">        <span class="keyword">int</span> k = (m+n)%<span class="number">2</span>==<span class="number">0</span>? (m+n)/<span class="number">2</span> :  (m+n)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 先比较完一个数组</span></span><br><span class="line">        <span class="keyword">while</span>(qa&lt;m &amp;&amp; qb&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arrA[qa]&lt;=arrB[qb])</span><br><span class="line">            &#123;</span><br><span class="line">                qa++; qc++;</span><br><span class="line">                <span class="comment">// 每次移动指针时判断是否确定（排序）数组中[0,中位数k]</span></span><br><span class="line">                <span class="comment">// 所有数字</span></span><br><span class="line">                <span class="keyword">if</span>(qc==k)  <span class="keyword">return</span> arrA[qa-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                qb++; qc++;</span><br><span class="line">                <span class="keyword">if</span>(qc==k) <span class="keyword">return</span> arrB[qb-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较剩余的数</span></span><br><span class="line">        <span class="keyword">while</span>(qa&lt;m)   <span class="comment">// A未比较完毕</span></span><br><span class="line">        &#123;</span><br><span class="line">            qa++; qc++;</span><br><span class="line">            <span class="keyword">if</span>(qc==k) <span class="keyword">return</span> arrA[qa-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(qb&lt;m)  </span><br><span class="line">        &#123;</span><br><span class="line">            qb++;qc++;</span><br><span class="line">            <span class="keyword">if</span>(qc==k) <span class="keyword">return</span> arrB[qb-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>但是如何优化时间到O(log(m+n)呢？</strong> 该问题可转换为：<u>求第k小数字</u>。</p>
<p>初始k值，即中位数在合并的序列中下标为 <code>k = (m+n)%2==0? (m+n)/2 :  (m+n)/2+1;</code></p>
<ol>
<li><p>比较A[k/2-1] 和 B[k/2-1]，其中较小者：最多只有A[0..k/2-2] + B[0..k/2-2] == k-2 个元素比它小，不可能是中位数k，可以将（[0..k/2-<strong>1</strong>]）数字全部排除。</p>
<p>更新数组左边界left=k/2，修改k=k-(k/2) （:warning: <u>不等价于k=k/2!</u>）</p>
</li>
<li><p>然后考虑三种边界条件（fu*k，怎么这么难想？）：</p>
<p><img src="https://i.loli.net/2021/03/20/GwTB8gA7eHiFRfb.png" alt="image-20210320223852345"></p>
</li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMedianinTwoSortedAray</span> <span class="params">(<span class="keyword">int</span>[] arrA, <span class="keyword">int</span>[] arrB)</span> </span></span><br><span class="line"><span class="function">  </span>&#123; </span><br><span class="line">      <span class="keyword">int</span> m = arrA.length, n = arrB.length;</span><br><span class="line">      <span class="comment">// 转换为求第k小的数</span></span><br><span class="line">      <span class="keyword">int</span> k = (m + n) % <span class="number">2</span> == <span class="number">0</span> ? (m + n) / <span class="number">2</span> : (m + n) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 数组左边界变化</span></span><br><span class="line">      <span class="keyword">int</span> leftA = <span class="number">0</span>, leftB = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 中位数指针比较位置</span></span><br><span class="line">      <span class="keyword">int</span> mediaA = <span class="number">0</span>, mediaB = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             1.比较A[k/2-1]和 B[k/2-1]</span></span><br><span class="line"><span class="comment">             2.如果，k/2-1会导致越界，改为对应数组的末尾len-1</span></span><br><span class="line"><span class="comment">             3.否则，更小的排除前面[0..k/2-1]个数 或 [0..len-1]之间数字</span></span><br><span class="line"><span class="comment">             4.更新k=k-k/2 或者 k=k-len</span></span><br><span class="line"><span class="comment">             5.更新左边界left,如果left&gt;数组边界，返回另外一个数组第k个元素</span></span><br><span class="line"><span class="comment">             6.直至k=1，返回左边界较小的数便是第k小的数</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          <span class="comment">// 数组为空说明该数组元素全部被排除，直接返回另外数组第k小即可</span></span><br><span class="line">          <span class="keyword">if</span>(leftA &gt; m-<span class="number">1</span>)</span><br><span class="line">              <span class="keyword">return</span> arrB[leftB+k-<span class="number">1</span>];</span><br><span class="line">          <span class="keyword">if</span>(leftB &gt; n-<span class="number">1</span>)</span><br><span class="line">              <span class="keyword">return</span> arrA[leftA+k-<span class="number">1</span>];</span><br><span class="line">          <span class="comment">// k==1时比较剩余待比较数组左边界第一个数字</span></span><br><span class="line">          <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">              <span class="keyword">return</span> arrA[leftA] &lt; arrB[leftB] ? arrA[leftA] :                                                        arrB[leftB] ;</span><br><span class="line">          <span class="comment">// *更新中位数指针比较位置(注意指针+left)</span></span><br><span class="line">          mediaA = leftA + k / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">          mediaB = leftB + k / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">          <span class="comment">// 处理越界情况</span></span><br><span class="line">          <span class="keyword">if</span> (mediaA &gt; m - <span class="number">1</span>) <span class="comment">// 数组A越界</span></span><br><span class="line">              mediaA = m - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (mediaB &gt; n - <span class="number">1</span>) <span class="comment">// 数组B越界</span></span><br><span class="line">              mediaB = n - <span class="number">1</span>;</span><br><span class="line">          <span class="comment">// 比较</span></span><br><span class="line">          <span class="keyword">if</span> (arrA[mediaA] &lt; arrB[mediaB]) <span class="comment">//排除[leftA..mediaA]</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">// *先更新k！</span></span><br><span class="line">              k = k - (mediaA - leftA + <span class="number">1</span>); <span class="comment">// 更新k=k-排除的数字</span></span><br><span class="line">              leftA = mediaA + <span class="number">1</span>;           <span class="comment">// 数组A左边界变化</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>  <span class="comment">//排除[leftB..mediaB]</span></span><br><span class="line">          &#123;</span><br><span class="line">              k = k - (mediaB - leftB + <span class="number">1</span>); <span class="comment">// 更新k=k-排除的数字</span></span><br><span class="line">              leftB = mediaB + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC30-最小正数"><a href="#NC30-最小正数" class="headerlink" title="NC30: 最小正数"></a>NC30: 最小正数</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8cc4f31432724b1f88201f7b721aa391?tpId=190&tqId=35388&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/21/wuGQP4W3mOirjlh.png" alt="image-20210321124313534"></p>
<p>加上条件：<code>加上这个缺失的最小整数后（不包括0），它是一个连续数组</code>。</p>
</li>
<li><p>解法思路</p>
<p>如果不考虑时间&amp;空间复杂度，利用双层循环：</p>
<ol>
<li>一次遍历记录数组最小元素<code>min</code>，和最大元素<code>max</code> ：<strong>如果<code>min&gt;1</code> ，返回<code>min-1</code></strong></li>
<li>【外层循环】对于每个整数元素 $j\in[min,max]$ ，【内层循环】遍历整个数组<code>Nums</code> 判断是否存在：不存在则返回<code>j</code> ； 都存在则返回<code>max+1</code></li>
</ol>
<p>显然对于【内层循环】，可以利用哈希表：<u>快速判断数组元素是否存在</u> ，的特性来查找。牺牲空间换时间：</p>
<ol>
<li>遍历数组，将数组元素<code>Nums[i]</code>, 作为哈希<code>dic</code>地址值(<code>key</code>) , <u>可在O(1)时间判断数组元素是否存在</u></li>
<li>同时上述遍历可以记录数组最小元素<code>min</code>，和最大元素<code>max</code>：如果<code>min&gt;1</code> ，返回<code>min-1</code></li>
<li>依次遍历整数 $j\in[min,max]$，判断是否存在<code>dic.get(j)</code>，不存在则返回<code>j</code> ； 都存在则返回<code>max+1</code> </li>
</ol>
<p>时间复杂度降为<code>O(n)</code> , 但是空间复杂度也是 <code>O(n)</code>  ，因为引入额外的哈希空间。为此我们使用<strong>“ 原地哈希 ”</strong> , 借助已知的数组<code>Nums</code>构造哈希表，优化空间。</p>
<blockquote>
<p><strong>首先分析最小正数范围：</strong>对于一个长度为N的整数数组<code>Nums</code>，如果出现元素<code>Nums[i]&lt;1</code> 或者 <code>Nums[i]&gt;N</code> 的数，那么缺少的整数$j\in[1,N]$ ; 如果都出现，则$j=N+1$。所以$j\in[1,N+1]$ 。因为数组一共只有N个数，如果出现不合法的数，则出现的1到N之间的数的个数一定小于N，故一定有没有出现的数。</p>
</blockquote>
<p>因此我们可以换种方式，<strong>用来在遍历正数$j\in[1,N]$ 快速判断是$j$否存在</strong>：遍历数组，如果存在元素$Nums[i]\in[1,N]$  , 则标记$Nums[Nums[i]-1]$ 取负数。</p>
<p><img src="https://i.loli.net/2021/03/22/67krG1Nx9XuQn5L.png" alt="image-20210322165559717"></p>
</li>
<li><p>代码实现</p>
<p>代码不是自己写的，因为觉得没多大意思这题，大多是数学问题。明白怎么分析过来就行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int firstMissingPositive(int[] nums)</span><br><span class="line">&#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[i] &lt;= 0) </span><br><span class="line">                nums[i] = n + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            int num = Math.abs(nums[i]);</span><br><span class="line">            if (num &lt;= n) &#123;</span><br><span class="line">                nums[num - 1] = -Math.abs(nums[num - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[i] &gt; 0) </span><br><span class="line">                return i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return n + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="【看】NC119-最小k个数"><a href="#【看】NC119-最小k个数" class="headerlink" title="【看】NC119:最小k个数"></a>【看】NC119:最小k个数</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=190&tqId=35976&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/22/k9yvA2DN6SJtZmr.png" alt="image-20210322173106038"></p>
</li>
<li><p>解法思路</p>
<p>把 <u>堆排序</u> 背下就没问题了，可参考前面堆排序代码理解。</p>
<p>时间复杂度：<code>O(nlongk)</code></p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] arr, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 套路题：对于找第k个小/打数，一般是堆排序最优</span></span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// k需小于数组长度</span></span><br><span class="line">        <span class="keyword">if</span>(k&gt;len|| k&lt;=<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> array ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.构建初始堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= len/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            <span class="comment">// 对每一个节点视作根节点，调整子树符合最小堆</span></span><br><span class="line">            MinHeapfily(arr,i,len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            array.add(arr[<span class="number">0</span>]);</span><br><span class="line">            swap(arr,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">            len--;</span><br><span class="line">            MinHeapfily(arr,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置参数要有数组长度，因为排序时交换堆顶和堆尾元素，相当删除堆顶元素</span></span><br><span class="line">    <span class="comment">// 对应数组长度-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MinHeapfily</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> root , <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 左右孩子</span></span><br><span class="line">        <span class="keyword">int</span> left = root*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = root*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left&gt;=len)</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = root;</span><br><span class="line">        min = arr[left]&lt; arr[min]? left : min;</span><br><span class="line">        min = right&lt;len &amp;&amp; arr[right]&lt; arr[min]? right : min;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果发生交换要往下调整</span></span><br><span class="line">        <span class="keyword">if</span>(min!=root)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(arr,min,root);</span><br><span class="line">            MinHeapfily(arr,min,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp ;</span><br><span class="line">        temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC88-第K大"><a href="#NC88-第K大" class="headerlink" title="NC88: 第K大"></a>NC88: 第K大</h5><ul>
<li><p><a href="">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/25/bTN3j6LJVCytxfE.png" alt="image-20210325230249765"></p>
</li>
<li><p>解法思路</p>
<p>思路主要参考快排，最后判断时结合二分：根据K大小决定去哪个子序列搜寻Kth。</p>
<p>代码细节参考下*。</p>
</li>
<li><p>代码实现</p>
<p>注意题目是<strong>寻找第K大</strong>，第K大对应的元素在 <u>排序后的数组下标</u> 是 <code>arr[n-k]</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 快排结合二分:</span></span><br><span class="line">        <span class="comment">// 如果一轮k==partition，return arr[k]</span></span><br><span class="line">        <span class="comment">// 如果k&gt;partition, 则在右侧搜索</span></span><br><span class="line">        <span class="comment">// 如果k&lt;partition, 则在左侧搜索</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> Kth = quickSort(arr,<span class="number">0</span>,n-<span class="number">1</span>,n-K);</span><br><span class="line">        <span class="keyword">return</span> Kth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快排思想</span></span><br><span class="line">    <span class="comment">// 1.设定一个基准pivot=arr[right],分割标记partition=left</span></span><br><span class="line">    <span class="comment">//   partition 表示最终基准插入的位置，初始==left表示默认所有元素&gt;pivot</span></span><br><span class="line">    <span class="comment">// 2.遍历数组，如果数组元素arr[i]&lt;pivot,交换arr[partition]和arr[i]</span></span><br><span class="line">    <span class="comment">//   且partition+1，将arr[i]交换到partition左边。保证基准左侧元素&lt;基准</span></span><br><span class="line">    <span class="comment">// 3.递归重复上述操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left, <span class="keyword">int</span> right,<span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// *这里实际不会执行，因为题目保证Kth一定存在</span></span><br><span class="line">        <span class="comment">// 所有return的一定是递归返回后的元素</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[right];</span><br><span class="line">        <span class="keyword">int</span> partition = left;</span><br><span class="line">        <span class="comment">// 保证partition左侧数字都小于基准</span></span><br><span class="line">        <span class="comment">// *从i=left，而不是i=0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;right; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;pivot)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(arr, i, partition);</span><br><span class="line">                partition++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 基准插入</span></span><br><span class="line">        swap(arr,partition,right);</span><br><span class="line">        <span class="comment">// 排序+二分</span></span><br><span class="line">        <span class="comment">// 递归返回搜索递归子树的结果</span></span><br><span class="line">        <span class="keyword">if</span>(K==partition)</span><br><span class="line">            <span class="keyword">return</span> arr[partition];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(K&lt;partition)</span><br><span class="line">            <span class="keyword">return</span> quickSort(arr,left,partition-<span class="number">1</span>,K);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> quickSort(arr,partition+<span class="number">1</span>,right,K);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组交换元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp ;</span><br><span class="line">        temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC105-二分查找第一个"><a href="#NC105-二分查找第一个" class="headerlink" title="NC105: 二分查找第一个"></a>NC105: 二分查找第一个</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/4f470d1d3b734f8aaf2afb014185b395?tpId=188&tqId=38062&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/26/DOndQULzSoFHhMc.png" alt="image-20210326152926676"></p>
</li>
<li><p>解题思路</p>
<p>就是二分查找套路，但是查找到target时要保证第一次出现，即左侧没有重复的元素。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span> <span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>,right = arr.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> mid ;</span><br><span class="line">       <span class="keyword">while</span> (left&lt;=right) <span class="comment">//*&lt;= 而不是&lt; </span></span><br><span class="line">       &#123;</span><br><span class="line">           mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(target == arr[mid])</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// *可能左侧还存在相同target，保证第一次出现</span></span><br><span class="line">               <span class="keyword">while</span>(mid&gt;<span class="number">0</span> &amp;&amp; arr[mid-<span class="number">1</span>]==target)</span><br><span class="line">                    mid--;</span><br><span class="line">               <span class="keyword">return</span> mid; <span class="comment">// 如果数组存在待查找元素，按照逻辑一定会是mid</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>  <span class="keyword">if</span>(target &lt; arr[mid])</span><br><span class="line">           &#123;</span><br><span class="line">  </span><br><span class="line">               right = mid-<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>  <span class="comment">// value &gt; arr[mid]</span></span><br><span class="line">           &#123;</span><br><span class="line">               left = mid+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">  </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC91-最长递增子序列"><a href="#NC91-最长递增子序列" class="headerlink" title="NC91: 最长递增子序列"></a>NC91: 最长递增子序列</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9cf027bf54714ad889d4f30ff0ae5481?tpId=190&tqId=35211&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/27/wfKH8ht2lnTEGAb.png" alt="image-20210327215133164"></p>
</li>
<li><p>解法思路</p>
<blockquote>
<p>从暴力解法→动态规划→再优化。</p>
</blockquote>
<p><strong>【一、暴力遍历】</strong></p>
<p>从头遍历所有的递增序列：</p>
<ol>
<li>对于每个元素<code>arr[i],q=i,ArrayList.add(arr[i])</code></li>
<li><strong>往后遍历，如果<code>arr[j]&gt;arr[i]</code>,则<code>q=j，ArrayList.add(arr[j])</code></strong></li>
<li><strong>如果<code>arr[j]&lt;arr[i]</code> 且 <code>j!=arr.length-1</code>,替换递增序列为<code>arr[j],q=[j]</code></strong></li>
<li>循环1,2，并记录每个ArrayList的最大长度，直至全部遍历完</li>
<li>遍历所有ArrayList，找到长度最长&amp;字典最小的ArrayList返回</li>
</ol>
<p>时间复杂度为<code>O(n^2)</code>，空间复杂度也为<code>O(n^2)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] LIS (<span class="keyword">int</span>[] arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen=-<span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrays = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            q=i;   <span class="comment">// 当前递增序列末尾</span></span><br><span class="line">            ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            array.add(arr[q]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;arr.length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[q])</span><br><span class="line">                &#123;</span><br><span class="line">                    q=j;array.add(arr[q]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j!=arr.length-<span class="number">1</span>&amp;&amp;arr[j]&lt;arr[q])  <span class="comment">// 替换末尾元素</span></span><br><span class="line">                &#123;</span><br><span class="line">                    array.remove(array.size()-<span class="number">1</span>);</span><br><span class="line">                    array.add(arr[j]);</span><br><span class="line">                    q=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录最大长度</span></span><br><span class="line">            <span class="keyword">int</span> len = array.size();</span><br><span class="line">            <span class="keyword">if</span>(len &gt; maxLen)</span><br><span class="line">                maxLen = len;</span><br><span class="line">            <span class="comment">// 记录以i为首的递增子序列</span></span><br><span class="line">            arrays.add(array);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">// 找到符合要求的最长递增子序列</span></span><br><span class="line">        <span class="keyword">int</span> LIS_idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minSum ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arrays.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            minSum = Sum(arrays.get(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span>(arrays.get(i).size()==maxLen) <span class="comment">// 符合最大长度</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Sum(arrays.get(i))&lt;minSum)</span><br><span class="line">                &#123;</span><br><span class="line">                    minSum=Sum(arrays.get(i));</span><br><span class="line">                    LIS_idx=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回满足要求的最长递增序列</span></span><br><span class="line">        <span class="keyword">return</span> arrays.get(LIS_idx).stream().mapToInt(k-&gt;k).toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>【二、动态规划】</strong></p>
<blockquote>
<p>参考解析：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/">leetcode-300，求最长子序列长度</a> ，但本题还需要返回递增子序列。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/03/30/f6I4ve2bxjtK3lU.png" alt="image-20210330210652510"></p>
<p>对状态方程不理解，可以看看 <u>解析的slides</u>，如何保证 $ dp[i]$ 是最大递增序列长度。  </p>
<ol>
<li>欲求子序列 $nums[0,1..,i]$ 中 $ dp[i]$ ，且已知道$j&lt;i,nums[0,1..,j]$ 各个子序列的$ dp[j]$</li>
<li> 遍历每个子序列，$nums[j]$ 是子序列的末尾元素</li>
</ol>
<ul>
<li> 如果$nums[i]&gt;nums[j]$，则可构成新的递增子序列， $nums[0,1..,j,i]$，此时最大子序列长度+1 ：$dp[i]=dp[j]+1$ 。但要保证$dp[i]$最大（每个子序列$dp[j]$值不同，更新$dp[i]$ 未必有先前大 ）：$dp[i]=max(dp[i],dp[j]+1]$ </li>
<li> 如果$nums[i]&lt;nums[j]$ , 跳过不用更新$dp[i]$</li>
</ul>
<p>对于本题还应该<strong>设置二维数组，保存所有递增子序列</strong>，所以：时间复杂度为<code>O(n^2)</code>，空间复杂度也为<code>O(n^2)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 1.状态定义</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 2.初始状态</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 3.动态方程</span></span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i]) </span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 返回值</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【三、再优化】</strong></p>
<p>算了。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC32-求平方根"><a href="#NC32-求平方根" class="headerlink" title="NC32: 求平方根"></a>NC32: 求平方根</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/09fbfb16140b40499951f55113f2166c?tpId=190&tqId=35187&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/30/8tWBIkA1h7TYPLN.png" alt="image-20210330213846787"></p>
</li>
<li><p>解法思路</p>
<blockquote>
<p>一、二分法，但是不知道为什么会超时？</p>
</blockquote>
<p>写出二分法模板，修改些边界条件：</p>
<ol>
<li><strong>找到所需平方根：</strong>如果一个数$mid$ 是$x$ 平方根，那一定满足$mid^2&lt;x&lt;(mid+1)^2$</li>
<li>修改左右边界，注意更新左右边界时可能会导致: ${right}^2&lt;x$ 或者  ${left}^2&gt;x$ ， 需要进行额外判断</li>
</ol>
<p>:bookmark_tabs: 注意明白<strong>1.</strong> 什么情况可以确定当前mid是平方根。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sqrt</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">        <span class="comment">// *x/2可以节省时间</span></span><br><span class="line">        <span class="keyword">return</span> binarySearchX(x,<span class="number">1</span>,x/<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchX</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">int</span> mid ;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right) </span><br><span class="line">        &#123;</span><br><span class="line">            mid = (right+left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            // [超时！！]这个判断条件会导致超时</span></span><br><span class="line"><span class="comment">            if(right-left&lt;=1)  // 此时一定是 left*left&lt;x&lt;right*right</span></span><br><span class="line"><span class="comment">                return left; </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(x/mid==mid) <span class="comment">// 等价于mid*mid&lt;x&lt;(mid+1)*(mid+1)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid; </span><br><span class="line">             &#125;</span><br><span class="line">            <span class="comment">// *防止mid*mid超出int最大表示</span></span><br><span class="line">            <span class="keyword">if</span>(x/mid &lt; mid)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">               <span class="comment">// *可能会出现right更新后right*right&lt;x</span></span><br><span class="line">               <span class="comment">// 说明(mid-1)*(mid-1) &lt; x &lt; mid*mid</span></span><br><span class="line">               <span class="keyword">if</span>(right &lt; x/right) </span><br><span class="line">                   <span class="keyword">return</span> mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x/mid &gt; mid)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// *可能会出现left*left&gt;x</span></span><br><span class="line">                <span class="keyword">if</span>(left &gt; x/left) </span><br><span class="line">                   <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC37-合并区间"><a href="#NC37-合并区间" class="headerlink" title="NC37: 合并区间"></a>NC37: 合并区间</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/69f4e5b7ad284a478777cb2a17fb5e6a?tpId=190&tqId=35348&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/31/CIgPSd4lz1yHoMT.png" alt="image-20210331184216974"></p>
</li>
<li><p>解法思路</p>
<p><strong>难点</strong>在于：</p>
<ul>
<li>排序完成后，可以分析出所有可能合并情况</li>
<li>能想到合并区间时不借助额外空间，只进行删除、替换元素，改变指针指向</li>
</ul>
<p>思路如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>冒泡排序：按区间左元素</span><br><span class="line"><span class="number">2.</span>遍历区间判断：是否合并区间</span><br><span class="line"> 前序列i=[a,b], 序列i+<span class="number">1</span>=[c,d]，其中c&gt;=a,</span><br><span class="line">  i).  如果c&gt;b,则不合并</span><br><span class="line">  ii). 如果c&lt;b,则可以合并序列[a,b]+[c,d]=[a,d]</span><br><span class="line">  iii).如果d&lt;b,则可以合并序列[a,b]+[c,d]=[a,b]</span><br><span class="line"><span class="number">3.</span>遍历返回结果</span><br></pre></td></tr></table></figure></li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Interval&gt; <span class="title">merge</span><span class="params">(ArrayList&lt;Interval&gt; intervals)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size()&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        <span class="comment">// 1.冒泡排序</span></span><br><span class="line">        <span class="keyword">int</span> len = intervals.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len-<span class="number">1</span>;i++)   <span class="comment">// 外轮=n-1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; len-i-<span class="number">1</span>; j++ ) <span class="comment">// 内轮=余下乱序数-1</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (intervals.get(j).start&gt;intervals.get(j+<span class="number">1</span>).start)</span><br><span class="line">                &#123;</span><br><span class="line">                    swapInterval(intervals,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 2.合并区间</span></span><br><span class="line">        <span class="comment">// *只保留符合要求的区间，不借助额外的空间</span></span><br><span class="line">        <span class="keyword">int</span> q=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q&lt;intervals.size()-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Interval i1 = intervals.get(q);</span><br><span class="line">            Interval i2 = intervals.get(q+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(i2.start&lt;=i1.end)</span><br><span class="line">            &#123;</span><br><span class="line">             <span class="keyword">if</span>(i2.end&lt;=i1.end)  <span class="comment">// 情况ii,[a,b]+[c,d]=[a,b]，删除[c,d]</span></span><br><span class="line">                  intervals.remove(q+<span class="number">1</span>);</span><br><span class="line">             <span class="keyword">else</span> <span class="comment">// 情况i,[a,b]+[c,d]=[a,d],替换[c,d]==[a,d]，删除[a,b]</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 替换</span></span><br><span class="line">                    intervals.get(q+<span class="number">1</span>).start= i1.start;</span><br><span class="line">                    <span class="comment">// 删除</span></span><br><span class="line">                    intervals.remove(q);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 情况i,不合并</span></span><br><span class="line">                q++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.返回</span></span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swapInterval</span><span class="params">(ArrayList&lt;Interval&gt; intervals,<span class="keyword">int</span> i1,<span class="keyword">int</span> i2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// *交换类类型指向不行？交换它们的数值</span></span><br><span class="line">        <span class="keyword">int</span> s1 = intervals.get(i1).start;</span><br><span class="line">        <span class="keyword">int</span> e1 = intervals.get(i1).end;</span><br><span class="line"></span><br><span class="line">        intervals.get(i1).start = intervals.get(i2).start;</span><br><span class="line">        intervals.get(i1).end = intervals.get(i2).end;</span><br><span class="line"></span><br><span class="line">        intervals.get(i2).start = s1;</span><br><span class="line">        intervals.get(i2).end = e1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC41-无重复子串"><a href="#NC41-无重复子串" class="headerlink" title="NC41: 无重复子串"></a>NC41: 无重复子串</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4?tpId=190&tqId=35220&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/19/8u7T4xiaQGZOl9N.png" alt="image-20210419153319381"></p>
</li>
<li><p>解法思路</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-3-字符串"><a href="#1-3-字符串" class="headerlink" title="1.3 字符串"></a>1.3 字符串</h3><h5 id="NC1-大数相加"><a href="#NC1-大数相加" class="headerlink" title="NC1: 大数相加"></a>NC1: 大数相加</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/11ae12e8c6fe48f883cad618c2e81475?tpId=190&tqId=36034&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/12/naKJiZTrUvWCIN2.png" alt="image-20210412151753848"></p>
</li>
<li><p>解法思路</p>
<ol>
<li><p>两个不等长度字符串，先补0化为长度相同【字符数组】</p>
<blockquote>
<p>e.g. : s=’123’ , t = ‘4’ <code>==&gt;</code> s=’123’ ,  t = ‘004’</p>
</blockquote>
<p>:notebook: 直接低位相加</p>
</li>
<li><p>从低位相加，计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环相加 </span></span><br><span class="line"><span class="keyword">int</span> a = cs[len]-<span class="string">&#x27;0&#x27;</span> + ct[len]-<span class="string">&#x27;0&#x27;</span> + carry;</span><br><span class="line">res.append(a%<span class="number">10</span>); <span class="comment">// (易错)*a%10 是低位；a/10 是高位</span></span><br><span class="line"><span class="comment">// 更新进位</span></span><br><span class="line">carry = a/<span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>返回结果</p>
<p>要最后判断是否有进位</p>
</li>
</ol>
<p>【反思：为什么debug这么久？】</p>
<ul>
<li><p><strong>对String类型转换不熟悉</strong>：char[] , int [] , String等等互转？又如，<code>char</code>和<code>int</code>之间如何互转？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *char转换为int自动转换× ,但转换的是ASCII码！</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;5&#x27;</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="string">&#x27;5&#x27;</span> - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 减去&#x27;0&#x27;的ASCII码，刚好是int类型5</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>对<code>StringBuffer</code> 不熟悉</strong>：在本题还需要一个结果字符串数组res来保存最后结果，res会不断被更新。如果使用<code>char[]</code> 会很麻烦（最后转换还是出错乱码了），在java应该优先考虑<code>StringBuffer</code>！</p>
</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(String s, String t)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = s.length(), j = t.length();</span><br><span class="line">       <span class="keyword">int</span> m = Math.max(i,j);</span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 1.先化为标准字符串</span></span><br><span class="line">       <span class="keyword">char</span>[] cs = <span class="keyword">new</span> <span class="keyword">char</span>[m];</span><br><span class="line">       <span class="keyword">char</span>[] ct = <span class="keyword">new</span> <span class="keyword">char</span>[m];</span><br><span class="line">       <span class="comment">// *遇到先减去值再计算的，最好用--m，而非m--</span></span><br><span class="line">       <span class="keyword">while</span>(--m&gt;=<span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           cs[m] = --i&gt;=<span class="number">0</span>? s.charAt(i):<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           ct[m] = --j&gt;=<span class="number">0</span>? t.charAt(j):<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 2.低位相加</span></span><br><span class="line">       <span class="keyword">int</span> len = cs.length;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.不知道为什么用char[] 数组保存结果，最后转换string乱码？</span></span><br><span class="line"><span class="comment">          char[] res = new char[len+1];</span></span><br><span class="line"><span class="comment">        2.下面StringBuffer直接insert会出错？改用append。</span></span><br><span class="line"><span class="comment">          res.insert(len+1,String.valueOf(a%10));</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">       <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(--len&gt;=<span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// *char转换为int自动转换× ,但转换的是ASCII码！</span></span><br><span class="line">           <span class="comment">// 得要减去-‘0’</span></span><br><span class="line">           <span class="keyword">int</span> a = cs[len]-<span class="string">&#x27;0&#x27;</span> + ct[len]-<span class="string">&#x27;0&#x27;</span> + carry;</span><br><span class="line">           <span class="comment">// (易错)*a%10 是低位；a/10 是高位</span></span><br><span class="line">           res.append(a%<span class="number">10</span>);</span><br><span class="line">           <span class="comment">// 更新进位</span></span><br><span class="line">           carry = a/<span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// 3.返回最后结果</span></span><br><span class="line">       <span class="keyword">if</span>(carry != <span class="number">0</span>) <span class="comment">// 最后依然有进位</span></span><br><span class="line">            res.append(carry);</span><br><span class="line">       <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC127-最长公共子串"><a href="#NC127-最长公共子串" class="headerlink" title="NC127: 最长公共子串"></a>NC127: 最长公共子串</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4?tpId=190&tqId=35220&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/19/2VHMnslSubrO7dT.png" alt="image-20210419162858034"></p>
</li>
<li><p>解法思路</p>
</li>
<li><p>代码实现</p>
<p><img src="https://i.loli.net/2021/04/21/YwZeovRAVNy1Pmf.png" alt="image-20210421203708822"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = text1.length(), n = text2.length();</span><br><span class="line">    <span class="comment">//dp[i][j] 表示 text1[0,i] 和 text1[0,j]最长</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 边界，i或j=0，字符串为空，dp[0][j]=dp[i][0]=0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = text1.charAt(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c2 = text2.charAt(j - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 动态方程</span></span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC41-最长不重复"><a href="#NC41-最长不重复" class="headerlink" title="NC41: 最长不重复"></a>NC41: 最长不重复</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4?tpId=191&tqId=36146&rp=1&ru=/activity/oj&qru=/ta/job-code-high-algorithm/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/25/yHiOA1h7qjQbFKe.png" alt="image-20210425160532901"></p>
</li>
<li><p>解法思路</p>
<p>采用经典滑动窗口来解决，滑动窗口里的数字都是不重复的：</p>
<blockquote>
<p>时间复杂度：O(N)，其中 <em>N</em> 是字符串的长度。</p>
</blockquote>
<ol>
<li><p>设置初始指针<code>left=0,right=0</code> 指向数组第1个数字；<code>curLen=1,maxLen=1</code> 分别记录当前滑动窗口的长度，和当前最大的不重复子串长度；</p>
</li>
<li><p>设置循环，<code>right</code> 向右移动<code>+1</code>，此时指向<code>arr[rigth]</code> ,设置循环遍历<code>滑动窗口[left,right-1]</code> ，是否发生重复；</p>
<blockquote>
<p>:warning: 循环遍历，已经用HashMap进行了优化。</p>
</blockquote>
</li>
<li><p>如果不发生重复，则此时窗口长度<code>curLen+1</code> ，并更新最大窗口长度<code>maxLen = Math.max(curLen,maxLen);</code> </p>
<blockquote>
<p>用HashMap不能在此时更新最大窗口长度，而应该在最后。详见代码注释</p>
</blockquote>
</li>
<li><p>如果发生重复，此时左指针指向重复数之后，更新窗口长度<code>curLen = right-left+1;</code> </p>
</li>
<li><p>直至<code>right</code>指针到达数组末尾，返回最大窗口长度。 </p>
</li>
</ol>
<p>【<strong>思维难点</strong>】</p>
<ul>
<li>陷入使用动态规划，而不知道如何下手；</li>
<li>判断发生重复，对HashMap不熟悉，最后还是用了循环<ul>
<li>HashMap不允许键值重复，如果发生重复会用后面的值覆盖</li>
<li>可以利用这个特性每次<code>right</code> 向右移动都用HashMap记录键值对<code>&lt;arr[right],right&gt;</code> ，保证重复的key，数组序列号一定是后面的</li>
<li>然后在判断是否发生重复时，判断是否在HashMap中，但是可能出现发生重复，但不在当前滑动窗口中，所以还要判断下重复元素的value是否&gt;left</li>
</ul>
</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> maxLen=<span class="number">1</span>,curLen=<span class="number">1</span>; <span class="comment">// *注意初始条件curLen</span></span><br><span class="line">       HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span>(++right&lt;arr.length) <span class="comment">// 右指针每次循环向右移动</span></span><br><span class="line">       &#123;</span><br><span class="line">           map.put(arr[right-<span class="number">1</span>],right-<span class="number">1</span>);</span><br><span class="line">           <span class="comment">// 判断当前右指针是否和前面序列发生重复</span></span><br><span class="line">           <span class="comment">// 根据是否重复做出判断</span></span><br><span class="line">           <span class="keyword">if</span>(! map.containsKey(arr[right]))</span><br><span class="line">           &#123;</span><br><span class="line">               curLen++; </span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="comment">// 发生重复</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// 改变left指针指向到重复数字之后</span></span><br><span class="line">               <span class="comment">// 但要保证一定是在当前滑动窗口内[left,right-1]</span></span><br><span class="line">               left = Math.max(left, map.get(arr[right])+<span class="number">1</span>);</span><br><span class="line">               curLen = right-left+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// *易错，此时最大值更新一定要在最后判断</span></span><br><span class="line">           <span class="comment">// 而不是放在if语句内</span></span><br><span class="line">           <span class="comment">// 因为用HashMap判断会导致，出现重复但</span></span><br><span class="line">           <span class="comment">// 实际并不在滑动窗口内，不会执行下面语句 </span></span><br><span class="line">            maxLen = Math.max(curLen,maxLen);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxLen;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC52-括号序列"><a href="#NC52-括号序列" class="headerlink" title="NC52: 括号序列"></a>NC52: 括号序列</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4?tpId=190&tqId=35220&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/19/z3s7gQkpheJfTuI.png" alt="image-20210419162935431"></p>
</li>
<li><p>解法思路</p>
<p>思路很清晰：</p>
<ol>
<li>设置一个栈，遍历字符串<code>s</code> ；</li>
<li>如果当前栈不为空，且栈顶元素和<code>s.charAt(i)</code> 括号匹配则将栈顶元素出栈；</li>
<li> 否则将<code>s.charAt(i)</code>压入栈；</li>
<li>当循环结束后，如果括号都匹配，此时栈应该为空，返回<code>true</code> ；否则返回<code>false</code> ；</li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span> <span class="params">(String s)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">// </span></span><br><span class="line">       Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 如果匹配就出栈，否则入栈</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;s.length();i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; isMatch(stack.peek(),s.charAt(i)))</span><br><span class="line">              <span class="comment">// 此时匹配则出栈</span></span><br><span class="line">               stack.pop();</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               stack.push(s.charAt(i));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果都匹配最后的栈应该是空的</span></span><br><span class="line">       <span class="keyword">if</span>(stack.isEmpty())</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">              </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span> c1,<span class="keyword">char</span> c2)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c1==<span class="string">&#x27;(&#x27;</span> &amp;&amp; c2==<span class="string">&#x27;)&#x27;</span>)     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(c1==<span class="string">&#x27;[&#x27;</span> &amp;&amp; c2==<span class="string">&#x27;]&#x27;</span>)     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(c1==<span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; c2==<span class="string">&#x27;&#125;&#x27;</span>)     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC103-反转字符串"><a href="#NC103-反转字符串" class="headerlink" title="NC103: 反转字符串"></a>NC103: 反转字符串</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c3a6afee325e472386a1c4eb1ef987f3?tpId=190&tqId=35226&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/25/ESl69eZqRjVQgmo.png" alt="image-20210425174038641"></p>
</li>
<li><p>解法思路</p>
<p>思路：</p>
<ol>
<li>首尾设置双指针，交换首尾元素即可</li>
</ol>
<p>【<strong>编码难点</strong>】</p>
<ul>
<li><code>String</code>类型不能修改，应该转换为<code>char[]</code> 在原地交换</li>
<li><code>String</code> 和 <code>char[]</code> 互转不熟悉</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(String str)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">// 思路：双指针+交换</span></span><br><span class="line">       <span class="comment">// *string类型不能修改，所以先转换为能修改的char数组</span></span><br><span class="line">       <span class="keyword">char</span>[] cstr = str.toCharArray();</span><br><span class="line">       <span class="comment">// 循环遍历</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=cstr.length-<span class="number">1</span>; i&lt;j; i++,j--)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">char</span> tmp = cstr[i];</span><br><span class="line">           cstr[i] = cstr[j];</span><br><span class="line">           cstr[j] = tmp; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(cstr);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC41-字符串排列组合"><a href="#NC41-字符串排列组合" class="headerlink" title="NC41: 字符串排列组合"></a>NC41: 字符串排列组合</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=190&tqId=35987&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/25/JzepNsjM6Et2F9l.png" alt="image-20210425232928928"></p>
</li>
<li><p>解法思路</p>
</li>
<li><p>代码实现</p>
</li>
</ul>
<h5 id="NC17-最长回文子串"><a href="#NC17-最长回文子串" class="headerlink" title="NC17: 最长回文子串"></a>NC17: 最长回文子串</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/b4525d1d84934cf280439aeecc36f4af?tpId=190&tqId=35207&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/25/5PUesu7AVT4hHlN.png" alt="image-20210425175425901"></p>
</li>
<li><p>解法思路</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC49-最长括号子串"><a href="#NC49-最长括号子串" class="headerlink" title="NC49: 最长括号子串"></a>NC49: 最长括号子串</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/45fd68024a4c4e97a8d6c45fc61dc6ad?tpId=190&tqId=35191&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/25/9tdqwlehpZ1G5P8.png" alt="image-20210425233123336"></p>
</li>
<li><p>解法思路</p>
</li>
<li><p>代码实现</p>
</li>
</ul>
<h5 id="NC41-最长不重复-1"><a href="#NC41-最长不重复-1" class="headerlink" title="NC41: 最长不重复"></a>NC41: 最长不重复</h5><ul>
<li><a href="">题目描述</a></li>
<li>解法思路</li>
<li>代码实现</li>
</ul>
<h5 id="NC41-最长不重复-2"><a href="#NC41-最长不重复-2" class="headerlink" title="NC41: 最长不重复"></a>NC41: 最长不重复</h5><ul>
<li><a href="">题目描述</a></li>
<li>解法思路</li>
<li>代码实现</li>
</ul>
<h5 id="NC41-最长不重复-3"><a href="#NC41-最长不重复-3" class="headerlink" title="NC41: 最长不重复"></a>NC41: 最长不重复</h5><ul>
<li><a href="">题目描述</a></li>
<li>解法思路</li>
<li>代码实现</li>
</ul>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="字符串第一个不重复的数字"><a href="#字符串第一个不重复的数字" class="headerlink" title="字符串第一个不重复的数字"></a>字符串第一个不重复的数字</h5><p>先一个int[26]统计26个字母出现次数，然后返回次数为1的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">printBin</span><span class="params">(<span class="keyword">double</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;0.&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; i++) &#123;</span><br><span class="line">            num *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 取整数部分</span></span><br><span class="line">                builder.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                <span class="comment">// 取完后减1取小数部分</span></span><br><span class="line">                num -= <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                builder.append(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> builder.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="微信抢红包算法"><a href="#微信抢红包算法" class="headerlink" title="微信抢红包算法"></a>微信抢红包算法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    ArrayList&lt;Double&gt; res </span><br><span class="line">           = WXRedPackageAlgorithm(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> money:res) &#123;</span><br><span class="line">        sum += money;</span><br><span class="line">        System.out.print(money +<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(sum);     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Double&gt;</span></span><br><span class="line"><span class="function"><span class="title">WXRedPackageAlgorithm</span><span class="params">(<span class="keyword">double</span> restMoney,<span class="keyword">int</span> restNum)</span></span>&#123;                </span><br><span class="line">    ArrayList&lt;Double&gt; res </span><br><span class="line">             = <span class="keyword">new</span> ArrayList&lt;&gt;(restNum);</span><br><span class="line"></span><br><span class="line">    Random random=<span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">while</span>(restNum&gt;<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//最大的红包为：两倍的平均红包大小</span></span><br><span class="line">        <span class="keyword">double</span> max=(restMoney/restNum) * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//产生[0,1)之间的随机数</span></span><br><span class="line">        <span class="keyword">double</span> r=random.nextDouble();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//抢到的红包区间[0,max)</span></span><br><span class="line">        <span class="keyword">double</span> money = r * max;</span><br><span class="line">        <span class="keyword">if</span>(money&lt;<span class="number">0.01</span>)</span><br><span class="line">            money = <span class="number">0.01</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            money= Math.floor(money*<span class="number">100</span>)/<span class="number">100</span>;        </span><br><span class="line"></span><br><span class="line">        res.add(money);</span><br><span class="line"></span><br><span class="line">        restNum--;</span><br><span class="line">        restMoney -= money; </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后一个红包为剩余余额</span></span><br><span class="line">    res.add(Math.floor(restMoney*<span class="number">100</span>)/<span class="number">100</span> );</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-4-链表和栈"><a href="#1-4-链表和栈" class="headerlink" title="1.4 链表和栈"></a>1.4 链表和栈</h3><h5 id="NC78-反转链表"><a href="#NC78-反转链表" class="headerlink" title="NC78: 反转链表"></a>NC78: 反转链表</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=190&tqId=35203&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/02/mpJih4vGB5QUzof.png" alt="image-20210402221818444"></p>
</li>
<li><p>解法思路</p>
<p>假设存在链表 1→2→3→∅，我们想要把它改成∅←1←2←3。</p>
<p>核心难点：</p>
<ol>
<li><p>设置三个指针初始化问题，<code>p,q,q_next</code>,记录前一个节点，当前节点，下一个节点;</p>
<p>为了操作统一，前一个节点应该指向<code>null</code></p>
</li>
<li><p>更新节点问题，放在循环开头还是末尾</p>
</li>
</ol>
<p>代码实现见下。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// *p,q,q_next,分别记录前一个节点，当前节点，下一个节点</span></span><br><span class="line">        <span class="comment">// *为了操作统一，p最开始指向null！！</span></span><br><span class="line">        ListNode p = <span class="keyword">null</span>;</span><br><span class="line">        ListNode q = head,q_next=head;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// *下一个节点更新放在循环开始，而非末尾</span></span><br><span class="line">            <span class="comment">// 避免q.next==null时，q.next.next赋值给q.next出错</span></span><br><span class="line">            q_next = q.next;</span><br><span class="line">            <span class="comment">// 改变q指向</span></span><br><span class="line">            q.next=p;</span><br><span class="line">            <span class="comment">// *更新前一个节点，当前更新p,q节点只能在循环末尾</span></span><br><span class="line">            <span class="comment">//  因为后面代码q.next=p，要操作p，q，在此之前不能更新p，q</span></span><br><span class="line">            p=q;</span><br><span class="line">            q=q_next;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC93-LRU"><a href="#NC93-LRU" class="headerlink" title="NC93: LRU"></a>NC93: LRU</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/e3769a5f49894d49b871c09cadd13a61?tpId=190&tqId=35214&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/04/EGol598eYWpPvXH.png" alt="image-20210404120459969"></p>
</li>
<li><p>解法思路</p>
<p>首先探讨使用何种数据结构：</p>
<ul>
<li>哈希表：通过key定位要操作的节点，<code>O(1)</code>复杂度</li>
<li>双向链表：实现节点插入、删除、获取值等操作，<code>O(1)</code>复杂度</li>
</ul>
<p>所以最终的数据结构形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;<span class="keyword">int</span> key,DLinkedNode&gt;  map ;</span><br></pre></td></tr></table></figure>

<p><code>DLinkedNode</code> 是双链表节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 键值对</span></span><br><span class="line">    <span class="keyword">int</span> key,value ;</span><br><span class="line">    <span class="comment">// 前后指针</span></span><br><span class="line">    DLinkedNode pre,next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">()</span> </span>&#123; pre = next = <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123; key = k;  value = v;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体实现双链表<code>DLinkedList</code>的trick：</p>
<ul>
<li><strong>统一操作：</strong> 双向链表使用<u>伪头部和伪尾部</u>来统一插入/删除操作</li>
</ul>
<p><u>链表实现，应该包含基本删除、插入操作（具体代码略）。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 伪头部，尾部</span></span><br><span class="line">    DLinkedNode head;</span><br><span class="line">    DLinkedNode tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *初始化,∅⇌head⇌tail⇌∅</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">DLinkedList</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//*这里head和tail是存在的，要实例化，而非指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*定义一些链表基本操作*/</span></span><br><span class="line">    <span class="comment">// 双链表：插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(DLinkedNode preNode,DLinkedNode insertNode)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双链表：删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(DLinkedNode delNode)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>为满足题目条件：</p>
<ul>
<li><p><strong>满足条件1：</strong> 使用<code>HashMap</code> 保存链表<code>&lt;key,对应节点&gt;</code>，用于快速定位；双向链表用于满足操作,<code>O(1)</code>复杂度</p>
</li>
<li><p><strong>满足条件2：</strong><u>链表越靠近头部则表示越频繁使用</u>，每次set操作，将节点插入到头部；get操作，将节点移动到头部</p>
</li>
<li><p><strong>满足条件3：</strong> 每次set操作，检查当前容量超过缓存大小，删除尾节点</p>
</li>
</ul>
<p>封装数据结构 <code>HashMap&lt;int key,DLinkedNode&gt; </code> ，和对应方法 <code>set、get</code> 来实现满足上述条件的基本LRU缓存结构。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRU_Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lru design</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operators int整型二维数组 the ops</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 the k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] LRU (<span class="keyword">int</span>[][] operators, <span class="keyword">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        Cache cache = <span class="keyword">new</span> Cache(k);</span><br><span class="line">        <span class="comment">// 进行操作</span></span><br><span class="line">        <span class="comment">// eg:[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;operators.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> opt = operators[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> key = operators[i][<span class="number">1</span>] ,value;</span><br><span class="line">            <span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                value = operators[i][<span class="number">2</span>];</span><br><span class="line">                cache.set(key,value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                arr.add(cache.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最后结果</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.size();i++)</span><br><span class="line">            res[i]=arr.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> capacity,len;</span><br><span class="line">    <span class="comment">// hashmap 保存所有节点，快速索引</span></span><br><span class="line">    HashMap&lt;Integer,DLinkedNode&gt; map ;</span><br><span class="line">    <span class="comment">// 链表</span></span><br><span class="line">    DLinkedList dll;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.len = <span class="number">0</span>;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;Integer,DLinkedNode&gt;();</span><br><span class="line">        dll = <span class="keyword">new</span> DLinkedList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 新建节点</span></span><br><span class="line">        DLinkedNode node = <span class="keyword">new</span>  DLinkedNode(key,value);</span><br><span class="line">        <span class="keyword">if</span>(len&gt;=capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 长度超过容量，移除最不常使用的记录（尾部）</span></span><br><span class="line">            <span class="comment">// *hashmap操作：map移除对应key</span></span><br><span class="line">            <span class="comment">// *移除的是被删除的尾节点的key！！</span></span><br><span class="line">            map.remove(dll.tail.pre.key);</span><br><span class="line">            <span class="comment">// 双链表操作:移除</span></span><br><span class="line">            dll.del(dll.tail.pre);</span><br><span class="line">            <span class="comment">// *长度-1</span></span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 链表头部插入新节点变为最常用</span></span><br><span class="line">        dll.insert(dll.head, node);</span><br><span class="line">        <span class="comment">// *HashMap也要更新</span></span><br><span class="line">        map.put(key,node);</span><br><span class="line">        <span class="comment">// cacha长度+1</span></span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DLinkedNode node = map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 删除节点</span></span><br><span class="line">            dll.del(node);</span><br><span class="line">            <span class="comment">// 移动到头部变为最常用</span></span><br><span class="line">            dll.insert(dll.head,node);</span><br><span class="line">            <span class="comment">// 返回值</span></span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 伪头部，尾部</span></span><br><span class="line">    DLinkedNode head,tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *初始化,∅⇌head⇌tail⇌∅</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">DLinkedList</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//*这里head和tail是存在的，要实例化，而非指针</span></span><br><span class="line">        head = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        tail = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*定义一些链表基本操作*/</span></span><br><span class="line">    <span class="comment">// 双链表：插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(DLinkedNode preNode,DLinkedNode insertNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        insertNode.next = preNode.next;</span><br><span class="line">        preNode.next.pre = insertNode;</span><br><span class="line"></span><br><span class="line">        insertNode.pre = preNode;</span><br><span class="line">        preNode.next = insertNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双链表：删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(DLinkedNode delNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        delNode.next.pre=delNode.pre;</span><br><span class="line">        delNode.pre.next = delNode.next;</span><br><span class="line">        delNode.pre = delNode.next =<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 键值对</span></span><br><span class="line">    <span class="keyword">int</span> key,value ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前后指针</span></span><br><span class="line">    DLinkedNode pre,next;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pre = next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        key = k;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC4-是否有环"><a href="#NC4-是否有环" class="headerlink" title="NC4: 是否有环"></a>NC4: 是否有环</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=190&tqId=35179&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/07/eVYm87lwRMucAzH.png" alt="image-20210407214335658"></p>
</li>
<li><p>解法思路</p>
<p>略，看代码</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 思路1：快慢指针（trick），最优解，O(1)复杂度</span></span><br><span class="line">        <span class="comment">// 思路2：hashmap存下所有节点，然后遍历节点就去判断是否在hashmap中</span></span><br><span class="line">        <span class="comment">// *要先判断head==null的情况</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode step1 = head;</span><br><span class="line">        ListNode step2 = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(step2!= <span class="keyword">null</span> &amp;&amp; step2.next != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 好像不会出现step1==null的情况？</span></span><br><span class="line">            <span class="comment">// 因为【如果有环】会在快指针走到终点前就相遇</span></span><br><span class="line">            step1 = step1.next;</span><br><span class="line">            <span class="comment">// 循环终止条件从这里得到</span></span><br><span class="line">            step2 = step2.next.next;</span><br><span class="line">            <span class="comment">// *不能在前面判断，因为初始step1==step2</span></span><br><span class="line">            <span class="keyword">if</span>(step1==step2)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC33-合并链表"><a href="#NC33-合并链表" class="headerlink" title="NC33:合并链表"></a>NC33:合并链表</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/a479a3f0c4554867b35356e0d57cf03d?tpId=190&tqId=35188&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/07/SP67yTnwDkcugxf.png" alt="image-20210407214615022"></p>
</li>
<li><p>解法思路</p>
<p>整体思路如下：</p>
<ol>
<li><p>定义一个辅助头结点<code>head</code> ，介绍判断第一个节点的麻烦；同时定义合并后链表工作指针<code>tail</code> ，用于在合并链表后方便插入节点</p>
<blockquote>
<p>:warning: 定义辅助头节点是要声明空间进行初始化的，和指针不同！<u>指针保存的都是节点的地址！</u> </p>
<p>:notebook_with_decorative_cover: 【不用纠结】也可以不定义辅助头节点，但是要先得到第一个节点。</p>
</blockquote>
</li>
<li><p>定义指针<code>h1，h2</code> ，分别指向链表<code>L1,L2</code> 第一个节点：比较指针<code>h1，h2</code> 指向的值大小，将<code>tail</code> 指向更小的节点，同时更新<code>tail</code> 和相应工作指针<code>h1，h2</code>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(h1.val &lt; h2.val)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// 更新head指向断开的节点h1</span></span><br><span class="line">         tail.next = h1;</span><br><span class="line">      <span class="comment">// 更新tail指向合并链表最后插入的节点</span></span><br><span class="line">         tail = h1;</span><br><span class="line">      <span class="comment">// 更新工作指针h1为h1.next</span></span><br><span class="line">         h1 = h1.next;</span><br><span class="line">      <span class="comment">// 不用更新*之前h1指向null，因为此时是tail，后面会指向</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">     <span class="comment">// 同上</span></span><br></pre></td></tr></table></figure></li>
<li><p>直至<code>h1或h2</code>  指向<code>null</code>，即其中一个链表被遍历完成，将<code>tail</code>  直接指向剩余未遍历完成的链表的第一个节点，即此时不为<code>null</code>工作指针<code>h1或h2</code> </p>
<blockquote>
<p>:warning: 和合并数组不同：此时 <strong>不用</strong><u>循环插入剩余的节点！</u> 指向第一个节点即可！</p>
</blockquote>
</li>
<li><p>最后返回辅助头节点的<code>head.next</code></p>
</li>
</ol>
</li>
<li><p>代码实现</p>
<p>不用在开头判断<code>L1，L2</code> 是否为<code>null</code>，后面的逻辑会处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span> <span class="params">(ListNode l1, ListNode l2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 思路</span></span><br><span class="line">        <span class="comment">// 定义工作节点h1,h2</span></span><br><span class="line">        ListNode h1 = l1, h2 = l2;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个辅助头节点，减少处理第一个节点麻烦</span></span><br><span class="line">        <span class="comment">// 辅助头节点肯定是要【初始化】</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// *定义一个尾指针（为了保留head返回）</span></span><br><span class="line">        <span class="comment">// *这个尾指针只对指向的节点操作</span></span><br><span class="line">        ListNode tail = head;</span><br><span class="line">        <span class="keyword">while</span>(h1!=<span class="keyword">null</span> &amp;&amp; h2!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 判断大小</span></span><br><span class="line">            <span class="keyword">if</span>(h1.val &lt; h2.val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 更新head指向断开的节点h1</span></span><br><span class="line">                tail.next = h1;</span><br><span class="line">                <span class="comment">// 更新tail指向合并链表最后插入的节点</span></span><br><span class="line">                tail = h1;</span><br><span class="line">                <span class="comment">// 更新工作指针h1为h1.next</span></span><br><span class="line">                h1 = h1.next;</span><br><span class="line">                <span class="comment">// 不用更新*之前h1指向null</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 更新head指向断开的节点h2</span></span><br><span class="line">                tail.next = h2;</span><br><span class="line">                <span class="comment">// 更新tail指向合并链表最后插入的节点</span></span><br><span class="line">                tail = h2;</span><br><span class="line">                <span class="comment">// 更新工作指针h2</span></span><br><span class="line">                h2 = h2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// tail直接指向剩下链表</span></span><br><span class="line">        <span class="comment">// *不用循环一个个插入到tail后面！</span></span><br><span class="line">        <span class="keyword">if</span>(h1 != <span class="keyword">null</span>)</span><br><span class="line">            tail.next = h1;  </span><br><span class="line">        <span class="keyword">if</span>(h2 != <span class="keyword">null</span>)</span><br><span class="line">            tail.next = h2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC76-栈实现队列"><a href="#NC76-栈实现队列" class="headerlink" title="NC76: 栈实现队列"></a>NC76: 栈实现队列</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=190&tqId=35202&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/08/wAQG9sW2IC81eHp.png" alt="image-20210408112008318"></p>
</li>
<li><p>思路解析</p>
<p>首先分析队列和栈的两个操作的不同：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">push</th>
<th align="center">pop</th>
</tr>
</thead>
<tbody><tr>
<td align="center">队列</td>
<td align="center">尾部插入</td>
<td align="center">头部弹出</td>
</tr>
<tr>
<td align="center">栈</td>
<td align="center">尾部插入</td>
<td align="center">尾部弹出</td>
</tr>
</tbody></table>
<p>显然对于队列的<strong>push</strong> 操作可以直接用栈<strong>push</strong> 操作来实现 ； 那队列的<strong>pop</strong>操作如何用栈来实现呢？</p>
<ul>
<li>假定实现队列<strong>push</strong> 用*<u>stack1</u><em>来*<em>push</em></em> 实现，尾部插入</li>
<li> 那么需要用栈<strong>pop</strong> 实现队列 <strong>pop</strong> ，必须要先将已有”队列“<em>stack1</em>中数据逆置：即将stack1中所有数据都pop，在push到<em>stack2</em>中 </li>
<li><em>stack2</em> 再使用栈<code>pop</code> 出的就是”队列“<em>stack1</em> 中的头部，即模拟了队列的<code>pop</code> </li>
<li>对于后续的队列<strong>pop</strong> ， 都可以直接<strong>pop</strong> 出<em>stack2</em>中的元素；如果<em>stack2</em>为空，就将<em>stack1</em> 中元素逆置到<em>stack2</em>中，再<strong>pop</strong></li>
</ul>
<p> 总结核心操作：</p>
<ul>
<li>队列push，直接用栈push实现，都是“尾部插入”</li>
<li>队列pop，可以先将队列中数据逆置（两个栈交换数据），再用栈pop“头部”弹出</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将stack1全部转移到stack2中</span></span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后再pop出来</span></span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC50-链表k翻转"><a href="#NC50-链表k翻转" class="headerlink" title="NC50: 链表k翻转"></a>NC50: 链表k翻转</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=190&tqId=35192&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/08/FMpjuIO1f3Ub5en.png" alt="image-20210408160501802"></p>
</li>
<li><p>解析思路</p>
<ol>
<li><p>【套翻转模板】先思考如何翻转指定首尾的链表：</p>
<ul>
<li>修改1：考虑翻转循环边界条件</li>
<li>修改2：首尾节点指向</li>
</ul>
</li>
<li><p>遍历链表，设置指针<code>pre,f,e</code> 分别指向要<u>反转链表段</u> 的：首节点前一个节点，首节点，尾节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始段首尾节点都指向首节点</span></span><br><span class="line">ListNode  pre = <span class="keyword">null</span>, f = head, f = head;</span><br></pre></td></tr></table></figure></li>
<li><p>尾指针<code>e</code>移动并计数，如果满足<code>count % k == 0</code> 说明找到尾节点，则<u>反转指定首尾的链表</u>，然后更新指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pre = f;  <span class="comment">// 指向下一个反转段的首节点的前一个节点 </span></span><br><span class="line">f = e = f.next; <span class="comment">// 首尾初始指向首节点</span></span><br></pre></td></tr></table></figure></li>
<li><p>直到移动<code>e</code>，寻找下一个段的尾节点发现不存在，<code>e==null</code>退出循环</p>
</li>
</ol>
<p>:warning: 在k反转的链表，第一组的翻转的链表尾节点<code>e</code>，是整个翻转链表的首节点！</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路</span></span><br><span class="line"><span class="comment">// 遍历链表找到每次反转的first,end 进行翻转</span></span><br><span class="line"><span class="comment">// *特别的：第一次翻转end是返回的头结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span> <span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode  pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode  f = head;</span><br><span class="line">        ListNode  e = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录翻转后链表第一个节点</span></span><br><span class="line">        ListNode firstNode = e;</span><br><span class="line">        <span class="keyword">while</span> (e!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 找到翻转段的尾节点e</span></span><br><span class="line">            <span class="keyword">if</span>(count % k == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 第一次翻转</span></span><br><span class="line">                <span class="keyword">if</span>(count == k)</span><br><span class="line">                    firstNode = e;</span><br><span class="line">                <span class="comment">// 翻转</span></span><br><span class="line">                reverse(pre,f,e);</span><br><span class="line">                <span class="comment">// *更新:注意此时段尾部是f</span></span><br><span class="line">                <span class="comment">// *尾部e移动了，要count+1</span></span><br><span class="line">                pre = f;</span><br><span class="line">                f = e = f.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            <span class="comment">// 无论哪种情况都要count++，所以移到这儿</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  firstNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指定链表段翻转</span></span><br><span class="line">    <span class="comment">// 先将[first-end] 节点反转，再修改反转后的首尾节点指向</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode pre,ListNode first,ListNode end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode p = <span class="keyword">null</span>;</span><br><span class="line">        ListNode q = first;</span><br><span class="line">        ListNode q_next = <span class="keyword">null</span>; <span class="comment">// 临时节点存储q.next</span></span><br><span class="line">        <span class="keyword">while</span> (p !=end )  <span class="comment">// 修改：到达末尾终止条件</span></span><br><span class="line">        &#123;</span><br><span class="line">            q_next = q.next;</span><br><span class="line">            q.next = p;</span><br><span class="line">            p = q;</span><br><span class="line">            q = q_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改：处理反转后的首尾节点指向</span></span><br><span class="line">        first.next = q;</span><br><span class="line">        <span class="comment">// 【边界情况】：从头节点开始反转</span></span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="keyword">null</span>)</span><br><span class="line">            pre.next=end;</span><br><span class="line">        <span class="comment">// *返回翻转后链表首节点end</span></span><br><span class="line">         <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC3-环入口节点"><a href="#NC3-环入口节点" class="headerlink" title="NC3: 环入口节点"></a>NC3: 环入口节点</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6e630519bf86480296d0f1c868d425ad?tpId=190&tqId=35178&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/10/b2irHchNK9jZJoM.png" alt="image-20210410182140532"></p>
</li>
<li><p>解法思路</p>
<p>数学题，题解见下：</p>
<p><img src="https://i.loli.net/2021/04/10/iFLndDrVtSh8pbA.png" alt="image-20210410230922390"></p>
</li>
<li><p>代码实现</p>
<p>套上<code>NC4：是否有环</code>的模板，补上后续操作判断即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">// *要先判断head==null的情况</span></span><br><span class="line">      <span class="keyword">if</span>(head==<span class="keyword">null</span>)  </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      ListNode step1 = head;</span><br><span class="line">      ListNode step2 = head;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">while</span>(step2!= <span class="keyword">null</span> &amp;&amp; step2.next != <span class="keyword">null</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 好像不会出现step1==null的情况？</span></span><br><span class="line">          <span class="comment">// 因为【如果有环】会在快指针走到终点前就相遇</span></span><br><span class="line">          step1 = step1.next;</span><br><span class="line">          <span class="comment">// 循环终止条件从这里得到</span></span><br><span class="line">          step2 = step2.next.next;</span><br><span class="line">          <span class="comment">// *在后面判断是否相遇</span></span><br><span class="line">          <span class="keyword">if</span>(step1==step2)</span><br><span class="line">          &#123; </span><br><span class="line">              <span class="comment">// 相遇,慢指针回到起点，快指针依旧在相遇点</span></span><br><span class="line">              step1 = head;</span><br><span class="line">              <span class="comment">// 快指针从相遇点，和慢指针从起始点，【一步一步走】再相遇</span></span><br><span class="line">              <span class="comment">// *相遇的地方就是环入口</span></span><br><span class="line">              <span class="keyword">while</span>(step1!=step2)</span><br><span class="line">              &#123;</span><br><span class="line">                 step1 = step1.next;</span><br><span class="line">                 step2 = step2.next;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> step1;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC53-删倒k个节点"><a href="#NC53-删倒k个节点" class="headerlink" title="NC53: 删倒k个节点"></a>NC53: 删倒k个节点</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/f95dcdafbde44b22a6d741baf71653f6?tpId=190&tqId=35195&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/10/Z43xnYbdBzsf1oH.png" alt="image-20210410233426263"></p>
</li>
<li><p>解法思路</p>
<p>简单，略。关键在于掌握两个【基础模板】：</p>
<ul>
<li>单链表删除节点</li>
<li>删除倒数第n个节点模板</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span> <span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="comment">// 边界条件判断</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.设置p,q指针分别指向首节点，pre指向p前一个节点</span></span><br><span class="line">        <span class="comment">// 2.q先走k步，然后p,q一起走，直至q指向null</span></span><br><span class="line">        <span class="comment">// 3.删除p</span></span><br><span class="line">        <span class="comment">// 3.返回head</span></span><br><span class="line">        </span><br><span class="line">        ListNode p = head, q = head;</span><br><span class="line">        ListNode p_pre = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> step = n; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(step&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q = q.next;</span><br><span class="line">                step--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p_pre = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                q = q.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除p</span></span><br><span class="line">        <span class="comment">// *当要删除的节点恰为头结点</span></span><br><span class="line">        <span class="keyword">if</span>(p==head)</span><br><span class="line">            head = head.next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p_pre.next = p.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC66-公共节点"><a href="#NC66-公共节点" class="headerlink" title="NC66: 公共节点"></a>NC66: 公共节点</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=190&tqId=35197&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="../AppData/Roaming/Typora/typora-user-images/image-20210412104727757.png" alt="image-20210412104727757"></p>
</li>
<li><p>解法思路</p>
<p>【方法一】首先容易想到暴力遍历：</p>
<ul>
<li>使用双循环，对链表1每个节点在链表2进行判断是否存在相同节点</li>
</ul>
<p>上述时间复杂度为<code>O(N^2)</code> ,  , 空间复杂度<code>O(1)</code>。</p>
<p>【方法二】对于判断链表2是否存在某个节点，可以用<code>hashmap</code> 存储所有链表2的节点，这样判断时间复杂度降为O(1)</p>
<ul>
<li>先<code>hashmap</code>存储所有链表2节点，遍历链表1每个节点，是否在链表2存在，如果存在则返回公共节点</li>
</ul>
<p>时间复杂度为<code>O(N)</code> , 空间复杂度<code>O(N)</code>。<u>如何继续优化空间复杂度？</u> </p>
<p><img src="../AppData/Roaming/Typora/typora-user-images/image-20210412111844484.png" alt="image-20210412111844484"></p>
<p>【方法三】观察公共链表特点：尾部相同，但前缀不同且长度也不同。</p>
<ul>
<li>如果知道前缀长度和相差的长度<code>k</code>， 那么可：让更长的链表工作指针<code>p</code>先走<code>k</code>步，然后和更短的链表工作指针<code>q</code>一起走，判断<strong>当前指向的节点相同就可以返回公共节点。</strong></li>
</ul>
<p><u>那么如何知道相差的长度<code>k</code> ？或者说如何让<code>p,q</code>距离公共节点长度一致？</u></p>
<p>双指针法。</p>
<ul>
<li>链表指针初始<code>p=head1,q=head2</code> 都同时往后走，当更短的指针（假设为<code>p</code>）指向<code>null</code> 时，更长链表工作指针<code>q</code>剩余<code>k</code> 步未走；</li>
<li>更新<code>p</code> 指向长链表头<code>head2 </code>，<code>p</code>和<code>q</code>继续往下走；</li>
<li>当<code>q</code>指向<code>null</code>时，<code>p</code>距离<code>head2</code>也走了<code>k</code>步 ，<code>q</code>指向<code>head1</code>；这样两个链表的工作指针距离公共节点的距离变保持一致了</li>
<li><code>p,q</code>同时往下走，判断遇到的第一个相同节点便是公共节点了</li>
</ul>
</li>
<li><p>代码实现</p>
<p>实现【方法三】。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode p1 = pHead1;</span><br><span class="line">    ListNode p2 = pHead2;</span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        p1 = p1 == <span class="keyword">null</span> ? pHead2 : p1.next;</span><br><span class="line">        p2 = p2 == <span class="keyword">null</span> ? pHead1 : p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC40-链表大数相加"><a href="#NC40-链表大数相加" class="headerlink" title="NC40: 链表大数相加"></a>NC40: 链表大数相加</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=190&tqId=35219&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/12/1VXROvCM57jpzal.png" alt="image-20210412151945766"></p>
</li>
<li><p>解法思路</p>
<p>思路类似<code>NC1</code> 大数相加，但是<u>不进行补0标准化</u>：</p>
<ol>
<li><p>先反转链表，从链表头部（低位开始相加），利用加法公式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算表达式</span></span><br><span class="line"><span class="keyword">int</span> res = a+b+carry;</span><br></pre></td></tr></table></figure></li>
<li><p>但是由于不进行标准化，长度不一致，在判断指针移动时要判断是否到末尾</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1 = p1==<span class="keyword">null</span>? <span class="keyword">null</span> : p1.next;</span><br><span class="line">p2 = p2==<span class="keyword">null</span>? <span class="keyword">null</span> : p2.next;</span><br></pre></td></tr></table></figure>

<p>同样的，获取计算表达式$a,b$ 值，也要进行判断指针位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = p1==<span class="keyword">null</span>? <span class="number">0</span> : p1.val;</span><br><span class="line">b = p2==<span class="keyword">null</span>? <span class="number">0</span> : p2.val;</span><br></pre></td></tr></table></figure></li>
<li><p>每次计算结果插入<u>头结点后面</u> ，返回最后的结果链表头结点</p>
</li>
</ol>
<p>【难点分析】</p>
<ul>
<li>记好<u>反转链表</u> 模板</li>
<li>记好<u>基本链表操作</u> ,如，插入</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.从低位开始相加，先高位补0转换为标准化【char[]数组】</span></span><br><span class="line">        <span class="comment">// 2.但由于长度不知，所以用【ArrayList】,并且不标准化（长度不一致）</span></span><br><span class="line">        <span class="comment">// 3.但是会引入额外的空间O(n)，不如直接反转链表，从低位开始相加</span></span><br><span class="line">        head1 = reverse(head1);</span><br><span class="line">        head2 = reverse(head2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 工作指针</span></span><br><span class="line">        ListNode p1 = head1, p2 = head2;</span><br><span class="line">        <span class="comment">// 结果链表</span></span><br><span class="line">        LinkList resList = <span class="keyword">new</span> LinkList();</span><br><span class="line">        <span class="keyword">int</span> a,b,carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="keyword">null</span> || p2 != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = p1==<span class="keyword">null</span>? <span class="number">0</span> : p1.val;</span><br><span class="line">            b = p2==<span class="keyword">null</span>? <span class="number">0</span> : p2.val;</span><br><span class="line">            <span class="comment">// 计算表达式</span></span><br><span class="line">            <span class="keyword">int</span> res = a+b+carry;</span><br><span class="line">            <span class="comment">// 插入新节点到头结点</span></span><br><span class="line">            resList.insert2head(<span class="keyword">new</span> ListNode(res%<span class="number">10</span>));</span><br><span class="line">            <span class="comment">// 更新进位</span></span><br><span class="line">            carry = res/<span class="number">10</span>; </span><br><span class="line">            <span class="comment">// 工作指针后移</span></span><br><span class="line">            p1 = p1==<span class="keyword">null</span>? <span class="keyword">null</span> : p1.next;</span><br><span class="line">            p2 = p2==<span class="keyword">null</span>? <span class="keyword">null</span> : p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最后还有进位</span></span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>)</span><br><span class="line">            resList.insert2head(<span class="keyword">new</span> ListNode(carry));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> resList.head.next;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 反转【指定】链表,链表没有头结点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode p = head , q=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q = p.next;</span><br><span class="line">            p.next = pre;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ListNode head; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkList</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入到【当前】头部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert2head</span><span class="params">(ListNode newNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode tmp = head.next;</span><br><span class="line">        head.next = newNode;</span><br><span class="line">        newNode.next = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC51-合并k个排序链表"><a href="#NC51-合并k个排序链表" class="headerlink" title="NC51:合并k个排序链表"></a>NC51:合并k个排序链表</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6?tpId=190&tqId=35193&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/13/M59XYTDvli3mNVe.png" alt="image-20210413152510801"></p>
</li>
<li><p>解法思路</p>
<p>关键在于套模板：</p>
<ul>
<li>【模板】合并两个排序链表</li>
</ul>
<p>易错点：</p>
<ul>
<li>合并头结点不记得，使用工作指针始终指向合并链表末尾（键代码）</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode res = lists.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ; i&lt;lists.size(); i++)</span><br><span class="line">            res = mergeList(res,lists.get(i));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeList</span><span class="params">(ListNode head1,ListNode head2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// *保留head，使用工作指针h</span></span><br><span class="line">        ListNode h = head; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head1.val&lt;head2.val)</span><br><span class="line">            &#123;</span><br><span class="line">                h.next = head1;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                h.next = head2;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// *指向合并链表末尾</span></span><br><span class="line">            h = h.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩下未排序完成的</span></span><br><span class="line">        <span class="keyword">if</span>(head1 != <span class="keyword">null</span>)</span><br><span class="line">            h.next = head1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            h.next = head2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC70-链表排序"><a href="#NC70-链表排序" class="headerlink" title="NC70:链表排序"></a>NC70:链表排序</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/f23604257af94d939848729b1a5cda08?tpId=190&tqId=35599&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/13/rIKUyLk4OHwJXDY.png" alt="image-20210413152658384"></p>
</li>
<li><p>解法思路</p>
<ul>
<li><p>模板：冒泡排序</p>
<p>:warning: 冒泡会超时，但是堆排序不会（后面更新代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortInList</span> <span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode p , q ;</span><br><span class="line">        ListNode  sort_first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(p=head; p.next!=<span class="keyword">null</span>; p = p.next ) <span class="comment">// n-1轮</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(q=head; q.next!=sort_first; q = q.next)<span class="comment">// n-已排序-1轮</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(q.val&gt;q.next.val)</span><br><span class="line">                    swap(q,q.next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 已排序的值放在链表之后，记录已排序的第一个节点</span></span><br><span class="line">            sort_first = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(ListNode node1, ListNode node2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = node1.val;</span><br><span class="line">        node1.val = node2.val;</span><br><span class="line">        node2.val = tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>模板：归并排序</p>
<blockquote>
<p><u>最佳选择：</u>保证了最好和最坏时间复杂度都是nlogn，而且它在数组排序中广受诟病的【合并链表时】**空间复杂度在链表排序中也从O(n)降到了O(1)**。</p>
</blockquote>
<ol>
<li><p>【快慢指针】找到链表中点，然后拆分成两个子链表</p>
<p><strong>:warning: 快慢指针注意判断条件！！</strong></p>
</li>
<li><p>【模板，合并有序链表】如果两个链表：<u>长度==1、null、有序</u>，则合并两个链表</p>
</li>
<li><p>【模板，归并】归并排序递归</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortInList</span> <span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="comment">// *考虑会出现其中一个子链表为空的情况</span></span><br><span class="line">         <span class="comment">//  为空或者长度=1，都可以返回进行合并</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)   </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拆分成两个子链表</span></span><br><span class="line">        ListNode h1 = head;</span><br><span class="line">        ListNode mid = getMid(head);</span><br><span class="line">        ListNode h2 = mid.next;</span><br><span class="line">        mid.next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归排序</span></span><br><span class="line">        <span class="comment">// *子链表排序后，其原先头结点不一定再是合并后头结点</span></span><br><span class="line">        <span class="comment">// *故要更新</span></span><br><span class="line">        h1 = sortInList(h1);</span><br><span class="line">        h2 = sortInList(h2);</span><br><span class="line">        <span class="comment">// 两个子链表都满足已排序，或者长度==1,null,则开始合并</span></span><br><span class="line">        <span class="keyword">return</span> mergeList(h1,h2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 快慢指针获取中点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> ListNode <span class="title">getMid</span> <span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         ListNode slow = head, fast = head;</span><br><span class="line">         <span class="comment">// *如果判断条件是fast!=null 或者 fast.next !=null</span></span><br><span class="line">         <span class="comment">// *等价于计算得到的中点向上取整，当链表长度=2时，1→2→null</span></span><br><span class="line">         <span class="comment">// *mid=2，由此切割的子链表是：1→2→null &amp; null ，不符合要求</span></span><br><span class="line">         <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next !=<span class="keyword">null</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             slow = slow.next;</span><br><span class="line">             fast = fast.next.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> slow;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">// 合并两个链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeList</span><span class="params">(ListNode head1,ListNode head2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// *保留head，使用工作指针h</span></span><br><span class="line">        ListNode h = head; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head1.val&lt;head2.val)</span><br><span class="line">            &#123;</span><br><span class="line">                h.next = head1;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                h.next = head2;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// *指向合并链表末尾</span></span><br><span class="line">            h = h.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩下未排序完成的</span></span><br><span class="line">        <span class="keyword">if</span>(head1 != <span class="keyword">null</span>)</span><br><span class="line">            h.next = head1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            h.next = head2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC96-是否回文"><a href="#NC96-是否回文" class="headerlink" title="NC96:是否回文"></a>NC96:是否回文</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/3fed228444e740c8be66232ce8b87c2f?tpId=190&tqId=35218&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/15/rSzuJlNys3h4ACx.png" alt="image-20210415121045459"></p>
</li>
<li><p>解法思路</p>
<ul>
<li><p>思路一：</p>
<p>1.栈/或者数组，保存节点，逆向比较</p>
<ol start="2">
<li>时空复杂度都是O(N)</li>
</ol>
</li>
<li><p>思路二：√（采用）</p>
<pre><code>      1. 快慢指针找到链表中点，翻转后面【一半】节点，比较
      2. 时间复杂度O(N),空间复杂度O(1)
</code></pre>
</li>
</ul>
<p>【<strong>难点：快慢指针</strong>】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>

<p>上面这种判断条件：</p>
<ul>
<li><p><strong>快慢指针返回的是左中位数</strong>：不知道奇/偶数个节点返回具体哪个位置</p>
<ul>
<li>如果是偶数，找到是左中位数，如：1→<strong>2</strong>→3→4→∅（节点2）</li>
<li>如果是奇数，就是中间节点，如：1→<strong>2</strong>→3→∅（节点2）</li>
</ul>
</li>
<li><p><strong>边界条件：</strong> 要保证head不为null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPail</span> <span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)  <span class="comment">// 一个数就是回文</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// （倾向左的）快慢指针找到中间节点</span></span><br><span class="line">        <span class="comment">// 如果是偶数，找到是左中位数，如：1→2→3→4→∅（节点2）</span></span><br><span class="line">        <span class="comment">// 如果是奇数，就是中间节点，如：1→2→3→∅（节点2）</span></span><br><span class="line">        ListNode mid = getMid(head);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 翻转节点</span></span><br><span class="line">        ListNode head2 = reverse(mid.next);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 比较是否是回文</span></span><br><span class="line">        <span class="keyword">while</span>(head2!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val != head2.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getMid</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 前面逻辑保证head不为null</span></span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(head.next==<span class="keyword">null</span>) <span class="comment">// 前面逻辑保证head不会为null</span></span><br><span class="line">             <span class="keyword">return</span> head;</span><br><span class="line">         <span class="comment">// 链表翻转模板</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode p = head, q = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q = p.next;</span><br><span class="line">            p.next = pre;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC21-区间翻转"><a href="#NC21-区间翻转" class="headerlink" title="NC21:区间翻转"></a>NC21:区间翻转</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=190&tqId=35184&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/15/FiqMCj5ghXPuKJ6.png" alt="image-20210415121204548"></p>
</li>
<li><p>解法思路</p>
<p>对于指定链表，如：1→2→3→4→5→∅，</p>
<ol>
<li><p>设置工作指针移动记录，翻转区间首节点<code>r1</code> ，和尾节点<code>r2</code> </p>
</li>
<li><p>根据翻转链表模板，<code>reverse(r1,r2)</code> 易将指定区间翻转为，∅←2←3←4，</p>
</li>
<li><p>现在要修改【模板：翻转链表】首尾节点指向：</p>
<ul>
<li><p>尾节点<code>r1</code> （2）指向（5）：由于<code>reverse(r1,r2)</code>模板可以获得翻转链表尾节点应该连接的下一个节点<code>q</code>（5），所以可以在<code>reverse</code>函数中直接修改尾节点指向</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r1.next = q; </span><br></pre></td></tr></table></figure></li>
<li><p>首节点<code>r2</code>（4）【被】（1）指向：由于节点（1）在翻转中没法获取，所以<u>还要在<strong>1.</strong> 中记录<code>r1</code> 前一个节点 <code>pre</code> 。</u></p>
<p>因此<code>reverse(pre,r1,r2)</code>增加一个参数<code>pre</code> 进行传递 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pre != <span class="keyword">null</span>) <span class="comment">// 从头节点开始翻转，前面无节点指向</span></span><br><span class="line">         pre.next = tail; <span class="comment">// 首节点【被】指向 </span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>返回：如果是从头结点开始翻转，返回翻转区间尾节点；否则返回头结点。</p>
</li>
</ol>
<p>【难点分析】</p>
<ul>
<li><strong>指定区间翻转不熟悉：</strong>修改首尾节点的操作应该 在<code>reverse</code>函数里，而不是在外面设置一堆节点记录边界，最后翻转后再来函数外修改。<u>定义变量多，且易错</u> </li>
<li><strong>套路不熟悉</strong> ：指定区间翻转的，通通（1）先获取 <u>翻转边界首尾节点</u> （2）再套翻转模板翻转（3）在翻转函数函数<strong>里面</strong>，修改翻转后首尾节点指向（4）考虑边界情况：<strong>从链表头部开始翻转</strong></li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span> <span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>; </span><br><span class="line">        <span class="comment">// 找到要反转的区间首尾节点r1,r2</span></span><br><span class="line">        <span class="comment">// 和首节点前一个节点r1_pre</span></span><br><span class="line">        ListNode p = head, pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode r1=p, r1_pre=pre;</span><br><span class="line">        ListNode r2;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count == m)</span><br><span class="line">            &#123;</span><br><span class="line">                r1_pre = pre;</span><br><span class="line">                r1 = p;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        r2 = pre;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 反转指定区间链表</span></span><br><span class="line">        <span class="comment">// *传参r1_pre方便在反转时【函数内部】修改链表首尾指向</span></span><br><span class="line">        ListNode reverse_head = reverse(r1_pre,r1,r2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(r1_pre == <span class="keyword">null</span>) <span class="comment">// 此时从头部就开始反转</span></span><br><span class="line">             <span class="keyword">return</span> reverse_head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// *翻转指定区间链表，除了首尾最好传参首节点前一个节点</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode pre_head ,ListNode head,ListNode tail)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 链表翻转模板</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode p = head, q = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pre!=tail)</span><br><span class="line">        &#123;</span><br><span class="line">            q = p.next;</span><br><span class="line">            p.next = pre;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// *处理首尾节点</span></span><br><span class="line">        head.next = q; <span class="comment">// 尾节点指向</span></span><br><span class="line">        <span class="keyword">if</span>(pre_head != <span class="keyword">null</span>)</span><br><span class="line">             pre_head.next = tail; <span class="comment">// 首节点【被】指向 </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC24-删除重复元素"><a href="#NC24-删除重复元素" class="headerlink" title="NC24:删除重复元素"></a>NC24:删除重复元素</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/71cef9f8b5564579bf7ed93fbe0b2024?tpId=190&tqId=35342&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/15/4avFOWUrPgXSieK.png" alt="image-20210415121426533"></p>
</li>
<li><p>解法思路</p>
<p>本题在【（模板）基础：删除重复元素】上进一步要求，第一次出现的重复数也要删除。因此我们可以在模板上进行修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span> <span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;     </span><br><span class="line">        ListNode pre = head, p = head.next; </span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.val == p.val)</span><br><span class="line">            &#123;</span><br><span class="line">                pre.next = p.next;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>设置一个指针指向pre前一个节点，和一个标记是否删除当前pre</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListNode pre = head, p = head.next; </span><br><span class="line">ListNode tmp = <span class="keyword">null</span>; <span class="comment">// 记录pre前的节点</span></span><br><span class="line"><span class="keyword">boolean</span> isDel = <span class="keyword">false</span>; </span><br></pre></td></tr></table></figure></li>
<li><p>【<strong>增加</strong>】每次<code>pre</code>即将移动时（<code>pre.val != p.val</code>）,即不存在和<code>pre</code>相同的数了，判断当前<code>pre</code>是否要删除。</p>
<p>如果存在过和<code>pre</code>相同的数那么就要删除它（<code>isDel==true</code>）。</p>
<p>:warning: 只有<code>pre</code>没有被删除时，才能更新<code>tmp</code>指向<code>pre</code> ；如果被删除，不修改指向（此时会将 <code>tmp.next = p</code>，此时<code>tmp</code>指向<code>p</code> ，而后面又更新了<code>pre</code>指向<code>p</code> ，那么<code>tmp</code>就是<code>pre</code>前一个节点）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="comment">// pre.val != p.val</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span>(isDel) <span class="comment">// pre移动到下一位时判断是否删除pre</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(pre==head) <span class="comment">// *删除头结点</span></span><br><span class="line">               head = head.next;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               tmp.next = p;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="comment">// *pre没删，tmp才更新</span></span><br><span class="line">      &#123;</span><br><span class="line">           tmp = pre;</span><br><span class="line">      &#125;</span><br><span class="line">      isDel = <span class="keyword">false</span>;</span><br><span class="line">                </span><br><span class="line">      pre = p;</span><br><span class="line">      p = p.next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>【<strong>增加</strong>】在<code>pre.val == p.val</code> 时我们也要增加判断一种边界情况：链表所有数值都相同，删除到最后一个节点时，如此时链表<code>1→∅</code> 。但此时<code>p</code> 指向<code>∅</code> ，不会进入下一次循环去判断删除<code>1</code> ，因此要进行边界判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pre.val == p.val)</span><br><span class="line">  &#123;</span><br><span class="line">       pre.next = p.next; <span class="comment">// 删除p</span></span><br><span class="line">       p = p.next;  </span><br><span class="line">       <span class="comment">// 存在和pre相同的元素，等删除完重复的，pre也要删</span></span><br><span class="line">       isDel = <span class="keyword">true</span>;  </span><br><span class="line">       <span class="keyword">if</span>(p==<span class="keyword">null</span>) <span class="comment">// *边界：p已指向null，但pre要删除</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(tmp!=<span class="keyword">null</span>) <span class="comment">// *边界：链表全相同，删除最后一个数</span></span><br><span class="line">                tmp.next = p;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span> <span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       </span><br><span class="line">       ListNode pre = head, p = head.next; </span><br><span class="line">       ListNode tmp = <span class="keyword">null</span>; <span class="comment">// 记录pre前的节点</span></span><br><span class="line">       <span class="keyword">boolean</span> isDel = <span class="keyword">false</span>; </span><br><span class="line">       <span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(pre.val == p.val)</span><br><span class="line">           &#123;</span><br><span class="line">               pre.next = p.next; <span class="comment">// 删除p</span></span><br><span class="line">               p = p.next;  </span><br><span class="line">               <span class="comment">// 存在和pre相同的元素，等删除完重复的，pre也要删</span></span><br><span class="line">               isDel = <span class="keyword">true</span>;  </span><br><span class="line">               <span class="keyword">if</span>(p==<span class="keyword">null</span>) <span class="comment">// *边界：p已指向null，但pre要删除</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span>(tmp!=<span class="keyword">null</span>) <span class="comment">// *边界：链表全相同，删除最后一个数</span></span><br><span class="line">                       tmp.next = p;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="comment">// pre.val == p.val</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(isDel) <span class="comment">// pre移动到下一位时判断是否删除pre</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span>(pre==head) <span class="comment">// 删除头结点</span></span><br><span class="line">                       head = head.next;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       tmp.next = p;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="comment">// *pre没删，tmp才更新</span></span><br><span class="line">               &#123;</span><br><span class="line">                   tmp = pre;</span><br><span class="line">               &#125;</span><br><span class="line">               isDel = <span class="keyword">false</span>;</span><br><span class="line">               </span><br><span class="line">               pre = p;</span><br><span class="line">               p = p.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC133-奇偶重排"><a href="#NC133-奇偶重排" class="headerlink" title="NC133:奇偶重排"></a>NC133:奇偶重排</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/02bf49ea45cd486daa031614f9bd6fc3?tpId=190&tqId=36037&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/04/16/fSKOtGPru8XUqh2.png" alt="image-20210416231147428"></p>
</li>
<li><p>解法思路</p>
<ul>
<li><p><strong>思路一（超时）</strong></p>
<ol>
<li>设置指针初始<code>Pre=head,q=head.next.next</code></li>
<li>使用临时节点tmp记录下一个待操作的节点<code>tmp=q.next.next</code>, 然后：<ul>
<li>删除节点<code>q</code> </li>
<li>插入到<code>Pre</code>后面</li>
</ul>
</li>
<li>更新<code>pre=q，q=tmp</code> </li>
<li>直至<code>tmp==null</code></li>
</ol>
</li>
<li><p><strong>思路二（通过）</strong></p>
<p>将奇数、偶数节点分别链接起来，然后将偶数节点串联在其后，具体：</p>
<ol>
<li>设置两个伪节点<code>evenHead</code> 、<code>oddHead</code> ，和两个工作指针：<code>even = evenHead, odd = evenHead;</code> ，以及一个工作指针<code>p=head</code></li>
<li>将<code>odd.next</code> 指向<code>p</code>（奇数节点）， <code>even.next</code> 指向<code>p.next</code>（偶数节点），并更新 <code>odd = p, even = p.next;</code></li>
<li>如果下一个奇数节点存在，即<code>p.next != null || p.next.next != null</code>  , 那么更新 <code>p = p.next.next</code> ，重复2、3，否则退出循环</li>
<li>最后将偶数链表放在奇数链表之后即可</li>
</ol>
</li>
</ul>
<p>【<strong>难点分析</strong>】</p>
<ul>
<li><p>想不到分别串联一个奇偶链表，再连接</p>
</li>
<li><p>设置伪节点有利于统一插入操作，也可以保证链表至少有两个节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span> || head.next.next==<span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure>

<p>然后让第一、二个节点分别为奇数、偶数链表的头结点。</p>
</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span> <span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode evenHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode oddHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode even = evenHead, odd = evenHead; </span><br><span class="line">        </span><br><span class="line">        ListNode p = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            odd = odd.next = p;</span><br><span class="line">            even = even.next = p.next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(p.next == <span class="keyword">null</span> || p.next.next == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = p.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将偶数链表链接在奇链表之后</span></span><br><span class="line">        <span class="comment">// *even此时指向可能为null</span></span><br><span class="line">        <span class="keyword">if</span>(even != <span class="keyword">null</span>)</span><br><span class="line">             even.next = <span class="keyword">null</span>;</span><br><span class="line">        odd.next = evenHead.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-5-动态规划"><a href="#1-5-动态规划" class="headerlink" title="1.5 动态规划"></a>1.5 动态规划</h3><h5 id="NC7-买股票"><a href="#NC7-买股票" class="headerlink" title="NC7: 买股票"></a>NC7: 买股票</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/64b4262d4e6d4f6181cd45446a5821ec?tpId=190&tqId=35181&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/18/849BUv6oA1YKpeu.png" alt="image-20210318131529621"></p>
</li>
<li><p>解法思路</p>
<p>因为是买股票，所以<u>买股票一定要在卖股票之前</u> ，包含时间序列，如果一次遍历找到最大最小求差是行不通的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> min=<span class="number">0</span>, max=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices[i]&lt;prices[min])</span><br><span class="line">          min = i;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(prices[i]&gt;prices[max])</span><br><span class="line">          max = i;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> prices[max]-prices[min];</span><br></pre></td></tr></table></figure>

<p>例如对于<code>case：num[2,4,1]</code> , 输出的<code>min=1，max=4</code>，而实际买入的利润是-3。</p>
<p>为此我们可以采用动态规划的思想，遍历数组prices，寻找前[0,i]中最大利润：</p>
<ul>
<li>记录前[0,i-1] 中股票最低值信息minValue，和最大利润maxProfit</li>
<li>第[i]个元素减去前[0,i-1] 中minValue，如果&gt;maxProfit, 更新maxProfit。从而获取前[0,i]中最大利润</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span> <span class="params">(<span class="keyword">int</span>[] prices)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 寻找数组中最大、最小数字</span></span><br><span class="line">        <span class="keyword">int</span> minValue=prices[<span class="number">0</span>], maxProfit=<span class="number">0</span>,currentProfit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 更新最大利润</span></span><br><span class="line">            currentProfit = prices[i]-minValue;</span><br><span class="line">            maxProfit =  currentProfit &gt; maxProfit?                                                          currentProfit:maxProfit;</span><br><span class="line">            <span class="comment">// 更新数组前[0,i-1]中最小值</span></span><br><span class="line">            minValue = prices[i]&lt;minValue?prices[i]:minValue;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="NC59：不同路径"><a href="#NC59：不同路径" class="headerlink" title="NC59：不同路径"></a>NC59：不同路径</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7d21b6be4c6b429bb92d219341c4f8bb?tpId=190&tqId=35224&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/17/zhFMxRSJedAbnGy.png" alt="image-20210317222723457"></p>
</li>
<li><p>解法分析</p>
<p>参考动态规划例题：<u>不同路径II（二维dp）</u></p>
</li>
</ul>
<h5 id="NC19-最大累积和"><a href="#NC19-最大累积和" class="headerlink" title="NC19: 最大累积和"></a>NC19: 最大累积和</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/554aa508dd5d4fefbf0f86e5fe953abd?tpId=190&tqId=35386&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">题目描述</a></p>
<p><img src="https://i.loli.net/2021/03/26/hWUqvypr3e49diS.png" alt="image-20210326153749074"></p>
</li>
<li><p>解法思路</p>
<p>很明显是到动态规划题目，按照<u>动态规划方式进行解题可以大幅度降低思维负担</u> ：</p>
<blockquote>
<p>参考解析：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/cong-bao-li-po-jie-dao-dong-tai-gui-hua-yfvkp/">从暴力破解到动态规划</a> , 讲解得很清晰。</p>
</blockquote>
<ul>
<li><p><strong>状态定义：</strong><code>dp[i]</code>表示以<code>nums[i]</code> <u>结尾的所有子数组</u>（不是所有可能子数组）求和最大值。</p>
<p>例如<code>dp[3]</code> 表示$sum(0,3)、sum(1,3)、sum(2,3)、sum(3,3)$ 中最大值。所有<code>dp[i]</code> 包含所有可能的子数组，它们的最大值累和最大值。</p>
</li>
<li><p><strong>转移方程：</strong> 转移方程见下</p>
<p><img src="https://i.loli.net/2021/03/27/IcKLq4FMgYd1wos.png" alt="image-20210327211827314"></p>
<p>以<code>dp[3]</code>为例，<strong>找寻$sum(0,3)、sum(1,3)、sum(2,3)、sum(3,3)$中最大值</strong> ，由于都包含了$nums[3]$, **等价于找寻$0,sum(0,2)、sum(1,2)、sum(2,2)$中最大值再+$nums[3]$**。而$0,sum(0,2)、sum(1,2)、sum(2,2)$ 最大值 == <code>dp[2]</code> 。</p>
<p>但特别的，单个元素也可以作为一个子数组，当<code>dp[2]&lt;0</code> , <code>dp[3]==nums[3]</code> 更大。</p>
<p><img src="https://i.loli.net/2021/03/27/t1loOTrGeFWjPqx.png" alt="image.png"></p>
</li>
<li><p><strong>初始状态：</strong> $j-1&gt;0$, 循环从1开始，那么<code>dp[0]=nums[0]</code>需已知</p>
</li>
<li><p><strong>返回值：</strong>返回数组dp中最大值</p>
</li>
</ul>
<p><strong>优化空间为O(1) ?</strong></p>
<ul>
<li>由于给定数组<code>nums</code> 在下次循环i+1时，前i个元素都不会使用，可以作为使用空间。</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxsumofSubarray</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 初始状态</span></span><br><span class="line">        <span class="comment">// 使用arr空间作为dp空间，初始化不用进行</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 状态方程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i-<span class="number">1</span>]&gt;<span class="number">0</span>)</span><br><span class="line">                arr[i]=arr[i-<span class="number">1</span>]+arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找寻到最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;max)</span><br><span class="line">                max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-6-树"><a href="#1-6-树" class="headerlink" title="1.6 树"></a>1.6 树</h3><h2 id="二、数据库"><a href="#二、数据库" class="headerlink" title="二、数据库"></a>二、数据库</h2><h3 id="2-1-入门开胃菜"><a href="#2-1-入门开胃菜" class="headerlink" title="2.1 入门开胃菜"></a>2.1 入门开胃菜</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013134432/article/details/103033002?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242">经典面试题型</a> </p>
</blockquote>
<h5 id="最晚入职员工"><a href="#最晚入职员工" class="headerlink" title="最晚入职员工"></a>最晚入职员工</h5><ul>
<li><p>题目</p>
<p><img src="https://i.loli.net/2021/04/21/lWb4gnuHa1yq6Go.png" alt="img"></p>
</li>
<li><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* 使用limit关键字 从第0条记录 向后读取1个， */</span><br><span class="line"></span><br><span class="line">select * from employees</span><br><span class="line">    order by hire_date desc</span><br><span class="line">    LIMIT 1 offset 0;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="入职倒数第三"><a href="#入职倒数第三" class="headerlink" title="入职倒数第三"></a>入职倒数第三</h5><ul>
<li><p>题目</p>
<p><img src="https://i.loli.net/2021/04/21/lWb4gnuHa1yq6Go.png" alt="img"></p>
</li>
<li><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from employees</span><br><span class="line">    order by hire_date desc</span><br><span class="line">    LIMIT 1 offset 2;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="查看部门薪水"><a href="#查看部门薪水" class="headerlink" title="查看部门薪水"></a>查看部门薪水</h5><ul>
<li><p>题目</p>
<blockquote>
<p>请你查找各个部门领导薪水详情以及其对应部门编号dept_no，输出结果以salaries.emp_no升序排序，并且请注意输出结果里面dept_no列是最后一列。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210205/557336_1612509718797/4AD4F3D1E977477D6DF98854EC10149D" alt="img"></p>
</blockquote>
<p>全部员工的薪水表salaries:</p>
<p><img src="https://i.loli.net/2021/04/21/pN5GRbMrafY9Ced.png" alt="img"></p>
<p>各个部门的领导表dept_manager: </p>
<p><img src="https://i.loli.net/2021/04/21/Bwx2ZEaYSkguLQ4.png" alt="img"></p>
</li>
<li><p>代码</p>
<p>纯where连接两张表进行查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*纯where连接两张表*/</span><br><span class="line">select s.* , d.dept_no</span><br><span class="line">from dept_manager  d, salaries  s</span><br><span class="line">where d.emp_no = s.emp_no </span><br><span class="line">and   d.to_date = &#x27;9999-01-01&#x27;</span><br><span class="line">order by s.emp_no ASC;  /*默认升序ASC*/</span><br></pre></td></tr></table></figure>

<p>使用内连接进行查询：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/plg17/article/details/78758593">内外连接很清晰的一篇文章</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select s.* , d.dept_no</span><br><span class="line">from dept_manager as d inner join salaries as s</span><br><span class="line">on d.emp_no = s.emp_no </span><br><span class="line">where d.to_date = &#x27;9999-01-01&#x27;  /*保证没离职*/</span><br><span class="line">order by s.emp_no ASC;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="查看员工信息"><a href="#查看员工信息" class="headerlink" title="查看员工信息"></a>查看员工信息</h5><ul>
<li><p>题目</p>
<blockquote>
<p>请你查找所有已经分配部门的员工的last_name和first_name以及dept_no：</p>
<ol>
<li>分别写出查询语句查询：【显示/不显示】未分配的部门的员工；</li>
<li>获取所有非manager的员工的emp_no</li>
</ol>
</blockquote>
<p>员工表，employees：</p>
<p><img src="https://i.loli.net/2021/04/21/ok1rHtvduleEqB4.png" alt="img"></p>
<p>部门表，dept_emp：</p>
<p><img src="https://i.loli.net/2021/04/21/6T3qstIXCyvH8zk.png" alt="img"></p>
</li>
<li><p>代码</p>
<p>不包括未分配员工：使用内连接去二者交集即可。</p>
<p><img src="https://i.loli.net/2021/04/21/RLkWchlZTMdOybK.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select e.last_name , e.first_name, d.dept_no</span><br><span class="line">from dept_emp as d inner join employees as e</span><br><span class="line">on e.emp_no = d.emp_no;</span><br></pre></td></tr></table></figure>

<p>包括未分配的员工，使用外连接即可。使用左连接，以员工表为主表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select e.last_name , e.first_name, d.dept_no</span><br><span class="line">from employees as e left join dept_emp as d </span><br><span class="line">on e.emp_no = d.emp_no;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取所有非manager的员工的emp_no 。</p>
</blockquote>
<p>一、使用<strong>NOT IN</strong> 子句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select emp_no</span><br><span class="line">from employees</span><br><span class="line">where emp_no not in (select emp_no from dept_manager);</span><br></pre></td></tr></table></figure>

<p>二、LEFT JOIN左连接+<strong>IS NUL</strong>L</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.emp_no</span><br><span class="line">FROM employees AS e LEFT JOIN dept_manager AS d</span><br><span class="line">ON e.emp_no=d.emp_no</span><br><span class="line">WHERE dept_no IS NULL;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​        </p>
<h5 id="统计薪水涨幅"><a href="#统计薪水涨幅" class="headerlink" title="统计薪水涨幅"></a>统计薪水涨幅</h5><ul>
<li><p>题目</p>
<blockquote>
<p>请你查找薪水记录超过15次的员工号emp_no以及其对应的记录次数t。</p>
</blockquote>
<p>薪水表，salaries：</p>
<p><img src="https://i.loli.net/2021/04/21/gIY4bGwmBOPhrDU.png" alt="img"></p>
<p>题目隐含：</p>
<ol>
<li>一条记录就算一次涨幅(严格意义上，从第二条记录算起才算一次涨幅)</li>
<li>任何一条记录都算一次涨幅(严格意义上，必须比上一条记录的工资高才算一次涨幅)</li>
</ol>
</li>
<li><p>代码</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/mysql/mysql-group-by-statement.html">MySQL GROUP BY 语句</a></p>
<p>GROUP BY 语句根据 <u>一个或多个列</u> 对结果集进行分组。在<strong>分组的列</strong>上我们可以使用 COUNT, SUM, AVG,等函数。</p>
</blockquote>
<p>统计结果要进行判断，必须使用<code>having</code> 而不是 <code>where</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select emp_no , count(emp_no) t</span><br><span class="line">from salaries </span><br><span class="line">group by emp_no</span><br><span class="line">having t&gt;15;   /*必须用having*/</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="薪水显示去重"><a href="#薪水显示去重" class="headerlink" title="薪水显示去重"></a>薪水显示去重</h5><ul>
<li><p>题目</p>
<blockquote>
<p>你找出所有员工具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示。</p>
</blockquote>
<p>薪水表，salaries：</p>
<p><img src="https://i.loli.net/2021/04/21/msFr4tGo5cJ9n8q.png" alt="img"></p>
</li>
<li><p>代码</p>
<p>一、可以用distinct函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select <span class="title">distinct</span><span class="params">(salary)</span></span></span><br><span class="line"><span class="function">from salaries</span></span><br><span class="line"><span class="function">where  to_date</span>=<span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line">order by salary desc;</span><br></pre></td></tr></table></figure>

<p>二、使用group by （推荐，性能更高）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select salary</span><br><span class="line">from salaries </span><br><span class="line">where  to_date=&#x27;9999-01-01&#x27;</span><br><span class="line">group by salary   /*分组一定要在where语句后面！*/</span><br><span class="line">order by salary desc; /*排序最后面*/</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-经典题目"><a href="#2-2-经典题目" class="headerlink" title="2.2 经典题目"></a>2.2 经典题目</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><ul>
<li>学生表：<code>Student(SId,Sname,Sage,Ssex)</code></li>
<li>课程表：<code>Course(CId,Cname,TId)</code></li>
<li>教师表：<code>Teacher(TId,Tname)</code></li>
<li>成绩表：<code>SC(SId,CId,score)</code></li>
</ul>
<h4 id="经典50题"><a href="#经典50题" class="headerlink" title="经典50题"></a>经典50题</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32137597">https://zhuanlan.zhihu.com/p/32137597</a></p>
<h5 id="1-查询”-01-“课程比”-02-“课程成绩高的学生的信息及课程分数"><a href="#1-查询”-01-“课程比”-02-“课程成绩高的学生的信息及课程分数" class="headerlink" title="1. 查询” 01 “课程比” 02 “课程成绩高的学生的信息及课程分数"></a>1. 查询” 01 “课程比” 02 “课程成绩高的学生的信息及课程分数</h5><ol>
<li><p>先分别得到只有01课程和02课程两张成绩子表：<code>sc1 (SID,score1)</code> , <code>sc2 (SID,score2)</code>  </p>
</li>
<li><p>通过**<u>自然连接</u>**，构建一张01,02课程成绩在同一行的表，<code>sc12(SID,score1,score2)</code> ，并 <code>sc1.score&gt;sc2.score</code></p>
<blockquote>
<p>因为有学生不是01，02都选，导致出现score1或 score2 为null的情况？</p>
<ul>
<li><strong>自然连接</strong>，0，只有该SID都有分数才会保留</li>
<li>内连接和交叉连接，才会保留所有结果（笛卡尔积）</li>
<li>外连接才会导致，某个分数score出现null，没匹配到SID但还是保留</li>
</ul>
</blockquote>
</li>
<li><p>再联合Student表，根据SID找到对应学生信息（只要SID，不要name等可以省略这步，<u>下面就省略了这步</u>）</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Select * </span><br><span class="line">from (select SId ,score from sc where sc.CId=&#x27;01&#x27;)as sc1 , (select SId ,score from sc where sc.CId=&#x27;02&#x27;) as sc2</span><br><span class="line">where sc1.SId=sc2.SId</span><br><span class="line">and   sc1.score&gt;sc2.score</span><br></pre></td></tr></table></figure>

<h6 id="1-1-查询同时选了”-01-“课程和”-02-“课程的学生SID"><a href="#1-1-查询同时选了”-01-“课程和”-02-“课程的学生SID" class="headerlink" title="1.1  查询同时选了” 01 “课程和” 02 “课程的学生SID"></a>1.1  查询同时选了” 01 “课程和” 02 “课程的学生SID</h6><p>自然连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from (select SId ,score from sc where sc.CId=&#x27;01&#x27;)as t1 , (select SId ,score from sc where sc.CId=&#x27;02&#x27;) as t2</span><br><span class="line">where t1.SId=t2.SId</span><br></pre></td></tr></table></figure>

<h6 id="1-2-查询选了”-01-“课程但可能不存在”-02-“课程的情况-不存在时显示为-null"><a href="#1-2-查询选了”-01-“课程但可能不存在”-02-“课程的情况-不存在时显示为-null" class="headerlink" title="1.2  查询选了” 01 “课程但可能不存在” 02 “课程的情况(不存在时显示为 null )"></a>1.2  查询选了” 01 “课程但可能不存在” 02 “课程的情况(不存在时显示为 null )</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="1-3-查询选了”-01-“课程但没选”-02-“课程的情况"><a href="#1-3-查询选了”-01-“课程但没选”-02-“课程的情况" class="headerlink" title="1.3 查询选了” 01 “课程但没选” 02 “课程的情况"></a>1.3 查询选了” 01 “课程但没选” 02 “课程的情况</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from sc</span><br><span class="line">where sc.SId not in (select SId from sc where sc.CId=&#x27;01&#x27;)</span><br><span class="line">and  sc.CId=&#x27;02&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="2-查询平均成绩大于等于-60-分的同学的学生编号和学生姓名和平均成绩"><a href="#2-查询平均成绩大于等于-60-分的同学的学生编号和学生姓名和平均成绩" class="headerlink" title="2. 查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩"></a><strong>2. 查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩</strong></h5><ol>
<li>先得到一张平均成绩表<code>(SID,AvgScore)</code></li>
<li>再根据平均成绩表SID，找到<code>Student</code> 表中信息，这里联合两张表可以采用左外连接</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Select s.SID,s.Sname,   </span><br><span class="line">From Student as s left join </span><br><span class="line">（</span><br><span class="line">   Select SC.SID , AVG(SC.score) as avgscore</span><br><span class="line">   From SC </span><br><span class="line">   Group by(SC.SID ) </span><br><span class="line">   Having AVG(sc.score) &gt;= 60 # 集合函数时不能使用where</span><br><span class="line"> ）as avgTable</span><br><span class="line"> ON s.SID = avgTable.SID # 外连接用ON, 不是Where连接</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Wanghui Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/11/25/%E5%B7%A5%E4%BD%9C%E4%B8%80_%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">http://example.com/2021/11/25/%E5%B7%A5%E4%BD%9C%E4%B8%80_%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatPay.png" target="_blank"><img class="post-qr-code-img" src="/img/wechatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/11/24/test/"><img class="next-cover" src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info"></div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wanghui Huang</div><div class="author-info__description">tech & life</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wanghui-Huang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hwh199601@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">royHuang's studio</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TO-DO"><span class="toc-number">1.1.</span> <span class="toc-text">TO  DO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%BE%E7%9A%AE%E4%B8%93%E5%9C%BA"><span class="toc-number">2.</span> <span class="toc-text">虾皮专场</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">2.1.</span> <span class="toc-text">1. 栈实现队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-LRUCache"><span class="toc-number">2.2.</span> <span class="toc-text">2. LRUCache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">3. 相交链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6"><span class="toc-number">2.4.</span> <span class="toc-text">4. 有序链表合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">2.5.</span> <span class="toc-text">5. 反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">2.6.</span> <span class="toc-text">6. 两数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">2.7.</span> <span class="toc-text">7. k个一组翻转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">2.8.</span> <span class="toc-text">8. 二叉树最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-number">2.9.</span> <span class="toc-text">9. 删除链表重复元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%9C%80%E5%A4%A7%E6%95%B0"><span class="toc-number">2.10.</span> <span class="toc-text">10. 最大数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">2.11.</span> <span class="toc-text">11. 二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2"><span class="toc-number">2.12.</span> <span class="toc-text">12. 最长不重复子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II"><span class="toc-number">2.13.</span> <span class="toc-text">13. 两数相加II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">2.14.</span> <span class="toc-text">14. 三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-next%E6%A0%91%EF%BC%88%E7%A9%BA%E9%97%B4O-1-%EF%BC%89"><span class="toc-number">2.15.</span> <span class="toc-text">15. next树（空间O(1)）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F2"><span class="toc-number">2.16.</span> <span class="toc-text">16. 跳跃游戏2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-number">2.17.</span> <span class="toc-text">17. 二叉树所有路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8E%E4%B8%BA%E4%B8%93%E5%9C%BA"><span class="toc-number">3.</span> <span class="toc-text">华为专场</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">一、算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">1.1 基本算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">数组排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE"><span class="toc-number">4.1.2.</span> <span class="toc-text">数组查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-number">4.1.3.</span> <span class="toc-text">树遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">4.1.4.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.5.</span> <span class="toc-text">链表操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%95%B0%E7%BB%84"><span class="toc-number">4.2.</span> <span class="toc-text">1.2 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%90%E7%9C%8B%E3%80%91NC61-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">【看】NC61: 两数之和</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC22-%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84"><span class="toc-number">4.2.0.2.</span> <span class="toc-text">NC22: 合并数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC38-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-number">4.2.0.3.</span> <span class="toc-text">NC38: 螺旋矩阵</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC12-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.2.0.4.</span> <span class="toc-text">NC12: 重建二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC65-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91"><span class="toc-number">4.2.0.5.</span> <span class="toc-text">NC65: 斐波那契</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC48-%E5%8A%A8%E6%95%B0%E7%BB%84%E6%89%BE%E5%80%BC"><span class="toc-number">4.2.0.6.</span> <span class="toc-text">NC48: 动数组找值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC54-3sum"><span class="toc-number">4.2.0.7.</span> <span class="toc-text">NC54: 3sum</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC73-%E4%B8%80%E5%8D%8A%E6%95%B0%E5%AD%97"><span class="toc-number">4.2.0.8.</span> <span class="toc-text">NC73:一半数字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC36-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">4.2.0.9.</span> <span class="toc-text">NC36: 数组中位数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC30-%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B0"><span class="toc-number">4.2.0.10.</span> <span class="toc-text">NC30: 最小正数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%90%E7%9C%8B%E3%80%91NC119-%E6%9C%80%E5%B0%8Fk%E4%B8%AA%E6%95%B0"><span class="toc-number">4.2.0.11.</span> <span class="toc-text">【看】NC119:最小k个数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC88-%E7%AC%ACK%E5%A4%A7"><span class="toc-number">4.2.0.12.</span> <span class="toc-text">NC88: 第K大</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC105-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA"><span class="toc-number">4.2.0.13.</span> <span class="toc-text">NC105: 二分查找第一个</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC91-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">4.2.0.14.</span> <span class="toc-text">NC91: 最长递增子序列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC32-%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="toc-number">4.2.0.15.</span> <span class="toc-text">NC32: 求平方根</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC37-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">4.2.0.16.</span> <span class="toc-text">NC37: 合并区间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC41-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2"><span class="toc-number">4.2.0.17.</span> <span class="toc-text">NC41: 无重复子串</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.3.</span> <span class="toc-text">1.3 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#NC1-%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">NC1: 大数相加</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC127-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2"><span class="toc-number">4.3.0.2.</span> <span class="toc-text">NC127: 最长公共子串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC41-%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D"><span class="toc-number">4.3.0.3.</span> <span class="toc-text">NC41: 最长不重复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC52-%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97"><span class="toc-number">4.3.0.4.</span> <span class="toc-text">NC52: 括号序列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC103-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.3.0.5.</span> <span class="toc-text">NC103: 反转字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC41-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88"><span class="toc-number">4.3.0.6.</span> <span class="toc-text">NC41: 字符串排列组合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC17-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">4.3.0.7.</span> <span class="toc-text">NC17: 最长回文子串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC49-%E6%9C%80%E9%95%BF%E6%8B%AC%E5%8F%B7%E5%AD%90%E4%B8%B2"><span class="toc-number">4.3.0.8.</span> <span class="toc-text">NC49: 最长括号子串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC41-%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D-1"><span class="toc-number">4.3.0.9.</span> <span class="toc-text">NC41: 最长不重复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC41-%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D-2"><span class="toc-number">4.3.0.10.</span> <span class="toc-text">NC41: 最长不重复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC41-%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D-3"><span class="toc-number">4.3.0.11.</span> <span class="toc-text">NC41: 最长不重复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">4.3.0.12.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">4.3.0.13.</span> <span class="toc-text">字符串第一个不重复的数字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-number">4.3.0.14.</span> <span class="toc-text">十进制转二进制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.0.15.</span> <span class="toc-text">微信抢红包算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E9%93%BE%E8%A1%A8%E5%92%8C%E6%A0%88"><span class="toc-number">4.4.</span> <span class="toc-text">1.4 链表和栈</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#NC78-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">4.4.0.1.</span> <span class="toc-text">NC78: 反转链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC93-LRU"><span class="toc-number">4.4.0.2.</span> <span class="toc-text">NC93: LRU</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC4-%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF"><span class="toc-number">4.4.0.3.</span> <span class="toc-text">NC4: 是否有环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC33-%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8"><span class="toc-number">4.4.0.4.</span> <span class="toc-text">NC33:合并链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC76-%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">4.4.0.5.</span> <span class="toc-text">NC76: 栈实现队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC50-%E9%93%BE%E8%A1%A8k%E7%BF%BB%E8%BD%AC"><span class="toc-number">4.4.0.6.</span> <span class="toc-text">NC50: 链表k翻转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC3-%E7%8E%AF%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9"><span class="toc-number">4.4.0.7.</span> <span class="toc-text">NC3: 环入口节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC53-%E5%88%A0%E5%80%92k%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">4.4.0.8.</span> <span class="toc-text">NC53: 删倒k个节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC66-%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="toc-number">4.4.0.9.</span> <span class="toc-text">NC66: 公共节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC40-%E9%93%BE%E8%A1%A8%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-number">4.4.0.10.</span> <span class="toc-text">NC40: 链表大数相加</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC51-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">4.4.0.11.</span> <span class="toc-text">NC51:合并k个排序链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC70-%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">4.4.0.12.</span> <span class="toc-text">NC70:链表排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC96-%E6%98%AF%E5%90%A6%E5%9B%9E%E6%96%87"><span class="toc-number">4.4.0.13.</span> <span class="toc-text">NC96:是否回文</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC21-%E5%8C%BA%E9%97%B4%E7%BF%BB%E8%BD%AC"><span class="toc-number">4.4.0.14.</span> <span class="toc-text">NC21:区间翻转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC24-%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-number">4.4.0.15.</span> <span class="toc-text">NC24:删除重复元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC133-%E5%A5%87%E5%81%B6%E9%87%8D%E6%8E%92"><span class="toc-number">4.4.0.16.</span> <span class="toc-text">NC133:奇偶重排</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">4.5.</span> <span class="toc-text">1.5 动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#NC7-%E4%B9%B0%E8%82%A1%E7%A5%A8"><span class="toc-number">4.5.0.1.</span> <span class="toc-text">NC7: 买股票</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC59%EF%BC%9A%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">4.5.0.2.</span> <span class="toc-text">NC59：不同路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NC19-%E6%9C%80%E5%A4%A7%E7%B4%AF%E7%A7%AF%E5%92%8C"><span class="toc-number">4.5.0.3.</span> <span class="toc-text">NC19: 最大累积和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E6%A0%91"><span class="toc-number">4.6.</span> <span class="toc-text">1.6 树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">5.</span> <span class="toc-text">二、数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%85%A5%E9%97%A8%E5%BC%80%E8%83%83%E8%8F%9C"><span class="toc-number">5.1.</span> <span class="toc-text">2.1 入门开胃菜</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E6%99%9A%E5%85%A5%E8%81%8C%E5%91%98%E5%B7%A5"><span class="toc-number">5.1.0.1.</span> <span class="toc-text">最晚入职员工</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A5%E8%81%8C%E5%80%92%E6%95%B0%E7%AC%AC%E4%B8%89"><span class="toc-number">5.1.0.2.</span> <span class="toc-text">入职倒数第三</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%83%A8%E9%97%A8%E8%96%AA%E6%B0%B4"><span class="toc-number">5.1.0.3.</span> <span class="toc-text">查看部门薪水</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%91%98%E5%B7%A5%E4%BF%A1%E6%81%AF"><span class="toc-number">5.1.0.4.</span> <span class="toc-text">查看员工信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E8%96%AA%E6%B0%B4%E6%B6%A8%E5%B9%85"><span class="toc-number">5.1.0.5.</span> <span class="toc-text">统计薪水涨幅</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%96%AA%E6%B0%B4%E6%98%BE%E7%A4%BA%E5%8E%BB%E9%87%8D"><span class="toc-number">5.1.0.6.</span> <span class="toc-text">薪水显示去重</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE"><span class="toc-number">5.2.</span> <span class="toc-text">2.2 经典题目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">5.2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B850%E9%A2%98"><span class="toc-number">5.2.2.</span> <span class="toc-text">经典50题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9F%A5%E8%AF%A2%E2%80%9D-01-%E2%80%9C%E8%AF%BE%E7%A8%8B%E6%AF%94%E2%80%9D-02-%E2%80%9C%E8%AF%BE%E7%A8%8B%E6%88%90%E7%BB%A9%E9%AB%98%E7%9A%84%E5%AD%A6%E7%94%9F%E7%9A%84%E4%BF%A1%E6%81%AF%E5%8F%8A%E8%AF%BE%E7%A8%8B%E5%88%86%E6%95%B0"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">1. 查询” 01 “课程比” 02 “课程成绩高的学生的信息及课程分数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-1-%E6%9F%A5%E8%AF%A2%E5%90%8C%E6%97%B6%E9%80%89%E4%BA%86%E2%80%9D-01-%E2%80%9C%E8%AF%BE%E7%A8%8B%E5%92%8C%E2%80%9D-02-%E2%80%9C%E8%AF%BE%E7%A8%8B%E7%9A%84%E5%AD%A6%E7%94%9FSID"><span class="toc-number">5.2.2.1.1.</span> <span class="toc-text">1.1  查询同时选了” 01 “课程和” 02 “课程的学生SID</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-%E6%9F%A5%E8%AF%A2%E9%80%89%E4%BA%86%E2%80%9D-01-%E2%80%9C%E8%AF%BE%E7%A8%8B%E4%BD%86%E5%8F%AF%E8%83%BD%E4%B8%8D%E5%AD%98%E5%9C%A8%E2%80%9D-02-%E2%80%9C%E8%AF%BE%E7%A8%8B%E7%9A%84%E6%83%85%E5%86%B5-%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6%E6%98%BE%E7%A4%BA%E4%B8%BA-null"><span class="toc-number">5.2.2.1.2.</span> <span class="toc-text">1.2  查询选了” 01 “课程但可能不存在” 02 “课程的情况(不存在时显示为 null )</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-3-%E6%9F%A5%E8%AF%A2%E9%80%89%E4%BA%86%E2%80%9D-01-%E2%80%9C%E8%AF%BE%E7%A8%8B%E4%BD%86%E6%B2%A1%E9%80%89%E2%80%9D-02-%E2%80%9C%E8%AF%BE%E7%A8%8B%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">5.2.2.1.3.</span> <span class="toc-text">1.3 查询选了” 01 “课程但没选” 02 “课程的情况</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%9F%A5%E8%AF%A2%E5%B9%B3%E5%9D%87%E6%88%90%E7%BB%A9%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E-60-%E5%88%86%E7%9A%84%E5%90%8C%E5%AD%A6%E7%9A%84%E5%AD%A6%E7%94%9F%E7%BC%96%E5%8F%B7%E5%92%8C%E5%AD%A6%E7%94%9F%E5%A7%93%E5%90%8D%E5%92%8C%E5%B9%B3%E5%9D%87%E6%88%90%E7%BB%A9"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">2. 查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/25/%E5%B7%A5%E4%BD%9C%E4%B8%80_%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="XXX">XXX</a><time datetime="2021-11-25T03:34:30.479Z" title="Created 2021-11-25 11:34:30">2021-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/24/test/" title="No title">No title</a><time datetime="2021-11-24T09:34:48.534Z" title="Created 2021-11-24 17:34:48">2021-11-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/24/test-my-site/" title="test_my_site">test_my_site</a><time datetime="2021-11-24T09:03:08.000Z" title="Created 2021-11-24 17:03:08">2021-11-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/24/hello-world/" title="Hello World">Hello World</a><time datetime="2021-11-24T09:00:02.998Z" title="Created 2021-11-24 17:00:02">2021-11-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Wanghui Huang</div><div class="footer_custom_text">Tencent Cloud</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="Increase font size"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="Decrease font size"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '7920b243397ba41b79a6',
      clientSecret: 'cf88800e73c283b2cc76bc3817304b6964982a47',
      repo: 'gittalk',
      owner: 'Wanghui-Huang',
      admin: ['Wanghui-Huang'],
      id: '665dfc6536cd8d0d592a4567d224b4aa',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: true,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>